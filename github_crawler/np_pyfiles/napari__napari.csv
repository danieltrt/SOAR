file_path,api_count,code
setup.py,0,"b'""""""\nPEP 517 doesn\xe2\x80\x99t support editable installs\nso this file is currently here to support ""pip install -e .""\n""""""\nfrom setuptools import setup\n\nsetup(\n    use_scm_version={""write_to"": ""napari/_version.py""},\n    setup_requires=[""setuptools_scm""],\n)\n'"
examples/3D_paths.py,2,"b'""""""\nDisplay two vectors layers ontop of a 4-D image layer. One of the vectors\nlayers is 3D and ""sliced"" with a different set of vectors appearing on\ndifferent 3D slices. Another is 2D and ""broadcast"" with the same vectors\napprearing on each slice.\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=0.05\n            )\n\n    viewer = napari.Viewer(ndisplay=3)\n    viewer.add_image(blobs.astype(float))\n\n    # sample vector coord-like data\n    path = np.array([np.array([[0, 0, 0], [0, 10, 10], [0, 5, 15], [20, 5, 15],\n        [56, 70, 21], [127, 127, 127]]),\n        np.array([[0, 0, 0], [0, 10, 10], [0, 5, 15], [0, 5, 15],\n            [0, 70, 21], [0, 127, 127]])])\n\n    print(\'Path\', path.shape)\n    layer = viewer.add_shapes(\n        path, shape_type=\'path\', edge_width=4, edge_color=[\'red\', \'blue\']\n    )\n'"
examples/add_grayscale_image.py,2,"b'""""""\nDisplay one grayscale image using the add_image API.\n""""""\n\nfrom skimage import data\nimport napari\nimport numpy as np\n\n\nwith napari.gui_qt():\n    # simulating a grayscale image here for testing contrast limits adjustments\n    image = data.astronaut().mean(-1) * 100 + 100\n    image += np.random.rand(*image.shape) * 3000\n    viewer = napari.view_image(image.astype(np.uint16))\n'"
examples/add_image.py,0,"b'""""""\nDisplay one image using the add_image API.\n""""""\n\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # create the viewer with an image\n    viewer = napari.view_image(data.astronaut(), rgb=True)\n'"
examples/add_labels.py,0,"b'""""""\nDisplay a labels layer above of an image layer using the add_labels and\nadd_image APIs\n""""""\n\nfrom skimage import data\nfrom skimage.filters import threshold_otsu\nfrom skimage.segmentation import clear_border\nfrom skimage.measure import label\nfrom skimage.morphology import closing, square, remove_small_objects\nimport napari\n\n\nwith napari.gui_qt():\n    image = data.coins()[50:-50, 50:-50]\n\n    # apply threshold\n    thresh = threshold_otsu(image)\n    bw = closing(image > thresh, square(4))\n\n    # remove artifacts connected to image border\n    cleared = remove_small_objects(clear_border(bw), 20)\n\n    # label image regions\n    label_image = label(cleared)\n\n    # initialise viewer with coins image\n    viewer = napari.view_image(image, name=\'coins\', rgb=False)\n\n    # add the labels\n    label_layer = viewer.add_labels(label_image, name=\'segmentation\')\n'"
examples/add_labels_with_properties.py,2,"b'""""""\nDisplay a labels layer with various properties\n""""""\n\n\nfrom skimage import data\nfrom skimage.filters import threshold_otsu\nfrom skimage.segmentation import clear_border\nfrom skimage.measure import label\nfrom skimage.morphology import closing, square, remove_small_objects\nimport numpy as np\nimport napari\n\n\nwith napari.gui_qt():\n    image = data.coins()[50:-50, 50:-50]\n\n    # apply threshold\n    thresh = threshold_otsu(image)\n    bw = closing(image > thresh, square(4))\n\n    # remove artifacts connected to image border\n    cleared = remove_small_objects(clear_border(bw), 20)\n\n    # label image regions\n    label_image = label(cleared)\n\n    # initialise viewer with coins image\n    viewer = napari.view_image(image, name=\'coins\', rgb=False)\n\n    # get the size of each coin (first element is background area)\n    label_areas = np.bincount(label_image.ravel())[1:]\n\n    # split coins into small or large\n    size_range = max(label_areas) - min(label_areas)\n    small_threshold = min(label_areas) + (size_range / 2)\n    coin_sizes = np.where(label_areas > small_threshold, \'large\', \'small\')\n\n    label_properties = {\n        \'row\': [\'none\']\n        + [\'top\'] * 4\n        + [\'bottom\'] * 4,  # background is row: none\n        \'size\': [\'none\'] + list(coin_sizes),  # background is size: none\n    }\n\n    # add the labels\n    label_layer = viewer.add_labels(\n        label_image, name=\'segmentation\', properties=label_properties\n    )\n'"
examples/add_multiscale_image.py,1,"b'""""""\nDisplays a multiscale image\n""""""\n\nfrom skimage import data\nfrom skimage.util import img_as_ubyte\nfrom skimage.color import rgb2gray\nfrom skimage.transform import pyramid_gaussian\nimport napari\nimport numpy as np\n\n\n# create multiscale from astronaut image\nbase = np.tile(data.astronaut(), (8, 8, 1))\nmultiscale = list(\n    pyramid_gaussian(base, downscale=2, max_layer=4, multichannel=True)\n)\nprint(\'multiscale level shapes: \', [p.shape[:2] for p in multiscale])\n\nwith napari.gui_qt():\n    # add image multiscale\n    napari.view_image(multiscale, multiscale=True)\n'"
examples/add_points.py,2,"b'""""""\nDisplay a points layer on top of an image layer using the add_points and\nadd_image APIs\n""""""\n\nimport numpy as np\nfrom skimage import data\nfrom skimage.color import rgb2gray\nimport napari\n\n\nwith napari.gui_qt():\n    # add the image\n    viewer = napari.view_image(rgb2gray(data.astronaut()))\n    # add the points\n    points = np.array([[100, 100], [200, 200], [333, 111]])\n    size = np.array([10, 20, 20])\n    viewer.add_points(points, size=size)\n\n    # unselect the image layer\n    viewer.layers[0].selected = False\n\n    # adjust some of the points layer properties\n    layer = viewer.layers[1]\n\n    # change the layer name\n    layer.name = \'points\'\n\n    # change the layer visibility\n    layer.visible = False\n    layer.visible = True\n\n    # change the layer selection\n    layer.selected = False\n    layer.selected = True\n\n    # change the layer opacity\n    layer.opacity = 0.9\n\n    # change the layer point symbol using an alias\n    layer.symbol = \'+\'\n\n    # change the layer point n_dimensional status\n    layer.n_dimensional = True\n\n    # change the layer mode\n    layer.mode = \'add\'\n\n'"
examples/add_points_with_properties.py,3,"b'""""""\nDisplay a points layer on top of an image layer using the add_points and\nadd_image APIs\n""""""\n\nimport numpy as np\nfrom skimage import data\nfrom skimage.color import rgb2gray\nimport napari\n\n\nwith napari.gui_qt():\n    # add the image\n    viewer = napari.view_image(rgb2gray(data.astronaut()))\n    # add the points\n    points = np.array([[100, 100], [200, 200], [333, 111]])\n\n    # create properties for each point\n    properties = {\n        \'confidence\': np.array([1, 0.5, 0]),\n        \'good_point\': np.array([True, False, False])\n    }\n\n    # define the color cycle for the face_color annotation\n    face_color_cycle = [\'blue\', \'green\']\n\n    # create a points layer where the face_color is set by the good_point property\n    # and the edge_color is set via a color map (grayscale) on the confidence property.\n    points_layer = viewer.add_points(\n        points,\n        properties=properties,\n        size=20,\n        edge_width=7,\n        edge_color=\'confidence\',\n        edge_colormap=\'gray\',\n        face_color=\'good_point\',\n        face_color_cycle=face_color_cycle\n    )\n\n    # set the edge_color mode to colormap\n    points_layer.edge_color_mode = \'colormap\'\n\n    # bind a function to toggle the good_point annotation of the selected points\n    @viewer.bind_key(\'t\')\n    def toggle_point_annotation(viewer):\n        selected_points = list(points_layer.selected_data)\n        if len(selected_points) > 0:\n            good_point = points_layer.properties[\'good_point\']\n            good_point[list(selected_points)] = ~good_point[list(selected_points)]\n            points_layer.properties[\'good_point\'] = good_point\n\n            # we need to manually refresh since we did not use the Points.properties setter\n            # to avoid changing the color map if all points get toggled to the same class,\n            # we set update_colors=False (only re-colors the point using the previously-determined color mapping).\n            points_layer.refresh_colors(update_color_mapping=False)\n'"
examples/add_shapes.py,4,"b'""""""\nDisplay one shapes layer ontop of one image layer using the add_shapes and\nadd_image APIs. When the window is closed it will print the coordinates of\nyour shapes.\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # add the image\n    viewer = napari.view_image(data.camera(), name=\'photographer\')\n\n    # create a list of polygons\n    polygons = [\n        np.array([[11, 13], [111, 113], [22, 246]]),\n        np.array(\n            [\n                [505, 60],\n                [402, 71],\n                [383, 42],\n                [251, 95],\n                [212, 59],\n                [131, 137],\n                [126, 187],\n                [191, 204],\n                [171, 248],\n                [211, 260],\n                [273, 243],\n                [264, 225],\n                [430, 173],\n                [512, 160],\n            ]\n        ),\n        np.array(\n            [\n                [310, 382],\n                [229, 381],\n                [209, 401],\n                [221, 411],\n                [258, 411],\n                [300, 412],\n                [306, 435],\n                [268, 434],\n                [265, 454],\n                [298, 461],\n                [307, 461],\n                [307, 507],\n                [349, 510],\n                [352, 369],\n                [330, 366],\n                [330, 366],\n            ]\n        ),\n    ]\n\n    # add polygons\n    layer = viewer.add_shapes(\n        polygons,\n        shape_type=\'polygon\',\n        edge_width=1,\n        edge_color=\'coral\',\n        face_color=\'royalblue\',\n        name=\'shapes\',\n    )\n\n    # change some properties of the layer\n    layer.selected_data = set(range(layer.nshapes))\n    layer.current_edge_width = 5\n    layer.selected_data = set()\n\n    # add an ellipse to the layer\n    ellipse = np.array([[59, 222], [110, 289], [170, 243], [119, 176]])\n    layer.add(\n        ellipse,\n        shape_type=\'ellipse\',\n        edge_width=5,\n        edge_color=\'coral\',\n        face_color=\'purple\',\n    )\n\n    # To save layers to svg:\n    # viewer.layers.save(\'viewer.svg\', plugin=\'svg\')\n'"
examples/add_surface_2D.py,3,"b'""""""\nDisplay a 2D surface\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    data = np.array([[0, 0], [0, 20], [10, 0], [10, 10]])\n    faces = np.array([[0, 1, 2], [1, 2, 3]])\n    values = np.linspace(0, 1, len(data))\n\n    # add the surface\n    viewer = napari.view_surface((data, faces, values))\n'"
examples/add_vectors.py,7,"b'""""""\nThis example generates an image of vectors\nVector data is an array of shape (N, 4)\nEach vector position is defined by an (x, y, x-proj, y-proj) element\n    where x and y are the center points\n    where x-proj and y-proj are the vector projections at each center\n\n""""""\n\nimport napari\nfrom skimage import data\nimport numpy as np\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    layer = viewer.add_image(data.camera(), name=\'photographer\')\n\n    # sample vector coord-like data\n    n = 200\n    pos = np.zeros((n, 2, 2), dtype=np.float32)\n    phi_space = np.linspace(0, 4 * np.pi, n)\n    radius_space = np.linspace(0, 100, n)\n\n    # assign x-y position\n    pos[:, 0, 0] = radius_space * np.cos(phi_space) + 300\n    pos[:, 0, 1] = radius_space * np.sin(phi_space) + 256\n\n    # assign x-y projection\n    pos[:, 1, 0] = 2 * radius_space * np.cos(phi_space)\n    pos[:, 1, 1] = 2 * radius_space * np.sin(phi_space)\n\n    # add the vectors\n    layer = viewer.add_vectors(pos, edge_width=3)\n'"
examples/add_vectors_color_by_angle.py,9,"b'""""""\nThis example generates a set of vectors in a spiral pattern.\nThe color of the vectors is mapped to their \'angle\' property.\n\n""""""\n\nimport napari\nfrom skimage import data\nimport numpy as np\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    layer = viewer.add_image(data.camera(), name=\'photographer\')\n\n    # sample vector coord-like data\n    n = 300\n    pos = np.zeros((n, 2, 2), dtype=np.float32)\n    phi_space = np.linspace(0, 4 * np.pi, n)\n    radius_space = np.linspace(0, 100, n)\n\n    # assign x-y position\n    pos[:, 0, 0] = radius_space * np.cos(phi_space) + 300\n    pos[:, 0, 1] = radius_space * np.sin(phi_space) + 256\n\n    # assign x-y projection\n    pos[:, 1, 0] = 2 * radius_space * np.cos(phi_space)\n    pos[:, 1, 1] = 2 * radius_space * np.sin(phi_space)\n\n    # make the angle property, range 0-2pi\n    angle = np.mod(phi_space, 2 * np.pi)\n\n    # create a property that is true for all angles  > pi\n    pos_angle = angle > np.pi\n\n    # create the properties dictionary.\n    properties = {\n        \'angle\': angle,\n        \'pos_angle\':pos_angle,\n    }\n\n    # add the vectors\n    layer = viewer.add_vectors(pos, edge_width=3, properties=properties, edge_color=\'angle\', edge_colormap=\'husl\')\n\n    # set the edge color mode to colormap\n    layer.edge_color_mode = \'colormap\'\n'"
examples/add_vectors_image.py,4,"b'""""""\nThis example generates an image of vectors\nVector data is an array of shape (N, M, 2)\nEach vector position is defined by an (x-proj, y-proj) element\n    where x-proj and y-proj are the vector projections at each center\n    where each vector is centered on a pixel of the NxM grid\n""""""\n\nimport napari\nimport numpy as np\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    n = 20\n    m = 40\n\n    image = 0.2 * np.random.random((n, m)) + 0.5\n    layer = viewer.add_image(image, contrast_limits=[0, 1], name=\'background\')\n\n    # sample vector image-like data\n    # n x m grid of slanted lines\n    # random data on the open interval (-1, 1)\n    pos = np.zeros(shape=(n, m, 2), dtype=np.float32)\n    rand1 = 2 * (np.random.random_sample(n * m) - 0.5)\n    rand2 = 2 * (np.random.random_sample(n * m) - 0.5)\n\n    # assign projections for each vector\n    pos[:, :, 0] = rand1.reshape((n, m))\n    pos[:, :, 1] = rand2.reshape((n, m))\n\n    # add the vectors\n    vect = viewer.add_vectors(pos, edge_width=0.2, length=2.5)\n\n    print(image.shape, pos.shape)\n'"
examples/add_volume.py,0,"b'""""""\nDisplay one 3-D volume layer using the add_volume API\n""""""\n\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(\n        float\n    )\n    viewer = napari.Viewer(ndisplay=3)\n    # add the volume\n    viewer.add_image(blobs, scale=[3, 1, 1])\n'"
examples/annotate-2d.py,1,"b'""""""\nDisplay one points layer ontop of one image layer using the add_points and\nadd_image APIs\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nprint(""click to add points; close the window when finished."")\n\nwith napari.gui_qt():\n    viewer = napari.view_image(data.astronaut(), rgb=True)\n    points = viewer.add_points(np.zeros((0, 2)))\n    points.mode = \'add\'\n\nprint(""you clicked on:"")\nprint(points.data)\n'"
examples/cursor_position.py,4,"b'""""""\nAdd small data to examine cursor positions\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n\n    viewer = napari.Viewer()\n    image = np.array([[1, 0, 0, 1],\n                      [0, 0, 1, 1],\n                      [1, 0, 3, 0],\n                      [0, 2, 0, 0]], dtype=int)\n\n    viewer.add_labels(image)\n\n    points = np.array([[0, 0], [2, 0], [1, 3]])\n    viewer.add_points(points, size=0.25)\n\n    rect = np.array([[0, 0], [3, 1]])\n    viewer.add_shapes(rect, shape_type=\'rectangle\', edge_width=0.1)\n\n    vect = np.array([[[3, 2], [-1, 1]]])\n    viewer.add_vectors(vect, edge_width=0.1)\n'"
examples/custom_key_bindings.py,0,"b'""""""\nDisplay one 4-D image layer using the add_image API\n""""""\n\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(\n        length=128, blob_size_fraction=0.05, n_dim=2, volume_fraction=0.25\n    ).astype(float)\n\n    viewer = napari.view_image(blobs, name=\'blobs\')\n\n    @viewer.bind_key(\'a\')\n    def accept_image(viewer):\n        msg = \'this is a good image\'\n        viewer.status = msg\n        print(msg)\n        next(viewer)\n\n    @viewer.bind_key(\'r\')\n    def reject_image(viewer):\n        msg = \'this is a bad image\'\n        viewer.status = msg\n        print(msg)\n        next(viewer)\n\n    def next(viewer):\n        blobs = data.binary_blobs(\n            length=128, blob_size_fraction=0.05, n_dim=2, volume_fraction=0.25\n        ).astype(float)\n        viewer.layers[0].data = blobs\n\n    @napari.Viewer.bind_key(\'w\')\n    def hello(viewer):\n        # on press\n        viewer.status = \'hello world!\'\n\n        yield\n\n        # on release\n        viewer.status = \'goodbye world :(\'\n\n    # change viewer title\n    viewer.title = \'quality control images\'\n'"
examples/custom_mouse_functions.py,3,"b'""""""\nDisplay one 4-D image layer using the add_image API\n""""""\n\nfrom skimage import data\nfrom skimage.morphology import binary_dilation, binary_erosion\nfrom scipy import ndimage as ndi\nimport numpy as np\nimport napari\n\n\nwith napari.gui_qt():\n    np.random.seed(1)\n    viewer = napari.Viewer()\n    blobs = data.binary_blobs(length=128, volume_fraction=0.1, n_dim=2)\n    labeled = ndi.label(blobs)[0]\n    labels_layer = viewer.add_labels(labeled, name=\'blob ID\')\n\n    @viewer.mouse_drag_callbacks.append\n    def get_ndisplay(viewer, event):\n        if \'Alt\' in event.modifiers:\n            print(\'viewer display \', viewer.dims.ndisplay)\n\n    @labels_layer.mouse_drag_callbacks.append\n    def get_connected_component_shape(layer, event):\n        cords = np.round(layer.coordinates).astype(int)\n        val = layer.get_value()\n        if val is None:\n            return\n        if val != 0:\n            data = layer.data\n            binary = data == val\n            if \'Shift\' in event.modifiers:\n                binary_new = binary_erosion(binary)\n                data[binary] = 0\n                data[binary_new] = val\n            else:\n                binary_new = binary_dilation(binary)\n                data[binary_new] = val\n            size = np.sum(binary_new)\n            layer.data = data\n            msg = f\'clicked at {cords} on blob {val} which is now {size} pixels\'\n        else:\n            msg = f\'clicked at {cords} on background which is ignored\'\n        layer.status = msg\n        print(msg)\n'"
examples/dask_nD_image.py,1,"b'""""""\nDisplay a dask array\n""""""\n\ntry:\n    from dask import array as da\nexcept ImportError:\n    raise ImportError(""""""This example uses a dask array but dask is not\n    installed. To install try \'pip install dask\'."""""")\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = da.stack(\n        [\n            data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=f\n            )\n            for f in np.linspace(0.05, 0.5, 10)\n        ],\n        axis=0,\n    )\n    viewer = napari.view_image(blobs.astype(float))\n'"
examples/interactive_scripting.py,2,"b'import numpy as np\nimport napari\nfrom napari.qt import thread_worker\nimport time\n\n\nwith napari.gui_qt():\n    # create the viewer with an image\n    data = np.random.random((512, 512))\n    viewer = napari.Viewer()\n    layer = viewer.add_image(data)\n\n    @thread_worker(start_thread=True)\n    def layer_update(*, update_period, num_updates):\n        # number of times to update\n        for k in range(num_updates):\n            time.sleep(update_period)\n\n            dat = np.random.random((512, 512))\n            layer.data = dat\n\n            # check that data layer is properly assigned and not blocked?\n            while layer.data.all() != dat.all():\n                layer.data = dat\n            yield\n\n    layer_update(update_period=0.05, num_updates=100)\n'"
examples/labels-2d.py,0,"b'""""""\nDisplay a labels layer above of an image layer using the add_labels and\nadd_image APIs\n""""""\n\nfrom skimage import data\nfrom skimage.color import rgb2gray\nfrom skimage.segmentation import slic\nimport napari\n\n\nwith napari.gui_qt():\n    astro = data.astronaut()\n\n    # initialise viewer with astro image\n    viewer = napari.view_image(rgb2gray(astro), name=\'astronaut\', rgb=False)\n\n    # add the labels\n    # we add 1 because SLIC returns labels from 0, which we consider background\n    labels = slic(astro, multichannel=True, compactness=20) + 1\n    label_layer = viewer.add_labels(labels, name=\'segmentation\')\n\n    # Set the labels layer mode to picker with a string\n    label_layer.mode = \'picker\'\n    print(f\'The color of label 5 is {label_layer.get_color(5)}\')\n'"
examples/layers.py,1,"b'""""""\nDisplay multiple image layers using the add_image API and then reorder them\nusing the layers swap method and remove one\n""""""\n\nfrom skimage import data\nfrom skimage.color import rgb2gray\nimport numpy as np\nimport napari\n\n\nwith napari.gui_qt():\n    # create the viewer with several image layers\n    viewer = napari.view_image(rgb2gray(data.astronaut()), name=\'astronaut\')\n    viewer.add_image(data.camera(), name=\'photographer\')\n    viewer.add_image(data.coins(), name=\'coins\')\n    viewer.add_image(data.moon(), name=\'moon\')\n    viewer.add_image(np.random.random((512, 512)), name=\'random\')\n    viewer.add_image(data.binary_blobs(length=512, volume_fraction=0.2, n_dim=2), name=\'blobs\')\n    viewer.grid_view()\n'"
examples/mouse_drag_callback.py,3,"b'""""""\nExample updating the status bar with line profile info while dragging\nlines around in a shapes layer.\n""""""\n\nfrom skimage import data\nfrom skimage import measure\nimport numpy as np\nimport napari\n\n\ndef profile_lines(image, shape_layer):\n    profile_data = []\n    for line in shape_layer.data:\n        profile_data.append(\n            measure.profile_line(image, line[0], line[1]).mean()\n        )\n    msg = (\'profile means: [\'\n            + \', \'.join([f\'{d:.2f}\' for d in profile_data])\n            + \']\')\n    shape_layer.status = msg\n\n\nwith napari.gui_qt():\n    np.random.seed(1)\n    viewer = napari.Viewer()\n    blobs = data.binary_blobs(length=512, volume_fraction=0.1, n_dim=2)\n    viewer.add_image(blobs, name=\'blobs\')\n    line1 = np.array([[11, 13], [111, 113]])\n    line2 = np.array([[200, 200], [400, 300]])\n    lines = [line1, line2]\n    shapes_layer = viewer.add_shapes(lines, shape_type=\'line\',\n            edge_width=5, edge_color=\'coral\', face_color=\'royalblue\')\n    shapes_layer.mode = \'select\'\n\n    @shapes_layer.mouse_drag_callbacks.append\n    def profile_lines_drag(layer, event):\n        profile_lines(blobs, layer)\n        yield\n        while event.type == \'mouse_move\':\n            profile_lines(blobs, layer)\n            # the yield statement allows the mouse UI to keep working while\n            # this loop is executed repeatedly\n            yield\n'"
examples/multiple_viewers.py,0,"b'""""""\nCreate multiple viewers from the same script\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # add the image\n    photographer = data.camera()\n    viewer_a = napari.view_image(photographer, name=\'photographer\')\n\n    # add the image\n    astronaut = data.astronaut()\n    viewer_b = napari.view_image(astronaut, name=\'astronaut\')\n'"
examples/multithreading_simple.py,0,"b'from qtpy.QtWidgets import QApplication, QWidget, QHBoxLayout, QLabel\nimport time\nfrom napari.qt import thread_worker\n\n\n@thread_worker\ndef long_running_function():\n    """"""Just a long running function, most like viewer.update.""""""\n    time.sleep(2)  # long function\n    return \'finished!\'\n\n\ndef create_widget():\n    widget = QWidget()\n    layout = QHBoxLayout()\n    widget.setLayout(layout)\n    widget.status = QLabel(\'ready...\')\n    layout.addWidget(widget.status)\n    widget.show()\n    return widget\n\n\nif __name__ == ""__main__"":\n    app = QApplication([])\n    wdg = create_widget()\n\n    # call decorated function\n    # By default, @thread_worker-decorated functions do not immediately start\n    worker = long_running_function()\n    # Signals are best connected *before* starting the worker.\n    worker.started.connect(lambda: wdg.status.setText(""worker is running...""))\n    worker.returned.connect(lambda x: wdg.status.setText(f""returned {x}""))\n\n    # # Connections may also be passed directly to the decorated function.\n    # # The above syntax is equivalent to:\n    # worker = long_running_function(\n    #     _connect={\n    #         \'started\': lambda: wdg.status.setText(""worker is running...""),\n    #         \'returned\': lambda x: wdg.status.setText(f""returned {x!r}""),\n    #     }\n    # )\n\n    worker.start()\n\n    app.exec_()\n'"
examples/multithreading_two_way.py,1,"b'import time\n\nfrom qtpy.QtWidgets import (\n    QGridLayout,\n    QLabel,\n    QProgressBar,\n    QPushButton,\n    QWidget,\n)\n\nimport napari\nimport numpy as np\nfrom napari._qt.threading import thread_worker\n\n\n@thread_worker\ndef two_way_communication_with_args(start, end):\n    """"""Both sends and receives values to & from the main thread.\n\n    Accepts arguments, puts them on the worker object.\n    Receives values from main thread with ``incoming = yield``\n    Optionally returns a value at the end\n    """"""\n\n    # do computationally intensive work here\n    i = start\n    while i < end:\n        i += 1\n        time.sleep(0.1)\n        # incoming receives values from the main thread\n        # while yielding sends values back to the main thread\n        incoming = yield i\n        i = incoming if incoming is not None else i\n\n    # do optional teardown here\n    return ""done""\n\n\nclass Controller(QWidget):\n    def __init__(self):\n        super().__init__()\n\n        layout = QGridLayout()\n        self.setLayout(layout)\n        self.status = QLabel(\'Click ""Start""\', self)\n        self.play_btn = QPushButton(""Start"", self)\n        self.abort_btn = QPushButton(""Abort!"", self)\n        self.reset_btn = QPushButton(""Reset"", self)\n        self.progress_bar = QProgressBar()\n\n        layout.addWidget(self.play_btn, 0, 0)\n        layout.addWidget(self.reset_btn, 0, 1)\n        layout.addWidget(self.abort_btn, 0, 2)\n        layout.addWidget(self.status, 0, 3)\n        layout.setColumnStretch(3, 1)\n        layout.addWidget(self.progress_bar, 1, 0, 1, 4)\n\n\ndef create_connected_widget():\n    """"""Builds a widget that can control a function in another thread.""""""\n    w = Controller()\n    steps = 40\n\n    # the decorated function now returns a GeneratorWorker object, and the\n    # Qthread in which it\'s running.\n    # (optionally pass start=False to prevent immediate running)\n    worker = two_way_communication_with_args(0, steps)\n\n    w.play_btn.clicked.connect(worker.start)\n\n    # it provides signals like {started, yielded, returned, errored, finished}\n    worker.returned.connect(lambda x: w.status.setText(f""worker returned {x}""))\n    worker.errored.connect(lambda x: w.status.setText(f""worker errored {x}""))\n    worker.started.connect(lambda: w.status.setText(""worker started...""))\n    worker.aborted.connect(lambda: w.status.setText(""worker aborted""))\n\n    # send values into the function (like generator.send) using worker.send\n    # abort thread with worker.abort()\n    w.abort_btn.clicked.connect(lambda: worker.quit())\n\n    def on_reset_button_pressed():\n        # we want to avoid sending into a unstarted worker\n        if worker.is_running:\n            worker.send(0)\n\n    def on_yield(x):\n        # Receive events and update widget progress\n        w.progress_bar.setValue(100 * x // steps)\n        w.status.setText(f""worker yielded {x}"")\n\n    def on_start():\n        def handle_pause():\n            worker.toggle_pause()\n            w.play_btn.setText(""Pause"" if worker.is_paused else ""Continue"")\n\n        w.play_btn.clicked.disconnect(worker.start)\n        w.play_btn.setText(""Pause"")\n        w.play_btn.clicked.connect(handle_pause)\n\n    def on_finish():\n        w.play_btn.setDisabled(True)\n        w.reset_btn.setDisabled(True)\n        w.abort_btn.setDisabled(True)\n        w.play_btn.setText(""Done"")\n\n    w.reset_btn.clicked.connect(on_reset_button_pressed)\n    worker.yielded.connect(on_yield)\n    worker.started.connect(on_start)\n    worker.finished.connect(on_finish)\n    return w\n\n\nif __name__ == ""__main__"":\n\n    with napari.gui_qt():\n        viewer = napari.view_image(np.random.rand(512, 512))\n        w = create_connected_widget()\n        viewer.window.add_dock_widget(w)\n'"
examples/nD_image.py,2,"b'""""""\nDisplay one 4-D image layer using the add_image API\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = np.stack(\n        [\n            data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=f\n            )\n            for f in np.linspace(0.05, 0.5, 10)\n        ],\n        axis=0,\n    )\n    viewer = napari.view_image(blobs.astype(float))\n'"
examples/nD_labels.py,0,"b'""""""\nDisplay a labels layer above of an image layer using the add_labels and\nadd_image APIs\n""""""\n\nfrom skimage import data\nfrom scipy import ndimage as ndi\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(length=128, volume_fraction=0.1, n_dim=3)\n    viewer = napari.view_image(blobs.astype(float), name=\'blobs\')\n    labeled = ndi.label(blobs)[0]\n    viewer.add_labels(labeled, name=\'blob ID\')\n'"
examples/nD_multiscale_image.py,2,"b'""""""\nDisplays an nD multiscale image\n""""""\n\nfrom skimage.transform import pyramid_gaussian\nimport napari\nimport numpy as np\n\n\n# create multiscale from random data\nbase = np.random.random((1536, 1536))\nbase = np.array([base * (8 - i) / 8 for i in range(8)])\nprint(\'base shape\', base.shape)\nmultiscale = list(\n    pyramid_gaussian(base, downscale=2, max_layer=2, multichannel=False)\n)\nprint(\'multiscale level shapes: \', [p.shape for p in multiscale])\n\nwith napari.gui_qt():\n    # add image multiscale\n    napari.view_image(multiscale, contrast_limits=[0, 1], multiscale=True)\n'"
examples/nD_multiscale_image_non_uniform.py,2,"b'""""""\nDisplays an nD multiscale image\n""""""\n\nfrom skimage import data\nfrom skimage.util import img_as_ubyte\nfrom skimage.color import rgb2gray\nfrom skimage.transform import pyramid_gaussian\nimport napari\nimport numpy as np\n\n\n# create multiscale from astronaut image\nastronaut = data.astronaut()\nbase = np.tile(astronaut, (3, 3, 1))\nmultiscale = list(\n    pyramid_gaussian(base, downscale=2, max_layer=3, multichannel=True)\n)\nmultiscale = [\n    np.array([p * (abs(3 - i) + 1) / 4 for i in range(6)]) for p in multiscale\n]\nprint(\'multiscale level shapes: \', [p.shape for p in multiscale])\n\nwith napari.gui_qt():\n    # add image multiscale\n    napari.view_image(multiscale, multiscale=True)\n'"
examples/nD_points.py,3,"b'""""""\nDisplay one points layer on top of one 4-D image layer using the\nadd_points and add_image APIs, where the markes are visible as nD objects\naccross the dimensions, specified by their size\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = np.stack(\n        [\n            data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=f\n            )\n            for f in np.linspace(0.05, 0.5, 10)\n        ],\n        axis=0,\n    )\n    viewer = napari.view_image(blobs.astype(float))\n\n    # add the points\n    points = np.array(\n        [\n            [0, 0, 100, 100],\n            [0, 0, 50, 120],\n            [1, 0, 100, 40],\n            [2, 10, 110, 100],\n            [9, 8, 80, 100],\n        ]\n    )\n    viewer.add_points(points, size=[0, 6, 10, 10], face_color=\'blue\', n_dimensional=True)\n'"
examples/nD_points_with_properties.py,2,"b'""""""\nDisplay one points layer ontop of one 4-D image layer using the\nadd_points and add_image APIs, where the markes are visible as nD objects\naccross the dimensions, specified by their size\n""""""\n\nfrom math import ceil\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(\n                length=100, blob_size_fraction=0.05, n_dim=3, volume_fraction=0.05\n            )\n    viewer = napari.view_image(blobs.astype(float))\n\n    # create the points\n    points = []\n    for z in range(blobs.shape[0]):\n        points += [\n                [z, 25, 25],\n                [z, 25, 75],\n                [z, 75, 25],\n                [z, 75, 75]\n        ]\n\n    # create the property for setting the face and edge color.\n    face_property = np.array(\n        [True, True, True, True, False, False, False, False] * int((blobs.shape[0] / 2))\n    )\n    edge_property = np.array([\'A\', \'B\', \'C\', \'D\', \'E\'] * int(len(points) / 5))\n\n    properties = {\n        \'face_property\': face_property,\n        \'edge_property\': edge_property,\n    }\n\n    points_layer = viewer.add_points(\n        points,\n        properties=properties,\n        size=3,\n        edge_width=5,\n        edge_color=\'edge_property\',\n        face_color=\'face_property\',\n        n_dimensional=False,\n    )\n\n    # change the face color cycle\n    points_layer.face_color_cycle = [\'white\', \'black\']\n\n    # change the edge_color cycle.\n    # there are 4 colors for 5 categories, so \'c\' will be recycled\n    points_layer.edge_color_cycle = [\'c\', \'m\', \'y\', \'k\']\n'"
examples/nD_shapes.py,9,"b'""""""\nDisplay one 4-D image layer using the add_image API\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = data.binary_blobs(\n        length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=0.1\n    ).astype(float)\n\n    viewer = napari.view_image(blobs.astype(float))\n\n    # create one random polygon per ""plane""\n    planes = np.tile(np.arange(128).reshape((128, 1, 1)), (1, 5, 1))\n    np.random.seed(0)\n    corners = np.random.uniform(0, 128, size=(128, 5, 2))\n    shapes = np.concatenate((planes, corners), axis=2)\n\n    base_cols = [\'red\', \'green\', \'blue\', \'white\', \'yellow\', \'magenta\', \'cyan\']\n    colors = np.random.choice(base_cols, size=128)\n\n    layer = viewer.add_shapes(\n        np.array(shapes),\n        shape_type=\'polygon\',\n        face_color=colors,\n        name=\'sliced\',\n    )\n\n    masks = layer.to_masks(mask_shape=(128, 128, 128))\n    labels = layer.to_labels(labels_shape=(128, 128, 128))\n    shape_array = np.array(layer.data)\n\n    print(\n        f\'sliced: nshapes {layer.nshapes}, mask shape {masks.shape}, \'\n        f\'labels_shape {labels.shape}, array_shape, {shape_array.shape}\'\n    )\n\n    corners = np.random.uniform(0, 128, size=(2, 2))\n    layer = viewer.add_shapes(\n        corners, shape_type=\'rectangle\', name=\'broadcasted\'\n    )\n\n    masks = layer.to_masks(mask_shape=(128, 128))\n    labels = layer.to_labels(labels_shape=(128, 128))\n    shape_array = np.array(layer.data)\n\n    print(\n        f\'broadcast: nshapes {layer.nshapes}, mask shape {masks.shape}, \'\n        f\'labels_shape {labels.shape}, array_shape, {shape_array.shape}\'\n    )\n'"
examples/nD_surface.py,3,"b'""""""\nDisplay a 3D surface\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer(ndisplay=3)\n\n    data = np.array([[0, 0, 0], [0, 20, 10], [10, 0, -10], [10, 10, -10]])\n    faces = np.array([[0, 1, 2], [1, 2, 3]])\n    values = np.linspace(0, 1, len(data))\n\n    # add the surface\n    layer = viewer.add_surface((data, faces, values))\n'"
examples/nD_vectors.py,13,"b'""""""\nDisplay two vectors layers ontop of a 4-D image layer. One of the vectors\nlayers is 3D and ""sliced"" with a different set of vectors appearing on\ndifferent 3D slices. Another is 2D and ""broadcast"" with the same vectors\napprearing on each slice.\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = np.stack(\n        [\n            data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=f\n            )\n            for f in np.linspace(0.05, 0.5, 10)\n        ],\n        axis=0,\n    )\n    viewer = napari.view_image(blobs.astype(float))\n\n    # sample vector coord-like data\n    n = 200\n    pos = np.zeros((n, 2, 2), dtype=np.float32)\n    phi_space = np.linspace(0, 4 * np.pi, n)\n    radius_space = np.linspace(0, 20, n)\n\n    # assign x-y position\n    pos[:, 0, 0] = radius_space * np.cos(phi_space) + 64\n    pos[:, 0, 1] = radius_space * np.sin(phi_space) + 64\n\n    # assign x-y projection\n    pos[:, 1, 0] = 2 * radius_space * np.cos(phi_space)\n    pos[:, 1, 1] = 2 * radius_space * np.sin(phi_space)\n\n    planes = np.round(np.linspace(0, 128, n)).astype(int)\n    planes = np.concatenate(\n        (planes.reshape((n, 1, 1)), np.zeros((n, 1, 1))), axis=1\n    )\n    vectors = np.concatenate((planes, pos), axis=2)\n\n    # add the sliced vectors\n    layer = viewer.add_vectors(\n        vectors, edge_width=0.4, name=\'sliced vectors\', edge_color=\'blue\'\n    )\n\n    viewer.dims.ndisplay = 3\n'"
examples/nD_vectors_image.py,2,"b'""""""\nThis example generates an image of vectors\nVector data is an array of shape (M, N, P, 3)\nEach vector position is defined by an (x-proj, y-proj, z-proj) element\nwhich are vector projections centered on a pixel of the MxNxP grid\n""""""\n\nimport napari\nimport numpy as np\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    m = 10\n    n = 20\n    p = 40\n\n    image = 0.2 * np.random.random((m, n, p)) + 0.5\n    layer = viewer.add_image(image, contrast_limits=[0, 1], name=\'background\')\n\n    # sample vector image-like data\n    # n x m grid of slanted lines\n    # random data on the open interval (-1, 1)\n    pos = np.random.uniform(-1, 1, size=(m, n, p, 3))\n    print(image.shape, pos.shape)\n\n    # add the vectors\n    vect = viewer.add_vectors(pos, edge_width=0.2, length=2.5)\n'"
examples/nD_volume.py,1,"b'""""""\nSlide through 3D Volume series in 4D data using the add_volume API\n""""""\n\nfrom skimage import data\nimport numpy as np\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = np.asarray(\n        [\n            data.binary_blobs(length=64, volume_fraction=0.1, n_dim=3).astype(\n                float\n            )\n            for i in range(10)\n        ]\n    )\n    viewer = napari.Viewer(ndisplay=3)\n\n    # add the volume\n    layer = viewer.add_image(blobs)\n'"
examples/pass_colormaps.py,1,"b'""""""\nAdd named or unnamed vispy colormaps to existing layers.\n""""""\n\nimport numpy as np\nimport vispy.color\nfrom skimage import data\nimport napari\n\n\nhisto = data.astronaut() / 255\nrch, gch, bch = np.transpose(histo, (2, 0, 1))\n\nwith napari.gui_qt():\n    v = napari.Viewer()\n\n    rlayer = v.add_image(\n        rch, name=\'red channel\', colormap=\'red\', blending=\'additive\'\n    )\n    glayer = v.add_image(\n        gch, name=\'green channel\', colormap=\'green\', blending=\'additive\'\n    )\n    blayer = v.add_image(\n        bch, name=\'blue channel\', colormap=\'blue\', blending=\'additive\'\n    )\n'"
examples/reader_plugin.py,0,"b'""""""Barebones reader plugin example, using imageio.imread""""""\nfrom napari_plugin_engine import napari_hook_implementation\nfrom imageio import formats, imread\n\n\nreadable_extensions = tuple(set(x for f in formats for x in f.extensions))\n\n\n@napari_hook_implementation\ndef napari_get_reader(path):\n    """"""A basic implementation of the napari_get_reader hook specification.""""""\n    # if we know we cannot read the file, we immediately return None.\n    if not path.endswith(readable_extensions):\n        return None\n    # otherwise we return the *function* that can read ``path``.\n    return reader_function\n\n\ndef reader_function(path):\n    """"""Take a path and returns a list of LayerData tuples.""""""\n    data = imread(path)\n    # Readers are expected to return data as a list of tuples, where each tuple\n    # is (data, [meta_dict, [layer_type]])\n    return [(data,)]\n'"
examples/set_colormaps.py,1,"b'""""""\nAdd named or unnamed vispy colormaps to existing layers.\n""""""\n\nimport numpy as np\nimport vispy.color\nfrom skimage import data\nimport napari\n\n\nhisto = data.astronaut() / 255\nrch, gch, bch = np.transpose(histo, (2, 0, 1))\nred = vispy.color.Colormap([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]])\ngreen = vispy.color.Colormap([[0.0, 0.0, 0.0], [0.0, 1.0, 0.0]])\nblue = vispy.color.Colormap([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\n\nwith napari.gui_qt():\n    v = napari.Viewer()\n\n    rlayer = v.add_image(rch, name=\'red channel\')\n    rlayer.blending = \'additive\'\n    rlayer.colormap = \'red\', red\n    glayer = v.add_image(gch, name=\'green channel\')\n    glayer.blending = \'additive\'\n    glayer.colormap = green  # this will appear as [unnamed colormap]\n    blayer = v.add_image(bch, name=\'blue channel\')\n    blayer.blending = \'additive\'\n    blayer.colormap = {\'blue\': blue}\n'"
examples/set_theme.py,0,"b'""""""\nDisplays an image and sets the theme to \'light\'.\n""""""\n\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # create the viewer with an image\n    viewer = napari.view_image(\n        data.astronaut(), rgb=True, name=\'astronaut\'\n    )\n\n    # set the theme to \'light\'\n    viewer.theme = \'light\'\n'"
examples/shapes_to_labels.py,4,"b'""""""\nDisplay one shapes layer ontop of one image layer using the add_shapes and\nadd_image APIs. When the window is closed it will print the coordinates of\nyour shapes.\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\nfrom vispy.color import Colormap\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    # add the image\n    img_layer = viewer.add_image(data.camera(), name=\'photographer\')\n\n    # create a list of polygons\n    polygons = [\n        np.array([[11, 13], [111, 113], [22, 246]]),\n        np.array(\n            [\n                [505, 60],\n                [402, 71],\n                [383, 42],\n                [251, 95],\n                [212, 59],\n                [131, 137],\n                [126, 187],\n                [191, 204],\n                [171, 248],\n                [211, 260],\n                [273, 243],\n                [264, 225],\n                [430, 173],\n                [512, 160],\n            ]\n        ),\n        np.array(\n            [\n                [310, 382],\n                [229, 381],\n                [209, 401],\n                [221, 411],\n                [258, 411],\n                [300, 412],\n                [306, 435],\n                [268, 434],\n                [265, 454],\n                [298, 461],\n                [307, 461],\n                [307, 507],\n                [349, 510],\n                [352, 369],\n                [330, 366],\n                [330, 366],\n            ]\n        ),\n    ]\n\n    # add polygons\n    layer = viewer.add_shapes(\n        polygons,\n        shape_type=\'polygon\',\n        edge_width=1,\n        edge_color=\'coral\',\n        face_color=\'royalblue\',\n        name=\'shapes\',\n    )\n\n    # change some properties of the layer\n    layer.selected_data = set(range(layer.nshapes))\n    layer.current_edge_width = 5\n    layer.current_opacity = 0.75\n    layer.selected_data = set()\n\n    # add an ellipse to the layer\n    ellipse = np.array([[59, 222], [110, 289], [170, 243], [119, 176]])\n    layer.add(\n        ellipse,\n        shape_type=\'ellipse\',\n        edge_width=5,\n        edge_color=\'coral\',\n        face_color=\'purple\',\n        opacity=0.75,\n    )\n\n    masks = layer.to_masks([512, 512])\n    masks_layer = viewer.add_image(masks.astype(float), name=\'masks\')\n    masks_layer.opacity = 0.7\n    masks_layer.colormap = Colormap(\n        [[0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 1.0]]\n    )\n\n    labels = layer.to_labels([512, 512])\n    labels_layer = viewer.add_labels(labels, name=\'labels\')\n    labels_layer.visible = False\n'"
examples/surface_timeseries.py,0,"b'""""""\nDisplay a surface timeseries using data from nilearn\n""""""\n\ntry:\n    from nilearn import datasets\n    from nilearn import surface\nexcept ImportError:\n    raise ImportError(\n        ""You must have nilearn installed to run this example.""\n    )\n\nimport numpy as np\nimport napari\n\n\n# Fetch datasets - this will download dataset if datasets are not found\nnki_dataset = datasets.fetch_surf_nki_enhanced(n_subjects=1)\nfsaverage = datasets.fetch_surf_fsaverage()\n\n# Load surface data and resting state time series from nilearn\nbrain_vertices, brain_faces = surface.load_surf_data(fsaverage[\'pial_left\'])\nbrain_vertex_depth = surface.load_surf_data(fsaverage[\'sulc_left\'])\ntimeseries = surface.load_surf_data(nki_dataset[\'func_left\'][0])\n# nilearn provides data as n_vertices x n_timepoints, but napari requires the\n# vertices axis to be placed last to match NumPy broadcasting rules\ntimeseries = timeseries.transpose((1, 0))\n\nwith napari.gui_qt():\n    # create an empty viewer\n    viewer = napari.Viewer(ndisplay=3)\n\n    # add the mri\n    viewer.add_surface((brain_vertices, brain_faces, brain_vertex_depth), name=\'base\')\n    viewer.add_surface((brain_vertices, brain_faces, timeseries),\n                       colormap=\'turbo\', opacity=0.9,\n                       contrast_limits=[-1.5, 3.5], name=\'timeseries\')\n'"
examples/swap_dims.py,3,"b'""""""\nDisplay a 4-D image and points layer and swap the displayed dimensions\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    blobs = np.stack(\n        [\n            data.binary_blobs(\n                length=128, blob_size_fraction=0.05, n_dim=3, volume_fraction=f\n            )\n            for f in np.linspace(0.05, 0.5, 10)\n        ],\n        axis=0,\n    )\n    viewer = napari.view_image(blobs.astype(float))\n\n    # add the points\n    points = np.array(\n        [\n            [0, 0, 0, 100],\n            [0, 0, 50, 120],\n            [1, 0, 100, 40],\n            [2, 10, 110, 100],\n            [9, 8, 80, 100],\n        ]\n    )\n    viewer.add_points(\n        points, size=[0, 6, 10, 10], face_color=\'blue\', n_dimensional=True\n    )\n\n    viewer.dims.order = (0, 2, 1, 3)\n'"
examples/to_screenshot.py,13,"b'""""""\nDisplay one shapes layer ontop of one image layer using the add_shapes and\nadd_image APIs. When the window is closed it will print the coordinates of\nyour shapes.\n""""""\n\nimport numpy as np\nfrom skimage import data\nfrom skimage.io import imsave\nimport napari\nfrom vispy.color import Colormap\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    # add the image\n    img_layer = viewer.add_image(data.camera(), name=\'photographer\')\n    img_layer.colormap = \'gray\'\n\n    # create a list of polygons\n    polygons = [\n        np.array([[11, 13], [111, 113], [22, 246]]),\n        np.array(\n            [\n                [505, 60],\n                [402, 71],\n                [383, 42],\n                [251, 95],\n                [212, 59],\n                [131, 137],\n                [126, 187],\n                [191, 204],\n                [171, 248],\n                [211, 260],\n                [273, 243],\n                [264, 225],\n                [430, 173],\n                [512, 160],\n            ]\n        ),\n        np.array(\n            [\n                [310, 382],\n                [229, 381],\n                [209, 401],\n                [221, 411],\n                [258, 411],\n                [300, 412],\n                [306, 435],\n                [268, 434],\n                [265, 454],\n                [298, 461],\n                [307, 461],\n                [307, 507],\n                [349, 510],\n                [352, 369],\n                [330, 366],\n                [330, 366],\n            ]\n        ),\n    ]\n\n    # add polygons\n    layer = viewer.add_shapes(\n        polygons,\n        shape_type=\'polygon\',\n        edge_width=1,\n        edge_color=\'coral\',\n        face_color=\'royalblue\',\n        name=\'shapes\',\n    )\n\n    # change some properties of the layer\n    layer.selected_data = set(range(layer.nshapes))\n    layer.current_edge_width = 5\n    layer.current_opacity = 0.75\n    layer.selected_data = set()\n\n    # add an ellipse to the layer\n    ellipse = np.array([[59, 222], [110, 289], [170, 243], [119, 176]])\n    layer.add(\n        ellipse,\n        shape_type=\'ellipse\',\n        edge_width=5,\n        edge_color=\'coral\',\n        face_color=\'purple\',\n        opacity=0.75,\n    )\n\n    masks = layer.to_masks([512, 512])\n    masks_layer = viewer.add_image(masks.astype(float), name=\'masks\')\n    masks_layer.opacity = 0.7\n    masks_layer.colormap = Colormap(\n        [[0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 0.0, 1.0]]\n    )\n\n    labels = layer.to_labels([512, 512])\n    labels_layer = viewer.add_labels(labels, name=\'labels\')\n\n    points = np.array([[100, 100], [200, 200], [333, 111]])\n    size = np.array([10, 20, 20])\n    viewer.add_points(points, size=size)\n\n    # sample vector coord-like data\n    n = 100\n    pos = np.zeros((n, 2, 2), dtype=np.float32)\n    phi_space = np.linspace(0, 4 * np.pi, n)\n    radius_space = np.linspace(0, 100, n)\n\n    # assign x-y position\n    pos[:, 0, 0] = radius_space * np.cos(phi_space) + 350\n    pos[:, 0, 1] = radius_space * np.sin(phi_space) + 256\n\n    # assign x-y projection\n    pos[:, 1, 0] = 2 * radius_space * np.cos(phi_space)\n    pos[:, 1, 1] = 2 * radius_space * np.sin(phi_space)\n\n    # add the vectors\n    layer = viewer.add_vectors(pos, edge_width=2)\n\n    # take screenshot\n    screenshot = viewer.screenshot()\n    viewer.add_image(screenshot, rgb=True, name=\'screenshot\')\n    # imsave(\'screenshot.png\', screenshot)\n'"
examples/update_console.py,3,"b'""""""\nDisplay one shapes layer ontop of one image layer using the add_shapes and\nadd_image APIs. When the window is closed it will print the coordinates of\nyour shapes.\n""""""\n\nimport numpy as np\nfrom skimage import data\nimport napari\n\n\nwith napari.gui_qt():\n    # create the viewer and window\n    viewer = napari.Viewer()\n\n    # add the image\n    photographer = data.camera()\n    image_layer = napari.view_image(photographer, name=\'photographer\')\n\n    # create a list of polygons\n    polygons = [\n        np.array([[11, 13], [111, 113], [22, 246]]),\n        np.array(\n            [\n                [505, 60],\n                [402, 71],\n                [383, 42],\n                [251, 95],\n                [212, 59],\n                [131, 137],\n                [126, 187],\n                [191, 204],\n                [171, 248],\n                [211, 260],\n                [273, 243],\n                [264, 225],\n                [430, 173],\n                [512, 160],\n            ]\n        ),\n        np.array(\n            [\n                [310, 382],\n                [229, 381],\n                [209, 401],\n                [221, 411],\n                [258, 411],\n                [300, 412],\n                [306, 435],\n                [268, 434],\n                [265, 454],\n                [298, 461],\n                [307, 461],\n                [307, 507],\n                [349, 510],\n                [352, 369],\n                [330, 366],\n                [330, 366],\n            ]\n        ),\n    ]\n\n    # add polygons\n    shapes_layer = viewer.add_shapes(\n        polygons,\n        shape_type=\'polygon\',\n        edge_width=5,\n        edge_color=\'coral\',\n        face_color=\'royalblue\',\n        name=\'shapes\',\n    )\n\n    # Send local variables to the console\n    viewer.update_console(locals())\n'"
examples/xarray_nD_image.py,1,"b'""""""\nDisplays an xarray\n""""""\n\ntry:\n    import xarray as xr\nexcept ImportError:\n    raise ImportError(""""""This example uses a xarray but xarray is not\n    installed. To install try \'pip install xarray\'."""""")\n\nimport numpy as np\nimport napari\n\ndata = np.random.random((20, 40, 50))\nxdata = xr.DataArray(data, dims=[\'z\', \'y\', \'x\'])\n\nwith napari.gui_qt():\n    # create an empty viewer\n    viewer = napari.Viewer()\n\n    # add the xarray\n    layer = viewer.add_image(xdata, name=\'xarray\')\n'"
examples/zarr_nD_image.py,0,"b'""""""\nDisplay a zarr array\n""""""\n\ntry:\n    import zarr\nexcept ImportError:\n    raise ImportError(""""""This example uses a zarr array but zarr is not\n    installed. To install try \'pip install zarr\'."""""")\n\nimport napari\n\n\nwith napari.gui_qt():\n    data = zarr.zeros((102_0, 200, 210), chunks=(100, 200, 210))\n    data[53_0:53_1, 100:110, 110:120] = 1\n\n    print(data.shape)\n    # For big data, we should specify the contrast_limits range, or napari will try\n    # to find the min and max of the full image.\n    viewer = napari.view_image(data, contrast_limits=[0, 1], rgb=False)\n'"
napari/__init__.py,0,"b'try:\n    from ._version import version as __version__\nexcept ImportError:\n    __version__ = ""not-installed""\n\nimport os\nfrom distutils.version import StrictVersion\nfrom pathlib import Path\n\ntry:\n    from qtpy import API_NAME\nexcept Exception as e:\n    if \'No Qt bindings could be found\' in str(e):\n        raise type(e)(\n            ""No Qt bindings could be found.\\n\\nnapari requires either PyQt5 or""\n            "" PySide2 to be installed in the environment.\\nTo install the ""\n            \'default backend (currently PyQt5), run ""pip install napari[all]""\'\n            \'\\nYou may also use ""pip install napari[pyside2]"" for Pyside2, \'\n            \'or ""pip install napari[pyqt5]"" for PyQt5\'\n        ) from e\n    raise\n\n\nif API_NAME == \'PySide2\':\n    # Set plugin path appropriately if using PySide2. This is a bug fix\n    # for when both PyQt5 and Pyside2 are installed\n    import PySide2\n\n    os.environ[\'QT_PLUGIN_PATH\'] = str(\n        Path(PySide2.__file__).parent / \'Qt\' / \'plugins\'\n    )\n\nfrom qtpy import QtCore\n\n# When QT is not the specific version, we raise a warning:\nfrom warnings import warn\n\nif StrictVersion(QtCore.__version__) < StrictVersion(\'5.12.3\'):\n    warn_message = f""""""\n    napari was tested with QT library `>=5.12.3`.\n    The version installed is {QtCore.__version__}. Please report any issues with this\n    specific QT version at https://github.com/Napari/napari/issues.\n    """"""\n    warn(message=warn_message)\n\nfrom vispy import app\nimport logging\n\n# set vispy application to the appropriate qt backend\napp.use_app(API_NAME)\ndel app\n# set vispy logger to show warning and errors only\nvispy_logger = logging.getLogger(\'vispy\')\nvispy_logger.setLevel(logging.WARNING)\n\nfrom .viewer import Viewer\nfrom .plugins.io import save_layers\n\n# Note that importing _viewer_key_bindings is needed as the Viewer gets\n# decorated with keybindings during that process, but it is not directly needed\n# by our users and so is deleted below\nfrom . import _viewer_key_bindings  # noqa: F401\nfrom .view_layers import (\n    view_path,\n    view_image,\n    view_labels,\n    view_surface,\n    view_shapes,\n    view_points,\n    view_vectors,\n)\nfrom ._qt import gui_qt\nfrom .utils import sys_info, _magicgui\n\n# register napari object types with magicgui if it is installed\n_magicgui.register_types_with_magicgui()\n\ndel _magicgui\ndel _viewer_key_bindings\n'"
napari/__main__.py,0,"b'""""""\nnapari command line viewer.\n""""""\nimport argparse\nimport logging\nimport sys\nfrom ast import literal_eval\nfrom textwrap import wrap\nfrom typing import Any, Dict, List\n\nfrom . import __version__, gui_qt, layers, view_path\nfrom .components.add_layers_mixin import valid_add_kwargs\nfrom .utils import citation_text, sys_info\n\n\nclass InfoAction(argparse.Action):\n    def __call__(self, *args, **kwargs):\n        # prevent unrelated INFO logs when doing ""napari --info""\n        logging.basicConfig(level=logging.WARNING)\n        print(sys_info())\n        sys.exit()\n\n\nclass CitationAction(argparse.Action):\n    def __call__(self, *args, **kwargs):\n        # prevent unrelated INFO logs when doing ""napari --citation""\n        logging.basicConfig(level=logging.WARNING)\n        print(citation_text)\n        sys.exit()\n\n\ndef validate_unknown_args(unknown: List[str]) -> Dict[str, Any]:\n    """"""Convert a list of strings into a dict of valid kwargs for add_* methods.\n\n    Will exit program if any of the arguments are unrecognized, or are\n    malformed.  Converts string to python type using literal_eval.\n\n    Parameters\n    ----------\n    unknown : List[str]\n        a list of strings gathered as ""unknown"" arguments in argparse.\n\n    Returns\n    -------\n    kwargs : Dict[str, Any]\n        {key: val} dict suitable for the viewer.add_* methods where ``val``\n        is a ``literal_eval`` result, or string.\n    """"""\n\n    out: Dict[str, Any] = dict()\n    valid = set.union(*valid_add_kwargs().values())\n    for i, arg in enumerate(unknown):\n        if not arg.startswith(""--""):\n            continue\n\n        if ""="" in arg:\n            key, value = arg.split(""="", maxsplit=1)\n        else:\n            key = arg\n        key = key.lstrip(\'-\').replace(""-"", ""_"")\n\n        if key not in valid:\n            sys.exit(f""error: unrecognized arguments: {arg}"")\n\n        if ""="" not in arg:\n            try:\n                value = unknown[i + 1]\n                if value.startswith(""--""):\n                    raise IndexError()\n            except IndexError:\n                sys.exit(f""error: argument {arg} expected one argument"")\n        try:\n            value = literal_eval(value)\n        except Exception:\n            value = value\n\n        out[key] = value\n    return out\n\n\ndef main():\n    kwarg_options = []\n    for layer_type, keys in valid_add_kwargs().items():\n        kwarg_options.append(f""  {layer_type.title()}:"")\n        keys = {k.replace(\'_\', \'-\') for k in keys}\n        lines = wrap("", "".join(sorted(keys)), break_on_hyphens=False)\n        kwarg_options.extend([f""    {line}"" for line in lines])\n\n    parser = argparse.ArgumentParser(\n        usage=__doc__,\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=""optional layer-type-specific arguments (precede with \'--\'):\\n""\n        + ""\\n"".join(kwarg_options),\n    )\n    parser.add_argument(\'images\', nargs=\'*\', help=\'image(s) to view.\')\n    parser.add_argument(\n        \'-v\',\n        \'--verbose\',\n        action=\'count\',\n        default=0,\n        help=""increase output verbosity"",\n    )\n    parser.add_argument(\n        \'--version\', action=\'version\', version=f\'napari version {__version__}\',\n    )\n    parser.add_argument(\n        \'--info\',\n        action=InfoAction,\n        nargs=0,\n        help=\'show system information and exit\',\n    )\n    parser.add_argument(\n        \'--citation\',\n        action=CitationAction,\n        nargs=0,\n        help=\'show citation information and exit\',\n    )\n    parser.add_argument(\n        \'--stack\',\n        action=\'store_true\',\n        help=\'concatenate multiple input files into a single stack.\',\n    )\n    parser.add_argument(\n        \'--plugin\', help=\'specify plugin name when opening a file\',\n    )\n    parser.add_argument(\n        \'--layer-type\',\n        metavar=""TYPE"",\n        choices=set(layers.NAMES),\n        help=(\n            \'force file to be interpreted as a specific layer type. \'\n            f\'one of {set(layers.NAMES)}\'\n        ),\n    )\n\n    args, unknown = parser.parse_known_args()\n    # this is a hack to allow using ""="" as a key=value separator while also\n    # allowing nargs=\'*\' on the ""images"" argument...\n    for idx, item in enumerate(reversed(args.images)):\n        if item.startswith(""--""):\n            unknown.append(args.images.pop(len(args.images) - idx - 1))\n    kwargs = validate_unknown_args(unknown) if unknown else {}\n\n    # parse -v flags and set the appropriate logging level\n    levels = [logging.WARNING, logging.INFO, logging.DEBUG]\n    level = levels[min(2, args.verbose)]  # prevent index error\n    logging.basicConfig(\n        level=level,\n        format=""%(asctime)s %(levelname)s %(message)s"",\n        datefmt=\'%H:%M:%S\',\n    )\n\n    if args.plugin:\n        # make sure plugin is only used when files are specified\n        if not args.images:\n            sys.exit(\n                ""error: The \'--plugin\' argument is only valid ""\n                ""when providing a file name""\n            )\n        # I *think* that Qt is looking in sys.argv for a flag `--plugins`,\n        # which emits ""WARNING: No such plugin for spec \'builtins\'""\n        # so remove --plugin from sys.argv to prevent that warningz\n        sys.argv.remove(\'--plugin\')\n\n    with gui_qt(startup_logo=True):\n        view_path(\n            args.images,\n            stack=args.stack,\n            plugin=args.plugin,\n            layer_type=args.layer_type,\n            **kwargs,\n        )\n\n\nif __name__ == \'__main__\':\n    sys.exit(main())\n'"
napari/_viewer_key_bindings.py,3,"b'import numpy as np\nfrom .viewer import Viewer\n\n\n@Viewer.bind_key(\'Control-F\')\ndef toggle_fullscreen(viewer):\n    """"""Toggle fullscreen mode.""""""\n    if viewer.window._qt_window.isFullScreen():\n        viewer.window._qt_window.showNormal()\n    else:\n        viewer.window._qt_window.showFullScreen()\n\n\n@Viewer.bind_key(\'Control-Y\')\ndef toggle_ndisplay(viewer):\n    """"""Toggle ndisplay.""""""\n    if viewer.dims.ndisplay == 3:\n        viewer.dims.ndisplay = 2\n    else:\n        viewer.dims.ndisplay = 3\n\n\n@Viewer.bind_key(\'Left\')\ndef increment_dims_left(viewer):\n    """"""Increment dimensions slider to the left.""""""\n    axis = viewer.window.qt_viewer.dims.last_used\n    if axis is not None:\n        cur_point = viewer.dims.point[axis]\n        axis_range = viewer.dims.range[axis]\n        new_point = np.clip(\n            cur_point - axis_range[2],\n            axis_range[0],\n            axis_range[1] - axis_range[2],\n        )\n        viewer.dims.set_point(axis, new_point)\n\n\n@Viewer.bind_key(\'Right\')\ndef increment_dims_right(viewer):\n    """"""Increment dimensions slider to the right.""""""\n    axis = viewer.window.qt_viewer.dims.last_used\n    if axis is not None:\n        cur_point = viewer.dims.point[axis]\n        axis_range = viewer.dims.range[axis]\n        new_point = np.clip(\n            cur_point + axis_range[2],\n            axis_range[0],\n            axis_range[1] - axis_range[2],\n        )\n        viewer.dims.set_point(axis, new_point)\n\n\n@Viewer.bind_key(\'Control-E\')\ndef roll_axes(viewer):\n    """"""Change order of the visible axes, e.g. [0, 1, 2] -> [2, 0, 1].""""""\n    viewer.dims._roll()\n\n\n@Viewer.bind_key(\'Control-T\')\ndef transpose_axes(viewer):\n    """"""Transpose order of the last two visible axes, e.g. [0, 1] -> [1, 0].""""""\n    viewer.dims._transpose()\n\n\n@Viewer.bind_key(\'Alt-Up\')\ndef focus_axes_up(viewer):\n    """"""Move focus of dimensions slider up.""""""\n    viewer.window.qt_viewer.dims.focus_up()\n\n\n@Viewer.bind_key(\'Alt-Down\')\ndef focus_axes_down(viewer):\n    """"""Move focus of dimensions slider down.""""""\n    viewer.window.qt_viewer.dims.focus_down()\n\n\n@Viewer.bind_key(\'Control-Backspace\')\n@Viewer.bind_key(\'Control-Delete\')\ndef remove_selected(viewer):\n    """"""Remove selected layers.""""""\n    viewer.layers.remove_selected()\n\n\n@Viewer.bind_key(\'Control-A\')\ndef select_all(viewer):\n    """"""Selected all layers.""""""\n    viewer.layers.select_all()\n\n\n@Viewer.bind_key(\'Control-Shift-Backspace\')\n@Viewer.bind_key(\'Control-Shift-Delete\')\ndef remove_all_layers(viewer):\n    """"""Remove all layers.""""""\n    viewer.layers.select_all()\n    viewer.layers.remove_selected()\n\n\n@Viewer.bind_key(\'Up\')\ndef select_layer_above(viewer):\n    """"""Select layer above.""""""\n    viewer.layers.select_next()\n\n\n@Viewer.bind_key(\'Down\')\ndef select_layer_below(viewer):\n    """"""Select layer below.""""""\n    viewer.layers.select_previous()\n\n\n@Viewer.bind_key(\'Shift-Up\')\ndef also_select_layer_above(viewer):\n    """"""Also select layer above.""""""\n    viewer.layers.select_next(shift=True)\n\n\n@Viewer.bind_key(\'Shift-Down\')\ndef also_select_layer_below(viewer):\n    """"""Also select layer below.""""""\n    viewer.layers.select_previous(shift=True)\n\n\n@Viewer.bind_key(\'Control-R\')\ndef reset_view(viewer):\n    """"""Reset view to original state.""""""\n    viewer.reset_view()\n\n\n@Viewer.bind_key(\'Control-G\')\ndef toggle_grid(viewer):\n    """"""Toggle grid mode.""""""\n    if np.all(viewer.grid_size == (1, 1)):\n        viewer.grid_view()\n    else:\n        viewer.stack_view()\n\n\n@Viewer.bind_key(\'Control-Alt-P\')\ndef play(viewer):\n    """"""Toggle animation on the first axis""""""\n    if viewer.window.qt_viewer.dims.is_playing:\n        viewer.window.qt_viewer.dims.stop()\n    else:\n        axis = viewer.window.qt_viewer.dims.last_used or 0\n        viewer.window.qt_viewer.dims.play(axis)\n\n\n@Viewer.bind_key(\'V\')\ndef toggle_selected_visibility(viewer):\n    """"""Toggle visibility of selected layers""""""\n    viewer.layers.toggle_selected_visibility()\n'"
napari/conftest.py,32,"b'import warnings\nfrom functools import partial\nfrom typing import List\n\nimport numpy as np\nimport pytest\nfrom qtpy.QtWidgets import QApplication\n\nfrom napari import Viewer\nfrom napari.components import LayerList\nfrom napari.layers import Image, Labels, Points, Shapes, Vectors\nfrom napari.plugins._builtins import (\n    napari_write_image,\n    napari_write_labels,\n    napari_write_points,\n    napari_write_shapes,\n)\nfrom napari.utils import io\n\ntry:\n    from skimage.data import image_fetcher\nexcept ImportError:\n    from skimage.data import data_dir\n    import os\n\n    class image_fetcher:\n        def fetch(data_name):\n            if data_name.startswith(""data/""):\n                data_name = data_name[5:]\n            path = os.path.join(data_dir, data_name)\n            if not os.path.exists(path):\n                raise ValueError(\n                    f""Legacy skimage image_fetcher cannot find file: {path}""\n                )\n            return path\n\n\ndef pytest_addoption(parser):\n    """"""An option to show viewers during tests. (Hidden by default).\n\n    Showing viewers decreases test speed by about %18.  Note, due to the\n    placement of this conftest.py file, you must specify the napari folder (in\n    the pytest command) to use this flag.\n\n    Example\n    -------\n    $ pytest napari --show-viewer\n    """"""\n    parser.addoption(\n        ""--show-viewer"",\n        action=""store_true"",\n        default=False,\n        help=""don\'t show viewer during tests"",\n    )\n\n\n@pytest.fixture\ndef qtbot(qtbot):\n    """"""A modified qtbot fixture that makes sure no widgets have been leaked.""""""\n    initial = QApplication.topLevelWidgets()\n    yield qtbot\n    QApplication.processEvents()\n    leaks = set(QApplication.topLevelWidgets()).difference(initial)\n    # still not sure how to clean up some of the remaining vispy\n    # vispy.app.backends._qt.CanvasBackendDesktop widgets...\n    if any([n.__class__.__name__ != \'CanvasBackendDesktop\' for n in leaks]):\n        raise AssertionError(f\'Widgets leaked!: {leaks}\')\n    if leaks:\n        warnings.warn(f\'Widgets leaked!: {leaks}\')\n\n\n@pytest.fixture(scope=""function"")\ndef viewer_factory(qtbot, request):\n    viewers: List[Viewer] = []\n\n    def actual_factory(*model_args, **model_kwargs):\n        model_kwargs[\'show\'] = model_kwargs.pop(\n            \'show\', request.config.getoption(""--show-viewer"")\n        )\n        viewer = Viewer(*model_args, **model_kwargs)\n        viewers.append(viewer)\n        view = viewer.window.qt_viewer\n        return view, viewer\n\n    yield actual_factory\n\n    for viewer in viewers:\n        viewer.close()\n\n\n@pytest.fixture(\n    params=[\'image\', \'labels\', \'points\', \'points-with-properties\', \'shapes\']\n)\ndef layer_writer_and_data(request):\n    """"""Fixture that supplies layer io utilities for tests.\n\n    Parameters\n    ----------\n    request : _pytest.fixtures.SubRequest\n        The pytest request object\n\n    Returns\n    -------\n    tuple\n        ``(writer, layer_data, extension, reader, Layer)``\n\n        - writer: a function that can write layerdata to a path\n        - layer_data: the layerdata tuple for this layer\n        - extension: an appropriate extension for this layer type\n        - reader: a function that can read this layer type from a path and\n                  returns a ``(data, meta)`` tuple.\n        - Layer: the Layer class\n    """"""\n    if request.param == \'image\':\n        data = np.random.rand(20, 20)\n        Layer = Image\n        layer = Image(data)\n        writer = napari_write_image\n        extension = \'.tif\'\n\n        def reader(path):\n            return (io.imread(path), {}, \'image\')  # metadata\n\n    elif request.param == \'labels\':\n        data = np.random.randint(0, 16000, (32, 32), \'uint64\')\n        Layer = Labels\n        layer = Labels(data)\n        writer = napari_write_labels\n        extension = \'.tif\'\n\n        def reader(path):\n            return (io.imread(path), {}, \'labels\')  # metadata\n\n    elif request.param == \'points\':\n        data = np.random.rand(20, 2)\n        Layer = Points\n        layer = Points(data)\n        writer = napari_write_points\n        extension = \'.csv\'\n        reader = partial(io.csv_to_layer_data, require_type=\'points\')\n    elif request.param == \'points-with-properties\':\n        data = np.random.rand(20, 2)\n        Layer = Points\n        layer = Points(data, properties={\'values\': np.random.rand(20)})\n        writer = napari_write_points\n        extension = \'.csv\'\n        reader = partial(io.csv_to_layer_data, require_type=\'points\')\n    elif request.param == \'shapes\':\n        np.random.seed(0)\n        data = [\n            np.random.rand(2, 2),\n            np.random.rand(2, 2),\n            np.random.rand(6, 2),\n            np.random.rand(6, 2),\n            np.random.rand(2, 2),\n        ]\n        shape_type = [\'ellipse\', \'line\', \'path\', \'polygon\', \'rectangle\']\n        Layer = Shapes\n        layer = Shapes(data, shape_type=shape_type)\n        writer = napari_write_shapes\n        extension = \'.csv\'\n        reader = partial(io.csv_to_layer_data, require_type=\'shapes\')\n    else:\n        return None, None, None, None, None\n\n    layer_data = layer.as_layer_data_tuple()\n    return writer, layer_data, extension, reader, Layer\n\n\n@pytest.fixture\ndef layer_data_and_types():\n    """"""Fixture that provides some layers and filenames\n\n    Returns\n    -------\n    tuple\n        ``layers, layer_data, layer_types, filenames``\n\n        - layers: some image and points layers\n        - layer_data: same as above but in LayerData form\n        - layer_types: list of strings with type of layer\n        - filenames: the expected filenames with extensions for the layers.\n    """"""\n    layers = [\n        Image(np.random.rand(20, 20), name=\'ex_img\'),\n        Image(np.random.rand(20, 20)),\n        Points(np.random.rand(20, 2), name=\'ex_pts\'),\n        Points(\n            np.random.rand(20, 2), properties={\'values\': np.random.rand(20)}\n        ),\n    ]\n    extensions = [\'.tif\', \'.tif\', \'.csv\', \'.csv\']\n    layer_data = [l.as_layer_data_tuple() for l in layers]\n    layer_types = [layer._type_string for layer in layers]\n    filenames = [l.name + e for l, e in zip(layers, extensions)]\n    return layers, layer_data, layer_types, filenames\n\n\n@pytest.fixture(\n    params=[\n        \'image\',\n        \'labels\',\n        \'points\',\n        \'shapes\',\n        \'shapes-rectangles\',\n        \'vectors\',\n    ]\n)\ndef layer(request):\n    """"""Parameterized fixture that supplies a layer for testing.\n\n    Parameters\n    ----------\n    request : _pytest.fixtures.SubRequest\n        The pytest request object\n\n    Returns\n    -------\n    napari.layers.Layer\n        The desired napari Layer.\n    """"""\n    np.random.seed(0)\n    if request.param == \'image\':\n        data = np.random.rand(20, 20)\n        return Image(data)\n    elif request.param == \'labels\':\n        data = np.random.randint(10, size=(20, 20))\n        return Labels(data)\n    elif request.param == \'points\':\n        data = np.random.rand(20, 2)\n        return Points(data)\n    elif request.param == \'shapes\':\n        data = [\n            np.random.rand(2, 2),\n            np.random.rand(2, 2),\n            np.random.rand(6, 2),\n            np.random.rand(6, 2),\n            np.random.rand(2, 2),\n        ]\n        shape_type = [\'ellipse\', \'line\', \'path\', \'polygon\', \'rectangle\']\n        return Shapes(data, shape_type=shape_type)\n    elif request.param == \'shapes-rectangles\':\n        data = np.random.rand(7, 4, 2)\n        return Shapes(data)\n    elif request.param == \'vectors\':\n        data = np.random.rand(20, 2, 2)\n        return Vectors(data)\n    else:\n        return None\n\n\n@pytest.fixture()\ndef layers():\n    """"""Fixture that supplies a layers list for testing.\n\n    Returns\n    -------\n    napari.components.LayerList\n        The desired napari LayerList.\n    """"""\n    np.random.seed(0)\n    list_of_layers = [\n        Image(np.random.rand(20, 20)),\n        Labels(np.random.randint(10, size=(20, 2))),\n        Points(np.random.rand(20, 2)),\n        Shapes(np.random.rand(10, 2, 2)),\n        Vectors(np.random.rand(10, 2, 2)),\n    ]\n    return LayerList(list_of_layers)\n\n\n@pytest.fixture\ndef two_pngs():\n    return [image_fetcher.fetch(f\'data/{n}.png\') for n in (\'moon\', \'camera\')]\n\n\n@pytest.fixture\ndef rgb_png():\n    return [image_fetcher.fetch(\'data/astronaut.png\')]\n\n\n@pytest.fixture\ndef single_png():\n    return [image_fetcher.fetch(\'data/camera.png\')]\n\n\n@pytest.fixture\ndef irregular_images():\n    return [image_fetcher.fetch(f\'data/{n}.png\') for n in (\'camera\', \'coins\')]\n\n\n@pytest.fixture\ndef single_tiff():\n    return [image_fetcher.fetch(\'data/multipage.tif\')]\n'"
napari/types.py,2,"b'from functools import wraps\nfrom types import TracebackType\nfrom typing import Any, Callable, Dict, List, Tuple, Type, Union\n\nimport dask.array as da\nimport numpy as np\nimport vispy.color\n\ntry:\n    import zarr\nexcept ImportError:\n    zarr = None\n\n# This is a WOEFULLY inadequate stub for a duck-array type.\n# Mostly, just a placeholder for the concept of needing an ArrayLike type.\n# Ultimately, this should come from https://github.com/napari/image-types\n# and should probably be replaced by a typing.Protocol\nif zarr:\n    ArrayLike = Union[np.ndarray, da.Array, zarr.Array]\nelse:\n    ArrayLike = Union[np.ndarray, da.Array]\n\n# layer data may be: (data,) (data, meta), or (data, meta, layer_type)\n# using ""Any"" for the data type until ArrayLike is more mature.\nFullLayerData = Tuple[Any, Dict, str]\nLayerData = Union[Tuple[Any], Tuple[Any, Dict], FullLayerData]\n\nPathLike = Union[str, List[str]]\nReaderFunction = Callable[[PathLike], List[LayerData]]\nWriterFunction = Callable[[str, List[FullLayerData]], List[str]]\n\nExcInfo = Union[\n    Tuple[Type[BaseException], BaseException, TracebackType],\n    Tuple[None, None, None],\n]\n\n\ndef image_reader_to_layerdata_reader(\n    func: Callable[[PathLike], ArrayLike]\n) -> ReaderFunction:\n    """"""Convert a PathLike -> ArrayLike function to a PathLike -> LayerData.\n\n    Parameters\n    ----------\n    func : Callable[[PathLike], ArrayLike]\n        A function that accepts a string or list of strings, and returns an\n        ArrayLike.\n\n    Returns\n    -------\n    reader_function : Callable[[PathLike], List[LayerData]]\n        A function that accepts a string or list of strings, and returns data\n        as a list of LayerData: List[Tuple[ArrayLike]]\n    """"""\n\n    @wraps(func)\n    def reader_function(*args, **kwargs) -> List[LayerData]:\n        result = func(*args, **kwargs)\n        return [(result,)]\n\n    return reader_function\n\n\nValidColormapArg = Union[\n    str,\n    vispy.color.Colormap,\n    Tuple[str, vispy.color.Colormap],\n    Dict[str, vispy.color.Colormap],\n]\n'"
napari/view_layers.py,3,"b'from .viewer import Viewer\n\n\ndef view_image(\n    data=None,\n    *,\n    channel_axis=None,\n    rgb=None,\n    colormap=None,\n    contrast_limits=None,\n    gamma=1,\n    interpolation=\'nearest\',\n    rendering=\'mip\',\n    iso_threshold=0.5,\n    attenuation=0.5,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=1,\n    blending=None,\n    visible=True,\n    multiscale=None,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add an image layer.\n\n    Parameters\n    ----------\n    data : array or list of array\n        Image data. Can be N dimensional. If the last dimension has length\n        3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a\n        list and arrays are decreasing in shape then the data is treated as\n        a multiscale image.\n    channel_axis : int, optional\n        Axis to expand image along.\n    rgb : bool\n        Whether the image is rgb RGB or RGBA. If not specified by user and\n        the last dimension of the data has length 3 or 4 it will be set as\n        `True`. If `False` the image is interpreted as a luminance image.\n    colormap : str, vispy.Color.Colormap, tuple, dict, list\n        Colormaps to use for luminance images. If a string must be the name\n        of a supported colormap from vispy or matplotlib. If a tuple the\n        first value must be a string to assign as a name to a colormap and\n        the second item must be a Colormap. If a dict the key must be a\n        string to assign as a name to a colormap and the value must be a\n        Colormap. If a list then must be same length as the axis that is\n        being expanded as channels, and each colormap is applied to each new\n        image layer.\n    contrast_limits : list (2,)\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If not passed is calculated as the min and max of\n        the image. If list of lists then must be same length as the axis\n        that is being expanded and then each colormap is applied to each\n        image.\n    gamma : list, float\n        Gamma correction for determining colormap linearity. Defaults to 1.\n        If a list then must be same length as the axis that is being expanded\n        and then each entry in the list is applied to each image.\n    interpolation : str\n        Interpolation mode used by vispy. Must be one of our supported\n        modes.\n    rendering : str\n        Rendering mode used by vispy. Must be one of our supported\n        modes.\n    iso_threshold : float\n        Threshold for isosurface.\n    attenuation : float\n        Attenuation rate for attenuated maximum intensity projection.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. If not specified by\n        the user and if the data is a list of arrays that decrease in shape\n        then it will be taken to be multiscale. The first image in the list\n        should be the largest.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_image(\n        data=data,\n        channel_axis=channel_axis,\n        rgb=rgb,\n        multiscale=multiscale,\n        colormap=colormap,\n        contrast_limits=contrast_limits,\n        gamma=gamma,\n        interpolation=interpolation,\n        rendering=rendering,\n        iso_threshold=iso_threshold,\n        attenuation=attenuation,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n\n\ndef view_path(\n    path,\n    *,\n    stack=False,\n    plugin=None,\n    layer_type=None,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n    **kwargs,\n):\n    """"""Create a viewer and add a layer whose type will be determined by path.\n\n    Parameters\n    ----------\n    path : str or list of str\n        A filepath, directory, or URL (or a list of any) to open.\n    stack : bool, optional\n        If a list of strings is passed and ``stack`` is ``True``, then the\n        entire list will be passed to plugins.  It is then up to individual\n        plugins to know how to handle a list of paths.  If ``stack`` is\n        ``False``, then the ``path`` list is broken up and passed to plugin\n        readers one by one.  by default False.\n    plugin : str, optional\n        Name of a plugin to use.  If provided, will force ``path`` to be\n        read with the specified ``plugin``.  If the requested plugin cannot\n        read ``path``, an execption will be raised.\n    layer_type : str, optional\n        If provided, will force data read from ``path`` to be passed to the\n        corresponding ``add_<layer_type>`` method (along with any\n        additional) ``kwargs`` provided to this function.  This *may*\n        result in exceptions if the data returned from the path is not\n        compatible with the layer_type.\n    title : string, optional\n        The title of the viewer window. by default \'napari\'\n    ndisplay : {2, 3}, optional\n        Number of displayed dimensions, by default 2\n    order : tuple of int, optional\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3. by default None\n    axis_labels : list of str, optional\n        Dimension names. by default None\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n    **kwargs\n        All other keyword arguments will be passed on to the respective\n        ``add_layer`` method.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.open(\n        path=path, stack=stack, plugin=plugin, layer_type=layer_type, **kwargs\n    )\n    return viewer\n\n\ndef view_points(\n    data=None,\n    *,\n    properties=None,\n    symbol=\'o\',\n    size=10,\n    edge_width=1,\n    edge_color=""black"",\n    edge_color_cycle=None,\n    edge_colormap=\'viridis\',\n    edge_contrast_limits=None,\n    face_color=""white"",\n    face_color_cycle=None,\n    face_colormap=\'viridis\',\n    face_contrast_limits=None,\n    n_dimensional=False,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=1,\n    blending=\'translucent\',\n    visible=True,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add a points layer.\n\n    Parameters\n    ----------\n    data : array (N, D)\n        Coordinates for N points in D dimensions.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each point. Each property should be an array of length N,\n        where N is the number of points.\n    symbol : str\n        Symbol to be used for the point markers. Must be one of the\n        following: arrow, clobber, cross, diamond, disc, hbar, ring,\n        square, star, tailed_arrow, triangle_down, triangle_up, vbar, x.\n    size : float, array\n        Size of the point marker. If given as a scalar, all points are made\n        the same size. If given as an array, size must be the same\n        broadcastable to the same shape as the data.\n    edge_width : float\n        Width of the symbol edge in pixels.\n    edge_color : str, array-like\n        Color of the point marker border. Numeric color values should be RGB(A).\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set edge_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    face_color : str, array-like\n        Color of the point marker body. Numeric color values should be RGB(A).\n    face_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to face_color if a\n        categorical attribute is used color the vectors.\n    face_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set face_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    face_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    n_dimensional : bool\n        If True, renders points not just in central plane but also in all\n        n-dimensions according to specified point marker size.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n\n    Notes\n    -----\n    See vispy\'s marker visual docs for more details:\n    http://api.vispy.org/en/latest/visuals.html#vispy.visuals.MarkersVisual\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_points(\n        data=data,\n        properties=properties,\n        symbol=symbol,\n        size=size,\n        edge_width=edge_width,\n        edge_color=edge_color,\n        edge_color_cycle=edge_color_cycle,\n        edge_colormap=edge_colormap,\n        edge_contrast_limits=edge_contrast_limits,\n        face_color=face_color,\n        face_color_cycle=face_color_cycle,\n        face_colormap=face_colormap,\n        face_contrast_limits=face_contrast_limits,\n        n_dimensional=n_dimensional,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n\n\ndef view_labels(\n    data=None,\n    *,\n    num_colors=50,\n    properties=None,\n    seed=0.5,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=0.7,\n    blending=\'translucent\',\n    visible=True,\n    multiscale=None,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add a labels (or segmentation) layer.\n\n    An image-like layer where every pixel contains an integer ID\n    corresponding to the region it belongs to.\n\n    Using the viewer\'s label editing tools (painting, erasing) will\n    modify the input-array in-place.\n\n        To avoid this, pass a copy as follows:\n            viewer = napari.view_labels(data.copy(), name=""sample"")\n            # do some painting/editing\n\n        Get the painted labels as follows:\n            result = viewer.layers[""sample""].data\n\n    Parameters\n    ----------\n    data : array or list of array\n        Labels data as an array or multiscale.\n    num_colors : int\n        Number of unique colors to use in colormap.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each label. Each property should be an array of length\n        N, where N is the number of labels, and the first property corresponds to\n        background.\n    seed : float\n        Seed for colormap random generator.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. If not specified by\n        the user and if the data is a list of arrays that decrease in shape\n        then it will be taken to be multiscale. The first image in the list\n        should be the largest.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_labels(\n        data=data,\n        multiscale=multiscale,\n        num_colors=num_colors,\n        properties=properties,\n        seed=seed,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n\n\ndef view_shapes(\n    data=None,\n    *,\n    shape_type=\'rectangle\',\n    edge_width=1,\n    edge_color=\'black\',\n    face_color=\'white\',\n    z_index=0,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=0.7,\n    blending=\'translucent\',\n    visible=True,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add a shapes layer.\n\n    Parameters\n    ----------\n    data : list or array\n        List of shape data, where each element is an (N, D) array of the\n        N vertices of a shape in D dimensions. Can be an 3-dimensional\n        array if each shape has the same number of vertices.\n    shape_type : string or list\n        String of shape shape_type, must be one of ""{\'line\', \'rectangle\',\n        \'ellipse\', \'path\', \'polygon\'}"". If a list is supplied it must be\n        the same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    edge_width : float or list\n        Thickness of lines and edges. If a list is supplied it must be the\n        same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    edge_color : str, array-like\n        If string can be any color name recognized by vispy or hex value if\n        starting with `#`. If array-like must be 1-dimensional array with 3\n        or 4 elements. If a list is supplied it must be the same length as\n        the length of `data` and each element will be applied to each shape\n        otherwise the same value will be used for all shapes.\n    face_color : str, array-like\n        If string can be any color name recognized by vispy or hex value if\n        starting with `#`. If array-like must be 1-dimensional array with 3\n        or 4 elements. If a list is supplied it must be the same length as\n        the length of `data` and each element will be applied to each shape\n        otherwise the same value will be used for all shapes.\n    z_index : int or list\n        Specifier of z order priority. Shapes with higher z order are\n        displayed ontop of others. If a list is supplied it must be the\n        same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_shapes(\n        data=data,\n        shape_type=shape_type,\n        edge_width=edge_width,\n        edge_color=edge_color,\n        face_color=face_color,\n        z_index=z_index,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n\n\ndef view_surface(\n    data,\n    *,\n    colormap=\'gray\',\n    contrast_limits=None,\n    gamma=1,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=1,\n    blending=\'translucent\',\n    visible=True,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add a surface layer.\n\n    Parameters\n    ----------\n    data : 3-tuple of array\n        The first element of the tuple is an (N, D) array of vertices of\n        mesh triangles. The second is an (M, 3) array of int of indices\n        of the mesh triangles. The third element is the (K0, ..., KL, N)\n        array of values used to color vertices where the additional L\n        dimensions are used to color the same mesh with different values.\n    colormap : str, vispy.Color.Colormap, tuple, dict\n        Colormap to use for luminance images. If a string must be the name\n        of a supported colormap from vispy or matplotlib. If a tuple the\n        first value must be a string to assign as a name to a colormap and\n        the second item must be a Colormap. If a dict the key must be a\n        string to assign as a name to a colormap and the value must be a\n        Colormap.\n    contrast_limits : list (2,)\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If not passed is calculated as the min and max of\n        the image.\n    gamma : float\n        Gamma correction for determining colormap linearity. Defaults to 1.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_surface(\n        data,\n        colormap=colormap,\n        contrast_limits=contrast_limits,\n        gamma=gamma,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n\n\ndef view_vectors(\n    data,\n    *,\n    properties=None,\n    edge_width=1,\n    edge_color=\'red\',\n    edge_color_cycle=None,\n    edge_colormap=\'viridis\',\n    edge_contrast_limits=None,\n    length=1,\n    name=None,\n    metadata=None,\n    scale=None,\n    translate=None,\n    opacity=0.7,\n    blending=\'translucent\',\n    visible=True,\n    title=\'napari\',\n    ndisplay=2,\n    order=None,\n    axis_labels=None,\n    show=True,\n):\n    """"""Create a viewer and add a vectors layer.\n\n    Parameters\n    ----------\n    data : (N, 2, D) or (N1, N2, ..., ND, D) array\n        An (N, 2, D) array is interpreted as ""coordinate-like"" data and a\n        list of N vectors with start point and projections of the vector in\n        D dimensions. An (N1, N2, ..., ND, D) array is interpreted as\n        ""image-like"" data where there is a length D vector of the\n        projections at each pixel.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each vector. Each property should be an array of length N,\n        where N is the number of vectors.\n    edge_width : float\n        Width for all vectors in pixels.\n    length : float\n         Multiplicative factor on projections for length of all vectors.\n    edge_color : str\n        Color of all of the vectors.\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set vector color if a continuous attribute is used to set edge_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str\n        Dimension names.\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n\n    Returns\n    -------\n    viewer : :class:`napari.Viewer`\n        The newly-created viewer.\n    """"""\n    viewer = Viewer(\n        title=title,\n        ndisplay=ndisplay,\n        order=order,\n        axis_labels=axis_labels,\n        show=show,\n    )\n    viewer.add_vectors(\n        data,\n        properties=properties,\n        edge_width=edge_width,\n        edge_color=edge_color,\n        edge_color_cycle=edge_color_cycle,\n        edge_colormap=edge_colormap,\n        edge_contrast_limits=edge_contrast_limits,\n        length=length,\n        name=name,\n        metadata=metadata,\n        scale=scale,\n        translate=translate,\n        opacity=opacity,\n        blending=blending,\n        visible=visible,\n    )\n    return viewer\n'"
napari/viewer.py,0,"b'import os\nimport platform\nimport sys\nfrom os.path import dirname, join\n\nfrom qtpy.QtGui import QIcon\nfrom qtpy.QtWidgets import QApplication\n\nfrom ._qt.qt_main_window import Window\nfrom ._qt.qt_viewer import QtViewer\nfrom ._qt.threading import wait_for_workers_to_quit, create_worker\nfrom .components import ViewerModel\nfrom . import __version__\n\n\nclass Viewer(ViewerModel):\n    """"""Napari ndarray viewer.\n\n    Parameters\n    ----------\n    title : string, optional\n        The title of the viewer window. by default \'napari\'.\n    ndisplay : {2, 3}, optional\n        Number of displayed dimensions. by default 2.\n    order : tuple of int, optional\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3. by default None\n    axis_labels : list of str, optional\n        Dimension names. by default they are labeled with sequential numbers\n    show : bool, optional\n        Whether to show the viewer after instantiation. by default True.\n    """"""\n\n    # set _napari_app_id to False to avoid overwriting dock icon on windows\n    # set _napari_app_id to custom string to prevent grouping different base viewer\n    _napari_app_id = \'napari.napari.viewer.\' + str(__version__)\n\n    def __init__(\n        self,\n        title=\'napari\',\n        ndisplay=2,\n        order=None,\n        axis_labels=None,\n        show=True,\n    ):\n        # instance() returns the singleton instance if it exists, or None\n        app = QApplication.instance()\n        # if None, raise a RuntimeError with the appropriate message\n        if app is None:\n            message = (\n                ""napari requires a Qt event loop to run. To create one, ""\n                ""try one of the following: \\n""\n                ""  - use the `napari.gui_qt()` context manager. See ""\n                ""https://github.com/napari/napari/tree/master/examples for""\n                "" usage examples.\\n""\n                ""  - In IPython or a local Jupyter instance, use the ""\n                ""`%gui qt` magic command.\\n""\n                ""  - Launch IPython with the option `--gui=qt`.\\n""\n                ""  - (recommended) in your IPython configuration file, add""\n                "" or uncomment the line `c.TerminalIPythonApp.gui = \'qt\'`.""\n                "" Then, restart IPython.""\n            )\n            raise RuntimeError(message)\n\n        # For perfmon we need a special QApplication. If using gui_qt we already\n        # have the special one, and this is a noop. When running inside IPython\n        # or Jupyter however this is where we switch out the QApplication.\n        if os.getenv(""NAPARI_PERFMON"", ""0"") != ""0"":\n            from ._qt.qt_event_timing import convert_app_for_timing\n\n            app = convert_app_for_timing(app)\n\n        if (\n            platform.system() == ""Windows""\n            and not getattr(sys, \'frozen\', False)\n            and self._napari_app_id\n        ):\n            import ctypes\n\n            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(\n                self._napari_app_id\n            )\n\n        logopath = join(dirname(__file__), \'resources\', \'logo.png\')\n        app.setWindowIcon(QIcon(logopath))\n\n        # see docstring of `wait_for_workers_to_quit` for caveats on killing\n        # workers at shutdown.\n        app.aboutToQuit.connect(wait_for_workers_to_quit)\n\n        super().__init__(\n            title=title,\n            ndisplay=ndisplay,\n            order=order,\n            axis_labels=axis_labels,\n        )\n        qt_viewer = QtViewer(self)\n        self.window = Window(qt_viewer, show=show)\n\n    def update_console(self, variables):\n        """"""Update console\'s namespace with desired variables.\n\n        Parameters\n        ----------\n        variables : dict, str or list/tuple of str\n            The variables to inject into the console\'s namespace.  If a dict, a\n            simple update is done.  If a str, the string is assumed to have\n            variable names separated by spaces.  A list/tuple of str can also\n            be used to give the variable names.  If just the variable names are\n            give (list/tuple/str) then the variable values looked up in the\n            callers frame.\n        """"""\n        if self.window.qt_viewer.console is None:\n            return\n        else:\n            self.window.qt_viewer.console.push(variables)\n\n    def screenshot(self, path=None, *, canvas_only=True):\n        """"""Take currently displayed screen and convert to an image array.\n\n        Parameters\n        ----------\n        path : str\n            Filename for saving screenshot image.\n        canvas_only : bool\n            If True, screenshot shows only the image display canvas, and\n            if False include the napari viewer frame in the screenshot,\n            By default, True.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region.\n        """"""\n        if canvas_only:\n            image = self.window.qt_viewer.screenshot(path=path)\n        else:\n            image = self.window.screenshot(path=path)\n        return image\n\n    def update(self, func, *args, **kwargs):\n        import warnings\n\n        warnings.warn(\n            ""Viewer.update() is deprecated, use ""\n            ""create_worker(func, *args, **kwargs) instead"",\n            DeprecationWarning,\n        )\n        return create_worker(func, *args, **kwargs, _start_thread=True)\n\n    def show(self):\n        """"""Resize, show, and raise the viewer window.""""""\n        self.window.show()\n\n    def close(self):\n        """"""Close the viewer window.""""""\n        self.window.close()\n\n    def __str__(self):\n        """"""Simple string representation""""""\n        return f\'napari.Viewer: {self.title}\'\n'"
docs/release/generate_release_notes.py,0,"b'""""""Generate the release notes automatically from Github pull requests.\nStart with:\n```\nexport GH_TOKEN=<your-gh-api-token>\n```\nThen, for to include everything from a certain release to master:\n```\npython /path/to/generate_release_notes.py v0.14.0 master --version 0.15.0\n```\nOr two include only things between two releases:\n```\npython /path/to/generate_release_notes.py v.14.2 v0.14.3 --version 0.14.3\n```\nYou should probably redirect the output with:\n```\npython /path/to/generate_release_notes.py [args] | tee release_notes.md\n```\nYou\'ll require PyGitHub and tqdm, which you can install with:\n```\npip install -e "".[release]""\n```\nReferences\nhttps://github.com/scikit-image/scikit-image/blob/master/tools/generate_release_notes.py\nhttps://github.com/scikit-image/scikit-image/issues/3404\nhttps://github.com/scikit-image/scikit-image/issues/3405\n""""""\nimport os\nimport argparse\nfrom datetime import datetime\nfrom collections import OrderedDict\nfrom warnings import warn\n\nfrom github import Github\n\ntry:\n    from tqdm import tqdm\nexcept ImportError:\n    warn(\n        \'tqdm not installed. This script takes approximately 5 minutes \'\n        \'to run. To view live progressbars, please install tqdm. \'\n        \'Otherwise, be patient.\'\n    )\n\n    def tqdm(i, **kwargs):\n        return i\n\n\nGH = ""https://github.com""\nGH_USER = \'napari\'\nGH_REPO = \'napari\'\nGH_TOKEN = os.environ.get(\'GH_TOKEN\')\nif GH_TOKEN is None:\n    raise RuntimeError(\n        ""It is necessary that the environment variable `GH_TOKEN` ""\n        ""be set to avoid running into problems with rate limiting. ""\n        ""One can be acquired at https://github.com/settings/tokens.\\n\\n""\n        ""You do not need to select any permission boxes while generating ""\n        ""the token.""\n    )\n\ng = Github(GH_TOKEN)\nrepository = g.get_repo(f\'{GH_USER}/{GH_REPO}\')\n\n\nparser = argparse.ArgumentParser(usage=__doc__)\nparser.add_argument(\'from_commit\', help=\'The starting tag.\')\nparser.add_argument(\'to_commit\', help=\'The head branch.\')\nparser.add_argument(\n    \'--version\', help=""Version you\'re about to release."", default=\'0.2.0\'\n)\n\nargs = parser.parse_args()\n\nfor tag in repository.get_tags():\n    if tag.name == args.from_commit:\n        previous_tag = tag\n        break\nelse:\n    raise RuntimeError(f\'Desired tag ({args.from_commit}) not found\')\n\n# For some reason, go get the github commit from the commit to get\n# the correct date\ngithub_commit = previous_tag.commit.commit\nprevious_tag_date = datetime.strptime(\n    github_commit.last_modified, \'%a, %d %b %Y %H:%M:%S %Z\'\n)\n\n\nall_commits = list(\n    tqdm(\n        repository.get_commits(sha=args.to_commit, since=previous_tag_date),\n        desc=f\'Getting all commits between {args.from_commit} \'\n        f\'and {args.to_commit}\',\n    )\n)\nall_hashes = set(c.sha for c in all_commits)\n\n\ndef add_to_users(users, new_user):\n    if new_user.name is None:\n        users[new_user.login] = new_user.login\n    else:\n        users[new_user.login] = new_user.name\n\n\nauthors = set()\ncommitters = set()\nreviewers = set()\nusers = {}\n\nfor commit in tqdm(all_commits, desc=""Getting commiters and authors""):\n    if commit.committer is not None:\n        add_to_users(users, commit.committer)\n        committers.add(commit.committer.login)\n    if commit.author is not None:\n        add_to_users(users, commit.author)\n        authors.add(commit.author.login)\n\n# remove these bots.\ncommitters.discard(""web-flow"")\nauthors.discard(""azure-pipelines-bot"")\n\nhighlights = OrderedDict()\n\nhighlights[\'Highlights\'] = {}\nhighlights[\'New Features\'] = {}\nhighlights[\'Improvements\'] = {}\nhighlights[\'Bug Fixes\'] = {}\nhighlights[\'API Changes\'] = {}\nhighlights[\'Deprecations\'] = {}\nhighlights[\'Build Tools\'] = {}\nother_pull_requests = {}\n\nfor pull in tqdm(\n    g.search_issues(\n        f\'repo:{GH_USER}/{GH_REPO} \'\n        f\'merged:>{previous_tag_date.isoformat()} \'\n        \'sort:created-asc\'\n    ),\n    desc=\'Pull Requests...\',\n):\n    pr = repository.get_pull(pull.number)\n    if pr.merge_commit_sha in all_hashes:\n        summary = pull.title\n        for review in pr.get_reviews():\n            if review.user is not None:\n                add_to_users(users, review.user)\n                reviewers.add(review.user.login)\n        for key, key_dict in highlights.items():\n            pr_title_prefix = (key + \': \').lower()\n            if summary.lower().startswith(pr_title_prefix):\n                key_dict[pull.number] = {\n                    \'summary\': summary[len(pr_title_prefix) :]\n                }\n                break\n        else:\n            other_pull_requests[pull.number] = {\'summary\': summary}\n\n\n# add Other PRs to the ordered dict to make doc generation easier.\nhighlights[\'Other Pull Requests\'] = other_pull_requests\n\n\n# Now generate the release notes\ntitle = f\'# napari {args.version}\'\nprint(title)\n\nprint(\n    f""""""\nWe\'re happy to announce the release of napari {args.version}!\nnapari is a fast, interactive, multi-dimensional image viewer for Python.\nIt\'s designed for browsing, annotating, and analyzing large multi-dimensional\nimages. It\'s built on top of Qt (for the GUI), vispy (for performant GPU-based\nrendering), and the scientific Python stack (numpy, scipy).\n""""""\n)\n\nprint(\n    """"""\nFor more information, examples, and documentation, please visit our website:\nhttps://github.com/napari/napari\n""""""\n)\n\nfor section, pull_request_dicts in highlights.items():\n    print(f\'## {section}\\n\')\n    if len(pull_request_dicts.items()) == 0:\n        print()\n    for number, pull_request_info in pull_request_dicts.items():\n        print(f\'- {pull_request_info[""summary""]} (#{number})\')\n\n\ncontributors = OrderedDict()\n\ncontributors[\'authors\'] = authors\ncontributors[\'reviewers\'] = reviewers\n# ignore committers\n# contributors[\'committers\'] = committers\n\nfor section_name, contributor_set in contributors.items():\n    print()\n    if None in contributor_set:\n        contributor_set.remove(None)\n    committer_str = (\n        f\'## {len(contributor_set)} {section_name} added to this \'\n        \'release (alphabetical)\'\n    )\n    print(committer_str)\n    print()\n\n    for c in sorted(contributor_set, key=lambda x: users[x].lower()):\n        commit_link = f""{GH}/{GH_USER}/{GH_REPO}/commits?author={c}""\n        print(f""- [{users[c]}]({commit_link}) - @{c}"")\n    print()\n'"
docs/source/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nimport re\nimport fileinput\n\nsys.path.insert(0, os.path.abspath(\'../..\'))\nfrom napari import __version__  # noqa: E402\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'napari\'\ncopyright = \'2020, napari contributors\'\nauthor = \'napari contributors\'\n\nrelease = __version__\nversion = __version__\nCONFDIR = os.path.dirname(__file__)\n\n\ndef clean_release_notes():\n\n    release_rst = """"""Release Notes\n=============\n\n.. toctree::\n   :maxdepth: 1\n   :glob:\n\n""""""\n    dirname = os.path.join(CONFDIR, \'release\')\n    for rel in sorted(\n        os.listdir(dirname),\n        key=lambda s: list(map(int, re.findall(r\'\\d+\', s))),\n        reverse=True,\n    ):\n        for line in fileinput.input(os.path.join(dirname, rel), inplace=True):\n            line = re.sub(\n                r\'#(\\d+)\',\n                r\'[#\\1](<https://github.com/napari/napari/issues/\\1>)\',\n                line,\n            )\n            print(line, end=\'\')\n        release_rst += \'   release/\' + rel.replace(\'.md\', \'\\n\')\n    with open(os.path.join(CONFDIR, \'releases.rst\'), \'w\') as f:\n        f.write(release_rst)\n\n\nclean_release_notes()\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.napoleon\',\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.intersphinx\',\n    \'recommonmark\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\nsource_suffix = [\'.rst\', \'.md\']\n\n# Custom parsers of source files.\nsource_parsers = {\'.md\': \'recommonmark.parser.CommonMarkParser\'}\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\n\n# intersphinx allows us to link directly to other repos sphinxdocs.\n# https://www.sphinx-doc.org/en/master/usage/extensions/intersphinx.html\nintersphinx_mapping = {\n    \'python\': (\'https://docs.python.org/3\', None),\n    \'numpy\': (\'http://docs.scipy.org/doc/numpy/\', None),\n    \'napari_plugin_engine\': (\n        \'https://napari-plugin-engine.readthedocs.io/en/latest/\',\n        \'https://napari-plugin-engine.readthedocs.io/en/latest/objects.inv\',\n    ),\n    # \'scipy\': (\'http://docs.scipy.org/doc/scipy/reference/\', None),\n}\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\nhtml_logo = ""img/napari_logo.png""\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = []\n\n\n# -- Extension configuration -------------------------------------------------\n\n# add_module_names = False avoids showing the full path to a function or class\n# for example:\n# napari.layers.points.keybindings.activate_add_mode(layer)\n# becomes\n# activate_add_mode\n# (we can show the full module path elsewhere on the page)\n\nadd_module_names = False\n\n# -- Options for todo extension ----------------------------------------------\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n'"
napari/_qt/__init__.py,0,"b'from .qt_range_slider import QHRangeSlider, QVRangeSlider\nfrom .event_loop import gui_qt\nfrom ..resources import import_resources\n\nimport_resources()\n'"
napari/_qt/_constants.py,0,"b'from ..utils.misc import StringEnum\nfrom enum import auto\n\n\nclass LoopMode(StringEnum):\n    """"""Looping mode for animating an axis.\n\n    LoopMode.ONCE\n        Animation will stop once movie reaches the max frame (if fps > 0) or\n        the first frame (if fps < 0).\n    LoopMode.LOOP\n        Movie will return to the first frame after reaching the last frame,\n        looping continuously until stopped.\n    LoopMode.BACK_AND_FORTH\n        Movie will loop continuously until stopped, reversing direction when\n        the maximum or minimum frame has been reached.\n    """"""\n\n    ONCE = auto()\n    LOOP = auto()\n    BACK_AND_FORTH = auto()\n'"
napari/_qt/event_loop.py,0,"b'import os\nimport sys\nfrom contextlib import contextmanager\nfrom os.path import dirname, join\n\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtGui import QPixmap\nfrom qtpy.QtWidgets import QApplication, QSplashScreen\n\n\ndef _create_application(argv) -> QApplication:\n    """"""Create our QApplication.\n\n    Notes\n    -----\n\n    We substitute QApplicationWithTiming when using perfmon.\n\n    Note that in Viewer we call convert_app_for_timing() which will create a\n    QApplicationWithTiming. However that\'s only for IPython/Jupyter. When using\n    gui_qt we need to create it up front here before any QWidget objects are\n    created, like the splash screen.\n    """"""\n    if os.getenv(""NAPARI_PERFMON"", ""0"") != ""0"":\n        from .qt_event_timing import QApplicationWithTiming\n\n        return QApplicationWithTiming(argv)\n    else:\n        return QApplication(argv)\n\n\n@contextmanager\ndef gui_qt(*, startup_logo=False):\n    """"""Start a Qt event loop in which to run the application.\n\n    Parameters\n    ----------\n    startup_logo : bool\n        Show a splash screen with the napari logo during startup.\n\n    Notes\n    -----\n    This context manager is not needed if running napari within an interactive\n    IPython session. In this case, use the ``%gui qt`` magic command, or start\n    IPython with the Qt GUI event loop enabled by default by using\n    ``ipython --gui=qt``.\n    """"""\n    splash_widget = None\n    app = QApplication.instance()\n    if not app:\n        # automatically determine monitor DPI.\n        # Note: this MUST be set before the QApplication is instantiated\n        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)\n        # if this is the first time the Qt app is being instantiated, we set\n        # the name, so that we know whether to raise_ in Window.show()\n        app = _create_application(sys.argv)\n        app.setApplicationName(\'napari\')\n        if startup_logo:\n            logopath = join(dirname(__file__), \'..\', \'resources\', \'logo.png\')\n            pm = QPixmap(logopath).scaled(\n                360, 360, Qt.KeepAspectRatio, Qt.SmoothTransformation\n            )\n            splash_widget = QSplashScreen(pm)\n            splash_widget.show()\n    yield app\n    # if the application already existed before this function was called,\n    # there\'s no need to start it again.  By avoiding unnecessary calls to\n    # ``app.exec_``, we avoid blocking.\n    if app.applicationName() == \'napari\':\n        if splash_widget and startup_logo:\n            splash_widget.close()\n        app.exec_()\n'"
napari/_qt/qt_about.py,0,"b'from qtpy import QtGui\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import (\n    QVBoxLayout,\n    QTextEdit,\n    QDialog,\n    QLabel,\n    QPushButton,\n    QHBoxLayout,\n)\n\nfrom ..utils import sys_info, citation_text\n\n\nclass QtAbout(QDialog):\n    """"""Qt dialog window for displaying \'About napari\' information.\n\n    Attributes\n    ----------\n    citationCopyButton : napari._qt.qt_about.QtCopyToClipboardButton\n        Button to copy citation information to the clipboard.\n    citationTextBox : qtpy.QtWidgets.QTextEdit\n        Text box containing napari citation information.\n    citation_layout : qtpy.QtWidgets.QHBoxLayout\n        Layout widget for napari citation information.\n    infoCopyButton : napari._qt.qt_about.QtCopyToClipboardButton\n        Button to copy napari version information to the clipboard.\n    info_layout : qtpy.QtWidgets.QHBoxLayout\n        Layout widget for napari version information.\n    infoTextBox : qtpy.QtWidgets.QTextEdit\n        Text box containing napari version information.\n    layout : qtpy.QtWidgets.QVBoxLayout\n        Layout widget for the entire \'About napari\' dialog.\n    """"""\n\n    def __init__(self):\n        super().__init__()\n\n        self.layout = QVBoxLayout()\n\n        # Description\n        title_label = QLabel(\n            ""<b>napari: a multi-dimensional image viewer for python</b>""\n        )\n        title_label.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.layout.addWidget(title_label)\n\n        # Add information\n        self.infoTextBox = QTextEdit()\n        self.infoTextBox.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.infoTextBox.setLineWrapMode(QTextEdit.NoWrap)\n        # Add text copy button\n        self.infoCopyButton = QtCopyToClipboardButton(self.infoTextBox)\n        self.info_layout = QHBoxLayout()\n        self.info_layout.addWidget(self.infoTextBox, 1)\n        self.info_layout.addWidget(self.infoCopyButton, 0, Qt.AlignTop)\n        self.info_layout.setAlignment(Qt.AlignTop)\n        self.layout.addLayout(self.info_layout)\n\n        self.infoTextBox.setText(sys_info(as_html=True))\n        self.infoTextBox.setMinimumSize(\n            self.infoTextBox.document().size().width() + 19,\n            min(self.infoTextBox.document().size().height() + 10, 500),\n        )\n\n        self.layout.addWidget(QLabel(\'<b>citation information:</b>\'))\n        self.citationTextBox = QTextEdit(citation_text)\n        self.citationTextBox.setFixedHeight(64)\n        self.citationCopyButton = QtCopyToClipboardButton(self.citationTextBox)\n        self.citation_layout = QHBoxLayout()\n        self.citation_layout.addWidget(self.citationTextBox, 1)\n        self.citation_layout.addWidget(self.citationCopyButton, 0, Qt.AlignTop)\n        self.layout.addLayout(self.citation_layout)\n\n        self.setLayout(self.layout)\n\n    @staticmethod\n    def showAbout(qt_viewer):\n        """"""Display the \'About napari\' dialog box.\n\n        Paramters\n        ---------\n        qt_viewer : QtViewer\n            QtViewer instance that the `About napari` dialog box belongs to.\n        """"""\n        d = QtAbout()\n        d.setObjectName(\'QtAbout\')\n        d.setStyleSheet(qt_viewer.styleSheet())\n        d.setWindowTitle(\'About\')\n        d.setWindowModality(Qt.ApplicationModal)\n        d.exec_()\n\n\nclass QtCopyToClipboardButton(QPushButton):\n    """"""Button to copy text box information to the clipboard.\n\n    Parameters\n    ----------\n    text_edit : qtpy.QtWidgets.QTextEdit\n        The text box contents linked to copy to clipboard button.\n\n    Attributes\n    ----------\n    text_edit : qtpy.QtWidgets.QTextEdit\n        The text box contents linked to copy to clipboard button.\n    """"""\n\n    def __init__(self, text_edit):\n        super().__init__()\n        self.setObjectName(""QtCopyToClipboardButton"")\n        self.text_edit = text_edit\n        self.setToolTip(""Copy to clipboard"")\n        self.clicked.connect(self.copyToClipboard)\n\n    def copyToClipboard(self):\n        """"""Copy text to the clipboard.""""""\n        cb = QtGui.QGuiApplication.clipboard()\n        cb.setText(str(self.text_edit.toPlainText()))\n'"
napari/_qt/qt_about_key_bindings.py,0,"b'from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import (\n    QDialog,\n    QVBoxLayout,\n    QHBoxLayout,\n    QTextEdit,\n    QComboBox,\n)\nfrom collections import OrderedDict\nimport napari\nfrom ..utils.interactions import get_key_bindings_summary\n\n\nclass QtAboutKeyBindings(QDialog):\n    """"""Qt dialog window for displaying keybinding information.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    key_bindings_strs : collections.OrderedDict\n        Ordered dictionary of hotkey shortcuts and associated key bindings.\n        Dictionary keys include:\n        - \'All active key bindings\'\n        - \'Image layer\'\n        - \'Labels layer\'\n        - \'Points layer\'\n        - \'Shapes layer\'\n        - \'Surface layer\'\n        - \'Vectors layer\'\n    layout : qtpy.QtWidgets.QVBoxLayout\n        Layout of the widget.\n    layerTypeComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown menu to select layer type.\n    textEditBox : qtpy.QtWidgets.QTextEdit\n        Text box widget containing table of key bindings information.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    ALL_ACTIVE_KEYBINDINGS = \'All active key bindings\'\n\n    def __init__(self, viewer, parent=None):\n        super().__init__(parent=parent)\n\n        self.viewer = viewer\n        self.layout = QVBoxLayout()\n\n        self.setWindowTitle(\'Keybindings\')\n        self.setWindowModality(Qt.NonModal)\n        self.setLayout(self.layout)\n\n        # stacked key bindings widgets\n        self.textEditBox = QTextEdit()\n        self.textEditBox.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.textEditBox.setMinimumWidth(360)\n        # Can switch to a normal dict when our minimum Python is 3.7\n        self.key_bindings_strs = OrderedDict()\n        self.key_bindings_strs[self.ALL_ACTIVE_KEYBINDINGS] = \'\'\n        col = self.viewer.palette[\'secondary\']\n        layers = [\n            napari.layers.Image,\n            napari.layers.Labels,\n            napari.layers.Points,\n            napari.layers.Shapes,\n            napari.layers.Surface,\n            napari.layers.Vectors,\n        ]\n        for layer in layers:\n            if len(layer.class_keymap) == 0:\n                text = \'No key bindings\'\n            else:\n                text = get_key_bindings_summary(layer.class_keymap, col=col)\n            self.key_bindings_strs[f""{layer.__name__} layer""] = text\n\n        # layer type selection\n        self.layerTypeComboBox = QComboBox()\n        self.layerTypeComboBox.addItems(list(self.key_bindings_strs))\n        self.layerTypeComboBox.activated[str].connect(self.change_layer_type)\n        self.layerTypeComboBox.setCurrentText(self.ALL_ACTIVE_KEYBINDINGS)\n        # self.change_layer_type(current_layer)\n        layer_type_layout = QHBoxLayout()\n        layer_type_layout.setContentsMargins(10, 5, 0, 0)\n        layer_type_layout.addWidget(self.layerTypeComboBox)\n        layer_type_layout.addStretch(1)\n        layer_type_layout.setSpacing(0)\n        self.layout.addLayout(layer_type_layout)\n        self.layout.addWidget(self.textEditBox, 1)\n\n        self.viewer.events.active_layer.connect(self.update_active_layer)\n        self.viewer.events.palette.connect(self.update_active_layer)\n        self.update_active_layer()\n\n    def change_layer_type(self, text):\n        """"""Change layer type selected in dropdown menu.\n\n        Parameters\n        ----------\n        text : str\n            Dictionary key to access key bindings associated with the layer.\n            Available keys include:\n            - \'All active key bindings\'\n            - \'Image layer\'\n            - \'Labels layer\'\n            - \'Points layer\'\n            - \'Shapes layer\'\n            - \'Surface layer\'\n            - \'Vectors layer\'\n        """"""\n        self.textEditBox.setHtml(self.key_bindings_strs[text])\n\n    def update_active_layer(self, event=None):\n        """"""Update the active layer and display key bindings for that layer type.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        col = self.viewer.palette[\'secondary\']\n        # Add class and instance viewer key bindings\n        text = get_key_bindings_summary(self.viewer.active_keymap, col=col)\n\n        # Update layer speficic key bindings if all active are displayed\n        self.key_bindings_strs[self.ALL_ACTIVE_KEYBINDINGS] = text\n        if self.layerTypeComboBox.currentText() == self.ALL_ACTIVE_KEYBINDINGS:\n            self.textEditBox.setHtml(text)\n'"
napari/_qt/qt_color_dialog.py,15,"b'import re\nfrom typing import Optional, Union\n\nimport numpy as np\nfrom qtpy.QtCore import Qt, Signal, Slot, QEvent\nfrom qtpy.QtGui import QColor, QKeyEvent\nfrom qtpy.QtWidgets import (\n    QColorDialog,\n    QCompleter,\n    QFrame,\n    QHBoxLayout,\n    QLineEdit,\n    QVBoxLayout,\n    QWidget,\n)\n\nfrom ..layers.utils.color_transformations import ColorType\nfrom ..utils.colormaps.standardize_color import (\n    hex_to_name,\n    rgb_to_hex,\n    transform_color,\n)\nfrom .qt_modal import QtPopup\nfrom vispy.color import get_color_dict\n\n# matches any 3- or 4-tuple of int or float, with or without parens\n# captures the numbers into groups.\n# this is used to allow users to enter colors as e.g.: ""(1, 0.7, 0)""\nrgba_regex = re.compile(\n    r""\\(?([\\d.]+),\\s*([\\d.]+),\\s*([\\d.]+),?\\s*([\\d.]+)?\\)?""\n)\n\nTRANSPARENT = np.array([0, 0, 0, 0], np.float32)\nAnyColorType = Union[ColorType, QColor]\n\n\nclass QColorSwatchEdit(QWidget):\n    """"""A widget that combines a QColorSwatch with a QColorLineEdit.\n\n    emits a color_changed event with a 1x4 numpy array when the current color\n    changes.  Note, the ""model"" for the current color is the ``_color``\n    attribute on the QColorSwatch.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        parent widget, by default None\n    initial_color : AnyColorType, optional\n        Starting color, by default None\n    tooltip : str, optional\n        Tooltip when hovering on the swatch,\n        by default \'click to set color\'\n\n    Attributes\n    ----------\n    line_edit : QColorLineEdit\n        An instance of QColorLineEdit, which takes hex, rgb, or autocompletes\n        common color names.  On invalid input, this field will return to the\n        previous color value.\n    color_swatch : QColorSwatch\n        The square that shows the current color, and can be clicked to show a\n        color dialog.\n    color : np.ndarray\n        The current color (just an alias for the colorSwatch.color)\n\n    Signals\n    -------\n    color_changed : np.ndarray\n        Emits the new color when the current color changes.\n    """"""\n\n    color_changed = Signal(np.ndarray)\n\n    def __init__(\n        self,\n        parent: Optional[QWidget] = None,\n        *,\n        initial_color: Optional[AnyColorType] = None,\n        tooltip: Optional[str] = None,\n    ):\n        super().__init__(parent=parent)\n        self.setObjectName(\'QColorSwatchEdit\')\n\n        layout = QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(6)\n        self.setLayout(layout)\n\n        self.line_edit = QColorLineEdit(self)\n        self.line_edit.editingFinished.connect(self._on_line_edit_edited)\n\n        self.color_swatch = QColorSwatch(self, tooltip=tooltip)\n        self.color_swatch.color_changed.connect(self._on_swatch_changed)\n        self.setColor = self.color_swatch.setColor\n        if initial_color is not None:\n            self.setColor(initial_color)\n\n        layout.addWidget(self.color_swatch)\n        layout.addWidget(self.line_edit)\n\n    @property\n    def color(self):\n        """"""Return the current color.""""""\n        return self.color_swatch.color\n\n    def _on_line_edit_edited(self):\n        """"""When the user hits enter or loses focus on the LineEdit widget.""""""\n        text = self.line_edit.text()\n        rgb_match = rgba_regex.match(text)\n        if rgb_match:\n            text = [float(x) for x in rgb_match.groups() if x]\n        self.color_swatch.setColor(text)\n\n    @Slot(np.ndarray)\n    def _on_swatch_changed(self, color: np.ndarray):\n        """"""Receive QColorSwatch change event, update the lineEdit, re-emit.""""""\n        self.line_edit.setText(color)\n        self.color_changed.emit(color)\n\n\nclass QColorSwatch(QFrame):\n    """"""A QFrame that displays a color and can be clicked to show a QColorPopup.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        parent widget, by default None\n    tooltip : Optional[str], optional\n        Tooltip when hovering on swatch,\n        by default \'click to set color\'\n    initial_color : ColorType, optional\n        initial color, by default will be transparent\n\n    Attributes\n    ----------\n    color : np.ndarray\n        The current color\n\n    Signals\n    -------\n    color_changed : np.ndarray\n        Emits the new color when the current color changes.\n    """"""\n\n    color_changed = Signal(np.ndarray)\n\n    def __init__(\n        self,\n        parent: Optional[QWidget] = None,\n        tooltip: Optional[str] = None,\n        initial_color: Optional[ColorType] = None,\n    ):\n        super().__init__(parent)\n        self.setObjectName(\'colorSwatch\')\n        self.setToolTip(tooltip or \'click to set color\')\n        self.setCursor(Qt.PointingHandCursor)\n\n        self.color_changed.connect(self._update_swatch_style)\n        self._color: np.ndarray = TRANSPARENT\n        if initial_color is not None:\n            self.setColor(initial_color)\n\n    @property\n    def color(self):\n        """"""Return the current color""""""\n        return self._color\n\n    @Slot(np.ndarray)\n    def _update_swatch_style(self, color: np.ndarray) -> None:\n        """"""Convert the current color to rgba() string and update appearance.""""""\n        rgba = f\'rgba({"","".join(map(lambda x: str(int(x*255)), self._color))})\'\n        self.setStyleSheet(\'#colorSwatch {background-color: \' + rgba + \';}\')\n\n    def mouseReleaseEvent(self, event: QEvent):\n        """"""Show QColorPopup picker when the user clicks on the swatch.""""""\n        if event.button() == Qt.LeftButton:\n            initial = QColor(*(255 * self._color).astype(\'int\'))\n            popup = QColorPopup(self, initial)\n            popup.colorSelected.connect(self.setColor)\n            popup.show_right_of_mouse()\n\n    def setColor(self, color: AnyColorType) -> None:\n        """"""Set the color of the swatch.\n\n        Parameters\n        ----------\n        color : ColorType\n            Can be any ColorType recognized by our\n            utils.colormaps.standardize_color.transform_color function.\n        """"""\n        if isinstance(color, QColor):\n            _color = (np.array(color.getRgb()) / 255).astype(np.float32)\n        else:\n            try:\n                _color = transform_color(color)[0]\n            except ValueError:\n                return self.color_changed.emit(self._color)\n        emit = np.any(self._color != _color)\n        self._color = _color\n        if emit or np.all(_color == TRANSPARENT):\n            self.color_changed.emit(_color)\n\n\nclass QColorLineEdit(QLineEdit):\n    """"""A LineEdit that takes hex, rgb, or autocompletes common color names.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget, by default None\n    """"""\n\n    def __init__(self, parent=None):\n        super().__init__(parent)\n        self._compl = QCompleter(list(get_color_dict()) + [\'transparent\'])\n        self._compl.setCompletionMode(QCompleter.InlineCompletion)\n        self.setCompleter(self._compl)\n        self.setTextMargins(2, 2, 2, 2)\n\n    def setText(self, color: ColorType):\n        """"""Set the text of the lineEdit using any ColorType.\n\n        Colors will be converted to standard SVG spec names if possible,\n        or shown as #RGBA hex if not.\n\n        Parameters\n        ----------\n        color : ColorType\n            Can be any ColorType recognized by our\n            utils.colormaps.standardize_color.transform_color function.\n        """"""\n        _rgb = transform_color(color)[0]\n        _hex = rgb_to_hex(_rgb)[0]\n        super().setText(hex_to_name.get(_hex, _hex))\n\n\nclass CustomColorDialog(QColorDialog):\n    def __init__(self, parent=None):\n        super().__init__(parent=parent)\n        self.setObjectName(\'CustomColorDialog\')\n\n    def keyPressEvent(self, event: QEvent):\n        event.ignore()\n\n\nclass QColorPopup(QtPopup):\n    """"""A QColorDialog inside of our QtPopup.\n\n    Allows all of the show methods of QtPopup (like show relative to mouse).\n    Passes through signals from the ColorDialogm, and handles some keypress\n    events.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget. by default None\n    initial_color : AnyColorType, optional\n        The initial color set in the color dialog, by default None\n\n    Attributes\n    ----------\n    color_dialog : CustomColorDialog\n        The main color dialog in the popup\n    """"""\n\n    currentColorChanged = Signal(QColor)\n    colorSelected = Signal(QColor)\n\n    def __init__(\n        self, parent: QWidget = None, initial_color: AnyColorType = None\n    ) -> None:\n        super().__init__(parent)\n        self.setObjectName(\'QtColorPopup\')\n        self.color_dialog = CustomColorDialog(self)\n\n        # native dialog doesn\'t get added to the QtPopup frame\n        # so more would need to be done to use it\n        self.color_dialog.setOptions(\n            QColorDialog.DontUseNativeDialog | QColorDialog.ShowAlphaChannel\n        )\n        layout = QVBoxLayout()\n        self.frame.setLayout(layout)\n        layout.addWidget(self.color_dialog)\n\n        self.color_dialog.currentColorChanged.connect(\n            self.currentColorChanged.emit\n        )\n        self.color_dialog.colorSelected.connect(self._on_color_selected)\n        self.color_dialog.rejected.connect(self._on_rejected)\n        self.color_dialog.setCurrentColor(QColor(initial_color))\n\n    def _on_color_selected(self, color: QColor):\n        """"""When a color has beeen selected and the OK button clicked.""""""\n        self.colorSelected.emit(color)\n        self.close()\n\n    def _on_rejected(self):\n        self.close()\n\n    def keyPressEvent(self, event: QKeyEvent):\n        """"""Accept current color on enter, cancel on escape.\n\n        Parameters\n        ----------\n        event : QKeyEvent\n            The keypress event that triggered this method.\n        """"""\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter):\n            return self.color_dialog.accept()\n        if event.key() == Qt.Key_Escape:\n            return self.color_dialog.reject()\n        self.color_dialog.keyPressEvent(event)\n'"
napari/_qt/qt_console.py,0,"b'import sys\n\nfrom qtpy.QtGui import QColor\nfrom ipykernel.connect import get_connection_file\nfrom ipykernel.inprocess.ipkernel import InProcessInteractiveShell\nfrom ipykernel.zmqshell import ZMQInteractiveShell\nfrom IPython import get_ipython\nfrom IPython.terminal.interactiveshell import TerminalInteractiveShell\nfrom qtconsole.client import QtKernelClient\nfrom qtconsole.inprocess import QtInProcessKernelManager\nfrom qtconsole.rich_jupyter_widget import RichJupyterWidget\nfrom ..utils.misc import str_to_rgb\n\n""""""\nset default asyncio policy to be compatible with tornado\n\nTornado 6 (at least) is not compatible with the default\nasyncio implementation on Windows\n\nPick the older SelectorEventLoopPolicy on Windows\nif the known-incompatible default policy is in use.\n\nFIXME: if/when tornado supports the defaults in asyncio,\nremove and bump tornado requirement for py38\nborrowed from ipykernel:  https://github.com/ipython/ipykernel/pull/456\n""""""\nif sys.platform.startswith(""win"") and sys.version_info >= (3, 8):\n    import asyncio\n\n    try:\n        from asyncio import (\n            WindowsProactorEventLoopPolicy,\n            WindowsSelectorEventLoopPolicy,\n        )\n    except ImportError:\n        pass\n        # not affected\n    else:\n        if (\n            type(asyncio.get_event_loop_policy())\n            is WindowsProactorEventLoopPolicy\n        ):\n            # WindowsProactorEventLoopPolicy is not compatible with tornado 6\n            # fallback to the pre-3.8 default of Selector\n            asyncio.set_event_loop_policy(WindowsSelectorEventLoopPolicy())\n\n\nclass QtConsole(RichJupyterWidget):\n    """"""Qt view for the console, an integrated iPython terminal in napari.\n\n    Parameters\n    ----------\n    user_variables : dict\n        Dictionary of user variables to declare in console name space.\n\n    Attributes\n    ----------\n    kernel_client : qtconsole.inprocess.QtInProcessKernelClient,\n                    qtconsole.client.QtKernelClient, or None\n        Client for the kernel if it exists, None otherwise.\n    shell : ipykernel.inprocess.ipkernel.InProcessInteractiveShell,\n            ipykernel.zmqshell.ZMQInteractiveShell, or None.\n        Shell for the kernel if it exists, None otherwise.\n    """"""\n\n    def __init__(self, user_variables=None):\n        super().__init__()\n\n        # get current running instance or create new instance\n        shell = get_ipython()\n\n        if shell is None:\n            # If there is no currently running instance create an in-process\n            # kernel.\n            kernel_manager = QtInProcessKernelManager()\n            kernel_manager.start_kernel(show_banner=False)\n            kernel_manager.kernel.gui = \'qt\'\n\n            kernel_client = kernel_manager.client()\n            kernel_client.start_channels()\n\n            self.kernel_manager = kernel_manager\n            self.kernel_client = kernel_client\n            self.shell = kernel_manager.kernel.shell\n            self.push = self.shell.push\n        elif type(shell) == InProcessInteractiveShell:\n            # If there is an existing running InProcessInteractiveShell\n            # it is likely because multiple viewers have been launched from\n            # the same process. In that case create a new kernel.\n            # Connect existing kernel\n            kernel_manager = QtInProcessKernelManager(kernel=shell.kernel)\n            kernel_client = kernel_manager.client()\n\n            self.kernel_manager = kernel_manager\n            self.kernel_client = kernel_client\n            self.shell = kernel_manager.kernel.shell\n            self.push = self.shell.push\n        elif isinstance(shell, TerminalInteractiveShell):\n            # if launching from an ipython terminal then adding a console is\n            # not supported. Instead users should use the ipython terminal for\n            # the same functionality.\n            self.kernel_client = None\n            self.kernel_manager = None\n            self.shell = None\n            self.push = lambda var: None\n\n        elif isinstance(shell, ZMQInteractiveShell):\n            # if launching from jupyter notebook, connect to the existing\n            # kernel\n            kernel_client = QtKernelClient(\n                connection_file=get_connection_file()\n            )\n            kernel_client.load_connection_file()\n            kernel_client.start_channels()\n\n            self.kernel_manager = None\n            self.kernel_client = kernel_client\n            self.shell = shell\n            self.push = self.shell.push\n        else:\n            raise ValueError(\n                \'ipython shell not recognized; \' f\'got {type(shell)}\'\n            )\n        # Add any user variables\n        user_variables = user_variables or {}\n        self.push(user_variables)\n\n        self.enable_calltips = False\n\n        # TODO: Try to get console from jupyter to run without a shift click\n        # self.execute_on_complete_input = True\n\n    def _update_palette(self, palette, themed_stylesheet):\n        """"""Update the napari GUI theme.\n\n        Parameters\n        ----------\n        palette : dict of str: str\n            Color palette with which to style the viewer.\n            Property of napari.components.viewer_model.ViewerModel.\n        themed_stylesheet : str\n            Stylesheet that has already been themed with the current pallete.\n        """"""\n        self.style_sheet = themed_stylesheet\n        self.syntax_style = palette[\'syntax_style\']\n        bracket_color = QColor(*str_to_rgb(palette[\'highlight\']))\n        self._bracket_matcher.format.setBackground(bracket_color)\n\n    def closeEvent(self, event):\n        """"""Clean up the integrated console in napari.""""""\n        if self.kernel_client is not None:\n            self.kernel_client.stop_channels()\n        if self.kernel_manager is not None and self.kernel_manager.has_kernel:\n            self.kernel_manager.shutdown_kernel()\n\n        # RichJupyterWidget doesn\'t clean these up\n        self._completion_widget.deleteLater()\n        self._call_tip_widget.deleteLater()\n        self.deleteLater()\n        event.accept()\n'"
napari/_qt/qt_controls.py,0,"b'from qtpy.QtWidgets import QStackedWidget, QFrame\nfrom .layers import create_qt_controls\n\n\nclass QtControls(QStackedWidget):\n    """"""Container widget for QtLayerControl widgets.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    empty_widget : qtpy.QtWidgets.QFrame\n        Empty placeholder frame for when no layer is selected.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    widgets : dict\n        Dictionary of key value pairs matching layer with its widget controls.\n        widgets[layer] = controls\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n        self.setProperty(""emphasized"", True)\n        self.viewer = viewer\n\n        self.setMouseTracking(True)\n        self.empty_widget = QFrame()\n        self.widgets = {}\n        self.addWidget(self.empty_widget)\n        self._display(None)\n\n        self.viewer.layers.events.added.connect(self._add)\n        self.viewer.layers.events.removed.connect(self._remove)\n        self.viewer.events.active_layer.connect(self._display)\n\n    def _display(self, event):\n        """"""Change the displayed controls to be those of the target layer.\n\n        Parameters\n        ----------\n        event : Event\n            Event with the target layer at `event.item`.\n        """"""\n        if event is None:\n            layer = None\n        else:\n            layer = event.item\n\n        if layer is None:\n            self.setCurrentWidget(self.empty_widget)\n        else:\n            controls = self.widgets[layer]\n            self.setCurrentWidget(controls)\n\n    def _add(self, event):\n        """"""Add the controls target layer to the list of control widgets.\n\n        Parameters\n        ----------\n        event : Event\n            Event with the target layer at `event.item`.\n        """"""\n        layer = event.item\n        controls = create_qt_controls(layer)\n        self.addWidget(controls)\n        self.widgets[layer] = controls\n\n    def _remove(self, event):\n        """"""Remove the controls target layer from the list of control widgets.\n\n        Parameters\n        ----------\n        event : Event\n            Event with the target layer at `event.item`.\n        """"""\n        layer = event.item\n        controls = self.widgets[layer]\n        self.removeWidget(controls)\n        controls.deleteLater()\n        controls = None\n        del self.widgets[layer]\n'"
napari/_qt/qt_debug_menu.py,0,"b'""""""Debug menu.\n\nThe debug menu is for developer-focused functionality that we want to be\neasy-to-use and discoverable, but which is not for the average user.\n\nCurrent Items\n-------------\nTrace File -> Start Tracing...\nTrace File -> Stop Tracking\n""""""\nfrom qtpy.QtCore import QTimer\nfrom qtpy.QtWidgets import QAction, QFileDialog\n\nfrom ..utils import perf\n\n\ndef _ensure_extension(filename: str, extension: str):\n    """"""Add the extension if needed.""""""\n    if filename.endswith(extension):\n        return filename\n    return filename + extension\n\n\nclass DebugMenu:\n    def __init__(self, main_window):\n        """"""Create the debug menu.\n\n        Parameters\n        ----------\n        main_menu : qtpy.QtWidgets.QMainWindow.menuBar\n            We add ourselves to this menu.\n        """"""\n        self.debug_menu = main_window.main_menu.addMenu(\'&Debug\')\n\n        self.perf = PerformanceSubMenu(\n            main_window, self.debug_menu.addMenu(""Performance Trace"")\n        )\n\n\nclass PerformanceSubMenu:\n    """"""The flyout menu to start/stop recording a trace file.\n    """"""\n\n    def __init__(self, main_window, sub_menu):\n        self.main_window = main_window\n        self.sub_menu = sub_menu\n        self.start = self._add_start()\n        self.stop = self._add_stop()\n        self._set_recording(False)\n\n    def _set_recording(self, recording: bool):\n        """"""Toggle which are enabled/disabled.\n\n        Parameters\n        ----------\n        record : bool\n            Are we currently recording a trace file.\n        """"""\n        self.start.setEnabled(not recording)\n        self.stop.setEnabled(recording)\n\n    def _add_start(self):\n        """"""Add Start Recording action.\n        """"""\n        start = QAction(\'Start Recording...\', self.main_window._qt_window)\n        start.setShortcut(\'Alt+T\')\n        start.setStatusTip(\'Start recording a trace file\')\n        start.triggered.connect(self._start_trace)\n        self.sub_menu.addAction(start)\n        return start\n\n    def _add_stop(self):\n        """"""Add Stop Recording action.\n        """"""\n        stop = QAction(\'Stop Recording\', self.main_window._qt_window)\n        stop.setShortcut(\'Shift+Alt+T\')\n        stop.setStatusTip(\'Stop recording a trace file\')\n        stop.triggered.connect(self._stop_trace)\n        self.sub_menu.addAction(stop)\n        return stop\n\n    def _start_trace(self):\n        """"""Start recording a trace file.""""""\n        viewer = self.main_window.qt_viewer\n\n        filename, _ = QFileDialog.getSaveFileName(\n            parent=viewer,\n            caption=\'Record performance trace file\',\n            directory=viewer._last_visited_dir,\n            filter=""Trace Files (*.json)"",\n        )\n        if filename:\n            filename = _ensure_extension(filename, \'.json\')\n\n            def start_trace():\n                perf.timers.start_trace_file(filename)\n                self._set_recording(True)\n\n            # Schedule this to avoid bogus ""MetaCall"" event for the entire\n            # time the file dialog was up.\n            QTimer.singleShot(0, start_trace)\n\n    def _stop_trace(self):\n        """"""Stop recording a trace file.\n        """"""\n        perf.timers.stop_trace_file()\n        self._set_recording(False)\n'"
napari/_qt/qt_dict_table.py,0,"b'import re\nfrom typing import List, Optional\n\nfrom qtpy.QtCore import QSize, Slot\nfrom qtpy.QtGui import QFont\nfrom qtpy.QtWidgets import QTableWidget, QTableWidgetItem\n\nemail_pattern = re.compile(r""^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$"")\nurl_pattern = re.compile(\n    r""https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}""\n    r""\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)""\n)\n\n\nclass QtDictTable(QTableWidget):\n    """"""A QTableWidget subclass that makes a table from a list of dicts.\n\n    This will also make any cells that contain emails address or URLs\n    clickable to open the link in a browser/email client.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        The parent widget, by default None\n    source : list of dict, optional\n        A list of dicts where each dict in the list is a row, and each key in\n        the dict is a header, by default None.  (call set_data later to add\n        data)\n    headers : list of str, optional\n        If provided, will be used in order as the headers of the table.  All\n        items in ``headers`` must be present in at least one of the dicts.\n        by default headers will be the set of all keys in all dicts in\n        ``source``\n    min_section_width : int, optional\n        If provided, sets a minimum width on the columns, by default None\n    max_section_width : int, optional\n        Sets a maximum width on the columns, by default 480\n\n    Raises\n    ------\n    ValueError\n        if ``source`` is not a list of dicts.\n    """"""\n\n    def __init__(\n        self,\n        parent=None,\n        source: List[dict] = None,\n        *,\n        headers: List[str] = None,\n        min_section_width: Optional[int] = None,\n        max_section_width: int = 480,\n    ):\n        super().__init__(parent=parent)\n        if min_section_width:\n            self.horizontalHeader().setMinimumSectionSize(min_section_width)\n        self.horizontalHeader().setMaximumSectionSize(max_section_width)\n        self.horizontalHeader().setStretchLastSection(True)\n        if source:\n            self.set_data(source, headers)\n        self.cellClicked.connect(self._go_to_links)\n        self.setMouseTracking(True)\n\n    def set_data(self, data: List[dict], headers: Optional[List[str]] = None):\n        """"""Set the data in the table, given a list of dicts.\n\n        Parameters\n        ----------\n        data : List[dict]\n            A list of dicts where each dict in the list is a row, and each key\n            in the dict is a header, by default None.  (call set_data later to\n            add data)\n        headers : list of str, optional\n            If provided, will be used in order as the headers of the table. All\n            items in ``headers`` must be present in at least one of the dicts.\n            by default headers will be the set of all keys in all dicts in\n            ``source``\n        """"""\n        if not isinstance(data, list) or any(\n            not isinstance(i, dict) for i in data\n        ):\n            raise ValueError(""\'data\' argument must be a list of dicts"")\n        nrows = len(data)\n        _headers = sorted(set().union(*data))\n        if headers:\n            for h in headers:\n                if h not in _headers:\n                    raise ValueError(\n                        f""Argument \'headers\' got item \'{h}\', which was ""\n                        ""not found in any of the items in \'data\'""\n                    )\n            _headers = headers\n        self.setRowCount(nrows)\n        self.setColumnCount(len(_headers))\n        for row, elem in enumerate(data):\n            for key, value in elem.items():\n                value = value or \'\'\n                try:\n                    col = _headers.index(key)\n                except ValueError:\n                    continue\n                item = QTableWidgetItem(value)\n                # underline links\n                if email_pattern.match(value) or url_pattern.match(value):\n                    font = QFont()\n                    font.setUnderline(True)\n                    item.setFont(font)\n                self.setItem(row, col, item)\n\n        self.setHorizontalHeaderLabels(_headers)\n        self.resize_to_fit()\n\n    @Slot(int, int)\n    def _go_to_links(self, row, col):\n        """"""if a cell is clicked and it contains an email or url, go to link.""""""\n        import webbrowser\n\n        item = self.item(row, col)\n        text = item.text().strip()\n        if email_pattern.match(text):\n            webbrowser.open(f\'mailto:{text}\', new=1)\n            return\n        if url_pattern.match(text):\n            webbrowser.open(text, new=1)\n\n    def resize_to_fit(self):\n        self.resizeColumnsToContents()\n        self.resize(self.sizeHint())\n\n    def sizeHint(self):\n        """"""Return (width, height) of the table""""""\n        width = sum(map(self.columnWidth, range(self.columnCount()))) + 25\n        height = self.rowHeight(0) * (self.rowCount() + 1)\n        return QSize(width, height)\n'"
napari/_qt/qt_dims.py,6,"b'import warnings\nfrom typing import Optional, Tuple\n\nimport numpy as np\nfrom qtpy.QtGui import QFont, QFontMetrics\nfrom qtpy.QtWidgets import QLineEdit, QSizePolicy, QVBoxLayout, QWidget\n\nfrom ..components.dims import Dims\nfrom .qt_dims_slider import QtDimSliderWidget\nfrom ._constants import LoopMode\n\n\nclass QtDims(QWidget):\n    """"""Qt view for the napari Dims model.\n\n    Parameters\n    ----------\n    dims : napari.components.dims.Dims\n        Dims object to be passed to Qt object.\n    parent : QWidget, optional\n        QWidget that will be the parent of this widget.\n\n    Attributes\n    ----------\n    dims : napari.components.dims.Dims\n        Dimensions object modeling slicing and displaying.\n    slider_widgets : list[QtDimSliderWidget]\n        List of slider widgets.\n    """"""\n\n    def __init__(self, dims: Dims, parent=None):\n\n        super().__init__(parent=parent)\n\n        self.SLIDERHEIGHT = 22\n\n        # We keep a reference to the view:\n        self.dims = dims\n\n        # list of sliders\n        self.slider_widgets = []\n\n        # True / False if slider is or is not displayed\n        self._displayed_sliders = []\n\n        self._last_used = None\n        self._play_ready = True  # False if currently awaiting a draw event\n        self._animation_thread = None\n\n        # Initialises the layout:\n        layout = QVBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(3)\n        self.setLayout(layout)\n        self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)\n\n        # Update the number of sliders now that the dims have been added\n        self._update_nsliders()\n        self.dims.events.ndim.connect(self._update_nsliders)\n        self.dims.events.axis.connect(lambda ev: self._update_slider(ev.axis))\n        self.dims.events.range.connect(lambda ev: self._update_range(ev.axis))\n        self.dims.events.ndisplay.connect(self._update_display)\n        self.dims.events.order.connect(self._update_display)\n\n    @property\n    def nsliders(self):\n        """"""Returns the number of sliders displayed.\n\n        Returns\n        -------\n        nsliders: int\n            Number of sliders displayed.\n        """"""\n        return len(self.slider_widgets)\n\n    @property\n    def last_used(self):\n        """"""Returns the integer index of the last used slider.\n\n        Returns\n        -------\n        int\n            Index of slider last used.\n        """"""\n        return self._last_used\n\n    @last_used.setter\n    def last_used(self, last_used: int):\n        """"""Sets the last used slider.\n\n        Parameters\n        ----------\n        last_used : int\n            Index of slider last used.\n        """"""\n        if last_used == self.last_used:\n            return\n\n        formerly_used = self.last_used\n        if formerly_used is not None:\n            sld = self.slider_widgets[formerly_used].slider\n            sld.setProperty(\'last_used\', False)\n            sld.style().unpolish(sld)\n            sld.style().polish(sld)\n\n        self._last_used = last_used\n        if last_used is not None:\n            sld = self.slider_widgets[last_used].slider\n            sld.setProperty(\'last_used\', True)\n            sld.style().unpolish(sld)\n            sld.style().polish(sld)\n\n    def _update_slider(self, axis: int):\n        """"""Updates position for a given slider.\n\n        Parameters\n        ----------\n        axis : int\n            Axis index.\n        """"""\n\n        if axis >= len(self.slider_widgets):\n            return\n\n        self.slider_widgets[axis]._update_slider()\n        self.last_used = axis\n\n    def _update_range(self, axis: int):\n        """"""Updates range for a given slider.\n\n        Parameters\n        ----------\n        axis : int\n            Axis index.\n        """"""\n        if axis >= len(self.slider_widgets):\n            return\n\n        self.slider_widgets[axis]._update_range()\n        nsliders = np.sum(self._displayed_sliders)\n        self.setMinimumHeight(nsliders * self.SLIDERHEIGHT)\n        self._resize_slice_labels()\n\n    def _update_display(self, event=None):\n        """"""Updates display for all sliders.\n\n        The event parameter is there just to allow easy connection to signals,\n        without using `lambda event:`\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context, by default None.\n        """"""\n        widgets = reversed(list(enumerate(self.slider_widgets)))\n        for (axis, widget) in widgets:\n            _range = self.dims.range[axis][1] - self.dims.range[axis][2]\n            if axis in self.dims.displayed or _range == 0:\n                # Displayed dimensions correspond to non displayed sliders\n                self._displayed_sliders[axis] = False\n                self.last_used = None\n                widget.hide()\n            else:\n                # Non displayed dimensions correspond to displayed sliders\n                self._displayed_sliders[axis] = True\n                self.last_used = axis\n                widget.show()\n        nsliders = np.sum(self._displayed_sliders)\n        self.setMinimumHeight(nsliders * self.SLIDERHEIGHT)\n        self._resize_slice_labels()\n\n    def _update_nsliders(self, event=None):\n        """"""Updates the number of sliders based on the number of dimensions.\n\n        The event parameter is there just to allow easy connection to signals,\n        without using `lambda event:`\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context, by default None.\n        """"""\n        self._trim_sliders(0)\n        self._create_sliders(self.dims.ndim)\n        self._update_display()\n        for i in range(self.dims.ndim):\n            self._update_range(i)\n            if self._displayed_sliders[i]:\n                self._update_slider(i)\n\n    def _resize_axis_labels(self):\n        """"""When any of the labels get updated, this method updates all label\n        widths to the width of the longest label. This keeps the sliders\n        left-aligned and allows the full label to be visible at all times,\n        with minimal space, without setting stretch on the layout.\n        """"""\n        fm = QFontMetrics(QFont("""", 0))\n        labels = self.findChildren(QLineEdit, \'axis_label\')\n        newwidth = max([fm.boundingRect(lab.text()).width() for lab in labels])\n\n        if any(self._displayed_sliders):\n            # set maximum width to no more than 20% of slider width\n            maxwidth = self.slider_widgets[0].width() * 0.2\n            newwidth = min([newwidth, maxwidth])\n        for labl in labels:\n            labl.setFixedWidth(newwidth + 10)\n\n    def _resize_slice_labels(self):\n        """"""When the size of any dimension changes, we want to resize all of the\n        slice labels to width of the longest label, to keep all the sliders\n        right aligned.  The width is determined by the number of digits in the\n        largest dimensions, plus a little padding.\n        """"""\n        width = 0\n        for ax, maxi in enumerate(self.dims.max_indices):\n            if self._displayed_sliders[ax]:\n                length = len(str(int(maxi)))\n                if length > width:\n                    width = length\n        # gui width of a string of length `width`\n        fm = QFontMetrics(QFont("""", 0))\n        width = fm.boundingRect(""8"" * width).width()\n        for labl in self.findChildren(QWidget, \'slice_label\'):\n            labl.setFixedWidth(width + 6)\n\n    def _create_sliders(self, number_of_sliders: int):\n        """"""Creates sliders to match new number of dimensions.\n\n        Parameters\n        ----------\n        number_of_sliders : int\n            New number of sliders.\n        """"""\n        # add extra sliders so that number_of_sliders are present\n        # add to the beginning of the list\n        for slider_num in range(self.nsliders, number_of_sliders):\n            dim_axis = number_of_sliders - slider_num - 1\n            slider_widget = QtDimSliderWidget(self, dim_axis)\n            slider_widget.axis_label_changed.connect(self._resize_axis_labels)\n            slider_widget.play_button.play_requested.connect(self.play)\n            self.layout().addWidget(slider_widget)\n            self.slider_widgets.insert(0, slider_widget)\n            self._displayed_sliders.insert(0, True)\n            nsliders = np.sum(self._displayed_sliders)\n            self.setMinimumHeight(nsliders * self.SLIDERHEIGHT)\n        self._resize_axis_labels()\n\n    def _trim_sliders(self, number_of_sliders):\n        """"""Trims number of dimensions to a lower number.\n\n        Parameters\n        ----------\n        number_of_sliders : int\n            New number of sliders.\n        """"""\n        # remove extra sliders so that only number_of_sliders are left\n        # remove from the beginning of the list\n        for slider_num in range(number_of_sliders, self.nsliders):\n            self._remove_slider_widget(0)\n\n    def _remove_slider_widget(self, index):\n        """"""Remove slider_widget at index, including all sub-widgets.\n\n        Parameters\n        ----------\n        axis : int\n            Index of slider to remove\n        """"""\n        # remove particular slider\n        slider_widget = self.slider_widgets.pop(index)\n        self._displayed_sliders.pop(index)\n        self.layout().removeWidget(slider_widget)\n        slider_widget.deleteLater()\n        nsliders = np.sum(self._displayed_sliders)\n        self.setMinimumHeight(int(nsliders * self.SLIDERHEIGHT))\n        self.last_used = None\n\n    def focus_up(self):\n        """"""Shift focused dimension slider to be the next slider above.""""""\n        displayed = list(np.nonzero(self._displayed_sliders)[0])\n        if len(displayed) == 0:\n            return\n\n        if self.last_used is None:\n            self.last_used = displayed[-1]\n        else:\n            index = (displayed.index(self.last_used) + 1) % len(displayed)\n            self.last_used = displayed[index]\n\n    def focus_down(self):\n        """"""Shift focused dimension slider to be the next slider bellow.""""""\n        displayed = list(np.nonzero(self._displayed_sliders)[0])\n        if len(displayed) == 0:\n            return\n\n        if self.last_used is None:\n            self.last_used = displayed[-1]\n        else:\n            index = (displayed.index(self.last_used) - 1) % len(displayed)\n            self.last_used = displayed[index]\n\n    def play(\n        self,\n        axis: int = 0,\n        fps: Optional[float] = None,\n        loop_mode: Optional[str] = None,\n        frame_range: Optional[Tuple[int, int]] = None,\n    ):\n        """"""Animate (play) axis.\n\n        Parameters\n        ----------\n        axis: int\n            Index of axis to play\n        fps: float\n            Frames per second for playback.  Negative values will play in\n            reverse.  fps == 0 will stop the animation. The view is not\n            guaranteed to keep up with the requested fps, and may drop frames\n            at higher fps.\n        loop_mode: str\n            Mode for animation playback.  Must be one of the following options:\n                ""once"": Animation will stop once movie reaches the\n                    max frame (if fps > 0) or the first frame (if fps < 0).\n                ""loop"":  Movie will return to the first frame\n                    after reaching the last frame, looping until stopped.\n                ""back_and_forth"":  Movie will loop back and forth until\n                    stopped\n        frame_range: tuple | list\n            If specified, will constrain animation to loop [first, last] frames\n\n        Raises\n        ------\n        IndexError\n            If ``axis`` requested is out of the range of the dims\n        IndexError\n            If ``frame_range`` is provided and out of the range of the dims\n        ValueError\n            If ``frame_range`` is provided and range[0] >= range[1]\n        """"""\n        # doing manual check here to avoid issue in StringEnum\n        # see https://github.com/napari/napari/issues/754\n        if loop_mode is not None:\n            _modes = LoopMode.keys()\n            if loop_mode not in _modes:\n                raise ValueError(\n                    f\'loop_mode must be one of {_modes}.  Got: {loop_mode}\'\n                )\n            loop_mode = LoopMode(loop_mode)\n\n        if axis >= len(self.dims.range):\n            raise IndexError(\'axis argument out of range\')\n\n        if self.is_playing:\n            if self._animation_worker.axis == axis:\n                self.slider_widgets[axis]._update_play_settings(\n                    fps, loop_mode, frame_range\n                )\n                return\n            else:\n                self.stop()\n\n        # we want to avoid playing a dimension that does not have a slider\n        # (like X or Y, or a third dimension in volume view.)\n        if self._displayed_sliders[axis]:\n            work = self.slider_widgets[axis]._play(fps, loop_mode, frame_range)\n            if work:\n                self._animation_worker, self._animation_thread = work\n            else:\n                self._animation_worker, self._animation_thread = None, None\n        else:\n            warnings.warn(\'Refusing to play a hidden axis\')\n\n    def stop(self):\n        """"""Stop axis animation""""""\n        if self._animation_thread:\n            self._animation_thread.quit()\n            self._animation_thread.wait()\n        self._animation_thread = None\n        self._animation_worker = None\n        self.enable_play()\n\n    @property\n    def is_playing(self):\n        """"""Return True if any axis is currently animated.""""""\n        return self._animation_thread and self._animation_thread.isRunning()\n\n    def _set_frame(self, axis, frame):\n        """"""Safely tries to set `axis` to the requested `point`.\n\n        This function is debounced: if the previous frame has not yet drawn to\n        the canvas, it will simply do nothing.  If the timer plays faster than\n        the canvas can draw, this will drop the intermediate frames, keeping\n        the effective frame rate constant even if the canvas cannot keep up.\n        """"""\n        if self._play_ready:\n            # disable additional point advance requests until this one draws\n            self._play_ready = False\n            self.dims.set_point(axis, frame)\n\n    def enable_play(self, *args):\n        # this is mostly here to connect to the main SceneCanvas.events.draw\n        # event in the qt_viewer\n        self._play_ready = True\n\n    def closeEvent(self, event):\n        [w.deleteLater() for w in self.slider_widgets]\n        self.deleteLater()\n        event.accept()\n'"
napari/_qt/qt_dims_slider.py,1,"b'from typing import Optional, Tuple\n\nimport numpy as np\nfrom qtpy.QtCore import QObject, Qt, QTimer, Signal, Slot\nfrom qtpy.QtGui import QIntValidator\nfrom qtpy.QtWidgets import (\n    QApplication,\n    QCheckBox,\n    QComboBox,\n    QDoubleSpinBox,\n    QFormLayout,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QPushButton,\n    QWidget,\n    QFrame,\n)\n\nfrom ..components.dims_constants import DimsMode\nfrom ..utils.event import Event\nfrom ._constants import LoopMode\nfrom .qt_modal import QtPopup\nfrom .qt_scrollbar import ModifiedScrollBar\nfrom .threading import _new_worker_qthread\n\n\nclass QtDimSliderWidget(QWidget):\n    """"""Compound widget to hold the label, slider and play button for an axis.\n\n    These will usually be instantiated in the QtDims._create_sliders method.\n    This widget *must* be instantiated with a parent QtDims.\n    """"""\n\n    axis_label_changed = Signal(int, str)  # axis, label\n    fps_changed = Signal(float)\n    mode_changed = Signal(str)\n    range_changed = Signal(tuple)\n    play_started = Signal()\n    play_stopped = Signal()\n\n    def __init__(self, parent: QWidget, axis: int):\n        super().__init__(parent=parent)\n        self.axis = axis\n        self.qt_dims = parent\n        self.dims = parent.dims\n        self.axis_label = None\n        self.slider = None\n        self.play_button = None\n        self.curslice_label = QLineEdit(self)\n        self.curslice_label.setToolTip(f\'Current slice for axis {axis}\')\n        # if we set the QIntValidator to actually reflect the range of the data\n        # then an invalid (i.e. too large) index doesn\'t actually trigger the\n        # editingFinished event (the user is expected to change the value)...\n        # which is confusing to the user, so instead we use an IntValidator\n        # that makes sure the user can only enter integers, but we do our own\n        # value validation in self.change_slice\n        self.curslice_label.setValidator(QIntValidator(0, 999999))\n\n        self.curslice_label.editingFinished.connect(self._set_slice_from_label)\n        self.totslice_label = QLabel(self)\n        self.totslice_label.setToolTip(f\'Total slices for axis {axis}\')\n        self.curslice_label.setObjectName(\'slice_label\')\n        self.totslice_label.setObjectName(\'slice_label\')\n        sep = QFrame(self)\n        sep.setFixedSize(1, 14)\n        sep.setObjectName(\'slice_label_sep\')\n\n        self._fps = 10\n        self._minframe = None\n        self._maxframe = None\n        self._loop_mode = LoopMode.LOOP\n\n        layout = QHBoxLayout()\n        self._create_axis_label_widget()\n        self._create_range_slider_widget()\n        self._create_play_button_widget()\n\n        layout.addWidget(self.axis_label)\n        layout.addWidget(self.play_button)\n        layout.addWidget(self.slider, stretch=1)\n        layout.addWidget(self.curslice_label)\n        layout.addWidget(sep)\n        layout.addWidget(self.totslice_label)\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.setSpacing(2)\n        self.setLayout(layout)\n        self.dims.events.axis_labels.connect(self._pull_label)\n\n    def _set_slice_from_label(self):\n        """"""Update the dims point based on the curslice_label.""""""\n        val = int(self.curslice_label.text())\n        max_allowed = self.dims.max_indices[self.axis]\n        if val > max_allowed:\n            val = max_allowed\n            self.curslice_label.setText(str(val))\n        self.curslice_label.clearFocus()\n        self.qt_dims.setFocus()\n        self.dims.set_point(self.axis, val)\n\n    def _create_axis_label_widget(self):\n        """"""Create the axis label widget which accompanies its slider.""""""\n        label = QLineEdit(self)\n        label.setObjectName(\'axis_label\')  # needed for _update_label\n        label.setText(self.dims.axis_labels[self.axis])\n        label.home(False)\n        label.setToolTip(\'Edit to change axis label\')\n        label.setAcceptDrops(False)\n        label.setEnabled(True)\n        label.setAlignment(Qt.AlignRight)\n        label.setContentsMargins(0, 0, 2, 0)\n        label.textChanged.connect(self._update_label)\n        label.editingFinished.connect(self._clear_label_focus)\n        self.axis_label = label\n\n    def _create_range_slider_widget(self):\n        """"""Creates a range slider widget for a given axis.""""""\n        _range = self.dims.range[self.axis]\n        # Set the maximum values of the range slider to be one step less than\n        # the range of the layer as otherwise the slider can move beyond the\n        # shape of the layer as the endpoint is included\n        _range = (_range[0], _range[1] - _range[2], _range[2])\n        point = self.dims.point[self.axis]\n\n        slider = ModifiedScrollBar(Qt.Horizontal)\n        slider.setFocusPolicy(Qt.NoFocus)\n        slider.setMinimum(int(_range[0]))\n        slider.setMaximum(int(_range[1]))\n        slider.setSingleStep(int(_range[2]))\n        slider.setPageStep(int(_range[2]))\n        slider.setValue(point)\n\n        # Listener to be used for sending events back to model:\n        slider.valueChanged.connect(\n            lambda value: self.dims.set_point(self.axis, value)\n        )\n\n        def slider_focused_listener():\n            self.qt_dims.last_used = self.axis\n\n        # linking focus listener to the last used:\n        slider.sliderPressed.connect(slider_focused_listener)\n        self.slider = slider\n\n    def _create_play_button_widget(self):\n        """"""Creates the actual play button, which has the modal popup.""""""\n        self.play_button = QtPlayButton(self.qt_dims, self.axis)\n        self.play_button.mode_combo.activated[str].connect(\n            lambda x: self.__class__.loop_mode.fset(\n                self, LoopMode(x.replace(\' \', \'_\'))\n            )\n        )\n\n        def fps_listener(*args):\n            fps = self.play_button.fpsspin.value()\n            fps *= -1 if self.play_button.reverse_check.isChecked() else 1\n            self.__class__.fps.fset(self, fps)\n\n        self.play_button.fpsspin.editingFinished.connect(fps_listener)\n        self.play_button.reverse_check.stateChanged.connect(fps_listener)\n        self.play_stopped.connect(self.play_button._handle_stop)\n        self.play_started.connect(self.play_button._handle_start)\n\n    def _pull_label(self, event):\n        """"""Updates the label LineEdit from the dims model.""""""\n        if event.axis == self.axis:\n            label = self.dims.axis_labels[self.axis]\n            self.axis_label.setText(label)\n            self.axis_label_changed.emit(self.axis, label)\n\n    def _update_label(self):\n        """"""Update dimension slider label.""""""\n        with self.dims.events.axis_labels.blocker():\n            self.dims.set_axis_label(self.axis, self.axis_label.text())\n        self.axis_label_changed.emit(self.axis, self.axis_label.text())\n\n    def _clear_label_focus(self):\n        """"""Clear focus from dimension slider label.""""""\n        self.axis_label.clearFocus()\n        self.qt_dims.setFocus()\n\n    def _update_range(self):\n        """"""Updates range for slider.""""""\n        displayed_sliders = self.qt_dims._displayed_sliders\n\n        _range = self.dims.range[self.axis]\n        _range = (_range[0], _range[1] - _range[2], _range[2])\n        if _range not in (None, (None, None, None)):\n            if _range[1] == 0:\n                displayed_sliders[self.axis] = False\n                self.qt_dims.last_used = None\n                self.hide()\n            else:\n                if (\n                    not displayed_sliders[self.axis]\n                    and self.axis not in self.dims.displayed\n                ):\n                    displayed_sliders[self.axis] = True\n                    self.last_used = self.axis\n                    self.show()\n                self.slider.setMinimum(int(_range[0]))\n                self.slider.setMaximum(int(_range[1]))\n                self.slider.setSingleStep(int(_range[2]))\n                self.slider.setPageStep(int(_range[2]))\n                maxi = self.dims.max_indices[self.axis]\n                self.totslice_label.setText(str(int(maxi)))\n                self.totslice_label.setAlignment(Qt.AlignLeft)\n                self._update_slice_labels()\n        else:\n            displayed_sliders[self.axis] = False\n            self.hide()\n\n    def _update_slider(self):\n        """"""Update dimension slider.""""""\n        mode = self.dims.mode[self.axis]\n        if mode == DimsMode.POINT:\n            self.slider.setValue(int(self.dims.point[self.axis]))\n            self._update_slice_labels()\n\n    def _update_slice_labels(self):\n        """"""Update slice labels to match current dimension slider position.""""""\n        step = self.dims.range[self.axis][2]\n        self.curslice_label.setText(\n            str(int(self.dims.point[self.axis] // step))\n        )\n        self.curslice_label.setAlignment(Qt.AlignRight)\n\n    @property\n    def fps(self):\n        """"""Frames per second for animation.""""""\n        return self._fps\n\n    @fps.setter\n    def fps(self, value):\n        """"""Frames per second for animation.\n\n        Paramters\n        ---------\n        value : float\n            Frames per second for animation.\n        """"""\n        self._fps = value\n        self.play_button.fpsspin.setValue(abs(value))\n        self.play_button.reverse_check.setChecked(value < 0)\n        self.fps_changed.emit(value)\n\n    @property\n    def loop_mode(self):\n        """"""Loop mode for animation.\n\n        Loop mode enumeration napari._qt._constants.LoopMode\n        Available options for the loop mode string enumeration are:\n        - LoopMode.ONCE\n            Animation will stop once movie reaches the max frame\n            (if fps > 0) or the first frame (if fps < 0).\n        - LoopMode.LOOP\n            Movie will return to the first frame after reaching\n            the last frame, looping continuously until stopped.\n        - LoopMode.BACK_AND_FORTH\n            Movie will loop continuously until stopped,\n            reversing direction when the maximum or minimum frame\n            has been reached.\n        """"""\n        return self._loop_mode\n\n    @loop_mode.setter\n    def loop_mode(self, value):\n        """"""Loop mode for animation.\n\n        Paramters\n        ---------\n        value : napari._qt._constants.LoopMode\n            Loop mode for animation.\n            Available options for the loop mode string enumeration are:\n            - LoopMode.ONCE\n                Animation will stop once movie reaches the max frame\n                (if fps > 0) or the first frame (if fps < 0).\n            - LoopMode.LOOP\n                Movie will return to the first frame after reaching\n                the last frame, looping continuously until stopped.\n            - LoopMode.BACK_AND_FORTH\n                Movie will loop continuously until stopped,\n                reversing direction when the maximum or minimum frame\n                has been reached.\n        """"""\n        self._loop_mode = value\n        self.play_button.mode_combo.setCurrentText(str(value))\n        self.mode_changed.emit(str(value))\n\n    @property\n    def frame_range(self):\n        """"""Frame range for animation, as (minimum_frame, maximum_frame).""""""\n        frame_range = (self._minframe, self._maxframe)\n        frame_range = frame_range if any(frame_range) else None\n        return frame_range\n\n    @frame_range.setter\n    def frame_range(self, value):\n        """"""Frame range for animation, as (minimum_frame, maximum_frame).\n\n        Paramters\n        ---------\n        value : tuple(int, int)\n            Frame range as tuple/list with range (minimum_frame, maximum_frame)\n        """"""\n        if not isinstance(value, (tuple, list, type(None))):\n            raise TypeError(\'frame_range value must be a list or tuple\')\n        if value and not len(value) == 2:\n            raise ValueError(\'frame_range must have a length of 2\')\n        if value is None:\n            value = (None, None)\n        self._minframe, self._maxframe = value\n        self.range_changed.emit(tuple(value))\n\n    def _update_play_settings(self, fps, loop_mode, frame_range):\n        """"""Update settings for animation.\n\n        Parameters\n        ----------\n        fps : float\n            Frames per second to play the animation.\n        loop_mode : napari._qt._constants.LoopMode\n            Loop mode for animation.\n            Available options for the loop mode string enumeration are:\n            - LoopMode.ONCE\n                Animation will stop once movie reaches the max frame\n                (if fps > 0) or the first frame (if fps < 0).\n            - LoopMode.LOOP\n                Movie will return to the first frame after reaching\n                the last frame, looping continuously until stopped.\n            - LoopMode.BACK_AND_FORTH\n                Movie will loop continuously until stopped,\n                reversing direction when the maximum or minimum frame\n                has been reached.\n        frame_range : tuple(int, int)\n            Frame range as tuple/list with range (minimum_frame, maximum_frame)\n        """"""\n        if fps is not None:\n            self.fps = fps\n        if loop_mode is not None:\n            self.loop_mode = loop_mode\n        if frame_range is not None:\n            self.frame_range = frame_range\n\n    def _play(\n        self,\n        fps: Optional[float] = None,\n        loop_mode: Optional[str] = None,\n        frame_range: Optional[Tuple[int, int]] = None,\n    ):\n        """"""Animate (play) axis. Same API as QtDims.play()\n\n        Putting the AnimationWorker logic here makes it easier to call\n        QtDims.play(axis), or hit the keybinding, and have each axis remember\n        it\'s own settings (fps, mode, etc...).\n\n        Parameters\n        ----------\n        fps : float\n            Frames per second for animation.\n        loop_mode : napari._qt._constants.LoopMode\n            Loop mode for animation.\n            Available options for the loop mode string enumeration are:\n            - LoopMode.ONCE\n                Animation will stop once movie reaches the max frame\n                (if fps > 0) or the first frame (if fps < 0).\n            - LoopMode.LOOP\n                Movie will return to the first frame after reaching\n                the last frame, looping continuously until stopped.\n            - LoopMode.BACK_AND_FORTH\n                Movie will loop continuously until stopped,\n                reversing direction when the maximum or minimum frame\n                has been reached.\n        frame_range : tuple(int, int)\n            Frame range as tuple/list with range (minimum_frame, maximum_frame)\n        """"""\n\n        # having this here makes sure that using the QtDims.play() API\n        # keeps the play preferences synchronized with the play_button.popup\n        self._update_play_settings(fps, loop_mode, frame_range)\n\n        # setting fps to 0 just stops the animation\n        if fps == 0:\n            return\n\n        worker, thread = _new_worker_qthread(\n            AnimationWorker,\n            self,\n            _start_thread=True,\n            _connect={\'frame_requested\': self.qt_dims._set_frame},\n        )\n        worker.finished.connect(self.qt_dims.stop)\n        thread.finished.connect(self.play_stopped.emit)\n        self.play_started.emit()\n        self.thread = thread\n        return worker, thread\n\n\nclass QtCustomDoubleSpinBox(QDoubleSpinBox):\n    """"""Custom Spinbox that emits an additional editingFinished signal whenever\n    the valueChanged event is emitted AND the left mouse button is down.\n\n    The original use case here was the FPS spinbox in the play button, where\n    hooking to the actual valueChanged event is undesireable, because if the\n    user clears the LineEdit to type, for example, ""0.5"", then play back\n    will temporarily pause when ""0"" is typed (if the animation is currently\n    running).  However, the editingFinished event ignores mouse click events on\n    the spin buttons.  This subclass class triggers an event both during\n    editingFinished and when the user clicks on the spin buttons.\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, *kwargs)\n        self.valueChanged.connect(self.custom_change_event)\n\n    def custom_change_event(self, value):\n        """"""Emits editingFinished if valueChanged AND left mouse button is down.\n        (i.e. when the user clicks on the spin buttons)\n        Paramters\n        ---------\n        value : float\n            The value of this custom double spin box.\n        """"""\n        if QApplication.mouseButtons() & Qt.LeftButton:\n            self.editingFinished.emit()\n\n    def textFromValue(self, value):\n        """"""This removes the decimal places if the float is an integer.\n\n        Paramters\n        ---------\n        value : float\n            The value of this custom double spin box.\n        """"""\n        if value.is_integer():\n            value = int(value)\n        return str(value)\n\n    def keyPressEvent(self, event):\n        """"""Handle key press event for the dimension slider spinbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        # this is here to intercept Return/Enter keys when editing the FPS\n        # SpinBox.  We WANT the return key to close the popup normally,\n        # but if the user is editing the FPS spinbox, we simply want to\n        # register the change and lose focus on the lineEdit, in case they\n        # want to make an additional change (without reopening the popup)\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter):\n            self.editingFinished.emit()\n            self.clearFocus()\n            return\n        super().keyPressEvent(event)\n\n\nclass QtPlayButton(QPushButton):\n    """"""Play button, included in the DimSliderWidget, to control playback\n\n    the button also owns the QtModalPopup that controls the playback settings.\n    """"""\n\n    play_requested = Signal(int)  # axis, fps\n\n    def __init__(self, dims, axis, reverse=False, fps=10, mode=LoopMode.LOOP):\n        super().__init__()\n        self.dims = dims\n        self.axis = axis\n        self.reverse = reverse\n        self.fps = fps\n        self.mode = mode\n        self.setProperty(\'reverse\', str(reverse))  # for styling\n        self.setProperty(\'playing\', \'False\')  # for styling\n\n        # build popup modal form\n\n        self.popup = QtPopup(self)\n        form_layout = QFormLayout()\n        self.popup.frame.setLayout(form_layout)\n\n        fpsspin = QtCustomDoubleSpinBox(self.popup)\n        fpsspin.setObjectName(""fpsSpinBox"")\n        fpsspin.setAlignment(Qt.AlignCenter)\n        fpsspin.setValue(self.fps)\n        if hasattr(fpsspin, \'setStepType\'):\n            # this was introduced in Qt 5.12.  Totally optional, just nice.\n            fpsspin.setStepType(QDoubleSpinBox.AdaptiveDecimalStepType)\n        fpsspin.setMaximum(500)\n        fpsspin.setMinimum(0)\n        form_layout.insertRow(\n            0, QLabel(\'frames per second:\', parent=self.popup), fpsspin\n        )\n        self.fpsspin = fpsspin\n\n        revcheck = QCheckBox(self.popup)\n        revcheck.setObjectName(""playDirectionCheckBox"")\n        form_layout.insertRow(\n            1, QLabel(\'play direction:\', parent=self.popup), revcheck\n        )\n        self.reverse_check = revcheck\n\n        mode_combo = QComboBox(self.popup)\n        mode_combo.addItems([str(i).replace(\'_\', \' \') for i in LoopMode])\n        form_layout.insertRow(\n            2, QLabel(\'play mode:\', parent=self.popup), mode_combo\n        )\n        mode_combo.setCurrentText(str(self.mode))\n        self.mode_combo = mode_combo\n\n    def mouseReleaseEvent(self, event):\n        """"""Show popup for right-click, toggle animation for right click.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the qt context.\n        """"""\n        # using this instead of self.customContextMenuRequested.connect and\n        # clicked.connect because the latter was not sending the\n        # rightMouseButton release event.\n        if event.button() == Qt.RightButton:\n            self.popup.show_above_mouse()\n        elif event.button() == Qt.LeftButton:\n            self._on_click()\n\n    def _on_click(self):\n        """"""Toggle play/stop animation control.""""""\n        if self.property(\'playing\') == ""True"":\n            return self.dims.stop()\n        self.play_requested.emit(self.axis)\n\n    def _handle_start(self):\n        """"""On animation start, set playing property to True & update style.""""""\n        self.setProperty(\'playing\', \'True\')\n        self.style().unpolish(self)\n        self.style().polish(self)\n\n    def _handle_stop(self):\n        """"""On animation stop, set playing property to False & update style.""""""\n        self.setProperty(\'playing\', \'False\')\n        self.style().unpolish(self)\n        self.style().polish(self)\n\n\nclass AnimationWorker(QObject):\n    """"""A thread to keep the animation timer independent of the main event loop.\n\n    This prevents mouseovers and other events from causing animation lag. See\n    QtDims.play() for public-facing docstring.\n    """"""\n\n    frame_requested = Signal(int, int)  # axis, point\n    finished = Signal()\n    started = Signal()\n\n    def __init__(self, slider):\n        super().__init__()\n        self.slider = slider\n        self.dims = slider.dims\n        self.axis = slider.axis\n        self.loop_mode = slider.loop_mode\n        slider.fps_changed.connect(self.set_fps)\n        slider.mode_changed.connect(self.set_loop_mode)\n        slider.range_changed.connect(self.set_frame_range)\n        self.set_fps(self.slider.fps)\n        self.set_frame_range(slider.frame_range)\n\n        # after dims.set_point is called, it will emit a dims.events.axis()\n        # we use this to update this threads current frame (in case it\n        # was some other event that updated the axis)\n        self.dims.events.axis.connect(self._on_axis_changed)\n        self.current = max(self.dims.point[self.axis], self.min_point)\n        self.current = min(self.current, self.max_point)\n        self.timer = QTimer()\n\n    @Slot()\n    def work(self):\n        """"""Play the animation.""""""\n        # if loop_mode is once and we are already on the last frame,\n        # return to the first frame... (so the user can keep hitting once)\n        if self.loop_mode == LoopMode.ONCE:\n            if self.step > 0 and self.current >= self.max_point - 1:\n                self.frame_requested.emit(self.axis, self.min_point)\n            elif self.step < 0 and self.current <= self.min_point + 1:\n                self.frame_requested.emit(self.axis, self.max_point)\n            self.timer.singleShot(self.interval, self.advance)\n        else:\n            # immediately advance one frame\n            self.advance()\n        self.started.emit()\n\n    @Slot(float)\n    def set_fps(self, fps):\n        """"""Set the frames per second value for the animation.\n\n        Parameters\n        ----------\n        fps : float\n            Frames per second for the animation.\n        """"""\n        if fps == 0:\n            return self.finish()\n        self.step = 1 if fps > 0 else -1  # negative fps plays in reverse\n        self.interval = 1000 / abs(fps)\n\n    @Slot(tuple)\n    def set_frame_range(self, frame_range):\n        """"""Frame range for animation, as (minimum_frame, maximum_frame).\n\n        Parameters\n        ----------\n        frame_range : tuple(int, int)\n            Frame range as tuple/list with range (minimum_frame, maximum_frame)\n        """"""\n        self.dimsrange = self.dims.range[self.axis]\n\n        if frame_range is not None:\n            if frame_range[0] >= frame_range[1]:\n                raise ValueError(""frame_range[0] must be <= frame_range[1]"")\n            if frame_range[0] < self.dimsrange[0]:\n                raise IndexError(""frame_range[0] out of range"")\n            if frame_range[1] * self.dimsrange[2] >= self.dimsrange[1]:\n                raise IndexError(""frame_range[1] out of range"")\n        self.frame_range = frame_range\n\n        if self.frame_range is not None:\n            self.min_point, self.max_point = self.frame_range\n        else:\n            self.min_point = 0\n            self.max_point = int(\n                np.floor(self.dimsrange[1] - self.dimsrange[2])\n            )\n        self.max_point += 1  # range is inclusive\n\n    @Slot(str)\n    def set_loop_mode(self, mode):\n        """"""Set the loop mode for the animation.\n\n        Parameters\n        ----------\n        mode : str\n            Loop mode for animation.\n            Available options for the loop mode string enumeration are:\n            - LoopMode.ONCE\n                Animation will stop once movie reaches the max frame\n                (if fps > 0) or the first frame (if fps < 0).\n            - LoopMode.LOOP\n                Movie will return to the first frame after reaching\n                the last frame, looping continuously until stopped.\n            - LoopMode.BACK_AND_FORTH\n                Movie will loop continuously until stopped,\n                reversing direction when the maximum or minimum frame\n                has been reached.\n        """"""\n        self.loop_mode = LoopMode(mode)\n\n    def advance(self):\n        """"""Advance the current frame in the animation.\n\n        Takes dims scale into account and restricts the animation to the\n        requested frame_range, if entered.\n        """"""\n        self.current += self.step * self.dimsrange[2]\n        if self.current < self.min_point:\n            if (\n                self.loop_mode == LoopMode.BACK_AND_FORTH\n            ):  # \'loop_back_and_forth\'\n                self.step *= -1\n                self.current = self.min_point + self.step * self.dimsrange[2]\n            elif self.loop_mode == LoopMode.LOOP:  # \'loop\'\n                self.current = self.max_point + self.current - self.min_point\n            else:  # loop_mode == \'once\'\n                return self.finish()\n        elif self.current >= self.max_point:\n            if (\n                self.loop_mode == LoopMode.BACK_AND_FORTH\n            ):  # \'loop_back_and_forth\'\n                self.step *= -1\n                self.current = (\n                    self.max_point + 2 * self.step * self.dimsrange[2]\n                )\n            elif self.loop_mode == LoopMode.LOOP:  # \'loop\'\n                self.current = self.min_point + self.current - self.max_point\n            else:  # loop_mode == \'once\'\n                return self.finish()\n        with self.dims.events.axis.blocker(self._on_axis_changed):\n            self.frame_requested.emit(self.axis, self.current)\n        # using a singleShot timer here instead of timer.start() because\n        # it makes it easier to update the interval using signals/slots\n        self.timer.singleShot(self.interval, self.advance)\n\n    def finish(self):\n        """"""Emit the finished event signal.""""""\n        self.finished.emit()\n\n    @Slot(Event)\n    def _on_axis_changed(self, event):\n        """"""Update the current frame if the axis has changed.""""""\n        # slot for external events to update the current frame\n        if event.axis == self.axis and hasattr(event, \'value\'):\n            self.current = event.value\n'"
napari/_qt/qt_event_timing.py,0,"b'""""""A special QApplication for perfmon.\n\nThis file defines QApplicationWithTiming and convert_app_for_timing(), both of\nwhich we use when perfmon is enabled to time Qt Events.\n\nPerf timers power the debug menu\'s ""Start Tracing"" feature as well as the\ndockable QtPerformance widget.\n""""""\nimport sys\n\nfrom qtpy.QtCore import QEvent\nfrom qtpy.QtWidgets import QApplication, QWidget\n\nfrom ..utils import perf\n\n\ndef convert_app_for_timing(app: QApplication) -> QApplication:\n    """"""If necessary replace existing app with our special perfmon one.\n\n    Parameters\n    ----------\n    app : QApplication\n        The existing application if any.\n    """"""\n    if isinstance(app, QApplicationWithTiming):\n        # We\'re already using QApplicationWithTiming so there is nothing\n        # to do. This happens when napari is launched from the command\n        # line because we create a QApplicationWithTiming in gui_qt.\n        return app\n\n    if app is not None:\n\n        # Because we can\'t monkey patch QApplication.notify, since it\'s a\n        # SIP wrapped C++ method, we delete the current app and create a new one.\n        # This must be done very early before any Qt objects are created.\n        import sip\n\n        sip.delete(app)\n\n    # Is it right to pass in sys.argv here? I think so if there are any\n    # Qt flags on there?\n    return QApplicationWithTiming(sys.argv)\n\n\nclass QApplicationWithTiming(QApplication):\n    """"""Extend QApplication to time Qt Events.\n\n    This QApplication times how long the normal notify() method takes.\n\n    Notes\n    -----\n    Qt Event handling is nested. A call to notify() can trigger other calls to\n    notify() prior to the first one finishing, even several levels deep.\n\n    The hierarchy of timers is displayed correctly in the chrome://tracing GUI.\n    Seeing the structure of the event handling hierarchy can be very informative\n    even apart from the actual timing numbers.\n    """"""\n\n    def notify(self, receiver, event):\n        """"""Time events while we handle them.""""""\n        timer_name = _get_timer_name(receiver, event)\n\n        # Time the event while we handle it.\n        with perf.perf_timer(timer_name, ""qt_event""):\n            return QApplication.notify(self, receiver, event)\n\n\nclass EventTypes:\n    """"""Convert event type to a string name.\n\n    Create event type to string mapping once on startup. We want human-readable\n    event names for our timers. PySide2 does this for you but PyQt5 does not:\n\n    # PySide2\n    str(QEvent.KeyPress) -> \'PySide2.QtCore.QEvent.Type.KeyPress\'\n\n    # PyQt5\n    str(QEvent.KeyPress) -> \'6\'\n\n    We use this class for PyQt5 and PySide2 to be consistent.\n    """"""\n\n    def __init__(self):\n        """"""Create mapping for all known event types.""""""\n        self.string_name = {}\n        for name in vars(QEvent):\n            attribute = getattr(QEvent, name)\n            if type(attribute) == QEvent.Type:\n                self.string_name[attribute] = name\n\n    def as_string(self, event: QEvent.Type) -> str:\n        """"""Return the string name for this event.\n\n        event : QEvent.Type\n            Return string for this event type.\n        """"""\n        try:\n            return self.string_name[event]\n        except KeyError:\n            return f""UnknownEvent:{event}""\n\n\nEVENT_TYPES = EventTypes()\n\n\ndef _get_timer_name(receiver: QWidget, event: QEvent) -> str:\n    """"""Return a name for this event.\n\n    Parameters\n    ----------\n    receiver : QWidget\n        The receiver of the event.\n    event : QEvent\n        The event name.\n\n    Returns\n    -------\n    str\n        The timer\'s name\n\n    Notes\n    -----\n    If no object we return <event_name>.\n    If there\'s an object we return <event_name>:<object_name>.\n\n    Combining the two names with a colon is our own made-up format. The name\n    will show up in chrome://tracing and our QtPerformance widget.\n    """"""\n    event_str = EVENT_TYPES.as_string(event.type())\n\n    try:\n        # There may or may not be a receiver object name.\n        object_name = receiver.objectName()\n    except AttributeError:\n        # Ignore ""missing objectName attribute"" during shutdown.\n        object_name = None\n\n    if object_name:\n        return f""{event_str}:{object_name}""\n\n    # There was no object (pretty common).\n    return event_str\n'"
napari/_qt/qt_layerlist.py,4,"b'from qtpy.QtCore import Qt, QMimeData, QTimer\nfrom qtpy.QtGui import QImage, QPixmap\nfrom qtpy.QtWidgets import (\n    QWidget,\n    QVBoxLayout,\n    QFrame,\n    QScrollArea,\n    QApplication,\n    QLineEdit,\n    QLabel,\n    QCheckBox,\n    QHBoxLayout,\n    QSizePolicy,\n)\nfrom qtpy.QtGui import QDrag\nimport numpy as np\n\n\nclass QtLayerList(QScrollArea):\n    """"""Widget storing a list of all the layers present in the current window.\n\n    Parameters\n    ----------\n    layers : napari.components.LayerList\n        The layer list to track and display.\n\n    Attributes\n    ----------\n    centers : list\n        List of layer widgets center coordinates.\n    layers : napari.components.LayerList\n        The layer list to track and display.\n    vbox_layout : QVBoxLayout\n        The layout instance in which the layouts appear.\n    """"""\n\n    def __init__(self, layers):\n        super().__init__()\n\n        self.layers = layers\n        self.setWidgetResizable(True)\n        self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)\n        scrollWidget = QWidget()\n        self.setWidget(scrollWidget)\n        self.vbox_layout = QVBoxLayout(scrollWidget)\n        self.vbox_layout.addWidget(QtDivider())\n        self.vbox_layout.addStretch(1)\n        self.vbox_layout.setContentsMargins(0, 0, 0, 0)\n        self.vbox_layout.setSpacing(2)\n        self.centers = []\n\n        # Create a timer to be used for autoscrolling the layers list up and\n        # down when dragging a layer near the end of the displayed area\n        self._drag_timer = QTimer()\n        self._drag_timer.setSingleShot(False)\n        self._drag_timer.setInterval(20)\n        self._drag_timer.timeout.connect(self._force_scroll)\n        self._scroll_up = True\n        self._min_scroll_region = 24\n        self.setAcceptDrops(True)\n        self.setToolTip(\'Layer list\')\n        self.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)\n\n        self.layers.events.added.connect(self._add)\n        self.layers.events.removed.connect(self._remove)\n        self.layers.events.reordered.connect(self._reorder)\n\n        self._drag_start_position = np.zeros(2)\n        self._drag_name = None\n\n    def _add(self, event):\n        """"""Insert widget for layer `event.item` at index `event.index`.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        layer = event.item\n        total = len(self.layers)\n        index = 2 * (total - event.index) - 1\n        widget = QtLayerWidget(layer)\n        self.vbox_layout.insertWidget(index, widget)\n        self.vbox_layout.insertWidget(index + 1, QtDivider())\n        layer.events.select.connect(self._scroll_on_select)\n\n    def _remove(self, event):\n        """"""Remove widget for layer at index `event.index`.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        layer_index = event.index\n        total = len(self.layers)\n        # Find property widget and divider for layer to be removed\n        index = 2 * (total - layer_index) + 1\n        widget = self.vbox_layout.itemAt(index).widget()\n        divider = self.vbox_layout.itemAt(index + 1).widget()\n        self.vbox_layout.removeWidget(widget)\n        widget.deleteLater()\n        self.vbox_layout.removeWidget(divider)\n        divider.deleteLater()\n\n    def _reorder(self, event=None):\n        """"""Reorder list of layer widgets.\n\n        Loops through all widgets in list, sequentially removing them\n        and inserting them into the correct place in the final list.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context.\n        """"""\n        total = len(self.layers)\n\n        # Create list of the current property and divider widgets\n        widgets = [\n            self.vbox_layout.itemAt(i + 1).widget() for i in range(2 * total)\n        ]\n        # Take every other widget to ignore the dividers and get just the\n        # property widgets\n        indices = [\n            self.layers.index(w.layer)\n            for i, w in enumerate(widgets)\n            if i % 2 == 0\n        ]\n\n        # Move through the layers in order\n        for i in range(total):\n            # Find index of property widget in list of the current layer\n            index = 2 * indices.index(i)\n            widget = widgets[index]\n            divider = widgets[index + 1]\n            # Check if current index does not match new index\n            index_current = self.vbox_layout.indexOf(widget)\n            index_new = 2 * (total - i) - 1\n            if index_current != index_new:\n                # Remove that property widget and divider\n                self.vbox_layout.removeWidget(widget)\n                self.vbox_layout.removeWidget(divider)\n                # Insert the property widget and divider into new location\n                self.vbox_layout.insertWidget(index_new, widget)\n                self.vbox_layout.insertWidget(index_new + 1, divider)\n\n    def _force_scroll(self):\n        """"""Force the scroll bar to automattically scroll either up or down.""""""\n        cur_value = self.verticalScrollBar().value()\n        if self._scroll_up:\n            new_value = cur_value - self.verticalScrollBar().singleStep() / 4\n            if new_value < 0:\n                new_value = 0\n            self.verticalScrollBar().setValue(new_value)\n        else:\n            new_value = cur_value + self.verticalScrollBar().singleStep() / 4\n            if new_value > self.verticalScrollBar().maximum():\n                new_value = self.verticalScrollBar().maximum()\n            self.verticalScrollBar().setValue(new_value)\n\n    def _scroll_on_select(self, event):\n        """"""Scroll to ensure that the currently selected layer is visible.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        layer = event.source\n        self._ensure_visible(layer)\n\n    def _ensure_visible(self, layer):\n        """"""Ensure layer widget for at particular layer is visible.\n\n        Parameters\n        ----------\n        layer : napari.layers.Layer\n            An instance of a napari layer.\n\n        """"""\n        total = len(self.layers)\n        layer_index = self.layers.index(layer)\n        # Find property widget and divider for layer to be removed\n        index = 2 * (total - layer_index) - 1\n        widget = self.vbox_layout.itemAt(index).widget()\n        self.ensureWidgetVisible(widget)\n\n    def keyPressEvent(self, event):\n        """"""Ignore a key press event.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n\n    def keyReleaseEvent(self, event):\n        """"""Ignore key relase event.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n\n    def mousePressEvent(self, event):\n        """"""Register mouse click if it happens on a layer widget.\n\n        Checks if mouse press happens on a layer properties widget or\n        a child of such a widget. If not, the press has happended on the\n        Layers Widget itself and should be ignored.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        widget = self.childAt(event.pos())\n        layer = (\n            getattr(widget, \'layer\', None)\n            or getattr(widget.parentWidget(), \'layer\', None)\n            or getattr(widget.parentWidget().parentWidget(), \'layer\', None)\n        )\n\n        if layer is not None:\n            self._drag_start_position = np.array(\n                [event.pos().x(), event.pos().y()]\n            )\n            self._drag_name = layer.name\n        else:\n            self._drag_name = None\n\n    def mouseReleaseEvent(self, event):\n        """"""Select layer using mouse click.\n\n        Key modifiers:\n        Shift - If the Shift button is pressed, select all layers in between\n            currently selected one and the clicked one.\n        Control - If the Control button is pressed, mouse click will\n            toggle selected state of the layer.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if self._drag_name is None:\n            # Unselect all the layers if not dragging a layer\n            self.layers.unselect_all()\n            return\n\n        modifiers = event.modifiers()\n        layer = self.layers[self._drag_name]\n        if modifiers == Qt.ShiftModifier:\n            # If shift select all layers in between currently selected one and\n            # clicked one\n            index = self.layers.index(layer)\n            lastSelected = None\n            for i in range(len(self.layers)):\n                if self.layers[i].selected:\n                    lastSelected = i\n            r = [index, lastSelected]\n            r.sort()\n            for i in range(r[0], r[1] + 1):\n                self.layers[i].selected = True\n        elif modifiers == Qt.ControlModifier:\n            # If control click toggle selected state\n            layer.selected = not layer.selected\n        else:\n            # If otherwise unselect all and leave clicked one selected\n            self.layers.unselect_all(ignore=layer)\n            layer.selected = True\n\n    def mouseMoveEvent(self, event):\n        """"""Drag and drop layer with mouse movement.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        position = np.array([event.pos().x(), event.pos().y()])\n        distance = np.linalg.norm(position - self._drag_start_position)\n        if (\n            distance < QApplication.startDragDistance()\n            or self._drag_name is None\n        ):\n            return\n        mimeData = QMimeData()\n        mimeData.setText(self._drag_name)\n        drag = QDrag(self)\n        drag.setMimeData(mimeData)\n        drag.setHotSpot(event.pos() - self.rect().topLeft())\n        drag.exec_()\n        if self._drag_name is not None:\n            index = self.layers.index(self._drag_name)\n            layer = self.layers[index]\n            self._ensure_visible(layer)\n\n    def dragLeaveEvent(self, event):\n        """"""Unselects layer dividers.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n        self._drag_timer.stop()\n        for i in range(0, self.vbox_layout.count(), 2):\n            self.vbox_layout.itemAt(i).widget().setSelected(False)\n\n    def dragEnterEvent(self, event):\n        """"""Update divider position before dragging layer widget to new position\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.source() == self:\n            event.accept()\n            divs = []\n            for i in range(0, self.vbox_layout.count(), 2):\n                widget = self.vbox_layout.itemAt(i).widget()\n                divs.append(widget.y() + widget.frameGeometry().height() / 2)\n            self.centers = [\n                (divs[i + 1] + divs[i]) / 2 for i in range(len(divs) - 1)\n            ]\n        else:\n            event.ignore()\n\n    def dragMoveEvent(self, event):\n        """"""Highlight appriate divider when dragging layer to new position.\n\n        Sets the appropriate layers list divider to be highlighted when\n        dragging a layer to a new position in the layers list.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        max_height = self.frameGeometry().height()\n        if (\n            event.pos().y() < self._min_scroll_region\n            and not self._drag_timer.isActive()\n        ):\n            self._scroll_up = True\n            self._drag_timer.start()\n        elif (\n            event.pos().y() > max_height - self._min_scroll_region\n            and not self._drag_timer.isActive()\n        ):\n            self._scroll_up = False\n            self._drag_timer.start()\n        elif (\n            self._drag_timer.isActive()\n            and event.pos().y() >= self._min_scroll_region\n            and event.pos().y() <= max_height - self._min_scroll_region\n        ):\n            self._drag_timer.stop()\n\n        # Determine which widget center is the mouse currently closed to\n        cord = event.pos().y() + self.verticalScrollBar().value()\n        center_list = (i for i, x in enumerate(self.centers) if x > cord)\n        divider_index = next(center_list, len(self.centers))\n        # Determine the current location of the widget being dragged\n        total = self.vbox_layout.count() // 2 - 1\n        insert = total - divider_index\n        index = self.layers.index(self._drag_name)\n        # If the widget being dragged hasn\'t moved above or below any other\n        # widgets then don\'t highlight any dividers\n        selected = not (insert == index) and not (insert - 1 == index)\n        # Set the selected state of all the dividers\n        for i in range(0, self.vbox_layout.count(), 2):\n            if i == 2 * divider_index:\n                self.vbox_layout.itemAt(i).widget().setSelected(selected)\n            else:\n                self.vbox_layout.itemAt(i).widget().setSelected(False)\n\n    def dropEvent(self, event):\n        """"""Drop dragged layer widget into new position in the list of layers.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if self._drag_timer.isActive():\n            self._drag_timer.stop()\n\n        for i in range(0, self.vbox_layout.count(), 2):\n            self.vbox_layout.itemAt(i).widget().setSelected(False)\n        cord = event.pos().y() + self.verticalScrollBar().value()\n        center_list = (i for i, x in enumerate(self.centers) if x > cord)\n        divider_index = next(center_list, len(self.centers))\n        total = self.vbox_layout.count() // 2 - 1\n        insert = total - divider_index\n        index = self.layers.index(self._drag_name)\n        if index != insert and index + 1 != insert:\n            if insert >= index:\n                insert -= 1\n            self.layers.move_selected(index, insert)\n        event.accept()\n\n\nclass QtDivider(QFrame):\n    """"""Qt divider used to separate Qt widgets visually.\n\n    Attributes\n    ----------\n    layout : QVBoxLayout\n        Layout of the widget.\n    selected : bool\n        Whether the QtDivider is currently selected.\n    """"""\n\n    def __init__(self):\n        super().__init__()\n        self.setSelected(False)\n        self.layout = QVBoxLayout()\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(self.layout)\n\n    def setSelected(self, selected):\n        """"""Toggle boolean \'selected\' attribute of QTDivider instance.\n\n        Parameters\n        ----------\n        selected : bool\n        """"""\n        if selected:\n            self.setProperty(\'selected\', True)\n            self.style().polish(self)\n        else:\n            self.setProperty(\'selected\', False)\n            self.style().polish(self)\n\n\nclass QtLayerWidget(QFrame):\n    """"""Qt view for Layer model.\n\n    Attributes\n    ----------\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n    layout : QVBoxLayout\n        Layout of the widget.\n    nameTextBox : QLineEdit\n        Textbox for layer name.\n    thumbnailLabel : QLabel\n        Label of layer thumbnail.\n    typeLabel : QLabel\n        Label of layer type.\n    visibleCheckBox : QCheckBox\n        Checkbox to toggle layer visibility.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__()\n\n        self.layer = layer\n        layer.events.select.connect(lambda v: self.setSelected(True))\n        layer.events.deselect.connect(lambda v: self.setSelected(False))\n        layer.events.name.connect(self._on_layer_name_change)\n        layer.events.visible.connect(self._on_visible_change)\n        layer.events.thumbnail.connect(self._on_thumbnail_change)\n\n        self.setObjectName(\'layer\')\n\n        self.layout = QHBoxLayout()\n        self.layout.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(self.layout)\n\n        tb = QLabel(self)\n        tb.setObjectName(\'thumbnail\')\n        tb.setToolTip(\'Layer thumbnail\')\n        self.thumbnailLabel = tb\n        self._on_thumbnail_change()\n        self.layout.addWidget(tb)\n\n        cb = QCheckBox(self)\n        cb.setObjectName(\'visibility\')\n        cb.setToolTip(\'Layer visibility\')\n        cb.setChecked(self.layer.visible)\n        cb.setProperty(\'mode\', \'visibility\')\n        cb.stateChanged.connect(self.changeVisible)\n        self.visibleCheckBox = cb\n        self.layout.addWidget(cb)\n\n        textbox = QLineEdit(self)\n        textbox.setText(layer.name)\n        textbox.home(False)\n        textbox.setToolTip(self.layer.name)\n        textbox.setAcceptDrops(False)\n        textbox.setEnabled(True)\n        textbox.editingFinished.connect(self.changeText)\n        self.nameTextBox = textbox\n        self.layout.addWidget(textbox)\n\n        ltb = QLabel(self)\n        layer_type = type(layer).__name__\n        ltb.setObjectName(layer_type)\n        ltb.setProperty(\'layer_type_label\', True)\n        ltb.setToolTip(\'Layer type\')\n        self.typeLabel = ltb\n        self.layout.addWidget(ltb)\n\n        msg = \'Click to select\\nDrag to rearrange\'\n        self.setToolTip(msg)\n        self.setSelected(self.layer.selected)\n\n    def setSelected(self, state):\n        """"""Select layer widget.\n\n        Parameters\n        ----------\n        state : bool\n        """"""\n        self.setProperty(\'selected\', state)\n        self.nameTextBox.setEnabled(state)\n        self.style().unpolish(self)\n        self.style().polish(self)\n\n    def changeVisible(self, state):\n        """"""Toggle visibility of the layer.\n\n        Parameters\n        ----------\n        state : bool\n        """"""\n        if state == Qt.Checked:\n            self.layer.visible = True\n        else:\n            self.layer.visible = False\n\n    def changeText(self):\n        """"""Update layer name attribute using layer name textbox contents.""""""\n        self.layer.name = self.nameTextBox.text()\n        self.nameTextBox.setToolTip(self.layer.name)\n        self.nameTextBox.clearFocus()\n        self.setFocus()\n\n    def mouseReleaseEvent(self, event):\n        """"""Ignores mouse release event.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n\n    def mousePressEvent(self, event):\n        """"""Ignores mouse press event.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n\n    def mouseMoveEvent(self, event):\n        """"""Ignores mouse move event.\n\n        Allows the event to pass through a parent widget to its child widget\n        without doing anything. If we did not use event.ignore() then the\n        parent widget would catch the event and not pass it on to the child.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n\n    def _on_layer_name_change(self, event=None):\n        """"""Update text displaying name of layer.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context.\n        """"""\n        with self.layer.events.name.blocker():\n            self.nameTextBox.setText(self.layer.name)\n            self.nameTextBox.home(False)\n\n    def _on_visible_change(self, event=None):\n        """"""Toggle visibility of the layer.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context.\n        """"""\n        with self.layer.events.visible.blocker():\n            self.visibleCheckBox.setChecked(self.layer.visible)\n\n    def _on_thumbnail_change(self, event=None):\n        """"""Update thumbnail image on the layer widget.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context.\n        """"""\n        thumbnail = self.layer.thumbnail\n        # Note that QImage expects the image width followed by height\n        image = QImage(\n            thumbnail,\n            thumbnail.shape[1],\n            thumbnail.shape[0],\n            QImage.Format_RGBA8888,\n        )\n        self.thumbnailLabel.setPixmap(QPixmap.fromImage(image))\n'"
napari/_qt/qt_main_window.py,0,"b'""""""\nCustom Qt widgets that serve as native objects that the public-facing elements\nwrap.\n""""""\nimport time\n\n# set vispy to use same backend as qtpy\nfrom ..utils.io import imsave\n\nfrom .qt_viewer import QtViewer\nfrom .qt_about import QtAbout\nfrom .qt_plugin_report import QtPluginErrReporter\nfrom .qt_plugin_sorter import QtPluginSorter\nfrom .qt_debug_menu import DebugMenu\nfrom .qt_dict_table import QtDictTable\nfrom .qt_viewer_dock_widget import QtViewerDockWidget\nfrom ..resources import get_stylesheet\nfrom ..utils import perf\n\n# these ""# noqa"" comments are here to skip flake8 linting (E402),\n# these module-level imports have to come after `app.use_app(API)`\n# see discussion on #638\nfrom qtpy.QtWidgets import (  # noqa: E402\n    QAbstractItemView,\n    QApplication,\n    QMainWindow,\n    QWidget,\n    QHBoxLayout,\n    QDialog,\n    QDockWidget,\n    QLabel,\n    QAction,\n    QShortcut,\n    QStatusBar,\n    QVBoxLayout,\n    QFileDialog,\n)\nfrom qtpy.QtCore import Qt  # noqa: E402\nfrom qtpy.QtGui import QKeySequence, QIcon  # noqa: E402\nfrom .utils import QImg2array  # noqa: E402\nfrom ..utils.theme import template  # noqa: E402\n\n\nclass Window:\n    """"""Application window that contains the menu bar and viewer.\n\n    Parameters\n    ----------\n    qt_viewer : QtViewer\n        Contained viewer widget.\n\n    Attributes\n    ----------\n    file_menu : qtpy.QtWidgets.QMenu\n        File menu.\n    help_menu : qtpy.QtWidgets.QMenu\n        Help menu.\n    main_menu : qtpy.QtWidgets.QMainWindow.menuBar\n        Main menubar.\n    qt_viewer : QtViewer\n        Contained viewer widget.\n    view_menu : qtpy.QtWidgets.QMenu\n        View menu.\n    window_menu : qtpy.QtWidgets.QMenu\n        Window menu.\n    """"""\n\n    raw_stylesheet = get_stylesheet()\n\n    def __init__(self, qt_viewer: QtViewer, *, show: bool = True):\n\n        self.qt_viewer = qt_viewer\n\n        self._qt_window = QMainWindow()\n        self._qt_window.setAttribute(Qt.WA_DeleteOnClose)\n        self._qt_window.setUnifiedTitleAndToolBarOnMac(True)\n        self._qt_center = QWidget(self._qt_window)\n\n        self._qt_window.setCentralWidget(self._qt_center)\n        self._qt_window.setWindowTitle(self.qt_viewer.viewer.title)\n        self._qt_center.setLayout(QHBoxLayout())\n        self._status_bar = QStatusBar()\n        self._qt_window.setStatusBar(self._status_bar)\n\n        self._add_menubar()\n\n        self._add_file_menu()\n        self._add_view_menu()\n        self._add_window_menu()\n        self._add_plugins_menu()\n        self._add_help_menu()\n\n        self._status_bar.showMessage(\'Ready\')\n        self._help = QLabel(\'\')\n        self._status_bar.addPermanentWidget(self._help)\n\n        self._qt_center.layout().addWidget(self.qt_viewer)\n        self._qt_center.layout().setContentsMargins(4, 0, 4, 0)\n\n        self._update_palette()\n\n        self._add_viewer_dock_widget(self.qt_viewer.dockConsole)\n        self._add_viewer_dock_widget(self.qt_viewer.dockLayerControls)\n        self._add_viewer_dock_widget(self.qt_viewer.dockLayerList)\n\n        self.qt_viewer.viewer.events.status.connect(self._status_changed)\n        self.qt_viewer.viewer.events.help.connect(self._help_changed)\n        self.qt_viewer.viewer.events.title.connect(self._title_changed)\n        self.qt_viewer.viewer.events.palette.connect(self._update_palette)\n\n        if perf.USE_PERFMON:\n            # Add DebugMenu if using perfmon. The DebugMenu is intended to\n            # contain non-perfmon stuff as well. When it does we will want\n            # a separate env variable for it.\n            self._debug_menu = DebugMenu(self)\n\n            # The QtPerformance widget only exists if we are using perfmon.\n            self._add_viewer_dock_widget(self.qt_viewer.dockPerformance)\n        else:\n            self._debug_menu = None\n\n        if show:\n            self.show()\n\n    def _add_menubar(self):\n        """"""Add menubar to napari app.""""""\n        self.main_menu = self._qt_window.menuBar()\n        # Menubar shortcuts are only active when the menubar is visible.\n        # Therefore, we set a global shortcut not associated with the menubar\n        # to toggle visibility, *but*, in order to not shadow the menubar\n        # shortcut, we disable it, and only enable it when the menubar is\n        # hidden. See this stackoverflow link for details:\n        # https://stackoverflow.com/questions/50537642/how-to-keep-the-shortcuts-of-a-hidden-widget-in-pyqt5\n        self._main_menu_shortcut = QShortcut(\n            QKeySequence(\'Ctrl+M\'), self._qt_window\n        )\n        self._main_menu_shortcut.activated.connect(\n            self._toggle_menubar_visible\n        )\n        self._main_menu_shortcut.setEnabled(False)\n\n    def _toggle_menubar_visible(self):\n        """"""Toggle visibility of app menubar.\n\n        This function also disables or enables a global keyboard shortcut to\n        show the menubar, since menubar shortcuts are only available while the\n        menubar is visible.\n        """"""\n        if self.main_menu.isVisible():\n            self.main_menu.setVisible(False)\n            self._main_menu_shortcut.setEnabled(True)\n        else:\n            self.main_menu.setVisible(True)\n            self._main_menu_shortcut.setEnabled(False)\n\n    def _add_file_menu(self):\n        """"""Add \'File\' menu to app menubar.""""""\n        open_images = QAction(\'Open File(s)...\', self._qt_window)\n        open_images.setShortcut(\'Ctrl+O\')\n        open_images.setStatusTip(\'Open file(s)\')\n        open_images.triggered.connect(self.qt_viewer._open_files_dialog)\n\n        open_stack = QAction(\'Open Files as Stack...\', self._qt_window)\n        open_stack.setShortcut(\'Ctrl+Alt+O\')\n        open_stack.setStatusTip(\'Open files\')\n        open_stack.triggered.connect(\n            self.qt_viewer._open_files_dialog_as_stack_dialog\n        )\n\n        open_folder = QAction(\'Open Folder...\', self._qt_window)\n        open_folder.setShortcut(\'Ctrl+Shift+O\')\n        open_folder.setStatusTip(\'Open a folder\')\n        open_folder.triggered.connect(self.qt_viewer._open_folder_dialog)\n\n        save_selected_layers = QAction(\n            \'Save Selected Layer(s)...\', self._qt_window\n        )\n        save_selected_layers.setShortcut(\'Ctrl+S\')\n        save_selected_layers.setStatusTip(\'Save selected layers\')\n        save_selected_layers.triggered.connect(\n            lambda: self.qt_viewer._save_layers_dialog(selected=True)\n        )\n\n        save_all_layers = QAction(\'Save All Layers...\', self._qt_window)\n        save_all_layers.setShortcut(\'Ctrl+Shift+S\')\n        save_all_layers.setStatusTip(\'Save all layers\')\n        save_all_layers.triggered.connect(\n            lambda: self.qt_viewer._save_layers_dialog(selected=False)\n        )\n\n        screenshot = QAction(\'Save Screenshot...\', self._qt_window)\n        screenshot.setShortcut(\'Alt+S\')\n        screenshot.setStatusTip(\n            \'Save screenshot of current display, default .png\'\n        )\n        screenshot.triggered.connect(self.qt_viewer._screenshot_dialog)\n\n        screenshot_wv = QAction(\n            \'Save Screenshot with Viewer...\', self._qt_window\n        )\n        screenshot_wv.setShortcut(\'Alt+Shift+S\')\n        screenshot_wv.setStatusTip(\n            \'Save screenshot of current display with the viewer, default .png\'\n        )\n        screenshot_wv.triggered.connect(self._screenshot_dialog)\n\n        # OS X will rename this to Quit and put it in the app menu.\n        exitAction = QAction(\'Exit\', self._qt_window)\n        exitAction.setShortcut(\'Ctrl+Q\')\n        exitAction.setMenuRole(QAction.QuitRole)\n\n        def handle_exit():\n            # if the event loop was started in gui_qt() then the app will be\n            # named \'napari\'. Since the Qapp was started by us, just close it.\n            if QApplication.applicationName() == \'napari\':\n                QApplication.closeAllWindows()\n                QApplication.quit()\n            # otherwise, something else created the QApp before us (such as\n            # %gui qt IPython magic).  If we quit the app in this case, then\n            # *later* attemps to instantiate a napari viewer won\'t work until\n            # the event loop is restarted with app.exec_().  So rather than\n            # quit just close all the windows (and clear our app icon).\n            else:\n                QApplication.setWindowIcon(QIcon())\n                self.close()\n\n        exitAction.triggered.connect(handle_exit)\n\n        self.file_menu = self.main_menu.addMenu(\'&File\')\n        self.file_menu.addAction(open_images)\n        self.file_menu.addAction(open_stack)\n        self.file_menu.addAction(open_folder)\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(save_selected_layers)\n        self.file_menu.addAction(save_all_layers)\n        self.file_menu.addAction(screenshot)\n        self.file_menu.addAction(screenshot_wv)\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(exitAction)\n\n    def _add_view_menu(self):\n        """"""Add \'View\' menu to app menubar.""""""\n        toggle_visible = QAction(\'Toggle Menubar Visibility\', self._qt_window)\n        toggle_visible.setShortcut(\'Ctrl+M\')\n        toggle_visible.setStatusTip(\'Hide Menubar\')\n        toggle_visible.triggered.connect(self._toggle_menubar_visible)\n        toggle_theme = QAction(\'Toggle Theme\', self._qt_window)\n        toggle_theme.setShortcut(\'Ctrl+Shift+T\')\n        toggle_theme.setStatusTip(\'Toggle theme\')\n        toggle_theme.triggered.connect(self.qt_viewer.viewer._toggle_theme)\n        self.view_menu = self.main_menu.addMenu(\'&View\')\n        self.view_menu.addAction(toggle_visible)\n        self.view_menu.addAction(toggle_theme)\n\n    def _add_window_menu(self):\n        """"""Add \'Window\' menu to app menubar.""""""\n        exit_action = QAction(""Close Window"", self._qt_window)\n        exit_action.setShortcut(""Ctrl+W"")\n        exit_action.setStatusTip(\'Close napari window\')\n        exit_action.triggered.connect(self._qt_window.close)\n        self.window_menu = self.main_menu.addMenu(\'&Window\')\n        self.window_menu.addAction(exit_action)\n\n    def _add_plugins_menu(self):\n        """"""Add \'Plugins\' menu to app menubar.""""""\n        self.plugins_menu = self.main_menu.addMenu(\'&Plugins\')\n\n        list_plugins_action = QAction(\n            ""List Installed Plugins..."", self._qt_window\n        )\n        list_plugins_action.setStatusTip(\'List installed plugins\')\n        list_plugins_action.triggered.connect(self._show_plugin_list)\n        self.plugins_menu.addAction(list_plugins_action)\n\n        order_plugin_action = QAction(""Plugin Call Order..."", self._qt_window)\n        order_plugin_action.setStatusTip(\'Change call order for plugins\')\n        order_plugin_action.triggered.connect(self._show_plugin_sorter)\n        self.plugins_menu.addAction(order_plugin_action)\n\n        report_plugin_action = QAction(""Plugin Errors..."", self._qt_window)\n        report_plugin_action.setStatusTip(\n            \'Review stack traces for plugin exceptions and notify developers\'\n        )\n        report_plugin_action.triggered.connect(self._show_plugin_err_reporter)\n        self.plugins_menu.addAction(report_plugin_action)\n\n    def _show_plugin_list(self, plugin_manager=None):\n        """"""Show dialog with a table of installed plugins and metadata.""""""\n        if not plugin_manager:\n            from ..plugins import plugin_manager\n\n        dialog = QDialog(self._qt_window)\n        dialog.setMaximumHeight(800)\n        dialog.setMaximumWidth(1280)\n        layout = QVBoxLayout()\n        # maybe someday add a search bar here?\n        title = QLabel(""Installed Plugins"")\n        title.setObjectName(""h2"")\n        layout.addWidget(title)\n        # get metadata for successfully registered plugins\n        plugin_manager.discover()\n        data = plugin_manager.list_plugin_metadata()\n        data = list(filter(lambda x: x[\'plugin_name\'] != \'builtins\', data))\n        # create a table for it\n        dialog.table = QtDictTable(\n            self._qt_window,\n            data,\n            headers=[\n                \'plugin_name\',\n                \'package\',\n                \'version\',\n                \'url\',\n                \'author\',\n                \'license\',\n            ],\n            min_section_width=60,\n        )\n        dialog.table.setObjectName(""pluginTable"")\n        dialog.table.horizontalHeader().setObjectName(""pluginTableHeader"")\n        dialog.table.verticalHeader().setObjectName(""pluginTableHeader"")\n        dialog.table.setGridStyle(Qt.NoPen)\n        # prevent editing of table\n        dialog.table.setEditTriggers(QAbstractItemView.NoEditTriggers)\n        layout.addWidget(dialog.table)\n        dialog.setLayout(layout)\n        dialog.setAttribute(Qt.WA_DeleteOnClose)\n        self._plugin_list = dialog\n        dialog.exec_()\n\n    def _show_plugin_sorter(self):\n        """"""Show dialog that allows users to sort the call order of plugins.""""""\n        plugin_sorter = QtPluginSorter(parent=self._qt_window)\n        dock_widget = self.add_dock_widget(\n            plugin_sorter, name=\'Plugin Sorter\', area=""right""\n        )\n        plugin_sorter.finished.connect(dock_widget.close)\n        plugin_sorter.finished.connect(plugin_sorter.deleteLater)\n        plugin_sorter.finished.connect(dock_widget.deleteLater)\n\n    def _show_plugin_err_reporter(self):\n        """"""Show dialog that allows users to review and report plugin errors.""""""\n        plugin_sorter = QtPluginErrReporter(parent=self._qt_window)\n        plugin_sorter.exec_()\n\n    def _add_help_menu(self):\n        """"""Add \'Help\' menu to app menubar.""""""\n        self.help_menu = self.main_menu.addMenu(\'&Help\')\n\n        about_action = QAction(""napari Info"", self._qt_window)\n        about_action.setShortcut(""Ctrl+/"")\n        about_action.setStatusTip(\'About napari\')\n        about_action.triggered.connect(\n            lambda e: QtAbout.showAbout(self.qt_viewer)\n        )\n        self.help_menu.addAction(about_action)\n\n        about_key_bindings = QAction(""Show Key Bindings"", self._qt_window)\n        about_key_bindings.setShortcut(""Ctrl+Alt+/"")\n        about_key_bindings.setShortcutContext(Qt.ApplicationShortcut)\n        about_key_bindings.setStatusTip(\'key_bindings\')\n        about_key_bindings.triggered.connect(\n            self.qt_viewer.show_key_bindings_dialog\n        )\n        self.help_menu.addAction(about_key_bindings)\n\n    def add_dock_widget(\n        self,\n        widget: QWidget,\n        *,\n        name: str = \'\',\n        area: str = \'bottom\',\n        allowed_areas=None,\n        shortcut=None,\n    ):\n        """"""Convenience method to add a QDockWidget to the main window\n\n        Parameters\n        ----------\n        widget : QWidget\n            `widget` will be added as QDockWidget\'s main widget.\n        name : str, optional\n            Name of dock widget to appear in window menu.\n        area : str\n            Side of the main window to which the new dock widget will be added.\n            Must be in {\'left\', \'right\', \'top\', \'bottom\'}\n        allowed_areas : list[str], optional\n            Areas, relative to main window, that the widget is allowed dock.\n            Each item in list must be in {\'left\', \'right\', \'top\', \'bottom\'}\n            By default, all areas are allowed.\n        shortcut : str, optional\n            Keyboard shortcut to appear in dropdown menu.\n\n        Returns\n        -------\n        dock_widget : QtViewerDockWidget\n            `dock_widget` that can pass viewer events.\n        """"""\n\n        dock_widget = QtViewerDockWidget(\n            self.qt_viewer,\n            widget,\n            name=name,\n            area=area,\n            allowed_areas=allowed_areas,\n            shortcut=shortcut,\n        )\n        self._add_viewer_dock_widget(dock_widget)\n        return dock_widget\n\n    def _add_viewer_dock_widget(self, dock_widget: QtViewerDockWidget):\n        """"""Add a QtViewerDockWidget to the main window\n\n        Parameters\n        ----------\n        dock_widget : QtViewerDockWidget\n            `dock_widget` will be added to the main window.\n        """"""\n        dock_widget.setParent(self._qt_window)\n        self._qt_window.addDockWidget(dock_widget.qt_area, dock_widget)\n        action = dock_widget.toggleViewAction()\n        action.setStatusTip(dock_widget.name)\n        action.setText(dock_widget.name)\n        if dock_widget.shortcut is not None:\n            action.setShortcut(dock_widget.shortcut)\n        self.window_menu.addAction(action)\n\n    def remove_dock_widget(self, widget):\n        """"""Removes specified dock widget.\n\n        Parameters\n        ----------\n            widget : QWidget | str\n                If widget == \'all\', all docked widgets will be removed.\n        """"""\n        if widget == \'all\':\n            for dw in self._qt_window.findChildren(QDockWidget):\n                self._qt_window.removeDockWidget(dw)\n        else:\n            self._qt_window.removeDockWidget(widget)\n\n    def resize(self, width, height):\n        """"""Resize the window.\n\n        Parameters\n        ----------\n        width : int\n            Width in logical pixels.\n        height : int\n            Height in logical pixels.\n        """"""\n        self._qt_window.resize(width, height)\n\n    def show(self):\n        """"""Resize, show, and bring forward the window.""""""\n        self._qt_window.resize(self._qt_window.layout().sizeHint())\n        self._qt_window.show()\n        # Resize axis labels now that window is shown\n        self.qt_viewer.dims._resize_axis_labels()\n\n        # We want to call Window._qt_window.raise_() in every case *except*\n        # when instantiating a viewer within a gui_qt() context for the\n        # _first_ time within the Qt app\'s lifecycle.\n        #\n        # `app_name` will be ""napari"" iff the application was instantiated in\n        # gui_qt(). isActiveWindow() will be True if it is the second time a\n        # _qt_window has been created. See #732\n        app_name = QApplication.instance().applicationName()\n        if app_name != \'napari\' or self._qt_window.isActiveWindow():\n            self._qt_window.raise_()  # for macOS\n            self._qt_window.activateWindow()  # for Windows\n\n    def _update_palette(self, event=None):\n        """"""Update widget color palette.""""""\n        # set window styles which don\'t use the primary stylesheet\n        # FIXME: this is a problem with the stylesheet not using properties\n        palette = self.qt_viewer.viewer.palette\n        self._status_bar.setStyleSheet(\n            template(\n                \'QStatusBar { background: {{ background }}; \'\n                \'color: {{ text }}; }\',\n                **palette,\n            )\n        )\n        self._qt_center.setStyleSheet(\n            template(\'QWidget { background: {{ background }}; }\', **palette)\n        )\n        self._qt_window.setStyleSheet(template(self.raw_stylesheet, **palette))\n\n    def _status_changed(self, event):\n        """"""Update status bar.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self._status_bar.showMessage(event.text)\n\n    def _title_changed(self, event):\n        """"""Update window title.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self._qt_window.setWindowTitle(event.text)\n\n    def _help_changed(self, event):\n        """"""Update help message on status bar.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self._help.setText(event.text)\n\n    def _screenshot_dialog(self):\n        """"""Save screenshot of current display with viewer, default .png""""""\n        filename, _ = QFileDialog.getSaveFileName(\n            parent=self.qt_viewer,\n            caption=\'Save screenshot with viewer\',\n            directory=self.qt_viewer._last_visited_dir,  # home dir by default\n            filter=""Image files (*.png *.bmp *.gif *.tif *.tiff)"",  # first one used by default\n            # jpg and jpeg not included as they don\'t support an alpha channel\n        )\n        if (filename != \'\') and (filename is not None):\n            # double check that an appropriate extension has been added as the\n            # filter option does not always add an extension on linux and windows\n            # see https://bugreports.qt.io/browse/QTBUG-27186\n            image_extensions = (\'.bmp\', \'.gif\', \'.png\', \'.tif\', \'.tiff\')\n            if not filename.endswith(image_extensions):\n                filename = filename + \'.png\'\n            self.screenshot(path=filename)\n\n    def screenshot(self, path=None):\n        """"""Take currently displayed viewer and convert to an image array.\n\n        Parameters\n        ----------\n        path : str\n            Filename for saving screenshot image.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region.\n        """"""\n        img = self._qt_window.grab().toImage()\n        if path is not None:\n            imsave(path, QImg2array(img))  # scikit-image imsave method\n        return QImg2array(img)\n\n    def close(self):\n        """"""Close the viewer window and cleanup sub-widgets.""""""\n        # on some versions of Darwin, exiting while fullscreen seems to tickle\n        # some bug deep in NSWindow.  This forces the fullscreen keybinding\n        # test to complete its draw cycle, then pop back out of fullscreen.\n        if self._qt_window.isFullScreen():\n            self._qt_window.showNormal()\n            for i in range(8):\n                time.sleep(0.1)\n                QApplication.processEvents()\n        self.qt_viewer.close()\n        self._qt_window.close()\n        del self._qt_window\n'"
napari/_qt/qt_modal.py,0,"b'from qtpy.QtCore import QPoint, Qt, QRect\nfrom qtpy.QtGui import QCursor, QGuiApplication\nfrom qtpy.QtWidgets import QDialog, QFrame, QVBoxLayout\n\n\nclass QtPopup(QDialog):\n    """"""A generic popup window.\n\n    The seemingly extra frame here is to allow rounded corners on a truly\n    transparent background.  New items should be added to QtPopup.frame\n\n    +----------------------------------\n    | Dialog\n    |  +-------------------------------\n    |  | QVBoxLayout\n    |  |  +----------------------------\n    |  |  | QFrame\n    |  |  |  +-------------------------\n    |  |  |  |\n    |  |  |  |  (add a new layout here)\n\n    Parameters\n    ----------\n    parent : qtpy.QtWidgets:QWidget\n        Parent widget of the popup dialog box.\n\n    Attributes\n    ----------\n    frame : qtpy.QtWidgets.QFrame\n        Frame of the popup dialog box.\n    layout : qtpy.QtWidgets.QVBoxLayout\n        Layout of the popup dialog box.\n    """"""\n\n    def __init__(self, parent):\n        super().__init__(parent)\n        self.setObjectName(""QtModalPopup"")\n        self.setModal(False)  # if False, then clicking anywhere else closes it\n        self.setWindowFlags(Qt.Popup | Qt.FramelessWindowHint)\n        self.setLayout(QVBoxLayout())\n\n        self.frame = QFrame()\n        self.frame.setObjectName(""QtPopupFrame"")\n        self.layout().addWidget(self.frame)\n        self.layout().setContentsMargins(0, 0, 0, 0)\n\n    def show_above_mouse(self, *args):\n        """"""Show popup dialog above the mouse cursor position.""""""\n        pos = QCursor().pos()  # mouse position\n        szhint = self.sizeHint()\n        pos -= QPoint(szhint.width() / 2, szhint.height() + 14)\n        self.move(pos)\n        self.show()\n\n    def show_right_of_mouse(self, *args):\n        pos = QCursor().pos()  # mouse position\n        szhint = self.sizeHint()\n        pos -= QPoint(-14, szhint.height() / 4)\n        self.move(pos)\n        self.show()\n\n    def show_at(self, position=\'top\', *, win_ratio=0.9, min_length=0):\n        """"""Show popup at a position relative to the QMainWindow.\n\n        Parameters\n        ----------\n        position : {str, tuple}, optional\n            position in the QMainWindow to show the pop, by default \'top\'\n            if str: must be one of {\'top\', \'bottom\', \'left\', \'right\' }\n            if tuple: must be length 4 with (left, top, width, height)\n        win_ratio : float, optional\n            Fraction of the width (for position = top/bottom) or height (for\n            position = left/right) of the QMainWindow that the popup will\n            occupy.  Only valid when isinstance(position, str).\n            by default 0.9\n        min_length : int, optional\n            Minimum size of the long dimension (width for top/bottom or\n            height fort left/right).\n\n        Raises\n        ------\n        ValueError\n            if position is a string and not one of\n            {\'top\', \'bottom\', \'left\', \'right\' }\n        """"""\n        if isinstance(position, str):\n            window = self.parent().window() if self.parent() else None\n            if not window:\n                raise ValueError(\n                    ""Specifying position as a string is only posible if ""\n                    ""the popup has a parent""\n                )\n            left = window.pos().x()\n            top = window.pos().y()\n            if position in (\'top\', \'bottom\'):\n                width = window.width() * win_ratio\n                width = max(width, min_length)\n                left += (window.width() - width) / 2\n                height = self.sizeHint().height()\n                top += (\n                    24\n                    if position == \'top\'\n                    else (window.height() - height - 12)\n                )\n            elif position in (\'left\', \'right\'):\n                height = window.height() * win_ratio\n                height = max(height, min_length)\n                # 22 is for the title bar\n                top += 22 + (window.height() - height) / 2\n                width = self.sizeHint().width()\n                left += (\n                    12 if position == \'left\' else (window.width() - width - 12)\n                )\n            else:\n                raise ValueError(\n                    \'position must be one of \'\n                    \'[""top"", ""left"", ""bottom"", ""right""]\'\n                )\n        elif isinstance(position, (tuple, list)):\n            assert len(position) == 4, \'`position` argument must have length 4\'\n            left, top, width, height = position\n        else:\n            raise ValueError(f""Wrong type of position {position}"")\n\n        # necessary for transparent round corners\n        self.resize(self.sizeHint())\n        # make sure the popup is completely on the screen\n        # In Qt \xe2\x89\xa55.10 we can use screenAt to know which monitor the mouse is on\n\n        if hasattr(QGuiApplication, ""screenAt""):\n            screen_geometry: QRect = QGuiApplication.screenAt(\n                QCursor.pos()\n            ).geometry()\n        else:\n            # This widget is deprecated since Qt 5.11\n            from qtpy.QtWidgets import QDesktopWidget\n\n            screen_num = QDesktopWidget().screenNumber(QCursor.pos())\n            screen_geometry = QGuiApplication.screens()[screen_num].geometry()\n\n        left = max(\n            min(screen_geometry.right() - width, left), screen_geometry.left()\n        )\n        top = max(\n            min(screen_geometry.bottom() - height, top), screen_geometry.top()\n        )\n        self.setGeometry(left, top, width, height)\n        self.show()\n\n    def keyPressEvent(self, event):\n        """"""Close window on return, else pass event through to super class.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter):\n            return self.close()\n        super().keyPressEvent(event)\n'"
napari/_qt/qt_mode_buttons.py,0,"b'from qtpy.QtWidgets import QRadioButton, QPushButton\n\n\nclass QtModeRadioButton(QRadioButton):\n    """"""Creates a radio button that can enable a specific layer mode.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        The layer instance that this button controls.\n    button_name : str\n        Name for the button.  This is mostly used to identify the button\n        in stylesheets (e.g. to add a custom icon)\n    mode : Enum\n        The mode to enable when this button is clicked.\n    tooltip : str, optional\n        A tooltip to display when hovering the mouse on this button,\n        by default it will be set to `button_name`.\n    checked : bool, optional\n        Whether the button is activate, by default False.\n        One button in a QButtonGroup should be initially checked.\n\n    Attributes\n    ----------\n    layer : napari.layers.Layer\n        The layer instance that this button controls.\n    """"""\n\n    def __init__(\n        self, layer, button_name, mode, *, tooltip=None, checked=False\n    ):\n        super().__init__()\n\n        self.layer = layer\n        self.setToolTip(tooltip or button_name)\n        self.setChecked(checked)\n        self.setProperty(\'mode\', button_name)\n        self.setFixedWidth(28)\n        self.mode = mode\n        if mode is not None:\n            self.toggled.connect(self._set_mode)\n\n    def _set_mode(self, bool):\n        """"""Toggle the mode associated with the layer.\n\n        Parameters\n        ----------\n        bool : bool\n            Whether this mode is currently selected or not.\n        """"""\n        with self.layer.events.mode.blocker(self._set_mode):\n            if bool:\n                self.layer.mode = self.mode\n\n\nclass QtModePushButton(QPushButton):\n    """"""Creates a radio button that can trigger a specific action.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        The layer instance that this button controls.\n    button_name : str\n        Name for the button.  This is mostly used to identify the button\n        in stylesheets (e.g. to add a custom icon)\n    slot : callable, optional\n        The function to call when this button is clicked.\n    tooltip : str, optional\n        A tooltip to display when hovering the mouse on this button.\n\n    Attributes\n    ----------\n    layer : napari.layers.Layer\n        The layer instance that this button controls.\n    """"""\n\n    def __init__(self, layer, button_name, *, slot=None, tooltip=None):\n        super().__init__()\n\n        self.layer = layer\n        self.setProperty(\'mode\', button_name)\n        self.setToolTip(tooltip or button_name)\n        self.setFixedWidth(28)\n        self.setFixedHeight(28)\n        if slot is not None:\n            self.clicked.connect(slot)\n'"
napari/_qt/qt_performance.py,0,"b'""""""QtPerformance widget to show performance information.\n""""""\nimport time\n\nfrom qtpy.QtCore import QTimer, Qt\nfrom qtpy.QtGui import QTextCursor\n\nfrom qtpy.QtWidgets import (\n    QComboBox,\n    QHBoxLayout,\n    QLabel,\n    QProgressBar,\n    QSizePolicy,\n    QSpacerItem,\n    QTextEdit,\n    QVBoxLayout,\n    QWidget,\n)\n\nfrom ..utils import perf\n\n\nclass TextLog(QTextEdit):\n    """"""Text window we can write ""log"" messages to.\n\n    TODO: need to limit length, erase oldest messages?\n    """"""\n\n    def append(self, name: str, time_ms: float) -> None:\n        """"""Add one line of text for this timer.\n\n        Parameters\n        ----------\n        name : str\n            Timer name.\n        time_ms : float\n            Duration of the timer in milliseconds.\n        """"""\n        self.moveCursor(QTextCursor.End)\n        self.setTextColor(Qt.red)\n        self.insertPlainText(f""{time_ms:5.0f}ms {name}\\n"")\n\n\nclass QtPerformance(QWidget):\n    """"""Dockable widget to show performance info.\n\n    Notes\n    -----\n\n    1) The progress bar doesn\'t show ""progress"", we use it as a bar graph to\n       show the average duration of recent ""UpdateRequest"" events. This\n       is actually not the total draw time, but it\'s generally the biggest\n       part of each frame.\n\n    2) We log any event whose duration is longer than the threshold.\n\n    3) We show uptime so you can tell if this window is being updated at all.\n\n    Attributes\n    ----------\n    start_time : float\n        Time is seconds when widget was created.\n    bar : QProgressBar\n        The progress bar we use as your draw time indicator.\n    thresh_ms : float\n        Log events whose duration is longer then this.\n    timer_label : QLabel\n        We write the current ""uptime"" into this label.\n    timer : QTimer\n        To update our window every UPDATE_MS.\n    """"""\n\n    # We log events slower than some threshold (in milliseconds).\n    THRESH_DEFAULT = 100\n    THRESH_OPTIONS = [\n        ""1"",\n        ""5"",\n        ""10"",\n        ""15"",\n        ""20"",\n        ""30"",\n        ""40"",\n        ""50"",\n        ""100"",\n        ""200"",\n    ]\n\n    # Update at 250ms / 4Hz for now. The more we update more alive our\n    # display will look, but the more we will slow things down.\n    UPDATE_MS = 250\n\n    def __init__(self):\n        """"""Create our windgets.\n        """"""\n        super().__init__()\n        layout = QVBoxLayout()\n\n        # For our ""uptime"" timer.\n        self.start_time = time.time()\n\n        # Label for our progress bar.\n        bar_label = QLabel(""Draw Time:"")\n        layout.addWidget(bar_label)\n\n        # Progress bar is not used for ""progress"", it\'s just a bar graph to show\n        # the ""draw time"", the duration of the ""UpdateRequest"" event.\n        bar = QProgressBar()\n        bar.setRange(0, 100)\n        bar.setValue(50)\n        bar.setFormat(""%vms"")\n        layout.addWidget(bar)\n        self.bar = bar\n\n        # We let the user set the ""slow event"" threshold.\n        self.thresh_ms = self.THRESH_DEFAULT\n        self.thresh_combo = QComboBox()\n        self.thresh_combo.addItems(self.THRESH_OPTIONS)\n        self.thresh_combo.activated[str].connect(self._change_thresh)\n        self.thresh_combo.setCurrentText(str(self.thresh_ms))\n\n        combo_layout = QHBoxLayout()\n        combo_layout.addWidget(QLabel(""Show Events Slower Than:""))\n        combo_layout.addWidget(self.thresh_combo)\n        combo_layout.addWidget(QLabel(""milliseconds""))\n        combo_layout.addItem(\n            QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)\n        )\n        layout.addLayout(combo_layout)\n\n        # We log slow events to this window.\n        self.log = TextLog()\n        layout.addWidget(self.log)\n\n        # Uptime label. To indicate if the widget is getting updated.\n        label = QLabel(\'\')\n        layout.addWidget(label)\n        self.timer_label = label\n\n        self.setLayout(layout)\n\n        # Update us with a timer.\n        self.timer = QTimer(self)\n        self.timer.timeout.connect(self.update)\n        self.timer.setInterval(self.UPDATE_MS)\n        self.timer.start()\n\n    def _change_thresh(self, text):\n        """"""Threshold combo box change.\n        """"""\n        self.thresh_ms = float(text)\n        self.log.clear()  # start fresh with this new threshold\n\n    def _get_timer_info(self):\n        """"""Get the information from the timers that we want to display.\n        """"""\n        average = None\n        long_events = []\n\n        # We don\'t update any GUI/widgets while iterating over the timers.\n        # Updating widgets can create immediate Qt Events which would modify the\n        # timers out from under us!\n        for name, timer in perf.timers.timers.items():\n\n            # The Qt Event ""UpdateRequest"" is the main ""draw"" event, so\n            # that\'s what we use for our progress bar.\n            if name == ""UpdateRequest"":\n                average = timer.average\n\n            # Log any ""long"" events to the text window.\n            if timer.max >= self.thresh_ms:\n                long_events.append((name, timer.max))\n\n        return average, long_events\n\n    def update(self):\n        """"""Update our label and progress bar and log any new slow events.\n        """"""\n        # Update our timer label.\n        elapsed = time.time() - self.start_time\n        self.timer_label.setText(f""Uptime: {elapsed:.2f}"")\n\n        average, long_events = self._get_timer_info()\n\n        # Now safe to update the GUI: progress bar first.\n        if average is not None:\n            self.bar.setValue(average)\n\n        # And log any new slow events.\n        for name, time_ms in long_events:\n            self.log.append(name, time_ms)\n\n        # Clear all the timers since we\'ve displayed them. They will immediately\n        # start accumulating numbers for the next update.\n        perf.timers.clear()\n'"
napari/_qt/qt_plugin_report.py,0,"b'""""""Provides a QtPluginErrReporter that allows the user report plugin errors.\n""""""\nfrom typing import Optional\n\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtGui import QGuiApplication\nfrom qtpy.QtWidgets import (\n    QComboBox,\n    QDialog,\n    QHBoxLayout,\n    QLabel,\n    QPushButton,\n    QTextEdit,\n    QVBoxLayout,\n    QWidget,\n)\n\nfrom ..plugins.exceptions import format_exceptions\nfrom napari_plugin_engine import PluginManager, standard_metadata\n\n\nclass QtPluginErrReporter(QDialog):\n    """"""Dialog that allows users to review and report PluginError tracebacks.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        Optional parent widget for this widget.\n    initial_plugin : str, optional\n        If provided, errors from ``initial_plugin`` will be shown when the\n        dialog is created, by default None\n\n    Attributes\n    ----------\n    text_area : qtpy.QtWidgets.QTextEdit\n        The text area where traceback information will be shown.\n    plugin_combo : qtpy.QtWidgets.QComboBox\n        The dropdown menu used to select the current plugin\n    github_button : qtpy.QtWidgets.QPushButton\n        A button that, when pressed, will open an issue at the current plugin\'s\n        github issue tracker, prepopulated with a formatted traceback.  Button\n        is only visible if a github URL is detected in the package metadata for\n        the current plugin.\n    clipboard_button : qtpy.QtWidgets.QPushButton\n        A button that, when pressed, copies the current traceback information\n        to the clipboard.  (HTML tags are removed in the copied text.)\n    plugin_meta : qtpy.QtWidgets.QLabel\n        A label that will show available plugin metadata (such as home page).\n    """"""\n\n    NULL_OPTION = \'select plugin... \'\n\n    def __init__(\n        self,\n        plugin_manager: Optional[PluginManager] = None,\n        *,\n        parent: Optional[QWidget] = None,\n        initial_plugin: Optional[str] = None,\n    ) -> None:\n        super().__init__(parent)\n        if not plugin_manager:\n            from ..plugins import plugin_manager as _pm\n\n            self.plugin_manager = _pm\n        else:\n            self.plugin_manager = plugin_manager\n\n        self.setWindowTitle(\'Recorded Plugin Exceptions\')\n        self.setWindowModality(Qt.NonModal)\n        self.layout = QVBoxLayout()\n        self.layout.setSpacing(0)\n        self.layout.setContentsMargins(10, 10, 10, 10)\n        self.setLayout(self.layout)\n\n        self.text_area = QTextEdit()\n        self.text_area.setTextInteractionFlags(Qt.TextSelectableByMouse)\n        self.text_area.setMinimumWidth(360)\n\n        # Create plugin dropdown menu\n        self.plugin_combo = QComboBox()\n        self.plugin_combo.addItem(self.NULL_OPTION)\n        bad_plugins = [e.plugin_name for e in self.plugin_manager.get_errors()]\n        self.plugin_combo.addItems(list(sorted(set(bad_plugins))))\n        self.plugin_combo.currentTextChanged.connect(self.set_plugin)\n        self.plugin_combo.setCurrentText(self.NULL_OPTION)\n\n        # create github button (gets connected in self.set_plugin)\n        self.github_button = QPushButton(\'Open issue on GitHub\', self)\n        self.github_button.setToolTip(\n            ""Open a web browser to submit this error log\\n""\n            ""to the developer\'s GitHub issue tracker""\n        )\n        self.github_button.hide()\n\n        # create copy to clipboard button\n        self.clipboard_button = QPushButton()\n        self.clipboard_button.hide()\n        self.clipboard_button.setObjectName(""QtCopyToClipboardButton"")\n        self.clipboard_button.setToolTip(""Copy error log to clipboard"")\n        self.clipboard_button.clicked.connect(self.copyToClipboard)\n\n        # plugin_meta contains a URL to the home page, (and/or other details)\n        self.plugin_meta = QLabel(\'\', parent=self)\n        self.plugin_meta.setObjectName(""pluginInfo"")\n        self.plugin_meta.setTextFormat(Qt.RichText)\n        self.plugin_meta.setTextInteractionFlags(Qt.TextBrowserInteraction)\n        self.plugin_meta.setOpenExternalLinks(True)\n        self.plugin_meta.setAlignment(Qt.AlignRight)\n\n        # make layout\n        row_1_layout = QHBoxLayout()\n        row_1_layout.setContentsMargins(11, 5, 10, 0)\n        row_1_layout.addStretch(1)\n        row_1_layout.addWidget(self.plugin_meta)\n        row_2_layout = QHBoxLayout()\n        row_2_layout.setContentsMargins(11, 5, 10, 0)\n        row_2_layout.addWidget(self.plugin_combo)\n        row_2_layout.addStretch(1)\n        row_2_layout.addWidget(self.github_button)\n        row_2_layout.addWidget(self.clipboard_button)\n        row_2_layout.setSpacing(5)\n        self.layout.addLayout(row_1_layout)\n        self.layout.addLayout(row_2_layout)\n        self.layout.addWidget(self.text_area, 1)\n        self.setMinimumWidth(750)\n        self.setMinimumHeight(600)\n\n        if initial_plugin:\n            self.set_plugin(initial_plugin)\n\n    def set_plugin(self, plugin: str) -> None:\n        """"""Set the current plugin shown in the dropdown and text area.\n\n        Parameters\n        ----------\n        plugin : str\n            name of a plugin that has created an error this session.\n        """"""\n        self.github_button.hide()\n        self.clipboard_button.hide()\n        try:\n            self.github_button.clicked.disconnect()\n        # when disconnecting a non-existent signal\n        # PySide2 raises runtimeError, PyQt5 raises TypeError\n        except (RuntimeError, TypeError):\n            pass\n\n        if not plugin or (plugin == self.NULL_OPTION):\n            self.plugin_meta.setText(\'\')\n            self.text_area.setHtml(\'\')\n            return\n\n        if not self.plugin_manager.get_errors(plugin):\n            raise ValueError(f""No errors reported for plugin \'{plugin}\'"")\n        self.plugin_combo.setCurrentText(plugin)\n\n        err_string = format_exceptions(plugin, as_html=True)\n        self.text_area.setHtml(err_string)\n        self.clipboard_button.show()\n\n        # set metadata and outbound links/buttons\n        err0 = self.plugin_manager.get_errors(plugin)[0]\n        meta = standard_metadata(err0.plugin) if err0.plugin else {}\n        meta_text = \'\'\n        if not meta:\n            self.plugin_meta.setText(meta_text)\n            return\n\n        url = meta.get(\'url\')\n        if url:\n            meta_text += (\n                \'<span style=""color:#999;"">plugin home page:&nbsp;&nbsp;\'\n                f\'</span><a href=""{url}"" style=""color:#999"">{url}</a>\'\n            )\n            if \'github.com\' in url:\n\n                def onclick():\n                    import webbrowser\n\n                    err = format_exceptions(plugin, as_html=False)\n                    err = (\n                        ""<!--Provide detail on the error here-->\\n\\n\\n\\n""\n                        ""<details>\\n<summary>Traceback from napari</summary>""\n                        f""\\n\\n```\\n{err}\\n```\\n</details>""\n                    )\n                    url = f\'{meta.get(""url"")}/issues/new?&body={err}\'\n                    webbrowser.open(url, new=2)\n\n                self.github_button.clicked.connect(onclick)\n                self.github_button.show()\n        self.plugin_meta.setText(meta_text)\n\n    def copyToClipboard(self) -> None:\n        """"""Copy current plugin traceback info to clipboard as plain text.""""""\n        plugin = self.plugin_combo.currentText()\n        err_string = format_exceptions(plugin, as_html=False)\n        cb = QGuiApplication.clipboard()\n        cb.setText(err_string)\n'"
napari/_qt/qt_plugin_sorter.py,0,"b'""""""Provides a QtPluginSorter that allows the user to change plugin call order.\n""""""\nfrom typing import List, Optional, Union\n\nfrom qtpy.QtCore import QEvent, Qt, Signal, Slot\nfrom qtpy.QtWidgets import (\n    QCheckBox,\n    QComboBox,\n    QDialog,\n    QFrame,\n    QGraphicsOpacityEffect,\n    QHBoxLayout,\n    QLabel,\n    QListWidget,\n    QListWidgetItem,\n    QSizePolicy,\n    QVBoxLayout,\n    QWidget,\n)\n\nfrom ..plugins import plugin_manager as napari_plugin_manager\nfrom napari_plugin_engine import HookImplementation, HookCaller, PluginManager\nfrom .utils import drag_with_pixmap\n\n\nclass ImplementationListItem(QFrame):\n    """"""A Widget to render each hook implementation item in a ListWidget.\n\n    Parameters\n    ----------\n    item : QListWidgetItem\n        An item instance from a QListWidget. This will most likely come from\n        :meth:`QtHookImplementationListWidget.add_hook_implementation_to_list`.\n    parent : QWidget, optional\n        The parent widget, by default None\n\n    Attributes\n    ----------\n    plugin_name_label : QLabel\n        The name of the plugin providing the hook implementation.\n    enabled_checkbox : QCheckBox\n        Checkbox to set the ``enabled`` status of the corresponding hook\n        implementation.\n    opacity : QGraphicsOpacityEffect\n        The opacity of the whole widget.  When self.enabled_checkbox is\n        unchecked, the opacity of the item is decreased.\n    """"""\n\n    def __init__(self, item: QListWidgetItem, parent: QWidget = None):\n        super().__init__(parent)\n        self.setToolTip(""Click and drag to change call order"")\n        self.item = item\n        self.opacity = QGraphicsOpacityEffect(self)\n        self.setGraphicsEffect(self.opacity)\n        layout = QHBoxLayout()\n        self.setLayout(layout)\n\n        self.position_label = QLabel()\n        self.update_position_label()\n\n        self.plugin_name_label = QLabel(item.hook_implementation.plugin_name)\n        self.enabled_checkbox = QCheckBox(self)\n        self.enabled_checkbox.setToolTip(""Uncheck to disable this plugin"")\n        self.enabled_checkbox.stateChanged.connect(self._set_enabled)\n        self.enabled_checkbox.setChecked(\n            getattr(item.hook_implementation, \'enabled\', True)\n        )\n        layout.addWidget(self.position_label)\n        layout.addWidget(self.enabled_checkbox)\n        layout.addWidget(self.plugin_name_label)\n        layout.setStretch(2, 1)\n        layout.setContentsMargins(0, 0, 0, 0)\n\n    def _set_enabled(self, state: Union[bool, int]):\n        """"""Set the enabled state of this hook implementation to ``state``.""""""\n        self.item.hook_implementation.enabled = bool(state)\n        self.opacity.setOpacity(1 if state else 0.5)\n\n    def update_position_label(self, order=None):\n        """"""Update the label showing the position of this item in the list.\n\n        Parameters\n        ----------\n        order : list, optional\n            A HookOrderType list ... unused by this function, but here for ease\n            of signal connection, by default None.\n        """"""\n        position = self.item.listWidget().indexFromItem(self.item).row() + 1\n        self.position_label.setText(str(position))\n\n\nclass QtHookImplementationListWidget(QListWidget):\n    """"""A ListWidget to display & sort the call order of a hook implementation.\n\n    This class will usually be instantiated by a\n    :class:`~napari._qt.qt_plugin_sorter.QtPluginSorter`.  Each item in the list\n    will be rendered as a :class:`ImplementationListItem`.\n\n    Parameters\n    ----------\n    parent : QWidget, optional\n        Optional parent widget, by default None\n    hook : HookCaller, optional\n        The ``HookCaller`` for which to show implementations. by default None\n        (i.e. no hooks shown)\n\n    Attributes\n    ----------\n    hook_caller : HookCaller or None\n        The current ``HookCaller`` instance being shown in the list.\n    """"""\n\n    order_changed = Signal(list)  # emitted when the user changes the order.\n\n    def __init__(\n        self,\n        parent: Optional[QWidget] = None,\n        hook_caller: Optional[HookCaller] = None,\n    ):\n        super().__init__(parent)\n        self.setDefaultDropAction(Qt.MoveAction)\n        self.setDragEnabled(True)\n        self.setDragDropMode(self.InternalMove)\n        self.setSelectionMode(self.SingleSelection)\n        self.setAcceptDrops(True)\n        self.setSpacing(1)\n        self.setMinimumHeight(1)\n        self.setSizePolicy(\n            QSizePolicy.MinimumExpanding, QSizePolicy.MinimumExpanding\n        )\n        self.order_changed.connect(self.permute_hook)\n        self.hook_caller: Optional[HookCaller] = None\n        self.set_hook_caller(hook_caller)\n\n    def set_hook_caller(self, hook_caller: Optional[HookCaller]):\n        """"""Set the list widget to show hook implementations for ``hook_caller``.\n\n        Parameters\n        ----------\n        hook : HookCaller, optional\n            A ``HookCaller`` for which to show implementations. by default None\n            (i.e. no hooks shown)\n        """"""\n        self.clear()\n        self.hook_caller = hook_caller\n        if not hook_caller:\n            return\n\n        # _nonwrappers returns hook implementations in REVERSE call order\n        # so we reverse them here to show them in the list in the order in\n        # which they get called.\n        for hook_implementation in reversed(hook_caller._nonwrappers):\n            self.append_hook_implementation(hook_implementation)\n\n    def append_hook_implementation(\n        self, hook_implementation: HookImplementation\n    ):\n        """"""Add a list item for ``hook_implementation`` with a custom widget.\n\n        Parameters\n        ----------\n        hook_implementation : HookImplementation\n            The hook implementation object to add to the list.\n        """"""\n        item = QListWidgetItem(parent=self)\n        item.hook_implementation = hook_implementation\n        self.addItem(item)\n        widg = ImplementationListItem(item, parent=self)\n        item.setSizeHint(widg.sizeHint())\n        self.order_changed.connect(widg.update_position_label)\n        self.setItemWidget(item, widg)\n\n    def dropEvent(self, event: QEvent):\n        """"""Triggered when the user moves & drops one of the items in the list.\n\n        Parameters\n        ----------\n        event : QEvent\n            The event that triggered the dropEvent.\n        """"""\n        super().dropEvent(event)\n        order = [self.item(r).hook_implementation for r in range(self.count())]\n        self.order_changed.emit(order)\n\n    def startDrag(self, supportedActions: Qt.DropActions):\n        drag = drag_with_pixmap(self)\n        drag.exec_(supportedActions, Qt.MoveAction)\n\n    @Slot(list)\n    def permute_hook(self, order: List[HookImplementation]):\n        """"""Rearrage the call order of the hooks for the current hook impl.\n\n        Parameters\n        ----------\n        order : list\n            A list of str, hook_implementation, or module_or_class, with the\n            desired CALL ORDER of the hook implementations.\n        """"""\n        if not self.hook_caller:\n            return\n        self.hook_caller.bring_to_front(order)\n\n\nclass QtPluginSorter(QDialog):\n    """"""Dialog that allows a user to change the call order of plugin hooks.\n\n    A main QComboBox lets the user pick which hook specification they would\n    like to reorder.  Then a :class:`QtHookImplementationListWidget` shows the\n    current call order for all implementations of the current hook\n    specification.  The user may then reorder them, or disable them by checking\n    the checkbox next to each hook implementation name.\n\n    Parameters\n    ----------\n    plugin_manager : PluginManager, optional\n        An instance of a PluginManager. by default, the main\n        :class:`~napari.plugins.manager.PluginManager` instance\n    parent : QWidget, optional\n        Optional parent widget, by default None\n    initial_hook : str, optional\n        If provided the QComboBox at the top of the dialog will be set to\n        this hook, by default None\n    firstresult_only : bool, optional\n        If True, only hook specifications that declare the ""firstresult""\n        option will be included.  (these are hooks for which only the first\n        non None result is returned).  by default True (because it makes\n        less sense to sort hooks where we just collect all results anyway)\n        https://pluggy.readthedocs.io/en/latest/#first-result-only\n\n    Attributes\n    ----------\n    hook_combo_box : QComboBox\n        A dropdown menu to select the current hook.\n    hook_list : QtHookImplementationListWidget\n        The list widget that displays (and allows sorting of) all of the hook\n        implementations for the currently selected hook.\n    """"""\n\n    NULL_OPTION = \'select hook... \'\n\n    def __init__(\n        self,\n        plugin_manager: PluginManager = napari_plugin_manager,\n        *,\n        parent: Optional[QWidget] = None,\n        initial_hook: Optional[str] = None,\n        firstresult_only: bool = True,\n    ):\n        super().__init__(parent)\n        self.setWindowModality(Qt.NonModal)\n        self.plugin_manager = plugin_manager\n        self.layout = QVBoxLayout()\n        self.setLayout(self.layout)\n        self.hook_combo_box = QComboBox()\n        self.hook_combo_box.addItem(self.NULL_OPTION)\n\n        # populate comboBox with all of the hooks known by the plugin manager\n        hooks = []\n        for name, hook_caller in plugin_manager.hooks.items():\n            if firstresult_only:\n                # if the firstresult_only option is set\n                # we only want to include hook_specifications that declare the\n                # ""firstresult"" option as True.\n                if not hook_caller.spec.opts.get(\'firstresult\', False):\n                    continue\n            hooks.append(name)\n        self.hook_combo_box.addItems(hooks)\n        self.hook_combo_box.setToolTip(\n            ""select the hook specification to reorder""\n        )\n        self.hook_combo_box.activated[str].connect(self.set_current_hook)\n        self.hook_list = QtHookImplementationListWidget(parent=self)\n\n        title = QLabel(\'Plugin Sorter\')\n        title.setObjectName(""h2"")\n        self.layout.addWidget(title)\n\n        instructions = QLabel(\n            \'Select a hook to rearrange, then drag and \'\n            \'drop plugins into the desired call order. \'\n            \'\\nDisable plugins by unchecking their checkbox.\'\n        )\n        instructions.setWordWrap(True)\n        self.layout.addWidget(instructions)\n\n        self.layout.addWidget(self.hook_combo_box)\n        self.layout.addWidget(self.hook_list)\n        if initial_hook is not None:\n            self.hook_combo_box.setCurrentText(initial_hook)\n            self.set_current_hook(initial_hook)\n\n    def set_current_hook(self, hook: str):\n        """"""Change the hook specification shown in the list widget.\n\n        Parameters\n        ----------\n        hook : str\n            Name of the new hook specification to show.\n        """"""\n        if hook == self.NULL_OPTION:\n            hook_caller = None\n        else:\n            hook_caller = getattr(self.plugin_manager.hooks, hook)\n        self.hook_list.set_hook_caller(hook_caller)\n'"
napari/_qt/qt_range_slider.py,0,"b'""""""\nRange slider, extended QWidget slider for napari.\n""""""\nfrom qtpy.QtGui import QPainter, QColor\nfrom qtpy.QtCore import Signal, Property, Qt\nfrom qtpy.QtWidgets import QWidget\nfrom ..utils.validators import validate_n_seq\n\n\nvalidate_2_tuple = validate_n_seq(2)\n\n\nclass QRangeSlider(QWidget):\n    """"""\n    QRangeSlider class, super class for QVRangeSlider and QHRangeSlider.\n    """"""\n\n    valuesChanged = Signal(tuple)\n    rangeChanged = Signal(tuple)\n    collapsedChanged = Signal(bool)\n    focused = Signal()\n    resized = Signal()\n\n    def __init__(\n        self,\n        initial_values=None,\n        data_range=None,\n        step_size=None,\n        collapsible=True,\n        collapsed=False,\n        parent=None,\n    ):\n        """"""A range slider with two handles for min/max values.\n\n        Values should be provided in the range of the underlying data.\n        (normalization to 0-1 happens internally in the slider.sliderValues())\n\n        Parameters\n        ----------\n        initial_values : 2-tuple, optional\n            Initial min & max values of the slider, defaults to (0.2, 0.8)\n        data_range : 2-tuple, optional\n            Min and max of the slider range, defaults to (0, 1)\n        step_size : float, optional\n            Single step size for the slider, defaults to 1\n        collapsible : bool\n            Whether the slider is collapsible, defaults to True.\n        collapsed : bool\n            Whether the slider begins collapsed, defaults to False.\n        parent : qtpy.QtWidgets.QWidget\n            Parent widget.\n        """"""\n        super().__init__(parent)\n        self.handle_radius = 8\n        self.slider_width = 6\n        self.moving = ""none""\n        self.collapsible = collapsible\n        self.collapsed = collapsed\n        self.prev_moving = None\n        self.bc_min = None\n        self.bc_max = None\n\n        # Variables initialized in methods\n        self.value_min = 0\n        self.value_max = 1\n        self.start_display_min = None\n        self.start_display_max = None\n        self.start_pos = None\n        self.display_min = None\n        self.display_max = None\n\n        self.setBarColor(QColor(200, 200, 200))\n        self.setBackgroundColor(QColor(100, 100, 100))\n        self.setHandleColor(QColor(200, 200, 200))\n        self.setHandleBorderColor(QColor(200, 200, 200))\n\n        self.setRange((0, 100) if data_range is None else data_range)\n        self.setValues((20, 80) if initial_values is None else initial_values)\n        if step_size is None:\n            # pick an appropriate slider step size based on the data range\n            if data_range is not None:\n                step_size = (data_range[1] - data_range[0]) / 1000\n            else:\n                step_size = 0.001\n        self.setStep(step_size)\n        if not parent:\n            if \'HRange\' in self.__class__.__name__:\n                self.setGeometry(200, 200, 200, 20)\n            else:\n                self.setGeometry(200, 200, 20, 200)\n\n    def range(self):\n        """"""Min and max possible values for the slider range. In data units""""""\n        return self.data_range_min, self.data_range_max\n\n    def setRange(self, values):\n        """"""Min and max possible values for the slider range. In data units.""""""\n        validate_2_tuple(values)\n        self.data_range_min, self.data_range_max = values\n        self.rangeChanged.emit(self.range())\n        self.updateDisplayPositions()\n\n    def values(self):\n        """"""Current slider values.\n\n        Returns\n        -------\n        tuple\n            Current minimum and maximum values of the range slider\n        """"""\n        return tuple(\n            [self._slider_to_data_value(v) for v in self.sliderValues()]\n        )\n\n    def setValues(self, values):\n        self.setSliderValues([self._data_to_slider_value(v) for v in values])\n\n    def sliderValues(self):\n        """"""Current slider values, as a fraction of slider width.\n\n        Returns\n        -------\n        values : 2-tuple of int\n            Start and end of the range.\n        """"""\n        return self.value_min, self.value_max\n\n    def setSliderValues(self, values):\n        """"""Set current slider values, as a fraction of slider width.\n\n        Parameters\n        ----------\n        values : 2-tuple of float or int\n            Start and end of the range.\n        """"""\n        validate_2_tuple(values)\n        self.value_min, self.value_max = values\n        self.valuesChanged.emit(self.values())\n        self.updateDisplayPositions()\n\n    def setStep(self, step):\n        self._step = step\n\n    @property\n    def single_step(self):\n        return self._step / self.scale\n\n    def mouseMoveEvent(self, event):\n        if not self.isEnabled():\n            return\n\n        size = self.rangeSliderSize()\n        pos = self.getPos(event)\n        if self.moving == ""min"":\n            if pos <= self.handle_radius:\n                self.display_min = self.handle_radius\n            elif pos > self.display_max - self.handle_radius / 2:\n                self.display_min = self.display_max - self.handle_radius / 2\n            else:\n                self.display_min = pos\n        elif self.moving == ""max"":\n            if pos >= size + self.handle_radius:\n                self.display_max = size + self.handle_radius\n            elif pos < self.display_min + self.handle_radius / 2:\n                self.display_max = self.display_min + self.handle_radius / 2\n            else:\n                self.display_max = pos\n        elif self.moving == ""bar"":\n            width = self.start_display_max - self.start_display_min\n            lower_part = self.start_pos - self.start_display_min\n            upper_part = self.start_display_max - self.start_pos\n            if pos + upper_part >= size + self.handle_radius:\n                self.display_max = size + self.handle_radius\n                self.display_min = self.display_max - width\n            elif pos - lower_part <= self.handle_radius:\n                self.display_min = self.handle_radius\n                self.display_max = self.display_min + width\n            else:\n                self.display_min = pos - lower_part\n                self.display_max = self.display_min + width\n\n        self.updateValuesFromDisplay()\n\n    def mousePressEvent(self, event):\n        if not self.isEnabled():\n            return\n\n        pos = self.getPos(event)\n        top = self.rangeSliderSize() + self.handle_radius\n        if event.button() == Qt.LeftButton:\n            if not self.collapsed:\n                if abs(self.display_min - pos) <= (self.handle_radius):\n                    self.moving = ""min""\n                elif abs(self.display_max - pos) <= (self.handle_radius):\n                    self.moving = ""max""\n                elif pos > self.display_min and pos < self.display_max:\n                    self.moving = ""bar""\n                elif pos > self.display_max and pos < top:\n                    self.display_max = pos\n                    self.moving = ""max""\n                    self.updateValuesFromDisplay()\n                elif pos < self.display_min and pos > self.handle_radius:\n                    self.display_min = pos\n                    self.moving = ""min""\n                    self.updateValuesFromDisplay()\n            else:\n                self.moving = ""bar""\n                if pos > self.handle_radius and pos < top:\n                    self.display_max = pos\n                    self.display_min = pos\n        else:\n            if self.collapsible:\n                if self.collapsed:\n                    self.expand()\n                else:\n                    self.collapse()\n                self.collapsedChanged.emit(self.collapsed)\n\n        self.start_display_min = self.display_min\n        self.start_display_max = self.display_max\n        self.start_pos = pos\n        self.focused.emit()\n\n    def mouseReleaseEvent(self, event):\n        if self.isEnabled():\n            if not (self.moving == ""none""):\n                self.valuesChanged.emit(self.values())\n            self.moving = ""none""\n\n    def collapse(self):\n        self.bc_min, self.bc_max = self.value_min, self.value_max\n        midpoint = (self.value_max + self.value_min) / 2\n        min_value = midpoint\n        max_value = midpoint\n        self.setSliderValues((min_value, max_value))\n        self.collapsed = True\n\n    def expand(self):\n        _mid = (self.bc_max - self.bc_min) / 2\n        min_value = self.value_min - _mid\n        max_value = self.value_min + _mid\n        if min_value < 0:\n            min_value = 0\n            max_value = self.bc_max - self.bc_min\n        elif max_value > 1:\n            max_value = 1\n            min_value = max_value - (self.bc_max - self.bc_min)\n        self.setSliderValues((min_value, max_value))\n        self.collapsed = False\n\n    def resizeEvent(self, event):\n        self.updateDisplayPositions()\n        self.resized.emit()\n\n    def updateDisplayPositions(self):\n        size = self.rangeSliderSize()\n        range_min = int(size * self.value_min)\n        range_max = int(size * self.value_max)\n        self.display_min = range_min + self.handle_radius\n        self.display_max = range_max + self.handle_radius\n        self.update()\n\n    def _data_to_slider_value(self, value):\n        rmin, rmax = self.range()\n        return (value - rmin) / self.scale\n\n    def _slider_to_data_value(self, value):\n        rmin, rmax = self.range()\n        return rmin + value * self.scale\n\n    @property\n    def scale(self):\n        return self.data_range_max - self.data_range_min\n\n    def updateValuesFromDisplay(self):\n        size = self.rangeSliderSize()\n        val_min, val_max = self.sliderValues()\n        if (self.moving == ""min"") or (self.moving == ""bar""):\n            scale_min = (self.display_min - self.handle_radius) / size\n            ratio = round(scale_min / self.single_step)\n            val_min = ratio * self.single_step\n        if (self.moving == ""max"") or (self.moving == ""bar""):\n            scale_max = (self.display_max - self.handle_radius) / size\n            ratio = round(scale_max / self.single_step)\n            val_max = ratio * self.single_step\n        self.setSliderValues((val_min, val_max))\n\n    def getBarColor(self):\n        return self.bar_color\n\n    def setBarColor(self, barColor):\n        self.bar_color = barColor\n\n    barColor = Property(QColor, getBarColor, setBarColor)\n\n    def getBackgroundColor(self):\n        return self.background_color\n\n    def setBackgroundColor(self, backgroundColor):\n        self.background_color = backgroundColor\n\n    backgroundColor = Property(QColor, getBackgroundColor, setBackgroundColor)\n\n    @property\n    def handle_width(self):\n        return self.handle_radius * 2\n\n    def getHandleColor(self):\n        return self.handle_color\n\n    def setHandleColor(self, handleColor):\n        self.handle_color = handleColor\n\n    handleColor = Property(QColor, getHandleColor, setHandleColor)\n\n    def getHandleBorderColor(self):\n        return self.handle_border_color\n\n    def setHandleBorderColor(self, handleBorderColor):\n        self.handle_border_color = handleBorderColor\n\n    handleBorderColor = Property(\n        QColor, getHandleBorderColor, setHandleBorderColor\n    )\n\n    def setEnabled(self, bool):\n        super().setEnabled(bool)\n        self.update()\n\n\nclass QHRangeSlider(QRangeSlider):\n    """"""\n    Horizontal Range Slider, extended from QRangeSlider\n\n    Parameters\n    ----------\n    initial_values : 2-tuple, optional\n        Initial min & max values of the slider, defaults to (0.2, 0.8)\n    data_range : 2-tuple, optional\n        Min and max of the slider range, defaults to (0, 1)\n    step_size : float, optional\n        Single step size for the slider, defaults to 1\n    collapsible : bool\n        Whether the slider is collapsible, defaults to True.\n    collapsed : bool\n        Whether the slider begins collapsed, defaults to False.\n    parent : qtpy.QtWidgets.QWidget\n        Parent widget.\n    """"""\n\n    def getPos(self, event):\n        """"""Get event position.\n\n        Parameters\n        ----------\n        event : qtpy.QEvent\n            Event from the Qt context.\n\n        Returns\n        -------\n        position : int\n            Relative horizontal position of the event.\n        """"""\n        return event.x()\n\n    def paintEvent(self, event):\n        """"""Paint the background, range bar and splitters.\n\n        Parameters\n        ----------\n        event : qtpy.QEvent\n            Event from the Qt context.\n        """"""\n        painter, w, h = QPainter(self), self.width(), self.height()\n\n        half_width = self.slider_width / 2 - 1\n        halfdiff = h / 2 - half_width\n\n        # Background\n        painter.setPen(self.background_color)\n        painter.setBrush(self.background_color)\n        painter.drawRoundedRect(0, halfdiff, w, self.slider_width, 2, 2)\n\n        # Range Bar\n        painter.setPen(self.bar_color)\n        painter.setBrush(self.bar_color)\n        if self.collapsed:\n            painter.drawRect(0, halfdiff, self.display_max, self.slider_width)\n        else:\n            painter.drawRect(\n                self.display_min,\n                halfdiff,\n                self.display_max - self.display_min,\n                self.slider_width,\n            )\n\n        painter.setRenderHints(QPainter.Antialiasing)\n        # Splitters\n        painter.setPen(self.handle_border_color)\n        painter.setBrush(self.handle_color)\n        painter.drawEllipse(\n            self.display_min - self.handle_radius,\n            h / 2 - self.handle_radius + 1,\n            self.handle_width - 1,\n            self.handle_width - 1,\n        )  # left\n        painter.drawEllipse(\n            self.display_max - self.handle_radius,\n            h / 2 - self.handle_radius + 1,\n            self.handle_width - 1,\n            self.handle_width - 1,\n        )  # right\n\n    def rangeSliderSize(self):\n        """"""Width of the slider, in pixels\n\n        Returns\n        -------\n        size : int\n            Slider bar length (horizontal sliders) or height (vertical\n            sliders).\n        """"""\n        return float(self.width() - self.handle_width)\n\n\nclass QVRangeSlider(QRangeSlider):\n    """"""\n    Vertical Range Slider, extended from QRangeSlider\n\n    Parameters\n    ----------\n    initial_values : 2-tuple, optional\n        Initial min & max values of the slider, defaults to (0.2, 0.8)\n    data_range : 2-tuple, optional\n        Min and max of the slider range, defaults to (0, 1)\n    step_size : float, optional\n        Single step size for the slider, defaults to 1\n    collapsible : bool\n        Whether the slider is collapsible, defaults to True.\n    collapsed : bool\n        Whether the slider begins collapsed, defaults to False.\n    parent : qtpy.QtWidgets.QWidget\n        Parent widget.\n    """"""\n\n    def getPos(self, event):\n        """"""Get event position.\n\n        Parameters\n        ----------\n        event : qtpy.QEvent\n            Event from the Qt context.\n\n        Returns\n        -------\n        position : int\n            Relative horizontal position of the event.\n        """"""\n        return self.height() - event.y()\n\n    def paintEvent(self, event):\n        """"""Paint the background, range bar and splitters.\n\n        Parameters\n        ----------\n        event : qtpy.QEvent\n            Event from the Qt context.\n        """"""\n        painter, w, h = QPainter(self), self.width(), self.height()\n\n        half_width = self.slider_width / 2\n        halfdiff = w / 2 - half_width\n        # Background\n        painter.setPen(self.background_color)\n        painter.setBrush(self.background_color)\n        painter.drawRoundedRect(halfdiff, 0, self.slider_width, h, 2, 2)\n\n        # Range Bar\n        painter.setPen(self.bar_color)\n        painter.setBrush(self.bar_color)\n        if self.collapsed:\n            painter.drawRect(\n                halfdiff,\n                h - self.display_max,\n                self.slider_width,\n                self.display_max,\n            )\n        else:\n            painter.drawRect(\n                halfdiff,\n                h - self.display_max,\n                self.slider_width,\n                self.display_max - self.display_min,\n            )\n\n        painter.setRenderHints(QPainter.Antialiasing)\n        # Splitters\n        painter.setPen(self.handle_border_color)\n        painter.setBrush(self.handle_color)\n        painter.drawEllipse(\n            w / 2 - self.handle_radius,\n            h - self.display_min - self.handle_radius,\n            self.handle_width,\n            self.handle_width,\n        )  # upper\n        painter.drawEllipse(\n            w / 2 - self.handle_radius,\n            h - self.display_max - self.handle_radius,\n            self.handle_width,\n            self.handle_width,\n        )  # lower\n\n    def rangeSliderSize(self):\n        """"""Height of the slider, in pixels\n\n        Returns\n        -------\n        size : int\n            Slider bar length (horizontal sliders) or height (vertical\n            sliders).\n        """"""\n        return float(self.height() - self.handle_width)\n'"
napari/_qt/qt_range_slider_popup.py,0,"b'from functools import partial\n\nfrom qtpy.QtCore import Qt, QPoint\nfrom qtpy.QtGui import QDoubleValidator, QFontMetrics, QFont\nfrom qtpy.QtWidgets import QHBoxLayout, QLineEdit\n\nfrom .qt_modal import QtPopup\nfrom .qt_range_slider import QHRangeSlider, QVRangeSlider\nfrom .utils import qt_signals_blocked\n\n\nclass LabelEdit(QLineEdit):\n    """"""Helper class to position LineEdits above the slider handle\n\n    Parameters\n    ----------\n    value : str, optional\n        Starting value, by default \'\'\n    parent : QRangeSliderPopup, optional\n        Required for proper label positioning above handle, by default None.\n    get_pos : callable, optional\n        Function that returns the position of the appropriate slider handle\n        by default None.\n\n    Attributes\n    ----------\n    get_pos : callable or None\n        Function that returns the position of the appropriate slider handle.\n    max_width : int\n        Minimum label width.\n    min_width : int\n        Maximum label width.\n    slider : qtpy.QtWidgets.QHRangeSlider\n        Slider widget.\n    """"""\n\n    def __init__(self, value=\'\', parent=None, get_pos=None):\n        super().__init__(value, parent=parent)\n        self.fm = QFontMetrics(QFont("""", 0))\n        self.setObjectName(\'slice_label\')\n        self.min_width = 30\n        self.max_width = 200\n        self.setCursor(Qt.IBeamCursor)\n        self.setValidator(QDoubleValidator())\n        self.textChanged.connect(self._on_text_changed)\n        self._on_text_changed(value)\n\n        self.get_pos = get_pos\n        if parent is not None:\n            self.min_width = 50\n            self.slider = parent.slider\n            self.setAlignment(Qt.AlignCenter)\n\n    def _on_text_changed(self, text):\n        """"""Update label text displayed above the slider handle.\n\n        Parameters\n        ----------\n        text : str\n            Label text to display above the slider handle.\n        """"""\n        # with non mono-spaced fonts, an ""n-digit"" number isn\'t always the same\n        # width... so we convert all numbers to ""n 8s"" before measuring width\n        # so as to avoid visual jitter in the width of the label\n        width = self.fm.boundingRect(\'8\' * len(text)).width() + 4\n        width = max(self.min_width, min(width, self.max_width))\n        if width > self.min_width:\n            # don\'t ever make the label smaller ... it causes visual jitter\n            self.min_width = width\n        self.setFixedWidth(width)\n\n    def update_position(self):\n        """"""Update slider position.""""""\n        x = self.get_pos() - self.width() / 2\n        y = self.slider.handle_radius + 12\n        self.move(QPoint(x, -y) + self.slider.pos())\n\n    def mouseDoubleClickEvent(self, event):\n        """"""Select all on mouse double click.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.selectAll()\n\n\nclass QRangeSliderPopup(QtPopup):\n    def __init__(self, parent=None, horizontal=True, precision=0, **kwargs):\n        """"""A popup window that contains a range slider and linked LineEdits.\n\n        Parameters\n        ----------\n        parent : QWidget, optional\n            Will like be an instance of QtLayerControls.  Note, providing\n            parent can be useful to inherit stylesheets.\n        horizontal : bool, optional\n            Whether the slider is oriented horizontally, by default True.\n            (Vertical orientation has not been tested much)\n        precision : int, optional\n            Number of decimal values in the labels, by default 0\n        **kwargs\n            all additional keyword arguments will be passed to the RangeSlider\n\n        Attributes\n        ----------\n        curmax_label : napari._qt.qt_range_slider_popup.LabelEdit\n            Label for the current maximum contrast limit.\n        curmin_label : napari._qt.qt_range_slider_popup.LabelEdit\n            Label for the current minimum contrast limit.\n        frame : qtpy.QtWidgets.QFrame\n            Frame of the popup dialog box.\n        layout : qtpy.QtWidgets.QHBoxLayout\n            Layout of the popup dialog box.\n        precision : int\n            Number of decimal values in numeric labels.\n        range_max_label : napari._qt.qt_range_slider_popup.LabelEdit\n            Label for maximum slider range value.\n        range_min_label : napari._qt.qt_range_slider_popup.LabelEdit\n            Label for minimum slider range value.\n        slider : qtpy.QtWidgets.QHRangeSlider\n            Slider widget.\n        """"""\n        super().__init__(parent)\n        self.precision = precision\n\n        # create slider\n        self.slider = (\n            QHRangeSlider(parent=parent, **kwargs)\n            if horizontal\n            else QVRangeSlider(parent=parent, **kwargs)\n        )\n        self.slider.setMinimumHeight(18)\n        self.slider.setFocus()\n        self.slider.valuesChanged.connect(self._on_values_change)\n        self.slider.rangeChanged.connect(self._on_range_change)\n        self.slider.resized.connect(self._update_cur_label_positions)\n\n        # create ""floating"" min/max value labels\n        cmin, cmax = self.slider.values()\n        get_min_pos = partial(getattr, self.slider, \'display_min\')\n        get_max_pos = partial(getattr, self.slider, \'display_max\')\n        self.curmin_label = LabelEdit(self._numformat(cmin), self, get_min_pos)\n        self.curmax_label = LabelEdit(self._numformat(cmax), self, get_max_pos)\n        self.curmin_label.editingFinished.connect(self._curmin_label_changed)\n        self.curmax_label.editingFinished.connect(self._curmax_label_changed)\n        self.curmin_label.setToolTip(""current minimum contrast limit"")\n        self.curmax_label.setToolTip(""current maximum contrast limit"")\n\n        # create range min/max labels (left & right of slider)\n        rmin, rmax = self.slider.range()\n        self.range_min_label = LabelEdit(self._numformat(rmin))\n        self.range_max_label = LabelEdit(self._numformat(rmax))\n        self.range_min_label.editingFinished.connect(self._range_label_changed)\n        self.range_max_label.editingFinished.connect(self._range_label_changed)\n        self.range_min_label.setToolTip(""minimum contrast range"")\n        self.range_max_label.setToolTip(""maximum contrast range"")\n        self.range_min_label.setAlignment(Qt.AlignRight)\n\n        # add widgets to layout\n        self.layout = QHBoxLayout()\n        self.frame.setLayout(self.layout)\n        self.frame.setContentsMargins(0, 8, 0, 0)\n        self.layout.addWidget(self.range_min_label)\n        self.layout.addWidget(self.slider, 50)\n        self.layout.addWidget(self.range_max_label)\n\n    def _numformat(self, number):\n        """"""Format float value to a specific number of decimal places.\n\n        Paramters\n        ---------\n        number : float\n            Number value formatted to a specific number of decimal places.\n        """"""\n        if round(number) == number:\n            return ""{:.{}f}"".format(number, 0)\n        else:\n            return ""{:.{}f}"".format(number, self.precision)\n\n    def _update_cur_label_positions(self):\n        """"""Update label positions of current minimum/maximum contrast range.""""""\n        self.curmin_label.update_position()\n        self.curmax_label.update_position()\n\n    def _on_values_change(self, values):\n        """"""Update labels of the current contrast range.\n\n        Parameters\n        ----------\n        values : tuple(float, float)\n            Minimum and maximum values of the current contrast range.\n        """"""\n        cmin_, cmax_ = values\n        with qt_signals_blocked(self.slider):\n            self.curmin_label.setText(self._numformat(cmin_))\n            self.curmax_label.setText(self._numformat(cmax_))\n            self._update_cur_label_positions()\n\n    def _on_range_change(self, values):\n        """"""Update values of current contrast range and display labels.\n\n        Parameters\n        ----------\n        values : tuple(float, float)\n            Minimum and maximum values of the current contrast range.\n        """"""\n        cmin_, cmax_ = values\n        with qt_signals_blocked(self.slider):\n            self.range_min_label.setText(self._numformat(cmin_))\n            self.range_max_label.setText(self._numformat(cmax_))\n            # changing range may also change values\n            vmin_, vmax_ = self.slider.values()\n            self.curmin_label.setText(self._numformat(vmin_))\n            self.curmax_label.setText(self._numformat(vmax_))\n\n    def _curmin_label_changed(self):\n        """"""Update minimum value of current contrast range.""""""\n        cmin = float(self.curmin_label.text())\n        cmax = float(self.curmax_label.text())\n        if cmin > cmax:\n            cmin = cmax\n        self.slider.setValues((cmin, cmax))\n\n    def _curmax_label_changed(self):\n        """"""Update maximum value of current contrast range.""""""\n        cmin = float(self.curmin_label.text())\n        cmax = float(self.curmax_label.text())\n        if cmax < cmin:\n            cmax = cmin\n        self.slider.setValues((cmin, cmax))\n\n    def _range_label_changed(self):\n        """"""Update values for minimum & maximum slider range to match labels.""""""\n        rmin = float(self.range_min_label.text())\n        rmax = float(self.range_max_label.text())\n        if rmin >= rmax:\n            rmax = rmin + 1\n        self.slider.setRange((rmin, rmax))\n\n    def keyPressEvent(self, event):\n        """"""On key press lose focus of the lineEdits.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        # we override the parent keyPressEvent so that hitting enter does not\n        # hide the window... but we do want to lose focus on the lineEdits\n        if event.key() in (Qt.Key_Return, Qt.Key_Enter):\n            self.slider.setFocus()\n            return\n        super().keyPressEvent(event)\n\n    def closeEvent(self, event):\n        self.deleteLater()\n        event.accept()\n'"
napari/_qt/qt_scrollbar.py,0,"b'from qtpy.QtWidgets import QScrollBar, QStyleOptionSlider, QStyle\nfrom qtpy.QtCore import Qt\n\n\n# https://stackoverflow.com/questions/29710327/how-to-override-qscrollbar-onclick-default-behaviour\nclass ModifiedScrollBar(QScrollBar):\n    """"""Modified QScrollBar that moves fully to the clicked position.\n\n    When the user clicks on the scroll bar background area (aka, the ""page\n    control""), the default behavior of the QScrollBar is to move one ""page""\n    towards the click (rather than all the way to the clicked position).\n    See: https://doc.qt.io/qt-5/qscrollbar.html\n    This scroll bar modifies the mousePressEvent to move the slider position\n    fully to the clicked position.\n    """"""\n\n    def _move_to_mouse_position(self, event):\n        opt = QStyleOptionSlider()\n        self.initStyleOption(opt)\n        control = self.style().hitTestComplexControl(\n            QStyle.CC_ScrollBar, opt, event.pos(), self\n        )\n        if (\n            control == QStyle.SC_ScrollBarAddPage\n            or control == QStyle.SC_ScrollBarSubPage\n        ):\n            # scroll here\n            gr = self.style().subControlRect(\n                QStyle.CC_ScrollBar, opt, QStyle.SC_ScrollBarGroove, self\n            )\n            sr = self.style().subControlRect(\n                QStyle.CC_ScrollBar, opt, QStyle.SC_ScrollBarSlider, self\n            )\n            if self.orientation() == Qt.Horizontal:\n                pos = event.pos().x()\n                sliderLength = sr.width()\n                sliderMin = gr.x()\n                sliderMax = gr.right() - sliderLength + 1\n                if self.layoutDirection() == Qt.RightToLeft:\n                    opt.upsideDown = not opt.upsideDown\n            else:\n                pos = event.pos().y()\n                sliderLength = sr.height()\n                sliderMin = gr.y()\n                sliderMax = gr.bottom() - sliderLength + 1\n            self.setValue(\n                QStyle.sliderValueFromPosition(\n                    self.minimum(),\n                    self.maximum(),\n                    pos - sliderMin - sliderLength // 2,\n                    sliderMax - sliderMin,\n                    opt.upsideDown,\n                )\n            )\n\n    def mouseMoveEvent(self, event):\n        if event.buttons() & Qt.LeftButton:\n            # dragging with the mouse button down should move the slider\n            self._move_to_mouse_position(event)\n        return super().mouseMoveEvent(event)\n\n    def mousePressEvent(self, event):\n        if event.button() == Qt.LeftButton:\n            # clicking the mouse button should move slider to the clicked point\n            self._move_to_mouse_position(event)\n        return super().mousePressEvent(event)\n'"
napari/_qt/qt_update_ui.py,0,"b'from qtpy.QtCore import QRunnable\n\n\nclass QtUpdateUI(QRunnable):\n    """"""UI Update thread, extended QThread.\n\n    Parameters\n    ----------\n    fn : function\n        The function that would be executed.\n    """"""\n\n    def __init__(self, fn, *args, **kwargs):\n        super().__init__()\n        self.fn = fn\n        self.args = args\n        self.kwargs = kwargs\n\n    def run(self):\n        self.fn(*self.args, **self.kwargs)\n'"
napari/_qt/qt_viewer.py,0,"b'from pathlib import Path\n\nfrom qtpy.QtCore import QCoreApplication, Qt, QSize\nfrom qtpy.QtWidgets import (\n    QWidget,\n    QVBoxLayout,\n    QFileDialog,\n    QSplitter,\n    QMessageBox,\n)\nfrom qtpy.QtGui import QCursor, QGuiApplication\nfrom ..utils.io import imsave\nfrom vispy.scene import SceneCanvas, PanZoomCamera, ArcballCamera\nfrom vispy.visuals.transforms import ChainTransform\n\nfrom .qt_dims import QtDims\nfrom .qt_layerlist import QtLayerList\nfrom ..resources import get_stylesheet\nfrom ..utils.theme import template\nfrom ..utils.interactions import (\n    ReadOnlyWrapper,\n    mouse_press_callbacks,\n    mouse_move_callbacks,\n    mouse_release_callbacks,\n)\nfrom ..utils.key_bindings import components_to_key_combo\nfrom ..utils import perf\n\nfrom .utils import QImg2array, square_pixmap\nfrom .qt_controls import QtControls\nfrom .qt_viewer_buttons import QtLayerButtons, QtViewerButtons\nfrom .qt_viewer_dock_widget import QtViewerDockWidget\nfrom .qt_about_key_bindings import QtAboutKeyBindings\nfrom .qt_performance import QtPerformance\nfrom .._vispy import create_vispy_visual\n\n\nclass QtViewer(QSplitter):\n    """"""Qt view for the napari Viewer model.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    canvas : vispy.scene.SceneCanvas\n        Canvas for rendering the current view.\n    console : QtConsole\n        iPython console terminal integrated into the napari GUI.\n    controls : QtControls\n        Qt view for GUI controls.\n    dims : napari.qt_dims.QtDims\n        Dimension sliders; Qt View for Dims model.\n    dockConsole : QtViewerDockWidget\n        QWidget wrapped in a QDockWidget with forwarded viewer events.\n    aboutKeybindings : QtAboutKeybindings\n        Key bindings for the \'About\' Qt dialog.\n    dockLayerControls : QtViewerDockWidget\n        QWidget wrapped in a QDockWidget with forwarded viewer events.\n    dockLayerList : QtViewerDockWidget\n        QWidget wrapped in a QDockWidget with forwarded viewer events.\n    layerButtons : QtLayerButtons\n        Button controls for napari layers.\n    layers : QtLayerList\n        Qt view for LayerList controls.\n    layer_to_visual : dict\n        Dictionary mapping napari layers with their corresponding vispy_layers.\n    view : vispy scene widget\n        View displayed by vispy canvas. Adds a vispy ViewBox as a child widget.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    viewerButtons : QtViewerButtons\n        Button controls for the napari viewer.\n    """"""\n\n    raw_stylesheet = get_stylesheet()\n\n    def __init__(self, viewer):\n        super().__init__()\n        self.setAttribute(Qt.WA_DeleteOnClose)\n\n        QCoreApplication.setAttribute(\n            Qt.AA_UseStyleSheetPropagationInWidgetStyles, True\n        )\n\n        self.viewer = viewer\n        self.dims = QtDims(self.viewer.dims)\n        self.controls = QtControls(self.viewer)\n        self.layers = QtLayerList(self.viewer.layers)\n        self.layerButtons = QtLayerButtons(self.viewer)\n        self.viewerButtons = QtViewerButtons(self.viewer)\n        self._console = None\n\n        layerList = QWidget()\n        layerList.setObjectName(\'layerList\')\n        layerListLayout = QVBoxLayout()\n        layerListLayout.addWidget(self.layerButtons)\n        layerListLayout.addWidget(self.layers)\n        layerListLayout.addWidget(self.viewerButtons)\n        layerListLayout.setContentsMargins(8, 4, 8, 6)\n        layerList.setLayout(layerListLayout)\n        self.dockLayerList = QtViewerDockWidget(\n            self,\n            layerList,\n            name=\'layer list\',\n            area=\'left\',\n            allowed_areas=[\'left\', \'right\'],\n        )\n        self.dockLayerControls = QtViewerDockWidget(\n            self,\n            self.controls,\n            name=\'layer controls\',\n            area=\'left\',\n            allowed_areas=[\'left\', \'right\'],\n        )\n        self.dockConsole = QtViewerDockWidget(\n            self,\n            QWidget(),\n            name=\'console\',\n            area=\'bottom\',\n            allowed_areas=[\'top\', \'bottom\'],\n            shortcut=\'Ctrl+Shift+C\',\n        )\n        self.dockConsole.setVisible(False)\n        # because the console is loaded lazily in the @getter, this line just\n        # gets (or creates) the console when the dock console is made visible.\n        self.dockConsole.visibilityChanged.connect(\n            lambda visible: self.console if visible else None\n        )\n        self.dockLayerControls.visibilityChanged.connect(self._constrain_width)\n        self.dockLayerList.setMaximumWidth(258)\n        self.dockLayerList.setMinimumWidth(258)\n\n        self.dockPerformance = self._create_performance_dock_widget()\n\n        # This dictionary holds the corresponding vispy visual for each layer\n        self.layer_to_visual = {}\n        self.viewerButtons.consoleButton.clicked.connect(\n            self.toggle_console_visibility\n        )\n\n        self.canvas = SceneCanvas(keys=None, vsync=True, parent=self)\n        self.canvas.events.ignore_callback_errors = False\n        self.canvas.events.draw.connect(self.dims.enable_play)\n        self.canvas.native.setMinimumSize(QSize(200, 200))\n        self.canvas.context.set_depth_func(\'lequal\')\n\n        self.canvas.connect(self.on_mouse_move)\n        self.canvas.connect(self.on_mouse_press)\n        self.canvas.connect(self.on_mouse_release)\n        self.canvas.connect(self.on_key_press)\n        self.canvas.connect(self.on_key_release)\n\n        self.view = self.canvas.central_widget.add_view()\n        self._update_camera()\n\n        main_widget = QWidget()\n        main_layout = QVBoxLayout()\n        main_layout.setContentsMargins(10, 22, 10, 2)\n        main_layout.addWidget(self.canvas.native)\n        main_layout.addWidget(self.dims)\n        main_layout.setSpacing(10)\n        main_widget.setLayout(main_layout)\n\n        self.setOrientation(Qt.Vertical)\n        self.addWidget(main_widget)\n\n        self._last_visited_dir = str(Path.home())\n\n        self._cursors = {\n            \'cross\': Qt.CrossCursor,\n            \'forbidden\': Qt.ForbiddenCursor,\n            \'pointing\': Qt.PointingHandCursor,\n            \'standard\': QCursor(),\n        }\n\n        self._update_palette()\n\n        self.viewer.events.interactive.connect(self._on_interactive)\n        self.viewer.events.cursor.connect(self._on_cursor)\n        self.viewer.events.reset_view.connect(self._on_reset_view)\n        self.viewer.events.palette.connect(self._update_palette)\n        self.viewer.layers.events.reordered.connect(self._reorder_layers)\n        self.viewer.layers.events.added.connect(self._add_layer)\n        self.viewer.layers.events.removed.connect(self._remove_layer)\n        self.viewer.dims.events.camera.connect(\n            lambda event: self._update_camera()\n        )\n        # stop any animations whenever the layers change\n        self.viewer.events.layers_change.connect(lambda x: self.dims.stop())\n\n        self.setAcceptDrops(True)\n\n    def _create_performance_dock_widget(self):\n        """"""Create the dock widget that shows performance metrics.\n        """"""\n        if not perf.USE_PERFMON:\n            return None\n\n        return QtViewerDockWidget(\n            self,\n            QtPerformance(),\n            name=\'performance\',\n            area=\'bottom\',\n            shortcut=\'Ctrl+Shift+P\',\n        )\n\n    @property\n    def console(self):\n        """"""QtConsole: iPython console terminal integrated into the napari GUI.\n        """"""\n        if self._console is None:\n            from .qt_console import QtConsole\n\n            self.console = QtConsole({\'viewer\': self.viewer})\n        return self._console\n\n    @console.setter\n    def console(self, console):\n        self._console = console\n        self.dockConsole.widget = console\n        self._update_palette()\n\n    def _constrain_width(self, event):\n        """"""Allow the layer controls to be wider, only if floated.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if self.dockLayerControls.isFloating():\n            self.controls.setMaximumWidth(700)\n        else:\n            self.controls.setMaximumWidth(220)\n\n    def _add_layer(self, event):\n        """"""When a layer is added, set its parent and order.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        layers = event.source\n        layer = event.item\n        vispy_layer = create_vispy_visual(layer)\n        vispy_layer.node.parent = self.view.scene\n        vispy_layer.order = len(layers)\n        self.canvas.connect(vispy_layer.on_draw)\n        self.layer_to_visual[layer] = vispy_layer\n\n    def _remove_layer(self, event):\n        """"""When a layer is removed, remove its parent.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        layer = event.item\n        vispy_layer = self.layer_to_visual[layer]\n        self.canvas.events.draw.disconnect(vispy_layer.on_draw)\n        vispy_layer.node.transforms = ChainTransform()\n        vispy_layer.node.parent = None\n        del vispy_layer\n\n    def _reorder_layers(self, event):\n        """"""When the list is reordered, propagate changes to draw order.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        for i, layer in enumerate(self.viewer.layers):\n            vispy_layer = self.layer_to_visual[layer]\n            vispy_layer.order = i\n        self.canvas._draw_order.clear()\n        self.canvas.update()\n\n    def _update_camera(self):\n        """"""Update the viewer camera.""""""\n        if self.viewer.dims.ndisplay == 3:\n            # Set a 3D camera\n            if not isinstance(self.view.camera, ArcballCamera):\n                self.view.camera = ArcballCamera(name=""ArcballCamera"", fov=0)\n                # flip y-axis to have correct alignment\n                # self.view.camera.flip = (0, 1, 0)\n\n                self.view.camera.viewbox_key_event = viewbox_key_event\n                self.viewer.reset_view()\n        else:\n            # Set 2D camera\n            if not isinstance(self.view.camera, PanZoomCamera):\n                self.view.camera = PanZoomCamera(\n                    aspect=1, name=""PanZoomCamera""\n                )\n                # flip y-axis to have correct alignment\n                self.view.camera.flip = (0, 1, 0)\n\n                self.view.camera.viewbox_key_event = viewbox_key_event\n                self.viewer.reset_view()\n\n    def _save_layers_dialog(self, selected=False):\n        """"""Save layers (all or selected) to disk, using ``LayerList.save()``.\n\n        Parameters\n        ----------\n        selected : bool\n            If True, only layers that are selected in the viewer will be saved.\n            By default, all layers are saved.\n        """"""\n        msg = \'\'\n        if not len(self.viewer.layers):\n            msg = ""There are no layers in the viewer to save""\n        elif selected and not len(self.viewer.layers.selected):\n            msg = (\n                \'Please select one or more layers to save,\'\n                \'\\nor use ""Save all layers...""\'\n            )\n        if msg:\n            QMessageBox.warning(self, ""Nothing to save"", msg, QMessageBox.Ok)\n            return\n\n        filename, _ = QFileDialog.getSaveFileName(\n            parent=self,\n            caption=f\'Save {""selected"" if selected else ""all""} layers\',\n            directory=self._last_visited_dir,  # home dir by default\n        )\n        if filename:\n            self.viewer.layers.save(filename, selected=selected)\n\n    def screenshot(self, path=None):\n        """"""Take currently displayed screen and convert to an image array.\n\n        Parmeters\n        ---------\n        path : str\n            Filename for saving screenshot image.\n\n        Returns\n        -------\n        image : array\n            Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n            upper-left corner of the rendered region.\n        """"""\n        img = self.canvas.native.grabFramebuffer()\n        if path is not None:\n            imsave(path, QImg2array(img))  # scikit-image imsave method\n        return QImg2array(img)\n\n    def _screenshot_dialog(self):\n        """"""Save screenshot of current display, default .png""""""\n        filename, _ = QFileDialog.getSaveFileName(\n            parent=self,\n            caption=\'Save screenshot\',\n            directory=self._last_visited_dir,  # home dir by default\n            filter=""Image files (*.png *.bmp *.gif *.tif *.tiff)"",  # first one used by default\n            # jpg and jpeg not included as they don\'t support an alpha channel\n        )\n        if (filename != \'\') and (filename is not None):\n            # double check that an appropriate extension has been added as the\n            # filter option does not always add an extension on linux and windows\n            # see https://bugreports.qt.io/browse/QTBUG-27186\n            image_extensions = (\'.bmp\', \'.gif\', \'.png\', \'.tif\', \'.tiff\')\n            if not filename.endswith(image_extensions):\n                filename = filename + \'.png\'\n            self.screenshot(path=filename)\n\n    def _open_files_dialog(self):\n        """"""Add files from the menubar.""""""\n        filenames, _ = QFileDialog.getOpenFileNames(\n            parent=self,\n            caption=\'Select file(s)...\',\n            directory=self._last_visited_dir,  # home dir by default\n        )\n        if (filenames != []) and (filenames is not None):\n            self.viewer.open(filenames)\n\n    def _open_files_dialog_as_stack_dialog(self):\n        """"""Add files as a stack, from the menubar.""""""\n        filenames, _ = QFileDialog.getOpenFileNames(\n            parent=self,\n            caption=\'Select files...\',\n            directory=self._last_visited_dir,  # home dir by default\n        )\n        if (filenames != []) and (filenames is not None):\n            self.viewer.open(filenames, stack=True)\n\n    def _open_folder_dialog(self):\n        """"""Add a folder of files from the menubar.""""""\n        folder = QFileDialog.getExistingDirectory(\n            parent=self,\n            caption=\'Select folder...\',\n            directory=self._last_visited_dir,  # home dir by default\n        )\n        if folder not in {\'\', None}:\n            self.viewer.open([folder])\n\n    def _on_interactive(self, event):\n        """"""Link interactive attributes of view and viewer.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.view.interactive = self.viewer.interactive\n\n    def _on_cursor(self, event):\n        """"""Set the appearance of the mouse cursor.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        cursor = self.viewer.cursor\n        if cursor == \'square\':\n            size = self.viewer.cursor_size\n            # make sure the square fits within the current canvas\n            if size < 8 or size > (\n                min(*self.viewer.window.qt_viewer.canvas.size) - 4\n            ):\n                q_cursor = self._cursors[\'cross\']\n            else:\n                q_cursor = QCursor(square_pixmap(size))\n        else:\n            q_cursor = self._cursors[cursor]\n        self.canvas.native.setCursor(q_cursor)\n\n    def _on_reset_view(self, event):\n        """"""Reset view of the rendered scene.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if isinstance(self.view.camera, ArcballCamera):\n            quat = self.view.camera._quaternion.create_from_axis_angle(\n                *event.quaternion\n            )\n            self.view.camera._quaternion = quat\n            self.view.camera.center = event.center\n            self.view.camera.scale_factor = event.scale_factor\n        else:\n            # Assumes default camera has the same properties as PanZoomCamera\n            self.view.camera.rect = event.rect\n\n    def _update_palette(self, event=None):\n        """"""Update the napari GUI theme.""""""\n        # template and apply the primary stylesheet\n        themed_stylesheet = template(\n            self.raw_stylesheet, **self.viewer.palette\n        )\n        if self._console is not None:\n            self.console._update_palette(\n                self.viewer.palette, themed_stylesheet\n            )\n        self.setStyleSheet(themed_stylesheet)\n        self.canvas.bgcolor = self.viewer.palette[\'canvas\']\n\n    def toggle_console_visibility(self, event=None):\n        """"""Toggle console visible and not visible.\n\n        Imports the console the first time it is requested.\n        """"""\n        # force instantiation of console if not already instantiated\n        _ = self.console\n\n        viz = not self.dockConsole.isVisible()\n        # modulate visibility at the dock widget level as console is docakable\n        self.dockConsole.setVisible(viz)\n        if self.dockConsole.isFloating():\n            self.dockConsole.setFloating(True)\n\n        self.viewerButtons.consoleButton.setProperty(\n            \'expanded\', self.dockConsole.isVisible()\n        )\n        self.viewerButtons.consoleButton.style().unpolish(\n            self.viewerButtons.consoleButton\n        )\n        self.viewerButtons.consoleButton.style().polish(\n            self.viewerButtons.consoleButton\n        )\n\n    def show_key_bindings_dialog(self, event=None):\n        dialog = QtAboutKeyBindings(self.viewer, parent=self)\n        dialog.show()\n\n    def on_mouse_press(self, event):\n        """"""Called whenever mouse pressed in canvas.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.pos is None:\n            return\n\n        event = ReadOnlyWrapper(event)\n        mouse_press_callbacks(self.viewer, event)\n\n        layer = self.viewer.active_layer\n        if layer is not None:\n            # update cursor position in visual and layer\n            visual = self.layer_to_visual[layer]\n            visual._position = list(event.pos)\n            layer.position = visual._transform_position(visual._position)\n            mouse_press_callbacks(layer, event)\n\n    def on_mouse_move(self, event):\n        """"""Called whenever mouse moves over canvas.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.pos is None:\n            return\n\n        mouse_move_callbacks(self.viewer, event)\n\n        layer = self.viewer.active_layer\n        if layer is not None:\n            # update cursor position in visual and layer\n            visual = self.layer_to_visual[layer]\n            visual._position = list(event.pos)\n            layer.position = visual._transform_position(visual._position)\n            mouse_move_callbacks(layer, event)\n\n    def on_mouse_release(self, event):\n        """"""Called whenever mouse released in canvas.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.pos is None:\n            return\n\n        mouse_release_callbacks(self.viewer, event)\n\n        layer = self.viewer.active_layer\n        if layer is not None:\n            # update cursor position in visual and layer\n            visual = self.layer_to_visual[layer]\n            visual._position = list(event.pos)\n            layer.position = visual._transform_position(visual._position)\n            mouse_release_callbacks(layer, event)\n\n    def on_key_press(self, event):\n        """"""Called whenever key pressed in canvas.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if (\n            event.native is not None\n            and event.native.isAutoRepeat()\n            and event.key.name not in [\'Up\', \'Down\', \'Left\', \'Right\']\n        ) or event.key is None:\n            # pass if no key is present or if key is held down, unless the\n            # key being held down is one of the navigation keys\n            # this helps for scrolling, etc.\n            return\n\n        combo = components_to_key_combo(event.key.name, event.modifiers)\n        self.viewer.press_key(combo)\n\n    def on_key_release(self, event):\n        """"""Called whenever key released in canvas.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.key is None:\n            return\n        combo = components_to_key_combo(event.key.name, event.modifiers)\n        self.viewer.release_key(combo)\n\n    def keyPressEvent(self, event):\n        """"""Called whenever a key is pressed.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.canvas._backend._keyEvent(self.canvas.events.key_press, event)\n        event.accept()\n\n    def keyReleaseEvent(self, event):\n        """"""Called whenever a key is released.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.canvas._backend._keyEvent(self.canvas.events.key_release, event)\n        event.accept()\n\n    def dragEnterEvent(self, event):\n        """"""Ignore event if not dragging & dropping a file or URL to open.\n\n        Using event.ignore() here allows the event to pass through the\n        parent widget to its child widget, otherwise the parent widget\n        would catch the event and not pass it on to the child widget.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.mimeData().hasUrls():\n            event.accept()\n        else:\n            event.ignore()\n\n    def dropEvent(self, event):\n        """"""Add local files and web URLS with drag and drop.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        shift_down = QGuiApplication.keyboardModifiers() & Qt.ShiftModifier\n        filenames = []\n        for url in event.mimeData().urls():\n            if url.isLocalFile():\n                filenames.append(url.toLocalFile())\n            else:\n                filenames.append(url.toString())\n        self.viewer.open(filenames, stack=bool(shift_down))\n\n    def closeEvent(self, event):\n        """"""Cleanup and close.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        # if the viewer.QtDims object is playing an axis, we need to terminate\n        # the AnimationThread before close, otherwise it will cauyse a segFault\n        # or Abort trap. (calling stop() when no animation is occuring is also\n        # not a problem)\n        self.dims.stop()\n        self.canvas.native.deleteLater()\n        if self._console is not None:\n            self.console.close()\n        self.dockConsole.deleteLater()\n        event.accept()\n\n\ndef viewbox_key_event(event):\n    """"""ViewBox key event handler.\n\n    Parameters\n    ----------\n    event : qtpy.QtCore.QEvent\n        Event from the Qt context.\n    """"""\n    return\n'"
napari/_qt/qt_viewer_buttons.py,1,"b'from qtpy.QtWidgets import QHBoxLayout, QPushButton, QFrame, QCheckBox\nfrom qtpy.QtCore import Qt\nimport numpy as np\n\n\nclass QtLayerButtons(QFrame):\n    """"""Button controls for napari layers.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    deleteButton : QtDeleteButton\n        Button to delete selected layers.\n    newLabelsButton : QtViewerPushButton\n        Button to add new Label layer.\n    newPointsButton : QtViewerPushButton\n        Button to add new Points layer.\n    newShapesButton : QtViewerPushButton\n        Button to add new Shapes layer.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n\n        self.viewer = viewer\n        self.deleteButton = QtDeleteButton(self.viewer)\n        self.newPointsButton = QtViewerPushButton(\n            self.viewer,\n            \'new_points\',\n            \'New points layer\',\n            lambda: self.viewer.add_points(data=None),\n        )\n        self.newShapesButton = QtViewerPushButton(\n            self.viewer,\n            \'new_shapes\',\n            \'New shapes layer\',\n            lambda: self.viewer.add_shapes(data=None),\n        )\n        self.newLabelsButton = QtViewerPushButton(\n            self.viewer,\n            \'new_labels\',\n            \'New labels layer\',\n            lambda: self.viewer._new_labels(),\n        )\n\n        layout = QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(self.newPointsButton)\n        layout.addWidget(self.newShapesButton)\n        layout.addWidget(self.newLabelsButton)\n        layout.addStretch(0)\n        layout.addWidget(self.deleteButton)\n        self.setLayout(layout)\n\n\nclass QtViewerButtons(QFrame):\n    """"""Button controls for the napari viewer.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    consoleButton : QtViewerPushButton\n        Button to open iPython console within napari.\n    rollDimsButton : QtViewerPushButton\n        Button to roll orientation of spatial dimensions in the napari viewer.\n    transposeDimsButton : QtViewerPushButton\n        Button to transpose dimensions in the napari viewer.\n    resetViewButton : QtViewerPushButton\n        Button resetting the view of the rendered scene.\n    gridViewButton : QtGridViewButton\n        Button to toggle grid view mode of layers on and off.\n    ndisplayButton : QtNDisplayButton\n        Button to toggle number of displayed dimensions.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n\n        self.viewer = viewer\n        self.consoleButton = QtViewerPushButton(\n            self.viewer, \'console\', \'Open IPython terminal\'\n        )\n        self.consoleButton.setProperty(\'expanded\', False)\n        self.rollDimsButton = QtViewerPushButton(\n            self.viewer,\n            \'roll\',\n            \'Roll dimensions order for display\',\n            lambda: self.viewer.dims._roll(),\n        )\n        self.transposeDimsButton = QtViewerPushButton(\n            self.viewer,\n            \'transpose\',\n            \'Transpose displayed dimensions\',\n            lambda: self.viewer.dims._transpose(),\n        )\n        self.resetViewButton = QtViewerPushButton(\n            self.viewer, \'home\', \'Reset view\', lambda: self.viewer.reset_view()\n        )\n        self.gridViewButton = QtGridViewButton(self.viewer)\n        self.ndisplayButton = QtNDisplayButton(self.viewer)\n\n        layout = QHBoxLayout()\n        layout.setContentsMargins(0, 0, 0, 0)\n        layout.addWidget(self.consoleButton)\n        layout.addWidget(self.ndisplayButton)\n        layout.addWidget(self.rollDimsButton)\n        layout.addWidget(self.transposeDimsButton)\n        layout.addWidget(self.gridViewButton)\n        layout.addWidget(self.resetViewButton)\n        layout.addStretch(0)\n        self.setLayout(layout)\n\n\nclass QtDeleteButton(QPushButton):\n    """"""Delete button to remove selected layers.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    hover : bool\n        Hover is true while mouse cursor is on the button widget.\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n\n        self.viewer = viewer\n        self.setToolTip(\'Delete selected layers\')\n        self.setAcceptDrops(True)\n        self.clicked.connect(lambda: self.viewer.layers.remove_selected())\n\n    def dragEnterEvent(self, event):\n        """"""The cursor enters the widget during a drag and drop operation.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.accept()\n        self.hover = True\n        self.update()\n\n    def dragLeaveEvent(self, event):\n        """"""The cursor leaves the widget during a drag and drop operation.\n\n        Using event.ignore() here allows the event to pass through the\n        parent widget to its child widget, otherwise the parent widget\n        would catch the event and not pass it on to the child widget.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.ignore()\n        self.hover = False\n        self.update()\n\n    def dropEvent(self, event):\n        """"""The drag and drop mouse event is completed.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        event.accept()\n        layer_name = event.mimeData().text()\n        layer = self.viewer.layers[layer_name]\n        if not layer.selected:\n            self.viewer.layers.remove(layer)\n        else:\n            self.viewer.layers.remove_selected()\n\n\nclass QtViewerPushButton(QPushButton):\n    """"""Push button.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer, button_name, tooltip=None, slot=None):\n        super().__init__()\n\n        self.viewer = viewer\n        self.setToolTip(tooltip or button_name)\n        self.setProperty(\'mode\', button_name)\n        if slot is not None:\n            self.clicked.connect(slot)\n\n\nclass QtGridViewButton(QCheckBox):\n    """"""Button to toggle grid view mode of layers on and off.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n\n    Attributes\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n\n        self.viewer = viewer\n        self.setToolTip(\'Toggle grid view\')\n        self.viewer.events.grid.connect(self._on_grid_change)\n        self.stateChanged.connect(self.change_grid)\n        self._on_grid_change()\n\n    def change_grid(self, state):\n        """"""Toggle between grid view mode and (the ordinary) stack view mode.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if state == Qt.Checked:\n            self.viewer.stack_view()\n        else:\n            self.viewer.grid_view()\n\n    def _on_grid_change(self, event=None):\n        """"""Update grid layout size.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.viewer.events.grid.blocker():\n            self.setChecked(bool(np.all(self.viewer.grid_size == (1, 1))))\n\n\nclass QtNDisplayButton(QCheckBox):\n    """"""Button to toggle number of displayed dimensions.\n\n    Parameters\n    ----------\n    viewer : napari.components.ViewerModel\n        Napari viewer containing the rendered scene, layers, and controls.\n    """"""\n\n    def __init__(self, viewer):\n        super().__init__()\n\n        self.viewer = viewer\n        self.setToolTip(\'Toggle number of displayed dimensions\')\n        self.viewer.dims.events.ndisplay.connect(self._on_ndisplay_change)\n\n        self.setChecked(self.viewer.dims.ndisplay == 3)\n        self.stateChanged.connect(self.change_ndisplay)\n\n    def change_ndisplay(self, state):\n        """"""Toggle between 2D and 3D display.\n\n        Parameters\n        ----------\n        state : bool\n            If state is True the display view is 3D, if False display is 2D.\n        """"""\n        if state == Qt.Checked:\n            self.viewer.dims.ndisplay = 3\n        else:\n            self.viewer.dims.ndisplay = 2\n\n    def _on_ndisplay_change(self, event=None):\n        """"""Update number of displayed dimensions, while blocking events.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context.\n        """"""\n        with self.viewer.dims.events.ndisplay.blocker():\n            self.setChecked(self.viewer.dims.ndisplay == 3)\n'"
napari/_qt/qt_viewer_dock_widget.py,0,"b'from functools import reduce\nfrom operator import ior\nfrom typing import List, Optional\n\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import (\n    QDockWidget,\n    QFrame,\n    QHBoxLayout,\n    QLabel,\n    QPushButton,\n    QVBoxLayout,\n    QWidget,\n)\n\nfrom .utils import combine_widgets, qt_signals_blocked\n\n\nclass QtViewerDockWidget(QDockWidget):\n    """"""Wrap a QWidget in a QDockWidget and forward viewer events\n\n    Parameters\n    ----------\n    qt_viewer : QtViewer\n        The QtViewer instance that this dock widget will belong to.\n    widget : QWidget\n        `widget` that will be added as QDockWidget\'s main widget.\n    name : str\n        Name of dock widget.\n    area : str\n        Side of the main window to which the new dock widget will be added.\n        Must be in {\'left\', \'right\', \'top\', \'bottom\'}\n    allowed_areas : list[str], optional\n        Areas, relative to main window, that the widget is allowed dock.\n        Each item in list must be in {\'left\', \'right\', \'top\', \'bottom\'}\n        By default, all areas are allowed.\n    shortcut : str, optional\n        Keyboard shortcut to appear in dropdown menu.\n    """"""\n\n    def __init__(\n        self,\n        qt_viewer,\n        widget: QWidget,\n        *,\n        name: str = \'\',\n        area: str = \'bottom\',\n        allowed_areas: Optional[List[str]] = None,\n        shortcut=None,\n    ):\n        self.qt_viewer = qt_viewer\n        super().__init__(name)\n        self.name = name\n\n        areas = {\n            \'left\': Qt.LeftDockWidgetArea,\n            \'right\': Qt.RightDockWidgetArea,\n            \'top\': Qt.TopDockWidgetArea,\n            \'bottom\': Qt.BottomDockWidgetArea,\n        }\n        if area not in areas:\n            raise ValueError(f\'area argument must be in {list(areas.keys())}\')\n        self.area = area\n        self.qt_area = areas[area]\n        self.shortcut = shortcut\n\n        if allowed_areas:\n            if not isinstance(allowed_areas, (list, tuple)):\n                raise TypeError(\'`allowed_areas` must be a list or tuple\')\n            if not all(area in areas for area in allowed_areas):\n                raise ValueError(\n                    f\'all allowed_areas argument must be in {list(areas.keys())}\'\n                )\n            allowed_areas = reduce(ior, [areas[a] for a in allowed_areas])\n        else:\n            allowed_areas = Qt.AllDockWidgetAreas\n        self.setAllowedAreas(allowed_areas)\n        self.setMinimumHeight(50)\n        self.setMinimumWidth(50)\n        self.setObjectName(name)\n\n        self.widget = combine_widgets(\n            widget, vertical=area in {\'left\', \'right\'}\n        )\n        self._features = self.features()\n        self.dockLocationChanged.connect(self._set_title_orientation)\n\n        # custom title bar\n        self.title = QtCustomTitleBar(self)\n        self.setTitleBarWidget(self.title)\n        self.visibilityChanged.connect(self._on_visibility_changed)\n\n    @property\n    def widget(self):\n        """"""QWidget: widget that will be added as QDockWidget\'s main widget.""""""\n        return self._widget\n\n    @widget.setter\n    def widget(self, widget):\n        self.setWidget(widget)\n        widget.setParent(self)\n        self._widget = widget\n\n    def setFeatures(self, features):\n        super().setFeatures(features)\n        self._features = self.features()\n\n    def keyPressEvent(self, event):\n        # if you subclass QtViewerDockWidget and override the keyPressEvent\n        # method, be sure to call super().keyPressEvent(event) at the end of\n        # your method to pass uncaught key-combinations to the viewer.\n        return self.qt_viewer.keyPressEvent(event)\n\n    def _set_title_orientation(self, area):\n        if area in (Qt.LeftDockWidgetArea, Qt.RightDockWidgetArea):\n            features = self._features\n            if features & self.DockWidgetVerticalTitleBar:\n                features = features ^ self.DockWidgetVerticalTitleBar\n        else:\n            features = self._features | self.DockWidgetVerticalTitleBar\n        self.setFeatures(features)\n\n    @property\n    def is_vertical(self):\n        if not self.isFloating():\n            par = self.parent()\n            if par and hasattr(par, \'dockWidgetArea\'):\n                return par.dockWidgetArea(self) in (\n                    Qt.LeftDockWidgetArea,\n                    Qt.RightDockWidgetArea,\n                )\n        return self.size().height() > self.size().width()\n\n    def _on_visibility_changed(self, visible):\n        if not visible:\n            return\n        with qt_signals_blocked(self):\n            self.setTitleBarWidget(None)\n            if not self.isFloating():\n                self.title = QtCustomTitleBar(\n                    self, vertical=not self.is_vertical\n                )\n                self.setTitleBarWidget(self.title)\n\n\nclass QtCustomTitleBar(QLabel):\n    """"""A widget to be used as the titleBar in the QtViewerDockWidget.\n\n    Keeps vertical size minimal, has a hand cursor and styles (in stylesheet)\n    for hover. Close and float buttons.\n\n    Parameters\n    ----------\n    parent : QDockWidget\n        The QtViewerDockWidget to which this titlebar belongs\n    vertical : bool\n        Whether this titlebar is oriented vertically or not.\n    """"""\n\n    def __init__(self, parent, vertical=False):\n        super().__init__(parent)\n        self.setObjectName(""QtCustomTitleBar"")\n        self.setProperty(\'vertical\', str(vertical))\n        self.vertical = vertical\n        self.setToolTip(\'drag to move. double-click to float\')\n\n        line = QFrame(self)\n        line.setObjectName(""QtCustomTitleBarLine"")\n\n        self.close_button = QPushButton(self)\n        self.close_button.setToolTip(\'hide this panel\')\n        self.close_button.setObjectName(""QTitleBarCloseButton"")\n        self.close_button.setCursor(Qt.ArrowCursor)\n        self.close_button.clicked.connect(\n            lambda: self.parent().toggleViewAction().trigger()\n        )\n        self.float_button = QPushButton(self)\n        self.float_button.setToolTip(\'float this panel\')\n        self.float_button.setObjectName(""QTitleBarFloatButton"")\n        self.float_button.setCursor(Qt.ArrowCursor)\n        self.float_button.clicked.connect(\n            lambda: self.parent().setFloating(not self.parent().isFloating())\n        )\n\n        if vertical:\n            layout = QVBoxLayout()\n            layout.setSpacing(4)\n            layout.setContentsMargins(0, 8, 0, 8)\n            line.setFixedWidth(1)\n            layout.addWidget(self.close_button, 0, Qt.AlignHCenter)\n            layout.addWidget(self.float_button, 0, Qt.AlignHCenter)\n            layout.addWidget(line, 0, Qt.AlignHCenter)\n\n        else:\n            layout = QHBoxLayout()\n            layout.setSpacing(4)\n            layout.setContentsMargins(8, 1, 8, 0)\n            line.setFixedHeight(1)\n            layout.addWidget(self.close_button)\n            layout.addWidget(self.float_button)\n            layout.addWidget(line)\n\n        self.setLayout(layout)\n        self.setCursor(Qt.OpenHandCursor)\n\n    def sizeHint(self):\n        # this seems to be the correct way to set the height of the titlebar\n        szh = super().sizeHint()\n        if self.vertical:\n            szh.setWidth(20)\n        else:\n            szh.setHeight(20)\n        return szh\n'"
napari/_qt/theme_sample.py,0,"b'""""""SampleWidget that contains many types of QWidgets.\n\nThis file and SampleWidget is useful for testing out themes from the command\nline or for generating screenshots of a sample widget to demonstrate a theme.\n\nExamples\n--------\nTo use from the command line:\n\n$ python -m napari._qt.theme_sample\n\nTo generate a screenshot within python:\n\n>>> from napari._qt.theme_sample import SampleWidget\n>>> widg = SampleWidget(theme=\'dark\')\n>>> screenshot = widg.screenshot()\n""""""\n\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import (\n    QApplication,\n    QCheckBox,\n    QComboBox,\n    QDoubleSpinBox,\n    QFontComboBox,\n    QFormLayout,\n    QGroupBox,\n    QHBoxLayout,\n    QLabel,\n    QLineEdit,\n    QProgressBar,\n    QPushButton,\n    QRadioButton,\n    QScrollBar,\n    QSlider,\n    QSpinBox,\n    QTabWidget,\n    QTextEdit,\n    QTimeEdit,\n    QVBoxLayout,\n    QWidget,\n)\nfrom ..utils.io import imsave\n\nfrom .qt_range_slider import QHRangeSlider\nfrom ..resources import get_stylesheet\nfrom ..utils.theme import palettes, template\n\nfrom .utils import QImg2array\n\nraw_stylesheet = get_stylesheet()\n\nblurb = """"""\n<h3>Heading</h3>\n<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit,\nsed do eiusmod tempor incididunt ut labore et dolore magna\naliqua. Ut enim ad minim veniam, quis nostrud exercitation\nullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit\nesse cillum dolore eu fugiat nulla pariatur. Excepteur\nsint occaecat cupidatat non proident, sunt in culpa qui\nofficia deserunt mollit anim id est laborum.</p>\n""""""\n\n\nclass TabDemo(QTabWidget):\n    def __init__(self, parent=None, emphasized=False):\n        super().__init__(parent)\n        self.setProperty(\'emphasized\', emphasized)\n        self.tab1 = QWidget()\n        self.tab1.setProperty(\'emphasized\', emphasized)\n        self.tab2 = QWidget()\n        self.tab2.setProperty(\'emphasized\', emphasized)\n\n        self.addTab(self.tab1, ""Tab 1"")\n        self.addTab(self.tab2, ""Tab 2"")\n        layout = QFormLayout()\n        layout.addRow(""Height"", QSpinBox())\n        layout.addRow(""Weight"", QDoubleSpinBox())\n        self.setTabText(0, ""Tab 1"")\n        self.tab1.setLayout(layout)\n\n        layout2 = QFormLayout()\n        sex = QHBoxLayout()\n        sex.addWidget(QRadioButton(""Male""))\n        sex.addWidget(QRadioButton(""Female""))\n        layout2.addRow(QLabel(""Sex""), sex)\n        layout2.addRow(""Date of Birth"", QLineEdit())\n        self.setTabText(1, ""Tab 2"")\n        self.tab2.setLayout(layout2)\n\n        self.setWindowTitle(""tab demo"")\n\n\nclass SampleWidget(QWidget):\n    def __init__(self, theme=\'dark\', emphasized=False):\n        super().__init__(None)\n        self.setProperty(\'emphasized\', emphasized)\n        self.setStyleSheet(template(raw_stylesheet, **palettes[theme]))\n        lay = QVBoxLayout()\n        self.setLayout(lay)\n        lay.addWidget(QPushButton(\'push button\'))\n        box = QComboBox()\n        box.addItems([\'a\', \'b\', \'c\', \'cd\'])\n        lay.addWidget(box)\n        lay.addWidget(QFontComboBox())\n\n        hbox = QHBoxLayout()\n        chk = QCheckBox(\'tristate\')\n        chk.setToolTip(\'I am a tooltip\')\n        chk.setTristate(True)\n        chk.setCheckState(Qt.PartiallyChecked)\n        chk3 = QCheckBox(\'checked\')\n        chk3.setChecked(True)\n        hbox.addWidget(QCheckBox(\'unchecked\'))\n        hbox.addWidget(chk)\n        hbox.addWidget(chk3)\n        lay.addLayout(hbox)\n\n        lay.addWidget(TabDemo(emphasized=emphasized))\n\n        sld = QSlider(Qt.Horizontal)\n        sld.setValue(50)\n        lay.addWidget(sld)\n        scroll = QScrollBar(Qt.Horizontal)\n        scroll.setValue(50)\n        lay.addWidget(scroll)\n        lay.addWidget(QHRangeSlider(parent=self))\n        text = QTextEdit()\n        text.setMaximumHeight(100)\n        text.setHtml(blurb)\n        lay.addWidget(text)\n        lay.addWidget(QTimeEdit())\n        edit = QLineEdit()\n        edit.setPlaceholderText(\'LineEdit placeholder...\')\n        lay.addWidget(edit)\n        lay.addWidget(QLabel(\'label\'))\n        prog = QProgressBar()\n        prog.setValue(50)\n        lay.addWidget(prog)\n        groupBox = QGroupBox(""Exclusive Radio Buttons"")\n        radio1 = QRadioButton(""&Radio button 1"")\n        radio2 = QRadioButton(""R&adio button 2"")\n        radio3 = QRadioButton(""Ra&dio button 3"")\n        radio1.setChecked(True)\n        hbox = QHBoxLayout()\n        hbox.addWidget(radio1)\n        hbox.addWidget(radio2)\n        hbox.addWidget(radio3)\n        hbox.addStretch(1)\n        groupBox.setLayout(hbox)\n        lay.addWidget(groupBox)\n\n    def screenshot(self, path=None):\n        img = self.grab().toImage()\n        if path is not None:\n            imsave(path, QImg2array(img))\n        return QImg2array(img)\n\n\nif __name__ == ""__main__"":\n    import sys\n\n    themes = [sys.argv[1]] if len(sys.argv) > 1 else palettes.keys()\n    app = QApplication([])\n    widgets = []\n    for n, theme in enumerate(themes):\n        try:\n            w = SampleWidget(theme)\n        except KeyError:\n            print(f""{theme} is not a recognized theme"")\n            continue\n        w.setGeometry(10 + 430 * n, 0, 425, 600)\n        w.show()\n        widgets.append(w)\n    if widgets:\n        app.exec_()\n'"
napari/_qt/threading.py,0,"b'import inspect\nimport time\nfrom functools import wraps\nfrom typing import Any, Callable, Dict, Optional, Sequence, Set, Type, Union\n\nimport toolz as tz\nfrom qtpy.QtCore import QObject, QRunnable, QThread, QThreadPool, Signal, Slot\n\n\ndef as_generator_function(func: Callable) -> Callable:\n    """"""Turns a regular function (single return) into a generator function.""""""\n\n    @wraps(func)\n    def genwrapper(*args, **kwargs):\n        yield\n        return func(*args, **kwargs)\n\n    return genwrapper\n\n\nclass WorkerBaseSignals(QObject):\n\n    started = Signal()  # emitted when the work is started\n    finished = Signal()  # emitted when the work is finished\n    returned = Signal(object)  # emitted with return value\n    errored = Signal(object)  # emitted with error object on Exception\n\n\nclass WorkerBase(QRunnable):\n    """"""Base class for creating a Worker that can run in another thread.\n\n    Parameters\n    ----------\n    SignalsClass : type, optional\n        A QObject subclass that contains signals, by default WorkerBaseSignals\n    """"""\n\n    #: A set of Workers.  Add to set using :meth:`WorkerBase.start`\n    _worker_set: Set[\'WorkerBase\'] = set()\n\n    def __init__(\n        self, *args, SignalsClass: Type[QObject] = WorkerBaseSignals, **kwargs\n    ) -> None:\n        super().__init__()\n        self._abort_requested = False\n        self._running = False\n        self._signals = SignalsClass()\n\n    def __getattr__(self, name):\n        """"""Pass through attr requests to signals to simplify connection API.\n\n        The goal is to enable ``worker.signal.connect`` instead of\n        ``worker.signals.yielded.connect``. Because multiple inheritance of Qt\n        classes is not well supported in PyQt, we have to use composition here\n        (signals are provided by QObjects, and QRunnable is not a QObject). So\n        this passthrough allows us to connect to signals on the ``_signals``\n        object.\n        """"""\n        # the Signal object is actually a class attribute\n        attr = getattr(self._signals.__class__, name, None)\n        if isinstance(attr, Signal):\n            # but what we need to connect to is the instantiated signal\n            # (which is of type `SignalInstance` in PySide and\n            # `pyqtBoundSignal` in PyQt)\n            return getattr(self._signals, name)\n\n    def quit(self) -> None:\n        """"""Send a request to abort the worker.\n\n        .. note::\n\n            It is entirely up to subclasses to honor this method by checking\n            ``self.abort_requested`` periodically in their ``worker.work``\n            method, and exiting if ``True``.\n        """"""\n        self._abort_requested = True\n\n    @property\n    def abort_requested(self) -> bool:\n        """"""Whether the worker has been requested to stop.""""""\n        return self._abort_requested\n\n    @property\n    def is_running(self) -> bool:\n        """"""Whether the worker has been started""""""\n        return self._running\n\n    @Slot()\n    def run(self):\n        """"""Start the worker.\n\n        The end-user should never need to call this function.\n        But it cannot be made private or renamed, since it is called by Qt.\n\n        The order of method calls when starting a worker is:\n\n        .. code-block:: none\n\n           calls QThreadPool.globalInstance().start(worker)\n           |               triggered by the QThreadPool.start() method\n           |               |             called by worker.run\n           |               |             |\n           V               V             V\n           worker.start -> worker.run -> worker.work\n\n        **This** is the function that actually gets called when calling\n        :func:`QThreadPool.start(worker)`.  It simply wraps the :meth:`work`\n        method, and emits a few signals.  Subclasses should NOT override this\n        method (except with good reason), and instead should implement\n        :meth:`work`.\n        """"""\n        self.started.emit()\n        self._running = True\n        try:\n            result = self.work()\n            self.returned.emit(result)\n        except Exception as exc:\n            self.errored.emit(exc)\n        self.finished.emit()\n\n    def work(self):\n        """"""Main method to execute the worker.\n\n        The end-user should never need to call this function.\n        But subclasses must implement this method (See\n        :meth:`GeneratorFunction.work` for an example implementation).\n        Minimally, it should check ``self.abort_requested`` periodically and\n        exit if True.\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            class MyWorker(WorkerBase):\n\n                def work(self):\n                    i = 0\n                    while True:\n                        if self.abort_requested:\n                            self.aborted.emit()\n                            break\n                        i += 1\n                        if i > max_iters:\n                            break\n                        time.sleep(0.5)\n        """"""\n        raise NotImplementedError(\n            f\'""{self.__class__.__name__}"" failed to define work() method\'\n        )\n\n    def start(self):\n        """"""Start this worker in a thread and add it to the global threadpool.\n\n        The order of method calls when starting a worker is:\n\n        .. code-block:: none\n\n           calls QThreadPool.globalInstance().start(worker)\n           |               triggered by the QThreadPool.start() method\n           |               |             called by worker.run\n           |               |             |\n           V               V             V\n           worker.start -> worker.run -> worker.work\n        """"""\n        if self in WorkerBase._worker_set:\n            raise RuntimeError(\'This worker is already started!\')\n\n        # This will raise a RunTimeError if the worker is already deleted\n        repr(self)\n\n        WorkerBase._worker_set.add(self)\n        self.finished.connect(lambda: WorkerBase._worker_set.discard(self))\n        QThreadPool.globalInstance().start(self)\n\n\nclass FunctionWorker(WorkerBase):\n    """"""QRunnable with signals that wraps a simple long-running function.\n\n    .. note::\n\n        ``FunctionWorker`` does not provide a way to stop a very long-running\n        function (e.g. ``time.sleep(10000)``).  So whenever possible, it is\n        better to implement your long running function as a generator that\n        yields periodically, and use the :class:`GeneratorWorker` instead.\n\n    Parameters\n    ----------\n    func : Callable\n        A function to call in another thread\n    *args\n        will be passed to the function\n    **kwargs\n        will be passed to the function\n\n    Raises\n    ------\n    TypeError\n        If ``func`` is a generator function and not a regular function.\n    """"""\n\n    def __init__(self, func: Callable, *args, **kwargs):\n        if inspect.isgeneratorfunction(func):\n            raise TypeError(\n                f""Generator function {func} cannot be used with ""\n                ""FunctionWorker, use GeneratorWorker instead""\n            )\n        super().__init__()\n\n        self._func = func\n        self._args = args\n        self._kwargs = kwargs\n\n    def work(self):\n        return self._func(*self._args, **self._kwargs)\n\n\nclass GeneratorWorkerSignals(WorkerBaseSignals):\n\n    yielded = Signal(object)  # emitted with yielded values (if generator used)\n    paused = Signal()  # emitted when a running job has successfully paused\n    resumed = Signal()  # emitted when a paused job has successfully resumed\n    aborted = Signal()  # emitted when a running job is successfully aborted\n\n\nclass GeneratorWorker(WorkerBase):\n    """"""QRunnable with signals that wraps a long-running generator.\n\n    Provides a convenient way to run a generator function in another thread,\n    while allowing 2-way communication between threads, using plain-python\n    generator syntax in the original function.\n\n    Parameters\n    ----------\n    func : callable\n        The function being run in another thread.  May be a generator function.\n    SignalsClass : type, optional\n        A QObject subclass that contains signals, by default\n        GeneratorWorkerSignals\n    *args\n        Will be passed to func on instantiation\n    **kwargs\n        Will be passed to func on instantiation\n    """"""\n\n    def __init__(\n        self,\n        func: Callable,\n        *args,\n        SignalsClass: Type[QObject] = GeneratorWorkerSignals,\n        **kwargs,\n    ):\n        if not inspect.isgeneratorfunction(func):\n            raise TypeError(\n                f""Regular function {func} cannot be used with ""\n                ""GeneratorWorker, use FunctionWorker instead""\n            )\n        super().__init__(SignalsClass=SignalsClass)\n\n        self._gen = func(*args, **kwargs)\n        self._incoming_value = None\n        self._pause_requested = False\n        self._resume_requested = False\n        self._paused = False\n        # polling interval: ONLY relevant if the user paused a running worker\n        self._pause_interval = 0.01\n\n    def work(self) -> None:\n        """"""Core event loop that calls the original function.\n\n        Enters a continual loop, yielding and returning from the original\n        function.  Checks for various events (quit, pause, resume, etc...).\n        (To clarify: we are creating a rudimentary event loop here because\n        there IS NO Qt event loop running in the other thread to hook into)\n        """"""\n        while True:\n            if self.abort_requested:\n                self.aborted.emit()\n                break\n            if self._paused:\n                if self._resume_requested:\n                    self._paused = False\n                    self._resume_requested = False\n                    self.resumed.emit()\n                else:\n                    time.sleep(self._pause_interval)\n                    continue\n            elif self._pause_requested:\n                self._paused = True\n                self._pause_requested = False\n                self.paused.emit()\n                continue\n            try:\n                self.yielded.emit(self._gen.send(self._next_value()))\n            except StopIteration as exc:\n                return exc.value\n\n    def send(self, value: Any):\n        """"""Send a value into the function (if a generator was used).""""""\n        self._incoming_value = value\n\n    def _next_value(self) -> Any:\n        out = None\n        if self._incoming_value is not None:\n            out = self._incoming_value\n            self._incoming_value = None\n        return out\n\n    @property\n    def is_paused(self) -> bool:\n        """"""Whether the worker is currently paused.""""""\n        return self._paused\n\n    def toggle_pause(self) -> None:\n        """"""Request to pause the worker if playing or resume if paused.""""""\n        if self.is_paused:\n            self._resume_requested = True\n        else:\n            self._pause_requested = True\n\n    def pause(self) -> None:\n        """"""Request to pause the worker.""""""\n        if not self.is_paused:\n            self._pause_requested = True\n\n    def resume(self) -> None:\n        """"""Send a request to resume the worker.\n        """"""\n        if self.is_paused:\n            self._resume_requested = True\n\n\n############################################################################\n\n# public API\n\n# For now, the next three functions simply wrap the QThreadPool API, and allow\n# us to track and cleanup all workers that were started with ``start_worker``,\n# provided that ``wait_for_workers_to_quit`` is called at shutdown.\n# In the future, this could wrap any API, or a pure python threadpool.\n\n\ndef set_max_thread_count(num: int):\n    """"""Set the maximum number of threads used by the thread pool.\n\n    Note: The thread pool will always use at least 1 thread, even if\n    maxThreadCount limit is zero or negative.\n    """"""\n    QThreadPool.globalInstance().setMaxThreadCount(num)\n\n\ndef wait_for_workers_to_quit(msecs: int = None):\n    """"""Ask all workers to quit, and wait up to `msec` for quit.\n\n    Attempts to clean up all running workers by calling ``worker.quit()``\n    method.  Any workers in the ``WorkerBase._worker_set`` set will have this\n    method.\n\n    By default, this function will block indefinitely, until worker threads\n    finish.  If a timeout is provided, a ``RuntimeError`` will be raised if\n    the workers do not gracefully exit in the time requests, but the threads\n    will NOT be killed.  It is (currently) left to the user to use their OS\n    to force-quit rogue threads.\n\n    .. important::\n\n        If the user does not put any yields in their function, and the function\n        is super long, it will just hang... For instance, there\'s no graceful\n        way to kill this thread in python:\n\n        .. code-block:: python\n\n            @thread_worker\n            def ZZZzzz():\n                time.sleep(10000000)\n\n        This is why it\'s always advisable to use a generator that periodically\n        yields for long-running computations in another thread.\n\n        See `this stack-overflow post\n        <https://stackoverflow.com/questions/323972/is-there-any-way-to-kill-a-thread>`_\n        for a good discussion on the difficulty of killing a rogue python thread:\n\n    Parameters\n    ----------\n    msecs : int, optional\n        Waits up to msecs milliseconds for all threads to exit and removes all\n        threads from the thread pool. If msecs is `None` (the default), the\n        timeout is ignored (waits for the last thread to exit).\n\n    Raises\n    -------\n    RuntimeError\n        If a timeout is provided and workers do not quit successfully within\n        the time alotted.\n    """"""\n    for worker in WorkerBase._worker_set:\n        worker.quit()\n\n    msecs = msecs if msecs is not None else -1\n    if not QThreadPool.globalInstance().waitForDone(msecs):\n        raise RuntimeError(\n            f""Workers did not quit gracefully in the time alotted ({msecs} ms)""\n        )\n\n\ndef active_thread_count() -> int:\n    """"""Return the number of active threads in the global ThreadPool.""""""\n    return QThreadPool.globalInstance().activeThreadCount()\n\n\n#############################################################################\n\n# convenience functions for creating Worker instances\n\n\ndef create_worker(\n    func: Callable,\n    *args,\n    _start_thread: Optional[bool] = None,\n    _connect: Optional[Dict[str, Union[Callable, Sequence[Callable]]]] = None,\n    _worker_class: Optional[Type[WorkerBase]] = None,\n    _ignore_errors: bool = False,\n    **kwargs,\n) -> WorkerBase:\n    """"""Convenience function to start a function in another thread.\n\n    By default, uses :class:`Worker`, but a custom ``WorkerBase`` subclass may\n    be provided.  If so, it must be a subclass of :class:`Worker`, which\n    defines a standard set of signals and a run method.\n\n    Parameters\n    ----------\n    func : Callable\n        The function to call in another thread.\n    _start_thread : bool, optional\n        Whether to immediaetly start the thread.  If False, the returned worker\n        must be manually started with ``worker.start()``. by default it will be\n        ``False`` if the ``_connect`` argument is ``None``, otherwise ``True``.\n    _connect : Dict[str, Union[Callable, Sequence]], optional\n        A mapping of ``""signal_name""`` -> ``callable`` or list of ``callable``:\n        callback functions to connect to the various signals offered by the\n        worker class. by default None\n    _worker_class : Type[WorkerBase], optional\n        The :class`WorkerBase` to instantiate, by default\n        :class:`FunctionWorker` will be used if ``func`` is a regular function,\n        and :class:`GeneratorWorker` will be used if it is a generator.\n    _ignore_errors : bool, optional\n        If ``False`` (the default), errors raised in the other thread will be\n        reraised in the main thread (makes debugging significantly easier).\n    *args\n        will be passed to ``func``\n    **kwargs\n        will be passed to ``func``\n\n    Returns\n    -------\n    worker : WorkerBase\n        An instantiated worker.  If ``_start_thread`` was ``False``, the worker\n        will have a `.start()` method that can be used to start the thread.\n\n    Raises\n    ------\n    TypeError\n        If a worker_class is provided that is not a subclass of WorkerBase.\n    TypeError\n        If _connect is provided and is not a dict of ``{str: callable}``\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        def long_function(duration):\n            import time\n            time.sleep(duration)\n\n        worker = create_worker(long_function, 10)\n\n    """"""\n    if not _worker_class:\n        if inspect.isgeneratorfunction(func):\n            _worker_class = GeneratorWorker\n        else:\n            _worker_class = FunctionWorker\n\n    if not (\n        inspect.isclass(_worker_class)\n        and issubclass(_worker_class, WorkerBase)\n    ):\n        raise TypeError(\n            f\'Worker {_worker_class} must be a subclass of WorkerBase\'\n        )\n\n    worker = _worker_class(func, *args, **kwargs)\n\n    if _connect is not None:\n        if not isinstance(_connect, dict):\n            raise TypeError(""The \'_connect\' argument must be a dict"")\n\n        if _start_thread is None:\n            _start_thread = True\n\n        for key, val in _connect.items():\n            _val = val if isinstance(val, (tuple, list)) else [val]\n            for v in _val:\n                if not callable(v):\n                    raise TypeError(\n                        f\'""_connect[{key!r}]"" must be a function or \'\n                        \'sequence of functions\'\n                    )\n                getattr(worker, key).connect(v)\n\n    # if the user has not provided a default connection for the ""errored""\n    # signal... and they have not explicitly set ``ignore_errors=True``\n    # Then rereaise any errors from the thread.\n    if not _ignore_errors and not (_connect or {}).get(\'errored\', False):\n\n        def reraise(e):\n            raise e\n\n        worker.errored.connect(reraise)\n\n    if _start_thread:\n        worker.start()\n    return worker\n\n\n@tz.curry\ndef thread_worker(\n    function: Callable,\n    start_thread: Optional[bool] = None,\n    connect: Optional[Dict[str, Union[Callable, Sequence[Callable]]]] = None,\n    worker_class: Optional[Type[WorkerBase]] = None,\n    ignore_errors: bool = False,\n) -> Callable:\n    """"""Decorator that runs a function in a seperate thread when called.\n\n    When called, the decorated function returns a :class:`WorkerBase`.  See\n    :func:`create_worker` for additional keyword arguments that can be used\n    when calling the function.\n\n    The returned worker will have these signals:\n\n        - *started*: emitted when the work is started\n        - *finished*: emitted when the work is finished\n        - *returned*: emitted with return value\n        - *errored*: emitted with error object on Exception\n\n    It will also have a ``worker.start()`` method that can be used to start\n    execution of the function in another thread. (useful if you need to connect\n    callbacks to signals prior to execution)\n\n    If the decorated function is a generator, the returned worker will also\n    provide these signals:\n\n        - *yielded*: emitted with yielded values\n        - *paused*: emitted when a running job has successfully paused\n        - *resumed*: emitted when a paused job has successfully resumed\n        - *aborted*: emitted when a running job is successfully aborted\n\n    And these methods:\n\n        - *quit*: ask the thread to quit\n        - *toggle_paused*: toggle the running state of the thread.\n        - *send*: send a value into the generator.  (This requires that your\n          decorator function uses the ``value = yield`` syntax)\n\n\n    Parameters\n    ----------\n    func : callable\n        Function to call in another thread.  For communication between threads\n        may be a generator function.\n    start_thread : bool, optional\n        Whether to immediaetly start the thread.  If False, the returned worker\n        must be manually started with ``worker.start()``. by default it will be\n        ``False`` if the ``_connect`` argument is ``None``, otherwise ``True``.\n    connect : Dict[str, Union[Callable, Sequence]], optional\n        A mapping of ``""signal_name""`` -> ``callable`` or list of ``callable``:\n        callback functions to connect to the various signals offered by the\n        worker class. by default None\n    worker_class : Type[WorkerBase], optional\n        The :class`WorkerBase` to instantiate, by default\n        :class:`FunctionWorker` will be used if ``func`` is a regular function,\n        and :class:`GeneratorWorker` will be used if it is a generator.\n    ignore_errors : bool, optional\n        If ``False`` (the default), errors raised in the other thread will be\n        reraised in the main thread (makes debugging significantly easier).\n\n    Returns\n    -------\n    callable\n        function that creates a worker, puts it in a new thread and returns\n        the worker instance.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        @thread_worker\n        def long_function(start, end):\n            # do work, periodically yielding\n            i = start\n            while i <= end:\n                time.sleep(0.1)\n                yield i\n\n            # do teardown\n            return \'anything\'\n\n        # call the function to start running in another thread.\n        worker = long_function()\n        # connect signals here if desired... or they may be added using the\n        # `connect` argument in the `@thread_worker` decorator... in which\n        # case the worker will start immediately when long_function() is called\n        worker.start()\n    """"""\n\n    @wraps(function)\n    def worker_function(*args, **kwargs):\n        # decorator kwargs can be overridden at call time by using the\n        # underscore-prefixed version of the kwarg.\n        kwargs[\'_start_thread\'] = kwargs.get(\'_start_thread\', start_thread)\n        kwargs[\'_connect\'] = kwargs.get(\'_connect\', connect)\n        kwargs[\'_worker_class\'] = kwargs.get(\'_worker_class\', worker_class)\n        kwargs[\'_ignore_errors\'] = kwargs.get(\'_ignore_errors\', ignore_errors)\n        return create_worker(function, *args, **kwargs,)\n\n    return worker_function\n\n\n############################################################################\n\n# This is a variant on the above pattern, it uses QThread instead of Qrunnable\n# see https://doc.qt.io/qt-5/threads-technologies.html#comparison-of-solutions\n# (it appears from that table that QRunnable cannot emit or receive signals,\n# but we circumvent that here with our WorkerBase class that also inherits from\n# QObject... providing signals/slots).\n#\n# A benefit of the QRunnable pattern is that Qt manages the threads for you,\n# in the QThreadPool.globalInstance() ... making it easier to reuse threads,\n# and reduce overhead.\n#\n# However, a disadvantage is that you have no access to (and therefore less\n# control over) the QThread itself.  See for example all of the methods\n# provided on the QThread object: https://doc.qt.io/qt-5/qthread.html\n\n\n# TODO: potentially remove this altogether, by refactoring the dims\n# AnimationWorker to subclass WorkerBase\n\n\ndef _new_worker_qthread(\n    Worker: Type[QObject],\n    *args,\n    _start_thread: bool = False,\n    _connect: Dict[str, Callable] = None,\n    **kwargs,\n):\n    """"""This is a convenience function to start a worker in a Qthread.\n\n    In most cases, the @thread_worker decorator is sufficient and preferable.\n    But this allows the user to completely customize the Worker object.\n    However, they must then maintain control over the thread and clean up\n    appropriately.\n\n    It follows the pattern described here:\n    https://www.qt.io/blog/2010/06/17/youre-doing-it-wrong\n    and\n    https://doc.qt.io/qt-5/qthread.html#details\n\n    see also:\n    https://mayaposch.wordpress.com/2011/11/01/how-to-really-truly-use-qthreads-the-full-explanation/\n\n    A QThread object is not a thread! It should be thought of as a class to\n    *manage* a thread, not as the actual code or object that runs in that\n    thread.  The QThread object is created on the main thread and lives there.\n\n    Worker objects which derive from QObject are the things that actually do\n    the work. They can be moved to a QThread as is done here.\n\n    .. note:: Mostly ignorable detail\n\n        While the signals/slots syntax of the worker looks very similar to\n        standard ""single-threaded"" signals & slots, note that inter-thread\n        signals and slots (automatically) use an event-based QueuedConnection,\n        while intra-thread signals use a DirectConnection. See `Signals and\n        Slots Across Threads\n        <https://doc.qt.io/qt-5/threads-qobject.html#signals-and-slots-across-threads>`_\n\n    Parameters\n    ----------\n    Worker : QObject\n        QObject type that implements a work() method.  The Worker should also\n        emit a finished signal when the work is done.\n    start_thread : bool\n        If True, thread will be started immediately, otherwise, thread must\n        be manually started with thread.start().\n    connections: dict, optional\n        Optional dictionary of {signal: function} to connect to the new worker.\n        for instance:  connections = {\'incremented\': myfunc} will result in:\n        worker.incremented.connect(myfunc)\n    *args\n        will be passed to the Worker class on instantiation.\n    **kwargs\n        will be passed to the Worker class on instantiation.\n\n    Returns\n    -------\n    worker : WorkerBase\n        The created worker.\n    thread : QThread\n        The thread on which the worker is running.\n\n    Examples\n    --------\n    Create some QObject that has a long-running work method:\n\n    .. code-block:: python\n\n        class Worker(QObject):\n\n            finished = Signal()\n            increment = Signal(int)\n\n            def __init__(self, argument):\n                super().__init__()\n                self.argument = argument\n\n            @Slot()\n            def work(self):\n                # some long running task...\n                import time\n                for i in range(10):\n                    time.sleep(1)\n                    self.increment.emit(i)\n                self.finished.emit()\n\n        worker, thread = _new_worker_qthread(\n            Worker,\n            \'argument\',\n            start_thread=True,\n            connections={\'increment\': print},\n        )\n\n    """"""\n\n    if _connect and not isinstance(_connect, dict):\n        raise TypeError(\'_connect parameter must be a dict\')\n\n    thread = QThread()\n    worker = Worker(*args, **kwargs)\n    worker.moveToThread(thread)\n    thread.started.connect(worker.work)\n    worker.finished.connect(thread.quit)\n    worker.finished.connect(worker.deleteLater)\n    thread.finished.connect(thread.deleteLater)\n\n    if _connect:\n        [getattr(worker, key).connect(val) for key, val in _connect.items()]\n\n    if _start_thread:\n        thread.start()  # sometimes need to connect stuff before starting\n    return worker, thread\n'"
napari/_qt/utils.py,2,"b'from contextlib import contextmanager\nfrom functools import lru_cache\nfrom typing import Sequence, Union\n\nimport numpy as np\nfrom qtpy import API_NAME\nfrom qtpy.QtCore import QSize, Qt\nfrom qtpy.QtGui import QCursor, QDrag, QImage, QPainter, QPixmap\nfrom qtpy.QtWidgets import (\n    QGraphicsOpacityEffect,\n    QHBoxLayout,\n    QListWidget,\n    QVBoxLayout,\n    QWidget,\n    QSizePolicy,\n)\n\nfrom ..utils.misc import is_sequence\n\n\ndef QImg2array(img):\n    """"""Convert QImage to an array.\n\n    Parameters\n    ----------\n    img : qtpy.QtGui.QImage\n        QImage to be converted.\n\n    Returns\n    -------\n    arr : array\n        Numpy array of type ubyte and shape (h, w, 4). Index [0, 0] is the\n        upper-left corner of the rendered region.\n    """"""\n    # Fix when  image is provided in wrong format (ex. test on Azure pipelines)\n    if img.format() != QImage.Format_ARGB32:\n        img = img.convertToFormat(QImage.Format_ARGB32)\n    b = img.constBits()\n    h, w, c = img.height(), img.width(), 4\n\n    # As vispy doesn\'t use qtpy we need to reconcile the differences\n    # between the `QImage` API for `PySide2` and `PyQt5` on how to convert\n    # a QImage to a numpy array.\n    if API_NAME == \'PySide2\':\n        arr = np.array(b).reshape(h, w, c)\n    else:\n        b.setsize(h * w * c)\n        arr = np.frombuffer(b, np.uint8).reshape(h, w, c)\n\n    # Format of QImage is ARGB32_Premultiplied, but color channels are\n    # reversed.\n    arr = arr[:, :, [2, 1, 0, 3]]\n    return arr\n\n\n@contextmanager\ndef qt_signals_blocked(obj):\n    """"""Context manager to temporarily block signals from `obj`""""""\n    obj.blockSignals(True)\n    yield\n    obj.blockSignals(False)\n\n\ndef disable_with_opacity(obj, widget_list, disabled):\n    """"""Set enabled state on a list of widgets. If disabled, decrease opacity""""""\n    for wdg in widget_list:\n        widget = getattr(obj, wdg)\n        widget.setEnabled(obj.layer.editable)\n        op = QGraphicsOpacityEffect(obj)\n        op.setOpacity(1 if obj.layer.editable else 0.5)\n        widget.setGraphicsEffect(op)\n\n\n@lru_cache(maxsize=64)\ndef square_pixmap(size):\n    """"""Create a white/black hollow square pixmap. For use as labels cursor.""""""\n    pixmap = QPixmap(QSize(size, size))\n    pixmap.fill(Qt.transparent)\n    painter = QPainter(pixmap)\n    painter.setPen(Qt.white)\n    painter.drawRect(0, 0, size - 1, size - 1)\n    painter.setPen(Qt.black)\n    painter.drawRect(1, 1, size - 3, size - 3)\n    painter.end()\n    return pixmap\n\n\ndef drag_with_pixmap(list_widget: QListWidget) -> QDrag:\n    """"""Create a QDrag object with a pixmap of the currently select list item.\n\n    This method is useful when you have a QListWidget that displays custom\n    widgets for each QListWidgetItem instance in the list (usually by calling\n    ``QListWidget.setItemWidget(item, widget)``).  When used in a\n    ``QListWidget.startDrag`` method, this function creates a QDrag object that\n    shows an image of the item being dragged (rather than an empty rectangle).\n\n    Parameters\n    ----------\n    list_widget : QListWidget\n        The QListWidget for which to create a QDrag object.\n\n    Returns\n    -------\n    QDrag\n        A QDrag instance with a pixmap of the currently selected item.\n\n    Example\n    -------\n    >>> class QListWidget:\n    ...     def startDrag(self, supportedActions):\n    ...         drag = drag_with_pixmap(self)\n    ...         drag.exec_(supportedActions, Qt.MoveAction)\n\n    """"""\n    drag = QDrag(list_widget)\n    drag.setMimeData(list_widget.mimeData(list_widget.selectedItems()))\n    size = list_widget.viewport().visibleRegion().boundingRect().size()\n    pixmap = QPixmap(size)\n    pixmap.fill(Qt.transparent)\n    painter = QPainter(pixmap)\n    for index in list_widget.selectedIndexes():\n        rect = list_widget.visualRect(index)\n        painter.drawPixmap(rect, list_widget.viewport().grab(rect))\n    painter.end()\n    drag.setPixmap(pixmap)\n    drag.setHotSpot(list_widget.viewport().mapFromGlobal(QCursor.pos()))\n    return drag\n\n\ndef combine_widgets(\n    widgets: Union[QWidget, Sequence[QWidget]], vertical: bool = False\n) -> QWidget:\n    """"""Combine a list of widgets into a single QWidget with Layout.\n\n    Parameters\n    ----------\n    widgets : QWidget or sequence of QWidget\n        A widget or a list of widgets to combine.\n    vertical : bool, optional\n        Whether the layout should be QVBoxLayout or not, by default\n        QHBoxLayout is used\n\n    Returns\n    -------\n    QWidget\n        If ``widgets`` is a sequence, returns combined QWidget with `.layout`\n        property, otherwise returns the original widget.\n\n    Raises\n    ------\n    TypeError\n        If ``widgets`` is neither a ``QWidget`` or a sequence of ``QWidgets``.\n    """"""\n    if isinstance(widgets, QWidget):\n        return widgets\n    elif is_sequence(widgets) and all(isinstance(i, QWidget) for i in widgets):\n        container = QWidget()\n        container.layout = QVBoxLayout() if vertical else QHBoxLayout()\n        container.setLayout(container.layout)\n        for widget in widgets:\n            container.layout.addWidget(widget)\n        # if this is a vertical layout, and none of the widgets declare a size\n        # policy of ""expanding"", add our own stretch.\n        if vertical and not any(\n            w.sizePolicy().verticalPolicy() == QSizePolicy.Expanding\n            for w in widgets\n        ):\n            container.layout.addStretch()\n        return container\n    else:\n        raise TypeError(\'""widget"" must be a QWidget or a sequence of QWidgets\')\n'"
napari/_tests/__init__.py,0,b''
napari/_tests/test_advanced.py,52,"b'import numpy as np\n\n\ndef test_4D_5D_images(viewer_factory):\n    """"""Test adding 4D followed by 5D image layers to the viewer.\n\n    Intially only 2 sliders should be present, then a third slider should be\n    created.\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add 4D image data\n    data = np.random.random((2, 6, 30, 40))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 4\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 2\n\n    # now add 5D image data - check an extra slider has been created\n    data = np.random.random((4, 4, 5, 30, 40))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[1].data == data)\n    assert len(viewer.layers) == 2\n    assert viewer.dims.ndim == 5\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 3\n\n\ndef test_5D_image_3D_rendering(viewer_factory):\n    """"""Test 3D rendering of a 5D image.""""""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add 4D image data\n    data = np.random.random((2, 10, 12, 13, 14))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 5\n    assert viewer.dims.ndisplay == 2\n    assert viewer.layers[0]._data_view.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 3\n\n    # switch to 3D rendering\n    viewer.dims.ndisplay = 3\n    assert viewer.dims.ndisplay == 3\n    assert viewer.layers[0]._data_view.ndim == 3\n    assert np.sum(view.dims._displayed_sliders) == 2\n\n\ndef test_change_image_dims(viewer_factory):\n    """"""Test changing the dims and shape of an image layer in place and checking\n    the numbers of sliders and their ranges changes appropriately.\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add 3D image data\n    data = np.random.random((10, 30, 40))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 1\n\n    # switch number of displayed dimensions\n    viewer.layers[0].data = data[0]\n    assert np.all(viewer.layers[0].data == data[0])\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # switch number of displayed dimensions\n    viewer.layers[0].data = data[:6]\n    assert np.all(viewer.layers[0].data == data[:6])\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 1\n\n    # change the shape of the data\n    viewer.layers[0].data = data[:3]\n    assert np.all(viewer.layers[0].data == data[:3])\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 1\n\n\ndef test_range_one_image(viewer_factory):\n    """"""Test adding an image with a range one dimensions.\n\n    There should be no slider shown for the axis corresponding to the range\n    one dimension.\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add 5D image data with range one dimensions\n    data = np.random.random((1, 1, 1, 100, 200))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 5\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # now add 5D points data - check extra sliders have been created\n    points = np.floor(5 * np.random.random((1000, 5))).astype(int)\n    points[:, -2:] = 20 * points[:, -2:]\n    viewer.add_points(points)\n    assert np.all(viewer.layers[1].data == points)\n    assert len(viewer.layers) == 2\n    assert viewer.dims.ndim == 5\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 3\n\n\ndef test_range_one_images_and_points(viewer_factory):\n    """"""Test adding images with range one dimensions and points.\n\n    Intially no sliders should be present as the images have range one\n    dimensions. On adding the points the sliders should be displayed.\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add 5D image data with range one dimensions\n    data = np.random.random((1, 1, 1, 100, 200))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 5\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # now add 5D points data - check extra sliders have been created\n    points = np.floor(5 * np.random.random((1000, 5))).astype(int)\n    points[:, -2:] = 20 * points[:, -2:]\n    viewer.add_points(points)\n    assert np.all(viewer.layers[1].data == points)\n    assert len(viewer.layers) == 2\n    assert viewer.dims.ndim == 5\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 3\n\n\ndef test_update_console(viewer_factory):\n    """"""Test updating the console with local variables.""""""\n    view, viewer = viewer_factory()\n\n    # Check viewer in console\n    assert view.console.kernel_client is not None\n    assert \'viewer\' in view.console.shell.user_ns\n    assert view.console.shell.user_ns[\'viewer\'] == viewer\n\n    a = 4\n    b = 5\n    viewer.update_console(locals())\n    assert \'a\' in view.console.shell.user_ns\n    assert view.console.shell.user_ns[\'a\'] == a\n    assert \'b\' in view.console.shell.user_ns\n    assert view.console.shell.user_ns[\'b\'] == b\n\n\ndef test_changing_display_surface(viewer_factory):\n    """"""Test adding 3D surface and changing its display.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    viewer.add_surface(data)\n    assert np.all(\n        [np.all(vd == d) for vd, d in zip(viewer.layers[0].data, data)]\n    )\n\n    assert len(viewer.layers) == 1\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 3\n    assert view.dims.nsliders == viewer.dims.ndim\n\n    # Check display is currently 2D with one slider\n    assert viewer.layers[0]._data_view.shape[1] == 2\n    assert np.sum(view.dims._displayed_sliders) == 1\n\n    # Make display 3D\n    viewer.dims.ndisplay = 3\n    assert viewer.layers[0]._data_view.shape[1] == 3\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # Make display 2D again\n    viewer.dims.ndisplay = 2\n    assert viewer.layers[0]._data_view.shape[1] == 2\n    assert np.sum(view.dims._displayed_sliders) == 1\n\n    # Iterate over all values in first dimension\n    len_slider = viewer.dims.range[0]\n    for s in len_slider:\n        viewer.dims.set_point(0, s)\n\n\ndef test_labels_undo_redo(viewer_factory):\n    """"""Test undoing/redoing on the labels layer.""""""\n    view, viewer = viewer_factory()\n\n    data = np.zeros((50, 50), dtype=np.uint8)\n    data[:5, :5] = 1\n    data[5:10, 5:10] = 2\n    data[25:, 25:] = 3\n\n    labels = viewer.add_labels(data)\n\n    l1 = labels.data.copy()\n\n    # fill\n    labels.fill((30, 30), 42)\n\n    l2 = labels.data.copy()\n    assert not np.array_equal(l1, l2)\n\n    # undo\n    labels.undo()\n    assert np.array_equal(l1, labels.data)\n\n    # redo\n    labels.redo()\n    assert np.array_equal(l2, labels.data)\n\n    # history limit\n    labels._history_limit = 1\n    labels.fill((0, 0), 3)\n\n    l3 = labels.data.copy()\n\n    assert not np.array_equal(l3, l2)\n\n    labels.undo()\n    assert np.array_equal(l2, labels.data)\n\n    # cannot undo as limit exceded\n    labels.undo()\n    assert np.array_equal(l2, labels.data)\n'"
napari/_tests/test_cli.py,0,"b'from napari import __main__\nimport sys\nimport pytest\nfrom contextlib import contextmanager\n\n\ndef test_cli_works(monkeypatch, capsys):\n    """"""Test the cli runs and shows help""""""\n    monkeypatch.setattr(sys, \'argv\', [\'napari\', \'-h\'])\n    with pytest.raises(SystemExit):\n        __main__.main()\n    assert \'napari command line viewer.\' in str(capsys.readouterr())\n\n\ndef test_cli_shows_plugins(monkeypatch, capsys):\n    """"""Test the cli --info runs and shows plugins""""""\n    monkeypatch.setattr(sys, \'argv\', [\'napari\', \'--info\'])\n    with pytest.raises(SystemExit):\n        __main__.main()\n    assert \'svg\' in str(capsys.readouterr())\n\n\ndef test_cli_parses_unknowns(monkeypatch):\n    """"""test that we can parse layer keyword arg variants""""""\n\n    def assert_kwargs(*args, **kwargs):\n        assert args == ([""file""],)\n        assert kwargs[\'contrast_limits\'] == (0, 1)\n\n    @contextmanager\n    def gui_qt(**kwargs):\n        yield\n\n    # testing all the variants of literal_evals\n    monkeypatch.setattr(__main__, \'view_path\', assert_kwargs)\n    monkeypatch.setattr(__main__, \'gui_qt\', gui_qt)\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'n\', \'file\', \'--contrast-limits\', \'(0, 1)\'])\n        __main__.main()\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'n\', \'file\', \'--contrast-limits\', \'(0,1)\'])\n        __main__.main()\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'n\', \'file\', \'--contrast-limits=(0, 1)\'])\n        __main__.main()\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'n\', \'file\', \'--contrast-limits=(0,1)\'])\n        __main__.main()\n\n\ndef test_cli_raises(monkeypatch):\n    """"""test that unknown kwargs raise the correct errors.""""""\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'napari\', \'path/to/file\', \'--nonsense\'])\n        with pytest.raises(SystemExit) as e:\n            __main__.main()\n        assert str(e.value) == \'error: unrecognized arguments: --nonsense\'\n\n    with monkeypatch.context() as m:\n        m.setattr(sys, \'argv\', [\'napari\', \'path/to/file\', \'--gamma\'])\n        with pytest.raises(SystemExit) as e:\n            __main__.main()\n        assert str(e.value) == \'error: argument --gamma expected one argument\'\n'"
napari/_tests/test_draw.py,1,"b'import numpy as np\nimport pytest\nimport sys\n\n\n@pytest.mark.skipif(\n    sys.platform.startswith(\'win\') or sys.platform.startswith(\'linux\'),\n    reason=\'Currently fails on certain CI due to error on canvas draw.\',\n)\ndef test_canvas_drawing(viewer_factory):\n    """"""Test drawing before and after adding and then deleting a layer.""""""\n    view, viewer = viewer_factory()\n    assert len(viewer.layers) == 0\n    # Check canvas context is not none before drawing, as currently on\n    # some of our CI a proper canvas context is not made\n    view.canvas.events.draw()\n\n    # Add layer\n    data = np.random.random((15, 10, 5))\n    layer = viewer.add_image(data)\n    assert len(viewer.layers) == 1\n    view.canvas.events.draw()\n\n    # Remove layer\n    viewer.layers.remove(layer)\n    assert len(viewer.layers) == 0\n    view.canvas.events.draw()\n'"
napari/_tests/test_dtypes.py,18,"b'import numpy as np\nimport pytest\n\ndtypes = [\n    np.dtype(np.bool),\n    np.dtype(np.int8),\n    np.dtype(np.uint8),\n    np.dtype(np.int16),\n    np.dtype(np.uint16),\n    np.dtype(np.int32),\n    np.dtype(np.uint32),\n    np.dtype(np.int64),\n    np.dtype(np.uint64),\n    np.dtype(np.float16),\n    np.dtype(np.float32),\n    np.dtype(np.float64),\n]\n\n\n@pytest.mark.parametrize(\'dtype\', dtypes)\ndef test_image_dytpes(viewer_factory, dtype):\n    """"""Test different dtype images.""""""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    # add dtype image data\n    data = np.random.randint(20, size=(30, 40)).astype(dtype)\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n\n    # add dtype multiscale data\n    data = [\n        np.random.randint(20, size=(30, 40)).astype(dtype),\n        np.random.randint(20, size=(15, 20)).astype(dtype),\n    ]\n    viewer.add_image(data, multiscale=True)\n    assert np.all(viewer.layers[1].data == data)\n'"
napari/_tests/test_key_bindings.py,3,"b'import numpy as np\nfrom unittest.mock import Mock\nfrom vispy import keys\n\n\ndef test_viewer_key_bindings(viewer_factory):\n    """"""Test adding key bindings to the viewer\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    mock_press = Mock()\n    mock_release = Mock()\n    mock_shift_press = Mock()\n    mock_shift_release = Mock()\n\n    @viewer.bind_key(\'F\')\n    def key_callback(v):\n        assert viewer == v\n\n        # on press\n        mock_press.method()\n\n        yield\n\n        # on release\n        mock_release.method()\n\n    @viewer.bind_key(\'Shift-F\')\n    def key_shift_callback(v):\n        assert viewer == v\n\n        # on press\n        mock_shift_press.method()\n\n        yield\n\n        # on release\n        mock_shift_release.method()\n\n    # Simulate press only\n    view.canvas.events.key_press(key=keys.Key(\'F\'))\n    mock_press.method.assert_called_once()\n    mock_press.reset_mock()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.key_release(key=keys.Key(\'F\'))\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_called_once()\n    mock_release.reset_mock()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate press only\n    view.canvas.events.key_press(key=keys.Key(\'F\'), modifiers=[keys.SHIFT])\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_called_once()\n    mock_shift_press.reset_mock()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.key_release(key=keys.Key(\'F\'), modifiers=[keys.SHIFT])\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_called_once()\n    mock_shift_release.reset_mock()\n\n\ndef test_layer_key_bindings(viewer_factory):\n    """"""Test adding key bindings to a layer\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory()\n\n    layer = viewer.add_image(np.random.random((10, 20)))\n    layer.selected = True\n\n    mock_press = Mock()\n    mock_release = Mock()\n    mock_shift_press = Mock()\n    mock_shift_release = Mock()\n\n    @layer.bind_key(\'F\')\n    def key_callback(l):\n        assert layer == l\n        # on press\n        mock_press.method()\n        yield\n        # on release\n        mock_release.method()\n\n    @layer.bind_key(\'Shift-F\')\n    def key_shift_callback(l):\n        assert layer == l\n\n        # on press\n        mock_shift_press.method()\n\n        yield\n\n        # on release\n        mock_shift_release.method()\n\n    # Simulate press only\n    view.canvas.events.key_press(key=keys.Key(\'F\'))\n    mock_press.method.assert_called_once()\n    mock_press.reset_mock()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.key_release(key=keys.Key(\'F\'))\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_called_once()\n    mock_release.reset_mock()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate press only\n    view.canvas.events.key_press(key=keys.Key(\'F\'), modifiers=[keys.SHIFT])\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_called_once()\n    mock_shift_press.reset_mock()\n    mock_shift_release.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.key_release(key=keys.Key(\'F\'), modifiers=[keys.SHIFT])\n    mock_press.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_shift_press.method.assert_not_called()\n    mock_shift_release.method.assert_called_once()\n    mock_shift_release.reset_mock()\n'"
napari/_tests/test_mouse_bindings.py,5,"b'import numpy as np\nfrom unittest.mock import Mock\n\n\ndef test_viewer_mouse_bindings(viewer_factory):\n    """"""Test adding mouse bindings to the viewer\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory(show=True)\n\n    mock_press = Mock()\n    mock_drag = Mock()\n    mock_release = Mock()\n    mock_move = Mock()\n\n    @viewer.mouse_drag_callbacks.append\n    def drag_callback(v, event):\n        assert viewer == v\n\n        # on press\n        mock_press.method()\n\n        yield\n\n        # on move\n        while event.type == \'mouse_move\':\n            mock_drag.method()\n            yield\n\n        # on release\n        mock_release.method()\n\n    @viewer.mouse_move_callbacks.append\n    def move_callback(v, event):\n        assert viewer == v\n        # on move\n        mock_move.method()\n\n    # Simulate press only\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_called_once()\n    mock_press.reset_mock()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_called_once()\n    mock_release.reset_mock()\n    mock_move.method.assert_not_called()\n\n    # Simulate move with no press\n    view.canvas.events.mouse_move(pos=(0, 0), modifiers=())\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_called_once()\n    mock_move.reset_mock()\n\n    # Simulate press, drag, release\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    view.canvas.events.mouse_move(\n        pos=(0, 0), modifiers=(), button=0, press_event=True\n    )\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_called_once()\n    mock_drag.method.assert_called_once()\n    mock_release.method.assert_called_once()\n    mock_move.method.assert_not_called()\n\n\ndef test_layer_mouse_bindings(viewer_factory):\n    """"""Test adding mouse bindings to a layer that is selected\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory(show=True)\n\n    layer = viewer.add_image(np.random.random((10, 20)))\n    layer.selected = True\n\n    mock_press = Mock()\n    mock_drag = Mock()\n    mock_release = Mock()\n    mock_move = Mock()\n\n    @layer.mouse_drag_callbacks.append\n    def drag_callback(l, event):\n        assert layer == l\n        # on press\n        mock_press.method()\n\n        yield\n\n        # on move\n        while event.type == \'mouse_move\':\n            mock_drag.method()\n            yield\n\n        # on release\n        mock_release.method()\n\n    @layer.mouse_move_callbacks.append\n    def move_callback(l, event):\n        assert layer == l\n        # on press\n        mock_move.method()\n\n    # Simulate press only\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_called_once()\n    mock_press.reset_mock()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_called_once()\n    mock_release.reset_mock()\n    mock_move.method.assert_not_called()\n\n    # Simulate move with no press\n    view.canvas.events.mouse_move(pos=(0, 0), modifiers=())\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_called_once()\n    mock_move.reset_mock()\n\n    # Simulate press, drag, release\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    view.canvas.events.mouse_move(\n        pos=(0, 0), modifiers=(), button=0, press_event=True\n    )\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_called_once()\n    mock_drag.method.assert_called_once()\n    mock_release.method.assert_called_once()\n    mock_move.method.assert_not_called()\n\n\ndef test_unselected_layer_mouse_bindings(viewer_factory):\n    """"""Test adding mouse bindings to a layer that is not selected\n    """"""\n    np.random.seed(0)\n    view, viewer = viewer_factory(show=True)\n\n    layer = viewer.add_image(np.random.random((10, 20)))\n    layer.selected = False\n\n    mock_press = Mock()\n    mock_drag = Mock()\n    mock_release = Mock()\n    mock_move = Mock()\n\n    @layer.mouse_drag_callbacks.append\n    def drag_callback(l, event):\n        assert layer == l\n        # on press\n        mock_press.method()\n\n        yield\n\n        # on move\n        while event.type == \'mouse_move\':\n            mock_drag.method()\n            yield\n\n        # on release\n        mock_release.method()\n\n    @layer.mouse_move_callbacks.append\n    def move_callback(l, event):\n        assert layer == l\n        # on press\n        mock_move.method()\n\n    # Simulate press only\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n\n    # Simulate release only\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n\n    # Simulate move with no press\n    view.canvas.events.mouse_move(pos=(0, 0), modifiers=())\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n\n    # Simulate press, drag, release\n    view.canvas.events.mouse_press(pos=(0, 0), modifiers=(), button=0)\n    view.canvas.events.mouse_move(\n        pos=(0, 0), modifiers=(), button=0, press_event=True\n    )\n    view.canvas.events.mouse_release(pos=(0, 0), modifiers=(), button=0)\n    mock_press.method.assert_not_called()\n    mock_drag.method.assert_not_called()\n    mock_release.method.assert_not_called()\n    mock_move.method.assert_not_called()\n'"
napari/_tests/test_napari.py,4,"b'import numpy as np\nimport pytest\n\n\nimport napari\nfrom napari._tests.utils import (\n    check_viewer_functioning,\n    layer_test_data,\n    view_layer_type,\n)\n\n\n@pytest.mark.parametrize(\'layer_type, data, ndim\', layer_test_data)\ndef test_view(qtbot, layer_type, data, ndim):\n    np.random.seed(0)\n    viewer = view_layer_type(layer_type, data)\n    view = viewer.window.qt_viewer\n    check_viewer_functioning(viewer, view, data, ndim)\n    viewer.close()\n\n\ndef test_view_multichannel(qtbot):\n    """"""Test adding image.""""""\n    np.random.seed(0)\n    data = np.random.random((15, 10, 5))\n    viewer = napari.view_image(data, channel_axis=-1)\n    assert len(viewer.layers) == data.shape[-1]\n    for i in range(data.shape[-1]):\n        assert np.all(viewer.layers[i].data == data.take(i, axis=-1))\n    viewer.close()\n'"
napari/_tests/test_numpy_like.py,12,"b'import numpy as np\nimport dask.array as da\nimport zarr\nimport xarray as xr\n\n\ndef test_dask_2D(viewer_factory):\n    """"""Test adding 2D dask image.""""""\n    view, viewer = viewer_factory()\n\n    da.random.seed(0)\n    data = da.random.random((10, 15))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n\n\ndef test_dask_nD(viewer_factory):\n    """"""Test adding nD dask image.""""""\n    view, viewer = viewer_factory()\n\n    da.random.seed(0)\n    data = da.random.random((10, 15, 6, 16))\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == data)\n\n\ndef test_zarr_2D(viewer_factory):\n    """"""Test adding 2D zarr image.""""""\n    view, viewer = viewer_factory()\n\n    data = zarr.zeros((200, 100), chunks=(40, 20))\n    data[53:63, 10:20] = 1\n    # If passing a zarr file directly, must pass contrast_limits\n    viewer.add_image(data, contrast_limits=[0, 1])\n    assert np.all(viewer.layers[0].data == data)\n\n\ndef test_zarr_nD(viewer_factory):\n    """"""Test adding nD zarr image.""""""\n    view, viewer = viewer_factory()\n\n    data = zarr.zeros((200, 100, 50), chunks=(40, 20, 10))\n    data[53:63, 10:20, :] = 1\n    # If passing a zarr file directly, must pass contrast_limits\n    viewer.add_image(data, contrast_limits=[0, 1])\n    assert np.all(viewer.layers[0].data == data)\n\n\ndef test_zarr_dask_2D(viewer_factory):\n    """"""Test adding 2D dask image.""""""\n    view, viewer = viewer_factory()\n\n    data = zarr.zeros((200, 100), chunks=(40, 20))\n    data[53:63, 10:20] = 1\n    zdata = da.from_zarr(data)\n    viewer.add_image(zdata)\n    assert np.all(viewer.layers[0].data == zdata)\n\n\ndef test_zarr_dask_nD(viewer_factory):\n    """"""Test adding nD zarr image.""""""\n    view, viewer = viewer_factory()\n\n    data = zarr.zeros((200, 100, 50), chunks=(40, 20, 10))\n    data[53:63, 10:20, :] = 1\n    zdata = da.from_zarr(data)\n    viewer.add_image(zdata)\n    assert np.all(viewer.layers[0].data == zdata)\n\n\ndef test_xarray_2D(viewer_factory):\n    """"""Test adding 2D xarray image.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    xdata = xr.DataArray(data, dims=[\'y\', \'x\'])\n    viewer.add_image(data)\n    assert np.all(viewer.layers[0].data == xdata)\n\n\ndef test_xarray_nD(viewer_factory):\n    """"""Test adding nD xarray image.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15, 6, 16))\n    xdata = xr.DataArray(data, dims=[\'t\', \'z\', \'y\', \'x\'])\n    viewer.add_image(xdata)\n    assert np.all(viewer.layers[0].data == xdata)\n'"
napari/_tests/test_viewer.py,12,"b'import time\n\nimport numpy as np\nimport pytest\n\nfrom napari import Viewer\nfrom napari._tests.utils import (\n    add_layer_by_type,\n    check_viewer_functioning,\n    check_view_transform_consistency,\n    layer_test_data,\n)\n\n\ndef test_viewer(viewer_factory):\n    """"""Test instantiating viewer.""""""\n    view, viewer = viewer_factory()\n\n    assert viewer.title == \'napari\'\n    assert view.viewer == viewer\n\n    assert len(viewer.layers) == 0\n    assert view.layers.vbox_layout.count() == 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    viewer.dims.ndisplay = 3\n    assert viewer.dims.ndisplay == 3\n    viewer.dims.ndisplay = 2\n    assert viewer.dims.ndisplay == 2\n\n    # Run all class key bindings\n    for func in viewer.class_keymap.values():\n        func(viewer)\n        # the `play` keybinding calls QtDims.play_dim(), which then creates a\n        # new QThread. we must then run the keybinding a second time, which\n        # will call QtDims.stop(), otherwise the thread will be killed at the\n        # end of the test without cleanup, causing a segmentation fault.\n        # (though the tests still pass)\n        if func.__name__ == \'play\':\n            func(viewer)\n\n    # the test for fullscreen that used to be here has been moved to the\n    # Window.close() method.\n\n\n@pytest.mark.first  # provided by pytest-ordering\ndef test_no_qt_loop():\n    """"""Test informative error raised when no Qt event loop exists.\n\n    Logically, this test should go at the top of the file. Howveer, that\n    resulted in tests passing when only this file was run, but failing when\n    other tests involving Qt-bot were run before this file. Putting this test\n    second provides a sanity check that pytest-ordering is correctly doing its\n    magic.\n    """"""\n    with pytest.raises(RuntimeError):\n        _ = Viewer()\n\n\n@pytest.mark.parametrize(\'layer_class, data, ndim\', layer_test_data)\n@pytest.mark.parametrize(\'visible\', [True, False])\ndef test_add_layer(viewer_factory, layer_class, data, ndim, visible):\n    view, viewer = viewer_factory()\n    layer = add_layer_by_type(viewer, layer_class, data, visible=visible)\n    check_viewer_functioning(viewer, view, data, ndim)\n\n    # Run all class key bindings\n    for func in layer.class_keymap.values():\n        func(layer)\n\n\ndef test_screenshot(viewer_factory):\n    """"""Test taking a screenshot.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    # Add image\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n\n    # Add labels\n    data = np.random.randint(20, size=(10, 15))\n    viewer.add_labels(data)\n\n    # Add points\n    data = 20 * np.random.random((10, 2))\n    viewer.add_points(data)\n\n    # Add vectors\n    data = 20 * np.random.random((10, 2, 2))\n    viewer.add_vectors(data)\n\n    # Add shapes\n    data = 20 * np.random.random((10, 4, 2))\n    viewer.add_shapes(data)\n\n    # Take screenshot of the image canvas only\n    screenshot = viewer.screenshot(canvas_only=True)\n    assert screenshot.ndim == 3\n\n    # Take screenshot with the viewer included\n    screenshot = viewer.screenshot(canvas_only=False)\n    assert screenshot.ndim == 3\n\n\ndef test_update(viewer_factory):\n    data = np.random.random((512, 512))\n    view, viewer = viewer_factory()\n    layer = viewer.add_image(data)\n\n    def layer_update(*, update_period, num_updates):\n        # number of times to update\n\n        for k in range(num_updates):\n            time.sleep(update_period)\n\n            dat = np.random.random((512, 512))\n            layer.data = dat\n\n            assert layer.data.all() == dat.all()\n            # if you\'re looking at this as an example,\n            # it would be best to put a yield statement here...\n            # but we\'re testing how it handles not having a yield statement\n\n    # NOTE: The closure approach used here has the potential to throw an error:\n    # ""RuntimeError: Internal C++ object () already deleted.""\n    # if an enclosed object (like the layer here) is deleted in the main thread\n    # and then subsequently called in the other thread.\n    # Previously this error would have been invisible (raised only in the other\n    # thread). But because this can make debugging hard, the new\n    # `create_worker` approach reraises thread errors in the main thread by\n    # default.  To make this test pass, we now need to explicitly use\n    # `_ignore_errors=True`, because the `layer.data = dat` line will throw an\n    # error when called after the main thread is closed.\n    with pytest.warns(DeprecationWarning):\n        viewer.update(\n            layer_update,\n            update_period=0.01,\n            num_updates=100,\n            _ignore_errors=True,\n        )\n\n\ndef test_changing_theme(viewer_factory):\n    """"""Test instantiating viewer.""""""\n    view, viewer = viewer_factory()\n    assert viewer.palette[\'folder\'] == \'dark\'\n\n    viewer.theme = \'light\'\n    assert viewer.palette[\'folder\'] == \'light\'\n\n    with pytest.raises(ValueError):\n        viewer.theme = \'nonexistent_theme\'\n\n\n@pytest.mark.parametrize(\'layer_class, data, ndim\', layer_test_data)\ndef test_roll_traspose_update(viewer_factory, layer_class, data, ndim):\n    """"""Check that transpose and roll preserve correct transform sequence.""""""\n\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n\n    layer = add_layer_by_type(viewer, layer_class, data)\n\n    # Set translations and scalings (match type of visual layer storing):\n    transf_dict = {\n        \'translate\': np.random.randint(0, 10, ndim).astype(np.float32),\n        \'scale\': np.random.rand(ndim).astype(np.float32),\n    }\n    for k, val in transf_dict.items():\n        setattr(layer, k, val)\n\n    # Check consistency:\n    check_view_transform_consistency(layer, viewer, transf_dict)\n\n    # Roll dims and check again:\n    viewer.dims._roll()\n    check_view_transform_consistency(layer, viewer, transf_dict)\n\n    # Transpose and check again:\n    viewer.dims._transpose()\n    check_view_transform_consistency(layer, viewer, transf_dict)\n'"
napari/_tests/test_viewer_layer_parity.py,0,"b'""""""\nEnsure that layers and their convenience methods on the viewer\nhave the same signatures and docstrings.\n""""""\n\nimport inspect\nimport re\n\nimport pytest\nfrom numpydoc.docscrape import FunctionDoc, ClassDoc\n\nfrom napari import layers as module, Viewer\nfrom napari.utils.misc import camel_to_snake, callsignature\n\n\nlayers = []\n\nfor name in dir(module):\n    obj = getattr(module, name)\n\n    if obj is module.Layer or not inspect.isclass(obj):\n        continue\n\n    if issubclass(obj, module.Layer):\n        layers.append(obj)\n\n\n@pytest.mark.parametrize(\'layer\', layers, ids=lambda layer: layer.__name__)\ndef test_docstring(layer):\n    name = layer.__name__\n\n    method_name = f\'add_{camel_to_snake(name)}\'\n    method = getattr(Viewer, method_name)\n\n    method_doc = FunctionDoc(method)\n    layer_doc = ClassDoc(layer)\n\n    # check summary section\n    method_summary = \' \'.join(method_doc[\'Summary\'])  # join multi-line summary\n\n    summary_format = \'Add an? .+? layer to the layers list.\'\n\n    assert re.match(\n        summary_format, method_summary\n    ), f""improper \'Summary\' section of \'{method_name}\'""\n\n    # check parameters section\n    method_params = method_doc[\'Parameters\']\n    layer_params = layer_doc[\'Parameters\']\n\n    # Remove path parameter from viewer method if it exists\n    method_params = [m for m in method_params if m.name != \'path\']\n\n    if name == \'Image\':\n        # For Image just test arguments that are in layer are in method\n        named_method_params = [m.name for m in method_params]\n        for layer_param in layer_params:\n            l_name, l_type, l_description = layer_param\n            assert l_name in named_method_params\n    else:\n        try:\n            assert len(method_params) == len(layer_params)\n            for method_param, layer_param in zip(method_params, layer_params):\n                m_name, m_type, m_description = method_param\n                l_name, l_type, l_description = layer_param\n\n                # descriptions are treated as lists where each line is an\n                # element\n                m_description = \' \'.join(m_description)\n                l_description = \' \'.join(l_description)\n\n                assert m_name == l_name, \'different parameter names or order\'\n                assert (\n                    m_type == l_type\n                ), f""type mismatch of parameter \'{m_name}\'""\n                assert (\n                    m_description == l_description\n                ), f""description mismatch of parameter \'{m_name}\'""\n        except AssertionError as e:\n            raise AssertionError(\n                f""docstrings don\'t match for class {name}""\n            ) from e\n\n    # check returns section\n    (method_returns,) = method_doc[\n        \'Returns\'\n    ]  # only one thing should be returned\n    description = \' \'.join(method_returns[-1])  # join multi-line description\n    method_returns = *method_returns[:-1], description\n\n    if name == \'Image\':\n        assert method_returns == (\n            \'layer\',\n            f\':class:`napari.layers.{name}` or list\',\n            f\'The newly-created {name.lower()} layer or list of {name.lower()} layers.\',  # noqa: E501\n        ), f""improper \'Returns\' section of \'{method_name}\'""\n    else:\n        assert method_returns == (\n            \'layer\',\n            f\':class:`napari.layers.{name}`\',\n            f\'The newly-created {name.lower()} layer.\',\n        ), f""improper \'Returns\' section of \'{method_name}\'""\n\n\n@pytest.mark.parametrize(\'layer\', layers, ids=lambda layer: layer.__name__)\ndef test_signature(layer):\n    name = layer.__name__\n\n    method = getattr(Viewer, f\'add_{camel_to_snake(name)}\')\n\n    class_parameters = dict(inspect.signature(layer.__init__).parameters)\n    method_parameters = dict(inspect.signature(method).parameters)\n\n    fail_msg = f""signatures don\'t match for class {name}""\n    if name == \'Image\':\n        # If Image just test that class params appear in method\n        for class_param in class_parameters.keys():\n            assert class_param in method_parameters.keys(), fail_msg\n    else:\n        assert class_parameters == method_parameters, fail_msg\n\n    code = inspect.getsource(method)\n\n    # Below, we test that somewhere in the source code of the method, a call to\n    # the corresponding Layer.__init__ method is made that has all of the same\n    # parameters.  add_image has a special implementation, and therefore\n    # requires a modified test.\n    if name == \'Image\':\n        # it becomes very cumbersome to have to type out all of the\n        # parameters in add_image for both single images, and all the iterables\n        # when channel_axis is supplied, so the approach was changed in\n        # https://github.com/napari/napari/pull/1092\n        # this makes sure we\'re still passing all the proper arguments\n        args = re.search(r\'kwargs = \\{(.+?)\\}\', code, flags=re.S)\n        args = \' \'.join(args.group(1).split())\n        # convert \'arg\': arg -> arg=arg\n        args = \'data, \' + re.sub(r""[\'\\""]([^\'\\""]+)[\'\\""]:\\s?"", \'\\\\1=\', args)\n    else:\n        args = re.search(rf\'layer = layers\\.{name}\\((.+?)\\)\', code, flags=re.S)\n        # get the arguments & normalize whitepsace\n        args = \' \'.join(args.group(1).split())\n\n    if args.endswith(\',\'):  # remove tailing comma if present\n        args = args[:-1]\n\n    autogen = callsignature(layer)\n    autogen = autogen.replace(\n        # remove \'self\' parameter\n        parameters=[p for k, p in autogen.parameters.items() if k != \'self\']\n    )\n    autogen = str(autogen)[1:-1]  # remove parentheses\n\n    try:\n        assert args == autogen\n    except AssertionError as e:\n        msg = (\n            \'arguments improperly passed from convenience \'\n            f\'method to layer {name}\'\n        )\n        raise SyntaxError(msg) from e\n'"
napari/_tests/utils.py,26,"b'import napari\nimport numpy as np\nfrom napari import Viewer\nfrom napari.layers import Image, Labels, Points, Shapes, Vectors, Surface\n\n""""""\nUsed as pytest params for testing layer add and view functionality (Layer class, data, ndim)\n""""""\nlayer_test_data = [\n    (Image, np.random.random((10, 15)), 2),\n    (Image, np.random.random((10, 15, 20)), 3),\n    (Image, [np.random.random(s) for s in [(40, 20), (20, 10), (10, 5)]], 2),\n    (Labels, np.random.randint(20, size=(10, 15)), 2),\n    (Labels, np.random.randint(20, size=(6, 10, 15)), 3),\n    (Points, 20 * np.random.random((10, 2)), 2),\n    (Points, 20 * np.random.random((10, 3)), 3),\n    (Vectors, 20 * np.random.random((10, 2, 2)), 2),\n    (Shapes, 20 * np.random.random((10, 4, 2)), 2),\n    (Shapes, 20 * np.random.random((10, 4, 2)), 2),\n    (\n        Surface,\n        (\n            np.random.random((10, 3)),\n            np.random.randint(10, size=(6, 3)),\n            np.random.random(10),\n        ),\n        3,\n    ),\n]\n\n\nclasses = [Labels, Points, Vectors, Shapes, Surface, Image]\nnames = [cls.__name__.lower() for cls in classes]\nlayer2addmethod = {\n    cls: getattr(Viewer, \'add_\' + name) for cls, name in zip(classes, names)\n}\n\nlayer2viewmethod = {\n    cls: getattr(napari, \'view_\' + name) for cls, name in zip(classes, names)\n}\n\n# examples of valid tuples that might be passed to viewer._add_layer_from_data\ngood_layer_data = [\n    (np.random.random((10, 10)),),\n    (np.random.random((10, 10, 3)), {\'rgb\': True}),\n    (np.random.randint(20, size=(10, 15)), {\'seed\': 0.3}, \'labels\'),\n    (np.random.random((10, 2)) * 20, {\'face_color\': \'blue\'}, \'points\'),\n    (np.random.random((10, 2, 2)) * 20, {}, \'vectors\'),\n    (np.random.random((10, 4, 2)) * 20, {\'opacity\': 1}, \'shapes\'),\n    (\n        (\n            np.random.random((10, 3)),\n            np.random.randint(10, size=(6, 3)),\n            np.random.random(10),\n        ),\n        {\'name\': \'some surface\'},\n        \'surface\',\n    ),\n]\n\n\ndef add_layer_by_type(viewer, layer_type, data, visible=True):\n    """"""\n    Convenience method that maps a LayerType to its add_layer method.\n\n    Parameters\n    ----------\n    layer_type : LayerTypes\n        Layer type to add\n    data :\n        The layer data to view\n    """"""\n    return layer2addmethod[layer_type](viewer, data, visible=visible)\n\n\ndef view_layer_type(layer_type, data):\n    """"""\n    Convenience method that maps a LayerType to it\'s view method.\n\n    Parameters\n    ----------\n    layer_type : LayerTypes\n        Layer type to view\n    data :\n        The layer data to view\n    """"""\n    return layer2viewmethod[layer_type](data)\n\n\ndef check_viewer_functioning(viewer, view=None, data=None, ndim=2):\n    viewer.dims.ndisplay = 2\n    assert np.all(viewer.layers[0].data == data)\n    assert len(viewer.layers) == 1\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == ndim\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == ndim - 2\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    viewer.dims.ndisplay = 3\n    assert viewer.dims.ndisplay == 3\n\n    # Flip dims order displayed\n    dims_order = list(range(ndim))\n    viewer.dims.order = dims_order\n    assert viewer.dims.order == dims_order\n\n    # Flip dims order including non-displayed\n    dims_order[0], dims_order[-1] = dims_order[-1], dims_order[0]\n    viewer.dims.order = dims_order\n    assert viewer.dims.order == dims_order\n\n    viewer.dims.ndisplay = 2\n    assert viewer.dims.ndisplay == 2\n\n\ndef check_view_transform_consistency(layer, viewer, transf_dict):\n    """"""Check layer transforms have been applied to the view.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        Layer model.\n    viewer : napari.Viewer\n        Viewer, including Qt elements\n    transf_dict : dict\n        Dictionary of transform properties with keys referring to the name of\n        the transform property (i.e. `scale`, `translate`) and the value\n        corresponding to the array of property values\n    """"""\n    # Get an handle on visual layer:\n    vis_lyr = viewer.window.qt_viewer.layer_to_visual[layer]\n\n    # Visual layer attributes should match expected from viewer dims:\n    for transf_name, transf in transf_dict.items():\n        disp_dims = viewer.dims.displayed  # dimensions displayed in 2D\n        # values of visual layer\n        vis_vals = getattr(vis_lyr, transf_name)[1::-1]\n\n        # The transform of the visual includes both values from the\n        # data2world transform and the tile2data transform and so any\n        # any additional scaling / translation from tile2data transform\n        # must be taken into account\n        transform = layer._transforms[\'tile2data\'].set_slice(disp_dims)\n        tile_transf = getattr(transform, transf_name)\n        if transf_name == \'scale\':\n            # expected scale values\n            correct_vals = np.multiply(transf[disp_dims], tile_transf)\n        else:\n            # expected translate values\n            correct_vals = np.add(transf[disp_dims], tile_transf)\n        assert (vis_vals == correct_vals).all()\n'"
napari/_vispy/__init__.py,0,b'from .utils import create_vispy_visual\n'
napari/_vispy/markers.py,0,"b""from vispy.scene.visuals import Markers as BaseMarkers\n\n\n# Custom markers class is needed for entering 3D rendering mode when a points\n# layer is invisble and the self._data property is None\nclass Markers(BaseMarkers):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def _compute_bounds(self, axis, view):\n        # This if statement needs to be added to vispy master\n        if self._data is None:\n            return None\n        pos = self._data['a_position']\n        if pos is None:\n            return None\n        if pos.shape[1] > axis:\n            return (pos[:, axis].min(), pos[:, axis].max())\n        else:\n            return (0, 0)\n"""
napari/_vispy/utils.py,0,"b'from ..layers import Image, Labels, Points, Shapes, Surface, Vectors\nfrom .vispy_image_layer import VispyImageLayer\nfrom .vispy_points_layer import VispyPointsLayer\nfrom .vispy_shapes_layer import VispyShapesLayer\nfrom .vispy_vectors_layer import VispyVectorsLayer\nfrom .vispy_surface_layer import VispySurfaceLayer\n\n\nlayer_to_visual = {\n    Image: VispyImageLayer,\n    Labels: VispyImageLayer,\n    Points: VispyPointsLayer,\n    Shapes: VispyShapesLayer,\n    Surface: VispySurfaceLayer,\n    Vectors: VispyVectorsLayer,\n}\n\n\ndef create_vispy_visual(layer):\n    """"""Create vispy visual for a layer based on its layer type.\n\n    Parameters\n    ----------\n    layer : napari.layers._base_layer.Layer\n        Layer that needs its propetry widget created.\n\n    Returns\n    ----------\n    visual : vispy.scene.visuals.VisualNode\n        Vispy visual node\n    """"""\n    visual = layer_to_visual[type(layer)](layer)\n\n    return visual\n'"
napari/_vispy/vispy_base_layer.py,9,"b'from abc import ABC, abstractmethod\nfrom functools import lru_cache\nimport numpy as np\nfrom vispy.app import Canvas\nfrom vispy.gloo import gl\nfrom vispy.visuals.transforms import STTransform\n\n\nclass VispyBaseLayer(ABC):\n    """"""Base object for individual layer views\n\n    Meant to be subclassed.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        Layer model.\n    node : vispy.scene.VisualNode\n        Central node with which to interact with the visual.\n\n    Attributes\n    ----------\n    layer : napari.layers.Layer\n        Layer model.\n    node : vispy.scene.VisualNode\n        Central node with which to interact with the visual.\n    scale : sequence of float\n        Scale factors for the layer visual in the scenecanvas.\n    translate : sequence of float\n        Translation values for the layer visual in the scenecanvas.\n    scale_factor : float\n        Conversion factor from canvas coordinates to image coordinates, which\n        depends on the current zoom level.\n    MAX_TEXTURE_SIZE_2D : int\n        Max texture size allowed by the vispy canvas during 2D rendering.\n    MAX_TEXTURE_SIZE_3D : int\n        Max texture size allowed by the vispy canvas during 2D rendering.\n\n    Extended Summary\n    ----------\n    _master_transform : vispy.visuals.transforms.STTransform\n        Transform positioning the layer visual inside the scenecanvas.\n    """"""\n\n    def __init__(self, layer, node):\n        super().__init__()\n\n        self.layer = layer\n        self.node = node\n\n        MAX_TEXTURE_SIZE_2D, MAX_TEXTURE_SIZE_3D = get_max_texture_sizes()\n        self.MAX_TEXTURE_SIZE_2D = MAX_TEXTURE_SIZE_2D\n        self.MAX_TEXTURE_SIZE_3D = MAX_TEXTURE_SIZE_3D\n\n        self._position = (0,) * self.layer.dims.ndisplay\n\n        self.layer.events.refresh.connect(lambda e: self.node.update())\n        self.layer.events.set_data.connect(self._on_data_change)\n        self.layer.events.visible.connect(self._on_visible_change)\n        self.layer.events.opacity.connect(self._on_opacity_change)\n        self.layer.events.blending.connect(self._on_blending_change)\n        self.layer.events.scale.connect(self._on_scale_change)\n        self.layer.events.translate.connect(self._on_translate_change)\n\n    @property\n    def _master_transform(self):\n        """"""vispy.visuals.transforms.STTransform:\n        Central node\'s firstmost transform.\n        """"""\n        # whenever a new parent is set, the transform is reset\n        # to a NullTransform so we reset it here\n        if not isinstance(self.node.transform, STTransform):\n            self.node.transform = STTransform()\n\n        return self.node.transform\n\n    @property\n    def order(self):\n        """"""int: Order in which the visual is drawn in the scenegraph.\n\n        Lower values are closer to the viewer.\n        """"""\n        return self.node.order\n\n    @order.setter\n    def order(self, order):\n        self.node.order = order\n\n    @property\n    def scale(self):\n        """"""sequence of float: Scale factors.""""""\n        return self._master_transform.scale\n\n    @scale.setter\n    def scale(self, scale):\n        # Avoid useless update if nothing changed in the displayed dims\n        # Note that the master_transform scale is always a 4-vector so pad\n        padded_scale = np.pad(\n            scale, ((0, 4 - len(scale))), constant_values=1, mode=\'constant\'\n        )\n        if self.scale is not None and np.all(self.scale == padded_scale):\n            return\n        self._master_transform.scale = padded_scale\n\n    @property\n    def translate(self):\n        """"""sequence of float: Translation values.""""""\n        return self._master_transform.translate\n\n    @translate.setter\n    def translate(self, translate):\n        # Avoid useless update if nothing changed in the displayed dims\n        # Note that the master_transform translate is always a 4-vector so pad\n        padded_translate = np.pad(\n            translate,\n            ((0, 4 - len(translate))),\n            constant_values=1,\n            mode=\'constant\',\n        )\n        if self.translate is not None and np.all(\n            self.translate == padded_translate\n        ):\n            return\n        self._master_transform.translate = padded_translate\n\n    @property\n    def scale_factor(self):\n        """"""float: Conversion factor from canvas pixels to data coordinates.\n        """"""\n        if self.node.canvas is not None:\n            transform = self.node.canvas.scene.node_transform(self.node)\n            return transform.map([1, 1])[0] - transform.map([0, 0])[0]\n        else:\n            return 1\n\n    @abstractmethod\n    def _on_data_change(self, event=None):\n        raise NotImplementedError()\n\n    def _on_visible_change(self, event=None):\n        self.node.visible = self.layer.visible\n\n    def _on_opacity_change(self, event=None):\n        self.node.opacity = self.layer.opacity\n\n    def _on_blending_change(self, event=None):\n        self.node.set_gl_state(self.layer.blending)\n        self.node.update()\n\n    def _on_scale_change(self, event=None):\n        scale = self.layer._transforms.simplified.set_slice(\n            self.layer.dims.displayed\n        ).scale\n        # convert NumPy axis ordering to VisPy axis ordering\n        self.scale = scale[::-1]\n        self.layer.corner_pixels = self.coordinates_of_canvas_corners()\n        self.layer.position = self._transform_position(self._position)\n\n    def _on_translate_change(self, event=None):\n        translate = self.layer._transforms.simplified.set_slice(\n            self.layer.dims.displayed\n        ).translate\n        # convert NumPy axis ordering to VisPy axis ordering\n        self.translate = translate[::-1]\n        self.layer.corner_pixels = self.coordinates_of_canvas_corners()\n        self.layer.position = self._transform_position(self._position)\n\n    def _transform_position(self, position):\n        """"""Transform cursor position from canvas space (x, y) into image space.\n\n        Parameters\n        -------\n        position : 2-tuple\n            Cursor position in canvase (x, y).\n\n        Returns\n        -------\n        coords : tuple\n            Coordinates of cursor in image space for displayed dimensions only\n        """"""\n        nd = self.layer.dims.ndisplay\n        if self.node.canvas is not None:\n            transform = self.node.canvas.scene.node_transform(self.node)\n            # Map and offset position so that pixel center is at 0\n            mapped_position = transform.map(list(position))[:nd] - 0.5\n            return tuple(mapped_position[::-1])\n        else:\n            return (0,) * nd\n\n    def _reset_base(self):\n        self._on_visible_change()\n        self._on_opacity_change()\n        self._on_blending_change()\n        self._on_scale_change()\n        self._on_translate_change()\n\n    def coordinates_of_canvas_corners(self):\n        """"""Find location of the corners of canvas in data coordinates.\n\n        This method should only be used during 2D image viewing. The result\n        depends on the current pan and zoom position.\n\n        Returns\n        ----------\n        corner_pixels : array\n            Coordinates of top left and bottom right canvas pixel in the data.\n        """"""\n        nd = self.layer.dims.ndisplay\n        # Find image coordinate of top left canvas pixel\n        if self.node.canvas is not None:\n            offset = self.translate[:nd] / self.scale[:nd]\n            tl_raw = np.floor(self._transform_position([0, 0]) + offset[::-1])\n            br_raw = np.ceil(\n                self._transform_position(self.node.canvas.size) + offset[::-1]\n            )\n        else:\n            tl_raw = [0] * nd\n            br_raw = [1] * nd\n\n        top_left = np.zeros(self.layer.ndim)\n        bottom_right = np.zeros(self.layer.ndim)\n        for d, tl, br in zip(self.layer.dims.displayed, tl_raw, br_raw):\n            top_left[d] = tl\n            bottom_right[d] = br\n\n        return np.array([top_left, bottom_right]).astype(int)\n\n    def on_draw(self, event):\n        """"""Called whenever the canvas is drawn.\n\n        This is triggered from vispy whenever new data is sent to the canvas or\n        the camera is moved and is connected in the `QtViewer`.\n        """"""\n        self.layer.scale_factor = self.scale_factor\n        old_corner_pixels = self.layer.corner_pixels\n        self.layer.corner_pixels = self.coordinates_of_canvas_corners()\n\n        # For 2D multiscale data determine if new data has been requested\n        if (\n            self.layer.multiscale\n            and self.layer.dims.ndisplay == 2\n            and self.node.canvas is not None\n        ):\n            self.layer._update_multiscale(\n                corner_pixels=old_corner_pixels,\n                shape_threshold=self.node.canvas.size,\n            )\n\n\n@lru_cache()\ndef get_max_texture_sizes():\n    """"""Get maximum texture sizes for 2D and 3D rendering.\n\n    Returns\n    -------\n    MAX_TEXTURE_SIZE_2D : int or None\n        Max texture size allowed by the vispy canvas during 2D rendering.\n    MAX_TEXTURE_SIZE_3D : int or None\n        Max texture size allowed by the vispy canvas during 2D rendering.\n    """"""\n    # A canvas must be created to access gl values\n    c = Canvas(show=False)\n    try:\n        MAX_TEXTURE_SIZE_2D = gl.glGetParameter(gl.GL_MAX_TEXTURE_SIZE)\n    finally:\n        c.close()\n    if MAX_TEXTURE_SIZE_2D == ():\n        MAX_TEXTURE_SIZE_2D = None\n    # vispy doesn\'t expose GL_MAX_3D_TEXTURE_SIZE so hard coding\n    # MAX_TEXTURE_SIZE_3D = gl.glGetParameter(gl.GL_MAX_3D_TEXTURE_SIZE)\n    # if MAX_TEXTURE_SIZE_3D == ():\n    #    MAX_TEXTURE_SIZE_3D = None\n    MAX_TEXTURE_SIZE_3D = 2048\n\n    return MAX_TEXTURE_SIZE_2D, MAX_TEXTURE_SIZE_3D\n'"
napari/_vispy/vispy_image_layer.py,14,"b'import warnings\nfrom vispy.scene.visuals import Image as ImageNode\nfrom .volume import Volume as VolumeNode\nfrom vispy.color import Colormap\nimport numpy as np\nfrom .vispy_base_layer import VispyBaseLayer\nfrom ..layers.image._image_constants import Rendering\n\n\ntexture_dtypes = [\n    np.dtype(np.int8),\n    np.dtype(np.uint8),\n    np.dtype(np.int16),\n    np.dtype(np.uint16),\n    np.dtype(np.float32),\n]\n\n\nclass VispyImageLayer(VispyBaseLayer):\n    def __init__(self, layer):\n        node = ImageNode(None, method=\'auto\')\n        super().__init__(layer, node)\n\n        self.layer.events.rendering.connect(self._on_rendering_change)\n        self.layer.events.interpolation.connect(self._on_interpolation_change)\n        self.layer.events.colormap.connect(self._on_colormap_change)\n        self.layer.events.contrast_limits.connect(\n            self._on_contrast_limits_change\n        )\n        self.layer.events.gamma.connect(self._on_gamma_change)\n        self.layer.events.iso_threshold.connect(self._on_threshold_change)\n        self.layer.events.attenuation.connect(self._on_threshold_change)\n\n        self._on_display_change()\n        self._on_data_change()\n\n    def _on_display_change(self, data=None):\n        parent = self.node.parent\n        self.node.parent = None\n\n        if self.layer.dims.ndisplay == 2:\n            self.node = ImageNode(data, method=\'auto\')\n        else:\n            if data is None:\n                data = np.zeros((1, 1, 1))\n            self.node = VolumeNode(data, clim=self.layer.contrast_limits)\n\n        self.node.parent = parent\n        self.reset()\n\n    def _on_data_change(self, event=None):\n        data = self.layer._data_view\n        dtype = np.dtype(data.dtype)\n        if dtype not in texture_dtypes:\n            try:\n                dtype = dict(\n                    i=np.int16, f=np.float32, u=np.uint16, b=np.uint8\n                )[dtype.kind]\n            except KeyError:  # not an int or float\n                raise TypeError(\n                    f\'type {dtype} not allowed for texture; must be one of {set(texture_dtypes)}\'  # noqa: E501\n                )\n            data = data.astype(dtype)\n\n        if self.layer.dims.ndisplay == 3 and self.layer.dims.ndim == 2:\n            data = np.expand_dims(data, axis=0)\n\n        # Check if data exceeds MAX_TEXTURE_SIZE and downsample\n        if (\n            self.MAX_TEXTURE_SIZE_2D is not None\n            and self.layer.dims.ndisplay == 2\n        ):\n            data = self.downsample_texture(data, self.MAX_TEXTURE_SIZE_2D)\n        elif (\n            self.MAX_TEXTURE_SIZE_3D is not None\n            and self.layer.dims.ndisplay == 3\n        ):\n            data = self.downsample_texture(data, self.MAX_TEXTURE_SIZE_3D)\n\n        # Check if ndisplay has changed current node type needs updating\n        if (\n            self.layer.dims.ndisplay == 3\n            and not isinstance(self.node, VolumeNode)\n        ) or (\n            self.layer.dims.ndisplay == 2\n            and not isinstance(self.node, ImageNode)\n        ):\n            self._on_display_change(data)\n        else:\n            if self.layer.dims.ndisplay == 2:\n                self.node._need_colortransform_update = True\n                self.node.set_data(data)\n            else:\n                self.node.set_data(data, clim=self.layer.contrast_limits)\n\n        # Call to update order of translation values with new dims:\n        self._on_scale_change()\n        self._on_translate_change()\n        self.node.update()\n\n    def _on_interpolation_change(self, event=None):\n        self.node.interpolation = self.layer.interpolation\n\n    def _on_rendering_change(self, event=None):\n        if self.layer.dims.ndisplay == 3:\n            self.node.method = self.layer.rendering\n            self._on_threshold_change()\n\n    def _on_colormap_change(self, event=None):\n        cmap = self.layer.colormap[1]\n        if self.layer.gamma != 1:\n            # when gamma!=1, we instantiate a new colormap\n            # with 256 control points from 0-1\n            cmap = Colormap(cmap[np.linspace(0, 1, 256) ** self.layer.gamma])\n\n        # Below is fixed in #1712\n        if not self.layer.dims.ndisplay == 2:\n            self.node.view_program[\'texture2D_LUT\'] = (\n                cmap.texture_lut() if (hasattr(cmap, \'texture_lut\')) else None\n            )\n        self.node.cmap = cmap\n\n    def _on_contrast_limits_change(self, event=None):\n        if self.layer.dims.ndisplay == 2:\n            self.node.clim = self.layer.contrast_limits\n        else:\n            self._on_data_change()\n\n    def _on_gamma_change(self, event=None):\n        self._on_colormap_change()\n\n    def _on_threshold_change(self, event=None):\n        if self.layer.dims.ndisplay == 2:\n            return\n        rendering = Rendering(self.layer.rendering)\n        if rendering == Rendering.ISO:\n            self.node.threshold = float(self.layer.iso_threshold)\n        elif rendering == Rendering.ATTENUATED_MIP:\n            self.node.threshold = float(self.layer.attenuation)\n\n    def reset(self, event=None):\n        self._reset_base()\n        self._on_interpolation_change()\n        self._on_colormap_change()\n        self._on_rendering_change()\n        if self.layer.dims.ndisplay == 2:\n            self._on_contrast_limits_change()\n\n    def downsample_texture(self, data, MAX_TEXTURE_SIZE):\n        """"""Downsample data based on maximum allowed texture size.\n\n        Parameters\n        ----------\n        data : array\n            Data to be downsampled if needed.\n        MAX_TEXTURE_SIZE : int\n            Maximum allowed texture size.\n\n        Returns\n        -------\n        data : array\n            Data that now fits inside texture.\n        """"""\n        if np.any(np.greater(data.shape, MAX_TEXTURE_SIZE)):\n            if self.layer.multiscale:\n                raise ValueError(\n                    f""Shape of individual tiles in multiscale {data.shape} ""\n                    f""cannot exceed GL_MAX_TEXTURE_SIZE ""\n                    f""{MAX_TEXTURE_SIZE}. Rendering is currently in ""\n                    f""{self.layer.dims.ndisplay}D mode.""\n                )\n            warnings.warn(\n                f""data shape {data.shape} exceeds GL_MAX_TEXTURE_SIZE ""\n                f""{MAX_TEXTURE_SIZE} in at least one axis and ""\n                f""will be downsampled. Rendering is currently in ""\n                f""{self.layer.dims.ndisplay}D mode.""\n            )\n            downsample = np.ceil(\n                np.divide(data.shape, MAX_TEXTURE_SIZE)\n            ).astype(int)\n            scale = np.ones(self.layer.ndim)\n            for i, d in enumerate(self.layer.dims.displayed):\n                scale[d] = downsample[i]\n            self.layer._transforms[\'tile2data\'].scale = scale\n            self._on_scale_change()\n            slices = tuple(slice(None, None, ds) for ds in downsample)\n            data = data[slices]\n        return data\n'"
napari/_vispy/vispy_points_layer.py,6,"b""import numpy as np\nfrom vispy.scene.visuals import Line, Compound\nfrom .markers import Markers\nfrom vispy.visuals.transforms import ChainTransform\n\nfrom .vispy_base_layer import VispyBaseLayer\nfrom ..utils.colormaps.standardize_color import transform_color\n\n\nclass VispyPointsLayer(VispyBaseLayer):\n    _highlight_color = (0, 0.6, 1)\n    _highlight_width = 2\n\n    def __init__(self, layer):\n        # Create a compound visual with the following four subvisuals:\n        # Lines: The lines of the interaction box used for highlights.\n        # Markers: The the outlines for each point used for highlights.\n        # Markers: The actual markers of each point.\n        node = Compound([Markers(), Markers(), Line()])\n\n        super().__init__(layer, node)\n\n        self.layer.events.symbol.connect(self._on_data_change)\n        self.layer.events.edge_width.connect(self._on_data_change)\n        self.layer.events.edge_color.connect(self._on_data_change)\n        self.layer.events.face_color.connect(self._on_data_change)\n        self.layer.events.highlight.connect(self._on_highlight_change)\n        self._on_display_change()\n        self._on_data_change()\n\n    def _on_display_change(self):\n        parent = self.node.parent\n        self.node.transforms = ChainTransform()\n        self.node.parent = None\n\n        if self.layer.dims.ndisplay == 2:\n            self.node = Compound([Markers(), Markers(), Line()])\n        else:\n            self.node = Compound([Markers(), Markers()])\n        self.node.parent = parent\n        self._reset_base()\n\n    def _on_data_change(self, event=None):\n        # Check if ndisplay has changed current node type needs updating\n        if (\n            self.layer.dims.ndisplay == 3 and len(self.node._subvisuals) != 2\n        ) or (\n            self.layer.dims.ndisplay == 2 and len(self.node._subvisuals) != 3\n        ):\n            self._on_display_change()\n            self._on_highlight_change()\n\n        if len(self.layer._indices_view) > 0:\n            edge_color = self.layer._view_edge_color\n            face_color = self.layer._view_face_color\n        else:\n            edge_color = np.array([[0.0, 0.0, 0.0, 1.0]], dtype=np.float32)\n            face_color = np.array([[1.0, 1.0, 1.0, 1.0]], dtype=np.float32)\n\n        # Set vispy data, noting that the order of the points needs to be\n        # reversed to make the most recently added point appear on top\n        # and the rows / columns need to be switch for vispys x / y ordering\n        if len(self.layer._indices_view) == 0:\n            data = np.zeros((1, self.layer.dims.ndisplay))\n            size = [0]\n        else:\n            data = self.layer._view_data\n            size = self.layer._view_size\n\n        set_data = self.node._subvisuals[0].set_data\n\n        set_data(\n            data[:, ::-1] + 0.5,\n            size=size,\n            edge_width=self.layer.edge_width,\n            symbol=self.layer.symbol,\n            edge_color=edge_color,\n            face_color=face_color,\n            scaling=True,\n        )\n        self.node.update()\n        # Call to update order of translation values with new dims:\n        self._on_scale_change()\n        self._on_translate_change()\n\n    def _on_highlight_change(self, event=None):\n        if len(self.layer._highlight_index) > 0:\n            # Color the hovered or selected points\n            data = self.layer._view_data[self.layer._highlight_index]\n            if data.ndim == 1:\n                data = np.expand_dims(data, axis=0)\n            size = self.layer._view_size[self.layer._highlight_index]\n        else:\n            data = np.zeros((1, self.layer.dims.ndisplay))\n            size = 0\n\n        self.node._subvisuals[1].set_data(\n            data[:, ::-1] + 0.5,\n            size=size,\n            edge_width=self._highlight_width,\n            symbol=self.layer.symbol,\n            edge_color=self._highlight_color,\n            face_color=transform_color('transparent'),\n            scaling=True,\n        )\n\n        # only draw a box in 2D\n        if self.layer.dims.ndisplay == 2:\n            if (\n                self.layer._highlight_box is None\n                or 0 in self.layer._highlight_box.shape\n            ):\n                pos = np.zeros((1, self.layer.dims.ndisplay))\n                width = 0\n            else:\n                pos = self.layer._highlight_box\n                width = self._highlight_width\n\n            self.node._subvisuals[2].set_data(\n                pos=pos[:, ::-1] + 0.5,\n                color=self._highlight_color,\n                width=width,\n            )\n\n        self.node.update()\n"""
napari/_vispy/vispy_shapes_layer.py,8,"b""from vispy.scene.visuals import Line, Compound, Mesh, Markers\nfrom .vispy_base_layer import VispyBaseLayer\nimport numpy as np\n\n\nclass VispyShapesLayer(VispyBaseLayer):\n    def __init__(self, layer):\n        # Create a compound visual with the following four subvisuals:\n        # Markers: corresponding to the vertices of the interaction box or the\n        # shapes that are used for highlights.\n        # Lines: The lines of the interaction box used for highlights.\n        # Mesh: The mesh of the outlines for each shape used for highlights.\n        # Mesh: The actual meshes of the shape faces and edges\n        node = Compound([Mesh(), Mesh(), Line(), Markers()])\n\n        super().__init__(layer, node)\n\n        self.layer.events.edge_width.connect(self._on_data_change)\n        self.layer.events.edge_color.connect(self._on_data_change)\n        self.layer.events.face_color.connect(self._on_data_change)\n        self.layer.events.highlight.connect(self._on_highlight_change)\n\n        self._reset_base()\n        self._on_data_change()\n        self._on_highlight_change()\n\n    def _on_data_change(self, event=None):\n        faces = self.layer._data_view._mesh.displayed_triangles\n        colors = self.layer._data_view._mesh.displayed_triangles_colors\n        vertices = self.layer._data_view._mesh.vertices\n\n        # Note that the indicies of the vertices need to be resversed to\n        # go from numpy style to xyz\n        if vertices is not None:\n            vertices = vertices[:, ::-1] + 0.5\n\n        if len(vertices) == 0 or len(faces) == 0:\n            vertices = np.zeros((3, self.layer.dims.ndisplay))\n            faces = np.array([[0, 1, 2]])\n            colors = np.array([[0, 0, 0, 0]])\n\n        if self.layer.dims.ndisplay == 3 and self.layer.dims.ndim == 2:\n            vertices = np.pad(vertices, ((0, 0), (0, 1)), mode='constant')\n\n        self.node._subvisuals[0].set_data(\n            vertices=vertices, faces=faces, face_colors=colors\n        )\n        # Call to update order of translation values with new dims:\n        self._on_scale_change()\n        self._on_translate_change()\n        self.node.update()\n\n    def _on_highlight_change(self, event=None):\n        # Compute the vertices and faces of any shape outlines\n        vertices, faces = self.layer._outline_shapes()\n\n        if vertices is None or len(vertices) == 0 or len(faces) == 0:\n            vertices = np.zeros((3, self.layer.dims.ndisplay))\n            faces = np.array([[0, 1, 2]])\n        else:\n            vertices = vertices + 0.5\n\n        self.node._subvisuals[1].set_data(\n            vertices=vertices, faces=faces, color=self.layer._highlight_color\n        )\n\n        # Compute the location and properties of the vertices and box that\n        # need to get rendered\n        (\n            vertices,\n            face_color,\n            edge_color,\n            pos,\n            width,\n        ) = self.layer._compute_vertices_and_box()\n\n        if vertices is None or len(vertices) == 0:\n            vertices = np.zeros((1, self.layer.dims.ndisplay))\n            size = 0\n        else:\n            vertices = vertices + 0.5\n            size = self.layer._vertex_size\n\n        self.node._subvisuals[3].set_data(\n            vertices,\n            size=size,\n            face_color=face_color,\n            edge_color=edge_color,\n            edge_width=1.5,\n            symbol='square',\n            scaling=False,\n        )\n\n        if pos is None or len(pos) == 0:\n            pos = np.zeros((1, self.layer.dims.ndisplay))\n            width = 0\n        else:\n            pos = pos + 0.5\n\n        self.node._subvisuals[2].set_data(\n            pos=pos, color=edge_color, width=width\n        )\n"""
napari/_vispy/vispy_surface_layer.py,3,"b'from vispy.scene.visuals import Mesh\nfrom vispy.color import Colormap\nfrom .vispy_base_layer import VispyBaseLayer\nimport numpy as np\n\n\nclass VispySurfaceLayer(VispyBaseLayer):\n    """"""Vispy view for the surface layer.\n\n    View is based on the vispy mesh node and uses default values for\n    lighting direction and lighting color. More information can be found\n    here https://github.com/vispy/vispy/blob/master/vispy/visuals/mesh.py\n    """"""\n\n    def __init__(self, layer):\n        node = Mesh()\n\n        super().__init__(layer, node)\n\n        self.layer.events.colormap.connect(self._on_colormap_change)\n        self.layer.events.contrast_limits.connect(\n            self._on_contrast_limits_change\n        )\n        self.layer.events.gamma.connect(self._on_gamma_change)\n\n        self.reset()\n        self._on_data_change()\n\n    def _on_data_change(self, event=None):\n        if len(self.layer._data_view) == 0 or len(self.layer._view_faces) == 0:\n            vertices = None\n            faces = None\n            vertex_values = np.array([0])\n        else:\n            # Offseting so pixels now centered\n            vertices = self.layer._data_view[:, ::-1] + 0.5\n            faces = self.layer._view_faces\n            vertex_values = self.layer._view_vertex_values\n\n        if (\n            vertices is not None\n            and self.layer.dims.ndisplay == 3\n            and self.layer.dims.ndim == 2\n        ):\n            vertices = np.pad(vertices, ((0, 0), (0, 1)))\n        self.node.set_data(\n            vertices=vertices, faces=faces, vertex_values=vertex_values\n        )\n        self.node.update()\n        # Call to update order of translation values with new dims:\n        self._on_scale_change()\n        self._on_translate_change()\n\n    def _on_colormap_change(self, event=None):\n        cmap = self.layer.colormap[1]\n        if self.layer.gamma != 1:\n            # when gamma!=1, we instantiate a new colormap with 256 control\n            # points from 0-1\n            cmap = Colormap(cmap[np.linspace(0, 1, 256) ** self.layer.gamma])\n        if self.layer.dims.ndisplay == 3:\n            self.node.view_program[\'texture2D_LUT\'] = (\n                cmap.texture_lut() if (hasattr(cmap, \'texture_lut\')) else None\n            )\n        self.node.cmap = cmap\n\n    def _on_contrast_limits_change(self, event=None):\n        self.node.clim = self.layer.contrast_limits\n\n    def _on_gamma_change(self, event=None):\n        self._on_colormap_change()\n\n    def reset(self, event=None):\n        self._reset_base()\n        self._on_colormap_change()\n        self._on_contrast_limits_change()\n'"
napari/_vispy/vispy_vectors_layer.py,4,"b""from vispy.scene.visuals import Mesh\nfrom .vispy_base_layer import VispyBaseLayer\nimport numpy as np\n\n\nclass VispyVectorsLayer(VispyBaseLayer):\n    def __init__(self, layer):\n        node = Mesh()\n        super().__init__(layer, node)\n\n        self.layer.events.edge_color.connect(self._on_data_change)\n        self._reset_base()\n        self._on_data_change()\n\n    def _on_data_change(self, event=None):\n        if (\n            len(self.layer._view_vertices) == 0\n            or len(self.layer._view_faces) == 0\n        ):\n            vertices = np.zeros((3, self.layer.dims.ndisplay))\n            faces = np.array([[0, 1, 2]])\n            face_color = np.array([[0, 0, 0, 0]])\n        else:\n            vertices = self.layer._view_vertices[:, ::-1] + 0.5\n            faces = self.layer._view_faces\n            face_color = self.layer._view_face_color\n\n        if self.layer.dims.ndisplay == 3 and self.layer.dims.ndim == 2:\n            vertices = np.pad(vertices, ((0, 0), (0, 1)), mode='constant')\n\n        # self.node.set_data(\n        #     vertices=vertices, faces=faces, color=self.layer.current_edge_color\n        # )\n        self.node.set_data(\n            vertices=vertices, faces=faces, face_colors=face_color,\n        )\n\n        self.node.update()\n        # Call to update order of translation values with new dims:\n        self._on_scale_change()\n        self._on_translate_change()\n"""
napari/_vispy/volume.py,0,"b'from vispy.scene.visuals import Volume as BaseVolume\nfrom vispy.visuals.shaders import Function\n\n# Vertex shader\nVERT_SHADER = """"""\nattribute vec3 a_position;\n// attribute vec3 a_texcoord;\nuniform vec3 u_shape;\n\n// varying vec3 v_texcoord;\nvarying vec3 v_position;\nvarying vec4 v_nearpos;\nvarying vec4 v_farpos;\n\nvoid main() {\n    // v_texcoord = a_texcoord;\n    v_position = a_position;\n\n    // Project local vertex coordinate to camera position. Then do a step\n    // backward (in cam coords) and project back. Voila, we get our ray vector.\n    vec4 pos_in_cam = $viewtransformf(vec4(v_position, 1));\n\n    // intersection of ray and near clipping plane (z = -1 in clip coords)\n    pos_in_cam.z = -pos_in_cam.w;\n    v_nearpos = $viewtransformi(pos_in_cam);\n\n    // intersection of ray and far clipping plane (z = +1 in clip coords)\n    pos_in_cam.z = pos_in_cam.w;\n    v_farpos = $viewtransformi(pos_in_cam);\n\n    gl_Position = $transform(vec4(v_position, 1.0));\n}\n""""""  # noqa\n\n# Fragment shader\nFRAG_SHADER = """"""\n// uniforms\nuniform $sampler_type u_volumetex;\nuniform vec3 u_shape;\nuniform float u_threshold;\nuniform float u_relative_step_size;\n\n//varyings\n// varying vec3 v_texcoord;\nvarying vec3 v_position;\nvarying vec4 v_nearpos;\nvarying vec4 v_farpos;\n\n// uniforms for lighting. Hard coded until we figure out how to do lights\nconst vec4 u_ambient = vec4(0.2, 0.2, 0.2, 1.0);\nconst vec4 u_diffuse = vec4(0.8, 0.2, 0.2, 1.0);\nconst vec4 u_specular = vec4(1.0, 1.0, 1.0, 1.0);\nconst float u_shininess = 40.0;\n\n//varying vec3 lightDirs[1];\n\n// global holding view direction in local coordinates\nvec3 view_ray;\n\nfloat rand(vec2 co)\n{{\n    // Create a pseudo-random number between 0 and 1.\n    // http://stackoverflow.com/questions/4200224\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}}\n\nfloat colorToVal(vec4 color1)\n{{\n    return color1.g; // todo: why did I have this abstraction in visvis?\n}}\n\nvec4 calculateColor(vec4 betterColor, vec3 loc, vec3 step)\n{{\n    // Calculate color by incorporating lighting\n    vec4 color1;\n    vec4 color2;\n\n    // View direction\n    vec3 V = normalize(view_ray);\n\n    // calculate normal vector from gradient\n    vec3 N; // normal\n    color1 = $sample( u_volumetex, loc+vec3(-step[0],0.0,0.0) );\n    color2 = $sample( u_volumetex, loc+vec3(step[0],0.0,0.0) );\n    N[0] = colorToVal(color1) - colorToVal(color2);\n    betterColor = max(max(color1, color2),betterColor);\n    color1 = $sample( u_volumetex, loc+vec3(0.0,-step[1],0.0) );\n    color2 = $sample( u_volumetex, loc+vec3(0.0,step[1],0.0) );\n    N[1] = colorToVal(color1) - colorToVal(color2);\n    betterColor = max(max(color1, color2),betterColor);\n    color1 = $sample( u_volumetex, loc+vec3(0.0,0.0,-step[2]) );\n    color2 = $sample( u_volumetex, loc+vec3(0.0,0.0,step[2]) );\n    N[2] = colorToVal(color1) - colorToVal(color2);\n    betterColor = max(max(color1, color2),betterColor);\n    float gm = length(N); // gradient magnitude\n    N = normalize(N);\n\n    // Flip normal so it points towards viewer\n    float Nselect = float(dot(N,V) > 0.0);\n    N = (2.0*Nselect - 1.0) * N;  // ==  Nselect * N - (1.0-Nselect)*N;\n\n    // Get color of the texture (albeido)\n    color1 = betterColor;\n    color2 = color1;\n    // todo: parametrise color1_to_color2\n\n    // Init colors\n    vec4 ambient_color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 diffuse_color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 specular_color = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 final_color;\n\n    // todo: allow multiple light, define lights on viewvox or subscene\n    int nlights = 1;\n    for (int i=0; i<nlights; i++)\n    {{\n        // Get light direction (make sure to prevent zero devision)\n        vec3 L = normalize(view_ray);  //lightDirs[i];\n        float lightEnabled = float( length(L) > 0.0 );\n        L = normalize(L+(1.0-lightEnabled));\n\n        // Calculate lighting properties\n        float lambertTerm = clamp( dot(N,L), 0.0, 1.0 );\n        vec3 H = normalize(L+V); // Halfway vector\n        float specularTerm = pow( max(dot(H,N),0.0), u_shininess);\n\n        // Calculate mask\n        float mask1 = lightEnabled;\n\n        // Calculate colors\n        ambient_color +=  mask1 * u_ambient; // * gl_LightSource[i].ambient;\n        diffuse_color +=  mask1 * lambertTerm;\n        specular_color += mask1 * specularTerm * u_specular;\n    }}\n\n    // Calculate final color by componing different components\n    final_color = color2 * ( ambient_color + diffuse_color) + specular_color;\n    final_color.a = color2.a;\n\n    // Done\n    return final_color;\n}}\n\n// for some reason, this has to be the last function in order for the\n// filters to be inserted in the correct place...\n\nvoid main() {{\n    vec3 farpos = v_farpos.xyz / v_farpos.w;\n    vec3 nearpos = v_nearpos.xyz / v_nearpos.w;\n\n    // Calculate unit vector pointing in the view direction through this\n    // fragment.\n    view_ray = normalize(farpos.xyz - nearpos.xyz);\n\n    // Compute the distance to the front surface or near clipping plane\n    float distance = dot(nearpos-v_position, view_ray);\n    distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,\n                            (u_shape.x - 0.5 - v_position.x) / view_ray.x));\n    distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,\n                            (u_shape.y - 0.5 - v_position.y) / view_ray.y));\n    distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,\n                            (u_shape.z - 0.5 - v_position.z) / view_ray.z));\n\n    // Now we have the starting position on the front surface\n    vec3 front = v_position + view_ray * distance;\n\n    // Decide how many steps to take\n    int nsteps = int(-distance / u_relative_step_size + 0.5);\n    float f_nsteps = float(nsteps);\n    if( nsteps < 1 )\n        discard;\n\n    // Get starting location and step vector in texture coordinates\n    vec3 step = ((v_position - front) / u_shape) / f_nsteps;\n    vec3 start_loc = front / u_shape;\n\n    // For testing: show the number of steps. This helps to establish\n    // whether the rays are correctly oriented\n    //gl_FragColor = vec4(0.0, f_nsteps / 3.0 / u_shape.x, 1.0, 1.0);\n    //return;\n\n    {before_loop}\n\n    // This outer loop seems necessary on some systems for large\n    // datasets. Ugly, but it works ...\n    vec3 loc = start_loc;\n    int iter = 0;\n    while (iter < nsteps) {{\n        for (iter=iter; iter<nsteps; iter++)\n        {{\n            // Get sample color\n            vec4 color = $sample(u_volumetex, loc);\n            float val = color.g;\n\n            {in_loop}\n\n            // Advance location deeper into the volume\n            loc += step;\n        }}\n    }}\n\n    {after_loop}\n\n    /* Set depth value - from visvis TODO\n    int iter_depth = int(maxi);\n    // Calculate end position in world coordinates\n    vec4 position2 = vertexPosition;\n    position2.xyz += ray*shape*float(iter_depth);\n    // Project to device coordinates and set fragment depth\n    vec4 iproj = gl_ModelViewProjectionMatrix * position2;\n    iproj.z /= iproj.w;\n    gl_FragDepth = (iproj.z+1.0)/2.0;\n    */\n}}\n\n\n""""""  # noqa\n\n\nMIP_SNIPPETS = dict(\n    before_loop=""""""\n        float maxval = -99999.0; // The maximum encountered value\n        int maxi = 0;  // Where the maximum value was encountered\n        """""",\n    in_loop=""""""\n        if( val > maxval ) {\n            maxval = val;\n            maxi = iter;\n        }\n        """""",\n    after_loop=""""""\n        // Refine search for max value\n        loc = start_loc + step * (float(maxi) - 0.5);\n        for (int i=0; i<10; i++) {\n            maxval = max(maxval, $sample(u_volumetex, loc).g);\n            loc += step * 0.1;\n        }\n        gl_FragColor = $cmap(maxval);\n        """""",\n)\nMIP_FRAG_SHADER = FRAG_SHADER.format(**MIP_SNIPPETS)\n\n\nTRANSLUCENT_SNIPPETS = dict(\n    before_loop=""""""\n        vec4 integrated_color = vec4(0., 0., 0., 0.);\n        """""",\n    in_loop=""""""\n            color = $cmap(val);\n            float a1 = integrated_color.a;\n            float a2 = color.a * (1 - a1);\n            float alpha = max(a1 + a2, 0.001);\n\n            // Doesn\'t work.. GLSL optimizer bug?\n            //integrated_color = (integrated_color * a1 / alpha) +\n            //                   (color * a2 / alpha);\n            // This should be identical but does work correctly:\n            integrated_color *= a1 / alpha;\n            integrated_color += color * a2 / alpha;\n\n            integrated_color.a = alpha;\n\n            if( alpha > 0.99 ){\n                // stop integrating if the fragment becomes opaque\n                iter = nsteps;\n            }\n\n        """""",\n    after_loop=""""""\n        gl_FragColor = integrated_color;\n        """""",\n)\nTRANSLUCENT_FRAG_SHADER = FRAG_SHADER.format(**TRANSLUCENT_SNIPPETS)\n\n\nADDITIVE_SNIPPETS = dict(\n    before_loop=""""""\n        vec4 integrated_color = vec4(0., 0., 0., 0.);\n        """""",\n    in_loop=""""""\n        color = $cmap(val);\n\n        integrated_color = 1.0 - (1.0 - integrated_color) * (1.0 - color);\n        """""",\n    after_loop=""""""\n        gl_FragColor = integrated_color;\n        """""",\n)\nADDITIVE_FRAG_SHADER = FRAG_SHADER.format(**ADDITIVE_SNIPPETS)\n\n\nISO_SNIPPETS = dict(\n    before_loop=""""""\n        vec4 color3 = vec4(0.0);  // final color\n        vec3 dstep = 1.5 / u_shape;  // step to sample derivative\n        gl_FragColor = vec4(0.0);\n    """""",\n    in_loop=""""""\n        if (val > u_threshold-0.2) {\n            // Take the last interval in smaller steps\n            vec3 iloc = loc - step;\n            for (int i=0; i<10; i++) {\n                color = $sample(u_volumetex, iloc);\n                if (color.g > u_threshold) {\n                    color = calculateColor(color, iloc, dstep);\n                    gl_FragColor = $cmap(color.g);\n                    iter = nsteps;\n                    break;\n                }\n                iloc += step * 0.1;\n            }\n        }\n        """""",\n    after_loop=""""""\n        """""",\n)\n\nISO_FRAG_SHADER = FRAG_SHADER.format(**ISO_SNIPPETS)\n\nATTENUATED_MIP_SNIPPETS = dict(\n    before_loop=""""""\n        float maxval = -99999.0; // The maximum encountered value\n        float sumval = 0.0; // The sum of the encountered values\n        float scaled = 0.0; // The scaled value\n        int maxi = 0;  // Where the maximum value was encountered\n        vec3 maxloc = vec3(0.0);  // Location where the maximum value was encountered\n        """""",\n    in_loop=""""""\n        sumval = sumval + val;\n        scaled = val * exp(-u_threshold * (sumval - 1) / u_relative_step_size);\n        if( scaled > maxval ) {\n            maxval = scaled;\n            maxi = iter;\n            maxloc = loc;\n        }\n        """""",\n    after_loop=""""""\n        gl_FragColor = $cmap(maxval);\n        """""",\n)\nATTENUATED_MIP_FRAG_SHADER = FRAG_SHADER.format(**ATTENUATED_MIP_SNIPPETS)\n\nfrag_dict = {\n    \'mip\': MIP_FRAG_SHADER,\n    \'iso\': ISO_FRAG_SHADER,\n    \'translucent\': TRANSLUCENT_FRAG_SHADER,\n    \'additive\': ADDITIVE_FRAG_SHADER,\n    \'attenuated_mip\': ATTENUATED_MIP_FRAG_SHADER,\n}\n\n\n# Custom volume class is needed for better 3D rendering\nclass Volume(BaseVolume):\n    _interpolation_names = [\'linear\', \'nearest\']\n\n    def __init__(self, *args, **kwargs):\n        self._interpolation = \'linear\'\n        self._threshold = 0\n        super().__init__(*args, **kwargs)\n\n    @property\n    def method(self):\n        """"""The render method to use\n\n        Current options are:\n\n            * translucent: voxel colors are blended along the view ray until\n              the result is opaque.\n            * mip: maxiumum intensity projection. Cast a ray and display the\n              maximum value that was encountered.\n            * additive: voxel colors are added along the view ray until\n              the result is saturated.\n            * iso: isosurface. Cast a ray until a certain threshold is\n              encountered. At that location, lighning calculations are\n              performed to give the visual appearance of a surface.\n        """"""\n        return self._method\n\n    @method.setter\n    def method(self, method):\n        # Check and save\n        known_methods = list(frag_dict.keys())\n        if method not in known_methods:\n            raise ValueError(\n                \'Volume render method should be in %r, not %r\'\n                % (known_methods, method)\n            )\n        self._method = method\n        self.shared_program.frag = frag_dict[method]\n        self.shared_program.frag[\'sampler_type\'] = self._tex.glsl_sampler_type\n        self.shared_program.frag[\'sample\'] = self._tex.glsl_sample\n        self.shared_program.frag[\'cmap\'] = Function(self._cmap.glsl_map)\n        self.shared_program[\'texture2D_LUT\'] = (\n            self.cmap.texture_lut()\n            if (hasattr(self.cmap, \'texture_lut\'))\n            else None\n        )\n        if \'u_threshold\' in self.shared_program:\n            self.shared_program[\'u_threshold\'] = self.threshold\n        self.update()\n\n    @property\n    def threshold(self):\n        """""" The threshold value to apply for the isosurface render method.\n        """"""\n        return self._threshold\n\n    @threshold.setter\n    def threshold(self, value):\n        self._threshold = float(value)\n        if \'u_threshold\' in self.shared_program:\n            self.shared_program[\'u_threshold\'] = self._threshold\n        self.update()\n\n    @property\n    def interpolation(self):\n        return self._interpolation\n\n    @interpolation.setter\n    def interpolation(self, interp):\n        if interp not in self._interpolation_names:\n            raise ValueError(\n                ""interpolation must be one of %s""\n                % \', \'.join(self._interpolation_names)\n            )\n        if self._interpolation != interp:\n            self._interpolation = interp\n            self._tex.interpolation = self._interpolation\n            self.update()\n'"
napari/benchmarks/benchmark_image_layer.py,6,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Image\n\n\nclass Image2DSuite:\n    """"""Benchmarks for the Image layer with 2D data.""""""\n\n    params = [2 ** i for i in range(4, 13)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, n))\n        self.new_data = np.random.random((n, n))\n        self.layer = Image(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create an image layer.""""""\n        Image(self.data)\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_set_data(self, n):\n        """"""Time to get current value.""""""\n        self.layer.data = self.new_data\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Image3DSuite:\n    """"""Benchmarks for the Image layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 11)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, n, n))\n        self.new_data = np.random.random((n, n, n))\n        self.layer = Image(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create an image layer.""""""\n        Image(self.data)\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_set_data(self, n):\n        """"""Time to get current value.""""""\n        self.layer.data = self.new_data\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return Image(self.data)\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/benchmarks/benchmark_labels_layer.py,4,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Labels\n\n\nclass Labels2DSuite:\n    """"""Benchmarks for the Labels layer with 2D data""""""\n\n    params = [2 ** i for i in range(4, 13)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.randint(20, size=(n, n))\n        self.layer = Labels(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create layer.""""""\n        Labels(self.data)\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_save_history(self, n):\n        """"""Time to save history.""""""\n        self.layer._save_history()\n\n    def time_raw_to_displayed(self, n):\n        """"""Time to convert raw to displayed.""""""\n        self.layer._raw_to_displayed(self.layer._data_raw)\n\n    def time_paint(self, n):\n        """"""Time to paint.""""""\n        self.layer.paint(self.layer.coordinates, self.layer.selected_label)\n\n    def time_fill(self, n):\n        """"""Time to fill.""""""\n        self.layer.fill(\n            self.layer.coordinates,\n            self.layer._value,\n            self.layer.selected_label,\n        )\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Labels3DSuite:\n    """"""Benchmarks for the Labels layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 11)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.randint(20, size=(n, n, n))\n        self.layer = Labels(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create layer.""""""\n        Labels(self.data)\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_save_history(self, n):\n        """"""Time to save history.""""""\n        self.layer._save_history()\n\n    def time_raw_to_displayed(self, n):\n        """"""Time to convert raw to displayed.""""""\n        self.layer._raw_to_displayed(self.layer._data_raw)\n\n    def time_paint(self, n):\n        """"""Time to paint.""""""\n        self.layer.paint(self.layer.coordinates, self.layer.selected_label)\n\n    def time_fill(self, n):\n        """"""Time to fill.""""""\n        self.layer.fill(\n            self.layer.coordinates,\n            self.layer._value,\n            self.layer.selected_label,\n        )\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/benchmarks/benchmark_points_layer.py,4,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Points\n\n\nclass Points2DSuite:\n    """"""Benchmarks for the Points layer with 2D data""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, 2))\n        self.layer = Points(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create layer.""""""\n        Points(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Points3DSuite:\n    """"""Benchmarks for the Points layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, 3))\n        self.layer = Points(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create layer.""""""\n        Points(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/benchmarks/benchmark_qt_viewer.py,0,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport napari\n\n\nclass QtViewerSuite:\n    """"""Benchmarks for viewing images in the viewer.""""""\n\n    def setup(self):\n        self.viewer = None\n\n    def teardown(self):\n        self.viewer.window.close()\n\n    def time_create_viewer(self):\n        """"""Time to create the viewer.""""""\n        self.viewer = napari.Viewer()\n'"
napari/benchmarks/benchmark_qt_viewer_image.py,12,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nimport napari\nfrom qtpy.QtWidgets import QApplication\n\n\nclass QtViewerViewImageSuite:\n    """"""Benchmarks for viewing images in the viewer.""""""\n\n    params = [2 ** i for i in range(4, 13)]\n\n    def setup(self, n):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.random((n, n))\n        self.viewer = None\n\n    def teardown(self, n):\n        self.viewer.window.close()\n\n    def time_view_image(self, n):\n        """"""Time to view an image.""""""\n        self.viewer = napari.view_image(self.data)\n\n\nclass QtViewerAddImageSuite:\n    """"""Benchmarks for adding images to the viewer.""""""\n\n    params = [2 ** i for i in range(4, 13)]\n\n    def setup(self, n):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.random((n, n))\n        self.viewer = napari.Viewer()\n\n    def teardown(self, n):\n        self.viewer.window.close()\n\n    def time_add_image(self, n):\n        """"""Time to view an image.""""""\n        self.viewer.add_image(self.data)\n\n\nclass QtViewerImageSuite:\n    """"""Benchmarks for images in the viewer.""""""\n\n    params = [2 ** i for i in range(4, 13)]\n\n    def setup(self, n):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.random((n, n))\n        self.viewer = napari.view_image(self.data)\n\n    def teardown(self, n):\n        self.viewer.window.close()\n\n    def time_zoom(self, n):\n        """"""Time to zoom in and zoom out.""""""\n        self.viewer.window.qt_viewer.view.camera.zoom(0.5, center=(0.5, 0.5))\n        self.viewer.window.qt_viewer.view.camera.zoom(2.0, center=(0.5, 0.5))\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.viewer.layers[0].refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.viewer.layers[0]._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.viewer.layers[0]._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.viewer.layers[0].get_value()\n\n\nclass QtViewerSingleImageSuite:\n    """"""Benchmarks for a single image layer in the viewer.""""""\n\n    def setup(self):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.random((128, 128, 128))\n        self.new_data = np.random.random((128, 128, 128))\n        self.viewer = napari.view_image(self.data)\n\n    def teardown(self):\n        self.viewer.window.close()\n\n    def time_zoom(self):\n        """"""Time to zoom in and zoom out.""""""\n        self.viewer.window.qt_viewer.view.camera.zoom(0.5, center=(0.5, 0.5))\n        self.viewer.window.qt_viewer.view.camera.zoom(2.0, center=(0.5, 0.5))\n\n    def time_set_data(self):\n        """"""Time to set view slice.""""""\n        self.viewer.layers[0].data = self.new_data\n\n    def time_refresh(self):\n        """"""Time to refresh view.""""""\n        self.viewer.layers[0].refresh()\n\n    def time_set_view_slice(self):\n        """"""Time to set view slice.""""""\n        self.viewer.layers[0]._set_view_slice()\n\n    def time_update_thumbnail(self):\n        """"""Time to update thumbnail.""""""\n        self.viewer.layers[0]._update_thumbnail()\n\n    def time_get_value(self):\n        """"""Time to get current value.""""""\n        self.viewer.layers[0].get_value()\n\n    def time_ndisplay(self):\n        """"""Time to enter 3D rendering.""""""\n        self.viewer.dims.ndisplay = 3\n\n\nclass QtViewerSingleInvisbleImageSuite:\n    """"""Benchmarks for a invisble single image layer in the viewer.""""""\n\n    def setup(self):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.random((128, 128, 128))\n        self.new_data = np.random.random((128, 128, 128))\n        self.viewer = napari.view_image(self.data, visible=False)\n\n    def teardown(self):\n        self.viewer.window.close()\n\n    def time_zoom(self):\n        """"""Time to zoom in and zoom out.""""""\n        self.viewer.window.qt_viewer.view.camera.zoom(0.5, center=(0.5, 0.5))\n        self.viewer.window.qt_viewer.view.camera.zoom(2.0, center=(0.5, 0.5))\n\n    def time_set_data(self):\n        """"""Time to set view slice.""""""\n        self.viewer.layers[0].data = self.new_data\n\n    def time_refresh(self):\n        """"""Time to refresh view.""""""\n        self.viewer.layers[0].refresh()\n\n    def time_set_view_slice(self):\n        """"""Time to set view slice.""""""\n        self.viewer.layers[0]._set_view_slice()\n\n    def time_update_thumbnail(self):\n        """"""Time to update thumbnail.""""""\n        self.viewer.layers[0]._update_thumbnail()\n\n    def time_get_value(self):\n        """"""Time to get current value.""""""\n        self.viewer.layers[0].get_value()\n\n    def time_ndisplay(self):\n        """"""Time to enter 3D rendering.""""""\n        self.viewer.dims.ndisplay = 3\n'"
napari/benchmarks/benchmark_qt_viewer_labels.py,2,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nimport napari\nfrom qtpy.QtWidgets import QApplication\nimport collections\n\n\nclass QtViewerSingleLabelsSuite:\n    """"""Benchmarks for editing a single labels layer in the viewer.""""""\n\n    def setup(self):\n        _ = QApplication.instance() or QApplication([])\n        np.random.seed(0)\n        self.data = np.random.randint(10, size=(512, 512))\n        self.viewer = napari.view_labels(self.data)\n        self.layer = self.viewer.layers[0]\n        self.layer.brush_size = 10\n        self.layer.mode = \'paint\'\n        self.layer.selected_label = 3\n        self.layer._last_cursor_coord = (511, 511)\n        Event = collections.namedtuple(\'Event\', \'is_dragging\')\n        self.event = Event(is_dragging=True)\n\n    def teardown(self):\n        self.viewer.window.close()\n\n    def time_zoom(self):\n        """"""Time to zoom in and zoom out.""""""\n        self.viewer.window.qt_viewer.view.camera.zoom(0.5, center=(0.5, 0.5))\n        self.viewer.window.qt_viewer.view.camera.zoom(2.0, center=(0.5, 0.5))\n\n    def time_set_view_slice(self):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_update_thumbnail(self):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_raw_to_displayed(self):\n        """"""Time to convert raw to displayed.""""""\n        self.layer._raw_to_displayed(self.layer._data_raw)\n\n    def time_paint(self):\n        """"""Time to paint.""""""\n        self.layer.paint(self.layer.coordinates, self.layer.selected_label)\n\n    def time_fill(self):\n        """"""Time to fill.""""""\n        self.layer.fill(\n            self.layer.coordinates,\n            self.layer._value,\n            self.layer.selected_label,\n        )\n\n    def time_on_mouse_move(self):\n        """"""Time to drag paint on mouse move.""""""\n        self.layer.on_mouse_move(self.event)\n'"
napari/benchmarks/benchmark_shapes_layer.py,4,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Shapes\n\n\nclass Shapes2DSuite:\n    """"""Benchmarks for the Shapes layer with 2D data""""""\n\n    params = [2 ** i for i in range(4, 9)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = [50 * np.random.random((6, 2)) for i in range(n)]\n        self.layer = Shapes(self.data, shape_type=\'polygon\')\n\n    def time_create_layer(self, n):\n        """"""Time to create an image layer.""""""\n        Shapes(self.data, shape_type=\'polygon\')\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Shapes3DSuite:\n    """"""Benchmarks for the Shapes layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 9)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = [50 * np.random.random((6, 3)) for i in range(n)]\n        self.layer = Shapes(self.data, shape_type=\'polygon\')\n\n    def time_create_layer(self, n):\n        """"""Time to create a layer.""""""\n        Shapes(self.data, shape_type=\'polygon\')\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/benchmarks/benchmark_surface_layer.py,8,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Surface\n\n\nclass Surface2DSuite:\n    """"""Benchmarks for the Surface layer with 2D data""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = (\n            np.random.random((n, 2)),\n            np.random.randint(n, size=(n, 3)),\n            np.random.random(n),\n        )\n        self.layer = Surface(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create an image layer.""""""\n        Surface(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Surface3DSuite:\n    """"""Benchmarks for the Surface layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = (\n            np.random.random((n, 3)),\n            np.random.randint(n, size=(n, 3)),\n            np.random.random(n),\n        )\n        self.layer = Surface(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create a layer.""""""\n        Surface(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/benchmarks/benchmark_vectors_layer.py,4,"b'# See ""Writing benchmarks"" in the asv docs for more information.\n# https://asv.readthedocs.io/en/latest/writing_benchmarks.html\n# or the napari documentation on benchmarking\n# https://github.com/napari/napari/blob/master/docs/BENCHMARKS.md\nimport numpy as np\nfrom napari.layers import Vectors\n\n\nclass Vectors2DSuite:\n    """"""Benchmarks for the Vectors layer with 2D data""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, 2, 2))\n        self.layer = Vectors(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create an image layer.""""""\n        Vectors(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_width(self, n):\n        """"""Time to update width.""""""\n        self.layer.width = 2\n\n    def time_length(self, n):\n        """"""Time to update length.""""""\n        self.layer.length = 2\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n\n\nclass Vectors3DSuite:\n    """"""Benchmarks for the Vectors layer with 3D data.""""""\n\n    params = [2 ** i for i in range(4, 18, 2)]\n\n    def setup(self, n):\n        np.random.seed(0)\n        self.data = np.random.random((n, 2, 3))\n        self.layer = Vectors(self.data)\n\n    def time_create_layer(self, n):\n        """"""Time to create a layer.""""""\n        Vectors(self.data)\n\n    def time_refresh(self, n):\n        """"""Time to refresh view.""""""\n        self.layer.refresh()\n\n    def time_set_view_slice(self, n):\n        """"""Time to set view slice.""""""\n        self.layer._set_view_slice()\n\n    def time_update_thumbnail(self, n):\n        """"""Time to update thumbnail.""""""\n        self.layer._update_thumbnail()\n\n    def time_get_value(self, n):\n        """"""Time to get current value.""""""\n        self.layer.get_value()\n\n    def time_width(self, n):\n        """"""Time to update width.""""""\n        self.layer.width = 2\n\n    def time_length(self, n):\n        """"""Time to update length.""""""\n        self.layer.length = 2\n\n    def mem_layer(self, n):\n        """"""Memory used by layer.""""""\n        return self.layer\n\n    def mem_data(self, n):\n        """"""Memory used by raw data.""""""\n        return self.data\n'"
napari/components/__init__.py,0,"b'""""""napari.components provides the public-facing models for widgets\nand other utilities that the user will be able to programmatically interact\nwith.\n\nClasses\n-------\nDims\n    Current indices along each data dimension, together with which dimensions\n    are being displayed, projected, sliced...\nLayerList\n    List of layers currently present in the viewer.\nViewerModel\n    Data viewer displaying the currently rendered scene and\n    layer-related controls.\n""""""\nfrom .dims import Dims\nfrom .layerlist import LayerList\nfrom .viewer_model import ViewerModel\n'"
napari/components/add_layers_mixin.py,10,"b'import inspect\nimport itertools\nimport os\nfrom functools import lru_cache\nfrom logging import getLogger\nfrom typing import Any, Dict, List, Optional, Sequence, Set, Union\n\nimport numpy as np\n\nfrom .. import layers\nfrom ..layers.image._image_utils import guess_labels, guess_multiscale\nfrom ..plugins.io import read_data_with_plugins\nfrom ..types import FullLayerData, LayerData\nfrom ..utils import colormaps\nfrom ..utils.colormaps import ensure_colormap_tuple\nfrom ..utils.misc import (\n    ensure_iterable,\n    ensure_sequence_of_iterables,\n    is_sequence,\n)\n\nlogger = getLogger(__name__)\n\n\nclass AddLayersMixin:\n    """"""A mixin that adds add_* methods for adding layers to the ViewerModel.\n\n    Each method corresponds to adding one or more layers to the viewer.\n    Methods that just add a single layer contain the keyword arguments and\n    copies of the documentation from that the layer. These are copied and\n    pasted instead of being autogenerated because IDEs like PyCharm parse the\n    source code for docs instead of pulling it up dynamically.\n\n    These methods are separated into a mixin to keep the ViewerModel class\n    easier to read and make these methods easier to maintain.\n    """"""\n\n    def add_layer(self, layer: layers.Layer) -> layers.Layer:\n        """"""Add a layer to the viewer.\n\n        Parameters\n        ----------\n        layer : :class:`napari.layers.Layer`\n            Layer to add.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Layer` or list\n            The layer that was added (same as input).\n        """"""\n        layer.events.select.connect(self._update_active_layer)\n        layer.events.deselect.connect(self._update_active_layer)\n        layer.events.status.connect(self._update_status)\n        layer.events.help.connect(self._update_help)\n        layer.events.interactive.connect(self._update_interactive)\n        layer.events.cursor.connect(self._update_cursor)\n        layer.events.cursor_size.connect(self._update_cursor_size)\n        layer.events.data.connect(self._on_layers_change)\n        layer.dims.events.ndisplay.connect(self._on_layers_change)\n        layer.dims.events.order.connect(self._on_layers_change)\n        layer.dims.events.range.connect(self._on_layers_change)\n        self.layers.append(layer)\n        self._update_layers(layers=[layer])\n\n        if len(self.layers) == 1:\n            self.reset_view()\n        return layer\n\n    def add_image(\n        self,\n        data=None,\n        *,\n        channel_axis=None,\n        rgb=None,\n        colormap=None,\n        contrast_limits=None,\n        gamma=1,\n        interpolation=\'nearest\',\n        rendering=\'mip\',\n        iso_threshold=0.5,\n        attenuation=0.5,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=None,\n        visible=True,\n        multiscale=None,\n    ) -> Union[layers.Image, List[layers.Image]]:\n        """"""Add an image layer to the layers list.\n\n        Parameters\n        ----------\n        data : array or list of array\n            Image data. Can be N dimensional. If the last dimension has length\n            3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a\n            list and arrays are decreasing in shape then the data is treated as\n            a multiscale image.\n        channel_axis : int, optional\n            Axis to expand image along.  If provided, each channel in the data\n            will be added as an individual image layer.  In channel_axis mode,\n            all other parameters MAY be provided as lists, and the Nth value\n            will be applied to the Nth channel in the data.  If a single value\n            is provided, it will be broadcast to all Layers.\n        rgb : bool or list\n            Whether the image is rgb RGB or RGBA. If not specified by user and\n            the last dimension of the data has length 3 or 4 it will be set as\n            `True`. If `False` the image is interpreted as a luminance image.\n            If a list then must be same length as the axis that is being\n            expanded as channels.\n        colormap : str, vispy.Color.Colormap, tuple, dict, list\n            Colormaps to use for luminance images. If a string must be the name\n            of a supported colormap from vispy or matplotlib. If a tuple the\n            first value must be a string to assign as a name to a colormap and\n            the second item must be a Colormap. If a dict the key must be a\n            string to assign as a name to a colormap and the value must be a\n            Colormap. If a list then must be same length as the axis that is\n            being expanded as channels, and each colormap is applied to each\n            new image layer.\n        contrast_limits : list (2,)\n            Color limits to be used for determining the colormap bounds for\n            luminance images. If not passed is calculated as the min and max of\n            the image. If list of lists then must be same length as the axis\n            that is being expanded and then each colormap is applied to each\n            image.\n        gamma : list, float\n            Gamma correction for determining colormap linearity. Defaults to 1.\n            If a list then must be same length as the axis that is being\n            expanded as channels.\n        interpolation : str or list\n            Interpolation mode used by vispy. Must be one of our supported\n            modes. If a list then must be same length as the axis that is being\n            expanded as channels.\n        rendering : str or list\n            Rendering mode used by vispy. Must be one of our supported\n            modes. If a list then must be same length as the axis that is being\n            expanded as channels.\n        iso_threshold : float or list\n            Threshold for isosurface. If a list then must be same length as the\n            axis that is being expanded as channels.\n        attenuation : float or list\n            Attenuation rate for attenuated maximum intensity projection. If a\n            list then must be same length as the axis that is being expanded as\n            channels.\n        name : str or list of str\n            Name of the layer.  If a list then must be same length as the axis\n            that is being expanded as channels.\n        metadata : dict or list of dict\n            Layer metadata. If a list then must be a list of dicts with the\n            same length as the axis that is being expanded as channels.\n        scale : tuple of float or list\n            Scale factors for the layer. If a list then must be a list of\n            tuples of float with the same length as the axis that is being\n            expanded as channels.\n        translate : tuple of float or list\n            Translation values for the layer. If a list then must be a list of\n            tuples of float with the same length as the axis that is being\n            expanded as channels.\n        opacity : float or list\n            Opacity of the layer visual, between 0.0 and 1.0.  If a list then\n            must be same length as the axis that is being expanded as channels.\n        blending : str or list\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}. If a list then\n            must be same length as the axis that is being expanded as channels.\n        visible : bool or list of bool\n            Whether the layer visual is currently being displayed.\n            If a list then must be same length as the axis that is\n            being expanded as channels.\n        multiscale : bool\n            Whether the data is a multiscale image or not. Multiscale data is\n            represented by a list of array like image data. If not specified by\n            the user and if the data is a list of arrays that decrease in shape\n            then it will be taken to be multiscale. The first image in the list\n            should be the largest.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Image` or list\n            The newly-created image layer or list of image layers.\n        """"""\n\n        if colormap is not None:\n            # standardize colormap argument(s) to strings, and make sure they\n            # are in AVAILABLE_COLORMAPS.  This will raise one of many various\n            # errors if the colormap argument is invalid.  See\n            # ensure_colormap_tuple for details\n            if isinstance(colormap, list):\n                colormap = [ensure_colormap_tuple(c)[0] for c in colormap]\n            else:\n                colormap, _ = ensure_colormap_tuple(colormap)\n\n        # doing this here for IDE/console autocompletion in add_image function.\n        kwargs = {\n            \'rgb\': rgb,\n            \'colormap\': colormap,\n            \'contrast_limits\': contrast_limits,\n            \'gamma\': gamma,\n            \'interpolation\': interpolation,\n            \'rendering\': rendering,\n            \'iso_threshold\': iso_threshold,\n            \'attenuation\': attenuation,\n            \'name\': name,\n            \'metadata\': metadata,\n            \'scale\': scale,\n            \'translate\': translate,\n            \'opacity\': opacity,\n            \'blending\': blending,\n            \'visible\': visible,\n            \'multiscale\': multiscale,\n        }\n\n        # these arguments are *already* iterables in the single-channel case.\n        iterable_kwargs = {\'scale\', \'translate\', \'contrast_limits\', \'metadata\'}\n\n        if channel_axis is None:\n            kwargs[\'colormap\'] = kwargs[\'colormap\'] or \'gray\'\n            kwargs[\'blending\'] = kwargs[\'blending\'] or \'translucent\'\n            # Helpful message if someone tries to add mulit-channel kwargs,\n            # but forget the channel_axis arg\n            for k, v in kwargs.items():\n                if k not in iterable_kwargs and is_sequence(v):\n                    raise TypeError(\n                        f""Received sequence for argument \'{k}\', ""\n                        ""did you mean to specify a \'channel_axis\'? ""\n                    )\n\n            return self.add_layer(layers.Image(data, **kwargs))\n        else:\n            # Determine if data is a multiscale\n            if multiscale is None:\n                multiscale, data = guess_multiscale(data)\n            n_channels = (data[0] if multiscale else data).shape[channel_axis]\n            kwargs[\'blending\'] = kwargs[\'blending\'] or \'additive\'\n\n            # turn the kwargs dict into a mapping of {key: iterator}\n            # so that we can use {k: next(v) for k, v in kwargs.items()} below\n            for key, val in kwargs.items():\n                if key == \'colormap\' and val is None:\n                    if n_channels == 1:\n                        kwargs[key] = iter([\'gray\'])\n                    elif n_channels == 2:\n                        kwargs[key] = iter(colormaps.MAGENTA_GREEN)\n                    else:\n                        kwargs[key] = itertools.cycle(colormaps.CYMRGB)\n\n                # make sure that iterable_kwargs are a *sequence* of iterables\n                # for the multichannel case.  For example: if scale == (1, 2) &\n                # n_channels = 3, then scale should == [(1, 2), (1, 2), (1, 2)]\n                elif key in iterable_kwargs:\n                    kwargs[key] = iter(\n                        ensure_sequence_of_iterables(val, n_channels)\n                    )\n                else:\n                    kwargs[key] = iter(ensure_iterable(val))\n\n            layer_list = []\n            for i in range(n_channels):\n                if multiscale:\n                    image = [\n                        np.take(data[j], i, axis=channel_axis)\n                        for j in range(len(data))\n                    ]\n                else:\n                    image = np.take(data, i, axis=channel_axis)\n                i_kwargs = {k: next(v) for k, v in kwargs.items()}\n                layer = self.add_layer(layers.Image(image, **i_kwargs))\n                layer_list.append(layer)\n            return layer_list\n\n    def add_points(\n        self,\n        data=None,\n        *,\n        properties=None,\n        symbol=\'o\',\n        size=10,\n        edge_width=1,\n        edge_color=\'black\',\n        edge_color_cycle=None,\n        edge_colormap=\'viridis\',\n        edge_contrast_limits=None,\n        face_color=\'white\',\n        face_color_cycle=None,\n        face_colormap=\'viridis\',\n        face_contrast_limits=None,\n        n_dimensional=False,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n    ) -> layers.Points:\n        """"""Add a points layer to the layers list.\n\n        Parameters\n        ----------\n        data : array (N, D)\n            Coordinates for N points in D dimensions.\n        properties : dict {str: array (N,)}, DataFrame\n            Properties for each point. Each property should be an array of length N,\n            where N is the number of points.\n        symbol : str\n            Symbol to be used for the point markers. Must be one of the\n            following: arrow, clobber, cross, diamond, disc, hbar, ring,\n            square, star, tailed_arrow, triangle_down, triangle_up, vbar, x.\n        size : float, array\n            Size of the point marker. If given as a scalar, all points are made\n            the same size. If given as an array, size must be the same\n            broadcastable to the same shape as the data.\n        edge_width : float\n            Width of the symbol edge in pixels.\n        edge_color : str, array-like\n            Color of the point marker border. Numeric color values should be RGB(A).\n        edge_color_cycle : np.ndarray, list\n            Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n            categorical attribute is used color the vectors.\n        edge_colormap : str, vispy.color.colormap.Colormap\n            Colormap to set edge_color if a continuous attribute is used to set face_color.\n            See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n        edge_contrast_limits : None, (float, float)\n            clims for mapping the property to a color map. These are the min and max value\n            of the specified property that are mapped to 0 and 1, respectively.\n            The default value is None. If set the none, the clims will be set to\n            (property.min(), property.max())\n        face_color : str, array-like\n            Color of the point marker body. Numeric color values should be RGB(A).\n        face_color_cycle : np.ndarray, list\n            Cycle of colors (provided as string name, RGB, or RGBA) to map to face_color if a\n            categorical attribute is used color the vectors.\n        face_colormap : str, vispy.color.colormap.Colormap\n            Colormap to set face_color if a continuous attribute is used to set face_color.\n            See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n        face_contrast_limits : None, (float, float)\n            clims for mapping the property to a color map. These are the min and max value\n            of the specified property that are mapped to 0 and 1, respectively.\n            The default value is None. If set the none, the clims will be set to\n            (property.min(), property.max())\n        n_dimensional : bool\n            If True, renders points not just in central plane but also in all\n            n-dimensions according to specified point marker size.\n        name : str\n            Name of the layer.\n        metadata : dict\n            Layer metadata.\n        scale : tuple of float\n            Scale factors for the layer.\n        translate : tuple of float\n            Translation values for the layer.\n        opacity : float\n            Opacity of the layer visual, between 0.0 and 1.0.\n        blending : str\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}.\n        visible : bool\n            Whether the layer visual is currently being displayed.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Points`\n            The newly-created points layer.\n\n        Notes\n        -----\n        See vispy\'s marker visual docs for more details:\n        http://api.vispy.org/en/latest/visuals.html#vispy.visuals.MarkersVisual\n        """"""\n        if data is None:\n            ndim = max(self.dims.ndim, 2)\n            data = np.empty([0, ndim])\n\n        layer = layers.Points(\n            data=data,\n            properties=properties,\n            symbol=symbol,\n            size=size,\n            edge_width=edge_width,\n            edge_color=edge_color,\n            edge_color_cycle=edge_color_cycle,\n            edge_colormap=edge_colormap,\n            edge_contrast_limits=edge_contrast_limits,\n            face_color=face_color,\n            face_color_cycle=face_color_cycle,\n            face_colormap=face_colormap,\n            face_contrast_limits=face_contrast_limits,\n            n_dimensional=n_dimensional,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n        self.add_layer(layer)\n        return layer\n\n    def add_labels(\n        self,\n        data,\n        *,\n        num_colors=50,\n        properties=None,\n        seed=0.5,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n        multiscale=None,\n    ) -> layers.Labels:\n        """"""Add a labels (or segmentation) layer to the layers list.\n\n        An image-like layer where every pixel contains an integer ID\n        corresponding to the region it belongs to.\n\n        Using the viewer\'s label editing tools (painting, erasing) will\n        modify the input-array in-place.\n\n        To avoid this, pass a copy as follows:\n            layer = viewer.add_labels(data.copy())\n            # do some painting/editing\n\n        Get the modified labels as follows:\n            result = layer.data\n\n        Parameters\n        ----------\n        data : array or list of array\n            Labels data as an array or multiscale.\n        num_colors : int\n            Number of unique colors to use in colormap.\n        properties : dict {str: array (N,)}, DataFrame\n            Properties for each label. Each property should be an array of length\n            N, where N is the number of labels, and the first property corresponds to\n            background.\n        seed : float\n            Seed for colormap random generator.\n        name : str\n            Name of the layer.\n        metadata : dict\n            Layer metadata.\n        scale : tuple of float\n            Scale factors for the layer.\n        translate : tuple of float\n            Translation values for the layer.\n        opacity : float\n            Opacity of the layer visual, between 0.0 and 1.0.\n        blending : str\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}.\n        visible : bool\n            Whether the layer visual is currently being displayed.\n        multiscale : bool\n            Whether the data is a multiscale image or not. Multiscale data is\n            represented by a list of array like image data. If not specified by\n            the user and if the data is a list of arrays that decrease in shape\n            then it will be taken to be multiscale. The first image in the list\n            should be the largest.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Labels`\n            The newly-created labels layer.\n        """"""\n        layer = layers.Labels(\n            data,\n            num_colors=num_colors,\n            properties=properties,\n            seed=seed,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n            multiscale=multiscale,\n        )\n        self.add_layer(layer)\n        return layer\n\n    def add_shapes(\n        self,\n        data=None,\n        *,\n        shape_type=\'rectangle\',\n        edge_width=1,\n        edge_color=\'black\',\n        face_color=\'white\',\n        z_index=0,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n    ) -> layers.Shapes:\n        """"""Add a shapes layer to the layers list.\n\n        Parameters\n        ----------\n        data : list or array\n            List of shape data, where each element is an (N, D) array of the\n            N vertices of a shape in D dimensions. Can be an 3-dimensional\n            array if each shape has the same number of vertices.\n        shape_type : string or list\n            String of shape shape_type, must be one of ""{\'line\', \'rectangle\',\n            \'ellipse\', \'path\', \'polygon\'}"". If a list is supplied it must be\n            the same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        edge_width : float or list\n            Thickness of lines and edges. If a list is supplied it must be the\n            same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        edge_color : str, array-like\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements. If a list is supplied it must be the same length as\n            the length of `data` and each element will be applied to each shape\n            otherwise the same value will be used for all shapes.\n        face_color : str, array-like\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements. If a list is supplied it must be the same length as\n            the length of `data` and each element will be applied to each shape\n            otherwise the same value will be used for all shapes.\n        z_index : int or list\n            Specifier of z order priority. Shapes with higher z order are\n            displayed ontop of others. If a list is supplied it must be the\n            same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        name : str\n            Name of the layer.\n        metadata : dict\n            Layer metadata.\n        scale : tuple of float\n            Scale factors for the layer.\n        translate : tuple of float\n            Translation values for the layer.\n        opacity : float\n            Opacity of the layer visual, between 0.0 and 1.0.\n        blending : str\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}.\n        visible : bool\n            Whether the layer visual is currently being displayed.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Shapes`\n            The newly-created shapes layer.\n        """"""\n        if data is None:\n            ndim = max(self.dims.ndim, 2)\n            data = np.empty((0, 0, ndim))\n\n        layer = layers.Shapes(\n            data=data,\n            shape_type=shape_type,\n            edge_width=edge_width,\n            edge_color=edge_color,\n            face_color=face_color,\n            z_index=z_index,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n        self.add_layer(layer)\n        return layer\n\n    def add_surface(\n        self,\n        data,\n        *,\n        colormap=\'gray\',\n        contrast_limits=None,\n        gamma=1,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n    ) -> layers.Surface:\n        """"""Add a surface layer to the layers list.\n\n        Parameters\n        ----------\n        data : 3-tuple of array\n            The first element of the tuple is an (N, D) array of vertices of\n            mesh triangles. The second is an (M, 3) array of int of indices\n            of the mesh triangles. The third element is the (K0, ..., KL, N)\n            array of values used to color vertices where the additional L\n            dimensions are used to color the same mesh with different values.\n        colormap : str, vispy.Color.Colormap, tuple, dict\n            Colormap to use for luminance images. If a string must be the name\n            of a supported colormap from vispy or matplotlib. If a tuple the\n            first value must be a string to assign as a name to a colormap and\n            the second item must be a Colormap. If a dict the key must be a\n            string to assign as a name to a colormap and the value must be a\n            Colormap.\n        contrast_limits : list (2,)\n            Color limits to be used for determining the colormap bounds for\n            luminance images. If not passed is calculated as the min and max of\n            the image.\n        gamma : float\n            Gamma correction for determining colormap linearity. Defaults to 1.\n        name : str\n            Name of the layer.\n        metadata : dict\n            Layer metadata.\n        scale : tuple of float\n            Scale factors for the layer.\n        translate : tuple of float\n            Translation values for the layer.\n        opacity : float\n            Opacity of the layer visual, between 0.0 and 1.0.\n        blending : str\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}.\n        visible : bool\n            Whether the layer visual is currently being displayed.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Surface`\n            The newly-created surface layer.\n        """"""\n        layer = layers.Surface(\n            data,\n            colormap=colormap,\n            contrast_limits=contrast_limits,\n            gamma=gamma,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n        self.add_layer(layer)\n        return layer\n\n    def add_vectors(\n        self,\n        data,\n        *,\n        properties=None,\n        edge_width=1,\n        edge_color=\'red\',\n        edge_color_cycle=None,\n        edge_colormap=\'viridis\',\n        edge_contrast_limits=None,\n        length=1,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n    ) -> layers.Vectors:\n        """"""Add a vectors layer to the layers list.\n\n        Parameters\n        ----------\n        data : (N, 2, D) or (N1, N2, ..., ND, D) array\n            An (N, 2, D) array is interpreted as ""coordinate-like"" data and a\n            list of N vectors with start point and projections of the vector in\n            D dimensions. An (N1, N2, ..., ND, D) array is interpreted as\n            ""image-like"" data where there is a length D vector of the\n            projections at each pixel.\n        properties : dict {str: array (N,)}, DataFrame\n            Properties for each vector. Each property should be an array of length N,\n            where N is the number of vectors.\n        edge_width : float\n            Width for all vectors in pixels.\n        length : float\n             Multiplicative factor on projections for length of all vectors.\n        edge_color : str\n            Color of all of the vectors.\n        edge_color_cycle : np.ndarray, list\n            Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n            categorical attribute is used color the vectors.\n        edge_colormap : str, vispy.color.colormap.Colormap\n            Colormap to set vector color if a continuous attribute is used to set edge_color.\n            See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n        edge_contrast_limits : None, (float, float)\n            clims for mapping the property to a color map. These are the min and max value\n            of the specified property that are mapped to 0 and 1, respectively.\n            The default value is None. If set the none, the clims will be set to\n            (property.min(), property.max())\n        name : str\n            Name of the layer.\n        metadata : dict\n            Layer metadata.\n        scale : tuple of float\n            Scale factors for the layer.\n        translate : tuple of float\n            Translation values for the layer.\n        opacity : float\n            Opacity of the layer visual, between 0.0 and 1.0.\n        blending : str\n            One of a list of preset blending modes that determines how RGB and\n            alpha values of the layer visual get mixed. Allowed values are\n            {\'opaque\', \'translucent\', and \'additive\'}.\n        visible : bool\n            Whether the layer visual is currently being displayed.\n\n        Returns\n        -------\n        layer : :class:`napari.layers.Vectors`\n            The newly-created vectors layer.\n        """"""\n        layer = layers.Vectors(\n            data,\n            properties=properties,\n            edge_width=edge_width,\n            edge_color=edge_color,\n            edge_color_cycle=edge_color_cycle,\n            edge_colormap=edge_colormap,\n            edge_contrast_limits=edge_contrast_limits,\n            length=length,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n        self.add_layer(layer)\n        return layer\n\n    def open(\n        self,\n        path: Union[str, Sequence[str]],\n        stack: bool = False,\n        plugin: Optional[str] = None,\n        layer_type: Optional[str] = None,\n        **kwargs,\n    ) -> List[layers.Layer]:\n        """"""Open a path or list of paths with plugins, and add layers to viewer.\n\n        A list of paths will be handed one-by-one to the napari_get_reader hook\n        if stack is False, otherwise the full list is passed to each plugin\n        hook.\n\n        Parameters\n        ----------\n        path : str or list of str\n            A filepath, directory, or URL (or a list of any) to open.\n        stack : bool, optional\n            If a list of strings is passed and ``stack`` is ``True``, then the\n            entire list will be passed to plugins.  It is then up to individual\n            plugins to know how to handle a list of paths.  If ``stack`` is\n            ``False``, then the ``path`` list is broken up and passed to plugin\n            readers one by one.  by default False.\n        plugin : str, optional\n            Name of a plugin to use.  If provided, will force ``path`` to be\n            read with the specified ``plugin``.  If the requested plugin cannot\n            read ``path``, an execption will be raised.\n        layer_type : str, optional\n            If provided, will force data read from ``path`` to be passed to the\n            corresponding ``add_<layer_type>`` method (along with any\n            additional) ``kwargs`` provided to this function.  This *may*\n            result in exceptions if the data returned from the path is not\n            compatible with the layer_type.\n        **kwargs\n            All other keyword arguments will be passed on to the respective\n            ``add_layer`` method.\n\n        Returns\n        -------\n        layers : list\n            A list of any layers that were added to the viewer.\n        """"""\n        paths = [path] if isinstance(path, str) else path\n        paths = [os.fspath(path) for path in paths]  # PathObjects -> str\n        if not isinstance(paths, (tuple, list)):\n            raise ValueError(\n                ""\'path\' argument must be a string, list, or tuple""\n            )\n\n        if stack:\n            return self._add_layers_with_plugins(\n                paths, kwargs, plugin=plugin, layer_type=layer_type\n            )\n\n        added: List[layers.Layer] = []  # for layers that get added\n        for _path in paths:\n            added.extend(\n                self._add_layers_with_plugins(\n                    _path, kwargs, plugin=plugin, layer_type=layer_type\n                )\n            )\n\n        return added\n\n    def _add_layers_with_plugins(\n        self,\n        path_or_paths: Union[str, Sequence[str]],\n        kwargs: Optional[dict] = None,\n        plugin: Optional[str] = None,\n        layer_type: Optional[str] = None,\n    ) -> List[layers.Layer]:\n        """"""Load a path or a list of paths into the viewer using plugins.\n\n        This function is mostly called from self.open_path, where the ``stack``\n        argument determines whether a list of strings is handed to plugins one\n        at a time, or en-masse.\n\n        Parameters\n        ----------\n        path_or_paths : str or list of str\n            A filepath, directory, or URL (or a list of any) to open. If a\n            list, the assumption is that the list is to be treated as a stack.\n        kwargs : dict, optional\n            keyword arguments that will be used to overwrite any of those that\n            are returned in the meta dict from plugins.\n        plugin : str, optional\n            Name of a plugin to use.  If provided, will force ``path`` to be\n            read with the specified ``plugin``.  If the requested plugin cannot\n            read ``path``, an execption will be raised.\n        layer_type : str, optional\n            If provided, will force data read from ``path`` to be passed to the\n            corresponding ``add_<layer_type>`` method (along with any\n            additional) ``kwargs`` provided to this function.  This *may*\n            result in exceptions if the data returned from the path is not\n            compatible with the layer_type.\n\n        Returns\n        -------\n        List[layers.Layer]\n            A list of any layers that were added to the viewer.\n        """"""\n        layer_data = read_data_with_plugins(path_or_paths, plugin=plugin)\n\n        # glean layer names from filename. These will be used as *fallback*\n        # names, if the plugin does not return a name kwarg in their meta dict.\n        if isinstance(path_or_paths, str):\n            filenames = itertools.repeat(path_or_paths)\n        elif is_sequence(path_or_paths):\n            if len(path_or_paths) == len(layer_data):\n                filenames = iter(path_or_paths)\n            else:\n                # if a list of paths has been returned as a list of layer data\n                # without a 1:1 relationship between the two lists we iterate\n                # over the first name\n                filenames = itertools.repeat(path_or_paths[0])\n\n        # add each layer to the viewer\n        added: List[layers.Layer] = []  # for layers that get added\n        for data, filename in zip(layer_data, filenames):\n            basename, ext = os.path.splitext(os.path.basename(filename))\n            _data = _unify_data_and_user_kwargs(\n                data, kwargs, layer_type, fallback_name=basename\n            )\n            # actually add the layer\n            new = self._add_layer_from_data(*_data)\n            # some add_* methods return a List[Layer], others just a Layer\n            # we want to always return a list\n            added.extend(new if isinstance(new, list) else [new])\n        return added\n\n    def _add_layer_from_data(\n        self, data, meta: dict = None, layer_type: Optional[str] = None\n    ) -> Union[layers.Layer, List[layers.Layer]]:\n        """"""Add arbitrary layer data to the viewer.\n\n        Primarily intended for usage by reader plugin hooks.\n\n        Parameters\n        ----------\n        data : Any\n            Data in a format that is valid for the corresponding `add_*` method\n            of the specified ``layer_type``.\n        meta : dict, optional\n            Dict of keyword arguments that will be passed to the corresponding\n            `add_*` method.  MUST NOT contain any keyword arguments that are\n            not valid for the corresponding method.\n        layer_type : str\n            Type of layer to add.  MUST have a corresponding add_* method on\n            on the viewer instance.  If not provided, the layer is assumed to\n            be ""image"", unless data.dtype is one of (np.int32, np.uint32,\n            np.int64, np.uint64), in which case it is assumed to be ""labels"".\n\n        Raises\n        ------\n        ValueError\n            If ``layer_type`` is not one of the recognized layer types.\n        TypeError\n            If any keyword arguments in ``meta`` are unexpected for the\n            corresponding `add_*` method for this layer_type.\n\n        Examples\n        --------\n        A typical use case might be to upack a tuple of layer data with a\n        specified layer_type.\n\n        >>> viewer = napari.Viewer()\n        >>> data = (\n        ...     np.random.random((10, 2)) * 20,\n        ...     {\'face_color\': \'blue\'},\n        ...     \'points\',\n        ... )\n        >>> viewer._add_layer_from_data(*data)\n\n        """"""\n\n        layer_type = (layer_type or \'\').lower()\n\n        # assumes that big integer type arrays are likely labels.\n        if not layer_type:\n            layer_type = guess_labels(data)\n\n        if layer_type not in layers.NAMES:\n            raise ValueError(\n                f""Unrecognized layer_type: \'{layer_type}\'. ""\n                f""Must be one of: {layers.NAMES}.""\n            )\n\n        try:\n            add_method = getattr(self, \'add_\' + layer_type)\n        except AttributeError:\n            raise NotImplementedError(\n                f""Sorry! {layer_type} is a valid layer type, but there is no ""\n                f""viewer.add_{layer_type} available yet.""\n            )\n\n        try:\n            layer = add_method(data, **(meta or {}))\n        except TypeError as exc:\n            if \'unexpected keyword argument\' in str(exc):\n                bad_key = str(exc).split(\'keyword argument \')[-1]\n                raise TypeError(\n                    ""_add_layer_from_data received an unexpected keyword ""\n                    f""argument ({bad_key}) for layer type {layer_type}""\n                ) from exc\n            else:\n                raise exc\n\n        return layer\n\n\n@lru_cache(maxsize=1)\ndef valid_add_kwargs() -> Dict[str, Set[str]]:\n    """"""Return a dict where keys are layer types & values are valid kwargs.""""""\n    valid = dict()\n    for meth in dir(AddLayersMixin):\n        if not meth.startswith(\'add_\') or meth[4:] == \'layer\':\n            continue\n        params = inspect.signature(getattr(AddLayersMixin, meth)).parameters\n        valid[meth[4:]] = set(params) - {\'self\', \'kwargs\'}\n    return valid\n\n\ndef _normalize_layer_data(data: LayerData) -> FullLayerData:\n    """"""Accepts any layerdata tuple, and returns a fully qualified tuple.\n\n    Parameters\n    ----------\n    data : LayerData\n        1-, 2-, or 3-tuple with (data, meta, layer_type).\n\n    Returns\n    -------\n    FullLayerData\n        3-tuple with (data, meta, layer_type)\n\n    Raises\n    ------\n    ValueError\n        If data has len < 1 or len > 3, or if the second item in ``data`` is\n        not a ``dict``, or the third item is not a valid layer_type ``str``\n    """"""\n    if not isinstance(data, tuple) and 0 < len(data) < 4:\n        raise ValueError(""LayerData must be a 1-, 2-, or 3-tuple"")\n    _data = list(data)\n    if len(_data) > 1:\n        if not isinstance(_data[1], dict):\n            raise ValueError(\n                ""The second item in a LayerData tuple must be a dict""\n            )\n    else:\n        _data.append(dict())\n    if len(_data) > 2:\n        if _data[2] not in layers.NAMES:\n            raise ValueError(\n                ""The third item in a LayerData tuple must be one of: ""\n                f""{layers.NAMES!r}.""\n            )\n    else:\n        _data.append(guess_labels(_data[0]))\n    return tuple(_data)  # type: ignore\n\n\ndef _unify_data_and_user_kwargs(\n    data: LayerData,\n    kwargs: Optional[dict] = None,\n    layer_type: Optional[str] = None,\n    fallback_name: str = None,\n) -> FullLayerData:\n    """"""Merge data returned from plugins with options specified by user.\n\n    If ``data == (_data, _meta, _type)``.  Then:\n\n    - ``kwargs`` will be used to update ``_meta``\n    - ``layer_type`` will replace ``_type`` and, if provided, ``_meta`` keys\n        will be pruned to layer_type-appropriate kwargs\n    - ``fallback_name`` is used if ``not _meta.get(\'name\')``\n\n    .. note:\n\n        If a user specified both layer_type and additional keyword arguments\n        to viewer.open(), it is their responsibility to make sure the kwargs\n        match the layer_type.\n\n    Parameters\n    ----------\n    data : LayerData\n        1-, 2-, or 3-tuple with (data, meta, layer_type) returned from plugin.\n    kwargs : dict, optional\n        User-supplied keyword arguments, to override those in ``meta`` supplied\n        by plugins.\n    layer_type : str, optional\n        A user-supplied layer_type string, to override the ``layer_type``\n        declared by the plugin.\n    fallback_name : str, optional\n        A name for the layer, to override any name in ``meta`` supplied by the\n        plugin.\n\n    Returns\n    -------\n    FullLayerData\n        Fully qualified LayerData tuple with user-provided overrides.\n    """"""\n    _data, _meta, _type = _normalize_layer_data(data)\n\n    if layer_type:\n        # the user has explicitly requested this be a certain layer type\n        # strip any kwargs from the plugin that are no longer relevant\n        _meta = prune_kwargs(_meta, layer_type)\n        _type = layer_type\n\n    if kwargs:\n        # if user provided kwargs, use to override any meta dict values that\n        # were returned by the plugin. We only prune kwargs if the user did\n        # *not* specify the layer_type. This means that if a user specified\n        # both layer_type and additional keyword arguments to viewer.open(),\n        # it is their responsibility to make sure the kwargs match the\n        # layer_type.\n        _meta.update(prune_kwargs(kwargs, _type) if not layer_type else kwargs)\n\n    if not _meta.get(\'name\') and fallback_name:\n        _meta[\'name\'] = fallback_name\n    return (_data, _meta, _type)\n\n\ndef prune_kwargs(kwargs: Dict[str, Any], layer_type: str) -> Dict[str, Any]:\n    """"""Return copy of ``kwargs`` with only keys valid for ``add_<layer_type>``\n\n    Parameters\n    ----------\n    kwargs : dict\n        A key: value mapping where some or all of the keys are parameter names\n        for the corresponding ``Viewer.add_<layer_type>`` method.\n    layer_type : str\n        The type of layer that is going to be added with these ``kwargs``.\n\n    Returns\n    -------\n    pruned_kwargs : dict\n        A key: value mapping where all of the keys are valid parameter names\n        for the corresponding ``Viewer.add_<layer_type>`` method.\n\n    Raises\n    ------\n    ValueError\n        If ``AddLayersMixin`` does not provide an ``add_<layer_type>`` method\n        for the provided ``layer_type``.\n\n    Examples\n    --------\n    >>> test_kwargs = {\n            \'scale\': (0.75, 1),\n            \'blending\': \'additive\',\n            \'num_colors\': 10,\n        }\n    >>> prune_kwargs(test_kwargs, \'image\')\n    {\'scale\': (0.75, 1), \'blending\': \'additive\'}\n\n    >>> # only labels has the ``num_colors`` argument\n    >>> prune_kwargs(test_kwargs, \'labels\')\n    {\'scale\': (0.75, 1), \'blending\': \'additive\', \'num_colors\': 10}\n    """"""\n    add_method = getattr(AddLayersMixin, \'add_\' + layer_type, None)\n    if not add_method or layer_type == \'layer\':\n        raise ValueError(f""Invalid layer_type: {layer_type}"")\n\n    # get valid params for the corresponding add_<layer_type> method\n    valid = valid_add_kwargs()[layer_type]\n    return {k: v for k, v in kwargs.items() if k in valid}\n'"
napari/components/dims.py,10,"b'from copy import copy\nfrom typing import Union, Sequence\nimport numpy as np\n\nfrom .dims_constants import DimsMode\nfrom ..utils.event import EmitterGroup\n\n\nclass Dims:\n    """"""Dimensions object modeling slicing and displaying.\n\n    Parameters\n    ----------\n    ndim : int, optional\n        Number of dimensions\n    ndisplay : int, optional\n        Number of displayed dimensions.\n    order : list of int, optional\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels : list of str, optional\n        Dimension names\n\n    Attributes\n    ----------\n    events : EmitterGroup\n        Event emitter group\n    range : list of 3-tuple\n        List of tuples (min, max, step), one for each dimension\n    point : list of float\n        List of floats setting the current value of the range slider when in\n        POINT mode, one for each dimension\n    interval : list of 2-tuple\n        List of tuples (min, max) setting the current selection of the range\n        slider when in INTERVAL mode, one for each dimension\n    mode : list of DimsMode\n        List of DimsMode, one for each dimension\n    clip : bool\n        Flag if to clip indices based on range. Needed for image-like\n        layers, but prevents shape-like layers from adding new shapes\n        outside their range.\n    ndim : int\n        Number of dimensions.\n    indices : tuple of slice object\n        Tuple of slice objects for slicing arrays on each dimension, one for\n        each dimension\n    displayed : tuple\n        List of dimensions that are displayed.\n    not_displayed : tuple\n        List of dimensions that are not displayed.\n    displayed_order : tuple\n        Order of only displayed dimensions.\n    """"""\n\n    def __init__(self, ndim=None, *, ndisplay=2, order=None, axis_labels=None):\n        super().__init__()\n\n        # Events:\n        self.events = EmitterGroup(\n            source=self,\n            auto_connect=True,\n            axis=None,\n            axis_labels=None,\n            ndim=None,\n            ndisplay=None,\n            order=None,\n            range=None,\n            camera=None,\n        )\n        self._range = []\n        self._point = []\n        self._interval = []\n        self._mode = []\n        self._order = []\n        self._axis_labels = []\n        self.clip = True\n        self._ndisplay = 2 if ndisplay is None else ndisplay\n\n        if ndim is None and order is None and axis_labels is None:\n            ndim = self._ndisplay\n        elif ndim is None and order is None:\n            ndim = len(axis_labels)\n        elif ndim is None and axis_labels is None:\n            ndim = len(order)\n        self.ndim = ndim\n\n        if order is not None:\n            if len(order) != ndim:\n                raise ValueError(\n                    f""Length of order must be identical to ndim.""\n                    f"" ndim is {ndim} while order is {order}.""\n                )\n            self._order = order\n        if axis_labels is not None:\n            if len(axis_labels) != ndim:\n                raise ValueError(\n                    f""Length of axis labels must be identical to ndim.""\n                    f"" ndim is {ndim} while axis labels is {axis_labels}.""\n                )\n            self._axis_labels = list(axis_labels)\n\n    def __str__(self):\n        return ""~~"".join(\n            map(\n                str,\n                [\n                    self.range,\n                    self.point,\n                    self.interval,\n                    self.mode,\n                    self.order,\n                    self.axis_labels,\n                ],\n            )\n        )\n\n    @property\n    def range(self):\n        """"""List of 3-tuple: (min, max, step size) of each dimension.\n        """"""\n        return copy(self._range)\n\n    @property\n    def max_indices(self):\n        """"""Maximum index for each dimension (in data space).\n        """"""\n        return [((ma - st) // st) for mi, ma, st in self._range]\n\n    @property\n    def point(self):\n        """"""List of int: value of each dimension if in POINT mode.""""""\n        return copy(self._point)\n\n    @property\n    def interval(self):\n        """"""List of 2-tuple: (min, max) of each dimension if in INTERVAL mode.\n        """"""\n        return copy(self._interval)\n\n    @property\n    def mode(self):\n        """"""List of DimsMode: List of DimsMode, one for each dimension.""""""\n        return copy(self._mode)\n\n    @property\n    def axis_labels(self):\n        """"""List of labels for each axis.""""""\n        return copy(self._axis_labels)\n\n    @axis_labels.setter\n    def axis_labels(self, labels):\n        if self._axis_labels == labels:\n            return\n\n        if len(labels) != self.ndim:\n            raise ValueError(\n                f""Number of labels doesn\'t match number of dimensions. Number""\n                f"" of given labels was {len(labels)}, number of dimensions is""\n                f"" {self.ndim}. Note: If you wish to keep some of the ""\n                ""dimensions unlabeled, use \'\' instead.""\n            )\n\n        self._axis_labels = list(labels)\n        for axis in range(self.ndim):\n            self.events.axis_labels(axis=axis)\n\n    @property\n    def order(self):\n        """"""List of int: Display order of dimensions.""""""\n        return copy(self._order)\n\n    @order.setter\n    def order(self, order):\n        if np.all(self._order == order):\n            return\n\n        if not len(order) == self.ndim:\n            raise ValueError(\n                f""Invalid ordering {order} for {self.ndim} dimensions""\n            )\n\n        self._order = order\n        self.events.order()\n        self.events.camera()\n\n    @property\n    def ndim(self):\n        """"""Returns the number of dimensions.\n\n        Returns\n        -------\n        ndim : int\n            Number of dimensions\n        """"""\n        return len(self.point)\n\n    @ndim.setter\n    def ndim(self, ndim):\n        cur_ndim = self.ndim\n        if cur_ndim == ndim:\n            return\n        elif ndim > cur_ndim:\n            # Range value is (min, max, step) for the entire slider\n            self._range = [(0, 2, 1)] * (ndim - cur_ndim) + self._range\n            # Point is the slider value if in point mode\n            self._point = [0] * (ndim - cur_ndim) + self._point\n            # Interval value is the (min, max) of the slider selction\n            # if in interval mode\n            self._interval = [(0, 1)] * (ndim - cur_ndim) + self._interval\n            self._mode = [DimsMode.POINT] * (ndim - cur_ndim) + self._mode\n            self._order = list(range(ndim - cur_ndim)) + [\n                o + ndim - cur_ndim for o in self.order\n            ]\n            # Append new ""default"" labels to existing ones\n            if self._axis_labels == list(map(str, range(cur_ndim))):\n                self._axis_labels = list(map(str, range(ndim)))\n            else:\n                self._axis_labels = (\n                    list(map(str, range(ndim - cur_ndim))) + self._axis_labels\n                )\n\n            # Notify listeners that the number of dimensions have changed\n            self.events.ndim()\n\n            # Notify listeners of which dimensions have been affected\n            for axis_changed in range(ndim - cur_ndim):\n                self.events.axis(axis=axis_changed)\n        elif ndim < cur_ndim:\n            self._range = self._range[-ndim:]\n            self._point = self._point[-ndim:]\n            self._interval = self._interval[-ndim:]\n            self._mode = self._mode[-ndim:]\n            self._order = self._reorder_after_dim_reduction(\n                self._order[-ndim:]\n            )\n            self._axis_labels = self._axis_labels[-ndim:]\n\n            # Notify listeners that the number of dimensions have changed\n            self.events.ndim()\n\n    def _reorder_after_dim_reduction(self, order):\n        """"""Ensure current dimension order is preserved after dims are dropped.\n\n        Parameters\n        ----------\n        order : list-like\n            The data to reorder.\n\n        Returns\n        -------\n        arr : list\n            The original array with the unneeded dimension\n            thrown away.\n        """"""\n        arr = np.array(order)\n        arr[np.argsort(arr)] = range(len(arr))\n        return arr.tolist()\n\n    @property\n    def indices(self):\n        """"""Tuple of slice objects for slicing arrays on each dimension.""""""\n        slice_list = []\n        for axis in range(self.ndim):\n            if axis in self.displayed:\n                slice_list.append(slice(None))\n            else:\n                if self.clip:\n                    p = np.clip(\n                        self.point[axis],\n                        np.round(self.range[axis][0]),\n                        np.round(self.range[axis][1]) - 1,\n                    )\n                else:\n                    p = self.point[axis]\n                p = np.round(p / self.range[axis][2]).astype(int)\n                slice_list.append(p)\n        return tuple(slice_list)\n\n    @property\n    def ndisplay(self):\n        """"""Int: Number of displayed dimensions.""""""\n        return self._ndisplay\n\n    @ndisplay.setter\n    def ndisplay(self, ndisplay):\n        if self._ndisplay == ndisplay:\n            return\n\n        if ndisplay not in (2, 3):\n            raise ValueError(\n                f""Invalid number of dimensions to be displayed {ndisplay}""\n            )\n\n        self._ndisplay = ndisplay\n        self.events.ndisplay()\n        self.events.camera()\n\n    @property\n    def displayed(self):\n        """"""Tuple: Dimensions that are displayed.""""""\n        return self.order[-self.ndisplay :]\n\n    @property\n    def not_displayed(self):\n        """"""Tuple: Dimensions that are not displayed.""""""\n        return self.order[: -self.ndisplay]\n\n    @property\n    def displayed_order(self):\n        """"""Tuple: Order of only displayed dimensions.""""""\n        order = np.array(self.displayed)\n        order[np.argsort(order)] = list(range(len(order)))\n        return tuple(order)\n\n    def reset(self):\n        """"""Reset dims values to initial states.""""""\n        for axis in range(self.ndim):\n            # Range value is (min, max, step) for the entire slider\n            self._range[axis] = (0, 2, 1)\n            # Point is the slider value if in point mode\n            self._point[axis] = 0\n            # Interval value is the (min, max) of the slider selction\n            # if in interval mode\n            self._interval[axis] = (0, 1)\n            self._mode[axis] = DimsMode.POINT\n            self._order[axis] = axis\n            # Default axis labels go from ""-ndim"" to ""-1"" so new axes can easily be added\n            self._axis_labels[axis] = str(axis - self.ndim)\n\n    def set_range(self, axis: int, _range: Sequence[Union[int, float]]):\n        """"""Sets the range (min, max, step) for a given dimension.\n\n        Parameters\n        ----------\n        axis : int\n            Dimension index.\n        range : tuple\n            Range specified as (min, max, step).\n        """"""\n        axis = self._assert_axis_in_bounds(axis)\n        if self.range[axis] != _range:\n            self._range[axis] = _range\n            self.events.range(axis=axis)\n\n    def set_point(self, axis: int, value: Union[int, float]):\n        """"""Sets the point at which to slice this dimension.\n\n        Parameters\n        ----------\n        axis : int\n            Dimension index.\n        value : int or float\n            Value of the point.\n        """"""\n        axis = self._assert_axis_in_bounds(axis)\n        if self.point[axis] != value:\n            self._point[axis] = value\n            self.events.axis(axis=axis, value=value)\n\n    def set_interval(self, axis: int, interval: Sequence[Union[int, float]]):\n        """"""Sets the interval used for cropping and projecting this dimension.\n\n        Parameters\n        ----------\n        axis : int\n            Dimension index.\n        interval : tuple\n            INTERVAL specified with (min, max).\n        """"""\n        axis = self._assert_axis_in_bounds(axis)\n        if self.interval[axis] != interval:\n            self._interval[axis] = interval\n            self.events.axis(axis=axis)\n\n    def set_mode(self, axis: int, mode: DimsMode):\n        """"""Sets the mode: POINT or INTERVAL.\n\n        Parameters\n        ----------\n        axis : int\n            Dimension index.\n        mode : POINT or INTERVAL\n            Whether dimension is in the POINT or INTERVAL mode.\n        """"""\n        axis = self._assert_axis_in_bounds(axis)\n        if self.mode[axis] != mode:\n            self._mode[axis] = mode\n            self.events.axis(axis=axis)\n\n    def set_axis_label(self, axis: int, label: str):\n        """"""Sets a new axis label for the given axis.\n\n        Parameters\n        ----------\n        axis : int\n            Dimension index\n        label : str\n            Given label\n        """"""\n        axis = self._assert_axis_in_bounds(axis)\n        if self.axis_labels[axis] != str(label):\n            self._axis_labels[axis] = str(label)\n            self.events.axis_labels(axis=axis)\n\n    def _assert_axis_in_bounds(self, axis: int) -> int:\n        """"""Assert a given value is inside the existing axes of the image.\n\n        Returns\n        -------\n        axis : int\n            The axis which was checked for validity.\n\n        Raises\n        ------\n        ValueError\n            The given axis index is out of bounds.\n        """"""\n        if axis not in range(-self.ndim, self.ndim):\n            msg = (\n                f\'Axis {axis} not defined for dimensionality {self.ndim}. \'\n                f\'Must be in [{-self.ndim}, {self.ndim}).\'\n            )\n            raise ValueError(msg)\n\n        return axis % self.ndim\n\n    def _roll(self):\n        """"""Roll order of dimensions for display.""""""\n        self.order = np.roll(self.order, 1)\n\n    def _transpose(self):\n        """"""Transpose displayed dimensions.""""""\n        order = copy(self.order)\n        order[-2], order[-1] = order[-1], order[-2]\n        self.order = order\n'"
napari/components/dims_constants.py,0,b'from enum import Enum\n\n\nclass DimsMode(Enum):\n    POINT = 0\n    INTERVAL = 1\n'
napari/components/layerlist.py,0,"b'from typing import Optional, List\nfrom ..layers import Layer\nfrom ..utils.naming import inc_name_count\nfrom ..utils.list import ListModel\n\n\ndef _add(event):\n    """"""When a layer is added, set its name.""""""\n    layers = event.source\n    layer = event.item\n    layer.name = layers._coerce_name(layer.name, layer)\n    layer.events.name.connect(lambda e: layers._update_name(e))\n    layers.unselect_all(ignore=layer)\n\n\nclass LayerList(ListModel):\n    """"""List-like layer collection with built-in reordering and callback hooks.\n\n    Parameters\n    ----------\n    iterable : iterable\n        Iterable of napari.layer.Layer\n\n    Attributes\n    ----------\n    events : vispy.util.event.EmitterGroup\n        Event hooks:\n            * added(item, index): whenever an item is added\n            * removed(item): whenever an item is removed\n            * reordered(): whenever the list is reordered\n    """"""\n\n    def __init__(self, iterable=()):\n        super().__init__(\n            basetype=Layer,\n            iterable=iterable,\n            lookup={str: lambda q, e: q == e.name},\n        )\n\n        self.events.added.connect(_add)\n\n    def __newlike__(self, iterable):\n        return ListModel(self._basetype, iterable, self._lookup)\n\n    def _coerce_name(self, name, layer=None):\n        """"""Coerce a name into a unique equivalent.\n\n        Parameters\n        ----------\n        name : str\n            Original name.\n        layer : napari.layers.Layer, optional\n            Layer for which name is generated.\n\n        Returns\n        -------\n        new_name : str\n            Coerced, unique name.\n        """"""\n        for l in self:\n            if l is layer:\n                continue\n            if l.name == name:\n                name = inc_name_count(name)\n\n        return name\n\n    def _update_name(self, event):\n        """"""Coerce name of the layer in `event.layer`.""""""\n        layer = event.source\n        layer.name = self._coerce_name(layer.name, layer)\n\n    @property\n    def selected(self):\n        """"""List of selected layers.""""""\n        return [layer for layer in self if layer.selected]\n\n    def move_selected(self, index, insert):\n        """"""Reorder list by moving the item at index and inserting it\n        at the insert index. If additional items are selected these will\n        get inserted at the insert index too. This allows for rearranging\n        the list based on dragging and dropping a selection of items, where\n        index is the index of the primary item being dragged, and insert is\n        the index of the drop location, and the selection indicates if\n        multiple items are being dragged. If the moved layer is not selected\n        select it.\n\n        Parameters\n        ----------\n        index : int\n            Index of primary item to be moved\n        insert : int\n            Index that item(s) will be inserted at\n        """"""\n        total = len(self)\n        indices = list(range(total))\n        if not self[index].selected:\n            self.unselect_all()\n            self[index].selected = True\n        selected = [i for i in range(total) if self[i].selected]\n\n        # remove all indices to be moved\n        for i in selected:\n            indices.remove(i)\n        # adjust offset based on selected indices to move\n        offset = sum([i < insert and i != index for i in selected])\n        # insert indices to be moved at correct start\n        for insert_idx, elem_idx in enumerate(selected, start=insert - offset):\n            indices.insert(insert_idx, elem_idx)\n        # reorder list\n        self[:] = self[tuple(indices)]\n\n    def unselect_all(self, ignore=None):\n        """"""Unselects all layers expect any specified in ignore.\n\n        Parameters\n        ----------\n        ignore : Layer | None\n            Layer that should not be unselected if specified.\n        """"""\n        for layer in self:\n            if layer.selected and layer != ignore:\n                layer.selected = False\n\n    def select_all(self):\n        """"""Selects all layers.""""""\n        for layer in self:\n            if not layer.selected:\n                layer.selected = True\n\n    def remove_selected(self):\n        """"""Removes selected items from list.""""""\n        to_delete = []\n        for i in range(len(self)):\n            if self[i].selected:\n                to_delete.append(i)\n        to_delete.reverse()\n        for i in to_delete:\n            self.pop(i)\n        if len(to_delete) > 0:\n            first_to_delete = to_delete[-1]\n            if first_to_delete == 0 and len(self) > 0:\n                self[0].selected = True\n            elif first_to_delete > 0:\n                self[first_to_delete - 1].selected = True\n\n    def select_next(self, shift=False):\n        """"""Selects next item from list.\n        """"""\n        selected = []\n        for i in range(len(self)):\n            if self[i].selected:\n                selected.append(i)\n        if len(selected) > 0:\n            if selected[-1] == len(self) - 1:\n                if shift is False:\n                    self.unselect_all(ignore=self[selected[-1]])\n            elif selected[-1] < len(self) - 1:\n                if shift is False:\n                    self.unselect_all(ignore=self[selected[-1] + 1])\n                self[selected[-1] + 1].selected = True\n        elif len(self) > 0:\n            self[-1].selected = True\n\n    def select_previous(self, shift=False):\n        """"""Selects previous item from list.\n        """"""\n        selected = []\n        for i in range(len(self)):\n            if self[i].selected:\n                selected.append(i)\n        if len(selected) > 0:\n            if selected[0] == 0:\n                if shift is False:\n                    self.unselect_all(ignore=self[0])\n            elif selected[0] > 0:\n                if shift is False:\n                    self.unselect_all(ignore=self[selected[0] - 1])\n                self[selected[0] - 1].selected = True\n        elif len(self) > 0:\n            self[0].selected = True\n\n    def toggle_selected_visibility(self):\n        """"""Toggle visibility of selected layers""""""\n        for layer in self:\n            if layer.selected:\n                layer.visible = not layer.visible\n\n    def save(\n        self,\n        path: str,\n        *,\n        selected: bool = False,\n        plugin: Optional[str] = None,\n    ) -> List[str]:\n        """"""Save all or only selected layers to a path using writer plugins.\n\n        If ``plugin`` is not provided and only one layer is targeted, then we\n        directly call the corresponding``napari_write_<layer_type>`` hook (see\n        :ref:`single layer writer hookspecs <write-single-layer-hookspecs>`)\n        which will loop through implementations and stop when the first one\n        returns a non-``None`` result. The order in which implementations are\n        called can be changed with the Plugin sorter in the GUI or with the\n        corresponding hook\'s\n        :meth:`~napari.plugins._hook_callers._HookCaller.bring_to_front`\n        method.\n\n        If ``plugin`` is not provided and multiple layers are targeted,\n        then we call\n        :meth:`~napari.plugins.hook_specifications.napari_get_writer` which\n        loops through plugins to find the first one that knows how to handle\n        the combination of layers and is able to write the file. If no plugins\n        offer :meth:`~napari.plugins.hook_specifications.napari_get_writer` for\n        that combination of layers then the default\n        :meth:`~napari.plugins.hook_specifications.napari_get_writer` will\n        create a folder and call ``napari_write_<layer_type>`` for each layer\n        using the ``Layer.name`` variable to modify the path such that the\n        layers are written to unique files in the folder.\n\n        If ``plugin`` is provided and a single layer is targeted, then we\n        call the ``napari_write_<layer_type>`` for that plugin, and if it fails\n        we error.\n\n        If ``plugin`` is provided and multiple layers are targeted, then\n        we call we call\n        :meth:`~napari.plugins.hook_specifications.napari_get_writer` for\n        that plugin, and if it doesn\xe2\x80\x99t return a ``WriterFunction`` we error,\n        otherwise we call it and if that fails if it we error.\n\n        Parameters\n        ----------\n        path : str\n            A filepath, directory, or URL to open.  Extensions may be used to\n            specify output format (provided a plugin is avaiable for the\n            requested format).\n        selected : bool\n            Optional flag to only save selected layers. False by default.\n        plugin : str, optional\n            Name of the plugin to use for saving. If None then all plugins\n            corresponding to appropriate hook specification will be looped\n            through to find the first one that can save the data.\n\n        Returns\n        -------\n        list of str\n            File paths of any files that were written.\n        """"""\n        from ..plugins.io import save_layers\n\n        layers = self.selected if selected else list(self)\n\n        if not layers:\n            import warnings\n\n            warnings.warn(f""No layers {\'selected\' if selected else \'to save\'}"")\n            return []\n\n        return save_layers(path, layers, plugin=plugin)\n'"
napari/components/viewer_model.py,16,"b'from math import inf\nimport itertools\nimport numpy as np\n\nfrom .add_layers_mixin import AddLayersMixin\nfrom .dims import Dims\nfrom .layerlist import LayerList\nfrom ..utils.event import EmitterGroup, Event\nfrom ..utils.key_bindings import KeymapHandler, KeymapProvider\nfrom ..utils.theme import palettes\n\n\nclass ViewerModel(AddLayersMixin, KeymapHandler, KeymapProvider):\n    """"""Viewer containing the rendered scene, layers, and controlling elements\n    including dimension sliders, and control bars for color limits.\n\n    Parameters\n    ----------\n    title : string\n        The title of the viewer window.\n    ndisplay : {2, 3}\n        Number of displayed dimensions.\n    order : tuple of int\n        Order in which dimensions are displayed where the last two or last\n        three dimensions correspond to row x column or plane x row x column if\n        ndisplay is 2 or 3.\n    axis_labels = list of str\n        Dimension names.\n\n    Attributes\n    ----------\n    window : Window\n        Parent window.\n    layers : LayerList\n        List of contained layers.\n    dims : Dimensions\n        Contains axes, indices, dimensions and sliders.\n    themes : dict of str: dict of str: str\n        Preset color palettes.\n    """"""\n\n    themes = palettes\n\n    def __init__(\n        self, title=\'napari\', ndisplay=2, order=None, axis_labels=None\n    ):\n        super().__init__()\n\n        self.events = EmitterGroup(\n            source=self,\n            auto_connect=True,\n            status=Event,\n            help=Event,\n            title=Event,\n            interactive=Event,\n            cursor=Event,\n            reset_view=Event,\n            active_layer=Event,\n            palette=Event,\n            grid=Event,\n            layers_change=Event,\n        )\n\n        self.dims = Dims(\n            ndim=None, ndisplay=ndisplay, order=order, axis_labels=axis_labels\n        )\n\n        self.layers = LayerList()\n\n        self._status = \'Ready\'\n        self._help = \'\'\n        self._title = title\n        self._cursor = \'standard\'\n        self._cursor_size = None\n        self._interactive = True\n        self._active_layer = None\n        self._grid_size = (1, 1)\n        self.grid_stride = 1\n\n        self._palette = None\n        self.theme = \'dark\'\n\n        self.dims.events.camera.connect(self.reset_view)\n        self.dims.events.ndisplay.connect(self._update_layers)\n        self.dims.events.order.connect(self._update_layers)\n        self.dims.events.axis.connect(self._update_layers)\n        self.layers.events.changed.connect(self._on_layers_change)\n        self.layers.events.changed.connect(self._update_active_layer)\n        self.layers.events.changed.connect(self._update_grid)\n\n        self.keymap_providers = [self]\n\n        # Hold callbacks for when mouse moves with nothing pressed\n        self.mouse_move_callbacks = []\n        # Hold callbacks for when mouse is pressed, dragged, and released\n        self.mouse_drag_callbacks = []\n        self._persisted_mouse_event = {}\n        self._mouse_drag_gen = {}\n\n    @property\n    def palette(self):\n        """"""dict of str: str : Color palette with which to style the viewer.\n        """"""\n        return self._palette\n\n    @palette.setter\n    def palette(self, palette):\n        if palette == self.palette:\n            return\n\n        self._palette = palette\n        self.events.palette()\n\n    @property\n    def theme(self):\n        """"""string or None : Preset color palette.\n        """"""\n        for theme, palette in self.themes.items():\n            if palette == self.palette:\n                return theme\n\n    @theme.setter\n    def theme(self, theme):\n        if theme == self.theme:\n            return\n\n        try:\n            self.palette = self.themes[theme]\n        except KeyError:\n            raise ValueError(\n                f""Theme \'{theme}\' not found; ""\n                f""options are {list(self.themes)}.""\n            )\n\n    @property\n    def grid_size(self):\n        """"""tuple: Size of grid\n        """"""\n        return self._grid_size\n\n    @grid_size.setter\n    def grid_size(self, grid_size):\n        if np.all(self.grid_size == grid_size):\n            return\n        self._grid_size = grid_size\n        self.reset_view()\n        self.events.grid()\n\n    @property\n    def status(self):\n        """"""string: Status string\n        """"""\n        return self._status\n\n    @status.setter\n    def status(self, status):\n        if status == self.status:\n            return\n        self._status = status\n        self.events.status(text=self._status)\n\n    @property\n    def help(self):\n        """"""string: String that can be displayed to the\n        user in the status bar with helpful usage tips.\n        """"""\n        return self._help\n\n    @help.setter\n    def help(self, help):\n        if help == self.help:\n            return\n        self._help = help\n        self.events.help(text=self._help)\n\n    @property\n    def title(self):\n        """"""string: String that is displayed in window title.\n        """"""\n        return self._title\n\n    @title.setter\n    def title(self, title):\n        if title == self.title:\n            return\n        self._title = title\n        self.events.title(text=self._title)\n\n    @property\n    def interactive(self):\n        """"""bool: Determines if canvas pan/zoom interactivity is enabled or not.\n        """"""\n        return self._interactive\n\n    @interactive.setter\n    def interactive(self, interactive):\n        if interactive == self.interactive:\n            return\n        self._interactive = interactive\n        self.events.interactive()\n\n    @property\n    def cursor(self):\n        """"""string: String identifying cursor displayed over canvas.\n        """"""\n        return self._cursor\n\n    @cursor.setter\n    def cursor(self, cursor):\n        if cursor == self.cursor:\n            return\n        self._cursor = cursor\n        self.events.cursor()\n\n    @property\n    def cursor_size(self):\n        """"""int | None: Size of cursor if custom. None is yields default size\n        """"""\n        return self._cursor_size\n\n    @cursor_size.setter\n    def cursor_size(self, cursor_size):\n        if cursor_size == self.cursor_size:\n            return\n        self._cursor_size = cursor_size\n        self.events.cursor()\n\n    @property\n    def active_layer(self):\n        """"""int: index of active_layer\n        """"""\n        return self._active_layer\n\n    @active_layer.setter\n    def active_layer(self, active_layer):\n        if active_layer == self.active_layer:\n            return\n\n        if self._active_layer is not None:\n            self.keymap_providers.remove(self._active_layer)\n\n        self._active_layer = active_layer\n\n        if active_layer is not None:\n            self.keymap_providers.insert(0, active_layer)\n\n        self.events.active_layer(item=self._active_layer)\n\n    def _scene_shape(self):\n        """"""Get shape of currently viewed dimensions.\n\n        Returns\n        ----------\n        centroid : list\n            List of center coordinates of scene, length 2 or 3 if displayed\n            view is 2D or 3D.\n        size : list\n            List of size of scene, length 2 or 3 if displayed view is 2D or 3D.\n        corner : list\n            List of coordinates of top left corner of scene, length 2 or 3 if\n            displayed view is 2D or 3D.\n        """"""\n        # Scale the camera to the contents in the scene\n        min_shape, max_shape = self._calc_bbox()\n        size = np.subtract(max_shape, min_shape)\n        size = [size[i] for i in self.dims.displayed]\n        corner = [min_shape[i] for i in self.dims.displayed]\n\n        return size, corner\n\n    def reset_view(self, event=None):\n        """"""Resets the camera\'s view using `event.rect` a 4-tuple of the x, y\n        corner position followed by width and height of the camera\n        """"""\n\n        scene_size, corner = self._scene_shape()\n        grid_size = list(self.grid_size)\n        if len(scene_size) > len(grid_size):\n            grid_size = [1] * (len(scene_size) - len(grid_size)) + grid_size\n        size = np.multiply(scene_size, grid_size)\n        centroid = np.add(corner, np.divide(size, 2))\n\n        if self.dims.ndisplay == 2:\n            # For a PanZoomCamera emit a 4-tuple of the rect\n            corner = np.subtract(corner, np.multiply(0.05, size))[::-1]\n            size = np.multiply(1.1, size)[::-1]\n            rect = tuple(corner) + tuple(size)\n            self.events.reset_view(rect=rect)\n        else:\n            # For an ArcballCamera emit the center and scale_factor\n            center = centroid[::-1]\n            scale_factor = 1.1 * np.max(size[-2:])\n            # set initial camera angle so that it matches top layer of 2D view\n            # when transitioning to 3D view\n            quaternion = [np.pi / 2, 1, 0, 0]\n            self.events.reset_view(\n                center=center, scale_factor=scale_factor, quaternion=quaternion\n            )\n\n    def _new_labels(self):\n        if self.dims.ndim == 0:\n            dims = (512, 512)\n        else:\n            dims = self._calc_bbox()[1]\n            dims = [np.ceil(d).astype(\'int\') if d > 0 else 1 for d in dims]\n            if len(dims) < 1:\n                dims = (512, 512)\n        empty_labels = np.zeros(dims, dtype=int)\n        self.add_labels(empty_labels)\n\n    def _update_layers(self, event=None, layers=None):\n        """"""Updates the contained layers.\n\n        Parameters\n        ----------\n        layers : list of napari.layers.Layer, optional\n            List of layers to update. If none provided updates all.\n        """"""\n        layers = layers or self.layers\n\n        for layer in layers:\n            # adjust the order of the global dims based on the number of\n            # dimensions that a layer has - for example a global order of\n            # [2, 1, 0, 3] -> [0, 1] for a layer that only has two dimesnions\n            # or -> [1, 0, 2] for a layer with three as that corresponds to\n            # the relative order of the last two and three dimensions\n            # respectively\n            offset = self.dims.ndim - layer.dims.ndim\n            order = np.array(self.dims.order)\n            if offset <= 0:\n                order = list(range(-offset)) + list(order - offset)\n            else:\n                order = list(order[order >= offset] - offset)\n            layer.dims.order = order\n            layer.dims.ndisplay = self.dims.ndisplay\n\n            # Update the point values of the layers for the dimensions that\n            # the layer has\n            for axis in range(layer.dims.ndim):\n                point = self.dims.point[axis + offset]\n                layer.dims.set_point(axis, point)\n\n    def _toggle_theme(self):\n        """"""Switch to next theme in list of themes\n        """"""\n        theme_names = list(self.themes.keys())\n        cur_theme = theme_names.index(self.theme)\n        self.theme = theme_names[(cur_theme + 1) % len(theme_names)]\n\n    def _update_active_layer(self, event):\n        """"""Set the active layer by iterating over the layers list and\n        finding the first selected layer. If multiple layers are selected the\n        iteration stops and the active layer is set to be None\n\n        Parameters\n        ----------\n        event : Event\n            No Event parameters are used\n        """"""\n        # iteration goes backwards to find top most selected layer if any\n        # if multiple layers are selected sets the active layer to None\n\n        active_layer = None\n        for layer in self.layers:\n            if active_layer is None and layer.selected:\n                active_layer = layer\n            elif active_layer is not None and layer.selected:\n                active_layer = None\n                break\n\n        if active_layer is None:\n            self.status = \'Ready\'\n            self.help = \'\'\n            self.cursor = \'standard\'\n            self.interactive = True\n            self.active_layer = None\n        else:\n            self.status = active_layer.status\n            self.help = active_layer.help\n            self.cursor = active_layer.cursor\n            self.interactive = active_layer.interactive\n            self.active_layer = active_layer\n\n    def _on_layers_change(self, event):\n        if len(self.layers) == 0:\n            self.dims.ndim = 2\n            self.dims.reset()\n        else:\n            layer_range = self._calc_layers_ranges()\n            self.dims.ndim = len(layer_range)\n            for i, r in enumerate(layer_range):\n                self.dims.set_range(i, r)\n        self.events.layers_change()\n\n    def _calc_layers_ranges(self):\n        """"""Calculates the range along each axis from all present layers.\n        """"""\n\n        ndims = self._calc_layers_num_dims()\n        ranges = [(inf, -inf, inf)] * ndims\n\n        for layer in self.layers:\n            layer_range = layer.dims.range[::-1]\n            ranges = [\n                (min(a, b), max(c, d), min(e, f))\n                for (a, c, e), (b, d, f) in itertools.zip_longest(\n                    ranges, layer_range, fillvalue=(inf, -inf, inf)\n                )\n            ]\n\n        return ranges[::-1]\n\n    def _calc_bbox(self):\n        """"""Calculates the bounding box of all displayed layers.\n        This assumes that all layers are stacked.\n        """"""\n\n        min_shape = []\n        max_shape = []\n        for min, max, step in self._calc_layers_ranges():\n            min_shape.append(min)\n            max_shape.append(max)\n        if len(min_shape) == 0:\n            min_shape = [0] * self.dims.ndim\n            max_shape = [1] * self.dims.ndim\n\n        return min_shape, max_shape\n\n    def _calc_layers_num_dims(self):\n        """"""Calculates the number of maximum dimensions in the contained images.\n        """"""\n        max_dims = 0\n        for layer in self.layers:\n            dims = layer.ndim\n            if dims > max_dims:\n                max_dims = dims\n\n        return max_dims\n\n    def _update_status(self, event):\n        """"""Set the viewer status with the `event.status` string.""""""\n        self.status = event.status\n\n    def _update_help(self, event):\n        """"""Set the viewer help with the `event.help` string.""""""\n        self.help = event.help\n\n    def _update_interactive(self, event):\n        """"""Set the viewer interactivity with the `event.interactive` bool.""""""\n        self.interactive = event.interactive\n\n    def _update_cursor(self, event):\n        """"""Set the viewer cursor with the `event.cursor` string.""""""\n        self.cursor = event.cursor\n\n    def _update_cursor_size(self, event):\n        """"""Set the viewer cursor_size with the `event.cursor_size` int.""""""\n        self.cursor_size = event.cursor_size\n\n    def grid_view(self, n_row=None, n_column=None, stride=1):\n        """"""Arrange the current layers is a 2D grid.\n\n        Default behaviour is to make a square 2D grid.\n\n        Parameters\n        ----------\n        n_row : int, optional\n            Number of rows in the grid.\n        n_column : int, optional\n            Number of column in the grid.\n        stride : int, optional\n            Number of layers to place in each grid square before moving on to\n            the next square. The default ordering is to place the most visible\n            layer in the top left corner of the grid. A negative stride will\n            cause the order in which the layers are placed in the grid to be\n            reversed.\n        """"""\n        n_grid_squares = np.ceil(len(self.layers) / abs(stride)).astype(int)\n        if n_row is None and n_column is None:\n            n_row = np.ceil(np.sqrt(n_grid_squares)).astype(int)\n            n_column = n_row\n        elif n_row is None:\n            n_row = np.ceil(n_grid_squares / n_column).astype(int)\n        elif n_column is None:\n            n_column = np.ceil(n_grid_squares / n_row).astype(int)\n\n        n_row = max(1, n_row)\n        n_column = max(1, n_column)\n        self.grid_size = (n_row, n_column)\n        self.grid_stride = stride\n        for i, layer in enumerate(self.layers):\n            if stride > 0:\n                adj_i = len(self.layers) - i - 1\n            else:\n                adj_i = i\n            adj_i = adj_i // abs(stride)\n            adj_i = adj_i % (n_row * n_column)\n            i_row = adj_i // n_column\n            i_column = adj_i % n_column\n            self._subplot(layer, (i_row, i_column))\n\n    def stack_view(self):\n        """"""Arrange the current layers is a stack.\n        """"""\n        self.grid_view(n_row=1, n_column=1, stride=1)\n\n    def _update_grid(self, event=None):\n        """"""Update grid with current grid values.\n        """"""\n        self.grid_view(\n            n_row=self.grid_size[0],\n            n_column=self.grid_size[1],\n            stride=self.grid_stride,\n        )\n\n    def _subplot(self, layer, position):\n        """"""Shift a layer to a specified position in a 2D grid.\n\n        Parameters\n        ----------\n        layer : napar.layers.Layer\n            Layer that is to be moved.\n        position : 2-tuple of int\n            New position of layer in grid.\n        size : 2-tuple of int\n            Size of the grid that is being used.\n        """"""\n        scene_size, corner = self._scene_shape()\n        translate_2d = np.multiply(scene_size[-2:], position)\n        translate = [0] * layer.ndim\n        translate[-2:] = translate_2d\n        layer.translate_grid = translate\n'"
napari/layers/__init__.py,0,"b'""""""Layers are the viewable objects that can be added to a viewer.\n\nCustom layers must inherit from Layer and pass along the\n`visual node <http://vispy.org/scene.html#module-vispy.scene.visuals>`_\nto the super constructor.\n""""""\n\nfrom ..utils.misc import all_subclasses\nfrom .base import Layer\nfrom .image import Image\nfrom .labels import Labels\nfrom .points import Points\nfrom .shapes import Shapes\nfrom .surface import Surface\nfrom .vectors import Vectors\n\nNAMES = {subclass.__name__.lower() for subclass in all_subclasses(Layer)}\ndel all_subclasses\n'"
napari/layers/intensity_mixin.py,2,"b'import numpy as np\n\nfrom ..utils.colormaps import ensure_colormap_tuple, make_colorbar\nfrom ..utils.event import Event\nfrom ..utils.status_messages import format_float\nfrom ..utils.validators import validate_n_seq\n\nvalidate_2_tuple = validate_n_seq(2)\n\n\nclass IntensityVisualizationMixin:\n    """"""A mixin that adds gamma, colormap, and contrast limits logic to Layers.\n\n    When used, this should come before the Layer in the inheritance, e.g.:\n\n        class Image(ImageSurfaceMixin, Layer):\n            def __init__(self):\n                ...\n    """"""\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        self.events.add(contrast_limits=Event, gamma=Event, colormap=Event)\n        self._gamma = 1\n        self._colormap_name = \'\'\n        self._contrast_limits_msg = \'\'\n        self._contrast_limits = [None, None]\n        self._contrast_limits_range = [None, None]\n\n    def reset_contrast_limits(self):\n        """"""Scale contrast limits to data range""""""\n        data_range = self._calc_data_range()\n        self.contrast_limits = data_range\n\n    def reset_contrast_limits_range(self):\n        """"""Scale contrast limits range to data type.\n\n        Currently, this only does something if the data type is an unsigned\n        integer... otherwise it\'s unclear what the full range should be.\n        """"""\n        if np.issubdtype(self.dtype, np.unsignedinteger):\n            info = np.iinfo(self.dtype)\n            self.contrast_limits_range = (info.min, info.max)\n\n    @property\n    def colormap(self):\n        """"""2-tuple of str, vispy.color.Colormap: colormap for luminance images.\n        """"""\n        return self._colormap_name, self._cmap\n\n    @colormap.setter\n    def colormap(self, colormap):\n        name, cmap = ensure_colormap_tuple(colormap)\n        self._colormap_name = name\n        self._cmap = cmap\n        self._colorbar = make_colorbar(self._cmap)\n        self._update_thumbnail()\n        self.events.colormap()\n\n    @property\n    def colormaps(self):\n        """"""tuple of str: names of available colormaps.""""""\n        return tuple(self._colormaps.keys())\n\n    @property\n    def contrast_limits(self):\n        """"""list of float: Limits to use for the colormap.""""""\n        return list(self._contrast_limits)\n\n    @contrast_limits.setter\n    def contrast_limits(self, contrast_limits):\n        validate_2_tuple(contrast_limits)\n        self._contrast_limits_msg = (\n            format_float(contrast_limits[0])\n            + \', \'\n            + format_float(contrast_limits[1])\n        )\n        self.status = self._contrast_limits_msg\n        self._contrast_limits = contrast_limits\n        # make sure range slider is big enough to fit range\n        newrange = list(self.contrast_limits_range)\n        newrange[0] = min(newrange[0], contrast_limits[0])\n        newrange[1] = max(newrange[1], contrast_limits[1])\n        self.contrast_limits_range = newrange\n        self._update_thumbnail()\n        self.events.contrast_limits()\n\n    @property\n    def contrast_limits_range(self):\n        """"""The current valid range of the contrast limits.""""""\n        return list(self._contrast_limits_range)\n\n    @contrast_limits_range.setter\n    def contrast_limits_range(self, value):\n        """"""Set the valid range of the contrast limits""""""\n        validate_2_tuple(value)\n        if list(value) == self.contrast_limits_range:\n            return\n\n        # if either value is ""None"", it just preserves the current range\n        current_range = self.contrast_limits_range\n        value = list(value)  # make sure it is mutable\n        for i in range(2):\n            value[i] = current_range[i] if value[i] is None else value[i]\n        self._contrast_limits_range = value\n\n        # make sure that the current values fit within the new range\n        # this also serves the purpose of emitting events.contrast_limits()\n        # and updating the views/controllers\n        if hasattr(self, \'_contrast_limits\') and any(self._contrast_limits):\n            cur_min, cur_max = self.contrast_limits\n            new_min = min(max(value[0], cur_min), value[1])\n            new_max = max(min(value[1], cur_max), value[0])\n            self.contrast_limits = (new_min, new_max)\n            self.events.contrast_limits()\n\n    @property\n    def gamma(self):\n        return self._gamma\n\n    @gamma.setter\n    def gamma(self, value):\n        self.status = format_float(value)\n        self._gamma = value\n        self._update_thumbnail()\n        self.events.gamma()\n'"
napari/layers/transforms.py,8,"b'import toolz as tz\nfrom typing import Sequence\nimport numpy as np\nfrom ..utils.list import ListModel\n\n\nclass Transform:\n    """"""Base transform class.\n\n    Defaults to the identity transform.\n\n    Parameters\n    ----------\n    func : callable, Coords -> Coords\n        A function converting an NxD array of coordinates to NxD\'.\n    name : string\n        A string name for the transform.\n    """"""\n\n    def __init__(self, func=tz.identity, inverse=None, name=None):\n        self.func = func\n        self._inverse_func = inverse\n        self.name = name\n\n        if func is tz.identity:\n            self._inverse_func = tz.identity\n\n    def __call__(self, coords):\n        """"""Transform input coordinates to output.""""""\n        return self.func(coords)\n\n    @property\n    def inverse(self) -> \'Transform\':\n        if self._inverse_func is not None:\n            return Transform(self._inverse_func, self.func)\n        else:\n            raise ValueError(\'Inverse function was not provided.\')\n\n    def compose(self, transform: \'Transform\') -> \'Transform\':\n        """"""Return the composite of this transform and the provided one.""""""\n        raise ValueError(\'Transform composition rule not provided\')\n\n    def set_slice(self, axes: Sequence[int]) -> \'Transform\':\n        """"""Return a transform subset to the visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Axes to subset the current transform with.\n\n        Returns\n        -------\n        Transform\n            Resulting transform.\n        """"""\n        raise NotImplementedError(\'Cannot subset arbitrary transforms.\')\n\n    def expand_dims(self, axes: Sequence[int]) -> \'Transform\':\n        """"""Return a transform with added axes for non-visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Location of axes to expand the current transform with. Passing a\n            list allows expanion to occur at specific locations and for\n            expand_dims to be like an inverse to the set_slice method.\n\n        Returns\n        -------\n        Transform\n            Resulting transform.\n        """"""\n        raise NotImplementedError(\'Cannot subset arbitrary transforms.\')\n\n\nclass TransformChain(ListModel, Transform):\n    def __init__(self, transforms=[]):\n        super().__init__(\n            basetype=Transform,\n            iterable=transforms,\n            lookup={str: lambda q, e: q == e.name},\n        )\n\n    def __call__(self, coords):\n        return tz.pipe(coords, *self)\n\n    def __newlike__(self, iterable):\n        return ListModel(self._basetype, iterable, self._lookup)\n\n    @property\n    def inverse(self) -> \'TransformChain\':\n        """"""Return the inverse transform chain.""""""\n        return TransformChain([tf.inverse for tf in self[::-1]])\n\n    @property\n    def simplified(self) -> \'Transform\':\n        """"""Return the composite of the transforms inside the transform chain.""""""\n        if len(self) == 0:\n            return None\n        if len(self) == 1:\n            return self[0]\n        else:\n            return tz.pipe(self[0], *[tf.compose for tf in self[1:]])\n\n    def set_slice(self, axes: Sequence[int]) -> \'TransformChain\':\n        """"""Return a transform chain subset to the visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Axes to subset the current transform chain with.\n\n        Returns\n        -------\n        TransformChain\n            Resulting transform chain.\n        """"""\n        return TransformChain([tf.set_slice(axes) for tf in self])\n\n    def expand_dims(self, axes: Sequence[int]) -> \'Transform\':\n        """"""Return a transform chain with added axes for non-visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Location of axes to expand the current transform with. Passing a\n            list allows expanion to occur at specific locations and for\n            expand_dims to be like an inverse to the set_slice method.\n\n        Returns\n        -------\n        TransformChain\n            Resulting transform chain.\n        """"""\n        return TransformChain([tf.expand_dims(axes) for tf in self])\n\n\nclass ScaleTranslate(Transform):\n    """"""n-dimensional scale and translation (shift) class.\n\n    Scaling is always applied before translation.\n\n    Parameters\n    ----------\n    scale : 1-D array\n        A 1-D array of factors to scale each axis by. Scale is broadcast to 1\n        in leading dimensions, so that, for example, a scale of [4, 18, 34] in\n        3D can be used as a scale of [1, 4, 18, 34] in 4D without modification.\n        An empty translation vector implies no scaling.\n    translate : 1-D array\n        A 1-D array of factors to shift each axis by. Translation is broadcast\n        to 0 in leading dimensions, so that, for example, a translation of\n        [4, 18, 34] in 3D can be used as a translation of [0, 4, 18, 34] in 4D\n        without modification. An empty translation vector implies no\n        translation.\n    name : string\n        A string name for the transform.\n    """"""\n\n    def __init__(self, scale=(1.0,), translate=(0.0,), name=None):\n        super().__init__(name=name)\n        self.scale = np.array(scale)\n        self.translate = np.array(translate)\n\n    def __call__(self, coords):\n        coords = np.atleast_2d(coords)\n        scale = np.concatenate(\n            ([1.0] * (coords.shape[1] - len(self.scale)), self.scale)\n        )\n        translate = np.concatenate(\n            ([0.0] * (coords.shape[1] - len(self.translate)), self.translate)\n        )\n        return np.squeeze(scale * coords + translate)\n\n    @property\n    def inverse(self) -> \'ScaleTranslate\':\n        """"""Return the inverse transform.""""""\n        return ScaleTranslate(1 / self.scale, -1 / self.scale * self.translate)\n\n    def compose(self, transform: \'ScaleTranslate\') -> \'ScaleTranslate\':\n        """"""Return the composite of this transform and the provided one.""""""\n        scale = self.scale * transform.scale\n        translate = self.translate + self.scale * transform.translate\n        return ScaleTranslate(scale, translate)\n\n    def set_slice(self, axes: Sequence[int]) -> \'ScaleTranslate\':\n        """"""Return a transform subset to the visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Axes to subset the current transform with.\n\n        Returns\n        -------\n        Transform\n            Resulting transform.\n        """"""\n        return ScaleTranslate(\n            self.scale[axes], self.translate[axes], name=self.name\n        )\n\n    def expand_dims(self, axes: Sequence[int]) -> \'ScaleTranslate\':\n        """"""Return a transform with added axes for non-visible dimensions.\n\n        Parameters\n        ----------\n        axes : Sequence[int]\n            Location of axes to expand the current transform with. Passing a\n            list allows expanion to occur at specific locations and for\n            expand_dims to be like an inverse to the set_slice method.\n\n        Returns\n        -------\n        Transform\n            Resulting transform.\n        """"""\n        n = len(axes) + len(self.scale)\n        not_axes = [i for i in range(n) if i not in axes]\n        scale = np.ones(n)\n        scale[not_axes] = self.scale\n        translate = np.zeros(n)\n        translate[not_axes] = self.translate\n        return ScaleTranslate(scale, translate, name=self.name)\n'"
napari/plugins/__init__.py,0,"b'import sys\n\nfrom napari_plugin_engine import PluginManager\nfrom . import hook_specifications\nfrom . import _builtins\n\n# the main plugin manager instance for the `napari` plugin namespace.\nplugin_manager = PluginManager(\n    \'napari\', discover_entry_point=\'napari.plugin\', discover_prefix=\'napari_\'\n)\nwith plugin_manager.discovery_blocked():\n    plugin_manager.add_hookspecs(hook_specifications)\n    plugin_manager.register(_builtins, name=\'builtins\')\n\n\n__all__ = [\n    ""PluginManager"",\n    ""plugin_manager"",\n]\n'"
napari/plugins/_builtins.py,14,"b'""""""\nInternal napari hook implementations to be registered by the plugin manager\n""""""\nimport os\nimport shutil\nfrom typing import Any, List, Optional, Union\n\nimport numpy as np\nfrom napari_plugin_engine import napari_hook_implementation\n\nfrom ..types import (\n    LayerData,\n    FullLayerData,\n    ReaderFunction,\n    WriterFunction,\n    image_reader_to_layerdata_reader,\n)\nfrom ..utils.io import (\n    imsave,\n    magic_imread,\n    write_csv,\n    imsave_extensions,\n    csv_to_layer_data,\n)\nfrom ..utils.misc import abspath_or_url\n\n\ndef csv_reader_function(path: Union[str, List[str]]) -> List[LayerData]:\n    if isinstance(path, list):\n        out: List[LayerData] = []\n        for p in path:\n            layer_data = csv_to_layer_data(p, require_type=None)\n            if layer_data:\n                out.append(layer_data)\n        return out\n    else:\n        layer_data = csv_to_layer_data(path, require_type=None)\n        return [layer_data] if layer_data else []\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_get_reader(path: Union[str, List[str]]) -> ReaderFunction:\n    """"""Our internal fallback file reader at the end of the reader plugin chain.\n\n    This will assume that the filepath is an image, and will pass all of the\n    necessary information to viewer.add_image().\n\n    Parameters\n    ----------\n    path : str\n        path to file/directory\n\n    Returns\n    -------\n    callable\n        function that returns layer_data to be handed to viewer._add_layer_data\n    """"""\n    if isinstance(path, str) and path.endswith(\'.csv\'):\n        return csv_reader_function\n    return image_reader_to_layerdata_reader(magic_imread)\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_write_image(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Our internal fallback image writer at the end of the plugin chain.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array or list of array\n        Image data. Can be N dimensional. If meta[\'rgb\'] is ``True`` then the\n        data should be interpreted as RGB or RGBA. If ``meta[\'multiscale\']`` is\n        ``True``, then the data should be interpreted as a multiscale image.\n    meta : dict\n        Image metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n    ext = os.path.splitext(path)[1]\n    if not ext:\n        path += \'.tif\'\n        ext = \'.tif\'\n\n    if ext in imsave_extensions():\n        imsave(path, data)\n        return path\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_write_labels(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Our internal fallback labels writer at the end of the plugin chain.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array or list of array\n        Image data. Can be N dimensional. If meta[\'rgb\'] is ``True`` then the\n        data should be interpreted as RGB or RGBA. If ``meta[\'multiscale\']`` is\n        ``True``, then the data should be interpreted as a multiscale image.\n    meta : dict\n        Image metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n    dtype = data.dtype if data.dtype.itemsize >= 4 else np.uint32\n    return napari_write_image(path, np.asarray(data, dtype=dtype), meta)\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_write_points(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Our internal fallback points writer at the end of the plugin chain.\n\n    Append ``.csv`` extension to the filename if it is not already there.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array (N, D)\n        Coordinates for N points in D dimensions.\n    meta : dict\n        Points metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n    ext = os.path.splitext(path)[1]\n    if ext == \'\':\n        path = path + \'.csv\'\n    elif ext != \'.csv\':\n        # If an extension is provided then it must be `.csv`\n        return\n\n    if \'properties\' in meta:\n        properties = meta[\'properties\']\n    else:\n        properties = {}\n    # TODO: we need to change this to the axis names once we get access to them\n    # construct table from data\n    column_names = [\'axis-\' + str(n) for n in range(data.shape[1])]\n    if properties:\n        column_names += properties.keys()\n        prop_table = [\n            np.expand_dims(col, axis=1) for col in properties.values()\n        ]\n    else:\n        prop_table = []\n\n    # add index of each point\n    column_names = [\'index\'] + column_names\n    indices = np.expand_dims(list(range(data.shape[0])), axis=1)\n    table = np.concatenate([indices, data] + prop_table, axis=1)\n\n    # write table to csv file\n    write_csv(path, table, column_names)\n    return path\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_write_shapes(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Our internal fallback points writer at the end of the plugin chain.\n\n    Append ``.csv`` extension to the filename if it is not already there.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : list of array (N, D)\n        List of coordinates for shapes, each with for N vertices in D\n        dimensions.\n    meta : dict\n        Points metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n    ext = os.path.splitext(path)[1]\n    if ext == \'\':\n        path = path + \'.csv\'\n    elif ext != \'.csv\':\n        # If an extension is provided then it must be `.csv`\n        return\n\n    if \'shape_type\' in meta:\n        shape_type = meta[\'shape_type\']\n    else:\n        shape_type = [\'rectangle\'] * len(data)\n\n    # No data passed so nothing written\n    if len(data) == 0:\n        return\n\n    # TODO: we need to change this to the axis names once we get access to them\n    # construct table from data\n    n_dimensions = max([s.shape[1] for s in data])\n    column_names = [\'axis-\' + str(n) for n in range(n_dimensions)]\n\n    # add shape id and vertex id of each vertex\n    column_names = [\'index\', \'shape-type\', \'vertex-index\'] + column_names\n\n    # concatenate shape data into 2D array\n    len_shapes = [s.shape[0] for s in data]\n    all_data = np.concatenate(data)\n    all_idx = np.expand_dims(\n        np.concatenate([np.repeat(i, s) for i, s in enumerate(len_shapes)]),\n        axis=1,\n    )\n    all_types = np.expand_dims(\n        np.concatenate(\n            [np.repeat(shape_type[i], s) for i, s in enumerate(len_shapes)]\n        ),\n        axis=1,\n    )\n    all_vert_idx = np.expand_dims(\n        np.concatenate([np.arange(s) for s in len_shapes]), axis=1\n    )\n\n    table = np.concatenate(\n        [all_idx, all_types, all_vert_idx, all_data], axis=1\n    )\n\n    # write table to csv file\n    write_csv(path, table, column_names)\n    return path\n\n\n@napari_hook_implementation(trylast=True)\ndef napari_get_writer(\n    path: str, layer_types: List[str]\n) -> Optional[WriterFunction]:\n    """"""Our internal fallback file writer at the end of the writer plugin chain.\n\n    This will create a new folder from the path and call\n    ``napari_write_<layer>`` for each layer using the ``layer.name`` variable\n    to modify the path such that the layers are written to unique files in the\n    folder. It will use the default builtin writer for each layer type.\n\n    Parameters\n    ----------\n    path : str\n        path to file/directory\n\n    Returns\n    -------\n    callable\n        function that accepts the path and a list of layer_data (where\n        layer_data is ``(data, meta, layer_type)``) and writes each layer.\n    """"""\n    # normally, a plugin would do some logic here to decide whether it supports\n    # the ``path`` extension and layer_types.  But because this is our builtin\n    # ""last resort"" implementation, we just immediately hand back the writer\n    # function, and let it throw an exception if it fails.\n    return write_layer_data_with_plugins\n\n\ndef write_layer_data_with_plugins(\n    path: str,\n    layer_data: List[FullLayerData],\n    *,\n    plugin_name: Optional[str] = \'builtins\',\n    plugin_manager=None,\n) -> List[str]:\n    """"""Write layer data out into a folder one layer at a time.\n\n    Call ``napari_write_<layer>`` for each layer using the ``layer.name``\n    variable to modify the path such that the layers are written to unique\n    files in the folder.\n\n    If ``plugin_name`` is ``None`` then we just directly call\n    ``plugin_manager.hook.napari_write_<layer>()`` which will loop through\n    implementations and stop when the first one returns a non-None result. The\n    order in which implementations are called can be changed with the\n    implementation sorter/disabler.\n\n    If ``plugin_name`` is provided, then we call the\n    ``napari_write_<layer_type>`` for that plugin, and if it fails we error.\n    By default, we restrict this function to using only napari ``builtins``\n    plugins.\n\n    Parameters\n    ----------\n    path : str\n        path to file/directory\n    layer_data : list of napari.types.LayerData\n        List of layer_data, where layer_data is ``(data, meta, layer_type)``.\n    plugin_name : str, optional\n        Name of the plugin to use for saving. If None then all plugins\n        corresponding to appropriate hook specification will be looped\n        through to find the first one that can save the data. By default,\n        only builtin napari implementations are used.\n    plugin_manager : plugins.PluginManager, optional\n        Instance of a napari PluginManager.  by default the main napari\n        plugin_manager will be used.\n\n    Returns\n    -------\n    list of str\n        A list of any filepaths that were written.\n    """"""\n    from tempfile import TemporaryDirectory\n\n    if not plugin_manager:\n        from . import plugin_manager as napari_plugin_manager\n\n        plugin_manager = napari_plugin_manager\n\n    # remember whether it was there to begin with\n    already_existed = os.path.exists(path)\n    # Try and make directory based on current path if it doesn\'t exist\n    if not already_existed:\n        os.makedirs(path)\n\n    written: List[str] = []  # the files that were actually written\n    try:\n        # build in a temporary directory and then move afterwards,\n        # it makes cleanup easier if an exception is raised inside.\n        with TemporaryDirectory(dir=path) as tmp:\n            # Loop through data for each layer\n            for layer_data_tuple in layer_data:\n                data, meta, layer_type = layer_data_tuple\n                # Get hook caller according to layer type\n                hook_caller = getattr(\n                    plugin_manager.hook, f\'napari_write_{layer_type}\'\n                )\n                # Create full path using name of layer\n                full_path = abspath_or_url(os.path.join(tmp, meta[\'name\']))\n                # Write out data using first plugin found for this hook spec\n                # or named plugin if provided\n                outpath = hook_caller(\n                    _plugin=plugin_name, path=full_path, data=data, meta=meta\n                )\n                written.append(outpath)\n            for fname in os.listdir(tmp):\n                shutil.move(os.path.join(tmp, fname), path)\n    except Exception as exc:\n        if not already_existed:\n            shutil.rmtree(path, ignore_errors=True)\n        raise exc\n    return written\n'"
napari/plugins/exceptions.py,0,"b'import re\nimport sys\nfrom typing import Callable, Dict, Generator\nfrom napari_plugin_engine import PluginError, standard_metadata\nfrom ..types import ExcInfo\n\nif sys.version_info >= (3, 8):\n    from importlib import metadata as importlib_metadata\nelse:\n    import importlib_metadata\nDistribution = importlib_metadata.Distribution\n\n\ndef format_exceptions(plugin_name: str, as_html: bool = False):\n    """"""Return formatted tracebacks for all exceptions raised by plugin.\n\n    Parameters\n    ----------\n    plugin_name : str\n        The name of a plugin for which to retrieve tracebacks.\n    as_html : bool\n        Whether to return the exception string as formatted html,\n        defaults to False.\n\n    Returns\n    -------\n    str\n        A formatted string with traceback information for every exception\n        raised by ``plugin_name`` during this session.\n    """"""\n    _plugin_errors = PluginError.get(plugin_name=plugin_name)\n    if not _plugin_errors:\n        return \'\'\n\n    from napari import __version__\n\n    format_exc_info = get_tb_formatter()\n\n    _linewidth = 80\n    _pad = (_linewidth - len(plugin_name) - 18) // 2\n    msg = [\n        f""{\'=\' * _pad} Errors for plugin \'{plugin_name}\' {\'=\' * _pad}"",\n        \'\',\n        f\'{""napari version"": >16}: {__version__}\',\n    ]\n\n    err0 = _plugin_errors[0]\n    if err0.plugin:\n        package_meta = standard_metadata(err0.plugin)\n        if package_meta:\n            msg.extend(\n                [\n                    f\'{""plugin package"": >16}: {package_meta[""package""]}\',\n                    f\'{""version"": >16}: {package_meta[""version""]}\',\n                    f\'{""module"": >16}: {err0.plugin}\',\n                ]\n            )\n    msg.append(\'\')\n\n    for n, err in enumerate(_plugin_errors):\n        _pad = _linewidth - len(str(err)) - 10\n        msg += [\'\', f\'ERROR #{n + 1}:  {str(err)} {""-"" * _pad}\', \'\']\n        msg.append(format_exc_info(err.info(), as_html))\n\n    msg.append(\'=\' * _linewidth)\n\n    return (""<br>"" if as_html else ""\\n"").join(msg)\n\n\ndef get_tb_formatter() -> Callable[[ExcInfo, bool], str]:\n    """"""Return a formatter callable that uses IPython VerboseTB if available.\n\n    Imports IPython lazily if available to take advantage of ultratb.VerboseTB.\n    If unavailable, cgitb is used instead, but this function overrides a lot of\n    the hardcoded citgb styles and adds error chaining (for exceptions that\n    result from other exceptions).\n\n    Returns\n    -------\n    callable\n        A function that accepts a 3-tuple and a boolean ``(exc_info, as_html)``\n        and returns a formatted traceback string. The ``exc_info`` tuple is of\n        the ``(type, value, traceback)`` format returned by sys.exc_info().\n        The ``as_html`` determines whether the traceback is formated in html\n        or plain text.\n    """"""\n    try:\n        import IPython.core.ultratb\n\n        def format_exc_info(info: ExcInfo, as_html: bool) -> str:\n            color = \'Linux\' if as_html else \'NoColor\'\n            vbtb = IPython.core.ultratb.VerboseTB(color_scheme=color)\n            if as_html:\n                ansi_string = vbtb.text(*info).replace("" "", ""&nbsp;"")\n                html = """".join(ansi2html(ansi_string))\n                html = html.replace(""\\n"", ""<br>"")\n                html = (\n                    ""<span style=\'font-family: monaco,courier,monospace;\'>""\n                    + html\n                    + ""</span>""\n                )\n                return html\n            else:\n                return vbtb.text(*info)\n\n    except ImportError:\n        import cgitb\n        import traceback\n\n        # cgitb does not support error chaining...\n        # see https://www.python.org/dev/peps/pep-3134/#enhanced-reporting\n        # this is a workaround\n        def cgitb_chain(exc: Exception) -> Generator[str, None, None]:\n            """"""Recurse through exception stack and chain cgitb_html calls.""""""\n            if exc.__cause__:\n                yield from cgitb_chain(exc.__cause__)\n                yield (\n                    \'<br><br><font color=""#51B432"">The above exception was \'\n                    \'the direct cause of the following exception:</font><br>\'\n                )\n            elif exc.__context__:\n                yield from cgitb_chain(exc.__context__)\n                yield (\n                    \'<br><br><font color=""#51B432"">During handling of the \'\n                    \'above exception, another exception occurred:</font><br>\'\n                )\n            yield cgitb_html(exc)\n\n        def cgitb_html(exc: Exception) -> str:\n            """"""Format exception with cgitb.html.""""""\n            info = (type(exc), exc, exc.__traceback__)\n            return cgitb.html(info)\n\n        def format_exc_info(info: ExcInfo, as_html: bool) -> str:\n            if as_html:\n                html = ""\\n"".join(cgitb_chain(info[1]))\n                # cgitb has a lot of hardcoded colors that don\'t work for us\n                # remove bgcolor, and let theme handle it\n                html = re.sub(\'bgcolor=""#.*""\', \'\', html)\n                # remove superfluous whitespace\n                html = html.replace(\'<br>\\n\', \'\\n\')\n                # but retain it around the <small> bits\n                html = re.sub(r\'(<tr><td><small.*</tr>)\', f\'<br>\\\\1<br>\', html)\n                # weird 2-part syntax is a workaround for hard-to-grep text.\n                html = html.replace(\n                    ""<p>A problem occurred in a Python script.  ""\n                    ""Here is the sequence of"",\n                    """",\n                )\n                html = html.replace(\n                    ""function calls leading up to the error, ""\n                    ""in the order they occurred.</p>"",\n                    ""<br>"",\n                )\n                # remove hardcoded fonts\n                html = html.replace(\'face=""helvetica, arial""\', """")\n                html = (\n                    ""<span style=\'font-family: monaco,courier,monospace;\'>""\n                    + html\n                    + ""</span>""\n                )\n                return html\n            else:\n                # if we don\'t need HTML, just use traceback\n                return \'\'.join(traceback.format_exception(*info))\n\n    return format_exc_info\n\n\nANSI_STYLES = {\n    1: {""font_weight"": ""bold""},\n    2: {""font_weight"": ""lighter""},\n    3: {""font_weight"": ""italic""},\n    4: {""text_decoration"": ""underline""},\n    5: {""text_decoration"": ""blink""},\n    6: {""text_decoration"": ""blink""},\n    8: {""visibility"": ""hidden""},\n    9: {""text_decoration"": ""line-through""},\n    30: {""color"": ""black""},\n    31: {""color"": ""red""},\n    32: {""color"": ""green""},\n    33: {""color"": ""yellow""},\n    34: {""color"": ""blue""},\n    35: {""color"": ""magenta""},\n    36: {""color"": ""cyan""},\n    37: {""color"": ""white""},\n}\n\n\ndef ansi2html(\n    ansi_string: str, styles: Dict[int, Dict[str, str]] = ANSI_STYLES\n) -> Generator[str, None, None]:\n    """"""Convert ansi string to colored HTML\n\n    Parameters\n    ----------\n    ansi_string : str\n        text with ANSI color codes.\n    styles : dict, optional\n        A mapping from ANSI codes to a dict of css kwargs:values,\n        by default ANSI_STYLES\n\n    Yields\n    -------\n    str\n        HTML strings that can be joined to form the final html\n    """"""\n    previous_end = 0\n    in_span = False\n    ansi_codes = []\n    ansi_finder = re.compile(""\\033\\\\["" ""([\\\\d;]*)"" ""([a-zA-z])"")\n    for match in ansi_finder.finditer(ansi_string):\n        yield ansi_string[previous_end : match.start()]\n        previous_end = match.end()\n        params, command = match.groups()\n\n        if command not in ""mM"":\n            continue\n\n        try:\n            params = [int(p) for p in params.split("";"")]\n        except ValueError:\n            params = [0]\n\n        for i, v in enumerate(params):\n            if v == 0:\n                params = params[i + 1 :]\n                if in_span:\n                    in_span = False\n                    yield ""</span>""\n                ansi_codes = []\n                if not params:\n                    continue\n\n        ansi_codes.extend(params)\n        if in_span:\n            yield ""</span>""\n            in_span = False\n\n        if not ansi_codes:\n            continue\n\n        style = [\n            ""; "".join([f""{k}: {v}"" for k, v in styles[k].items()]).strip()\n            for k in ansi_codes\n            if k in styles\n        ]\n        yield \'<span style=""%s"">\' % ""; "".join(style)\n\n        in_span = True\n\n    yield ansi_string[previous_end:]\n    if in_span:\n        yield ""</span>""\n        in_span = False\n'"
napari/plugins/hook_specifications.py,0,"b'""""""\nAll napari hook specifications for pluggable functionality are defined here.\n\nA *hook specification* is a function signature (with documentation) that\ndeclares an API that plugin developers must adhere to when providing hook\nimplementations.  *Hook implementations* provided by plugins (and internally by\nnapari) will then be invoked in various places throughout the code base.\n\nWhen implementing a hook specification, pay particular attention to the number\nand types of the arguments in the specification signature, as well as the\nexpected return type.\n\nTo allow for hook specifications to evolve over the lifetime of napari,\nhook implementations may accept *fewer* arguments than defined in the\nspecification. (This allows for extending existing hook arguments without\nbreaking existing implementations). However, implementations must not require\n*more* arguments than defined in the spec.\n\nFor more general background on the plugin hook calling mechanism, see the\n`napari-plugin-manager documentation\n<https://napari-plugin-engine.readthedocs.io/en/latest/>`_.\n\n.. NOTE::\n    Hook specifications are a feature borrowed from `pluggy\n    <https://pluggy.readthedocs.io/en/latest/#specs>`_. In the `pluggy\n    documentation <https://pluggy.readthedocs.io/en/latest/>`_, hook\n    specification marker instances are named ``hookspec`` by convention, and\n    hook implementation marker instances are named ``hookimpl``.  The\n    convention in napari is to name them more explicity:\n    ``napari_hook_specification`` and ``napari_hook_implementation``,\n    respectively.\n""""""\n\n# These hook specifications also serve as the API reference for plugin\n# developers, so comprehensive documentation with complete type annotations is\n# imperative!\n\nfrom napari_plugin_engine import napari_hook_specification\nfrom typing import Optional, Union, List, Any\nfrom ..types import ReaderFunction, WriterFunction\n\n\n# -------------------------------------------------------------------------- #\n#                                 IO Hooks                                   #\n# -------------------------------------------------------------------------- #\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_get_reader(path: Union[str, List[str]]) -> Optional[ReaderFunction]:\n    """"""Return a function capable of loading ``path`` into napari, or ``None``.\n\n    This is the primary ""**reader plugin**"" function.  It accepts a path or\n    list of paths, and returns a list of data to be added to the ``Viewer``.\n\n    The main place this hook is used is in :func:`Viewer.open()\n    <napari.components.add_layers_mixin.AddLayersMixin.open>`, via the\n    :func:`~napari.plugins.io.read_data_with_plugins` function.\n\n    It will also be called on ``File -> Open...`` or when a user drops a file\n    or folder onto the viewer. This function must execute **quickly**, and\n    should return ``None`` if the filepath is of an unrecognized format for\n    this reader plugin.  If ``path`` is determined to be recognized format,\n    this function should return a *new* function that accepts the same filepath\n    (or list of paths), and returns a list of ``LayerData`` tuples, where each\n    tuple is a 1-, 2-, or 3-tuple of ``(data,)``, ``(data, meta)``, or ``(data,\n    meta, layer_type)``.\n\n    ``napari`` will then use each tuple in the returned list to generate a new\n    layer in the viewer using the :func:`Viewer._add_layer_from_data()\n    <napari.components.add_layers_mixin.AddLayersMixin._add_layer_from_data>`\n    method.  The first, (optional) second, and (optional) third items in each\n    tuple in the returned layer_data list, therefore correspond to the\n    ``data``, ``meta``, and ``layer_type`` arguments of the\n    :func:`Viewer._add_layer_from_data()\n    <napari.components.add_layers_mixin.AddLayersMixin._add_layer_from_data>`\n    method, respectively.\n\n\n    .. important::\n\n       ``path`` may be either a ``str`` or a ``list`` of ``str``.  If a\n       ``list``, then each path in the list can be assumed to be one part of a\n       larger multi-dimensional stack (for instance: a list of 2D image files\n       that should be stacked along a third axis). Implementations should do\n       their own checking for ``list`` or ``str``, and handle each case as\n       desired.\n\n    Parameters\n    ----------\n    path : str or list of str\n        Path to file, directory, or resource (like a URL), or a list of paths.\n\n    Returns\n    -------\n    Callable or None\n        A function that accepts the path, and returns a list of ``layer_data``,\n        where ``layer_data`` is one of ``(data,)``, ``(data, meta)``, or\n        ``(data, meta, layer_type)``.\n        If unable to read the path, must return ``None`` (not ``False``!).\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_get_writer(\n    path: str, layer_types: List[str]\n) -> Optional[WriterFunction]:\n    """"""Return function capable of writing napari layer data to ``path``.\n\n    This function will be called whenever the user attempts to save multiple\n    layers (e.g. via ``File -> Save Layers``, or\n    :func:`~napari.plugins.io.save_layers`).\n    This function must execute **quickly**, and should return ``None`` if\n    ``path`` has an unrecognized extension for the reader plugin or the list of\n    layer types are incompatible with what the plugin can write. If ``path`` is\n    a recognized format, this function should return a *function* that accepts\n    the same ``path``, and a list of tuples containing the data for each layer\n    being saved in the form of ``(Layer.data, Layer._get_state(),\n    Layer._type_string)``. The writer function should return a list of strings\n    (the actual filepath(s) that were written).\n\n    .. important::\n\n        It is up to plugins to inspect and obey any extension in ``path``\n        (and return ``None`` if it is an unsupported extension).\n\n    An example function signature for a ``WriterFunction`` that might be\n    returned by this hook specification is as follows:\n\n    .. code-block:: python\n\n        def writer_function(\n            path: str, layer_data: List[Tuple[Any, Dict, str]]\n        ) -> List[str]:\n            ...\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).  Any extensions in\n        the path should be examined and obeyed.  (i.e. if the plugin is\n        incapable of returning a requested extension, it should return\n        ``None``).\n    layer_types : list of str\n        List of layer types (e.g. ""image"", ""labels"") that will be provided to\n        the writer function.\n\n    Returns\n    -------\n    Callable or None\n        A function that accepts the path, a list of layer_data (where\n        layer_data is ``(data, meta, layer_type)``). If unable to write to the\n        path or write the layer_data, must return ``None`` (not ``False``).\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_image(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write image data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array or list of array\n        Image data. Can be N dimensional. If meta[\'rgb\'] is ``True`` then the\n        data should be interpreted as RGB or RGBA. If meta[\'multiscale\'] is\n        True, then the data should be interpreted as a multiscale image.\n    meta : dict\n        Image metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_labels(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write labels data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array or list of array\n        Integer valued label data. Can be N dimensional. Every pixel contains\n        an integer ID corresponding to the region it belongs to. The label 0 is\n        rendered as transparent. If a list and arrays are decreasing in shape\n        then the data is from a multiscale image.\n    meta : dict\n        Labels metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_points(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write points data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : array (N, D)\n        Coordinates for N points in D dimensions.\n    meta : dict\n        Points metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_shapes(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write shapes data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : list\n        List of shape data, where each element is an (N, D) array of the\n        N vertices of a shape in D dimensions.\n    meta : dict\n        Shapes metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_surface(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write surface data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : 3-tuple of array\n        The first element of the tuple is an (N, D) array of vertices of\n        mesh triangles. The second is an (M, 3) array of int of indices\n        of the mesh triangles. The third element is the (K0, ..., KL, N)\n        array of values used to color vertices where the additional L\n        dimensions are used to color the same mesh with different values.\n    meta : dict\n        Surface metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n\n\n@napari_hook_specification(firstresult=True)\ndef napari_write_vectors(path: str, data: Any, meta: dict) -> Optional[str]:\n    """"""Write vectors data and metadata into a path.\n\n    It is the responsibility of the implementation to check any extension on\n    ``path`` and return ``None`` if it is an unsupported extension.  If\n    ``path`` has no extension, implementations may append their preferred\n    extension.\n\n    Parameters\n    ----------\n    path : str\n        Path to file, directory, or resource (like a URL).\n    data : (N, 2, D) array\n        The start point and projections of N vectors in D dimensions.\n    meta : dict\n        Vectors metadata.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n'"
napari/plugins/io.py,0,"b'import warnings\nfrom logging import getLogger\nfrom typing import List, Optional, Sequence, Union\n\nfrom napari_plugin_engine import (\n    HookImplementation,\n    PluginCallError,\n    PluginManager,\n)\n\nfrom ..layers import Layer\nfrom ..types import LayerData\nfrom ..utils.misc import abspath_or_url\nfrom . import plugin_manager as napari_plugin_manager\n\nlogger = getLogger(__name__)\n\n\ndef read_data_with_plugins(\n    path: Union[str, Sequence[str]],\n    plugin: Optional[str] = None,\n    plugin_manager: PluginManager = napari_plugin_manager,\n) -> List[LayerData]:\n    """"""Iterate reader hooks and return first non-None LayerData or None.\n\n    This function returns as soon as the path has been read successfully,\n    while catching any plugin exceptions, storing them for later retrievial,\n    providing useful error messages, and relooping until either layer data is\n    returned, or no valid readers are found.\n\n    Exceptions will be caught and stored as PluginErrors\n    (in plugins.exceptions.PLUGIN_ERRORS)\n\n    Parameters\n    ----------\n    path : str\n        The path (file, directory, url) to open\n    plugin : str, optional\n        Name of a plugin to use.  If provided, will force ``path`` to be read\n        with the specified ``plugin``.  If the requested plugin cannot read\n        ``path``, a PluginCallError will be raised.\n    plugin_manager : plugins.PluginManager, optional\n        Instance of a napari PluginManager.  by default the main napari\n        plugin_manager will be used.\n\n    Returns\n    -------\n    LayerData : list of tuples, or None\n        LayerData that can be passed to :func:`Viewer._add_layer_from_data()\n        <napari.components.add_layers_mixin.AddLayersMixin._add_layer_from_data>`.\n        ``LayerData`` is a list tuples, where each tuple is one of\n        ``(data,)``, ``(data, meta)``, or ``(data, meta, layer_type)`` .\n\n        If no reader plugins are (or they all error), returns ``None``\n\n    Raises\n    ------\n    PluginCallError\n        If ``plugin`` is specified but raises an Exception while reading.\n    """"""\n    hook_caller = plugin_manager.hook.napari_get_reader\n\n    if plugin:\n        if plugin not in plugin_manager.plugins:\n            names = {i.plugin_name for i in hook_caller.get_hookimpls()}\n            raise ValueError(\n                f""There is no registered plugin named \'{plugin}\'.\\n""\n                f""Names of plugins offering readers are: {names}""\n            )\n        reader = hook_caller._call_plugin(plugin, path=path)\n        if not callable(reader):\n            raise ValueError(f\'Plugin {plugin!r} does not support file {path}\')\n        return reader(path) or []\n\n    errors: List[PluginCallError] = []\n    path = abspath_or_url(path)\n    skip_impls: List[HookImplementation] = []\n    layer_data = None\n    while True:\n        result = hook_caller.call_with_result_obj(\n            path=path, _skip_impls=skip_impls\n        )\n        reader = result.result  # will raise exceptions if any occured\n        if not reader:\n            # we\'re all out of reader plugins\n            break\n        try:\n            layer_data = reader(path)  # try to read data\n            if layer_data:\n                break\n        except Exception as exc:\n            # collect the error and log it, but don\'t raise it.\n            err = PluginCallError(result.implementation, cause=exc)\n            err.log(logger=logger)\n            errors.append(err)\n        # don\'t try this impl again\n        skip_impls.append(result.implementation)\n\n    if not layer_data:\n        # if layer_data is empty, it means no plugin could read path\n        # we just want to provide some useful feedback, which includes\n        # whether or not paths were passed to plugins as a list.\n        if isinstance(path, (tuple, list)):\n            path_repr = f""[{path[0]}, ...] as stack""\n        else:\n            path_repr = repr(path)\n        msg = f\'No plugin found capable of reading {path_repr}.\'\n        logger.warn(msg)\n\n    if errors:\n        names = set([repr(e.plugin_name) for e in errors])\n        err_msg = f""({len(errors)}) error{\'s\' if len(errors) > 1 else \'\'} ""\n        err_msg += f""occured in plugins: {\', \'.join(names)}. ""\n        err_msg += \'See full error logs in ""Plugins \xe2\x86\x92 Plugin Errors...""\'\n        logger.error(err_msg)\n\n    return layer_data or []\n\n\ndef save_layers(\n    path: str, layers: List[Layer], *, plugin: Optional[str] = None,\n) -> List[str]:\n    """"""Write list of layers or individual layer to a path using writer plugins.\n\n    If ``plugin`` is not provided and only one layer is passed, then we\n    directly call ``plugin_manager.hook.napari_write_<layer>()`` which\n    will loop through implementations and stop when the first one returns a\n    non-None result. The order in which implementations are called can be\n    changed with the hook ``bring_to_front`` method, for instance:\n    ``plugin_manager.hook.napari_write_points.bring_to_front``\n\n    If ``plugin`` is not provided and multiple layers are passed, then\n    we call ``plugin_manager.hook.napari_get_writer()`` which loops through\n    plugins to find the first one that knows how to handle the combination of\n    layers and is able to write the file. If no plugins offer\n    ``napari_get_writer`` for that combination of layers then the builtin\n    ``napari_get_writer`` implementation will create a folder and call\n    ``napari_write_<layer>`` for each layer using the ``layer.name`` variable\n    to modify the path such that the layers are written to unique files in the\n    folder.\n\n    If ``plugin`` is provided and a single layer is passed, then\n    we call the ``napari_write_<layer_type>`` for that plugin, and if it\n    fails we error.\n\n    If a ``plugin`` is provided and multiple layers are passed, then\n    we call we call ``napari_get_writer`` for that plugin, and if it\n    doesn\xe2\x80\x99t return a WriterFunction we error, otherwise we call it and if\n    that fails if it we error.\n\n    Parameters\n    ----------\n    path : str\n        A filepath, directory, or URL to open.\n    layers : List[layers.Layer]\n        List of layers to be saved. If only a single layer is passed then\n        we use the hook specification corresponding to its layer type,\n        ``napari_write_<layer_type>``. If multiple layers are passed then we\n        use the ``napari_get_writer`` hook specification.\n    plugin : str, optional\n        Name of the plugin to use for saving. If None then all plugins\n        corresponding to appropriate hook specification will be looped\n        through to find the first one that can save the data.\n\n    Returns\n    -------\n    list of str\n        File paths of any files that were written.\n    """"""\n    if len(layers) > 1:\n        written = _write_multiple_layers_with_plugins(\n            path, layers, plugin_name=plugin\n        )\n    elif len(layers) == 1:\n        _written = _write_single_layer_with_plugins(\n            path, layers[0], plugin_name=plugin\n        )\n        written = [_written] if _written else []\n    else:\n        written = []\n\n    if not written:\n        # if written is empty, it means no plugin could write the\n        # path/layers combination\n        # we just want to provide some useful feedback\n        warnings.warn(\n            \'No data written! There may be no plugins \'\n            f\'capable of writing these {len(layers)} layers to {path}.\'\n        )\n\n    return written\n\n\ndef _write_multiple_layers_with_plugins(\n    path: str,\n    layers: List[Layer],\n    *,\n    plugin_name: Optional[str] = None,\n    plugin_manager=napari_plugin_manager,\n) -> List[str]:\n    """"""Write data from multiple layers data with a plugin.\n\n    If a ``plugin_name`` is not provided we loop through plugins to find the\n    first one that knows how to handle the combination of layers and is able to\n    write the file. If no plugins offer ``napari_get_writer`` for that\n    combination of layers then the default ``napari_get_writer`` will create a\n    folder and call ``napari_write_<layer>`` for each layer using the\n    ``layer.name`` variable to modify the path such that the layers are written\n    to unique files in the folder.\n\n    If a ``plugin_name`` is provided, then call ``napari_get_writer`` for that\n    plugin. If it doesn\xe2\x80\x99t return a ``WriterFunction`` we error, otherwise we\n    call it and if that fails if it we error.\n\n    Exceptions will be caught and stored as PluginErrors\n    (in plugins.exceptions.PLUGIN_ERRORS)\n\n    Parameters\n    ----------\n    path : str\n        The path (file, directory, url) to write.\n    layers : List of napari.layers.Layer\n        List of napari layers to write.\n    plugin_name: str, optional\n        If provided, force the plugin manager to use the ``napari_get_writer``\n        from the requested ``plugin_name``.  If none is available, or if it is\n        incapable of handling the layers, this function will fail.\n    plugin_manager : plugins.PluginManager, optional\n        Instance of a PluginManager.  by default the main napari\n        plugin_manager will be used.\n\n    Returns\n    -------\n    list of str\n        A list of filenames, if any, that were written.\n    """"""\n    layer_data = [layer.as_layer_data_tuple() for layer in layers]\n    layer_types = [ld[2] for ld in layer_data]\n\n    hook_caller = plugin_manager.hook.napari_get_writer\n    path = abspath_or_url(path)\n    if plugin_name:\n        # if plugin has been specified we just directly call napari_get_writer\n        # with that plugin_name.\n        if plugin_name not in plugin_manager.plugins:\n            names = {i.plugin_name for i in hook_caller.get_hookimpls()}\n            raise ValueError(\n                f""There is no registered plugin named \'{plugin_name}\'.\\n""\n                f""Names of plugins offering writers are: {names}""\n            )\n        implementation = hook_caller.get_plugin_implementation(plugin_name)\n        writer_function = hook_caller(\n            _plugin=plugin_name, path=path, layer_types=layer_types\n        )\n    else:\n        result = hook_caller.call_with_result_obj(\n            path=path, layer_types=layer_types, _return_impl=True\n        )\n        writer_function = result.result\n        implementation = result.implementation\n\n    if not callable(writer_function):\n        if plugin_name:\n            msg = f\'Requested plugin ""{plugin_name}"" is not capable\'\n        else:\n            msg = \'Unable to find plugin capable\'\n        msg += f\' of writing this combination of layer types: {layer_types}\'\n        raise ValueError(msg)\n\n    try:\n        return writer_function(abspath_or_url(path), layer_data)\n    except Exception as exc:\n        raise PluginCallError(implementation, cause=exc)\n\n\ndef _write_single_layer_with_plugins(\n    path: str,\n    layer: Layer,\n    *,\n    plugin_name: Optional[str] = None,\n    plugin_manager=napari_plugin_manager,\n) -> Optional[str]:\n    """"""Write single layer data with a plugin.\n\n    If ``plugin_name`` is not provided then we just directly call\n    ``plugin_manager.hook.napari_write_<layer>()`` which will loop through\n    implementations and stop when the first one returns a non-None result. The\n    order in which implementations are called can be changed with the\n    implementation sorter/disabler.\n\n    If ``plugin_name`` is provided, then we call the\n    ``napari_write_<layer_type>`` for that plugin, and if it fails we error.\n\n    Exceptions will be caught and stored as PluginErrors\n    (in plugins.exceptions.PLUGIN_ERRORS)\n\n    Parameters\n    ----------\n    path : str\n        The path (file, directory, url) to write.\n    layer : napari.layers.Layer\n        Layer to be written out.\n    plugin_name : str, optional\n        Name of the plugin to write data with. If None then all plugins\n        corresponding to appropriate hook specification will be looped\n        through to find the first one that can write the data.\n    plugin_manager : plugins.PluginManager, optional\n        Instance of a napari PluginManager.  by default the main napari\n        plugin_manager will be used.\n\n    Returns\n    -------\n    path : str or None\n        If data is successfully written, return the ``path`` that was written.\n        Otherwise, if nothing was done, return ``None``.\n    """"""\n    hook_caller = getattr(\n        plugin_manager.hook, f\'napari_write_{layer._type_string}\'\n    )\n\n    if plugin_name and (plugin_name not in plugin_manager.plugins):\n        names = {i.plugin_name for i in hook_caller.get_hookimpls()}\n        raise ValueError(\n            f""There is no registered plugin named \'{plugin_name}\'.\\n""\n            ""Plugins capable of writing layer._type_string layers""\n            f""are: {names}""\n        )\n\n    # Call the hook_caller\n    return hook_caller(\n        _plugin=plugin_name,\n        path=abspath_or_url(path),\n        data=layer.data,\n        meta=layer._get_state(),\n    )\n'"
napari/plugins/pypi.py,0,"b'""""""\nThese convenience functions will be useful for searching pypi for packages\nthat match the plugin naming convention, and retrieving related metadata.\n""""""\nfrom urllib import request\nfrom typing import Tuple, Dict\nimport re\n\nPYPI_SIMPLE_API_URL = \'https://pypi.org/simple/\'\nURL_CACHE = {}  # {name: url} for packages at pypi.org/simple\nVERSION_CACHE = {}  # {name: tuple of versions} for packages at pypi.org/simple\n\n\ndef clear_cache():\n    global URL_CACHE\n    global VERSION_CACHE\n\n    URL_CACHE = {}\n    VERSION_CACHE = {}\n\n\ndef get_packages_by_prefix(prefix: str) -> Dict[str, str]:\n    """"""Search for packages starting with ``prefix`` on pypi.\n\n    Packages using naming convention: http://bit.ly/pynaming-convention\n    can be autodiscovered on pypi using the SIMPLE API:\n    https://www.python.org/dev/peps/pep-0503/\n\n    Returns\n    -------\n    dict\n        {name: url} for all packages at pypi that start with ``prefix``\n    """"""\n\n    with request.urlopen(PYPI_SIMPLE_API_URL) as response:\n        html = response.read()\n\n    pattern = f\'<a href=""/simple/(.+)"">({prefix}.*)</a>\'\n    urls = {\n        name: PYPI_SIMPLE_API_URL + url\n        for url, name in re.findall(pattern, html.decode())\n    }\n    URL_CACHE.update(urls)\n    return urls\n\n\ndef get_package_versions(name: str) -> Tuple[str]:\n    """"""Get available versions of a package on pypi\n\n    Parameters\n    ----------\n    name : str\n        name of the package\n\n    Returns\n    -------\n    tuple\n        versions available on pypi\n    """"""\n    url = URL_CACHE.get(name, PYPI_SIMPLE_API_URL + name)\n    with request.urlopen(url) as response:\n        html = response.read()\n\n    versions = tuple(set(re.findall(f\'>{name}-(.+).tar\', html.decode())))\n    VERSION_CACHE[name] = versions\n    return versions\n'"
napari/qt/__init__.py,0,"b""from .._qt.qt_main_window import Window\nfrom .._qt.qt_viewer import QtViewer\nfrom .._qt.qt_viewer_buttons import QtNDisplayButton, QtViewerButtons\nfrom .threading import create_worker, thread_worker\n\n__all__ = (\n    'create_worker',\n    'QtNDisplayButton',\n    'QtViewer',\n    'QtViewerButtons',\n    'thread_worker',\n    'Window',\n)\n"""
napari/qt/threading.py,0,"b""from .._qt.threading import (\n    FunctionWorker,\n    GeneratorWorker,\n    GeneratorWorkerSignals,\n    WorkerBase,\n    WorkerBaseSignals,\n    active_thread_count,\n    create_worker,\n    set_max_thread_count,\n    thread_worker,\n)\n\n# all of these might be used by an end-user when subclassing\n__all__ = (\n    'active_thread_count',\n    'create_worker',\n    'FunctionWorker',\n    'GeneratorWorker',\n    'GeneratorWorkerSignals',\n    'set_max_thread_count',\n    'thread_worker',\n    'WorkerBase',\n    'WorkerBaseSignals',\n)\n"""
napari/resources/__init__.py,0,"b'import sys\nfrom functools import lru_cache\nfrom glob import glob\nfrom importlib.util import module_from_spec, spec_from_file_location\nfrom os import environ, fspath\nfrom os.path import abspath, dirname, expanduser, join\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import List, Optional\n\nfrom qtpy import API, QT_VERSION\n\nfrom .. import __version__\nfrom .build_icons import build_pyqt_resources\n\n\ndef _try_touch_file(target) -> Optional[Path]:\n    """"""Test to see if we have permissions to create a file at ``target``.\n    \n    If the target already exists, it will not be touched.  If it does not\n    exist, this function attempts to create it and delete it (i.e. testing\n    permissions).  NOTE: all parent directories required to write the file will\n    be created, but NOT deleted.  \n    \n    If successful, the path is returned, if not, return None.\n \n    Parameters\n    ----------\n    target : str\n        Filepath to test\n    \n    Returns\n    -------\n    target : str or None\n        Returns the target if it is writeable, returns None if it is not.\n    """"""\n    target = Path(target)\n    if not target.exists():\n        try:\n            # create parent directories\n            target.parent.mkdir(parents=True, exist_ok=True)\n            target.touch()  # create the file itself\n        except Exception:\n            return None\n        target.unlink()  # delete it\n    return target\n\n\ndef import_resources(version: str = \'\', overwrite: bool = False) -> str:\n    """"""Build and import our icons as Qt resources.\n\n    This function attempts to write that file to one of three locations\n    (in this order):\n\n        1. The directory of *this* file (currently ``napari/resources``)\n        2. The user ~/.config/napari directory\n        3. A temporary file.\n\n    If a temporary file must be used, resources will need to be rebuilt at each\n    launch of napari (which takes ~300ms on a decent computer).\n\n    Parameters\n    ----------\n    version : str, optional\n        Version string, by default the resources will be written to a file that\n        encodes the current napari version, as well as Qt backend and version:\n        ``_qt_resources_{napari.__version__}_{API}_{QT_VERSION}.py``\n\n    overwrite : bool, optional\n        Whether to recompile and overwrite the resources.\n        Resources will be rebuilt if any of the following are True:\n        \n            - the resources file does not already exist.\n            - ``overwrite`` argument is True\n            - the ``NAPARI_REBUILD_RESOURCES`` environmental variable is set\n\n    Returns\n    -------\n    out_path : str\n        Path to the python resource file. File is already imported under `napari._qt_resources name`.\n        Copy this file to make the SVGs and other resources available in bundled application.\n\n    Raises\n    ------\n    PermissionError\n        If we cannot write to any of the requested locations.\n    """"""\n    # the resources filename holds the napari version, Qt API, and QT version\n    version = version or f\'{__version__}_{API}_{QT_VERSION}\'\n    filename = f\'_qt_resources_{version}.py\'\n\n    # see if we can write to the current napari/resources directory\n    target_file = _try_touch_file(join(abspath(dirname(__file__)), filename))\n    # if not, try to write to ~/.config/napari\n    if not target_file:\n        target_file = expanduser(join(\'~\', \'.config\', \'napari\', filename))\n        target_file = _try_touch_file(target_file)\n    # if that still doesn\'t work, create a temporary directory.\n    # all required files (themed SVG icons, res.qrc) will be temporarily built\n    # in this directory, and cleaned up after the resources are imported\n    if not target_file:\n        # not using context manager because we need it for build_pyqt_resources\n        # but tempdir will be cleaned automatically when the function ends\n        tempdir = TemporaryDirectory()\n        target_file = join(tempdir.name, filename)\n    # if we can\'t even write a temporary file, we\'re probably screwed...\n    if not target_file:\n        raise PermissionError(\n            ""Could not write qt_resources to disk. Please report this with a ""\n            ""description of your environment (pip freeze) at ""\n            ""https://github.com/napari/napari/issues""\n        )\n\n    # build the res.qrc Qt resources file, and then from that autogenerate\n    # the python resources file that needs to be imported.\n    # If the file already exists and overwrite is False, it will not be\n    # regenerated.\n    overwrite = overwrite or bool(environ.get(\'NAPARI_REBUILD_RESOURCES\'))\n    respath = build_pyqt_resources(fspath(target_file), overwrite=overwrite)\n\n    # import the python resources file and add to sys.modules\n    # https://stackoverflow.com/a/67692/1631624\n    spec = spec_from_file_location(""napari._qt_resources"", respath)\n    module = module_from_spec(spec)\n    # important to add to sys.modules! otherwise segfault when function ends.\n    sys.modules[spec.name] = module\n    spec.loader.exec_module(module)\n    return respath\n\n\n@lru_cache(maxsize=4)\ndef get_stylesheet(extra: Optional[List[str]] = None) -> str:\n    """"""Combine all qss files into single (cached) style string.\n    \n    Note, this string may still have {{ template_variables }} that need to be\n    replaced using the :func:`napari.utils.theme.template` function.  (i.e. the\n    output of this function serves as the input of ``template()``)\n\n    Parameters\n    ----------\n    extra : list of str, optional\n        Additional paths to QSS files to include in stylesheet, by default None\n    \n    Returns\n    -------\n    css : str\n        The combined stylesheet.\n    """"""\n    resources_dir = abspath(dirname(__file__))\n    stylesheet = \'\'\n    for file in sorted(glob(join(resources_dir, \'styles/*.qss\'))):\n        with open(file, \'r\') as f:\n            stylesheet += f.read()\n    if extra:\n        for file in extra:\n            with open(file, \'r\') as f:\n                stylesheet += f.read()\n    return stylesheet\n\n\n__all__ = [\'build_pyqt_resources\', \'get_stylesheet\', \'import_resources\']\n'"
napari/resources/build_icons.py,0,"b'""""""Utility script to generate copies of icons with colors based\non our themes. Neccessary workaround because qt does not allow\nfor styling svg elements using qss\n""""""\n\nimport os\nimport re\nimport shutil\nimport sys\nfrom subprocess import check_call\nfrom typing import Dict, List, Tuple\n\nfrom ..utils.theme import palettes as _palettes\n\nRESOURCES_DIR = os.path.abspath(os.path.dirname(__file__))\nSVGPATH = os.path.join(RESOURCES_DIR, \'icons\')\n\nsvg_tag_open = re.compile(r\'(<svg[^>]*>)\')\n\n\ndef themify_icons(\n    dest_dir: str,\n    svg_path: str = SVGPATH,\n    palettes: Dict[str, Dict[str, str]] = _palettes,\n    color_lookup: Dict[str, str] = None,\n) -> List[str]:\n    """"""Create a new ""themed"" SVG file, for every SVG file in ``svg_path``.\n\n    Parameters\n    ----------\n    dest_dir : str\n        The directory in which to write all of the themed icons.  Individual\n        themes will be in subdirectories named after each theme.\n    svg_path : str, optional\n        The folder to look in for SVG files, by default will search in a folder\n        named ``icons`` in the same directory as this file.\n    palettes : dict, optional\n        A mapping of ``theme_name: theme_dict``, where ``theme_dict`` is a\n        mapping of color classes to rgb strings. By default will uses palettes\n        from :const:`napari.resources.utils.theme.palettes`.\n    color_lookup : dict, optional\n        A mapping of icon name to color class.  If the icon name is not in the\n        color_lookup, it\'s color class will be ``""icon""``.\n\n    Returns\n    -------\n    files : list of str\n        a list of generaged SVG filepaths (each relative to dest_dir)\n    """"""\n\n    color_lookup = color_lookup or {\n        \'visibility\': \'text\',\n        \'visibility_off\': \'secondary\',\n        \'menu\': \'highlight\',\n        \'drop_down\': \'secondary\',\n        \'plus\': \'secondary\',\n        \'minus\': \'secondary\',\n        \'properties_contract\': \'secondary\',\n        \'properties_expand\': \'secondary\',\n    }\n    icon_names = [\n        i.replace(\'.svg\', \'\')\n        for i in os.listdir(SVGPATH)\n        if i.endswith(\'.svg\')\n    ]\n\n    svg_style_insert = r""""""<style type=""text/css"">\n    path{fill:{{ color }}}\n    polygon{fill:{{ color }}}\n    circle{fill:{{ color }}}\n    rect{fill:{{ color }}}\n    </style>""""""\n\n    files = []\n    for theme_name, palette in palettes.items():\n        palette_dir = os.path.join(dest_dir, theme_name)\n        os.makedirs(palette_dir, exist_ok=True)\n        for icon_name in icon_names:\n            svg_name = icon_name + \'.svg\'\n            new_file = os.path.join(palette_dir, svg_name)\n            color = color_lookup.get(icon_name, \'icon\')\n            css = svg_style_insert.replace(\'{{ color }}\', palette[color])\n            with open(os.path.join(SVGPATH, svg_name), \'r\') as fr:\n                contents = fr.read()\n            with open(new_file, \'w\') as fw:\n                # use regex to find the svg tag and insert css right after\n                # (the \'\\\\1\' syntax includes the matched tag in the output)\n                fw.write(svg_tag_open.sub(f\'\\\\1{css}\', contents))\n            files.append(os.path.join(theme_name, svg_name))\n    return files\n\n\ndef build_resources_qrc(\n    dest_dir: str, overwrite: bool = False\n) -> Tuple[str, str]:\n    """"""Create a res.qrc file for all icons generated by ``themify_icons``.\n\n    Parameters\n    ----------\n    dest_dir : str\n        The directory in which to write create the output file.  Themed SVG\n        icons will also be written to ``dest_dir/themes``.\n    overwrite : bool\n        Whether to force rebuilding of the icons and res.qrc file, by default\n        False\n\n    Returns\n    -------\n    tuple\n        2-tuple of (path-to-qrc.res, path-to-theme-directory).\n    """"""\n    qrc_path = os.path.join(dest_dir, \'res.qrc\')\n    theme_dir = os.path.join(dest_dir, \'themes\')\n    if os.path.exists(qrc_path) and (not overwrite):\n        return qrc_path, theme_dir\n\n    qrc_string = """"""\n    <!DOCTYPE RCC>\n    <RCC version=""1.0"">\n    <qresource>\n    """"""\n    for filename in themify_icons(theme_dir):\n        qrc_string += f\'\\n    <file>themes/{filename}</file>\'\n\n    qrc_string += """"""\n    </qresource>\n    </RCC>\n    """"""\n\n    with open(qrc_path, \'w\') as f:\n        f.write(qrc_string)\n\n    return qrc_path, theme_dir\n\n\ndef _find_rcc_or_raise() -> str:\n    """"""Locate the Qt rcc binary to generate resource files\n\n    1. we always want to use pyrcc5 if it\'s available, regardless of API\n    2. it will sometimes, (if not always) be named pyrcc5.bat on windows...\n       but shutil.which() will find that too\n    3. We also want to prefer binaries higher up on the path, and we add\n       sys.executable to the front of the path (and \\\\Scripts on windows)\n    4. after pyrcc5 we try pyside2-rcc\n\n    see https://github.com/napari/napari/issues/1221\n    and https://github.com/napari/napari/issues/1254\n\n    Returns\n    -------\n    path : str\n        Path to the located rcc binary, or None if not found\n\n    Raises\n    ------\n    FileNotFoundError\n        If no executable can be found.\n    """"""\n    python_dir = os.path.dirname(sys.executable)\n    paths = [python_dir, os.environ.get(""PATH"", \'\')]\n    if os.name == \'nt\':\n        paths.insert(0, os.path.join(python_dir, \'Scripts\'))\n    path = os.pathsep.join(paths)\n\n    for bin_name in (\'pyrcc5\', \'pyside2-rcc\'):\n        rcc_binary = shutil.which(bin_name, path=path)\n        if rcc_binary:\n            return rcc_binary\n    raise FileNotFoundError(\n        ""Unable to find an executable to build Qt resources (icons).\\n""\n        ""Tried: \'pyrcc5.bat\', \'pyrcc5\', \'pyside2-rcc\'.\\n""\n        ""Please open issue at https://github.com/napari/napari/issues/.""\n    )\n\n\ndef build_pyqt_resources(out_path: str, overwrite: bool = False) -> str:\n    """"""Build a res.qrc file from icons and convert for python usage.\n\n    calls :func:`build_resources` and then converts using ``pyside2-rcc`` or\n    ``pyrcc5`` depending on which is installed in the environment.\n    Finally, cleans up autogenerated icon.svgs and res.qrc file after _qt.py\n    file is generated\n\n    References\n    ----------\n    https://doc.qt.io/qt-5/resources.html\n\n    Parameters\n    ----------\n    out_path : str\n        Path to write the python resource file.\n    overwrite : bool, optional\n        Whether to force rebuilding of the output file, by default False\n\n    Returns\n    -------\n    out_path : str\n        Path to the python resource file.  Import this file to make the SVGs\n        and other resources available to Qt stylesheets.\n    """"""\n\n    if os.path.exists(out_path) and not overwrite:\n        return out_path\n\n    # build the resource file to the same path\n    qrc_path, theme_dir = build_resources_qrc(\n        os.path.dirname(out_path), overwrite=overwrite\n    )\n\n    # then convert it to a python file\n    check_call([_find_rcc_or_raise(), \'-o\', out_path, qrc_path])\n\n    # make sure we import from qtpy\n    with open(out_path, ""rt"") as fin:\n        data = fin.read()\n        data = data.replace(\'PySide2\', \'qtpy\').replace(\'PyQt5\', \'qtpy\')\n    with open(out_path, ""wt"") as fin:\n        fin.write(data)\n\n    # cleanup.\n    # we do this here because pip uninstall napari would not collect these\n    # and the final `out_path.py` contains all the necessary bytes info\n    shutil.rmtree(theme_dir, ignore_errors=True)\n    try:\n        os.remove(qrc_path)\n    except Exception:\n        pass\n    return out_path\n'"
napari/resources/test_resources.py,0,"b'from napari.resources import import_resources\nimport os\n\n\ndef test_resources():\n    """"""Test that we can build icons and resources.""""""\n    out = import_resources(version=\'test\')\n    os.remove(out)\n'"
napari/utils/__init__.py,0,"b'from .info import sys_info, citation_text\nfrom .dask_utils import resize_dask_cache\nfrom .notebook_display import nbscreenshot\n\n#: dask.cache.Cache, optional : A dask cache for opportunistic caching\n#: use :func:`~.resize_dask_cache` to actually register and resize.\ndask_cache = None\n'"
napari/utils/_magicgui.py,0,"b'""""""This module installs some napari-specific types in magicgui, if present.\n\nmagicgui is a package that allows users to create GUIs from python functions\nhttps://magicgui.readthedocs.io/en/latest/\n\nIt offers a function ``register_type`` that allows developers to specify how\ntheir custom classes or types should be converted into GUIs.  Then, when the\nend-user annotates one of their function arguments with a type hint using one\nof those custom classes, magicgui will know what to do with it.\n\n""""""\nfrom typing import Any, Tuple, Type, Optional\nfrom qtpy.QtWidgets import QWidget\n\nfrom ..layers import Layer\nfrom ..viewer import Viewer\n\ntry:\n    from magicgui import register_type as _magictype\nexcept ImportError:\n\n    def _magictype(*args, **kwargs):\n        pass\n\n\ndef register_types_with_magicgui():\n    """"""Register napari types with magicgui.\n\n    Parameter Annotations -> Widgets:\n        napari.layers.Layer, will be rendered as a ComboBox.\n            if a parameter is annotated as a subclass Layer type, then the\n            combobox options will be limited to that layer type.\n\n    Return Annotations -> Widgets:\n        napari.layers.Layer will add a new layer to the Viewer.\n            if a return is annotated as a subclass of Layer, then the\n            corresponding layer type will be added.\n            see `show_layer_result` for detail\n\n    """"""\n    _magictype(Layer, choices=get_layers, return_callback=show_layer_result)\n    _magictype(Viewer, choices=get_viewers)\n\n\ndef find_viewer_ancestor(widget: QWidget) -> Optional[Viewer]:\n    """"""Return the Viewer object if it is an ancestory of ``widget``, else None.\n\n    Parameters\n    ----------\n    widget : QWidget\n        A widget\n\n    Returns\n    -------\n    viewer : napari.Viewer or None\n        Viewer instance if one exists, else None.\n    """"""\n    parent = widget.parent()\n    while parent:\n        if hasattr(parent, \'qt_viewer\'):\n            return parent.qt_viewer.viewer\n        parent = parent.parent()\n    return None\n\n\ndef get_viewers(gui, *args) -> Tuple[Viewer, ...]:\n    """"""Return the viewer that the magicwidget is in, or a list of all Viewers.\n    """"""\n    viewer = find_viewer_ancestor(gui)\n    if viewer:\n        return (viewer,)\n    else:\n        # until we maintain a list of instantiated viewers, this might be the\n        # only option\n        return tuple(v for v in globals().values() if isinstance(v, Viewer))\n\n\ndef get_layers(gui, layer_type: Type[Layer]) -> Tuple[Layer, ...]:\n    """"""Retrieve layers of type `layer_type`, from the Viewer the gui is in.\n\n    Parameters\n    ----------\n    gui : MagicGui or QWidget\n        The instantiated MagicGui widget.  May or may not be docked in a\n        dock widget.\n    layer_type : type\n        This is the exact type used in the type hint of the user\'s\n        function. It may be a subclass of napari.layers.Layer\n\n    Returns\n    -------\n    tuple\n        Tuple of layers of type ``layer_type``\n\n    Example\n    -------\n    This allows the user to do this, and get a dropdown box in their GUI\n    that shows the available image layers.\n\n    >>> @magicgui\n    ... def get_layer_mean(layer: napari.layers.Image) -> float:\n    ...     return layer.data.mean()\n\n    """"""\n\n    viewer = find_viewer_ancestor(gui)\n    if viewer:\n        return tuple(l for l in viewer.layers if isinstance(l, layer_type))\n    return ()\n\n\ndef show_layer_result(gui, result: Any, return_type: Type[Layer]) -> None:\n    """"""Show a magicgui result in the viewer.\n\n    Parameters\n    ----------\n    gui : MagicGui or QWidget\n        The instantiated MagicGui widget.  May or may not be docked in a\n        dock widget.\n    result : Any\n        The result of the function call.\n    return_type : type\n        The return annotation that was used in the decorated function.\n    """"""\n    if result is None:\n        return\n\n    viewer = find_viewer_ancestor(gui)\n    if not viewer:\n        return\n\n    # if they have annotated the return type as a base layer (layers.Layer),\n    # NOT a subclass of it, then the function MUST return a list of\n    # LayerData tuples where:\n    # LayerData = Union[Tuple[data], Tuple[data, Dict], Tuple[data, Dict, str]]\n    # where `data` is the data for a given layer\n    # and `Dict` is a dict of keywords args that could be passed to that layer\n    # type\'s add_* method\n    if return_type == Layer:\n        if (\n            isinstance(result, list)\n            and (len(result))\n            and all(isinstance(i, tuple) and (0 < len(i) <= 3) for i in result)\n        ):\n            for layer_datum in result:\n                # if the layer data has a meta dict with a \'name\' key in it...\n                if (\n                    len(layer_datum) > 1\n                    and isinstance(layer_datum[1], dict)\n                    and layer_datum[1].get(\'name\')\n                ):\n                    # then try to update the viewer layer with that name.\n                    try:\n                        name = layer_datum[1].get(\'name\')\n                        viewer.layers[name].data = layer_datum[0]\n                        continue\n                    except KeyError:\n                        pass\n                # otherwise create a new layer from the layer data\n                viewer._add_layer_from_data(*layer_datum)\n            return\n        raise TypeError(\n            \'Functions annotated with a return type of \'\n            \'napari.layers.Layer MUST return a list of LayerData tuples\'\n        )\n\n    # Otherwise they annotated it as a subclass of layers.Layer, and we allow\n    # the simpler behavior where they only return the layer data.\n    try:\n        viewer.layers[gui.result_name].data = result\n    except KeyError:\n        adder = getattr(viewer, f\'add_{return_type.__name__.lower()}\')\n        adder(data=result, name=gui.result_name)\n'"
napari/utils/_register.py,0,"b'import inspect\n\nfrom .misc import camel_to_snake, callsignature\n\n\ntemplate = """"""def {name}(self, {signature}):\n    layer = {cls_name}({call_args})\n    self.add_layer(layer)\n    return layer\n""""""\n\n\ndef create_func(cls, name=None, doc=None):\n    module = inspect.getmodule(cls)\n\n    module_name = module.__name__\n    cls_name = cls.__name__\n    sig = inspect.signature(cls)\n    call_args = callsignature(cls)\n\n    if name is None:\n        name = camel_to_snake(cls_name)\n\n    if \'layer\' in name:\n        raise ValueError(f""name {name} should not include \'layer\'"")\n\n    name = \'add_\' + name\n\n    if doc is None:\n        doc = inspect.getdoc(cls)\n        cutoff = doc.find(\'\\n\\nParameters\\n----------\\n\')\n        if cutoff > 0:\n            doc = doc[cutoff:]\n\n        n = \'n\' if cls_name[0].lower() in \'aeiou\' else \'\'\n        doc = f\'Adds a{n} {cls_name} layer to the viewer. \' + doc\n        doc += \'\\n\\nReturns\\n-------\\n\'\n        doc += f\'layer : {module_name}.{cls_name}\'\n        doc += \'\\n\\tAdded layer.\'\n        doc = doc.expandtabs(4)\n\n    src = template.format(\n        name=name,\n        signature=str(sig)[1:-1],\n        cls_name=cls_name,\n        call_args=str(call_args)[1:-1],\n    )\n\n    execdict = {cls_name: cls}\n    exec(src, execdict)\n    func = execdict[name]\n\n    func.__doc__ = doc\n\n    return func\n\n\ndef _register(cls, *, name=None, doc=None):\n    from ..components import ViewerModel\n\n    func = create_func(cls, name=name, doc=doc)\n    setattr(ViewerModel, func.__name__, func)\n    return cls\n\n\ndef add_to_viewer(cls=None, *, name=None, doc=None):\n    """"""Adds a layer creation convenience method under viewers\n    as ``add_{name}``.\n\n    Parameters\n    ----------\n    cls : type, optional\n        Class to register.\n        If None, this function is treated as a decorator.\n    name : string, keyword-only\n        Name in snake-case of the layer name.\n        If None, is autogenerated from the class name.\n    doc : string, keyword-only\n        Docstring to use in the method.\n        If None, is autogenerated from the existing docstring.\n    """"""\n    if cls is not None:\n        return _register(cls, name=name, doc=doc)\n\n    def inner(cls):\n        return _register(cls, name=name, doc=doc)\n\n    return inner\n'"
napari/utils/dask_utils.py,0,"b'""""""Dask cache utilities.\n""""""\nfrom contextlib import contextmanager\nfrom typing import Callable, ContextManager, Optional\nimport warnings\n\nimport dask\nimport dask.array as da\nfrom dask.cache import Cache\n\nfrom .. import utils\n\n\ndef create_dask_cache(\n    nbytes: Optional[int] = None, mem_fraction: float = 0.5\n) -> Cache:\n    """"""Create a dask cache at utils.dask_cache if one doesn\'t already exist.\n\n    Parameters\n    ----------\n    nbytes : int, optional\n        The desired size of the cache, in bytes.  If ``None``, the cache size\n        will autodetermined as fraction of the total memory in the system,\n        using ``mem_fraction``.  If ``nbytes`` is 0, cache object will be\n        created, but not caching will occur. by default, cache size is\n        autodetermined using ``mem_fraction``.\n    mem_fraction : float, optional\n        The fraction (from 0 to 1) of total memory to use for the dask cache.\n        by default, 50% of total memory is used.\n\n    Returns\n    -------\n    dask_cache : dask.cache.Cache\n        An instance of a Dask Cache\n    """"""\n    import psutil\n\n    if nbytes is None:\n        nbytes = psutil.virtual_memory().total * mem_fraction\n    if not (\n        hasattr(utils, \'dask_cache\') and isinstance(utils.dask_cache, Cache)\n    ):\n        utils.dask_cache = Cache(nbytes)\n        utils.dask_cache.register()\n    return utils.dask_cache\n\n\ndef resize_dask_cache(\n    nbytes: Optional[int] = None, mem_fraction: float = None\n) -> Cache:\n    """"""Create or resize the dask cache used for opportunistic caching.\n\n    The cache object is an instance of a :class:`Cache`, (which\n    wraps a :class:`cachey.Cache`), and is made available at\n    :attr:`napari.utils.dask_cache`.\n\n    See `Dask opportunistic caching\n    <https://docs.dask.org/en/latest/caching.html>`_\n\n    Parameters\n    ----------\n    nbytes : int, optional\n        The desired size of the cache, in bytes.  If ``None``, the cache size\n        will autodetermined as fraction of the total memory in the system,\n        using ``mem_fraction``.  If ``nbytes`` is 0. The cache is turned off.\n        by default, cache size is autodetermined using ``mem_fraction``.\n    mem_fraction : float, optional\n        The fraction (from 0 to 1) of total memory to use for the dask cache.\n\n    Returns\n    -------\n    dask_cache : dask.cache.Cache\n        An instance of a Dask Cache\n\n    Example\n    -------\n    >>> from napari.utils import resize_dask_cache\n    >>> cache = resize_dask_cache()  # use 50% of total memory by default\n\n    >>> # dask.Cache wraps cachey.Cache\n    >>> assert isinstance(cache.cache, cachey.Cache)\n\n    >>> # useful attributes\n    >>> cache.cache.available_bytes  # full size of cache\n    >>> cache.cache.total_bytes   # currently used bytes\n    """"""\n\n    import psutil\n\n    if nbytes is None and mem_fraction is not None:\n        nbytes = psutil.virtual_memory().total * mem_fraction\n\n    # if we don\'t have a cache already, create one.  If neither nbytes nor\n    # mem_fraction was provided, it will use the default size as determined in\n    # create_cache.\n    if not (\n        hasattr(utils, \'dask_cache\') and isinstance(utils.dask_cache, Cache)\n    ):\n        return create_dask_cache(nbytes)\n    else:  # we already have a cache\n        # if the cache has already been registered, then calling\n        # resize_dask_cache() without supplying either mem_fraction or nbytes\n        # is a no-op:\n        if (\n            nbytes is not None\n            and nbytes != utils.dask_cache.cache.available_bytes\n        ):\n            utils.dask_cache.cache.resize(nbytes)\n\n    return utils.dask_cache\n\n\ndef _is_dask_data(data) -> bool:\n    """"""Return True if data is a dask array or a list/tuple of dask arrays.""""""\n    return isinstance(data, da.Array) or (\n        isinstance(data, (list, tuple))\n        and any(isinstance(i, da.Array) for i in data)\n    )\n\n\ndef configure_dask(data) -> Callable[[], ContextManager[dict]]:\n    """"""Spin up cache and return context manager that optimizes Dask indexing.\n\n    This function determines whether data is a dask array or list of dask\n    arrays and prepares some optimizations if so.\n\n    When a delayed dask array is given to napari, there are couple things that\n    need to be done to optimize performance.\n\n    1. Opportunistic caching needs to be enabled, such that we don\'t recompute\n       (or ""re-read"") data that has already been computed or read.\n\n    2. Dask task fusion must be turned off to prevent napari from triggering\n       new io on data that has already been read from disk. For example, with a\n       4D timelapse of 3D stacks, napari may actually *re-read* the entire 3D\n       tiff file every time the Z plane index is changed. Turning of Dask task\n       fusion with ``optimization.fuse.active == False`` prevents this.\n\n       .. note::\n\n          Turning off task fusion requires Dask version 2.15.0 or later.\n\n    For background and context, see `napari/napari#718\n    <https://github.com/napari/napari/issues/718>`_, `napari/napari#1124\n    <https://github.com/napari/napari/pull/1124>`_, and `dask/dask#6084\n    <https://github.com/dask/dask/pull/6084>`_.\n\n    For details on Dask task fusion, see the documentation on `Dask\n    Optimization <https://docs.dask.org/en/latest/optimize.html>`_.\n\n    Parameters\n    ----------\n    data : Any\n        data, as passed to a ``Layer.__init__`` method.\n\n    Returns\n    -------\n    ContextManager\n        A context manager that can be used to optimize dask indexing\n\n    Example\n    -------\n    >>> data = dask.array.ones((10,10,10))\n    >>> optimized_slicing = configure_dask(data)\n    >>> with optimized_slicing():\n    ...    data[0, 2].compute()\n    """"""\n    if _is_dask_data(data):\n        create_dask_cache()  # creates one if it doesn\'t exist\n        dask_version = tuple(map(int, dask.__version__.split(""."")))\n        if dask_version < (2, 15, 0):\n            warnings.warn(\n                \'For best performance with Dask arrays in napari, please \'\n                \'upgrade Dask to v2.15.0 or later. Current version is \'\n                f\'{dask.__version__}\'\n            )\n\n        def dask_optimized_slicing():\n            with dask.config.set({""optimization.fuse.active"": False}) as cfg:\n                yield cfg\n\n    else:\n\n        def dask_optimized_slicing():\n            yield {}\n\n    return contextmanager(dask_optimized_slicing)\n'"
napari/utils/event.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright (c) Vispy Development Team. All Rights Reserved.\n# Distributed under the (new) BSD License. See LICENSE.txt for more info.\n\n# # LICENSE.txt\n# Vispy licensing terms\n# ---------------------\n\n# Vispy is licensed under the terms of the (new) BSD license:\n#\n# Copyright (c) 2013-2017, Vispy Development Team. All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# * Redistributions of source code must retain the above copyright\n#   notice, this list of conditions and the following disclaimer.\n# * Redistributions in binary form must reproduce the above copyright\n#   notice, this list of conditions and the following disclaimer in the\n#   documentation and/or other materials provided with the distribution.\n# * Neither the name of Vispy Development Team nor the names of its\n#   contributors may be used to endorse or promote products\n#   derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS\n# IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER\n# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n#\n# Exceptions\n# ----------\n#\n# The examples code in the examples directory can be considered public\n# domain, unless otherwise indicated in the corresponding source file.\n\n""""""\nThe event module implements the classes that make up the event system.\nThe Event class and its subclasses are used to represent ""stuff that happens"".\nThe EventEmitter class provides an interface to connect to events and\nto emit events. The EmitterGroup groups EventEmitter objects.\n\nFor more information see http://github.com/vispy/vispy/wiki/API_Events\n\n""""""\n\nfrom __future__ import division\n\nfrom collections import OrderedDict\nimport inspect\nimport traceback\nimport weakref\n\nfrom vispy.util.logs import logger, _handle_exception\nfrom vispy.ext.six import string_types\n\n\nclass Event(object):\n\n    """"""Class describing events that occur and can be reacted to with callbacks.\n    Each event instance contains information about a single event that has\n    occurred such as a key press, mouse motion, timer activation, etc.\n\n    Subclasses: :class:`KeyEvent`, :class:`MouseEvent`, :class:`TouchEvent`,\n    :class:`StylusEvent`\n\n    The creation of events and passing of events to the appropriate callback\n    functions is the responsibility of :class:`EventEmitter` instances.\n\n    Note that each event object has an attribute for each of the input\n    arguments listed below.\n\n    Parameters\n    ----------\n    type : str\n       String indicating the event type (e.g. mouse_press, key_release)\n    native : object (optional)\n       The native GUI event object\n    **kwargs : keyword arguments\n        All extra keyword arguments become attributes of the event object.\n    """"""\n\n    def __init__(self, type, native=None, **kwargs):\n        # stack of all sources this event has been emitted through\n        self._sources = []\n        self._handled = False\n        self._blocked = False\n        # Store args\n        self._type = type\n        self._native = native\n        for k, v in kwargs.items():\n            setattr(self, k, v)\n\n    @property\n    def source(self):\n        """"""The object that the event applies to (i.e. the source of the event).\n        """"""\n        return self._sources[-1] if self._sources else None\n\n    @property\n    def sources(self):\n        """""" List of objects that the event applies to (i.e. are or have\n        been a source of the event). Can contain multiple objects in case\n        the event traverses a hierarchy of objects.\n        """"""\n        return self._sources\n\n    def _push_source(self, source):\n        self._sources.append(source)\n\n    def _pop_source(self):\n        return self._sources.pop()\n\n    @property\n    def type(self):\n        # No docstring; documeted in class docstring\n        return self._type\n\n    @property\n    def native(self):\n        # No docstring; documeted in class docstring\n        return self._native\n\n    @property\n    def handled(self):\n        """"""This boolean property indicates whether the event has already been\n        acted on by an event handler. Since many handlers may have access to\n        the same events, it is recommended that each check whether the event\n        has already been handled as well as set handled=True if it decides to\n        act on the event.\n        """"""\n        return self._handled\n\n    @handled.setter\n    def handled(self, val):\n        self._handled = bool(val)\n\n    @property\n    def blocked(self):\n        """"""This boolean property indicates whether the event will be delivered\n        to event callbacks. If it is set to True, then no further callbacks\n        will receive the event. When possible, it is recommended to use\n        Event.handled rather than Event.blocked.\n        """"""\n        return self._blocked\n\n    @blocked.setter\n    def blocked(self, val):\n        self._blocked = bool(val)\n\n    def __repr__(self):\n        # Try to generate a nice string representation of the event that\n        # includes the interesting properties.\n        # need to keep track of depth because it is\n        # very difficult to avoid excessive recursion.\n        global _event_repr_depth\n        _event_repr_depth += 1\n        try:\n            if _event_repr_depth > 2:\n                return ""<...>""\n            attrs = []\n            for name in dir(self):\n                if name.startswith(\'_\'):\n                    continue\n                # select only properties\n                if not hasattr(type(self), name) or not isinstance(\n                    getattr(type(self), name), property\n                ):\n                    continue\n                attr = getattr(self, name)\n\n                attrs.append(""%s=%s"" % (name, attr))\n            return ""<%s %s>"" % (self.__class__.__name__, "" "".join(attrs))\n        finally:\n            _event_repr_depth -= 1\n\n    def __str__(self):\n        """"""Shorter string representation""""""\n        return self.__class__.__name__\n\n\n_event_repr_depth = 0\n\n\nclass EventEmitter(object):\n\n    """"""Encapsulates a list of event callbacks.\n\n    Each instance of EventEmitter represents the source of a stream of similar\n    events, such as mouse click events or timer activation events. For\n    example, the following diagram shows the propagation of a mouse click\n    event to the list of callbacks that are registered to listen for that\n    event::\n\n       User clicks    |Canvas creates\n       mouse on       |MouseEvent:                |\'mouse_press\' EventEmitter:         |callbacks in sequence: # noqa\n       Canvas         |                           |                                    |  # noqa\n                   -->|event = MouseEvent(...) -->|Canvas.events.mouse_press(event) -->|callback1(event)  # noqa\n                      |                           |                                 -->|callback2(event)  # noqa\n                      |                           |                                 -->|callback3(event)  # noqa\n\n    Callback functions may be added or removed from an EventEmitter using\n    :func:`connect() <vispy.event.EventEmitter.connect>` or\n    :func:`disconnect() <vispy.event.EventEmitter.disconnect>`.\n\n    Calling an instance of EventEmitter will cause each of its callbacks\n    to be invoked in sequence. All callbacks are invoked with a single\n    argument which will be an instance of :class:`Event <vispy.event.Event>`.\n\n    EventEmitters are generally created by an EmitterGroup instance.\n\n    Parameters\n    ----------\n    source : object\n        The object that the generated events apply to. All emitted Events will\n        have their .source property set to this value.\n    type : str or None\n        String indicating the event type (e.g. mouse_press, key_release)\n    event_class : subclass of Event\n        The class of events that this emitter will generate.\n    """"""\n\n    def __init__(self, source=None, type=None, event_class=Event):\n        self._callbacks = []\n        self._callback_refs = []\n\n        # count number of times this emitter is blocked for each callback.\n        self._blocked = {None: 0}\n\n        # used to detect emitter loops\n        self.source = source\n        self.default_args = {}\n        if type is not None:\n            self.default_args[\'type\'] = type\n\n        assert inspect.isclass(event_class)\n        self.event_class = event_class\n\n        self._ignore_callback_errors = False  # True\n        self.print_callback_errors = \'reminders\'  # \'reminders\'\n\n    @property\n    def ignore_callback_errors(self):\n        """"""Whether exceptions during callbacks will be caught by the emitter\n\n        This allows it to continue invoking other callbacks if an error\n        occurs.\n        """"""\n        return self._ignore_callback_errors\n\n    @ignore_callback_errors.setter\n    def ignore_callback_errors(self, val):\n        self._ignore_callback_errors = val\n\n    @property\n    def print_callback_errors(self):\n        """"""Print a message and stack trace if a callback raises an exception\n\n        Valid values are ""first"" (only show first instance), ""reminders"" (show\n        complete first instance, then counts), ""always"" (always show full\n        traceback), or ""never"".\n\n        This assumes ignore_callback_errors=True. These will be raised as\n        warnings, so ensure that the vispy logging level is set to at\n        least ""warning"".\n        """"""\n        return self._print_callback_errors\n\n    @print_callback_errors.setter\n    def print_callback_errors(self, val):\n        if val not in (\'first\', \'reminders\', \'always\', \'never\'):\n            raise ValueError(\n                \'print_callback_errors must be ""first"", \'\n                \'""reminders"", ""always"", or ""never""\'\n            )\n        self._print_callback_errors = val\n\n    @property\n    def callback_refs(self):\n        """"""The set of callback references""""""\n        return tuple(self._callback_refs)\n\n    @property\n    def callbacks(self):\n        """"""The set of callbacks""""""\n        return tuple(self._callbacks)\n\n    @property\n    def source(self):\n        """"""The object that events generated by this emitter apply to""""""\n        return (\n            None if self._source is None else self._source()\n        )  # get object behind weakref\n\n    @source.setter\n    def source(self, s):\n        if s is None:\n            self._source = None\n        else:\n            self._source = weakref.ref(s)\n\n    def connect(\n        self, callback, ref=False, position=\'first\', before=None, after=None\n    ):\n        """"""Connect this emitter to a new callback.\n\n        Parameters\n        ----------\n        callback : function | tuple\n            *callback* may be either a callable object or a tuple\n            (object, attr_name) where object.attr_name will point to a\n            callable object. Note that only a weak reference to ``object``\n            will be kept.\n        ref : bool | str\n            Reference used to identify the callback in ``before``/``after``.\n            If True, the callback ref will automatically determined (see\n            Notes). If False, the callback cannot be referred to by a string.\n            If str, the given string will be used. Note that if ``ref``\n            is not unique in ``callback_refs``, an error will be thrown.\n        position : str\n            If ``\'first\'``, the first eligible position is used (that\n            meets the before and after criteria), ``\'last\'`` will use\n            the last position.\n        before : str | callback | list of str or callback | None\n            List of callbacks that the current callback should precede.\n            Can be None if no before-criteria should be used.\n        after : str | callback | list of str or callback | None\n            List of callbacks that the current callback should follow.\n            Can be None if no after-criteria should be used.\n\n        Notes\n        -----\n        If ``ref=True``, the callback reference will be determined from:\n\n            1. If ``callback`` is ``tuple``, the secend element in the tuple.\n            2. The ``__name__`` attribute.\n            3. The ``__class__.__name__`` attribute.\n\n        The current list of callback refs can be obtained using\n        ``event.callback_refs``. Callbacks can be referred to by either\n        their string reference (if given), or by the actual callback that\n        was attached (e.g., ``(canvas, \'swap_buffers\')``).\n\n        If the specified callback is already connected, then the request is\n        ignored.\n\n        If before is None and after is None (default), the new callback will\n        be added to the beginning of the callback list. Thus the\n        callback that is connected _last_ will be the _first_ to receive\n        events from the emitter.\n        """"""\n        callbacks = self.callbacks\n        callback_refs = self.callback_refs\n\n        callback = self._normalize_cb(callback)\n\n        if callback in callbacks:\n            return\n\n        # deal with the ref\n        if isinstance(ref, bool):\n            if ref:\n                if isinstance(callback, tuple):\n                    ref = callback[1]\n                elif hasattr(callback, \'__name__\'):  # function\n                    ref = callback.__name__\n                else:  # Method, or other\n                    ref = callback.__class__.__name__\n            else:\n                ref = None\n        elif not isinstance(ref, string_types):\n            raise TypeError(\'ref must be a bool or string\')\n        if ref is not None and ref in self._callback_refs:\n            raise ValueError(\'ref ""%s"" is not unique\' % ref)\n\n        # positions\n        if position not in (\'first\', \'last\'):\n            raise ValueError(\n                \'position must be ""first"" or ""last"", not %s\' % position\n            )\n\n        # bounds\n        bounds = list()  # upper & lower bnds (inclusive) of possible cb locs\n        for ri, criteria in enumerate((before, after)):\n            if criteria is None or criteria == []:\n                bounds.append(len(callback_refs) if ri == 0 else 0)\n            else:\n                if not isinstance(criteria, list):\n                    criteria = [criteria]\n                for c in criteria:\n                    count = sum(\n                        [\n                            (c == cn or c == cc)\n                            for cn, cc in zip(callback_refs, callbacks)\n                        ]\n                    )\n                    if count != 1:\n                        raise ValueError(\n                            \'criteria ""%s"" is in the current \'\n                            \'callback list %s times:\\n%s\\n%s\'\n                            % (criteria, count, callback_refs, callbacks)\n                        )\n                matches = [\n                    ci\n                    for ci, (cn, cc) in enumerate(\n                        zip(callback_refs, callbacks)\n                    )\n                    if (cc in criteria or cn in criteria)\n                ]\n                bounds.append(matches[0] if ri == 0 else (matches[-1] + 1))\n        if bounds[0] < bounds[1]:  # i.e., ""place before"" < ""place after""\n            raise RuntimeError(\n                \'cannot place callback before ""%s"" \'\n                \'and after ""%s"" for callbacks: %s\'\n                % (before, after, callback_refs)\n            )\n        idx = bounds[1] if position == \'first\' else bounds[0]  # \'last\'\n\n        # actually add the callback\n        self._callbacks.insert(idx, callback)\n        self._callback_refs.insert(idx, ref)\n        return callback  # allows connect to be used as a decorator\n\n    def disconnect(self, callback=None):\n        """"""Disconnect a callback from this emitter.\n\n        If no callback is specified, then *all* callbacks are removed.\n        If the callback was not already connected, then the call does nothing.\n        """"""\n        if callback is None:\n            self._callbacks = []\n            self._callback_refs = []\n        else:\n            callback = self._normalize_cb(callback)\n            if callback in self._callbacks:\n                idx = self._callbacks.index(callback)\n                self._callbacks.pop(idx)\n                self._callback_refs.pop(idx)\n\n    def _normalize_cb(self, callback):\n        # dereference methods into a (self, method_name) pair so that we can\n        # make the connection without making a strong reference to the\n        # instance.\n        if inspect.ismethod(callback):\n            callback = (callback.__self__, callback.__name__)\n\n        # always use a weak ref\n        if isinstance(callback, tuple) and not isinstance(\n            callback[0], weakref.ref\n        ):\n            callback = (weakref.ref(callback[0]),) + callback[1:]\n\n        return callback\n\n    def __call__(self, *args, **kwargs):\n        """""" __call__(**kwargs)\n        Invoke all callbacks for this emitter.\n\n        Emit a new event object, created with the given keyword\n        arguments, which must match with the input arguments of the\n        corresponding event class. Note that the \'type\' argument is\n        filled in by the emitter.\n\n        Alternatively, the emitter can also be called with an Event\n        instance as the only argument. In this case, the specified\n        Event will be used rather than generating a new one. This allows\n        customized Event instances to be emitted and also allows EventEmitters\n        to be chained by connecting one directly to another.\n\n        Note that the same Event instance is sent to all callbacks.\n        This allows some level of communication between the callbacks\n        (notably, via Event.handled) but also requires that callbacks\n        be careful not to inadvertently modify the Event.\n        """"""\n        # This is a VERY highly used method; must be fast!\n        blocked = self._blocked\n\n        # create / massage event as needed\n        event = self._prepare_event(*args, **kwargs)\n\n        # Add our source to the event; remove it after all callbacks have been\n        # invoked.\n        event._push_source(self.source)\n        try:\n            if blocked.get(None, 0) > 0:  # this is the same as self.blocked()\n                return event\n\n            rem = []\n            for cb in self._callbacks[:]:\n                if isinstance(cb, tuple):\n                    obj = cb[0]()\n                    if obj is None:\n                        rem.append(cb)\n                        continue\n                    cb = getattr(obj, cb[1], None)\n                    if cb is None:\n                        continue\n\n                if blocked.get(cb, 0) > 0:\n                    continue\n\n                self._invoke_callback(cb, event)\n                if event.blocked:\n                    break\n\n            # remove callbacks to dead objects\n            for cb in rem:\n                self.disconnect(cb)\n        finally:\n            if event._pop_source() != self.source:\n                raise RuntimeError(""Event source-stack mismatch."")\n\n        return event\n\n    def _invoke_callback(self, cb, event):\n        try:\n            cb(event)\n        except Exception:\n            _handle_exception(\n                self.ignore_callback_errors,\n                self.print_callback_errors,\n                self,\n                cb_event=(cb, event),\n            )\n\n    def _prepare_event(self, *args, **kwargs):\n        # When emitting, this method is called to create or otherwise alter\n        # an event before it is sent to callbacks. Subclasses may extend\n        # this method to make custom modifications to the event.\n        if len(args) == 1 and not kwargs and isinstance(args[0], Event):\n            event = args[0]\n            # Ensure that the given event matches what we want to emit\n            assert isinstance(event, self.event_class)\n        elif not args:\n            args = self.default_args.copy()\n            args.update(kwargs)\n            event = self.event_class(**args)\n        else:\n            raise ValueError(\n                ""Event emitters can be called with an Event ""\n                ""instance or with keyword arguments only.""\n            )\n        return event\n\n    def blocked(self, callback=None):\n        """"""Return boolean indicating whether the emitter is blocked for\n        the given callback.\n        """"""\n        return self._blocked.get(callback, 0) > 0\n\n    def block(self, callback=None):\n        """"""Block this emitter. Any attempts to emit an event while blocked\n        will be silently ignored. If *callback* is given, then the emitter\n        is only blocked for that specific callback.\n\n        Calls to block are cumulative; the emitter must be unblocked the same\n        number of times as it is blocked.\n        """"""\n        self._blocked[callback] = self._blocked.get(callback, 0) + 1\n\n    def unblock(self, callback=None):\n        """""" Unblock this emitter. See :func:`event.EventEmitter.block`.\n\n        Note: Use of ``unblock(None)`` only reverses the effect of\n        ``block(None)``; it does not unblock callbacks that were explicitly\n        blocked using ``block(callback)``.\n        """"""\n        if callback not in self._blocked or self._blocked[callback] == 0:\n            raise RuntimeError(\n                ""Cannot unblock %s for callback %s; emitter ""\n                ""was not previously blocked."" % (self, callback)\n            )\n        b = self._blocked[callback] - 1\n        if b == 0 and callback is not None:\n            del self._blocked[callback]\n        else:\n            self._blocked[callback] = b\n\n    def blocker(self, callback=None):\n        """"""Return an EventBlocker to be used in \'with\' statements\n\n           Notes\n           -----\n           For example, one could do::\n\n               with emitter.blocker():\n                   pass  # ..do stuff; no events will be emitted..\n        """"""\n        return EventBlocker(self, callback)\n\n\nclass WarningEmitter(EventEmitter):\n    """"""\n    EventEmitter subclass used to allow deprecated events to be used with a\n    warning message.\n    """"""\n\n    def __init__(self, message, *args, **kwargs):\n        self._message = message\n        self._warned = False\n        EventEmitter.__init__(self, *args, **kwargs)\n\n    def connect(self, cb, *args, **kwargs):\n        self._warn(cb)\n        return EventEmitter.connect(self, cb, *args, **kwargs)\n\n    def _invoke_callback(self, cb, event):\n        self._warn(cb)\n        return EventEmitter._invoke_callback(self, cb, event)\n\n    def _warn(self, cb):\n        if self._warned:\n            return\n\n        # don\'t warn about unimplemented connections\n        if isinstance(cb, tuple) and getattr(cb[0], cb[1], None) is None:\n            return\n\n        traceback.print_stack()\n        logger.warning(self._message)\n        self._warned = True\n\n\nclass EmitterGroup(EventEmitter):\n\n    """"""EmitterGroup instances manage a set of related\n    :class:`EventEmitters <vispy.event.EventEmitter>`.\n    Its primary purpose is to provide organization for objects\n    that make use of multiple emitters and to reduce the boilerplate code\n    needed to initialize those emitters with default connections.\n\n    EmitterGroup instances are usually stored as an \'events\' attribute on\n    objects that use multiple emitters. For example::\n\n         EmitterGroup  EventEmitter\n                 |       |\n        Canvas.events.mouse_press\n        Canvas.events.resized\n        Canvas.events.key_press\n\n    EmitterGroup is also a subclass of\n    :class:`EventEmitters <vispy.event.EventEmitter>`,\n    allowing it to emit its own\n    events. Any callback that connects directly to the EmitterGroup will\n    receive *all* of the events generated by the group\'s emitters.\n\n    Parameters\n    ----------\n    source : object\n        The object that the generated events apply to.\n    auto_connect : bool\n        If *auto_connect* is True (default), then one connection will\n        be made for each emitter that looks like\n        :func:`emitter.connect((source, \'on_\' + event_name))\n        <vispy.event.EventEmitter.connect>`.\n        This provides a simple mechanism for automatically connecting a large\n        group of emitters to default callbacks.\n    emitters : keyword arguments\n        See the :func:`add <vispy.event.EmitterGroup.add>` method.\n    """"""\n\n    def __init__(self, source=None, auto_connect=True, **emitters):\n        EventEmitter.__init__(self, source)\n\n        self.auto_connect = auto_connect\n        self.auto_connect_format = ""on_%s""\n        self._emitters = OrderedDict()\n        # whether the sub-emitters have been connected to the group:\n        self._emitters_connected = False\n        self.add(**emitters)\n\n    def __getitem__(self, name):\n        """"""\n        Return the emitter assigned to the specified name.\n        Note that emitters may also be retrieved as an attribute of the\n        EmitterGroup.\n        """"""\n        return self._emitters[name]\n\n    def __setitem__(self, name, emitter):\n        """"""\n        Alias for EmitterGroup.add(name=emitter)\n        """"""\n        self.add(**{name: emitter})\n\n    def add(self, auto_connect=None, **kwargs):\n        """""" Add one or more EventEmitter instances to this emitter group.\n        Each keyword argument may be specified as either an EventEmitter\n        instance or an Event subclass, in which case an EventEmitter will be\n        generated automatically::\n\n            # This statement:\n            group.add(mouse_press=MouseEvent,\n                      mouse_release=MouseEvent)\n\n            # ..is equivalent to this statement:\n            group.add(mouse_press=EventEmitter(group.source, \'mouse_press\',\n                                               MouseEvent),\n                      mouse_release=EventEmitter(group.source, \'mouse_press\',\n                                                 MouseEvent))\n        """"""\n        if auto_connect is None:\n            auto_connect = self.auto_connect\n\n        # check all names before adding anything\n        for name in kwargs:\n            if name in self._emitters:\n                raise ValueError(\n                    ""EmitterGroup already has an emitter named \'%s\'"" % name\n                )\n            elif hasattr(self, name):\n                raise ValueError(\n                    ""The name \'%s\' cannot be used as an emitter; ""\n                    ""it is already an attribute of EmitterGroup"" % name\n                )\n\n        # add each emitter specified in the keyword arguments\n        for name, emitter in kwargs.items():\n            if emitter is None:\n                emitter = Event\n\n            if inspect.isclass(emitter) and issubclass(emitter, Event):\n                emitter = EventEmitter(\n                    source=self.source, type=name, event_class=emitter\n                )\n            elif not isinstance(emitter, EventEmitter):\n                raise Exception(\n                    \'Emitter must be specified as either an \'\n                    \'EventEmitter instance or Event subclass. \'\n                    \'(got %s=%s)\' % (name, emitter)\n                )\n\n            # give this emitter the same source as the group.\n            emitter.source = self.source\n\n            setattr(self, name, emitter)\n            self._emitters[name] = emitter\n\n            if auto_connect and self.source is not None:\n                emitter.connect((self.source, self.auto_connect_format % name))\n\n            # If emitters are connected to the group already, then this one\n            # should be connected as well.\n            if self._emitters_connected:\n                emitter.connect(self)\n\n    @property\n    def emitters(self):\n        """""" List of current emitters in this group.\n        """"""\n        return self._emitters\n\n    def __iter__(self):\n        """"""\n        Iterates over the names of emitters in this group.\n        """"""\n        for k in self._emitters:\n            yield k\n\n    def block_all(self):\n        """""" Block all emitters in this group.\n        """"""\n        self.block()\n        for em in self._emitters.values():\n            em.block()\n\n    def unblock_all(self):\n        """""" Unblock all emitters in this group.\n        """"""\n        self.unblock()\n        for em in self._emitters.values():\n            em.unblock()\n\n    def connect(\n        self, callback, ref=False, position=\'first\', before=None, after=None\n    ):\n        """""" Connect the callback to the event group. The callback will receive\n        events from *all* of the emitters in the group.\n\n        See :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>`\n        for arguments.\n        """"""\n        self._connect_emitters(True)\n        return EventEmitter.connect(\n            self, callback, ref, position, before, after\n        )\n\n    def disconnect(self, callback=None):\n        """""" Disconnect the callback from this group. See\n        :func:`connect() <vispy.event.EmitterGroup.connect>` and\n        :func:`EventEmitter.connect() <vispy.event.EventEmitter.connect>` for\n        more information.\n        """"""\n        ret = EventEmitter.disconnect(self, callback)\n        if len(self._callbacks) == 0:\n            self._connect_emitters(False)\n        return ret\n\n    def _connect_emitters(self, connect):\n        # Connect/disconnect all sub-emitters from the group. This allows the\n        # group to emit an event whenever _any_ of the sub-emitters emit,\n        # while simultaneously eliminating the overhead if nobody is listening.\n        if connect:\n            for emitter in self:\n                self[emitter].connect(self)\n        else:\n            for emitter in self:\n                self[emitter].disconnect(self)\n\n        self._emitters_connected = connect\n\n    @property\n    def ignore_callback_errors(self):\n        return super(EventEmitter, self).ignore_callback_errors\n\n    @ignore_callback_errors.setter\n    def ignore_callback_errors(self, ignore):\n        EventEmitter.ignore_callback_errors.fset(self, ignore)\n        for emitter in self._emitters.values():\n            if isinstance(emitter, EventEmitter):\n                emitter.ignore_callback_errors = ignore\n            elif isinstance(emitter, EmitterGroup):\n                emitter.ignore_callback_errors_all(ignore)\n\n\nclass EventBlocker(object):\n\n    """""" Represents a block for an EventEmitter to be used in a context\n    manager (i.e. \'with\' statement).\n    """"""\n\n    def __init__(self, target, callback=None):\n        self.target = target\n        self.callback = callback\n\n    def __enter__(self):\n        self.target.block(self.callback)\n\n    def __exit__(self, *args):\n        self.target.unblock(self.callback)\n'"
napari/utils/info.py,0,"b'import platform\n\nimport sys\n\nimport napari\n\n\ndef sys_info(as_html=False):\n    """"""Gathers relevant module versions for troubleshooting purposes.\n\n    Parameters\n    ----------\n    as_html : bool\n        if True, info will be returned as HTML, suitable for a QTextEdit widget\n    """"""\n    from napari.plugins import plugin_manager\n\n    sys_version = sys.version.replace(\'\\n\', \' \')\n    text = (\n        f""<b>napari</b>: {napari.__version__}<br>""\n        f""<b>Platform</b>: {platform.platform()}<br>""\n        f""<b>Python</b>: {sys_version}<br>""\n    )\n\n    try:\n        from qtpy import API_NAME, PYQT_VERSION, PYSIDE_VERSION, QtCore\n\n        if API_NAME == \'PySide2\':\n            API_VERSION = PYSIDE_VERSION\n        elif API_NAME == \'PyQt5\':\n            API_VERSION = PYQT_VERSION\n        else:\n            API_VERSION = \'\'\n\n        text += (\n            f""<b>Qt</b>: {QtCore.__version__}<br>""\n            f""<b>{API_NAME}</b>: {API_VERSION}<br>""\n        )\n    except Exception as e:\n        text += f""<b>Qt</b>: Import failed ({e})<br>""\n\n    modules = (\n        (\'numpy\', \'NumPy\'),\n        (\'scipy\', \'SciPy\'),\n        (\'dask\', \'Dask\'),\n        (\'vispy\', \'VisPy\'),\n    )\n\n    loaded = {}\n    for module, name in modules:\n        try:\n            loaded[module] = __import__(module)\n            text += f""<b>{name}</b>: {loaded[module].__version__}<br>""\n        except Exception as e:\n            text += f""<b>{name}</b>: Import failed ({e})<br>""\n\n    if loaded.get(\'vispy\', False):\n        sys_info_text = ""<br>"".join(\n            [\n                loaded[\'vispy\'].sys_info().split(""\\n"")[index]\n                for index in [-4, -3]\n            ]\n        ).replace(""\'"", """")\n        text += f\'<br>{sys_info_text}\'\n\n    plugin_manager.discover()\n    plugin_strings = []\n    for meta in plugin_manager.list_plugin_metadata():\n        plugin_name = meta.get(\'plugin_name\')\n        if plugin_name == \'builtins\':\n            continue\n        version = meta.get(\'version\')\n        version_string = f"": {version}"" if version else """"\n        plugin_strings.append(f""  - {plugin_name}{version_string}"")\n    text += \'<br><br><b>Plugins</b>:\'\n    text += (\n        (""<br>"" + ""<br>"".join(sorted(plugin_strings)))\n        if plugin_strings\n        else \'  None\'\n    )\n\n    if not as_html:\n        text = (\n            text.replace(""<br>"", ""\\n"").replace(""<b>"", """").replace(""</b>"", """")\n        )\n    return text\n\n\ncitation_text = (\n    \'napari contributors (2019). napari: a \'\n    \'multi-dimensional image viewer for python. \'\n    \'doi:10.5281/zenodo.3555620\'\n)\n'"
napari/utils/interactions.py,0,"b'import inspect\nimport sys\n\nimport wrapt\nfrom numpydoc.docscrape import FunctionDoc\n\n\nclass ReadOnlyWrapper(wrapt.ObjectProxy):\n    """"""\n    Disable item and attribute setting with the exception of  ``__wrapped__``.\n    """"""\n\n    def __setattr__(self, name, val):\n        if name != \'__wrapped__\':\n            raise TypeError(f\'cannot set attribute {name}\')\n        super().__setattr__(name, val)\n\n    def __setitem__(self, name, val):\n        raise TypeError(f\'cannot set item {name}\')\n\n\ndef mouse_press_callbacks(obj, event):\n    """"""Run mouse press callbacks on either layer or viewer object.\n\n    Note that drag callbacks should have the following form:\n\n    .. code-block:: python\n\n        def hello_world(layer, event):\n            ""dragging""\n            # on press\n            print(\'hello world!\')\n            yield\n\n            # on move\n            while event.type == \'mouse_move\':\n                print(event.pos)\n                yield\n\n            # on release\n            print(\'goodbye world ;(\')\n\n    Parameters\n    ---------\n    obj : ViewerModel or Layer\n        Layer or Viewer object to run callbacks on\n    event : Event\n        Mouse event\n    """"""\n    # iterate through drag callback functions\n    for mouse_drag_func in obj.mouse_drag_callbacks:\n        # exectute function to run press event code\n        gen = mouse_drag_func(obj, event)\n        # if function returns a generator then try to iterate it\n        if inspect.isgenerator(gen):\n            try:\n                next(gen)\n                # now store iterated genenerator\n                obj._mouse_drag_gen[mouse_drag_func] = gen\n                # and now store event that initially triggered the press\n                obj._persisted_mouse_event[gen] = event\n            except StopIteration:\n                pass\n\n\ndef mouse_move_callbacks(obj, event):\n    """"""Run mouse move callbacks on either layer or viewer object.\n\n    Note that drag callbacks should have the following form:\n\n    .. code-block:: python\n\n        def hello_world(layer, event):\n            ""dragging""\n            # on press\n            print(\'hello world!\')\n            yield\n\n            # on move\n            while event.type == \'mouse_move\':\n                print(event.pos)\n                yield\n\n            # on release\n            print(\'goodbye world ;(\')\n\n    Parameters\n    ---------\n    obj : ViewerModel or Layer\n        Layer or Viewer object to run callbacks on\n    event : Event\n        Mouse event\n    """"""\n    if not event.is_dragging:\n        # if not dragging simply call the mouse move callbacks\n        for mouse_move_func in obj.mouse_move_callbacks:\n            mouse_move_func(obj, event)\n\n    # for each drag callback get the current generator\n    for func, gen in tuple(obj._mouse_drag_gen.items()):\n        # save the event current event\n        obj._persisted_mouse_event[gen].__wrapped__ = event\n        try:\n            # try to advance the generator\n            next(gen)\n        except StopIteration:\n            # If done deleted the generator and stored event\n            del obj._mouse_drag_gen[func]\n            del obj._persisted_mouse_event[gen]\n\n\ndef mouse_release_callbacks(obj, event):\n    """"""Run mouse release callbacks on either layer or viewer object.\n\n    Note that drag callbacks should have the following form:\n\n    .. code-block:: python\n\n        def hello_world(layer, event):\n            ""dragging""\n            # on press\n            print(\'hello world!\')\n            yield\n\n            # on move\n            while event.type == \'mouse_move\':\n                print(event.pos)\n                yield\n\n            # on release\n            print(\'goodbye world ;(\')\n\n    Parameters\n    ---------\n    obj : ViewerModel or Layer\n        Layer or Viewer object to run callbacks on\n    event : Event\n        Mouse event\n    """"""\n    for func, gen in tuple(obj._mouse_drag_gen.items()):\n        obj._persisted_mouse_event[gen].__wrapped__ = event\n        try:\n            # Run last part of the function to trigger release event\n            next(gen)\n        except StopIteration:\n            pass\n        # Finally delete the generator and stored event\n        del obj._mouse_drag_gen[func]\n        del obj._persisted_mouse_event[gen]\n\n\nKEY_SYMBOLS = {\n    \'Control\': \'Ctrl\',\n    \'Shift\': \'\xe2\x87\xa7\',\n    \'Alt\': \'Alt\',\n    \'Option\': \'Opt\',\n    \'Meta\': \'\xe2\x8a\x9e\',\n    \'Left\': \'\xe2\x86\x90\',\n    \'Right\': \'\xe2\x86\x92\',\n    \'Up\': \'\xe2\x86\x91\',\n    \'Down\': \'\xe2\x86\x93\',\n    \'Backspace\': \'\xe2\x8c\xab\',\n    \'Tab\': \'\xe2\x86\xb9\',\n    \'Escape\': \'Esc\',\n    \'Return\': \'\xe2\x8f\x8e\',\n    \'Enter\': \'\xe2\x86\xb5\',\n}\n\n\nif sys.platform.startswith(\'darwin\'):\n    KEY_SYMBOLS.update(\n        {\'Control\': \'\xe2\x8c\x98\', \'Alt\': \'\xe2\x8c\xa5\', \'Option\': \'\xe2\x8c\xa5\', \'Meta\': \'\xe2\x8c\x83\'}\n    )\nelif sys.platform.startswith(\'linux\'):\n    KEY_SYMBOLS.update({\'Meta\': \'Super\'})\n\n\ndef get_key_bindings_summary(keymap, col=\'rgb(134, 142, 147)\'):\n    """"""Get summary of key bindings in keymap.\n\n    Parameters\n    ---------\n    keymap : dict\n        Dictionary of key bindings.\n    col : str\n        Color string in format rgb(int, int, int) used for highlighting\n        keypress combination.\n\n    Returns\n    ---------\n    key_bindings_str : str\n        String with summary of all key_bindings and their functions.\n    """"""\n    key_bindings_str = \'<table border=""0"" width=""100%"">\'\n    for key in keymap:\n        keycodes = [KEY_SYMBOLS.get(k, k) for k in key.split(\'-\')]\n        keycodes = ""+"".join(\n            [f""<span style=\'color: {col}\'><b>{k}</b></span>"" for k in keycodes]\n        )\n        key_bindings_str += (\n            ""<tr><td width=\'80\' style=\'text-align: right; padding: 4px;\'>""\n            f""<span style=\'color: rgb(66, 72, 80)\'>{keycodes}</span></td>""\n            ""<td style=\'text-align: left; padding: 4px; color: #CCC;\'>""\n            f""{get_function_summary(keymap[key])}</td></tr>""\n        )\n    key_bindings_str += \'</table>\'\n    return key_bindings_str\n\n\ndef get_function_summary(func):\n    """"""Get summary of doc string of function.""""""\n    doc = FunctionDoc(func)\n    summary = \'\'\n    for s in doc[\'Summary\']:\n        summary += s\n    return summary.rstrip(\'.\')\n'"
napari/utils/io.py,22,"b'import csv\nimport os\nimport re\nfrom glob import glob\nfrom pathlib import Path\nfrom typing import List, Optional, Tuple, Union\nfrom ..types import FullLayerData\n\nimport numpy as np\nfrom dask import array as da\nfrom dask import delayed\n\nfrom ..utils.misc import abspath_or_url\n\n\ndef imsave(filename: str, data: np.ndarray):\n    """"""Custom implementation of imsave to avoid skimage dependency.\n\n    Parameters\n    ----------\n    filename : string\n        The path to write the file to.\n    data : np.ndarray\n        The image data.\n    """"""\n    ext = os.path.splitext(filename)[1]\n    if ext in ["".tif"", "".tiff""]:\n        import tifffile\n\n        tifffile.imsave(filename, data)\n    else:\n        import imageio\n\n        imageio.imsave(filename, data)\n\n\ndef imsave_extensions() -> Tuple[str, ...]:\n    """"""Valid extensions of files that imsave can write to.\n\n    Returns\n    ----------\n    tuple\n        Valid extensions of files that imsave can write to.\n    """"""\n    # import imageio\n    # return tuple(set(x for f in imageio.formats for x in f.extensions))\n\n    # The above method generates a lot of extensions that will fail.  This list\n    # is a more realistic set, generated by trying to write a variety of numpy\n    # arrays (skimage.data.camera, grass, and some random numpy arrays/shapes).\n    # TODO: maybe write a proper imageio plugin.\n    return (\n        \'.bmp\',\n        \'.bsdf\',\n        \'.bw\',\n        \'.eps\',\n        \'.gif\',\n        \'.icns\',\n        \'.ico\',\n        \'.im\',\n        \'.j2c\',\n        \'.j2k\',\n        \'.jfif\',\n        \'.jp2\',\n        \'.jpc\',\n        \'.jpe\',\n        \'.jpeg\',\n        \'.jpf\',\n        \'.jpg\',\n        \'.jpx\',\n        \'.lsm\',\n        \'.mpo\',\n        \'.npz\',\n        \'.pbm\',\n        \'.pcx\',\n        \'.pgm\',\n        \'.png\',\n        \'.ppm\',\n        \'.ps\',\n        \'.rgb\',\n        \'.rgba\',\n        \'.sgi\',\n        \'.stk\',\n        \'.tga\',\n        \'.tif\',\n        \'.tiff\',\n    )\n\n\ndef imread(filename: str) -> np.ndarray:\n    """"""Custom implementation of imread to avoid skimage dependency.\n\n    Parameters\n    ----------\n    filename : string\n        The path from which to read the image.\n\n    Returns\n    -------\n    data : np.ndarray\n        The image data.\n    """"""\n    filename = abspath_or_url(filename)\n    ext = os.path.splitext(filename)[1]\n    if ext in ["".tif"", "".tiff"", "".lsm""]:\n        import tifffile\n\n        return tifffile.imread(filename)\n    else:\n        import imageio\n\n        return imageio.imread(filename)\n\n\ndef _alphanumeric_key(s):\n    """"""Convert string to list of strings and ints that gives intuitive sorting.\n\n    Parameters\n    ----------\n    s : string\n\n    Returns\n    -------\n    k : a list of strings and ints\n\n    Examples\n    --------\n    >>> _alphanumeric_key(\'z23a\')\n    [\'z\', 23, \'a\']\n    >>> filenames = [\'f9.10.png\', \'e10.png\', \'f9.9.png\', \'f10.10.png\',\n    ...              \'f10.9.png\']\n    >>> sorted(filenames)\n    [\'e10.png\', \'f10.10.png\', \'f10.9.png\', \'f9.10.png\', \'f9.9.png\']\n    >>> sorted(filenames, key=_alphanumeric_key)\n    [\'e10.png\', \'f9.9.png\', \'f9.10.png\', \'f10.9.png\', \'f10.10.png\']\n    """"""\n    k = [int(c) if c.isdigit() else c for c in re.split(\'([0-9]+)\', s)]\n    return k\n\n\ndef magic_imread(filenames, *, use_dask=None, stack=True):\n    """"""Dispatch the appropriate reader given some files.\n\n    The files are assumed to all have the same shape.\n\n    Parameters\n    -------\n    filenames : list\n        List of filenames or directories to be opened.\n        A list of `pathlib.Path` objects and a single filename or `Path` object\n        are also accepted.\n    use_dask : bool\n        Whether to use dask to create a lazy array, rather than NumPy.\n        Default of None will resolve to True if filenames contains more than\n        one image, False otherwise.\n    stack : bool\n        Whether to stack the images in multiple files into a single array. If\n        False, a list of arrays will be returned.\n\n    Returns\n    -------\n    image : array-like\n        Array or list of images\n    """"""\n    # cast Path to string\n    if isinstance(filenames, Path):\n        filenames = filenames.as_posix()\n\n    if len(filenames) == 0:\n        return None\n    if isinstance(filenames, str):\n        filenames = [filenames]  # ensure list\n\n    # replace folders with their contents\n    filenames_expanded = []\n    for filename in filenames:\n        ext = os.path.splitext(filename)[-1]\n        # zarr files are folders, but should be read as 1 file\n        if os.path.isdir(filename) and not ext == \'.zarr\':\n            dir_contents = sorted(\n                glob(os.path.join(filename, \'*.*\')), key=_alphanumeric_key\n            )\n            # remove subdirectories\n            dir_contents_files = filter(\n                lambda f: not os.path.isdir(f), dir_contents\n            )\n            filenames_expanded.extend(dir_contents_files)\n        else:\n            filenames_expanded.append(filename)\n\n    if use_dask is None:\n        use_dask = len(filenames_expanded) > 1\n\n    if not filenames_expanded:\n        raise ValueError(\n            f""No files found in {filenames} after removing subdirectories""\n        )\n\n    # then, read in images\n    images = []\n    shape = None\n    for filename in filenames_expanded:\n        ext = os.path.splitext(filename)[-1]\n        if ext == \'.zarr\':\n            image, zarr_shape = read_zarr_dataset(filename)\n            if shape is None:\n                shape = zarr_shape\n        else:\n            if shape is None:\n                image = imread(filename)\n                shape = image.shape\n                dtype = image.dtype\n            if use_dask:\n                image = da.from_delayed(\n                    delayed(imread)(filename), shape=shape, dtype=dtype\n                )\n            elif len(images) > 0:  # not read by shape clause\n                image = imread(filename)\n        images.append(image)\n    if len(images) == 1:\n        image = images[0]\n    else:\n        if stack:\n            if use_dask:\n                image = da.stack(images)\n            else:\n                try:\n                    image = np.stack(images)\n                except ValueError as e:\n                    if \'input arrays must have the same shape\' in str(e):\n                        msg = (\n                            \'To stack multiple files into a single array with \'\n                            \'numpy, all input arrays must have the same shape.\'\n                            \' Set `use_dask` to True to stack arrays with \'\n                            \'different shapes.\'\n                        )\n                        raise ValueError(msg) from e\n                    else:\n                        raise e\n        else:\n            image = images  # return a list\n    return image\n\n\ndef read_zarr_dataset(path):\n    """"""Read a zarr dataset, including an array or a group of arrays.\n\n    Parameters\n    --------\n    path : str\n        Path to directory ending in \'.zarr\'. Path can contain either an array\n        or a group of arrays in the case of multiscale data.\n    Returns\n    -------\n    image : array-like\n        Array or list of arrays\n    shape : tuple\n        Shape of array or first array in list\n    """"""\n    if os.path.exists(os.path.join(path, \'.zarray\')):\n        # load zarr array\n        image = da.from_zarr(path)\n        shape = image.shape\n    elif os.path.exists(os.path.join(path, \'.zgroup\')):\n        # else load zarr all arrays inside file, useful for multiscale data\n        image = []\n        for subpath in sorted(os.listdir(path)):\n            if not subpath.startswith(\'.\'):\n                image.append(read_zarr_dataset(os.path.join(path, subpath))[0])\n        shape = image[0].shape\n    else:\n        raise ValueError(f""Not a zarr dataset or group: {path}"")\n    return image, shape\n\n\ndef write_csv(\n    filename: str,\n    data: Union[List, np.ndarray],\n    column_names: Optional[List[str]] = None,\n):\n    """"""Write a csv file.\n\n    Parameters\n    ----------\n    filename : str\n        Filename for saving csv.\n    data : list or ndarray\n        Table values, contained in a list of lists or an ndarray.\n    column_names : list, optional\n        List of column names for table data.\n    """"""\n    with open(filename, mode=\'w\', newline=\'\') as csvfile:\n        writer = csv.writer(\n            csvfile, delimiter=\',\', quotechar=\'""\', quoting=csv.QUOTE_MINIMAL,\n        )\n        if column_names is not None:\n            writer.writerow(column_names)\n        for row in data:\n            writer.writerow(row)\n\n\ndef guess_layer_type_from_column_names(\n    column_names: List[str],\n) -> Optional[str]:\n    """"""Guess layer type based on column names from a csv file.\n\n    Parameters\n    ----------\n    column_names : list of str\n        List of the column names from the csv.\n\n    Returns\n    -------\n    str or None\n        Layer type if recognized, otherwise None.\n    """"""\n\n    if set(\n        [\'index\', \'shape-type\', \'vertex-index\', \'axis-0\', \'axis-1\']\n    ).issubset(column_names):\n        return \'shapes\'\n    elif set([\'axis-0\', \'axis-1\']).issubset(column_names):\n        return \'points\'\n    else:\n        return None\n\n\ndef read_csv(\n    filename: str, require_type: str = None\n) -> Tuple[np.array, List[str], Optional[str]]:\n    """"""Return CSV data only if column names match format for ``require_type``.\n\n    Reads only the first line of the CSV at first, then optionally raises an\n    exception if the column names are not consistent with a known format, as\n    determined by the ``require_type`` argument and\n    :func:`guess_layer_type_from_column_names`.\n\n    Parameters\n    ----------\n    filename : str\n        Path of file to open\n    require_type : str, optional\n        The desired layer type. If provided, should be one of the keys in\n        ``csv_reader_functions`` or the string ""any"".  If ``None``, data, will\n        not impose any format requirements on the csv, and data will always be\n        returned.  If ``any``, csv must be recognized as one of the valid layer\n        data formats, otherwise a ``ValueError`` will be raised.  If a specific\n        layer type string, then a ``ValueError`` will be raised if the column\n        names are not of the predicted format.\n\n    Returns\n    -------\n    (data, column_names, layer_type) : Tuple[np.array, List[str], str]\n        The table data and column names from the CSV file, along with the\n        detected layer type (string).\n\n    Raises\n    ------\n    ValueError\n        If the column names do not match the format requested by\n        ``require_type``.\n    """"""\n    with open(filename, newline=\'\') as csvfile:\n        reader = csv.reader(csvfile, delimiter=\',\')\n        column_names = next(reader)\n\n        layer_type = guess_layer_type_from_column_names(column_names)\n        if require_type:\n            if not layer_type:\n                raise ValueError(\n                    f\'File ""{filename}"" not recognized as valid Layer data\'\n                )\n            elif layer_type != require_type and require_type.lower() != ""any"":\n                raise ValueError(\n                    f\'File ""{filename}"" not recognized as {require_type} data\'\n                )\n\n        data = np.array(list(reader))\n    return data, column_names, layer_type\n\n\ndef csv_to_layer_data(\n    path: str, require_type: str = None\n) -> Optional[FullLayerData]:\n    """"""Return layer data from a CSV file if detected as a valid type.\n\n    Parameters\n    ----------\n    path : str\n        Path of file to open\n    require_type : str, optional\n        The desired layer type. If provided, should be one of the keys in\n        ``csv_reader_functions`` or the string ""any"".  If ``None``,\n        unrecognized CSV files will simply return ``None``.  If ``any``,\n        unrecognized CSV files will raise a ``ValueError``.  If a specific\n        layer type string, then a ``ValueError`` will be raised if the column\n        names are not of the predicted format.\n\n    Returns\n    -------\n    layer_data : tuple, or None\n        3-tuple ``(array, dict, str)`` (points data, metadata, layer_type) if\n        CSV is recognized as a valid type.\n\n    Raises\n    ------\n    ValueError\n        If ``require_type`` is not ``None``, but the CSV is not detected as a\n        valid data format.\n    """"""\n    try:\n        # pass at least require ""any"" here so that we don\'t bother reading the\n        # full dataset if it\'s not going to yield valid layer_data.\n        _require = require_type or \'any\'\n        table, column_names, _type = read_csv(path, require_type=_require)\n    except ValueError:\n        if not require_type:\n            return None\n        raise\n    if _type in csv_reader_functions:\n        return csv_reader_functions[_type](table, column_names)\n    return None  # only reachable if it is a valid layer type without a reader\n\n\ndef _points_csv_to_layerdata(\n    table: np.ndarray, column_names: List[str]\n) -> FullLayerData:\n    """"""Convert table data and column names from a csv file to Points LayerData.\n\n    Parameters\n    ----------\n    table : np.ndarray\n        CSV data.\n    column_names : list of str\n        The column names of the csv file\n\n    Returns\n    -------\n    layer_data : tuple\n        3-tuple ``(array, dict, str)`` (points data, metadata, \'points\')\n    """"""\n\n    data_axes = [cn.startswith(\'axis-\') for cn in column_names]\n    data = np.array(table[:, data_axes]).astype(\'float\')\n\n    # Add properties to metadata if provided\n    prop_axes = np.logical_not(data_axes)\n    if column_names[0] == \'index\':\n        prop_axes[0] = False\n    meta = {}\n    if np.any(prop_axes):\n        meta[\'properties\'] = {}\n        for ind in np.nonzero(prop_axes)[0]:\n            values = table[:, ind]\n            try:\n                values = np.array(values).astype(\'int\')\n            except ValueError:\n                try:\n                    values = np.array(values).astype(\'float\')\n                except ValueError:\n                    pass\n            meta[\'properties\'][column_names[ind]] = values\n\n    return data, meta, \'points\'\n\n\ndef _shapes_csv_to_layerdata(\n    table: np.ndarray, column_names: List[str]\n) -> FullLayerData:\n    """"""Convert table data and column names from a csv file to Shapes LayerData.\n\n    Parameters\n    ----------\n    table : np.ndarray\n        CSV data.\n    column_names : list of str\n        The column names of the csv file\n\n    Returns\n    -------\n    layer_data : tuple\n        3-tuple ``(array, dict, str)`` (points data, metadata, \'shapes\')\n    """"""\n\n    data_axes = [cn.startswith(\'axis-\') for cn in column_names]\n    raw_data = np.array(table[:, data_axes]).astype(\'float\')\n\n    inds = np.array(table[:, 0]).astype(\'int\')\n    n_shapes = max(inds) + 1\n    # Determine when shape id changes\n    transitions = list((np.diff(inds)).nonzero()[0] + 1)\n    shape_boundaries = [0] + transitions + [len(table)]\n    if n_shapes != len(shape_boundaries) - 1:\n        raise ValueError(\'Expected number of shapes not found\')\n\n    data = []\n    shape_type = []\n    for ind_a, ind_b in zip(shape_boundaries[:-1], shape_boundaries[1:]):\n        data.append(raw_data[ind_a:ind_b])\n        shape_type.append(table[ind_a, 1])\n\n    return data, {\'shape_type\': shape_type}, \'shapes\'\n\n\ncsv_reader_functions = {\n    \'points\': _points_csv_to_layerdata,\n    \'shapes\': _shapes_csv_to_layerdata,\n}\n'"
napari/utils/key_bindings.py,0,"b'""""""Key combinations are represented in the form ``[modifier-]key``,\ne.g. ``a``, ``Control-c``, or ``Control-Alt-Delete``.\nValid modifiers are Control, Alt, Shift, and Meta.\n\nLetters will always be read as upper-case.\nDue to the native implementation of the key system, Shift pressed in\ncertain key combinations may yield inconsistent or unexpected results.\nTherefore, it is not recommended to use Shift with non-letter keys. On OSX,\nControl is swapped with Meta such that pressing Command reads as Control.\n\nSpecial keys include Shift, Control, Alt, Meta, Up, Down, Left, Right,\nPageUp, PageDown, Insert, Delete, Home, End, Escape, Backspace, F1,\nF2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, Space, Enter, and Tab\n\nFunctions take in only one argument: the parent that the function\nwas bound to.\n\nBy default, all functions are assumed to work on key presses only,\nbut can be denoted to work on release too by separating the function\ninto two statements with the yield keyword::\n\n    @viewer.bind_key(\'h\')\n    def hello_world(viewer):\n        # on key press\n        viewer.status = \'hello world!\'\n\n        yield\n\n        # on key release\n        viewer.status = \'goodbye world :(\'\n\nTo create a keymap that will block others, ``bind_key(..., ...)```.\n""""""\n\nimport inspect\nimport re\nimport types\nfrom collections import ChainMap\n\nfrom vispy.util import keys\n\n\nSPECIAL_KEYS = [\n    keys.SHIFT,\n    keys.CONTROL,\n    keys.ALT,\n    keys.META,\n    keys.UP,\n    keys.DOWN,\n    keys.LEFT,\n    keys.RIGHT,\n    keys.PAGEUP,\n    keys.PAGEDOWN,\n    keys.INSERT,\n    keys.DELETE,\n    keys.HOME,\n    keys.END,\n    keys.ESCAPE,\n    keys.BACKSPACE,\n    keys.F1,\n    keys.F2,\n    keys.F3,\n    keys.F4,\n    keys.F5,\n    keys.F6,\n    keys.F7,\n    keys.F8,\n    keys.F9,\n    keys.F10,\n    keys.F11,\n    keys.F12,\n    keys.SPACE,\n    keys.ENTER,\n    keys.TAB,\n]\n\nMODIFIER_KEYS = [keys.CONTROL, keys.ALT, keys.SHIFT, keys.META]\n\n\ndef parse_key_combo(key_combo):\n    """"""Parse a key combination into its components in a comparable format.\n\n    Parameters\n    ----------\n    key_combo : str\n        Key combination.\n\n    Returns\n    -------\n    key : str\n        Base key of the combination.\n    modifiers : set of str\n        Modifier keys of the combination.\n    """"""\n    parsed = re.split(\'-(?=.+)\', key_combo)\n    *modifiers, key = parsed\n\n    return key, set(modifiers)\n\n\ndef components_to_key_combo(key, modifiers):\n    """"""Combine components to become a key combination.\n\n    Modifier keys will always be combined in the same order:\n    Control, Alt, Shift, Meta\n\n    Letters will always be read as upper-case.\n    Due to the native implementation of the key system, Shift pressed in\n    certain key combinations may yield inconsistent or unexpected results.\n    Therefore, it is not recommended to use Shift with non-letter keys. On OSX,\n    Control is swapped with Meta such that pressing Command reads as Control.\n\n    Parameters\n    ----------\n    key : str or vispy.app.Key\n        Base key.\n    modifiers : combination of str or vispy.app.Key\n        Modifier keys.\n\n    Returns\n    -------\n    key_combo : str\n        Generated key combination.\n    """"""\n    if len(key) == 1 and key.isalpha():  # it\'s a letter\n        key = key.upper()\n        cond = lambda m: True  # noqa: E731\n    elif key in SPECIAL_KEYS:\n        # remove redundant information i.e. an output of \'Shift-Shift\'\n        cond = lambda m: m != key  # noqa: E731\n    else:\n        # Shift is consumed to transform key\n\n        # bug found on OSX: Command will cause Shift to not\n        # transform the key so do not consume it\n        # note: \'Control\' is OSX Command key\n        cond = lambda m: m != \'Shift\' or \'Control\' in modifiers  # noqa: E731\n\n    modifiers = tuple(\n        key.name\n        for key in filter(\n            lambda key: key in modifiers and cond(key), MODIFIER_KEYS\n        )\n    )\n\n    return \'-\'.join(modifiers + (key,))\n\n\ndef normalize_key_combo(key_combo):\n    """"""Normalize key combination to make it easily comparable.\n\n    All aliases are converted and modifier orders are fixed to:\n    Control, Alt, Shift, Meta\n\n    Letters will always be read as upper-case.\n    Due to the native implementation of the key system, Shift pressed in\n    certain key combinations may yield inconsistent or unexpected results.\n    Therefore, it is not recommended to use Shift with non-letter keys. On OSX,\n    Control is swapped with Meta such that pressing Command reads as Control.\n\n    Parameters\n    ----------\n    key_combo : str\n        Key combination.\n\n    Returns\n    -------\n    normalized_key_combo : str\n        Normalized key combination.\n    """"""\n    key, modifiers = parse_key_combo(key_combo)\n\n    if len(key) != 1 and key not in SPECIAL_KEYS:\n        raise TypeError(f\'invalid key {key}\')\n\n    for modifier in modifiers:\n        if modifier not in MODIFIER_KEYS:\n            raise TypeError(f\'invalid modifier key {modifier}\')\n\n    return components_to_key_combo(key, modifiers)\n\n\nUNDEFINED = object()\n\n\ndef bind_key(keymap, key, func=UNDEFINED, *, overwrite=False):\n    """"""Bind a key combination to a keymap.\n\n    Parameters\n    ----------\n    keymap : dict of str: callable\n        Keymap to modify.\n    key : str or ...\n        Key combination.\n        ``...`` acts as a wildcard if no key combinations can be matched\n        in the keymap (this will overwrite all key combinations\n        further down the lookup chain).\n    func : callable, None, or ...\n        Callable to bind to the key combination.\n        If ``None`` is passed, unbind instead.\n        ``...`` acts as a blocker, effectively unbinding the key\n        combination for all keymaps further down the lookup chain.\n    overwrite : bool, keyword-only, optional\n        Whether to overwrite the key combination if it already exists.\n\n    Returns\n    -------\n    unbound : callable or None\n        Callable unbound by this operation, if any.\n\n    Notes\n    -----\n    Key combinations are represented in the form ``[modifier-]key``,\n    e.g. ``a``, ``Control-c``, or ``Control-Alt-Delete``.\n    Valid modifiers are Control, Alt, Shift, and Meta.\n\n    Letters will always be read as upper-case.\n    Due to the native implementation of the key system, Shift pressed in\n    certain key combinations may yield inconsistent or unexpected results.\n    Therefore, it is not recommended to use Shift with non-letter keys. On OSX,\n    Control is swapped with Meta such that pressing Command reads as Control.\n\n    Special keys include Shift, Control, Alt, Meta, Up, Down, Left, Right,\n    PageUp, PageDown, Insert, Delete, Home, End, Escape, Backspace, F1,\n    F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, Space, Enter, and Tab\n\n    Functions take in only one argument: the parent that the function\n    was bound to.\n\n    By default, all functions are assumed to work on key presses only,\n    but can be denoted to work on release too by separating the function\n    into two statements with the yield keyword::\n\n        @viewer.bind_key(\'h\')\n        def hello_world(viewer):\n            # on key press\n            viewer.status = \'hello world!\'\n\n            yield\n\n            # on key release\n            viewer.status = \'goodbye world :(\'\n\n    To create a keymap that will block others, ``bind_key(..., ...)```.\n    """"""\n    if func is UNDEFINED:\n\n        def inner(func):\n            bind_key(keymap, key, func, overwrite=overwrite)\n            return func\n\n        return inner\n\n    if key is not Ellipsis:\n        key = normalize_key_combo(key)\n\n    if func is not None and key in keymap and not overwrite:\n        raise ValueError(\n            f\'key combination {key} already used! \'\n            ""specify \'overwrite=True\' to bypass this check""\n        )\n\n    unbound = keymap.pop(key, None)\n\n    if func is not None:\n        if func is not Ellipsis and not callable(func):\n            raise TypeError(""\'func\' must be a callable"")\n        keymap[key] = func\n\n    return unbound\n\n\nclass KeybindingDescriptor:\n    """"""Descriptor which transforms ``func`` into a method with the first\n    argument bound to ``class_keymap`` or ``keymap`` depending on if it was\n    called from the class or the instance, respectively.\n\n    Parameters\n    ----------\n    func : callable\n        Function to bind.\n    """"""\n\n    def __init__(self, func):\n        self.__func__ = func\n\n    def __get__(self, instance, cls):\n        if instance is not None:\n            keymap = instance.keymap\n        else:\n            keymap = cls.class_keymap\n\n        return types.MethodType(self.__func__, keymap)\n\n\nclass KeymapProvider:\n    """"""Mix-in to add keymap functionality.\n\n    Attributes\n    ----------\n    class_keymap : dict\n        Class keymap.\n    keymap : dict\n        Instance keymap.\n    """"""\n\n    def __init__(self):\n        super().__init__()\n        self.keymap = {}\n\n    def __init_subclass__(cls, **kwargs):\n        super().__init_subclass__(**kwargs)\n\n        if \'class_keymap\' not in cls.__dict__:\n            # if in __dict__, was defined in class and not inherited\n            cls.class_keymap = {}\n\n    bind_key = KeybindingDescriptor(bind_key)\n\n\ndef _bind_keymap(keymap, instance):\n    """"""Bind all functions in a keymap to an instance.\n\n    Parameters\n    ----------\n    keymap : dict\n        Keymap to bind.\n    instance : object\n        Instance to bind to.\n\n    Returns\n    -------\n    bound_keymap : dict\n        Keymap with functions bound to the instance.\n    """"""\n    bound_keymap = {\n        key: types.MethodType(func, instance) if func is not Ellipsis else func\n        for key, func in keymap.items()\n    }\n    return bound_keymap\n\n\nclass KeymapHandler:\n    """"""Mix-in to add key handling functionality.\n\n    Attributes\n    ----------\n    keymap_providers : list of KeymapProvider\n        Classes that provide the keymaps for this class to handle.\n    """"""\n\n    def __init__(self):\n        super().__init__()\n        self._key_release_generators = {}\n        self.keymap_providers = []\n\n    @property\n    def keymap_chain(self):\n        """"""collections.ChainMap: Chain of keymaps from keymap providers.""""""\n        maps = []\n\n        for parent in self.keymap_providers:\n            maps.append(_bind_keymap(parent.keymap, parent))\n            maps.append(_bind_keymap(parent.class_keymap, parent))\n\n        return ChainMap(*maps)\n\n    @property\n    def active_keymap(self):\n        """"""dict: Active keymap, created by resolving the keymap chain.""""""\n        active_keymap = self.keymap_chain\n        keymaps = active_keymap.maps\n\n        for i, keymap in enumerate(keymaps):\n            if Ellipsis in keymap:  # catch-all key\n                # trim all keymaps after catch-all\n                active_keymap = ChainMap(*keymaps[: i + 1])\n                break\n\n        active_keymap_final = {\n            k: func\n            for k, func in active_keymap.items()\n            if func is not Ellipsis\n        }\n\n        return active_keymap_final\n\n    def press_key(self, key_combo):\n        """"""Simulate a key press to activate a keybinding.\n\n        Parameters\n        ----------\n        key_combo : str\n            Key combination.\n        """"""\n        key_combo = normalize_key_combo(key_combo)\n        keymap = self.active_keymap\n        if key_combo in keymap:\n            func = keymap[key_combo]\n        elif Ellipsis in keymap:  # catch-all\n            func = keymap[...]\n        else:\n            return  # no keybinding found\n\n        if func is Ellipsis:  # blocker\n            return\n        elif not callable(func):\n            raise TypeError(f""expected {func} to be callable"")\n\n        gen = func()\n\n        if inspect.isgeneratorfunction(func):\n            try:\n                next(gen)  # call function\n            except StopIteration:  # only one statement\n                pass\n            else:\n                key, _ = parse_key_combo(key_combo)\n                self._key_release_generators[key] = gen\n\n    def release_key(self, key_combo):\n        """"""Simulate a key release for a keybinding.\n\n        Parameters\n        ----------\n        key_combo : str\n            Key combination.\n        """"""\n        key, _ = parse_key_combo(key_combo)\n        try:\n            next(self._key_release_generators[key])  # call function\n        except (KeyError, StopIteration):\n            pass\n'"
napari/utils/misc.py,3,"b'""""""Miscellaneous utility functions.\n""""""\nimport collections.abc\nimport inspect\nimport itertools\nimport re\n\nfrom enum import Enum, EnumMeta\nfrom os import PathLike, fspath, path\nfrom typing import Optional, Sequence, Type, TypeVar\n\nimport numpy as np\n\nROOT_DIR = path.dirname(path.dirname(__file__))\n\n\ndef str_to_rgb(arg):\n    """"""Convert an rgb string \'rgb(x,y,z)\' to a list of ints [x,y,z].\n    """"""\n    return list(\n        map(int, re.match(r\'rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)\', arg).groups())\n    )\n\n\ndef ensure_iterable(arg, color=False):\n    """"""Ensure an argument is an iterable. Useful when an input argument\n    can either be a single value or a list. If a color is passed then it\n    will be treated specially to determine if it is iterable.\n    """"""\n    if is_iterable(arg, color=color):\n        return arg\n    else:\n        return itertools.repeat(arg)\n\n\ndef is_iterable(arg, color=False):\n    """"""Determine if a single argument is an iterable. If a color is being\n    provided and the argument is a 1-D array of length 3 or 4 then the input\n    is taken to not be iterable.\n    """"""\n    if arg is None:\n        return False\n    elif type(arg) is str:\n        return False\n    elif np.isscalar(arg):\n        return False\n    elif color and isinstance(arg, (list, np.ndarray)):\n        if np.array(arg).ndim == 1 and (len(arg) == 3 or len(arg) == 4):\n            return False\n        else:\n            return True\n    else:\n        return True\n\n\ndef is_sequence(arg):\n    """"""Check if ``arg`` is a sequence like a list or tuple.\n\n    return True:\n        list\n        tuple\n    return False\n        string\n        numbers\n        dict\n        set\n    """"""\n    if isinstance(arg, collections.abc.Sequence) and not isinstance(arg, str):\n        return True\n    return False\n\n\ndef ensure_sequence_of_iterables(obj, length: Optional[int] = None):\n    """"""Ensure that ``obj`` behaves like a (nested) sequence of iterables.\n\n    If length is provided and the object is already a sequence of iterables,\n    a ValueError will be raised if ``len(obj) != length``.\n\n    Examples\n    --------\n    In [1]: ensure_sequence_of_iterables([1, 2])\n    Out[1]: repeat([1, 2])\n\n    In [2]: ensure_sequence_of_iterables([(1, 2), (3, 4)])\n    Out[2]: [(1, 2), (3, 4)]\n\n    In [3]: ensure_sequence_of_iterables({\'a\':1})\n    Out[3]: repeat({\'a\': 1})\n\n    In [4]: ensure_sequence_of_iterables(None)\n    Out[4]: repeat(None)\n\n    Parameters\n    ----------\n    obj : Any\n        the object to check\n    length : int, optional\n        If provided, assert that obj has len ``length``, by default None\n\n    Returns\n    -------\n    iterable\n        nested sequence of iterables, or an itertools.repeat instance\n    """"""\n    if obj and is_sequence(obj) and is_iterable(obj[0]):\n        if length is not None and len(obj) != length:\n            raise ValueError(f""length of {obj} must equal {length}"")\n        return obj\n    return itertools.repeat(obj)\n\n\ndef formatdoc(obj):\n    """"""Substitute globals and locals into an object\'s docstring.""""""\n    frame = inspect.currentframe().f_back\n    try:\n        obj.__doc__ = obj.__doc__.format(\n            **{**frame.f_globals, **frame.f_locals}\n        )\n        return obj\n    finally:\n        del frame\n\n\nclass StringEnumMeta(EnumMeta):\n    def __getitem__(self, item):\n        """""" set the item name case to uppercase for name lookup\n        """"""\n        if isinstance(item, str):\n            item = item.upper()\n\n        return super().__getitem__(item)\n\n    def __call__(\n        cls,\n        value,\n        names=None,\n        *,\n        module=None,\n        qualname=None,\n        type=None,\n        start=1,\n    ):\n        """""" set the item value case to lowercase for value lookup\n        """"""\n        # simple value lookup\n        if names is None:\n            if isinstance(value, str):\n                return super().__call__(value.lower())\n            elif isinstance(value, cls):\n                return value\n            else:\n                raise ValueError(\n                    f\'{cls} may only be called with a `str`\'\n                    f\' or an instance of {cls}\'\n                )\n\n        # otherwise create new Enum class\n        return cls._create_(\n            value,\n            names,\n            module=module,\n            qualname=qualname,\n            type=type,\n            start=start,\n        )\n\n    def keys(self):\n        return list(map(str, self))\n\n\nclass StringEnum(Enum, metaclass=StringEnumMeta):\n    def _generate_next_value_(name, start, count, last_values):\n        """""" autonaming function assigns each value its own name as a value\n        """"""\n        return name.lower()\n\n    def __str__(self):\n        """"""String representation: The string method returns the lowercase\n        string of the Enum name\n        """"""\n        return self.value\n\n\ncamel_to_snake_pattern = re.compile(r\'(.)([A-Z][a-z]+)\')\n\n\ndef camel_to_snake(name):\n    # https://gist.github.com/jaytaylor/3660565\n    return camel_to_snake_pattern.sub(r\'\\1_\\2\', name).lower()\n\n\nT = TypeVar(\'T\', str, Sequence[str])\n\n\ndef abspath_or_url(relpath: T) -> T:\n    """"""Utility function that normalizes paths or a sequence thereof.\n\n    Expands user directory and converts relpaths to abspaths... but ignores\n    URLS that begin with ""http"", ""ftp"", or ""file"".\n\n    Parameters\n    ----------\n    relpath : str or list or tuple\n        A path, or list or tuple of paths.\n\n    Returns\n    -------\n    abspath : str or list or tuple\n        An absolute path, or list or tuple of absolute paths (same type as\n        input).\n    """"""\n    if isinstance(relpath, (tuple, list)):\n        return type(relpath)(abspath_or_url(p) for p in relpath)\n\n    if isinstance(relpath, (str, PathLike)):\n        relpath = fspath(relpath)\n        if relpath.startswith((\'http:\', \'https:\', \'ftp:\', \'file:\')):\n            return relpath\n        return path.abspath(path.expanduser(relpath))\n\n    raise TypeError(""Argument must be a string, PathLike, or sequence thereof"")\n\n\nclass CallDefault(inspect.Parameter):\n    def __str__(self):\n        """"""wrap defaults""""""\n        kind = self.kind\n        formatted = self._name\n\n        # Fill in defaults\n        if (\n            self._default is not inspect._empty\n            or kind == inspect._KEYWORD_ONLY\n        ):\n            formatted = \'{}={}\'.format(formatted, formatted)\n\n        if kind == inspect._VAR_POSITIONAL:\n            formatted = \'*\' + formatted\n        elif kind == inspect._VAR_KEYWORD:\n            formatted = \'**\' + formatted\n\n        return formatted\n\n\nclass CallSignature(inspect.Signature):\n    _parameter_cls = CallDefault\n\n    def __str__(self):\n        """"""do not render separators\n\n        commented code is what was taken out from\n        the copy/pasted inspect module code :)\n        """"""\n        result = []\n        # render_pos_only_separator = False\n        # render_kw_only_separator = True\n        for param in self.parameters.values():\n            formatted = str(param)\n            result.append(formatted)\n\n        rendered = \'({})\'.format(\', \'.join(result))\n\n        if self.return_annotation is not inspect._empty:\n            anno = inspect.formatannotation(self.return_annotation)\n            rendered += \' -> {}\'.format(anno)\n\n        return rendered\n\n\ncallsignature = CallSignature.from_callable\n\n\ndef all_subclasses(cls: Type) -> set:\n    """"""Recursively find all subclasses of class ``cls``.\n\n    Parameters\n    ----------\n    cls : class\n        A python class (or anything that implements a __subclasses__ method).\n\n    Returns\n    -------\n    set\n        the set of all classes that are subclassed from ``cls``\n    """"""\n    return set(cls.__subclasses__()).union(\n        [s for c in cls.__subclasses__() for s in all_subclasses(c)]\n    )\n'"
napari/utils/naming.py,0,"b'""""""Automatically generate names.\n""""""\nimport inspect\nimport re\nfrom collections import ChainMap\n\nfrom .misc import formatdoc\n\n\nsep = \' \'\nstart = 1\n\n# Match integer between square brackets at end of string if after space\n# or at beginning of string or just match end of string\nnumbered_patt = re.compile(r\'((?<=\\A\\[)|(?<=\\s\\[))(?:\\d+|)(?=\\]$)|$\')\n\n\ndef _inc_name_count_sub(match):\n    count = match.group(0)\n\n    try:\n        count = int(count)\n    except ValueError:  # not an int\n        count = f\'{sep}[{start}]\'\n    else:\n        count = f\'{count + 1}\'\n\n    return count\n\n\n@formatdoc\ndef inc_name_count(name):\n    """"""Increase a name\'s count matching `{numbered_patt}` by ``1``.\n\n    If the name is not already numbered, append \'{sep}[{start}]\'.\n\n    Parameters\n    ----------\n    name : str\n        Original name.\n\n    Returns\n    -------\n    incremented_name : str\n        Numbered name incremented by ``1``.\n    """"""\n    return numbered_patt.sub(_inc_name_count_sub, name, count=1)\n\n\ndef magic_name(value, *, path_prefix):\n    """"""Fetch the name of the variable with the given value passed to the calling function.\n\n    Parameters\n    ----------\n    value : any\n        The value of the desired variable.\n    path_prefix : absolute path-like, kwonly\n        The path prefixes to ignore.\n\n    Returns\n    -------\n    name : str or None\n        Name of the variable, if found.\n    """"""\n    frame = inspect.currentframe().f_back\n    code = frame.f_code\n\n    while code.co_filename.startswith(path_prefix):\n        frame = frame.f_back\n        code = frame.f_code\n\n    varmap = ChainMap(frame.f_locals, frame.f_globals)\n    names = *code.co_varnames, *code.co_names\n\n    for name in names:\n        if name.isidentifier() and name in varmap and varmap[name] is value:\n            return name\n'"
napari/utils/notebook_display.py,0,"b'from io import BytesIO\n\n__all__ = [\'nbscreenshot\']\n\n\ndef nbscreenshot(viewer, *, canvas_only=False):\n    """"""Display napari screenshot in the jupyter notebook.\n\n    Parameters\n    ----------\n    viewer : napari.Viewer\n        The napari viewer.\n    with_viewer : bool, optional\n        If True includes the napari viewer frame in the screenshot,\n        otherwise just includes the canvas. By default, True.\n\n    Returns\n    -------\n    napari.utils.notebook_display.NotebookScreenshot\n        Napari screenshot rendered as rich display in the jupyter notebook.\n    """"""\n    return NotebookScreenshot(viewer, canvas_only=canvas_only)\n\n\nclass NotebookScreenshot:\n    """"""Display napari screenshot in the jupyter notebook.\n\n    Functions returning an object with a _repr_png_() method\n    will displayed as a rich image in the jupyter notebook.\n\n    https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html\n\n    Examples\n    --------\n    ```\n    import napari\n    from skimage.data import chelsea\n\n    viewer = napari.view_image(chelsea(), name=\'chelsea-the-cat\')\n    viewer.nbscreenshot()\n\n    # screenshot just the canvas without the napari viewer framing it\n    viewer.nbscreenshot(with_viewer=False)\n    ```\n    """"""\n\n    def __init__(self, viewer, *, canvas_only=False):\n        """"""Initalize screenshot object.\n\n        Parameters\n        ----------\n        viewer : napari.Viewer\n            The napari viewer\n        canvas_only : bool, optional\n            If False include the napari viewer frame in the screenshot,\n            and if True then take screenshot of just the image display canvas.\n            By default, False.\n        """"""\n        self.viewer = viewer\n        self.canvas_only = canvas_only\n        self.image = None\n\n    def _repr_png_(self):\n        """"""PNG representation of the viewer object for IPython.\n\n        Returns\n        -------\n        In memory binary stream containing PNG screenshot image.\n        """"""\n        from imageio import imsave\n\n        self.image = self.viewer.screenshot(canvas_only=self.canvas_only)\n        with BytesIO() as file_obj:\n            imsave(file_obj, self.image, format=\'png\')\n            file_obj.seek(0)\n            png = file_obj.read()\n        return png\n'"
napari/utils/status_messages.py,4,"b'from collections.abc import Iterable\nimport numpy as np\n\n\ndef format_float(value):\n    """"""Nice float formatting into strings.""""""\n    return f\'{value:0.3g}\'\n\n\ndef status_format(value):\n    """"""Return a ""nice"" string representation of a value.\n\n    Parameters\n    ----------\n    value : Any\n        The value to be printed.\n\n    Returns\n    -------\n    formatted : str\n        The string resulting from formatting.\n\n    Examples\n    --------\n    >>> values = np.array([1, 10, 100, 1000, 1e6, 6.283, 123.932021,\n    ...                    1123.9392001, 2 * np.pi, np.exp(1)])\n    >>> status_format(values)\n    \'[1, 10, 100, 1e+03, 1e+06, 6.28, 124, 1.12e+03, 6.28, 2.72]\'\n    """"""\n    if isinstance(value, Iterable):\n        return \'[\' + str.join(\', \', [status_format(v) for v in value]) + \']\'\n    if value is None:\n        return \'\'\n    if isinstance(value, float) or np.issubdtype(type(value), np.floating):\n        return format_float(value)\n    elif isinstance(value, int) or np.issubdtype(type(value), np.integer):\n        return str(value)\n    else:\n        return str(value)\n'"
napari/utils/temporary_file.py,2,"b'from tempfile import NamedTemporaryFile\nfrom contextlib import contextmanager\nimport os\n\n\n@contextmanager\ndef temporary_file(suffix=\'\'):\n    """"""Yield a writable temporary filename that is deleted on context exit.\n    Parameters\n    ----------\n    suffix : string, optional\n        The suffix for the file.\n    Examples\n    --------\n    >>> import numpy as np\n    >>> from napari.utils import io\n    >>> with temporary_file(\'.tif\') as tempfile:\n    ...     im = np.arange(25, dtype=np.uint8).reshape((5, 5))\n    ...     io.imsave(tempfile, im)\n    ...     assert np.all(io.imread(tempfile) == im)\n    """"""\n    tempfile_stream = NamedTemporaryFile(suffix=suffix, delete=False)\n    tempfile = tempfile_stream.name\n    tempfile_stream.close()\n    yield tempfile\n    os.remove(tempfile)\n'"
napari/utils/theme.py,0,"b'# syntax_style for the console must be one of the supported styles from\n# pygments - see here for examples https://help.farbox.com/pygments.html\nimport re\nfrom ast import literal_eval\n\ntry:\n    from qtpy import QT_VERSION\n\n    major, minor, *rest = QT_VERSION.split(\'.\')\n    use_gradients = (int(major) >= 5) and (int(minor) >= 12)\nexcept Exception:\n    use_gradients = False\n\n\npalettes = {\n    \'dark\': {\n        \'folder\': \'dark\',\n        \'background\': \'rgb(38, 41, 48)\',\n        \'foreground\': \'rgb(65, 72, 81)\',\n        \'primary\': \'rgb(90, 98, 108)\',\n        \'secondary\': \'rgb(134, 142, 147)\',\n        \'highlight\': \'rgb(106, 115, 128)\',\n        \'text\': \'rgb(240, 241, 242)\',\n        \'icon\': \'rgb(209, 210, 212)\',\n        \'warning\': \'rgb(153, 18, 31)\',\n        \'current\': \'rgb(0, 122, 204)\',\n        \'syntax_style\': \'native\',\n        \'console\': \'rgb(0, 0, 0)\',\n        \'canvas\': \'black\',\n    },\n    \'light\': {\n        \'folder\': \'light\',\n        \'background\': \'rgb(239, 235, 233)\',\n        \'foreground\': \'rgb(214, 208, 206)\',\n        \'primary\': \'rgb(188, 184, 181)\',\n        \'secondary\': \'rgb(150, 146, 144)\',\n        \'highlight\': \'rgb(163, 158, 156)\',\n        \'text\': \'rgb(59, 58, 57)\',\n        \'icon\': \'rgb(107, 105, 103)\',\n        \'warning\': \'rgb(255, 18, 31)\',\n        \'current\': \'rgb(253, 240, 148)\',\n        \'syntax_style\': \'default\',\n        \'console\': \'rgb(255, 255, 255)\',\n        \'canvas\': \'white\',\n    },\n}\n\ngradient_pattern = re.compile(r\'([vh])gradient\\((.+)\\)\')\ndarken_pattern = re.compile(r\'{{\\s?darken\\((\\w+),?\\s?([-\\d]+)?\\)\\s?}}\')\nlighten_pattern = re.compile(r\'{{\\s?lighten\\((\\w+),?\\s?([-\\d]+)?\\)\\s?}}\')\n\n\ndef darken(color: str, percentage=10):\n    if color.startswith(\'rgb(\'):\n        color = literal_eval(color.lstrip(\'rgb(\').rstrip(\')\'))\n    ratio = 1 - float(percentage) / 100\n    red, green, blue = color\n    red = min(max(int(red * ratio), 0), 255)\n    green = min(max(int(green * ratio), 0), 255)\n    blue = min(max(int(blue * ratio), 0), 255)\n    return f\'rgb({red}, {green}, {blue})\'\n\n\ndef lighten(color: str, percentage=10):\n    if color.startswith(\'rgb(\'):\n        color = literal_eval(color.lstrip(\'rgb(\').rstrip(\')\'))\n    ratio = float(percentage) / 100\n    red, green, blue = color\n    red = min(max(int(red + (255 - red) * ratio), 0), 255)\n    green = min(max(int(green + (255 - green) * ratio), 0), 255)\n    blue = min(max(int(blue + (255 - blue) * ratio), 0), 255)\n    return f\'rgb({red}, {green}, {blue})\'\n\n\ndef gradient(stops, horizontal=True):\n    if not use_gradients:\n        return stops[-1]\n\n    if horizontal:\n        grad = \'qlineargradient(x1: 0, y1: 0, x2: 1, y2: 0, \'\n    else:\n        grad = \'qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1, \'\n\n    _stops = [f\'stop: {n} {stop}\' for n, stop in enumerate(stops)]\n    grad += "", "".join(_stops) + "")""\n\n    return grad\n\n\ndef template(css, **palette):\n    def darken_match(matchobj):\n        color, percentage = matchobj.groups()\n        return darken(palette[color], percentage)\n\n    def lighten_match(matchobj):\n        color, percentage = matchobj.groups()\n        return lighten(palette[color], percentage)\n\n    def gradient_match(matchobj):\n        horizontal = matchobj.groups()[1] == \'h\'\n        stops = [i.strip() for i in matchobj.groups()[1].split(\'-\')]\n        return gradient(stops, horizontal)\n\n    for k, v in palette.items():\n        css = gradient_pattern.sub(gradient_match, css)\n        css = darken_pattern.sub(darken_match, css)\n        css = lighten_pattern.sub(lighten_match, css)\n        css = css.replace(\'{{ %s }}\' % k, v)\n    return css\n'"
napari/utils/validators.py,1,"b'from collections.abc import Collection, Generator\n\n\ndef validate_n_seq(n: int, dtype=None):\n    """"""Creates a function to validate a sequence of len == N and type == dtype.\n\n    Currently does **not** validate generators (will always validate true).\n\n\n    Parameters\n    ----------\n    n : int\n        Desired length of the sequence\n    dtype : type, optional\n        If provided each item in the sequence must match dtype, by default None\n\n    Returns\n    -------\n    function\n        Function that can be called on an object to validate that is a sequence\n        of len `n` and (optionally) each item in the sequence has type `dtype`\n\n    Example\n    -------\n\n    validate = validate_N_seq(2)\n    validate(8)  # raises TypeError\n    validate([1, 2, 3])  # raises ValueError\n    validate([4, 5])  # just fine, thank you very much\n    """"""\n\n    def func(obj):\n        """"""Function that validates whether an object is a sequence of len `n`.\n\n        Parameters\n        ----------\n        obj : any\n            the object to be validated\n\n        Raises\n        ------\n        TypeError\n            If the object is not an indexable collection.\n        ValueError\n            If the object does not have length `n`\n        TypeError\n            If `dtype` was provided to the wrapper function and all items in\n            the sequence are not of type `dtype`.\n        """"""\n\n        if isinstance(obj, Generator):\n            return\n        if not (isinstance(obj, Collection) and hasattr(obj, \'__getitem__\')):\n            raise TypeError(\n                f""object \'{obj}\' is not an indexable collection ""\n                f""(list, tuple, or np.array), of length {n}""\n            )\n        if not len(obj) == n:\n            raise ValueError(f""object must have length {n}, got {len(obj)}"")\n        if dtype is not None:\n            for item in obj:\n                if not isinstance(item, dtype):\n                    raise TypeError(\n                        f""Every item in the sequence must be of type {dtype}, ""\n                        f""but {item} is of type {type(item)}""\n                    )\n\n    return func\n'"
napari/_qt/_tests/__init__.py,0,b''
napari/_qt/_tests/test_qt_buttons.py,0,"b'from napari._qt.qt_mode_buttons import QtModePushButton, QtModeRadioButton\nfrom napari.layers import Points\nfrom napari.layers.points._points_constants import Mode\n\n\ndef test_radio_button(qtbot):\n    """"""Make sure the QtModeRadioButton works to change layer modes""""""\n    layer = Points()\n    assert layer.mode != Mode.ADD\n\n    btn = QtModeRadioButton(layer, \'test_button\', Mode.ADD, tooltip=\'tooltip\')\n    assert btn.property(\'mode\') == \'test_button\'\n    assert btn.toolTip() == \'tooltip\'\n\n    btn.click()\n    qtbot.wait(50)\n    assert layer.mode == \'add\'\n\n\ndef test_push_button(qtbot):\n    """"""Make sure the QtModePushButton works with callbacks""""""\n    layer = Points()\n\n    def set_test_prop():\n        layer.test_prop = True\n\n    btn = QtModePushButton(\n        layer, \'test_button\', slot=set_test_prop, tooltip=\'tooltip\'\n    )\n    assert btn.property(\'mode\') == \'test_button\'\n    assert btn.toolTip() == \'tooltip\'\n\n    btn.click()\n    qtbot.wait(50)\n    assert layer.test_prop\n'"
napari/_qt/_tests/test_qt_console.py,0,"b'from napari._qt.qt_console import QtConsole\nfrom IPython.terminal.interactiveshell import TerminalInteractiveShell\nfrom unittest import mock\n\n\ndef test_console(qtbot):\n    """"""Test creating the console.""""""\n    console = QtConsole()\n    qtbot.addWidget(console)\n    assert console.kernel_client is not None\n\n\ndef test_console_user_variables(qtbot):\n    """"""Test creating the console with user variables.""""""\n    console = QtConsole({\'var\': 3})\n    qtbot.addWidget(console)\n    assert console.kernel_client is not None\n    assert \'var\' in console.shell.user_ns\n    assert console.shell.user_ns[\'var\'] == 3\n\n\ndef test_multiple_consoles(qtbot):\n    """"""Test creating multiple consoles.""""""\n    console_a = QtConsole({\'var_a\': 3})\n    qtbot.addWidget(console_a)\n    console_b = QtConsole({\'var_b\': 4})\n    qtbot.addWidget(console_b)\n\n    assert console_a.kernel_client is not None\n    assert console_b.kernel_client is not None\n    assert \'var_a\' in console_a.shell.user_ns\n    assert \'var_b\' in console_a.shell.user_ns\n\n\ndef test_ipython_console(qtbot):\n    """"""Test mock-creating a console from within ipython.""""""\n\n    def mock_get_ipython():\n        return TerminalInteractiveShell()\n\n    with mock.patch(\n        \'napari._qt.qt_console.get_ipython\', side_effect=mock_get_ipython\n    ):\n        console = QtConsole()\n        qtbot.addWidget(console)\n        assert console.kernel_client is None\n'"
napari/_qt/_tests/test_qt_dims.py,16,"b'import os\nfrom sys import platform\n\nimport numpy as np\nimport pytest\nfrom qtpy.QtCore import Qt\n\nfrom napari._qt.qt_dims import QtDims\nfrom napari.components import Dims\n\n\ndef test_creating_view(qtbot):\n    """"""\n    Test creating dims view.\n    """"""\n    ndim = 4\n    dims = Dims(ndim)\n    view = QtDims(dims)\n\n    qtbot.addWidget(view)\n    view.show()\n\n    # Check that the dims model has been appended to the dims view\n    assert view.dims == dims\n\n    # Check the number of displayed sliders is two less than the number of\n    # dimensions\n    assert view.nsliders == view.dims.ndim\n    assert np.sum(view._displayed_sliders) == view.dims.ndim - 2\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n\ndef test_changing_ndim(qtbot):\n    """"""\n    Test changing the number of dimensions\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n\n    qtbot.addWidget(view)\n    view.show()\n\n    # Check that adding dimensions adds sliders\n    view.dims.ndim = 5\n    assert view.nsliders == view.dims.ndim\n    assert np.sum(view._displayed_sliders) == view.dims.ndim - 2\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n    # Check that removing dimensions removes sliders\n    view.dims.ndim = 2\n    assert view.nsliders == view.dims.ndim\n    assert np.sum(view._displayed_sliders) == view.dims.ndim - 2\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n\ndef test_changing_focus(qtbot):\n    """"""Test changing focus updates the dims.last_used prop.""""""\n    # too-few dims, should have no sliders to update\n    ndim = 2\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n    assert view.last_used is None\n    view.focus_down()\n    view.focus_up()\n    assert view.last_used is None\n\n    view.dims.ndim = 5\n    assert view.last_used == 2\n    view.focus_down()\n    assert view.last_used == 1\n    view.focus_up()\n    assert view.last_used == 2\n    view.focus_up()\n    assert view.last_used == 0\n    view.focus_down()\n    assert view.last_used == 2\n\n\ndef test_changing_display(qtbot):\n    """"""\n    Test changing the displayed property of an axis\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n    view.show()\n\n    assert view.nsliders == view.dims.ndim\n    assert np.sum(view._displayed_sliders) == view.dims.ndim - 2\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n    # Check changing displayed removes a slider\n    view.dims.ndisplay = 3\n    assert view.nsliders == view.dims.ndim\n    assert np.sum(view._displayed_sliders) == view.dims.ndim - 3\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n\ndef test_slider_values(qtbot):\n    """"""\n    Test the values of a slider stays matched to the values of the dims point.\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n\n    # Check that values of the dimension slider matches the values of the\n    # dims point at initialization\n    first_slider = view.slider_widgets[0].slider\n    assert first_slider.value() == view.dims.point[0]\n\n    # Check that values of the dimension slider matches the values of the\n    # dims point after the point has been moved within the dims\n    view.dims.set_point(0, 2)\n    assert first_slider.value() == view.dims.point[0]\n\n    # Check that values of the dimension slider matches the values of the\n    # dims point after the point has been moved within the slider\n    first_slider.setValue(1)\n    assert first_slider.value() == view.dims.point[0]\n\n\ndef test_slider_range(qtbot):\n    """"""\n    Tests range of the slider is matched to the range of the dims\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n\n    # Check the range of slider matches the values of the range of the dims\n    # at initialization\n    first_slider = view.slider_widgets[0].slider\n    assert first_slider.minimum() == view.dims.range[0][0]\n    assert (\n        first_slider.maximum() == view.dims.range[0][1] - view.dims.range[0][2]\n    )\n    assert first_slider.singleStep() == view.dims.range[0][2]\n\n    # Check the range of slider stays matched to the values of the range of\n    # the dims\n    view.dims.set_range(0, (1, 5, 2))\n    assert first_slider.minimum() == view.dims.range[0][0]\n    assert (\n        first_slider.maximum() == view.dims.range[0][1] - view.dims.range[0][2]\n    )\n    assert first_slider.singleStep() == view.dims.range[0][2]\n\n\ndef test_singleton_dims(qtbot):\n    """"""\n    Test singleton dims causes no slider.\n    """"""\n    ndim = 4\n    dims = Dims(ndim)\n    dims.set_range(0, (0, 1, 1))\n    view = QtDims(dims)\n    qtbot.addWidget(view)\n    view.show()\n\n    # Check that the dims model has been appended to the dims view\n    assert view.dims == dims\n\n    # Check the number of displayed sliders is only one\n    assert view.nsliders == 4\n    assert np.sum(view._displayed_sliders) == 1\n    assert np.all(\n        [\n            s.isVisible() == d\n            for s, d in zip(view.slider_widgets, view._displayed_sliders)\n        ]\n    )\n\n    # Change ndisplay to three\n    view.dims.ndisplay = 3\n\n    # Check no sliders now shown\n    assert np.sum(view._displayed_sliders) == 0\n\n    # Change ndisplay back to two\n    view.dims.ndisplay = 2\n\n    # Check only slider now shown\n    assert np.sum(view._displayed_sliders) == 1\n\n\ndef test_order_when_changing_ndim(qtbot):\n    """"""\n    Test order of the sliders when changing the number of dimensions.\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n\n    # Check that values of the dimension slider matches the values of the\n    # dims point after the point has been moved within the dims\n    view.dims.set_point(0, 2)\n    view.dims.set_point(1, 1)\n    for i in range(view.dims.ndim - 2):\n        slider = view.slider_widgets[i].slider\n        assert slider.value() == view.dims.point[i]\n\n    # Check the matching dimensions and sliders are preserved when\n    # dimensions are added\n    view.dims.ndim = 5\n    for i in range(view.dims.ndim - 2):\n        slider = view.slider_widgets[i].slider\n        assert slider.value() == view.dims.point[i]\n\n    # Check the matching dimensions and sliders are preserved when dims\n    # dimensions are removed\n    view.dims.ndim = 4\n    for i in range(view.dims.ndim - 2):\n        slider = view.slider_widgets[i].slider\n        assert slider.value() == view.dims.point[i]\n\n    # Check the matching dimensions and sliders are preserved when dims\n    # dimensions are removed\n    view.dims.ndim = 3\n    for i in range(view.dims.ndim - 2):\n        slider = view.slider_widgets[i].slider\n        assert slider.value() == view.dims.point[i]\n\n\ndef test_update_dims_labels(qtbot):\n    """"""\n    Test that the slider_widget axis labels are updated with the dims model\n    and vice versa.\n    """"""\n    ndim = 4\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n    view.dims.axis_labels = list(\'TZYX\')\n    assert [w.axis_label.text() for w in view.slider_widgets] == list(\'TZYX\')\n\n    first_label = view.slider_widgets[0].axis_label\n    assert first_label.text() == view.dims.axis_labels[0]\n    first_label.setText(\'napari\')\n    # first_label.editingFinished.emit()\n    assert first_label.text() == view.dims.axis_labels[0]\n\n\ndef test_slider_press_updates_last_used(qtbot):\n    """"""pressing on the slider should update the dims.last_used property""""""\n    ndim = 5\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n\n    for i, widg in enumerate(view.slider_widgets):\n        widg.slider.sliderPressed.emit()\n        assert view.last_used == i\n\n\n@pytest.mark.skipif(\n    os.environ.get(\'CI\') and platform == \'win32\',\n    reason=\'not working in windows VM\',\n)\ndef test_play_button(qtbot):\n    """"""test that the play button and its popup dialog work""""""\n    ndim = 3\n    view = QtDims(Dims(ndim))\n    qtbot.addWidget(view)\n    button = view.slider_widgets[0].play_button\n    qtbot.mouseClick(button, Qt.LeftButton)\n    qtbot.waitSignal(view._animation_thread.started, timeout=5000)\n    qtbot.wait(200)\n    assert view.is_playing\n    with qtbot.waitSignal(view._animation_thread.finished, timeout=7000):\n        qtbot.mouseClick(button, Qt.LeftButton)\n\n    qtbot.wait(200)\n    assert not view.is_playing\n\n    assert not button.popup.isVisible()\n    qtbot.mouseClick(button, Qt.RightButton)\n    assert button.popup.isVisible()\n\n\ndef test_slice_labels(viewer_factory):\n    view, viewer = viewer_factory()\n    np.random.seed(0)\n    data = np.random.random((20, 10, 10))\n    viewer.add_image(data)\n\n    # make sure the totslice_label is showing the correct number\n    assert int(view.dims.slider_widgets[0].totslice_label.text()) == 19\n\n    # make sure setting the dims.point updates the slice label\n    label_edit = view.dims.slider_widgets[0].curslice_label\n    viewer.dims.set_point(0, 15)\n    assert int(label_edit.text()) == 15\n\n    # make sure setting the current slice label updates the model\n    label_edit.setText(str(8))\n    label_edit.editingFinished.emit()\n    assert viewer.dims.point[0] == 8\n'"
napari/_qt/_tests/test_qt_dock_widget.py,0,"b'import pytest\nfrom qtpy.QtWidgets import QDockWidget, QHBoxLayout, QPushButton, QVBoxLayout\n\n\ndef test_add_dock_widget(viewer_factory):\n    """"""Test basic add_dock_widget functionality""""""\n    view, viewer = viewer_factory()\n    widg = QPushButton(\'button\')\n    dwidg = viewer.window.add_dock_widget(widg, name=\'test\')\n    assert not dwidg.is_vertical\n    assert viewer.window._qt_window.findChild(QDockWidget, \'test\')\n    assert dwidg.widget == widg\n    dwidg._on_visibility_changed(True)  # smoke test\n\n    widg2 = QPushButton(\'button\')\n    dwidg2 = viewer.window.add_dock_widget(widg2, name=\'test2\', area=\'right\')\n    assert dwidg2.is_vertical\n    assert viewer.window._qt_window.findChild(QDockWidget, \'test2\')\n    assert dwidg2.widget == widg2\n    dwidg2._on_visibility_changed(True)  # smoke test\n\n    with pytest.raises(ValueError):\n        # \'under\' is not a valid area\n        viewer.window.add_dock_widget(widg2, name=\'test2\', area=\'under\')\n\n    with pytest.raises(ValueError):\n        # \'under\' is not a valid area\n        viewer.window.add_dock_widget(\n            widg2, name=\'test2\', allowed_areas=[\'under\']\n        )\n\n    with pytest.raises(TypeError):\n        # allowed_areas must be a list\n        viewer.window.add_dock_widget(\n            widg2, name=\'test2\', allowed_areas=\'under\'\n        )\n\n\ndef test_add_dock_widget_from_list(viewer_factory):\n    """"""Test that we can add a list of widgets and they will be combined""""""\n    view, viewer = viewer_factory()\n    widg = QPushButton(\'button\')\n    widg2 = QPushButton(\'button\')\n\n    dwidg = viewer.window.add_dock_widget(\n        [widg, widg2], name=\'test\', area=\'right\'\n    )\n    assert viewer.window._qt_window.findChild(QDockWidget, \'test\')\n    assert isinstance(dwidg.widget.layout, QVBoxLayout)\n\n    dwidg = viewer.window.add_dock_widget(\n        [widg, widg2], name=\'test2\', area=\'bottom\'\n    )\n    assert viewer.window._qt_window.findChild(QDockWidget, \'test2\')\n    assert isinstance(dwidg.widget.layout, QHBoxLayout)\n\n\ndef test_add_dock_widget_raises(viewer_factory):\n    """"""Test that the widget passed must be a DockWidget.""""""\n    view, viewer = viewer_factory()\n    widg = object()\n\n    with pytest.raises(TypeError):\n        viewer.window.add_dock_widget(widg, name=\'test\')\n'"
napari/_qt/_tests/test_qt_layerlist.py,14,"b'import numpy as np\nfrom vispy.color import get_color_dict\n\nfrom napari.components import LayerList\nfrom napari.layers import Image\nfrom napari._qt.qt_layerlist import QtLayerList, QtDivider\nfrom napari.utils.colormaps.standardize_color import hex_to_name\n\n\ndef check_layout_layers(layout, layers):\n    """"""\n    Check the layer widget order matches the layers order in the layout\n\n    Parameters\n    ----------\n    layout : QLayout\n        Layout to test\n    layers : napari.components.LayerList\n        LayersList to compare to\n\n    Returns\n    ----------\n    match : bool\n        Boolean if layout matches layers\n    """"""\n    layers_layout = [\n        layout.itemAt(2 * i - 1).widget().layer\n        for i in range(len(layers), 0, -1)\n    ]\n    return layers_layout == list(layers)\n\n\ndef check_layout_dividers(layout, nlayers):\n    """"""\n    Check the layout contains dividers at the right places\n\n    Parameters\n    ----------\n    layout : QLayout\n        Layout to test\n    nlayers : int\n        Number of layers that should be present\n\n    Returns\n    ----------\n    match : bool\n        Boolean if layout contains dividers in the right places\n    """"""\n    dividers_layout = [\n        type(layout.itemAt(2 * i).widget()) for i in range(1 + nlayers)\n    ]\n    return dividers_layout == [QtDivider] * (1 + nlayers)\n\n\ndef test_divider(qtbot):\n    """"""\n    Test creating the divider.\n    """"""\n    divider = QtDivider()\n\n    qtbot.addWidget(divider)\n\n    # Check divider was created properly\n    assert type(divider) == QtDivider\n\n    # Check divider property defaults to False\n    assert divider.property(\'selected\') is False\n\n    # Set divider property\n    divider.setSelected(True)\n    assert divider.property(\'selected\') is True\n    divider.setSelected(False)\n    assert divider.property(\'selected\') is False\n\n\ndef test_creating_empty_view(qtbot):\n    """"""\n    Test creating LayerList view.\n    """"""\n    layers = LayerList()\n    view = QtLayerList(layers)\n\n    qtbot.addWidget(view)\n\n    # Check that the layers model has been appended to the layers view\n    assert view.layers == layers\n\n    # Check that vbox_layout only contains one QtDivider and one spacer\n    assert view.vbox_layout.count() == 2\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, 0)\n\n\ndef test_adding_layers(qtbot):\n    """"""\n    Test adding layers.\n    """"""\n    layers = LayerList()\n    view = QtLayerList(layers)\n\n    qtbot.addWidget(view)\n\n    # Check that new layer and divider get added to vbox_layout\n    layer_a = Image(np.random.random((10, 10)))\n    layers.append(layer_a)\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    # Check that new layers and dividers get added to vbox_layout\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_b)\n    layers.append(layer_c)\n    layers.append(layer_d)\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n\ndef test_removing_layers(qtbot):\n    """"""\n    Test removing layers.\n    """"""\n    layers = LayerList()\n    view = QtLayerList(layers)\n\n    qtbot.addWidget(view)\n\n    layer_a = Image(np.random.random((10, 10)))\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n    layers.append(layer_d)\n\n    # Check layout and layers list match after removing a layer\n    layers.remove(layer_b)\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    # Check layout and layers list match after removing a layer\n    layers.remove(layer_d)\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    layers.append(layer_b)\n    layers.append(layer_d)\n    # Select first and third layers\n    for l, s in zip(layers, [True, True, False, False]):\n        l.selected = s\n    layers.remove_selected()\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n\ndef test_reordering_layers(qtbot):\n    """"""\n    Test reordering layers.\n    """"""\n    layers = LayerList()\n    view = QtLayerList(layers)\n\n    qtbot.addWidget(view)\n\n    layer_a = Image(np.random.random((10, 10)), name=\'image_a\')\n    layer_b = Image(np.random.random((15, 15)), name=\'image_b\')\n    layer_c = Image(np.random.random((15, 15)), name=\'image_c\')\n    layer_d = Image(np.random.random((15, 15)), name=\'image_d\')\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n    layers.append(layer_d)\n\n    # Check layout and layers list match after rearranging layers\n    layers[:] = layers[(1, 0, 3, 2)]\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    # Check layout and layers list match after swapping two layers\n    layers[\'image_b\', \'image_c\'] = layers[\'image_c\', \'image_b\']\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    # Check layout and layers list match after reversing list\n    # TEST CURRENTLY FAILING\n    # layers.reverse()\n    # assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    # assert check_layout_layers(view.vbox_layout, layers)\n    # assert check_layout_dividers(view.vbox_layout, len(layers))\n\n    # Check layout and layers list match after rearranging selected layers\n    layer_e = Image(np.random.random((15, 15)))\n    layer_f = Image(np.random.random((15, 15)))\n    layers.append(layer_e)\n    layers.append(layer_f)\n    for l, s in zip(layers, [False, True, False, False, True, False]):\n        l.selected = s\n    layers.move_selected(1, 2)\n    assert view.vbox_layout.count() == 2 * (len(layers) + 1)\n    assert check_layout_layers(view.vbox_layout, layers)\n    assert check_layout_dividers(view.vbox_layout, len(layers))\n\n\ndef test_hex_to_name_is_updated():\n    fail_msg = (\n        ""If this test fails then vispy have probably updated their color dictionary, located ""\n        ""in vispy.color.get_color_dict. This not necessarily a bad thing, but make sure that ""\n        ""nothing terrible has happened due to this change.""\n    )\n    new_hex_to_name = {\n        f""{v.lower()}ff"": k for k, v in get_color_dict().items()\n    }\n    new_hex_to_name[""#00000000""] = \'transparent\'\n    assert new_hex_to_name == hex_to_name, fail_msg\n'"
napari/_qt/_tests/test_qt_play.py,2,"b'from contextlib import contextmanager\n\nimport numpy as np\nimport pytest\n\nfrom ...components import Dims\nfrom ..qt_dims import QtDims\nfrom ..qt_dims_slider import AnimationWorker\nfrom .._constants import LoopMode\n\n\n@contextmanager\ndef make_worker(\n    qtbot, nframes=8, fps=20, frame_range=None, loop_mode=LoopMode.LOOP\n):\n    # sets up an AnimationWorker ready for testing, and breaks down when done\n    dims = Dims(4)\n    qtdims = QtDims(dims)\n    qtbot.addWidget(qtdims)\n    nz = 8\n    step = 1\n    dims.set_range(0, (0, nz, step))\n    slider_widget = qtdims.slider_widgets[0]\n    slider_widget.loop_mode = loop_mode\n    slider_widget.fps = fps\n    slider_widget.frame_range = frame_range\n\n    worker = AnimationWorker(slider_widget)\n    worker._count = 0\n    worker.nz = nz\n\n    def bump(*args):\n        if worker._count < nframes:\n            worker._count += 1\n        else:\n            worker.finish()\n\n    def count_reached():\n        assert worker._count >= nframes\n\n    def go():\n        worker.work()\n        qtbot.waitUntil(count_reached, timeout=6000)\n        return worker.current\n\n    worker.frame_requested.connect(bump)\n    worker.go = go\n\n    yield worker\n\n\n# Each tuple represents different arguments we will pass to make_thread\n# frames, fps, mode, frame_range, expected_result(nframes, nz)\nCONDITIONS = [\n    # regular nframes < nz\n    (5, 10, LoopMode.LOOP, None, lambda x, y: x),\n    # loops around to the beginning\n    (10, 10, LoopMode.LOOP, None, lambda x, y: x % y),\n    # loops correctly with frame_range specified\n    (10, 10, LoopMode.LOOP, (2, 6), lambda x, y: x % y),\n    # loops correctly going backwards\n    (10, -10, LoopMode.LOOP, None, lambda x, y: y - (x % y)),\n    # loops back and forth\n    (10, 10, LoopMode.BACK_AND_FORTH, None, lambda x, y: x - y + 2),\n    # loops back and forth, with negative fps\n    (10, -10, LoopMode.BACK_AND_FORTH, None, lambda x, y: y - (x % y) - 2),\n]\n\n\n@pytest.mark.parametrize(""nframes,fps,mode,rng,result"", CONDITIONS)\ndef test_animation_thread_variants(qtbot, nframes, fps, mode, rng, result):\n    """"""This is mostly testing that AnimationWorker.advance works as expected""""""\n    with make_worker(\n        qtbot, fps=fps, nframes=nframes, frame_range=rng, loop_mode=mode\n    ) as worker:\n        current = worker.go()\n    if rng:\n        nrange = rng[1] - rng[0] + 1\n        expected = rng[0] + result(nframes, nrange)\n        assert expected - 1 <= current <= expected + 1\n    else:\n        expected = result(nframes, worker.nz)\n        # assert current == expected\n        # relaxing for CI OSX tests\n        assert expected - 1 <= current <= expected + 1\n\n\ndef test_animation_thread_once(qtbot):\n    """"""Single shot animation should stop when it reaches the last frame""""""\n    nframes = 13\n    with make_worker(\n        qtbot, nframes=nframes, loop_mode=LoopMode.ONCE\n    ) as worker:\n        with qtbot.waitSignal(worker.finished, timeout=8000):\n            worker.work()\n    assert worker.current == worker.nz\n\n\n@pytest.fixture()\ndef view(viewer_factory):\n    """"""basic viewer with data that we will use a few times""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 10, 15))\n    viewer.add_image(data)\n\n    return view\n\n\ndef test_play_raises_index_errors(qtbot, view):\n    # play axis is out of range\n    with pytest.raises(IndexError):\n        view.dims.play(4, 20)\n        qtbot.wait(20)\n        view.dims.stop()\n\n    # data doesn\'t have 20 frames\n    with pytest.raises(IndexError):\n        view.dims.play(0, 20, frame_range=[2, 20])\n        qtbot.wait(20)\n        view.dims.stop()\n\n\ndef test_play_raises_value_errors(qtbot, view):\n    # frame_range[1] not > frame_range[0]\n    with pytest.raises(ValueError):\n        view.dims.play(0, 20, frame_range=[2, 2])\n        qtbot.wait(20)\n        view.dims.stop()\n\n    # that\'s not a valid loop_mode\n    with pytest.raises(ValueError):\n        view.dims.play(0, 20, loop_mode=5)\n        qtbot.wait(20)\n        view.dims.stop()\n\n\n@pytest.mark.skip(reason=""fails too often... tested indirectly elsewhere"")\ndef test_play_api(qtbot, view):\n    """"""Test that the QtDims.play() function advances a few frames""""""\n    view.dims._frame = 0\n\n    def increment(e):\n        view.dims._frame += 1\n        # if we don\'t ""enable play"" again, view.dims won\'t request a new frame\n        view.dims._play_ready = True\n\n    view.dims.dims.events.axis.connect(increment)\n\n    view.dims.play(0, 20)\n    # wait for the thread to start before timing...\n    qtbot.waitSignal(view.dims._animation_thread.started, timeout=10000)\n    qtbot.wait(370)\n    with qtbot.waitSignal(view.dims._animation_thread.finished, timeout=7000):\n        view.dims.stop()\n    A = view.dims._frame\n    assert A >= 3\n\n    # make sure the stop button actually worked\n    qtbot.wait(150)\n    assert A == view.dims._frame\n\n\ndef test_playing_hidden_slider_does_nothing(view):\n    """"""Make sure playing a dimension without a slider does nothing""""""\n\n    def increment(e):\n        view.dims._frame = e.value  # this is provided by the axis event\n        # if we don\'t ""enable play"" again, view.dims won\'t request a new frame\n        view.dims._play_ready = True\n\n    view.dims.dims.events.axis.connect(increment)\n\n    with pytest.warns(UserWarning):\n        view.dims.play(2, 20)\n    assert not view.dims.is_playing\n'"
napari/_qt/_tests/test_qt_plugin_list.py,0,"b'from qtpy.QtCore import QTimer\nimport pytest\nfrom napari_plugin_engine.manager import temp_path_additions\n\n\nGOOD_PLUGIN = """"""\nfrom napari_plugin_engine import HookImplementationMarker\n\n@HookImplementationMarker(""test"")\ndef napari_get_reader(path):\n    return True\n""""""\n\n\n@pytest.fixture\ndef entrypoint_plugin(tmp_path):\n    """"""An example plugin that uses entry points.""""""\n    (tmp_path / ""entrypoint_plugin.py"").write_text(GOOD_PLUGIN)\n    distinfo = tmp_path / ""entrypoint_plugin-1.2.3.dist-info""\n    distinfo.mkdir()\n    (distinfo / ""top_level.txt"").write_text(\'entrypoint_plugin\')\n    (distinfo / ""entry_points.txt"").write_text(\n        ""[app.plugin]\\na_plugin = entrypoint_plugin""\n    )\n    (distinfo / ""METADATA"").write_text(\n        ""Metadata-Version: 2.1\\n""\n        ""Name: a_plugin\\n""\n        ""Version: 1.2.3\\n""\n        ""Author-Email: example@example.com\\n""\n        ""Home-Page: https://www.example.com\\n""\n        ""Requires-Python: >=3.6\\n""\n    )\n    return tmp_path\n\n\n# test_plugin_manager fixture is provided by napari_plugin_engine._testsupport\ndef test_qt_plugin_list(\n    viewer_factory, test_plugin_manager, entrypoint_plugin\n):\n    """"""Make sure the plugin list viewer works and has the test plugins.""""""\n    view, viewer = viewer_factory()\n    with temp_path_additions(entrypoint_plugin):\n        test_plugin_manager.discover(entry_point=\'app.plugin\')\n        assert \'a_plugin\' in test_plugin_manager.plugins\n\n        def handle_dialog():\n            assert hasattr(viewer.window, \'_plugin_list\')\n            table = viewer.window._plugin_list.table\n            assert table.rowCount() > 0\n            plugins = {\n                table.item(i, 0).text() for i in range(table.rowCount())\n            }\n            assert \'a_plugin\' in plugins\n            viewer.window._plugin_list.close()\n\n        QTimer.singleShot(100, handle_dialog)\n        viewer.window._show_plugin_list(test_plugin_manager)\n'"
napari/_qt/_tests/test_qt_plugin_report.py,0,"b'import webbrowser\n\nimport pytest\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtGui import QGuiApplication\n\nfrom napari._qt import qt_plugin_report\nfrom napari_plugin_engine import PluginError\n\n\n# qtbot fixture comes from pytest-qt\n# test_plugin_manager fixture is provided by napari_plugin_engine._testsupport\n# monkeypatch fixture is from pytest\ndef test_error_reporter(qtbot, test_plugin_manager, monkeypatch):\n    """"""test that QtPluginErrReporter shows any instantiated PluginErrors.""""""\n\n    monkeypatch.setattr(\n        qt_plugin_report,\n        \'standard_metadata\',\n        lambda x: {\'url\': \'https://github.com/example/example\'},\n    )\n\n    error_message = \'my special error\'\n    _ = PluginError(error_message, plugin_name=\'test_plugin\', plugin=""mock"")\n    report_widget = qt_plugin_report.QtPluginErrReporter(\n        plugin_manager=test_plugin_manager\n    )\n    qtbot.addWidget(report_widget)\n\n    # the null option plus the one we created\n    assert report_widget.plugin_combo.count() >= 2\n\n    # the message should appear somewhere in the text area\n    report_widget.set_plugin(\'test_plugin\')\n    assert error_message in report_widget.text_area.toPlainText()\n\n    # mock_webbrowser_open\n    def mock_webbrowser_open(url, new=0):\n        assert new == 2\n        assert ""Errors for plugin \'test_plugin\'"" in url\n        assert ""Traceback from napari"" in url\n\n    monkeypatch.setattr(webbrowser, \'open\', mock_webbrowser_open)\n\n    qtbot.mouseClick(report_widget.github_button, Qt.LeftButton)\n\n    # make sure we can copy traceback to clipboard\n    report_widget.copyToClipboard()\n    clipboard_text = QGuiApplication.clipboard().text()\n    assert ""Errors for plugin \'test_plugin\'"" in clipboard_text\n\n    # plugins without errors raise an error\n    with pytest.raises(ValueError):\n        report_widget.set_plugin(\'non_existent\')\n\n    report_widget.set_plugin(None)\n    assert not report_widget.text_area.toPlainText()\n'"
napari/_qt/_tests/test_qt_range_slider.py,8,"b""import numpy as np\nimport pytest\n\nfrom qtpy.QtCore import QPoint, Qt\nfrom napari._qt.qt_range_slider import QHRangeSlider, QVRangeSlider\n\n\n@pytest.mark.parametrize('orientation', ['h', 'v'])\ndef test_range_slider(qtbot, orientation):\n    model = QHRangeSlider if orientation == 'h' else QVRangeSlider\n    initial = np.array([100, 400])\n    range_ = np.array([0, 500])\n    diff = abs(np.diff(range_))\n    step = 1\n    sld = model(initial_values=initial, data_range=range_, step_size=step)\n    sld.show()\n    assert np.all([sld.value_min, sld.value_max] == (initial / diff))\n\n    # test clicking parts triggers the right slider.moving\n    assert sld.moving == 'none'\n    if orientation == 'h':\n        pos = sld.rangeSliderSize() * sld.value_min + sld.handle_radius\n        pos = QPoint(pos, sld.height() / 2)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'min'\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos - QPoint(50, 0), delay=50)\n        assert sld.moving == 'min'\n        pos = sld.rangeSliderSize() * sld.value_max + sld.handle_radius\n        pos = QPoint(pos, sld.height() / 2)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'max'\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos + QPoint(50, 0), delay=50)\n        assert sld.moving == 'max'\n        pos = sld.rangeSliderSize() * 0.5 + sld.handle_radius\n        pos = QPoint(pos, sld.height() / 2)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'bar'\n    else:\n        pos = sld.rangeSliderSize() * sld.value_min + sld.handle_radius\n        pos = QPoint(sld.width() / 2, pos)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'max'\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos - QPoint(0, 50), delay=50)\n        assert sld.moving == 'max'\n        pos = sld.rangeSliderSize() * sld.value_max + sld.handle_radius\n        pos = QPoint(sld.width() / 2, pos)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'min'\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos + QPoint(0, 50), delay=50)\n        assert sld.moving == 'min'\n        pos = sld.rangeSliderSize() * 0.5 + sld.handle_radius\n        pos = QPoint(sld.width() / 2, pos)\n        qtbot.mousePress(sld, Qt.LeftButton, pos=pos, delay=50)\n        assert sld.moving == 'bar'\n\n    # can't simulate mouse moves... so directly set min and max and make sure\n    # both the data values (sld.values()) and value_min/max update correctly\n    sld.display_min = sld.handle_radius + 0.4 * sld.rangeSliderSize()\n    sld.display_max = sld.handle_radius + 0.6 * sld.rangeSliderSize()\n    sld.updateValuesFromDisplay()\n    assert np.all([sld.value_min, sld.value_max] == [0.4, 0.6])\n    assert np.all(sld.values() == np.array([0.4, 0.6]) * diff)\n\n    # changing the range should update sld.values() but not sld.value_min/max\n    sld.setRange(range_ * 2)\n    assert np.all([sld.value_min, sld.value_max] == [0.4, 0.6])\n    assert np.all(sld.values() == np.array([0.4, 0.6]) * diff * 2)\n\n    qtbot.mouseRelease(sld, Qt.LeftButton, pos=pos, delay=50)\n    assert sld.moving == 'none'\n\n    # just make sure these don't crash for now\n    sld.collapse()\n    sld.expand()\n"""
napari/_qt/_tests/test_qt_range_slider_popup.py,4,"b'import numpy as np\nimport pytest\n\nfrom napari._qt.qt_range_slider_popup import QRangeSliderPopup\n\ninitial = np.array([100, 400])\nrange_ = np.array([0, 500])\n\n\n@pytest.fixture\ndef popup(qtbot):\n    popup = QRangeSliderPopup(\n        horizontal=True,\n        precision=2,\n        initial_values=initial,\n        data_range=range_,\n        step_size=1,\n    )\n    qtbot.addWidget(popup)\n    return popup\n\n\ndef test_range_slider_popup_labels(popup):\n    """"""make sure labels are correct""""""\n    assert float(popup.curmin_label.text()) == initial[0]\n    assert float(popup.curmax_label.text()) == initial[1]\n    assert np.all(popup.slider.range() == range_)\n\n\ndef test_range_slider_changes_labels(popup):\n    """"""make sure setting the slider updates the labels""""""\n    popup.slider.setValues((10, 20))\n    assert float(popup.curmin_label.text()) == 10\n    assert float(popup.curmax_label.text()) == 20\n\n\ndef test_labels_change_range_slider(popup):\n    """"""make sure setting the labels updates the slider""""""\n    popup.slider.setValues((10, 20))\n\n    popup.curmin_label.setText(\'100\')\n    popup.curmax_label.setText(\'300\')\n    popup.curmin_label.editingFinished.emit()\n    popup.curmax_label.editingFinished.emit()\n    assert np.all(popup.slider.values() == (100, 300))\n'"
napari/_qt/_tests/test_qt_scrollbar.py,0,"b'from qtpy.QtCore import Qt, QPoint\nfrom ..qt_scrollbar import ModifiedScrollBar\n\n\ndef test_modified_scrollbar_click(qtbot):\n    w = ModifiedScrollBar(Qt.Horizontal)\n    w.resize(100, 10)\n    assert w.value() == 0\n    qtbot.mousePress(w, Qt.LeftButton, pos=QPoint(50, 5))\n    # the normal QScrollBar would have moved to ""10""\n    assert w.value() >= 40\n'"
napari/_qt/_tests/test_qt_utils.py,0,"b'from qtpy.QtCore import QObject, Signal\n\nfrom ..utils import qt_signals_blocked\n\n\nclass Emitter(QObject):\n    test_signal = Signal()\n\n    def go(self):\n        self.test_signal.emit()\n\n\ndef test_signal_blocker(qtbot):\n    """"""make sure context manager signal blocker works""""""\n\n    obj = Emitter()\n\n    # make sure signal works\n    with qtbot.waitSignal(obj.test_signal):\n        obj.go()\n\n    # make sure blocker works\n    def err():\n        raise AssertionError(\'a signal was emitted\')\n\n    obj.test_signal.connect(err)\n    with qt_signals_blocked(obj):\n        obj.go()\n        qtbot.wait(750)\n'"
napari/_qt/_tests/test_qt_viewer.py,29,"b'import os\nfrom unittest import mock\n\nimport numpy as np\nimport pytest\n\nfrom napari.utils.io import imread\nfrom napari._tests.utils import (\n    add_layer_by_type,\n    check_viewer_functioning,\n    layer_test_data,\n)\n\n\ndef test_qt_viewer(viewer_factory):\n    """"""Test instantiating viewer.""""""\n    view, viewer = viewer_factory()\n\n    assert viewer.title == \'napari\'\n    assert view.viewer == viewer\n    # Check no console is present before it is requested\n    assert view._console is None\n\n    assert len(viewer.layers) == 0\n    assert view.layers.vbox_layout.count() == 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n\ndef test_qt_viewer_with_console(viewer_factory):\n    """"""Test instantiating console from viewer.""""""\n    view, viewer = viewer_factory()\n    # Check no console is present before it is requested\n    assert view._console is None\n    # Check console is created when requested\n    assert view.console is not None\n    assert view.dockConsole.widget == view.console\n\n\ndef test_qt_viewer_toggle_console(viewer_factory):\n    """"""Test instantiating console from viewer.""""""\n    view, viewer = viewer_factory()\n    # Check no console is present before it is requested\n    assert view._console is None\n    # Check console has been created when it is supposed to be shown\n    view.toggle_console_visibility(None)\n    assert view._console is not None\n    assert view.dockConsole.widget == view.console\n\n\n@pytest.mark.parametrize(\'layer_class, data, ndim\', layer_test_data)\ndef test_add_layer(viewer_factory, layer_class, data, ndim):\n    view, viewer = viewer_factory(ndisplay=ndim)\n\n    add_layer_by_type(viewer, layer_class, data)\n    check_viewer_functioning(viewer, view, data, ndim)\n\n\ndef test_new_labels(viewer_factory):\n    """"""Test adding new labels layer.""""""\n    # Add labels to empty viewer\n    view, viewer = viewer_factory()\n\n    viewer._new_labels()\n    assert np.max(viewer.layers[0].data) == 0\n    assert len(viewer.layers) == 1\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # Add labels with image already present\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer._new_labels()\n    assert np.max(viewer.layers[1].data) == 0\n    assert len(viewer.layers) == 2\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n\ndef test_new_points(viewer_factory):\n    """"""Test adding new points layer.""""""\n    # Add labels to empty viewer\n    view, viewer = viewer_factory()\n\n    viewer.add_points()\n    assert len(viewer.layers[0].data) == 0\n    assert len(viewer.layers) == 1\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # Add points with image already present\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer.add_points()\n    assert len(viewer.layers[1].data) == 0\n    assert len(viewer.layers) == 2\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n\ndef test_new_shapes_empty_viewer(viewer_factory):\n    """"""Test adding new shapes layer.""""""\n    # Add labels to empty viewer\n    view, viewer = viewer_factory()\n\n    viewer.add_shapes()\n    assert len(viewer.layers[0].data) == 0\n    assert len(viewer.layers) == 1\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n    # Add points with image already present\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer.add_shapes()\n    assert len(viewer.layers[1].data) == 0\n    assert len(viewer.layers) == 2\n    assert view.layers.vbox_layout.count() == 2 * len(viewer.layers) + 2\n\n    assert viewer.dims.ndim == 2\n    assert view.dims.nsliders == viewer.dims.ndim\n    assert np.sum(view.dims._displayed_sliders) == 0\n\n\ndef test_screenshot(viewer_factory):\n    ""Test taking a screenshot""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    # Add image\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n\n    # Add labels\n    data = np.random.randint(20, size=(10, 15))\n    viewer.add_labels(data)\n\n    # Add points\n    data = 20 * np.random.random((10, 2))\n    viewer.add_points(data)\n\n    # Add vectors\n    data = 20 * np.random.random((10, 2, 2))\n    viewer.add_vectors(data)\n\n    # Add shapes\n    data = 20 * np.random.random((10, 4, 2))\n    viewer.add_shapes(data)\n\n    # Take screenshot\n    screenshot = view.screenshot()\n    assert screenshot.ndim == 3\n\n\ndef test_screenshot_dialog(viewer_factory, tmpdir):\n    """"""Test save screenshot functionality.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    # Add image\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n\n    # Add labels\n    data = np.random.randint(20, size=(10, 15))\n    viewer.add_labels(data)\n\n    # Add points\n    data = 20 * np.random.random((10, 2))\n    viewer.add_points(data)\n\n    # Add vectors\n    data = 20 * np.random.random((10, 2, 2))\n    viewer.add_vectors(data)\n\n    # Add shapes\n    data = 20 * np.random.random((10, 4, 2))\n    viewer.add_shapes(data)\n\n    # Save screenshot\n    input_filepath = os.path.join(tmpdir, \'test-save-screenshot\')\n    mock_return = (input_filepath, \'\')\n    with mock.patch(\'napari._qt.qt_viewer.QFileDialog\') as mocker:\n        mocker.getSaveFileName.return_value = mock_return\n        view._screenshot_dialog()\n    # Assert behaviour is correct\n    expected_filepath = input_filepath + \'.png\'  # add default file extension\n    assert os.path.exists(expected_filepath)\n    output_data = imread(expected_filepath)\n    expected_data = view.screenshot()\n    assert np.allclose(output_data, expected_data)\n\n\n@pytest.mark.parametrize(\n    ""dtype"", [\'int8\', \'uint8\', \'int16\', \'uint16\', \'float32\']\n)\ndef test_qt_viewer_data_integrity(viewer_factory, dtype):\n    """"""Test that the viewer doesn\'t change the underlying array.""""""\n\n    image = np.random.rand(10, 32, 32)\n    image *= 200 if dtype.endswith(\'8\') else 2 ** 14\n    image = image.astype(dtype)\n    imean = image.mean()\n\n    view, viewer = viewer_factory()\n\n    viewer.add_image(image.copy())\n    datamean = viewer.layers[0].data.mean()\n    assert datamean == imean\n    # toggle dimensions\n    viewer.dims.ndisplay = 3\n    datamean = viewer.layers[0].data.mean()\n    assert datamean == imean\n    # back to 2D\n    viewer.dims.ndisplay = 2\n    datamean = viewer.layers[0].data.mean()\n    assert datamean == imean\n'"
napari/_qt/_tests/test_theme_sample.py,0,"b'from napari._qt import theme_sample\n\n\ndef test_theme_sample(qtbot):\n    """"""Just a smoke test to make sure that the theme sample can be created.""""""\n    w = theme_sample.SampleWidget()\n    qtbot.addWidget(w)\n    w.show()\n    assert w.isVisible()\n'"
napari/_qt/_tests/test_threading.py,0,"b'from napari._qt import threading\nimport inspect\nimport pytest\nimport time\n\n\ndef test_as_generator_function():\n    """"""Test we can convert a regular function to a generator function.""""""\n\n    def func():\n        return\n\n    assert not inspect.isgeneratorfunction(func)\n\n    newfunc = threading.as_generator_function(func)\n    assert inspect.isgeneratorfunction(newfunc)\n    assert list(newfunc()) == [None]\n\n\n# qtbot is necessary for qthreading here.\n# note: pytest-cov cannot check coverage of code run in the other thread.\ndef test_thread_worker(qtbot):\n    """"""Test basic threadworker on a function""""""\n\n    def func():\n        return 1\n\n    def test(v):\n        assert v == 1\n\n    thread_func = threading.thread_worker(func, connect={\'returned\': test})\n    worker = thread_func()\n    assert isinstance(worker, threading.FunctionWorker)\n\n\ndef test_thread_generator_worker(qtbot):\n    """"""Test basic threadworker on a generator""""""\n\n    def func():\n        yield 1\n        yield 1\n        return 3\n\n    def test_return(v):\n        assert v == 3\n\n    def test_yield(v):\n        assert v == 1\n\n    thread_func = threading.thread_worker(\n        func, connect={\'returned\': test_return, \'yielded\': test_yield}\n    )\n    worker = thread_func()\n    assert isinstance(worker, threading.GeneratorWorker)\n\n\ndef test_thread_raises(qtbot):\n    """"""Test exceptions get returned to main thread""""""\n\n    def func():\n        yield 1\n        yield 1\n        raise ValueError(\'whoops\')\n\n    def handle_raise(e):\n        assert isinstance(e, ValueError)\n        assert str(e) == \'whoops\'\n\n    thread_func = threading.thread_worker(\n        func, connect={\'errored\': handle_raise}\n    )\n    worker = thread_func()\n    assert isinstance(worker, threading.GeneratorWorker)\n\n\ndef test_multiple_connections(qtbot):\n    """"""Test the connect dict accepts a list of functions, and type checks""""""\n\n    def func():\n        return 1\n\n    def test1(v):\n        assert v == 1\n\n    def test2(v):\n        assert v == 1\n\n    thread_func = threading.thread_worker(\n        func, connect={\'returned\': [test1, test2]}\n    )\n    worker = thread_func()\n    assert isinstance(worker, threading.FunctionWorker)\n\n    # they must all be functions\n    with pytest.raises(TypeError):\n        threading.thread_worker(func, connect={\'returned\': [\'test1\', test2]})()\n\n    # they must all be functions\n    with pytest.raises(TypeError):\n        threading.thread_worker(func, connect=test1)()\n\n\ndef test_create_worker():\n    """"""Test directly calling create_worker.""""""\n\n    def func(x, y):\n        return x + y\n\n    worker = threading.create_worker(func, 1, 2)\n    assert isinstance(worker, threading.WorkerBase)\n\n    with pytest.raises(TypeError):\n        _ = threading.create_worker(func, 1, 2, _worker_class=object)\n\n\n# note: pytest-cov cannot check coverage of code run in the other thread.\n# this is just for the sake of coverage\ndef test_thread_worker_in_main_thread():\n    """"""Test basic threadworker on a function""""""\n\n    def func(x):\n        return x\n\n    thread_func = threading.thread_worker(func)\n    worker = thread_func(2)\n    # NOTE: you shouldn\'t normally call worker.work()!  If you do, it will NOT\n    # be run in a seperate thread (as it would for worker.start().\n    # This is for the sake of testing it in the main thread.\n    assert worker.work() == 2\n\n\n# note: pytest-cov cannot check coverage of code run in the other thread.\n# this is just for the sake of coverage\ndef test_thread_generator_worker_in_main_thread():\n    """"""Test basic threadworker on a generator in the main thread with methods.\n    """"""\n\n    def func():\n        i = 0\n        while i < 10:\n            i += 1\n            incoming = yield i\n            i = incoming if incoming is not None else i\n        return 3\n\n    worker = threading.thread_worker(func, start_thread=False)()\n    counter = 0\n\n    def handle_pause():\n        time.sleep(0.1)\n        assert worker.is_paused\n        worker.toggle_pause()\n\n    def test_yield(v):\n        nonlocal counter\n        counter += 1\n        if v == 2:\n            assert not worker.is_paused\n            worker.pause()\n            assert not worker.is_paused\n        if v == 3:\n            worker.send(7)\n        if v == 9:\n            worker.quit()\n\n    def handle_abort():\n        assert counter == 5  # because we skipped a few by sending in 7\n\n    worker.paused.connect(handle_pause)\n    assert isinstance(worker, threading.GeneratorWorker)\n    worker.yielded.connect(test_yield)\n    worker.aborted.connect(handle_abort)\n    # NOTE: you shouldn\'t normally call worker.work()!  If you do, it will NOT\n    # be run in a seperate thread (as it would for worker.start().\n    # This is for the sake of testing it in the main thread.\n    assert worker.work() is None  # because we aborted it\n    assert not worker.is_paused\n    assert counter == 5\n\n    worker2 = threading.thread_worker(func, start_thread=False)()\n    assert worker2.work() == 3\n'"
napari/_qt/layers/__init__.py,0,b'from .utils import create_qt_controls\n'
napari/_qt/layers/qt_base_layer.py,0,"b'from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QSlider, QGridLayout, QFrame, QComboBox\n\nfrom ...layers.base._base_constants import Blending\n\n\nclass QtLayerControls(QFrame):\n    """"""Superclass for all the other LayerControl classes.\n\n    This class is never directly instantiated anywhere.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n\n    Attributes\n    ----------\n    blendComboBox : qtpy.QtWidgets.QComboBox\n        Drowpdown widget to select blending mode of layer.\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n    opacitySlider : qtpy.QtWidgets.QSlider\n        Slider controlling opacity of the layer.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__()\n\n        self.layer = layer\n        layer.events.blending.connect(self._on_blending_change)\n        layer.events.opacity.connect(self._on_opacity_change)\n        self.setObjectName(\'layer\')\n        self.setMouseTracking(True)\n\n        self.grid_layout = QGridLayout(self)\n        self.grid_layout.setContentsMargins(0, 0, 0, 0)\n        self.grid_layout.setSpacing(2)\n        self.grid_layout.setColumnMinimumWidth(0, 86)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.setLayout(self.grid_layout)\n\n        sld = QSlider(Qt.Horizontal, parent=self)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(0)\n        sld.setMaximum(100)\n        sld.setSingleStep(1)\n        sld.valueChanged.connect(self.changeOpacity)\n        self.opacitySlider = sld\n        self._on_opacity_change()\n\n        blend_comboBox = QComboBox(self)\n        blend_comboBox.addItems(Blending.keys())\n        index = blend_comboBox.findText(\n            self.layer.blending, Qt.MatchFixedString\n        )\n        blend_comboBox.setCurrentIndex(index)\n        blend_comboBox.activated[str].connect(self.changeBlending)\n        self.blendComboBox = blend_comboBox\n\n    def changeOpacity(self, value):\n        """"""Change opacity value on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Opacity value for shapes.\n            Input range 0 - 100 (transparent to fully opaque).\n        """"""\n        with self.layer.events.blocker(self._on_opacity_change):\n            self.layer.opacity = value / 100\n\n    def changeBlending(self, text):\n        """"""Change blending mode on the layer model.\n\n        Parameters\n        ----------\n        text : str\n            Name of blending mode, eg: \'translucent\', \'additive\', \'opaque\'.\n        """"""\n        self.layer.blending = text\n\n    def _on_opacity_change(self, event=None):\n        """"""Receive layer model opacity change event and update opacity slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.opacity.blocker():\n            self.opacitySlider.setValue(self.layer.opacity * 100)\n\n    def _on_blending_change(self, event=None):\n        """"""Receive layer model blending mode change event and update slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.blending.blocker():\n            index = self.blendComboBox.findText(\n                self.layer.blending, Qt.MatchFixedString\n            )\n            self.blendComboBox.setCurrentIndex(index)\n'"
napari/_qt/layers/qt_image_base_layer.py,3,"b'from functools import partial\nfrom contextlib import suppress\n\nimport numpy as np\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtGui import QImage, QPixmap\nfrom qtpy.QtWidgets import QComboBox, QLabel, QSlider, QPushButton\n\nfrom ..qt_range_slider import QHRangeSlider\nfrom ..qt_range_slider_popup import QRangeSliderPopup\nfrom ..utils import qt_signals_blocked\nfrom .qt_base_layer import QtLayerControls\n\n\nclass QtBaseImageControls(QtLayerControls):\n    """"""Superclass for classes requiring colormaps, contrast & gamma sliders.\n\n    This class is never directly instantiated anywhere.\n    It is subclassed by QtImageControls and QtSurfaceControls.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n\n    Attributes\n    ----------\n    clim_pop : napari._qt.qt_range_slider_popup.QRangeSliderPopup\n        Popup widget launching the contrast range slider.\n    colorbarLabel : qtpy.QtWidgets.QLabel\n        Label text of colorbar widget.\n    colormapComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown widget for selecting the layer colormap.\n    contrastLimitsSlider : qtpy.QtWidgets.QHRangeSlider\n        Contrast range slider widget.\n    gammaSlider : qtpy.QtWidgets.QSlider\n        Gamma adjustment slider widget.\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.colormap.connect(self._on_colormap_change)\n        self.layer.events.gamma.connect(self.gamma_slider_update)\n        self.layer.events.contrast_limits.connect(self._on_clims_change)\n\n        comboBox = QComboBox(self)\n        comboBox.setObjectName(""colormapComboBox"")\n        comboBox.addItems(self.layer.colormaps)\n        comboBox._allitems = set(self.layer.colormaps)\n        comboBox.activated[str].connect(self.changeColor)\n        self.colormapComboBox = comboBox\n\n        # Create contrast_limits slider\n        self.contrastLimitsSlider = QHRangeSlider(\n            self.layer.contrast_limits,\n            self.layer.contrast_limits_range,\n            parent=self,\n        )\n        self.contrastLimitsSlider.mousePressEvent = self._clim_mousepress\n        set_clim = partial(setattr, self.layer, \'contrast_limits\')\n        set_climrange = partial(setattr, self.layer, \'contrast_limits_range\')\n        self.contrastLimitsSlider.valuesChanged.connect(set_clim)\n        self.contrastLimitsSlider.rangeChanged.connect(set_climrange)\n\n        # gamma slider\n        sld = QSlider(Qt.Horizontal, parent=self)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(2)\n        sld.setMaximum(200)\n        sld.setSingleStep(2)\n        sld.setValue(100)\n        sld.valueChanged.connect(self.gamma_slider_changed)\n        self.gammaSlider = sld\n        self.gamma_slider_update()\n\n        self.colorbarLabel = QLabel(parent=self)\n        self.colorbarLabel.setObjectName(\'colorbar\')\n        self.colorbarLabel.setToolTip(\'Colorbar\')\n\n        self._on_colormap_change()\n\n    def changeColor(self, text):\n        """"""Change colormap on the layer model.\n\n        Parameters\n        ----------\n        text : str\n            Colormap name.\n        """"""\n        self.layer.colormap = text\n\n    def _clim_mousepress(self, event):\n        """"""Update the slider, or, on right-click, pop-up an expanded slider.\n\n        The expanded slider provides finer control, directly editable values,\n        and the ability to change the available range of the sliders.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        if event.button() == Qt.RightButton:\n            self.clim_pop = create_range_popup(\n                self.layer, \'contrast_limits\', parent=self\n            )\n            self.clim_pop.finished.connect(self.clim_pop.deleteLater)\n            reset, fullrange = create_clim_reset_buttons(self.layer)\n            self.clim_pop.layout.addWidget(reset)\n            if fullrange is not None:\n                self.clim_pop.layout.addWidget(fullrange)\n            self.clim_pop.show_at(\'top\', min_length=650)\n        else:\n            return QHRangeSlider.mousePressEvent(\n                self.contrastLimitsSlider, event\n            )\n\n    def _on_clims_change(self, event=None):\n        """"""Receive layer model contrast limits change event and update slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with qt_signals_blocked(self.contrastLimitsSlider):\n            self.contrastLimitsSlider.setRange(\n                self.layer.contrast_limits_range\n            )\n            self.contrastLimitsSlider.setValues(self.layer.contrast_limits)\n\n        # clim_popup will throw an AttributeError if not yet created\n        # and a RuntimeError if it has already been cleaned up.\n        # we only want to update the slider if it\'s active\n        with suppress(AttributeError, RuntimeError):\n            self.clim_pop.slider.setRange(self.layer.contrast_limits_range)\n            with qt_signals_blocked(self.clim_pop.slider):\n                clims = self.layer.contrast_limits\n                self.clim_pop.slider.setValues(clims)\n                self.clim_pop._on_values_change(clims)\n\n    def _on_colormap_change(self, event=None):\n        """"""Receive layer model colormap change event and update dropdown menu.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        name = self.layer.colormap[0]\n        if name not in self.colormapComboBox._allitems:\n            self.colormapComboBox._allitems.add(name)\n            self.colormapComboBox.addItem(name)\n        if name != self.colormapComboBox.currentText():\n            self.colormapComboBox.setCurrentText(name)\n\n        # Note that QImage expects the image width followed by height\n        image = QImage(\n            self.layer._colorbar,\n            self.layer._colorbar.shape[1],\n            self.layer._colorbar.shape[0],\n            QImage.Format_RGBA8888,\n        )\n        self.colorbarLabel.setPixmap(QPixmap.fromImage(image))\n\n    def gamma_slider_changed(self, value):\n        """"""Change gamma value on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Gamma adjustment value.\n            https://en.wikipedia.org/wiki/Gamma_correction\n        """"""\n        self.layer.gamma = value / 100\n\n    def gamma_slider_update(self, event=None):\n        """"""Receive the layer model gamma change event and update the slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with qt_signals_blocked(self.gammaSlider):\n            self.gammaSlider.setValue(int(self.layer.gamma * 100))\n\n    def mouseMoveEvent(self, event):\n        self.layer.status = self.layer._contrast_limits_msg\n\n    def closeEvent(self, event):\n        self.deleteLater()\n        event.accept()\n\n\ndef create_range_popup(layer, attr, parent=None):\n    """"""Create a QRangeSliderPopup linked to a specific layer attribute.\n\n    This assumes the layer has an attribute named both `attr` and `attr`_range.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        probably an instance of Image or Surface layer\n    attr : str\n        the attribute to control with the slider.\n    parent : QWidget\n        probably an instance of QtLayerControls. important for styling.\n\n    Returns\n    -------\n    QRangeSliderPopup\n\n    Raises\n    ------\n    AttributeError\n        if `layer` does not have an attribute named `{attr}_range`\n    """"""\n    range_attr = f\'{attr}_range\'\n    if not hasattr(layer, range_attr):\n        raise AttributeError(\n            f\'Layer {layer} must have attribute {range_attr} \'\n            \'to use ""create_range_popup""\'\n        )\n    is_integer_type = np.issubdtype(layer.dtype, np.integer)\n\n    d_range = getattr(layer, range_attr)\n    popup = QRangeSliderPopup(\n        initial_values=getattr(layer, attr),\n        data_range=d_range,\n        collapsible=False,\n        precision=(\n            0\n            if is_integer_type\n            # scale precision with the log of the data range order of magnitude\n            # eg.   0 - 1   (0 order of mag)  -> 3 decimal places\n            #       0 - 10  (1 order of mag)  -> 2 decimals\n            #       0 - 100 (2 orders of mag) -> 1 decimal\n            #       \xe2\x89\xa5 3 orders of mag -> no decimals\n            else int(max(3 - np.log10(max(d_range[1] - d_range[0], 0.01)), 0))\n        ),\n        parent=parent,\n    )\n\n    set_values = partial(setattr, layer, attr)\n    set_range = partial(setattr, layer, range_attr)\n    popup.slider.valuesChanged.connect(set_values)\n    popup.slider.rangeChanged.connect(set_range)\n    return popup\n\n\ndef create_clim_reset_buttons(layer):\n    """"""Create contrast limits reset and full range buttons.\n\n    Important: consumers of this function should check whether range_btn is\n    not None before adding the widget to a layout.  Adding None to a layout\n    can cause a segmentation fault.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        Image or Surface Layer\n\n    Returns\n    -------\n    2-tuple\n        If layer data type is integer type, returns (reset_btn, range_btn).\n        Else, returns (reset_btn, None)\n    """"""\n\n    def reset():\n        layer.reset_contrast_limits()\n        layer.contrast_limits_range = layer.contrast_limits\n\n    def reset_range():\n        layer.reset_contrast_limits_range()\n\n    reset_btn = QPushButton(""reset"")\n    reset_btn.setObjectName(""reset_clims_button"")\n    reset_btn.setToolTip(""autoscale contrast to data range"")\n    reset_btn.setFixedWidth(40)\n    reset_btn.clicked.connect(reset)\n\n    range_btn = None\n    # the ""full range"" button doesn\'t do anything if it\'s not an\n    # unsigned integer type (it\'s unclear what range should be set)\n    # so we don\'t show create it at all.\n    if np.issubdtype(layer.dtype, np.integer):\n        range_btn = QPushButton(""full range"")\n        range_btn.setObjectName(""full_clim_range_button"")\n        range_btn.setToolTip(""set contrast range to full bit-depth"")\n        range_btn.setFixedWidth(65)\n        range_btn.clicked.connect(reset_range)\n\n    return reset_btn, range_btn\n'"
napari/_qt/layers/qt_image_layer.py,0,"b'from qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QComboBox, QHBoxLayout, QLabel, QSlider\n\nfrom ...layers.image._image_constants import (\n    Interpolation,\n    Interpolation3D,\n    Rendering,\n)\nfrom .qt_image_base_layer import QtBaseImageControls\n\n\nclass QtImageControls(QtBaseImageControls):\n    """"""Qt view and controls for the napari Image layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Image\n        An instance of a napari Image layer.\n\n    Attributes\n    ----------\n    attenuationSlider : qtpy.QtWidgets.QSlider\n        Slider controlling attenuation rate for `attenuated_mip` mode.\n    attenuationLabel : qtpy.QtWidgets.QLabel\n        Label for the attenuation slider widget.\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    interpComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown menu to select the interpolation mode for image display.\n    interpLabel : qtpy.QtWidgets.QLabel\n        Label for the interpolation dropdown menu.\n    isoThresholdSlider : qtpy.QtWidgets.QSlider\n        Slider controlling the isosurface threshold value for rendering.\n    isoThresholdLabel : qtpy.QtWidgets.QLabel\n        Label for the isosurface threshold slider widget.\n    layer : napari.layers.Image\n        An instance of a napari Image layer.\n    renderComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown menu to select the rendering mode for image display.\n    renderLabel : qtpy.QtWidgets.QLabel\n        Label for the rendering mode dropdown menu.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.interpolation.connect(self._on_interpolation_change)\n        self.layer.events.rendering.connect(self._on_rendering_change)\n        self.layer.events.iso_threshold.connect(self._on_iso_threshold_change)\n        self.layer.events.attenuation.connect(self._on_attenuation_change)\n        self.layer.dims.events.ndisplay.connect(self._on_ndisplay_change)\n\n        self.interpComboBox = QComboBox(self)\n        self.interpComboBox.activated[str].connect(self.changeInterpolation)\n        self.interpLabel = QLabel(\'interpolation:\')\n\n        renderComboBox = QComboBox(self)\n        renderComboBox.addItems(Rendering.keys())\n        index = renderComboBox.findText(\n            self.layer.rendering, Qt.MatchFixedString\n        )\n        renderComboBox.setCurrentIndex(index)\n        renderComboBox.activated[str].connect(self.changeRendering)\n        self.renderComboBox = renderComboBox\n        self.renderLabel = QLabel(\'rendering:\')\n\n        sld = QSlider(Qt.Horizontal, parent=self)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(0)\n        sld.setMaximum(100)\n        sld.setSingleStep(1)\n        sld.setValue(int(self.layer.iso_threshold * 100))\n        sld.valueChanged.connect(self.changeIsoThreshold)\n        self.isoThresholdSlider = sld\n        self.isoThresholdLabel = QLabel(\'iso threshold:\')\n\n        sld = QSlider(Qt.Horizontal, parent=self)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(0)\n        sld.setMaximum(200)\n        sld.setSingleStep(1)\n        sld.setValue(int(self.layer.attenuation * 100))\n        sld.valueChanged.connect(self.changeAttenuation)\n        self.attenuationSlider = sld\n        self.attenuationLabel = QLabel(\'attenuation:\')\n        self._on_ndisplay_change()\n\n        colormap_layout = QHBoxLayout()\n        colormap_layout.addWidget(self.colorbarLabel)\n        colormap_layout.addWidget(self.colormapComboBox)\n        colormap_layout.addStretch(1)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 0, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 0, 1)\n        self.grid_layout.addWidget(QLabel(\'contrast limits:\'), 1, 0)\n        self.grid_layout.addWidget(self.contrastLimitsSlider, 1, 1)\n        self.grid_layout.addWidget(QLabel(\'gamma:\'), 2, 0)\n        self.grid_layout.addWidget(self.gammaSlider, 2, 1)\n        self.grid_layout.addWidget(QLabel(\'colormap:\'), 3, 0)\n        self.grid_layout.addLayout(colormap_layout, 3, 1)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 4, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 4, 1)\n        self.grid_layout.addWidget(self.interpLabel, 5, 0)\n        self.grid_layout.addWidget(self.interpComboBox, 5, 1)\n        self.grid_layout.addWidget(self.renderLabel, 6, 0)\n        self.grid_layout.addWidget(self.renderComboBox, 6, 1)\n        self.grid_layout.addWidget(self.isoThresholdLabel, 7, 0)\n        self.grid_layout.addWidget(self.isoThresholdSlider, 7, 1)\n        self.grid_layout.addWidget(self.attenuationLabel, 8, 0)\n        self.grid_layout.addWidget(self.attenuationSlider, 8, 1)\n        self.grid_layout.setRowStretch(9, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n\n    def changeInterpolation(self, text):\n        """"""Change interpolation mode for image display.\n\n        Parameters\n        ----------\n        text : str\n            Interpolation mode used by vispy. Must be one of our supported\n            modes:\n            \'bessel\', \'bicubic\', \'bilinear\', \'blackman\', \'catrom\', \'gaussian\',\n            \'hamming\', \'hanning\', \'hermite\', \'kaiser\', \'lanczos\', \'mitchell\',\n            \'nearest\', \'spline16\', \'spline36\'\n        """"""\n        self.layer.interpolation = text\n\n    def changeRendering(self, text):\n        """"""Change rendering mode for image display.\n\n        Parameters\n        ----------\n        text : str\n            Rendering mode used by vispy.\n            Selects a preset rendering mode in vispy that determines how\n            volume is displayed:\n            * translucent: voxel colors are blended along the view ray until\n              the result is opaque.\n            * mip: maxiumum intensity projection. Cast a ray and display the\n              maximum value that was encountered.\n            * additive: voxel colors are added along the view ray until\n              the result is saturated.\n            * iso: isosurface. Cast a ray until a certain threshold is\n              encountered. At that location, lighning calculations are\n              performed to give the visual appearance of a surface.\n            * attenuated_mip: attenuated maxiumum intensity projection. Cast a\n              ray and attenuate values based on integral of encountered values,\n              display the maximum value that was encountered after attenuation.\n              This will make nearer objects appear more prominent.\n        """"""\n        self.layer.rendering = text\n        self._toggle_rendering_parameter_visbility()\n\n    def changeIsoThreshold(self, value):\n        """"""Change isosurface threshold on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Threshold for isosurface.\n        """"""\n        with self.layer.events.blocker(self._on_iso_threshold_change):\n            self.layer.iso_threshold = value / 100\n\n    def _on_iso_threshold_change(self, event):\n        """"""Receive layer model isosurface change event and update the slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.iso_threshold.blocker():\n            self.isoThresholdSlider.setValue(self.layer.iso_threshold * 100)\n\n    def changeAttenuation(self, value):\n        """"""Change attenuation rate for attenuated maximum intensity projection.\n\n        Parameters\n        ----------\n        value : Float\n            Attenuation rate for attenuated maximum intensity projection.\n        """"""\n        with self.layer.events.blocker(self._on_attenuation_change):\n            self.layer.attenuation = value / 100\n\n    def _on_attenuation_change(self, event):\n        """"""Receive layer model attenuation change event and update the slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.attenuation.blocker():\n            self.attenuationSlider.setValue(self.layer.attenuation * 100)\n\n    def _on_interpolation_change(self, event):\n        """"""Receive layer interpolation change event and update dropdown menu.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.interpolation.blocker():\n            index = self.interpComboBox.findText(\n                self.layer.interpolation, Qt.MatchFixedString\n            )\n            self.interpComboBox.setCurrentIndex(index)\n\n    def _on_rendering_change(self, event):\n        """"""Receive layer model rendering change event and update dropdown menu.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.rendering.blocker():\n            index = self.renderComboBox.findText(\n                self.layer.rendering, Qt.MatchFixedString\n            )\n            self.renderComboBox.setCurrentIndex(index)\n            self._toggle_rendering_parameter_visbility()\n\n    def _toggle_rendering_parameter_visbility(self):\n        """"""Hide isosurface rendering parameters if they aren\'t needed.""""""\n        rendering = Rendering(self.layer.rendering)\n        if rendering == Rendering.ISO:\n            self.isoThresholdSlider.show()\n            self.isoThresholdLabel.show()\n        else:\n            self.isoThresholdSlider.hide()\n            self.isoThresholdLabel.hide()\n        if rendering == Rendering.ATTENUATED_MIP:\n            self.attenuationSlider.show()\n            self.attenuationLabel.show()\n        else:\n            self.attenuationSlider.hide()\n            self.attenuationLabel.hide()\n\n    def _update_interpolation_combo(self):\n        self.interpComboBox.clear()\n        interp_enum = (\n            Interpolation3D if self.layer.dims.ndisplay == 3 else Interpolation\n        )\n        self.interpComboBox.addItems(interp_enum.keys())\n        index = self.interpComboBox.findText(\n            self.layer.interpolation, Qt.MatchFixedString\n        )\n        self.interpComboBox.setCurrentIndex(index)\n\n    def _on_ndisplay_change(self, event=None):\n        """"""Toggle between 2D and 3D visualization modes.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional\n            Event from the Qt context, default is None.\n        """"""\n        self._update_interpolation_combo()\n        if self.layer.dims.ndisplay == 2:\n            self.isoThresholdSlider.hide()\n            self.isoThresholdLabel.hide()\n            self.attenuationSlider.hide()\n            self.attenuationLabel.hide()\n            self.renderComboBox.hide()\n            self.renderLabel.hide()\n        else:\n            self.renderComboBox.show()\n            self.renderLabel.show()\n            self._toggle_rendering_parameter_visbility()\n'"
napari/_qt/layers/qt_labels_layer.py,1,"b'import sys\nfrom qtpy.QtGui import QPainter, QColor\nfrom qtpy.QtWidgets import (\n    QButtonGroup,\n    QWidget,\n    QSlider,\n    QCheckBox,\n    QLabel,\n    QSpinBox,\n    QHBoxLayout,\n)\nfrom qtpy.QtCore import Qt\n\nimport numpy as np\nfrom .qt_base_layer import QtLayerControls\nfrom ...layers.labels._labels_constants import Mode\nfrom ..qt_mode_buttons import QtModeRadioButton, QtModePushButton\nfrom ..utils import disable_with_opacity\n\n\nclass QtLabelsControls(QtLayerControls):\n    """"""Qt view and controls for the napari Labels layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Labels\n        An instance of a napari Labels layer.\n\n    Attributes\n    ----------\n    button_group : qtpy.QtWidgets.QButtonGroup\n        Button group of labels layer modes: PAN_ZOOM, PICKER, PAINT, ERASE, or\n        FILL.\n    colormapUpdate : qtpy.QtWidgets.QPushButton\n        Button to update colormap of label layer.\n    contigCheckBox : qtpy.QtWidgets.QCheckBox\n        Checkbox to control if label layer is contiguous.\n    fill_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select FILL mode on Labels layer.\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Labels\n        An instance of a napari Labels layer.\n    ndimCheckBox : qtpy.QtWidgets.QCheckBox\n        Checkbox to control if label layer is n-dimensional.\n    paint_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select PAINT mode on Labels layer.\n    panzoom_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select PAN_ZOOM mode on Labels layer.\n    pick_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select PICKER mode on Labels layer.\n    erase_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select ERASE mode on Labels layer.\n    selectionSpinBox : qtpy.QtWidgets.QSpinBox\n        Widget to select a specfic label by its index.\n\n    Raises\n    ------\n    ValueError\n        Raise error if label mode is not PAN_ZOOM, PICKER, PAINT, ERASE, or\n        FILL.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.mode.connect(self._on_mode_change)\n        self.layer.events.selected_label.connect(self._on_selection_change)\n        self.layer.events.brush_size.connect(self._on_brush_size_change)\n        self.layer.events.contiguous.connect(self._on_contig_change)\n        self.layer.events.n_dimensional.connect(self._on_n_dim_change)\n        self.layer.events.editable.connect(self._on_editable_change)\n        self.layer.events.preserve_labels.connect(\n            self._on_preserve_labels_change\n        )\n\n        # selection spinbox\n        self.selectionSpinBox = QSpinBox()\n        self.selectionSpinBox.setKeyboardTracking(False)\n        self.selectionSpinBox.setSingleStep(1)\n        self.selectionSpinBox.setMinimum(0)\n        self.selectionSpinBox.setMaximum(2147483647)\n        self.selectionSpinBox.valueChanged.connect(self.changeSelection)\n        self.selectionSpinBox.setAlignment(Qt.AlignCenter)\n        self._on_selection_change()\n\n        sld = QSlider(Qt.Horizontal)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(1)\n        sld.setMaximum(40)\n        sld.setSingleStep(1)\n        sld.valueChanged.connect(self.changeSize)\n        self.brushSizeSlider = sld\n        self._on_brush_size_change()\n\n        contig_cb = QCheckBox()\n        contig_cb.setToolTip(\'contiguous editing\')\n        contig_cb.stateChanged.connect(self.change_contig)\n        self.contigCheckBox = contig_cb\n        self._on_contig_change()\n\n        ndim_cb = QCheckBox()\n        ndim_cb.setToolTip(\'n-dimensional editing\')\n        ndim_cb.stateChanged.connect(self.change_ndim)\n        self.ndimCheckBox = ndim_cb\n        self._on_n_dim_change()\n\n        preserve_labels_cb = QCheckBox()\n        preserve_labels_cb.setToolTip(\n            \'preserve existing labels while painting\'\n        )\n        preserve_labels_cb.stateChanged.connect(self.change_preserve_labels)\n        self.preserveLabelsCheckBox = preserve_labels_cb\n        self._on_preserve_labels_change()\n\n        # shuffle colormap button\n        self.colormapUpdate = QtModePushButton(\n            None, \'shuffle\', slot=self.changeColor, tooltip=\'shuffle colors\',\n        )\n\n        self.panzoom_button = QtModeRadioButton(\n            layer,\n            \'zoom\',\n            Mode.PAN_ZOOM,\n            tooltip=\'Pan/zoom mode (Space)\',\n            checked=True,\n        )\n        self.pick_button = QtModeRadioButton(\n            layer, \'picker\', Mode.PICK, tooltip=\'Pick mode\'\n        )\n        self.paint_button = QtModeRadioButton(\n            layer, \'paint\', Mode.PAINT, tooltip=\'Paint mode\'\n        )\n        btn = \'Cmd\' if sys.platform == \'darwin\' else \'Ctrl\'\n        self.fill_button = QtModeRadioButton(\n            layer, \'fill\', Mode.FILL, tooltip=f\'Fill mode ({btn})\'\n        )\n        self.erase_button = QtModeRadioButton(\n            layer, \'erase\', Mode.ERASE, tooltip=\'Erase mode (Alt)\'\n        )\n\n        self.button_group = QButtonGroup(self)\n        self.button_group.addButton(self.panzoom_button)\n        self.button_group.addButton(self.paint_button)\n        self.button_group.addButton(self.pick_button)\n        self.button_group.addButton(self.fill_button)\n        self.button_group.addButton(self.erase_button)\n        self._on_editable_change()\n\n        button_row = QHBoxLayout()\n        button_row.addStretch(1)\n        button_row.addWidget(self.colormapUpdate)\n        button_row.addWidget(self.erase_button)\n        button_row.addWidget(self.fill_button)\n        button_row.addWidget(self.paint_button)\n        button_row.addWidget(self.pick_button)\n        button_row.addWidget(self.panzoom_button)\n        button_row.setSpacing(4)\n        button_row.setContentsMargins(0, 0, 0, 5)\n\n        color_layout = QHBoxLayout()\n        color_layout.addWidget(QtColorBox(layer))\n        color_layout.addWidget(self.selectionSpinBox)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addLayout(button_row, 0, 0, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'label:\'), 1, 0)\n        self.grid_layout.addLayout(color_layout, 1, 1)\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 2, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 2, 1)\n        self.grid_layout.addWidget(QLabel(\'brush size:\'), 3, 0)\n        self.grid_layout.addWidget(self.brushSizeSlider, 3, 1)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 4, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 4, 1)\n        self.grid_layout.addWidget(QLabel(\'contiguous:\'), 5, 0)\n        self.grid_layout.addWidget(self.contigCheckBox, 5, 1)\n        self.grid_layout.addWidget(QLabel(\'n-dim:\'), 6, 0)\n        self.grid_layout.addWidget(self.ndimCheckBox, 6, 1)\n        self.grid_layout.addWidget(QLabel(\'preserve labels:\'), 7, 0)\n        self.grid_layout.addWidget(self.preserveLabelsCheckBox, 7, 1)\n        self.grid_layout.setRowStretch(8, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n\n    def mouseMoveEvent(self, event):\n        """"""On mouse move, set layer status equal to the current selected mode.\n\n        Available mode options are: PAN_ZOOM, PICKER, PAINT, ERASE or FILL\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.layer.status = str(self.layer.mode)\n\n    def _on_mode_change(self, event):\n        """"""Receive layer model mode change event and update checkbox ticks.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n\n        Raises\n        ------\n        ValueError\n            Raise error if event.mode is not PAN_ZOOM, PICK, PAINT, ERASE, or\n            FILL\n        """"""\n        mode = event.mode\n        if mode == Mode.PAN_ZOOM:\n            self.panzoom_button.setChecked(True)\n        elif mode == Mode.PICK:\n            self.pick_button.setChecked(True)\n        elif mode == Mode.PAINT:\n            self.paint_button.setChecked(True)\n        elif mode == Mode.FILL:\n            self.fill_button.setChecked(True)\n        elif mode == Mode.ERASE:\n            self.erase_button.setChecked(True)\n        else:\n            raise ValueError(""Mode not recognized"")\n\n    def changeColor(self):\n        """"""Change colormap of the label layer.""""""\n        self.layer.new_colormap()\n\n    def changeSelection(self, value):\n        """"""Change currently selected label.\n\n        Parameters\n        ----------\n        value : int\n            Index of label to select.\n        """"""\n        self.layer.selected_label = value\n        self.selectionSpinBox.clearFocus()\n        self.setFocus()\n\n    def changeSize(self, value):\n        """"""Change paint brush size.\n\n        Parameters\n        ----------\n        value : float\n            Size of the paint brush.\n        """"""\n        self.layer.brush_size = value\n\n    def change_contig(self, state):\n        """"""Toggle contiguous state of label layer.\n\n        Parameters\n        ----------\n        state : QCheckBox\n            Checkbox indicating if labels are contiguous.\n        """"""\n        if state == Qt.Checked:\n            self.layer.contiguous = True\n        else:\n            self.layer.contiguous = False\n\n    def change_ndim(self, state):\n        """"""Toggle n-dimensional state of label layer.\n\n        Parameters\n        ----------\n        state : QCheckBox\n            Checkbox indicating if label layer is n-dimensional.\n        """"""\n        if state == Qt.Checked:\n            self.layer.n_dimensional = True\n        else:\n            self.layer.n_dimensional = False\n\n    def change_preserve_labels(self, state):\n        """"""Toggle preserve_labels state of label layer.\n\n        Parameters\n        ----------\n        state : QCheckBox\n            Checkbox indicating if overwriting label is enabled.\n        """"""\n        if state == Qt.Checked:\n            self.layer.preserve_labels = True\n        else:\n            self.layer.preserve_labels = False\n\n    def _on_selection_change(self, event=None):\n        """"""Receive layer model label selection change event and update spinbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.selected_label.blocker():\n            value = self.layer.selected_label\n            self.selectionSpinBox.setValue(int(value))\n\n    def _on_brush_size_change(self, event=None):\n        """"""Receive layer model brush size change event and update the slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.brush_size.blocker():\n            value = self.layer.brush_size\n            value = np.clip(int(value), 1, 40)\n            self.brushSizeSlider.setValue(value)\n\n    def _on_n_dim_change(self, event=None):\n        """"""Receive layer model n-dim mode change event and update the checkbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.n_dimensional.blocker():\n            self.ndimCheckBox.setChecked(self.layer.n_dimensional)\n\n    def _on_contig_change(self, event=None):\n        """"""Receive layer model contiguous change event and update the checkbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.contiguous.blocker():\n            self.contigCheckBox.setChecked(self.layer.contiguous)\n\n    def _on_preserve_labels_change(self, event=None):\n        """"""Receive layer model preserve_labels event and update the checkbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.preserve_labels.blocker():\n            self.preserveLabelsCheckBox.setChecked(self.layer.preserve_labels)\n\n    def _on_editable_change(self, event=None):\n        """"""Receive layer model editable change event & enable/disable buttons.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        disable_with_opacity(\n            self,\n            [\'pick_button\', \'paint_button\', \'fill_button\'],\n            self.layer.editable,\n        )\n\n\nclass QtColorBox(QWidget):\n    """"""A widget that shows a square with the current label color.\n\n    Parameters\n    ----------\n    layer : napari.layers.Layer\n        An instance of a napari layer.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__()\n\n        self.layer = layer\n        self._height = 24\n        self.setFixedWidth(self._height)\n        self.setFixedHeight(self._height)\n        self.setToolTip(\'Selected label color\')\n\n        self.layer.events.selected_label.connect(self.update_color)\n\n    def update_color(self, event):\n        """"""Receive layer model label selection change event & update colorbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.update()\n\n    def paintEvent(self, event):\n        """"""Paint the colorbox.  If no color, display a checkerboard pattern.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        painter = QPainter(self)\n        if self.layer._selected_color is None:\n            for i in range(self._height // 4):\n                for j in range(self._height // 4):\n                    if (i % 2 == 0 and j % 2 == 0) or (\n                        i % 2 == 1 and j % 2 == 1\n                    ):\n                        painter.setPen(QColor(230, 230, 230))\n                        painter.setBrush(QColor(230, 230, 230))\n                    else:\n                        painter.setPen(QColor(25, 25, 25))\n                        painter.setBrush(QColor(25, 25, 25))\n                    painter.drawRect(i * 4, j * 4, 5, 5)\n        else:\n            color = 255 * self.layer._selected_color\n            color = color.astype(int)\n            painter.setPen(QColor(*list(color)))\n            painter.setBrush(QColor(*list(color)))\n            painter.drawRect(0, 0, self._height, self._height)\n'"
napari/_qt/layers/qt_points_layer.py,4,"b'import numpy as np\nfrom qtpy.QtCore import Qt, Slot\nfrom qtpy.QtWidgets import (\n    QButtonGroup,\n    QCheckBox,\n    QComboBox,\n    QHBoxLayout,\n    QLabel,\n    QSlider,\n)\n\nfrom ...layers.points._points_constants import Mode, Symbol\nfrom ..qt_color_dialog import QColorSwatchEdit\nfrom ..qt_mode_buttons import QtModePushButton, QtModeRadioButton\nfrom ..utils import qt_signals_blocked\nfrom .qt_base_layer import QtLayerControls\nfrom ..utils import disable_with_opacity\n\n\nclass QtPointsControls(QtLayerControls):\n    """"""Qt view and controls for the napari Points layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Points\n        An instance of a napari Points layer.\n\n    Attributes\n    ----------\n    addition_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add points to layer.\n    button_group : qtpy.QtWidgets.QButtonGroup\n        Button group of points layer modes (ADD, PAN_ZOOM, SELECT).\n    delete_button : qtpy.QtWidgets.QtModePushButton\n        Button to delete points from layer.\n    edgeColorSwatch : qtpy.QtWidgets.QFrame\n        Color swatch showing shapes edge display color.\n    edgeComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown widget to select display color for shape edges.\n    faceColorSwatch : qtpy.QtWidgets.QFrame\n        Color swatch showing shapes face display color.\n    faceComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown widget to select display color for shape faces.\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Points\n        An instance of a napari Points layer.\n    ndimCheckBox : qtpy.QtWidgets.QCheckBox\n        Checkbox to indicate whether layer is n-dimensional.\n    panzoom_button : qtpy.QtWidgets.QtModeRadioButton\n        Button for pan/zoom mode.\n    select_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select points from layer.\n    sizeSlider : qtpy.QtWidgets.QSlider\n        Slider controlling size of points.\n    symbolComboBox : qtpy.QtWidgets.QComboBox\n        Drop down list of symbol options for points markers.\n\n    Raises\n    ------\n    ValueError\n        Raise error if points mode is not recognized.\n        Points mode must be one of: ADD, PAN_ZOOM, or SELECT.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.mode.connect(self.set_mode)\n        self.layer.events.n_dimensional.connect(self._on_n_dim_change)\n        self.layer.events.symbol.connect(self._on_symbol_change)\n        self.layer.events.size.connect(self._on_size_change)\n        self.layer.events.current_edge_color.connect(\n            self._on_edge_color_change\n        )\n        self.layer.events.current_face_color.connect(\n            self._on_face_color_change\n        )\n        self.layer.events.editable.connect(self._on_editable_change)\n\n        sld = QSlider(Qt.Horizontal)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(1)\n        sld.setMaximum(100)\n        sld.setSingleStep(1)\n        value = self.layer.current_size\n        sld.setValue(int(value))\n        sld.valueChanged.connect(self.changeSize)\n        self.sizeSlider = sld\n\n        self.faceColorEdit = QColorSwatchEdit(\n            initial_color=self.layer.current_face_color,\n            tooltip=\'click to set current face color\',\n        )\n        self.edgeColorEdit = QColorSwatchEdit(\n            initial_color=self.layer.current_edge_color,\n            tooltip=\'click to set current edge color\',\n        )\n        self.faceColorEdit.color_changed.connect(self.changeFaceColor)\n        self.edgeColorEdit.color_changed.connect(self.changeEdgeColor)\n\n        symbol_comboBox = QComboBox()\n        symbol_comboBox.addItems([str(s) for s in Symbol])\n        index = symbol_comboBox.findText(\n            self.layer.symbol, Qt.MatchFixedString\n        )\n        symbol_comboBox.setCurrentIndex(index)\n        symbol_comboBox.activated[str].connect(self.changeSymbol)\n        self.symbolComboBox = symbol_comboBox\n\n        ndim_cb = QCheckBox()\n        ndim_cb.setToolTip(\'N-dimensional points\')\n        ndim_cb.setChecked(self.layer.n_dimensional)\n        ndim_cb.stateChanged.connect(self.change_ndim)\n        self.ndimCheckBox = ndim_cb\n\n        self.select_button = QtModeRadioButton(\n            layer, \'select_points\', Mode.SELECT, tooltip=\'Select points\'\n        )\n        self.addition_button = QtModeRadioButton(\n            layer, \'add_points\', Mode.ADD, tooltip=\'Add points\'\n        )\n        self.panzoom_button = QtModeRadioButton(\n            layer, \'pan_zoom\', Mode.PAN_ZOOM, tooltip=\'Pan/zoom\', checked=True\n        )\n        self.delete_button = QtModePushButton(\n            layer,\n            \'delete_shape\',\n            slot=self.layer.remove_selected,\n            tooltip=\'Delete selected points\',\n        )\n\n        self.button_group = QButtonGroup(self)\n        self.button_group.addButton(self.select_button)\n        self.button_group.addButton(self.addition_button)\n        self.button_group.addButton(self.panzoom_button)\n\n        button_row = QHBoxLayout()\n        button_row.addStretch(1)\n        button_row.addWidget(self.delete_button)\n        button_row.addWidget(self.addition_button)\n        button_row.addWidget(self.select_button)\n        button_row.addWidget(self.panzoom_button)\n        button_row.setContentsMargins(0, 0, 0, 5)\n        button_row.setSpacing(4)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addLayout(button_row, 0, 1)\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 1, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 1, 1)\n        self.grid_layout.addWidget(QLabel(\'point size:\'), 2, 0)\n        self.grid_layout.addWidget(self.sizeSlider, 2, 1)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 3, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 3, 1)\n        self.grid_layout.addWidget(QLabel(\'symbol:\'), 4, 0)\n        self.grid_layout.addWidget(self.symbolComboBox, 4, 1)\n        self.grid_layout.addWidget(QLabel(\'face color:\'), 5, 0)\n        self.grid_layout.addWidget(self.faceColorEdit, 5, 1)\n        self.grid_layout.addWidget(QLabel(\'edge color:\'), 6, 0)\n        self.grid_layout.addWidget(self.edgeColorEdit, 6, 1)\n        self.grid_layout.addWidget(QLabel(\'n-dim:\'), 7, 0)\n        self.grid_layout.addWidget(self.ndimCheckBox, 7, 1)\n        self.grid_layout.setRowStretch(8, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n\n    def mouseMoveEvent(self, event):\n        """"""On mouse move, update layer mode status.\n\n        Modes available for points layer: ADD, PAN_ZOOM, SELECT\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.layer.status = self.layer.mode\n\n    def set_mode(self, event):\n        """"""""Update ticks in checkbox widgets when points layer mode is changed.\n\n        Available modes for points layer are:\n        * ADD\n        * SELECT\n        * PAN_ZOOM\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n\n        Raises\n        ------\n        ValueError\n            Raise error if event.mode is not ADD, PAN_ZOOM, or SELECT.\n        """"""\n        mode = event.mode\n        if mode == Mode.ADD:\n            self.addition_button.setChecked(True)\n        elif mode == Mode.SELECT:\n            self.select_button.setChecked(True)\n        elif mode == Mode.PAN_ZOOM:\n            self.panzoom_button.setChecked(True)\n        else:\n            raise ValueError(""Mode not recognized"")\n\n    def changeSymbol(self, text):\n        """"""Change marker symbol of the points on the layer model.\n\n        Parameters\n        ----------\n        text : str\n            Marker symbol of points, eg: \'+\', \'.\', etc.\n        """"""\n        self.layer.symbol = text\n\n    def changeSize(self, value):\n        """"""Change size of points on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Size of points.\n        """"""\n        self.layer.current_size = value\n\n    def change_ndim(self, state):\n        """"""Toggle n-dimensional state of label layer.\n\n        Parameters\n        ----------\n        state : QCheckBox\n            Checkbox indicating if label layer is n-dimensional.\n        """"""\n        if state == Qt.Checked:\n            self.layer.n_dimensional = True\n        else:\n            self.layer.n_dimensional = False\n\n    def _on_n_dim_change(self, event):\n        """"""Receive layer model n-dimensional change event and update checkbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.n_dimensional.blocker():\n            self.ndimCheckBox.setChecked(self.layer.n_dimensional)\n\n    def _on_symbol_change(self, event):\n        """"""Receive marker symbol change event and update the dropdown menu.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        with self.layer.events.symbol.blocker():\n            index = self.symbolComboBox.findText(\n                self.layer.symbol, Qt.MatchFixedString\n            )\n            self.symbolComboBox.setCurrentIndex(index)\n\n    def _on_size_change(self, event=None):\n        """"""Receive layer model size change event and update point size slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context.\n        """"""\n        with self.layer.events.size.blocker():\n            value = self.layer.current_size\n            self.sizeSlider.setValue(int(value))\n\n    @Slot(np.ndarray)\n    def changeFaceColor(self, color: np.ndarray):\n        """"""Update face color of layer model from color picker user input.""""""\n        with self.layer.events.current_face_color.blocker():\n            self.layer.current_face_color = color\n\n    @Slot(np.ndarray)\n    def changeEdgeColor(self, color: np.ndarray):\n        """"""Update edge color of layer model from color picker user input.""""""\n        with self.layer.events.current_edge_color.blocker():\n            self.layer.current_edge_color = color\n\n    def _on_face_color_change(self, event=None):\n        """"""Receive layer.current_face_color() change event and update view.""""""\n        with qt_signals_blocked(self.faceColorEdit):\n            self.faceColorEdit.setColor(self.layer.current_face_color)\n\n    def _on_edge_color_change(self, event=None):\n        """"""Receive layer.current_edge_color() change event and update view.""""""\n        with qt_signals_blocked(self.edgeColorEdit):\n            self.edgeColorEdit.setColor(self.layer.current_edge_color)\n\n    def _on_editable_change(self, event=None):\n        """"""Receive layer model editable change event & enable/disable buttons.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        disable_with_opacity(\n            self,\n            [\'select_button\', \'addition_button\', \'delete_button\'],\n            self.layer.editable,\n        )\n'"
napari/_qt/layers/qt_shapes_layer.py,6,"b'from collections.abc import Iterable\nimport numpy as np\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QButtonGroup, QLabel, QSlider, QGridLayout\nfrom .qt_base_layer import QtLayerControls\nfrom ..qt_color_dialog import QColorSwatchEdit\nfrom ...layers.shapes._shapes_constants import Mode\nfrom ..qt_mode_buttons import QtModeRadioButton, QtModePushButton\nfrom ..utils import disable_with_opacity, qt_signals_blocked\n\n\nclass QtShapesControls(QtLayerControls):\n    """"""Qt view and controls for the napari Shapes layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Shapes\n        An instance of a napari Shapes layer.\n\n    Attributes\n    ----------\n    button_group : qtpy.QtWidgets.QButtonGroup\n        Button group for shapes layer modes\n        (SELECT, DIRECT, PAN_ZOOM, ADD_RECTANGLE, ADD_ELLIPSE, ADD_LINE,\n        ADD_PATH, ADD_POLYGON, VERTEX_INSERT, VERTEX_REMOVE).\n    delete_button : qtpy.QtWidgets.QtModePushButton\n        Button to delete selected shapes\n    direct_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select individual vertices in shapes.\n    edgeColorSwatch : qtpy.QtWidgets.QFrame\n        Thumbnail display of points edge color.\n    edgeComboBox : qtpy.QtWidgets.QComboBox\n        Drop down list allowing user to set edge color of points.\n    ellipse_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add ellipses to shapes layer.\n    faceColorSwatch : qtpy.QtWidgets.QFrame\n        Thumbnail display of points face color.\n    faceComboBox : qtpy.QtWidgets.QComboBox\n        Drop down list allowing user to set face color of points.\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Shapes\n        An instance of a napari Shapes layer.\n    line_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add lines to shapes layer.\n    move_back_button : qtpy.QtWidgets.QtModePushButton\n        Button to move selected shape(s) to the back.\n    move_front_button : qtpy.QtWidgets.QtModePushButton\n        Button to move shape(s) to the front.\n    panzoom_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to pan/zoom shapes layer.\n    path_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add paths to shapes layer.\n    polygon_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add polygons to shapes layer.\n    rectangle_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to add rectangles to shapes layer.\n    select_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to select shapes.\n    vertex_insert_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to insert vertex into shape.\n    vertex_remove_button : qtpy.QtWidgets.QtModeRadioButton\n        Button to remove vertex from shapes.\n    widthSlider : qtpy.QtWidgets.QSlider\n        Slider controlling line edge width of shapes.\n\n    Raises\n    ------\n    ValueError\n        Raise error if shapes mode is not recognized.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.mode.connect(self.set_mode)\n        self.layer.events.edge_width.connect(self._on_edge_width_change)\n        self.layer.events.current_edge_color.connect(\n            self._on_edge_color_change\n        )\n        self.layer.events.current_face_color.connect(\n            self._on_face_color_change\n        )\n        self.layer.events.editable.connect(self._on_editable_change)\n\n        sld = QSlider(Qt.Horizontal)\n        sld.setFocusPolicy(Qt.NoFocus)\n        sld.setMinimum(0)\n        sld.setMaximum(40)\n        sld.setSingleStep(1)\n        value = self.layer.current_edge_width\n        if isinstance(value, Iterable):\n            if isinstance(value, list):\n                value = np.asarray(value)\n            value = value.mean()\n        sld.setValue(int(value))\n        sld.valueChanged.connect(self.changeWidth)\n        self.widthSlider = sld\n\n        self.select_button = QtModeRadioButton(\n            layer, \'select\', Mode.SELECT, tooltip=\'Select shapes\'\n        )\n        self.direct_button = QtModeRadioButton(\n            layer, \'direct\', Mode.DIRECT, tooltip=\'Select vertices\'\n        )\n        self.panzoom_button = QtModeRadioButton(\n            layer, \'zoom\', Mode.PAN_ZOOM, tooltip=\'Pan/zoom\', checked=True\n        )\n        self.rectangle_button = QtModeRadioButton(\n            layer, \'rectangle\', Mode.ADD_RECTANGLE, tooltip=\'Add rectangles\'\n        )\n        self.ellipse_button = QtModeRadioButton(\n            layer, \'ellipse\', Mode.ADD_ELLIPSE, tooltip=\'Add ellipses\'\n        )\n        self.line_button = QtModeRadioButton(\n            layer, \'line\', Mode.ADD_LINE, tooltip=\'Add lines\'\n        )\n        self.path_button = QtModeRadioButton(\n            layer, \'path\', Mode.ADD_PATH, tooltip=\'Add paths\'\n        )\n        self.polygon_button = QtModeRadioButton(\n            layer, \'polygon\', Mode.ADD_POLYGON, tooltip=\'Add polygons\'\n        )\n        self.vertex_insert_button = QtModeRadioButton(\n            layer, \'vertex_insert\', Mode.VERTEX_INSERT, tooltip=\'Insert vertex\'\n        )\n        self.vertex_remove_button = QtModeRadioButton(\n            layer, \'vertex_remove\', Mode.VERTEX_REMOVE, tooltip=\'Remove vertex\'\n        )\n\n        self.move_front_button = QtModePushButton(\n            layer,\n            \'move_front\',\n            slot=self.layer.move_to_front,\n            tooltip=\'Move to front\',\n        )\n        self.move_back_button = QtModePushButton(\n            layer,\n            \'move_back\',\n            slot=self.layer.move_to_back,\n            tooltip=\'Move to back\',\n        )\n        self.delete_button = QtModePushButton(\n            layer,\n            \'delete_shape\',\n            slot=self.layer.remove_selected,\n            tooltip=\'Delete selected shapes\',\n        )\n\n        self.button_group = QButtonGroup(self)\n        self.button_group.addButton(self.select_button)\n        self.button_group.addButton(self.direct_button)\n        self.button_group.addButton(self.panzoom_button)\n        self.button_group.addButton(self.rectangle_button)\n        self.button_group.addButton(self.ellipse_button)\n        self.button_group.addButton(self.line_button)\n        self.button_group.addButton(self.path_button)\n        self.button_group.addButton(self.polygon_button)\n        self.button_group.addButton(self.vertex_insert_button)\n        self.button_group.addButton(self.vertex_remove_button)\n\n        button_grid = QGridLayout()\n        button_grid.addWidget(self.vertex_remove_button, 0, 2)\n        button_grid.addWidget(self.vertex_insert_button, 0, 3)\n        button_grid.addWidget(self.delete_button, 0, 4)\n        button_grid.addWidget(self.direct_button, 0, 5)\n        button_grid.addWidget(self.select_button, 0, 6)\n        button_grid.addWidget(self.panzoom_button, 0, 7)\n        button_grid.addWidget(self.move_back_button, 1, 1)\n        button_grid.addWidget(self.move_front_button, 1, 2)\n        button_grid.addWidget(self.ellipse_button, 1, 3)\n        button_grid.addWidget(self.rectangle_button, 1, 4)\n        button_grid.addWidget(self.polygon_button, 1, 5)\n        button_grid.addWidget(self.line_button, 1, 6)\n        button_grid.addWidget(self.path_button, 1, 7)\n        button_grid.setContentsMargins(5, 0, 0, 5)\n        button_grid.setColumnStretch(0, 1)\n        button_grid.setSpacing(4)\n\n        self.faceColorEdit = QColorSwatchEdit(\n            initial_color=self.layer.current_face_color,\n            tooltip=\'click to set current face color\',\n        )\n        self._on_face_color_change()\n        self.edgeColorEdit = QColorSwatchEdit(\n            initial_color=self.layer.current_edge_color,\n            tooltip=\'click to set current edge color\',\n        )\n        self._on_edge_color_change()\n        self.faceColorEdit.color_changed.connect(self.changeFaceColor)\n        self.edgeColorEdit.color_changed.connect(self.changeEdgeColor)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addLayout(button_grid, 0, 0, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 1, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 1, 1)\n        self.grid_layout.addWidget(QLabel(\'edge width:\'), 2, 0)\n        self.grid_layout.addWidget(self.widthSlider, 2, 1)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 3, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 3, 1)\n        self.grid_layout.addWidget(QLabel(\'face color:\'), 4, 0)\n        self.grid_layout.addWidget(self.faceColorEdit, 4, 1)\n        self.grid_layout.addWidget(QLabel(\'edge color:\'), 5, 0)\n        self.grid_layout.addWidget(self.edgeColorEdit, 5, 1)\n        self.grid_layout.setRowStretch(6, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n\n    def mouseMoveEvent(self, event):\n        """"""On mouse move, update layer mode status.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n        """"""\n        self.layer.status = str(self.layer.mode)\n\n    def set_mode(self, event):\n        """"""""Update ticks in checkbox widgets when shapes layer mode changed.\n\n        Available modes for shapes layer are:\n        * SELECT\n        * DIRECT\n        * PAN_ZOOM\n        * ADD_RECTANGLE\n        * ADD_ELLIPSE\n        * ADD_LINE\n        * ADD_PATH\n        * ADD_POLYGON\n        * VERTEX_INSERT\n        * VERTEX_REMOVE\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent\n            Event from the Qt context.\n\n        Raises\n        ------\n        ValueError\n            Raise error if event.mode is not ADD, PAN_ZOOM, or SELECT.\n        """"""\n        mode_buttons = {\n            Mode.SELECT: self.select_button,\n            Mode.DIRECT: self.direct_button,\n            Mode.PAN_ZOOM: self.panzoom_button,\n            Mode.ADD_RECTANGLE: self.rectangle_button,\n            Mode.ADD_ELLIPSE: self.ellipse_button,\n            Mode.ADD_LINE: self.line_button,\n            Mode.ADD_PATH: self.path_button,\n            Mode.ADD_POLYGON: self.polygon_button,\n            Mode.VERTEX_INSERT: self.vertex_insert_button,\n            Mode.VERTEX_REMOVE: self.vertex_remove_button,\n        }\n\n        if event.mode in mode_buttons:\n            mode_buttons[event.mode].setChecked(True)\n        else:\n            raise ValueError(f""Mode \'{event.mode}\'not recognized"")\n\n    def changeFaceColor(self, color: np.ndarray):\n        """"""Change face color of shapes.\n\n        Parameters\n        ----------\n        color : np.ndarray\n            Face color for shapes, color name or hex string.\n            Eg: \'white\', \'red\', \'blue\', \'#00ff00\', etc.\n        """"""\n        with self.layer.events.current_face_color.blocker():\n            self.layer.current_face_color = color\n\n    def changeEdgeColor(self, color: np.ndarray):\n        """"""Change edge color of shapes.\n\n        Parameters\n        ----------\n        color : np.ndarray\n            Edge color for shapes, color name or hex string.\n            Eg: \'white\', \'red\', \'blue\', \'#00ff00\', etc.\n        """"""\n        with self.layer.events.current_edge_color.blocker():\n            self.layer.current_edge_color = color\n\n    def changeWidth(self, value):\n        """"""Change edge line width of shapes on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Line width of shapes.\n        """"""\n        self.layer.current_edge_width = float(value) / 2\n\n    def changeOpacity(self, value):\n        """"""Change opacity value of shapes on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Opacity value for shapes.\n            Input range 0 - 100 (transparent to fully opaque).\n        """"""\n        with self.layer.events.blocker(self._on_opacity_change):\n            self.layer.opacity = value / 100\n\n    def _on_edge_width_change(self, event=None):\n        """"""Receive layer model edge line width change event and update slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.edge_width.blocker():\n            value = self.layer.current_edge_width\n            value = np.clip(int(2 * value), 0, 40)\n            self.widthSlider.setValue(value)\n\n    def _on_edge_color_change(self, event=None):\n        """"""Receive layer model edge color change event and update color swatch.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with qt_signals_blocked(self.edgeColorEdit):\n            self.edgeColorEdit.setColor(self.layer.current_edge_color)\n\n    def _on_face_color_change(self, event=None):\n        """"""Receive layer model face color change event and update color swatch.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with qt_signals_blocked(self.faceColorEdit):\n            self.faceColorEdit.setColor(self.layer.current_face_color)\n\n    def _on_opacity_change(self, event=None):\n        """"""Receive layer model opacity change event and update opacity slider.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.opacity.blocker():\n            self.opacitySlider.setValue(self.layer.opacity * 100)\n\n    def _on_editable_change(self, event=None):\n        """"""Receive layer model editable change event & enable/disable buttons.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        disable_with_opacity(\n            self,\n            [\n                \'select_button\',\n                \'direct_button\',\n                \'rectangle_button\',\n                \'ellipse_button\',\n                \'line_button\',\n                \'path_button\',\n                \'polygon_button\',\n                \'vertex_remove_button\',\n                \'vertex_insert_button\',\n                \'delete_button\',\n                \'move_back_button\',\n                \'move_front_button\',\n            ],\n            self.layer.editable,\n        )\n'"
napari/_qt/layers/qt_surface_layer.py,0,"b'from .qt_image_base_layer import QtBaseImageControls\nfrom qtpy.QtWidgets import QLabel, QHBoxLayout\n\n\nclass QtSurfaceControls(QtBaseImageControls):\n    """"""Qt view and controls for the napari Surface layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Surface\n        An instance of a napari Surface layer.\n\n    Attributes\n    ----------\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Surface\n        An instance of a napari Surface layer.\n\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        colormap_layout = QHBoxLayout()\n        colormap_layout.addWidget(self.colorbarLabel)\n        colormap_layout.addWidget(self.colormapComboBox)\n        colormap_layout.addStretch(1)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 0, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 0, 1)\n        self.grid_layout.addWidget(QLabel(\'contrast limits:\'), 1, 0)\n        self.grid_layout.addWidget(self.contrastLimitsSlider, 1, 1)\n        self.grid_layout.addWidget(QLabel(\'gamma:\'), 2, 0)\n        self.grid_layout.addWidget(self.gammaSlider, 2, 1)\n        self.grid_layout.addWidget(QLabel(\'colormap:\'), 3, 0)\n        self.grid_layout.addLayout(colormap_layout, 3, 1)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 4, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 4, 1)\n        self.grid_layout.setRowStretch(5, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n'"
napari/_qt/layers/qt_vectors_layer.py,4,"b'import numpy as np\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QLabel, QComboBox, QDoubleSpinBox\nfrom .qt_base_layer import QtLayerControls\nfrom ..qt_color_dialog import QColorSwatchEdit\nfrom ..utils import qt_signals_blocked\nfrom ...layers.vectors._vectors_constants import ColorMode\n\n\nclass QtVectorsControls(QtLayerControls):\n    """"""Qt view and controls for the napari Vectors layer.\n\n    Parameters\n    ----------\n    layer : napari.layers.Vectors\n        An instance of a napari Vectors layer.\n\n    Attributes\n    ----------\n    edge_color_label : qtpy.QtWidgets.QLabel\n        Label for edgeColorSwatch\n    edgeColorSwatch : qtpy.QtWidgets.QFrame\n        Color swatch showing display color of vectors.\n    edgeComboBox : qtpy.QtWidgets.QComboBox\n        Dropdown widget to select display color for vectors.\n    color_mode_comboBox : qtpy.QtWidgets.QComboBox\n        Dropdown widget to select edge_color_mode for the vectors.\n    color_prop_box : qtpy.QtWidgets.QComboBox\n        Dropdown widget to select _edge_color_property for the vectors.\n    edge_prop_label : qtpy.QtWidgets.QLabel\n        Label for color_prop_box\n    grid_layout : qtpy.QtWidgets.QGridLayout\n        Layout of Qt widget controls for the layer.\n    layer : napari.layers.Vectors\n        An instance of a napari Vectors layer.\n    lengthSpinBox : qtpy.QtWidgets.QDoubleSpinBox\n        Spin box widget controlling line length of vectors.\n        Multiplicative factor on projections for length of all vectors.\n    widthSpinBox : qtpy.QtWidgets.QDoubleSpinBox\n        Spin box widget controlling edge line width of vectors.\n    """"""\n\n    def __init__(self, layer):\n        super().__init__(layer)\n\n        self.layer.events.edge_width.connect(self._on_width_change)\n        self.layer.events.length.connect(self._on_len_change)\n        self.layer.events.edge_color_mode.connect(\n            self._on_edge_color_mode_change\n        )\n        self.layer.events.edge_color.connect(self._on_edge_color_change)\n\n        # dropdown to select the property for mapping edge_color\n        color_properties = self._get_property_values()\n        color_prop_box = QComboBox(self)\n        color_prop_box.activated[str].connect(self.change_edge_color_property)\n        color_prop_box.addItems(color_properties)\n        self.color_prop_box = color_prop_box\n        self.edge_prop_label = QLabel(\'edge property:\')\n\n        # vector direct color mode adjustment and widget\n        self.edgeColorEdit = QColorSwatchEdit(\n            initial_color=self.layer.edge_color,\n            tooltip=\'click to set current edge color\',\n        )\n        self.edgeColorEdit.color_changed.connect(self.change_edge_color_direct)\n        self.edge_color_label = QLabel(\'edge color:\')\n        self._on_edge_color_change()\n\n        # dropdown to select the edge color mode\n        colorModeComboBox = QComboBox(self)\n        colorModeComboBox.addItems(ColorMode.keys())\n        colorModeComboBox.activated[str].connect(self.change_edge_color_mode)\n        self.color_mode_comboBox = colorModeComboBox\n        self._on_edge_color_mode_change()\n\n        # line width in pixels\n        self.widthSpinBox = QDoubleSpinBox()\n        self.widthSpinBox.setKeyboardTracking(False)\n        self.widthSpinBox.setSingleStep(0.1)\n        self.widthSpinBox.setMinimum(0.1)\n        self.widthSpinBox.setValue(self.layer.edge_width)\n        self.widthSpinBox.valueChanged.connect(self.change_width)\n\n        # line length\n        self.lengthSpinBox = QDoubleSpinBox()\n        self.lengthSpinBox.setKeyboardTracking(False)\n        self.lengthSpinBox.setSingleStep(0.1)\n        self.lengthSpinBox.setValue(self.layer.length)\n        self.lengthSpinBox.setMinimum(0.1)\n        self.lengthSpinBox.valueChanged.connect(self.change_length)\n\n        # grid_layout created in QtLayerControls\n        # addWidget(widget, row, column, [row_span, column_span])\n        self.grid_layout.addWidget(QLabel(\'opacity:\'), 0, 0)\n        self.grid_layout.addWidget(self.opacitySlider, 0, 1, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'width:\'), 1, 0)\n        self.grid_layout.addWidget(self.widthSpinBox, 1, 1, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'length:\'), 2, 0)\n        self.grid_layout.addWidget(self.lengthSpinBox, 2, 1, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'blending:\'), 3, 0)\n        self.grid_layout.addWidget(self.blendComboBox, 3, 1, 1, 2)\n        self.grid_layout.addWidget(QLabel(\'edge color mode:\'), 4, 0)\n        self.grid_layout.addWidget(self.color_mode_comboBox, 4, 1, 1, 2)\n        self.grid_layout.addWidget(self.edge_color_label, 5, 0)\n        self.grid_layout.addWidget(self.edgeColorEdit, 5, 1, 1, 2)\n        self.grid_layout.addWidget(self.edge_prop_label, 6, 0)\n        self.grid_layout.addWidget(self.color_prop_box, 6, 1, 1, 2)\n        self.grid_layout.setRowStretch(7, 1)\n        self.grid_layout.setColumnStretch(1, 1)\n        self.grid_layout.setSpacing(4)\n\n    def change_edge_color_property(self, property: str):\n        """"""Change edge_color_property of vectors on the layer model.\n        This property is the property the edge color is mapped to.\n\n        Parameters\n        ----------\n        property : str\n            property to map the edge color to\n        """"""\n        mode = self.layer.edge_color_mode\n        try:\n            self.layer.edge_color = property\n            self.layer.edge_color_mode = mode\n        except TypeError:\n            # if the selected property is the wrong type for the current color mode\n            # the color mode will be changed to the appropriate type, so we must update\n            self._on_edge_color_mode_change()\n            raise\n\n    def change_edge_color_mode(self, mode: str):\n        """"""Change edge color mode of vectors on the layer model.\n\n        Parameters\n        ----------\n        mode : str\n            Edge color for vectors. Must be: \'direct\', \'cycle\', or \'colormap\'\n        """"""\n        old_mode = self.layer.edge_color_mode\n        with self.layer.events.edge_color_mode.blocker():\n            try:\n                self.layer.edge_color_mode = mode\n                self._update_edge_color_gui(mode)\n\n            except ValueError:\n                # if the color mode was invalid, revert to the old mode\n                self.layer.edge_color_mode = old_mode\n                raise\n\n    def change_edge_color_direct(self, color: np.ndarray):\n        """"""Change edge color of vectors on the layer model.\n\n        Parameters\n        ----------\n        color : np.ndarray\n            Edge color for vectors, in an RGBA array\n        """"""\n        self.layer.edge_color = color\n\n    def change_width(self, value):\n        """"""Change edge line width of vectors on the layer model.\n\n        Parameters\n        ----------\n        value : float\n            Line width of vectors.\n        """"""\n        self.layer.edge_width = value\n        self.widthSpinBox.clearFocus()\n        self.setFocus()\n\n    def change_length(self, value):\n        """"""Change length of vectors on the layer model.\n\n        Multiplicative factor on projections for length of all vectors.\n\n        Parameters\n        ----------\n        value : float\n            Length of vectors.\n        """"""\n        self.layer.length = value\n        self.lengthSpinBox.clearFocus()\n        self.setFocus()\n\n    def _update_edge_color_gui(self, mode: str):\n        """""" Update the GUI element associated with edge_color.\n        This is typically used when edge_color_mode changes\n\n        Parameters\n        ----------\n        mode : str\n            The new edge_color mode the GUI needs to be updated for.\n            Should be: \'direct\', \'cycle\', \'colormap\'\n        """"""\n        if mode in (\'cycle\', \'colormap\'):\n            self.edgeColorEdit.setHidden(True)\n            self.edge_color_label.setHidden(True)\n            self.color_prop_box.setHidden(False)\n            self.edge_prop_label.setHidden(False)\n\n        elif mode == \'direct\':\n            self.edgeColorEdit.setHidden(False)\n            self.edge_color_label.setHidden(False)\n            self.color_prop_box.setHidden(True)\n            self.edge_prop_label.setHidden(True)\n\n    def _get_property_values(self):\n        """"""Get the current property values from the Vectors layer\n\n        Returns\n        -------\n        property_values : np.ndarray\n            array of all of the union of the property names (keys)\n            in Vectors.properties and Vectors._property_choices\n\n        """"""\n        property_choices = [*self.layer._property_choices]\n        properties = [*self.layer.properties]\n        property_values = np.union1d(property_choices, properties)\n\n        return property_values\n\n    def _on_len_change(self, event=None):\n        """"""Change length of vectors.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.length.blocker():\n            self.lengthSpinBox.setValue(self.layer.length)\n\n    def _on_width_change(self, event=None):\n        """"""""Receive layer model width change event and update width spinbox.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with self.layer.events.edge_width.blocker():\n            self.widthSpinBox.setValue(self.layer.edge_width)\n\n    def _on_edge_color_mode_change(self, event=None):\n        """"""""Receive layer model edge color mode change event & update dropdown.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        with qt_signals_blocked(self.color_mode_comboBox):\n            mode = self.layer.edge_color_mode\n            index = self.color_mode_comboBox.findText(\n                mode, Qt.MatchFixedString\n            )\n            self.color_mode_comboBox.setCurrentIndex(index)\n\n            self._update_edge_color_gui(mode)\n\n    def _on_edge_color_change(self, event=None):\n        """"""""Receive layer model edge color  change event & update dropdown.\n\n        Parameters\n        ----------\n        event : qtpy.QtCore.QEvent, optional.\n            Event from the Qt context, by default None.\n        """"""\n        if self.layer._edge_color_mode == ColorMode.DIRECT:\n            with qt_signals_blocked(self.edgeColorEdit):\n                self.edgeColorEdit.setColor(self.layer.edge_color[0])\n        elif self.layer._edge_color_mode in (\n            ColorMode.CYCLE,\n            ColorMode.COLORMAP,\n        ):\n            with qt_signals_blocked(self.color_prop_box):\n                prop = self.layer._edge_color_property\n                index = self.color_prop_box.findText(prop, Qt.MatchFixedString)\n                self.color_prop_box.setCurrentIndex(index)\n'"
napari/_qt/layers/utils.py,0,"b'from ...layers import Image, Labels, Points, Shapes, Surface, Vectors\nfrom .qt_image_layer import QtImageControls\nfrom .qt_points_layer import QtPointsControls\nfrom .qt_shapes_layer import QtShapesControls\nfrom .qt_labels_layer import QtLabelsControls\nfrom .qt_surface_layer import QtSurfaceControls\nfrom .qt_vectors_layer import QtVectorsControls\n\n\nlayer_to_controls = {\n    Image: QtImageControls,\n    Labels: QtLabelsControls,\n    Points: QtPointsControls,\n    Shapes: QtShapesControls,\n    Surface: QtSurfaceControls,\n    Vectors: QtVectorsControls,\n}\n\n\ndef create_qt_controls(layer):\n    """"""\n    Create a qt controls widget for a layer based on its layer type.\n\n    Parameters\n    ----------\n        layer : napari.layers._base_layer.Layer\n            Layer that needs its controls widget created.\n\n    Returns\n    ----------\n        controls : napari.layers.base.QtLayerControls\n            Qt controls widget\n    """"""\n    controls = layer_to_controls[type(layer)](layer)\n\n    return controls\n'"
napari/_vispy/_tests/test_image_rendering.py,1,"b'import numpy as np\n\n\ndef test_image_rendering(viewer_factory):\n    """"""Test 3D image with different rendering.""""""\n    view, viewer = viewer_factory()\n\n    data = np.random.random((20, 20, 20))\n    layer = viewer.add_image(data)\n\n    assert layer.rendering == \'mip\'\n\n    # Change rendering property\n    layer.rendering = \'translucent\'\n    assert layer.rendering == \'translucent\'\n\n    # Change rendering property\n    layer.rendering = \'attenuated_mip\'\n    assert layer.rendering == \'attenuated_mip\'\n    layer.attenuation = 0.2\n    assert layer.attenuation == 0.2\n\n    # Change rendering property\n    layer.rendering = \'iso\'\n    assert layer.rendering == \'iso\'\n    layer.iso_threshold = 0.3\n    assert layer.iso_threshold == 0.3\n\n    # Change rendering property\n    layer.rendering = \'additive\'\n    assert layer.rendering == \'additive\'\n'"
napari/_vispy/_tests/test_vispy_big_images.py,6,"b'import numpy as np\n\n\ndef test_big_2D_image(viewer_factory):\n    """"""Test big 2D image with axis exceeding max texture size.""""""\n    view, viewer = viewer_factory()\n\n    shape = (20_000, 10)\n    data = np.random.random(shape)\n    layer = viewer.add_image(data, multiscale=False)\n    visual = view.layer_to_visual[layer]\n    assert visual.node is not None\n    if visual.MAX_TEXTURE_SIZE_2D is not None:\n        s = np.ceil(np.divide(shape, visual.MAX_TEXTURE_SIZE_2D)).astype(int)\n        assert np.all(layer._transforms[\'tile2data\'].scale == s)\n\n\ndef test_big_3D_image(viewer_factory):\n    """"""Test big 3D image with axis exceeding max texture size.""""""\n    view, viewer = viewer_factory(ndisplay=3)\n\n    shape = (5, 10, 3_000)\n    data = np.random.random(shape)\n    layer = viewer.add_image(data, multiscale=False)\n    visual = view.layer_to_visual[layer]\n    assert visual.node is not None\n    if visual.MAX_TEXTURE_SIZE_3D is not None:\n        s = np.ceil(np.divide(shape, visual.MAX_TEXTURE_SIZE_3D)).astype(int)\n        assert np.all(layer._transforms[\'tile2data\'].scale == s)\n'"
napari/_vispy/_tests/test_vispy_calls.py,14,"b'import numpy as np\nfrom unittest.mock import patch\n\n\ndef test_data_change_ndisplay_image(viewer_factory):\n    """"""Test change data calls for image layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15, 8))\n    layer = viewer.add_image(data)\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n\n\ndef test_data_change_ndisplay_labels(viewer_factory):\n    """"""Test change data calls for labels layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15, 8))\n    layer = viewer.add_labels(data)\n\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n\n\ndef test_data_change_ndisplay_points(viewer_factory):\n    """"""Test change data calls for points layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 3))\n    layer = viewer.add_points(data)\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n\n\ndef test_data_change_ndisplay_vectors(viewer_factory):\n    """"""Test change data calls for vectors layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2, 3))\n    layer = viewer.add_vectors(data)\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n\n\ndef test_data_change_ndisplay_shapes(viewer_factory):\n    """"""Test change data calls for shapes layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 3))\n    layer = viewer.add_shapes(data)\n\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n\n\ndef test_data_change_ndisplay_surface(viewer_factory):\n    """"""Test change data calls for surface layer with ndisplay change.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = viewer.add_surface(data)\n\n    visual = view.layer_to_visual[layer]\n\n    @patch.object(visual, \'_on_data_change\', wraps=visual._on_data_change)\n    def test_ndisplay_change(mocked_method, ndisplay=3):\n        viewer.dims.ndisplay = ndisplay\n        mocked_method.assert_called_once()\n\n    # Switch to 3D rendering mode and back to 2D rendering mode\n    test_ndisplay_change(ndisplay=3)\n    test_ndisplay_change(ndisplay=2)\n'"
napari/_vispy/_tests/test_vispy_multiscale.py,26,"b'import numpy as np\nimport sys\nimport pytest\n\n\ndef test_multiscale(viewer_factory):\n    """"""Test rendering of multiscale data.""""""\n    view, viewer = viewer_factory(show=True)\n\n    shapes = [(4000, 3000), (2000, 1500), (1000, 750), (500, 375)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    _ = viewer.add_image(data, multiscale=True, contrast_limits=[0, 1])\n    layer = viewer.layers[0]\n\n    # Set canvas size to target amount\n    view.view.canvas.size = (800, 600)\n    list(view.layer_to_visual.values())[0].on_draw(None)\n\n    # Check that current level is first large enough to fill the canvas with\n    # a greater than one pixel depth\n    assert layer.data_level == 2\n\n    # Check that full field of view is currently requested\n    assert np.all(layer.corner_pixels[0] <= [0, 0])\n    assert np.all(layer.corner_pixels[1] >= np.subtract(shapes[2], 1))\n\n    # Test value at top left corner of image\n    layer.position = (0, 0)\n    value = layer.get_value()\n    np.testing.assert_allclose(value, (2, data[2][(0, 0)]))\n\n    # Test value at bottom right corner of image\n    layer.position = (999, 749)\n    value = layer.get_value()\n    np.testing.assert_allclose(value, (2, data[2][(999, 749)]))\n\n    # Test value outside image\n    layer.position = (1000, 750)\n    value = layer.get_value()\n    assert value[1] is None\n\n\ndef test_3D_multiscale_image(viewer_factory):\n    """"""Test rendering of 3D multiscale image uses lowest resolution.""""""\n    view, viewer = viewer_factory(show=True)\n\n    data = [np.random.random((128,) * 3), np.random.random((64,) * 3)]\n    viewer.add_image(data)\n\n    # Check that this doesn\'t crash.\n    viewer.dims.ndisplay = 3\n\n    # Check lowest resolution is used\n    assert viewer.layers[0].data_level == 1\n\n    # Note that draw command must be explicitly triggered in our tests\n    list(view.layer_to_visual.values())[0].on_draw(None)\n\n\n@pytest.mark.skipif(\n    sys.platform.startswith(\'win\'),\n    reason=\'Screenshot tests are not supported on napari windows CI.\',\n)\ndef test_multiscale_screenshot(viewer_factory):\n    """"""Test rendering of multiscale data with screenshot.""""""\n    view, viewer = viewer_factory(show=True)\n\n    shapes = [(4000, 3000), (2000, 1500), (1000, 750), (500, 375)]\n    data = [np.ones(s) for s in shapes]\n    _ = viewer.add_image(data, multiscale=True, contrast_limits=[0, 1])\n\n    # Set canvas size to target amount\n    view.view.canvas.size = (800, 600)\n\n    screenshot = viewer.screenshot(canvas_only=True)\n    center_coord = np.round(np.array(screenshot.shape[:2]) / 2).astype(np.int)\n    target_center = np.array([255, 255, 255, 255], dtype=\'uint8\')\n    target_edge = np.array([0, 0, 0, 255], dtype=\'uint8\')\n    screen_offset = 3  # Offset is needed as our screenshots have black borders\n\n    np.testing.assert_allclose(screenshot[tuple(center_coord)], target_center)\n    np.testing.assert_allclose(\n        screenshot[screen_offset, screen_offset], target_edge\n    )\n    np.testing.assert_allclose(\n        screenshot[-screen_offset, -screen_offset], target_edge\n    )\n\n\n@pytest.mark.skipif(\n    sys.platform.startswith(\'win\'),\n    reason=\'Screenshot tests are not supported on napari windows CI.\',\n)\ndef test_multiscale_screenshot_zoomed(viewer_factory):\n    """"""Test rendering of multiscale data with screenshot after zoom.""""""\n    view, viewer = viewer_factory(show=True)\n\n    shapes = [(4000, 3000), (2000, 1500), (1000, 750), (500, 375)]\n    data = [np.ones(s) for s in shapes]\n    _ = viewer.add_image(data, multiscale=True, contrast_limits=[0, 1])\n\n    # Set canvas size to target amount\n    view.view.canvas.size = (800, 600)\n\n    # Set zoom of camera to show highest resolution tile\n    view.view.camera.rect = [1000, 1000, 200, 150]\n    list(view.layer_to_visual.values())[0].on_draw(None)\n\n    # Check that current level is bottom level of multiscale\n    assert viewer.layers[0].data_level == 0\n\n    screenshot = viewer.screenshot(canvas_only=True)\n    center_coord = np.round(np.array(screenshot.shape[:2]) / 2).astype(np.int)\n    target_center = np.array([255, 255, 255, 255], dtype=\'uint8\')\n    screen_offset = 3  # Offset is needed as our screenshots have black borders\n\n    np.testing.assert_allclose(screenshot[tuple(center_coord)], target_center)\n    np.testing.assert_allclose(\n        screenshot[screen_offset, screen_offset], target_center\n    )\n    np.testing.assert_allclose(\n        screenshot[-screen_offset, -screen_offset], target_center\n    )\n\n\n@pytest.mark.skipif(\n    sys.platform.startswith(\'win\'),\n    reason=\'Screenshot tests are not supported on napari windows CI.\',\n)\ndef test_image_screenshot_zoomed(viewer_factory):\n    """"""Test rendering of image data with screenshot after zoom.""""""\n    view, viewer = viewer_factory(show=True)\n\n    data = np.ones((4000, 3000))\n    _ = viewer.add_image(data, multiscale=False, contrast_limits=[0, 1])\n\n    # Set canvas size to target amount\n    view.view.canvas.size = (800, 600)\n\n    # Set zoom of camera to show highest resolution tile\n    view.view.camera.rect = [1000, 1000, 200, 150]\n    list(view.layer_to_visual.values())[0].on_draw(None)\n\n    screenshot = viewer.screenshot(canvas_only=True)\n    center_coord = np.round(np.array(screenshot.shape[:2]) / 2).astype(np.int)\n    target_center = np.array([255, 255, 255, 255], dtype=\'uint8\')\n    screen_offset = 3  # Offset is needed as our screenshots have black borders\n\n    np.testing.assert_allclose(screenshot[tuple(center_coord)], target_center)\n    np.testing.assert_allclose(\n        screenshot[screen_offset, screen_offset], target_center\n    )\n    np.testing.assert_allclose(\n        screenshot[-screen_offset, -screen_offset], target_center\n    )\n'"
napari/components/_tests/test_add_layers.py,1,"b'from unittest.mock import MagicMock, patch\n\nimport numpy as np\nimport pytest\n\nfrom napari._tests.utils import layer_test_data\nfrom napari.components.viewer_model import ViewerModel\n\nimg = np.random.rand(10, 10)\nlayer_data = [(lay[1], {}, lay[0].__name__.lower()) for lay in layer_test_data]\n\n\n@pytest.mark.parametrize(""layer_datum"", layer_data)\ndef test_add_layers_with_plugins(layer_datum):\n    """"""Test that add_layers_with_plugins adds the expected layer types.""""""\n    with patch(\n        ""napari.components.add_layers_mixin.read_data_with_plugins"",\n        MagicMock(return_value=[layer_datum]),\n    ):\n        v = ViewerModel()\n        v._add_layers_with_plugins(\'mock_path\')\n        layertypes = [l._type_string for l in v.layers]\n        assert layertypes == [layer_datum[2]]\n\n\n@patch(\n    ""napari.components.add_layers_mixin.read_data_with_plugins"",\n    MagicMock(return_value=[]),\n)\ndef test_plugin_returns_nothing():\n    """"""Test that a plugin returning nothing adds nothing to the Viewer.""""""\n    v = ViewerModel()\n    v._add_layers_with_plugins(\'mock_path\')\n    assert not v.layers\n\n\n@patch(\n    ""napari.components.add_layers_mixin.read_data_with_plugins"",\n    MagicMock(return_value=[(img,)]),\n)\ndef test_viewer_open():\n    """"""Test that a plugin to returning an image adds stuff to the viewer.""""""\n    viewer = ViewerModel()\n    assert len(viewer.layers) == 0\n    viewer.open(\'mock_path.tif\')\n    assert len(viewer.layers) == 1\n    # The name should be taken from the path name, stripped of extension\n    assert viewer.layers[0].name == \'mock_path\'\n\n    # stack=True also works... and very long names are truncated\n    viewer.open(\'mock_path.tif\', stack=True)\n    assert len(viewer.layers) == 2\n    assert viewer.layers[1].name.startswith(\'mock_path\')\n\n\nplugin_returns = [\n    ([(img, {\'name\': \'foo\'})], {\'name\': \'bar\'}),\n    ([(img, {\'blending\': \'additive\'}), (img,)], {\'blending\': \'translucent\'}),\n]\n\n\n@pytest.mark.parametrize(""layer_data, kwargs"", plugin_returns)\ndef test_add_layers_with_plugins_and_kwargs(layer_data, kwargs):\n    """"""Test that _add_layers_with_plugins kwargs override plugin kwargs.\n\n    see also: napari.components._test.test_prune_kwargs\n    """"""\n    with patch(\n        ""napari.components.add_layers_mixin.read_data_with_plugins"",\n        MagicMock(return_value=layer_data),\n    ):\n        v = ViewerModel()\n        v._add_layers_with_plugins(\'mock_path\', kwargs=kwargs)\n        for layer in v.layers:\n            for key, val in kwargs.items():\n                assert getattr(layer, key) == val\n                # if plugins don\'t provide ""name"", it falls back to path name\n                if \'name\' not in kwargs:\n                    assert layer.name.startswith(\'mock_path\')\n'"
napari/components/_tests/test_dims.py,0,"b'import pytest\n\nfrom napari.components import Dims\nfrom napari.components.dims_constants import DimsMode\n\n\ndef test_ndim():\n    """"""\n    Test number of dimensions including after adding and removing dimensions.\n    """"""\n    dims = Dims()\n    assert dims.ndim == 2\n\n    dims = Dims(4)\n    assert dims.ndim == 4\n\n    dims = Dims(2)\n    assert dims.ndim == 2\n\n    dims.ndim = 10\n    assert dims.ndim == 10\n\n    dims.ndim = 5\n    assert dims.ndim == 5\n\n\ndef test_display():\n    """"""\n    Test display setting.\n    """"""\n    dims = Dims(4)\n    assert dims.order == [0, 1, 2, 3]\n    assert dims.ndisplay == 2\n\n    dims.order = [2, 3, 1, 0]\n    assert dims.order == [2, 3, 1, 0]\n\n\ndef test_order_with_init():\n    dims = Dims(3, order=[0, 2, 1])\n    assert dims.order == [0, 2, 1]\n\n\ndef test_labels_with_init():\n    dims = Dims(3, axis_labels=[\'x\', \'y\', \'z\'])\n    assert dims.axis_labels == [\'x\', \'y\', \'z\']\n\n\ndef test_wrong_order():\n    with pytest.raises(ValueError):\n        Dims(3, order=range(2))\n\n\ndef test_wrong_labels():\n    with pytest.raises(ValueError):\n        Dims(3, axis_labels=[\'a\', \'b\'])\n\n\ndef test_keyword_only_dims():\n    with pytest.raises(TypeError):\n        Dims(3, [1, 2, 3])\n\n\ndef test_point():\n    """"""\n    Test point setting.\n    """"""\n    dims = Dims(4)\n    assert dims.point == [0] * 4\n\n    dims.set_point(3, 4)\n    assert dims.point == [0, 0, 0, 4]\n\n    dims.set_point(2, 1)\n    assert dims.point == [0, 0, 1, 4]\n\n\ndef test_mode():\n    """"""\n    Test mode setting.\n    """"""\n    dims = Dims(4)\n    assert dims.mode == [DimsMode.POINT] * 4\n\n    dims.set_mode(3, DimsMode.INTERVAL)\n    assert dims.mode == [DimsMode.POINT] * 3 + [DimsMode.INTERVAL]\n\n\ndef test_range():\n    """"""\n    Tests range setting.\n    """"""\n    dims = Dims(4)\n    assert dims.range == [(0, 2, 1)] * 4\n\n    dims.set_range(3, (0, 4, 2))\n    assert dims.range == [(0, 2, 1)] * 3 + [(0, 4, 2)]\n\n\ndef test_interval():\n    """"""\n    Test interval setting.\n    """"""\n    dims = Dims(4)\n    assert dims.interval == [(0, 1)] * 4\n\n    dims.set_interval(3, (0, 3))\n    assert dims.interval == [(0, 1)] * 3 + [(0, 3)]\n\n\ndef test_indices():\n    """"""\n    Test indices values.\n    """"""\n    dims = Dims(4)\n    # On instantiation the last two dims are set to sliced mode\n    assert dims.indices == (0,) * 2 + (slice(None, None, None),) * 2\n\n    # Set the values of the first two dims in point mode outside of range\n    dims.set_point(0, 2)\n    dims.set_point(1, 3)\n    assert dims.indices == (1, 1) + (slice(None, None, None),) * 2\n\n    # Increase range and then set points again\n    # Note changing the step size changes the indices for the same point value\n    dims.set_range(0, (0, 4, 2))\n    dims.set_range(1, (0, 4, 2))\n    dims.set_point(0, 2)\n    dims.set_point(1, 3)\n    assert dims.indices == (1, 2) + (slice(None, None, None),) * 2\n\n\ndef test_axis_labels():\n    dims = Dims(4)\n    assert dims.axis_labels == [\'0\', \'1\', \'2\', \'3\']\n\n\ndef test_order_when_changing_ndim():\n    """"""\n    Test order of the dims when changing the number of dimensions.\n    """"""\n    dims = Dims(4)\n    dims.set_point(0, 2)\n\n    dims.ndim = 5\n    # Test that new dims get appended to the beginning of lists\n    assert dims.point == [0, 2, 0, 0, 0]\n    assert dims.order == [0, 1, 2, 3, 4]\n    assert dims.axis_labels == [\'0\', \'1\', \'2\', \'3\', \'4\']\n\n    dims.set_point(2, 3)\n    dims.ndim = 3\n    # Test that dims get removed from the beginning of lists\n    assert dims.point == [3, 0, 0]\n    assert dims.order == [0, 1, 2]\n    assert dims.axis_labels == [\'2\', \'3\', \'4\']\n\n\ndef test_labels_order_when_changing_dims():\n    dims = Dims(4)\n    dims.ndim = 5\n    assert dims.axis_labels == [\'0\', \'1\', \'2\', \'3\', \'4\']\n\n\n@pytest.mark.parametrize(\n    ""ndim, ax_input, expected"", [(2, 1, 1), (2, -1, 1), (4, -3, 1)]\n)\ndef test_assert_axis_in_bounds(ndim, ax_input, expected):\n    dims = Dims(ndim)\n    actual = dims._assert_axis_in_bounds(ax_input)\n    assert actual == expected\n\n\n@pytest.mark.parametrize(""ndim, ax_input"", [(2, 2), (2, -3)])\ndef test_assert_axis_out_of_bounds(ndim, ax_input):\n    dims = Dims(ndim)\n    with pytest.raises(ValueError):\n        dims._assert_axis_in_bounds(ax_input)\n\n\ndef test_axis_labels_str_to_list():\n    dims = Dims()\n    dims.axis_labels = \'TX\'\n    assert dims.axis_labels == [\'T\', \'X\']\n'"
napari/components/_tests/test_layers_list.py,34,"b'import os\nimport numpy as np\nimport pytest\nfrom napari.components import LayerList\nfrom napari.layers import Image\n\n\ndef test_empty_layers_list():\n    """"""\n    Test instantiating an empty LayerList object\n    """"""\n    layers = LayerList()\n\n    assert len(layers) == 0\n\n\ndef test_initialize_from_list():\n    layers = LayerList(\n        [Image(np.random.random((10, 10))), Image(np.random.random((10, 10)))]\n    )\n    assert len(layers) == 2\n\n\ndef test_adding_layer():\n    """"""\n    Test adding a Layer\n    """"""\n    layers = LayerList()\n    layer = Image(np.random.random((10, 10)))\n    layers.append(layer)\n\n    # LayerList should err if you add anything other than a layer\n    with pytest.raises(TypeError):\n        layers.append(\'something\')\n\n    assert len(layers) == 1\n\n\ndef test_removing_layer():\n    """"""\n    Test removing a Layer\n    """"""\n    layers = LayerList()\n    layer = Image(np.random.random((10, 10)))\n    layers.append(layer)\n    layers.remove(layer)\n\n    assert len(layers) == 0\n\n\ndef test_indexing():\n    """"""\n    Test indexing into a LayerList\n    """"""\n    layers = LayerList()\n    layer = Image(np.random.random((10, 10)), name=\'image\')\n    layers.append(layer)\n\n    assert layers[0] == layer\n    assert layers[\'image\'] == layer\n\n\ndef test_insert():\n    """"""\n    Test inserting into a LayerList\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)), name=\'image_a\')\n    layer_b = Image(np.random.random((15, 15)), name=\'image_b\')\n    layers.append(layer_a)\n    layers.insert(0, layer_b)\n\n    assert list(layers) == [layer_b, layer_a]\n\n\ndef test_get_index():\n    """"""\n    Test getting indexing from LayerList\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)), name=\'image_a\')\n    layer_b = Image(np.random.random((15, 15)), name=\'image_b\')\n    layers.append(layer_a)\n    layers.append(layer_b)\n\n    assert layers.index(layer_a) == 0\n    assert layers.index(\'image_a\') == 0\n    assert layers.index(layer_b) == 1\n    assert layers.index(\'image_b\') == 1\n\n\ndef test_reordering():\n    """"""\n    Test indexing into a LayerList by name\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)), name=\'image_a\')\n    layer_b = Image(np.random.random((15, 15)), name=\'image_b\')\n    layer_c = Image(np.random.random((15, 15)), name=\'image_c\')\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n\n    # Rearrange layers by tuple\n    layers[:] = layers[(1, 0, 2)]\n    assert list(layers) == [layer_b, layer_a, layer_c]\n\n    # Swap layers by name\n    layers[\'image_b\', \'image_c\'] = layers[\'image_c\', \'image_b\']\n    assert list(layers) == [layer_c, layer_a, layer_b]\n\n    # Reverse layers\n    layers.reverse()\n    assert list(layers) == [layer_b, layer_a, layer_c]\n\n\ndef test_naming():\n    """"""\n    Test unique naming in LayerList\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)), name=\'img\')\n    layer_b = Image(np.random.random((15, 15)), name=\'img\')\n    layers.append(layer_a)\n    layers.append(layer_b)\n\n    assert [l.name for l in layers] == [\'img\', \'img [1]\']\n\n    layer_b.name = \'chg\'\n    assert [l.name for l in layers] == [\'img\', \'chg\']\n\n    layer_a.name = \'chg\'\n    assert [l.name for l in layers] == [\'chg [1]\', \'chg\']\n\n\ndef test_selection():\n    """"""\n    Test only last added is selected.\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)))\n    layers.append(layer_a)\n    assert layers[0].selected is True\n\n    layer_b = Image(np.random.random((15, 15)))\n    layers.append(layer_b)\n    assert [l.selected for l in layers] == [False, True]\n\n    layer_c = Image(np.random.random((15, 15)))\n    layers.append(layer_c)\n    assert [l.selected for l in layers] == [False] * 2 + [True]\n\n    for l in layers:\n        l.selected = True\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_d)\n    assert [l.selected for l in layers] == [False] * 3 + [True]\n\n\ndef test_unselect_all():\n    """"""\n    Test unselecting\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)))\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n\n    layers.unselect_all()\n    assert [l.selected for l in layers] == [False] * 3\n\n    for l in layers:\n        l.selected = True\n    layers.unselect_all(ignore=layer_b)\n    assert [l.selected for l in layers] == [False, True, False]\n\n\ndef test_remove_selected():\n    """"""\n    Test removing selected layers\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)))\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n\n    # remove last added layer as only one selected\n    layers.remove_selected()\n    assert list(layers) == [layer_a, layer_b]\n\n    # check that the next to last layer is now selected\n    assert [l.selected for l in layers] == [False, True]\n\n    layers.remove_selected()\n    assert list(layers) == [layer_a]\n    assert [l.selected for l in layers] == [True]\n\n    # select and remove first layer only\n    layers.append(layer_b)\n    layers.append(layer_c)\n    assert list(layers) == [layer_a, layer_b, layer_c]\n    layer_a.selected = True\n    layer_b.selected = False\n    layer_c.selected = False\n    layers.remove_selected()\n    assert list(layers) == [layer_b, layer_c]\n    assert [l.selected for l in layers] == [True, False]\n\n    # select and remove first and last layer of four\n    layers.append(layer_a)\n    layers.append(layer_d)\n    assert list(layers) == [layer_b, layer_c, layer_a, layer_d]\n    layer_a.selected = False\n    layer_b.selected = True\n    layer_c.selected = False\n    layer_d.selected = True\n    layers.remove_selected()\n    assert list(layers) == [layer_c, layer_a]\n    assert [l.selected for l in layers] == [True, False]\n\n    # select and remove middle two layers of four\n    layers.append(layer_b)\n    layers.append(layer_d)\n    layer_a.selected = True\n    layer_b.selected = True\n    layer_c.selected = False\n    layer_d.selected = False\n    layers.remove_selected()\n    assert list(layers) == [layer_c, layer_d]\n    assert [l.selected for l in layers] == [True, False]\n\n    # select and remove all layers\n    for l in layers:\n        l.selected = True\n    layers.remove_selected()\n    assert len(layers) == 0\n\n\ndef test_move_selected():\n    """"""\n    Test removing selected layers\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)))\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n    layers.append(layer_d)\n\n    # Check nothing moves if given same insert and origin\n    layers.unselect_all()\n    layers.move_selected(2, 2)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [False, False, True, False]\n\n    # Move middle element to front of list and back\n    layers.unselect_all()\n    layers.move_selected(2, 0)\n    assert list(layers) == [layer_c, layer_a, layer_b, layer_d]\n    assert [l.selected for l in layers] == [True, False, False, False]\n    layers.unselect_all()\n    layers.move_selected(0, 2)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [False, False, True, False]\n\n    # Move middle element to end of list and back\n    layers.unselect_all()\n    layers.move_selected(2, 3)\n    assert list(layers) == [layer_a, layer_b, layer_d, layer_c]\n    assert [l.selected for l in layers] == [False, False, False, True]\n    layers.unselect_all()\n    layers.move_selected(3, 2)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [False, False, True, False]\n\n    # Select first two layers only\n    for l, s in zip(layers, [True, True, False, False]):\n        l.selected = s\n    # Move unselected middle element to front of list even if others selected\n    layers.move_selected(2, 0)\n    assert list(layers) == [layer_c, layer_a, layer_b, layer_d]\n    # Move selected first element back to middle of list\n    layers.move_selected(0, 2)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n\n    # Select first two layers only\n    for l, s in zip(layers, [True, True, False, False]):\n        l.selected = s\n    # Check nothing moves if given same insert and origin and multiple selected\n    layers.move_selected(0, 0)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [True, True, False, False]\n\n    # Check nothing moves if given same insert and origin and multiple selected\n    layers.move_selected(1, 1)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [True, True, False, False]\n\n    # Move first two selected to middle of list\n    layers.move_selected(0, 1)\n    assert list(layers) == [layer_c, layer_a, layer_b, layer_d]\n    assert [l.selected for l in layers] == [False, True, True, False]\n\n    # Move middle selected to front of list\n    layers.move_selected(2, 0)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [True, True, False, False]\n\n    # Move first two selected to middle of list\n    layers.move_selected(1, 2)\n    assert list(layers) == [layer_c, layer_a, layer_b, layer_d]\n    assert [l.selected for l in layers] == [False, True, True, False]\n\n    # Move middle selected to front of list\n    layers.move_selected(1, 0)\n    assert list(layers) == [layer_a, layer_b, layer_c, layer_d]\n    assert [l.selected for l in layers] == [True, True, False, False]\n\n    # Select first and third layers only\n    for l, s in zip(layers, [True, False, True, False]):\n        l.selected = s\n    # Move selection together to middle\n    layers.move_selected(2, 2)\n    assert list(layers) == [layer_b, layer_a, layer_c, layer_d]\n    assert [l.selected for l in layers] == [False, True, True, False]\n    layers[:] = layers[(1, 0, 2, 3)]\n\n    # Move selection together to middle\n    layers.move_selected(0, 1)\n    assert list(layers) == [layer_b, layer_a, layer_c, layer_d]\n    assert [l.selected for l in layers] == [False, True, True, False]\n    layers[:] = layers[(1, 0, 2, 3)]\n\n    # Move selection together to end\n    layers.move_selected(2, 3)\n    assert list(layers) == [layer_b, layer_d, layer_a, layer_c]\n    assert [l.selected for l in layers] == [False, False, True, True]\n    layers[:] = layers[(2, 0, 3, 1)]\n\n    # Move selection together to end\n    layers.move_selected(0, 2)\n    assert list(layers) == [layer_b, layer_d, layer_a, layer_c]\n    assert [l.selected for l in layers] == [False, False, True, True]\n    layers[:] = layers[(2, 0, 3, 1)]\n\n    # Move selection together to end\n    layers.move_selected(0, 3)\n    assert list(layers) == [layer_b, layer_d, layer_a, layer_c]\n    assert [l.selected for l in layers] == [False, False, True, True]\n    layers[:] = layers[(2, 0, 3, 1)]\n\n    layer_e = Image(np.random.random((15, 15)))\n    layer_f = Image(np.random.random((15, 15)))\n    layers.append(layer_e)\n    layers.append(layer_f)\n    # Check current order is correct\n    assert list(layers) == [\n        layer_a,\n        layer_b,\n        layer_c,\n        layer_d,\n        layer_e,\n        layer_f,\n    ]\n    # Select second and firth layers only\n    for l, s in zip(layers, [False, True, False, False, True, False]):\n        l.selected = s\n\n    # Move selection together to middle\n    layers.move_selected(1, 2)\n    assert list(layers) == [\n        layer_a,\n        layer_c,\n        layer_b,\n        layer_e,\n        layer_d,\n        layer_f,\n    ]\n    assert [l.selected for l in layers] == [\n        False,\n        False,\n        True,\n        True,\n        False,\n        False,\n    ]\n\n\ndef test_toggle_visibility():\n    """"""\n    Test toggling layer visibility\n    """"""\n    layers = LayerList()\n    layer_a = Image(np.random.random((10, 10)))\n    layer_b = Image(np.random.random((15, 15)))\n    layer_c = Image(np.random.random((15, 15)))\n    layer_d = Image(np.random.random((15, 15)))\n    layers.append(layer_a)\n    layers.append(layer_b)\n    layers.append(layer_c)\n    layers.append(layer_d)\n\n    layers[0].visible = False\n    layers[1].visible = True\n    layers[2].visible = False\n    layers[3].visible = True\n\n    layers.select_all()\n    layers[0].selected = False\n\n    layers.toggle_selected_visibility()\n\n    assert [l.visible for l in layers] == [False, False, True, False]\n\n    layers.toggle_selected_visibility()\n\n    assert [l.visible for l in layers] == [False, True, False, True]\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_layers_save(tmpdir, layer_data_and_types):\n    """"""Test saving all layer data.""""""\n    list_of_layers, _, _, filenames = layer_data_and_types\n    layers = LayerList(list_of_layers)\n\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    # Check folder does not exist\n    assert not os.path.isdir(path)\n\n    # Write data\n    layers.save(path, plugin=\'builtins\')\n\n    # Check folder now exists\n    assert os.path.isdir(path)\n\n    # Check individual files now exist\n    for f in filenames:\n        assert os.path.isfile(os.path.join(path, f))\n\n    # Check no additional files exist\n    assert set(os.listdir(path)) == set(filenames)\n    assert set(os.listdir(tmpdir)) == set([\'layers_folder\'])\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_layers_save_none_selected(tmpdir, layer_data_and_types):\n    """"""Test saving all layer data.""""""\n    list_of_layers, _, _, filenames = layer_data_and_types\n    layers = LayerList(list_of_layers)\n    layers.unselect_all()\n\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    # Check folder does not exist\n    assert not os.path.isdir(path)\n\n    # Write data (will get a warning that nothing is selected)\n    with pytest.warns(UserWarning):\n        layers.save(path, selected=True, plugin=\'builtins\')\n\n    # Check folder still does not exist\n    assert not os.path.isdir(path)\n\n    # Check individual files still do not exist\n    for f in filenames:\n        assert not os.path.isfile(os.path.join(path, f))\n\n    # Check no additional files exist\n    assert set(os.listdir(tmpdir)) == set(\'\')\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_layers_save_seleteced(tmpdir, layer_data_and_types):\n    """"""Test saving all layer data.""""""\n    list_of_layers, _, _, filenames = layer_data_and_types\n    layers = LayerList(list_of_layers)\n    layers.unselect_all()\n    layers[0].selected = True\n    layers[2].selected = True\n\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    # Check folder does not exist\n    assert not os.path.isdir(path)\n\n    # Write data\n    layers.save(path, selected=True, plugin=\'builtins\')\n\n    # Check folder exists\n    assert os.path.isdir(path)\n\n    # Check only appropriate files exist\n    assert os.path.isfile(os.path.join(path, filenames[0]))\n    assert not os.path.isfile(os.path.join(path, filenames[1]))\n    assert os.path.isfile(os.path.join(path, filenames[2]))\n    assert not os.path.isfile(os.path.join(path, filenames[1]))\n\n    # Check no additional files exist\n    assert set(os.listdir(path)) == set([filenames[0], filenames[2]])\n    assert set(os.listdir(tmpdir)) == set([\'layers_folder\'])\n\n\n# the layers fixture is defined in napari/conftest.py\ndef test_layers_save_svg(tmpdir, layers):\n    """"""Test saving all layer data to an svg.""""""\n    path = os.path.join(tmpdir, \'layers_file.svg\')\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    layers.save(path, plugin=\'svg\')\n\n    # Check file now exists\n    assert os.path.isfile(path)\n'"
napari/components/_tests/test_multichannel.py,16,"b'import numpy as np\nimport dask.array as da\nfrom napari.components import ViewerModel\nfrom napari.utils.colormaps import colormaps, ensure_colormap_tuple\nfrom napari.utils.misc import ensure_sequence_of_iterables, ensure_iterable\nimport pytest\n\nbase_colormaps = colormaps.CYMRGB\ntwo_colormaps = colormaps.MAGENTA_GREEN\ngreen_cmap = colormaps.simple_colormaps[\'green\']\nred_cmap = colormaps.simple_colormaps[\'red\']\nfire = colormaps.AVAILABLE_COLORMAPS[\'fire\']\ncmap_tuple = (""my_colormap"", colormaps.Colormap([\'g\', \'m\', \'y\']))\ncmap_dict = {""your_colormap"": colormaps.Colormap([\'g\', \'r\', \'y\'])}\n\nMULTI_TUPLES = [[0.3, 0.7], [0.1, 0.9], [0.3, 0.9], [0.4, 0.9], [0.2, 0.9]]\n\n# data shape is (15, 10, 5) unless otherwise set\n# channel_axis = -1 is implied unless otherwise set\nmulti_channel_test_data = [\n    # basic multichannel image\n    ((), {}),\n    # single channel\n    ((15, 10, 1), {}),\n    # two channels\n    ((15, 10, 2), {}),\n    # Test adding multichannel image with color channel set.\n    ((5, 10, 15), {\'channel_axis\': 0}),\n    # split single RGB image\n    ((15, 10, 3), {\'colormap\': [\'red\', \'green\', \'blue\']}),\n    # multiple RGB images\n    ((15, 10, 5, 3), {\'channel_axis\': 2, \'rgb\': True}),\n    # Test adding multichannel image with custom names.\n    ((), {\'name\': [\'multi \' + str(i + 3) for i in range(5)]}),\n    # Test adding multichannel image with custom contrast limits.\n    ((), {\'contrast_limits\': [0.3, 0.7]}),\n    ((), {\'contrast_limits\': MULTI_TUPLES}),\n    ((), {\'gamma\': 0.5}),\n    ((), {\'gamma\': [0.3, 0.4, 0.5, 0.6, 0.7]}),\n    ((), {\'visible\': [True, False, False, True, True]}),\n    # Test adding multichannel image with custom colormaps.\n    ((), {\'colormap\': \'gray\'}),\n    ((), {\'colormap\': green_cmap}),\n    ((), {\'colormap\': cmap_tuple}),\n    ((), {\'colormap\': cmap_dict}),\n    ((), {\'colormap\': [\'gray\', \'blue\', \'red\', \'green\', \'yellow\']}),\n    ((), {\'colormap\': [green_cmap, red_cmap, fire, fire, green_cmap]}),\n    ((), {\'colormap\': [green_cmap, \'gray\', cmap_tuple, fire, cmap_dict]}),\n    ((), {\'scale\': MULTI_TUPLES}),\n    ((), {\'translate\': MULTI_TUPLES}),\n    ((), {\'blending\': \'translucent\'}),\n    ((), {\'metadata\': {\'hi\': \'there\'}}),\n    ((), {\'metadata\': {k: v for k, v in MULTI_TUPLES}}),\n]\n\nids = [\n    \'basic_multichannel\',\n    \'one_channel\',\n    \'two_channel\',\n    \'specified_multichannel\',\n    \'split_RGB\',\n    \'list_RGB\',\n    \'names\',\n    \'contrast_limits_broadcast\',\n    \'contrast_limits_list\',\n    \'gamma_broadcast\',\n    \'gamma_list\',\n    \'visibility\',\n    \'colormap_string_broadcast\',\n    \'colormap_cmap_broadcast\',\n    \'colormap_tuple_broadcast\',\n    \'colormap_dict_broadcast\',\n    \'colormap_string_list\',\n    \'colormap_cmap_list\',\n    \'colormap_variable_list\',\n    \'scale\',\n    \'translate\',\n    \'blending\',\n    \'metadata_broadcast\',\n    \'metadata_multi\',\n]\n\n\n@pytest.mark.parametrize(\'shape, kwargs\', multi_channel_test_data, ids=ids)\ndef test_multichannel(shape, kwargs):\n    """"""Test adding multichannel image.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random(shape or (15, 10, 5))\n    channel_axis = kwargs.pop(\'channel_axis\', -1)\n    viewer.add_image(data, channel_axis=channel_axis, **kwargs)\n\n    # make sure the right number of layers got added\n    n_channels = data.shape[channel_axis]\n    assert len(viewer.layers) == n_channels\n\n    for i in range(n_channels):\n        # make sure that the data has been divided into layers\n        assert np.all(viewer.layers[i].data == data.take(i, axis=channel_axis))\n        # make sure colors have been assigned properly\n        if \'colormap\' not in kwargs:\n            if n_channels == 1:\n                assert viewer.layers[i].colormap[0] == \'gray\'\n            elif n_channels == 2:\n                assert viewer.layers[i].colormap[0] == two_colormaps[i]\n            else:\n                assert viewer.layers[i].colormap[0] == base_colormaps[i]\n        if \'blending\' not in kwargs:\n            assert viewer.layers[i].blending == \'additive\'\n        for key, expectation in kwargs.items():\n            # broadcast expections\n            if key in {\'scale\', \'translate\', \'contrast_limits\', \'metadata\'}:\n                expectation = ensure_sequence_of_iterables(expectation)\n            elif key == \'colormap\' and expectation is not None:\n                if isinstance(expectation, list):\n                    exp = [ensure_colormap_tuple(c)[0] for c in expectation]\n                else:\n                    exp, _ = ensure_colormap_tuple(expectation)\n                expectation = ensure_iterable(exp)\n            else:\n                expectation = ensure_iterable(expectation)\n            expectation = [v for i, v in zip(range(i + 1), expectation)]\n\n            result = getattr(viewer.layers[i], key)\n            if key == \'colormap\':  # colormaps are tuples of (name, cmap)\n                result = result[0]\n            assert np.all(result == expectation[i])\n\n\ndef test_multichannel_multiscale():\n    """"""Test adding multichannel multiscale.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    shapes = [(40, 20, 4), (20, 10, 4), (10, 5, 4)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    viewer.add_image(data, channel_axis=-1, multiscale=True)\n    assert len(viewer.layers) == data[0].shape[-1]\n    for i in range(data[0].shape[-1]):\n        assert np.all(\n            [\n                np.all(l_d == d)\n                for l_d, d in zip(\n                    viewer.layers[i].data,\n                    [data[j].take(i, axis=-1) for j in range(len(data))],\n                )\n            ]\n        )\n        assert viewer.layers[i].colormap[0] == base_colormaps[i]\n\n\ndef test_multichannel_implicit_multiscale():\n    """"""Test adding multichannel implicit multiscale.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    shapes = [(40, 20, 4), (20, 10, 4), (10, 5, 4)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    viewer.add_image(data, channel_axis=-1)\n    assert len(viewer.layers) == data[0].shape[-1]\n    for i in range(data[0].shape[-1]):\n        assert np.all(\n            [\n                np.all(l_d == d)\n                for l_d, d in zip(\n                    viewer.layers[i].data,\n                    [data[j].take(i, axis=-1) for j in range(len(data))],\n                )\n            ]\n        )\n        assert viewer.layers[i].colormap[0] == base_colormaps[i]\n\n\ndef test_multichannel_dask_array():\n    """"""Test adding multichannel dask array.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = da.random.random((2, 10, 10, 5))\n    viewer.add_image(data, channel_axis=0)\n    assert len(viewer.layers) == data.shape[0]\n    for i in range(data.shape[0]):\n        assert viewer.layers[i].data.shape == data.shape[1:]\n        assert isinstance(viewer.layers[i].data, da.Array)\n\n\ndef test_multichannel_error_hint():\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = da.random.random((15, 10, 5))\n    with pytest.raises(TypeError) as e:\n        viewer.add_image(data, name=[\'a\', \'b\', \'c\'])\n    assert ""did you mean to specify a \'channel_axis\'"" in str(e)\n'"
napari/components/_tests/test_prune_kwargs.py,0,"b""import pytest\nfrom napari.components.add_layers_mixin import prune_kwargs\n\nTEST_KWARGS = {\n    'scale': (0.75, 1),\n    'blending': 'translucent',\n    'num_colors': 10,\n    'edge_color': 'red',\n    'z_index': 20,\n    'edge_width': 2,\n    'face_color': 'white',\n    'multiscale': False,\n    'name': 'name',\n    'extra_kwarg': 'never_included',\n}\n\nEXPECTATIONS = [\n    (\n        'image',\n        {\n            'scale': (0.75, 1),\n            'blending': 'translucent',\n            'multiscale': False,\n            'name': 'name',\n        },\n    ),\n    (\n        'labels',\n        {\n            'scale': (0.75, 1),\n            'num_colors': 10,\n            'multiscale': False,\n            'name': 'name',\n            'blending': 'translucent',\n        },\n    ),\n    (\n        'points',\n        {\n            'scale': (0.75, 1),\n            'blending': 'translucent',\n            'edge_color': 'red',\n            'edge_width': 2,\n            'face_color': 'white',\n            'name': 'name',\n        },\n    ),\n    (\n        'shapes',\n        {\n            'scale': (0.75, 1),\n            'edge_color': 'red',\n            'z_index': 20,\n            'edge_width': 2,\n            'face_color': 'white',\n            'name': 'name',\n            'blending': 'translucent',\n        },\n    ),\n    (\n        'vectors',\n        {\n            'scale': (0.75, 1),\n            'edge_color': 'red',\n            'edge_width': 2,\n            'name': 'name',\n            'blending': 'translucent',\n        },\n    ),\n    (\n        'surface',\n        {'blending': 'translucent', 'scale': (0.75, 1), 'name': 'name'},\n    ),\n]\n\nids = [i[0] for i in EXPECTATIONS]\n\n\n@pytest.mark.parametrize('label_type, expectation', EXPECTATIONS, ids=ids)\ndef test_prune_kwargs(label_type, expectation):\n    assert prune_kwargs(TEST_KWARGS, label_type) == expectation\n\n\ndef test_prune_kwargs_raises():\n    with pytest.raises(ValueError):\n        prune_kwargs({}, 'nonexistent_layer_type')\n"""
napari/components/_tests/test_viewer_image_io.py,15,"b""import numpy as np\nfrom dask import array as da\nfrom tempfile import TemporaryDirectory\nimport pytest\nfrom napari.components import ViewerModel\n\n\ntry:\n    import zarr\n\n    zarr_available = True\nexcept ImportError:\n    zarr_available = False\n\n\n# the following fixtures are defined in napari/conftest.py\n# single_png, two_pngs, irregular_images, single_tiff, rgb_png\n\n\ndef test_add_single_png_defaults(single_png):\n    image_files = single_png\n    viewer = ViewerModel()\n    viewer.open(image_files, plugin='builtins')\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 2\n    assert isinstance(viewer.layers[0].data, np.ndarray)\n    assert viewer.layers[0].data.shape == (512, 512)\n\n\ndef test_add_multi_png_defaults(two_pngs):\n    image_files = two_pngs\n    viewer = ViewerModel()\n    viewer.open(image_files, stack=True, plugin='builtins')\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert isinstance(viewer.layers[0].data, da.Array)\n    assert viewer.layers[0].data.shape == (2, 512, 512)\n\n    viewer.open(image_files, stack=False, plugin='builtins')\n    assert len(viewer.layers) == 3\n\n\ndef test_add_tiff(single_tiff):\n    image_files = single_tiff\n    viewer = ViewerModel()\n    viewer.open(image_files, plugin='builtins')\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert isinstance(viewer.layers[0].data, np.ndarray)\n    assert viewer.layers[0].data.shape == (2, 15, 10)\n    assert viewer.layers[0].data.dtype == np.uint8\n\n\ndef test_add_many_tiffs(single_tiff):\n    image_files = single_tiff * 3\n    viewer = ViewerModel()\n    viewer.open(image_files, stack=True, plugin='builtins')\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 4\n    assert isinstance(viewer.layers[0].data, da.Array)\n    assert viewer.layers[0].data.shape == (3, 2, 15, 10)\n    assert viewer.layers[0].data.dtype == np.uint8\n\n\ndef test_add_single_filename(single_tiff):\n    image_files = single_tiff[0]\n    viewer = ViewerModel()\n    viewer.open(image_files, plugin='builtins')\n    assert len(viewer.layers) == 1\n    assert viewer.dims.ndim == 3\n    assert isinstance(viewer.layers[0].data, np.ndarray)\n    assert viewer.layers[0].data.shape == (2, 15, 10)\n    assert viewer.layers[0].data.dtype == np.uint8\n\n\n@pytest.mark.skipif(not zarr_available, reason='zarr not installed')\ndef test_add_zarr():\n    viewer = ViewerModel()\n    image = np.random.random((10, 20, 20))\n    with TemporaryDirectory(suffix='.zarr') as fout:\n        z = zarr.open(fout, 'a', shape=image.shape)\n        z[:] = image\n        viewer.open([fout], plugin='builtins')\n        assert len(viewer.layers) == 1\n        # Note: due to lazy loading, the next line needs to happen within\n        # the context manager. Alternatively, we could convert to NumPy here.\n        np.testing.assert_array_equal(image, viewer.layers[0].data)\n\n\n@pytest.mark.skipif(not zarr_available, reason='zarr not installed')\ndef test_zarr_multiscale():\n    viewer = ViewerModel()\n    multiscale = [\n        np.random.random((20, 20)),\n        np.random.random((10, 10)),\n        np.random.random((5, 5)),\n    ]\n    with TemporaryDirectory(suffix='.zarr') as fout:\n        root = zarr.open_group(fout, 'a')\n        for i in range(len(multiscale)):\n            shape = 20 // 2 ** i\n            z = root.create_dataset(str(i), shape=(shape,) * 2)\n            z[:] = multiscale[i]\n        viewer.open(fout, multiscale=True, plugin='builtins')\n        assert len(viewer.layers) == 1\n        assert len(multiscale) == len(viewer.layers[0].data)\n        # Note: due to lazy loading, the next line needs to happen within\n        # the context manager. Alternatively, we could convert to NumPy here.\n        for images, images_in in zip(multiscale, viewer.layers[0].data):\n            np.testing.assert_array_equal(images, images_in)\n\n\ndef test_add_multichannel_rgb(rgb_png):\n    image_files = rgb_png\n    viewer = ViewerModel()\n    viewer.open(image_files, channel_axis=2, plugin='builtins')\n    assert len(viewer.layers) == 3\n    assert viewer.dims.ndim == 2\n    assert isinstance(viewer.layers[0].data, np.ndarray)\n    assert viewer.layers[0].data.shape == (512, 512)\n\n\ndef test_add_multichannel_tiff(single_tiff):\n    image_files = single_tiff\n    viewer = ViewerModel()\n    viewer.open(image_files, channel_axis=0, plugin='builtins')\n    assert len(viewer.layers) == 2\n    assert viewer.dims.ndim == 2\n    assert isinstance(viewer.layers[0].data, np.ndarray)\n    assert viewer.layers[0].data.shape == (15, 10)\n    assert viewer.layers[0].data.dtype == np.uint8\n"""
napari/components/_tests/test_viewer_labels_io.py,2,"b""import pytest\nimport numpy as np\nfrom skimage.data import binary_blobs\nfrom imageio import imwrite\nfrom scipy import ndimage as ndi\nfrom napari.components import ViewerModel\nfrom napari.utils.temporary_file import temporary_file\nfrom napari.layers import Labels\n\n\n@pytest.mark.parametrize('suffix', ['.png', '.tiff'])\ndef test_open_labels(suffix):\n    viewer = ViewerModel()\n    blobs = binary_blobs(length=128, volume_fraction=0.1, n_dim=2)\n    labeled = ndi.label(blobs)[0].astype(np.uint8)\n    with temporary_file(suffix) as fout:\n        imwrite(fout, labeled, format=suffix)\n        viewer.open(fout, layer_type='labels', plugin='builtins')\n        assert len(viewer.layers) == 1\n        assert np.all(labeled == viewer.layers[0].data)\n        assert isinstance(viewer.layers[0], Labels)\n"""
napari/components/_tests/test_viewer_model.py,65,"b'import numpy as np\nimport pytest\n\nfrom napari.components import ViewerModel\nfrom napari._tests.utils import good_layer_data\nfrom napari.utils.colormaps import colormaps\n\n\ndef test_viewer_model():\n    """"""Test instantiating viewer model.""""""\n    viewer = ViewerModel()\n    assert viewer.title == \'napari\'\n    assert len(viewer.layers) == 0\n    assert viewer.dims.ndim == 2\n\n    # Create viewer model with custom title\n    viewer = ViewerModel(title=\'testing\')\n    assert viewer.title == \'testing\'\n\n\ndef test_add_image():\n    """"""Test adding image.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_image_colormap_variants():\n    """"""Test adding image with all valid colormap argument types.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    # as string\n    assert viewer.add_image(data, colormap=\'green\')\n\n    # as string that is valid, but not a default colormap\n    assert viewer.add_image(data, colormap=\'cubehelix\')\n\n    # as tuple\n    cmap_tuple = (""my_colormap"", colormaps.Colormap([\'g\', \'m\', \'y\']))\n    assert viewer.add_image(data, colormap=cmap_tuple)\n\n    # as dict\n    cmap_dict = {""your_colormap"": colormaps.Colormap([\'g\', \'r\', \'y\'])}\n    assert viewer.add_image(data, colormap=cmap_dict)\n\n    # as Colormap instance\n    fire = colormaps.AVAILABLE_COLORMAPS[\'fire\']\n    assert viewer.add_image(data, colormap=fire)\n\n    # string values must be known colormap types\n    with pytest.raises(KeyError) as err:\n        viewer.add_image(data, colormap=\'nonsense\')\n\n    assert \'Colormap ""nonsense"" not found\' in str(err.value)\n\n    # lists are only valid with channel_axis\n    with pytest.raises(TypeError) as err:\n        viewer.add_image(data, colormap=[\'green\', \'red\'])\n\n    assert ""did you mean to specify a \'channel_axis\'"" in str(err.value)\n\n\ndef test_add_volume():\n    """"""Test adding volume.""""""\n    viewer = ViewerModel(ndisplay=3)\n    np.random.seed(0)\n    data = np.random.random((10, 15, 20))\n    viewer.add_image(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 3\n\n\ndef test_add_multiscale():\n    """"""Test adding image multiscale.""""""\n    viewer = ViewerModel()\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    viewer.add_image(data, multiscale=True)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_labels():\n    """"""Test adding labels image.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    viewer.add_labels(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_points():\n    """"""Test adding points.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2))\n    viewer.add_points(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_empty_points_to_empty_viewer():\n    viewer = ViewerModel()\n    pts = viewer.add_points(name=\'empty points\')\n    assert pts.dims.ndim == 2\n    pts.add([1000.0, 27.0])\n    assert pts.data.shape == (1, 2)\n\n\ndef test_add_empty_points_on_top_of_image():\n    viewer = ViewerModel()\n    image = np.random.random((8, 64, 64))\n    # add_image always returns the corresponding layer\n    _ = viewer.add_image(image)\n    pts = viewer.add_points()\n    assert pts.dims.ndim == 3\n    pts.add([5.0, 32.0, 61.0])\n    assert pts.data.shape == (1, 3)\n\n\ndef test_add_empty_shapes_layer():\n    viewer = ViewerModel()\n    image = np.random.random((8, 64, 64))\n    # add_image always returns the corresponding layer\n    _ = viewer.add_image(image)\n    shp = viewer.add_shapes()\n    assert shp.dims.ndim == 3\n\n\ndef test_add_vectors():\n    """"""Test adding vectors.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2, 2))\n    viewer.add_vectors(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_shapes():\n    """"""Test adding shapes.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 2))\n    viewer.add_shapes(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n\ndef test_add_surface():\n    """"""Test adding 3D surface.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    viewer.add_surface(data)\n    assert len(viewer.layers) == 1\n    assert np.all(\n        [np.all(vd == d) for vd, d in zip(viewer.layers[0].data, data)]\n    )\n    assert viewer.dims.ndim == 3\n\n\ndef test_mix_dims():\n    """"""Test adding images of mixed dimensionality.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 2\n\n    data = np.random.random((6, 10, 15))\n    viewer.add_image(data)\n    assert len(viewer.layers) == 2\n    assert np.all(viewer.layers[1].data == data)\n    assert viewer.dims.ndim == 3\n\n\ndef test_new_labels():\n    """"""Test adding new labels layer.""""""\n    # Add labels to empty viewer\n    viewer = ViewerModel()\n    viewer._new_labels()\n    assert len(viewer.layers) == 1\n    assert np.max(viewer.layers[0].data) == 0\n    assert viewer.dims.ndim == 2\n\n    # Add labels with image already present\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer._new_labels()\n    assert len(viewer.layers) == 2\n    assert np.max(viewer.layers[1].data) == 0\n    assert viewer.dims.ndim == 2\n\n\ndef test_new_points():\n    """"""Test adding new points layer.""""""\n    # Add labels to empty viewer\n    viewer = ViewerModel()\n    viewer.add_points()\n    assert len(viewer.layers) == 1\n    assert len(viewer.layers[0].data) == 0\n    assert viewer.dims.ndim == 2\n\n    # Add points with image already present\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer.add_points()\n    assert len(viewer.layers) == 2\n    assert len(viewer.layers[1].data) == 0\n    assert viewer.dims.ndim == 2\n\n\ndef test_new_shapes():\n    """"""Test adding new shapes layer.""""""\n    # Add labels to empty viewer\n    viewer = ViewerModel()\n    viewer.add_shapes()\n    assert len(viewer.layers) == 1\n    assert len(viewer.layers[0].data) == 0\n    assert viewer.dims.ndim == 2\n\n    # Add points with image already present\n    viewer = ViewerModel()\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n    viewer.add_shapes()\n    assert len(viewer.layers) == 2\n    assert len(viewer.layers[1].data) == 0\n    assert viewer.dims.ndim == 2\n\n\ndef test_swappable_dims():\n    """"""Test swapping dims after adding layers.""""""\n    viewer = ViewerModel()\n    np.random.seed(0)\n    image_data = np.random.random((7, 12, 10, 15))\n    image_name = viewer.add_image(image_data).name\n    assert np.all(\n        viewer.layers[image_name]._data_view == image_data[0, 0, :, :]\n    )\n\n    points_data = np.random.randint(6, size=(10, 4))\n    viewer.add_points(points_data)\n\n    vectors_data = np.random.randint(6, size=(10, 2, 4))\n    viewer.add_vectors(vectors_data)\n\n    labels_data = np.random.randint(20, size=(7, 12, 10, 15))\n    labels_name = viewer.add_labels(labels_data).name\n    assert np.all(\n        viewer.layers[labels_name]._data_raw == labels_data[0, 0, :, :]\n    )\n\n    # Swap dims\n    viewer.dims.order = [0, 2, 1, 3]\n    assert viewer.dims.order == [0, 2, 1, 3]\n    assert np.all(\n        viewer.layers[image_name]._data_view == image_data[0, :, 0, :]\n    )\n    assert np.all(\n        viewer.layers[labels_name]._data_raw == labels_data[0, :, 0, :]\n    )\n\n\ndef test_grid():\n    ""Test grid_view""\n    viewer = ViewerModel()\n\n    np.random.seed(0)\n    # Add image\n    for i in range(6):\n        data = np.random.random((10, 15))\n        viewer.add_image(data)\n    assert np.all(viewer.grid_size == (1, 1))\n    assert viewer.grid_stride == 1\n\n    # enter grid view\n    viewer.grid_view()\n    assert np.all(viewer.grid_size == (3, 3))\n    assert viewer.grid_stride == 1\n\n    # retun to stack view\n    viewer.stack_view()\n    assert np.all(viewer.grid_size == (1, 1))\n    assert viewer.grid_stride == 1\n\n    # reenter grid view\n    viewer.grid_view(n_column=2, n_row=3, stride=-2)\n    assert np.all(viewer.grid_size == (3, 2))\n    assert viewer.grid_stride == -2\n\n\ndef test_add_remove_layer_dims_change():\n    """"""Test dims change appropriately when adding and removing layers.""""""\n    np.random.seed(0)\n    viewer = ViewerModel()\n\n    # Check ndim starts at 2\n    assert viewer.dims.ndim == 2\n\n    # Check ndim increase to 3 when 3D data added\n    data = np.random.random((10, 15, 20))\n    layer = viewer.add_image(data)\n    assert len(viewer.layers) == 1\n    assert np.all(viewer.layers[0].data == data)\n    assert viewer.dims.ndim == 3\n\n    # Remove layer and check ndim returns to 2\n    viewer.layers.remove(layer)\n    assert len(viewer.layers) == 0\n    assert viewer.dims.ndim == 2\n\n\n@pytest.mark.parametrize(\'data\', good_layer_data)\ndef test_add_layer_from_data(data):\n    # make sure adding valid layer data calls the proper corresponding add_*\n    # method for all layer types\n    viewer = ViewerModel()\n    viewer._add_layer_from_data(*data)\n\n    # make sure a layer of the correct type got added\n    assert len(viewer.layers) == 1\n    expected_layer_type = data[2] if len(data) > 2 else \'image\'\n    assert viewer.layers[0]._type_string == expected_layer_type\n\n\ndef test_add_layer_from_data_raises():\n    # make sure that adding invalid data or kwargs raises the right errors\n    viewer = ViewerModel()\n    # unrecognized layer type raises Value Error\n    with pytest.raises(ValueError):\n        # \'layer\' is not a valid type\n        # (even though there is an add_layer method)\n        viewer._add_layer_from_data(\n            np.random.random((10, 10)), layer_type=\'layer\'\n        )\n\n    # even with the correct meta kwargs, the underlying add_* method may raise\n    with pytest.raises(ValueError):\n        # improper dims for rgb data\n        viewer._add_layer_from_data(\n            np.random.random((10, 10, 6)), {\'rgb\': True}\n        )\n\n    # using a kwarg in the meta dict that is invalid for the corresponding\n    # add_* method raises a TypeError\n    with pytest.raises(TypeError):\n        viewer._add_layer_from_data(\n            np.random.random((10, 2, 2)) * 20,\n            {\'rgb\': True},  # vectors do not have an \'rgb\' kwarg\n            layer_type=\'vectors\',\n        )\n'"
napari/layers/_tests/__init__.py,0,b''
napari/layers/_tests/test_dask_layers.py,4,"b'from contextlib import contextmanager\n\nimport dask\nimport dask.array as da\nimport numpy as np\nimport pytest\n\nfrom napari import layers, utils, viewer\n\ndask_version = tuple(map(int, dask.__version__.split(""."")))\n\n\ndef test_dask_array_creates_cache():\n    """"""Test that adding a dask array creates a dask cache and turns of fusion.\n    """"""\n    # by default we have no dask_cache and task fusion is active\n    original = dask.config.get(""optimization.fuse.active"", None)\n\n    def mock_set_view_slice():\n        assert dask.config.get(""optimization.fuse.active"") is False\n\n    layer = layers.Image(da.ones((100, 100)))\n    layer._set_view_slice = mock_set_view_slice\n    layer.set_view_slice()\n    # adding a dask array will turn on the cache, and turn off task fusion.\n    assert isinstance(utils.dask_cache, dask.cache.Cache)\n    assert dask.config.get(""optimization.fuse.active"", None) == original\n\n    # if the dask version is too low to remove task fusion, emit a warning\n    _dask_ver = dask.__version__\n    dask.__version__ = \'2.14.0\'\n    with pytest.warns(UserWarning) as record:\n        _ = layers.Image(da.ones((100, 100)))\n\n    assert \'upgrade Dask to v2.15.0 or later\' in record[0].message.args[0]\n    dask.__version__ = _dask_ver\n\n    # make sure we can resize the cache\n    assert utils.dask_cache.cache.total_bytes > 1000\n    utils.resize_dask_cache(1000)\n    assert utils.dask_cache.cache.total_bytes <= 1000\n\n    # This should only affect dask arrays, and not numpy data\n    def mock_set_view_slice2():\n        assert dask.config.get(""optimization.fuse.active"", None) == original\n\n    layer2 = layers.Image(np.ones((100, 100)))\n    layer2._set_view_slice = mock_set_view_slice2\n    layer2.set_view_slice()\n\n    # clean up cache\n    utils.dask_cache = None\n\n\ndef test_list_of_dask_arrays_creates_cache():\n    """"""Test that adding a list of dask array also creates a dask cache.""""""\n    original = dask.config.get(""optimization.fuse.active"", None)\n    _ = layers.Image([da.ones((100, 100)), da.ones((20, 20))])\n    assert isinstance(utils.dask_cache, dask.cache.Cache)\n    assert dask.config.get(""optimization.fuse.active"", None) == original\n\n\n@pytest.fixture\ndef delayed_dask_stack():\n    """"""A 4D (20, 10, 10, 10) delayed dask array, simulates disk io.""""""\n    # we will return a dict with a \'calls\' variable that tracks call count\n    output = {\'calls\': 0}\n\n    # create a delayed version of function that simply generates np.arrays\n    # but also counts when it has been called\n    @dask.delayed\n    def get_array():\n        nonlocal output\n        output[\'calls\'] += 1\n        return np.random.rand(10, 10, 10)\n\n    # then make a mock ""timelapse"" of 3D stacks\n    # see https://napari.org/tutorials/applications/dask.html for details\n    _list = [get_array() for fn in range(20)]\n    output[\'stack\'] = da.stack(\n        [da.from_delayed(i, shape=(10, 10, 10), dtype=np.float) for i in _list]\n    )\n    assert output[\'stack\'].shape == (20, 10, 10, 10)\n    return output\n\n\n@pytest.mark.skipif(\n    dask_version < (2, 15, 0), reason=""requires dask 2.15.0 or higher""\n)\ndef test_dask_optimized_slicing(delayed_dask_stack, monkeypatch):\n    """"""Test that dask_configure reduces compute with dask stacks.""""""\n\n    # add dask stack to the viewer, making sure to pass multiscale and clims\n    v = viewer.ViewerModel()\n    dask_stack = delayed_dask_stack[\'stack\']\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert delayed_dask_stack[\'calls\'] == 1  # the first stack will be loaded\n\n    # changing the Z plane should never incur calls\n    # since the stack has already been loaded (& it is chunked as a 3D array)\n    for i in range(3):\n        v.dims.set_point(1, i)\n        assert delayed_dask_stack[\'calls\'] == 1  # still just the first call\n\n    # changing the timepoint will, of course, incur some compute calls\n    v.dims.set_point(0, 1)\n    assert delayed_dask_stack[\'calls\'] == 2\n    v.dims.set_point(0, 2)\n    assert delayed_dask_stack[\'calls\'] == 3\n\n    # but going back to previous timepoints should not, since they are cached\n    v.dims.set_point(0, 1)\n    v.dims.set_point(0, 0)\n    assert delayed_dask_stack[\'calls\'] == 3\n    v.dims.set_point(0, 3)\n    assert delayed_dask_stack[\'calls\'] == 4\n\n\n@pytest.mark.skipif(\n    dask_version < (2, 15, 0), reason=""requires dask 2.15.0 or higher""\n)\ndef test_dask_unoptimized_slicing(delayed_dask_stack, monkeypatch):\n    """"""Prove that the dask_configure function works with a counterexample.""""""\n    # make sure we are not caching for this test, which also tests that we\n    # can turn off caching\n    utils.resize_dask_cache(0)\n    assert utils.dask_cache.cache.available_bytes == 0\n\n    # mock the dask_configure function to return a no-op.\n    def mock_dask_config(data):\n        @contextmanager\n        def dask_optimized_slicing(*args, **kwds):\n            yield {}\n\n        return dask_optimized_slicing\n\n    monkeypatch.setattr(layers.base.base, \'configure_dask\', mock_dask_config)\n\n    # add dask stack to viewer.\n    v = viewer.ViewerModel()\n    dask_stack = delayed_dask_stack[\'stack\']\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert delayed_dask_stack[\'calls\'] == 1\n\n    # without optimized dask slicing, we get a new call to the get_array func\n    # (which ""re-reads"" the full z stack) EVERY time we change the Z plane\n    # even though we\'ve already read this full timepoint.\n    for i in range(3):\n        v.dims.set_point(1, i)\n        assert delayed_dask_stack[\'calls\'] == 1 + i  # \xf0\x9f\x98\x9e\n\n    # of course we still incur calls when moving to a new timepoint...\n    v.dims.set_point(0, 1)\n    v.dims.set_point(0, 2)\n    assert delayed_dask_stack[\'calls\'] == 5\n\n    # without the cache we ALSO incur calls when returning to previously loaded\n    # timepoints \xf0\x9f\x98\xad\n    v.dims.set_point(0, 1)\n    v.dims.set_point(0, 0)\n    v.dims.set_point(0, 3)\n    # all told, we have 2x as many calls as the optimized version above.\n    assert delayed_dask_stack[\'calls\'] == 8\n\n\ndef test_dask_cache_resizing(delayed_dask_stack):\n    """"""Test that we can spin up, resize, and spin down the cache.""""""\n    # add dask stack to the viewer, making sure to pass multiscale and clims\n    utils.dask_cache = None\n\n    v = viewer.ViewerModel()\n    dask_stack = delayed_dask_stack[\'stack\']\n\n    # adding a new stack should spin up a cache\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert utils.dask_cache.cache.available_bytes > 0\n    # make sure the cache actually has been populated\n    assert len(utils.dask_cache.cache.heap.heap) > 0\n\n    # we can resize that cache back to 0 bytes\n    utils.resize_dask_cache(0)\n    assert utils.dask_cache.cache.available_bytes == 0\n\n    # adding a 2nd stack should not adjust the cache size once created\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert utils.dask_cache.cache.available_bytes == 0\n    # and the cache will remain empty regardless of what we do\n    for i in range(3):\n        v.dims.set_point(1, i)\n    assert len(utils.dask_cache.cache.heap.heap) == 0\n\n    # but we can always spin it up again\n    utils.resize_dask_cache(1e4)\n    assert utils.dask_cache.cache.available_bytes == 1e4\n    # and adding a new image doesn\'t change the size\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert utils.dask_cache.cache.available_bytes == 1e4\n    # but the cache heap is getting populated again\n    for i in range(3):\n        v.dims.set_point(0, i)\n    assert len(utils.dask_cache.cache.heap.heap) > 0\n\n    # however, if the dask_cache attribute is deleted entirely (or set to None)\n    # we will have no memory of it ever having been created.\n    # and adding a new stack will spin up a cache\n    del utils.dask_cache\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert utils.dask_cache.cache.available_bytes > 0\n\n\ndef test_prevent_dask_cache(delayed_dask_stack):\n    """"""Test that pre-emptively setting cache to zero keeps it off""""""\n    # the del is not required, it just shows that prior state of the cache\n    # does not matter... calling resize_dask_cache(0) will permanently disable\n    del utils.dask_cache\n    utils.resize_dask_cache(0)\n\n    v = viewer.ViewerModel()\n    dask_stack = delayed_dask_stack[\'stack\']\n    # adding a new stack will not increase the cache size\n    v.add_image(dask_stack, multiscale=False, contrast_limits=(0, 1))\n    assert utils.dask_cache.cache.available_bytes == 0\n    # and the cache will not be populated\n    for i in range(3):\n        v.dims.set_point(0, i)\n    assert len(utils.dask_cache.cache.heap.heap) == 0\n'"
napari/layers/_tests/test_layer_save.py,5,"b'import os\nimport numpy as np\n\n\n# the layer_writer_and_data fixture is defined in napari/conftest.py\ndef test_layer_save(tmpdir, layer_writer_and_data):\n    """"""Test saving layer data.""""""\n    writer, layer_data, extension, reader, Layer = layer_writer_and_data\n    layer = Layer(layer_data[0], **layer_data[1])\n    path = os.path.join(tmpdir, \'layer_file\' + extension)\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    assert layer.save(path, plugin=\'builtins\')\n\n    # Check file now exists\n    assert os.path.isfile(path)\n\n    # Read data\n    read_data, read_meta, layer_type = reader(path)\n\n    # Compare read data to original data on layer\n    if type(read_data) is list:\n        for rd, ld in zip(read_data, layer_data[0]):\n            np.testing.assert_allclose(rd, ld)\n    else:\n        np.testing.assert_allclose(read_data, layer_data[0])\n\n    # Instantiate layer\n    read_layer = Layer(read_data, **read_meta)\n    read_layer_data = read_layer.as_layer_data_tuple()\n\n    # Compare layer data\n    if type(read_layer_data[0]) is list:\n        for ld, rld in zip(layer_data[0], read_layer_data[0]):\n            np.testing.assert_allclose(ld, rld)\n    else:\n        np.testing.assert_allclose(layer_data[0], read_layer_data[0])\n\n    # # Compare layer metadata\n    np.testing.assert_equal(layer_data[1], read_layer_data[1])\n    # Compare layer type\n    assert layer_data[2] == read_layer_data[2]\n\n\n# the layer fixture is defined in napari/conftest.py\ndef test_layer_save_svg(tmpdir, layer):\n    """"""Test saving layer data to an svg.""""""\n    path = os.path.join(tmpdir, \'layer_file.svg\')\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    assert layer.save(path, plugin=\'svg\')\n\n    # Check file now exists\n    assert os.path.isfile(path)\n'"
napari/layers/_tests/test_serialize.py,5,"b'import numpy as np\nimport pytest\nfrom napari.utils.misc import callsignature\nfrom napari._tests.utils import layer_test_data\n\n\n@pytest.mark.parametrize(\'Layer, data, ndim\', layer_test_data)\ndef test_attrs_arrays(Layer, data, ndim):\n    """"""Test layer attributes and arrays.""""""\n    np.random.seed(0)\n    layer = Layer(data)\n    # Check layer has been correctly created\n    assert layer.ndim == ndim\n\n    properties = layer._get_state()\n\n    # Check every property is in call signature\n    signature = callsignature(Layer)\n    for prop in properties.keys():\n        assert prop in signature.parameters\n\n    # Check number of properties is same as number in signature\n    assert len(properties) == len(signature.parameters)\n\n    # Check new layer can be created\n    new_layer = Layer(**properties)\n\n    # Check that new layer matches old on all properties:\n    for prop in properties.keys():\n        # If lists check equality of all elements with np.all\n        if isinstance(getattr(layer, prop), list):\n            assert np.all(\n                [\n                    np.all(ol == nl)\n                    for ol, nl in zip(\n                        getattr(layer, prop), getattr(new_layer, prop)\n                    )\n                ]\n            )\n        else:\n            assert np.all(getattr(layer, prop) == getattr(new_layer, prop))\n'"
napari/layers/_tests/test_transform_chain.py,0,"b'import numpy.testing as npt\nfrom napari.layers.transforms import ScaleTranslate, TransformChain\n\n\ndef test_transform_chain():\n    coord = [10, 13]\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n    transform_c = transform_b.compose(transform_a)\n\n    transform_chain = TransformChain([transform_a, transform_b])\n\n    new_coord_1 = transform_c(coord)\n    new_coord_2 = transform_chain(coord)\n    npt.assert_allclose(new_coord_1, new_coord_2)\n\n\ndef test_transform_chain_simplified():\n    coord = [10, 13]\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n\n    transform_chain = TransformChain([transform_a, transform_b])\n    transform_c = transform_chain.simplified\n\n    new_coord_1 = transform_c(coord)\n    new_coord_2 = transform_chain(coord)\n    npt.assert_allclose(new_coord_1, new_coord_2)\n\n\ndef test_transform_chain_inverse():\n    coord = [10, 13]\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n\n    transform_chain = TransformChain([transform_a, transform_b])\n    transform_chain_inverse = transform_chain.inverse\n\n    new_coord = transform_chain(coord)\n    orig_coord = transform_chain_inverse(new_coord)\n    npt.assert_allclose(coord, orig_coord)\n\n\ndef test_transform_chain_slice():\n    coord = [10, 13]\n    transform_a = ScaleTranslate(scale=[2, 3, 3], translate=[8, 2, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1, 1.4], translate=[-2.2, 4, 3])\n    transform_c = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_d = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n\n    transform_chain_a = TransformChain([transform_a, transform_b])\n    transform_chain_b = TransformChain([transform_c, transform_d])\n\n    transform_chain_sliced = transform_chain_a.set_slice([0, 2])\n\n    new_coord_1 = transform_chain_sliced(coord)\n    new_coord_2 = transform_chain_b(coord)\n    npt.assert_allclose(new_coord_1, new_coord_2)\n\n\ndef test_transform_chain_expanded():\n    coord = [10, 3, 13]\n    transform_a = ScaleTranslate(scale=[2, 1, 3], translate=[8, 0, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1, 1.4], translate=[-2.2, 0, 3])\n    transform_c = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_d = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n\n    transform_chain_a = TransformChain([transform_a, transform_b])\n    transform_chain_b = TransformChain([transform_c, transform_d])\n    transform_chain_expandded = transform_chain_b.expand_dims([1])\n\n    new_coord_2 = transform_chain_a(coord)\n    new_coord_1 = transform_chain_expandded(coord)\n    npt.assert_allclose(new_coord_1, new_coord_2)\n'"
napari/layers/_tests/test_transforms.py,0,"b""import numpy.testing as npt\nfrom napari.layers.transforms import ScaleTranslate\n\n\ndef test_scale_translate():\n    coord = [10, 13]\n    transform = ScaleTranslate(scale=[2, 3], translate=[8, -5], name='st')\n    new_coord = transform(coord)\n    target_coord = [2 * 10 + 8, 3 * 13 - 5]\n    assert transform.name == 'st'\n    npt.assert_allclose(new_coord, target_coord)\n\n\ndef test_scale_translate_inverse():\n    coord = [10, 13]\n    transform = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    new_coord = transform(coord)\n    target_coord = [2 * 10 + 8, 3 * 13 - 5]\n    npt.assert_allclose(new_coord, target_coord)\n\n    inverted_new_coord = transform.inverse(new_coord)\n    npt.assert_allclose(inverted_new_coord, coord)\n\n\ndef test_scale_translate_compose():\n    coord = [10, 13]\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_b = ScaleTranslate(scale=[0.3, 1.4], translate=[-2.2, 3])\n    transform_c = transform_b.compose(transform_a)\n\n    new_coord_1 = transform_c(coord)\n    new_coord_2 = transform_b(transform_a(coord))\n    npt.assert_allclose(new_coord_1, new_coord_2)\n\n\ndef test_scale_translate_slice():\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5])\n    transform_b = ScaleTranslate(\n        scale=[2, 1, 3], translate=[8, 3, -5], name='st'\n    )\n    npt.assert_allclose(transform_b.set_slice([0, 2]).scale, transform_a.scale)\n    npt.assert_allclose(\n        transform_b.set_slice([0, 2]).translate, transform_a.translate\n    )\n    assert transform_b.set_slice([0, 2]).name == 'st'\n\n\ndef test_scale_translate_expand_dims():\n    transform_a = ScaleTranslate(scale=[2, 3], translate=[8, -5], name='st')\n    transform_b = ScaleTranslate(scale=[2, 1, 3], translate=[8, 0, -5])\n    npt.assert_allclose(transform_a.expand_dims([1]).scale, transform_b.scale)\n    npt.assert_allclose(\n        transform_a.expand_dims([1]).translate, transform_b.translate\n    )\n    assert transform_a.expand_dims([1]).name == 'st'\n\n\ndef test_scale_translate_identity_default():\n    coord = [10, 13]\n    transform = ScaleTranslate()\n    new_coord = transform(coord)\n    npt.assert_allclose(new_coord, coord)\n"""
napari/layers/_tests/test_utils.py,28,"b'import numpy as np\nimport pytest\nfrom skimage.util import img_as_ubyte\n\nfrom ..utils.layer_utils import convert_to_uint8\n\n\n@pytest.mark.parametrize(""dtype"", [np.uint8, np.uint16, np.uint32, np.uint64])\ndef test_uint(dtype):\n    data = np.arange(50, dtype=dtype)\n    data_scaled = data * 256 ** (data.dtype.itemsize - 1)\n    assert convert_to_uint8(data_scaled).dtype == np.uint8\n    assert np.all(data == convert_to_uint8(data_scaled))\n    assert np.all(img_as_ubyte(data) == convert_to_uint8(data))\n    assert np.all(img_as_ubyte(data_scaled) == convert_to_uint8(data_scaled))\n\n\n@pytest.mark.parametrize(""dtype"", [np.int8, np.int16, np.int32, np.int64])\ndef test_int(dtype):\n    data = np.arange(50, dtype=dtype)\n    data_scaled = data * 256 ** (data.dtype.itemsize - 1)\n    assert convert_to_uint8(data).dtype == np.uint8\n    assert convert_to_uint8(data_scaled).dtype == np.uint8\n    assert np.all(img_as_ubyte(data) == convert_to_uint8(data))\n    assert np.all(2 * data == convert_to_uint8(data_scaled))\n    assert np.all(img_as_ubyte(data_scaled) == convert_to_uint8(data_scaled))\n    assert np.all(img_as_ubyte(data - 10) == convert_to_uint8(data - 10))\n    assert np.all(\n        img_as_ubyte(data_scaled - 10) == convert_to_uint8(data_scaled - 10)\n    )\n\n\n@pytest.mark.parametrize(""dtype"", [np.float64, np.float32, np.float])\ndef test_float(dtype):\n    data = np.linspace(0, 0.5, 128, dtype=dtype, endpoint=False)\n    res = np.arange(128, dtype=np.uint8)\n    assert convert_to_uint8(data).dtype == np.uint8\n    assert np.all(convert_to_uint8(data) == res)\n    data = np.linspace(0, 1, 256, dtype=dtype)\n    res = np.arange(256, dtype=np.uint8)\n    assert np.all(convert_to_uint8(data) == res)\n    assert np.all(img_as_ubyte(data) == convert_to_uint8(data))\n    assert np.all(img_as_ubyte(data - 0.5) == convert_to_uint8(data - 0.5))\n\n\ndef test_bool():\n    data = np.zeros((10, 10), dtype=np.bool)\n    data[2:-2, 2:-2] = 1\n    converted = convert_to_uint8(data)\n    assert converted.dtype == np.uint8\n    assert np.all(img_as_ubyte(data) == converted)\n'"
napari/layers/base/__init__.py,0,b'from .base import Layer\n'
napari/layers/base/_base_constants.py,0,"b'from enum import auto\n\nfrom ...utils.misc import StringEnum\n\n\nclass Blending(StringEnum):\n    """"""BLENDING: Blending mode for the layer.\n\n    Selects a preset blending mode in vispy that determines how\n            RGB and alpha values get mixed.\n            Blending.OPAQUE\n                Allows for only the top layer to be visible and corresponds to\n                depth_test=True, cull_face=False, blend=False.\n            Blending.TRANSLUCENT\n                Allows for multiple layers to be blended with different opacity\n                and corresponds to depth_test=True, cull_face=False,\n                blend=True, blend_func=(\'src_alpha\', \'one_minus_src_alpha\').\n            Blending.ADDITIVE\n                Allows for multiple layers to be blended together with\n                different colors and opacity. Useful for creating overlays. It\n                corresponds to depth_test=False, cull_face=False, blend=True,\n                blend_func=(\'src_alpha\', \'one\').\n    """"""\n\n    TRANSLUCENT = auto()\n    ADDITIVE = auto()\n    OPAQUE = auto()\n'"
napari/layers/base/base.py,19,"b'import warnings\nfrom abc import ABC, abstractmethod\nfrom contextlib import contextmanager\nfrom typing import List, Optional\n\nimport numpy as np\n\nfrom ...components import Dims\nfrom ...utils.dask_utils import configure_dask\nfrom ...utils.event import EmitterGroup, Event\nfrom ...utils.key_bindings import KeymapProvider\nfrom ...utils.misc import ROOT_DIR\nfrom ...utils.naming import magic_name\nfrom ...utils.status_messages import format_float, status_format\nfrom ..transforms import ScaleTranslate, TransformChain\nfrom ..utils.layer_utils import compute_multiscale_level, convert_to_uint8\nfrom ._base_constants import Blending\n\n\nclass Layer(KeymapProvider, ABC):\n    """"""Base layer class.\n\n    Parameters\n    ----------\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    multiscale : bool\n        Whether the data is multiscale or not. Multiscale data is\n        represented by a list of data objects and should go from largest to\n        smallest.\n\n    Attributes\n    ----------\n    name : str\n        Unique name of the layer.\n    opacity : flaot\n        Opacity of the layer visual, between 0.0 and 1.0.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    blending : Blending\n        Determines how RGB and alpha values get mixed.\n            Blending.OPAQUE\n                Allows for only the top layer to be visible and corresponds to\n                depth_test=True, cull_face=False, blend=False.\n            Blending.TRANSLUCENT\n                Allows for multiple layers to be blended with different opacity\n                and corresponds to depth_test=True, cull_face=False,\n                blend=True, blend_func=(\'src_alpha\', \'one_minus_src_alpha\').\n            Blending.ADDITIVE\n                Allows for multiple layers to be blended together with\n                different colors and opacity. Useful for creating overlays. It\n                corresponds to depth_test=False, cull_face=False, blend=True,\n                blend_func=(\'src_alpha\', \'one\').\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    multiscale : bool\n        Whether the data is multiscale or not. Multiscale data is\n        represented by a list of data objects and should go from largest to\n        smallest.\n    z_index : int\n        Depth of the layer visual relative to other visuals in the scenecanvas.\n    coordinates : tuple of float\n        Coordinates of the cursor in the data space of each layer. The length\n        of the tuple is equal to the number of dimensions of the layer.\n    corner_pixels : array\n        Coordinates of the top-left and bottom-right canvas pixels in the data\n        space of each layer. The length of the tuple is equal to the number of\n        dimensions of the layer.\n    position : 2-tuple of int\n        Cursor position in the image space of only the displayed dimensions.\n    shape : tuple of int\n        Size of the data in the layer.\n    ndim : int\n        Dimensionality of the layer.\n    selected : bool\n        Flag if layer is selected in the viewer or not.\n    thumbnail : (N, M, 4) array\n        Array of thumbnail data for the layer.\n    status : str\n        Displayed in status bar bottom left.\n    help : str\n        Displayed in status bar bottom right.\n    interactive : bool\n        Determine if canvas pan/zoom interactivity is enabled.\n    cursor : str\n        String identifying which cursor displayed over canvas.\n    cursor_size : int | None\n        Size of cursor if custom. None yields default size\n    scale_factor : float\n        Conversion factor from canvas coordinates to image coordinates, which\n        depends on the current zoom level.\n\n\n    Notes\n    -----\n    Must define the following:\n        * `_get_range()`: called by `range` property\n        * `data` property (setter & getter)\n\n    May define the following:\n        * `_set_view_slice(indices)`: called to set currently viewed slice\n        * `_basename()`: base/default name of the layer\n    """"""\n\n    def __init__(\n        self,\n        data,\n        ndim,\n        *,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n        multiscale=False,\n    ):\n        super().__init__()\n\n        if name is None and data is not None:\n            name = magic_name(data, path_prefix=ROOT_DIR)\n\n        self.dask_optimized_slicing = configure_dask(data)\n        self.metadata = metadata or {}\n        self._opacity = opacity\n        self._blending = Blending(blending)\n        self._visible = visible\n        self._selected = True\n        self._freeze = False\n        self._status = \'Ready\'\n        self._help = \'\'\n        self._cursor = \'standard\'\n        self._cursor_size = None\n        self._interactive = True\n        self._value = None\n        self.scale_factor = 1\n        self.multiscale = multiscale\n\n        self.dims = Dims(ndim)\n\n        if scale is None:\n            scale = [1] * ndim\n        if translate is None:\n            translate = [0] * ndim\n\n        # Create a transform chain consisting of three transforms:\n        # 1. `tile2data`: An initial transform only needed displaying tiles\n        #   of an image. It maps pixels of the tile into the coordinate space\n        #   of the full resolution data and can usually be represented by a\n        #   scale factor and a translation. A common use case is viewing part\n        #   of lower resolution level of a multiscale image, another is using a\n        #   downsampled version of an image when the full image size is larger\n        #   than the maximum allowed texture size of your graphics card.\n        # 2. `data2world`: The main transform mapping data to a world-like\n        #   coordinate.\n        # 3. `world2grid`: An additional transform mapping world-coordinates\n        #   into a grid for looking at layers side-by-side.\n        self._transforms = TransformChain(\n            [\n                ScaleTranslate(\n                    np.ones(ndim), np.zeros(ndim), name=\'tile2data\'\n                ),\n                ScaleTranslate(scale, translate, name=\'data2world\'),\n                ScaleTranslate(\n                    np.ones(ndim), np.zeros(ndim), name=\'world2grid\'\n                ),\n            ]\n        )\n\n        self.coordinates = (0,) * ndim\n        self._position = (0,) * self.dims.ndisplay\n        self.corner_pixels = np.zeros((2, ndim), dtype=int)\n        self._editable = True\n\n        self._thumbnail_shape = (32, 32, 4)\n        self._thumbnail = np.zeros(self._thumbnail_shape, dtype=np.uint8)\n        self._update_properties = True\n        self._name = \'\'\n        self.events = EmitterGroup(\n            source=self,\n            auto_connect=True,\n            refresh=Event,\n            set_data=Event,\n            blending=Event,\n            opacity=Event,\n            visible=Event,\n            select=Event,\n            deselect=Event,\n            scale=Event,\n            translate=Event,\n            data=Event,\n            name=Event,\n            thumbnail=Event,\n            status=Event,\n            help=Event,\n            interactive=Event,\n            cursor=Event,\n            cursor_size=Event,\n            editable=Event,\n        )\n        self.name = name\n\n        self.events.data.connect(lambda e: self._set_editable())\n        self.dims.events.ndisplay.connect(lambda e: self._set_editable())\n        self.dims.events.order.connect(self.refresh)\n        self.dims.events.ndisplay.connect(self._update_dims)\n        self.dims.events.order.connect(self._update_dims)\n        self.dims.events.axis.connect(self.refresh)\n\n        self.mouse_move_callbacks = []\n        self.mouse_drag_callbacks = []\n        self._persisted_mouse_event = {}\n        self._mouse_drag_gen = {}\n\n    def __str__(self):\n        """"""Return self.name.""""""\n        return self.name\n\n    def __repr__(self):\n        cls = type(self)\n        return f""<{cls.__name__} layer {repr(self.name)} at {hex(id(self))}>""\n\n    @classmethod\n    def _basename(cls):\n        return f\'{cls.__name__}\'\n\n    @property\n    def name(self):\n        """"""str: Unique name of the layer.""""""\n        return self._name\n\n    @name.setter\n    def name(self, name):\n        if name == self.name:\n            return\n        if not name:\n            name = self._basename()\n        self._name = name\n        self.events.name()\n\n    @property\n    def opacity(self):\n        """"""float: Opacity value between 0.0 and 1.0.\n        """"""\n        return self._opacity\n\n    @opacity.setter\n    def opacity(self, opacity):\n        if not 0.0 <= opacity <= 1.0:\n            raise ValueError(\n                \'opacity must be between 0.0 and 1.0; \' f\'got {opacity}\'\n            )\n\n        self._opacity = opacity\n        self._update_thumbnail()\n        self.status = format_float(self.opacity)\n        self.events.opacity()\n\n    @property\n    def blending(self):\n        """"""Blending mode: Determines how RGB and alpha values get mixed.\n\n            Blending.OPAQUE\n                Allows for only the top layer to be visible and corresponds to\n                depth_test=True, cull_face=False, blend=False.\n            Blending.TRANSLUCENT\n                Allows for multiple layers to be blended with different opacity\n                and corresponds to depth_test=True, cull_face=False,\n                blend=True, blend_func=(\'src_alpha\', \'one_minus_src_alpha\').\n            Blending.ADDITIVE\n                Allows for multiple layers to be blended together with\n                different colors and opacity. Useful for creating overlays. It\n                corresponds to depth_test=False, cull_face=False, blend=True,\n                blend_func=(\'src_alpha\', \'one\').\n        """"""\n        return str(self._blending)\n\n    @blending.setter\n    def blending(self, blending):\n        self._blending = Blending(blending)\n        self.events.blending()\n\n    @property\n    def visible(self):\n        """"""bool: Whether the visual is currently being displayed.""""""\n        return self._visible\n\n    @visible.setter\n    def visible(self, visibility):\n        self._visible = visibility\n        self.refresh()\n        self.events.visible()\n        if self.visible:\n            self.editable = self._set_editable()\n        else:\n            self.editable = False\n\n    @property\n    def editable(self):\n        """"""bool: Whether the current layer data is editable from the viewer.""""""\n        return self._editable\n\n    @editable.setter\n    def editable(self, editable):\n        if self._editable == editable:\n            return\n        self._editable = editable\n        self._set_editable(editable=editable)\n        self.events.editable()\n\n    @property\n    def scale(self):\n        """"""list: Anisotropy factors to scale data into world coordinates.""""""\n        return self._transforms[\'data2world\'].scale\n\n    @scale.setter\n    def scale(self, scale):\n        self._transforms[\'data2world\'].scale = np.array(scale)\n        self._update_dims()\n        self.events.scale()\n\n    @property\n    def translate(self):\n        """"""list: Factors to shift the layer by in units of world coordinates.""""""\n        return self._transforms[\'data2world\'].translate\n\n    @translate.setter\n    def translate(self, translate):\n        self._transforms[\'data2world\'].translate = np.array(translate)\n        self._update_dims()\n        self.events.translate()\n\n    @property\n    def translate_grid(self):\n        """"""list: Factors to shift the layer by.""""""\n        return self._transforms[\'world2grid\'].translate\n\n    @translate_grid.setter\n    def translate_grid(self, translate_grid):\n        if np.all(self.translate_grid == translate_grid):\n            return\n        self._transforms[\'world2grid\'].translate = np.array(translate_grid)\n        self.events.translate()\n\n    @property\n    def position(self):\n        """"""tuple of int: Cursor position in image of displayed dimensions.""""""\n        return self._position\n\n    @position.setter\n    def position(self, position):\n        if self._position == position:\n            return\n        self._position = position\n        self._update_coordinates()\n\n    def _update_dims(self, event=None):\n        """"""Updates dims model, which is useful after data has been changed.""""""\n        ndim = self._get_ndim()\n        ndisplay = self.dims.ndisplay\n\n        # If the dimensionality is changing then if the number of dimensions\n        # is becoming smaller trim the property from the beginning, and if\n        # the number of dimensions is becoming larger pad from the beginning\n        if len(self.position) > ndisplay:\n            self._position = self._position[-ndisplay:]\n        elif len(self.position) < ndisplay:\n            self._position = (0,) * (ndisplay - len(self.position)) + tuple(\n                self.position\n            )\n\n        old_ndim = self.dims.ndim\n        if old_ndim > ndim:\n            keep_axes = range(old_ndim - ndim, old_ndim)\n            self._transforms = self._transforms.set_slice(keep_axes)\n        elif old_ndim < ndim:\n            new_axes = range(ndim - old_ndim)\n            self._transforms = self._transforms.expand_dims(new_axes)\n\n        self.dims.ndim = ndim\n\n        curr_range = self._get_range()\n        for i, r in enumerate(curr_range):\n            self.dims.set_range(i, r)\n\n        self.refresh()\n        self._update_coordinates()\n\n    @property\n    @abstractmethod\n    def data(self):\n        # user writes own docstring\n        raise NotImplementedError()\n\n    @data.setter\n    @abstractmethod\n    def data(self, data):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _get_extent(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _get_ndim(self):\n        raise NotImplementedError()\n\n    def _set_editable(self, editable=None):\n        if editable is None:\n            self.editable = True\n\n    def _get_range(self):\n        extent = self._get_extent()\n        return tuple(\n            (s * e[0], s * e[1], s) for e, s in zip(extent, self.scale)\n        )\n\n    def _get_base_state(self):\n        """"""Get dictionary of attributes on base layer.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of attributes on base layer.\n        """"""\n        base_dict = {\n            \'name\': self.name,\n            \'metadata\': self.metadata,\n            \'scale\': list(self.scale),\n            \'translate\': list(self.translate),\n            \'opacity\': self.opacity,\n            \'blending\': self.blending,\n            \'visible\': self.visible,\n        }\n        return base_dict\n\n    @abstractmethod\n    def _get_state(self):\n        raise NotImplementedError()\n\n    @property\n    def _type_string(self):\n        return self.__class__.__name__.lower()\n\n    def as_layer_data_tuple(self):\n        state = self._get_state()\n        state.pop(\'data\', None)\n        return self.data, state, self._type_string\n\n    @property\n    def thumbnail(self):\n        """"""array: Integer array of thumbnail for the layer""""""\n        return self._thumbnail\n\n    @thumbnail.setter\n    def thumbnail(self, thumbnail):\n        if 0 in thumbnail.shape:\n            thumbnail = np.zeros(self._thumbnail_shape, dtype=np.uint8)\n        if thumbnail.dtype != np.uint8:\n            with warnings.catch_warnings():\n                warnings.simplefilter(""ignore"")\n                thumbnail = convert_to_uint8(thumbnail)\n\n        padding_needed = np.subtract(self._thumbnail_shape, thumbnail.shape)\n        pad_amounts = [(p // 2, (p + 1) // 2) for p in padding_needed]\n        thumbnail = np.pad(thumbnail, pad_amounts, mode=\'constant\')\n\n        # blend thumbnail with opaque black background\n        background = np.zeros(self._thumbnail_shape, dtype=np.uint8)\n        background[..., 3] = 255\n\n        f_dest = thumbnail[..., 3][..., None] / 255\n        f_source = 1 - f_dest\n        thumbnail = thumbnail * f_dest + background * f_source\n\n        self._thumbnail = thumbnail.astype(np.uint8)\n        self.events.thumbnail()\n\n    @property\n    def ndim(self):\n        """"""int: Number of dimensions in the data.""""""\n        return self.dims.ndim\n\n    @property\n    def shape(self):\n        """"""tuple of int: Shape of the data.""""""\n        return tuple(\n            np.round(r[1] - r[0]).astype(int) for r in self.dims.range\n        )\n\n    @property\n    def selected(self):\n        """"""bool: Whether this layer is selected or not.""""""\n        return self._selected\n\n    @selected.setter\n    def selected(self, selected):\n        if selected == self.selected:\n            return\n        self._selected = selected\n\n        if selected:\n            self.events.select()\n        else:\n            self.events.deselect()\n\n    @property\n    def status(self):\n        """"""str: displayed in status bar bottom left.""""""\n        return self._status\n\n    @status.setter\n    def status(self, status):\n        if status == self.status:\n            return\n        self.events.status(status=status)\n        self._status = status\n\n    @property\n    def help(self):\n        """"""str: displayed in status bar bottom right.""""""\n        return self._help\n\n    @help.setter\n    def help(self, help):\n        if help == self.help:\n            return\n        self.events.help(help=help)\n        self._help = help\n\n    @property\n    def interactive(self):\n        """"""bool: Determine if canvas pan/zoom interactivity is enabled.""""""\n        return self._interactive\n\n    @interactive.setter\n    def interactive(self, interactive):\n        if interactive == self.interactive:\n            return\n        self.events.interactive(interactive=interactive)\n        self._interactive = interactive\n\n    @property\n    def cursor(self):\n        """"""str: String identifying cursor displayed over canvas.""""""\n        return self._cursor\n\n    @cursor.setter\n    def cursor(self, cursor):\n        if cursor == self.cursor:\n            return\n        self.events.cursor(cursor=cursor)\n        self._cursor = cursor\n\n    @property\n    def cursor_size(self):\n        """"""int | None: Size of cursor if custom. None yields default size.""""""\n        return self._cursor_size\n\n    @cursor_size.setter\n    def cursor_size(self, cursor_size):\n        if cursor_size == self.cursor_size:\n            return\n        self.events.cursor_size(cursor_size=cursor_size)\n        self._cursor_size = cursor_size\n\n    def set_view_slice(self):\n        with self.dask_optimized_slicing():\n            self._set_view_slice()\n\n    @abstractmethod\n    def _set_view_slice(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _update_thumbnail(self):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _get_value(self):\n        raise NotImplementedError()\n\n    def get_value(self):\n        """"""Value of data at current coordinates.\n\n        Returns\n        -------\n        value : tuple, None\n            Value of the data at the coordinates.\n        """"""\n        if self.visible:\n            return self._get_value()\n        else:\n            return None\n\n    @contextmanager\n    def block_update_properties(self):\n        self._update_properties = False\n        yield\n        self._update_properties = True\n\n    def _set_highlight(self, force=False):\n        """"""Render layer highlights when appropriate.\n\n        Parameters\n        ----------\n        force : bool\n            Bool that forces a redraw to occur when `True`.\n        """"""\n        pass\n\n    def refresh(self, event=None):\n        """"""Refresh all layer data based on current view slice.\n        """"""\n        if self.visible:\n            self.set_view_slice()\n            self.events.set_data()\n            self._update_thumbnail()\n            self._update_coordinates()\n            self._set_highlight(force=True)\n\n    def _update_coordinates(self):\n        """"""Insert the cursor position into the correct position in the\n        tuple of indices and update the cursor coordinates.\n        """"""\n        coords = list(self.dims.indices)\n        for d, p in zip(self.dims.displayed, self.position):\n            coords[d] = p\n        self.coordinates = tuple(coords)\n        self._value = self.get_value()\n        self.status = self.get_message()\n\n    def _update_multiscale(self, corner_pixels, shape_threshold):\n        """"""Refresh layer multiscale if new resolution level or tile is required.\n\n        Parameters\n        ----------\n        corner_pixels : array\n            Coordinates of the top-left and bottom-right canvas pixels in the\n            data space of each layer. The length of the tuple is equal to the\n            number of dimensions of the layer. If different from the current\n            layer corner_pixels the layer needs refreshing.\n        shape_threshold : tuple\n            Requested shape of field of view in data coordinates\n        """"""\n\n        if len(self.dims.displayed) == 3:\n            data_level = corner_pixels.shape[1] - 1\n        else:\n            # Clip corner pixels inside data shape\n            new_corner_pixels = np.clip(\n                self.corner_pixels,\n                0,\n                np.subtract(self.level_shapes[self.data_level], 1),\n            )\n\n            # Scale to full resolution of the data\n            requested_shape = (\n                new_corner_pixels[1] - new_corner_pixels[0]\n            ) * self.downsample_factors[self.data_level]\n\n            downsample_factors = self.downsample_factors[\n                :, self.dims.displayed\n            ]\n\n            data_level = compute_multiscale_level(\n                requested_shape[self.dims.displayed],\n                shape_threshold,\n                downsample_factors,\n            )\n\n        if data_level != self.data_level:\n            # Set the data level, which will trigger a layer refresh and\n            # further updates including recalculation of the corner_pixels\n            # for the new level\n            self.data_level = data_level\n            self.refresh()\n        elif not np.all(self.corner_pixels == corner_pixels):\n            self.refresh()\n\n    @property\n    def displayed_coordinates(self):\n        """"""list: List of currently displayed coordinates.""""""\n        return [self.coordinates[i] for i in self.dims.displayed]\n\n    def get_message(self):\n        """"""Generate a status message based on the coordinates and value\n\n        Returns\n        ----------\n        msg : string\n            String containing a message that can be used as a status update.\n        """"""\n        coordinates = self._transforms.simplified(self.coordinates)\n        full_coord = np.round(coordinates).astype(int)\n\n        msg = f\'{self.name} {full_coord}\'\n\n        value = self._value\n        if value is not None:\n            if isinstance(value, tuple) and value != (None, None):\n                # it\'s a multiscale -> value = (data_level, value)\n                msg += f\': {status_format(value[0])}\'\n                if value[1] is not None:\n                    msg += f\', {status_format(value[1])}\'\n            else:\n                # it\'s either a grayscale or rgb image (scalar or list)\n                msg += f\': {status_format(value)}\'\n        return msg\n\n    def save(self, path: str, plugin: Optional[str] = None) -> List[str]:\n        """"""Save this layer to ``path`` with default (or specified) plugin.\n\n        Parameters\n        ----------\n        path : str\n            A filepath, directory, or URL to open.  Extensions may be used to\n            specify output format (provided a plugin is avaiable for the\n            requested format).\n        plugin : str, optional\n            Name of the plugin to use for saving. If ``None`` then all plugins\n            corresponding to appropriate hook specification will be looped\n            through to find the first one that can save the data.\n\n        Returns\n        -------\n        list of str\n            File paths of any files that were written.\n        """"""\n        from ...plugins.io import save_layers\n\n        return save_layers(path, [self], plugin=plugin)\n'"
napari/layers/image/__init__.py,0,b'from .image import Image\n'
napari/layers/image/_image_constants.py,0,"b'from enum import auto\nfrom ...utils.misc import StringEnum\n\n\nclass Interpolation(StringEnum):\n    """"""INTERPOLATION: Vispy interpolation mode.\n\n    The spatial filters used for interpolation are from vispy\'s\n    spatial filters. The filters are built in the file below:\n\n    https://github.com/vispy/vispy/blob/master/vispy/glsl/build-spatial-filters.py\n    """"""\n\n    BESSEL = auto()\n    BICUBIC = auto()\n    BILINEAR = auto()\n    BLACKMAN = auto()\n    CATROM = auto()\n    GAUSSIAN = auto()\n    HAMMING = auto()\n    HANNING = auto()\n    HERMITE = auto()\n    KAISER = auto()\n    LANCZOS = auto()\n    MITCHELL = auto()\n    NEAREST = auto()\n    SPLINE16 = auto()\n    SPLINE36 = auto()\n\n\nclass Interpolation3D(StringEnum):\n    """"""INTERPOLATION: Vispy interpolation mode for volume rendering.""""""\n\n    LINEAR = auto()\n    NEAREST = auto()\n\n\nclass Rendering(StringEnum):\n    """"""Rendering: Rendering mode for the layer.\n\n    Selects a preset rendering mode in vispy\n            * translucent: voxel colors are blended along the view ray until\n              the result is opaque.\n            * mip: maxiumum intensity projection. Cast a ray and display the\n              maximum value that was encountered.\n            * attenuated_mip: attenuated maxiumum intensity projection. Cast a\n              ray and attenuate values based on integral of encountered values,\n              display the maximum value that was encountered after attenuation.\n              This will make nearer objects appear more prominent.\n            * additive: voxel colors are added along the view ray until\n              the result is saturated.\n            * iso: isosurface. Cast a ray until a certain threshold is\n              encountered. At that location, lighning calculations are\n              performed to give the visual appearance of a surface.\n    """"""\n\n    TRANSLUCENT = auto()\n    ADDITIVE = auto()\n    ISO = auto()\n    MIP = auto()\n    ATTENUATED_MIP = auto()\n'"
napari/layers/image/_image_utils.py,7,"b'import numpy as np\n\n\ndef guess_rgb(shape):\n    """"""Guess if the passed shape comes from rgb data.\n\n    If last dim is 3 or 4 assume the data is rgb, including rgba.\n\n    Parameters\n    ----------\n    shape : list of int\n        Shape of the data that should be checked.\n\n    Returns\n    -------\n    bool\n        If data is rgb or not.\n    """"""\n    ndim = len(shape)\n    last_dim = shape[-1]\n\n    return ndim > 2 and last_dim < 5\n\n\ndef guess_multiscale(data):\n    """"""Guess whether the passed data is multiscale, process it accordingly.\n\n    If shape of arrays along first axis is strictly decreasing, the data is\n    multiscale. If it is the same shape everywhere, it is not. Various\n    ambiguous conditions in between will result in a ValueError being raised,\n    or in an ""unwrapping"" of data, if data contains only one element.\n\n    Parameters\n    ----------\n    data : array or list of array\n        Data that should be checked.\n\n    Returns\n    -------\n    multiscale : bool\n        True if the data is thought to be multiscale, False otherwise.\n    data : list or array\n        The input data, perhaps with the leading axis removed.\n    """"""\n    # If the data has ndim and is not one-dimensional then cannot be multiscale\n    # If data is a zarr array, this check ensure that subsets of it are not\n    # instantiated. (`for d in data` instantiates `d` as a NumPy array if\n    # `data` is a zarr array.)\n    if hasattr(data, \'ndim\') and data.ndim > 1:\n        return False, data\n\n    shapes = [d.shape for d in data]\n    sizes = np.array([np.prod(shape, dtype=np.uint64) for shape in shapes])\n    if len(sizes) == 1 and (isinstance(data, list) or isinstance(data, tuple)):\n        # pyramid with only one level, unwrap\n        return False, data[0]\n    if len(sizes) > 1:\n        consistent = bool(np.all(sizes[:-1] > sizes[1:]))\n        flat = bool(np.all(sizes == sizes[0]))\n        if flat:\n            # note: the individual array case should be caught by the first\n            # code line in this function, hasattr(ndim) and ndim > 1.\n            raise ValueError(\n                \'Input data should be an array-like object, or a sequence of \'\n                \'arrays of decreasing size. Got arrays of single shape: \'\n                f\'{shapes[0]}\'\n            )\n        if not consistent:\n            raise ValueError(\n                \'Input data should be an array-like object, or a sequence of \'\n                \'arrays of decreasing size. Got arrays in incorrect order, \'\n                f\'shapes: {shapes}\'\n            )\n        return True, data\n    else:\n        return False, data\n\n\ndef guess_labels(data):\n    """"""Guess if array contains labels data.""""""\n\n    if hasattr(data, \'dtype\') and data.dtype in (\n        np.int32,\n        np.uint32,\n        np.int64,\n        np.uint64,\n    ):\n        return \'labels\'\n\n    return \'image\'\n'"
napari/layers/image/image.py,40,"b'import types\nimport warnings\nimport numpy as np\nfrom scipy import ndimage as ndi\n\nfrom ...utils.colormaps import AVAILABLE_COLORMAPS\nfrom ...utils.event import Event\nfrom ...utils.status_messages import format_float\nfrom ..base import Layer\nfrom ..utils.layer_utils import calc_data_range\nfrom ..intensity_mixin import IntensityVisualizationMixin\nfrom ._image_constants import Interpolation, Interpolation3D, Rendering\nfrom ._image_utils import guess_rgb, guess_multiscale\n\n\n# Mixin must come before Layer\nclass Image(IntensityVisualizationMixin, Layer):\n    """"""Image layer.\n\n    Parameters\n    ----------\n    data : array or list of array\n        Image data. Can be N dimensional. If the last dimension has length\n        3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a\n        list and arrays are decreasing in shape then the data is treated as\n        a multiscale image.\n    rgb : bool\n        Whether the image is rgb RGB or RGBA. If not specified by user and\n        the last dimension of the data has length 3 or 4 it will be set as\n        `True`. If `False` the image is interpreted as a luminance image.\n    colormap : str, vispy.Color.Colormap, tuple, dict\n        Colormap to use for luminance images. If a string must be the name\n        of a supported colormap from vispy or matplotlib. If a tuple the\n        first value must be a string to assign as a name to a colormap and\n        the second item must be a Colormap. If a dict the key must be a\n        string to assign as a name to a colormap and the value must be a\n        Colormap.\n    contrast_limits : list (2,)\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If not passed is calculated as the min and max of\n        the image.\n    gamma : float\n        Gamma correction for determining colormap linearity. Defaults to 1.\n    interpolation : str\n        Interpolation mode used by vispy. Must be one of our supported\n        modes.\n    rendering : str\n        Rendering mode used by vispy. Must be one of our supported\n        modes.\n    iso_threshold : float\n        Threshold for isosurface.\n    attenuation : float\n        Attenuation rate for attenuated maximum intensity projection.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. If not specified by\n        the user and if the data is a list of arrays that decrease in shape\n        then it will be taken to be multiscale. The first image in the list\n        should be the largest.\n\n    Attributes\n    ----------\n    data : array or list of array\n        Image data. Can be N dimensional. If the last dimension has length\n        3 or 4 can be interpreted as RGB or RGBA if rgb is `True`. If a list\n        and arrays are decreaing in shape then the data is treated as a\n        multiscale image.\n    metadata : dict\n        Image metadata.\n    rgb : bool\n        Whether the image is rgb RGB or RGBA if rgb. If not\n        specified by user and the last dimension of the data has length 3 or 4\n        it will be set as `True`. If `False` the image is interpreted as a\n        luminance image.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. The first image in the\n        list should be the largest.\n    colormap : 2-tuple of str, vispy.color.Colormap\n        The first is the name of the current colormap, and the second value is\n        the colormap. Colormaps are used for luminance images, if the image is\n        rgb the colormap is ignored.\n    colormaps : tuple of str\n        Names of the available colormaps.\n    contrast_limits : list (2,) of float\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If the image is rgb the contrast_limits is ignored.\n    contrast_limits_range : list (2,) of float\n        Range for the color limits for luminace images. If the image is\n        rgb the contrast_limits_range is ignored.\n    gamma : float\n        Gamma correction for determining colormap linearity.\n    interpolation : str\n        Interpolation mode used by vispy. Must be one of our supported\n        modes.\n    rendering : str\n        Rendering mode used by vispy. Must be one of our supported\n        modes.\n    iso_threshold : float\n        Threshold for isosurface.\n    attenuation : float\n        Attenuation rate for attenuated maximum intensity projection.\n\n    Extended Summary\n    ----------\n    _data_view : array (N, M), (N, M, 3), or (N, M, 4)\n        Image data for the currently viewed slice. Must be 2D image data, but\n        can be multidimensional for RGB or RGBA images if multidimensional is\n        `True`.\n    _colorbar : array\n        Colorbar for current colormap.\n    """"""\n\n    _colormaps = AVAILABLE_COLORMAPS\n\n    def __init__(\n        self,\n        data,\n        *,\n        rgb=None,\n        colormap=\'gray\',\n        contrast_limits=None,\n        gamma=1,\n        interpolation=\'nearest\',\n        rendering=\'mip\',\n        iso_threshold=0.5,\n        attenuation=0.5,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n        multiscale=None,\n    ):\n        if isinstance(data, types.GeneratorType):\n            data = list(data)\n\n        # Determine if data is a multiscale\n        if multiscale is None:\n            multiscale, data = guess_multiscale(data)\n\n        # Determine initial shape\n        if multiscale:\n            init_shape = data[0].shape\n        else:\n            init_shape = data.shape\n\n        # Determine if rgb\n        if rgb is None:\n            rgb = guess_rgb(init_shape)\n\n        # Determine dimensionality of the data\n        if rgb:\n            ndim = len(init_shape) - 1\n        else:\n            ndim = len(init_shape)\n\n        super().__init__(\n            data,\n            ndim,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n            multiscale=multiscale,\n        )\n\n        self.events.add(\n            interpolation=Event,\n            rendering=Event,\n            iso_threshold=Event,\n            attenuation=Event,\n        )\n\n        # Set data\n        self.rgb = rgb\n        self._data = data\n        if self.multiscale:\n            self._data_level = len(self.data) - 1\n            # Determine which level of the multiscale to use for the thumbnail.\n            # Pick the smallest level with at least one axis >= 64. This is\n            # done to prevent the thumbnail from being from one of the very\n            # low resolution layers and therefore being very blurred.\n            big_enough_levels = [\n                np.any(np.greater_equal(p.shape, 64)) for p in data\n            ]\n            if np.any(big_enough_levels):\n                self._thumbnail_level = np.where(big_enough_levels)[0][-1]\n            else:\n                self._thumbnail_level = 0\n        else:\n            self._data_level = 0\n            self._thumbnail_level = 0\n        self.corner_pixels[1] = self.level_shapes[self._data_level]\n\n        # Intitialize image views and thumbnails with zeros\n        if self.rgb:\n            self._data_view = np.zeros(\n                (1,) * self.dims.ndisplay + (self.shape[-1],)\n            )\n        else:\n            self._data_view = np.zeros((1,) * self.dims.ndisplay)\n        self._data_raw = self._data_view\n        self._data_thumbnail = self._data_view\n\n        # Set contrast_limits and colormaps\n        self._gamma = gamma\n        self._iso_threshold = iso_threshold\n        self._attenuation = attenuation\n        if contrast_limits is None:\n            self.contrast_limits_range = self._calc_data_range()\n        else:\n            self.contrast_limits_range = contrast_limits\n        self._contrast_limits = tuple(self.contrast_limits_range)\n        self.colormap = colormap\n        self.contrast_limits = self._contrast_limits\n        self._interpolation = {\n            2: Interpolation.NEAREST,\n            3: (\n                Interpolation3D.NEAREST\n                if self.__class__.__name__ == \'Labels\'\n                else Interpolation3D.LINEAR\n            ),\n        }\n        self.interpolation = interpolation\n        self.rendering = rendering\n\n        # Trigger generation of view slice and thumbnail\n        self._update_dims()\n\n    def _calc_data_range(self):\n        if self.multiscale:\n            input_data = self.data[-1]\n        else:\n            input_data = self.data\n        return calc_data_range(input_data)\n\n    @property\n    def dtype(self):\n        return self.data[0].dtype if self.multiscale else self.data.dtype\n\n    @property\n    def data(self):\n        """"""array: Image data.""""""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        self._data = data\n        self._update_dims()\n        self.events.data()\n\n    def _get_ndim(self):\n        """"""Determine number of dimensions of the layer.""""""\n        return len(self.level_shapes[0])\n\n    def _get_extent(self):\n        return tuple((0, m) for m in self.level_shapes[0])\n\n    @property\n    def data_level(self):\n        """"""int: Current level of multiscale, or 0 if image.""""""\n        return self._data_level\n\n    @data_level.setter\n    def data_level(self, level):\n        if self._data_level == level:\n            return\n        self._data_level = level\n        self.refresh()\n\n    @property\n    def level_shapes(self):\n        """"""array: Shapes of each level of the multiscale or just of image.""""""\n        if self.multiscale:\n            if self.rgb:\n                shapes = [im.shape[:-1] for im in self.data]\n            else:\n                shapes = [im.shape for im in self.data]\n        else:\n            if self.rgb:\n                shapes = [self.data.shape[:-1]]\n            else:\n                shapes = [self.data.shape]\n        return np.array(shapes)\n\n    @property\n    def downsample_factors(self):\n        """"""list: Downsample factors for each level of the multiscale.""""""\n        return np.divide(self.level_shapes[0], self.level_shapes)\n\n    @property\n    def iso_threshold(self):\n        """"""float: threshold for isosurface.""""""\n        return self._iso_threshold\n\n    @iso_threshold.setter\n    def iso_threshold(self, value):\n        self.status = format_float(value)\n        self._iso_threshold = value\n        self._update_thumbnail()\n        self.events.iso_threshold()\n\n    @property\n    def attenuation(self):\n        """"""float: attenuation rate for attenuated_mip rendering.""""""\n        return self._attenuation\n\n    @attenuation.setter\n    def attenuation(self, value):\n        self.status = format_float(value)\n        self._attenuation = value\n        self._update_thumbnail()\n        self.events.attenuation()\n\n    @property\n    def interpolation(self):\n        """"""Return current interpolation mode.\n\n        Selects a preset interpolation mode in vispy that determines how volume\n        is displayed.  Makes use of the two Texture2D interpolation methods and\n        the available interpolation methods defined in\n        vispy/gloo/glsl/misc/spatial_filters.frag\n\n        Options include:\n        \'bessel\', \'bicubic\', \'bilinear\', \'blackman\', \'catrom\', \'gaussian\',\n        \'hamming\', \'hanning\', \'hermite\', \'kaiser\', \'lanczos\', \'mitchell\',\n        \'nearest\', \'spline16\', \'spline36\'\n\n        Returns\n        -------\n        str\n            The current interpolation mode\n        """"""\n        return str(self._interpolation[self.dims.ndisplay])\n\n    @interpolation.setter\n    def interpolation(self, interpolation):\n        """"""Set current interpolation mode.""""""\n        if self.dims.ndisplay == 3:\n            self._interpolation[self.dims.ndisplay] = Interpolation3D(\n                interpolation\n            )\n        else:\n            self._interpolation[self.dims.ndisplay] = Interpolation(\n                interpolation\n            )\n        self.events.interpolation()\n\n    @property\n    def rendering(self):\n        """"""Return current rendering mode.\n\n        Selects a preset rendering mode in vispy that determines how\n        volume is displayed.  Options include:\n\n        * ``translucent``: voxel colors are blended along the view ray until\n          the result is opaque.\n        * ``mip``: maxiumum intensity projection. Cast a ray and display the\n          maximum value that was encountered.\n        * ``additive``: voxel colors are added along the view ray until the\n          result is saturated.\n        * ``iso``: isosurface. Cast a ray until a certain threshold is\n          encountered. At that location, lighning calculations are performed to\n          give the visual appearance of a surface.\n        * ``attenuated_mip``: attenuated maxiumum intensity projection. Cast a\n          ray and attenuate values based on integral of encountered values,\n          display the maximum value that was encountered after attenuation.\n          This will make nearer objects appear more prominent.\n\n        Returns\n        -------\n        str\n            The current rendering mode\n        """"""\n        return str(self._rendering)\n\n    @rendering.setter\n    def rendering(self, rendering):\n        """"""Set current rendering mode.""""""\n        self._rendering = Rendering(rendering)\n        self.events.rendering()\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'rgb\': self.rgb,\n                \'multiscale\': self.multiscale,\n                \'colormap\': self.colormap[0],\n                \'contrast_limits\': self.contrast_limits,\n                \'interpolation\': self.interpolation,\n                \'rendering\': self.rendering,\n                \'iso_threshold\': self.iso_threshold,\n                \'attenuation\': self.attenuation,\n                \'gamma\': self.gamma,\n                \'data\': self.data,\n            }\n        )\n        return state\n\n    def _raw_to_displayed(self, raw):\n        """"""Determine displayed image from raw image.\n\n        For normal image layers, just return the actual image.\n\n        Parameters\n        -------\n        raw : array\n            Raw array.\n\n        Returns\n        -------\n        image : array\n            Displayed array.\n        """"""\n        image = raw\n        return image\n\n    def _set_view_slice(self):\n        """"""Set the view given the indices to slice with.""""""\n        not_disp = self.dims.not_displayed\n\n        if self.rgb:\n            # if rgb need to keep the final axis fixed during the\n            # transpose. The index of the final axis depends on how many\n            # axes are displayed.\n            order = self.dims.displayed_order + (\n                max(self.dims.displayed_order) + 1,\n            )\n        else:\n            order = self.dims.displayed_order\n\n        if self.multiscale:\n            # If 3d redering just show lowest level of multiscale\n            if self.dims.ndisplay == 3:\n                self.data_level = len(self.data) - 1\n\n            # Slice currently viewed level\n            level = self.data_level\n            indices = np.array(self.dims.indices)\n            downsampled_indices = (\n                indices[not_disp] / self.downsample_factors[level, not_disp]\n            )\n            downsampled_indices = np.round(\n                downsampled_indices.astype(float)\n            ).astype(int)\n            downsampled_indices = np.clip(\n                downsampled_indices, 0, self.level_shapes[level, not_disp] - 1\n            )\n            indices[not_disp] = downsampled_indices\n\n            scale = np.ones(self.ndim)\n            for d in self.dims.displayed:\n                scale[d] = self.downsample_factors[self.data_level][d]\n            self._transforms[\'tile2data\'].scale = scale\n\n            if self.dims.ndisplay == 2:\n                corner_pixels = np.clip(\n                    self.corner_pixels,\n                    0,\n                    np.subtract(self.level_shapes[self.data_level], 1),\n                )\n\n                for d in self.dims.displayed:\n                    indices[d] = slice(\n                        corner_pixels[0, d], corner_pixels[1, d] + 1, 1\n                    )\n                self._transforms[\'tile2data\'].translate = (\n                    corner_pixels[0]\n                    * self._transforms[\'data2world\'].scale\n                    * self._transforms[\'tile2data\'].scale\n                )\n\n            image = np.transpose(\n                np.asarray(self.data[level][tuple(indices)]), order\n            )\n\n            # Slice thumbnail\n            indices = np.array(self.dims.indices)\n            downsampled_indices = (\n                indices[not_disp]\n                / self.downsample_factors[self._thumbnail_level, not_disp]\n            )\n            downsampled_indices = np.round(\n                downsampled_indices.astype(float)\n            ).astype(int)\n            downsampled_indices = np.clip(\n                downsampled_indices,\n                0,\n                self.level_shapes[self._thumbnail_level, not_disp] - 1,\n            )\n            indices[not_disp] = downsampled_indices\n            thumbnail_source = np.asarray(\n                self.data[self._thumbnail_level][tuple(indices)]\n            ).transpose(order)\n        else:\n            self._transforms[\'tile2data\'].scale = np.ones(self.dims.ndim)\n            image = np.asarray(self.data[self.dims.indices]).transpose(order)\n            thumbnail_source = image\n\n        if self.rgb and image.dtype.kind == \'f\':\n            self._data_raw = np.clip(image, 0, 1)\n            self._data_view = self._raw_to_displayed(self._data_raw)\n            self._data_thumbnail = self._raw_to_displayed(\n                np.clip(thumbnail_source, 0, 1)\n            )\n\n        else:\n            self._data_raw = image\n            self._data_view = self._raw_to_displayed(self._data_raw)\n            self._data_thumbnail = self._raw_to_displayed(thumbnail_source)\n\n        if self.multiscale:\n            self.events.scale()\n            self.events.translate()\n\n    def _update_thumbnail(self):\n        """"""Update thumbnail with current image data and colormap.""""""\n        if self.dims.ndisplay == 3 and self.dims.ndim > 2:\n            image = np.max(self._data_thumbnail, axis=0)\n        else:\n            image = self._data_thumbnail\n\n        # float16 not supported by ndi.zoom\n        dtype = np.dtype(image.dtype)\n        if dtype in [np.dtype(np.float16)]:\n            image = image.astype(np.float32)\n\n        raw_zoom_factor = np.divide(\n            self._thumbnail_shape[:2], image.shape[:2]\n        ).min()\n        new_shape = np.clip(\n            raw_zoom_factor * np.array(image.shape[:2]),\n            1,  # smallest side should be 1 pixel wide\n            self._thumbnail_shape[:2],\n        )\n        zoom_factor = tuple(new_shape / image.shape[:2])\n        if self.rgb:\n            # warning filter can be removed with scipy 1.4\n            with warnings.catch_warnings():\n                warnings.simplefilter(""ignore"")\n                downsampled = ndi.zoom(\n                    image, zoom_factor + (1,), prefilter=False, order=0\n                )\n            if image.shape[2] == 4:  # image is RGBA\n                colormapped = np.copy(downsampled)\n                colormapped[..., 3] = downsampled[..., 3] * self.opacity\n                if downsampled.dtype == np.uint8:\n                    colormapped = colormapped.astype(np.uint8)\n            else:  # image is RGB\n                if downsampled.dtype == np.uint8:\n                    alpha = np.full(\n                        downsampled.shape[:2] + (1,),\n                        int(255 * self.opacity),\n                        dtype=np.uint8,\n                    )\n                else:\n                    alpha = np.full(downsampled.shape[:2] + (1,), self.opacity)\n                colormapped = np.concatenate([downsampled, alpha], axis=2)\n        else:\n            # warning filter can be removed with scipy 1.4\n            with warnings.catch_warnings():\n                warnings.simplefilter(""ignore"")\n                downsampled = ndi.zoom(\n                    image, zoom_factor, prefilter=False, order=0\n                )\n            low, high = self.contrast_limits\n            downsampled = np.clip(downsampled, low, high)\n            color_range = high - low\n            if color_range != 0:\n                downsampled = (downsampled - low) / color_range\n            downsampled = downsampled ** self.gamma\n            color_array = self.colormap[1][downsampled.ravel()]\n            colormapped = color_array.rgba.reshape(downsampled.shape + (4,))\n            colormapped[..., 3] *= self.opacity\n        self.thumbnail = colormapped\n\n    def _get_value(self):\n        """"""Returns coordinates, values, and a string for a given mouse position\n        and set of indices.\n\n        Returns\n        ----------\n        value : tuple\n            Value of the data at the coord.\n        """"""\n        coord = np.round(self.coordinates).astype(int)\n        if self.rgb:\n            shape = self._data_raw.shape[:-1]\n        else:\n            shape = self._data_raw.shape\n\n        if all(0 <= c < s for c, s in zip(coord[self.dims.displayed], shape)):\n            value = self._data_raw[tuple(coord[self.dims.displayed])]\n        else:\n            value = None\n\n        if self.multiscale:\n            value = (self.data_level, value)\n\n        return value\n'"
napari/layers/labels/__init__.py,0,"b'from .labels import Labels\nfrom . import _labels_key_bindings\n\n# Note that importing _labels_key_bindings is needed as the Labels layer gets\n# decorated with keybindings during that process, but it is not directly needed\n# by our users and so is deleted below\ndel _labels_key_bindings\n'"
napari/layers/labels/_labels_constants.py,0,"b'from enum import auto\nimport sys\n\nfrom ...utils.misc import StringEnum\n\n\nclass Mode(StringEnum):\n    """"""MODE: Interactive mode. The normal, default mode is PAN_ZOOM, which\n    allows for normal interactivity with the canvas.\n\n    In PICK mode the cursor functions like a color picker, setting the\n    clicked on label to be the curent label. If the background is picked it\n    will select the background label `0`.\n\n    In PAINT mode the cursor functions like a paint brush changing any pixels\n    it brushes over to the current label. If the background label `0` is\n    selected than any pixels will be changed to background and this tool\n    functions like an eraser. The size and shape of the cursor can be adjusted\n    in the properties widget.\n\n    In FILL mode the cursor functions like a fill bucket replacing pixels\n    of the label clicked on with the current label. It can either replace all\n    pixels of that label or just those that are contiguous with the clicked on\n    pixel. If the background label `0` is selected than any pixels will be\n    changed to background and this tool functions like an eraser.\n\n    In ERASE mode the cursor functions similarly to PAINT mode, but to paint\n    with background label, which effectively removes the label.\n    """"""\n\n    PAN_ZOOM = auto()\n    PICK = auto()\n    PAINT = auto()\n    FILL = auto()\n    ERASE = auto()\n\n\nBACKSPACE = \'delete\' if sys.platform == \'darwin\' else \'backspace\'\n'"
napari/layers/labels/_labels_key_bindings.py,0,"b'from .labels import Labels\nfrom ._labels_constants import Mode\n\n\n@Labels.bind_key(\'Space\')\ndef hold_to_pan_zoom(layer):\n    """"""Hold to pan and zoom in the viewer.""""""\n    if layer._mode != Mode.PAN_ZOOM:\n        # on key press\n        prev_mode = layer.mode\n        layer.mode = Mode.PAN_ZOOM\n\n        yield\n\n        # on key release\n        layer.mode = prev_mode\n\n\n@Labels.bind_key(\'P\')\ndef activate_paint_mode(layer):\n    """"""Activate the paintbrush.""""""\n    layer.mode = Mode.PAINT\n\n\n@Labels.bind_key(\'F\')\ndef activate_fill_mode(layer):\n    """"""Activate the fill bucket.""""""\n    layer.mode = Mode.FILL\n\n\n@Labels.bind_key(\'Z\')\ndef activate_pan_zoom_mode(layer):\n    """"""Activate pan and zoom mode.""""""\n    layer.mode = Mode.PAN_ZOOM\n\n\n@Labels.bind_key(\'L\')\ndef activate_picker_mode(layer):\n    """"""Activate the label picker.""""""\n    layer.mode = Mode.PICK\n\n\n@Labels.bind_key(\'E\')\ndef erase(layer):\n    """"""Activate the label eraser.""""""\n    layer.mode = Mode.ERASE\n\n\n@Labels.bind_key(\'M\')\ndef new_label(layer):\n    """"""Set the currently selected label to the largest used label plus one.""""""\n    layer.selected_label = layer.data.max() + 1\n\n\n@Labels.bind_key(\'D\')\ndef decrease_label_id(layer):\n    """"""Decrease the currently selected label by one.""""""\n    layer.selected_label -= 1\n\n\n@Labels.bind_key(\'I\')\ndef increase_label_id(layer):\n    """"""Increase the currently selected label by one.""""""\n    layer.selected_label += 1\n\n\n@Labels.bind_key(\'Control-Z\')\ndef undo(layer):\n    """"""Undo the last paint or fill action since the view slice has changed.""""""\n    layer.undo()\n\n\n@Labels.bind_key(\'Control-Shift-Z\')\ndef redo(layer):\n    """"""Redo any previously undone actions.""""""\n    layer.redo()\n\n\n@Labels.bind_key(\'Shift\')\ndef preserve_labels(layer):\n    """"""Toggle preserve label option when pressed.""""""\n    # on key press\n    layer.preserve_labels = not layer.preserve_labels\n\n    yield\n\n    # on key release\n    layer.preserve_labels = not layer.preserve_labels\n\n\n@Labels.bind_key(\'Control\')\ndef switch_fill(layer):\n    """"""Switch to fill mode temporarily when pressed.""""""\n    previous_mode = layer.mode\n\n    # on key press\n    layer.mode = Mode.FILL\n\n    yield\n\n    # on key release\n    layer.mode = previous_mode\n\n\n@Labels.bind_key(\'Alt\')\ndef switch_erase(layer):\n    """"""Switch to erase mode temporarily when pressed.""""""\n    previous_mode = layer.mode\n\n    # on key press\n    layer.mode = Mode.ERASE\n\n    yield\n\n    # on key release\n    layer.mode = previous_mode\n'"
napari/layers/labels/_labels_mouse_bindings.py,0,"b'from ._labels_utils import interpolate_coordinates\nfrom ._labels_constants import Mode\n\n\ndef draw(layer, event):\n    """"""Draw with the currently selected label to a coordinate.\n\n    This method have different behavior when draw is called\n    with different labeling layer mode.\n\n    In PAINT mode the cursor functions like a paint brush changing any\n    pixels it brushes over to the current label. If the background label\n    `0` is selected than any pixels will be changed to background and this\n    tool functions like an eraser. The size and shape of the cursor can be\n    adjusted in the properties widget.\n\n    In FILL mode the cursor functions like a fill bucket replacing pixels\n    of the label clicked on with the current label. It can either replace\n    all pixels of that label or just those that are contiguous with the\n    clicked on pixel. If the background label `0` is selected than any\n    pixels will be changed to background and this tool functions like an\n    eraser\n    """"""\n    # on press\n    layer._save_history()\n    layer._block_saving = True\n    if layer._mode == Mode.ERASE:\n        new_label = layer._background_label\n    else:\n        new_label = layer.selected_label\n\n    if layer._mode in [Mode.PAINT, Mode.ERASE]:\n        layer.paint(layer.coordinates, new_label)\n    elif layer._mode == Mode.FILL:\n        layer.fill(layer.coordinates, new_label)\n\n    last_cursor_coord = layer.coordinates\n    yield\n\n    # on move\n    while event.type == \'mouse_move\':\n        interp_coord = interpolate_coordinates(\n            last_cursor_coord, layer.coordinates, layer.brush_size\n        )\n        for c in interp_coord:\n            if layer._mode in [Mode.PAINT, Mode.ERASE]:\n                layer.paint(c, new_label, refresh=False)\n            elif layer._mode == Mode.FILL:\n                layer.fill(c, new_label, refresh=False)\n        layer.refresh()\n        last_cursor_coord = layer.coordinates\n        yield\n\n    # on release\n    layer._block_saving = False\n\n\ndef pick(layer, event):\n    """"""Change the selected label to the same as the region clicked.""""""\n    # on press\n    layer.selected_label = layer._value or 0\n'"
napari/layers/labels/_labels_utils.py,6,"b'import numpy as np\n\n\ndef interpolate_coordinates(old_coord, new_coord, brush_size):\n    """"""Interpolates coordinates depending on brush size.\n\n    Useful for ensuring painting is continuous in labels layer.\n\n    Parameters\n    ----------\n    old_coord : np.ndarray, 1x2\n        Last position of cursor.\n    new_coord : np.ndarray, 1x2\n        Current position of cursor.\n    brush_size : float\n        Size of brush, which determines spacing of interpolation.\n\n    Returns\n    ----------\n    coords : np.array, Nx2\n        List of coordinates to ensure painting is continuous\n    """"""\n    num_step = round(\n        max(abs(np.array(new_coord) - np.array(old_coord))) / brush_size * 4\n    )\n    coords = [\n        np.linspace(old_coord[i], new_coord[i], num=int(num_step + 1))\n        for i in range(len(new_coord))\n    ]\n    coords = np.stack(coords).T\n    if len(coords) > 1:\n        coords = coords[1:]\n\n    return coords\n'"
napari/layers/labels/labels.py,24,"b'from collections import deque\nfrom typing import Union, Dict\n\nimport numpy as np\nfrom scipy import ndimage as ndi\n\nfrom ..image import Image\nfrom ...utils.colormaps import colormaps\nfrom ...utils.event import Event\nfrom ...utils.status_messages import format_float\nfrom ._labels_constants import Mode\nfrom ._labels_mouse_bindings import draw, pick\n\nfrom ..utils.layer_utils import dataframe_to_properties\n\n\nclass Labels(Image):\n    """"""Labels (or segmentation) layer.\n\n    An image-like layer where every pixel contains an integer ID\n    corresponding to the region it belongs to.\n\n    Parameters\n    ----------\n    data : array or list of array\n        Labels data as an array or multiscale.\n    num_colors : int\n        Number of unique colors to use in colormap.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each label. Each property should be an array of length\n        N, where N is the number of labels, and the first property corresponds to\n        background.\n    seed : float\n        Seed for colormap random generator.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. If not specified by\n        the user and if the data is a list of arrays that decrease in shape\n        then it will be taken to be multiscale. The first image in the list\n        should be the largest.\n\n    Attributes\n    ----------\n    data : array\n        Integer valued label data. Can be N dimensional. Every pixel contains\n        an integer ID corresponding to the region it belongs to. The label 0 is\n        rendered as transparent.\n    multiscale : bool\n        Whether the data is a multiscale image or not. Multiscale data is\n        represented by a list of array like image data. The first image in the\n        list should be the largest.\n    metadata : dict\n        Labels metadata.\n    num_colors : int\n        Number of unique colors to use in colormap.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each label. Each property should be an array of length\n        N, where N is the number of labels, and the first property corresponds to\n        background.\n    seed : float\n        Seed for colormap random generator.\n    opacity : float\n        Opacity of the labels, must be between 0 and 1.\n    contiguous : bool\n        If `True`, the fill bucket changes only connected pixels of same label.\n    n_dimensional : bool\n        If `True`, paint and fill edit labels across all dimensions.\n    brush_size : float\n        Size of the paint brush.\n    selected_label : int\n        Index of selected label. Can be greater than the current maximum label.\n    mode : str\n        Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        In PICK mode the cursor functions like a color picker, setting the\n        clicked on label to be the curent label. If the background is picked it\n        will select the background label `0`.\n\n        In PAINT mode the cursor functions like a paint brush changing any\n        pixels it brushes over to the current label. If the background label\n        `0` is selected than any pixels will be changed to background and this\n        tool functions like an eraser. The size and shape of the cursor can be\n        adjusted in the properties widget.\n\n        In FILL mode the cursor functions like a fill bucket replacing pixels\n        of the label clicked on with the current label. It can either replace\n        all pixels of that label or just those that are contiguous with the\n        clicked on pixel. If the background label `0` is selected than any\n        pixels will be changed to background and this tool functions like an\n        eraser.\n\n        In ERASE mode the cursor functions similarly to PAINT mode, but to\n        paint with background label, which effectively removes the label.\n\n    Extended Summary\n    ----------\n    _data_raw : array (N, M)\n        2D labels data for the currently viewed slice.\n    _selected_color : 4-tuple or None\n        RGBA tuple of the color of the selected label, or None if the\n        background label `0` is selected.\n    """"""\n\n    _history_limit = 100\n\n    def __init__(\n        self,\n        data,\n        *,\n        num_colors=50,\n        properties=None,\n        seed=0.5,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n        multiscale=None,\n    ):\n\n        self._seed = seed\n        self._num_colors = num_colors\n        colormap = (\'random\', colormaps.label_colormap(self.num_colors))\n\n        if properties is None:\n            self._properties = {}\n            label_index = {}\n        else:\n            properties = self._validate_properties(properties)\n            self._properties, label_index = dataframe_to_properties(properties)\n        if label_index is None:\n            props = self._properties\n            if len(props) > 0:\n                self._label_index = self._map_index(properties)\n            else:\n                self._label_index = {}\n        else:\n            self._label_index = label_index\n\n        super().__init__(\n            data,\n            rgb=False,\n            colormap=colormap,\n            contrast_limits=[0.0, 1.0],\n            interpolation=\'nearest\',\n            rendering=\'translucent\',\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n            multiscale=multiscale,\n        )\n\n        self.events.add(\n            mode=Event,\n            preserve_labels=Event,\n            n_dimensional=Event,\n            contiguous=Event,\n            brush_size=Event,\n            selected_label=Event,\n        )\n\n        self._data_raw = np.zeros((1,) * self.dims.ndisplay)\n        self._n_dimensional = False\n        self._contiguous = True\n        self._brush_size = 10\n\n        self._background_label = 0\n        self._selected_label = 1\n        self._selected_color = self.get_color(self._selected_label)\n\n        self._mode = Mode.PAN_ZOOM\n        self._mode_history = self._mode\n        self._status = self.mode\n        self._preserve_labels = False\n        self._help = \'enter paint or fill mode to edit labels\'\n\n        self._block_saving = False\n        self._reset_history()\n\n        # Trigger generation of view slice and thumbnail\n        self._update_dims()\n        self._set_editable()\n\n        self.dims.events.ndisplay.connect(self._reset_history)\n        self.dims.events.order.connect(self._reset_history)\n        self.dims.events.axis.connect(self._reset_history)\n\n    @property\n    def contiguous(self):\n        """"""bool: fill bucket changes only connected pixels of same label.""""""\n        return self._contiguous\n\n    @contiguous.setter\n    def contiguous(self, contiguous):\n        self._contiguous = contiguous\n        self.events.contiguous()\n\n    @property\n    def n_dimensional(self):\n        """"""bool: paint and fill edits labels across all dimensions.""""""\n        return self._n_dimensional\n\n    @n_dimensional.setter\n    def n_dimensional(self, n_dimensional):\n        self._n_dimensional = n_dimensional\n        self.events.n_dimensional()\n\n    @property\n    def brush_size(self):\n        """"""float: Size of the paint brush.""""""\n        return self._brush_size\n\n    @brush_size.setter\n    def brush_size(self, brush_size):\n        self._brush_size = int(brush_size)\n        self.cursor_size = self._brush_size / self.scale_factor\n        self.status = format_float(self.brush_size)\n        self.events.brush_size()\n\n    @property\n    def seed(self):\n        """"""float: Seed for colormap random generator.""""""\n        return self._seed\n\n    @seed.setter\n    def seed(self, seed):\n        self._seed = seed\n        self._selected_color = self.get_color(self.selected_label)\n        self.refresh()\n        self.events.selected_label()\n\n    @property\n    def num_colors(self):\n        """"""int: Number of unique colors to use in colormap.""""""\n        return self._num_colors\n\n    @num_colors.setter\n    def num_colors(self, num_colors):\n        self._num_colors = num_colors\n        self.colormap = (\n            self._colormap_name,\n            colormaps.label_colormap(num_colors),\n        )\n        self.refresh()\n        self._selected_color = self.get_color(self.selected_label)\n        self.events.selected_label()\n\n    @property\n    def properties(self) -> Dict[str, np.ndarray]:\n        """"""dict {str: array (N,)}, DataFrame: Properties for each label.""""""\n        return self._properties\n\n    @properties.setter\n    def properties(self, properties: Dict[str, np.ndarray]):\n        if not isinstance(properties, dict):\n            properties, label_index = dataframe_to_properties(properties)\n            if label_index is None:\n                label_index = self._map_index(properties)\n        self._properties = self._validate_properties(properties)\n        self._label_index = label_index\n\n    def _validate_properties(\n        self, properties: Dict[str, np.ndarray]\n    ) -> Dict[str, np.ndarray]:\n        """"""Validate the type and size of properties.""""""\n        lens = []\n        for k, v in properties.items():\n            lens.append(len(v))\n            if not isinstance(v, np.ndarray):\n                properties[k] = np.asarray(v)\n\n        if not all([v == lens[0] for v in lens]):\n            raise ValueError(\n                ""the number of items must be equal for all properties""\n            )\n        return properties\n\n    def _map_index(self, properties: Dict[str, np.ndarray]) -> Dict[int, int]:\n        """"""Map rows in given properties to label indices""""""\n        arbitrary_key = list(properties.keys())[0]\n        label_index = {i: i for i in range(len(properties[arbitrary_key]))}\n        return label_index\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'multiscale\': self.multiscale,\n                \'num_colors\': self.num_colors,\n                \'properties\': self._properties,\n                \'seed\': self.seed,\n                \'data\': self.data,\n            }\n        )\n        return state\n\n    @property\n    def selected_label(self):\n        """"""int: Index of selected label.""""""\n        return self._selected_label\n\n    @selected_label.setter\n    def selected_label(self, selected_label):\n        if selected_label < 0:\n            raise ValueError(\'cannot reduce selected label below 0\')\n        if selected_label == self.selected_label:\n            return\n\n        self._selected_label = selected_label\n        self._selected_color = self.get_color(selected_label)\n        self.events.selected_label()\n\n    @property\n    def mode(self):\n        """"""MODE: Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        In PICK mode the cursor functions like a color picker, setting the\n        clicked on label to be the curent label. If the background is picked it\n        will select the background label `0`.\n\n        In PAINT mode the cursor functions like a paint brush changing any\n        pixels it brushes over to the current label. If the background label\n        `0` is selected than any pixels will be changed to background and this\n        tool functions like an eraser. The size and shape of the cursor can be\n        adjusted in the properties widget.\n\n        In FILL mode the cursor functions like a fill bucket replacing pixels\n        of the label clicked on with the current label. It can either replace\n        all pixels of that label or just those that are contiguous with the\n        clicked on pixel. If the background label `0` is selected than any\n        pixels will be changed to background and this tool functions like an\n        eraser.\n\n        In ERASE mode the cursor functions similarly to PAINT mode, but to\n        paint with background label, which effectively removes the label.\n        """"""\n        return str(self._mode)\n\n    @mode.setter\n    def mode(self, mode: Union[str, Mode]):\n        mode = Mode(mode)\n\n        if not self.editable:\n            mode = Mode.PAN_ZOOM\n\n        if mode == self._mode:\n            return\n\n        if self._mode == Mode.PICK:\n            self.mouse_drag_callbacks.remove(pick)\n        elif self._mode in [Mode.PAINT, Mode.FILL, Mode.ERASE]:\n            self.mouse_drag_callbacks.remove(draw)\n\n        if mode == Mode.PAN_ZOOM:\n            self.cursor = \'standard\'\n            self.interactive = True\n            self.help = \'enter paint or fill mode to edit labels\'\n        elif mode == Mode.PICK:\n            self.cursor = \'cross\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom, click to pick a label\'\n            self.mouse_drag_callbacks.append(pick)\n        elif mode == Mode.PAINT:\n            self.cursor_size = self.brush_size / self.scale_factor\n            self.cursor = \'square\'\n            self.interactive = False\n            self.help = (\n                \'hold <space> to pan/zoom, \'\n                \'hold <shift> to toggle preserve_labels, \'\n                \'hold <control> to fill, \'\n                \'hold <alt> to erase, \'\n                \'drag to paint a label\'\n            )\n            self.mouse_drag_callbacks.append(draw)\n        elif mode == Mode.FILL:\n            self.cursor = \'cross\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom, click to fill a label\'\n            self.mouse_drag_callbacks.append(draw)\n        elif mode == Mode.ERASE:\n            self.cursor_size = self.brush_size / self.scale_factor\n            self.cursor = \'square\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom, drag to erase a label\'\n            self.mouse_drag_callbacks.append(draw)\n        else:\n            raise ValueError(""Mode not recognized"")\n\n        self.status = str(mode)\n        self._mode = mode\n\n        self.events.mode(mode=mode)\n        self.refresh()\n\n    @property\n    def preserve_labels(self):\n        """"""Defines if painting should preserve existing labels.\n\n        Default to false to allow paint on existing labels. When\n        set to true, existing labels will be replaced during painting.\n        """"""\n        return self._preserve_labels\n\n    @preserve_labels.setter\n    def preserve_labels(self, preserve_labels: bool):\n        self._preserve_labels = preserve_labels\n        self.events.preserve_labels(preserve_labels=preserve_labels)\n\n    def _set_editable(self, editable=None):\n        """"""Set editable mode based on layer properties.""""""\n        if editable is None:\n            if self.multiscale or self.dims.ndisplay == 3:\n                self.editable = False\n            else:\n                self.editable = True\n\n        if not self.editable:\n            self.mode = Mode.PAN_ZOOM\n            self._reset_history()\n\n    def _raw_to_displayed(self, raw):\n        """"""Determine displayed image from a saved raw image and a saved seed.\n\n        This function ensures that the 0 label gets mapped to the 0 displayed\n        pixel.\n\n        Parameters\n        -------\n        raw : array or int\n            Raw integer input image.\n\n        Returns\n        -------\n        image : array\n            Image mapped between 0 and 1 to be displayed.\n        """"""\n        image = np.where(\n            raw > 0, colormaps._low_discrepancy_image(raw, self._seed), 0\n        )\n        return image\n\n    def new_colormap(self):\n        self.seed = np.random.rand()\n\n    def get_color(self, label):\n        """"""Return the color corresponding to a specific label.""""""\n        if label == 0:\n            col = None\n        else:\n            val = self._raw_to_displayed(np.array([label]))\n            col = self.colormap[1][val].rgba[0]\n        return col\n\n    def _reset_history(self, event=None):\n        self._undo_history = deque()\n        self._redo_history = deque()\n\n    def _trim_history(self):\n        while (\n            len(self._undo_history) + len(self._redo_history)\n            > self._history_limit\n        ):\n            self._undo_history.popleft()\n\n    def _save_history(self):\n        self._redo_history = deque()\n        if not self._block_saving:\n            self._undo_history.append(self.data[self.dims.indices].copy())\n            self._trim_history()\n\n    def _load_history(self, before, after):\n        if len(before) == 0:\n            return\n\n        prev = before.pop()\n        after.append(self.data[self.dims.indices].copy())\n        self.data[self.dims.indices] = prev\n\n        self.refresh()\n\n    def undo(self):\n        self._load_history(self._undo_history, self._redo_history)\n\n    def redo(self):\n        self._load_history(self._redo_history, self._undo_history)\n\n    def fill(self, coord, new_label, refresh=True):\n        """"""Replace an existing label with a new label, either just at the\n        connected component if the `contiguous` flag is `True` or everywhere\n        if it is `False`, working either just in the current slice if\n        the `n_dimensional` flag is `False` or on the entire data if it is\n        `True`.\n\n        Parameters\n        ----------\n        coord : sequence of float\n            Position of mouse cursor in image coordinates.\n        new_label : int\n            Value of the new label to be filled in.\n        refresh : bool\n            Whether to refresh view slice or not. Set to False to batch paint\n            calls.\n        """"""\n        int_coord = tuple(np.round(coord).astype(int))\n        # If requested fill location is outside data shape then return\n        if np.any(np.less(int_coord, 0)) or np.any(\n            np.greater_equal(int_coord, self.shape)\n        ):\n            return\n\n        # If requested new label doesn\'t change old label then return\n        old_label = self.data[int_coord]\n        if old_label == new_label or (\n            self.preserve_labels and old_label != self._background_label\n        ):\n            return\n\n        if refresh is True:\n            self._save_history()\n\n        if self.n_dimensional or self.ndim == 2:\n            # work with entire image\n            labels = self.data\n            slice_coord = tuple(int_coord)\n        else:\n            # work with just the sliced image\n            labels = self._data_raw\n            slice_coord = tuple(int_coord[d] for d in self.dims.displayed)\n\n        matches = labels == old_label\n        if self.contiguous:\n            # if contiguous replace only selected connected component\n            labeled_matches, num_features = ndi.label(matches)\n            if num_features != 1:\n                match_label = labeled_matches[slice_coord]\n                matches = np.logical_and(\n                    matches, labeled_matches == match_label\n                )\n\n        # Replace target pixels with new_label\n        labels[matches] = new_label\n\n        if not (self.n_dimensional or self.ndim == 2):\n            # if working with just the slice, update the rest of the raw data\n            self.data[tuple(self.dims.indices)] = labels\n\n        if refresh is True:\n            self.refresh()\n\n    def paint(self, coord, new_label, refresh=True):\n        """"""Paint over existing labels with a new label, using the selected\n        brush shape and size, either only on the visible slice or in all\n        n dimensions.\n\n        Parameters\n        ----------\n        coord : sequence of int\n            Position of mouse cursor in image coordinates.\n        new_label : int\n            Value of the new label to be filled in.\n        refresh : bool\n            Whether to refresh view slice or not. Set to False to batch paint\n            calls.\n        """"""\n        if refresh is True:\n            self._save_history()\n\n        if self.n_dimensional or self.ndim == 2:\n            slice_coord = tuple(\n                [\n                    slice(\n                        np.round(\n                            np.clip(c - self.brush_size / 2 + 0.5, 0, s)\n                        ).astype(int),\n                        np.round(\n                            np.clip(c + self.brush_size / 2 + 0.5, 0, s)\n                        ).astype(int),\n                        1,\n                    )\n                    for c, s in zip(coord, self.shape)\n                ]\n            )\n        else:\n            slice_coord = [0] * self.ndim\n            for i in self.dims.displayed:\n                slice_coord[i] = slice(\n                    np.round(\n                        np.clip(\n                            coord[i] - self.brush_size / 2 + 0.5,\n                            0,\n                            self.shape[i],\n                        )\n                    ).astype(int),\n                    np.round(\n                        np.clip(\n                            coord[i] + self.brush_size / 2 + 0.5,\n                            0,\n                            self.shape[i],\n                        )\n                    ).astype(int),\n                    1,\n                )\n            for i in self.dims.not_displayed:\n                slice_coord[i] = np.round(coord[i]).astype(int)\n            slice_coord = tuple(slice_coord)\n\n        # update the labels image\n\n        if not self.preserve_labels:\n            self.data[slice_coord] = new_label\n        else:\n            if new_label == self._background_label:\n                keep_coords = self.data[slice_coord] == self.selected_label\n            else:\n                keep_coords = self.data[slice_coord] == self._background_label\n            self.data[slice_coord][keep_coords] = new_label\n\n        if refresh is True:\n            self.refresh()\n\n    def get_message(self):\n        msg = super().get_message()\n        # if this labels layer has properties\n        if self._label_index and self._properties:\n            # if the cursor is not outside the image or on the background\n            if self._value is not None:\n                if self._value in self._label_index:\n                    idx = self._label_index[self._value]\n                    for k, v in self._properties.items():\n                        if k != \'index\':\n                            msg += f\', {k}: {v[idx]}\'\n                else:\n                    msg += f\' [No Properties]\'\n        return msg\n'"
napari/layers/points/__init__.py,0,"b'from .points import Points\nfrom . import _points_key_bindings\n\n# Note that importing _points_key_bindings is needed as the Points layer gets\n# decorated with keybindings during that process, but it is not directly needed\n# by our users and so is deleted below\ndel _points_key_bindings\n'"
napari/layers/points/_points_constants.py,0,"b'from enum import Enum, auto\n\nfrom ...utils.misc import StringEnum\n\n\nclass ColorMode(StringEnum):\n    """"""\n    ColorMode: Color setting mode.\n\n    DIRECT (default mode) allows each point to be set arbitrarily\n\n    CYCLE allows the color to be set via a color cycle over an attribute\n\n    COLORMAP allows color to be set via a color map over an attribute\n    """"""\n\n    DIRECT = auto()\n    CYCLE = auto()\n    COLORMAP = auto()\n\n\nclass Mode(StringEnum):\n    """"""\n    Mode: Interactive mode. The normal, default mode is PAN_ZOOM, which\n    allows for normal interactivity with the canvas.\n\n    ADD allows points to be added by clicking\n\n    SELECT allows the user to select points by clicking on them\n    """"""\n\n    ADD = auto()\n    SELECT = auto()\n    PAN_ZOOM = auto()\n\n\nclass Symbol(Enum):\n    """"""Symbol: Valid symbol/marker types for the Points layer.\n    The string method returns the valid vispy string.\n\n    """"""\n\n    ARROW = \'arrow\'\n    CLOBBER = \'clobber\'\n    CROSS = \'cross\'\n    DIAMOND = \'diamond\'\n    DISC = \'disc\'\n    HBAR = \'hbar\'\n    RING = \'ring\'\n    SQUARE = \'square\'\n    STAR = \'star\'\n    TAILED_ARROW = \'tailed_arrow\'\n    TRIANGLE_DOWN = \'triangle_down\'\n    TRIANGLE_UP = \'triangle_up\'\n    VBAR = \'vbar\'\n    X = \'x\'\n\n    def __str__(self):\n        """"""String representation: The string method returns the\n        valid vispy symbol string for the Markers visual.\n        """"""\n        return self.value\n\n\n# Mapping of symbol alias names to the deduplicated name\nSYMBOL_ALIAS = {\n    \'o\': Symbol.DISC,\n    \'*\': Symbol.STAR,\n    \'+\': Symbol.CROSS,\n    \'-\': Symbol.HBAR,\n    \'->\': Symbol.TAILED_ARROW,\n    \'>\': Symbol.ARROW,\n    \'^\': Symbol.TRIANGLE_UP,\n    \'v\': Symbol.TRIANGLE_DOWN,\n    \'s\': Symbol.SQUARE,\n    \'|\': Symbol.VBAR,\n}\n'"
napari/layers/points/_points_key_bindings.py,0,"b'from .points import Points\nfrom ._points_constants import Mode\n\n\n@Points.bind_key(\'Space\')\ndef hold_to_pan_zoom(layer):\n    """"""Hold to pan and zoom in the viewer.""""""\n    if layer._mode != Mode.PAN_ZOOM:\n        # on key press\n        prev_mode = layer.mode\n        prev_selected = layer.selected_data.copy()\n        layer.mode = Mode.PAN_ZOOM\n\n        yield\n\n        # on key release\n        layer.mode = prev_mode\n        layer.selected_data = prev_selected\n        layer._set_highlight()\n\n\n@Points.bind_key(\'P\')\ndef activate_add_mode(layer):\n    """"""Activate add points tool.""""""\n    layer.mode = Mode.ADD\n\n\n@Points.bind_key(\'S\')\ndef activate_select_mode(layer):\n    """"""Activate select points tool.""""""\n    layer.mode = Mode.SELECT\n\n\n@Points.bind_key(\'Z\')\ndef activate_pan_zoom_mode(layer):\n    """"""Activate pan and zoom mode.""""""\n    layer.mode = Mode.PAN_ZOOM\n\n\n@Points.bind_key(\'Control-C\')\ndef copy(layer):\n    """"""Copy any selected points.""""""\n    if layer._mode == Mode.SELECT:\n        layer._copy_data()\n\n\n@Points.bind_key(\'Control-V\')\ndef paste(layer):\n    """"""Paste any copied points.""""""\n    if layer._mode == Mode.SELECT:\n        layer._paste_data()\n\n\n@Points.bind_key(\'A\')\ndef select_all(layer):\n    """"""Select all points in the current view slice.""""""\n    if layer._mode == Mode.SELECT:\n        layer.selected_data = layer._indices_view[: len(layer._data_view)]\n        layer._set_highlight()\n\n\n@Points.bind_key(\'Backspace\')\n@Points.bind_key(\'Delete\')\ndef delete_selected(layer):\n    """"""Delet all selected points.""""""\n    if layer._mode in (Mode.SELECT, Mode.ADD):\n        layer.remove_selected()\n'"
napari/layers/points/_points_mouse_bindings.py,1,"b'import numpy as np\n\nfrom ._points_utils import points_in_box\n\n\ndef select(layer, event):\n    """"""Select points.\n\n    Clicking on a point will select that point. If holding shift while clicking\n    that point will be added to or removed from the existing selection\n    depending on whether it is selected or not.\n\n    Clicking and dragging a point that is already selected will drag all the\n    currently selected points.\n\n    Clicking and dragging on an empty part of the canvas (i.e. not on a point)\n    will create a drag box that will select all points inside it when finished.\n    Holding shift throughout the entirety of this process will add those points\n    to any existing selection, otherwise these will become the only selected\n    points.\n    """"""\n    # on press\n    modify_selection = (\n        \'Shift\' in event.modifiers or \'Control\' in event.modifiers\n    )\n\n    # if modifying selection add / remove any from existing selection\n    if modify_selection:\n        # layer._value is defined in the base layer and contains the value\n        # under the cursor. For points, this is the index of the highlighted\n        # point.\n        if layer._value is not None:\n            layer.selected_data = _toggle_selected(\n                layer.selected_data, layer._value\n            )\n    else:\n        if layer._value is not None:\n            # If the current index is not in the current list make it the only\n            # index selected, otherwise don\'t change the selection so that\n            # the current selection can be dragged together.\n            if layer._value not in layer.selected_data:\n                layer.selected_data = {layer._value}\n        else:\n            layer.selected_data = set()\n    layer._set_highlight()\n\n    yield\n\n    # on move\n    while event.type == \'mouse_move\':\n        # If not holding modifying selection and points selected then drag them\n        if not modify_selection and len(layer.selected_data) > 0:\n            layer._move(layer.selected_data, layer.coordinates)\n        else:\n            layer._is_selecting = True\n            if layer._drag_start is None:\n                layer._drag_start = layer.displayed_coordinates\n            layer._drag_box = np.array(\n                [layer._drag_start, layer.displayed_coordinates]\n            )\n            layer._set_highlight()\n        yield\n\n    # on release\n    layer._drag_start = None\n    if layer._is_selecting:\n        layer._is_selecting = False\n        if len(layer._view_data) > 0:\n            selection = points_in_box(\n                layer._drag_box, layer._view_data, layer._view_size\n            )\n            # If shift combine drag selection with existing selected ones\n            if modify_selection:\n                new_selected = layer._indices_view[selection]\n                target = set(layer.selected_data).symmetric_difference(\n                    set(new_selected)\n                )\n                layer.selected_data = list(target)\n            else:\n                layer.selected_data = layer._indices_view[selection]\n        else:\n            layer.selected_data = set()\n    layer._set_highlight(force=True)\n\n\ndef add(layer, event):\n    """"""Add a new point at the clicked position.""""""\n    # on press\n    layer.add(layer.coordinates)\n\n\ndef highlight(layer, event):\n    """"""Highlight hovered points.""""""\n    layer._set_highlight()\n\n\ndef _toggle_selected(selected_data, value):\n    """"""Add or remove value from the selected data set.\n\n    Paramerters\n    -----------\n    selected_data : set\n        Set of selected data points to be modified.\n    value : int\n        Index of point to add or remove from selected data set.\n\n    Returns\n    -------\n    set\n        Modified selected_data set.\n    """"""\n    if value in selected_data:\n        selected_data.remove(value)\n    else:\n        selected_data.add(value)\n\n    return selected_data\n'"
napari/layers/points/_points_utils.py,14,"b'import numpy as np\n\n\ndef create_box(data):\n    """"""Create the axis aligned interaction box of a list of points\n\n    Parameters\n    ----------\n    data : (N, 2) array\n        Points around which the interaction box is created\n\n    Returns\n    -------\n    box : (4, 2) array\n        Vertices of the interaction box\n    """"""\n    min_val = data.min(axis=0)\n    max_val = data.max(axis=0)\n    tl = np.array([min_val[0], min_val[1]])\n    tr = np.array([max_val[0], min_val[1]])\n    br = np.array([max_val[0], max_val[1]])\n    bl = np.array([min_val[0], max_val[1]])\n    box = np.array([tl, tr, br, bl])\n    return box\n\n\ndef points_to_squares(points, sizes):\n    """"""Expand points to squares defined by their size\n\n    Parameters\n    ----------\n    points : (N, 2) array\n        Points to be turned into squares\n    sizes : (N,) array\n        Size of each point\n\n    Returns\n    -------\n    rect : (4N, 2) array\n        Vertices of the expanded points\n    """"""\n    rect = np.concatenate(\n        [\n            points + np.sqrt(2) / 2 * np.array([sizes, sizes]).T,\n            points + np.sqrt(2) / 2 * np.array([sizes, -sizes]).T,\n            points + np.sqrt(2) / 2 * np.array([-sizes, sizes]).T,\n            points + np.sqrt(2) / 2 * np.array([-sizes, -sizes]).T,\n        ],\n        axis=0,\n    )\n    return rect\n\n\ndef points_in_box(corners, points, sizes):\n    """"""Determine which points are in an axis aligned box defined by the corners\n\n    Parameters\n    ----------\n    points : (N, 2) array\n        Points to be checked\n    sizes : (N,) array\n        Size of each point\n\n    Returns\n    -------\n    inside : list\n        Indices of points inside the box\n    """"""\n    box = create_box(corners)[[0, 2]]\n    # Check all four corners in a square around a given point. If any corner\n    # is inside the box, then that point is considered inside\n    point_corners = points_to_squares(points, sizes)\n    below_top = np.all(box[1] >= point_corners, axis=1)\n    above_bottom = np.all(point_corners >= box[0], axis=1)\n    point_corners_in_box = np.where(np.logical_and(below_top, above_bottom))[0]\n    # Determine indices of points which have at least one corner inside box\n    inside = np.unique(point_corners_in_box % len(points))\n    return list(inside)\n'"
napari/layers/points/points.py,126,"b'from typing import Union, Dict, Tuple, List\nfrom copy import copy, deepcopy\nfrom itertools import cycle\nimport warnings\n\nimport numpy as np\nfrom vispy.color.colormap import Colormap\n\nfrom ...utils.colormaps import ensure_colormap_tuple\nfrom ...types import ValidColormapArg\n\nfrom ..base import Layer\nfrom ...utils.event import Event\nfrom ...utils.status_messages import format_float\nfrom ...utils.colormaps.standardize_color import (\n    transform_color,\n    hex_to_name,\n    get_color_namelist,\n    rgb_to_hex,\n)\nfrom ..utils.color_transformations import (\n    transform_color_with_defaults,\n    transform_color_cycle,\n    normalize_and_broadcast_colors,\n    ColorType,\n)\nfrom ._points_constants import Symbol, SYMBOL_ALIAS, Mode, ColorMode\nfrom ._points_mouse_bindings import add, select, highlight\nfrom ._points_utils import (\n    create_box,\n    points_to_squares,\n)\nfrom ..utils.layer_utils import (\n    dataframe_to_properties,\n    guess_continuous,\n    map_property,\n)\n\nDEFAULT_COLOR_CYCLE = np.array([[1, 0, 1, 1], [0, 1, 0, 1]])\n\n\nclass Points(Layer):\n    """"""Points layer.\n\n    Parameters\n    ----------\n    data : array (N, D)\n        Coordinates for N points in D dimensions.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each point. Each property should be an array of length N,\n        where N is the number of points.\n    symbol : str\n        Symbol to be used for the point markers. Must be one of the\n        following: arrow, clobber, cross, diamond, disc, hbar, ring,\n        square, star, tailed_arrow, triangle_down, triangle_up, vbar, x.\n    size : float, array\n        Size of the point marker. If given as a scalar, all points are made\n        the same size. If given as an array, size must be the same\n        broadcastable to the same shape as the data.\n    edge_width : float\n        Width of the symbol edge in pixels.\n    edge_color : str, array-like\n        Color of the point marker border. Numeric color values should be RGB(A).\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set edge_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    face_color : str, array-like\n        Color of the point marker body. Numeric color values should be RGB(A).\n    face_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to face_color if a\n        categorical attribute is used color the vectors.\n    face_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set face_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    face_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    n_dimensional : bool\n        If True, renders points not just in central plane but also in all\n        n-dimensions according to specified point marker size.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n\n    Attributes\n    ----------\n    data : array (N, D)\n        Coordinates for N points in D dimensions.\n    properties : dict {str: array (N,)}\n        Annotations for each point. Each property should be an array of length N,\n        where N is the number of points.\n    symbol : str\n        Symbol used for all point markers.\n    size : array (N, D)\n        Array of sizes for each point in each dimension. Must have the same\n        shape as the layer `data`.\n    edge_width : float\n        Width of the marker edges in pixels for all points\n    edge_color : Nx4 numpy array\n        Array of edge color RGBA values, one for each point.\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set edge_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    face_color : Nx4 numpy array\n        Array of face color RGBA values, one for each point.\n    face_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to face_color if a\n        categorical attribute is used color the vectors.\n    face_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set face_color if a continuous attribute is used to set face_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    face_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    current_size : float\n        Size of the marker for the next point to be added or the currently\n        selected point.\n    current_edge_color : str\n        Size of the marker edge for the next point to be added or the currently\n        selected point.\n    current_face_color : str\n        Size of the marker edge for the next point to be added or the currently\n        selected point.\n    n_dimensional : bool\n        If True, renders points not just in central plane but also in all\n        n-dimensions according to specified point marker size.\n    selected_data : set\n        Integer indices of any selected points.\n    mode : str\n        Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        In ADD mode clicks of the cursor add points at the clicked location.\n\n        In SELECT mode the cursor can select points by clicking on them or\n        by dragging a box around them. Once selected points can be moved,\n        have their properties edited, or be deleted.\n    face_color_mode : str\n        Face color setting mode.\n\n        DIRECT (default mode) allows each point to be set arbitrarily\n\n        CYCLE allows the color to be set via a color cycle over an attribute\n\n        COLORMAP allows color to be set via a color map over an attribute\n    edge_color_mode : str\n        Edge color setting mode.\n\n        DIRECT (default mode) allows each point to be set arbitrarily\n\n        CYCLE allows the color to be set via a color cycle over an attribute\n\n        COLORMAP allows color to be set via a color map over an attribute\n\n    Extended Summary\n    ----------\n    _property_choices : dict {str: array (N,)}\n        Possible values for the properties in Points.properties.\n        If properties is not provided, it will be {} (empty dictionary).\n    _view_data : array (M, 2)\n        2D coordinates of points in the currently viewed slice.\n    _view_size : array (M, )\n        Size of the point markers in the currently viewed slice.\n    _indices_view : array (M, )\n        Integer indices of the points in the currently viewed slice.\n    _selected_view :\n        Integer indices of selected points in the currently viewed slice within\n        the `_view_data` array.\n    _selected_box : array (4, 2) or None\n        Four corners of any box either around currently selected points or\n        being created during a drag action. Starting in the top left and\n        going clockwise.\n    _drag_start : list or None\n        Coordinates of first cursor click during a drag action. Gets reset to\n        None after dragging is done.\n    """"""\n\n    # The max number of points that will ever be used to render the thumbnail\n    # If more points are present then they are randomly subsampled\n    _max_points_thumbnail = 1024\n\n    def __init__(\n        self,\n        data=None,\n        *,\n        properties=None,\n        symbol=\'o\',\n        size=10,\n        edge_width=1,\n        edge_color=\'black\',\n        edge_color_cycle=None,\n        edge_colormap=\'viridis\',\n        edge_contrast_limits=None,\n        face_color=\'white\',\n        face_color_cycle=None,\n        face_colormap=\'viridis\',\n        face_contrast_limits=None,\n        n_dimensional=False,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n    ):\n        if data is None:\n            data = np.empty((0, 2))\n        else:\n            data = np.atleast_2d(data)\n        ndim = data.shape[1]\n        super().__init__(\n            data,\n            ndim,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n\n        self.events.add(\n            mode=Event,\n            size=Event,\n            edge_width=Event,\n            face_color=Event,\n            current_face_color=Event,\n            edge_color=Event,\n            current_edge_color=Event,\n            current_properties=Event,\n            symbol=Event,\n            n_dimensional=Event,\n            highlight=Event,\n        )\n        # update highlights when the layer is selected/deselected\n        self.events.select.connect(self._set_highlight)\n        self.events.deselect.connect(self._set_highlight)\n\n        self._colors = get_color_namelist()\n\n        # Save the point coordinates\n        self._data = np.asarray(data)\n        self.dims.clip = False\n\n        # Save the properties\n        if properties is None:\n            self._properties = {}\n            self._property_choices = {}\n        elif len(data) > 0:\n            properties, _ = dataframe_to_properties(properties)\n            self._properties = self._validate_properties(properties)\n            self._property_choices = {\n                k: np.unique(v) for k, v in properties.items()\n            }\n        elif len(data) == 0:\n            self._property_choices = {\n                k: np.asarray(v) for k, v in properties.items()\n            }\n            empty_properties = {\n                k: np.empty(0, dtype=v.dtype)\n                for k, v in self._property_choices.items()\n            }\n            self._properties = empty_properties\n\n        # Save the point style params\n        self.symbol = symbol\n        self._n_dimensional = n_dimensional\n        self.edge_width = edge_width\n\n        # The following point properties are for the new points that will\n        # be added. For any given property, if a list is passed to the\n        # constructor so each point gets its own value then the default\n        # value is used when adding new points\n        if np.isscalar(size):\n            self._current_size = np.asarray(size)\n        else:\n            self._current_size = 10\n\n        # Indices of selected points\n        self._selected_data = set()\n        self._selected_data_stored = set()\n        self._selected_data_history = set()\n        # Indices of selected points within the currently viewed slice\n        self._selected_view = []\n        # Index of hovered point\n        self._value = None\n        self._value_stored = None\n        self._mode = Mode.PAN_ZOOM\n        self._mode_history = self._mode\n        self._status = self.mode\n        self._highlight_index = []\n        self._highlight_box = None\n\n        self._drag_start = None\n\n        # initialize view data\n        self._indices_view = []\n        self._view_size_scale = []\n\n        self._drag_box = None\n        self._drag_box_stored = None\n        self._is_selecting = False\n        self._clipboard = {}\n\n        with self.block_update_properties():\n            self._edge_color_property = \'\'\n            self.edge_color = edge_color\n            if edge_color_cycle is None:\n                edge_color_cycle = deepcopy(DEFAULT_COLOR_CYCLE)\n            self.edge_color_cycle = edge_color_cycle\n            self.edge_color_cycle_map = {}\n            self.edge_colormap = edge_colormap\n            self._edge_contrast_limits = edge_contrast_limits\n\n            self._face_color_property = \'\'\n            self.face_color = face_color\n            if face_color_cycle is None:\n                face_color_cycle = deepcopy(DEFAULT_COLOR_CYCLE)\n            self.face_color_cycle = face_color_cycle\n            self.face_color_cycle_map = {}\n            self.face_colormap = face_colormap\n            self._face_contrast_limits = face_contrast_limits\n\n        self.refresh_colors()\n\n        self.size = size\n        # set the current_* properties\n        if len(data) > 0:\n            self._current_edge_color = self.edge_color[-1]\n            self._current_face_color = self.face_color[-1]\n            self.current_properties = {\n                k: np.asarray([v[-1]]) for k, v in self.properties.items()\n            }\n        elif len(data) == 0 and self.properties:\n            self.current_properties = {\n                k: np.asarray([v[0]])\n                for k, v in self._property_choices.items()\n            }\n            self._initialize_current_color_for_empty_layer(edge_color, \'edge\')\n            self._initialize_current_color_for_empty_layer(face_color, \'face\')\n        else:\n            self._current_edge_color = self.edge_color[-1]\n            self._current_face_color = self.face_color[-1]\n            self.current_properties = {}\n\n        # Trigger generation of view slice and thumbnail\n        self._update_dims()\n\n    def _initialize_current_color_for_empty_layer(\n        self, color: ColorType, attribute: str\n    ):\n        """"""Initialize current_{edge,face}_color when starting with empty layer.\n\n        Parameters:\n        -----------\n        color : (N, 4) array or str\n            The value for setting edge or face_color\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        """"""\n        color_mode = getattr(self, f\'_{attribute}_color_mode\')\n        if color_mode == ColorMode.DIRECT:\n            curr_color = transform_color_with_defaults(\n                num_entries=1,\n                colors=color,\n                elem_name=f\'{attribute}_color\',\n                default=""white"",\n            )\n\n        elif color_mode == ColorMode.CYCLE:\n            color_cycle = getattr(self, f\'_{attribute}_color_cycle\')\n            curr_color = transform_color(next(color_cycle))\n\n            # add the new color cycle mapping\n            color_property = getattr(self, f\'_{attribute}_color_property\')\n            prop_value = self._property_choices[color_property][0]\n            color_cycle_map = getattr(self, f\'{attribute}_color_cycle_map\')\n            color_cycle_map[prop_value] = np.squeeze(curr_color)\n            setattr(self, f\'{attribute}_color_cycle_map\', color_cycle_map)\n\n        elif color_mode == ColorMode.COLORMAP:\n            color_property = getattr(self, f\'_{attribute}_color_property\')\n            prop_value = self._property_choices[color_property][0]\n            colormap = getattr(self, f\'{attribute}_colormap\')\n            contrast_limits = getattr(self, f\'_{attribute}_contrast_limits\')\n            curr_color, _ = map_property(\n                prop=prop_value,\n                colormap=colormap[1],\n                contrast_limits=contrast_limits,\n            )\n        setattr(self, f\'_current_{attribute}_color\', curr_color)\n\n    @property\n    def data(self) -> np.ndarray:\n        """"""(N, D) array: coordinates for N points in D dimensions.""""""\n        return self._data\n\n    @data.setter\n    def data(self, data: np.ndarray):\n        cur_npoints = len(self._data)\n        self._data = data\n\n        # Adjust the size array when the number of points has changed\n        if len(data) < cur_npoints:\n            # If there are now fewer points, remove the size and colors of the\n            # extra ones\n            with self.events.set_data.blocker():\n                self._edge_color = self.edge_color[: len(data)]\n                self._face_color = self.face_color[: len(data)]\n                self._size = self._size[: len(data)]\n\n                for k in self.properties:\n                    self.properties[k] = self.properties[k][: len(data)]\n\n        elif len(data) > cur_npoints:\n            # If there are now more points, add the size and colors of the\n            # new ones\n            with self.events.set_data.blocker():\n                adding = len(data) - cur_npoints\n                if len(self._size) > 0:\n                    new_size = copy(self._size[-1])\n                    for i in self.dims.displayed:\n                        new_size[i] = self.current_size\n                else:\n                    # Add the default size, with a value for each dimension\n                    new_size = np.repeat(\n                        self.current_size, self._size.shape[1]\n                    )\n                size = np.repeat([new_size], adding, axis=0)\n\n                for k in self.properties:\n                    new_property = np.repeat(\n                        self.current_properties[k], adding, axis=0\n                    )\n                    self.properties[k] = np.concatenate(\n                        (self.properties[k], new_property), axis=0\n                    )\n\n                # add new edge colors\n                self._add_point_color(adding, \'edge\')\n\n                # add new face colors\n                self._add_point_color(adding, \'face\')\n\n                self.size = np.concatenate((self._size, size), axis=0)\n                self.selected_data = set(np.arange(cur_npoints, len(data)))\n\n        self._update_dims()\n        self.events.data()\n\n    def _add_point_color(self, adding: int, attribute: str):\n        """"""Add the edge or face colors for new points.\n\n        Parameters:\n        ----------\n        adding : int\n            the number of points that were added\n            (and thus the number of color entries to add)\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_colo_moder or \'face\' for face_color_mode.\n        """"""\n        color_mode = getattr(self, f\'_{attribute}_color_mode\')\n        if color_mode == ColorMode.DIRECT:\n            current_face_color = getattr(self, f\'_current_{attribute}_color\')\n            new_colors = np.tile(current_face_color, (adding, 1))\n        elif color_mode == ColorMode.CYCLE:\n            property_name = getattr(self, f\'_{attribute}_color_property\')\n            color_property_value = self.current_properties[property_name][0]\n\n            # check if the new color property is in the cycle map\n            # and add it if it is not\n            color_cycle_map = getattr(self, f\'{attribute}_color_cycle_map\')\n            color_cycle_keys = [*color_cycle_map]\n            if color_property_value not in color_cycle_keys:\n                color_cycle = getattr(self, f\'_{attribute}_color_cycle\')\n                color_cycle_map[color_property_value] = np.squeeze(\n                    transform_color(next(color_cycle))\n                )\n\n                setattr(self, f\'{attribute}_color_cycle_map\', color_cycle_map)\n\n            new_colors = np.tile(\n                color_cycle_map[color_property_value], (adding, 1)\n            )\n        elif color_mode == ColorMode.COLORMAP:\n            property_name = getattr(self, f\'_{attribute}_color_property\')\n            color_property_value = self.current_properties[property_name][0]\n            colormap = getattr(self, f\'{attribute}_colormap\')\n            contrast_limits = getattr(self, f\'_{attribute}_contrast_limits\')\n\n            fc, _ = map_property(\n                prop=color_property_value,\n                colormap=colormap[1],\n                contrast_limits=contrast_limits,\n            )\n            new_colors = np.tile(fc, (adding, 1))\n        colors = getattr(self, f\'{attribute}_color\')\n        setattr(self, f\'_{attribute}_color\', np.vstack((colors, new_colors)))\n\n    @property\n    def properties(self) -> Dict[str, np.ndarray]:\n        """"""dict {str: np.ndarray (N,)}, DataFrame: Annotations for each point""""""\n        return self._properties\n\n    @properties.setter\n    def properties(self, properties: Dict[str, np.ndarray]):\n        if not isinstance(properties, dict):\n            properties, _ = dataframe_to_properties(properties)\n        self._properties = self._validate_properties(properties)\n        if self._face_color_property and (\n            self._face_color_property not in self._properties\n        ):\n            self._face_color_property = \'\'\n            warnings.warn(\n                \'property used for face_color dropped\', RuntimeWarning\n            )\n\n        if self._edge_color_property and (\n            self._edge_color_property not in self._properties\n        ):\n            self._edge_color_property = \'\'\n            warnings.warn(\n                \'property used for edge_color dropped\', RuntimeWarning\n            )\n\n    @property\n    def current_properties(self) -> Dict[str, np.ndarray]:\n        """"""dict{str: np.ndarray(1,)}: properties for the next added point.""""""\n        return self._current_properties\n\n    @current_properties.setter\n    def current_properties(self, current_properties):\n        self._current_properties = current_properties\n\n        if (\n            self._update_properties\n            and len(self.selected_data) > 0\n            and self._mode != Mode.ADD\n        ):\n            props = self.properties\n            for k in props:\n                props[k][list(self.selected_data)] = current_properties[k]\n            self.properties = props\n\n            self.refresh_colors()\n        self.events.current_properties()\n\n    def _validate_properties(\n        self, properties: Dict[str, np.ndarray]\n    ) -> Dict[str, np.ndarray]:\n        """"""Validates the type and size of the properties""""""\n        for k, v in properties.items():\n            if len(v) != len(self.data):\n                raise ValueError(\n                    \'the number of properties must equal the number of points\'\n                )\n            # ensure the property values are a numpy array\n            if type(v) != np.ndarray:\n                properties[k] = np.asarray(v)\n\n        return properties\n\n    def _get_ndim(self) -> int:\n        """"""Determine number of dimensions of the layer.""""""\n        return self.data.shape[1]\n\n    def _get_extent(self) -> List[Tuple[int, int, int]]:\n        """"""Determine ranges for slicing given by (min, max, step).""""""\n        if len(self.data) == 0:\n            maxs = np.ones(self.data.shape[1], dtype=int)\n            mins = np.zeros(self.data.shape[1], dtype=int)\n        else:\n            maxs = np.max(self.data, axis=0)\n            mins = np.min(self.data, axis=0)\n\n        return [(min, max) for min, max in zip(mins, maxs)]\n\n    @property\n    def n_dimensional(self) -> bool:\n        """"""bool: renders points as n-dimensionsal.""""""\n        return self._n_dimensional\n\n    @n_dimensional.setter\n    def n_dimensional(self, n_dimensional: bool) -> None:\n        self._n_dimensional = n_dimensional\n        self.events.n_dimensional()\n        self.refresh()\n\n    @property\n    def symbol(self) -> str:\n        """"""str: symbol used for all point markers.""""""\n        return str(self._symbol)\n\n    @symbol.setter\n    def symbol(self, symbol: Union[str, Symbol]) -> None:\n\n        if isinstance(symbol, str):\n            # Convert the alias string to the deduplicated string\n            if symbol in SYMBOL_ALIAS:\n                symbol = SYMBOL_ALIAS[symbol]\n            else:\n                symbol = Symbol(symbol)\n        self._symbol = symbol\n        self.events.symbol()\n        self.events.highlight()\n\n    @property\n    def size(self) -> Union[int, float, np.ndarray, list]:\n        """"""(N, D) array: size of all N points in D dimensions.""""""\n        return self._size\n\n    @size.setter\n    def size(self, size: Union[int, float, np.ndarray, list]) -> None:\n        try:\n            self._size = np.broadcast_to(size, self.data.shape).copy()\n        except Exception:\n            try:\n                self._size = np.broadcast_to(\n                    size, self.data.shape[::-1]\n                ).T.copy()\n            except Exception:\n                raise ValueError(""Size is not compatible for broadcasting"")\n        self.refresh()\n\n    @property\n    def current_size(self) -> Union[int, float]:\n        """"""float: size of marker for the next added point.""""""\n        return self._current_size\n\n    @current_size.setter\n    def current_size(self, size: Union[None, float]) -> None:\n        self._current_size = size\n        if (\n            self._update_properties\n            and len(self.selected_data) > 0\n            and self._mode != Mode.ADD\n        ):\n            for i in self.selected_data:\n                self.size[i, :] = (self.size[i, :] > 0) * size\n            self.refresh()\n            self.events.size()\n        self.status = format_float(self.current_size)\n\n    @property\n    def edge_width(self) -> Union[None, int, float]:\n        """"""float: width used for all point markers.""""""\n        return self._edge_width\n\n    @edge_width.setter\n    def edge_width(self, edge_width: Union[None, float]) -> None:\n        self._edge_width = edge_width\n        self.status = format_float(self.edge_width)\n        self.events.edge_width()\n\n    @property\n    def edge_color(self) -> np.ndarray:\n        """"""(N x 4) np.ndarray: Array of RGBA edge colors for each point""""""\n        return self._edge_color\n\n    @edge_color.setter\n    def edge_color(self, edge_color):\n        self._set_color(edge_color, \'edge\')\n\n    @property\n    def edge_color_cycle(self) -> np.ndarray:\n        """"""Union[list, np.ndarray] :  Color cycle for edge_color.\n        Can be a list of colors defined by name, RGB or RGBA\n\n        """"""\n        return self._edge_color_cycle_values\n\n    @edge_color_cycle.setter\n    def edge_color_cycle(self, edge_color_cycle: Union[list, np.ndarray]):\n        self._set_color_cycle(edge_color_cycle, \'edge\')\n\n    @property\n    def edge_colormap(self) -> Tuple[str, Colormap]:\n        """"""Return the colormap to be applied to a property to get the edge color.\n\n        Returns\n        -------\n        colormap_name : str\n            The name of the current colormap.\n        colormap : vispy.color.Colormap\n            The vispy colormap object.\n        """"""\n        return self._edge_colormap_name, self._edge_colormap\n\n    @edge_colormap.setter\n    def edge_colormap(self, colormap: ValidColormapArg):\n        name, cmap = ensure_colormap_tuple(colormap)\n        self._edge_colormap_name = name\n        self._edge_colormap = cmap\n\n    @property\n    def edge_contrast_limits(self) -> Tuple[float, float]:\n        """""" None, (float, float): contrast limits for mapping\n        the edge_color colormap property to 0 and 1\n        """"""\n        return self._edge_contrast_limits\n\n    @edge_contrast_limits.setter\n    def edge_contrast_limits(\n        self, contrast_limits: Union[None, Tuple[float, float]]\n    ):\n        self._edge_contrast_limits = contrast_limits\n\n    @property\n    def current_edge_color(self) -> str:\n        """"""str: Edge color of marker for the next added point or the selected point(s).""""""\n        hex_ = rgb_to_hex(self._current_edge_color)[0]\n        return hex_to_name.get(hex_, hex_)\n\n    @current_edge_color.setter\n    def current_edge_color(self, edge_color: ColorType) -> None:\n        self._current_edge_color = transform_color(edge_color)\n        if (\n            self._update_properties\n            and len(self.selected_data) > 0\n            and self._mode != Mode.ADD\n        ):\n            cur_colors: np.ndarray = self.edge_color\n            index = list(self.selected_data)\n            cur_colors[index] = self._current_edge_color\n            self.edge_color = cur_colors\n        self.events.current_edge_color()\n\n    @property\n    def edge_color_mode(self) -> str:\n        """"""str: Edge color setting mode\n\n        DIRECT (default mode) allows each point to be set arbitrarily\n\n        CYCLE allows the color to be set via a color cycle over an attribute\n\n        COLORMAP allows color to be set via a color map over an attribute\n        """"""\n        return str(self._edge_color_mode)\n\n    @edge_color_mode.setter\n    def edge_color_mode(self, edge_color_mode: Union[str, ColorMode]):\n        self._set_color_mode(edge_color_mode, \'edge\')\n\n    @property\n    def face_color(self) -> np.ndarray:\n        """"""(N x 4) np.ndarray: Array of RGBA face colors for each point""""""\n        return self._face_color\n\n    @face_color.setter\n    def face_color(self, face_color):\n        self._set_color(face_color, \'face\')\n\n    @property\n    def face_color_cycle(self) -> np.ndarray:\n        """"""Union[np.ndarray, cycle]:  Color cycle for face_color\n        Can be a list of colors defined by name, RGB or RGBA\n        """"""\n        return self._face_color_cycle_values\n\n    @face_color_cycle.setter\n    def face_color_cycle(self, face_color_cycle: Union[np.ndarray, cycle]):\n        self._set_color_cycle(face_color_cycle, \'face\')\n\n    @property\n    def face_colormap(self) -> Tuple[str, Colormap]:\n        """"""Return the colormap to be applied to a property to get the edge color.\n\n        Returns\n        -------\n        colormap_name : str\n            The name of the current colormap.\n        colormap : vispy.color.Colormap\n            The vispy colormap object.\n        """"""\n        return self._face_colormap_name, self._face_colormap\n\n    @face_colormap.setter\n    def face_colormap(self, colormap: ValidColormapArg):\n        name, cmap = ensure_colormap_tuple(colormap)\n        self._face_colormap_name = name\n        self._face_colormap = cmap\n\n    @property\n    def face_contrast_limits(self) -> Union[None, Tuple[float, float]]:\n        """"""None, (float, float) : clims for mapping the face_color\n        colormap property to 0 and 1\n        """"""\n        return self._face_contrast_limits\n\n    @face_contrast_limits.setter\n    def face_contrast_limits(\n        self, contrast_limits: Union[None, Tuple[float, float]]\n    ):\n        self._face_contrast_limits = contrast_limits\n\n    @property\n    def current_face_color(self) -> str:\n        """"""Face color of marker for the next added point or the selected point(s).""""""\n        hex_ = rgb_to_hex(self._current_face_color)[0]\n        return hex_to_name.get(hex_, hex_)\n\n    @current_face_color.setter\n    def current_face_color(self, face_color: ColorType) -> None:\n        self._current_face_color = transform_color(face_color)\n        if (\n            self._update_properties\n            and len(self.selected_data) > 0\n            and self._mode != Mode.ADD\n        ):\n            cur_colors: np.ndarray = self.face_color\n            index = list(self.selected_data)\n            cur_colors[index] = self._current_face_color\n            self.face_color = cur_colors\n\n        self.events.current_face_color()\n\n    @property\n    def face_color_mode(self) -> str:\n        """"""str: Face color setting mode\n\n        DIRECT (default mode) allows each point to be set arbitrarily\n\n        CYCLE allows the color to be set via a color cycle over an attribute\n\n        COLORMAP allows color to be set via a color map over an attribute\n        """"""\n        return str(self._face_color_mode)\n\n    @face_color_mode.setter\n    def face_color_mode(self, face_color_mode):\n        self._set_color_mode(face_color_mode, \'face\')\n\n    def _set_color_mode(\n        self, color_mode: Union[ColorMode, str], attribute: str\n    ):\n        """""" Set the face_color_mode or edge_color_mode property\n\n        Parameters\n        ----------\n        color_mode : str, ColorMode\n            The value for setting edge or face_color_mode. If color_mode is a string,\n            it should be one of: \'direct\', \'cycle\', or \'colormap\'\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_colo_moder or \'face\' for face_color_mode.\n        """"""\n        color_mode = ColorMode(color_mode)\n\n        if color_mode == ColorMode.DIRECT:\n            setattr(self, f\'_{attribute}_color_mode\', color_mode)\n        elif color_mode in (ColorMode.CYCLE, ColorMode.COLORMAP):\n            color_property = getattr(self, f\'_{attribute}_color_property\')\n            if color_property == \'\':\n                if self.properties:\n                    new_color_property = next(iter(self.properties))\n                    setattr(\n                        self,\n                        f\'_{attribute}_color_property\',\n                        new_color_property,\n                    )\n                    warnings.warn(\n                        \'_{attribute}_color_property was not set, setting to: {new_color_property}\'\n                    )\n                else:\n                    raise ValueError(\n                        \'There must be a valid Points.properties to use {color_mode}\'\n                    )\n\n            # ColorMode.COLORMAP can only be applied to numeric properties\n            color_property = getattr(self, f\'_{attribute}_color_property\')\n            if (color_mode == ColorMode.COLORMAP) and not issubclass(\n                self.properties[color_property].dtype.type, np.number\n            ):\n                raise TypeError(\n                    \'selected property must be numeric to use ColorMode.COLORMAP\'\n                )\n            setattr(self, f\'_{attribute}_color_mode\', color_mode)\n            self.refresh_colors()\n\n    def _set_color(self, color: ColorType, attribute: str):\n        """""" Set the face_color or edge_color property\n\n        Parameters\n        ----------\n        color : (N, 4) array or str\n            The value for setting edge or face_color\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        """"""\n        # if the provided color is a string, first check if it is a key in the properties.\n        # otherwise, assume it is the name of a color\n        if self._is_color_mapped(color):\n            if guess_continuous(self.properties[color]):\n                setattr(self, f\'_{attribute}_color_mode\', ColorMode.COLORMAP)\n            else:\n                setattr(self, f\'_{attribute}_color_mode\', ColorMode.CYCLE)\n            setattr(self, f\'_{attribute}_color_property\', color)\n            self.refresh_colors()\n\n        else:\n            transformed_color = transform_color_with_defaults(\n                num_entries=len(self.data),\n                colors=color,\n                elem_name=""face_color"",\n                default=""white"",\n            )\n            colors = normalize_and_broadcast_colors(\n                len(self.data), transformed_color\n            )\n            setattr(self, f\'_{attribute}_color\', colors)\n            setattr(self, f\'_{attribute}_color_mode\', ColorMode.DIRECT)\n\n            color_event = getattr(self.events, f\'{attribute}_color\')\n            color_event()\n\n    def _set_color_cycle(self, color_cycle: np.ndarray, attribute: str):\n        """""" Set the face_color_cycle or edge_color_cycle property\n\n        Parameters\n        ----------\n        color_cycle : (N, 4) or (N, 1) array\n            The value for setting edge or face_color_cycle\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        """"""\n        transformed_color_cycle, transformed_colors = transform_color_cycle(\n            color_cycle=color_cycle,\n            elem_name=f\'{attribute}_color_cycle\',\n            default=""white"",\n        )\n        setattr(self, f\'_{attribute}_color_cycle_values\', transformed_colors)\n        setattr(self, f\'_{attribute}_color_cycle\', transformed_color_cycle)\n        color_mode = getattr(self, f\'_{attribute}_color_mode\')\n        if color_mode == ColorMode.CYCLE:\n            self.refresh_colors(update_color_mapping=True)\n\n    def refresh_colors(self, update_color_mapping: bool = False):\n        """"""Calculate and update face and edge colors if using a cycle or color map\n\n        Parameters\n        ----------\n        update_color_mapping : bool\n            If set to True, the function will recalculate the color cycle map\n            or colormap (whichever is being used). If set to False, the function\n            will use the current color cycle map or color map. For example, if you\n            are adding/modifying points and want them to be colored with the same\n            mapping as the other points (i.e., the new points shouldn\'t affect\n            the color cycle map or colormap), set update_color_mapping=False.\n            Default value is False.\n        """"""\n\n        self._refresh_color(\'face\', update_color_mapping)\n        self._refresh_color(\'edge\', update_color_mapping)\n\n    def _refresh_color(self, attribute, update_color_mapping: bool = False):\n        """"""Calculate and update face or edge colors if using a cycle or color map\n\n        Parameters\n        ----------\n        attribute : str  in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        update_color_mapping : bool\n            If set to True, the function will recalculate the color cycle map\n            or colormap (whichever is being used). If set to False, the function\n            will use the current color cycle map or color map. For example, if you\n            are adding/modifying points and want them to be colored with the same\n            mapping as the other points (i.e., the new points shouldn\'t affect\n            the color cycle map or colormap), set update_color_mapping=False.\n            Default value is False.\n        """"""\n        if self._update_properties:\n            color_mode = getattr(self, f\'_{attribute}_color_mode\')\n            if color_mode == ColorMode.CYCLE:\n                color_property = getattr(self, f\'_{attribute}_color_property\')\n                color_properties = self.properties[color_property]\n                if update_color_mapping:\n                    color_cycle = getattr(self, f\'_{attribute}_color_cycle\')\n                    color_cycle_map = {\n                        k: np.squeeze(transform_color(c))\n                        for k, c in zip(\n                            np.unique(color_properties), color_cycle\n                        )\n                    }\n                    setattr(\n                        self, f\'{attribute}_color_cycle_map\', color_cycle_map\n                    )\n\n                else:\n                    # add properties if they are not in the colormap\n                    # and update_color_mapping==False\n                    color_cycle_map = getattr(\n                        self, f\'{attribute}_color_cycle_map\'\n                    )\n                    color_cycle_keys = [*color_cycle_map]\n                    props_in_map = np.in1d(color_properties, color_cycle_keys)\n                    if not np.all(props_in_map):\n                        props_to_add = np.unique(\n                            color_properties[np.logical_not(props_in_map)]\n                        )\n                        color_cycle = getattr(\n                            self, f\'_{attribute}_color_cycle\'\n                        )\n                        for prop in props_to_add:\n                            color_cycle_map[prop] = np.squeeze(\n                                transform_color(next(color_cycle))\n                            )\n                        setattr(\n                            self,\n                            f\'{attribute}_color_cycle_map\',\n                            color_cycle_map,\n                        )\n                colors = np.array(\n                    [color_cycle_map[x] for x in color_properties]\n                )\n                if len(colors) == 0:\n                    colors = np.empty((0, 4))\n                setattr(self, f\'_{attribute}_color\', colors)\n\n            elif color_mode == ColorMode.COLORMAP:\n                color_property = getattr(self, f\'_{attribute}_color_property\')\n                color_properties = self.properties[color_property]\n                if len(color_properties) > 0:\n                    contrast_limits = getattr(\n                        self, f\'{attribute}_contrast_limits\'\n                    )\n                    colormap = getattr(self, f\'{attribute}_colormap\')\n                    if update_color_mapping or contrast_limits is None:\n\n                        colors, contrast_limits = map_property(\n                            prop=color_properties, colormap=colormap[1]\n                        )\n                        setattr(\n                            self,\n                            f\'{attribute}_contrast_limits\',\n                            contrast_limits,\n                        )\n                    else:\n\n                        colors, _ = map_property(\n                            prop=color_properties,\n                            colormap=colormap[1],\n                            contrast_limits=contrast_limits,\n                        )\n                else:\n                    colors = np.empty((0, 4))\n                setattr(self, f\'_{attribute}_color\', colors)\n\n            color_event = getattr(self.events, f\'{attribute}_color\')\n            color_event()\n\n    def _is_color_mapped(self, color):\n        """""" determines if the new color argument is for directly setting or cycle/colormap""""""\n        if isinstance(color, str):\n            if color in self.properties:\n                return True\n            else:\n                return False\n        elif isinstance(color, (list, np.ndarray)):\n            return False\n        else:\n            raise ValueError(\n                \'face_color should be the name of a color, an array of colors, or the name of an property\'\n            )\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'symbol\': self.symbol,\n                \'edge_width\': self.edge_width,\n                \'face_color\': self.face_color,\n                \'face_color_cycle\': self.face_color_cycle,\n                \'face_colormap\': self.face_colormap[0],\n                \'face_contrast_limits\': self.face_contrast_limits,\n                \'edge_color\': self.edge_color,\n                \'edge_color_cycle\': self.edge_color_cycle,\n                \'edge_colormap\': self.edge_colormap[0],\n                \'edge_contrast_limits\': self.edge_contrast_limits,\n                \'properties\': self.properties,\n                \'n_dimensional\': self.n_dimensional,\n                \'size\': self.size,\n                \'data\': self.data,\n            }\n        )\n        return state\n\n    @property\n    def selected_data(self) -> set:\n        """"""set: set of currently selected points.""""""\n        return self._selected_data\n\n    @selected_data.setter\n    def selected_data(self, selected_data):\n        self._selected_data = set(selected_data)\n        selected = []\n        for c in self._selected_data:\n            if c in self._indices_view:\n                ind = list(self._indices_view).index(c)\n                selected.append(ind)\n        self._selected_view = selected\n\n        # Update properties based on selected points\n        if len(self._selected_data) == 0:\n            self._set_highlight()\n            return\n        index = list(self._selected_data)\n        edge_colors = np.unique(self.edge_color[index], axis=0)\n        if len(edge_colors) == 1:\n            edge_color = edge_colors[0]\n            with self.block_update_properties():\n                self.current_edge_color = edge_color\n\n        face_colors = np.unique(self.face_color[index], axis=0)\n        if len(face_colors) == 1:\n            face_color = face_colors[0]\n            with self.block_update_properties():\n                self.current_face_color = face_color\n\n        size = list(\n            set([self.size[i, self.dims.displayed].mean() for i in index])\n        )\n        if len(size) == 1:\n            size = size[0]\n            with self.block_update_properties():\n                self.current_size = size\n\n        properties = {\n            k: np.unique(v[index], axis=0) for k, v in self.properties.items()\n        }\n        n_unique_properties = np.array([len(v) for v in properties.values()])\n        if np.all(n_unique_properties == 1):\n            with self.block_update_properties():\n                self.current_properties = properties\n        self._set_highlight()\n\n    def interaction_box(self, index) -> np.ndarray:\n        """"""Create the interaction box around a list of points in view.\n\n        Parameters\n        ----------\n        index : list\n            List of points around which to construct the interaction box.\n\n        Returns\n        ----------\n        box : np.ndarray\n            4x2 array of corners of the interaction box in clockwise order\n            starting in the upper-left corner.\n        """"""\n        if len(index) == 0:\n            box = None\n        else:\n            data = self._view_data[index]\n            size = self._view_size[index]\n            data = points_to_squares(data, size)\n            box = create_box(data)\n\n        return box\n\n    @property\n    def mode(self) -> str:\n        """"""str: Interactive mode\n\n        Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        In ADD mode clicks of the cursor add points at the clicked location.\n\n        In SELECT mode the cursor can select points by clicking on them or\n        by dragging a box around them. Once selected points can be moved,\n        have their properties edited, or be deleted.\n        """"""\n        return str(self._mode)\n\n    @mode.setter\n    def mode(self, mode):\n        mode = Mode(mode)\n\n        if not self.editable:\n            mode = Mode.PAN_ZOOM\n\n        if mode == self._mode:\n            return\n        old_mode = self._mode\n\n        if old_mode == Mode.ADD:\n            self.mouse_drag_callbacks.remove(add)\n        elif old_mode == Mode.SELECT:\n            # add mouse drag and move callbacks\n            self.mouse_drag_callbacks.remove(select)\n            self.mouse_move_callbacks.remove(highlight)\n\n        if mode == Mode.ADD:\n            self.cursor = \'pointing\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom\'\n            self.selected_data = set()\n            self._set_highlight()\n            self.mouse_drag_callbacks.append(add)\n        elif mode == Mode.SELECT:\n            self.cursor = \'standard\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom\'\n            # add mouse drag and move callbacks\n            self.mouse_drag_callbacks.append(select)\n            self.mouse_move_callbacks.append(highlight)\n        elif mode == Mode.PAN_ZOOM:\n            self.cursor = \'standard\'\n            self.interactive = True\n            self.help = \'\'\n        else:\n            raise ValueError(""Mode not recognized"")\n\n        if not (mode == Mode.SELECT and old_mode == Mode.SELECT):\n            self._selected_data_stored = set()\n\n        self.status = str(mode)\n        self._mode = mode\n        self._set_highlight()\n\n        self.events.mode(mode=mode)\n\n    @property\n    def _view_data(self) -> np.ndarray:\n        """"""Get the coords of the points in view\n\n        Returns\n        -------\n        view_data : (N x D) np.ndarray\n            Array of coordinates for the N points in view\n        """"""\n        if len(self._indices_view) > 0:\n\n            data = self.data[np.ix_(self._indices_view, self.dims.displayed)]\n\n        else:\n            # if no points in this slice send dummy data\n            data = np.zeros((0, self.dims.ndisplay))\n\n        return data\n\n    @property\n    def _view_size(self) -> np.ndarray:\n        """"""Get the sizes of the points in view\n\n       Returns\n       -------\n       view_size : (N x D) np.ndarray\n           Array of sizes for the N points in view\n        """"""\n        if len(self._indices_view) > 0:\n            # Get the point sizes and scale for ndim display\n            sizes = (\n                self.size[\n                    np.ix_(self._indices_view, self.dims.displayed)\n                ].mean(axis=1)\n                * self._view_size_scale\n            )\n\n        else:\n            # if no points, return an empty list\n            sizes = np.array([])\n        return sizes\n\n    @property\n    def _view_face_color(self) -> np.ndarray:\n        """"""Get the face colors of the points in view\n\n        Returns\n        -------\n        view_face_color : (N x 4) np.ndarray\n            RGBA color array for the face colors of the N points in view.\n            If there are no points in view, returns array of length 0.\n        """"""\n        return self.face_color[self._indices_view]\n\n    @property\n    def _view_edge_color(self) -> np.ndarray:\n        """"""Get the edge colors of the points in view\n\n        Returns\n        -------\n        view_edge_color : (N x 4) np.ndarray\n            RGBA color array for the edge colors of the N points in view.\n            If there are no points in view, returns array of length 0.\n        """"""\n        return self.edge_color[self._indices_view]\n\n    def _set_editable(self, editable=None):\n        """"""Set editable mode based on layer properties.""""""\n        if editable is None:\n            if self.dims.ndisplay == 3:\n                self.editable = False\n            else:\n                self.editable = True\n\n        if not self.editable:\n            self.mode = Mode.PAN_ZOOM\n\n    def _slice_data(\n        self, dims_indices\n    ) -> Tuple[List[int], Union[float, np.ndarray]]:\n        """"""Determines the slice of points given the indices.\n\n        Parameters\n        ----------\n        dims_indices : sequence of int or slice\n            Indices to slice with.\n\n        Returns\n        ----------\n        slice_indices : list\n            Indices of points in the currently viewed slice.\n        scale : float, (N, ) array\n            If in `n_dimensional` mode then the scale factor of points, where\n            values of 1 corresponds to points located in the slice, and values\n            less than 1 correspond to points located in neighboring slices.\n        """"""\n        # Get a list of the data for the points in this slice\n        not_disp = list(self.dims.not_displayed)\n        indices = np.array(dims_indices)\n        if len(self.data) > 0:\n            if self.n_dimensional is True and self.ndim > 2:\n                distances = abs(self.data[:, not_disp] - indices[not_disp])\n                sizes = self.size[:, not_disp] / 2\n                matches = np.all(distances <= sizes, axis=1)\n                size_match = sizes[matches]\n                size_match[size_match == 0] = 1\n                scale_per_dim = (size_match - distances[matches]) / size_match\n                scale_per_dim[size_match == 0] = 1\n                scale = np.prod(scale_per_dim, axis=1)\n                slice_indices = np.where(matches)[0].astype(int)\n                return slice_indices, scale\n            else:\n                data = self.data[:, not_disp].astype(\'int\')\n                matches = np.all(data == indices[not_disp], axis=1)\n                slice_indices = np.where(matches)[0].astype(int)\n                return slice_indices, 1\n        else:\n            return [], []\n\n    def _get_value(self) -> Union[None, int]:\n        """"""Determine if points at current coordinates.\n\n        Returns\n        ----------\n        selection : int or None\n            Index of point that is at the current coordinate if any.\n        """"""\n        # Display points if there are any in this slice\n        if len(self._view_data) > 0:\n            # Get the point sizes\n            distances = abs(self._view_data - self.displayed_coordinates)\n            in_slice_matches = np.all(\n                distances <= np.expand_dims(self._view_size, axis=1) / 2,\n                axis=1,\n            )\n            indices = np.where(in_slice_matches)[0]\n            if len(indices) > 0:\n                selection = self._indices_view[indices[-1]]\n            else:\n                selection = None\n        else:\n            selection = None\n\n        return selection\n\n    def _set_view_slice(self):\n        """"""Sets the view given the indices to slice with.""""""\n        # get the indices of points in view\n        indices, scale = self._slice_data(self.dims.indices)\n        self._view_size_scale = scale\n        self._indices_view = indices\n        # get the selected points that are in view\n        selected = []\n        for c in self.selected_data:\n            if c in self._indices_view:\n                ind = list(self._indices_view).index(c)\n                selected.append(ind)\n        self._selected_view = selected\n        with self.events.highlight.blocker():\n            self._set_highlight(force=True)\n\n    def _set_highlight(self, force=False):\n        """"""Render highlights of shapes including boundaries, vertices,\n        interaction boxes, and the drag selection box when appropriate.\n        Highlighting only occurs in Mode.SELECT.\n\n        Parameters\n        ----------\n        force : bool\n            Bool that forces a redraw to occur when `True`\n        """"""\n        # Check if any point ids have changed since last call\n        if self.selected:\n            if (\n                self.selected_data == self._selected_data_stored\n                and self._value == self._value_stored\n                and np.all(self._drag_box == self._drag_box_stored)\n            ) and not force:\n                return\n            self._selected_data_stored = copy(self.selected_data)\n            self._value_stored = copy(self._value)\n            self._drag_box_stored = copy(self._drag_box)\n\n            if self._value is not None or len(self._selected_view) > 0:\n                if len(self._selected_view) > 0:\n                    index = copy(self._selected_view)\n                    # highlight the hovered point if not in adding mode\n                    if (\n                        self._value in self._indices_view\n                        and self._mode == Mode.SELECT\n                        and not self._is_selecting\n                    ):\n                        hover_point = list(self._indices_view).index(\n                            self._value\n                        )\n                        if hover_point in index:\n                            pass\n                        else:\n                            index.append(hover_point)\n                    index.sort()\n                else:\n                    # only highlight hovered points in select mode\n                    if (\n                        self._value in self._indices_view\n                        and self._mode == Mode.SELECT\n                        and not self._is_selecting\n                    ):\n                        hover_point = list(self._indices_view).index(\n                            self._value\n                        )\n                        index = [hover_point]\n                    else:\n                        index = []\n\n                self._highlight_index = index\n            else:\n                self._highlight_index = []\n\n            # only display dragging selection box in 2D\n            if self.dims.ndisplay == 2 and self._is_selecting:\n                pos = create_box(self._drag_box)\n                pos = pos[list(range(4)) + [0]]\n            else:\n                pos = None\n\n            self._highlight_box = pos\n            self.events.highlight()\n        else:\n            self._highlight_box = None\n            self._highlight_index = []\n            self.events.highlight()\n\n    def _update_thumbnail(self):\n        """"""Update thumbnail with current points and colors.""""""\n        colormapped = np.zeros(self._thumbnail_shape)\n        colormapped[..., 3] = 1\n        if len(self._view_data) > 0:\n            min_vals = [self.dims.range[i][0] for i in self.dims.displayed]\n            shape = np.ceil(\n                [\n                    self.dims.range[i][1] - self.dims.range[i][0] + 1\n                    for i in self.dims.displayed\n                ]\n            ).astype(int)\n            zoom_factor = np.divide(\n                self._thumbnail_shape[:2], shape[-2:]\n            ).min()\n            if len(self._view_data) > self._max_points_thumbnail:\n                thumbnail_indices = np.random.randint(\n                    0, len(self._view_data), self._max_points_thumbnail\n                )\n                points = self._view_data[thumbnail_indices]\n            else:\n                points = self._view_data\n                thumbnail_indices = self._indices_view\n            coords = np.floor(\n                (points[:, -2:] - min_vals[-2:] + 0.5) * zoom_factor\n            ).astype(int)\n            coords = np.clip(\n                coords, 0, np.subtract(self._thumbnail_shape[:2], 1)\n            )\n            colors = self.face_color[thumbnail_indices]\n            colormapped[coords[:, 0], coords[:, 1]] = colors\n\n        colormapped[..., 3] *= self.opacity\n        self.thumbnail = colormapped\n\n    def add(self, coord):\n        """"""Adds point at coordinate.\n\n        Parameters\n        ----------\n        coord : sequence of indices to add point at\n        """"""\n        self.data = np.append(self.data, np.atleast_2d(coord), axis=0)\n\n    def remove_selected(self):\n        """"""Removes selected points if any.""""""\n        index = list(self.selected_data)\n        index.sort()\n        if len(index) > 0:\n            self._size = np.delete(self._size, index, axis=0)\n            self._edge_color = np.delete(self.edge_color, index, axis=0)\n            self._face_color = np.delete(self.face_color, index, axis=0)\n            for k in self.properties:\n                self.properties[k] = np.delete(\n                    self.properties[k], index, axis=0\n                )\n            if self._value in self.selected_data:\n                self._value = None\n            self.selected_data = set()\n            self.data = np.delete(self.data, index, axis=0)\n\n    def _move(self, index, coord):\n        """"""Moves points relative drag start location.\n\n        Parameters\n        ----------\n        index : list\n            Integer indices of points to move\n        coord : tuple\n            Coordinates to move points to\n        """"""\n        if len(index) > 0:\n            index = list(index)\n            disp = list(self.dims.displayed)\n            if self._drag_start is None:\n                center = self.data[np.ix_(index, disp)].mean(axis=0)\n                self._drag_start = np.array(coord)[disp] - center\n            center = self.data[np.ix_(index, disp)].mean(axis=0)\n            shift = np.array(coord)[disp] - center - self._drag_start\n            self.data[np.ix_(index, disp)] = (\n                self.data[np.ix_(index, disp)] + shift\n            )\n            self.refresh()\n\n    def _paste_data(self):\n        """"""Paste any point from clipboard and select them.""""""\n        npoints = len(self._view_data)\n        totpoints = len(self.data)\n\n        if len(self._clipboard.keys()) > 0:\n            not_disp = self.dims.not_displayed\n            data = deepcopy(self._clipboard[\'data\'])\n            offset = [\n                self.dims.indices[i] - self._clipboard[\'indices\'][i]\n                for i in not_disp\n            ]\n            data[:, not_disp] = data[:, not_disp] + np.array(offset)\n            self._data = np.append(self.data, data, axis=0)\n            self._size = np.append(\n                self.size, deepcopy(self._clipboard[\'size\']), axis=0\n            )\n            self._edge_color = np.vstack(\n                (\n                    self.edge_color,\n                    transform_color(deepcopy(self._clipboard[\'edge_color\'])),\n                )\n            )\n            self._face_color = np.vstack(\n                (\n                    self.face_color,\n                    transform_color(deepcopy(self._clipboard[\'face_color\'])),\n                )\n            )\n            for k in self.properties:\n                self.properties[k] = np.concatenate(\n                    (self.properties[k], self._clipboard[\'properties\'][k]),\n                    axis=0,\n                )\n            self._selected_view = list(\n                range(npoints, npoints + len(self._clipboard[\'data\']))\n            )\n            self._selected_data = set(\n                range(totpoints, totpoints + len(self._clipboard[\'data\']))\n            )\n            self.refresh()\n\n    def _copy_data(self):\n        """"""Copy selected points to clipboard.""""""\n        if len(self.selected_data) > 0:\n            index = list(self.selected_data)\n            self._clipboard = {\n                \'data\': deepcopy(self.data[index]),\n                \'edge_color\': deepcopy(self.edge_color[index]),\n                \'face_color\': deepcopy(self.face_color[index]),\n                \'size\': deepcopy(self.size[index]),\n                \'properties\': {\n                    k: deepcopy(v[index]) for k, v in self.properties.items()\n                },\n                \'indices\': self.dims.indices,\n            }\n        else:\n            self._clipboard = {}\n'"
napari/layers/shapes/__init__.py,0,"b'from .shapes import Shapes\nfrom . import _shapes_key_bindings\n\n# Note that importing _shapes_key_bindings is needed as the Shapes layer gets\n# decorated with keybindings during that process, but it is not directly needed\n# by our users and so is deleted below\ndel _shapes_key_bindings\n'"
napari/layers/shapes/_mesh.py,19,"b'import numpy as np\n\n\nclass Mesh:\n    """"""Contains meshses of shapes that will ultimately get rendered.\n\n    Parameters\n    ----------\n    ndisplay : int\n        Number of displayed dimensions.\n\n    Attributes\n    ----------\n    ndisplay : int\n        Number of displayed dimensions.\n    vertices : np.ndarray\n         Qx2 array of vertices of all triangles for shapes including edges and\n         faces\n    vertices_centers : np.ndarray\n         Qx2 array of centers of vertices of triangles for shapes. For vertices\n         corresponding to faces these are the same as the actual vertices. For\n         vertices corresponding to edges these values should be added to a\n         scaled `vertices_offsets` to get the actual vertex positions.\n         The scaling corresponds to the width of the edge\n    vertices_offsets : np.ndarray\n         Qx2 array of offsets of vertices of triangles for shapes. For vertices\n         corresponding to faces these are 0. For vertices corresponding to\n         edges these values should be scaled and added to the\n         `vertices_centers` to get the actual vertex positions.\n         The scaling corresponds to the width of the edge\n    vertices_index : np.ndarray\n         Qx2 array of the index (0, ..., N-1) of each shape that each vertex\n         corresponds and the mesh type (0, 1) for face or edge.\n    triangles : np.ndarray\n        Px3 array of vertex indices that form the mesh triangles\n    triangles_index : np.ndarray\n        Px2 array of  the index (0, ..., N-1) of each shape that each triangle\n        corresponds and the mesh type (0, 1) for face or edge.\n    triangles_colors : np.ndarray\n        Px4 array of the rgba color of each triangle\n    triangles_z_order : np.ndarray\n        Length P array of the z order of each triangle. Must be a permutation\n        of (0, ..., P-1)\n\n    Extended Summary\n    ----------\n    _types : list\n        Length two list of the different mesh types corresponding to faces and\n        edges\n    """"""\n\n    _types = [\'face\', \'edge\']\n\n    def __init__(self, ndisplay=2):\n\n        self._ndisplay = ndisplay\n        self.clear()\n\n    def clear(self):\n        """"""Resets mesh data\n        """"""\n        self.vertices = np.empty((0, self.ndisplay))\n        self.vertices_centers = np.empty((0, self.ndisplay))\n        self.vertices_offsets = np.empty((0, self.ndisplay))\n        self.vertices_index = np.empty((0, 2), dtype=int)\n        self.triangles = np.empty((0, 3), dtype=np.uint32)\n        self.triangles_index = np.empty((0, 2), dtype=int)\n        self.triangles_colors = np.empty((0, 4))\n        self.triangles_z_order = np.empty((0), dtype=int)\n\n        self.displayed_triangles = np.empty((0, 3), dtype=np.uint32)\n        self.displayed_triangles_index = np.empty((0, 2), dtype=int)\n        self.displayed_triangles_colors = np.empty((0, 4))\n\n    @property\n    def ndisplay(self):\n        """"""int: Number of displayed dimensions.""""""\n        return self._ndisplay\n\n    @ndisplay.setter\n    def ndisplay(self, ndisplay):\n        if self.ndisplay == ndisplay:\n            return\n\n        self._ndisplay = ndisplay\n        self.clear()\n'"
napari/layers/shapes/_shape_list.py,94,"b'import numpy as np\nfrom ._mesh import Mesh\nfrom ._shapes_models import Shape, Line, Path\nfrom ._shapes_utils import inside_triangles, triangles_intersect_box\nfrom ._shapes_constants import shape_classes, ShapeType\n\n\nclass ShapeList:\n    """"""List of shapes class.\n\n    Parameters\n    ----------\n    data : list\n        List of Shape objects\n    ndisplay : int\n        Number of displayed dimensions.\n\n    Attributes\n    ----------\n    shapes : (N, ) list\n        Shape objects.\n    data : (N, ) list of (M, D) array\n        Data arrays for each shape.\n    ndisplay : int\n        Number of displayed dimensions.\n    slice_keys : (N, 2, P) array\n        Array of slice keys for each shape. Each slice key has the min and max\n        values of the P non-displayed dimensions, useful for slicing\n        multidimensional shapes. If the both min and max values of shape are\n        equal then the shape is entirely contained within the slice specified\n        by those values.\n    shape_types : (N, ) list of str\n        Name of shape type for each shape.\n    edge_color : (N x 4) np.ndarray\n        Array of RGBA edge colors for each shape.\n    face_color : (N x 4) np.ndarray\n        Array of RGBA face colors for each shape.\n    edge_widths : (N, ) list of float\n        Edge width for each shape.\n    z_indices : (N, ) list of int\n        z-index for each shape.\n\n    Extended Summary\n    ----------\n    _vertices : np.ndarray\n        Mx2 array of all displayed vertices from all shapes\n    _index : np.ndarray\n        Length M array with the index (0, ..., N-1) of each shape that each\n        vertex corresponds to\n    _z_index : np.ndarray\n        Length N array with z_index of each shape\n    _z_order : np.ndarray\n        Length N array with z_order of each shape. This must be a permutation\n        of (0, ..., N-1).\n    _mesh : Mesh\n        Mesh object containing all the mesh information that will ultimately\n        be rendered.\n    """"""\n\n    def __init__(self, data=[], ndisplay=2):\n\n        self._ndisplay = ndisplay\n        self.shapes = []\n        self._displayed = []\n        self._slice_key = []\n        self.displayed_vertices = []\n        self.displayed_index = []\n        self._vertices = np.empty((0, self.ndisplay))\n        self._index = np.empty((0), dtype=int)\n        self._z_index = np.empty((0), dtype=int)\n        self._z_order = np.empty((0), dtype=int)\n\n        self._mesh = Mesh(ndisplay=self.ndisplay)\n\n        self._edge_color = np.empty((0, 4))\n        self._face_color = np.empty((0, 4))\n\n        for d in data:\n            self.add(d)\n\n    @property\n    def data(self):\n        """"""list of (M, D) array: data arrays for each shape.""""""\n        return [s.data for s in self.shapes]\n\n    @property\n    def ndisplay(self):\n        """"""int: Number of displayed dimensions.""""""\n        return self._ndisplay\n\n    @ndisplay.setter\n    def ndisplay(self, ndisplay):\n        if self.ndisplay == ndisplay:\n            return\n\n        self._ndisplay = ndisplay\n        self._mesh.ndisplay = self.ndisplay\n        self._vertices = np.empty((0, self.ndisplay))\n        self._index = np.empty((0), dtype=int)\n        for index in range(len(self.shapes)):\n            shape = self.shapes[index]\n            shape.ndisplay = self.ndisplay\n            self.remove(index, renumber=False)\n            self.add(shape, shape_index=index)\n        self._update_z_order()\n\n    @property\n    def slice_keys(self):\n        """"""(N, 2, P) array: slice key for each shape.""""""\n        return np.array([s.slice_key for s in self.shapes])\n\n    @property\n    def shape_types(self):\n        """"""list of str: shape types for each shape.""""""\n        return [s.name for s in self.shapes]\n\n    @property\n    def edge_color(self):\n        """"""(N x 4) np.ndarray: Array of RGBA edge colors for each shape""""""\n        return self._edge_color\n\n    @edge_color.setter\n    def edge_color(self, edge_color):\n        self._set_color(edge_color, \'edge\')\n\n    @property\n    def face_color(self):\n        """"""(N x 4) np.ndarray: Array of RGBA face colors for each shape""""""\n        return self._face_color\n\n    @face_color.setter\n    def face_color(self, face_color):\n        self._set_color(face_color, \'face\')\n\n    def _set_color(self, colors, attribute):\n        """""" Set the face_color or edge_color property\n\n        Parameters\n        ----------\n        colors : (N, 4) np.ndarray\n            The value for setting edge or face_color. There must\n            be one color for each shape\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        """"""\n        n_shapes = len(self.data)\n        if not np.all(colors.shape == (n_shapes, 4)):\n            raise ValueError(\n                f\'{attribute}_color must have shape ({n_shapes}, 4)\'\n            )\n\n        update_method = getattr(self, f\'update_{attribute}_color\')\n\n        for i, col in enumerate(colors):\n            update_method(i, col, update=False)\n        self._update_displayed()\n\n    @property\n    def edge_widths(self):\n        """"""list of float: edge width for each shape.""""""\n        return [s.edge_width for s in self.shapes]\n\n    @property\n    def z_indices(self):\n        """"""list of int: z-index for each shape.""""""\n        return [s.z_index for s in self.shapes]\n\n    @property\n    def slice_key(self):\n        """"""list: slice key for slicing n-dimensional shapes.""""""\n        return self._slice_key\n\n    @slice_key.setter\n    def slice_key(self, slice_key):\n        slice_key = list(slice_key)\n        if not np.all(self._slice_key == slice_key):\n            self._slice_key = slice_key\n            self._update_displayed()\n\n    def _update_displayed(self):\n        """"""Update the displayed data based on the slice key.""""""\n        # The list slice key is repeated to check against both the min and\n        # max values stored in the shapes slice key.\n        slice_key = np.array([self.slice_key, self.slice_key])\n\n        # Slice key must exactly match mins and maxs of shape as then the\n        # shape is entirely contained within the current slice.\n        if len(self.shapes) > 0:\n            self._displayed = np.all(self.slice_keys == slice_key, axis=(1, 2))\n        else:\n            self._displayed = []\n        disp_indices = np.where(self._displayed)[0]\n\n        z_order = self._mesh.triangles_z_order\n        disp_tri = np.isin(\n            self._mesh.triangles_index[z_order, 0], disp_indices\n        )\n        self._mesh.displayed_triangles = self._mesh.triangles[z_order][\n            disp_tri\n        ]\n        self._mesh.displayed_triangles_index = self._mesh.triangles_index[\n            z_order\n        ][disp_tri]\n        self._mesh.displayed_triangles_colors = self._mesh.triangles_colors[\n            z_order\n        ][disp_tri]\n\n        disp_vert = np.isin(self._index, disp_indices)\n        self.displayed_vertices = self._vertices[disp_vert]\n        self.displayed_index = self._index[disp_vert]\n\n    def add(self, shape, face_color=None, edge_color=None, shape_index=None):\n        """"""Adds a single Shape object\n\n        Parameters\n        ----------\n        shape : subclass Shape\n            Must be a subclass of Shape, one of ""{\'Line\', \'Rectangle\',\n            \'Ellipse\', \'Path\', \'Polygon\'}""\n        shape_index : None | int\n            If int then edits the shape date at current index. To be used in\n            conjunction with `remove` when renumber is `False`. If None, then\n            appends a new shape to end of shapes list\n        """"""\n        if not issubclass(type(shape), Shape):\n            raise ValueError(\'shape must be subclass of Shape\')\n\n        if shape_index is None:\n            z_refresh = True\n            shape_index = len(self.shapes)\n            self.shapes.append(shape)\n            self._z_index = np.append(self._z_index, shape.z_index)\n\n            if face_color is None:\n                face_color = np.array([1, 1, 1, 1])\n            self._face_color = np.vstack([self._face_color, face_color])\n            if edge_color is None:\n                edge_color = np.array([0, 0, 0, 1])\n            self._edge_color = np.vstack([self._edge_color, edge_color])\n        else:\n            z_refresh = False\n            self.shapes[shape_index] = shape\n            self._z_index[shape_index] = shape.z_index\n\n            if face_color is None:\n                face_color = self._face_color[shape_index]\n            else:\n                self._face_color[shape_index, :] = face_color\n            if edge_color is None:\n                edge_color = self._edge_color[shape_index]\n            else:\n                self._edge_color[shape_index, :] = edge_color\n\n        self._vertices = np.append(\n            self._vertices, shape.data_displayed, axis=0\n        )\n        index = np.repeat(shape_index, len(shape.data))\n        self._index = np.append(self._index, index, axis=0)\n\n        # Add faces to mesh\n        m = len(self._mesh.vertices)\n        vertices = shape._face_vertices\n        self._mesh.vertices = np.append(self._mesh.vertices, vertices, axis=0)\n        vertices = shape._face_vertices\n        self._mesh.vertices_centers = np.append(\n            self._mesh.vertices_centers, vertices, axis=0\n        )\n        vertices = np.zeros(shape._face_vertices.shape)\n        self._mesh.vertices_offsets = np.append(\n            self._mesh.vertices_offsets, vertices, axis=0\n        )\n        index = np.repeat([[shape_index, 0]], len(vertices), axis=0)\n        self._mesh.vertices_index = np.append(\n            self._mesh.vertices_index, index, axis=0\n        )\n\n        triangles = shape._face_triangles + m\n        self._mesh.triangles = np.append(\n            self._mesh.triangles, triangles, axis=0\n        )\n        index = np.repeat([[shape_index, 0]], len(triangles), axis=0)\n        self._mesh.triangles_index = np.append(\n            self._mesh.triangles_index, index, axis=0\n        )\n        color_array = np.repeat([face_color], len(triangles), axis=0)\n        self._mesh.triangles_colors = np.append(\n            self._mesh.triangles_colors, color_array, axis=0\n        )\n\n        # Add edges to mesh\n        m = len(self._mesh.vertices)\n        vertices = (\n            shape._edge_vertices + shape.edge_width * shape._edge_offsets\n        )\n        self._mesh.vertices = np.append(self._mesh.vertices, vertices, axis=0)\n        vertices = shape._edge_vertices\n        self._mesh.vertices_centers = np.append(\n            self._mesh.vertices_centers, vertices, axis=0\n        )\n        vertices = shape._edge_offsets\n        self._mesh.vertices_offsets = np.append(\n            self._mesh.vertices_offsets, vertices, axis=0\n        )\n        index = np.repeat([[shape_index, 1]], len(vertices), axis=0)\n        self._mesh.vertices_index = np.append(\n            self._mesh.vertices_index, index, axis=0\n        )\n\n        triangles = shape._edge_triangles + m\n        self._mesh.triangles = np.append(\n            self._mesh.triangles, triangles, axis=0\n        )\n        index = np.repeat([[shape_index, 1]], len(triangles), axis=0)\n        self._mesh.triangles_index = np.append(\n            self._mesh.triangles_index, index, axis=0\n        )\n        color_array = np.repeat([edge_color], len(triangles), axis=0)\n        self._mesh.triangles_colors = np.append(\n            self._mesh.triangles_colors, color_array, axis=0\n        )\n\n        if z_refresh:\n            # Set z_order\n            self._update_z_order()\n\n    def remove_all(self):\n        """"""Removes all shapes\n        """"""\n        self.shapes = []\n        self._vertices = np.empty((0, self.ndisplay))\n        self._index = np.empty((0), dtype=int)\n        self._z_index = np.empty((0), dtype=int)\n        self._z_order = np.empty((0), dtype=int)\n        self._mesh.clear()\n        self._update_displayed()\n\n    def remove(self, index, renumber=True):\n        """"""Removes a single shape located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be removed.\n        renumber : bool\n            Bool to indicate whether to renumber all shapes or not. If not the\n            expectation is that this shape is being immediately readded to the\n            list using `add_shape`.\n        """"""\n        indices = self._index != index\n        self._vertices = self._vertices[indices]\n        self._index = self._index[indices]\n\n        # Remove triangles\n        indices = self._mesh.triangles_index[:, 0] != index\n        self._mesh.triangles = self._mesh.triangles[indices]\n        self._mesh.triangles_colors = self._mesh.triangles_colors[indices]\n        self._mesh.triangles_index = self._mesh.triangles_index[indices]\n\n        # Remove vertices\n        indices = self._mesh.vertices_index[:, 0] != index\n        self._mesh.vertices = self._mesh.vertices[indices]\n        self._mesh.vertices_centers = self._mesh.vertices_centers[indices]\n        self._mesh.vertices_offsets = self._mesh.vertices_offsets[indices]\n        self._mesh.vertices_index = self._mesh.vertices_index[indices]\n        indices = np.where(np.invert(indices))[0]\n        num_indices = len(indices)\n        if num_indices > 0:\n            indices = self._mesh.triangles > indices[0]\n            self._mesh.triangles[indices] = (\n                self._mesh.triangles[indices] - num_indices\n            )\n\n        if renumber:\n            del self.shapes[index]\n            indices = self._index > index\n            self._index[indices] = self._index[indices] - 1\n            self._z_index = np.delete(self._z_index, index)\n            indices = self._mesh.triangles_index[:, 0] > index\n            self._mesh.triangles_index[indices, 0] = (\n                self._mesh.triangles_index[indices, 0] - 1\n            )\n            indices = self._mesh.vertices_index[:, 0] > index\n            self._mesh.vertices_index[indices, 0] = (\n                self._mesh.vertices_index[indices, 0] - 1\n            )\n            self._update_z_order()\n\n    def _update_mesh_vertices(self, index, edge=False, face=False):\n        """"""Updates the mesh vertex data and vertex data for a single shape\n        located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        edge : bool\n            Bool to indicate whether to update mesh vertices corresponding to\n            edges\n        face : bool\n            Bool to indicate whether to update mesh vertices corresponding to\n            faces and to update the underlying shape vertices\n        """"""\n        shape = self.shapes[index]\n        if edge:\n            indices = np.all(self._mesh.vertices_index == [index, 1], axis=1)\n            self._mesh.vertices[indices] = (\n                shape._edge_vertices + shape.edge_width * shape._edge_offsets\n            )\n            self._mesh.vertices_centers[indices] = shape._edge_vertices\n            self._mesh.vertices_offsets[indices] = shape._edge_offsets\n            self._update_displayed()\n\n        if face:\n            indices = np.all(self._mesh.vertices_index == [index, 0], axis=1)\n            self._mesh.vertices[indices] = shape._face_vertices\n            self._mesh.vertices_centers[indices] = shape._face_vertices\n            indices = self._index == index\n            self._vertices[indices] = shape.data_displayed\n            self._update_displayed()\n\n    def _update_z_order(self):\n        """"""Updates the z order of the triangles given the z_index list\n        """"""\n        self._z_order = np.argsort(self._z_index)\n        if len(self._z_order) == 0:\n            self._mesh.triangles_z_order = np.empty((0), dtype=int)\n        else:\n            _, idx, counts = np.unique(\n                self._mesh.triangles_index[:, 0],\n                return_index=True,\n                return_counts=True,\n            )\n            triangles_z_order = [\n                np.arange(idx[z], idx[z] + counts[z]) for z in self._z_order\n            ]\n            self._mesh.triangles_z_order = np.concatenate(triangles_z_order)\n        self._update_displayed()\n\n    def edit(\n        self, index, data, face_color=None, edge_color=None, new_type=None\n    ):\n        """"""Updates the data of a single shape located at index. If\n        `new_type` is not None then converts the shape type to the new type\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        data : np.ndarray\n            NxD array of vertices.\n        new_type: None | str | Shape\n            If string , must be one of ""{\'line\', \'rectangle\', \'ellipse\',\n            \'path\', \'polygon\'}"".\n        """"""\n        if new_type is not None:\n            cur_shape = self.shapes[index]\n            if type(new_type) == str:\n                shape_type = ShapeType(new_type)\n                if shape_type in shape_classes.keys():\n                    shape_cls = shape_classes[shape_type]\n                else:\n                    raise ValueError(\n                        f\'{shape_type} must be one of {set(shape_classes)}\'\n                    )\n            else:\n                shape_cls = new_type\n            shape = shape_cls(\n                data,\n                edge_width=cur_shape.edge_width,\n                z_index=cur_shape.z_index,\n                dims_order=cur_shape.dims_order,\n            )\n        else:\n            shape = self.shapes[index]\n            shape.data = data\n\n        if face_color is not None:\n            self._face_color[index] = face_color\n        if edge_color is not None:\n            self._edge_color[index] = edge_color\n\n        self.remove(index, renumber=False)\n        self.add(shape, shape_index=index)\n        self._update_z_order()\n\n    def update_edge_width(self, index, edge_width):\n        """"""Updates the edge width of a single shape located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        edge_width : float\n            thickness of lines and edges.\n        """"""\n        self.shapes[index].edge_width = edge_width\n        self._update_mesh_vertices(index, edge=True)\n\n    def update_edge_color(self, index, edge_color, update=True):\n        """"""Updates the edge color of a single shape located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        edge_color : str | tuple\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements.\n        update : bool\n            If True, update the mesh with the new color property. Set to False to avoid\n            repeated updates when modifying multiple shapes. Default is True.\n        """"""\n        self._edge_color[index] = edge_color\n        indices = np.all(self._mesh.triangles_index == [index, 1], axis=1)\n        self._mesh.triangles_colors[indices] = self._edge_color[index]\n        if update:\n            self._update_displayed()\n\n    def update_face_color(self, index, face_color, update=True):\n        """"""Updates the face color of a single shape located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        face_color : str | tuple\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements.\n        update : bool\n            If True, update the mesh with the new color property. Set to False to avoid\n            repeated updates when modifying multiple shapes. Default is True.\n        """"""\n        self._face_color[index] = face_color\n        indices = np.all(self._mesh.triangles_index == [index, 0], axis=1)\n        self._mesh.triangles_colors[indices] = self._face_color[index]\n        if update:\n            self._update_displayed()\n\n    def update_dims_order(self, dims_order):\n        """"""Updates dimensions order for all shapes.\n\n        Parameters\n        ----------\n        dims_order : (D,) list\n            Order that the dimensions are rendered in.\n        """"""\n        for index in range(len(self.shapes)):\n            if not self.shapes[index].dims_order == dims_order:\n                shape = self.shapes[index]\n                shape.dims_order = dims_order\n                self.remove(index, renumber=False)\n                self.add(shape, shape_index=index)\n        self._update_z_order()\n\n    def update_z_index(self, index, z_index):\n        """"""Updates the z order of a single shape located at index.\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        z_index : int\n            Specifier of z order priority. Shapes with higher z order are\n            displayed ontop of others.\n        """"""\n        self.shapes[index].z_index = z_index\n        self._z_index[index] = z_index\n        self._update_z_order()\n\n    def shift(self, index, shift):\n        """"""Perfroms a 2D shift on a single shape located at index\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        shift : np.ndarray\n            length 2 array specifying shift of shapes.\n        """"""\n        self.shapes[index].shift(shift)\n        self._update_mesh_vertices(index, edge=True, face=True)\n\n    def scale(self, index, scale, center=None):\n        """"""Perfroms a scaling on a single shape located at index\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        scale : float, list\n            scalar or list specifying rescaling of shape.\n        center : list\n            length 2 list specifying coordinate of center of scaling.\n        """"""\n        self.shapes[index].scale(scale, center=center)\n        shape = self.shapes[index]\n        self.remove(index, renumber=False)\n        self.add(shape, shape_index=index)\n        self._update_z_order()\n\n    def rotate(self, index, angle, center=None):\n        """"""Perfroms a rotation on a single shape located at index\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        angle : float\n            angle specifying rotation of shape in degrees.\n        center : list\n            length 2 list specifying coordinate of center of rotation.\n        """"""\n        self.shapes[index].rotate(angle, center=center)\n        self._update_mesh_vertices(index, edge=True, face=True)\n\n    def flip(self, index, axis, center=None):\n        """"""Perfroms an vertical flip on a single shape located at index\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        axis : int\n            integer specifying axis of flip. `0` flips horizontal, `1` flips\n            vertical.\n        center : list\n            length 2 list specifying coordinate of center of flip axes.\n        """"""\n        self.shapes[index].flip(axis, center=center)\n        self._update_mesh_vertices(index, edge=True, face=True)\n\n    def transform(self, index, transform):\n        """"""Perfroms a linear transform on a single shape located at index\n\n        Parameters\n        ----------\n        index : int\n            Location in list of the shape to be changed.\n        transform : np.ndarray\n            2x2 array specifying linear transform.\n        """"""\n        self.shapes[index].transform(transform)\n        shape = self.shapes[index]\n        self.remove(index, renumber=False)\n        self.add(shape, shape_index=index)\n        self._update_z_order()\n\n    def outline(self, indices):\n        """"""Finds outlines of shapes listed in indices\n\n        Parameters\n        ----------\n        indices : int | list\n            Location in list of the shapes to be outline. If list must be a\n            list of int\n\n        Returns\n        ----------\n        centers :np.ndarray\n            Nx2 array of centers of outline\n        offsets :np.ndarray\n            Nx2 array of offsets of outline\n        triangles : np.ndarray\n            Mx3 array of any indices of vertices for triangles of outline\n        """"""\n        if type(indices) is list:\n            meshes = self._mesh.triangles_index\n            triangle_indices = [\n                i\n                for i, x in enumerate(meshes)\n                if x[0] in indices and x[1] == 1\n            ]\n            meshes = self._mesh.vertices_index\n            vertices_indices = [\n                i\n                for i, x in enumerate(meshes)\n                if x[0] in indices and x[1] == 1\n            ]\n        else:\n            triangle_indices = np.all(\n                self._mesh.triangles_index == [indices, 1], axis=1\n            )\n            triangle_indices = np.where(triangle_indices)[0]\n            vertices_indices = np.all(\n                self._mesh.vertices_index == [indices, 1], axis=1\n            )\n            vertices_indices = np.where(vertices_indices)[0]\n\n        offsets = self._mesh.vertices_offsets[vertices_indices]\n        centers = self._mesh.vertices_centers[vertices_indices]\n        triangles = self._mesh.triangles[triangle_indices]\n\n        if type(indices) is list:\n            t_ind = self._mesh.triangles_index[triangle_indices][:, 0]\n            inds = self._mesh.vertices_index[vertices_indices][:, 0]\n            starts = np.unique(inds, return_index=True)[1]\n            for i, ind in enumerate(indices):\n                inds = t_ind == ind\n                adjust_index = starts[i] - vertices_indices[starts[i]]\n                triangles[inds] = triangles[inds] + adjust_index\n        else:\n            triangles = triangles - vertices_indices[0]\n\n        return centers, offsets, triangles\n\n    def shapes_in_box(self, corners):\n        """"""Determines which shapes, if any, are inside an axis aligned box.\n\n        Looks only at displayed shapes\n\n        Parameters\n        ----------\n        corners : np.ndarray\n            2x2 array of two corners that will be used to create an axis\n            aligned box.\n\n        Returns\n        ----------\n        shapes : list\n            List of shapes that are inside the box.\n        """"""\n\n        triangles = self._mesh.vertices[self._mesh.displayed_triangles]\n        intersects = triangles_intersect_box(triangles, corners)\n        shapes = self._mesh.displayed_triangles_index[intersects, 0]\n        shapes = np.unique(shapes).tolist()\n\n        return shapes\n\n    def inside(self, coord):\n        """"""Determines if any shape at given coord by looking inside triangle\n        meshes. Looks only at displayed shapes\n\n        Parameters\n        ----------\n        coord : sequence of float\n            Image coordinates to check if any shapes are at.\n\n        Returns\n        ----------\n        shape : int | None\n            Index of shape if any that is at the coordinates. Returns `None`\n            if no shape is found.\n        """"""\n        triangles = self._mesh.vertices[self._mesh.displayed_triangles]\n        indices = inside_triangles(triangles - coord)\n        shapes = self._mesh.displayed_triangles_index[indices, 0]\n\n        if len(shapes) > 0:\n            z_list = self._z_order.tolist()\n            order_indices = np.array([z_list.index(m) for m in shapes])\n            ordered_shapes = shapes[np.argsort(order_indices)]\n            return ordered_shapes[0]\n        else:\n            return None\n\n    def to_masks(self, mask_shape=None, zoom_factor=1, offset=[0, 0]):\n        """"""Returns N binary masks, one for each shape, embedded in an array of\n        shape `mask_shape`.\n\n        Parameters\n        ----------\n        mask_shape : np.ndarray | tuple | None\n            2-tuple defining shape of mask to be generated. If non specified,\n            takes the max of all the vertiecs\n        zoom_factor : float\n            Premultiplier applied to coordinates before generating mask. Used\n            for generating as downsampled mask.\n        offset : 2-tuple\n            Offset subtracted from coordinates before multiplying by the\n            zoom_factor. Used for putting negative coordinates into the mask.\n\n        Returns\n        ----------\n        masks : (N, M, P) np.ndarray\n            Array where there is one binary mask of shape MxP for each of\n            N shapes\n        """"""\n        if mask_shape is None:\n            mask_shape = self.displayed_vertices.max(axis=0).astype(\'int\')\n\n        masks = np.array(\n            [\n                s.to_mask(mask_shape, zoom_factor=zoom_factor, offset=offset)\n                for s in self.shapes\n            ]\n        )\n\n        return masks\n\n    def to_labels(self, labels_shape=None, zoom_factor=1, offset=[0, 0]):\n        """"""Returns a integer labels image, where each shape is embedded in an\n        array of shape labels_shape with the value of the index + 1\n        corresponding to it, and 0 for background. For overlapping shapes\n        z-ordering will be respected.\n\n        Parameters\n        ----------\n        labels_shape : np.ndarray | tuple | None\n            2-tuple defining shape of labels image to be generated. If non\n            specified, takes the max of all the vertiecs\n        zoom_factor : float\n            Premultiplier applied to coordinates before generating mask. Used\n            for generating as downsampled mask.\n        offset : 2-tuple\n            Offset subtracted from coordinates before multiplying by the\n            zoom_factor. Used for putting negative coordinates into the mask.\n\n        Returns\n        ----------\n        labels : np.ndarray\n            MxP integer array where each value is either 0 for background or an\n            integer up to N for points inside the corresponding shape.\n        """"""\n        if labels_shape is None:\n            labels_shape = self.displayed_vertices.max(axis=0).astype(np.int)\n\n        labels = np.zeros(labels_shape, dtype=int)\n\n        for ind in self._z_order[::-1]:\n            mask = self.shapes[ind].to_mask(\n                labels_shape, zoom_factor=zoom_factor, offset=offset\n            )\n            labels[mask] = ind + 1\n\n        return labels\n\n    def to_colors(self, colors_shape=None, zoom_factor=1, offset=[0, 0]):\n        """"""Rasterize shapes to an RGBA image array.\n\n        Each shape is embedded in an array of shape `colors_shape` with the\n        RGBA value of the shape, and 0 for background. For overlapping shapes\n        z-ordering will be respected.\n\n        Parameters\n        ----------\n        colors_shape : np.ndarray | tuple | None\n            2-tuple defining shape of colors image to be generated. If non\n            specified, takes the max of all the vertiecs\n        zoom_factor : float\n            Premultiplier applied to coordinates before generating mask. Used\n            for generating as downsampled mask.\n        offset : 2-tuple\n            Offset subtracted from coordinates before multiplying by the\n            zoom_factor. Used for putting negative coordinates into the mask.\n\n        Returns\n        ----------\n        colors : (N, M, 4) array\n            rgba array where each value is either 0 for background or the rgba\n            value of the shape for points inside the corresponding shape.\n        """"""\n        if colors_shape is None:\n            colors_shape = self.displayed_vertices.max(axis=0).astype(np.int)\n\n        colors = np.zeros(tuple(colors_shape) + (4,), dtype=float)\n        colors[..., 3] = 1\n\n        for ind in self._z_order[::-1]:\n            if self._displayed[ind]:\n                mask = self.shapes[ind].to_mask(\n                    colors_shape, zoom_factor=zoom_factor, offset=offset\n                )\n                if type(self.shapes[ind]) in [Path, Line]:\n                    col = self._edge_color[ind]\n                else:\n                    col = self._face_color[ind]\n                colors[mask, :] = col\n\n        return colors\n'"
napari/layers/shapes/_shapes_constants.py,0,"b'from enum import auto\nimport sys\n\nfrom ...utils.misc import StringEnum\nfrom ._shapes_models import Rectangle, Ellipse, Line, Path, Polygon\n\n\nclass Mode(StringEnum):\n    """"""Mode: Interactive mode. The normal, default mode is PAN_ZOOM, which\n    allows for normal interactivity with the canvas.\n\n    The SELECT mode allows for entire shapes to be selected, moved and\n    resized.\n\n    The DIRECT mode allows for shapes to be selected and their individual\n    vertices to be moved.\n\n    The VERTEX_INSERT and VERTEX_REMOVE modes allow for individual\n    vertices either to be added to or removed from shapes that are already\n    selected. Note that shapes cannot be selected in this mode.\n\n    The ADD_RECTANGLE, ADD_ELLIPSE, ADD_LINE, ADD_PATH, and ADD_POLYGON\n    modes all allow for their corresponding shape type to be added.\n    """"""\n\n    PAN_ZOOM = auto()\n    SELECT = auto()\n    DIRECT = auto()\n    ADD_RECTANGLE = auto()\n    ADD_ELLIPSE = auto()\n    ADD_LINE = auto()\n    ADD_PATH = auto()\n    ADD_POLYGON = auto()\n    VERTEX_INSERT = auto()\n    VERTEX_REMOVE = auto()\n\n\nclass Box:\n    """"""Box: Constants associated with the vertices of the interaction box\n    """"""\n\n    WITH_HANDLE = [0, 1, 2, 3, 4, 5, 6, 7, 9]\n    LINE_HANDLE = [7, 6, 4, 2, 0, 7, 8]\n    LINE = [0, 2, 4, 6, 0]\n    TOP_LEFT = 0\n    TOP_CENTER = 7\n    LEFT_CENTER = 1\n    BOTTOM_RIGHT = 4\n    BOTTOM_LEFT = 2\n    CENTER = 8\n    HANDLE = 9\n    LEN = 8\n\n\nBACKSPACE = \'delete\' if sys.platform == \'darwin\' else \'backspace\'\n\n\nclass ShapeType(StringEnum):\n    """"""ShapeType: Valid shape type.""""""\n\n    RECTANGLE = auto()\n    ELLIPSE = auto()\n    LINE = auto()\n    PATH = auto()\n    POLYGON = auto()\n\n\nshape_classes = {\n    ShapeType.RECTANGLE: Rectangle,\n    ShapeType.ELLIPSE: Ellipse,\n    ShapeType.LINE: Line,\n    ShapeType.PATH: Path,\n    ShapeType.POLYGON: Polygon,\n}\n'"
napari/layers/shapes/_shapes_key_bindings.py,2,"b'import numpy as np\n\nfrom .shapes import Shapes\nfrom ._shapes_constants import Mode, Box\n\n\n@Shapes.bind_key(\'Space\')\ndef hold_to_pan_zoom(layer):\n    """"""Hold to pan and zoom in the viewer.""""""\n    if layer._mode != Mode.PAN_ZOOM:\n        # on key press\n        prev_mode = layer.mode\n        prev_selected = layer.selected_data.copy()\n        layer.mode = Mode.PAN_ZOOM\n\n        yield\n\n        # on key release\n        layer.mode = prev_mode\n        layer.selected_data = prev_selected\n        layer._set_highlight()\n\n\n@Shapes.bind_key(\'Shift\')\ndef hold_to_lock_aspect_ratio(layer):\n    """"""Hold to lock aspect ratio when resizing a shape.""""""\n    # on key press\n    layer._fixed_aspect = True\n    box = layer._selected_box\n    if box is not None:\n        size = box[Box.BOTTOM_RIGHT] - box[Box.TOP_LEFT]\n        if not np.any(size == np.zeros(2)):\n            layer._aspect_ratio = abs(size[1] / size[0])\n        else:\n            layer._aspect_ratio = 1\n    else:\n        layer._aspect_ratio = 1\n    if layer._is_moving:\n        layer._move(layer.displayed_coordinates)\n\n    yield\n\n    # on key release\n    layer._fixed_aspect = False\n    if layer._is_moving:\n        layer._move(layer.displayed_coordinates)\n\n\n@Shapes.bind_key(\'R\')\ndef activate_add_rectangle_mode(layer):\n    """"""Activate add rectangle tool.""""""\n    layer.mode = Mode.ADD_RECTANGLE\n\n\n@Shapes.bind_key(\'E\')\ndef activate_add_ellipse_mode(layer):\n    """"""Activate add ellipse tool.""""""\n    layer.mode = Mode.ADD_ELLIPSE\n\n\n@Shapes.bind_key(\'L\')\ndef activate_add_line_mode(layer):\n    """"""Activate add line tool.""""""\n    layer.mode = Mode.ADD_LINE\n\n\n@Shapes.bind_key(\'T\')\ndef activate_add_path_mode(layer):\n    """"""Activate add path tool.""""""\n    layer.mode = Mode.ADD_PATH\n\n\n@Shapes.bind_key(\'P\')\ndef activate_add_polygon_mode(layer):\n    """"""Activate add polygon tool.""""""\n    layer.mode = Mode.ADD_POLYGON\n\n\n@Shapes.bind_key(\'D\')\ndef activate_direct_mode(layer):\n    """"""Activate vertex selection tool.""""""\n    layer.mode = Mode.DIRECT\n\n\n@Shapes.bind_key(\'S\')\ndef activate_select_mode(layer):\n    """"""Activate shape selection tool.""""""\n    layer.mode = Mode.SELECT\n\n\n@Shapes.bind_key(\'Z\')\ndef activate_pan_zoom_mode(layer):\n    """"""Activate pan and zoom mode.""""""\n    layer.mode = Mode.PAN_ZOOM\n\n\n@Shapes.bind_key(\'I\')\ndef activate_vertex_insert_mode(layer):\n    """"""Activate vertex insertion tool.""""""\n    layer.mode = Mode.VERTEX_INSERT\n\n\n@Shapes.bind_key(\'X\')\ndef activate_vertex_remove_mode(layer):\n    """"""Activate vertex deletion tool.""""""\n    layer.mode = Mode.VERTEX_REMOVE\n\n\n@Shapes.bind_key(\'Control-C\')\ndef copy(layer):\n    """"""Copy any selected shapes.""""""\n    if layer._mode in (Mode.DIRECT, Mode.SELECT):\n        layer._copy_data()\n\n\n@Shapes.bind_key(\'Control-V\')\ndef paste(layer):\n    """"""Paste any copied shapes.""""""\n    if layer._mode in (Mode.DIRECT, Mode.SELECT):\n        layer._paste_data()\n\n\n@Shapes.bind_key(\'A\')\ndef select_all(layer):\n    """"""Select all shapes in the current view slice.""""""\n    if layer._mode in (Mode.DIRECT, Mode.SELECT):\n        layer.selected_data = set(np.nonzero(layer._data_view._displayed)[0])\n        layer._set_highlight()\n\n\n@Shapes.bind_key(\'Backspace\')\ndef delete_selected(layer):\n    """"""Delete any selected shapes.""""""\n    layer.remove_selected()\n\n\n@Shapes.bind_key(\'Escape\')\ndef finish_drawing(layer):\n    """"""Finish any drawing, for example when using the path or polygon tool.""""""\n    layer._finish_drawing()\n'"
napari/layers/shapes/_shapes_mouse_bindings.py,18,"b'import numpy as np\nfrom copy import copy\nfrom ._shapes_constants import Mode\nfrom ._shapes_models import Rectangle, Ellipse, Line, Path, Polygon\nfrom ._shapes_utils import point_to_lines\n\n\ndef highlight(layer, event):\n    """"""Highlight hovered shapes.""""""\n    layer._set_highlight()\n\n\ndef select(layer, event):\n    """"""Select shapes or vertices either in select or direct select mode.\n\n    Once selected shapes can be moved or resized, and vertices can be moved\n    depending on the mode. Holding shift when resizing a shape will preserve\n    the aspect ratio.\n    """"""\n    shift = \'Shift\' in event.modifiers\n    # on press\n    layer._moving_value = copy(layer._value)\n    shape_under_cursor, vertex_under_cursor = layer._value\n    if vertex_under_cursor is None:\n        if shift and shape_under_cursor is not None:\n            if shape_under_cursor in layer.selected_data:\n                layer.selected_data.remove(shape_under_cursor)\n                shapes = layer.selected_data\n                layer._selected_box = layer.interaction_box(shapes)\n            else:\n                layer.selected_data.add(shape_under_cursor)\n                shapes = layer.selected_data\n                layer._selected_box = layer.interaction_box(shapes)\n        elif shape_under_cursor is not None:\n            if shape_under_cursor not in layer.selected_data:\n                layer.selected_data = {shape_under_cursor}\n        else:\n            layer.selected_data = set()\n    layer._set_highlight()\n    yield\n\n    # on move\n    while event.type == \'mouse_move\':\n        # Drag any selected shapes\n        layer._move(layer.displayed_coordinates)\n        yield\n\n    # on release\n    shift = \'Shift\' in event.modifiers\n    if not layer._is_moving and not layer._is_selecting and not shift:\n        if shape_under_cursor is not None:\n            layer.selected_data = {shape_under_cursor}\n        else:\n            layer.selected_data = set()\n    elif layer._is_selecting:\n        layer.selected_data = layer._data_view.shapes_in_box(layer._drag_box)\n        layer._is_selecting = False\n        layer._set_highlight()\n    layer._is_moving = False\n    layer._drag_start = None\n    layer._drag_box = None\n    layer._fixed_vertex = None\n    layer._moving_value = (None, None)\n    layer._set_highlight()\n    layer._update_thumbnail()\n\n\ndef add_line(layer, event):\n    """"""Add a line.""""""\n    size = layer._vertex_size * layer.scale_factor / 4\n    corner = np.array(layer.displayed_coordinates)\n    data = np.array([corner, corner + size])\n    yield from _add_line_rectangle_ellipse(\n        layer, event, data=data, shape_type=\'line\'\n    )\n\n\ndef add_ellipse(layer, event):\n    """"""Add an ellipse.""""""\n    size = layer._vertex_size * layer.scale_factor / 4\n    corner = np.array(layer.displayed_coordinates)\n    data = np.array(\n        [corner, corner + [size, 0], corner + size, corner + [0, size]]\n    )\n    yield from _add_line_rectangle_ellipse(\n        layer, event, data=data, shape_type=\'ellipse\'\n    )\n\n\ndef add_rectangle(layer, event):\n    """"""Add an rectangle.""""""\n    size = layer._vertex_size * layer.scale_factor / 4\n    corner = np.array(layer.displayed_coordinates)\n    data = np.array(\n        [corner, corner + [size, 0], corner + size, corner + [0, size]]\n    )\n    yield from _add_line_rectangle_ellipse(\n        layer, event, data=data, shape_type=\'rectangle\'\n    )\n\n\ndef _add_line_rectangle_ellipse(layer, event, data, shape_type):\n    """"""Helper function for adding a a line, rectangle or ellipse.""""""\n\n    # on press\n    # Start drawing rectangle / ellipse / line\n    data_full = layer.expand_shape(data)\n    layer.add(data_full, shape_type=shape_type)\n    layer.selected_data = {layer.nshapes - 1}\n    layer._value = (layer.nshapes - 1, 4)\n    layer._moving_value = copy(layer._value)\n    layer.refresh()\n    yield\n\n    # on move\n    while event.type == \'mouse_move\':\n        # Drag any selected shapes\n        layer._move(layer.displayed_coordinates)\n        yield\n\n    # on release\n    layer._finish_drawing()\n\n\ndef add_path_polygon(layer, event):\n    """"""Add a path or polygon.""""""\n    coord = layer.displayed_coordinates\n\n    # on press\n    if layer._is_creating is False:\n        # Start drawing a path\n        data = np.array([coord, coord])\n        data_full = layer.expand_shape(data)\n        layer.add(data_full, shape_type=\'path\')\n        layer.selected_data = {layer.nshapes - 1}\n        layer._value = (layer.nshapes - 1, 1)\n        layer._moving_value = copy(layer._value)\n        layer._is_creating = True\n        layer._set_highlight()\n    else:\n        # Add to an existing path or polygon\n        index = layer._moving_value[0]\n        if layer._mode == Mode.ADD_POLYGON:\n            new_type = Polygon\n        else:\n            new_type = None\n        vertices = layer._data_view.displayed_vertices[\n            layer._data_view.displayed_index == index\n        ]\n        vertices = np.concatenate((vertices, [coord]), axis=0)\n        # Change the selected vertex\n        layer._value = (layer._value[0], layer._value[1] + 1)\n        layer._moving_value = copy(layer._value)\n        data_full = layer.expand_shape(vertices)\n        layer._data_view.edit(index, data_full, new_type=new_type)\n        layer._selected_box = layer.interaction_box(layer.selected_data)\n\n\ndef add_path_polygon_creating(layer, event):\n    """"""While a path or polygon move next vertex to be added.""""""\n    if layer._is_creating:\n        layer._move(layer.displayed_coordinates)\n\n\ndef vertex_insert(layer, event):\n    """"""Insert a vertex into a selected shape.\n\n    The vertex will get inserted in between the vertices of the closest edge\n    from all the edges in selected shapes. Vertices cannot be inserted into\n    Ellipses.\n    """"""\n    # Determine all the edges in currently selected shapes\n    all_edges = np.empty((0, 2, 2))\n    all_edges_shape = np.empty((0, 2), dtype=int)\n    for index in layer.selected_data:\n        shape_type = type(layer._data_view.shapes[index])\n        if shape_type == Ellipse:\n            # Adding vertex to ellipse not implemented\n            pass\n        else:\n            vertices = layer._data_view.displayed_vertices[\n                layer._data_view.displayed_index == index\n            ]\n            # Find which edge new vertex should inserted along\n            closed = shape_type != Path\n            n = len(vertices)\n            if closed:\n                lines = np.array(\n                    [[vertices[i], vertices[(i + 1) % n]] for i in range(n)]\n                )\n            else:\n                lines = np.array(\n                    [[vertices[i], vertices[i + 1]] for i in range(n - 1)]\n                )\n            all_edges = np.append(all_edges, lines, axis=0)\n            indices = np.array(\n                [np.repeat(index, len(lines)), list(range(len(lines)))]\n            ).T\n            all_edges_shape = np.append(all_edges_shape, indices, axis=0)\n\n    if len(all_edges) == 0:\n        # No appropriate edges were found\n        return\n\n    # Determine the closet edge to the current cursor coordinate\n    ind, loc = point_to_lines(layer.displayed_coordinates, all_edges)\n    index = all_edges_shape[ind][0]\n    ind = all_edges_shape[ind][1] + 1\n    shape_type = type(layer._data_view.shapes[index])\n    if shape_type == Line:\n        # Adding vertex to line turns it into a path\n        new_type = Path\n    elif shape_type == Rectangle:\n        # Adding vertex to rectangle turns it into a polygon\n        new_type = Polygon\n    else:\n        new_type = None\n    closed = shape_type != Path\n    vertices = layer._data_view.displayed_vertices[\n        layer._data_view.displayed_index == index\n    ]\n    if not closed:\n        if int(ind) == 1 and loc < 0:\n            ind = 0\n        elif int(ind) == len(vertices) - 1 and loc > 1:\n            ind = ind + 1\n\n    # Insert new vertex at appropriate place in vertices of target shape\n    vertices = np.insert(vertices, ind, [layer.displayed_coordinates], axis=0)\n    with layer.events.set_data.blocker():\n        data_full = layer.expand_shape(vertices)\n        layer._data_view.edit(index, data_full, new_type=new_type)\n        layer._selected_box = layer.interaction_box(layer.selected_data)\n    layer.refresh()\n\n\ndef vertex_remove(layer, event):\n    """"""Remove a vertex from a selected shape.\n\n    If a vertex is clicked on remove it from the shape it is in. If this cause\n    the shape to shrink to a size that no longer is valid remove the whole\n    shape.\n    """"""\n    shape_under_cursor, vertex_under_cursor = layer._value\n    if vertex_under_cursor is None:\n        # No vertex was clicked on so return\n        return\n\n    # Have clicked on a current vertex so remove\n    shape_type = type(layer._data_view.shapes[shape_under_cursor])\n    if shape_type == Ellipse:\n        # Removing vertex from ellipse not implemented\n        return\n    vertices = layer._data_view.displayed_vertices[\n        layer._data_view.displayed_index == shape_under_cursor\n    ]\n    if len(vertices) <= 2:\n        # If only 2 vertices present, remove whole shape\n        with layer.events.set_data.blocker():\n            if shape_under_cursor in layer.selected_data:\n                layer.selected_data.remove(shape_under_cursor)\n            layer._data_view.remove(shape_under_cursor)\n            shapes = layer.selected_data\n            layer._selected_box = layer.interaction_box(shapes)\n    elif shape_type == Polygon and len(vertices) == 3:\n        # If only 3 vertices of a polygon present remove\n        with layer.events.set_data.blocker():\n            if shape_under_cursor in layer.selected_data:\n                layer.selected_data.remove(shape_under_cursor)\n            layer._data_view.remove(shape_under_cursor)\n            shapes = layer.selected_data\n            layer._selected_box = layer.interaction_box(shapes)\n    else:\n        if shape_type == Rectangle:\n            # Deleting vertex from a rectangle creates a polygon\n            new_type = Polygon\n        else:\n            new_type = None\n        # Remove clicked on vertex\n        vertices = np.delete(vertices, vertex_under_cursor, axis=0)\n        with layer.events.set_data.blocker():\n            data_full = layer.expand_shape(vertices)\n            layer._data_view.edit(\n                shape_under_cursor, data_full, new_type=new_type\n            )\n            shapes = layer.selected_data\n            layer._selected_box = layer.interaction_box(shapes)\n    layer.refresh()\n'"
napari/layers/shapes/_shapes_utils.py,138,"b'import numpy as np\nfrom ..utils.layer_utils import segment_normal\nfrom vispy.geometry import PolygonData\nfrom vispy.visuals.tube import _frenet_frames\n\n\ndef inside_triangles(triangles):\n    """"""Checks which triangles contain the origin\n\n    Parameters\n    ----------\n    triangles : (N, 3, 2) array\n        Array of N triangles that should be checked\n\n    Returns\n    -------\n    inside : (N,) array of bool\n        Array with `True` values for trinagles containg the origin\n    """"""\n\n    AB = triangles[:, 1, :] - triangles[:, 0, :]\n    AC = triangles[:, 2, :] - triangles[:, 0, :]\n    BC = triangles[:, 2, :] - triangles[:, 1, :]\n\n    s_AB = -AB[:, 0] * triangles[:, 0, 1] + AB[:, 1] * triangles[:, 0, 0] >= 0\n    s_AC = -AC[:, 0] * triangles[:, 0, 1] + AC[:, 1] * triangles[:, 0, 0] >= 0\n    s_BC = -BC[:, 0] * triangles[:, 1, 1] + BC[:, 1] * triangles[:, 1, 0] >= 0\n\n    inside = np.all(np.array([s_AB != s_AC, s_AB == s_BC]), axis=0)\n\n    return inside\n\n\ndef inside_boxes(boxes):\n    """"""Checks which boxes contain the origin. Boxes need not be axis aligned\n\n    Parameters\n    ----------\n    boxes : (N, 8, 2) array\n        Array of N boxes that should be checked\n\n    Returns\n    -------\n    inside : (N,) array of bool\n        True if corresponding box contains the origin.\n    """"""\n\n    AB = boxes[:, 0] - boxes[:, 6]\n    AM = boxes[:, 0]\n    BC = boxes[:, 6] - boxes[:, 4]\n    BM = boxes[:, 6]\n\n    ABAM = np.multiply(AB, AM).sum(1)\n    ABAB = np.multiply(AB, AB).sum(1)\n    BCBM = np.multiply(BC, BM).sum(1)\n    BCBC = np.multiply(BC, BC).sum(1)\n\n    c1 = 0 <= ABAM\n    c2 = ABAM <= ABAB\n    c3 = 0 <= BCBM\n    c4 = BCBM <= BCBC\n\n    inside = np.all(np.array([c1, c2, c3, c4]), axis=0)\n\n    return inside\n\n\ndef triangles_intersect_box(triangles, corners):\n    """"""Determines which triangles intersect an axis aligned box.\n\n    Parameters\n    ----------\n    triangles : (N, 3, 2) array\n        Array of vertices of triangles to be tested\n    corners : (2, 2) array\n        Array specifying corners of a box\n\n    Returns\n    -------\n    intersects : (N,) array of bool\n        Array with `True` values for triangles intersecting the box\n    """"""\n\n    vertices_inside = triangle_vertices_inside_box(triangles, corners)\n    edge_intersects = triangle_edges_intersect_box(triangles, corners)\n\n    intersects = np.logical_or(vertices_inside, edge_intersects)\n\n    return intersects\n\n\ndef triangle_vertices_inside_box(triangles, corners):\n    """"""Determines which triangles have vertices inside an axis aligned box.\n\n    Parameters\n    ----------\n    triangles : (N, 3, 2) array\n        Array of vertices of triangles to be tested\n    corners : (2, 2) array\n        Array specifying corners of a box\n\n    Returns\n    -------\n    inside : (N,) array of bool\n        Array with `True` values for triangles with vertices inside the box\n    """"""\n    box = create_box(corners)[[0, 4]]\n\n    vertices_inside = np.empty(triangles.shape[:-1], dtype=bool)\n    for i in range(3):\n        # check if each triangle vertex is inside the box\n        below_top = np.all(box[1] >= triangles[:, i, :], axis=1)\n        above_bottom = np.all(triangles[:, i, :] >= box[0], axis=1)\n        vertices_inside[:, i] = np.logical_and(below_top, above_bottom)\n\n    inside = np.any(vertices_inside, axis=1)\n\n    return inside\n\n\ndef triangle_edges_intersect_box(triangles, corners):\n    """"""Determines which triangles have edges that intersect the edges of an\n    axis aligned box.\n\n    Parameters\n    ----------\n    triangles : (N, 3, 2) array\n        Array of vertices of triangles to be tested\n    corners : (2, 2) array\n        Array specifying corners of a box\n\n    Returns\n    -------\n    intersects : (N,) array of bool\n        Array with `True` values for triangles with edges that intersect the\n        edges of the box.\n    """"""\n    box = create_box(corners)[[0, 2, 4, 6]]\n\n    intersects = np.zeros([len(triangles), 12], dtype=bool)\n    for i in range(3):\n        # check if each triangle edge\n        p1 = triangles[:, i, :]\n        q1 = triangles[:, (i + 1) % 3, :]\n\n        for j in range(4):\n            # Check the four edges of the box\n            p2 = box[j]\n            q2 = box[(j + 1) % 3]\n            intersects[:, i * 3 + j] = [\n                lines_intersect(p1[k], q1[k], p2, q2) for k in range(len(p1))\n            ]\n\n    return np.any(intersects, axis=1)\n\n\ndef lines_intersect(p1, q1, p2, q2):\n    """"""Determines if line segment p1q1 intersects line segment p2q2\n\n    Parameters\n    -------\n    p1 : (2,) array\n        Array of first point of first line segment\n    q1 : (2,) array\n        Array of second point of first line segment\n    p2 : (2,) array\n        Array of first point of second line segment\n    q2 : (2,) array\n        Array of second point of second line segment\n\n    Returns\n    -------\n    intersects : bool\n        Bool indicating if line segment p1q1 intersects line segment p2q2\n    """"""\n    # Determine four orientations\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # Test general case\n    if (o1 != o2) and (o3 != o4):\n        return True\n\n    # Test special cases\n    # p1, q1 and p2 are collinear and p2 lies on segment p1q1\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n\n    # p1, q1 and q2 are collinear and q2 lies on segment p1q1\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n\n    # p2, q2 and p1 are collinear and p1 lies on segment p2q2\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n\n    # p2, q2 and q1 are collinear and q1 lies on segment p2q2\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    # Doesn\'t fall into any special cases\n    return False\n\n\ndef on_segment(p, q, r):\n    """"""Checks if q is on the segment from p to r\n\n    Parameters\n    -------\n    p : (2,) array\n        Array of first point of segment\n    q : (2,) array\n        Array of point to check if on segment\n    r : (2,) array\n        Array of second point of segment\n\n    Returns\n    -------\n    on : bool\n        Bool indicating if q is on segment from p to r\n    """"""\n    if (\n        q[0] <= max(p[0], r[0])\n        and q[0] >= min(p[0], r[0])\n        and q[1] <= max(p[1], r[1])\n        and q[1] >= min(p[1], r[1])\n    ):\n        on = True\n    else:\n        on = False\n\n    return on\n\n\ndef orientation(p, q, r):\n    """"""Determines oritentation of ordered triplet (p, q, r)\n\n    Parameters\n    -------\n    p : (2,) array\n        Array of first point of triplet\n    q : (2,) array\n        Array of second point of triplet\n    r : (2,) array\n        Array of third point of triplet\n\n    Returns\n    -------\n    val : int\n        One of (-1, 0, 1). 0 if p, q, r are collinear, 1 if clockwise, and -1\n        if counterclockwise.\n    """"""\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    val = np.sign(val)\n\n    return val\n\n\ndef is_collinear(points):\n    """"""Determines if a list of 2D points are collinear.\n\n    Parameters\n    -------\n    points : (N, 2) array\n        Points to be tested for collinearity\n\n    Returns\n    -------\n    val : bool\n        True is all points are collinear, False otherwise.\n    """"""\n    if len(points) < 3:\n        return True\n\n    # The collinearity test takes three points, the first two are the first\n    # two in the list, and then the third is iterated through in the loop\n    for p in points[2:]:\n        if orientation(points[0], points[1], p) != 0:\n            return False\n\n    return True\n\n\ndef point_to_lines(point, lines):\n    """"""Calculate the distance between a point and line segments and returns the\n    index of the closest line. First calculates the distance to the infinite\n    line, then checks if the projected point lies between the line segment\n    endpoints. If not, calculates distance to the endpoints\n\n    Parameters\n    ----------\n    point : np.ndarray\n        1x2 array of specifying the point\n    lines : np.ndarray\n        Nx2x2 array of line segments\n\n    Returns\n    -------\n    index : int\n        Integer index of the closest line\n    location : float\n        Normalized location of intersection of the distance normal to the line\n        closest. Less than 0 means an intersection before the line segment\n        starts. Between 0 and 1 means an intersection inside the line segment.\n        Greater than 1 means an intersection after the line segment ends\n    """"""\n\n    # shift and normalize vectors\n    lines_vectors = lines[:, 1] - lines[:, 0]\n    point_vectors = point - lines[:, 0]\n    end_point_vectors = point - lines[:, 1]\n    norm_lines = np.linalg.norm(lines_vectors, axis=1, keepdims=True)\n    reject = (norm_lines == 0).squeeze()\n    norm_lines[reject] = 1\n    unit_lines = lines_vectors / norm_lines\n\n    # calculate distance to line\n    line_dist = abs(np.cross(unit_lines, point_vectors))\n\n    # calculate scale\n    line_loc = (unit_lines * point_vectors).sum(axis=1) / norm_lines.squeeze()\n\n    # for points not falling inside segment calculate distance to appropriate\n    # endpoint\n    line_dist[line_loc < 0] = np.linalg.norm(\n        point_vectors[line_loc < 0], axis=1\n    )\n    line_dist[line_loc > 1] = np.linalg.norm(\n        end_point_vectors[line_loc > 1], axis=1\n    )\n    line_dist[reject] = np.linalg.norm(point_vectors[reject], axis=1)\n    line_loc[reject] = 0.5\n\n    # calculate closet line\n    index = np.argmin(line_dist)\n    location = line_loc[index]\n\n    return index, location\n\n\ndef create_box(data):\n    """"""Creates the axis aligned interaction box of a list of points\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Nx2 array of points whose interaction box is to be found\n\n    Returns\n    -------\n    box : np.ndarray\n        9x2 array of vertices of the interaction box. The first 8 points are\n        the corners and midpoints of the box in clockwise order starting in the\n        upper-left corner. The last point is the center of the box\n    """"""\n    min_val = [data[:, 0].min(axis=0), data[:, 1].min(axis=0)]\n    max_val = [data[:, 0].max(axis=0), data[:, 1].max(axis=0)]\n    tl = np.array([min_val[0], min_val[1]])\n    tr = np.array([max_val[0], min_val[1]])\n    br = np.array([max_val[0], max_val[1]])\n    bl = np.array([min_val[0], max_val[1]])\n    box = np.array(\n        [\n            tl,\n            (tl + tr) / 2,\n            tr,\n            (tr + br) / 2,\n            br,\n            (br + bl) / 2,\n            bl,\n            (bl + tl) / 2,\n            (tl + tr + br + bl) / 4,\n        ]\n    )\n    return box\n\n\ndef rectangle_to_box(data):\n    """"""Converts the four corners of a rectangle into a interaction box like\n    representation. If the rectangle is not axis aligned the resulting box\n    representation will not be axis aligned either\n\n    Parameters\n    ----------\n    data : np.ndarray\n        4xD array of corner points to be converted to a box like representation\n\n    Returns\n    -------\n    box : np.ndarray\n        9xD array of vertices of the interaction box. The first 8 points are\n        the corners and midpoints of the box in clockwise order starting in the\n        upper-left corner. The last point is the center of the box\n    """"""\n    if not data.shape[0] == 4:\n        raise ValueError(\n            """"""Data shape does not match expected `[4, D]`\n                         shape specifying corners for the rectangle""""""\n        )\n    box = np.array(\n        [\n            data[0],\n            (data[0] + data[1]) / 2,\n            data[1],\n            (data[1] + data[2]) / 2,\n            data[2],\n            (data[2] + data[3]) / 2,\n            data[3],\n            (data[3] + data[0]) / 2,\n            data.mean(axis=0),\n        ]\n    )\n    return box\n\n\ndef find_corners(data):\n    """"""Finds the four corners of the interaction box definied by an array of\n    points\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Nx2 array of points whose interaction box is to be found\n\n    Returns\n    -------\n    corners : np.ndarray\n        4x2 array of corners of the boudning box\n    """"""\n    min_val = data.min(axis=0)\n    max_val = data.max(axis=0)\n    tl = np.array([min_val[0], min_val[1]])\n    tr = np.array([max_val[0], min_val[1]])\n    br = np.array([max_val[0], max_val[1]])\n    bl = np.array([min_val[0], max_val[1]])\n    corners = np.array([tl, tr, br, bl])\n    return corners\n\n\ndef center_radii_to_corners(center, radii):\n    """"""Expands a center and radii into a four corner rectangle\n\n    Parameters\n    ----------\n    center : np.ndarray | list\n        Length 2 array or list of the center coordinates\n    radii : np.ndarray | list\n        Length 2 array or list of the two radii\n\n    Returns\n    -------\n    corners : np.ndarray\n        4x2 array of corners of the boudning box\n    """"""\n    data = np.array([center + radii, center - radii])\n    corners = find_corners(data)\n    return corners\n\n\ndef triangulate_ellipse(corners, num_segments=100):\n    """"""Determines the triangulation of a path. The resulting `offsets` can\n    mulitplied by a `width` scalar and be added to the resulting `centers`\n    to generate the vertices of the triangles for the triangulation, i.e.\n    `vertices = centers + width*offsets`. Using the `centers` and `offsets`\n    representation thus allows for the computed triangulation to be\n    independent of the line width.\n\n    Parameters\n    ----------\n    corners : np.ndarray\n        4xD array of four bounding corners of the ellipse. The ellipse will\n        still be computed properly even if the rectangle determined by the\n        corners is not axis aligned\n    num_segments : int\n        Integer determining the number of segments to use when triangulating\n        the ellipse\n\n    Returns\n    -------\n    vertices : np.ndarray\n        Mx2 array coordinates of vertices for triangulating an ellipse.\n        Includes the center vertex of the ellipse, followed by `num_segments`\n        vertices around the boundary of the ellipse\n    triangles : np.ndarray\n        Px2 array of the indices of the vertices for the triangles of the\n        triangulation. Has length given by `num_segments`\n    """"""\n    if not corners.shape[0] == 4:\n        raise ValueError(\n            """"""Data shape does not match expected `[4, D]`\n                         shape specifying corners for the ellipse""""""\n        )\n\n    center = corners.mean(axis=0)\n    adjusted = corners - center\n\n    vec = adjusted[1] - adjusted[0]\n    len_vec = np.linalg.norm(vec)\n    if len_vec > 0:\n        # rotate to be axis aligned\n        norm_vec = vec / len_vec\n        if corners.shape[1] == 2:\n            transform = np.array(\n                [[norm_vec[0], -norm_vec[1]], [norm_vec[1], norm_vec[0]]]\n            )\n        else:\n            transform = np.array(\n                [\n                    [0, 0],\n                    [norm_vec[0], -norm_vec[1]],\n                    [norm_vec[1], norm_vec[0]],\n                ]\n            )\n        adjusted = np.matmul(adjusted, transform)\n    else:\n        transform = np.eye(corners.shape[1])\n\n    radii = abs(adjusted[0])\n    vertices = np.zeros((num_segments + 1, 2), dtype=np.float32)\n    theta = np.linspace(0, np.deg2rad(360), num_segments)\n    vertices[1:, 0] = radii[0] * np.cos(theta)\n    vertices[1:, 1] = radii[1] * np.sin(theta)\n\n    if len_vec > 0:\n        # rotate back\n        vertices = np.matmul(vertices, transform.T)\n\n    # Shift back to center\n    vertices = vertices + center\n\n    triangles = np.array([[0, i + 1, i + 2] for i in range(num_segments)])\n    triangles[-1, 2] = 1\n\n    return vertices, triangles\n\n\ndef triangulate_face(data):\n    """"""Determines the triangulation of the face of a shape.\n\n    Parameters\n    ----------\n    data : np.ndarray\n        Nx2 array of vertices of shape to be triangulated\n\n    Returns\n    -------\n    vertices : np.ndarray\n        Mx2 array vertices of the trinagles.\n    triangles : np.ndarray\n        Px3 array of the indices of the vertices that will form the\n        triangles of the triangulation\n    """"""\n    vertices, triangles = PolygonData(vertices=data).triangulate()\n    triangles = triangles.astype(np.uint32)\n\n    return vertices, triangles\n\n\ndef triangulate_edge(path, closed=False):\n    """"""Determines the triangulation of a path. The resulting `offsets` can\n    mulitplied by a `width` scalar and be added to the resulting `centers`\n    to generate the vertices of the triangles for the triangulation, i.e.\n    `vertices = centers + width*offsets`. Using the `centers` and `offsets`\n    representation thus allows for the computed triangulation to be\n    independent of the line width.\n\n    Parameters\n    ----------\n    path : np.ndarray\n        Nx2 or Nx3 array of central coordinates of path to be triangulated\n    closed : bool\n        Bool which determines if the path is closed or not.\n\n    Returns\n    -------\n    centers : np.ndarray\n        Mx2 or Mx3 array central coordinates of path trinagles.\n    offsets : np.ndarray\n        Mx2 or Mx3 array of the offsets to the central coordinates that need to\n        be scaled by the line width and then added to the centers to\n        generate the actual vertices of the triangulation\n    triangles : np.ndarray\n        Px3 array of the indices of the vertices that will form the\n        triangles of the triangulation\n    """"""\n    # Remove any equal adjacent points\n    if len(path) > 2:\n        clean_path = np.array(\n            [\n                p\n                for i, p in enumerate(path)\n                if i == 0 or not np.all(p == path[i - 1])\n            ]\n        )\n        if clean_path.shape[0] == 1:\n            clean_path = np.concatenate((clean_path, clean_path), axis=0)\n    else:\n        clean_path = path\n\n    if clean_path.shape[-1] == 2:\n        centers, offsets, triangles = generate_2D_edge_meshes(\n            clean_path, closed=closed\n        )\n    else:\n        centers, offsets, triangles = generate_tube_meshes(\n            clean_path, closed=closed\n        )\n\n    return centers, offsets, triangles\n\n\ndef generate_2D_edge_meshes(path, closed=False, limit=3, bevel=False):\n    """"""Determines the triangulation of a path in 2D. The resulting `offsets`\n    can be mulitplied by a `width` scalar and be added to the resulting\n    `centers` to generate the vertices of the triangles for the triangulation,\n    i.e. `vertices = centers + width*offsets`. Using the `centers` and\n    `offsets` representation thus allows for the computed triangulation to be\n    independent of the line width.\n\n    Parameters\n    ----------\n    path : np.ndarray\n        Nx2 or Nx3 array of central coordinates of path to be triangulated\n    closed : bool\n        Bool which determines if the path is closed or not\n    limit : float\n        Miter limit which determines when to switch from a miter join to a\n        bevel join\n    bevel : bool\n        Bool which if True causes a bevel join to always be used. If False\n        a bevel join will only be used when the miter limit is exceeded\n\n    Returns\n    -------\n    centers : np.ndarray\n        Mx2 or Mx3 array central coordinates of path trinagles.\n    offsets : np.ndarray\n        Mx2 or Mx3 array of the offsets to the central coordinates that need to\n        be scaled by the line width and then added to the centers to\n        generate the actual vertices of the triangulation\n    triangles : np.ndarray\n        Px3 array of the indices of the vertices that will form the\n        triangles of the triangulation\n    """"""\n    clean_path = np.array(path).astype(float)\n\n    if closed:\n        if np.all(clean_path[0] == clean_path[-1]) and len(clean_path) > 2:\n            clean_path = clean_path[:-1]\n        full_path = np.concatenate(\n            ([clean_path[-1]], clean_path, [clean_path[0]]), axis=0\n        )\n        normals = [\n            segment_normal(full_path[i], full_path[i + 1])\n            for i in range(len(clean_path))\n        ]\n        normals = np.array(normals)\n        full_path = np.concatenate((clean_path, [clean_path[0]]), axis=0)\n        full_normals = np.concatenate((normals, [normals[0]]), axis=0)\n    else:\n        full_path = np.concatenate((clean_path, [clean_path[-2]]), axis=0)\n        normals = [\n            segment_normal(full_path[i], full_path[i + 1])\n            for i in range(len(clean_path))\n        ]\n        normals[-1] = -normals[-1]\n        normals = np.array(normals)\n        full_path = clean_path\n        full_normals = np.concatenate(([normals[0]], normals), axis=0)\n\n    miters = np.array(\n        [full_normals[i : i + 2].mean(axis=0) for i in range(len(full_path))]\n    )\n    miters = np.array(\n        [\n            miters[i] / np.dot(miters[i], full_normals[i])\n            if np.dot(miters[i], full_normals[i]) != 0\n            else full_normals[i]\n            for i in range(len(full_path))\n        ]\n    )\n    miter_lengths = np.linalg.norm(miters, axis=1)\n    miters = 0.5 * miters\n    vertex_offsets = []\n    central_path = []\n    triangles = []\n    m = 0\n\n    for i in range(len(full_path)):\n        if i == 0:\n            if (bevel or miter_lengths[i] > limit) and closed:\n                offset = np.array([miters[i, 1], -miters[i, 0]])\n                offset = 0.5 * offset / np.linalg.norm(offset)\n                flip = np.sign(np.dot(offset, full_normals[i]))\n                vertex_offsets.append(offset)\n                vertex_offsets.append(\n                    -flip * miters[i] / miter_lengths[i] * limit\n                )\n                vertex_offsets.append(-offset)\n                central_path.append(full_path[i])\n                central_path.append(full_path[i])\n                central_path.append(full_path[i])\n                triangles.append([0, 1, 2])\n                m = m + 1\n            else:\n                vertex_offsets.append(-miters[i])\n                vertex_offsets.append(miters[i])\n                central_path.append(full_path[i])\n                central_path.append(full_path[i])\n        elif i == len(full_path) - 1:\n            if closed:\n                a = vertex_offsets[m + 1]\n                b = vertex_offsets[1]\n                ray = full_path[i] - full_path[i - 1]\n                if np.cross(a, ray) * np.cross(b, ray) > 0:\n                    triangles.append([m, m + 1, 1])\n                    triangles.append([m, 0, 1])\n                else:\n                    triangles.append([m, m + 1, 1])\n                    triangles.append([m + 1, 0, 1])\n            else:\n                vertex_offsets.append(-miters[i])\n                vertex_offsets.append(miters[i])\n                central_path.append(full_path[i])\n                central_path.append(full_path[i])\n                a = vertex_offsets[m + 1]\n                b = vertex_offsets[m + 3]\n                ray = full_path[i] - full_path[i - 1]\n                if np.cross(a, ray) * np.cross(b, ray) > 0:\n                    triangles.append([m, m + 1, m + 3])\n                    triangles.append([m, m + 2, m + 3])\n                else:\n                    triangles.append([m, m + 1, m + 3])\n                    triangles.append([m + 1, m + 2, m + 3])\n        elif bevel or miter_lengths[i] > limit:\n            offset = np.array([miters[i, 1], -miters[i, 0]])\n            offset = 0.5 * offset / np.linalg.norm(offset)\n            flip = np.sign(np.dot(offset, full_normals[i]))\n            vertex_offsets.append(offset)\n            vertex_offsets.append(-flip * miters[i] / miter_lengths[i] * limit)\n            vertex_offsets.append(-offset)\n            central_path.append(full_path[i])\n            central_path.append(full_path[i])\n            central_path.append(full_path[i])\n            a = vertex_offsets[m + 1]\n            b = vertex_offsets[m + 3]\n            ray = full_path[i] - full_path[i - 1]\n            if np.cross(a, ray) * np.cross(b, ray) > 0:\n                triangles.append([m, m + 1, m + 3])\n                triangles.append([m, m + 2, m + 3])\n            else:\n                triangles.append([m, m + 1, m + 3])\n                triangles.append([m + 1, m + 2, m + 3])\n            triangles.append([m + 2, m + 3, m + 4])\n            m = m + 3\n        else:\n            vertex_offsets.append(-miters[i])\n            vertex_offsets.append(miters[i])\n            central_path.append(full_path[i])\n            central_path.append(full_path[i])\n            a = vertex_offsets[m + 1]\n            b = vertex_offsets[m + 3]\n            ray = full_path[i] - full_path[i - 1]\n            if np.cross(a, ray) * np.cross(b, ray) > 0:\n                triangles.append([m, m + 1, m + 3])\n                triangles.append([m, m + 2, m + 3])\n            else:\n                triangles.append([m, m + 1, m + 3])\n                triangles.append([m + 1, m + 2, m + 3])\n            m = m + 2\n    centers = np.array(central_path)\n    offsets = np.array(vertex_offsets)\n    triangles = np.array(triangles)\n\n    return centers, offsets, triangles\n\n\ndef generate_tube_meshes(path, closed=False, tube_points=10):\n    """"""Generates list of mesh vertices and triangles from a path\n\n    Adapted from vispy.visuals.TubeVisual\n    https://github.com/vispy/vispy/blob/master/vispy/visuals/tube.py\n\n    Parameters\n    ----------\n    path : (N, 3) array\n        Vertices specifying the path.\n    closed : bool\n        Bool which determines if the path is closed or not.\n    tube_points : int\n        The number of points in the circle-approximating polygon of the\n        tube\'s cross section.\n\n    Returns\n    ----------\n    centers : (M, 3) array\n        Vertices of all triangles for the lines\n    offsets : (M, D) array\n        offsets of all triangles for the lines\n    triangles : (P, 3) array\n        Vertex indices that form the mesh triangles\n    """"""\n    points = np.array(path).astype(float)\n\n    if closed and not np.all(points[0] == points[-1]):\n        points = np.concatenate([points, [points[0]]], axis=0)\n\n    tangents, normals, binormals = _frenet_frames(points, closed)\n\n    segments = len(points) - 1\n\n    # get the positions of each vertex\n    grid = np.zeros((len(points), tube_points, 3))\n    grid_off = np.zeros((len(points), tube_points, 3))\n    for i in range(len(points)):\n        pos = points[i]\n        normal = normals[i]\n        binormal = binormals[i]\n\n        # Add a vertex for each point on the circle\n        v = np.arange(tube_points, dtype=np.float) / tube_points * 2 * np.pi\n        cx = -1.0 * np.cos(v)\n        cy = np.sin(v)\n        grid[i] = pos\n        grid_off[i] = cx[:, np.newaxis] * normal + cy[:, np.newaxis] * binormal\n\n    # construct the mesh\n    indices = []\n    for i in range(segments):\n        for j in range(tube_points):\n            ip = (i + 1) % segments if closed else i + 1\n            jp = (j + 1) % tube_points\n\n            index_a = i * tube_points + j\n            index_b = ip * tube_points + j\n            index_c = ip * tube_points + jp\n            index_d = i * tube_points + jp\n\n            indices.append([index_a, index_b, index_d])\n            indices.append([index_b, index_c, index_d])\n    triangles = np.array(indices, dtype=np.uint32)\n\n    centers = grid.reshape(grid.shape[0] * grid.shape[1], 3)\n    offsets = grid_off.reshape(grid_off.shape[0] * grid_off.shape[1], 3)\n\n    return centers, offsets, triangles\n\n\ndef path_to_mask(mask_shape, vertices):\n    """"""Converts a path to a boolean mask with `True` for points lying along\n    each edge.\n\n    Parameters\n    ----------\n    mask_shape : array (2,)\n        Shape of mask to be generated.\n    vertices : array (N, 2)\n        Vertices of the path.\n\n    Returns\n    ----------\n    mask : np.ndarray\n        Boolean array with `True` for points along the path\n    """"""\n    mask = np.zeros(mask_shape, dtype=bool)\n    vertices = np.round(\n        np.clip(vertices, 0, np.subtract(mask_shape, 1))\n    ).astype(int)\n    for i in range(len(vertices) - 1):\n        start = vertices[i]\n        stop = vertices[i + 1]\n        step = np.ceil(np.max(abs(stop - start))).astype(int)\n        x_vals = np.linspace(start[0], stop[0], step)\n        y_vals = np.linspace(start[1], stop[1], step)\n        for x, y in zip(x_vals, y_vals):\n            mask[int(x), int(y)] = 1\n    return mask\n\n\ndef poly_to_mask(mask_shape, vertices):\n    """"""Converts a polygon to a boolean mask with `True` for points\n    lying inside the shape. Uses the bounding box of the vertices to reduce\n    computation time.\n\n    Parameters\n    ----------\n    mask_shape : np.ndarray | tuple\n        1x2 array of shape of mask to be generated.\n    vertices : np.ndarray\n        Nx2 array of the vertices of the polygon.\n\n    Returns\n    ----------\n    mask : np.ndarray\n        Boolean array with `True` for points inside the polygon\n    """"""\n    mask = np.zeros(mask_shape, dtype=bool)\n    bottom = vertices.min(axis=0).astype(\'int\')\n    bottom = np.clip(bottom, 0, np.subtract(mask_shape, 1))\n    top = np.ceil(vertices.max(axis=0)).astype(\'int\')\n    # top = np.append([top], [mask_shape], axis=0).min(axis=0)\n    top = np.clip(top, 0, np.subtract(mask_shape, 1))\n    if np.all(top > bottom):\n        bb_mask = grid_points_in_poly(top - bottom, vertices - bottom)\n        mask[bottom[0] : top[0], bottom[1] : top[1]] = bb_mask\n    return mask\n\n\ndef grid_points_in_poly(shape, vertices):\n    """"""Converts a polygon to a boolean mask with `True` for points\n    lying inside the shape. Loops through all indices in the grid\n\n    Parameters\n    ----------\n    shape : np.ndarray | tuple\n        1x2 array of shape of mask to be generated.\n    vertices : np.ndarray\n        Nx2 array of the vertices of the polygon.\n\n    Returns\n    ----------\n    mask : np.ndarray\n        Boolean array with `True` for points inside the polygon\n    """"""\n    points = np.array(\n        [(x, y) for x in range(shape[0]) for y in range(shape[1])], dtype=int\n    )\n    inside = points_in_poly(points, vertices)\n    mask = inside.reshape(shape)\n    return mask\n\n\ndef points_in_poly(points, vertices):\n    """"""Tests points for being inside a polygon using the ray casting algorithm\n\n    Parameters\n    ----------\n    points : np.ndarray\n        Mx2 array of points to be tested\n    vertices : np.ndarray\n        Nx2 array of the vertices of the polygon.\n\n    Returns\n    ----------\n    inside : np.ndarray\n        Length M boolean array with `True` for points inside the polygon\n    """"""\n    n_verts = len(vertices)\n    inside = np.zeros(len(points), dtype=bool)\n    j = n_verts - 1\n    for i in range(n_verts):\n        # Determine if a horizontal ray emanating from the point crosses the\n        # line defined by vertices i-1 and vertices i.\n        cond_1 = np.logical_and(\n            vertices[i, 1] <= points[:, 1], points[:, 1] < vertices[j, 1]\n        )\n        cond_2 = np.logical_and(\n            vertices[j, 1] <= points[:, 1], points[:, 1] < vertices[i, 1]\n        )\n        cond_3 = np.logical_or(cond_1, cond_2)\n        d = vertices[j] - vertices[i]\n        if d[1] == 0:\n            # If y vertices are aligned avoid division by zero\n            cond_4 = 0 < d[0] * (points[:, 1] - vertices[i, 1])\n        else:\n            cond_4 = points[:, 0] < (\n                d[0] * (points[:, 1] - vertices[i, 1]) / d[1] + vertices[i, 0]\n            )\n        cond_5 = np.logical_and(cond_3, cond_4)\n        inside[cond_5] = 1 - inside[cond_5]\n        j = i\n\n    # If the number of crossings is even then the point is outside the polygon,\n    # if the number of crossings is odd then the point is inside the polygon\n\n    return inside\n'"
napari/layers/shapes/shapes.py,88,"b'import numpy as np\nfrom copy import copy, deepcopy\n\nfrom ..utils.color_transformations import (\n    normalize_and_broadcast_colors,\n    transform_color_with_defaults,\n)\nfrom ...utils.colormaps.standardize_color import (\n    transform_color,\n    hex_to_name,\n    rgb_to_hex,\n)\nfrom ...utils.event import Event\nfrom ...utils.misc import ensure_iterable\nfrom ...utils.status_messages import format_float\nfrom ..base import Layer\nfrom vispy.color import get_color_names\nfrom ._shapes_constants import Mode, Box, BACKSPACE, shape_classes, ShapeType\nfrom ._shape_list import ShapeList\nfrom ._shapes_utils import create_box\nfrom ._shapes_models import Rectangle, Ellipse, Polygon\nfrom ._shapes_mouse_bindings import (\n    highlight,\n    select,\n    add_line,\n    add_ellipse,\n    add_rectangle,\n    add_path_polygon,\n    add_path_polygon_creating,\n    vertex_insert,\n    vertex_remove,\n)\n\n\nclass Shapes(Layer):\n    """"""Shapes layer.\n\n    Parameters\n    ----------\n    data : list or array\n        List of shape data, where each element is an (N, D) array of the\n        N vertices of a shape in D dimensions. Can be an 3-dimensional\n        array if each shape has the same number of vertices.\n    shape_type : string or list\n        String of shape shape_type, must be one of ""{\'line\', \'rectangle\',\n        \'ellipse\', \'path\', \'polygon\'}"". If a list is supplied it must be\n        the same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    edge_width : float or list\n        Thickness of lines and edges. If a list is supplied it must be the\n        same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    edge_color : str, array-like\n        If string can be any color name recognized by vispy or hex value if\n        starting with `#`. If array-like must be 1-dimensional array with 3\n        or 4 elements. If a list is supplied it must be the same length as\n        the length of `data` and each element will be applied to each shape\n        otherwise the same value will be used for all shapes.\n    face_color : str, array-like\n        If string can be any color name recognized by vispy or hex value if\n        starting with `#`. If array-like must be 1-dimensional array with 3\n        or 4 elements. If a list is supplied it must be the same length as\n        the length of `data` and each element will be applied to each shape\n        otherwise the same value will be used for all shapes.\n    z_index : int or list\n        Specifier of z order priority. Shapes with higher z order are\n        displayed ontop of others. If a list is supplied it must be the\n        same length as the length of `data` and each element will be\n        applied to each shape otherwise the same value will be used for all\n        shapes.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n\n    Attributes\n    ----------\n    data : (N, ) list of array\n        List of shape data, where each element is an (N, D) array of the\n        N vertices of a shape in D dimensions.\n    shape_type : (N, ) list of str\n        Name of shape type for each shape.\n    edge_color : str, array-like\n        Color of the shape border. Numeric color values should be RGB(A).\n    face_color : str, array-like\n        Color of the shape face. Numeric color values should be RGB(A).\n    edge_width : (N, ) list of float\n        Edge width for each shape.\n    z_index : (N, ) list of int\n        z-index for each shape.\n    current_edge_width : float\n        Thickness of lines and edges of the next shape to be added or the\n        currently selected shape.\n    current_edge_color : str\n        Color of the edge of the next shape to be added or the currently\n        selected shape.\n    current_face_color : str\n        Color of the face of the next shape to be added or the currently\n        selected shape.\n    selected_data : set\n        List of currently selected shapes.\n    nshapes : int\n        Total number of shapes.\n    mode : Mode\n        Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        The SELECT mode allows for entire shapes to be selected, moved and\n        resized.\n\n        The DIRECT mode allows for shapes to be selected and their individual\n        vertices to be moved.\n\n        The VERTEX_INSERT and VERTEX_REMOVE modes allow for individual\n        vertices either to be added to or removed from shapes that are already\n        selected. Note that shapes cannot be selected in this mode.\n\n        The ADD_RECTANGLE, ADD_ELLIPSE, ADD_LINE, ADD_PATH, and ADD_POLYGON\n        modes all allow for their corresponding shape type to be added.\n\n    Extended Summary\n    ----------\n    _data_dict : Dict of ShapeList\n        Dictionary containing all the shape data indexed by slice tuple\n    _data_view : ShapeList\n        Object containing the currently viewed shape data.\n    _mode_history : Mode\n        Interactive mode captured on press of <space>.\n    _selected_data_history : set\n        Set of currently selected captured on press of <space>.\n    _selected_data_stored : set\n        Set of selected previously displayed. Used to prevent rerendering the\n        same highlighted shapes when no data has changed.\n    _selected_box : None | np.ndarray\n        `None` if no shapes are selected, otherwise a 10x2 array of vertices of\n        the interaction box. The first 8 points are the corners and midpoints\n        of the box. The 9th point is the center of the box, and the last point\n        is the location of the rotation handle that can be used to rotate the\n        box.\n    _drag_start : None | np.ndarray\n        If a drag has been started and is in progress then a length 2 array of\n        the initial coordinates of the drag. `None` otherwise.\n    _drag_box : None | np.ndarray\n        If a drag box is being created to select shapes then this is a 2x2\n        array of the two extreme corners of the drag. `None` otherwise.\n    _drag_box_stored : None | np.ndarray\n        If a drag box is being created to select shapes then this is a 2x2\n        array of the two extreme corners of the drag that have previously been\n        rendered. `None` otherwise. Used to prevent rerendering the same\n        drag box when no data has changed.\n    _is_moving : bool\n        Bool indicating if any shapes are currently being moved.\n    _is_selecting : bool\n        Bool indicating if a drag box is currently being created in order to\n        select shapes.\n    _is_creating : bool\n        Bool indicating if any shapes are currently being created.\n    _fixed_aspect : bool\n        Bool indicating if aspect ratio of shapes should be preserved on\n        resizing.\n    _aspect_ratio : float\n        Value of aspect ratio to be preserved if `_fixed_aspect` is `True`.\n    _fixed_vertex : None | np.ndarray\n        If a scaling or rotation is in progress then a length 2 array of the\n        coordinates that are remaining fixed during the move. `None` otherwise.\n    _fixed_index : int\n        If a scaling or rotation is in progress then the index of the vertex of\n        the boudning box that is remaining fixed during the move. `None`\n        otherwise.\n    _update_properties : bool\n        Bool indicating if properties are to allowed to update the selected\n        shapes when they are changed. Blocking this prevents circular loops\n        when shapes are selected and the properties are changed based on that\n        selection\n    _clipboard : dict\n        Dict of shape objects that are to be used during a copy and paste.\n    _colors : list\n        List of supported vispy color names.\n    _vertex_size : float\n        Size of the vertices of the shapes and boudning box in Canvas\n        coordinates.\n    _rotation_handle_length : float\n        Length of the rotation handle of the boudning box in Canvas\n        coordinates.\n    _input_ndim : int\n        Dimensions of shape data.\n    """"""\n\n    _colors = get_color_names()\n    _vertex_size = 10\n    _rotation_handle_length = 20\n    _highlight_color = (0, 0.6, 1)\n    _highlight_width = 1.5\n\n    def __init__(\n        self,\n        data=None,\n        *,\n        shape_type=\'rectangle\',\n        edge_width=1,\n        edge_color=\'black\',\n        face_color=\'white\',\n        z_index=0,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n    ):\n        if data is None:\n            data = np.empty((0, 0, 2))\n        if np.array(data).ndim == 3:\n            ndim = np.array(data).shape[2]\n        elif len(data) == 0:\n            ndim = 2\n        elif np.array(data[0]).ndim == 1:\n            ndim = np.array(data).shape[1]\n        else:\n            ndim = np.array(data[0]).shape[1]\n\n        super().__init__(\n            data,\n            ndim,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n\n        self.events.add(\n            mode=Event,\n            edge_width=Event,\n            edge_color=Event,\n            face_color=Event,\n            current_edge_color=Event,\n            current_face_color=Event,\n            highlight=Event,\n        )\n\n        self._display_order_stored = []\n        self._ndisplay_stored = self.dims.ndisplay\n        self.dims.clip = False\n\n        # The following shape properties are for the new shapes that will\n        # be drawn. Each shape has a corresponding property with the\n        # value for itself\n        if np.isscalar(edge_width):\n            self._current_edge_width = edge_width\n        else:\n            self._current_edge_width = 1\n\n        if type(edge_color) is str:\n            self._current_edge_color = transform_color(edge_color)\n        else:\n            self._current_edge_color = np.array([0, 0, 0, 1])\n\n        if type(face_color) is str:\n            self._current_face_color = transform_color(face_color)\n        else:\n            self._current_face_color = np.array([1, 1, 1, 1])\n\n        self._data_view = ShapeList(ndisplay=self.dims.ndisplay)\n        self._data_view.slice_key = np.array(self.dims.indices)[\n            list(self.dims.not_displayed)\n        ]\n\n        self._value = (None, None)\n        self._value_stored = (None, None)\n        self._moving_value = (None, None)\n        self._selected_data = set()\n        self._selected_data_stored = set()\n        self._selected_data_history = set()\n        self._selected_box = None\n\n        self._drag_start = None\n        self._fixed_vertex = None\n        self._fixed_aspect = False\n        self._aspect_ratio = 1\n        self._is_moving = False\n        self._fixed_index = 0\n        self._is_selecting = False\n        self._drag_box = None\n        self._drag_box_stored = None\n        self._is_creating = False\n        self._clipboard = {}\n\n        self._mode = Mode.PAN_ZOOM\n        self._mode_history = self._mode\n        self._status = self.mode\n        self._help = \'enter a selection mode to edit shape properties\'\n\n        self.events.deselect.connect(self._finish_drawing)\n        self.events.face_color.connect(self._update_thumbnail)\n        self.events.edge_color.connect(self._update_thumbnail)\n\n        self.add(\n            data,\n            shape_type=shape_type,\n            edge_width=edge_width,\n            edge_color=edge_color,\n            face_color=face_color,\n            z_index=z_index,\n        )\n\n        # Trigger generation of view slice and thumbnail\n        self._update_dims()\n\n    @property\n    def data(self):\n        """"""list: Each element is an (N, D) array of the vertices of a shape.""""""\n        return self._data_view.data\n\n    @data.setter\n    def data(self, data, shape_type=\'rectangle\'):\n        self._finish_drawing()\n        self._data_view = ShapeList()\n        self.add(data, shape_type=shape_type)\n        self._update_dims()\n        self.events.data()\n\n    def _get_ndim(self):\n        """"""Determine number of dimensions of the layer.""""""\n        if self.nshapes == 0:\n            ndim = self.ndim\n        else:\n            ndim = self.data[0].shape[1]\n        return ndim\n\n    def _get_extent(self):\n        """"""Determine ranges for slicing given by (min, max, step).""""""\n        if self.nshapes == 0:\n            maxs = [1] * self.ndim\n            mins = [0] * self.ndim\n        else:\n            maxs = np.max([np.max(d, axis=0) for d in self.data], axis=0)\n            mins = np.min([np.min(d, axis=0) for d in self.data], axis=0)\n\n        return tuple((min, max) for min, max in zip(mins, maxs))\n\n    @property\n    def nshapes(self):\n        """"""int: Total number of shapes.""""""\n        return len(self._data_view.shapes)\n\n    @property\n    def current_edge_width(self):\n        """"""float: Width of shape edges including lines and paths.""""""\n        return self._current_edge_width\n\n    @current_edge_width.setter\n    def current_edge_width(self, edge_width):\n        self._current_edge_width = edge_width\n        if self._update_properties:\n            for i in self.selected_data:\n                self._data_view.update_edge_width(i, edge_width)\n        self.status = format_float(self.current_edge_width)\n        self.events.edge_width()\n\n    @property\n    def current_edge_color(self):\n        """"""str: color of shape edges including lines and paths.""""""\n        hex_ = rgb_to_hex(self._current_edge_color)[0]\n        return hex_to_name.get(hex_, hex_)\n\n    @current_edge_color.setter\n    def current_edge_color(self, edge_color):\n        self._current_edge_color = transform_color(edge_color)\n        if self._update_properties:\n            for i in self.selected_data:\n                self._data_view.update_edge_color(i, self._current_edge_color)\n        self.events.edge_color()\n        self.events.current_face_color()\n\n    @property\n    def current_face_color(self):\n        """"""str: color of shape faces.""""""\n        hex_ = rgb_to_hex(self._current_face_color)[0]\n        return hex_to_name.get(hex_, hex_)\n\n    @current_face_color.setter\n    def current_face_color(self, face_color):\n        self._current_face_color = transform_color(face_color)\n        if self._update_properties:\n            for i in self.selected_data:\n                self._data_view.update_face_color(i, self._current_face_color)\n        self.events.face_color()\n        self.events.current_face_color()\n\n    @property\n    def shape_type(self):\n        """"""list of str: name of shape type for each shape.""""""\n        return self._data_view.shape_types\n\n    @property\n    def edge_color(self):\n        """"""(N x 4) np.ndarray: Array of RGBA face colors for each shape""""""\n        return self._data_view.edge_color\n\n    @edge_color.setter\n    def edge_color(self, edge_color):\n        self._set_color(edge_color, \'edge\')\n        self.events.edge_color()\n\n    @property\n    def face_color(self):\n        """"""(N x 4) np.ndarray: Array of RGBA face colors for each shape""""""\n        return self._data_view.face_color\n\n    @face_color.setter\n    def face_color(self, face_color):\n        self._set_color(face_color, \'face\')\n        self.events.face_color()\n\n    @property\n    def edge_width(self):\n        """"""list of float: edge width for each shape.""""""\n        return self._data_view.edge_widths\n\n    @property\n    def z_index(self):\n        """"""list of int: z_index for each shape.""""""\n        return self._data_view.z_indices\n\n    @property\n    def selected_data(self):\n        """"""set: set of currently selected shapes.""""""\n        return self._selected_data\n\n    @selected_data.setter\n    def selected_data(self, selected_data):\n        self._selected_data = set(selected_data)\n        self._selected_box = self.interaction_box(self._selected_data)\n\n        # Update properties based on selected shapes\n        if len(selected_data) > 0:\n            selected_face_colors = self._data_view._face_color[\n                list(selected_data)\n            ]\n            face_colors = np.unique(selected_face_colors, axis=0)\n            if len(face_colors) == 1:\n                face_color = face_colors[0]\n                with self.block_update_properties():\n                    self.current_face_color = face_color\n\n            selected_edge_colors = self._data_view._edge_color[\n                list(selected_data)\n            ]\n            edge_colors = np.unique(selected_edge_colors, axis=0)\n            if len(edge_colors) == 1:\n                edge_color = edge_colors[0]\n                with self.block_update_properties():\n                    self.current_edge_color = edge_color\n\n            edge_width = list(\n                set(\n                    [\n                        self._data_view.shapes[i].edge_width\n                        for i in selected_data\n                    ]\n                )\n            )\n            if len(edge_width) == 1:\n                edge_width = edge_width[0]\n                with self.block_update_properties():\n                    self.current_edge_width = edge_width\n\n    def _set_color(self, color, attribute: str):\n        """""" Set the face_color or edge_color property\n\n        Parameters\n        ----------\n        color : (N, 4) array or str\n            The value for setting edge or face_color\n        attribute : str in {\'edge\', \'face\'}\n            The name of the attribute to set the color of.\n            Should be \'edge\' for edge_color or \'face\' for face_color.\n        """"""\n        transformed_color = transform_color_with_defaults(\n            num_entries=len(self.data),\n            colors=color,\n            elem_name=""face_color"",\n            default=""white"",\n        )\n        colors = normalize_and_broadcast_colors(\n            len(self.data), transformed_color\n        )\n\n        setattr(self._data_view, f\'{attribute}_color\', colors)\n\n        color_event = getattr(self.events, f\'{attribute}_color\')\n        color_event()\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'shape_type\': self.shape_type,\n                \'opacity\': self.opacity,\n                \'z_index\': self.z_index,\n                \'edge_width\': self.edge_width,\n                \'face_color\': self.face_color,\n                \'edge_color\': self.edge_color,\n                \'data\': self.data,\n            }\n        )\n        return state\n\n    @property\n    def mode(self):\n        """"""MODE: Interactive mode. The normal, default mode is PAN_ZOOM, which\n        allows for normal interactivity with the canvas.\n\n        The SELECT mode allows for entire shapes to be selected, moved and\n        resized.\n\n        The DIRECT mode allows for shapes to be selected and their individual\n        vertices to be moved.\n\n        The VERTEX_INSERT and VERTEX_REMOVE modes allow for individual\n        vertices either to be added to or removed from shapes that are already\n        selected. Note that shapes cannot be selected in this mode.\n\n        The ADD_RECTANGLE, ADD_ELLIPSE, ADD_LINE, ADD_PATH, and ADD_POLYGON\n        modes all allow for their corresponding shape type to be added.\n        """"""\n        return str(self._mode)\n\n    @mode.setter\n    def mode(self, mode):\n        mode = Mode(mode)\n\n        if not self.editable:\n            mode = Mode.PAN_ZOOM\n\n        if mode == self._mode:\n            return\n        old_mode = self._mode\n\n        if old_mode in [Mode.SELECT, Mode.DIRECT]:\n            self.mouse_drag_callbacks.remove(select)\n            self.mouse_move_callbacks.remove(highlight)\n        elif old_mode == Mode.VERTEX_INSERT:\n            self.mouse_drag_callbacks.remove(vertex_insert)\n            self.mouse_move_callbacks.remove(highlight)\n        elif old_mode == Mode.VERTEX_REMOVE:\n            self.mouse_drag_callbacks.remove(vertex_remove)\n            self.mouse_move_callbacks.remove(highlight)\n        elif old_mode == Mode.ADD_RECTANGLE:\n            self.mouse_drag_callbacks.remove(add_rectangle)\n        elif old_mode == Mode.ADD_ELLIPSE:\n            self.mouse_drag_callbacks.remove(add_ellipse)\n        elif old_mode == Mode.ADD_LINE:\n            self.mouse_drag_callbacks.remove(add_line)\n        elif old_mode in [Mode.ADD_PATH, Mode.ADD_POLYGON]:\n            self.mouse_drag_callbacks.remove(add_path_polygon)\n            self.mouse_move_callbacks.remove(add_path_polygon_creating)\n\n        if mode == Mode.PAN_ZOOM:\n            self.cursor = \'standard\'\n            self.interactive = True\n            self.help = \'enter a selection mode to edit shape properties\'\n        elif mode in [Mode.SELECT, Mode.DIRECT]:\n            self.cursor = \'pointing\'\n            self.interactive = False\n            self.help = (\n                \'hold <space> to pan/zoom, \'\n                f\'press <{BACKSPACE}> to remove selected\'\n            )\n            self.mouse_drag_callbacks.append(select)\n            self.mouse_move_callbacks.append(highlight)\n        elif mode in [Mode.VERTEX_INSERT, Mode.VERTEX_REMOVE]:\n            self.cursor = \'cross\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom\'\n            if mode == Mode.VERTEX_INSERT:\n                self.mouse_drag_callbacks.append(vertex_insert)\n            else:\n                self.mouse_drag_callbacks.append(vertex_remove)\n            self.mouse_move_callbacks.append(highlight)\n        elif mode in [Mode.ADD_RECTANGLE, Mode.ADD_ELLIPSE, Mode.ADD_LINE]:\n            self.cursor = \'cross\'\n            self.interactive = False\n            self.help = \'hold <space> to pan/zoom\'\n            if mode == Mode.ADD_RECTANGLE:\n                self.mouse_drag_callbacks.append(add_rectangle)\n            elif mode == Mode.ADD_ELLIPSE:\n                self.mouse_drag_callbacks.append(add_ellipse)\n            elif mode == Mode.ADD_LINE:\n                self.mouse_drag_callbacks.append(add_line)\n        elif mode in [Mode.ADD_PATH, Mode.ADD_POLYGON]:\n            self.cursor = \'cross\'\n            self.interactive = False\n            self.help = (\n                \'hold <space> to pan/zoom, \' \'press <esc> to finish drawing\'\n            )\n            self.mouse_drag_callbacks.append(add_path_polygon)\n            self.mouse_move_callbacks.append(add_path_polygon_creating)\n        else:\n            raise ValueError(""Mode not recognized"")\n\n        self.status = str(mode)\n        self._mode = mode\n\n        draw_modes = [\n            Mode.SELECT,\n            Mode.DIRECT,\n            Mode.VERTEX_INSERT,\n            Mode.VERTEX_REMOVE,\n        ]\n\n        self.events.mode(mode=mode)\n        if not (mode in draw_modes and old_mode in draw_modes):\n            self._finish_drawing()\n        self.refresh()\n\n    def _set_editable(self, editable=None):\n        """"""Set editable mode based on layer properties.""""""\n        if editable is None:\n            if self.dims.ndisplay == 3:\n                self.editable = False\n            else:\n                self.editable = True\n\n        if not self.editable:\n            self.mode = Mode.PAN_ZOOM\n\n    def add(\n        self,\n        data,\n        *,\n        shape_type=\'rectangle\',\n        edge_width=None,\n        edge_color=None,\n        face_color=None,\n        z_index=None,\n    ):\n        """"""Add shapes to the current layer.\n\n        Parameters\n        ----------\n        data : list or array\n            List of shape data, where each element is an (N, D) array of the\n            N vertices of a shape in D dimensions. Can be an 3-dimensional\n            array if each shape has the same number of vertices.\n        shape_type : string | list\n            String of shape shape_type, must be one of ""{\'line\', \'rectangle\',\n            \'ellipse\', \'path\', \'polygon\'}"". If a list is supplied it must be\n            the same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        edge_width : float | list\n            thickness of lines and edges. If a list is supplied it must be the\n            same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        edge_color : str | tuple | list\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements. If a list is supplied it must be the same length as\n            the length of `data` and each element will be applied to each shape\n            otherwise the same value will be used for all shapes.\n        face_color : str | tuple | list\n            If string can be any color name recognized by vispy or hex value if\n            starting with `#`. If array-like must be 1-dimensional array with 3\n            or 4 elements. If a list is supplied it must be the same length as\n            the length of `data` and each element will be applied to each shape\n            otherwise the same value will be used for all shapes.\n        z_index : int | list\n            Specifier of z order priority. Shapes with higher z order are\n            displayed ontop of others. If a list is supplied it must be the\n            same length as the length of `data` and each element will be\n            applied to each shape otherwise the same value will be used for all\n            shapes.\n        """"""\n        if edge_width is None:\n            edge_width = self.current_edge_width\n        if edge_color is None:\n            edge_color = self._current_edge_color\n        if face_color is None:\n            face_color = self._current_face_color\n        if self._data_view is not None:\n            z_index = z_index or max(self._data_view._z_index, default=-1) + 1\n        else:\n            z_index = z_index or 0\n\n        if len(data) > 0:\n            if np.array(data[0]).ndim == 1:\n                # If a single array for a shape has been passed turn into list\n                data = [data]\n\n            # transform the colors\n            transformed_ec = transform_color_with_defaults(\n                num_entries=len(data),\n                colors=edge_color,\n                elem_name=""edge_color"",\n                default=""white"",\n            )\n            transformed_edge_color = normalize_and_broadcast_colors(\n                len(data), transformed_ec\n            )\n            transformed_fc = transform_color_with_defaults(\n                num_entries=len(data),\n                colors=face_color,\n                elem_name=""face_color"",\n                default=""white"",\n            )\n            transformed_face_color = normalize_and_broadcast_colors(\n                len(data), transformed_fc\n            )\n\n            # Turn input arguments into iterables\n            shape_inputs = zip(\n                data,\n                ensure_iterable(shape_type),\n                ensure_iterable(edge_width),\n                transformed_edge_color,\n                transformed_face_color,\n                ensure_iterable(z_index),\n            )\n\n            for d, st, ew, ec, fc, z in shape_inputs:\n\n                # A False slice_key means the shape is invalid as it is not\n                # confined to a single plane\n                shape_cls = shape_classes[ShapeType(st)]\n                shape = shape_cls(\n                    d,\n                    edge_width=ew,\n                    z_index=z,\n                    dims_order=self.dims.order,\n                    ndisplay=self.dims.ndisplay,\n                )\n\n                # Add shape\n                self._data_view.add(shape, edge_color=ec, face_color=fc)\n\n        self._display_order_stored = copy(self.dims.order)\n        self._ndisplay_stored = copy(self.dims.ndisplay)\n        self._update_dims()\n\n    def _set_view_slice(self):\n        """"""Set the view given the slicing indices.""""""\n        if not self.dims.ndisplay == self._ndisplay_stored:\n            self.selected_data = set()\n            self._data_view.ndisplay = min(self.dims.ndim, self.dims.ndisplay)\n            self._ndisplay_stored = copy(self.dims.ndisplay)\n            self._clipboard = {}\n\n        if not self.dims.order == self._display_order_stored:\n            self.selected_data = set()\n            self._data_view.update_dims_order(self.dims.order)\n            self._display_order_stored = copy(self.dims.order)\n            # Clear clipboard if dimensions swap\n            self._clipboard = {}\n\n        slice_key = np.array(self.dims.indices)[list(self.dims.not_displayed)]\n        if not np.all(slice_key == self._data_view.slice_key):\n            self.selected_data = set()\n        self._data_view.slice_key = slice_key\n\n    def interaction_box(self, index):\n        """"""Create the interaction box around a shape or list of shapes.\n        If a single index is passed then the boudning box will be inherited\n        from that shapes interaction box. If list of indices is passed it will\n        be computed directly.\n\n        Parameters\n        ----------\n        index : int | list\n            Index of a single shape, or a list of shapes around which to\n            construct the interaction box\n\n        Returns\n        ----------\n        box : np.ndarray\n            10x2 array of vertices of the interaction box. The first 8 points\n            are the corners and midpoints of the box in clockwise order\n            starting in the upper-left corner. The 9th point is the center of\n            the box, and the last point is the location of the rotation handle\n            that can be used to rotate the box\n        """"""\n        if isinstance(index, (list, np.ndarray, set)):\n            if len(index) == 0:\n                box = None\n            elif len(index) == 1:\n                box = copy(self._data_view.shapes[list(index)[0]]._box)\n            else:\n                indices = np.isin(self._data_view.displayed_index, list(index))\n                box = create_box(self._data_view.displayed_vertices[indices])\n        else:\n            box = copy(self._data_view.shapes[index]._box)\n\n        if box is not None:\n            rot = box[Box.TOP_CENTER]\n            length_box = np.linalg.norm(\n                box[Box.BOTTOM_LEFT] - box[Box.TOP_LEFT]\n            )\n            if length_box > 0:\n                r = self._rotation_handle_length * self.scale_factor\n                rot = (\n                    rot\n                    - r\n                    * (box[Box.BOTTOM_LEFT] - box[Box.TOP_LEFT])\n                    / length_box\n                )\n            box = np.append(box, [rot], axis=0)\n\n        return box\n\n    def _outline_shapes(self):\n        """"""Find outlines of any selected or hovered shapes.\n\n        Returns\n        ----------\n        vertices : None | np.ndarray\n            Nx2 array of any vertices of outline or None\n        triangles : None | np.ndarray\n            Mx3 array of any indices of vertices for triangles of outline or\n            None\n        """"""\n        if self._value is not None and (\n            self._value[0] is not None or len(self.selected_data) > 0\n        ):\n            if len(self.selected_data) > 0:\n                index = list(self.selected_data)\n                if self._value[0] is not None:\n                    if self._value[0] in index:\n                        pass\n                    else:\n                        index.append(self._value[0])\n                index.sort()\n            else:\n                index = self._value[0]\n\n            centers, offsets, triangles = self._data_view.outline(index)\n            vertices = centers + (\n                self.scale_factor * self._highlight_width * offsets\n            )\n            vertices = vertices[:, ::-1]\n        else:\n            vertices = None\n            triangles = None\n\n        return vertices, triangles\n\n    def _compute_vertices_and_box(self):\n        """"""Compute location of highlight vertices and box for rendering.\n\n        Returns\n        ----------\n        vertices : np.ndarray\n            Nx2 array of any vertices to be rendered as Markers\n        face_color : str\n            String of the face color of the Markers\n        edge_color : str\n            String of the edge color of the Markers and Line for the box\n        pos : np.ndarray\n            Nx2 array of vertices of the box that will be rendered using a\n            Vispy Line\n        width : float\n            Width of the box edge\n        """"""\n        if len(self.selected_data) > 0:\n            if self._mode == Mode.SELECT:\n                # If in select mode just show the interaction boudning box\n                # including its vertices and the rotation handle\n                box = self._selected_box[Box.WITH_HANDLE]\n                if self._value[0] is None:\n                    face_color = \'white\'\n                elif self._value[1] is None:\n                    face_color = \'white\'\n                else:\n                    face_color = self._highlight_color\n                edge_color = self._highlight_color\n                vertices = box[:, ::-1]\n                # Use a subset of the vertices of the interaction_box to plot\n                # the line around the edge\n                pos = box[Box.LINE_HANDLE][:, ::-1]\n                width = 1.5\n            elif self._mode in (\n                [\n                    Mode.DIRECT,\n                    Mode.ADD_PATH,\n                    Mode.ADD_POLYGON,\n                    Mode.ADD_RECTANGLE,\n                    Mode.ADD_ELLIPSE,\n                    Mode.ADD_LINE,\n                    Mode.VERTEX_INSERT,\n                    Mode.VERTEX_REMOVE,\n                ]\n            ):\n                # If in one of these mode show the vertices of the shape itself\n                inds = np.isin(\n                    self._data_view.displayed_index, list(self.selected_data)\n                )\n                vertices = self._data_view.displayed_vertices[inds][:, ::-1]\n                # If currently adding path don\'t show box over last vertex\n                if self._mode == Mode.ADD_PATH:\n                    vertices = vertices[:-1]\n\n                if self._value[0] is None:\n                    face_color = \'white\'\n                elif self._value[1] is None:\n                    face_color = \'white\'\n                else:\n                    face_color = self._highlight_color\n                edge_color = self._highlight_color\n                pos = None\n                width = 0\n            else:\n                # Otherwise show nothing\n                vertices = np.empty((0, 2))\n                face_color = \'white\'\n                edge_color = \'white\'\n                pos = None\n                width = 0\n        elif self._is_selecting:\n            # If currently dragging a selection box just show an outline of\n            # that box\n            vertices = np.empty((0, 2))\n            edge_color = self._highlight_color\n            face_color = \'white\'\n            box = create_box(self._drag_box)\n            width = 1.5\n            # Use a subset of the vertices of the interaction_box to plot\n            # the line around the edge\n            pos = box[Box.LINE][:, ::-1]\n        else:\n            # Otherwise show nothing\n            vertices = np.empty((0, 2))\n            face_color = \'white\'\n            edge_color = \'white\'\n            pos = None\n            width = 0\n\n        return vertices, face_color, edge_color, pos, width\n\n    def _set_highlight(self, force=False):\n        """"""Render highlights of shapes.\n\n        Includes boundaries, vertices, interaction boxes, and the drag\n        selection box when appropriate.\n\n        Parameters\n        ----------\n        force : bool\n            Bool that forces a redraw to occur when `True`\n        """"""\n        # Check if any shape or vertex ids have changed since last call\n        if (\n            self.selected_data == self._selected_data_stored\n            and np.all(self._value == self._value_stored)\n            and np.all(self._drag_box == self._drag_box_stored)\n        ) and not force:\n            return\n        self._selected_data_stored = copy(self.selected_data)\n        self._value_stored = copy(self._value)\n        self._drag_box_stored = copy(self._drag_box)\n        self.events.highlight()\n\n    def _finish_drawing(self, event=None):\n        """"""Reset properties used in shape drawing.""""""\n        index = copy(self._moving_value[0])\n        self._is_moving = False\n        self.selected_data = set()\n        self._drag_start = None\n        self._drag_box = None\n        self._is_selecting = False\n        self._fixed_vertex = None\n        self._value = (None, None)\n        self._moving_value = (None, None)\n        if self._is_creating is True and self._mode == Mode.ADD_PATH:\n            vertices = self._data_view.displayed_vertices[\n                self._data_view.displayed_index == index\n            ]\n            if len(vertices) <= 2:\n                self._data_view.remove(index)\n            else:\n                data_full = self.expand_shape(vertices)\n                self._data_view.edit(index, data_full[:-1])\n        if self._is_creating is True and self._mode == Mode.ADD_POLYGON:\n            vertices = self._data_view.displayed_vertices[\n                self._data_view.displayed_index == index\n            ]\n            if len(vertices) <= 3:\n                self._data_view.remove(index)\n            else:\n                data_full = self.expand_shape(vertices)\n                self._data_view.edit(index, data_full[:-1])\n        self._is_creating = False\n        self._update_dims()\n\n    def _update_thumbnail(self, event=None):\n        """"""Update thumbnail with current points and colors.""""""\n        # calculate min vals for the vertices and pad with 0.5\n        # the offset is needed to ensure that the top left corner of the shapes\n        # corresponds to the top left corner of the thumbnail\n        offset = (\n            np.array([self.dims.range[d][0] for d in self.dims.displayed])\n            + 0.5\n        )\n        # calculate range of values for the vertices and pad with 1\n        # padding ensures the entire shape can be represented in the thumbnail\n        # without getting clipped\n        shape = np.ceil(\n            [\n                self.dims.range[d][1] - self.dims.range[d][0] + 1\n                for d in self.dims.displayed\n            ]\n        ).astype(int)\n        zoom_factor = np.divide(self._thumbnail_shape[:2], shape[-2:]).min()\n\n        colormapped = self._data_view.to_colors(\n            colors_shape=self._thumbnail_shape[:2],\n            zoom_factor=zoom_factor,\n            offset=offset[-2:],\n        )\n\n        self.thumbnail = colormapped\n\n    def remove_selected(self):\n        """"""Remove any selected shapes.""""""\n        index = list(self.selected_data)\n        to_remove = sorted(index, reverse=True)\n        for ind in to_remove:\n            self._data_view.remove(ind)\n\n        if len(index) > 0:\n            self._data_view._edge_color = np.delete(\n                self._data_view._edge_color, index, axis=0\n            )\n            self._data_view._face_color = np.delete(\n                self._data_view._face_color, index, axis=0\n            )\n        self.selected_data = set()\n        self._finish_drawing()\n\n    def _rotate_box(self, angle, center=[0, 0]):\n        """"""Perfrom a rotation on the selected box.\n\n        Parameters\n        ----------\n        angle : float\n            angle specifying rotation of shapes in degrees.\n        center : list\n            coordinates of center of rotation.\n        """"""\n        theta = np.radians(angle)\n        transform = np.array(\n            [[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]]\n        )\n        box = self._selected_box - center\n        self._selected_box = box @ transform.T + center\n\n    def _scale_box(self, scale, center=[0, 0]):\n        """"""Perfrom a scaling on the selected box.\n\n        Parameters\n        ----------\n        scale : float, list\n            scalar or list specifying rescaling of shape.\n        center : list\n            coordinates of center of rotation.\n        """"""\n        if not isinstance(scale, (list, np.ndarray)):\n            scale = [scale, scale]\n        box = self._selected_box - center\n        box = np.array(box * scale)\n        if not np.all(box[Box.TOP_CENTER] == box[Box.HANDLE]):\n            r = self._rotation_handle_length * self.scale_factor\n            handle_vec = box[Box.HANDLE] - box[Box.TOP_CENTER]\n            cur_len = np.linalg.norm(handle_vec)\n            box[Box.HANDLE] = box[Box.TOP_CENTER] + r * handle_vec / cur_len\n        self._selected_box = box + center\n\n    def _transform_box(self, transform, center=[0, 0]):\n        """"""Perfrom a linear transformation on the selected box.\n\n        Parameters\n        ----------\n        transform : np.ndarray\n            2x2 array specifying linear transform.\n        center : list\n            coordinates of center of rotation.\n        """"""\n        box = self._selected_box - center\n        box = box @ transform.T\n        if not np.all(box[Box.TOP_CENTER] == box[Box.HANDLE]):\n            r = self._rotation_handle_length * self.scale_factor\n            handle_vec = box[Box.HANDLE] - box[Box.TOP_CENTER]\n            cur_len = np.linalg.norm(handle_vec)\n            box[Box.HANDLE] = box[Box.TOP_CENTER] + r * handle_vec / cur_len\n        self._selected_box = box + center\n\n    def expand_shape(self, data):\n        """"""Expand shape from 2D to the full data dims.\n\n        Parameters\n        --------\n        data : array\n            2D data array of shape to be expanded.\n\n        Returns\n        --------\n        data_full : array\n            Full D dimensional data array of the shape.\n        """"""\n        if self.ndim == 2:\n            data_full = data[:, self.dims.displayed_order]\n        else:\n            data_full = np.zeros((len(data), self.ndim), dtype=float)\n            indices = np.array(self.dims.indices)\n            data_full[:, self.dims.not_displayed] = indices[\n                self.dims.not_displayed\n            ]\n            data_full[:, self.dims.displayed] = data\n\n        return data_full\n\n    def _get_value(self):\n        """"""Determine if any shape at given coord using triangle meshes.\n\n        Getting value is not supported yet for 3D meshes\n\n        Returns\n        ----------\n        shape : int | None\n            Index of shape if any that is at the coordinates. Returns `None`\n            if no shape is found.\n        vertex : int | None\n            Index of vertex if any that is at the coordinates. Returns `None`\n            if no vertex is found.\n        """"""\n        if self.dims.ndisplay == 3:\n            return (None, None)\n\n        if self._is_moving:\n            return self._moving_value\n\n        coord = self.displayed_coordinates\n\n        # Check selected shapes\n        value = None\n        selected_index = list(self.selected_data)\n        if len(selected_index) > 0:\n            if self._mode == Mode.SELECT:\n                # Check if inside vertex of interaction box or rotation handle\n                box = self._selected_box[Box.WITH_HANDLE]\n                distances = abs(box - coord)\n\n                # Get the vertex sizes\n                sizes = self._vertex_size * self.scale_factor / 2\n\n                # Check if any matching vertices\n                matches = np.all(distances <= sizes, axis=1).nonzero()\n                if len(matches[0]) > 0:\n                    value = (selected_index[0], matches[0][-1])\n            elif self._mode in (\n                [Mode.DIRECT, Mode.VERTEX_INSERT, Mode.VERTEX_REMOVE]\n            ):\n                # Check if inside vertex of shape\n                inds = np.isin(self._data_view.displayed_index, selected_index)\n                vertices = self._data_view.displayed_vertices[inds]\n                distances = abs(vertices - coord)\n\n                # Get the vertex sizes\n                sizes = self._vertex_size * self.scale_factor / 2\n\n                # Check if any matching vertices\n                matches = np.all(distances <= sizes, axis=1).nonzero()[0]\n                if len(matches) > 0:\n                    index = inds.nonzero()[0][matches[-1]]\n                    shape = self._data_view.displayed_index[index]\n                    vals, idx = np.unique(\n                        self._data_view.displayed_index, return_index=True\n                    )\n                    shape_in_list = list(vals).index(shape)\n                    value = (shape, index - idx[shape_in_list])\n\n        if value is None:\n            # Check if mouse inside shape\n            shape = self._data_view.inside(coord)\n            value = (shape, None)\n\n        return value\n\n    def move_to_front(self):\n        """"""Moves selected objects to be displayed in front of all others.""""""\n        if len(self.selected_data) == 0:\n            return\n        new_z_index = max(self._data_view._z_index) + 1\n        for index in self.selected_data:\n            self._data_view.update_z_index(index, new_z_index)\n        self.refresh()\n\n    def move_to_back(self):\n        """"""Moves selected objects to be displayed behind all others.""""""\n        if len(self.selected_data) == 0:\n            return\n        new_z_index = min(self._data_view._z_index) - 1\n        for index in self.selected_data:\n            self._data_view.update_z_index(index, new_z_index)\n        self.refresh()\n\n    def _copy_data(self):\n        """"""Copy selected shapes to clipboard.""""""\n        if len(self.selected_data) > 0:\n            index = list(self.selected_data)\n            self._clipboard = {\n                \'data\': [\n                    deepcopy(self._data_view.shapes[i])\n                    for i in self._selected_data\n                ],\n                \'edge_color\': deepcopy(self._data_view._edge_color[index]),\n                \'face_color\': deepcopy(self._data_view._face_color[index]),\n                \'indices\': self.dims.indices,\n            }\n        else:\n            self._clipboard = {}\n\n    def _paste_data(self):\n        """"""Paste any shapes from clipboard and then selects them.""""""\n        cur_shapes = self.nshapes\n        if len(self._clipboard.keys()) > 0:\n            # Calculate offset based on dimension shifts\n            offset = [\n                self.dims.indices[i] - self._clipboard[\'indices\'][i]\n                for i in self.dims.not_displayed\n            ]\n\n            # Add new shape data\n            for i, s in enumerate(self._clipboard[\'data\']):\n                shape = deepcopy(s)\n                data = copy(shape.data)\n                data[:, self.dims.not_displayed] = data[\n                    :, self.dims.not_displayed\n                ] + np.array(offset)\n                shape.data = data\n                face_color = self._clipboard[\'face_color\'][i]\n                edge_color = self._clipboard[\'edge_color\'][i]\n                self._data_view.add(\n                    shape, face_color=face_color, edge_color=edge_color\n                )\n\n            self.selected_data = set(\n                range(cur_shapes, cur_shapes + len(self._clipboard[\'data\']))\n            )\n            self.move_to_front()\n\n    def _move(self, coord):\n        """"""Moves object at given mouse position and set of indices.\n\n        Parameters\n        ----------\n        coord : sequence of two int\n            Position of mouse cursor in image coordinates.\n        """"""\n        vertex = self._moving_value[1]\n        if self._mode in (\n            [Mode.SELECT, Mode.ADD_RECTANGLE, Mode.ADD_ELLIPSE, Mode.ADD_LINE]\n        ):\n            if len(self.selected_data) > 0:\n                self._is_moving = True\n                if vertex is None:\n                    # Check where dragging box from to move whole object\n                    if self._drag_start is None:\n                        center = self._selected_box[Box.CENTER]\n                        self._drag_start = coord - center\n                    center = self._selected_box[Box.CENTER]\n                    shift = coord - center - self._drag_start\n                    for index in self.selected_data:\n                        self._data_view.shift(index, shift)\n                    self._selected_box = self._selected_box + shift\n                    self.refresh()\n                elif vertex < Box.LEN:\n                    # Corner / edge vertex is being dragged so resize object\n                    box = self._selected_box\n                    if self._fixed_vertex is None:\n                        self._fixed_index = (vertex + 4) % Box.LEN\n                        self._fixed_vertex = box[self._fixed_index]\n\n                    size = (\n                        box[(self._fixed_index + 4) % Box.LEN]\n                        - box[self._fixed_index]\n                    )\n                    offset = box[Box.HANDLE] - box[Box.CENTER]\n                    offset = offset / np.linalg.norm(offset)\n                    offset_perp = np.array([offset[1], -offset[0]])\n\n                    fixed = self._fixed_vertex\n                    new = list(coord)\n\n                    if self._fixed_aspect and self._fixed_index % 2 == 0:\n                        if (new - fixed)[0] == 0:\n                            ratio = 1\n                        else:\n                            ratio = abs((new - fixed)[1] / (new - fixed)[0])\n                        if ratio > self._aspect_ratio:\n                            r = self._aspect_ratio / ratio\n                            new[1] = fixed[1] + (new[1] - fixed[1]) * r\n                        else:\n                            r = ratio / self._aspect_ratio\n                            new[0] = fixed[0] + (new[0] - fixed[0]) * r\n\n                    if size @ offset == 0:\n                        dist = 1\n                    else:\n                        dist = ((new - fixed) @ offset) / (size @ offset)\n\n                    if size @ offset_perp == 0:\n                        dist_perp = 1\n                    else:\n                        dist_perp = ((new - fixed) @ offset_perp) / (\n                            size @ offset_perp\n                        )\n\n                    if self._fixed_index % 2 == 0:\n                        # corner selected\n                        scale = np.array([dist_perp, dist])\n                    elif self._fixed_index % 4 == 3:\n                        # top selected\n                        scale = np.array([1, dist])\n                    else:\n                        # side selected\n                        scale = np.array([dist_perp, 1])\n\n                    # prevent box from shrinking below a threshold size\n                    threshold = self._vertex_size * self.scale_factor / 8\n                    scale[abs(scale * size[[1, 0]]) < threshold] = 1\n\n                    # check orientation of box\n                    angle = -np.arctan2(offset[0], -offset[1])\n                    c, s = np.cos(angle), np.sin(angle)\n                    if angle == 0:\n                        for index in self.selected_data:\n                            self._data_view.scale(\n                                index, scale, center=self._fixed_vertex\n                            )\n                        self._scale_box(scale, center=self._fixed_vertex)\n                    else:\n                        rotation = np.array([[c, s], [-s, c]])\n                        scale_mat = np.array([[scale[0], 0], [0, scale[1]]])\n                        inv_rot = np.array([[c, -s], [s, c]])\n                        transform = rotation @ scale_mat @ inv_rot\n                        for index in self.selected_data:\n                            self._data_view.shift(index, -self._fixed_vertex)\n                            self._data_view.transform(index, transform)\n                            self._data_view.shift(index, self._fixed_vertex)\n                        self._transform_box(\n                            transform, center=self._fixed_vertex\n                        )\n                    self.refresh()\n                elif vertex == 8:\n                    # Rotation handle is being dragged so rotate object\n                    handle = self._selected_box[Box.HANDLE]\n                    if self._drag_start is None:\n                        self._fixed_vertex = self._selected_box[Box.CENTER]\n                        offset = handle - self._fixed_vertex\n                        self._drag_start = -np.degrees(\n                            np.arctan2(offset[0], -offset[1])\n                        )\n\n                    new_offset = coord - self._fixed_vertex\n                    new_angle = -np.degrees(\n                        np.arctan2(new_offset[0], -new_offset[1])\n                    )\n                    fixed_offset = handle - self._fixed_vertex\n                    fixed_angle = -np.degrees(\n                        np.arctan2(fixed_offset[0], -fixed_offset[1])\n                    )\n\n                    if np.linalg.norm(new_offset) < 1:\n                        angle = 0\n                    elif self._fixed_aspect:\n                        angle = np.round(new_angle / 45) * 45 - fixed_angle\n                    else:\n                        angle = new_angle - fixed_angle\n\n                    for index in self.selected_data:\n                        self._data_view.rotate(\n                            index, angle, center=self._fixed_vertex\n                        )\n                    self._rotate_box(angle, center=self._fixed_vertex)\n                    self.refresh()\n            else:\n                self._is_selecting = True\n                if self._drag_start is None:\n                    self._drag_start = coord\n                self._drag_box = np.array([self._drag_start, coord])\n                self._set_highlight()\n        elif self._mode in [Mode.DIRECT, Mode.ADD_PATH, Mode.ADD_POLYGON]:\n            if len(self.selected_data) > 0:\n                if vertex is not None:\n                    self._is_moving = True\n                    index = self._moving_value[0]\n                    shape_type = type(self._data_view.shapes[index])\n                    if shape_type == Ellipse:\n                        # DIRECT vertex moving of ellipse not implemented\n                        pass\n                    else:\n                        if shape_type == Rectangle:\n                            new_type = Polygon\n                        else:\n                            new_type = None\n                        indices = self._data_view.displayed_index == index\n                        vertices = self._data_view.displayed_vertices[indices]\n                        vertices[vertex] = coord\n                        data_full = self.expand_shape(vertices)\n                        self._data_view.edit(\n                            index, data_full, new_type=new_type\n                        )\n                        shapes = self.selected_data\n                        self._selected_box = self.interaction_box(shapes)\n                        self.refresh()\n            else:\n                self._is_selecting = True\n                if self._drag_start is None:\n                    self._drag_start = coord\n                self._drag_box = np.array([self._drag_start, coord])\n                self._set_highlight()\n        elif self._mode in [Mode.VERTEX_INSERT, Mode.VERTEX_REMOVE]:\n            if len(self.selected_data) > 0:\n                pass\n            else:\n                self._is_selecting = True\n                if self._drag_start is None:\n                    self._drag_start = coord\n                self._drag_box = np.array([self._drag_start, coord])\n                self._set_highlight()\n\n    def to_masks(self, mask_shape=None):\n        """"""Return an array of binary masks, one for each shape.\n\n        Parameters\n        ----------\n        mask_shape : np.ndarray | tuple | None\n            tuple defining shape of mask to be generated. If non specified,\n            takes the max of all the vertiecs\n\n        Returns\n        ----------\n        masks : np.ndarray\n            Array where there is one binary mask for each shape\n        """"""\n        if mask_shape is None:\n            mask_shape = self.shape\n\n        mask_shape = np.ceil(mask_shape).astype(\'int\')\n        masks = self._data_view.to_masks(mask_shape=mask_shape)\n\n        return masks\n\n    def to_labels(self, labels_shape=None):\n        """"""Return an integer labels image.\n\n        Parameters\n        ----------\n        labels_shape : np.ndarray | tuple | None\n            Tuple defining shape of labels image to be generated. If non\n            specified, takes the max of all the vertiecs\n\n        Returns\n        ----------\n        labels : np.ndarray\n            Integer array where each value is either 0 for background or an\n            integer up to N for points inside the shape at the index value - 1.\n            For overlapping shapes z-ordering will be respected.\n        """"""\n        if labels_shape is None:\n            labels_shape = self.shape\n\n        labels_shape = np.ceil(labels_shape).astype(\'int\')\n        labels = self._data_view.to_labels(labels_shape=labels_shape)\n\n        return labels\n'"
napari/layers/surface/__init__.py,0,b'from .surface import Surface\n'
napari/layers/surface/surface.py,20,"b'import warnings\n\nimport numpy as np\n\nfrom ...utils.colormaps import AVAILABLE_COLORMAPS\nfrom ...utils.event import Event\nfrom ..base import Layer\nfrom ..utils.layer_utils import calc_data_range\nfrom ..intensity_mixin import IntensityVisualizationMixin\n\n\n# Mixin must come before Layer\nclass Surface(IntensityVisualizationMixin, Layer):\n    """"""\n    Surface layer renders meshes onto the canvas.\n\n    Parameters\n    ----------\n    data : 3-tuple of array\n        The first element of the tuple is an (N, D) array of vertices of\n        mesh triangles. The second is an (M, 3) array of int of indices\n        of the mesh triangles. The third element is the (K0, ..., KL, N)\n        array of values used to color vertices where the additional L\n        dimensions are used to color the same mesh with different values.\n    colormap : str, vispy.Color.Colormap, tuple, dict\n        Colormap to use for luminance images. If a string must be the name\n        of a supported colormap from vispy or matplotlib. If a tuple the\n        first value must be a string to assign as a name to a colormap and\n        the second item must be a Colormap. If a dict the key must be a\n        string to assign as a name to a colormap and the value must be a\n        Colormap.\n    contrast_limits : list (2,)\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If not passed is calculated as the min and max of\n        the image.\n    gamma : float\n        Gamma correction for determining colormap linearity. Defaults to 1.\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n\n    Attributes\n    ----------\n    data : 3-tuple of array\n        The first element of the tuple is an (N, D) array of vertices of\n        mesh triangles. The second is an (M, 3) array of int of indices\n        of the mesh triangles. The third element is the (K0, ..., KL, N)\n        array of values used to color vertices where the additional L\n        dimensions are used to color the same mesh with different values.\n    vertices : (N, D) array\n        Vertices of mesh triangles.\n    faces : (M, 3) array of int\n        Indices of mesh triangles.\n    vertex_values : (K0, ..., KL, N) array\n        Values used to color vertices.\n    colormap : str, vispy.Color.Colormap, tuple, dict\n        Colormap to use for luminance images. If a string must be the name\n        of a supported colormap from vispy or matplotlib. If a tuple the\n        first value must be a string to assign as a name to a colormap and\n        the second item must be a Colormap. If a dict the key must be a\n        string to assign as a name to a colormap and the value must be a\n        Colormap.\n    contrast_limits : list (2,)\n        Color limits to be used for determining the colormap bounds for\n        luminance images. If not passed is calculated as the min and max of\n        the image.\n    gamma : float\n        Gamma correction for determining colormap linearity.\n\n    Extended Summary\n    ----------\n    _data_view : (M, 2) or (M, 3) array\n        The coordinates of the vertices given the viewed dimensions.\n    _view_faces : (P, 3) array\n        The integer indices of the vertices that form the triangles\n        in the currently viewed slice.\n    _colorbar : array\n        Colorbar for current colormap.\n    """"""\n\n    _colormaps = AVAILABLE_COLORMAPS\n\n    def __init__(\n        self,\n        data,\n        *,\n        colormap=\'gray\',\n        contrast_limits=None,\n        gamma=1,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=1,\n        blending=\'translucent\',\n        visible=True,\n    ):\n\n        ndim = data[0].shape[1]\n\n        super().__init__(\n            data,\n            ndim,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n\n        self.events.add(interpolation=Event, rendering=Event)\n\n        # Set contrast_limits and colormaps\n        self._gamma = gamma\n        if contrast_limits is None:\n            self._contrast_limits_range = calc_data_range(data[2])\n        else:\n            self._contrast_limits_range = contrast_limits\n        self._contrast_limits = tuple(self._contrast_limits_range)\n        self.colormap = colormap\n        self.contrast_limits = self._contrast_limits\n\n        # Data containing vectors in the currently viewed slice\n        self._data_view = np.zeros((0, self.dims.ndisplay))\n        self._view_faces = np.zeros((0, 3))\n        self._view_vertex_values = []\n\n        # assign mesh data and establish default behavior\n        self._vertices = data[0]\n        self._faces = data[1]\n        self._vertex_values = data[2]\n\n        # Trigger generation of view slice and thumbnail\n        self._update_dims()\n\n    def _calc_data_range(self):\n        return calc_data_range(self.vertex_values)\n\n    @property\n    def dtype(self):\n        return self.vertex_values.dtype\n\n    @property\n    def data(self):\n        return (self.vertices, self.faces, self.vertex_values)\n\n    @property\n    def vertices(self):\n        return self._vertices\n\n    @vertices.setter\n    def vertices(self, vertices):\n        """"""Array of vertices of mesh triangles.""""""\n\n        self._vertices = vertices\n\n        self._update_dims()\n        self.refresh()\n        self.events.data()\n\n    @property\n    def vertex_values(self) -> np.ndarray:\n        return self._vertex_values\n\n    @vertex_values.setter\n    def vertex_values(self, vertex_values: np.ndarray):\n        """"""Array of values used to color vertices..""""""\n\n        self._vertex_values = vertex_values\n\n        self.refresh()\n        self.events.data()\n\n    @property\n    def faces(self) -> np.ndarray:\n        return self._faces\n\n    @faces.setter\n    def faces(self, faces: np.ndarray):\n        """"""Array of indices of mesh triangles..""""""\n\n        self.faces = faces\n\n        self.refresh()\n        self.events.data()\n\n    def _get_ndim(self):\n        """"""Determine number of dimensions of the layer.""""""\n        return self.vertices.shape[1] + (self.vertex_values.ndim - 1)\n\n    def _get_extent(self):\n        """"""Determine ranges for slicing given by (min, max, step).""""""\n        if len(self.vertices) == 0:\n            maxs = np.ones(self.vertices.shape[1], dtype=int)\n            mins = np.zeros(self.vertices.shape[1], dtype=int)\n        else:\n            maxs = np.max(self.vertices, axis=0)\n            mins = np.min(self.vertices, axis=0)\n\n        # The full dimensionality and shape of the layer is determined by\n        # the number of additional vertex value dimensions and the\n        # dimensionality of the vertices themselves\n        if self.vertex_values.ndim > 1:\n            mins = [0] * (self.vertex_values.ndim - 1) + list(mins)\n            maxs = list(self.vertex_values.shape[:-1]) + list(maxs)\n\n        return [(min, max) for min, max in zip(mins, maxs)]\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'colormap\': self.colormap[0],\n                \'contrast_limits\': self.contrast_limits,\n                \'gamma\': self.gamma,\n                \'data\': self.data,\n            }\n        )\n        return state\n\n    def _set_view_slice(self):\n        """"""Sets the view given the indices to slice with.""""""\n        N, vertex_ndim = self.vertices.shape\n        values_ndim = self.vertex_values.ndim - 1\n\n        # Take vertex_values dimensionality into account if more than one value\n        # is provided per vertex.\n        if values_ndim > 0:\n            # Get indices for axes corresponding to values dimensions\n            values_indices = self.dims.indices[:-vertex_ndim]\n            values = self.vertex_values[values_indices]\n            if values.ndim > 1:\n                warnings.warn(\n                    """"""Assigning multiple values per vertex after slicing is\n                    not allowed. All dimensions corresponding to vertex_values\n                    must be non-displayed dimensions. Data will not be\n                    visible.""""""\n                )\n                self._data_view = np.zeros((0, self.dims.ndisplay))\n                self._view_faces = np.zeros((0, 3))\n                self._view_vertex_values = []\n                return\n\n            self._view_vertex_values = values\n            # Determine which axes of the vertices data are being displayed\n            # and not displayed, ignoring the additional dimensions\n            # corresponding to the vertex_values.\n            indices = np.array(self.dims.indices[-vertex_ndim:])\n            disp = [\n                d\n                for d in np.subtract(self.dims.displayed, values_ndim)\n                if d >= 0\n            ]\n            not_disp = [\n                d\n                for d in np.subtract(self.dims.not_displayed, values_ndim)\n                if d >= 0\n            ]\n        else:\n            self._view_vertex_values = self.vertex_values\n            indices = np.array(self.dims.indices)\n            not_disp = list(self.dims.not_displayed)\n            disp = list(self.dims.displayed)\n\n        self._data_view = self.vertices[:, disp]\n        if len(self.vertices) == 0:\n            self._view_faces = np.zeros((0, 3))\n        elif vertex_ndim > self.dims.ndisplay:\n            vertices = self.vertices[:, not_disp].astype(\'int\')\n            triangles = vertices[self.faces]\n            matches = np.all(triangles == indices[not_disp], axis=(1, 2))\n            matches = np.where(matches)[0]\n            if len(matches) == 0:\n                self._view_faces = np.zeros((0, 3))\n            else:\n                self._view_faces = self.faces[matches]\n        else:\n            self._view_faces = self.faces\n\n    def _update_thumbnail(self):\n        """"""Update thumbnail with current surface.""""""\n        pass\n\n    def _get_value(self):\n        """"""Returns coordinates, values, and a string for a given mouse position\n        and set of indices.\n\n        Returns\n        ----------\n        value : int, None\n            Value of the data at the coord.\n        """"""\n\n        return None\n'"
napari/layers/utils/__init__.py,0,b''
napari/layers/utils/color_transformations.py,14,"b'""""""This file contains functions which are designed to assist Layer objects transform,\nnormalize and broadcast the color inputs they receive into a more standardized format -\na numpy array with N rows, N being the number of data points, and a dtype of np.float32.\n\n""""""\nfrom itertools import cycle\nfrom typing import Union, List, Tuple, AnyStr\nimport warnings\n\nfrom vispy.color import Color, ColorArray\nimport numpy as np\n\nfrom ...utils.colormaps.standardize_color import transform_color\n\n\n# All parsable input datatypes that a user can provide\nColorType = Union[List, Tuple, np.ndarray, AnyStr, Color, ColorArray]\n\n\ndef transform_color_with_defaults(\n    num_entries: int, colors: ColorType, elem_name: str, default: str\n) -> np.ndarray:\n    """"""Helper method to return an Nx4 np.array from an arbitrary user input.\n\n    Parameters\n    ----------\n    num_entries : int\n        The number of data elements in the layer\n    colors : ColorType\n        The wanted colors for each of the data points\n    elem_name : str\n        Whether we\'re trying to set the face color or edge color of the layer\n    default : str\n        The default color for that element in the layer\n\n    Returns\n    -------\n    transformed : np.ndarray\n        Nx4 numpy array with a dtype of np.float32\n    """"""\n    try:\n        transformed = transform_color(colors)\n    except (AttributeError, ValueError, KeyError):\n        warnings.warn(\n            f""The provided {elem_name} parameter contained illegal values, ""\n            f""reseting all {elem_name} values to {default}.""\n        )\n        transformed = transform_color(default)\n    else:\n        if (len(transformed) != 1) and (len(transformed) != num_entries):\n            warnings.warn(\n                f""The provided {elem_name} parameter has {len(colors)} entries, ""\n                f""while the data contains {num_entries} entries. Setting {elem_name} to {default}.""\n            )\n            transformed = transform_color(default)\n    return transformed\n\n\ndef transform_color_cycle(\n    color_cycle: Union[ColorType, cycle], elem_name: str, default: str\n) -> cycle:\n    """"""Helper method to return an Nx4 np.array from an arbitrary user input.\n\n    Parameters\n    ----------\n    colors : ColorType, cycle\n        The desired colors for each of the data points\n    elem_name : str\n        Whether we\'re trying to set the face color or edge color of the layer\n    default : str\n        The default color for that element in the layer\n\n    Returns\n    -------\n    transformed_color_cycle : cycle\n        cycle of Nx4 numpy arrays with a dtype of np.float32\n    transformed_colors : np.ndarray\n        input array of colors transformed to RGBA\n    """"""\n    transformed_colors = transform_color_with_defaults(\n        num_entries=len(color_cycle),\n        colors=color_cycle,\n        elem_name=elem_name,\n        default=default,\n    )\n    transformed_color_cycle = cycle(transformed_colors)\n\n    return transformed_color_cycle, transformed_colors\n\n\ndef normalize_and_broadcast_colors(\n    num_entries: int, colors: ColorType\n) -> np.ndarray:\n    """"""Takes an input color array and forces into being the length of ``data``.\n\n    Used when a single color is supplied for many input objects, but we need\n    Layer.current_face_color or Layer.current_edge_color to have the shape of\n    the actual data.\n\n    Note: This function can\'t robustly parse user input, and thus should\n    always be used on the output of ``transform_color_with_defaults``.\n\n    Parameters\n    ----------\n    num_entries : int\n        The number of data elements in the layer\n    color : ColorType\n        The user\'s input after being normalized by transform_color_with_defaults\n\n    Returns\n    -------\n    tiled : np.ndarray\n        A tiled version (if needed) of the original input\n    """"""\n    # len == 0 data is handled somewhere else\n    if (len(colors) == num_entries) or (num_entries == 0):\n        return np.asarray(colors)\n    # If the user has supplied a list of colors, but its length doesn\'t\n    # match the length of the data, we warn them and return a single\n    # color for all inputs\n    if len(colors) != 1:\n        warnings.warn(\n            f""The number of supplied colors mismatch the number of given""\n            f"" data points. Length of data is {num_entries}, while the number of colors""\n            f"" is {len(colors)}. Color for all points is reset to white.""\n        )\n        tiled = np.ones((num_entries, 4), dtype=np.float32)\n        return tiled\n    # All that\'s left is to deal with length=1 color inputs\n    tiled = np.tile(colors.ravel(), (num_entries, 1))\n    return tiled\n'"
napari/layers/utils/layer_utils.py,37,"b'from typing import Dict, Union, Tuple\n\nimport numpy as np\nfrom vispy.color import Colormap\n\n\ndef calc_data_range(data):\n    """"""Calculate range of data values. If all values are equal return [0, 1].\n\n    Parameters\n    -------\n    data : array\n        Data to calculate range of values over.\n\n    Returns\n    -------\n    values : list of float\n        Range of values.\n\n    Notes\n    -----\n    If the data type is uint8, no calculation is performed, and 0-255 is\n    returned.\n    """"""\n    if data.dtype == np.uint8:\n        return [0, 255]\n    if np.prod(data.shape) > 1e6:\n        # If data is very large take the average of the top, bottom, and\n        # middle slices\n        bottom_plane_idx = (0,) * (data.ndim - 2)\n        middle_plane_idx = tuple(s // 2 for s in data.shape[:-2])\n        top_plane_idx = tuple(s - 1 for s in data.shape[:-2])\n        idxs = [bottom_plane_idx, middle_plane_idx, top_plane_idx]\n        reduced_data = [\n            [np.max(data[idx]) for idx in idxs],\n            [np.min(data[idx]) for idx in idxs],\n        ]\n    else:\n        reduced_data = data\n\n    min_val = np.min(reduced_data)\n    max_val = np.max(reduced_data)\n\n    if min_val == max_val:\n        min_val = 0\n        max_val = 1\n    return [float(min_val), float(max_val)]\n\n\ndef segment_normal(a, b, p=(0, 0, 1)):\n    """"""Determines the unit normal of the vector from a to b.\n\n    Parameters\n    ----------\n    a : np.ndarray\n        Length 2 array of first point or Nx2 array of points\n    b : np.ndarray\n        Length 2 array of second point or Nx2 array of points\n    p : 3-tuple, optional\n        orthogonal vector for segment calculation in 3D.\n\n    Returns\n    -------\n    unit_norm : np.ndarray\n        Length the unit normal of the vector from a to b. If a == b,\n        then returns [0, 0] or Nx2 array of vectors\n    """"""\n    d = b - a\n\n    if d.ndim == 1:\n        if len(d) == 2:\n            normal = np.array([d[1], -d[0]])\n        else:\n            normal = np.cross(d, p)\n        norm = np.linalg.norm(normal)\n        if norm == 0:\n            norm = 1\n    else:\n        if d.shape[1] == 2:\n            normal = np.stack([d[:, 1], -d[:, 0]], axis=0).transpose(1, 0)\n        else:\n            normal = np.cross(d, p)\n\n        norm = np.linalg.norm(normal, axis=1, keepdims=True)\n        ind = norm == 0\n        norm[ind] = 1\n    unit_norm = normal / norm\n\n    return unit_norm\n\n\ndef convert_to_uint8(data: np.ndarray) -> np.ndarray:\n    """"""\n    Convert array content to uint8.\n\n    If all negative values are changed on 0.\n\n    If values are integer and bellow 256 it is simple casting otherwise maximum value for this data type is picked\n    and values are scaled by 255/maximum type value.\n\n    Binary images ar converted to [0,255] images.\n\n    float images are multiply by 255 and then casted to uint8.\n\n    Based on skimage.util.dtype.convert but limited to output type uint8\n    """"""\n    out_dtype = np.dtype(np.uint8)\n    out_max = np.iinfo(out_dtype).max\n    if data.dtype == out_dtype:\n        return data\n    in_kind = data.dtype.kind\n    if in_kind == ""b"":\n        return data.astype(out_dtype) * 255\n    if in_kind == ""f"":\n        image_out = np.multiply(data, out_max, dtype=data.dtype)\n        np.rint(image_out, out=image_out)\n        np.clip(image_out, 0, out_max, out=image_out)\n        return image_out.astype(out_dtype)\n\n    if in_kind in ""ui"":\n        if in_kind == ""u"":\n            if data.max() < out_max:\n                return data.astype(out_dtype)\n            return np.right_shift(data, (data.dtype.itemsize - 1) * 8).astype(\n                out_dtype\n            )\n        else:\n            np.maximum(data, 0, out=data, dtype=data.dtype)\n            if data.dtype == np.int8:\n                return (data * 2).astype(np.uint8)\n            if data.max() < out_max:\n                return data.astype(out_dtype)\n            return np.right_shift(\n                data, (data.dtype.itemsize - 1) * 8 - 1\n            ).astype(out_dtype)\n\n\ndef dataframe_to_properties(dataframe) -> Dict[str, np.ndarray]:\n    """"""Convert a dataframe to Points.properties formatted dictionary.\n\n    Parameters\n    ----------\n    dataframe : DataFrame\n        The dataframe object to be converted to a properties dictionary\n\n    Returns\n    -------\n    dict[str, np.ndarray]\n        A properties dictionary where the key is the property name and the value\n        is an ndarray with the property value for each point.\n    """"""\n\n    properties = {col: np.asarray(dataframe[col]) for col in dataframe}\n    index = None\n    if \'index\' in properties:\n        index = {i: k for k, i in enumerate(properties[\'index\'])}\n    return properties, index\n\n\ndef guess_continuous(property: np.ndarray) -> bool:\n    """"""Guess if the property is continuous (return True) or categorical (return False)""""""\n    # if the property is a floating type, guess continuous\n    if (\n        issubclass(property.dtype.type, np.floating)\n        or len(np.unique(property)) > 16\n    ):\n        return True\n    else:\n        return False\n\n\ndef map_property(\n    prop: np.ndarray,\n    colormap: Colormap,\n    contrast_limits: Union[None, Tuple[float, float]] = None,\n) -> Tuple[np.ndarray, Tuple[float, float]]:\n    """"""Apply a colormap to a property\n\n    Parameters\n    ----------\n    prop : np.ndarray\n        The property to be colormapped\n    colormap : vispy.color.Colormap\n        The vispy colormap object to apply to the property\n    contrast_limits: Union[None, Tuple[float, float]]\n        The contrast limits for applying the colormap to the property.\n        If a 2-tuple is provided, it should be provided as (lower_bound, upper_bound).\n        If None is provided, the contrast limits will be set to (property.min(), property.max()).\n        Default value is None.\n    """"""\n\n    if contrast_limits is None:\n        contrast_limits = (prop.min(), prop.max())\n    normalized_properties = np.interp(prop, contrast_limits, (0, 1))\n    mapped_properties = colormap.map(normalized_properties)\n\n    return mapped_properties, contrast_limits\n\n\ndef compute_multiscale_level(\n    requested_shape, shape_threshold, downsample_factors\n):\n    """"""Computed desired level of the multiscale given requested field of view.\n\n    The level of the multiscale should be the lowest resolution such that\n    the requested shape is above the shape threshold. By passing a shape\n    threshold corresponding to the shape of the canvas on the screen this\n    ensures that we have at least one data pixel per screen pixel, but no\n    more than we need.\n\n    Parameters\n    ----------\n    requested_shape : tuple\n        Requested shape of field of view in data coordinates\n    shape_threshold : tuple\n        Maximum size of a displayed tile in pixels.\n    downsample_factors : list of tuple\n        Downsampling factors for each level of the multiscale. Must be increasing\n        for each level of the multiscale.\n\n    Returns\n    -------\n    level : int\n        Level of the multiscale to be viewing.\n    """"""\n    # Scale shape by downsample factors\n    scaled_shape = requested_shape / downsample_factors\n\n    # Find the highest resolution level allowed\n    locations = np.argwhere(np.all(scaled_shape > shape_threshold, axis=1))\n    if len(locations) > 0:\n        level = locations[-1][0]\n    else:\n        level = 0\n    return level\n'"
napari/layers/vectors/__init__.py,0,b'from .vectors import Vectors\n'
napari/layers/vectors/_vector_utils.py,12,"b'import numpy as np\nfrom copy import copy\nfrom ..utils.layer_utils import segment_normal\n\n\ndef vectors_to_coordinates(vectors):\n    """"""Validate and convert vector data to a coordinate representation\n\n    Parameters\n    ----------\n    vectors : (N, 2, D) or (N1, N2, ..., ND, D) array\n        A (N, 2, D) array is interpreted as ""coordinate-like"" data and a list\n        of N vectors with start point and projections of the vector in D\n        dimensions. A (N1, N2, ..., ND, D) array is interpreted as\n        ""image-like"" data where there is a length D vector of the\n        projections at each pixel.\n\n    Returns\n    ----------\n    coords : (N, 2, D) array\n        A list of N vectors with start point and projections of the vector\n        in D dimensions.\n    """"""\n    if vectors.shape[-2] == 2 and vectors.ndim == 3:\n        # an (N, 2, D) array that is coordinate-like\n        coords = vectors\n    elif vectors.shape[-1] == vectors.ndim - 1:\n        # an (N1, N2, ..., ND, D) array that is image-like\n        coords = convert_image_to_coordinates(vectors)\n    else:\n        raise TypeError(\n            ""Vector data of shape %s is not supported"" % str(vectors.shape)\n        )\n\n    return coords\n\n\ndef convert_image_to_coordinates(vectors):\n    """"""To convert an image-like array with elements (y-proj, x-proj) into a\n    position list of coordinates\n    Every pixel position (n, m) results in two output coordinates of (N,2)\n\n    Parameters\n    ----------\n    vectors : (N1, N2, ..., ND, D) array\n        ""image-like"" data where there is a length D vector of the\n        projections at each pixel.\n\n    Returns\n    ----------\n    coords : (N, 2, D) array\n        A list of N vectors with start point and projections of the vector\n        in D dimensions.\n    """"""\n    # create coordinate spacing for image\n    spacing = [list(range(r)) for r in vectors.shape[:-1]]\n    grid = np.meshgrid(*spacing)\n\n    # create empty vector of necessary shape\n    nvect = np.prod(vectors.shape[:-1])\n    coords = np.empty((nvect, 2, vectors.ndim - 1), dtype=np.float32)\n\n    # assign coordinates to all pixels\n    for i, g in enumerate(grid):\n        coords[:, 0, i] = g.flatten()\n    coords[:, 1, :] = np.reshape(vectors, (-1, vectors.ndim - 1))\n\n    return coords\n\n\ndef generate_vector_meshes(vectors, width, length):\n    """"""Generates list of mesh vertices and triangles from a list of vectors\n\n    Parameters\n    ----------\n    vectors : (N, 2, D) array\n        A list of N vectors with start point and projections of the vector\n        in D dimensions, where D is 2 or 3.\n    width : float\n        width of the line to be drawn\n    length : float\n        length multiplier of the line to be drawn\n\n    Returns\n    ----------\n    vertices : (4N, D) array\n        Vertices of all triangles for the lines\n    triangles : (2N, 3) array\n        Vertex indices that form the mesh triangles\n    """"""\n    ndim = vectors.shape[2]\n    if ndim == 2:\n        vertices, triangles = generate_vector_meshes_2D(vectors, width, length)\n    else:\n        v_a, t_a = generate_vector_meshes_2D(\n            vectors, width, length, p=(0, 0, 1)\n        )\n        v_b, t_b = generate_vector_meshes_2D(\n            vectors, width, length, p=(1, 0, 0)\n        )\n        vertices = np.concatenate([v_a, v_b], axis=0)\n        triangles = np.concatenate([t_a, len(v_a) + t_b], axis=0)\n\n    return vertices, triangles\n\n\ndef generate_vector_meshes_2D(vectors, width, length, p=(0, 0, 1)):\n    """"""Generates list of mesh vertices and triangles from a list of vectors\n\n    Parameters\n    ----------\n    vectors : (N, 2, D) array\n        A list of N vectors with start point and projections of the vector\n        in D dimensions, where D is 2 or 3.\n    width : float\n        width of the line to be drawn\n    length : float\n        length multiplier of the line to be drawn\n    p : 3-tuple, optional\n        orthogonal vector for segment calculation in 3D.\n\n    Returns\n    ----------\n    vertices : (4N, D) array\n        Vertices of all triangles for the lines\n    triangles : (2N, 3) array\n        Vertex indices that form the mesh triangles\n    """"""\n    ndim = vectors.shape[2]\n    vectors = np.reshape(copy(vectors), (-1, ndim))\n    vectors[1::2] = vectors[::2] + length * vectors[1::2]\n\n    centers = np.repeat(vectors, 2, axis=0)\n    offsets = segment_normal(vectors[::2, :], vectors[1::2, :], p=p)\n    offsets = np.repeat(offsets, 4, axis=0)\n    signs = np.ones((len(offsets), ndim))\n    signs[::2] = -1\n    offsets = offsets * signs\n\n    vertices = centers + width * offsets / 2\n    triangles = np.array(\n        [\n            [2 * i, 2 * i + 1, 2 * i + 2]\n            if i % 2 == 0\n            else [2 * i - 1, 2 * i, 2 * i + 1]\n            for i in range(len(vectors))\n        ]\n    ).astype(np.uint32)\n\n    return vertices, triangles\n'"
napari/layers/vectors/_vectors_constants.py,1,"b'from enum import auto\nimport numpy as np\nfrom ...utils.misc import StringEnum\n\n\nclass ColorMode(StringEnum):\n    """"""\n    ColorMode: Color setting mode.\n\n    DIRECT (default mode) allows each point to be set arbitrarily\n\n    CYCLE allows the color to be set via a color cycle over an attribute\n\n    COLORMAP allows color to be set via a color map over an attribute\n    """"""\n\n    DIRECT = auto()\n    CYCLE = auto()\n    COLORMAP = auto()\n\n\nDEFAULT_COLOR_CYCLE = np.array([[1, 0, 1, 1], [0, 1, 0, 1]])\n'"
napari/layers/vectors/vectors.py,56,"b'import warnings\nfrom copy import copy\nfrom typing import Dict, List, Tuple, Union\n\nimport numpy as np\nfrom vispy.color.colormap import Colormap\n\nfrom ...types import ValidColormapArg\nfrom ...utils.colormaps import ensure_colormap_tuple\nfrom ...utils.event import Event\nfrom ...utils.status_messages import format_float\nfrom ..base import Layer\nfrom ..utils.color_transformations import (\n    normalize_and_broadcast_colors,\n    transform_color_cycle,\n    transform_color_with_defaults,\n)\nfrom ..utils.layer_utils import (\n    dataframe_to_properties,\n    guess_continuous,\n    map_property,\n)\nfrom ._vector_utils import generate_vector_meshes, vectors_to_coordinates\nfrom ._vectors_constants import DEFAULT_COLOR_CYCLE, ColorMode\n\n\nclass Vectors(Layer):\n    """"""\n    Vectors layer renders lines onto the canvas.\n\n    Parameters\n    ----------\n    data : (N, 2, D) or (N1, N2, ..., ND, D) array\n        An (N, 2, D) array is interpreted as ""coordinate-like"" data and a\n        list of N vectors with start point and projections of the vector in\n        D dimensions. An (N1, N2, ..., ND, D) array is interpreted as\n        ""image-like"" data where there is a length D vector of the\n        projections at each pixel.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each vector. Each property should be an array of length N,\n        where N is the number of vectors.\n    edge_width : float\n        Width for all vectors in pixels.\n    length : float\n         Multiplicative factor on projections for length of all vectors.\n    edge_color : str\n        Color of all of the vectors.\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set vector color if a continuous attribute is used to set edge_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n    name : str\n        Name of the layer.\n    metadata : dict\n        Layer metadata.\n    scale : tuple of float\n        Scale factors for the layer.\n    translate : tuple of float\n        Translation values for the layer.\n    opacity : float\n        Opacity of the layer visual, between 0.0 and 1.0.\n    blending : str\n        One of a list of preset blending modes that determines how RGB and\n        alpha values of the layer visual get mixed. Allowed values are\n        {\'opaque\', \'translucent\', and \'additive\'}.\n    visible : bool\n        Whether the layer visual is currently being displayed.\n\n    Attributes\n    ----------\n    data : (N, 2, D) array\n        The start point and projections of N vectors in D dimensions.\n    properties : dict {str: array (N,)}, DataFrame\n        Properties for each vector. Each property should be an array of length N,\n        where N is the number of vectors.\n    edge_width : float\n        Width for all vectors in pixels.\n    length : float\n         Multiplicative factor on projections for length of all vectors.\n    edge_color : str\n        Color of all of the vectors.\n    edge_color_cycle : np.ndarray, list\n        Cycle of colors (provided as string name, RGB, or RGBA) to map to edge_color if a\n        categorical attribute is used color the vectors.\n    edge_colormap : str, vispy.color.colormap.Colormap\n        Colormap to set vector color if a continuous attribute is used to set edge_color.\n        See vispy docs for details: http://vispy.org/color.html#vispy.color.Colormap\n    edge_contrast_limits : None, (float, float)\n        clims for mapping the property to a color map. These are the min and max value\n        of the specified property that are mapped to 0 and 1, respectively.\n        The default value is None. If set the none, the clims will be set to\n        (property.min(), property.max())\n\n    Extended Summary\n    ----------\n    _view_data : (M, 2, 2) array\n        The start point and projections of N vectors in 2D for vectors whose\n        start point is in the currently viewed slice.\n    _view_face_color : (M, 4) np.ndarray\n        colors for the M in view vectors\n    _view_indices : (1, M) array\n        indices for the M in view vectors\n    _view_vertices : (4M, 2) or (8M, 2) np.ndarray\n        the corner points for the M in view faces. Shape is (4M, 2) for 2D and (8M, 2) for 3D.\n    _view_faces : (2M, 3) or (4M, 3) np.ndarray\n        indices of the _mesh_vertices that form the faces of the M in view vectors.\n        Shape is (2M, 2) for 2D and (4M, 2) for 3D.\n    _property_choices : dict {str: array (N,)}\n        Possible values for the properties in Vectors.properties.\n        If properties is not provided, it will be {} (empty dictionary).\n    _mesh_vertices : (4N, 2) array\n        The four corner points for the mesh representation of each vector as as\n        rectangle in the slice that it starts in.\n    _mesh_triangles : (2N, 3) array\n        The integer indices of the `_mesh_vertices` that form the two triangles\n        for the mesh representation of the vectors.\n    _max_vectors_thumbnail : int\n        The maximum number of vectors that will ever be used to render the\n        thumbnail. If more vectors are present then they are randomly\n        subsampled.\n    """"""\n\n    # The max number of vectors that will ever be used to render the thumbnail\n    # If more vectors are present then they are randomly subsampled\n    _max_vectors_thumbnail = 1024\n\n    def __init__(\n        self,\n        data,\n        *,\n        properties=None,\n        edge_width=1,\n        edge_color=\'red\',\n        edge_color_cycle=None,\n        edge_colormap=\'viridis\',\n        edge_contrast_limits=None,\n        length=1,\n        name=None,\n        metadata=None,\n        scale=None,\n        translate=None,\n        opacity=0.7,\n        blending=\'translucent\',\n        visible=True,\n    ):\n\n        super().__init__(\n            data,\n            2,\n            name=name,\n            metadata=metadata,\n            scale=scale,\n            translate=translate,\n            opacity=opacity,\n            blending=blending,\n            visible=visible,\n        )\n\n        # events for non-napari calculations\n        self.events.add(\n            length=Event,\n            edge_width=Event,\n            edge_color=Event,\n            edge_color_mode=Event,\n        )\n\n        self.visible = False\n\n        # Save the vector style params\n        self._edge_width = edge_width\n\n        # length attribute\n        self._length = length\n\n        self.data = data\n\n        # Save the properties\n        if properties is None:\n            self._properties = {}\n            self._property_choices = {}\n        elif len(data) > 0:\n            properties, _ = dataframe_to_properties(properties)\n            self._properties = self._validate_properties(properties)\n            self._property_choices = {\n                k: np.unique(v) for k, v in properties.items()\n            }\n        elif len(data) == 0:\n            self._property_choices = {\n                k: np.asarray(v) for k, v in properties.items()\n            }\n            empty_properties = {\n                k: np.empty(0, dtype=v.dtype)\n                for k, v in self._property_choices.items()\n            }\n            self._properties = empty_properties\n\n        with self.block_update_properties():\n            self._edge_color_property = \'\'\n            self._edge_color_mode = ColorMode.DIRECT\n            self.edge_color = edge_color\n            if edge_color_cycle is None:\n                edge_color_cycle = DEFAULT_COLOR_CYCLE\n            self.edge_color_cycle = edge_color_cycle\n            self.edge_color_cycle_map = {}\n            self.edge_colormap = edge_colormap\n            self._edge_contrast_limits = edge_contrast_limits\n\n        self.refresh_colors()\n\n        # Data containing vectors in the currently viewed slice\n        self._view_data = np.empty((0, 2, 2))\n        self._displayed_stored = []\n        self._view_vertices = []\n        self._view_faces = []\n        self._view_indices = []\n\n        # now that everything is set up, make the layer visible (if set to visible)\n        self.visible = visible\n\n    @property\n    def data(self) -> np.ndarray:\n        """"""(N, 2, D) array: start point and projections of vectors.""""""\n        return self._data\n\n    @data.setter\n    def data(self, vectors: np.ndarray):\n        self._data = vectors_to_coordinates(vectors)\n\n        vertices, triangles = generate_vector_meshes(\n            self._data[:, :, list(self.dims.displayed)],\n            self.edge_width,\n            self.length,\n        )\n        self._mesh_vertices = vertices\n        self._mesh_triangles = triangles\n        self._displayed_stored = copy(self.dims.displayed)\n\n        self._update_dims()\n        self.events.data()\n\n    @property\n    def properties(self) -> Dict[str, np.ndarray]:\n        """"""dict {str: array (N,)}, DataFrame: Annotations for each point""""""\n        return self._properties\n\n    @properties.setter\n    def properties(self, properties: Dict[str, np.ndarray]):\n        if not isinstance(properties, dict):\n            properties, _ = dataframe_to_properties(properties)\n        self._properties = self._validate_properties(properties)\n        if self._edge_color_property and (\n            self._edge_color_property not in self._properties\n        ):\n            self._edge_color_property = \'\'\n            warnings.warn(\'property used for edge_color dropped\')\n\n    def _validate_properties(\n        self, properties: Dict[str, np.ndarray]\n    ) -> Dict[str, np.ndarray]:\n        """"""Validates the type and size of the properties""""""\n        for v in properties.values():\n            if len(v) != len(self.data):\n                raise ValueError(\n                    \'the number of properties must equal the number of points\'\n                )\n\n        return properties\n\n    def _get_state(self):\n        """"""Get dictionary of layer state.\n\n        Returns\n        -------\n        state : dict\n            Dictionary of layer state.\n        """"""\n        state = self._get_base_state()\n        state.update(\n            {\n                \'length\': self.length,\n                \'edge_width\': self.edge_width,\n                \'edge_color\': self.edge_color,\n                \'edge_color_cycle\': self.edge_color_cycle,\n                \'edge_colormap\': self.edge_colormap[0],\n                \'edge_contrast_limits\': self.edge_contrast_limits,\n                \'data\': self.data,\n                \'properties\': self.properties,\n            }\n        )\n        return state\n\n    def _get_ndim(self) -> int:\n        """"""Determine number of dimensions of the layer.""""""\n        return self.data.shape[2]\n\n    def _get_extent(self) -> List[Tuple[int, int, int]]:\n        """"""Determine ranges for slicing given by (min, max, step).""""""\n        if len(self.data) == 0:\n            maxs = np.ones(self.data.shape[2], dtype=int)\n            mins = np.zeros(self.data.shape[2], dtype=int)\n        else:\n            # Convert from projections to endpoints using the current length\n            data = copy(self.data)\n            data[:, 1, :] = data[:, 0, :] + self.length * data[:, 1, :]\n            maxs = np.max(data, axis=(0, 1))\n            mins = np.min(data, axis=(0, 1))\n\n        return [(min, max) for min, max in zip(mins, maxs)]\n\n    @property\n    def edge_width(self) -> Union[int, float]:\n        """"""float: Width for all vectors in pixels.""""""\n        return self._edge_width\n\n    @edge_width.setter\n    def edge_width(self, edge_width: Union[int, float]):\n        self._edge_width = edge_width\n\n        vertices, triangles = generate_vector_meshes(\n            self.data[:, :, list(self.dims.displayed)],\n            self._edge_width,\n            self.length,\n        )\n        self._mesh_vertices = vertices\n        self._mesh_triangles = triangles\n        self._displayed_stored = copy(self.dims.displayed)\n\n        self.events.edge_width()\n        self.refresh()\n        self.status = format_float(self.edge_width)\n\n    @property\n    def length(self) -> Union[int, float]:\n        """"""float: Multiplicative factor for length of all vectors.""""""\n        return self._length\n\n    @length.setter\n    def length(self, length: Union[int, float]):\n        self._length = length\n\n        vertices, triangles = generate_vector_meshes(\n            self.data[:, :, list(self.dims.displayed)],\n            self.edge_width,\n            self._length,\n        )\n        self._mesh_vertices = vertices\n        self._mesh_triangles = triangles\n        self._displayed_stored = copy(self.dims.displayed)\n\n        self.events.length()\n        self.refresh()\n        self.status = format_float(self.length)\n\n    @property\n    def edge_color(self) -> np.ndarray:\n        """"""(1 x 4) np.ndarray: Array of RGBA edge colors (applied to all vectors)""""""\n        return self._edge_color\n\n    @edge_color.setter\n    def edge_color(self, edge_color: str):\n        # save the old mode, we will emit an event if the mode has changed\n        old_mode = self._edge_color_mode\n\n        # if the provided face color is a string, first check if it is a key in the properties.\n        # otherwise, assume it is the name of a color\n        if self._is_color_mapped(edge_color):\n            if guess_continuous(self.properties[edge_color]):\n                new_mode = ColorMode.COLORMAP\n                self._edge_color_mode = new_mode\n            else:\n                new_mode = ColorMode.CYCLE\n                self._edge_color_mode = new_mode\n            self._edge_color_property = edge_color\n            self.refresh_colors()\n\n        else:\n            transformed_color = transform_color_with_defaults(\n                num_entries=len(self.data),\n                colors=edge_color,\n                elem_name=""edge_color"",\n                default=""white"",\n            )\n            self._edge_color = normalize_and_broadcast_colors(\n                len(self.data), transformed_color\n            )\n            new_mode = ColorMode.DIRECT\n            self._edge_color_mode = new_mode\n            self._edge_color_property = \'\'\n\n            self.events.edge_color()\n\n            if self.visible:\n                self._update_thumbnail()\n        if new_mode != old_mode:\n            self.events.edge_color_mode()\n\n    def refresh_colors(self, update_color_mapping: bool = False):\n        """"""Calculate and update edge colors if using a cycle or color map\n\n        Parameters\n        ----------\n        update_color_mapping : bool\n            If set to True, the function will recalculate the color cycle map\n            or colormap (whichever is being used). If set to False, the function\n            will use the current color cycle map or color map. For example, if you\n            are adding/modifying vectors and want them to be colored with the same\n            mapping as the other vectors (i.e., the new vectors shouldn\'t affect\n            the color cycle map or colormap), set update_color_mapping=False.\n            Default value is False.\n        """"""\n        if self._update_properties:\n            if self._edge_color_mode == ColorMode.CYCLE:\n                edge_color_properties = self.properties[\n                    self._edge_color_property\n                ]\n                if update_color_mapping:\n                    self.edge_color_cycle_map = {\n                        k: c\n                        for k, c in zip(\n                            np.unique(edge_color_properties),\n                            self._edge_color_cycle,\n                        )\n                    }\n                else:\n                    # add properties if they are not in the colormap\n                    # and update_color_mapping==False\n                    edge_color_cycle_keys = [*self.edge_color_cycle_map]\n                    props_in_map = np.in1d(\n                        edge_color_properties, edge_color_cycle_keys\n                    )\n                    if not np.all(props_in_map):\n                        props_to_add = np.unique(\n                            edge_color_properties[np.logical_not(props_in_map)]\n                        )\n                        for prop in props_to_add:\n                            self.edge_color_cycle_map[prop] = next(\n                                self._edge_color_cycle\n                            )\n                edge_colors = np.array(\n                    [\n                        self.edge_color_cycle_map[x]\n                        for x in edge_color_properties\n                    ]\n                )\n                if len(edge_colors) == 0:\n                    edge_colors = np.empty((0, 4))\n                self._edge_color = edge_colors\n            elif self._edge_color_mode == ColorMode.COLORMAP:\n                edge_color_properties = self.properties[\n                    self._edge_color_property\n                ]\n                if len(edge_color_properties) > 0:\n                    if (\n                        update_color_mapping\n                        or self.edge_contrast_limits is None\n                    ):\n                        edge_colors, contrast_limits = map_property(\n                            prop=edge_color_properties,\n                            colormap=self.edge_colormap[1],\n                        )\n                        self.edge_contrast_limits = contrast_limits\n                    else:\n                        edge_colors, _ = map_property(\n                            prop=edge_color_properties,\n                            colormap=self.edge_colormap[1],\n                            contrast_limits=self.edge_contrast_limits,\n                        )\n                else:\n                    edge_colors = np.empty((0, 4))\n                self._edge_color = edge_colors\n            self.events.edge_color()\n            if self.visible:\n                self._update_thumbnail()\n\n    def _is_color_mapped(self, color) -> bool:\n        """""" determines if the new color argument is for directly setting or cycle/colormap""""""\n        if isinstance(color, str):\n            if color in self.properties:\n                return True\n            else:\n                return False\n        elif isinstance(color, (list, np.ndarray)):\n            return False\n        else:\n            raise ValueError(\n                \'edge_color should be the name of a color, an array of colors, or the name of an property\'\n            )\n\n    @property\n    def edge_color_mode(self) -> ColorMode:\n        """"""str: Edge color setting mode\n\n        DIRECT (default mode) allows each vector to be set arbitrarily\n\n        CYCLE allows the color to be set via a color cycle over an attribute\n\n        COLORMAP allows color to be set via a color map over an attribute\n        """"""\n        return str(self._edge_color_mode)\n\n    @edge_color_mode.setter\n    def edge_color_mode(self, edge_color_mode: Union[str, ColorMode]):\n        edge_color_mode = ColorMode(edge_color_mode)\n\n        if edge_color_mode == ColorMode.DIRECT:\n            self._edge_color_mode = edge_color_mode\n        elif edge_color_mode in (ColorMode.CYCLE, ColorMode.COLORMAP):\n            if self._edge_color_property == \'\':\n                if self.properties:\n                    self._edge_color_property = next(iter(self.properties))\n                    warning_msg = (\n                        \'edge_color_property was not set, setting to: %s\'\n                        % self._edge_color_property\n                    )\n                    warnings.warn(warning_msg, RuntimeWarning)\n                else:\n                    raise ValueError(\n                        \'There must valid properties to use %s color mode\'\n                        % str(edge_color_mode)\n                    )\n            # ColorMode.COLORMAP can only be applied to numeric properties\n            if (edge_color_mode == ColorMode.COLORMAP) and not issubclass(\n                self.properties[self._edge_color_property].dtype.type,\n                np.number,\n            ):\n                raise TypeError(\n                    \'selected property must be numeric to use ColorMode.COLORMAP\'\n                )\n\n            self._edge_color_mode = edge_color_mode\n            self.refresh_colors()\n        self.events.edge_color_mode()\n\n    @property\n    def edge_color_cycle(self) -> np.ndarray:\n        """"""list, np.ndarray :  Color cycle for edge_color.\n        Can be a list of colors defined by name, RGB or RGBA\n        """"""\n        return self._edge_color_cycle_values\n\n    @edge_color_cycle.setter\n    def edge_color_cycle(self, edge_color_cycle: Union[list, np.ndarray]):\n        transformed_color_cycle, transformed_colors = transform_color_cycle(\n            color_cycle=edge_color_cycle,\n            elem_name=\'edge_color_cycle\',\n            default=""white"",\n        )\n        self._edge_color_cycle_values = transformed_colors\n        self._edge_color_cycle = transformed_color_cycle\n        if self._edge_color_mode == ColorMode.CYCLE:\n            self.refresh_colors(update_color_mapping=True)\n\n    @property\n    def edge_colormap(self) -> Tuple[str, Colormap]:\n        """"""Return the colormap to be applied to a property to get the edge color.\n\n        Returns\n        -------\n        colormap_name : str\n            The name of the current colormap.\n        colormap : vispy.color.Colormap\n            The vispy colormap object.\n        """"""\n        return self._edge_colormap_name, self._edge_colormap\n\n    @edge_colormap.setter\n    def edge_colormap(self, colormap: ValidColormapArg):\n        name, cmap = ensure_colormap_tuple(colormap)\n        self._edge_colormap_name = name\n        self._edge_colormap = cmap\n\n    @property\n    def edge_contrast_limits(self) -> Tuple[float, float]:\n        """""" None, (float, float): contrast limits for mapping\n        the edge_color colormap property to 0 and 1\n        """"""\n        return self._edge_contrast_limits\n\n    @edge_contrast_limits.setter\n    def edge_contrast_limits(\n        self, contrast_limits: Union[None, Tuple[float, float]]\n    ):\n        self._edge_contrast_limits = contrast_limits\n\n    @property\n    def _view_face_color(self) -> np.ndarray:\n        """""""" (Mx4) np.ndarray : colors for the M in view vectors""""""\n        face_color = np.repeat(self.edge_color[self._view_indices], 2, axis=0)\n        if self.dims.ndisplay == 3 and self.ndim > 2:\n            face_color = np.vstack([face_color, face_color])\n\n        return face_color\n\n    def _set_view_slice(self):\n        """"""Sets the view given the indices to slice with.""""""\n\n        if not self.dims.displayed == self._displayed_stored:\n            vertices, triangles = generate_vector_meshes(\n                self.data[:, :, list(self.dims.displayed)],\n                self.edge_width,\n                self.length,\n            )\n            self._mesh_vertices = vertices\n            self._mesh_triangles = triangles\n            self._displayed_stored = copy(self.dims.displayed)\n\n        vertices = self._mesh_vertices\n        not_disp = list(self.dims.not_displayed)\n        disp = list(self.dims.displayed)\n        indices = np.array(self.dims.indices)\n\n        if len(self.data) == 0:\n            faces = []\n            self._view_data = np.empty((0, 2, 2))\n            self._view_indices = []\n        elif self.ndim > 2:\n            data = self.data[:, 0, not_disp].astype(\'int\')\n            matches = np.all(data == indices[not_disp], axis=1)\n            matches = np.where(matches)[0]\n            self._view_indices = matches\n            self._view_data = self.data[np.ix_(matches, [0, 1], disp)]\n            if len(matches) == 0:\n                faces = []\n            else:\n                keep_inds = np.repeat(2 * matches, 2)\n                keep_inds[1::2] = keep_inds[1::2] + 1\n                if self.dims.ndisplay == 3:\n                    keep_inds = np.concatenate(\n                        [\n                            keep_inds,\n                            len(self._mesh_triangles) // 2 + keep_inds,\n                        ],\n                        axis=0,\n                    )\n                faces = self._mesh_triangles[keep_inds]\n        else:\n            faces = self._mesh_triangles\n            self._view_data = self.data[:, :, disp]\n            self._view_indices = np.arange(self.data.shape[0])\n\n        if len(faces) == 0:\n            self._view_vertices = []\n            self._view_faces = []\n        else:\n            self._view_vertices = vertices\n            self._view_faces = faces\n\n    def _update_thumbnail(self):\n        """"""Update thumbnail with current vectors and colors.""""""\n        # calculate min vals for the vertices and pad with 0.5\n        # the offset is needed to ensure that the top left corner of the\n        # vectors corresponds to the top left corner of the thumbnail\n        offset = (\n            np.array([self.dims.range[d][0] for d in self.dims.displayed])\n            + 0.5\n        )[-2:]\n        # calculate range of values for the vertices and pad with 1\n        # padding ensures the entire vector can be represented in the thumbnail\n        # without getting clipped\n        shape = np.ceil(\n            [\n                self.dims.range[d][1] - self.dims.range[d][0] + 1\n                for d in self.dims.displayed\n            ]\n        ).astype(int)[-2:]\n        zoom_factor = np.divide(self._thumbnail_shape[:2], shape).min()\n\n        # vectors = copy(self._data_view[:, :, -2:])\n        if self._view_data.shape[0] > self._max_vectors_thumbnail:\n            thumbnail_indices = np.random.randint(\n                0, self._view_data.shape[0], self._max_vectors_thumbnail\n            )\n            vectors = copy(self._view_data[thumbnail_indices, :, -2:])\n            thumbnail_color_indices = self._view_indices[thumbnail_indices]\n        else:\n            vectors = copy(self._view_data[:, :, -2:])\n            thumbnail_color_indices = self._view_indices\n        vectors[:, 1, :] = vectors[:, 0, :] + vectors[:, 1, :] * self.length\n        downsampled = (vectors - offset) * zoom_factor\n        downsampled = np.clip(\n            downsampled, 0, np.subtract(self._thumbnail_shape[:2], 1)\n        )\n        colormapped = np.zeros(self._thumbnail_shape)\n        colormapped[..., 3] = 1\n        edge_colors = self.edge_color[thumbnail_color_indices]\n        for v, ec in zip(downsampled, edge_colors):\n            start = v[0]\n            stop = v[1]\n            step = int(np.ceil(np.max(abs(stop - start))))\n            x_vals = np.linspace(start[0], stop[0], step)\n            y_vals = np.linspace(start[1], stop[1], step)\n            for x, y in zip(x_vals, y_vals):\n                colormapped[int(x), int(y), :] = ec\n        colormapped[..., 3] *= self.opacity\n        self.thumbnail = colormapped\n\n    def _get_value(self) -> None:\n        """"""Returns coordinates, values, and a string for a given mouse position\n        and set of indices.\n\n        Returns\n        ----------\n        value : int, None\n            Value of the data at the coord.\n        """"""\n\n        return None\n'"
napari/plugins/_tests/__init__.py,0,b''
napari/plugins/_tests/test_builtin_get_writer.py,0,"b'import os\n\nimport pytest\n\nfrom napari.plugins._builtins import (\n    napari_get_writer,\n    napari_write_image,\n    napari_write_points,\n    write_layer_data_with_plugins,\n)\nfrom napari_plugin_engine import PluginCallError\nfrom napari.plugins import hook_specifications\n\n\n# test_plugin_manager fixture is provided by napari_plugin_engine._testsupport\ndef test_get_writer_succeeds(\n    test_plugin_manager, tmpdir, layer_data_and_types, add_implementation\n):\n    """"""Test writing layers data.""""""\n    test_plugin_manager.project_name = \'napari\'\n    test_plugin_manager.add_hookspecs(hook_specifications)\n\n    _, layer_data, layer_types, filenames = layer_data_and_types\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    add_implementation(napari_write_image)\n    add_implementation(napari_write_points)\n    add_implementation(napari_get_writer)\n    writer = test_plugin_manager.hook.napari_get_writer(\n        path=path, layer_types=layer_types\n    )\n\n    # Write data\n    assert writer == write_layer_data_with_plugins\n    assert writer(\n        path, layer_data, plugin_name=None, plugin_manager=test_plugin_manager\n    )\n\n    # Check folder and files exist\n    assert os.path.isdir(path)\n    for f in filenames:\n        assert os.path.isfile(os.path.join(path, f))\n\n    assert set(os.listdir(path)) == set(filenames)\n    assert set(os.listdir(tmpdir)) == set([\'layers_folder\'])\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\n# test_plugin_manager fixture is provided by napari_plugin_engine._testsupport\ndef test_get_writer_bad_plugin(\n    test_plugin_manager, temporary_hookimpl, tmpdir, layer_data_and_types\n):\n    """"""Test cleanup when get_writer has an exception.""""""\n\n    test_plugin_manager.project_name = \'napari\'\n    test_plugin_manager.add_hookspecs(hook_specifications)\n\n    def bad_write_points(path, data, meta):\n        raise ValueError(""shoot!"")\n\n    _, layer_data, layer_types, filenames = layer_data_and_types\n\n    # this time we try writing directly to the tmpdir (which already exists)\n    writer = napari_get_writer(tmpdir, layer_types)\n    # call writer with a bad hook implementation inserted\n    with temporary_hookimpl(bad_write_points, \'napari_write_points\'):\n        with pytest.raises(PluginCallError):\n            writer(\n                tmpdir,\n                layer_data,\n                plugin_name=None,\n                plugin_manager=test_plugin_manager,\n            )\n\n    # should have deleted all new files, but not the tmpdir\n    assert os.path.isdir(tmpdir)\n    for f in filenames:\n        assert not os.path.isfile(os.path.join(tmpdir, f))\n\n    # now try writing to a nested folder inside of tmpdir\n    path = os.path.join(tmpdir, \'layers_folder\')\n    writer = napari_get_writer(path, layer_types)\n    # call writer with a bad hook implementation inserted\n    with temporary_hookimpl(bad_write_points, \'napari_write_points\'):\n        with pytest.raises(PluginCallError):\n            writer(\n                tmpdir,\n                layer_data,\n                plugin_name=None,\n                plugin_manager=test_plugin_manager,\n            )\n\n    # should have deleted the new nested folder, but not the tmpdir\n    assert os.path.isdir(tmpdir)\n    assert not os.path.exists(path)\n'"
napari/plugins/_tests/test_builtin_write_layers.py,5,"b'import os\nimport numpy as np\n\n\n# the layer_writer_and_data fixture is defined in napari/conftest.py\ndef test_write_layer_with_round_trip(tmpdir, layer_writer_and_data):\n    """"""Test writing layer data from napari layer_data tuple.""""""\n    writer, layer_data, extension, reader, Layer = layer_writer_and_data\n    path = os.path.join(tmpdir, \'layer_file\' + extension)\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    assert writer(path, layer_data[0], layer_data[1])\n\n    # Check file now exists\n    assert os.path.isfile(path)\n\n    # Read data\n    read_data, read_meta, layer_type = reader(path)\n\n    # Compare read data to original data on layer\n    if type(read_data) is list:\n        for rd, ld in zip(read_data, layer_data[0]):\n            np.testing.assert_allclose(rd, ld)\n    else:\n        np.testing.assert_allclose(read_data, layer_data[0])\n\n    # Instantiate layer\n    read_layer = Layer(read_data, **read_meta)\n    read_layer_data = read_layer.as_layer_data_tuple()\n\n    # Compare layer data\n    if type(read_layer_data[0]) is list:\n        for ld, rld in zip(layer_data[0], read_layer_data[0]):\n            np.testing.assert_allclose(ld, rld)\n    else:\n        np.testing.assert_allclose(layer_data[0], read_layer_data[0])\n\n    # # Compare layer metadata\n    np.testing.assert_equal(layer_data[1], read_layer_data[1])\n    # Compare layer type\n    assert layer_data[2] == read_layer_data[2]\n\n\n# the layer_writer_and_data fixture is defined in napari/conftest.py\ndef test_write_layer_no_extension(tmpdir, layer_writer_and_data):\n    """"""Test writing layer data with no extension.""""""\n    writer, layer_data, extension, _, _ = layer_writer_and_data\n    path = os.path.join(tmpdir, \'layer_file\')\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    assert writer(path, layer_data[0], layer_data[1])\n\n    # Check file now exists with extension\n    assert os.path.isfile(path + extension)\n\n\n# the layer_writer_and_data fixture is defined in napari/conftest.py\ndef test_no_write_layer_bad_extension(tmpdir, layer_writer_and_data):\n    """"""Test not writing layer data with a bad extension.""""""\n    writer, layer_data, _, _, _ = layer_writer_and_data\n    path = os.path.join(tmpdir, \'layer_file.bad_extension\')\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Check no data is writen\n    assert not writer(path, layer_data[0], layer_data[1])\n\n    # Check file still does not exist\n    assert not os.path.isfile(path)\n\n\n# the layer_writer_and_data fixture is defined in napari/conftest.py\ndef test_write_layer_no_metadata(tmpdir, layer_writer_and_data):\n    """"""Test writing layer data with no metadata.""""""\n    writer, layer_data, extension, _, _ = layer_writer_and_data\n    path = os.path.join(tmpdir, \'layer_file\' + extension)\n\n    # Check file does not exist\n    assert not os.path.isfile(path)\n\n    # Write data\n    assert writer(path, layer_data[0], {})\n\n    # Check file now exists\n    assert os.path.isfile(path)\n'"
napari/plugins/_tests/test_exceptions.py,0,"b'import sys\n\nimport pytest\n\nfrom napari.plugins import exceptions\nfrom napari_plugin_engine import PluginError\n\n\n# monkeypatch fixture is from pytest\n@pytest.mark.parametrize(\'as_html\', (True, False), ids=[\'as_html\', \'as_text\'])\n@pytest.mark.parametrize(\'cgitb\', (True, False), ids=[\'cgitb\', \'ipython\'])\ndef test_format_exceptions(cgitb, as_html, monkeypatch):\n    if cgitb:\n        monkeypatch.setitem(sys.modules, \'IPython.core.ultratb\', None)\n    monkeypatch.setattr(\n        exceptions,\n        \'standard_metadata\',\n        lambda x: {\'package\': \'test-package\', \'version\': \'0.1.0\'},\n    )\n    _ = PluginError(\n        \'some error\',\n        plugin_name=\'test_plugin\',\n        plugin=""mock"",\n        cause=ValueError(""cause""),\n    )\n    formatted = exceptions.format_exceptions(\'test_plugin\', as_html=as_html)\n    assert ""some error"" in formatted\n    assert ""version: 0.1.0"" in formatted\n    assert ""plugin package: test-package"" in formatted\n\n    assert exceptions.format_exceptions(\'nonexistent\', as_html=as_html) == \'\'\n'"
napari/plugins/_tests/test_hook_specifications.py,0,"b'import inspect\n\nimport pytest\nfrom numpydoc.docscrape import FunctionDoc\n\nfrom napari.plugins import hook_specifications\n\n# 1. we first create a hook specification decorator:\n#    ``napari_hook_specification = napari_plugin_engine.HookSpecificationMarker(""napari"")``\n# 2. when it decorates a function, that function object gets a new attribute\n#    called ""napari_spec""\n# 3. that attribute is what makes specifications discoverable when you run\n#    ``plugin_manager.add_hookspecs(module)``\n#    (The ``add_hookspecs`` method basically just looks through the module for\n#    any functions that have a ""napari_spec"" attribute.\n#\n# here, we are using that attribute to discover all of our internal hook\n# specifications (in module ``napari.plugins.hook_specifications``) so as to\n# make sure that they conform to our own internal rules about documentation and\n# type annotations, etc...\n\n\nHOOK_SPECIFICATIONS = [\n    (name, func)\n    for name, func in vars(hook_specifications).items()\n    if hasattr(func, \'napari_spec\')\n]\n\n\n@pytest.mark.parametrize(""name, func"", HOOK_SPECIFICATIONS)\ndef test_hook_specification_naming(name, func):\n    """"""All hook specifications should begin with napari_.""""""\n    assert name.startswith(\'napari_\'), (\n        ""hook specification \'%s\' does not start with \'napari_\'"" % name\n    )\n\n\n@pytest.mark.parametrize(""name, func"", HOOK_SPECIFICATIONS)\ndef test_docstring_on_hook_specification(name, func):\n    """"""All hook specifications should have documentation.""""""\n    assert func.__doc__, ""no docstring for \'%s\'"" % name\n\n\n@pytest.mark.parametrize(""name, func"", HOOK_SPECIFICATIONS)\ndef test_annotation_on_hook_specification(name, func):\n    """"""All hook specifications should have type annotations for all parameters.\n\n    (Use typing.Any to bail out). If the hook specification accepts no\n    parameters, then it should declare a return type annotation.  (until we\n    identify a case where a hook specification needs to both take no parameters\n    and return nothing)\n    """"""\n    sig = inspect.signature(func)\n    if sig.parameters:\n        for param in sig.parameters.values():\n            for forbidden in (\'_plugin\', \'_skip_impls\', \'_return_result_obj\'):\n                assert (\n                    param.name != forbidden\n                ), f\'Must not name hook_specification argument ""{forbidden}"".\'\n            assert param.annotation is not param.empty, (\n                f""in hook specification \'{name}\', parameter \'{param}\' ""\n                ""has no type annotation""\n            )\n    else:\n        assert sig.return_annotation is not sig.empty, (\n            f""hook specifications with no parameters ({name}),""\n            "" must declare a return type annotation""\n        )\n\n\n@pytest.mark.parametrize(""name, func"", HOOK_SPECIFICATIONS)\ndef test_docs_match_signature(name, func):\n    sig = inspect.signature(func)\n    docs = FunctionDoc(func)\n    sig_params = set(sig.parameters)\n    doc_params = {p.name for p in docs.get(\'Parameters\')}\n    assert sig_params == doc_params, (\n        f""Signature parameters for hook specification \'{name}\' do ""\n        ""not match the parameters listed in the docstring:\\n""\n        f""{sig_params} != {doc_params}""\n    )\n'"
napari/plugins/_tests/test_pypi.py,0,"b'from unittest import mock\nfrom napari.plugins import pypi\n\n\nclass FakeResponse:\n    def __init__(self, *, data: bytes):\n        self.data = data\n\n    def read(self):\n        return self.data\n\n    def close(self):\n        pass\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *exc):\n        return\n\n\ntxtA = (\n    \'<!DOCTYPE html>\\n<html>\\n  <head>\\n  <title>Simple index</title>\'\n    \'\\n </head>\\n  <body>\\n  <a href=""/simple/package1/"">package1</a>\'\n    \'\\n  <a href=""/simple/package2/"">packge2</a>\\n   </body>\\n</html>\'\n).encode()\n\ntxtB = (\n    f\'<!DOCTYPE html>\\n<html>\\n  <head>\\n    <title>Links for package\'\n    f\'</title>\\n  </head>\\n  <body>\\n    <h1>Links for package</h1>\\n\'\n    f\'<a href=""http://pythonhosted.org/package-0.1.0.tar.gz#sha256=7"">\'\n    f\'package-0.1.0.tar.gz</a><br/>\\n </body>\\n</html>\'\n).encode()\n\n\n@mock.patch(\n    \'napari.plugins.pypi.request.urlopen\', return_value=FakeResponse(data=txtA)\n)\ndef test_get_packages_by_prefix(mock_get):\n    urls = pypi.get_packages_by_prefix(\'package\')\n    assert \'package1\' in urls\n    assert urls[\'package1\'] == \'https://pypi.org/simple/package1/\'\n\n\n@mock.patch(\n    \'napari.plugins.pypi.request.urlopen\', return_value=FakeResponse(data=txtB)\n)\ndef test_get_package_versions(mock_get):\n    versions = pypi.get_package_versions(\'package\')\n    assert \'0.1.0\' in versions\n    # Test that we can clear the URL and VERSION CACHE\n    assert \'package\' in pypi.VERSION_CACHE\n    pypi.clear_cache()\n    assert pypi.URL_CACHE == {}\n    assert pypi.VERSION_CACHE == {}\n'"
napari/plugins/_tests/test_reader_plugins.py,8,"b'import os\nfrom pathlib import Path\nfrom tempfile import NamedTemporaryFile\n\nimport numpy as np\nfrom napari.utils import io\n\nfrom napari.plugins.io import read_data_with_plugins\n\n\ndef test_builtin_reader_plugin(viewer_factory):\n    """"""Test the builtin reader plugin reads a temporary file.""""""\n\n    with NamedTemporaryFile(suffix=\'.tif\', delete=False) as tmp:\n        data = np.random.rand(20, 20)\n        io.imsave(tmp.name, data)\n        tmp.seek(0)\n        layer_data = read_data_with_plugins(tmp.name)\n\n        assert isinstance(layer_data, list)\n        assert len(layer_data) == 1\n        assert isinstance(layer_data[0], tuple)\n        assert np.allclose(data, layer_data[0][0])\n\n        view, viewer = viewer_factory()\n        viewer.open(tmp.name, plugin=\'builtins\')\n\n        assert np.allclose(viewer.layers[0].data, data)\n\n\ndef test_builtin_reader_plugin_csv(viewer_factory, tmpdir):\n    """"""Test the builtin reader plugin reads a temporary file.""""""\n    tmp = os.path.join(tmpdir, \'test.csv\')\n    column_names = [\'index\', \'axis-0\', \'axis-1\']\n    table = np.random.random((5, 3))\n    data = table[:, 1:]\n    # Write csv file\n    io.write_csv(tmp, table, column_names=column_names)\n    layer_data = read_data_with_plugins(tmp)\n\n    assert isinstance(layer_data, list)\n    assert len(layer_data) == 1\n    assert isinstance(layer_data[0], tuple)\n    assert layer_data[0][2] == \'points\'\n    assert np.allclose(data, layer_data[0][0])\n\n    view, viewer = viewer_factory()\n    viewer.open(tmp, plugin=\'builtins\')\n\n    assert np.allclose(viewer.layers[0].data, data)\n\n\ndef test_builtin_reader_plugin_stacks(viewer_factory):\n    """"""Test the builtin reader plugin reads multiple files as a stack.""""""\n    data = np.random.rand(5, 20, 20)\n    tmps = []\n    for plane in data:\n        tmp = NamedTemporaryFile(suffix=\'.tif\', delete=False)\n        io.imsave(tmp.name, plane)\n        tmp.seek(0)\n        tmps.append(tmp)\n\n    _, viewer = viewer_factory()\n    # open should take both strings and Path object, so we make one of the\n    # pathnames a Path object\n    names = [tmp.name for tmp in tmps]\n    names[0] = Path(names[0])\n    viewer.open(names, stack=True, plugin=\'builtins\')\n    assert np.allclose(viewer.layers[0].data, data)\n    for tmp in tmps:\n        tmp.close()\n        os.unlink(tmp.name)\n'"
napari/plugins/_tests/test_save_layers.py,0,"b'import os\n\nimport pytest\n\nfrom napari.plugins.io import save_layers\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_save_layer_single_named_plugin(tmpdir, layer_data_and_types):\n    """"""Test saving a single layer with a named plugin.""""""\n    layers, _, _, filenames = layer_data_and_types\n\n    for layer, fn in zip(layers, filenames):\n        path = os.path.join(tmpdir, fn)\n\n        # Check file does not exist\n        assert not os.path.isfile(path)\n\n        # Write data\n        save_layers(path, [layer], plugin=\'builtins\')\n\n        # Check file now exists\n        assert os.path.isfile(path)\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_save_layer_no_results(tmpdir):\n    """"""Test no layers is not an error, and warns on no results.""""""\n\n    with pytest.warns(UserWarning):\n        result = save_layers(\'no_layers\', [], plugin=\'builtins\')\n        assert result == []\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_save_layer_single_no_named_plugin(tmpdir, layer_data_and_types):\n    """"""Test saving a single layer without naming plugin.""""""\n    # make writer builtin plugins get called first\n    from napari.plugins import plugin_manager\n\n    plugin_manager.hooks.napari_write_image.bring_to_front([\'builtins\'])\n    plugin_manager.hooks.napari_write_points.bring_to_front([\'builtins\'])\n\n    layers, _, _, filenames = layer_data_and_types\n\n    for layer, fn in zip(layers, filenames):\n        path = os.path.join(tmpdir, fn)\n\n        # Check file does not exist\n        assert not os.path.isfile(path)\n\n        # Write data\n        save_layers(path, [layer])\n\n        # Check file now exists\n        assert os.path.isfile(path)\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_save_layer_multiple_named_plugin(tmpdir, layer_data_and_types):\n    """"""Test saving multiple layers with a named plugin.""""""\n    layers, _, _, filenames = layer_data_and_types\n\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    # Check file does not exist\n    assert not os.path.isdir(path)\n\n    # Write data\n    save_layers(path, layers, plugin=\'builtins\')\n\n    # Check folder now exists\n    assert os.path.isdir(path)\n\n    # Check individual files now exist\n    for f in filenames:\n        assert os.path.isfile(os.path.join(path, f))\n\n    # Check no additional files exist\n    assert set(os.listdir(path)) == set(filenames)\n    assert set(os.listdir(tmpdir)) == set([\'layers_folder\'])\n\n\n# the layer_data_and_types fixture is defined in napari/conftest.py\ndef test_save_layer_multiple_no_named_plugin(tmpdir, layer_data_and_types):\n    """"""Test saving multiple layers without naming a plugin.""""""\n    # make writer builtin plugins get called first\n    from napari.plugins import plugin_manager\n\n    plugin_manager.hooks.napari_get_writer.bring_to_front([\'builtins\'])\n\n    layers, _, _, filenames = layer_data_and_types\n\n    path = os.path.join(tmpdir, \'layers_folder\')\n\n    # Check file does not exist\n    assert not os.path.isdir(path)\n\n    # Write data\n    save_layers(path, layers, plugin=\'builtins\')\n\n    # Check folder now exists\n    assert os.path.isdir(path)\n\n    # Check individual files now exist\n    for f in filenames:\n        assert os.path.isfile(os.path.join(path, f))\n\n    # Check no additional files exist\n    assert set(os.listdir(path)) == set(filenames)\n    assert set(os.listdir(tmpdir)) == set([\'layers_folder\'])\n\n\ndef test_default_save_order():\n    from napari.plugins import plugin_manager\n\n    write_image = plugin_manager.hook.napari_write_image\n    implementations = [i.plugin_name for i in write_image.get_hookimpls()]\n    assert implementations.index(\'svg\') < implementations.index(\'builtins\')\n\n    write_labels = plugin_manager.hook.napari_write_labels\n    implementations = [i.plugin_name for i in write_labels.get_hookimpls()]\n    assert implementations.index(\'svg\') < implementations.index(\'builtins\')\n\n    get_writer = plugin_manager.hook.napari_get_writer\n    implementations = [i.plugin_name for i in get_writer.get_hookimpls()]\n    assert implementations.index(\'svg\') < implementations.index(\'builtins\')\n'"
napari/utils/_tests/__init__.py,0,b''
napari/utils/_tests/colors_data.py,12,"b'""""""\nThis file contains most (all?) permutations of single and dual colors\nwhich a user can try to use as an argument to face_color and edge_color\nin the relevant layers. The idea is to parameterize the tests over these\noptions.\n\nVispy has a few bugs/limitations that we\'re trying to overcome. First, it\ndoesn\'t parse lists like [Color(\'red\'), Color(\'red\')]. Second, the color of\n\'g\' and \'green\' is different. We\'re consistent with vispy\'s behavior ATM,\nbut it might change in a future release.\n""""""\nfrom vispy.color import Color, ColorArray\nimport numpy as np\n\n# Apparently there are two types of greens - \'g\' is represented by a\n# (0, 1, 0) tuple, while \'green\' has an approximate value of\n# (0, 0.5, 0). This is why these two colors are treated differently\n# below.\nREDA = (1.0, 0.0, 0.0, 1.0)\nRED = (1.0, 0.0, 0.0)\nREDF = \'#ff0000\'\nGREENV = Color(\'green\').rgb[1]\nGREENA = (0.0, GREENV, 0.0, 1.0)\nGREEN = (0.0, GREENV, 0.0)\nGREENF = Color(\'green\').hex\nREDARR = np.array([[1.0, 0.0, 0.0, 1.0]], dtype=np.float32)\nGREENARR = np.array([[0.0, GREENV, 0.0, 1.0]], dtype=np.float32)\n\nsingle_color_options = [\n    RED,\n    GREENA,\n    \'transparent\',\n    \'red\',\n    \'g\',\n    GREENF,\n    \'#ffccaa44\',\n    REDA,\n    REDARR[0, :3],\n    Color(RED).rgb,\n    Color(GREENF).rgba,\n    ColorArray(\'red\').rgb,\n    ColorArray(GREENA).rgba,\n    ColorArray(GREEN).rgb,\n    ColorArray([GREENA]).rgba,\n    GREENARR,\n    REDF,\n    np.array([GREEN]),\n    np.array([GREENF]),\n    None,\n]\n\nsingle_colors_as_array = [\n    ColorArray(RED).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray((0.0, 0.0, 0.0, 0.0)).rgba,\n    ColorArray(RED).rgba,\n    ColorArray(\'#00ff00\').rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(\'#ffccaa44\').rgba,\n    ColorArray(RED).rgba,\n    ColorArray(RED).rgba,\n    ColorArray(RED).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(RED).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(RED).rgba,\n    ColorArray(GREEN).rgba,\n    ColorArray(GREEN).rgba,\n    np.zeros((1, 4), dtype=np.float32),\n]\n\ntwo_color_options = [\n    [\'red\', \'red\'],\n    (\'green\', \'red\'),\n    [\'green\', \'#ff0000\'],\n    [\'green\', \'g\'],\n    (\'r\' for r in range(2)),\n    [\'r\', \'r\'],\n    np.array([\'r\', \'r\']),\n    np.array([[1, 1, 1, 1], [0, GREENV, 0, 1]]),\n    (None, \'green\'),\n    [GREENARR[0, :3], REDARR[0, :3]],\n]\n# Some of the options below are commented out. When the bugs with\n# vispy described above are resolved, we can uncomment the lines\n# below as well.\ntwo_colors_simple = [\n    [\'red\', \'red\'],\n    [\'green\', \'red\'],\n    [\'green\', \'red\'],\n    [\'green\', \'g\'],\n    [\'red\', \'red\'],\n    [\'red\', \'red\'],\n    [\'red\', \'red\'],\n    [\'white\', \'green\'],\n    (None, \'green\'),\n    [\'green\', \'red\'],\n]\n\ntwo_colors_as_array = [ColorArray(color).rgba for color in two_colors_simple]\n\ninvalid_colors = [\n    \'rr\',\n    \'gf\',\n    \'#gf9gfg\',\n    \'#ff00000\',\n    \'#ff0000ii\',\n    (-1, 0.0, 0.0, 0.0),\n    (\'a\', 1, 1, 1),\n    4,\n    (3,),\n    (34, 342, 2334, 4343, 32, 0.1, -1),\n    np.array([[1, 1, 1, 1, 1]]),\n    np.array([[[0, 1, 1, 1]]]),\n    ColorArray([\'r\', \'r\']),\n    Color(\'red\'),\n    (REDARR, GREENARR),\n]\n\nwarning_colors = [\n    np.array([]),\n    np.array([\'g\', \'g\'], dtype=object),\n    [],\n    [[1, 2], [3, 4], [5, 6]],\n    np.array([[10], [10], [10], [10]]),\n]\n'"
napari/utils/_tests/test_color_to_array.py,10,"b'import pytest\nimport numpy as np\n\nfrom .colors_data import (\n    single_color_options,\n    single_colors_as_array,\n    two_color_options,\n    two_colors_as_array,\n    invalid_colors,\n    warning_colors,\n)\nfrom napari.utils.colormaps.standardize_color import transform_color\n\n\n@pytest.mark.parametrize(\n    ""colors, true_colors"", zip(single_color_options, single_colors_as_array)\n)\ndef test_oned_points(colors, true_colors):\n    np.testing.assert_array_equal(true_colors, transform_color(colors))\n\n\ndef test_warns_but_parses():\n    """"""Test collection of colors that raise a warning but do not return\n    a default white color array.\n    """"""\n    colors = [\'\', (43, 3, 3, 3), np.array([[3, 3, 3, 3], [0, 0, 0, 1]])]\n\n    true_colors = [\n        np.zeros((1, 4), dtype=np.float32),\n        np.array([[1, 3 / 43, 3 / 43, 3 / 43]], dtype=np.float32),\n        np.array(\n            [[1.0, 1.0, 1.0, 1.0], [0.0, 0.0, 0.0, 1.0]], dtype=np.float32\n        ),\n    ]\n    with pytest.warns(UserWarning):\n        for true, color in zip(true_colors, colors):\n            np.testing.assert_array_equal(true, transform_color(color))\n\n\n@pytest.mark.parametrize(\n    ""colors, true_colors"", zip(two_color_options, two_colors_as_array)\n)\ndef test_twod_points(colors, true_colors):\n    np.testing.assert_array_equal(true_colors, transform_color(colors))\n\n\n@pytest.mark.parametrize(""color"", invalid_colors)\ndef test_invalid_colors(color):\n    with pytest.raises((ValueError, AttributeError, KeyError)):\n        transform_color(color)\n\n\n@pytest.mark.parametrize(""colors"", warning_colors)\ndef test_warning_colors(colors):\n    with pytest.warns(UserWarning):\n        np.testing.assert_array_equal(\n            np.ones((max(len(colors), 1), 4), dtype=np.float32),\n            transform_color(colors),\n        )\n'"
napari/utils/_tests/test_colormaps.py,2,"b'import pytest\nimport numpy as np\n\nfrom ..colormaps.colormaps import (\n    AVAILABLE_COLORMAPS,\n    increment_unnamed_colormap,\n)\nfrom vispy.color.color_array import ColorArray\n\n\n@pytest.mark.parametrize(""name"", list(AVAILABLE_COLORMAPS.keys()))\ndef test_colormap(name):\n    cmap = AVAILABLE_COLORMAPS[name]\n\n    # colormaps should accept a scalar with the __getitem__ method\n    # and return a ColorArray\n    assert isinstance(cmap[0.5], ColorArray)\n\n    # colormaps should accept a 1D array with the __getitem__ method\n    # and return a ColorArray\n    assert isinstance(cmap[np.linspace(0, 1, 256) ** 0.5], ColorArray)\n\n    # colormap.map() is a lower level API\n    # it takes a (N, 1) vector of values in [0, 1], and returns a rgba array of\n    # size (N, 4). as per the vispy documentation: This function doesn\'t need\n    # to implement argument checking on `item`. It can always assume that\n    # `item` is a (N, 1) array of values between 0 and 1.\n    # http://vispy.org/color.html\n    q = np.random.rand(10, 10)\n    assert cmap.map(q.reshape(-1, 1)).shape == (q.size, 4)\n\n\ndef test_increment_unnamed_colormap():\n    # test that unnamed colormaps are incremented\n    names = [\n        \'[unnamed colormap 0\',\n        \'existing_colormap\',\n        \'perceptually_uniform\',\n        \'[unnamed colormap 1]\',\n    ]\n    assert increment_unnamed_colormap(names) == \'[unnamed colormap 2]\'\n\n    # test that named colormaps are not incremented\n    named_colormap = \'perfect_colormap\'\n    assert increment_unnamed_colormap(names, named_colormap) == named_colormap\n'"
napari/utils/_tests/test_info.py,0,"b'from ..info import sys_info, citation_text\n\n\ndef test_sys_info():\n    str_info = sys_info()\n    assert isinstance(str_info, str)\n    assert \'<br>\' not in str_info\n    assert \'<b>\' not in str_info\n    assert ""Plugins"" in str_info\n\n    html_info = sys_info(as_html=True)\n    assert isinstance(html_info, str)\n    assert \'<br>\' in html_info\n    assert \'<b>\' in html_info\n\n\ndef test_citation_text():\n    assert isinstance(citation_text, str)\n    assert \'doi\' in citation_text\n'"
napari/utils/_tests/test_interactions.py,0,"b'import pytest\nfrom ..interactions import ReadOnlyWrapper\n\n\ndef test_ReadOnlyWrapper_setitem():\n    """"""test that ReadOnlyWrapper prevents setting items""""""\n    d = {\'hi\': 3}\n    d_read_only = ReadOnlyWrapper(d)\n\n    with pytest.raises(TypeError):\n        d_read_only[\'hi\'] = 5\n\n\ndef test_ReadOnlyWrapper_setattr():\n    """"""test that ReadOnlyWrapper prevents setting attributes""""""\n\n    class TestClass:\n        x = 3\n\n    tc = TestClass()\n    tc_read_only = ReadOnlyWrapper(tc)\n\n    with pytest.raises(TypeError):\n        tc_read_only.x = 5\n'"
napari/utils/_tests/test_io.py,23,"b'import os\nimport csv\nfrom pathlib import Path\nimport numpy as np\nfrom dask import array as da\nfrom tempfile import TemporaryDirectory\nfrom napari.utils import io\nimport pytest\n\n\ntry:\n    import zarr\n\n    zarr_available = True\nexcept ImportError:\n    zarr_available = False\n\n\n# the following fixtures are defined in napari/conftest.py\n# single_png, two_pngs, irregular_images, single_tiff\n\n\ndef test_single_png_defaults(single_png):\n    image_files = single_png\n    images = io.magic_imread(image_files)\n    assert isinstance(images, np.ndarray)\n    assert images.shape == (512, 512)\n\n\ndef test_single_png_single_file(single_png):\n    image_files = single_png[0]\n    images = io.magic_imread(image_files)\n    assert isinstance(images, np.ndarray)\n    assert images.shape == (512, 512)\n\n\ndef test_single_png_pathlib(single_png):\n    image_files = Path(single_png[0])\n    images = io.magic_imread(image_files)\n    assert isinstance(images, np.ndarray)\n    assert images.shape == (512, 512)\n\n\ndef test_multi_png_defaults(two_pngs):\n    image_files = two_pngs\n    images = io.magic_imread(image_files)\n    assert isinstance(images, da.Array)\n    assert images.shape == (2, 512, 512)\n\n\ndef test_multi_png_pathlib(two_pngs):\n    image_files = [Path(png) for png in two_pngs]\n    images = io.magic_imread(image_files)\n    assert isinstance(images, da.Array)\n    assert images.shape == (2, 512, 512)\n\n\ndef test_multi_png_no_dask(two_pngs):\n    image_files = two_pngs\n    images = io.magic_imread(image_files, use_dask=False)\n    assert isinstance(images, np.ndarray)\n    assert images.shape == (2, 512, 512)\n\n\ndef test_multi_png_no_stack(two_pngs):\n    image_files = two_pngs\n    images = io.magic_imread(image_files, stack=False)\n    assert isinstance(images, list)\n    assert len(images) == 2\n    assert all(a.shape == (512, 512) for a in images)\n\n\ndef test_no_files_raises(tmp_path, two_pngs):\n    with pytest.raises(ValueError) as e:\n        io.magic_imread(tmp_path)\n    assert ""No files found in"" in str(e.value)\n\n\ndef test_irregular_images(irregular_images):\n    image_files = irregular_images\n    # Ideally, this would work ""magically"" with dask and irregular images,\n    # but there is no foolproof way to do this without reading in all the\n    # files. We need to be able to inspect the file shape without reading\n    # it in first, then we can automatically turn stacking off when shapes\n    # are irregular (and create proper dask arrays)\n    images = io.magic_imread(image_files, use_dask=False, stack=False)\n    assert isinstance(images, list)\n    assert len(images) == 2\n    assert tuple(image.shape for image in images) == ((512, 512), (303, 384))\n\n\ndef test_tiff(single_tiff):\n    image_files = single_tiff\n    images = io.magic_imread(image_files)\n    assert isinstance(images, np.ndarray)\n    assert images.shape == (2, 15, 10)\n    assert images.dtype == np.uint8\n\n\ndef test_many_tiffs(single_tiff):\n    image_files = single_tiff * 3\n    images = io.magic_imread(image_files)\n    assert isinstance(images, da.Array)\n    assert images.shape == (3, 2, 15, 10)\n    assert images.dtype == np.uint8\n\n\ndef test_single_filename(single_tiff):\n    image_files = single_tiff[0]\n    images = io.magic_imread(image_files)\n    assert images.shape == (2, 15, 10)\n\n\n@pytest.mark.skipif(not zarr_available, reason=\'zarr not installed\')\ndef test_zarr():\n    image = np.random.random((10, 20, 20))\n    with TemporaryDirectory(suffix=\'.zarr\') as fout:\n        z = zarr.open(fout, \'a\', shape=image.shape)\n        z[:] = image\n        image_in = io.magic_imread([fout])\n        # Note: due to lazy loading, the next line needs to happen within\n        # the context manager. Alternatively, we could convert to NumPy here.\n        np.testing.assert_array_equal(image, image_in)\n\n\n@pytest.mark.skipif(not zarr_available, reason=\'zarr not installed\')\ndef test_zarr_multiscale():\n    multiscale = [\n        np.random.random((20, 20)),\n        np.random.random((10, 10)),\n        np.random.random((5, 5)),\n    ]\n    with TemporaryDirectory(suffix=\'.zarr\') as fout:\n        root = zarr.open_group(fout, \'a\')\n        for i in range(len(multiscale)):\n            shape = 20 // 2 ** i\n            z = root.create_dataset(str(i), shape=(shape,) * 2)\n            z[:] = multiscale[i]\n        multiscale_in = io.magic_imread([fout])\n        assert len(multiscale) == len(multiscale_in)\n        # Note: due to lazy loading, the next line needs to happen within\n        # the context manager. Alternatively, we could convert to NumPy here.\n        for images, images_in in zip(multiscale, multiscale_in):\n            np.testing.assert_array_equal(images, images_in)\n\n\ndef test_write_csv(tmpdir):\n    expected_filename = os.path.join(tmpdir, \'test.csv\')\n    column_names = [\'column_1\', \'column_2\', \'column_3\']\n    expected_data = np.random.random((5, len(column_names)))\n\n    # Write csv file\n    io.write_csv(expected_filename, expected_data, column_names=column_names)\n    assert os.path.exists(expected_filename)\n\n    # Check csv file is as expected\n    with open(expected_filename) as output_csv:\n        csv.reader(output_csv, delimiter=\',\')\n        for row_index, row in enumerate(output_csv):\n            if row_index == 0:\n                assert row == ""column_1,column_2,column_3\\n""\n            else:\n                output_row_data = [float(i) for i in row.split(\',\')]\n                np.testing.assert_allclose(\n                    np.array(output_row_data), expected_data[row_index - 1]\n                )\n\n\ndef test_read_csv(tmpdir):\n    expected_filename = os.path.join(tmpdir, \'test.csv\')\n    column_names = [\'column_1\', \'column_2\', \'column_3\']\n    expected_data = np.random.random((5, len(column_names)))\n\n    # Write csv file\n    io.write_csv(expected_filename, expected_data, column_names=column_names)\n    assert os.path.exists(expected_filename)\n\n    # Read csv file\n    read_data, read_column_names, _ = io.read_csv(expected_filename)\n    read_data = np.array(read_data).astype(\'float\')\n    np.testing.assert_allclose(expected_data, read_data)\n\n    assert column_names == read_column_names\n\n\ndef test_guess_layer_type_from_column_names():\n    points_names = [\'index\', \'axis-0\', \'axis-1\']\n    assert io.guess_layer_type_from_column_names(points_names) == \'points\'\n\n    shapes_names = [\'index\', \'shape-type\', \'vertex-index\', \'axis-0\', \'axis-1\']\n    assert io.guess_layer_type_from_column_names(shapes_names) == \'shapes\'\n\n    also_points_names = [\'no-index\', \'axis-0\', \'axis-1\']\n    assert io.guess_layer_type_from_column_names(also_points_names) == \'points\'\n\n    bad_names = [\'no-index\', \'no-axis-0\', \'axis-1\']\n    assert io.guess_layer_type_from_column_names(bad_names) is None\n\n\ndef test_read_csv_raises(tmp_path):\n    """"""Test various exception raising circumstances with read_csv.""""""\n    temp = tmp_path / \'points.csv\'\n\n    # test that points data is detected with require_type = None, any, points\n    # but raises for other shape types.\n    data = [[\'index\', \'axis-0\', \'axis-1\']]\n    data.extend(np.random.random((3, 3)).tolist())\n    with open(temp, mode=\'w\', newline=\'\') as csvfile:\n        csv.writer(csvfile).writerows(data)\n    assert io.read_csv(temp, require_type=None)[2] == \'points\'\n    assert io.read_csv(temp, require_type=\'any\')[2] == \'points\'\n    assert io.read_csv(temp, require_type=\'points\')[2] == \'points\'\n    with pytest.raises(ValueError):\n        io.read_csv(temp, require_type=\'shapes\')\n\n    # test that unrecognized data is detected with require_type = None\n    # but raises for specific shape types or ""any""\n    data = [[\'some\', \'random\', \'header\']]\n    data.extend(np.random.random((3, 3)).tolist())\n    with open(temp, mode=\'w\', newline=\'\') as csvfile:\n        csv.writer(csvfile).writerows(data)\n    assert io.read_csv(temp, require_type=None)[2] is None\n    with pytest.raises(ValueError):\n        assert io.read_csv(temp, require_type=\'any\')\n    with pytest.raises(ValueError):\n        assert io.read_csv(temp, require_type=\'points\')\n    with pytest.raises(ValueError):\n        io.read_csv(temp, require_type=\'shapes\')\n\n\ndef test_csv_to_layer_data_raises(tmp_path):\n    """"""Test various exception raising circumstances with csv_to_layer_data.""""""\n    temp = tmp_path / \'points.csv\'\n\n    # test that points data is detected with require_type == points, any, None\n    # but raises for other shape types.\n    data = [[\'index\', \'axis-0\', \'axis-1\']]\n    data.extend(np.random.random((3, 3)).tolist())\n    with open(temp, mode=\'w\', newline=\'\') as csvfile:\n        csv.writer(csvfile).writerows(data)\n    assert io.csv_to_layer_data(temp, require_type=None)[2] == \'points\'\n    assert io.csv_to_layer_data(temp, require_type=\'any\')[2] == \'points\'\n    assert io.csv_to_layer_data(temp, require_type=\'points\')[2] == \'points\'\n    with pytest.raises(ValueError):\n        io.csv_to_layer_data(temp, require_type=\'shapes\')\n\n    # test that unrecognized data simply returns None when require_type==None\n    # but raises for specific shape types or require_type==""any""\n    data = [[\'some\', \'random\', \'header\']]\n    data.extend(np.random.random((3, 3)).tolist())\n    with open(temp, mode=\'w\', newline=\'\') as csvfile:\n        csv.writer(csvfile).writerows(data)\n    assert io.csv_to_layer_data(temp, require_type=None) is None\n    with pytest.raises(ValueError):\n        assert io.csv_to_layer_data(temp, require_type=\'any\')\n    with pytest.raises(ValueError):\n        assert io.csv_to_layer_data(temp, require_type=\'points\')\n    with pytest.raises(ValueError):\n        io.csv_to_layer_data(temp, require_type=\'shapes\')\n'"
napari/utils/_tests/test_key_bindings.py,0,"b""import inspect\nimport types\n\nimport pytest\n\nfrom .. import key_bindings\nfrom ..key_bindings import (\n    _bind_keymap,\n    bind_key,\n    components_to_key_combo,\n    KeymapHandler,\n    KeymapProvider,\n    normalize_key_combo,\n    parse_key_combo,\n)\n\n\ndef test_parse_key_combo():\n    assert parse_key_combo('X') == ('X', set())\n    assert parse_key_combo('Control-X') == ('X', {'Control'})\n    assert parse_key_combo('Control-Alt-Shift-Meta-X') == (\n        'X',\n        {'Control', 'Alt', 'Shift', 'Meta'},\n    )\n\n\ndef test_components_to_key_combo():\n    assert components_to_key_combo('X', []) == 'X'\n    assert components_to_key_combo('X', ['Control']) == 'Control-X'\n\n    # test consuming\n    assert components_to_key_combo('X', []) == 'X'\n    assert components_to_key_combo('X', ['Shift']) == 'Shift-X'\n    assert components_to_key_combo('x', []) == 'X'\n\n    assert components_to_key_combo('@', ['Shift']) == '@'\n    assert (\n        components_to_key_combo('2', ['Control', 'Shift']) == 'Control-Shift-2'\n    )\n\n    # test ordering\n    assert (\n        components_to_key_combo('2', ['Control', 'Alt', 'Shift', 'Meta'])\n        == 'Control-Alt-Shift-Meta-2'\n    )\n    assert (\n        components_to_key_combo('2', ['Alt', 'Shift', 'Control', 'Meta'])\n        == 'Control-Alt-Shift-Meta-2'\n    )\n\n\ndef test_normalize_key_combo():\n    assert normalize_key_combo('x') == 'X'\n    assert normalize_key_combo('Control-X') == 'Control-X'\n    assert normalize_key_combo('Meta-Alt-X') == 'Alt-Meta-X'\n    assert (\n        normalize_key_combo('Shift-Alt-Control-Meta-2')\n        == 'Control-Alt-Shift-Meta-2'\n    )\n\n\ndef test_bind_key():\n    kb = {}\n\n    # bind\n    def forty_two():\n        return 42\n\n    bind_key(kb, 'A', forty_two)\n    assert kb == dict(A=forty_two)\n\n    # overwrite\n    def spam():\n        return 'SPAM'\n\n    with pytest.raises(ValueError):\n        bind_key(kb, 'A', spam)\n\n    bind_key(kb, 'A', spam, overwrite=True)\n    assert kb == dict(A=spam)\n\n    # unbind\n    bind_key(kb, 'A', None)\n    assert kb == {}\n\n    # check signature\n    # blocker\n    bind_key(kb, 'A', ...)\n    assert kb == {'A': ...}\n\n    # catch-all\n    bind_key(kb, ..., ...)\n    assert kb == {'A': ..., ...: ...}\n\n    with pytest.raises(TypeError):\n        bind_key(kb, 'B', 'not a callable')\n\n\ndef test_bind_key_decorator():\n    kb = {}\n\n    @bind_key(kb, 'A')\n    def foo():\n        ...\n\n    assert kb == dict(A=foo)\n\n\ndef test_keymap_provider():\n    class Foo(KeymapProvider):\n        ...\n\n    assert Foo.class_keymap == {}\n\n    foo = Foo()\n    assert foo.keymap == {}\n\n    class Bar(Foo):\n        ...\n\n    assert Bar.class_keymap == {}\n    assert Bar.class_keymap is not Foo.class_keymap\n\n    class Baz(KeymapProvider):\n        class_keymap = {'A', ...}\n\n    assert Baz.class_keymap == {'A', ...}\n\n\ndef test_bind_keymap():\n    class Foo:\n        ...\n\n    def bar(foo):\n        return foo\n\n    def baz(foo):\n        return foo\n\n    keymap = {'A': bar, 'B': baz, 'C': ...}\n\n    foo = Foo()\n\n    assert _bind_keymap(keymap, foo) == {\n        'A': types.MethodType(bar, foo),\n        'B': types.MethodType(baz, foo),\n        'C': ...,\n    }\n\n\nclass Foo(KeymapProvider):\n    class_keymap = {\n        'A': lambda x: setattr(x, 'A', ...),\n        'B': lambda x: setattr(x, 'B', ...),\n        'C': lambda x: setattr(x, 'C', ...),\n        'D': ...,\n    }\n\n    def __init__(self):\n        self.keymap = {\n            'B': lambda x: setattr(x, 'B', None),  # overwrite\n            'E': lambda x: setattr(x, 'E', None),  # new entry\n            'C': ...,  # blocker\n        }\n\n\nclass Bar(KeymapProvider):\n    class_keymap = {'E': lambda x: setattr(x, 'E', 42)}\n\n\ndef test_handle_single_keymap_provider():\n    foo = Foo()\n\n    handler = KeymapHandler()\n    handler.keymap_providers = [foo]\n\n    assert handler.keymap_chain.maps == [\n        _bind_keymap(foo.keymap, foo),\n        _bind_keymap(foo.class_keymap, foo),\n    ]\n    assert handler.active_keymap == {\n        'A': types.MethodType(foo.class_keymap['A'], foo),\n        'B': types.MethodType(foo.keymap['B'], foo),\n        'E': types.MethodType(foo.keymap['E'], foo),\n    }\n\n    # non-overwritten class keybinding\n    # 'A' in Foo and not foo\n    assert not hasattr(foo, 'A')\n    handler.press_key('A')\n    assert foo.A is ...\n\n    # keybinding blocker on class\n    # 'D' in Foo and not foo but has no func\n    handler.press_key('D')\n    assert not hasattr(foo, 'D')\n\n    # non-overwriting instance keybinding\n    # 'E' not in Foo and in foo\n    assert not hasattr(foo, 'E')\n    handler.press_key('E')\n    assert foo.E is None\n\n    # overwriting instance keybinding\n    # 'B' in Foo and in foo; foo has priority\n    assert not hasattr(foo, 'B')\n    handler.press_key('B')\n    assert foo.B is None\n\n    # keybinding blocker on instance\n    # 'C' in Foo and in Foo; foo has priority but no func\n    handler.press_key('C')\n    assert not hasattr(foo, 'C')\n\n\ndef test_handle_multiple_keymap_providers():\n    foo = Foo()\n    bar = Bar()\n    handler = KeymapHandler()\n    handler.keymap_providers = [bar, foo]\n\n    assert handler.keymap_chain.maps == [\n        _bind_keymap(bar.keymap, bar),\n        _bind_keymap(bar.class_keymap, bar),\n        _bind_keymap(foo.keymap, foo),\n        _bind_keymap(foo.class_keymap, foo),\n    ]\n    assert handler.active_keymap == {\n        'A': types.MethodType(foo.class_keymap['A'], foo),\n        'B': types.MethodType(foo.keymap['B'], foo),\n        'E': types.MethodType(bar.class_keymap['E'], bar),\n    }\n\n    # check 'bar' callback\n    # 'E' in bar and foo; bar takes priority\n    assert not hasattr(bar, 'E')\n    handler.press_key('E')\n    assert bar.E == 42\n\n    # check 'foo' callback\n    # 'B' not in bar and in foo\n    handler.press_key('B')\n    assert not hasattr(bar, 'B')\n\n    # catch-all key combo\n    # if key not found in 'bar' keymap; default to this binding\n    def catch_all(x):\n        x.catch_all = True\n\n    bar.class_keymap[...] = catch_all\n    assert handler.active_keymap == {\n        ...: types.MethodType(catch_all, bar),\n        'E': types.MethodType(bar.class_keymap['E'], bar),\n    }\n    assert not hasattr(bar, 'catch_all')\n    handler.press_key('Z')\n    assert bar.catch_all is True\n\n    # empty\n    bar.class_keymap[...] = ...\n    assert handler.active_keymap == {\n        'E': types.MethodType(bar.class_keymap['E'], bar)\n    }\n    del foo.B\n    handler.press_key('B')\n    assert not hasattr(foo, 'B')\n\n\ndef test_handle_on_release_bindings():\n    def make_42(x):\n        # on press\n        x.SPAM = 42\n        if False:\n            yield\n            # on release\n            # do nothing, but this will make it a generator function\n\n    def add_then_subtract(x):\n        # on press\n        x.aliiiens += 3\n        yield\n        # on release\n        x.aliiiens -= 3\n\n    class Baz(KeymapProvider):\n        aliiiens = 0\n        class_keymap = {'A': make_42, 'Control-Shift-B': add_then_subtract}\n\n    baz = Baz()\n    handler = KeymapHandler()\n    handler.keymap_providers = [baz]\n\n    # one-statement generator function\n    assert not hasattr(baz, 'SPAM')\n    handler.press_key('A')\n    assert baz.SPAM == 42\n\n    # two-statement generator function\n    assert baz.aliiiens == 0\n    handler.press_key('Control-Shift-B')\n    assert baz.aliiiens == 3\n    handler.release_key('Control-Shift-B')\n    assert baz.aliiiens == 0\n\n    # order of modifiers should not matter\n    handler.press_key('Shift-Control-B')\n    assert baz.aliiiens == 3\n    handler.release_key('B')\n    assert baz.aliiiens == 0\n\n\ndef test_bind_key_method():\n    class Foo2(KeymapProvider):\n        ...\n\n    foo = Foo2()\n\n    # instance binding\n    foo.bind_key('A', lambda: 42)\n    assert foo.keymap['A']() == 42\n\n    # class binding\n    @Foo2.bind_key('B')\n    def bar():\n        return 'SPAM'\n\n    assert Foo2.class_keymap['B'] is bar\n\n\ndef test_bind_key_doc():\n    doc = inspect.getdoc(bind_key)\n    doc = doc.split('Notes\\n-----\\n')[-1]\n\n    assert doc == inspect.getdoc(key_bindings)\n"""
napari/utils/_tests/test_misc.py,0,"b'from enum import auto\nfrom os.path import expanduser, abspath, sep\nfrom pathlib import Path\n\nimport pytest\n\nfrom napari.utils.misc import (\n    StringEnum,\n    callsignature,\n    ensure_sequence_of_iterables,\n    ensure_iterable,\n    abspath_or_url,\n)\n\nITERABLE = (0, 1, 2)\nNESTED_ITERABLE = [ITERABLE, ITERABLE, ITERABLE]\nDICT = {\'a\': 1, \'b\': 3, \'c\': 5}\nLIST_OF_DICTS = [DICT, DICT, DICT]\n\n\n@pytest.mark.parametrize(\n    \'input, expected\',\n    [\n        [ITERABLE, NESTED_ITERABLE],\n        [NESTED_ITERABLE, NESTED_ITERABLE],\n        [(ITERABLE, (2,), (3, 1, 6)), (ITERABLE, (2,), (3, 1, 6))],\n        [DICT, LIST_OF_DICTS],\n        [LIST_OF_DICTS, LIST_OF_DICTS],\n        [(ITERABLE, (2,), (3, 1, 6)), (ITERABLE, (2,), (3, 1, 6))],\n        [None, (None, None, None)],\n        # BEWARE: only the first element of a nested sequence is checked.\n        [((0, 1), None, None), ((0, 1), None, None)],\n    ],\n)\ndef test_sequence_of_iterables(input, expected):\n    """"""Test ensure_sequence_of_iterables returns a sequence of iterables.""""""\n    zipped = zip(range(3), ensure_sequence_of_iterables(input), expected)\n    for i, result, expectation in zipped:\n        assert result == expectation\n\n\ndef test_sequence_of_iterables_raises():\n    with pytest.raises(ValueError):\n        # the length argument asserts a specific length\n        ensure_sequence_of_iterables(((0, 1),), length=4)\n\n    # BEWARE: only the first element of a nested sequence is checked.\n    with pytest.raises(AssertionError):\n        iterable = (None, (0, 1), (0, 2))\n        result = iter(ensure_sequence_of_iterables(iterable))\n        assert next(result) is None\n\n\n@pytest.mark.parametrize(\n    \'input, expected\',\n    [\n        [ITERABLE, ITERABLE],\n        [DICT, DICT],\n        [1, [1, 1, 1]],\n        [\'foo\', [\'foo\', \'foo\', \'foo\']],\n        [None, [None, None, None]],\n    ],\n)\ndef test_ensure_iterable(input, expected):\n    """"""Test test_ensure_iterable returns an iterable.""""""\n    zipped = zip(range(3), ensure_iterable(input), expected)\n    for i, result, expectation in zipped:\n        assert result == expectation\n\n\ndef test_callsignature():\n    # no arguments\n    assert str(callsignature(lambda: None)) == \'()\'\n\n    # one arg\n    assert str(callsignature(lambda a: None)) == \'(a)\'\n\n    # multiple args\n    assert str(callsignature(lambda a, b: None)) == \'(a, b)\'\n\n    # arbitrary args\n    assert str(callsignature(lambda *args: None)) == \'(*args)\'\n\n    # arg + arbitrary args\n    assert str(callsignature(lambda a, *az: None)) == \'(a, *az)\'\n\n    # default arg\n    assert str(callsignature(lambda a=42: None)) == \'(a=a)\'\n\n    # multiple default args\n    assert str(callsignature(lambda a=0, b=1: None)) == \'(a=a, b=b)\'\n\n    # arg + default arg\n    assert str(callsignature(lambda a, b=42: None)) == \'(a, b=b)\'\n\n    # arbitrary kwargs\n    assert str(callsignature(lambda **kwargs: None)) == \'(**kwargs)\'\n\n    # default arg + arbitrary kwargs\n    assert str(callsignature(lambda a=42, **kwargs: None)) == \'(a=a, **kwargs)\'\n\n    # arg + default arg + arbitrary kwargs\n    assert str(callsignature(lambda a, b=42, **kw: None)) == \'(a, b=b, **kw)\'\n\n    # arbitary args + arbitrary kwargs\n    assert str(callsignature(lambda *args, **kw: None)) == \'(*args, **kw)\'\n\n    # arg + default arg + arbitrary kwargs\n    assert (\n        str(callsignature(lambda a, b=42, *args, **kwargs: None))\n        == \'(a, b=b, *args, **kwargs)\'\n    )\n\n    # kwonly arg\n    assert str(callsignature(lambda *, a: None)) == \'(a=a)\'\n\n    # arg + kwonly arg\n    assert str(callsignature(lambda a, *, b: None)) == \'(a, b=b)\'\n\n    # default arg + kwonly arg\n    assert str(callsignature(lambda a=42, *, b: None)) == \'(a=a, b=b)\'\n\n    # kwonly args + everything\n    assert (\n        str(callsignature(lambda a, b=42, *, c, d=5, **kwargs: None))\n        == \'(a, b=b, c=c, d=d, **kwargs)\'\n    )\n\n\ndef test_string_enum():\n    # Make a test StringEnum\n    class TestEnum(StringEnum):\n        THING = auto()\n        OTHERTHING = auto()\n\n    # test setting by value, correct case\n    assert TestEnum(\'thing\') == TestEnum.THING\n\n    # test setting by value mixed case\n    assert TestEnum(\'thInG\') == TestEnum.THING\n\n    # test setting by instance of self\n    assert TestEnum(TestEnum.THING) == TestEnum.THING\n\n    # test setting by name correct case\n    assert TestEnum[\'THING\'] == TestEnum.THING\n\n    # test setting by name mixed case\n    assert TestEnum[\'tHiNg\'] == TestEnum.THING\n\n    # test setting by value with incorrect value\n    with pytest.raises(ValueError):\n        TestEnum(\'NotAThing\')\n\n    # test  setting by name with incorrect name\n    with pytest.raises(KeyError):\n        TestEnum[\'NotAThing\']\n\n    # test creating a StringEnum with the functional API\n    animals = StringEnum(\'Animal\', \'AARDVARK BUFFALO CAT DOG\')\n    assert str(animals.AARDVARK) == \'aardvark\'\n    assert animals(\'BUffALO\') == animals.BUFFALO\n    assert animals[\'BUffALO\'] == animals.BUFFALO\n\n    # test setting by instance of self\n    class OtherEnum(StringEnum):\n        SOMETHING = auto()\n\n    #  test setting by instance of a different StringEnum is an error\n    with pytest.raises(ValueError):\n        TestEnum(OtherEnum.SOMETHING)\n\n\ndef test_abspath_or_url():\n    relpath = ""~"" + sep + ""something""\n    assert abspath_or_url(relpath) == expanduser(relpath)\n    assert abspath_or_url(\'something\') == abspath(\'something\')\n    assert abspath_or_url(sep + \'something\') == abspath(sep + \'something\')\n    assert abspath_or_url(\'https://something\') == \'https://something\'\n    assert abspath_or_url(\'http://something\') == \'http://something\'\n    assert abspath_or_url(\'ftp://something\') == \'ftp://something\'\n    assert abspath_or_url(\'file://something\') == \'file://something\'\n    assert abspath_or_url((\'a\', \'~\')) == (abspath(\'a\'), expanduser(\'~\'))\n    assert abspath_or_url([\'a\', \'~\']) == [abspath(\'a\'), expanduser(\'~\')]\n\n    assert abspath_or_url((\'a\', Path(\'~\'))) == (abspath(\'a\'), expanduser(\'~\'))\n\n    with pytest.raises(TypeError):\n        abspath_or_url({\'a\', \'~\'})\n'"
napari/utils/_tests/test_naming.py,0,"b'import functools\nimport inspect\nimport sys\n\nfrom napari.utils.naming import (\n    numbered_patt,\n    inc_name_count,\n    sep,\n    start,\n    magic_name,\n)\n\n\ndef test_re_base_brackets():\n    assert numbered_patt.search(\'layer [12]\').group(0) == \'12\'\n    assert numbered_patt.search(\'layer [e]\').group(0) == \'\'\n    assert numbered_patt.search(\'layer 12]\').group(0) == \'\'\n    assert numbered_patt.search(\'layer [12\').group(0) == \'\'\n    assert numbered_patt.search(\'layer[12]\').group(0) == \'\'\n    assert numbered_patt.search(\'layer 12\').group(0) == \'\'\n    assert numbered_patt.search(\'layer12\').group(0) == \'\'\n    assert numbered_patt.search(\'layer\').group(0) == \'\'\n\n\ndef test_re_other_brackets():\n    assert numbered_patt.search(\'layer [3] [123]\').group(0) == \'123\'\n\n\ndef test_re_first_bracket():\n    assert numbered_patt.search(\' [42]\').group(0) == \'42\'\n    assert numbered_patt.search(\'[42]\').group(0) == \'42\'\n\n\ndef test_re_sub_base_num():\n    assert numbered_patt.sub(\'8\', \'layer [7]\', count=1) == \'layer [8]\'\n\n\ndef test_re_sub_base_empty():\n    assert numbered_patt.sub(\' [3]\', \'layer\', count=1) == \'layer [3]\'\n\n\ndef test_inc_name_count():\n    assert inc_name_count(\'layer [7]\') == \'layer [8]\'\n    assert inc_name_count(\'layer\') == f\'layer{sep}[{start}]\'\n    assert inc_name_count(\'[41]\') == \'[42]\'\n\n\ndef eval_with_filename(source, filename=__file__):\n    frame = inspect.currentframe().f_back\n    code = compile(source, filename, \'eval\')\n    return eval(code, frame.f_globals, frame.f_locals)\n\n\nwalrus = sys.version_info >= (3, 8)\nmagic_name = functools.partial(\n    magic_name, path_prefix=magic_name.__code__.co_filename\n)\n\n\ndef test_basic():\n    """"""Check that name is guessed correctly.""""""\n    assert magic_name(42) is None\n\n    z = 5\n    assert magic_name(z) == \'z\'\n\n    if walrus:\n        assert eval_with_filename(""magic_name(y:=\'SPAM\')"") == \'y\'\n\n\nglobalval = 42\n\n\ndef test_global():\n    """"""Check that it works with global variables.""""""\n    assert magic_name(globalval) == \'globalval\'\n\n\ndef test_function_chains():\n    """"""Check that nothing weird happens with function chains.""""""\n\n    def foo():\n        return 42\n\n    assert magic_name(foo()) is None\n\n\ndef test_assignment():\n    """"""Check that assignment expressions do not confuse it.""""""\n    result = magic_name(17)\n    assert result is None\n\n    t = 3\n    result = magic_name(t)\n    assert result == \'t\'\n\n    if walrus:\n        result = eval_with_filename(\'magic_name(d:=42)\')\n        assert result == \'d\'\n\n\ndef test_path_prefix():\n    """"""Test that path prefixes work as expected.""""""\n    mname = functools.partial(magic_name, path_prefix=__file__)\n\n    def foo(x):\n        def bar(y):\n            return mname(y)\n\n        return bar(x)\n\n    assert eval_with_filename(\'foo(42)\', \'hi.py\') is None\n\n    r = 8  # noqa\n    assert eval_with_filename(\'foo(r)\', \'bye.py\') == \'r\'\n\n    if walrus:\n        assert eval_with_filename(\'foo(i:=33)\', \'rye.py\') == \'i\'\n'"
napari/utils/_tests/test_notebook_display.py,2,"b'import numpy as np\n\nfrom napari.utils import nbscreenshot\n\n\ndef test_nbscreenshot(viewer_factory):\n    """"""Test taking a screenshot.""""""\n    view, viewer = viewer_factory()\n\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    viewer.add_image(data)\n\n    rich_display_object = nbscreenshot(viewer)\n    assert hasattr(rich_display_object, \'_repr_png_\')\n    # Trigger method that would run in jupyter notebook cell automatically\n    rich_display_object._repr_png_()\n    assert rich_display_object.image is not None\n'"
napari/utils/_tests/test_validators.py,0,"b'from .. import validators\nimport pytest\n\n\ndef test_sequence_validator():\n    validate = validators.validate_n_seq(2, int)\n\n    # this should work\n    validate([4, 5])\n\n    with pytest.raises(TypeError):\n        validate(8)  # raises TypeError\n\n    with pytest.raises(ValueError):\n        validate([1, 2, 3])  # raises ValueError\n\n    with pytest.raises(TypeError):\n        validate([1.4, 5])  # raises TypeError\n'"
napari/utils/colormaps/__init__.py,0,"b'from .colormaps import (\n    matplotlib_colormaps,\n    simple_colormaps,\n    ensure_colormap_tuple,\n    AVAILABLE_COLORMAPS,\n    ALL_COLORMAPS,\n    MAGENTA_GREEN,\n    RGB,\n    CYMRGB,\n)\nfrom .colorbars import make_colorbar\n'"
napari/utils/colormaps/colorbars.py,4,"b'import numpy as np\n\n\ndef make_colorbar(cmap, size=(18, 28), horizontal=True):\n    """"""Make a colorbar from a colormap.\n\n    Parameters\n    ----------\n    cmap : vispy.color.Colormap\n        Colormap to create colorbar with.\n    size : 2-tuple\n        Shape of colorbar.\n    horizontal : bool\n        If True colobar is oriented horizontal, otherwise it is oriented\n        vertical.\n\n    Returns\n    ----------\n    cbar : array\n        Array of colorbar.\n    """"""\n\n    if horizontal:\n        input = np.linspace(0, 1, size[1])\n        bar = np.tile(np.expand_dims(input, 1), size[0]).transpose((1, 0))\n    else:\n        input = np.linspace(0, 1, size[0])\n        bar = np.tile(np.expand_dims(input, 1), size[1])\n\n    # cmap.__getitem__ returns a vispy.color.ColorArray\n    color_array = cmap[bar.ravel()]\n    # the ColorArray.RGBA method returns a normalized uint8 array\n    cbar = color_array.RGBA.reshape(bar.shape + (4,))\n\n    return cbar\n'"
napari/utils/colormaps/colormaps.py,31,"b'import os\nfrom typing import Tuple, List\n\nimport numpy as np\nfrom vispy.color import BaseColormap, Colormap, get_colormap, get_colormaps\n\nfrom ...types import ValidColormapArg\nfrom .vendored import cm, colorconv\n\n_matplotlib_list_file = os.path.join(\n    os.path.dirname(__file__), \'matplotlib_cmaps.txt\'\n)\nwith open(_matplotlib_list_file) as fin:\n    matplotlib_colormaps = [line.rstrip() for line in fin]\n\n\nprimary_color_names = [\'red\', \'green\', \'blue\', \'cyan\', \'magenta\', \'yellow\']\nprimary_colors = np.array(\n    [(1, 0, 0), (0, 1, 0), (0, 0, 1), (0, 1, 1), (1, 0, 1), (1, 1, 0)],\n    dtype=float,\n)\n\n\nsimple_colormaps = {\n    name: Colormap([[0.0, 0.0, 0.0], color])\n    for name, color in zip(primary_color_names, primary_colors)\n}\n\n\ndef _all_rgb():\n    """"""Return all 256**3 valid rgb tuples.""""""\n    base = np.arange(256, dtype=np.uint8)\n    r, g, b = np.meshgrid(base, base, base, indexing=\'ij\')\n    return np.stack((r, g, b), axis=-1).reshape((-1, 3))\n\n\n# obtained with colorconv.rgb2luv(_all_rgb().reshape((-1, 256, 3)))\nLUVMIN = np.array([0.0, -83.07790815, -134.09790293])\nLUVMAX = np.array([100.0, 175.01447356, 107.39905336])\nLUVRNG = LUVMAX - LUVMIN\n\n# obtained with colorconv.rgb2lab(_all_rgb().reshape((-1, 256, 3)))\nLABMIN = np.array([0.0, -86.18302974, -107.85730021])\nLABMAX = np.array([100.0, 98.23305386, 94.47812228])\nLABRNG = LABMAX - LABMIN\n\n\ndef _validate_rgb(colors, *, tolerance=0.0):\n    """"""Return the subset of colors that is in [0, 1] for all channels.\n\n    Parameters\n    ----------\n    colors : array of float, shape (N, 3)\n        Input colors in RGB space.\n\n    Other Parameters\n    ----------------\n    tolerance : float, optional\n        Values outside of the range by less than ``tolerance`` are allowed and\n        clipped to be within the range.\n\n    Returns\n    -------\n    filtered_colors : array of float, shape (M, 3), M <= N\n        The subset of colors that are in valid RGB space.\n\n    Examples\n    --------\n    >>> colors = np.array([[  0. , 1.,  1.  ],\n    ...                    [  1.1, 0., -0.03],\n    ...                    [  1.2, 1.,  0.5 ]])\n    >>> _validate_rgb(colors)\n    array([[0., 1., 1.]])\n    >>> _validate_rgb(colors, tolerance=0.15)\n    array([[0., 1., 1.],\n           [1., 0., 0.]])\n    """"""\n    lo = 0 - tolerance\n    hi = 1 + tolerance\n    valid = np.all((colors > lo) & (colors < hi), axis=1)\n    filtered_colors = np.clip(colors[valid], 0, 1)\n    return filtered_colors\n\n\ndef _low_discrepancy_image(image, seed=0.5, margin=1 / 256):\n    """"""Generate a 1d low discrepancy sequence of coordinates.\n\n    Parameters\n    ----------\n    labels : array of int\n        A set of labels or label image.\n    seed : float\n        The seed from which to start the quasirandom sequence.\n    margin : float\n        Values too close to 0 or 1 will get mapped to the edge of the colormap,\n        so we need to offset to a margin slightly inside those values. Since\n        the bin size is 1/256 by default, we offset by that amount.\n\n    Returns\n    -------\n    image_out : array of float\n        The set of ``labels`` remapped to [0, 1] quasirandomly.\n\n    """"""\n    phi_mod = 0.6180339887498948482\n    image_float = seed + image * phi_mod\n    # We now map the floats to the range [0 + margin, 1 - margin]\n    image_out = margin + (1 - 2 * margin) * (\n        image_float - np.floor(image_float)\n    )\n    return image_out\n\n\ndef _low_discrepancy(dim, n, seed=0.5):\n    """"""Generate a 1d, 2d, or 3d low discrepancy sequence of coordinates.\n\n    Parameters\n    ----------\n    dim : one of {1, 2, 3}\n        The dimensionality of the sequence.\n    n : int\n        How many points to generate.\n    seed : float or array of float, shape (dim,)\n        The seed from which to start the quasirandom sequence.\n\n    Returns\n    -------\n    pts : array of float, shape (n, dim)\n        The sampled points.\n\n    References\n    ----------\n    ..[1]: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/  # noqa: E501\n    """"""\n    phi1 = 1.6180339887498948482\n    phi2 = 1.32471795724474602596\n    phi3 = 1.22074408460575947536\n    seed = np.broadcast_to(seed, (1, dim))\n    phi = np.array([phi1, phi2, phi3])\n    g = 1 / phi\n    n = np.reshape(np.arange(n), (n, 1))\n    pts = (seed + (n * g[:dim])) % 1\n    return pts\n\n\ndef _color_random(n, *, colorspace=\'lab\', tolerance=0.0, seed=0.5):\n    """"""Generate n random RGB colors uniformly from LAB or LUV space.\n\n    Parameters\n    ----------\n    n : int\n        Number of colors to generate.\n    colorspace : str, one of {\'lab\', \'luv\', \'rgb\'}\n        The colorspace from which to get random colors.\n    tolerance : float\n        How much margin to allow for out-of-range RGB values (these are\n        clipped to be in-range).\n    seed : float or array of float, shape (3,)\n        Value from which to start the quasirandom sequence.\n\n    Returns\n    -------\n    rgb : array of float, shape (n, 3)\n        RGB colors chosen uniformly at random from given colorspace.\n    """"""\n    factor = 6  # about 1/5 of random LUV tuples are inside the space\n    expand_factor = 2\n    rgb = np.zeros((0, 3))\n    while len(rgb) < n:\n        random = _low_discrepancy(3, n * factor, seed=seed)\n        if colorspace == \'luv\':\n            raw_rgb = colorconv.luv2rgb(random * LUVRNG + LUVMIN)\n        elif colorspace == \'rgb\':\n            raw_rgb = random\n        else:  # \'lab\' by default\n            raw_rgb = colorconv.lab2rgb(random * LABRNG + LABMIN)\n        rgb = _validate_rgb(raw_rgb, tolerance=tolerance)\n        factor *= expand_factor\n    return rgb[:n]\n\n\ndef label_colormap(num_colors=256, seed=0.5):\n    """"""Produce a colormap suitable for use with a given label set.\n\n    Parameters\n    ----------\n    num_colors : int, optional\n        Number of unique colors to use. Default used if not given.\n    seed : float or array of float, length 3\n        The seed for the random color generator.\n\n    Returns\n    -------\n    cmap : vispy.color.Colormap\n        A colormap for use with labels are remapped to [0, 1].\n\n    Notes\n    -----\n    0 always maps to fully transparent.\n    """"""\n    # Starting the control points slightly above 0 and below 1 is necessary\n    # to ensure that the background pixel 0 is transparent\n    midpoints = np.linspace(0.00001, 1 - 0.00001, num_colors - 1)\n    control_points = np.concatenate(([0], midpoints, [1.0]))\n    # make sure to add an alpha channel to the colors\n    colors = np.concatenate(\n        (_color_random(num_colors, seed=seed), np.full((num_colors, 1), 1)),\n        axis=1,\n    )\n    colors[0, :] = 0  # ensure alpha is 0 for label 0\n    cmap = Colormap(\n        colors=colors, controls=control_points, interpolation=\'zero\'\n    )\n    return cmap\n\n\ndef vispy_or_mpl_colormap(name):\n    """"""Try to get a colormap from vispy, or convert an mpl one to vispy format.\n\n    Parameters\n    ----------\n    name : str\n        The name of the colormap.\n\n    Returns\n    -------\n    cmap : vispy.color.Colormap\n        The found colormap.\n\n    Raises\n    ------\n    KeyError\n        If no colormap with that name is found within vispy or matplotlib.\n    """"""\n    vispy_cmaps = get_colormaps()\n    if name in vispy_cmaps:\n        cmap = get_colormap(name)\n    else:\n        try:\n            mpl_cmap = getattr(cm, name)\n        except AttributeError:\n            raise KeyError(\n                f\'Colormap ""{name}"" not found in either vispy \'\n                \'or matplotlib.\'\n            )\n        mpl_colors = mpl_cmap(np.linspace(0, 1, 256))\n        cmap = Colormap(mpl_colors)\n    return cmap\n\n\n# Fire and Grays are two colormaps that work well for\n# translucent and additive volume rendering - add\n# them to best_3d_colormaps, append them to\n# all the existing colormaps\n\n\nclass TransFire(BaseColormap):\n    glsl_map = """"""\n    vec4 translucent_fire(float t) {\n        return vec4(pow(t, 0.5), t, t*t, max(0, t*1.05 - 0.05));\n    }\n    """"""\n\n    def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack(\n                [np.power(t, 0.5), t, t * t, np.maximum(0, t * 1.05 - 0.05)]\n            ).astype(np.float32)\n        else:\n            return np.array(\n                [np.power(t, 0.5), t, t * t, np.maximum(0, t * 1.05 - 0.05)],\n                dtype=np.float32,\n            )\n\n\nclass TransGrays(BaseColormap):\n    glsl_map = """"""\n    vec4 translucent_grays(float t) {\n        return vec4(t, t, t, t*0.5);\n    }\n    """"""\n\n    def map(self, t):\n        if isinstance(t, np.ndarray):\n            return np.hstack([t, t, t, t * 0.5]).astype(np.float32)\n        else:\n            return np.array([t, t, t, t * 0.5], dtype=np.float32)\n\n\ncolormaps_3D = {""fire"": TransFire(), ""gray_trans"": TransGrays()}\ncolormaps_3D = {k: v for k, v in sorted(colormaps_3D.items())}\n\n\n# A dictionary mapping names to VisPy colormap objects\nALL_COLORMAPS = {k: vispy_or_mpl_colormap(k) for k in matplotlib_colormaps}\nALL_COLORMAPS.update(simple_colormaps)\nALL_COLORMAPS.update(colormaps_3D)\n\n# ... sorted alphabetically by name\nAVAILABLE_COLORMAPS = {k: v for k, v in sorted(ALL_COLORMAPS.items())}\n\n# curated colormap sets\n# these are selected to look good or at least reasonable when using additive\n# blending of multiple channels.\nMAGENTA_GREEN = [\'magenta\', \'green\']\nRGB = [\'red\', \'green\', \'blue\']\nCYMRGB = [\'cyan\', \'yellow\', \'magenta\', \'red\', \'green\', \'blue\']\n\n\ndef increment_unnamed_colormap(\n    existing: List[str], name: str = \'[unnamed colormap]\'\n) -> str:\n    """"""Increment name for unnamed colormap.\n\n    Parameters\n    ----------\n    existing : list of str\n        Names of existing colormaps.\n    name : str, optional\n        Name of colormap to be incremented. by default \'[unnamed colormap]\'\n\n    Returns\n    -------\n    name : str\n        Name of colormap after incrementing.\n    """"""\n    if name == \'[unnamed colormap]\':\n        past_names = [n for n in existing if n.startswith(\'[unnamed colormap\')]\n        name = f\'[unnamed colormap {len(past_names)}]\'\n    return name\n\n\ndef ensure_colormap_tuple(colormap: ValidColormapArg) -> Tuple[str, Colormap]:\n    """"""Accept any valid colormap arg, and return (name, Colormap), or raise.\n\n    Adds any new colormaps to AVAILABLE_COLORMAPS in the process.\n\n    Parameters\n    ----------\n    colormap : ValidColormapArg\n        colormap as str, Colormap, {name: Colormap} ``dict``, or\n        (name, Colormap) ``tuple``.\n\n    Returns\n    -------\n    Tuple[str, Colormap]\n        Normalized name and Colormap.\n\n    Raises\n    ------\n    KeyError\n        If a string is provided that is not in AVAILABLE_COLORMAPS\n    TypeError\n        If a tuple is provided and the first element is not a string or the\n        second element is not a Colormap.\n    TypeError\n        If a dict is provided and any of the values are not Colormap instances.\n    TypeError\n        If ``colormap`` is not a ``str``, ``dict``, ``tuple``, or ``Colormap``\n    """"""\n    if isinstance(colormap, str):\n        name = colormap\n        if name not in AVAILABLE_COLORMAPS:\n            cmap = vispy_or_mpl_colormap(name)  # raises KeyError if not found\n            AVAILABLE_COLORMAPS[name] = cmap\n    elif isinstance(colormap, BaseColormap):\n        # if a colormap instance is provided, make sure we don\'t already know\n        # about it before adding a new unnamed colormap\n        name = None\n        for key, val in AVAILABLE_COLORMAPS.items():\n            if colormap == val:\n                name = key\n                break\n        if not name:\n            name = increment_unnamed_colormap(AVAILABLE_COLORMAPS)\n        AVAILABLE_COLORMAPS[name] = colormap\n    elif isinstance(colormap, tuple):\n        if not (\n            len(colormap) > 1\n            and isinstance(colormap[1], BaseColormap)\n            and isinstance(colormap[0], str)\n        ):\n            raise TypeError(\n                ""When providing a tuple as a colormap argument, the first ""\n                ""element must be a string and the second a Colormap instance""\n            )\n        name, cmap = colormap\n        AVAILABLE_COLORMAPS[name] = cmap\n    elif isinstance(colormap, dict):\n        if not all(isinstance(i, BaseColormap) for i in colormap.values()):\n            raise TypeError(\n                ""When providing a dict as a colormap, ""\n                ""all values must be BaseColormap instances""\n            )\n        AVAILABLE_COLORMAPS.update(colormap)\n        if len(colormap) == 1:\n            name = list(colormap)[0]  # first key in dict\n        elif len(colormap) > 1:\n            import warnings\n\n            warnings.warn(\n                ""only the first item in a colormap dict is used as an argument""\n            )\n        else:\n            raise ValueError(""Received an empty dict as a colormap argument."")\n    else:\n        raise TypeError(\n            f\'invalid type for colormap: {type(colormap)}. \'\n            \'Must be a {str, tuple, dict, vispy.colormap.Colormap}\'\n        )\n\n    return name, AVAILABLE_COLORMAPS[name]\n'"
napari/utils/colormaps/standardize_color.py,52,"b'""""""This module contains functions that \'standardize\' the color handling\nof napari layers by supplying functions that are able to convert most\ncolor representation the user had in mind into a single representation -\na numpy Nx4 array of float32 values between 0 and 1 - that is used across\nthe codebase. The color is always in an RGBA format. To handle colors in\nHSV, for example, we should point users to skimage, matplotlib and others.\n\nThe main function of the module is ""transform_color"", which might call\na cascade of other, private, function in the module to do the hard work\nof converting the input. This function will either be called directly, or\nused by the function ""transform_color_with_defaults"", which is a helper\nfunction for the layer objects located in\n``layers.utils.color_transformations.py``.\n\nIn general, when handling colors we try to catch invalid color\nrepresentations, warn the users of their misbehaving and return a default\nwhite color array, since it seems unreasonable to crash the entire napari\nsession due to mis-represented colors.\n""""""\n\nimport types\nfrom typing import Dict, Any, Callable, Sequence\nimport functools\nimport warnings\n\nimport numpy as np\nfrom vispy.color import ColorArray, get_color_dict, get_color_names\nfrom vispy.color.color_array import _string_to_rgb\n\n\ndef transform_color(colors: Any) -> np.ndarray:\n    """"""Transforms provided color(s) to an Nx4 array of RGBA np.float32\n    values.\n\n    N is the number of given colors. The function is designed to parse all\n    valid color representations a user might have and convert them properly.\n    That being said, combinations of different color representation in the\n    same list of colors is prohibited, and will error. This means that a list\n    of [\'red\', np.array([1, 0, 0])] cannot be parsed and has to be manually\n    pre-processed by the user before sent to this function. In addition, the\n    provided colors - if numeric - should already be in an RGB(A) format. To\n    convert an existing numeric color array to RGBA format use skimage before\n    calling this function.\n\n    Parameters\n    --------\n    colors : string and array-like.\n        The color(s) to interpret and convert\n\n    Returns\n    ------\n    colors : np.ndarray\n        An instance of np.ndarray with a data type of float32, 4 columns in\n        RGBA order and N rows, with N being the number of colors. The array\n        will always be 2D even if a single color is passed.\n\n    Raises\n    -----\n    ValueError, AttributeError, KeyError\n        invalid inputs\n    """"""\n    colortype = type(colors)\n    return _color_switch[colortype](colors)\n\n\n@functools.lru_cache(maxsize=1024)\ndef _handle_str(color: str) -> np.ndarray:\n    """"""Creates an array from a color of type string.\n\n    The function uses an LRU cache to enhance performance.\n\n    Parameters\n    --------\n    color : str\n        A single string as an input color. Can be a color name or a\n        hex representation of a color, with either 6 or 8 hex digits.\n\n    Returns\n    ------\n    colorarray : np.ndarray\n        1x4 array\n\n    """"""\n    if len(color) == 0:\n        warnings.warn(""Empty string detected. Returning black instead."")\n        return np.zeros((1, 4), dtype=np.float32)\n    # This line will stay here until vispy adds a ""transparent"" key\n    # to their color dictionary. A PR was sent and approved, currently\n    # waiting to be merged.\n    color = color.replace(""transparent"", ""#00000000"")\n    colorarray = np.atleast_2d(_string_to_rgb(color)).astype(np.float32)\n    if colorarray.shape[1] == 3:\n        colorarray = np.column_stack([colorarray, np.float32(1.0)])\n    return colorarray\n\n\ndef _handle_list_like(colors: Sequence) -> np.ndarray:\n    """"""Parse a list-like container of colors into a numpy Nx4 array.\n\n    Handles all list-like containers of colors using recursion (if necessary).\n    The colors inside the container should all be represented in the same\n    manner. This means that a list containing [\'r\', (1., 1., 1.)] will raise\n    an error. Note that numpy arrays are handled in _handle_array. Lists which\n    are known to contain strings will be parsed with _handle_str_list_like.\n    Generators should first visit _handle_generator before arriving as input.\n\n    Parameters\n    --------\n    colors : Sequence\n        A list-like container of colors. The colors inside should be homogeneuous\n        in their representation.\n\n    Returns\n    ------\n    color_array : np.ndarray\n        Nx4 numpy array, with N being the length of ``colors``.\n    """"""\n    try:\n        # The following conversion works for most cases, and so it\'s expected\n        # that most valid inputs will pass this .asarray() call\n        # with ease. Those who don\'t are usually too cryptic to decipher.\n        color_array = np.atleast_2d(np.asarray(colors))\n    except ValueError:\n        warnings.warn(\n            ""Coudln\'t convert input color array to a proper numpy array.""\n            "" Please make sure that your input data is in a parsable format.""\n            "" Converting input to a white color array.""\n        )\n        return np.ones((max(len(colors), 1), 4), dtype=np.float32)\n\n    # Happy path - converted to a float\\integer array\n    if color_array.dtype.kind in [\'f\', \'i\']:\n        return _handle_array(color_array)\n\n    # User input was an iterable with strings\n    if color_array.dtype.kind in [\'U\', \'O\']:\n        return _handle_str_list_like(color_array.ravel())\n\n\ndef _handle_generator(colors) -> np.ndarray:\n    """"""Generators are converted to lists since we need to know their\n    length to instantiate a proper array.\n    """"""\n    return _handle_list_like(list(colors))\n\n\ndef handle_nested_colors(colors) -> ColorArray:\n    """"""In case of an array-like container holding colors, unpack it.""""""\n    colors_as_rbga = np.ones((len(colors), 4), dtype=np.float32)\n    for idx, color in enumerate(colors):\n        colors_as_rbga[idx] = _color_switch[type(color)](color)\n    return ColorArray(colors_as_rbga)\n\n\ndef _handle_array(colors: np.ndarray) -> np.ndarray:\n    """"""Converts the given array into an array in the right format.""""""\n    kind = colors.dtype.kind\n\n    # Object arrays aren\'t handled by napari\n    if kind == \'O\':\n        warnings.warn(\n            ""An object array was passed as the color input.""\n            "" Please convert its datatype before sending it to napari.""\n            "" Converting input to a white color array.""\n        )\n        return np.ones((max(len(colors), 1), 4), dtype=np.float32)\n\n    # An array of strings will be treated as a list if compatible\n    elif kind == \'U\':\n        if colors.ndim == 1:\n            return _handle_str_list_like(colors)\n        else:\n            warnings.warn(\n                ""String color arrays should be one-dimensional.""\n                "" Converting input to a white color array.""\n            )\n            return np.ones((len(colors), 4), dtype=np.float32)\n\n    # Test the dimensionality of the input array\n\n    # Empty color array can be a way for the user to signal\n    # that it wants the ""default"" colors of napari. We return\n    # a single white color.\n    if colors.shape[-1] == 0:\n        warnings.warn(\n            ""Given color input is empty. Converting input to""\n            "" a white color array.""\n        )\n        return np.ones((1, 4), dtype=np.float32)\n\n    colors = np.atleast_2d(colors)\n\n    # Arrays with more than two dimensions don\'t have a clear\n    # conversion method to a color array and thus raise an error.\n    if colors.ndim > 2:\n        raise ValueError(\n            ""Given colors input should contain one or two dimensions.""\n            f"" Received array with {colors.ndim} dimensions.""\n        )\n\n    # User provided a list of numbers as color input. This input\n    # cannot be coerced into something understandable and thus\n    # will return an error.\n    if colors.shape[0] == 1 and colors.shape[1] not in {3, 4}:\n        raise ValueError(\n            ""Given color array has an unsupported format.""\n            f"" Received the following array:\\n{colors}\\n""\n            ""A proper color array should have 3-4 columns""\n            "" with a row per data entry.""\n        )\n\n    # The user gave a list of colors, but it contains a wrong number\n    # of columns. This check will also drop Nx1 (2D) arrays, since\n    # numpy has vectors, and representing colors in this way\n    # (column vector-like) is redundant. However, this results in a\n    # warning and not a ValueError since we know the number of colors\n    # in this dataset, meaning we can save the napari session by\n    # rendering the data in white, which better than crashing.\n    if not 3 <= colors.shape[1] <= 4:\n        warnings.warn(\n            ""Given colors input should contain three or four columns.""\n            f"" Received array with {colors.shape[1]} columns.""\n            "" Converting input to a white color array.""\n        )\n        return np.ones((len(colors), 4), dtype=np.float32)\n\n    # Arrays with floats and ints can be safely converted to the proper format\n    if kind in [\'f\', \'i\', \'u\']:\n        return _convert_array_to_correct_format(colors)\n\n    else:\n        raise ValueError(f""Data type of array ({colors.dtype}) not supported."")\n\n\ndef _convert_array_to_correct_format(colors: np.ndarray) -> np.ndarray:\n    """"""Asserts shape, dtype and normalization of given color array.\n\n    This function deals with arrays which are already \'well-behaved\',\n    i.e. have (almost) the correct number of columns and are able to represent\n    colors correctly. It then it makes sure that the array indeed has exactly\n    four columns and that its values are normalized between 0 and 1, with a\n    data type of float32.\n\n    Parameters\n    --------\n    colors : np.ndarray\n        Input color array, perhaps un-normalized and without the alpha channel.\n\n    Returns\n    ------\n    colors : np.ndarray\n        Nx4, float32 color array with values in the range [0, 1]\n    """"""\n    if colors.shape[1] == 3:\n        colors = np.column_stack(\n            [colors, np.ones(len(colors), dtype=np.float32)]\n        )\n\n    if colors.min() < 0:\n        raise ValueError(""Colors input had negative values."")\n\n    if colors.max() > 1:\n        warnings.warn(\n            ""Colors with values larger than one detected. napari""\n            "" will normalize these colors for you. If you\'d like to convert these""\n            "" yourself, please use the proper method from skimage.color.""\n        )\n        colors = _normalize_color_array(colors)\n    return np.atleast_2d(np.asarray(colors, dtype=np.float32))\n\n\ndef _handle_str_list_like(colors: Sequence) -> np.ndarray:\n    """"""Converts lists or arrays filled with strings to the proper color array\n    format.\n\n    Parameters\n    ---------\n    colors : list-like\n        A sequence of string colors\n\n    Returns\n    ------\n    color_array : np.ndarray\n        Nx4, float32 color array\n    """"""\n    color_array = np.empty((len(colors), 4), dtype=np.float32)\n    for idx, c in enumerate(colors):\n        try:\n            color_array[idx, :] = _color_switch[type(c)](c)\n        except (ValueError, TypeError, KeyError):\n            raise ValueError(f""Invalid color found: {c} at index {idx}."")\n    return color_array\n\n\ndef _handle_none(color) -> np.ndarray:\n    """"""Converts color given as None to black.\n\n    Parameters\n    --------\n    color : NoneType\n        None value given as a color\n\n    Returns\n    ------\n    arr : np.ndarray\n        1x4 numpy array of float32 zeros\n\n    """"""\n    return np.zeros((1, 4), dtype=np.float32)\n\n\ndef _normalize_color_array(colors: np.ndarray) -> np.ndarray:\n    """"""Normalize all array values to the range [0, 1].\n\n    The added complexity here stems from the fact that if a row in the given\n    array contains four identical value a simple normalization might raise a\n    division by zero exception.\n\n    Parameters\n    ----------\n    colors : np.ndarray\n        A numpy array with values possibly outside the range of [0, 1]\n\n    Returns\n    -------\n    colors : np.ndarray\n        Copy of input array with normalized values\n    """"""\n    colors = colors.astype(np.float32, copy=True)\n    out_of_bounds_idx = np.unique(np.where((colors > 1) | (colors < 0))[0])\n    out_of_bounds = colors[out_of_bounds_idx]\n    norm = np.linalg.norm(out_of_bounds, np.inf, axis=1)\n    out_of_bounds = out_of_bounds / norm[:, np.newaxis]\n    colors[out_of_bounds_idx] = out_of_bounds\n    return colors.astype(np.float32)\n\n\n_color_switch: Dict[Any, Callable] = {\n    str: _handle_str,\n    np.str_: _handle_str,\n    list: _handle_list_like,\n    tuple: _handle_list_like,\n    types.GeneratorType: _handle_generator,\n    np.ndarray: _handle_array,\n    type(None): _handle_none,\n}\n\n\ndef _create_hex_to_name_dict():\n    """"""Create a dictionary mapping hexadecimal RGB colors into their\n    \'official\' name.\n\n    Returns\n    -----\n    hex_to_rgb : dict\n        Mapping from hexadecimal RGB (\'#ff0000\') to name (\'red\').\n    """"""\n    colordict = get_color_dict()\n    hex_to_name = {f""{v.lower()}ff"": k for k, v in colordict.items()}\n    hex_to_name[""#00000000""] = ""transparent""\n    return hex_to_name\n\n\ndef get_color_namelist():\n    """"""A wrapper around vispy\'s get_color_names designed to add a\n    ""transparent"" (alpha = 0) color to it.\n\n    Once https://github.com/vispy/vispy/pull/1794 is merged this\n    function is no longer necessary.\n\n    Returns\n    ------\n    color_dict : list\n        A list of all valid vispy color names plus ""transparent"".\n    """"""\n    names = get_color_names()\n    names.append(\'transparent\')\n    return names\n\n\nhex_to_name = _create_hex_to_name_dict()\n\n\ndef _check_color_dim(val):\n    """"""Ensures input is Nx4.\n\n    Parameters\n    ----------\n    val : np.ndarray\n        A color array of possibly less than 4 columns\n\n    Returns\n    -------\n    val : np.ndarray\n        A four columns version of the input array. If the original array\n        was a missing the fourth channel, it\'s added as 1.0 values.\n    """"""\n    val = np.atleast_2d(val)\n    if val.shape[1] not in (3, 4):\n        raise RuntimeError(\'Value must have second dimension of size 3 or 4\')\n    if val.shape[1] == 3:\n        val = np.column_stack([val, np.float32(1.0)])\n    return val\n\n\ndef rgb_to_hex(rgbs: Sequence) -> np.ndarray:\n    """"""Convert RGB to hex quadruplet.\n\n    Taken from vispy with slight modifications.\n\n    Parameters\n    ----------\n    rgbs : Sequence\n        A list-like container of colors in RGBA format with values\n        between [0, 1]\n\n    Returns\n    -------\n    arr : np.ndarray\n        An array of the hex representation of the input colors\n\n    """"""\n    rgbs = _check_color_dim(rgbs)\n    return np.array(\n        [\n            f\'#{""%02x"" * 4}\' % tuple((255 * rgb).astype(np.uint8))\n            for rgb in rgbs\n        ],\n        \'|U9\',\n    )\n'"
napari/utils/list/__init__.py,0,b'from ._base import List\nfrom ._model import ListModel\nfrom ._multi import MultiIndexList\nfrom ._typed import TypedList\n'
napari/utils/list/_base.py,0,"b'from collections.abc import Iterable\n\n\nclass List(list):\n    """"""Inheritable list that better connects related/dependent functions,\n    allowing for an easier time making modifications with reusable components.\n\n    It has the following new methods:\n    `__locitem__(key)` : transform a key into the index of its corresponding item  # noqa\n    `__prsitem__(key)` : parse a key such as `0:1` into indices\n    `__newlike__(iterable)` : create a new instance given an iterable\n\n    TODO: handle operators (e.g. +, *, etc.)\n    """"""\n\n    def __contains__(self, key):\n        try:\n            self.index(key)\n            return True\n        except ValueError:\n            return False\n\n    def __iter__(self):\n        for i in range(len(self)):\n            yield self[i]\n\n    def __getitem__(self, key):\n        indices = self.__prsitem__(key)\n        can_iter = isinstance(indices, Iterable)\n\n        if can_iter:\n            return self.__newlike__(\n                super(List, self).__getitem__(i) for i in indices\n            )\n\n        return super().__getitem__(indices)\n\n    def __setitem__(self, key, value):\n        super().__setitem__(self.__locitem__(key), value)\n\n    def __delitem__(self, key):\n        super().remove(key)\n\n    def __prsitem__(self, key):\n        """"""Parse a key into list indices.\n\n        Default implementation handles slices\n\n        Parameters\n        ----------\n        key : any\n            Key to parse.\n\n        Returns\n        -------\n        indices : int or iterable of int\n            Key parsed into indices.\n        """"""\n        if isinstance(key, slice):\n            start = key.start\n            stop = key.stop\n            step = key.step\n\n            if start is not None:\n                try:\n                    start = self.__locitem__(start)\n                except IndexError:\n                    if start != len(self):\n                        raise\n\n            if stop is not None:\n                try:\n                    stop = self.__locitem__(stop)\n                except IndexError:\n                    if stop != len(self):\n                        raise\n\n            return range(*slice(start, stop, step).indices(len(self)))\n        else:\n            return self.__locitem__(key)\n\n    def __locitem__(self, key):\n        """"""Parse a key into a list index.\n\n        Default implementation handles integers.\n\n        Parameters\n        ----------\n        key : any\n            Key to parse.\n\n        Returns\n        -------\n        index : int\n            Location of the object ``key`` is referencing.\n\n        Raises\n        ------\n        IndexError\n            When the index is out of bounds.\n        KeyError\n            When the key is otherwise invalid.\n        """"""\n        if not isinstance(key, int):\n            raise TypeError(f\'expected int; got {type(key)}\')\n\n        if key < 0:\n            key += len(self)\n\n        if not (0 <= key < len(self)):\n            raise IndexError(\n                f\'expected index to be in [0, {len(self)}); got {key}\'\n            )\n\n        return key\n\n    def __newlike__(self, iterable):\n        """"""Create a new instance from an iterable with the same properties\n        as this one.\n\n        Parameters\n        ----------\n        iterable : iterable\n            Elements to make the new list from.\n\n        Returns\n        -------\n        new_list : List\n            New list created from the iterable with the same properties.\n        """"""\n        cls = type(self)\n        return cls(iterable)\n\n    def copy(self):\n        return self.__newlike__(self)\n\n    def count(self, key):\n        super().count(self.__locitem__(key))\n\n    def extend(self, iterable):\n        for e in iterable:\n            self.append(e)\n\n    def insert(self, index, item):\n        super().insert(self.__locitem__(index), item)\n\n    def pop(self, index):\n        return super().pop(self.__locitem__(index))\n\n    def remove(self, item):\n        self.pop(self.__locitem__(item))\n'"
napari/utils/list/_model.py,0,"b'from ...utils.event import EmitterGroup\n\nfrom ._multi import MultiIndexList\nfrom ._typed import TypedList\n\n\nclass ListModel(MultiIndexList, TypedList):\n    """"""List with events, tuple-indexing, typing, and filtering.\n\n    Parameters\n    ----------\n    basetype : type\n        Type of the elements in the list.\n    iterable : iterable, optional\n        Elements to initialize the list with.\n    lookup : dict of type : function(object, ``basetype``) -> bool\n        Functions that determine if an object is a reference to an\n        element of the list.\n\n    Attributes\n    ----------\n    events : vispy.util.event.EmitterGroup\n        Group of events for adding, removing, and reordering elements\n        within the list.\n    """"""\n\n    def __init__(self, basetype, iterable=(), lookup=None):\n        super().__init__(basetype, iterable, lookup)\n        self.events = EmitterGroup(\n            source=self,\n            auto_connect=True,\n            added=None,\n            removed=None,\n            reordered=None,\n            changed=None,\n        )\n        self.events.added.connect(self.events.changed)\n        self.events.removed.connect(self.events.changed)\n        self.events.reordered.connect(self.events.changed)\n\n    def __setitem__(self, query, values):\n        indices = tuple(self.__prsitem__(query))\n        new_indices = tuple(values)\n\n        if sorted(indices) != sorted(self.index(v) for v in new_indices):\n            raise TypeError(\n                \'must be a reordering of indices; \'\n                \'setting of list items not allowed\'\n            )\n\n        super().__setitem__(indices, new_indices)\n        self.events.reordered()\n\n    def insert(self, index, obj):\n        super().insert(index, obj)\n        self.events.added(item=obj, index=self.__locitem__(index))\n\n    def append(self, obj):\n        TypedList.append(self, obj)\n        self.events.added(item=obj, index=len(self) - 1)\n\n    def pop(self, key):\n        obj = super().pop(key)\n        self.events.removed(item=obj, index=key)\n        return obj\n'"
napari/utils/list/_multi.py,0,"b'from collections.abc import Iterable\nfrom ._base import List\n\n\nclass MultiIndexList(List):\n    """"""Allow indexing with tuples.\n    """"""\n\n    def __prsitem__(self, keys):\n        if not isinstance(keys, tuple):\n            return super().__prsitem__(keys)\n\n        indices = []\n\n        for key in keys:\n            i = self.__prsitem__(key)\n            can_iter = isinstance(i, Iterable)\n            if can_iter:\n                indices.extend(i)\n            else:\n                indices.append(i)\n\n        # TODO: how to handle duplicates?\n\n        return indices\n\n    def __setitem__(self, key, value):\n        indices = self.__prsitem__(key)\n        can_iter = isinstance(indices, Iterable)\n\n        if can_iter:\n            if hasattr(value, \'__getitem__\') and hasattr(value, \'__len__\'):\n                # value is a vector\n                if len(value) != len(indices):\n                    raise ValueError(\n                        f\'expected {len(indices)} values; \' f\'got {len(value)}\'\n                    )\n                for o, i in enumerate(indices):\n                    super().__setitem__(i, value[o])\n            else:\n                # value is a scalar\n                for i in indices:\n                    super().__setitem__(i, value)\n        else:\n            super().__setitem__(indices, value)\n\n    def __delitem__(self, key):\n        indices = self.__prsitem__(key)\n        can_iter = isinstance(indices, Iterable)\n\n        if can_iter:\n            for i in indices:\n                super().__delitem__(i)\n        else:\n            super().__delitem__(indices)\n'"
napari/utils/list/_typed.py,0,"b'from ._base import List\n\n\ndef cpprint(obj):\n    return obj.__name__\n\n\nclass TypedList(List):\n    """"""Enforce list elements to be of a specific type and allow indexing with\n    their unique properties.\n\n    Parameters\n    ----------\n    basetype : type\n        Type of the elements in the list.\n    iterable : iterable, optional\n        Elements to initialize the list with.\n    lookup : dict of type : function(object, ``basetype``) -> bool\n        Functions that determine if an object is a reference to an\n        element of the list.\n    """"""\n\n    def __init__(self, basetype, iterable=(), lookup=None):\n        if lookup is None:\n            lookup = {}\n        self._basetype = basetype\n        self._lookup = lookup\n        super().__init__(self._check(e) for e in iterable)\n\n    def __setitem__(self, key, value):\n        self._check(value)\n        super().__setitem__(key, value)\n\n    def __locitem__(self, key):\n        if not isinstance(key, int):\n            key = self.index(key)\n        return super().__locitem__(key)\n\n    def __newlike__(self, iterable):\n        cls = type(self)\n        return cls(self._basetype, iterable, self._lookup)\n\n    def _check(self, e):\n        if not isinstance(e, self._basetype):\n            raise TypeError(\n                f\'expected {cpprint(self._basetype)}; \'\n                f\'got {cpprint(type(e))}\'\n            )\n        return e\n\n    def insert(self, key, object):\n        self._check(object)\n        super().insert(key, object)\n\n    def append(self, object):\n        self._check(object)\n        super().append(object)\n\n    def index(self, value, start=None, stop=None):\n        q = value\n        basetype = self._basetype\n\n        if not isinstance(q, basetype):\n            lookup = self._lookup\n\n            for t in lookup:\n                if isinstance(q, t):\n                    break\n            else:\n                raise TypeError(\n                    f\'expected object of type {cpprint(basetype)} \'\n                    f\'or one of {set(cpprint(t) for t in lookup)}; \'\n                    f\'got {cpprint(type(q))}\'\n                )\n\n            ref = lookup[t]\n\n            for e in self[start:stop]:\n                if ref(q, e):\n                    break\n            else:\n                raise KeyError(f\'could not find element {q} was referencing\')\n\n            q = e\n\n        return super().index(q)\n'"
napari/utils/perf/__init__.py,0,"b'""""""Performance Monitoring init.\n\nUSE_PERFMON is true only if NAPARI_PERFMON environment variable is set and not\nzero.\n\ntimers is an instance of PerfTimers with these methods:\n    add_event(event: PerfEvent)\n    clear()\n    start_trace_file(path: str)\n    stop_trace_file()\n\nUse perf_timer to time blocks of code.\nUse perf_func to time functions.\n""""""\nfrom ._config import USE_PERFMON\nfrom ._event import PerfEvent\nfrom ._timers import timers\nfrom ._utils import perf_timer, perf_func\n'"
napari/utils/perf/_compat.py,0,"b'""""""Compatibility functions.\n""""""\nimport time\n\nfrom ._config import PYTHON_3_7\n\n\nif PYTHON_3_7:\n    # Use the real perf_counter_ns\n    perf_counter_ns = time.perf_counter_ns\nelse:\n\n    def perf_counter_ns():\n        """"""Compatibility version for pre Python 3.7.""""""\n        return int(time.perf_counter() * 1e9)\n'"
napari/utils/perf/_config.py,0,"b'""""""Perf configuration flags.\n""""""\nimport os\nimport sys\n\n# If USE_PERFMON is not set then performance timers will be 100% disabled with\n# hopefully zero run-time impact.\nUSE_PERFMON = os.getenv(""NAPARI_PERFMON"", ""0"") != ""0""\n\n# We have some pre-3.7 functionality.\nPYTHON_3_7 = sys.version_info[:2] >= (3, 7)\n'"
napari/utils/perf/_event.py,0,"b'""""""PerfEvent class.\n""""""\n\n\nclass PerfEvent:\n    """"""One perf event represents a span of time.\n\n    Parameters\n    ----------\n    category : str\n        You can toggle categories on/off in some GUIs.\n    name : str\n        The name of this event like ""draw"".\n    start_ns : int\n        Start time in nanoseconds.\n    end_ns : int\n        End time in nanoseconds.\n\n    Notes\n    -----\n    The times are from perf_counter_ns() and do not indicate time of day,\n    the origin is arbitrary. But subtracting two counters is valid.\n    """"""\n\n    def __init__(self, category: str, name: str, start_ns: int, end_ns: int):\n        self.category = category\n        self.name = name\n        self.start_ns = start_ns\n        self.end_ns = end_ns\n\n    @property\n    def start_us(self):\n        return self.start_ns / 1e3\n\n    @property\n    def start_ms(self):\n        return self.start_ns / 1e6\n\n    @property\n    def duration_ns(self):\n        return self.end_ns - self.start_ns\n\n    @property\n    def duration_us(self):\n        return self.duration_ns / 1e3\n\n    @property\n    def duration_ms(self):\n        return self.duration_ns / 1e6\n'"
napari/utils/perf/_stat.py,0,"b'""""""Stat class.\n""""""\n\n\nclass Stat:\n    """"""Keep min/max/average on an integer value.\n\n    Parameters\n    ----------\n    value : int\n        The first value to keep statistics on.\n\n    Attributes\n    ----------\n    min : int\n        Minimum value so far.\n    max : int\n        Maximum value so far.\n    sum : int\n        Sum of all values seen.\n    count : int\n        How many values we\'ve seen.\n    """"""\n\n    def __init__(self, value: int):\n        """"""Create Stat with an initial value.\n\n        Parameters\n        ----------\n        value : int\n            Initial value.\n        """"""\n        self.min = value\n        self.max = value\n        self.sum = value\n        self.count = 1\n\n    def add(self, value: int) -> None:\n        """"""Add a new value.\n\n        Parameters\n        ----------\n        value : int\n            The new value.\n        """"""\n        self.sum += value\n        self.count += 1\n        self.max = max(self.max, value)\n        self.min = min(self.min, value)\n\n    @property\n    def average(self) -> int:\n        """"""Average value.\n\n        Returns\n        -------\n        average value : int.\n        """"""\n        if self.count > 0:\n            return self.sum / self.count\n        raise ValueError(""no values"")  # impossible for us\n'"
napari/utils/perf/_timers.py,0,"b'""""""PerfTimers class and global instance.\n""""""\nfrom ._config import USE_PERFMON\nfrom ._event import PerfEvent\nfrom ._stat import Stat\nfrom ._trace_file import PerfTraceFile\n\n\nclass PerfTimers:\n    """"""Timers for performance monitoring.\n\n    For each PerfEvent recorded we do two things:\n    1) Update our self.timers dictionary (always).\n    2) Write to a trace file (optional if recording one).\n\n    Anyone can record a timing event, but these are 3 common ways:\n    1) Our custom QtApplication times Qt Events.\n    2) Our perf_timer context object times blocks of code.\n    3) Our perf_func decorator can time functions.\n\n    The QtPerformance Widget goes through our self.timers looking for long events\n    and prints them to a log window. Then it clears the timers.\n\n    Attributes\n    ----------\n    timers : dict\n        Maps a timer name to a SimpleStat object.\n    trace_file : PerfTraceFile, optional\n        The tracing file we are writing to if any.\n\n    Notes\n    -----\n    Chrome deduces nesting based on the start and end times of each timer. The\n    chrome://tracing GUI shows the nesting as stacks of colored rectangles.\n\n    However our self.timers dictionary and thus our QtPerformance widget do not\n    currently understand nesting. So if they say two timers each took 1ms, you\n    can\'t tell if one called the other or not.\n\n    Despite this limitation when the QtPerformance widget reports slow timers it\n    still gives you a good idea what was slow. And then you can use the\n    chrome://tracing GUI to see the full story.\n    """"""\n\n    def __init__(self):\n        """"""Create PerfTimers.\n        """"""\n        # Maps a timer name to one Stat object.\n        self.timers = {}\n\n        # Menu item ""Debug -> Record Trace File..."" starts a trace.\n        self.trace_file = None\n\n    def add_event(self, event: PerfEvent):\n        """"""Add one timing event.\n\n        Parameters\n        ----------\n        event : PerfEvent\n            Add this event.\n        """"""\n        # Write if actively tracing.\n        if self.trace_file is not None:\n            self.trace_file.write_event(event)\n\n        # Update our self.timers (in milliseconds).\n        name = event.name\n        duration_ms = event.duration_ms\n        if name in self.timers:\n            self.timers[name].add(duration_ms)\n        else:\n            self.timers[name] = Stat(duration_ms)\n\n    def clear(self):\n        """"""Clear all timers.\n        """"""\n        # After the GUI displays timing information it clears the timers\n        # so that we start accumulating fresh information.\n        self.timers.clear()\n\n    def start_trace_file(self, path: str) -> None:\n        """"""Start recording a trace file to disk.\n\n        Parameters\n        ----------\n        path : str\n            Write the trace to this path.\n        """"""\n        self.trace_file = PerfTraceFile(path)\n\n    def stop_trace_file(self) -> None:\n        """"""Stop recording a trace file.\n        """"""\n        if self.trace_file is not None:\n            self.trace_file.outf.close()\n            self.trace_file = None\n\n\nif USE_PERFMON:\n    # The one global instance\n    timers = PerfTimers()\nelse:\n    # No one should be access this since they are disabled.\n    timers = None\n'"
napari/utils/perf/_trace_file.py,0,"b'""""""PerfTraceFile class to write JSON files in the chrome://tracing format.\n""""""\nimport json\nimport os\nimport threading\n\nfrom ._compat import perf_counter_ns\nfrom ._event import PerfEvent\n\n\nclass PerfTraceFile:\n    """"""Writes a chrome://tracing formatted JSON file.\n\n    Chrome has a nice built-in performance tool called chrome://tracing. Chrome\n    can record traces of web applications. But the format is well-documented and\n    anyone can create the files and use the nice GUI. And other programs accept\n    the format including:\n    1) https://www.speedscope.app/ which does flamegraphs (Chrome doesn\'t).\n    2) Qt Creator\'s performance tools.\n\n    Parameters\n    ----------\n    path : str\n        Write the trace file to this path.\n\n    Attributes\n    ----------\n    zero_ns : int\n        perf_counter_ns() time when we started the trace.\n    pid : int\n        Process ID.\n    tid : int\n        Thread ID.\n    outf : file handle\n        JSON file we are writing to.\n\n    Notes\n    -----\n    There are two chrome://tracing formats:\n    1) JSON Array Format\n    2) JSON Object Format\n\n    We are using the JSON Array Format right now, the file can be cut off at\n    anytime. The other format allows for more options if we need them but must\n    be closed properly.\n\n    See the ""trace_event format"" Google Doc for details:\n    https://chromium.googlesource.com/catapult/+/HEAD/tracing/README.md\n    """"""\n\n    def __init__(self, path: str):\n        """"""Open the tracing file on disk.\n        """"""\n        # So the events we write start at t=0.\n        self.zero_ns = perf_counter_ns()\n\n        # PID and TID go in every event. We are assuming one process and\n        # one thread for now, otherwise we\'ll have to add these to PerfEvent.\n        self.pid = os.getpid()\n        self.tid = threading.get_ident()\n\n        # Start writing the file with an open bracket, per JSON Array format.\n        self.outf = open(path, ""w"")\n        self.outf.write(""[\\n"")\n\n    def write_event(self, event: PerfEvent) -> None:\n        """"""Write one perf event.\n\n        Parameters\n        ----------\n        event : PerfEvent\n            Event to write.\n        """"""\n        # Event type ""X"" denotes a completed event. Meaning we already\n        # know the duration. The format wants times in micro-seconds.\n        data = {\n            ""pid"": self.pid,\n            ""name"": event.name,\n            ""cat"": event.category,\n            ""ph"": ""X"",\n            ""ts"": event.start_us,\n            ""dur"": event.duration_us,\n        }\n        json_str = json.dumps(data)\n\n        # Write comma separated JSON objects. Note jsonlines is really a better\n        # way to write JSON that can be cut off, but chrome://tracing probably\n        # predates that convention.\n        self.outf.write(f""{json_str},\\n"")\n\n        # Write as we go in case we exit without closing.\n        self.outf.flush()\n'"
napari/utils/perf/_utils.py,0,"b'""""""Utilities to support performance monitoring:\n\n1) context manager: perf_timer times a block of code.\n2) decorator: perf_func times a function.\n""""""\nimport contextlib\nimport functools\nfrom typing import Optional\n\nfrom ._compat import perf_counter_ns\nfrom ._config import USE_PERFMON, PYTHON_3_7\nfrom ._event import PerfEvent\nfrom ._timers import timers\n\n\nif USE_PERFMON:\n\n    @contextlib.contextmanager\n    def perf_timer(name: str, category: Optional[str] = None):\n        """"""Time a block of code.\n\n        Parameters\n        ----------\n        name : str\n            The name of this timer.\n        category : str, optional\n            Category for this timer.\n\n        Example\n        -------\n        with perf_timer(""draw""):\n            draw_stuff()\n        """"""\n        start_ns = perf_counter_ns()\n        yield\n        end_ns = perf_counter_ns()\n        event = PerfEvent(category, name, start_ns, end_ns)\n        timers.add_event(event)\n\n    def perf_func(func):\n        """"""Decorator to time a function.\n\n        The timer name is automatically based on the function\'s name.\n\n        Parameters\n        ----------\n        func\n            The function we are wrapping.\n\n        Example\n        -------\n        @perf_func\n        def draw(self):\n            draw_stuff()\n        """"""\n        # Name alone first so that\'s visible in the GUI first.\n        timer_name = f""{func.__name__} - {func.__module__}.{func.__qualname__}""\n\n        @functools.wraps(func)\n        def time_function(*args, **kwargs):\n\n            with perf_timer(timer_name, ""decorator""):\n                return func(*args, **kwargs)\n\n        return time_function\n\n    def perf_func_named(timer_name: str):\n        """"""Decorator to time a function where we specify the timer name.\n\n        Parameters\n        ----------\n        timer_name : str\n            The name to give this timer.\n\n        Example\n        -------\n        @perf_func_name(""important draw"")\n        def draw(self):\n            draw_stuff()\n        """"""\n\n        def decorator(func):\n            @functools.wraps(func)\n            def time_function(*args, **kwargs):\n                with perf_timer(timer_name, ""decorator""):\n                    return func(*args, **kwargs)\n\n            return time_function\n\n        return decorator\n\n\nelse:\n    # Disable both with hopefully zero run-time overhead.\n    if PYTHON_3_7:\n        perf_timer = contextlib.nullcontext()\n    else:\n\n        @contextlib.contextmanager\n        def perf_timer(name: str):\n            yield\n\n    def perf_func():\n        def decorator(func):\n            return func\n\n    def perf_func_named(timer_name: str):\n        def decorator(func):\n            return func\n'"
napari/_qt/layers/_tests/__init__.py,0,b''
napari/_qt/layers/_tests/test_qt_image_base_layer_.py,7,"b'import os\nfrom sys import platform\n\nimport numpy as np\nimport pytest\nfrom qtpy.QtCore import Qt\nfrom qtpy.QtWidgets import QPushButton\n\nfrom napari._qt.layers.qt_image_base_layer import (\n    QtBaseImageControls,\n    create_range_popup,\n)\nfrom napari.layers import Image, Surface\n\n_IMAGE = np.arange(100).astype(np.uint16).reshape((10, 10))\n_SURF = (\n    np.random.random((10, 2)),\n    np.random.randint(10, size=(6, 3)),\n    np.arange(100).astype(np.float),\n)\n\n\n@pytest.mark.parametrize(\'layer\', [Image(_IMAGE), Surface(_SURF)])\ndef test_base_controls_creation(qtbot, layer):\n    """"""Check basic creation of QtBaseImageControls works""""""\n    qtctrl = QtBaseImageControls(layer)\n    qtbot.addWidget(qtctrl)\n    original_clims = tuple(layer.contrast_limits)\n    slider_clims = qtctrl.contrastLimitsSlider.values()\n    assert slider_clims[0] == 0\n    assert slider_clims[1] == 99\n    assert tuple(slider_clims) == original_clims\n\n\n@pytest.mark.parametrize(\'layer\', [Image(_IMAGE), Surface(_SURF)])\ndef test_clim_right_click_shows_popup(qtbot, layer):\n    """"""Right clicking on the contrast limits slider should show a popup.""""""\n    qtctrl = QtBaseImageControls(layer)\n    qtbot.addWidget(qtctrl)\n    qtbot.mousePress(qtctrl.contrastLimitsSlider, Qt.RightButton)\n    assert hasattr(qtctrl, \'clim_pop\')\n    # virtualized tests on windows CI are failing on isVisible()\n    if not (os.environ.get(\'CI\') and platform == \'win32\'):\n        assert qtctrl.clim_pop.isVisible()\n\n\n@pytest.mark.parametrize(\'layer\', [Image(_IMAGE), Surface(_SURF)])\ndef test_changing_model_updates_view(qtbot, layer):\n    """"""Changing the model attribute should update the view""""""\n    qtctrl = QtBaseImageControls(layer)\n    qtbot.addWidget(qtctrl)\n    new_clims = (20, 40)\n    layer.contrast_limits = new_clims\n    assert tuple(qtctrl.contrastLimitsSlider.values()) == new_clims\n\n\n@pytest.mark.parametrize(\'layer\', [Image(_IMAGE), Surface(_SURF)])\ndef test_range_popup_clim_buttons(qtbot, layer):\n    """"""The buttons in the clim_popup should adjust the contrast limits value""""""\n    qtctrl = QtBaseImageControls(layer)\n    qtbot.addWidget(qtctrl)\n    original_clims = tuple(layer.contrast_limits)\n    layer.contrast_limits = (20, 40)\n    qtbot.mousePress(qtctrl.contrastLimitsSlider, Qt.RightButton)\n\n    # pressing the reset button returns the clims to the default values\n    reset_button = qtctrl.clim_pop.findChild(QPushButton, ""reset_clims_button"")\n    reset_button.click()\n    qtbot.wait(20)\n    assert tuple(qtctrl.contrastLimitsSlider.values()) == original_clims\n\n    rangebtn = qtctrl.clim_pop.findChild(QPushButton, ""full_clim_range_button"")\n    # the data we created above was uint16 for Image, and float for Surface\n    # Surface will not have a ""full range button""\n    if np.issubdtype(layer.dtype, np.integer):\n        rangebtn.click()\n        qtbot.wait(20)\n        assert tuple(layer.contrast_limits_range) == (0, 2 ** 16 - 1)\n        assert tuple(qtctrl.contrastLimitsSlider.range()) == (0, 2 ** 16 - 1)\n    else:\n        assert rangebtn is None\n\n\n@pytest.mark.parametrize(\'mag\', [-12, -9, -3, 0, 2, 4, 6])\ndef test_clim_slider_step_size_and_precision(qtbot, mag):\n    """"""Make sure the slider has a reasonable step size and precision.\n\n    ...across a broad range of orders of magnitude.\n    """"""\n    layer = Image(np.random.rand(20, 20) / 10 ** mag)\n    popup = create_range_popup(layer, \'contrast_limits\')\n    qtbot.addWidget(popup)\n    # the range slider popup labels should have a number of decimal points that\n    # is inversely proportional to the order of magnitude of the range of data,\n    # but should never be greater than 5 or less than 0\n    assert popup.precision == max(min(mag + 3, 5), 0)\n\n    # the slider step size should also be inversely proportional to the data\n    # range, with 1000 steps across the data range\n    assert np.ceil(popup.slider._step * 10 ** (mag + 4)) == 10\n'"
napari/layers/image/_tests/__init__.py,0,b''
napari/layers/image/_tests/test_big_image_timing.py,0,"b'import dask.array as da\nimport zarr\nfrom napari.layers import Image\nimport pytest\n\n\ndata_dask = da.random.random(\n    size=(100_000, 1000, 1000), chunks=(1, 1000, 1000)\n)\ndata_zarr = zarr.zeros((100_000, 1000, 1000))\ndata_dask_2D = da.random.random((100_000, 100_000))\n\n\n@pytest.mark.timeout(2)\n@pytest.mark.parametrize(\'data\', [data_dask, data_zarr])\ndef test_timing_fast_big_dask_all_specified_(data):\n    layer = Image(data, multiscale=False, contrast_limits=[0, 1])\n    assert layer.data.shape == data.shape\n\n\n@pytest.mark.timeout(2)\n@pytest.mark.parametrize(\'data\', [data_dask, data_zarr])\ndef test_timing_fast_big_dask_multiscale_specified(data):\n    layer = Image(data, multiscale=False)\n    assert layer.data.shape == data.shape\n\n\n@pytest.mark.timeout(2)\n@pytest.mark.parametrize(\'data\', [data_dask, data_zarr])\ndef test_timing_fast_big_dask_contrast_limits_specified(data):\n    layer = Image(data, contrast_limits=[0, 1])\n    assert layer.data.shape == data.shape\n\n\n@pytest.mark.timeout(2)\n@pytest.mark.parametrize(\'data\', [data_dask, data_zarr])\ndef test_timing_fast_big_dask_nothing_specified(data):\n    layer = Image(data)\n    assert layer.data.shape == data.shape\n\n\n@pytest.mark.timeout(2)\ndef test_non_visible_images():\n    """"""Test loading non-visible images doesn\'t trigger compute.""""""\n    layer = Image(\n        data_dask_2D, visible=False, multiscale=False, contrast_limits=[0, 1],\n    )\n    assert layer.data.shape == data_dask_2D.shape\n'"
napari/layers/image/_tests/test_image.py,104,"b'import numpy as np\nimport dask.array as da\nimport xarray as xr\n\nimport pytest\nfrom vispy.color import Colormap\nfrom napari.layers import Image\n\n\ndef test_random_image():\n    """"""Test instantiating Image layer with random 2D data.""""""\n    shape = (10, 15)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n    assert layer.rgb is False\n    assert layer.multiscale is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_negative_image():\n    """"""Test instantiating Image layer with negative data.""""""\n    shape = (10, 15)\n    np.random.seed(0)\n    # Data between -1.0 and 1.0\n    data = 2 * np.random.random(shape) - 1.0\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n    # Data between -10 and 10\n    data = 20 * np.random.random(shape) - 10\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_all_zeros_image():\n    """"""Test instantiating Image layer with all zeros data.""""""\n    shape = (10, 15)\n    data = np.zeros(shape, dtype=float)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_integer_image():\n    """"""Test instantiating Image layer with integer data.""""""\n    shape = (10, 15)\n    np.random.seed(0)\n    data = np.round(10 * np.random.random(shape)).astype(int)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_bool_image():\n    """"""Test instantiating Image layer with bool data.""""""\n    shape = (10, 15)\n    data = np.zeros(shape, dtype=bool)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_3D_image():\n    """"""Test instantiating Image layer with random 3D data.""""""\n    shape = (10, 15, 6)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_3D_image_shape_1():\n    """"""Test instantiating Image layer with random 3D data with shape 1 axis.""""""\n    shape = (1, 10, 15)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_4D_image():\n    """"""Test instantiating Image layer with random 4D data.""""""\n    shape = (10, 15, 6, 8)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_5D_image_shape_1():\n    """"""Test instantiating Image layer with random 5D data with shape 1 axis.""""""\n    shape = (4, 1, 2, 10, 15)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_rgb_image():\n    """"""Test instantiating Image layer with RGB data.""""""\n    shape = (10, 15, 3)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape) - 1\n    assert layer.shape == shape[:-1]\n    assert layer.rgb is True\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_rgba_image():\n    """"""Test instantiating Image layer with RGBA data.""""""\n    shape = (10, 15, 4)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape) - 1\n    assert layer.shape == shape[:-1]\n    assert layer.rgb is True\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_negative_rgba_image():\n    """"""Test instantiating Image layer with negative RGBA data.""""""\n    shape = (10, 15, 4)\n    np.random.seed(0)\n    # Data between -1.0 and 1.0\n    data = 2 * np.random.random(shape) - 1\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape) - 1\n    assert layer.shape == shape[:-1]\n    assert layer.rgb is True\n    assert layer._data_view.shape == shape[-3:]\n\n    # Data between -10 and 10\n    data = 20 * np.random.random(shape) - 10\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape) - 1\n    assert layer.shape == shape[:-1]\n    assert layer.rgb is True\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_non_rgb_image():\n    """"""Test forcing Image layer to be 3D and not rgb.""""""\n    shape = (10, 15, 3)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data, rgb=False)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_error_non_rgb_image():\n    """"""Test error on trying non rgb as rgb.""""""\n    # If rgb is set to be True in constructor but the last dim has a\n    # size > 4 then data cannot actually be rgb\n    shape = (10, 15, 6)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    with pytest.raises(ValueError):\n        Image(data, rgb=True)\n\n\ndef test_changing_image():\n    """"""Test changing Image data.""""""\n    shape_a = (10, 15)\n    shape_b = (20, 12)\n    np.random.seed(0)\n    data_a = np.random.random(shape_a)\n    data_b = np.random.random(shape_b)\n    layer = Image(data_a)\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == len(shape_b)\n    assert layer.shape == shape_b\n    assert layer.dims.range == [(0, m, 1) for m in shape_b]\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape_b[-2:]\n\n\ndef test_changing_image_dims():\n    """"""Test changing Image data including dimensionality.""""""\n    shape_a = (10, 15)\n    shape_b = (20, 12, 6)\n    np.random.seed(0)\n    data_a = np.random.random(shape_a)\n    data_b = np.random.random(shape_b)\n    layer = Image(data_a)\n\n    # Prep indices for switch to 3D\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == len(shape_b)\n    assert layer.shape == shape_b\n    assert layer.dims.range == [(0, m, 1) for m in shape_b]\n    assert layer.rgb is False\n    assert layer._data_view.shape == shape_b[-2:]\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.name == \'Image\'\n\n    layer = Image(data, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'img\'\n    assert layer.name == \'img\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Image(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting layer opacity.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.opacity == 1\n\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    layer = Image(data, opacity=0.6)\n    assert layer.opacity == 0.6\n\n    layer.opacity = 0.3\n    assert layer.opacity == 0.3\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Image(data, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\ndef test_interpolation():\n    """"""Test setting image interpolation mode.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.interpolation == \'nearest\'\n\n    layer = Image(data, interpolation=\'bicubic\')\n    assert layer.interpolation == \'bicubic\'\n\n    layer.interpolation = \'bilinear\'\n    assert layer.interpolation == \'bilinear\'\n\n\ndef test_colormaps():\n    """"""Test setting test_colormaps.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.colormap[0] == \'gray\'\n    assert type(layer.colormap[1]) == Colormap\n\n    layer.colormap = \'magma\'\n    assert layer.colormap[0] == \'magma\'\n    assert type(layer.colormap[1]) == Colormap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.3, 0.7, 0.2, 1.0]])\n    layer.colormap = \'custom\', cmap\n    assert layer.colormap[0] == \'custom\'\n    assert layer.colormap[1] == cmap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.7, 0.2, 0.6, 1.0]])\n    layer.colormap = {\'new\': cmap}\n    assert layer.colormap[0] == \'new\'\n    assert layer.colormap[1] == cmap\n\n    layer = Image(data, colormap=\'magma\')\n    assert layer.colormap[0] == \'magma\'\n    assert type(layer.colormap[1]) == Colormap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.3, 0.7, 0.2, 1.0]])\n    layer = Image(data, colormap=(\'custom\', cmap))\n    assert layer.colormap[0] == \'custom\'\n    assert layer.colormap[1] == cmap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.7, 0.2, 0.6, 1.0]])\n    layer = Image(data, colormap={\'new\': cmap})\n    assert layer.colormap[0] == \'new\'\n    assert layer.colormap[1] == cmap\n\n\ndef test_contrast_limits():\n    """"""Test setting color limits.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.contrast_limits[0] >= 0\n    assert layer.contrast_limits[1] <= 1\n    assert layer.contrast_limits[0] < layer.contrast_limits[1]\n    assert layer.contrast_limits == layer.contrast_limits_range\n\n    # Change contrast_limits property\n    contrast_limits = [0, 2]\n    layer.contrast_limits = contrast_limits\n    assert layer.contrast_limits == contrast_limits\n    assert layer.contrast_limits_range == contrast_limits\n\n    # Set contrast_limits as keyword argument\n    layer = Image(data, contrast_limits=contrast_limits)\n    assert layer.contrast_limits == contrast_limits\n    assert layer.contrast_limits_range == contrast_limits\n\n\ndef test_contrast_limits_range():\n    """"""Test setting color limits range.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.contrast_limits_range[0] >= 0\n    assert layer.contrast_limits_range[1] <= 1\n    assert layer.contrast_limits_range[0] < layer.contrast_limits_range[1]\n\n    # If all data is the same value the contrast_limits_range and\n    # contrast_limits defaults to [0, 1]\n    data = np.zeros((10, 15))\n    layer = Image(data)\n    assert layer.contrast_limits_range == [0, 1]\n    assert layer.contrast_limits == [0.0, 1.0]\n\n\ndef test_set_contrast_limits_range():\n    """"""Test setting color limits range.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15)) * 100\n    layer = Image(data)\n    layer.contrast_limits_range = [0, 100]\n    layer.contrast_limits = [20, 40]\n    assert layer.contrast_limits_range == [0, 100]\n    assert layer.contrast_limits == [20, 40]\n\n    # clim values should stay within the contrast limits range\n    layer.contrast_limits_range = [0, 30]\n    assert layer.contrast_limits == [20, 30]\n    # setting contrast limits range should clamp both of the clims values\n    layer.contrast_limits_range = [0, 10]\n    assert layer.contrast_limits == [10, 10]\n    # in both directions...\n    layer.contrast_limits_range = [0, 100]\n    layer.contrast_limits = [20, 40]\n    layer.contrast_limits_range = [60, 100]\n    assert layer.contrast_limits == [60, 60]\n\n\ndef test_gamma():\n    """"""Test setting gamma.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.gamma == 1\n\n    # Change gamma property\n    gamma = 0.7\n    layer.gamma = gamma\n    assert layer.gamma == gamma\n\n    # Set gamma as keyword argument\n    layer = Image(data, gamma=gamma)\n    assert layer.gamma == gamma\n\n\ndef test_rendering():\n    """"""Test setting rendering.""""""\n    np.random.seed(0)\n    data = np.random.random((20, 10, 15))\n    layer = Image(data)\n    assert layer.rendering == \'mip\'\n\n    # Change rendering property\n    layer.rendering = \'translucent\'\n    assert layer.rendering == \'translucent\'\n\n    # Change rendering property\n    layer.rendering = \'attenuated_mip\'\n    assert layer.rendering == \'attenuated_mip\'\n\n    # Change rendering property\n    layer.rendering = \'iso\'\n    assert layer.rendering == \'iso\'\n\n    # Change rendering property\n    layer.rendering = \'additive\'\n    assert layer.rendering == \'additive\'\n\n\ndef test_iso_threshold():\n    """"""Test setting iso_threshold.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.iso_threshold == 0.5\n\n    # Change iso_threshold property\n    iso_threshold = 0.7\n    layer.iso_threshold = iso_threshold\n    assert layer.iso_threshold == iso_threshold\n\n    # Set iso_threshold as keyword argument\n    layer = Image(data, iso_threshold=iso_threshold)\n    assert layer.iso_threshold == iso_threshold\n\n\ndef test_attenuation():\n    """"""Test setting attenuation.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.attenuation == 0.5\n\n    # Change iso_threshold property\n    attenuation = 0.7\n    layer.attenuation = attenuation\n    assert layer.attenuation == attenuation\n\n    # Set attenuation as keyword argument\n    layer = Image(data, attenuation=attenuation)\n    assert layer.attenuation == attenuation\n\n\ndef test_metadata():\n    """"""Test setting image metadata.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    assert layer.metadata == {}\n\n    layer = Image(data, metadata={\'unit\': \'cm\'})\n    assert layer.metadata == {\'unit\': \'cm\'}\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert value == data[0, 0]\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    layer = Image(data)\n    msg = layer.get_message()\n    assert type(msg) == str\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    np.random.seed(0)\n    data = np.random.random((30, 30))\n    layer = Image(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_narrow_thumbnail():\n    """"""Ensure that the thumbnail generation works for very narrow images.\n\n    See: https://github.com/napari/napari/issues/641 and\n    https://github.com/napari/napari/issues/489\n    """"""\n    image = np.random.random((1, 2048))\n    layer = Image(image)\n    layer._update_thumbnail()\n    thumbnail = layer.thumbnail[..., :3]  # ignore alpha channel\n    middle_row = thumbnail.shape[0] // 2\n    assert np.all(thumbnail[: middle_row - 1] == 0)\n    assert np.all(thumbnail[middle_row + 1 :] == 0)\n    assert np.mean(thumbnail[middle_row - 1 : middle_row + 1]) > 0\n\n\n@pytest.mark.parametrize(\'dtype\', [np.float32, np.float64])\ndef test_out_of_range_image(dtype):\n    data = -1.7 - 0.001 * np.random.random((10, 15)).astype(dtype)\n    layer = Image(data)\n    layer._update_thumbnail()\n\n\n@pytest.mark.parametrize(\'dtype\', [np.float32, np.float64])\ndef test_out_of_range_no_contrast(dtype):\n    data = np.full((10, 15), -3.2, dtype=dtype)\n    layer = Image(data)\n    layer._update_thumbnail()\n\n\n@pytest.mark.parametrize(\n    ""scale"",\n    [\n        (None),\n        ([1, 1]),\n        (np.array([1, 1])),\n        (da.from_array([1, 1], chunks=1)),\n        (da.from_array([1, 1], chunks=2)),\n        (xr.DataArray(np.array([1, 1]))),\n        (xr.DataArray(np.array([1, 1]), dims=(\'dimension_name\'))),\n    ],\n)\ndef test_image_scale(scale):\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    Image(data, scale=scale)\n\n\n@pytest.mark.parametrize(\n    ""translate"",\n    [\n        (None),\n        ([1, 1]),\n        (np.array([1, 1])),\n        (da.from_array([1, 1], chunks=1)),\n        (da.from_array([1, 1], chunks=2)),\n        (xr.DataArray(np.array([1, 1]))),\n        (xr.DataArray(np.array([1, 1]), dims=(\'dimension_name\'))),\n    ],\n)\ndef test_image_translate(translate):\n    np.random.seed(0)\n    data = np.random.random((10, 15))\n    Image(data, translate=translate)\n'"
napari/layers/image/_tests/test_image_utils.py,11,"b'import dask.array as da\nimport numpy as np\nimport pytest\nfrom skimage.transform import pyramid_gaussian\nfrom napari.layers.image._image_utils import (\n    guess_multiscale,\n    guess_rgb,\n)\n\n\ndata_dask = da.random.random(\n    size=(100_000, 1000, 1000), chunks=(1, 1000, 1000)\n)\n\n\ndef test_guess_rgb():\n    shape = (10, 15)\n    assert not guess_rgb(shape)\n\n    shape = (10, 15, 6)\n    assert not guess_rgb(shape)\n\n    shape = (10, 15, 3)\n    assert guess_rgb(shape)\n\n    shape = (10, 15, 4)\n    assert guess_rgb(shape)\n\n\ndef test_guess_multiscale():\n    data = np.random.random((10, 15))\n    assert not guess_multiscale(data)[0]\n\n    data = np.random.random((10, 15, 6))\n    assert not guess_multiscale(data)[0]\n\n    data = [np.random.random((10, 15, 6))]\n    assert not guess_multiscale(data)[0]\n\n    data = [np.random.random((10, 15, 6)), np.random.random((5, 7, 3))]\n    assert guess_multiscale(data)[0]\n\n    data = [np.random.random((10, 15, 6)), np.random.random((10, 7, 3))]\n    assert guess_multiscale(data)[0]\n\n    data = tuple(data)\n    assert guess_multiscale(data)[0]\n\n    data = tuple(\n        pyramid_gaussian(np.random.random((10, 15)), multichannel=False)\n    )\n    assert guess_multiscale(data)[0]\n\n    data = np.asarray(\n        tuple(pyramid_gaussian(np.random.random((10, 15)), multichannel=False))\n    )\n    assert guess_multiscale(data)[0]\n\n    # Check for integer overflow with big data\n    s = 8192\n    data = [da.ones((s,) * 3), da.ones((s // 2,) * 3), da.ones((s // 4,) * 3)]\n    assert guess_multiscale(data)[0]\n\n\ndef test_guess_multiscale_strip_single_scale():\n    data = [np.empty((10, 10))]\n    guess, data_out = guess_multiscale(data)\n    assert data_out is data[0]\n    assert guess is False\n\n\ndef test_guess_multiscale_non_array_list():\n    """"""Check that non-decreasing list input raises ValueError""""""\n    data = [np.empty((10, 15, 6)),] * 2  # noqa: E231\n    with pytest.raises(ValueError):\n        _, _ = guess_multiscale(data)\n\n\ndef test_guess_multiscale_incorrect_order():\n    data = [np.empty((10, 15)), np.empty((5, 6)), np.empty((20, 15))]\n    with pytest.raises(ValueError):\n        _, _ = guess_multiscale(data)\n\n\n@pytest.mark.timeout(2)\ndef test_timing_multiscale_big():\n    assert not guess_multiscale(data_dask)[0]\n'"
napari/layers/image/_tests/test_multiscale.py,53,"b'import numpy as np\nfrom skimage.transform import pyramid_gaussian\nfrom vispy.color import Colormap\nfrom napari.layers import Image\n\n\ndef test_random_multiscale():\n    """"""Test instantiating Image layer with random 2D multiscale data.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_infer_multiscale():\n    """"""Test instantiating Image layer with random 2D multiscale data.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_infer_tuple_multiscale():\n    """"""Test instantiating Image layer with random 2D multiscale data.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = tuple(np.random.random(s) for s in shapes)\n    layer = Image(data)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_blocking_multiscale():\n    """"""Test instantiating Image layer blocking 2D multiscale data.""""""\n    shape = (40, 20)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data, multiscale=False)\n    assert np.all(layer.data == data)\n    assert layer.multiscale is False\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_multiscale_tuple():\n    """"""Test instantiating Image layer multiscale tuple.""""""\n    shape = (40, 20)\n    np.random.seed(0)\n    img = np.random.random(shape)\n    data = tuple(pyramid_gaussian(img, multichannel=False))\n    layer = Image(data)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_3D_multiscale():\n    """"""Test instantiating Image layer with 3D data.""""""\n    shapes = [(8, 40, 20), (4, 20, 10), (2, 10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.data == data\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_non_uniform_3D_multiscale():\n    """"""Test instantiating Image layer non-uniform 3D data.""""""\n    shapes = [(8, 40, 20), (8, 20, 10), (8, 10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.data == data\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_rgb_multiscale():\n    """"""Test instantiating Image layer with RGB data.""""""\n    shapes = [(40, 20, 3), (20, 10, 3), (10, 5, 3)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.data == data\n    assert layer.ndim == len(shapes[0]) - 1\n    assert layer.shape == shapes[0][:-1]\n    assert layer.rgb is True\n    assert layer._data_view.ndim == 3\n\n\ndef test_3D_rgb_multiscale():\n    """"""Test instantiating Image layer with 3D RGB data.""""""\n    shapes = [(8, 40, 20, 3), (4, 20, 10, 3), (2, 10, 5, 3)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.data == data\n    assert layer.ndim == len(shapes[0]) - 1\n    assert layer.shape == shapes[0][:-1]\n    assert layer.rgb is True\n    assert layer._data_view.ndim == 3\n\n\ndef test_non_rgb_image():\n    """"""Test forcing Image layer to be 3D and not rgb.""""""\n    shapes = [(40, 20, 3), (20, 10, 3), (10, 5, 3)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True, rgb=False)\n    assert layer.data == data\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.name == \'Image\'\n\n    layer = Image(data, multiscale=True, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'img\'\n    assert layer.name == \'img\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Image(data, multiscale=True, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting layer opacity.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.opacity == 1.0\n\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    layer = Image(data, multiscale=True, opacity=0.6)\n    assert layer.opacity == 0.6\n\n    layer.opacity = 0.3\n    assert layer.opacity == 0.3\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Image(data, multiscale=True, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\ndef test_interpolation():\n    """"""Test setting image interpolation mode.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.interpolation == \'nearest\'\n\n    layer = Image(data, multiscale=True, interpolation=\'bicubic\')\n    assert layer.interpolation == \'bicubic\'\n\n    layer.interpolation = \'bilinear\'\n    assert layer.interpolation == \'bilinear\'\n\n\ndef test_colormaps():\n    """"""Test setting test_colormaps.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.colormap[0] == \'gray\'\n    assert type(layer.colormap[1]) == Colormap\n\n    layer.colormap = \'magma\'\n    assert layer.colormap[0] == \'magma\'\n    assert type(layer.colormap[1]) == Colormap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.3, 0.7, 0.2, 1.0]])\n    layer.colormap = \'custom\', cmap\n    assert layer.colormap[0] == \'custom\'\n    assert layer.colormap[1] == cmap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.7, 0.2, 0.6, 1.0]])\n    layer.colormap = {\'new\': cmap}\n    assert layer.colormap[0] == \'new\'\n    assert layer.colormap[1] == cmap\n\n    layer = Image(data, multiscale=True, colormap=\'magma\')\n    assert layer.colormap[0] == \'magma\'\n    assert type(layer.colormap[1]) == Colormap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.3, 0.7, 0.2, 1.0]])\n    layer = Image(data, multiscale=True, colormap=(\'custom\', cmap))\n    assert layer.colormap[0] == \'custom\'\n    assert layer.colormap[1] == cmap\n\n    cmap = Colormap([[0.0, 0.0, 0.0, 0.0], [0.7, 0.2, 0.6, 1.0]])\n    layer = Image(data, multiscale=True, colormap={\'new\': cmap})\n    assert layer.colormap[0] == \'new\'\n    assert layer.colormap[1] == cmap\n\n\ndef test_contrast_limits():\n    """"""Test setting color limits.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.contrast_limits[0] >= 0\n    assert layer.contrast_limits[1] <= 1\n    assert layer.contrast_limits[0] < layer.contrast_limits[1]\n    assert layer.contrast_limits == layer._contrast_limits_range\n\n    # Change contrast_limits property\n    contrast_limits = [0, 2]\n    layer.contrast_limits = contrast_limits\n    assert layer.contrast_limits == contrast_limits\n    assert layer._contrast_limits_range == contrast_limits\n\n    # Set contrast_limits as keyword argument\n    layer = Image(data, multiscale=True, contrast_limits=contrast_limits)\n    assert layer.contrast_limits == contrast_limits\n    assert layer._contrast_limits_range == contrast_limits\n\n\ndef test_contrast_limits_range():\n    """"""Test setting color limits range.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer._contrast_limits_range[0] >= 0\n    assert layer._contrast_limits_range[1] <= 1\n    assert layer._contrast_limits_range[0] < layer._contrast_limits_range[1]\n\n    # If all data is the same value the contrast_limits_range and\n    # contrast_limits defaults to [0, 1]\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    data = [np.zeros(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer._contrast_limits_range == [0, 1]\n    assert layer.contrast_limits == [0.0, 1.0]\n\n\ndef test_metadata():\n    """"""Test setting image metadata.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    assert layer.metadata == {}\n\n    layer = Image(data, multiscale=True, metadata={\'unit\': \'cm\'})\n    assert layer.metadata == {\'unit\': \'cm\'}\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert layer.data_level == 2\n    np.testing.assert_allclose(value, (2, data[2][0, 0]))\n\n\ndef test_corner_value():\n    """"""Test getting the value of the data at the new position.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    value = layer.get_value()\n    target_position = (39, 19)\n    target_level = 0\n    layer.data_level = target_level\n    layer.corner_pixels[1] = shapes[target_level]  # update requested view\n    layer.refresh()\n\n    # Test position at corner of image\n    layer.position = target_position\n    value = layer.get_value()\n    np.testing.assert_allclose(\n        value, (target_level, data[target_level][target_position])\n    )\n\n    # Test position at outside image\n    layer.position = (40, 20)\n    value = layer.get_value()\n    assert value[1] is None\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    msg = layer.get_message()\n    assert type(msg) == str\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    shapes = [(40, 40), (20, 20), (10, 10)]\n    np.random.seed(0)\n    data = [np.random.random(s) for s in shapes]\n    layer = Image(data, multiscale=True)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_not_create_random_multiscale():\n    """"""Test instantiating Image layer with random 2D data.""""""\n    shape = (20_000, 20)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.multiscale is False\n'"
napari/layers/image/_tests/test_volume.py,30,"b'import numpy as np\nfrom napari.layers import Image\n\n\ndef test_random_volume():\n    """"""Test instantiating Image layer with random 3D data.""""""\n    shape = (10, 15, 20)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_switching_displayed_dimensions():\n    """"""Test instantiating data then switching to displayed.""""""\n    shape = (10, 15, 20)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n\n    # check displayed data is initially 2D\n    assert layer._data_view.shape == shape[-2:]\n\n    layer.dims.ndisplay = 3\n    # check displayed data is now 3D\n    assert layer._data_view.shape == shape[-3:]\n\n    layer.dims.ndisplay = 2\n    # check displayed data is now 2D\n    assert layer._data_view.shape == shape[-2:]\n\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n\n    # check displayed data is initially 3D\n    assert layer._data_view.shape == shape[-3:]\n\n    layer.dims.ndisplay = 2\n    # check displayed data is now 2D\n    assert layer._data_view.shape == shape[-2:]\n\n    layer.dims.ndisplay = 3\n    # check displayed data is now 3D\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_all_zeros_volume():\n    """"""Test instantiating Image layer with all zeros data.""""""\n    shape = (10, 15, 20)\n    data = np.zeros(shape, dtype=float)\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_integer_volume():\n    """"""Test instantiating Image layer with integer data.""""""\n    shape = (10, 15, 20)\n    np.random.seed(0)\n    data = np.round(10 * np.random.random(shape)).astype(int)\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_3D_volume():\n    """"""Test instantiating Image layer with random 3D data.""""""\n    shape = (10, 15, 6)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_4D_volume():\n    """"""Test instantiating multiple Image layers with random 4D data.""""""\n    shape = (10, 15, 6, 8)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_changing_volume():\n    """"""Test changing Image data.""""""\n    shape_a = (10, 15, 30)\n    shape_b = (20, 12, 6)\n    np.random.seed(0)\n    data_a = np.random.random(shape_a)\n    data_b = np.random.random(shape_b)\n    layer = Image(data_a)\n    layer.dims.ndisplay = 3\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == len(shape_b)\n    assert layer.shape == shape_b\n    assert layer.dims.range == [(0, m, 1) for m in shape_b]\n    assert layer._data_view.shape == shape_b[-3:]\n\n\ndef test_scale():\n    """"""Test instantiating anisotropic 3D volume.""""""\n    shape = (10, 15, 20)\n    scale = [3, 1, 1]\n    full_shape = tuple(np.multiply(shape, scale))\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Image(data, scale=scale)\n    layer.dims.ndisplay = 3\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == full_shape\n    # Note that the scale appears as the step size in the range\n    assert layer.dims.range == list(\n        (0, m, s) for m, s in zip(full_shape, scale)\n    )\n    assert layer._data_view.shape == shape[-3:]\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15, 20))\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0, 0)\n    assert value == data[0, 0, 0]\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 15, 20))\n    layer = Image(data)\n    layer.dims.ndisplay = 3\n    msg = layer.get_message()\n    assert type(msg) == str\n'"
napari/layers/labels/_tests/test_labels.py,73,"b'import numpy as np\nfrom vispy.color import Colormap\nfrom napari.layers import Labels\n\n\ndef test_random_labels():\n    """"""Test instantiating Labels layer with random 2D data.""""""\n    shape = (10, 15)\n    np.random.seed(0)\n    data = np.random.randint(20, size=shape)\n    layer = Labels(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer.dims.range == [(0, m, 1) for m in shape]\n    assert layer._data_view.shape == shape[-2:]\n    assert layer.editable is True\n\n\ndef test_all_zeros_labels():\n    """"""Test instantiating Labels layer with all zeros data.""""""\n    shape = (10, 15)\n    data = np.zeros(shape, dtype=int)\n    layer = Labels(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-2:]\n\n\ndef test_3D_labels():\n    """"""Test instantiating Labels layer with random 3D data.""""""\n    shape = (6, 10, 15)\n    np.random.seed(0)\n    data = np.random.randint(20, size=shape)\n    layer = Labels(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == len(shape)\n    assert layer.shape == shape\n    assert layer._data_view.shape == shape[-2:]\n    assert layer.editable is True\n\n    layer.dims.ndisplay = 3\n    assert layer.dims.ndisplay == 3\n    assert layer.editable is False\n    assert layer.mode == \'pan_zoom\'\n\n\ndef test_changing_labels():\n    """"""Test changing Labels data.""""""\n    shape_a = (10, 15)\n    shape_b = (20, 12)\n    np.random.seed(0)\n    data_a = np.random.randint(20, size=shape_a)\n    data_b = np.random.randint(20, size=shape_b)\n    layer = Labels(data_a)\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == len(shape_b)\n    assert layer.shape == shape_b\n    assert layer.dims.range == [(0, m, 1) for m in shape_b]\n    assert layer._data_view.shape == shape_b[-2:]\n\n\ndef test_changing_labels_dims():\n    """"""Test changing Labels data including dimensionality.""""""\n    shape_a = (10, 15)\n    shape_b = (20, 12, 6)\n    np.random.seed(0)\n    data_a = np.random.randint(20, size=shape_a)\n    data_b = np.random.randint(20, size=shape_b)\n    layer = Labels(data_a)\n\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == len(shape_b)\n    assert layer.shape == shape_b\n    assert layer.dims.range == [(0, m, 1) for m in shape_b]\n    assert layer._data_view.shape == shape_b[-2:]\n\n\ndef test_changing_modes():\n    """"""Test changing modes.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n    layer.mode = \'fill\'\n    assert layer.mode == \'fill\'\n    assert layer.interactive is False\n\n    layer.mode = \'paint\'\n    assert layer.mode == \'paint\'\n    assert layer.interactive is False\n\n    layer.mode = \'pick\'\n    assert layer.mode == \'pick\'\n    assert layer.interactive is False\n\n    layer.mode = \'pan_zoom\'\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n    layer.mode = \'paint\'\n    assert layer.mode == \'paint\'\n    layer.editable = False\n    assert layer.mode == \'pan_zoom\'\n    assert layer.editable is False\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.name == \'Labels\'\n\n    layer = Labels(data, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'lbls\'\n    assert layer.name == \'lbls\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Labels(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting layer opacity.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.opacity == 0.7\n\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    layer = Labels(data, opacity=0.6)\n    assert layer.opacity == 0.6\n\n    layer.opacity = 0.3\n    assert layer.opacity == 0.3\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Labels(data, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\ndef test_seed():\n    """"""Test setting seed.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.seed == 0.5\n\n    layer.seed = 0.9\n    assert layer.seed == 0.9\n\n    layer = Labels(data, seed=0.7)\n    assert layer.seed == 0.7\n\n\ndef test_num_colors():\n    """"""Test setting number of colors in colormap.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.num_colors == 50\n\n    layer.num_colors = 80\n    assert layer.num_colors == 80\n\n    layer = Labels(data, num_colors=60)\n    assert layer.num_colors == 60\n\n\ndef test_properties():\n    """"""Test adding labels with properties.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n\n    layer = Labels(data)\n    assert isinstance(layer.properties, dict)\n    assert len(layer.properties) == 0\n\n    properties = {\'class\': [\'Background\'] + [f\'Class {i}\' for i in range(20)]}\n    label_index = {i: i for i in range(len(properties[\'class\']))}\n    layer = Labels(data, properties=properties)\n    assert isinstance(layer.properties, dict)\n    assert layer.properties == properties\n    assert layer._label_index == label_index\n\n    current_label = layer.get_value()\n    layer_message = layer.get_message()\n    assert layer_message.endswith(f\'Class {current_label - 1}\')\n\n    properties = {\'class\': [\'Background\']}\n    layer = Labels(data, properties=properties)\n    layer_message = layer.get_message()\n    assert layer_message.endswith(""[No Properties]"")\n\n    properties = {\'class\': [\'Background\', \'Class 12\'], \'index\': [0, 12]}\n    label_index = {0: 0, 12: 1}\n    layer = Labels(data, properties=properties)\n    layer_message = layer.get_message()\n    assert layer._label_index == label_index\n    assert layer_message.endswith(\'Class 12\')\n\n\ndef test_colormap():\n    """"""Test colormap.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert type(layer.colormap) == tuple\n    assert layer.colormap[0] == \'random\'\n    assert type(layer.colormap[1]) == Colormap\n\n    layer.new_colormap()\n    assert type(layer.colormap) == tuple\n    assert layer.colormap[0] == \'random\'\n    assert type(layer.colormap[1]) == Colormap\n\n\ndef test_metadata():\n    """"""Test setting labels metadata.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.metadata == {}\n\n    layer = Labels(data, metadata={\'unit\': \'cm\'})\n    assert layer.metadata == {\'unit\': \'cm\'}\n\n\ndef test_brush_size():\n    """"""Test changing brush size.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.brush_size == 10\n\n    layer.brush_size = 20\n    assert layer.brush_size == 20\n\n\ndef test_contiguous():\n    """"""Test changing contiguous.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.contiguous is True\n\n    layer.contiguous = False\n    assert layer.contiguous is False\n\n\ndef test_n_dimensional():\n    """"""Test changing n_dimensional.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.n_dimensional is False\n\n    layer.n_dimensional = True\n    assert layer.n_dimensional is True\n\n\ndef test_selecting_label():\n    """"""Test selecting label.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    assert layer.selected_label == 1\n    assert (layer._selected_color == layer.get_color(1)).all\n\n    layer.selected_label = 1\n    assert layer.selected_label == 1\n    assert len(layer._selected_color) == 4\n\n\ndef test_label_color():\n    """"""Test getting label color.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    col = layer.get_color(0)\n    assert col is None\n\n    col = layer.get_color(1)\n    assert len(col) == 4\n\n\ndef test_paint():\n    """"""Test painting labels with different brush sizes.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    data[:10, :10] = 1\n    layer = Labels(data)\n    assert np.unique(layer.data[:5, :5]) == 1\n    assert np.unique(layer.data[5:10, 5:10]) == 1\n\n    layer.brush_size = 9\n    layer.paint([0, 0], 2)\n    assert np.unique(layer.data[:5, :5]) == 2\n    assert np.unique(layer.data[5:10, 5:10]) == 1\n\n    layer.brush_size = 10\n    layer.paint([0, 0], 2)\n    assert np.unique(layer.data[:6, :6]) == 2\n    assert np.unique(layer.data[6:10, 6:10]) == 1\n\n    layer.brush_size = 19\n    layer.paint([0, 0], 2)\n    assert np.unique(layer.data[:5, :5]) == 2\n    assert np.unique(layer.data[5:10, 5:10]) == 2\n\n\ndef test_paint_with_preserve_labels():\n    """"""Test painting labels while preserving existing labels""""""\n    data = np.zeros((15, 10))\n    data[:3, :3] = 1\n    layer = Labels(data)\n    layer.preserve_labels = True\n    assert np.unique(layer.data[:3, :3]) == 1\n\n    layer.brush_size = 9\n    layer.paint([0, 0], 2)\n\n    assert np.unique(layer.data[3:5, 0:5]) == 2\n    assert np.unique(layer.data[0:5, 3:5]) == 2\n    assert np.unique(layer.data[:3, :3]) == 1\n\n\ndef test_fill():\n    """"""Test filling labels with different brush sizes.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    data[:10, :10] = 2\n    data[:5, :5] = 1\n    layer = Labels(data)\n    assert np.unique(layer.data[:5, :5]) == 1\n    assert np.unique(layer.data[5:10, 5:10]) == 2\n\n    layer.fill([0, 0], 3)\n    assert np.unique(layer.data[:5, :5]) == 3\n    assert np.unique(layer.data[5:10, 5:10]) == 2\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert value == data[0, 0]\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 15))\n    layer = Labels(data)\n    msg = layer.get_message()\n    assert type(msg) == str\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    np.random.seed(0)\n    data = np.random.randint(20, size=(30, 30))\n    layer = Labels(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n'"
napari/layers/labels/_tests/test_labels_mouse_bindings.py,60,"b'import pytest\nimport numpy as np\nimport collections\nfrom napari.layers import Labels\nfrom napari.utils.interactions import (\n    ReadOnlyWrapper,\n    mouse_press_callbacks,\n    mouse_move_callbacks,\n    mouse_release_callbacks,\n)\n\n\n@pytest.fixture\ndef Event():\n    """"""Create a subclass for simulating vispy mouse events.\n\n    Returns\n    -------\n    Event : Type\n        A new tuple subclass named Event that can be used to create a\n        NamedTuple object with fields ""type"" and ""is_dragging"".\n    """"""\n    return collections.namedtuple(\'Event\', field_names=[\'type\', \'is_dragging\'])\n\n\ndef test_paint(Event):\n    """"""Test painting labels with different brush sizes.""""""\n    data = np.ones((20, 20))\n    layer = Labels(data)\n    layer.brush_size = 10\n    layer.mode = \'paint\'\n    layer.selected_label = 3\n    layer.position = (0, 0)\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n\n    layer.position = (19, 19)\n\n    # Simulate drag\n    event = ReadOnlyWrapper(Event(type=\'mouse_move\', is_dragging=True))\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(Event(type=\'mouse_release\', is_dragging=False))\n    mouse_release_callbacks(layer, event)\n\n    # Painting goes from (0, 0) to (19, 19) with a brush size of 10, changing\n    # all pixels along that path, but non outside it.\n    assert np.unique(layer.data[:5, :5]) == 3\n    assert np.unique(layer.data[-5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5]) == 1\n\n\ndef test_erase(Event):\n    """"""Test erasing labels with different brush sizes.""""""\n    data = np.ones((20, 20))\n    layer = Labels(data)\n    layer.brush_size = 10\n    layer.mode = \'erase\'\n    layer.selected_label = 3\n    layer.position = (0, 0)\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n\n    layer.position = (19, 19)\n\n    # Simulate drag\n    event = ReadOnlyWrapper(Event(type=\'mouse_move\', is_dragging=True))\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(Event(type=\'mouse_release\', is_dragging=False))\n    mouse_release_callbacks(layer, event)\n\n    # Painting goes from (0, 0) to (19, 19) with a brush size of 10, changing\n    # all pixels along that path, but non outside it.\n    assert np.unique(layer.data[:5, :5]) == 0\n    assert np.unique(layer.data[-5:, -5:]) == 0\n    assert np.unique(layer.data[:5, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5]) == 1\n\n\ndef test_pick(Event):\n    """"""Test picking label.""""""\n    data = np.ones((20, 20))\n    data[:5, :5] = 2\n    data[-5:, -5:] = 3\n    layer = Labels(data)\n    assert layer.selected_label == 1\n\n    layer.mode = \'pick\'\n    layer.position = (0, 0)\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert layer.selected_label == 2\n\n    layer.position = (19, 19)\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert layer.selected_label == 3\n\n\ndef test_fill(Event):\n    """"""Test filling label.""""""\n    data = np.ones((20, 20))\n    data[:5, :5] = 2\n    data[-5:, -5:] = 3\n    layer = Labels(data)\n    assert np.unique(layer.data[:5, :5]) == 2\n    assert np.unique(layer.data[-5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5]) == 1\n\n    layer.mode = \'fill\'\n    layer.position = (0, 0)\n    layer.selected_label = 4\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[:5, :5]) == 4\n    assert np.unique(layer.data[-5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5]) == 1\n\n    layer.position = (19, 19)\n    layer.selected_label = 5\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[:5, :5]) == 4\n    assert np.unique(layer.data[-5:, -5:]) == 5\n    assert np.unique(layer.data[:5, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5]) == 1\n\n\ndef test_fill_nD_plane(Event):\n    """"""Test filling label nD plane.""""""\n    data = np.ones((20, 20, 20))\n    data[:5, :5, :5] = 2\n    data[0, 8:10, 8:10] = 2\n    data[-5:, -5:, -5:] = 3\n    layer = Labels(data)\n    assert np.unique(layer.data[:5, :5, :5]) == 2\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5, -5:]) == 1\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n\n    layer.mode = \'fill\'\n    layer.position = (0, 0)\n    layer.selected_label = 4\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[0, :5, :5]) == 4\n    assert np.unique(layer.data[1:5, :5, :5]) == 2\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5, -5:]) == 1\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n\n    layer.position = (19, 19)\n    layer.selected_label = 5\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[0, :5, :5]) == 4\n    assert np.unique(layer.data[1:5, :5, :5]) == 2\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[1:5, -5:, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5, -5:]) == 1\n    assert np.unique(layer.data[0, -5:, -5:]) == 5\n    assert np.unique(layer.data[0, :5, -5:]) == 5\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n\n\ndef test_fill_nD_all(Event):\n    """"""Test filling label nD.""""""\n    data = np.ones((20, 20, 20))\n    data[:5, :5, :5] = 2\n    data[0, 8:10, 8:10] = 2\n    data[-5:, -5:, -5:] = 3\n    layer = Labels(data)\n    assert np.unique(layer.data[:5, :5, :5]) == 2\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5, -5:]) == 1\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n\n    layer.n_dimensional = True\n    layer.mode = \'fill\'\n    layer.position = (0, 0)\n    layer.selected_label = 4\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[:5, :5, :5]) == 4\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:, -5:]) == 1\n    assert np.unique(layer.data[-5:, :5, -5:]) == 1\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n\n    layer.position = (19, 19)\n    layer.selected_label = 5\n\n    # Simulate click\n    event = ReadOnlyWrapper(Event(type=\'mouse_press\', is_dragging=False))\n    mouse_press_callbacks(layer, event)\n    assert np.unique(layer.data[:5, :5, :5]) == 4\n    assert np.unique(layer.data[-5:, -5:, -5:]) == 3\n    assert np.unique(layer.data[:5, -5:, -5:]) == 5\n    assert np.unique(layer.data[-5:, :5, -5:]) == 5\n    assert np.unique(layer.data[0, 8:10, 8:10]) == 2\n'"
napari/layers/labels/_tests/test_labels_pyramid.py,6,"b'import numpy as np\nfrom napari.layers import Labels\n\n\ndef test_random_multiscale():\n    """"""Test instantiating Labels layer with random 2D multiscale data.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.randint(20, size=s) for s in shapes]\n    layer = Labels(data, multiscale=True)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.editable is False\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_infer_multiscale():\n    """"""Test instantiating Labels layer with random 2D multiscale data.""""""\n    shapes = [(40, 20), (20, 10), (10, 5)]\n    np.random.seed(0)\n    data = [np.random.randint(20, size=s) for s in shapes]\n    layer = Labels(data)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.editable is False\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n\n\ndef test_3D_multiscale():\n    """"""Test instantiating Labels layer with 3D data.""""""\n    shapes = [(8, 40, 20), (4, 20, 10), (2, 10, 5)]\n    np.random.seed(0)\n    data = [np.random.randint(20, size=s) for s in shapes]\n    layer = Labels(data, multiscale=True)\n    assert layer.data == data\n    assert layer.multiscale is True\n    assert layer.editable is False\n    assert layer.ndim == len(shapes[0])\n    assert layer.shape == shapes[0]\n    assert layer.rgb is False\n    assert layer._data_view.ndim == 2\n'"
napari/layers/labels/_tests/test_labels_utils.py,4,"b'import numpy as np\n\nfrom napari.layers.labels._labels_utils import interpolate_coordinates\n\n\ndef test_interpolate_coordinates():\n    # test when number of interpolated points > 1\n    old_coord = np.array([0, 1])\n    new_coord = np.array([0, 10])\n    coords = interpolate_coordinates(old_coord, new_coord, brush_size=3)\n    expected_coords = np.array(\n        [\n            [0, 1.75],\n            [0, 2.5],\n            [0, 3.25],\n            [0, 4],\n            [0, 4.75],\n            [0, 5.5],\n            [0, 6.25],\n            [0, 7],\n            [0, 7.75],\n            [0, 8.5],\n            [0, 9.25],\n            [0, 10],\n        ]\n    )\n    assert np.all(coords == expected_coords)\n'"
napari/layers/points/_tests/test_points.py,238,"b'from copy import copy\nfrom itertools import cycle, islice\nimport numpy as np\nimport pandas as pd\nimport pytest\nfrom vispy.color import get_colormap\n\nfrom napari.layers import Points\nfrom napari.layers.points._points_utils import points_to_squares\nfrom napari.utils.colormaps.standardize_color import transform_color\n\n\ndef _make_cycled_properties(values, length):\n    """"""Helper function to make property values\n\n    Parameters:\n    -----------\n    values :\n        The values to be cycled.\n    length : int\n        The length of the resulting property array\n\n    Returns:\n    --------\n    cycled_properties : np.ndarray\n        The property array comprising the cycled values.\n    """"""\n    cycled_properties = np.array(list(islice(cycle(values), 0, length)))\n    return cycled_properties\n\n\ndef test_empty_points():\n    pts = Points()\n    assert pts.data.shape == (0, 2)\n\n\ndef test_empty_points_with_properties():\n    """""" Test instantiating an empty Points layer with properties\n\n    See: https://github.com/napari/napari/pull/1069\n    """"""\n    properties = {\n        \'label\': np.array([\'label1\', \'label2\']),\n        \'cont_prop\': np.array([0], dtype=np.float),\n    }\n    pts = Points(properties=properties)\n    current_props = {k: v[0] for k, v in properties.items()}\n    np.testing.assert_equal(pts.current_properties, current_props)\n\n    # verify the property datatype is correct\n    assert pts.properties[\'cont_prop\'].dtype == np.float\n\n    # add two points and verify the default property was applied\n    pts.add([10, 10])\n    pts.add([20, 20])\n    props = {\n        \'label\': np.array([\'label1\', \'label1\']),\n        \'cont_prop\': np.array([0, 0], dtype=np.float),\n    }\n    np.testing.assert_equal(pts.properties, props)\n\n\ndef test_empty_points_with_properties_list():\n    """""" Test instantiating an empty Points layer with properties\n    stored in a list\n\n    See: https://github.com/napari/napari/pull/1069\n    """"""\n    properties = {\'label\': [\'label1\', \'label2\'], \'cont_prop\': [0]}\n    pts = Points(properties=properties)\n    current_props = {k: np.asarray(v[0]) for k, v in properties.items()}\n    np.testing.assert_equal(pts.current_properties, current_props)\n\n    # add two points and verify the default property was applied\n    pts.add([10, 10])\n    pts.add([20, 20])\n    props = {\n        \'label\': np.array([\'label1\', \'label1\']),\n        \'cont_prop\': np.array([0, 0], dtype=np.float),\n    }\n    np.testing.assert_equal(pts.properties, props)\n\n\ndef test_empty_layer_with_face_colorap():\n    """""" Test creating an empty layer where the face color is a colormap\n    See: https://github.com/napari/napari/pull/1069\n    """"""\n    default_properties = {\'point_type\': np.array([1.5], dtype=np.float)}\n    layer = Points(\n        properties=default_properties,\n        face_color=\'point_type\',\n        face_colormap=\'grays\',\n    )\n\n    assert layer.face_color_mode == \'colormap\'\n\n    # verify the current_face_color is correct\n    face_color = np.array([1, 1, 1, 1])\n    assert np.all(layer._current_face_color == face_color)\n\n\ndef test_empty_layer_with_edge_colormap():\n    """""" Test creating an empty layer where the face color is a colormap\n    See: https://github.com/napari/napari/pull/1069\n    """"""\n    default_properties = {\'point_type\': np.array([1.5], dtype=np.float)}\n    layer = Points(\n        properties=default_properties,\n        edge_color=\'point_type\',\n        edge_colormap=\'grays\',\n    )\n\n    assert layer.edge_color_mode == \'colormap\'\n\n    # verify the current_face_color is correct\n    edge_color = np.array([1, 1, 1, 1])\n    assert np.all(layer._current_edge_color == edge_color)\n\n\ndef test_random_points():\n    """"""Test instantiating Points layer with random 2D data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 10\n    assert len(layer.selected_data) == 0\n\n\ndef test_integer_points():\n    """"""Test instantiating Points layer with integer data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = np.random.randint(20, size=(10, 2))\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 10\n\n\ndef test_negative_points():\n    """"""Test instantiating Points layer with negative data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape) - 10\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 10\n\n\ndef test_empty_points_array():\n    """"""Test instantiating Points layer with empty array.""""""\n    shape = (0, 2)\n    data = np.empty(shape)\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 0\n\n\ndef test_3D_points():\n    """"""Test instantiating Points layer with random 3D data.""""""\n    shape = (10, 3)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 10\n\n\ndef test_4D_points():\n    """"""Test instantiating Points layer with random 4D data.""""""\n    shape = (10, 4)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert np.all(layer.data == data)\n    assert layer.ndim == shape[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 10\n\n\ndef test_changing_points():\n    """"""Test changing Points data.""""""\n    shape_a = (10, 2)\n    shape_b = (20, 2)\n    np.random.seed(0)\n    data_a = 20 * np.random.random(shape_a)\n    data_b = 20 * np.random.random(shape_b)\n    layer = Points(data_a)\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.ndim == shape_b[1]\n    assert layer._view_data.ndim == 2\n    assert len(layer.data) == 20\n\n\ndef test_selecting_points():\n    """"""Test selecting points.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    layer.mode = \'select\'\n    data_to_select = {1, 2}\n    layer.selected_data = data_to_select\n    assert layer.selected_data == data_to_select\n\n    # test switching to 3D\n    layer.dims.ndisplay = 3\n    assert layer.selected_data == data_to_select\n\n    # select different points while in 3D mode\n    other_data_to_select = {0}\n    layer.selected_data = other_data_to_select\n    assert layer.selected_data == other_data_to_select\n\n    # selection should persist when going back to 2D mode\n    layer.dims.ndisplay = 2\n    assert layer.selected_data == other_data_to_select\n\n    # selection should persist when switching between between select and pan_zoom\n    layer.mode = \'pan_zoom\'\n    assert layer.selected_data == other_data_to_select\n    layer.mode = \'select\'\n    assert layer.selected_data == other_data_to_select\n\n    # add mode should clear the selection\n    layer.mode = \'add\'\n    assert layer.selected_data == set()\n\n\ndef test_adding_points():\n    """"""Test adding Points data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert len(layer.data) == 10\n\n    coord = [20, 20]\n    layer.add(coord)\n    assert len(layer.data) == 11\n    assert np.all(layer.data[10] == coord)\n    # the added point should be selected\n    assert layer.selected_data == {10}\n\n    # test adding multiple points\n    coords = [[10, 10], [15, 15]]\n    layer.add(coords)\n    assert len(layer.data) == 13\n    assert np.all(layer.data[11:, :] == coords)\n\n    # test that the last added points can be deleted\n    layer.remove_selected()\n    np.testing.assert_equal(layer.data, np.vstack((data, coord)))\n\n\ndef test_adding_points_to_empty():\n    """"""Test adding Points data to empty.""""""\n    shape = (0, 2)\n    data = np.empty(shape)\n    layer = Points(data)\n    assert len(layer.data) == 0\n\n    coord = [20, 20]\n    layer.add(coord)\n    assert len(layer.data) == 1\n    assert np.all(layer.data[0] == coord)\n\n\ndef test_removing_selected_points():\n    """"""Test selecting points.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n\n    # With nothing selected no points should be removed\n    layer.remove_selected()\n    assert len(layer.data) == shape[0]\n\n    # Select two points and remove them\n    layer.selected_data = {0, 3}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 2\n    assert len(layer.selected_data) == 0\n    keep = [1, 2] + list(range(4, 10))\n    assert np.all(layer.data == data[keep])\n\n    # Select another point and remove it\n    layer.selected_data = {4}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 3\n\n\ndef test_move():\n    """"""Test moving points.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    unmoved = copy(data)\n    layer = Points(data)\n\n    # Move one point relative to an initial drag start location\n    layer._move([0], [0, 0])\n    layer._move([0], [10, 10])\n    layer._drag_start = None\n    assert np.all(layer.data[0] == unmoved[0] + [10, 10])\n    assert np.all(layer.data[1:] == unmoved[1:])\n\n    # Move two points relative to an initial drag start location\n    layer._move([1, 2], [2, 2])\n    layer._move([1, 2], np.add([2, 2], [-3, 4]))\n    assert np.all(layer.data[1:2] == unmoved[1:2] + [-3, 4])\n\n\ndef test_changing_modes():\n    """"""Test changing modes.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n    layer.mode = \'add\'\n    assert layer.mode == \'add\'\n    assert layer.interactive is False\n\n    layer.mode = \'select\'\n    assert layer.mode == \'select\'\n    assert layer.interactive is False\n\n    layer.mode = \'pan_zoom\'\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n    with pytest.raises(ValueError):\n        layer.mode = \'not_a_mode\'\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2))\n    layer = Points(data)\n    assert layer.name == \'Points\'\n\n    layer = Points(data, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'pts\'\n    assert layer.name == \'pts\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2))\n    layer = Points(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Points(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting layer opacity.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2))\n    layer = Points(data)\n    assert layer.opacity == 1.0\n\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    layer = Points(data, opacity=0.6)\n    assert layer.opacity == 0.6\n\n    layer.opacity = 0.3\n    assert layer.opacity == 0.3\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 2))\n    layer = Points(data)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Points(data, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\ndef test_symbol():\n    """"""Test setting symbol.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.symbol == \'disc\'\n\n    layer.symbol = \'cross\'\n    assert layer.symbol == \'cross\'\n\n    layer = Points(data, symbol=\'star\')\n    assert layer.symbol == \'star\'\n\n\nproperties_array = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], 10)}\nproperties_list = {\'point_type\': list(_make_cycled_properties([\'A\', \'B\'], 10))}\n\n\n@pytest.mark.parametrize(""properties"", [properties_array, properties_list])\ndef test_properties(properties):\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data, properties=copy(properties))\n    np.testing.assert_equal(layer.properties, properties)\n\n    current_prop = {\'point_type\': np.array([\'B\'])}\n    assert layer.current_properties == current_prop\n\n    # test removing points\n    layer.selected_data = {0, 1}\n    layer.remove_selected()\n    remove_properties = properties[\'point_type\'][2::]\n    assert len(layer.properties[\'point_type\']) == (shape[0] - 2)\n    assert np.all(layer.properties[\'point_type\'] == remove_properties)\n\n    # test selection of properties\n    layer.selected_data = {0}\n    selected_annotation = layer.current_properties[\'point_type\']\n    assert len(selected_annotation) == 1\n    assert selected_annotation[0] == \'A\'\n\n    # test adding points with properties\n    layer.add([10, 10])\n    add_annotations = np.concatenate((remove_properties, [\'A\']), axis=0)\n    assert np.all(layer.properties[\'point_type\'] == add_annotations)\n\n    # test copy/paste\n    layer.selected_data = {0, 1}\n    layer._copy_data()\n    assert np.all(layer._clipboard[\'properties\'][\'point_type\'] == [\'A\', \'B\'])\n\n    layer._paste_data()\n    paste_annotations = np.concatenate((add_annotations, [\'A\', \'B\']), axis=0)\n    assert np.all(layer.properties[\'point_type\'] == paste_annotations)\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_adding_properties(attribute):\n    """"""Test adding properties to an existing layer""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n\n    # add properties\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    layer.properties = properties\n    np.testing.assert_equal(layer.properties, properties)\n\n    # add properties as a dataframe\n    properties_df = pd.DataFrame(properties)\n    layer.properties = properties_df\n    np.testing.assert_equal(layer.properties, properties)\n\n    # add properties as a dictionary with list values\n    properties_list = {\n        \'point_type\': list(_make_cycled_properties([\'A\', \'B\'], shape[0]))\n    }\n    layer.properties = properties_list\n    assert isinstance(layer.properties[\'point_type\'], np.ndarray)\n\n    # removing a property that was the _*_color_property should give a warning\n    setattr(layer, f\'_{attribute}_color_property\', \'vector_type\')\n    properties_2 = {\n        \'not_vector_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])\n    }\n    with pytest.warns(RuntimeWarning):\n        layer.properties = properties_2\n\n\ndef test_properties_dataframe():\n    """"""Test if properties can be provided as a DataFrame""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    properties_df = pd.DataFrame(properties)\n    properties_df = properties_df.astype(properties[\'point_type\'].dtype)\n    layer = Points(data, properties=properties_df)\n    np.testing.assert_equal(layer.properties, properties)\n\n\ndef test_add_points_with_properties_as_list():\n    # test adding points initialized with properties as list\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\n        \'point_type\': list(_make_cycled_properties([\'A\', \'B\'], shape[0]))\n    }\n    layer = Points(data, properties=copy(properties))\n\n    coord = [18, 18]\n    layer.add(coord)\n    new_prop = {\'point_type\': np.append(properties[\'point_type\'], \'B\')}\n    np.testing.assert_equal(layer.properties, new_prop)\n\n\ndef test_updating_points_properties():\n    # test adding points initialized with properties\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    layer = Points(data, properties=copy(properties))\n\n    layer.mode = \'select\'\n    layer.selected_data = [len(data) - 1]\n    layer.current_properties = {\'point_type\': np.array([\'A\'])}\n\n    updated_properties = properties\n    updated_properties[\'point_type\'][-1] = \'A\'\n    np.testing.assert_equal(layer.properties, updated_properties)\n\n\ndef test_points_errors():\n    shape = (3, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n\n    # try adding properties with the wrong number of properties\n    with pytest.raises(ValueError):\n        annotations = {\'point_type\': np.array([\'A\', \'B\'])}\n        Points(data, properties=copy(annotations))\n\n\ndef test_is_color_mapped():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    annotations = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    layer = Points(data, properties=annotations)\n\n    # giving the name of an annotation should return True\n    assert layer._is_color_mapped(\'point_type\')\n\n    # giving a list should return false (i.e., could be an RGBA color)\n    assert not layer._is_color_mapped([1, 1, 1, 1])\n\n    # giving an ndarray should return false (i.e., could be an RGBA color)\n    assert not layer._is_color_mapped(np.array([1, 1, 1, 1]))\n\n    # give an invalid color argument\n    with pytest.raises(ValueError):\n        layer._is_color_mapped((123, 323))\n\n\ndef test_edge_width():\n    """"""Test setting edge width.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.edge_width == 1\n\n    layer.edge_width = 2\n    assert layer.edge_width == 2\n\n    layer = Points(data, edge_width=3)\n    assert layer.edge_width == 3\n\n\ndef test_n_dimensional():\n    """"""Test setting n_dimensional flag for 2D and 4D data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.n_dimensional is False\n\n    layer.n_dimensional = True\n    assert layer.n_dimensional is True\n\n    layer = Points(data, n_dimensional=True)\n    assert layer.n_dimensional is True\n\n    shape = (10, 4)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.n_dimensional is False\n\n    layer.n_dimensional = True\n    assert layer.n_dimensional is True\n\n    layer = Points(data, n_dimensional=True)\n    assert layer.n_dimensional is True\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_switch_color_mode(attribute):\n    """"""Test switching between color modes""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    # create a continuous property with a known value in the last element\n    continuous_prop = np.random.random((shape[0],))\n    continuous_prop[-1] = 1\n    properties = {\n        \'point_truthiness\': continuous_prop,\n        \'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0]),\n    }\n    initial_color = [1, 0, 0, 1]\n    color_cycle = [\'red\', \'blue\']\n    color_kwarg = f\'{attribute}_color\'\n    colormap_kwarg = f\'{attribute}_colormap\'\n    color_cycle_kwarg = f\'{attribute}_color_cycle\'\n    args = {\n        color_kwarg: initial_color,\n        colormap_kwarg: \'gray\',\n        color_cycle_kwarg: color_cycle,\n    }\n    layer = Points(data, properties=properties, **args)\n\n    layer_color_mode = getattr(layer, f\'{attribute}_color_mode\')\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert layer_color_mode == \'direct\'\n    np.testing.assert_allclose(\n        layer_color, np.repeat([initial_color], shape[0], axis=0)\n    )\n\n    # there should not be an edge_color_property\n    color_property = getattr(layer, f\'_{attribute}_color_property\')\n    assert color_property == \'\'\n\n    # transitioning to colormap should raise a warning\n    # because there isn\'t an edge color property yet and\n    # the first property in points.properties is being automatically selected\n    with pytest.warns(UserWarning):\n        setattr(layer, f\'{attribute}_color_mode\', \'colormap\')\n    color_property = getattr(layer, f\'_{attribute}_color_property\')\n    assert color_property == next(iter(properties))\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(layer_color[-1], [1, 1, 1, 1])\n\n    # switch to color cycle\n    setattr(layer, f\'{attribute}_color_mode\', \'cycle\')\n    setattr(layer, f\'{attribute}_color\', \'point_type\')\n    color = getattr(layer, f\'{attribute}_color\')\n    layer_color = transform_color(color_cycle * int((shape[0] / 2)))\n    np.testing.assert_allclose(color, layer_color)\n\n    # switch back to direct, edge_colors shouldn\'t change\n    setattr(layer, f\'{attribute}_color_mode\', \'direct\')\n    new_edge_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(new_edge_color, color)\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_colormap_without_properties(attribute):\n    """"""Setting the colormode to colormap should raise an exception""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n\n    with pytest.raises(ValueError):\n        setattr(layer, f\'{attribute}_color_mode\', \'colormap\')\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_colormap_with_categorical_properties(attribute):\n    """"""Setting the colormode to colormap should raise an exception""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    layer = Points(data, properties=properties)\n\n    with pytest.raises(TypeError):\n        setattr(layer, f\'{attribute}_color_mode\', \'colormap\')\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_add_colormap(attribute):\n    """"""Test  directly adding a vispy Colormap object""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    annotations = {\'point_type\': _make_cycled_properties([0, 1.5], shape[0])}\n    color_kwarg = f\'{attribute}_color\'\n    colormap_kwarg = f\'{attribute}_colormap\'\n    args = {color_kwarg: \'point_type\', colormap_kwarg: \'viridis\'}\n    layer = Points(data, properties=annotations, **args)\n\n    setattr(layer, f\'{attribute}_colormap\', get_colormap(\'gray\'))\n    layer_colormap = getattr(layer, f\'{attribute}_colormap\')\n    assert \'unnamed colormap\' in layer_colormap[0]\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_color_direct(attribute: str):\n    """"""Test setting colors directly""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer_kwargs = {f\'{attribute}_color\': \'black\'}\n    layer = Points(data, **layer_kwargs)\n    color_array = transform_color([\'black\'] * shape[0])\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert current_color == \'black\'\n    assert len(layer.edge_color) == shape[0]\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # With no data selected changing color has no effect\n    setattr(layer, f\'current_{attribute}_color\', \'blue\')\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    assert current_color == \'blue\'\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Select data and change edge color of selection\n    selected_data = {0, 1}\n    layer.selected_data = {0, 1}\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    assert current_color == \'black\'\n    setattr(layer, f\'current_{attribute}_color\', \'green\')\n    colorarray_green = transform_color([\'green\'] * len(layer.selected_data))\n    color_array[list(selected_data)] = colorarray_green\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Add new point and test its color\n    coord = [18, 18]\n    layer.selected_data = {}\n    setattr(layer, f\'current_{attribute}_color\', \'blue\')\n    layer.add(coord)\n    color_array = np.vstack([color_array, transform_color(\'blue\')])\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] + 1\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] - 1\n    np.testing.assert_allclose(\n        layer_color, np.vstack((color_array[1], color_array[3:])),\n    )\n\n\ncolor_cycle_str = [\'red\', \'blue\']\ncolor_cycle_rgb = [[1, 0, 0], [0, 0, 1]]\ncolor_cycle_rgba = [[1, 0, 0, 1], [0, 0, 1, 1]]\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\n@pytest.mark.parametrize(\n    ""color_cycle"", [color_cycle_str, color_cycle_rgb, color_cycle_rgba],\n)\ndef test_color_cycle(attribute, color_cycle):\n    """"""Test setting edge/face color with a color cycle list""""""\n    # create Points using list color cycle\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    points_kwargs = {\n        \'properties\': properties,\n        f\'{attribute}_color\': \'point_type\',\n        f\'{attribute}_color_cycle\': color_cycle,\n    }\n    layer = Points(data, **points_kwargs)\n\n    assert layer.properties == properties\n    color_array = transform_color(\n        list(islice(cycle(color_cycle), 0, shape[0]))\n    )\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(layer_color, color_array)\n\n    # Add new point and test its color\n    coord = [18, 18]\n    layer.selected_data = {0}\n    layer.add(coord)\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] + 1\n    np.testing.assert_allclose(\n        layer_color, np.vstack((color_array, transform_color(\'red\'))),\n    )\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] - 1\n    np.testing.assert_allclose(\n        layer_color,\n        np.vstack((color_array[1], color_array[3:], transform_color(\'red\'))),\n    )\n\n    # refresh colors\n    layer.refresh_colors(update_color_mapping=True)\n\n    # test adding a point with a new property value\n    layer.selected_data = {}\n    current_properties = layer.current_properties\n    current_properties[\'point_type\'] = np.array([\'new\'])\n    layer.current_properties = current_properties\n    layer.add([10, 10])\n    color_cycle_map = getattr(layer, f\'{attribute}_color_cycle_map\')\n\n    assert \'new\' in color_cycle_map\n    np.testing.assert_allclose(\n        color_cycle_map[\'new\'], np.squeeze(transform_color(color_cycle[0]))\n    )\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_add_color_cycle_to_empty_layer(attribute):\n    """""" Test adding a point to an empty layer when edge/face color is a color cycle\n\n    See: https://github.com/napari/napari/pull/1069\n    """"""\n    default_properties = {\'point_type\': np.array([\'A\'])}\n    color_cycle = [\'red\', \'blue\']\n    points_kwargs = {\n        \'properties\': default_properties,\n        f\'{attribute}_color\': \'point_type\',\n        f\'{attribute}_color_cycle\': color_cycle,\n    }\n    layer = Points(**points_kwargs)\n\n    # verify the current_edge_color is correct\n    expected_color = transform_color(color_cycle[0])\n    current_color = getattr(layer, f\'_current_{attribute}_color\')\n    np.testing.assert_allclose(current_color, expected_color)\n\n    # add a point\n    layer.add([10, 10])\n    props = {\'point_type\': np.array([\'A\'])}\n    expected_color = np.array([[1, 0, 0, 1]])\n    np.testing.assert_equal(layer.properties, props)\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(attribute_color, expected_color)\n\n    # add a point with a new property\n    layer.selected_data = []\n    layer.current_properties = {\'point_type\': np.array([\'B\'])}\n    layer.add([12, 12])\n    new_color = np.array([0, 0, 1, 1])\n    expected_color = np.vstack((expected_color, new_color))\n    new_properties = {\'point_type\': np.array([\'A\', \'B\'])}\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(attribute_color, expected_color)\n    np.testing.assert_equal(layer.properties, new_properties)\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_adding_value_color_cycle(attribute):\n    """""" Test that adding values to properties used to set a color cycle\n    and then calling Points.refresh_colors() performs the update and adds the\n    new value to the face/edge_color_cycle_map.\n\n    See: https://github.com/napari/napari/issues/988\n    """"""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([\'A\', \'B\'], shape[0])}\n    color_cycle = [\'red\', \'blue\']\n    points_kwargs = {\n        \'properties\': properties,\n        f\'{attribute}_color\': \'point_type\',\n        f\'{attribute}_color_cycle\': color_cycle,\n    }\n    layer = Points(data, **points_kwargs)\n\n    # make point 0 point_type C\n    point_types = layer.properties[\'point_type\']\n    point_types[0] = \'C\'\n    layer.properties[\'point_type\'] = point_types\n    layer.refresh_colors(update_color_mapping=False)\n\n    color_cycle_map = getattr(layer, f\'{attribute}_color_cycle_map\')\n    color_map_keys = [*color_cycle_map]\n    assert \'C\' in color_map_keys\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_color_colormap(attribute):\n    """"""Test setting edge/face color with a colormap""""""\n    # create Points using with a colormap\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    properties = {\'point_type\': _make_cycled_properties([0, 1.5], shape[0])}\n    points_kwargs = {\n        \'properties\': properties,\n        f\'{attribute}_color\': \'point_type\',\n        f\'{attribute}_colormap\': \'gray\',\n    }\n    layer = Points(data, **points_kwargs)\n    assert layer.properties == properties\n    color_mode = getattr(layer, f\'{attribute}_color_mode\')\n    assert color_mode == \'colormap\'\n    color_array = transform_color([\'black\', \'white\'] * int((shape[0] / 2)))\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    assert np.all(attribute_color == color_array)\n\n    # change the color cycle - face_color should not change\n    setattr(layer, f\'{attribute}_color_cycle\', [\'red\', \'blue\'])\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    assert np.all(attribute_color == color_array)\n\n    # Add new point and test its color\n    coord = [18, 18]\n    layer.selected_data = {0}\n    layer.add(coord)\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    assert len(attribute_color) == shape[0] + 1\n    np.testing.assert_allclose(\n        attribute_color, np.vstack((color_array, transform_color(\'black\'))),\n    )\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    assert len(attribute_color) == shape[0] - 1\n    np.testing.assert_allclose(\n        attribute_color,\n        np.vstack(\n            (color_array[1], color_array[3:], transform_color(\'black\'),)\n        ),\n    )\n\n    # adjust the clims\n    setattr(layer, f\'{attribute}_contrast_limits\', (0, 3))\n    layer.refresh_colors(update_color_mapping=False)\n    attribute_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(attribute_color[-2], [0.5, 0.5, 0.5, 1])\n\n    # change the colormap\n    new_colormap = \'viridis\'\n    setattr(layer, f\'{attribute}_colormap\', new_colormap)\n    attribute_colormap = getattr(layer, f\'{attribute}_colormap\')\n    assert attribute_colormap[1] == get_colormap(new_colormap)\n\n\ndef test_size():\n    """"""Test setting size with scalar.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.unique(layer.size)[0] == 10\n\n    # Add a new point, it should get current size\n    coord = [17, 17]\n    layer.add(coord)\n    assert layer.size.shape == (11, 2)\n    assert np.unique(layer.size)[0] == 10\n\n    # Setting size affects newly added points not current points\n    layer.current_size = 20\n    assert layer.current_size == 20\n    assert layer.size.shape == (11, 2)\n    assert np.unique(layer.size)[0] == 10\n\n    # Add new point, should have new size\n    coord = [18, 18]\n    layer.add(coord)\n    assert layer.size.shape == (12, 2)\n    assert np.unique(layer.size[:11])[0] == 10\n    assert np.all(layer.size[11] == [20, 20])\n\n    # Select data and change size\n    layer.selected_data = {0, 1}\n    assert layer.current_size == 10\n    layer.current_size = 16\n    assert layer.size.shape == (12, 2)\n    assert np.unique(layer.size[2:11])[0] == 10\n    assert np.unique(layer.size[:2])[0] == 16\n\n    # Select data and size changes\n    layer.selected_data = {11}\n    assert layer.current_size == 20\n\n\ndef test_size_with_arrays():\n    """"""Test setting size with arrays.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    sizes = 5 * np.random.random(shape)\n    layer.size = sizes\n    assert np.all(layer.size == sizes)\n\n    # Test broadcasting of sizes\n    sizes = [5, 5]\n    layer.size = sizes\n    assert np.all(layer.size[0] == sizes)\n\n    # Test broadcasting of transposed sizes\n    sizes = np.random.randint(low=1, high=5, size=shape[::-1])\n    layer.size = sizes\n    np.testing.assert_equal(layer.size, sizes.T)\n\n    # Un-broadcastable array should raise an exception\n    bad_sizes = np.random.randint(low=1, high=5, size=(3, 8))\n    with pytest.raises(ValueError):\n        layer.size = bad_sizes\n\n    # Create new layer with new size array data\n    sizes = 5 * np.random.random(shape)\n    layer = Points(data, size=sizes)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.all(layer.size == sizes)\n\n    # Create new layer with new size array data\n    sizes = [5, 5]\n    layer = Points(data, size=sizes)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.all(layer.size[0] == sizes)\n\n    # Add new point, should have new size\n    coord = [18, 18]\n    layer.current_size = 13\n    layer.add(coord)\n    assert layer.size.shape == (11, 2)\n    assert np.unique(layer.size[:10])[0] == 5\n    assert np.all(layer.size[10] == [13, 13])\n\n    # Select data and change size\n    layer.selected_data = {0, 1}\n    assert layer.current_size == 5\n    layer.current_size = 16\n    assert layer.size.shape == (11, 2)\n    assert np.unique(layer.size[2:10])[0] == 5\n    assert np.unique(layer.size[:2])[0] == 16\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == 9\n    assert len(layer.size) == 9\n    assert np.all(layer.size[0] == [16, 16])\n    assert np.all(layer.size[1] == [5, 5])\n\n\ndef test_size_with_3D_arrays():\n    """"""Test setting size with 3D arrays.""""""\n    shape = (10, 3)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[:2, 0] = 0\n    layer = Points(data)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.unique(layer.size)[0] == 10\n\n    sizes = 5 * np.random.random(shape)\n    layer.size = sizes\n    assert np.all(layer.size == sizes)\n\n    # Test broadcasting of sizes\n    sizes = [1, 5, 5]\n    layer.size = sizes\n    assert np.all(layer.size[0] == sizes)\n\n    # Create new layer with new size array data\n    sizes = 5 * np.random.random(shape)\n    layer = Points(data, size=sizes)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.all(layer.size == sizes)\n\n    # Create new layer with new size array data\n    sizes = [1, 5, 5]\n    layer = Points(data, size=sizes)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.all(layer.size[0] == sizes)\n\n    # Add new point, should have new size in last dim only\n    coord = [4, 18, 18]\n    layer.current_size = 13\n    layer.add(coord)\n    assert layer.size.shape == (11, 3)\n    assert np.unique(layer.size[:10, 1:])[0] == 5\n    assert np.all(layer.size[10] == [1, 13, 13])\n\n    # Select data and change size\n    layer.selected_data = {0, 1}\n    assert layer.current_size == 5\n    layer.current_size = 16\n    assert layer.size.shape == (11, 3)\n    assert np.unique(layer.size[2:10, 1:])[0] == 5\n    assert np.all(layer.size[0] == [16, 16, 16])\n\n    # Create new 3D layer with new 2D points size data\n    sizes = [0, 5, 5]\n    layer = Points(data, size=sizes)\n    assert layer.current_size == 10\n    assert layer.size.shape == shape\n    assert np.all(layer.size[0] == sizes)\n\n    # Add new point, should have new size only in last 2 dimensions\n    coord = [4, 18, 18]\n    layer.current_size = 13\n    layer.add(coord)\n    assert layer.size.shape == (11, 3)\n    assert np.all(layer.size[10] == [0, 13, 13])\n\n    # Select data and change size\n    layer.selected_data = {0, 1}\n    assert layer.current_size == 5\n    layer.current_size = 16\n    assert layer.size.shape == (11, 3)\n    assert np.unique(layer.size[2:10, 1:])[0] == 5\n    assert np.all(layer.size[0] == [0, 16, 16])\n\n\ndef test_copy_and_paste():\n    """"""Test copying and pasting selected points.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Points(data)\n    # Clipboard starts empty\n    assert layer._clipboard == {}\n\n    # Pasting empty clipboard doesn\'t change data\n    layer._paste_data()\n    assert len(layer.data) == 10\n\n    # Copying with nothing selected leave clipboard empty\n    layer._copy_data()\n    assert layer._clipboard == {}\n\n    # Copying and pasting with two points selected adds to clipboard and data\n    layer.selected_data = {0, 1}\n    layer._copy_data()\n    layer._paste_data()\n    assert len(layer._clipboard.keys()) > 0\n    assert len(layer.data) == shape[0] + 2\n    assert np.all(layer.data[:2] == layer.data[-2:])\n\n    # Pasting again adds two more points to data\n    layer._paste_data()\n    assert len(layer.data) == shape[0] + 4\n    assert np.all(layer.data[:2] == layer.data[-2:])\n\n    # Unselecting everything and copying and pasting will empty the clipboard\n    # and add no new data\n    layer.selected_data = {}\n    layer._copy_data()\n    layer._paste_data()\n    assert layer._clipboard == {}\n    assert len(layer.data) == shape[0] + 4\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[-1] = [0, 0]\n    layer = Points(data)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert value == 9\n\n    layer.data = layer.data + 20\n    value = layer.get_value()\n    assert value is None\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[-1] = [0, 0]\n    layer = Points(data)\n    msg = layer.get_message()\n    assert type(msg) == str\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[0] = [0, 0]\n    data[-1] = [20, 20]\n    layer = Points(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_thumbnail_with_n_points_greater_than_max():\n    """"""Test thumbnail generation with n_points > _max_points_thumbnail\n\n    see: https://github.com/napari/napari/pull/934\n    """"""\n    # 2D\n    max_points = Points._max_points_thumbnail * 2\n    bigger_data = np.random.randint(10, 100, (max_points, 2))\n    big_layer = Points(bigger_data)\n    big_layer._update_thumbnail()\n    assert big_layer.thumbnail.shape == big_layer._thumbnail_shape\n\n    # #3D\n    bigger_data_3d = np.random.randint(10, 100, (max_points, 3))\n    bigger_layer_3d = Points(bigger_data_3d)\n    bigger_layer_3d.dims.ndisplay = 3\n    bigger_layer_3d._update_thumbnail()\n    assert bigger_layer_3d.thumbnail.shape == bigger_layer_3d._thumbnail_shape\n\n\ndef test_view_data():\n    coords = np.array([[0, 1, 1], [0, 2, 2], [1, 3, 3], [3, 3, 3]])\n    layer = Points(coords)\n\n    layer.dims.set_point(0, 0)\n    assert np.all(\n        layer._view_data == coords[np.ix_([0, 1], layer.dims.displayed)]\n    )\n\n    layer.dims.set_point(0, 1)\n    assert np.all(\n        layer._view_data == coords[np.ix_([2], layer.dims.displayed)]\n    )\n\n    layer.dims.ndisplay = 3\n    assert np.all(layer._view_data == coords)\n\n\ndef test_view_size():\n    coords = np.array([[0, 1, 1], [0, 2, 2], [1, 3, 3], [3, 3, 3]])\n    sizes = np.array([[3, 5, 5], [3, 5, 5], [3, 3, 3], [2, 2, 3]])\n    layer = Points(coords, size=sizes, n_dimensional=False)\n\n    layer.dims.set_point(0, 0)\n    assert np.all(\n        layer._view_size == sizes[np.ix_([0, 1], layer.dims.displayed)]\n    )\n\n    layer.dims.set_point(0, 1)\n    assert np.all(layer._view_size == sizes[np.ix_([2], layer.dims.displayed)])\n\n    layer.n_dimensional = True\n    assert len(layer._view_size) == 3\n\n    # test a slice with no points\n    layer.n_dimensional = False\n    layer.dims.set_point(0, 2)\n    assert np.all(layer._view_size == [])\n\n\ndef test_view_colors():\n    coords = [[0, 1, 1], [0, 2, 2], [1, 3, 3], [3, 3, 3]]\n    face_color = np.array(\n        [[1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1], [0, 0, 1, 1]]\n    )\n    edge_color = np.array(\n        [[0, 0, 1, 1], [1, 0, 0, 1], [0, 1, 0, 1], [0, 0, 1, 1]]\n    )\n\n    layer = Points(coords, face_color=face_color, edge_color=edge_color)\n    layer.dims.set_point(0, 0)\n    print(layer.face_color)\n    print(layer._view_face_color)\n    assert np.all(layer._view_face_color == face_color[[0, 1]])\n    assert np.all(layer._view_edge_color == edge_color[[0, 1]])\n\n    layer.dims.set_point(0, 1)\n    assert np.all(layer._view_face_color == face_color[[2]])\n    assert np.all(layer._view_edge_color == edge_color[[2]])\n\n    # view colors should return empty array if there are no points\n    layer.dims.set_point(0, 2)\n    assert len(layer._view_face_color) == 0\n    assert len(layer._view_edge_color) == 0\n\n\ndef test_interaction_box():\n    """"""Test the boxes calculated for selected points""""""\n    data = [[3, 3]]\n    size = 2\n    layer = Points(data, size=size)\n\n    # get a box with no points selected\n    index = []\n    box = layer.interaction_box(index)\n    assert box is None\n\n    # get a box with a point selected\n    index = [0]\n    expected_box = points_to_squares(data, size)\n    box = layer.interaction_box(index)\n    np.all([np.isin(p, expected_box) for p in box])\n'"
napari/layers/points/_tests/test_points_mouse_bindings.py,2,"b'import pytest\nimport numpy as np\nimport collections\nfrom napari.layers import Points\nfrom napari.utils.interactions import (\n    ReadOnlyWrapper,\n    mouse_press_callbacks,\n    mouse_move_callbacks,\n    mouse_release_callbacks,\n)\n\n\n@pytest.fixture\ndef Event():\n    """"""Create a subclass for simulating vispy mouse events.\n\n    Returns\n    -------\n    Event : Type\n        A new tuple subclass named Event that can be used to create a\n        NamedTuple object with fields ""type"", ""is_dragging"", and ""modifiers"".\n    """"""\n    return collections.namedtuple(\n        \'Event\', field_names=[\'type\', \'is_dragging\', \'modifiers\']\n    )\n\n\n@pytest.fixture\ndef create_known_points_layer():\n    """"""Create points layer with known coordinates\n\n    Returns\n    -------\n    layer : napar.layers.Points\n        Points layer.\n    n_points : int\n        Number of points in the points layer\n    known_non_point : list\n        Data coordinates that are known to contain no points. Useful during\n        testing when needing to guarantee no point is clicked on.\n    """"""\n    data = [[1, 3], [8, 4], [10, 10], [15, 4]]\n    known_non_point = [20, 30]\n    n_points = len(data)\n\n    layer = Points(data, size=1)\n    assert np.all(layer.data == data)\n    assert layer.ndim == 2\n    assert len(layer.data) == n_points\n    assert len(layer.selected_data) == 0\n\n    return layer, n_points, known_non_point\n\n\ndef test_not_adding_or_selecting_point(create_known_points_layer, Event):\n    """"""Don\'t add or select a point by clicking on one in pan_zoom mode.""""""\n    layer, n_points, _ = create_known_points_layer\n    layer.mode = \'pan_zoom\'\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no new point added and non selected\n    assert len(layer.data) == n_points\n    assert len(layer.selected_data) == 0\n\n\ndef test_add_point(create_known_points_layer, Event):\n    """"""Add point by clicking in add mode.""""""\n    layer, n_points, known_non_point = create_known_points_layer\n\n    # Add point at location where non exists\n    layer.mode = \'add\'\n    layer.position = known_non_point\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check new point added at coordinates location\n    assert len(layer.data) == n_points + 1\n    np.testing.assert_allclose(layer.data[-1], known_non_point)\n\n\ndef test_select_point(create_known_points_layer, Event):\n    """"""Select a point by clicking on one in select mode.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = tuple(layer.data[0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 1\n    assert 0 in layer.selected_data\n\n\ndef test_after_in_add_mode_point(create_known_points_layer, Event):\n    """"""Don\'t add or select a point by clicking on one in pan_zoom mode.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'add\'\n    layer.mode = \'pan_zoom\'\n    layer.position = tuple(layer.data[0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no new point added and non selected\n    assert len(layer.data) == n_points\n    assert len(layer.selected_data) == 0\n\n\ndef test_after_in_select_mode_point(create_known_points_layer, Event):\n    """"""Don\'t add or select a point by clicking on one in pan_zoom mode.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.mode = \'pan_zoom\'\n    layer.position = tuple(layer.data[0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no new point added and non selected\n    assert len(layer.data) == n_points\n    assert len(layer.selected_data) == 0\n\n\ndef test_unselect_select_point(create_known_points_layer, Event):\n    """"""Select a point by clicking on one in select mode.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = tuple(layer.data[0])\n    layer.selected_data = {2, 3}\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 1\n    assert 0 in layer.selected_data\n\n\ndef test_add_select_point(create_known_points_layer, Event):\n    """"""Add to a selection of points point by shift-clicking on one.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = tuple(layer.data[0])\n    layer.selected_data = {2, 3}\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[\'Shift\'])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[\'Shift\'])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 3\n    assert layer.selected_data == {2, 3, 0}\n\n\ndef test_remove_select_point(create_known_points_layer, Event):\n    """"""Remove from a selection of points point by shift-clicking on one.""""""\n    layer, n_points, _ = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = tuple(layer.data[0])\n    layer.selected_data = {0, 2, 3}\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[\'Shift\'])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[\'Shift\'])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 2\n    assert layer.selected_data == {2, 3}\n\n\ndef test_not_selecting_point(create_known_points_layer, Event):\n    """"""Don\'t select a point by not clicking on one in select mode.""""""\n    layer, n_points, known_non_point = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = known_non_point\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 0\n\n\ndef test_unselecting_points(create_known_points_layer, Event):\n    """"""Unselect points by not clicking on one in select mode.""""""\n    layer, n_points, known_non_point = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = known_non_point\n    layer.selected_data = {2, 3}\n    assert len(layer.selected_data) == 2\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked point selected\n    assert len(layer.selected_data) == 0\n\n\ndef test_selecting_all_points_with_drag(create_known_points_layer, Event):\n    """"""Select all points when drag box includes all of them.""""""\n    layer, n_points, known_non_point = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = known_non_point\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag start\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    layer.position = [0, 0]\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check all points selected as drag box contains them\n    assert len(layer.selected_data) == n_points\n\n\ndef test_selecting_no_points_with_drag(create_known_points_layer, Event):\n    """"""Select all points when drag box includes all of them.""""""\n    layer, n_points, known_non_point = create_known_points_layer\n\n    layer.mode = \'select\'\n    layer.position = known_non_point\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag start\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    layer.position = [50, 60]\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no points selected as drag box doesn\'t contain them\n    assert len(layer.selected_data) == 0\n'"
napari/layers/shapes/_shapes_models/__init__.py,0,b'from .shape import Shape\nfrom .rectangle import Rectangle\nfrom .ellipse import Ellipse\nfrom .line import Line\nfrom .path import Path\nfrom .polygon import Polygon\n'
napari/layers/shapes/_shapes_models/ellipse.py,5,"b'import numpy as np\nfrom .shape import Shape\nfrom .._shapes_utils import (\n    triangulate_edge,\n    triangulate_ellipse,\n    center_radii_to_corners,\n    rectangle_to_box,\n)\n\n\nclass Ellipse(Shape):\n    """"""Class for a single ellipse\n\n    Parameters\n    ----------\n    data : (4, D) array or (2, 2) array.\n        Either a (2, 2) array specifying the center and radii of an axis\n        aligned ellipse, or a (4, D) array specifying the four corners of a\n        boudning box that contains the ellipse. These need not be axis aligned.\n    edge_width : float\n        thickness of lines and edges.\n    opacity : float\n        Opacity of the shape, must be between 0 and 1.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    """"""\n\n    def __init__(\n        self,\n        data,\n        *,\n        edge_width=1,\n        opacity=1,\n        z_index=0,\n        dims_order=None,\n        ndisplay=2,\n    ):\n\n        super().__init__(\n            edge_width=edge_width,\n            z_index=z_index,\n            dims_order=dims_order,\n            ndisplay=ndisplay,\n        )\n\n        self._closed = True\n        self._use_face_vertices = True\n        self.data = data\n        self.name = \'ellipse\'\n\n    @property\n    def data(self):\n        """"""(4, D) array: ellipse vertices.\n        """"""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        data = np.array(data).astype(float)\n\n        if len(self.dims_order) != data.shape[1]:\n            self._dims_order = list(range(data.shape[1]))\n\n        if len(data) == 2 and data.shape[1] == 2:\n            data = center_radii_to_corners(data[0], data[1])\n\n        if len(data) != 4:\n            raise ValueError(\n                f""""""Data shape does not match a ellipse.\n                             Ellipse expects four corner vertices,\n                             {len(data)} provided.""""""\n            )\n\n        self._data = data\n        self._update_displayed_data()\n\n    def _update_displayed_data(self):\n        """"""Update the data that is to be displayed.""""""\n        # Build boundary vertices with num_segments\n        vertices, triangles = triangulate_ellipse(self.data_displayed)\n        self._set_meshes(vertices[1:-1], face=False)\n        self._face_vertices = vertices\n        self._face_triangles = triangles\n        self._box = rectangle_to_box(self.data_displayed)\n\n        data_not_displayed = self.data[:, self.dims_not_displayed]\n        self.slice_key = np.round(\n            [\n                np.min(data_not_displayed, axis=0),\n                np.max(data_not_displayed, axis=0),\n            ]\n        ).astype(\'int\')\n\n    def transform(self, transform):\n        """"""Performs a linear transform on the shape\n\n        Parameters\n        ----------\n        transform : np.ndarray\n            2x2 array specifying linear transform.\n        """"""\n        self._box = self._box @ transform.T\n        self._data[:, self.dims_displayed] = (\n            self._data[:, self.dims_displayed] @ transform.T\n        )\n        self._face_vertices = self._face_vertices @ transform.T\n\n        points = self._face_vertices[1:-1]\n\n        centers, offsets, triangles = triangulate_edge(\n            points, closed=self._closed\n        )\n        self._edge_vertices = centers\n        self._edge_offsets = offsets\n        self._edge_triangles = triangles\n'"
napari/layers/shapes/_shapes_models/line.py,4,"b'import numpy as np\nfrom .shape import Shape\nfrom .._shapes_utils import create_box\n\n\nclass Line(Shape):\n    """"""Class for a single line segment\n\n    Parameters\n    ----------\n    data : (2, D) array\n        Line vertices.\n    edge_width : float\n        thickness of lines and edges.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    """"""\n\n    def __init__(\n        self, data, *, edge_width=1, z_index=0, dims_order=None, ndisplay=2,\n    ):\n\n        super().__init__(\n            edge_width=edge_width,\n            z_index=z_index,\n            dims_order=dims_order,\n            ndisplay=ndisplay,\n        )\n        self._filled = False\n        self.data = data\n        self.name = \'line\'\n\n    @property\n    def data(self):\n        """"""(2, D) array: line vertices.\n        """"""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        data = np.array(data).astype(float)\n\n        if len(self.dims_order) != data.shape[1]:\n            self._dims_order = list(range(data.shape[1]))\n\n        if len(data) != 2:\n            raise ValueError(\n                f""""""Data shape does not match a line. A\n                             line expects two end vertices,\n                             {len(data)} provided.""""""\n            )\n\n        self._data = data\n        self._update_displayed_data()\n\n    def _update_displayed_data(self):\n        """"""Update the data that is to be displayed.""""""\n        # For path connect every all data\n        self._set_meshes(self.data_displayed, face=False, closed=False)\n        self._box = create_box(self.data_displayed)\n\n        data_not_displayed = self.data[:, self.dims_not_displayed]\n        self.slice_key = np.round(\n            [\n                np.min(data_not_displayed, axis=0),\n                np.max(data_not_displayed, axis=0),\n            ]\n        ).astype(\'int\')\n'"
napari/layers/shapes/_shapes_models/path.py,6,"b'import numpy as np\nfrom .shape import Shape\nfrom .._shapes_utils import create_box\n\n\nclass Path(Shape):\n    """"""Class for a single path, which is a sequence of line segments.\n\n    Parameters\n    ----------\n    data : np.ndarray\n        NxD array of vertices specifying the path.\n    edge_width : float\n        thickness of lines and edges.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    """"""\n\n    def __init__(\n        self, data, *, edge_width=1, z_index=0, dims_order=None, ndisplay=2,\n    ):\n\n        super().__init__(\n            edge_width=edge_width,\n            z_index=z_index,\n            dims_order=dims_order,\n            ndisplay=ndisplay,\n        )\n        self._filled = False\n        self.data = data\n        self.name = \'path\'\n\n    @property\n    def data(self):\n        """"""np.ndarray: NxD array of vertices.\n        """"""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        data = np.array(data).astype(float)\n\n        if len(self.dims_order) != data.shape[1]:\n            self._dims_order = list(range(data.shape[1]))\n\n        if len(data) < 2:\n            raise ValueError(\n                f""""""Data shape does not match a path. A\n                             Path expects at least two vertices,\n                             {len(data)} provided.""""""\n            )\n\n        self._data = data\n        self._update_displayed_data()\n\n    def _update_displayed_data(self):\n        """"""Update the data that is to be displayed.""""""\n        # For path connect every all data\n        self._set_meshes(self.data_displayed, face=False, closed=False)\n        self._box = create_box(self.data_displayed)\n\n        data_not_displayed = self.data[:, self.dims_not_displayed]\n        self.slice_key = np.round(\n            [\n                np.min(data_not_displayed, axis=0),\n                np.max(data_not_displayed, axis=0),\n            ]\n        ).astype(\'int\')\n'"
napari/layers/shapes/_shapes_models/polygon.py,6,"b'import numpy as np\nfrom .shape import Shape\nfrom .._shapes_utils import create_box\n\n\nclass Polygon(Shape):\n    """"""Class for a single polygon\n\n    Parameters\n    ----------\n    data : np.ndarray\n        NxD array of vertices specifying the shape.\n    edge_width : float\n        thickness of lines and edges.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    """"""\n\n    def __init__(\n        self, data, *, edge_width=1, z_index=0, dims_order=None, ndisplay=2,\n    ):\n\n        super().__init__(\n            edge_width=edge_width,\n            z_index=z_index,\n            dims_order=dims_order,\n            ndisplay=ndisplay,\n        )\n        self._closed = True\n        self.data = data\n        self.name = \'polygon\'\n\n    @property\n    def data(self):\n        """"""np.ndarray: NxD array of vertices.\n        """"""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        data = np.array(data).astype(float)\n\n        if len(self.dims_order) != data.shape[1]:\n            self._dims_order = list(range(data.shape[1]))\n\n        if len(data) < 2:\n            raise ValueError(\n                f""""""Data shape does not match a polygon. A\n                             Polygon expects at least two vertices,\n                             {len(data)} provided.""""""\n            )\n\n        self._data = data\n        self._update_displayed_data()\n\n    def _update_displayed_data(self):\n        """"""Update the data that is to be displayed.""""""\n        self._set_meshes(self.data_displayed)\n        self._box = create_box(self.data_displayed)\n\n        data_not_displayed = self.data[:, self.dims_not_displayed]\n        self.slice_key = np.round(\n            [\n                np.min(data_not_displayed, axis=0),\n                np.max(data_not_displayed, axis=0),\n            ]\n        ).astype(\'int\')\n'"
napari/layers/shapes/_shapes_models/rectangle.py,5,"b'import numpy as np\nfrom .shape import Shape\nfrom .._shapes_utils import find_corners, rectangle_to_box\n\n\nclass Rectangle(Shape):\n    """"""Class for a single rectangle\n\n    Parameters\n    ----------\n    data : (4, D) or (2, 2) array\n        Either a (2, 2) array specifying the two corners of an axis aligned\n        rectangle, or a (4, D) array specifying the four corners of a bounding\n        box that contains the rectangle. These need not be axis aligned.\n    edge_width : float\n        thickness of lines and edges.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    """"""\n\n    def __init__(\n        self, data, *, edge_width=1, z_index=0, dims_order=None, ndisplay=2,\n    ):\n\n        super().__init__(\n            edge_width=edge_width,\n            z_index=z_index,\n            dims_order=dims_order,\n            ndisplay=ndisplay,\n        )\n\n        self._closed = True\n        self.data = data\n        self.name = \'rectangle\'\n\n    @property\n    def data(self):\n        """"""(4, D) array: rectangle vertices.\n        """"""\n        return self._data\n\n    @data.setter\n    def data(self, data):\n        data = np.array(data).astype(float)\n\n        if len(self.dims_order) != data.shape[1]:\n            self._dims_order = list(range(data.shape[1]))\n\n        if len(data) == 2 and data.shape[1] == 2:\n            data = find_corners(data)\n\n        if len(data) != 4:\n            print(data)\n            raise ValueError(\n                f""""""Data shape does not match a rectangle.\n                             Rectangle expects four corner vertices,\n                             {len(data)} provided.""""""\n            )\n\n        self._data = data\n        self._update_displayed_data()\n\n    def _update_displayed_data(self):\n        """"""Update the data that is to be displayed.""""""\n        # Add four boundary lines and then two triangles for each\n        self._set_meshes(self.data_displayed, face=False)\n        self._face_vertices = self.data_displayed\n        self._face_triangles = np.array([[0, 1, 2], [0, 2, 3]])\n        self._box = rectangle_to_box(self.data_displayed)\n\n        data_not_displayed = self.data[:, self.dims_not_displayed]\n        self.slice_key = np.round(\n            [\n                np.min(data_not_displayed, axis=0),\n                np.max(data_not_displayed, axis=0),\n            ]\n        ).astype(\'int\')\n'"
napari/layers/shapes/_shapes_models/shape.py,44,"b'from abc import ABC, abstractmethod\nimport numpy as np\nfrom copy import copy\n\nfrom .._shapes_utils import (\n    triangulate_edge,\n    triangulate_face,\n    is_collinear,\n    poly_to_mask,\n    path_to_mask,\n)\n\n\nclass Shape(ABC):\n    """"""Base class for a single shape\n\n    Parameters\n    ----------\n    data : (N, D) array\n        Vertices specifying the shape.\n    edge_width : float\n        thickness of lines and edges.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are to be rendered in.\n    ndisplay : int\n        Number of displayed dimensions.\n\n    Attributes\n    ----------\n    data : (N, D) array\n        Vertices specifying the shape.\n    data_displayed : (N, 2) array\n        Vertices of the shape that are currently displayed. Only 2D rendering\n        currently supported.\n    edge_width : float\n        thickness of lines and edges.\n    name : str\n        Name of shape type.\n    z_index : int\n        Specifier of z order priority. Shapes with higher z order are displayed\n        ontop of others.\n    dims_order : (D,) list\n        Order that the dimensions are rendered in.\n    ndisplay : int\n        Number of dimensions to be displayed, must be 2 as only 2D rendering\n        currently supported.\n    displayed : tuple\n        List of dimensions that are displayed.\n    not_displayed : tuple\n        List of dimensions that are not displayed.\n    slice_key : (2, M) array\n        Min and max values of the M non-displayed dimensions, useful for\n        slicing multidimensional shapes.\n\n    Extended Summary\n    ----------\n    _closed : bool\n        Bool if shape edge is a closed path or not\n    _box : np.ndarray\n        9x2 array of vertices of the interaction box. The first 8 points are\n        the corners and midpoints of the box in clockwise order starting in the\n        upper-left corner. The last point is the center of the box\n    _face_vertices : np.ndarray\n        Qx2 array of vertices of all triangles for the shape face\n    _face_triangles : np.ndarray\n        Px3 array of vertex indices that form the triangles for the shape face\n    _edge_vertices : np.ndarray\n        Rx2 array of centers of vertices of triangles for the shape edge.\n        These values should be added to the scaled `_edge_offsets` to get the\n        actual vertex positions. The scaling corresponds to the width of the\n        edge\n    _edge_offsets : np.ndarray\n        Sx2 array of offsets of vertices of triangles for the shape edge. For\n        These values should be scaled and added to the `_edge_vertices` to get\n        the actual vertex positions. The scaling corresponds to the width of\n        the edge\n    _edge_triangles : np.ndarray\n        Tx3 array of vertex indices that form the triangles for the shape edge\n    _filled : bool\n        Flag if array is filled or not.\n    _use_face_vertices : bool\n        Flag to use face vertices for mask generation.\n    """"""\n\n    def __init__(\n        self,\n        *,\n        shape_type=\'rectangle\',\n        edge_width=1,\n        z_index=0,\n        dims_order=None,\n        ndisplay=2,\n    ):\n\n        self._dims_order = dims_order or list(range(2))\n        self._ndisplay = ndisplay\n        self.slice_key = None\n\n        self._face_vertices = np.empty((0, self.ndisplay))\n        self._face_triangles = np.empty((0, 3), dtype=np.uint32)\n        self._edge_vertices = np.empty((0, self.ndisplay))\n        self._edge_offsets = np.empty((0, self.ndisplay))\n        self._edge_triangles = np.empty((0, 3), dtype=np.uint32)\n        self._box = np.empty((9, 2))\n\n        self._closed = False\n        self._filled = True\n        self._use_face_vertices = False\n        self.edge_width = edge_width\n        self.z_index = z_index\n        self.name = \'\'\n\n    @property\n    @abstractmethod\n    def data(self):\n        # user writes own docstring\n        raise NotImplementedError()\n\n    @data.setter\n    @abstractmethod\n    def data(self, data):\n        raise NotImplementedError()\n\n    @abstractmethod\n    def _update_displayed_data(self):\n        raise NotImplementedError()\n\n    @property\n    def ndisplay(self):\n        """"""int: Number of displayed dimensions.""""""\n        return self._ndisplay\n\n    @ndisplay.setter\n    def ndisplay(self, ndisplay):\n        if self.ndisplay == ndisplay:\n            return\n        self._ndisplay = ndisplay\n        self._update_displayed_data()\n\n    @property\n    def dims_order(self):\n        """"""(D,) list: Order that the dimensions are rendered in.""""""\n        return self._dims_order\n\n    @dims_order.setter\n    def dims_order(self, dims_order):\n        if self.dims_order == dims_order:\n            return\n        self._dims_order = dims_order\n        self._update_displayed_data()\n\n    @property\n    def dims_displayed(self):\n        """"""tuple: Dimensions that are displayed.""""""\n        return self.dims_order[-self.ndisplay :]\n\n    @property\n    def dims_not_displayed(self):\n        """"""tuple: Dimensions that are not displayed.""""""\n        return self.dims_order[: -self.ndisplay]\n\n    @property\n    def data_displayed(self):\n        """"""(N, 2) array: Vertices of the shape that are currently displayed.""""""\n        return self.data[:, self.dims_displayed]\n\n    @property\n    def edge_width(self):\n        """"""float: thickness of lines and edges.\n        """"""\n        return self._edge_width\n\n    @edge_width.setter\n    def edge_width(self, edge_width):\n        self._edge_width = edge_width\n\n    @property\n    def z_index(self):\n        """"""int: z order priority of shape. Shapes with higher z order displayed\n        ontop of others.\n        """"""\n        return self._z_index\n\n    @z_index.setter\n    def z_index(self, z_index):\n        self._z_index = z_index\n\n    def _set_meshes(self, data, closed=True, face=True, edge=True):\n        """"""Sets the face and edge meshes from a set of points.\n\n        Parameters\n        ----------\n        data : np.ndarray\n            Nx2 or Nx3 array specifying the shape to be triangulated\n        closed : bool\n            Bool which determines if the edge is closed or not\n        face : bool\n            Bool which determines if the face need to be traingulated\n        edge : bool\n            Bool which determines if the edge need to be traingulated\n        """"""\n        if edge:\n            centers, offsets, triangles = triangulate_edge(data, closed=closed)\n            self._edge_vertices = centers\n            self._edge_offsets = offsets\n            self._edge_triangles = triangles\n        else:\n            self._edge_vertices = np.empty((0, self.ndisplay))\n            self._edge_offsets = np.empty((0, self.ndisplay))\n            self._edge_triangles = np.empty((0, 3), dtype=np.uint32)\n\n        if face:\n            clean_data = np.array(\n                [\n                    p\n                    for i, p in enumerate(data)\n                    if i == 0 or not np.all(p == data[i - 1])\n                ]\n            )\n\n            if not is_collinear(clean_data[:, -2:]):\n                if clean_data.shape[1] == 2:\n                    vertices, triangles = triangulate_face(clean_data)\n                elif len(np.unique(clean_data[:, 0])) == 1:\n                    val = np.unique(clean_data[:, 0])\n                    vertices, triangles = triangulate_face(clean_data[:, -2:])\n                    exp = np.expand_dims(np.repeat(val, len(vertices)), axis=1)\n                    vertices = np.concatenate([exp, vertices], axis=1)\n                else:\n                    triangles = []\n                    vertices = []\n                if len(triangles) > 0:\n                    self._face_vertices = vertices\n                    self._face_triangles = triangles\n                else:\n                    self._face_vertices = np.empty((0, self.ndisplay))\n                    self._face_triangles = np.empty((0, 3), dtype=np.uint32)\n            else:\n                self._face_vertices = np.empty((0, self.ndisplay))\n                self._face_triangles = np.empty((0, 3), dtype=np.uint32)\n        else:\n            self._face_vertices = np.empty((0, self.ndisplay))\n            self._face_triangles = np.empty((0, 3), dtype=np.uint32)\n\n    def transform(self, transform):\n        """"""Performs a linear transform on the shape\n\n        Parameters\n        ----------\n        transform : np.ndarray\n            2x2 array specifying linear transform.\n        """"""\n        self._box = self._box @ transform.T\n        self._data[:, self.dims_displayed] = (\n            self._data[:, self.dims_displayed] @ transform.T\n        )\n        self._face_vertices = self._face_vertices @ transform.T\n\n        points = self.data_displayed\n\n        centers, offsets, triangles = triangulate_edge(\n            points, closed=self._closed\n        )\n        self._edge_vertices = centers\n        self._edge_offsets = offsets\n        self._edge_triangles = triangles\n\n    def shift(self, shift):\n        """"""Performs a 2D shift on the shape\n\n        Parameters\n        ----------\n        shift : np.ndarray\n            length 2 array specifying shift of shapes.\n        """"""\n        shift = np.array(shift)\n\n        self._face_vertices = self._face_vertices + shift\n        self._edge_vertices = self._edge_vertices + shift\n        self._box = self._box + shift\n        self._data[:, self.dims_displayed] = self.data_displayed + shift\n\n    def scale(self, scale, center=None):\n        """"""Performs a scaling on the shape\n\n        Parameters\n        ----------\n        scale : float, list\n            scalar or list specifying rescaling of shape.\n        center : list\n            length 2 list specifying coordinate of center of scaling.\n        """"""\n        if isinstance(scale, (list, np.ndarray)):\n            transform = np.array([[scale[0], 0], [0, scale[1]]])\n        else:\n            transform = np.array([[scale, 0], [0, scale]])\n        if center is None:\n            self.transform(transform)\n        else:\n            self.shift(-center)\n            self.transform(transform)\n            self.shift(center)\n\n    def rotate(self, angle, center=None):\n        """"""Performs a rotation on the shape\n\n        Parameters\n        ----------\n        angle : float\n            angle specifying rotation of shape in degrees. CCW is positive.\n        center : list\n            length 2 list specifying coordinate of fixed point of the rotation.\n        """"""\n        theta = np.radians(angle)\n        transform = np.array(\n            [[np.cos(theta), np.sin(theta)], [-np.sin(theta), np.cos(theta)]]\n        )\n        if center is None:\n            self.transform(transform)\n        else:\n            self.shift(-center)\n            self.transform(transform)\n            self.shift(center)\n\n    def flip(self, axis, center=None):\n        """"""Performs a flip on the shape, either horizontal or vertical.\n\n        Parameters\n        ----------\n        axis : int\n            integer specifying axis of flip. `0` flips horizontal, `1` flips\n            vertical.\n        center : list\n            length 2 list specifying coordinate of center of flip axes.\n        """"""\n        if axis == 0:\n            transform = np.array([[1, 0], [0, -1]])\n        elif axis == 1:\n            transform = np.array([[-1, 0], [0, 1]])\n        else:\n            raise ValueError(\n                """"""Axis not recognized, must be one of ""{0, 1}""\n                             """"""\n            )\n        if center is None:\n            self.transform(transform)\n        else:\n            self.shift(-center)\n            self.transform(transform)\n            self.shift(-center)\n\n    def to_mask(self, mask_shape=None, zoom_factor=1, offset=[0, 0]):\n        """"""Convert the shape vertices to a boolean mask.\n\n        Set points to `True` if they are lying inside the shape if the shape is\n        filled, or if they are lying along the boundary of the shape if the\n        shape is not filled. Negative points or points outside the mask_shape\n        after the zoom and offset are clipped.\n\n        Parameters\n        ----------\n        mask_shape : (D,) array\n            Shape of mask to be generated. If non specified, takes the max of\n            the displayed vertices.\n        zoom_factor : float\n            Premultiplier applied to coordinates before generating mask. Used\n            for generating as downsampled mask.\n        offset : 2-tuple\n            Offset subtracted from coordinates before multiplying by the\n            zoom_factor. Used for putting negative coordinates into the mask.\n\n        Returns\n        ----------\n        mask : np.ndarray\n            Boolean array with `True` for points inside the shape\n        """"""\n        if mask_shape is None:\n            mask_shape = np.round(self.data_displayed.max(axis=0)).astype(\n                \'int\'\n            )\n\n        if len(mask_shape) == 2:\n            embedded = False\n            shape_plane = mask_shape\n        elif len(mask_shape) == self.data.shape[1]:\n            embedded = True\n            shape_plane = [mask_shape[d] for d in self.dims_displayed]\n        else:\n            raise ValueError(\n                f""""""mask shape length must either be 2 or the same\n            as the dimensionality of the shape, expected {self.data.shape[1]}\n            got {len(mask_shape)}.""""""\n            )\n\n        if self._use_face_vertices:\n            data = self._face_vertices\n        else:\n            data = self.data_displayed\n\n        data = data[:, -len(shape_plane) :]\n\n        if self._filled:\n            mask_p = poly_to_mask(shape_plane, (data - offset) * zoom_factor)\n        else:\n            mask_p = path_to_mask(shape_plane, (data - offset) * zoom_factor)\n\n        # If the mask is to be embedded in a larger array, compute array\n        # and embed as a slice.\n        if embedded:\n            mask = np.zeros(mask_shape, dtype=bool)\n            slice_key = [0] * len(mask_shape)\n            j = 0\n            for i in range(len(mask_shape)):\n                if i in self.dims_displayed:\n                    slice_key[i] = slice(None)\n                else:\n                    slice_key[i] = slice(\n                        self.slice_key[0, j], self.slice_key[1, j] + 1\n                    )\n                j += 1\n            displayed_order = np.array(copy(self.dims_displayed))\n            displayed_order[np.argsort(displayed_order)] = list(\n                range(len(displayed_order))\n            )\n            mask[tuple(slice_key)] = mask_p.transpose(displayed_order)\n        else:\n            mask = mask_p\n\n        return mask\n'"
napari/layers/shapes/_tests/test_shape_list.py,8,"b'import numpy as np\nfrom napari.layers.shapes._shape_list import ShapeList\nfrom napari.layers.shapes._shapes_models import Rectangle, Polygon, Path\nimport pytest\n\n\ndef test_empty_shape_list():\n    """"""Test instantiating empty ShapeList.""""""\n    shape_list = ShapeList()\n    assert len(shape_list.shapes) == 0\n\n\ndef test_adding_to_shape_list():\n    """"""Test adding shapes to ShapeList.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 2))\n    shape = Rectangle(data)\n    shape_list = ShapeList()\n\n    shape_list.add(shape)\n    assert len(shape_list.shapes) == 1\n    assert shape_list.shapes[0] == shape\n\n\ndef test_nD_shapes():\n    """"""Test adding shapes to ShapeList.""""""\n    np.random.seed(0)\n    shape_list = ShapeList()\n    data = 20 * np.random.random((6, 3))\n    data[:, 0] = 0\n    shape_a = Polygon(data)\n    shape_list.add(shape_a)\n\n    data = 20 * np.random.random((6, 3))\n    data[:, 0] = 1\n    shape_b = Path(data)\n    shape_list.add(shape_b)\n\n    assert len(shape_list.shapes) == 2\n    assert shape_list.shapes[0] == shape_a\n    assert shape_list.shapes[1] == shape_b\n\n    assert shape_list._vertices.shape[1] == 2\n    assert shape_list._mesh.vertices.shape[1] == 2\n\n    shape_list.ndisplay = 3\n    assert shape_list._vertices.shape[1] == 3\n    assert shape_list._mesh.vertices.shape[1] == 3\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_bad_color_array(attribute):\n    """"""Test adding shapes to ShapeList.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 2))\n    shape = Rectangle(data)\n    shape_list = ShapeList()\n\n    shape_list.add(shape)\n\n    # test setting color with a color array of the wrong shape\n    bad_color_array = np.array([[0, 0, 0, 1], [1, 1, 1, 1]])\n    with pytest.raises(ValueError):\n        setattr(shape_list, f\'{attribute}_color\', bad_color_array)\n'"
napari/layers/shapes/_tests/test_shapes.py,175,"b'import numpy as np\nimport pytest\n\nfrom napari.layers import Shapes\nfrom napari.utils.colormaps.standardize_color import transform_color\n\n\ndef test_empty_shapes():\n    shp = Shapes()\n    assert shp.dims.ndim == 2\n\n\ndef test_rectangles():\n    """"""Test instantiating Shapes layer with a random 2D rectangles.""""""\n    # Test a single four corner rectangle\n    shape = (1, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all(layer.data[0] == data[0])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n    # Test multiple four corner rectangles\n    shape = (10, 4, 2)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n    # Test a single two corner rectangle, which gets converted into four\n    # corner rectangle\n    shape = (1, 2, 2)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.nshapes == 1\n    assert len(layer.data[0]) == 4\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n    # Test multiple two corner rectangles\n    shape = (10, 2, 2)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all([len(ld) == 4 for ld in layer.data])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_rectangles_roundtrip():\n    """"""Test a full roundtrip with rectangles data.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    new_layer = Shapes(layer.data)\n    assert np.all([nd == d for nd, d in zip(new_layer.data, layer.data)])\n\n\ndef test_integer_rectangle():\n    """"""Test instantiating rectangles with integer data.""""""\n    shape = (10, 2, 2)\n    np.random.seed(1)\n    data = np.random.randint(20, size=shape)\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all([len(ld) == 4 for ld in layer.data])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_negative_rectangle():\n    """"""Test instantiating rectangles with negative data.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape) - 10\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_empty_rectangle():\n    """"""Test instantiating rectangles with empty data.""""""\n    shape = (0, 0, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.nshapes == shape[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_3D_rectangles():\n    """"""Test instantiating Shapes layer with 3D planar rectangles.""""""\n    # Test a single four corner rectangle\n    np.random.seed(0)\n    planes = np.tile(np.arange(10).reshape((10, 1, 1)), (1, 4, 1))\n    corners = np.random.uniform(0, 10, size=(10, 4, 2))\n    data = np.concatenate((planes, corners), axis=2)\n    layer = Shapes(data)\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 3\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_ellipses():\n    """"""Test instantiating Shapes layer with a random 2D ellipses.""""""\n    # Test a single four corner ellipses\n    shape = (1, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'ellipse\')\n    assert layer.nshapes == shape[0]\n    assert np.all(layer.data[0] == data[0])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'ellipse\' for s in layer.shape_type])\n\n    # Test multiple four corner ellipses\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'ellipse\')\n    assert layer.nshapes == shape[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'ellipse\' for s in layer.shape_type])\n\n    # Test a single ellipse center radii, which gets converted into four\n    # corner ellipse\n    shape = (1, 2, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'ellipse\')\n    assert layer.nshapes == 1\n    assert len(layer.data[0]) == 4\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'ellipse\' for s in layer.shape_type])\n\n    # Test multiple center radii ellipses\n    shape = (10, 2, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'ellipse\')\n    assert layer.nshapes == shape[0]\n    assert np.all([len(ld) == 4 for ld in layer.data])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'ellipse\' for s in layer.shape_type])\n\n\ndef test_4D_ellispse():\n    """"""Test instantiating Shapes layer with 4D planar ellipse.""""""\n    # Test a single 4D ellipse\n    np.random.seed(0)\n    data = [\n        [\n            [3, 5, 108, 108],\n            [3, 5, 108, 148],\n            [3, 5, 148, 148],\n            [3, 5, 148, 108],\n        ]\n    ]\n    layer = Shapes(data, shape_type=\'ellipse\')\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 4\n    assert np.all([s == \'ellipse\' for s in layer.shape_type])\n\n\ndef test_ellipses_roundtrip():\n    """"""Test a full roundtrip with ellipss data.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'ellipse\')\n    new_layer = Shapes(layer.data, shape_type=\'ellipse\')\n    assert np.all([nd == d for nd, d in zip(new_layer.data, layer.data)])\n\n\ndef test_lines():\n    """"""Test instantiating Shapes layer with a random 2D lines.""""""\n    # Test a single two end point line\n    shape = (1, 2, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'line\')\n    assert layer.nshapes == shape[0]\n    assert np.all(layer.data[0] == data[0])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'line\' for s in layer.shape_type])\n\n    # Test multiple lines\n    shape = (10, 2, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'line\')\n    assert layer.nshapes == shape[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'line\' for s in layer.shape_type])\n\n\ndef test_lines_roundtrip():\n    """"""Test a full roundtrip with line data.""""""\n    shape = (10, 2, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'line\')\n    new_layer = Shapes(layer.data, shape_type=\'line\')\n    assert np.all([nd == d for nd, d in zip(new_layer.data, layer.data)])\n\n\ndef test_paths():\n    """"""Test instantiating Shapes layer with a random 2D paths.""""""\n    # Test a single path with 6 points\n    shape = (1, 6, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'path\')\n    assert layer.nshapes == shape[0]\n    assert np.all(layer.data[0] == data[0])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'path\' for s in layer.shape_type])\n\n    # Test multiple paths with different numbers of points\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(10)\n    ]\n    layer = Shapes(data, shape_type=\'path\')\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 2\n    assert np.all([s == \'path\' for s in layer.shape_type])\n\n\ndef test_paths_roundtrip():\n    """"""Test a full roundtrip with path data.""""""\n    np.random.seed(0)\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(10)\n    ]\n    layer = Shapes(data, shape_type=\'path\')\n    new_layer = Shapes(layer.data, shape_type=\'path\')\n    assert np.all(\n        [np.all(nd == d) for nd, d in zip(new_layer.data, layer.data)]\n    )\n\n\ndef test_polygons():\n    """"""Test instantiating Shapes layer with a random 2D polygons.""""""\n    # Test a single polygon with 6 points\n    shape = (1, 6, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data, shape_type=\'polygon\')\n    assert layer.nshapes == shape[0]\n    assert np.all(layer.data[0] == data[0])\n    assert layer.ndim == shape[2]\n    assert np.all([s == \'polygon\' for s in layer.shape_type])\n\n    # Test multiple polygons with different numbers of points\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(10)\n    ]\n    layer = Shapes(data, shape_type=\'polygon\')\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 2\n    assert np.all([s == \'polygon\' for s in layer.shape_type])\n\n\ndef test_polygon_roundtrip():\n    """"""Test a full roundtrip with polygon data.""""""\n    np.random.seed(0)\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(10)\n    ]\n    layer = Shapes(data, shape_type=\'polygon\')\n    new_layer = Shapes(layer.data, shape_type=\'polygon\')\n    assert np.all(\n        [np.all(nd == d) for nd, d in zip(new_layer.data, layer.data)]\n    )\n\n\ndef test_mixed_shapes():\n    """"""Test instantiating Shapes layer with a mix of random 2D shapes.""""""\n    # Test multiple polygons with different numbers of points\n    np.random.seed(0)\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(5)\n    ] + list(np.random.random((5, 4, 2)))\n    shape_type = [\'polygon\'] * 5 + [\'rectangle\'] * 3 + [\'ellipse\'] * 2\n    layer = Shapes(data, shape_type=shape_type)\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 2\n    assert np.all([s == so for s, so in zip(layer.shape_type, shape_type)])\n\n    # Test roundtrip with mixed data\n    new_layer = Shapes(layer.data, shape_type=layer.shape_type)\n    assert np.all(\n        [np.all(nd == d) for nd, d in zip(new_layer.data, layer.data)]\n    )\n    assert np.all(\n        [ns == s for ns, s in zip(new_layer.shape_type, layer.shape_type)]\n    )\n\n\ndef test_changing_shapes():\n    """"""Test changing Shapes data.""""""\n    shape_a = (10, 4, 2)\n    shape_b = (20, 4, 2)\n    np.random.seed(0)\n    data_a = 20 * np.random.random(shape_a)\n    data_b = 20 * np.random.random(shape_b)\n    layer = Shapes(data_a)\n    assert layer.nshapes == shape_a[0]\n    layer.data = data_b\n    assert layer.nshapes == shape_b[0]\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data_b)])\n    assert layer.ndim == shape_b[2]\n    assert np.all([s == \'rectangle\' for s in layer.shape_type])\n\n\ndef test_adding_shapes():\n    """"""Test adding shapes.""""""\n    # Start with polygons with different numbers of points\n    np.random.seed(0)\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(5)\n    ]\n    # shape_type = [\'polygon\'] * 5 + [\'rectangle\'] * 3 + [\'ellipse\'] * 2\n    layer = Shapes(data, shape_type=\'polygon\')\n    new_data = np.random.random((5, 4, 2))\n    new_shape_type = [\'rectangle\'] * 3 + [\'ellipse\'] * 2\n    layer.add(new_data, shape_type=new_shape_type)\n    all_data = data + list(new_data)\n    all_shape_type = [\'polygon\'] * 5 + new_shape_type\n    assert layer.nshapes == len(all_data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, all_data)])\n    assert layer.ndim == 2\n    assert np.all([s == so for s, so in zip(layer.shape_type, all_shape_type)])\n\n\ndef test_adding_shapes_to_empty():\n    """"""Test adding shapes to empty.""""""\n    data = np.empty((0, 0, 2))\n    np.random.seed(0)\n    layer = Shapes(np.empty((0, 0, 2)))\n    assert len(layer.data) == 0\n\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(5)\n    ] + list(np.random.random((5, 4, 2)))\n    shape_type = [\'path\'] * 5 + [\'rectangle\'] * 3 + [\'ellipse\'] * 2\n\n    layer.add(data, shape_type=shape_type)\n    assert layer.nshapes == len(data)\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer.ndim == 2\n    assert np.all([s == so for s, so in zip(layer.shape_type, shape_type)])\n\n\ndef test_selecting_shapes():\n    """"""Test selecting shapes.""""""\n    data = 20 * np.random.random((10, 4, 2))\n    np.random.seed(0)\n    layer = Shapes(data)\n    layer.selected_data = {0, 1}\n    assert layer.selected_data == {0, 1}\n\n    layer.selected_data = {9}\n    assert layer.selected_data == {9}\n\n    layer.selected_data = set()\n    assert layer.selected_data == set()\n\n\ndef test_removing_selected_shapes():\n    """"""Test removing selected shapes.""""""\n    np.random.seed(0)\n    data = [\n        20 * np.random.random((np.random.randint(2, 12), 2)) for i in range(5)\n    ] + list(np.random.random((5, 4, 2)))\n    shape_type = [\'polygon\'] * 5 + [\'rectangle\'] * 3 + [\'ellipse\'] * 2\n    layer = Shapes(data, shape_type=shape_type)\n\n    # With nothing selected no points should be removed\n    layer.remove_selected()\n    assert len(layer.data) == len(data)\n\n    # Select three shapes and remove them\n    layer.selected_data = {1, 7, 8}\n    layer.remove_selected()\n    keep = [0] + list(range(2, 7)) + [9]\n    data_keep = [data[i] for i in keep]\n    shape_type_keep = [shape_type[i] for i in keep]\n    assert len(layer.data) == len(data_keep)\n    assert len(layer.selected_data) == 0\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data_keep)])\n    assert layer.ndim == 2\n    assert np.all(\n        [s == so for s, so in zip(layer.shape_type, shape_type_keep)]\n    )\n\n\ndef test_changing_modes():\n    """"""Test changing modes.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 2))\n    layer = Shapes(data)\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n    layer.mode = \'select\'\n    assert layer.mode == \'select\'\n    assert layer.interactive is False\n\n    layer.mode = \'direct\'\n    assert layer.mode == \'direct\'\n    assert layer.interactive is False\n\n    layer.mode = \'vertex_insert\'\n    assert layer.mode == \'vertex_insert\'\n    assert layer.interactive is False\n\n    layer.mode = \'vertex_remove\'\n    assert layer.mode == \'vertex_remove\'\n    assert layer.interactive is False\n\n    layer.mode = \'add_rectangle\'\n    assert layer.mode == \'add_rectangle\'\n    assert layer.interactive is False\n\n    layer.mode = \'add_ellipse\'\n    assert layer.mode == \'add_ellipse\'\n    assert layer.interactive is False\n\n    layer.mode = \'add_line\'\n    assert layer.mode == \'add_line\'\n    assert layer.interactive is False\n\n    layer.mode = \'add_path\'\n    assert layer.mode == \'add_path\'\n    assert layer.interactive is False\n\n    layer.mode = \'add_polygon\'\n    assert layer.mode == \'add_polygon\'\n    assert layer.interactive is False\n\n    layer.mode = \'pan_zoom\'\n    assert layer.mode == \'pan_zoom\'\n    assert layer.interactive is True\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 2))\n    layer = Shapes(data)\n    assert layer.name == \'Shapes\'\n\n    layer = Shapes(data, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'shps\'\n    assert layer.name == \'shps\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 2))\n    layer = Shapes(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Shapes(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting opacity.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    # Check default opacity value of 0.7\n    assert layer.opacity == 0.7\n\n    # Select data and change opacity of selection\n    layer.selected_data = {0, 1}\n    assert layer.opacity == 0.7\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    # Add new shape and test its width\n    new_shape = np.random.random((1, 4, 2))\n    layer.selected_data = set()\n    layer.add(new_shape)\n    assert layer.opacity == 0.5\n\n    # Instantiate with custom opacity\n    layer2 = Shapes(data, opacity=0.2)\n    assert layer2.opacity == 0.2\n\n    # Check removing data shouldn\'t change opacity\n    layer2.selected_data = {0, 2}\n    layer2.remove_selected()\n    assert len(layer2.data) == shape[0] - 2\n    assert layer2.opacity == 0.2\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    np.random.seed(0)\n    data = 20 * np.random.random((10, 4, 2))\n    layer = Shapes(data)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Shapes(data, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\n@pytest.mark.parametrize(""attribute"", [\'edge\', \'face\'])\ndef test_color_direct(attribute: str):\n    """"""Test setting face/edge color directly.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer_kwargs = {f\'{attribute}_color\': \'black\'}\n    layer = Shapes(data, **layer_kwargs)\n    color_array = transform_color([\'black\'] * shape[0])\n\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert current_color == \'black\'\n    assert len(layer.edge_color) == shape[0]\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # With no data selected changing color has no effect\n    setattr(layer, f\'current_{attribute}_color\', \'blue\')\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    assert current_color == \'blue\'\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Select data and change edge color of selection\n    selected_data = {0, 1}\n    layer.selected_data = {0, 1}\n    current_color = getattr(layer, f\'current_{attribute}_color\')\n    assert current_color == \'black\'\n    setattr(layer, f\'current_{attribute}_color\', \'green\')\n    colorarray_green = transform_color([\'green\'] * len(layer.selected_data))\n    color_array[list(selected_data)] = colorarray_green\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Add new shape and test its color\n    new_shape = np.random.random((1, 4, 2))\n    layer.selected_data = set()\n    setattr(layer, f\'current_{attribute}_color\', \'blue\')\n    layer.add(new_shape)\n    color_array = np.vstack([color_array, transform_color(\'blue\')])\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] + 1\n    np.testing.assert_allclose(color_array, layer_color)\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    assert len(layer_color) == shape[0] - 1\n    np.testing.assert_allclose(\n        layer_color, np.vstack((color_array[1], color_array[3:])),\n    )\n\n    # set the color directly\n    setattr(layer, f\'{attribute}_color\', \'black\')\n    color_array = np.tile([[0, 0, 0, 1]], (len(layer.data), 1))\n    layer_color = getattr(layer, f\'{attribute}_color\')\n    np.testing.assert_allclose(color_array, layer_color)\n\n\ndef test_edge_width():\n    """"""Test setting edge width.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.current_edge_width == 1\n    assert len(layer.edge_width) == shape[0]\n    assert layer.edge_width == [1] * shape[0]\n\n    # With no data selected changing edge width has no effect\n    layer.current_edge_width = 2\n    assert layer.current_edge_width == 2\n    assert layer.edge_width == [1] * shape[0]\n\n    # Select data and change edge color of selection\n    layer.selected_data = {0, 1}\n    assert layer.current_edge_width == 1\n    layer.current_edge_width = 3\n    assert layer.edge_width == [3] * 2 + [1] * (shape[0] - 2)\n\n    # Add new shape and test its width\n    new_shape = np.random.random((1, 4, 2))\n    layer.selected_data = set()\n    layer.current_edge_width = 4\n    layer.add(new_shape)\n    assert layer.edge_width == [3] * 2 + [1] * (shape[0] - 2) + [4]\n\n    # Instantiate with custom edge width\n    layer = Shapes(data, edge_width=5)\n    assert layer.current_edge_width == 5\n\n    # Instantiate with custom edge width list\n    width_list = [2, 3] * 5\n    layer = Shapes(data, edge_width=width_list)\n    assert layer.current_edge_width == 1\n    assert layer.edge_width == width_list\n\n    # Add new shape and test its color\n    layer.current_edge_width = 4\n    layer.add(new_shape)\n    assert len(layer.edge_width) == shape[0] + 1\n    assert layer.edge_width == width_list + [4]\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n    assert len(layer.edge_width) == shape[0] - 1\n    assert layer.edge_width == [width_list[1]] + width_list[3:] + [4]\n\n\ndef test_z_index():\n    """"""Test setting z-index during instantiation.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer.z_index == [0] * shape[0]\n\n    # Instantiate with custom z-index\n    layer = Shapes(data, z_index=4)\n    assert layer.z_index == [4] * shape[0]\n\n    # Instantiate with custom z-index list\n    z_index_list = [2, 3] * 5\n    layer = Shapes(data, z_index=z_index_list)\n    assert layer.z_index == z_index_list\n\n    # Add new shape and its z-index\n    new_shape = np.random.random((1, 4, 2))\n    layer.add(new_shape)\n    assert len(layer.z_index) == shape[0] + 1\n    assert layer.z_index == z_index_list + [4]\n\n    # Check removing data adjusts colors correctly\n    layer.selected_data = {0, 2}\n    layer.remove_selected()\n    assert len(layer.data) == shape[0] - 1\n    assert len(layer.z_index) == shape[0] - 1\n    assert layer.z_index == [z_index_list[1]] + z_index_list[3:] + [4]\n\n\ndef test_move_to_front():\n    """"""Test moving shapes to front.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    z_index_list = [2, 3] * 5\n    layer = Shapes(data, z_index=z_index_list)\n    assert layer.z_index == z_index_list\n\n    # Move selected shapes to front\n    layer.selected_data = {0, 2}\n    layer.move_to_front()\n    assert layer.z_index == [4] + [z_index_list[1]] + [4] + z_index_list[3:]\n\n\ndef test_move_to_back():\n    """"""Test moving shapes to back.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    z_index_list = [2, 3] * 5\n    layer = Shapes(data, z_index=z_index_list)\n    assert layer.z_index == z_index_list\n\n    # Move selected shapes to front\n    layer.selected_data = {0, 2}\n    layer.move_to_back()\n    assert layer.z_index == [1] + [z_index_list[1]] + [1] + z_index_list[3:]\n\n\ndef test_interaction_box():\n    """"""Test the creation of the interaction box.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    assert layer._selected_box is None\n\n    layer.selected_data = {0}\n    assert len(layer._selected_box) == 10\n\n    layer.selected_data = {0, 1}\n    assert len(layer._selected_box) == 10\n\n    layer.selected_data = set()\n    assert layer._selected_box is None\n\n\ndef test_copy_and_paste():\n    """"""Test copying and pasting selected shapes.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    # Clipboard starts empty\n    assert layer._clipboard == {}\n\n    # Pasting empty clipboard doesn\'t change data\n    layer._paste_data()\n    assert len(layer.data) == 10\n\n    # Copying with nothing selected leave clipboard empty\n    layer._copy_data()\n    assert layer._clipboard == {}\n\n    # Copying and pasting with two shapes selected adds to clipboard and data\n    layer.selected_data = {0, 1}\n    layer._copy_data()\n    layer._paste_data()\n    assert len(layer._clipboard) == 4\n    assert len(layer.data) == shape[0] + 2\n    assert np.all(\n        [np.all(a == b) for a, b in zip(layer.data[:2], layer.data[-2:])]\n    )\n\n    # Pasting again adds two more points to data\n    layer._paste_data()\n    assert len(layer.data) == shape[0] + 4\n    assert np.all(\n        [np.all(a == b) for a, b in zip(layer.data[:2], layer.data[-2:])]\n    )\n\n    # Unselecting everything and copying and pasting will empty the clipboard\n    # and add no new data\n    layer.selected_data = set()\n    layer._copy_data()\n    layer._paste_data()\n    assert layer._clipboard == {}\n    assert len(layer.data) == shape[0] + 4\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[-1, :] = [[0, 0], [0, 10], [10, 0], [10, 10]]\n    layer = Shapes(data)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert value == (9, None)\n\n    layer.mode = \'select\'\n    layer.selected_data = {9}\n    value = layer.get_value()\n    assert value == (9, 7)\n\n    layer = Shapes(data + 5)\n    value = layer.get_value()\n    assert value == (None, None)\n\n\ndef test_message():\n    """"""Test converting values and coords to message.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    msg = layer.get_message()\n    assert type(msg) == str\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    data[-1, :] = [[0, 0], [0, 20], [20, 0], [20, 20]]\n    layer = Shapes(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_to_masks():\n    """"""Test the mask generation.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    masks = layer.to_masks()\n    assert masks.ndim == 3\n    assert len(masks) == shape[0]\n\n    masks = layer.to_masks(mask_shape=[20, 20])\n    assert masks.shape == (shape[0], 20, 20)\n\n\ndef test_to_labels():\n    """"""Test the labels generation.""""""\n    shape = (10, 4, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    layer = Shapes(data)\n    labels = layer.to_labels()\n    assert labels.ndim == 2\n    assert len(np.unique(labels)) <= 11\n\n    labels = layer.to_labels(labels_shape=[20, 20])\n    assert labels.shape == (20, 20)\n    assert len(np.unique(labels)) <= 11\n\n\ndef test_to_labels_3D():\n    """"""Test label generation for 3D data""""""\n    data = [\n        [[0, 100, 100], [0, 100, 200], [0, 200, 200], [0, 200, 100]],\n        [[1, 125, 125], [1, 125, 175], [1, 175, 175], [1, 175, 125]],\n        [[2, 100, 100], [2, 100, 200], [2, 200, 200], [2, 200, 100]],\n    ]\n    labels_shape = (3, 300, 300)\n    layer = Shapes(np.array(data), shape_type=\'polygon\')\n    labels = layer.to_labels(labels_shape=labels_shape)\n    assert np.all(labels.shape == labels_shape)\n    assert np.all(np.unique(labels) == [0, 1, 2, 3])\n'"
napari/layers/shapes/_tests/test_shapes_key_bindings.py,9,"b""import numpy as np\nfrom napari.layers import Shapes\nfrom napari.layers.shapes import _shapes_key_bindings as key_bindings\n\n\ndef test_lock_aspect_ratio():\n    # Test a single four corner rectangle\n    layer = Shapes(20 * np.random.random((1, 4, 2)))\n    layer._is_moving = True\n    # need to go through the generator\n    _ = list(key_bindings.hold_to_lock_aspect_ratio(layer))\n\n\ndef test_lock_aspect_ratio_selected_box():\n    # Test a single four corner rectangle\n    layer = Shapes(20 * np.random.random((1, 4, 2)))\n    # select a shape\n    layer._selected_box = layer.interaction_box(0)\n    layer._is_moving = True\n    # need to go through the generator\n    _ = list(key_bindings.hold_to_lock_aspect_ratio(layer))\n\n\ndef test_lock_aspect_ratio_selected_box_zeros():\n    # Test a single four corner rectangle that has zero size\n    layer = Shapes(20 * np.zeros((1, 4, 2)))\n    # select a shape\n    layer._selected_box = layer.interaction_box(0)\n    layer._is_moving = True\n    # need to go through the generator\n    _ = list(key_bindings.hold_to_lock_aspect_ratio(layer))\n\n\ndef test_hold_to_pan_zoom():\n    # Test a single four corner rectangle\n    layer = Shapes(20 * np.random.random((1, 4, 2)))\n    layer.mode = 'direct'\n    # need to go through the generator\n    _ = list(key_bindings.hold_to_pan_zoom(layer))\n\n\ndef test_activate_modes():\n    # Test a single four corner rectangle\n    layer = Shapes(20 * np.random.random((1, 4, 2)))\n    # need to go through the generator\n    key_bindings.activate_add_rectangle_mode(layer)\n    assert layer.mode == 'add_rectangle'\n    key_bindings.activate_add_ellipse_mode(layer)\n    assert layer.mode == 'add_ellipse'\n    key_bindings.activate_add_line_mode(layer)\n    assert layer.mode == 'add_line'\n    key_bindings.activate_add_path_mode(layer)\n    assert layer.mode == 'add_path'\n    key_bindings.activate_add_polygon_mode(layer)\n    assert layer.mode == 'add_polygon'\n    key_bindings.activate_direct_mode(layer)\n    assert layer.mode == 'direct'\n    key_bindings.activate_select_mode(layer)\n    assert layer.mode == 'select'\n    key_bindings.activate_pan_zoom_mode(layer)\n    assert layer.mode == 'pan_zoom'\n    key_bindings.activate_vertex_insert_mode(layer)\n    assert layer.mode == 'vertex_insert'\n    key_bindings.activate_vertex_remove_mode(layer)\n    assert layer.mode == 'vertex_remove'\n\n\ndef test_copy_paste():\n    # Test on three four corner rectangle\n    layer = Shapes(20 * np.random.random((3, 4, 2)))\n    layer.mode = 'direct'\n\n    assert len(layer.data) == 3\n    assert layer._clipboard == {}\n    layer.selected_data = {0, 1}\n\n    key_bindings.copy(layer)\n    assert len(layer.data) == 3\n    assert len(layer._clipboard) == 4\n\n    key_bindings.paste(layer)\n    assert len(layer.data) == 5\n    assert len(layer._clipboard) == 4\n\n\ndef test_select_all():\n    # Test on three four corner rectangle\n    layer = Shapes(20 * np.random.random((3, 4, 2)))\n    layer.mode = 'direct'\n\n    assert len(layer.data) == 3\n    assert len(layer.selected_data) == 0\n\n    key_bindings.select_all(layer)\n    assert len(layer.selected_data) == 3\n\n\ndef test_delete():\n    # Test on three four corner rectangle\n    layer = Shapes(20 * np.random.random((3, 4, 2)))\n    layer.mode = 'direct'\n\n    assert len(layer.data) == 3\n    layer.selected_data = {0, 1}\n\n    key_bindings.delete_selected(layer)\n    assert len(layer.data) == 1\n\n\ndef test_finish():\n    # Test on three four corner rectangle\n    layer = Shapes(20 * np.random.random((3, 4, 2)))\n    key_bindings.finish_drawing(layer)\n"""
napari/layers/shapes/_tests/test_shapes_mouse_bindings.py,10,"b'import numpy as np\nimport pytest\nimport collections\nfrom napari.layers import Shapes\nfrom napari.utils.interactions import (\n    ReadOnlyWrapper,\n    mouse_press_callbacks,\n    mouse_move_callbacks,\n    mouse_release_callbacks,\n)\n\n\n@pytest.fixture\ndef Event():\n    """"""Create a subclass for simulating vispy mouse events.\n\n    Returns\n    -------\n    Event : Type\n        A new tuple subclass named Event that can be used to create a\n        NamedTuple object with fields ""type"", ""is_dragging"", and ""modifiers"".\n    """"""\n    return collections.namedtuple(\n        \'Event\', field_names=[\'type\', \'is_dragging\', \'modifiers\']\n    )\n\n\n@pytest.fixture\ndef create_known_shapes_layer():\n    """"""Create shapes layer with known coordinates\n\n    Returns\n    -------\n    layer : napar.layers.Shapes\n        Shapes layer.\n    n_shapes : int\n        Number of shapes in the shapes layer\n    known_non_shape : list\n        Data coordinates that are known to contain no shapes. Useful during\n        testing when needing to guarantee no shape is clicked on.\n    """"""\n    data = [[[1, 3], [8, 4]], [[10, 10], [15, 4]]]\n    known_non_shape = [20, 30]\n    n_shapes = len(data)\n\n    layer = Shapes(data)\n    assert layer.ndim == 2\n    assert len(layer.data) == n_shapes\n    assert len(layer.selected_data) == 0\n\n    return layer, n_shapes, known_non_shape\n\n\ndef test_not_adding_or_selecting_shape(create_known_shapes_layer, Event):\n    """"""Don\'t add or select a shape by clicking on one in pan_zoom mode.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n    layer.mode = \'pan_zoom\'\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no new shape added and non selected\n    assert len(layer.data) == n_shapes\n    assert len(layer.selected_data) == 0\n\n\n@pytest.mark.parametrize(\'shape_type\', [\'rectangle\', \'ellipse\', \'line\'])\ndef test_add_simple_shape(shape_type, create_known_shapes_layer, Event):\n    """"""Add simple shape by clicking in add mode.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    # Add shape at location where non exists\n    layer.mode = \'add_\' + shape_type\n    layer.position = known_non_shape\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    known_non_shape_end = [40, 60]\n    layer.position = known_non_shape_end\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check new shape added at coordinates\n    assert len(layer.data) == n_shapes + 1\n    np.testing.assert_allclose(layer.data[-1][0], known_non_shape)\n    new_shape_max = np.max(layer.data[-1], axis=0)\n    np.testing.assert_allclose(new_shape_max, known_non_shape_end)\n    assert layer.shape_type[-1] == shape_type\n\n\n@pytest.mark.parametrize(\'shape_type\', [\'path\', \'polygon\'])\ndef test_add_complex_shape(shape_type, create_known_shapes_layer, Event):\n    """"""Add simple shape by clicking in add mode.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    desired_shape = [[20, 30], [10, 50], [60, 40], [80, 20]]\n    # Add shape at location where non exists\n    layer.mode = \'add_\' + shape_type\n    layer.position = desired_shape[0]\n\n    for coord in desired_shape:\n        layer.position = coord\n        # Simulate move, click, and release\n        event = ReadOnlyWrapper(\n            Event(type=\'mouse_move\', is_dragging=False, modifiers=[])\n        )\n        mouse_move_callbacks(layer, event)\n        event = ReadOnlyWrapper(\n            Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n        )\n        mouse_press_callbacks(layer, event)\n        event = ReadOnlyWrapper(\n            Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n        )\n        mouse_release_callbacks(layer, event)\n\n    # finish drawing\n    layer._finish_drawing()\n\n    # Check new shape added at coordinates\n    assert len(layer.data) == n_shapes + 1\n    np.testing.assert_allclose(layer.data[-1], desired_shape)\n    assert layer.shape_type[-1] == shape_type\n\n\ndef test_vertex_insert(create_known_shapes_layer, Event):\n    """"""Add vertex to shape.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    n_coord = len(layer.data[0])\n    layer.mode = \'vertex_insert\'\n    layer.selected_data = {0}\n    layer.position = known_non_shape\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Check new shape added at coordinates\n    assert len(layer.data) == n_shapes\n    assert len(layer.data[0]) == n_coord + 1\n    np.testing.assert_allclose(\n        np.min(abs(layer.data[0] - known_non_shape), axis=0), [0, 0]\n    )\n\n\ndef test_vertex_remove(create_known_shapes_layer, Event):\n    """"""Remove vertex from shape.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    n_coord = len(layer.data[0])\n    layer.mode = \'vertex_remove\'\n    layer.selected_data = {0}\n    layer.position = tuple(layer.data[0][0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Check new shape added at coordinates\n    assert len(layer.data) == n_shapes\n    assert len(layer.data[0]) == n_coord - 1\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_select_shape(mode, create_known_shapes_layer, Event):\n    """"""Select a shape by clicking on one in select mode.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = tuple(layer.data[0][0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 1\n    assert layer.selected_data == {0}\n\n\ndef test_drag_shape(create_known_shapes_layer, Event):\n    """"""Select and drag vertex.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n\n    layer.mode = \'select\'\n    orig_data = layer.data[0].copy()\n    assert len(layer.selected_data) == 0\n\n    layer.position = tuple(np.mean(layer.data[0], axis=0))\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    assert len(layer.selected_data) == 1\n    assert layer.selected_data == {0}\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=True, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n    # start drag event\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n    layer.position = tuple(np.add(layer.position, [10, 5]))\n    # Simulate move, click, and release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 1\n    assert layer.selected_data == {0}\n    np.testing.assert_allclose(layer.data[0], orig_data + [10, 5])\n\n\ndef test_drag_vertex(create_known_shapes_layer, Event):\n    """"""Select and drag vertex.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n\n    layer.mode = \'direct\'\n    layer.selected_data = {0}\n    layer.position = tuple(layer.data[0][0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    layer.position = [0, 0]\n    # Simulate move, click, and release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 1\n    assert layer.selected_data == {0}\n    np.testing.assert_allclose(layer.data[0][-1], [0, 0])\n\n\n@pytest.mark.parametrize(\n    \'mode\',\n    [\n        \'select\',\n        \'direct\',\n        \'add_rectangle\',\n        \'add_ellipse\',\n        \'add_line\',\n        \'add_polygon\',\n        \'add_path\',\n        \'vertex_insert\',\n        \'vertex_remove\',\n    ],\n)\ndef test_after_in_add_mode_shape(mode, create_known_shapes_layer, Event):\n    """"""Don\'t add or select a shape by clicking on one in pan_zoom mode.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.mode = \'pan_zoom\'\n    layer.position = tuple(layer.data[0][0])\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no new shape added and non selected\n    assert len(layer.data) == n_shapes\n    assert len(layer.selected_data) == 0\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_unselect_select_shape(mode, create_known_shapes_layer, Event):\n    """"""Select a shape by clicking on one in select mode.""""""\n    layer, n_shapes, _ = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = tuple(layer.data[0][0])\n    layer.selected_data = {1}\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 1\n    assert layer.selected_data == {0}\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_not_selecting_shape(mode, create_known_shapes_layer, Event):\n    """"""Don\'t select a shape by not clicking on one in select mode.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = known_non_shape\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 0\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_unselecting_shapes(mode, create_known_shapes_layer, Event):\n    """"""Unselect shapes by not clicking on one in select mode.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = known_non_shape\n    layer.selected_data = {0, 1}\n    assert len(layer.selected_data) == 2\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=False, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check clicked shape selected\n    assert len(layer.selected_data) == 0\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_selecting_shapes_with_drag(mode, create_known_shapes_layer, Event):\n    """"""Select all shapes when drag box includes all of them.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = known_non_shape\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag start\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    layer.position = [0, 0]\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check all shapes selected as drag box contains them\n    assert len(layer.selected_data) == n_shapes\n\n\n@pytest.mark.parametrize(\'mode\', [\'select\', \'direct\'])\ndef test_selecting_no_shapes_with_drag(mode, create_known_shapes_layer, Event):\n    """"""Select all shapes when drag box includes all of them.""""""\n    layer, n_shapes, known_non_shape = create_known_shapes_layer\n\n    layer.mode = mode\n    layer.position = known_non_shape\n\n    # Simulate click\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_press\', is_dragging=False, modifiers=[])\n    )\n    mouse_press_callbacks(layer, event)\n\n    # Simulate drag start\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    layer.position = [50, 60]\n    # Simulate drag end\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_move\', is_dragging=True, modifiers=[])\n    )\n    mouse_move_callbacks(layer, event)\n\n    # Simulate release\n    event = ReadOnlyWrapper(\n        Event(type=\'mouse_release\', is_dragging=True, modifiers=[])\n    )\n    mouse_release_callbacks(layer, event)\n\n    # Check no shapes selected as drag box doesn\'t contain them\n    assert len(layer.selected_data) == 0\n'"
napari/layers/surface/_tests/test_surface.py,36,"b'import numpy as np\nfrom napari.layers import Surface\n\n\ndef test_random_surface():\n    """"""Test instantiating Surface layer with random 2D data.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 2))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.ndim == 2\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert np.all(layer.vertices == vertices)\n    assert np.all(layer.faces == faces)\n    assert np.all(layer.vertex_values == values)\n    assert layer._data_view.shape[1] == 2\n    assert layer._view_vertex_values.ndim == 1\n\n\ndef test_random_3D_surface():\n    """"""Test instantiating Surface layer with random 3D data.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.ndim == 3\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer._data_view.shape[1] == 2\n    assert layer._view_vertex_values.ndim == 1\n\n    layer.dims.ndisplay = 3\n    assert layer._data_view.shape[1] == 3\n    assert layer._view_vertex_values.ndim == 1\n\n\ndef test_random_4D_surface():\n    """"""Test instantiating Surface layer with random 4D data.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 4))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.ndim == 4\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer._data_view.shape[1] == 2\n    assert layer._view_vertex_values.ndim == 1\n\n    layer.dims.ndisplay = 3\n    assert layer._data_view.shape[1] == 3\n    assert layer._view_vertex_values.ndim == 1\n\n\ndef test_random_3D_timeseries_surface():\n    """"""Test instantiating Surface layer with random 3D timeseries data.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random((22, 10))\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.ndim == 4\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer._data_view.shape[1] == 2\n    assert layer._view_vertex_values.ndim == 1\n    assert layer.shape[0] == 22\n\n    layer.dims.ndisplay = 3\n    assert layer._data_view.shape[1] == 3\n    assert layer._view_vertex_values.ndim == 1\n\n    # If a values axis is made to be a displayed axis then no data should be\n    # shown\n    layer.dims.order = [3, 0, 1, 2]\n    assert len(layer._data_view) == 0\n\n\ndef test_random_3D_multitimeseries_surface():\n    """"""Test instantiating Surface layer with random 3D multitimeseries data.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random((16, 22, 10))\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.ndim == 5\n    assert np.all([np.all(ld == d) for ld, d in zip(layer.data, data)])\n    assert layer._data_view.shape[1] == 2\n    assert layer._view_vertex_values.ndim == 1\n    assert layer.shape[0] == 16\n    assert layer.shape[1] == 22\n\n    layer.dims.ndisplay = 3\n    assert layer._data_view.shape[1] == 3\n    assert layer._view_vertex_values.ndim == 1\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Surface(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_surface_gamma():\n    """"""Test setting gamma.""""""\n    np.random.seed(0)\n    vertices = np.random.random((10, 3))\n    faces = np.random.randint(10, size=(6, 3))\n    values = np.random.random(10)\n    data = (vertices, faces, values)\n    layer = Surface(data)\n    assert layer.gamma == 1\n\n    # Change gamma property\n    gamma = 0.7\n    layer.gamma = gamma\n    assert layer.gamma == gamma\n\n    # Set gamma as keyword argument\n    layer = Surface(data, gamma=gamma)\n    assert layer.gamma == gamma\n'"
napari/layers/utils/_tests/test_color_transforms.py,23,"b'from itertools import cycle\n\nimport pytest\nimport numpy as np\nfrom vispy.color import ColorArray\n\nfrom napari.layers.utils.color_transformations import (\n    transform_color_with_defaults,\n    normalize_and_broadcast_colors,\n    transform_color_cycle,\n)\n\n\ndef test_transform_color_basic():\n    """"""Test inner method with the same name.""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    colorarray = transform_color_with_defaults(\n        num_entries=len(data),\n        colors=\'r\',\n        elem_name=\'edge_color\',\n        default=\'black\',\n    )\n    np.testing.assert_array_equal(colorarray, ColorArray(\'r\').rgba)\n\n\ndef test_transform_color_wrong_colorname():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    with pytest.warns(UserWarning):\n        colorarray = transform_color_with_defaults(\n            num_entries=len(data),\n            colors=\'rr\',\n            elem_name=\'edge_color\',\n            default=\'black\',\n        )\n    np.testing.assert_array_equal(colorarray, ColorArray(\'black\').rgba)\n\n\ndef test_transform_color_wrong_colorlen():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    with pytest.warns(UserWarning):\n        colorarray = transform_color_with_defaults(\n            num_entries=len(data),\n            colors=[\'r\', \'r\'],\n            elem_name=\'face_color\',\n            default=\'black\',\n        )\n    np.testing.assert_array_equal(colorarray, ColorArray(\'black\').rgba)\n\n\ndef test_normalize_colors_basic():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    colors = ColorArray([\'w\'] * shape[0]).rgba\n    colorarray = normalize_and_broadcast_colors(len(data), colors)\n    np.testing.assert_array_equal(colorarray, colors)\n\n\ndef test_normalize_colors_wrong_num():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    colors = ColorArray([\'w\'] * shape[0]).rgba\n    with pytest.warns(UserWarning):\n        colorarray = normalize_and_broadcast_colors(len(data), colors[:-1])\n    np.testing.assert_array_equal(colorarray, colors)\n\n\ndef test_normalize_colors_zero_colors():\n    shape = (10, 2)\n    np.random.seed(0)\n    data = 20 * np.random.random(shape)\n    real = np.ones((shape[0], 4), dtype=np.float32)\n    with pytest.warns(UserWarning):\n        colorarray = normalize_and_broadcast_colors(len(data), [])\n    np.testing.assert_array_equal(colorarray, real)\n\n\ndef test_transform_color_cycle():\n    colors = [\'red\', \'blue\']\n    transformed_color_cycle, transformed_colors = transform_color_cycle(\n        colors, elem_name=\'face_color\', default=\'white\'\n    )\n    transformed_result = np.array(\n        [next(transformed_color_cycle) for i in range(10)]\n    )\n\n    color_cycle = cycle(np.array([[1, 0, 0, 1], [0, 0, 1, 1]]))\n    color_cycle_result = np.array([next(color_cycle) for i in range(10)])\n\n    np.testing.assert_allclose(transformed_result, color_cycle_result)\n'"
napari/layers/utils/_tests/test_layer_utils.py,25,"b""import numpy as np\nimport pandas as pd\nimport pytest\nfrom dask import array as da\n\nfrom napari.layers.utils.layer_utils import (\n    calc_data_range,\n    dataframe_to_properties,\n    guess_continuous,\n    segment_normal,\n)\n\ndata_dask = da.random.random(\n    size=(100_000, 1000, 1000), chunks=(1, 1000, 1000)\n)\n\n\ndef test_calc_data_range():\n    # all zeros should return [0, 1] by default\n    data = np.zeros((10, 10))\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 1])\n\n    # all ones should return [0, 1] by default\n    data = np.ones((10, 10))\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 1])\n\n    # return min and max\n    data = np.random.random((10, 15))\n    data[0, 0] = 0\n    data[0, 1] = 2\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 2])\n\n    # return min and max\n    data = np.random.random((6, 10, 15))\n    data[0, 0, 0] = 0\n    data[0, 0, 1] = 2\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 2])\n\n    # Try large data\n    data = np.zeros((1000, 2000))\n    data[0, 0] = 0\n    data[0, 1] = 2\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 2])\n\n    # Try large data mutlidimensional\n    data = np.zeros((3, 1000, 1000))\n    data[0, 0, 0] = 0\n    data[0, 0, 1] = 2\n    clim = calc_data_range(data)\n    assert np.all(clim == [0, 2])\n\n\ndef test_calc_data_fast_uint8():\n    data = da.random.randint(\n        0,\n        100,\n        size=(100_000, 1000, 1000),\n        chunks=(1, 1000, 1000),\n        dtype=np.uint8,\n    )\n    assert calc_data_range(data) == [0, 255]\n\n\n@pytest.mark.timeout(2)\ndef test_calc_data_range_fast_big():\n    val = calc_data_range(data_dask)\n    assert len(val) > 0\n\n\ndef test_segment_normal_2d():\n    a = np.array([1, 1])\n    b = np.array([1, 10])\n\n    unit_norm = segment_normal(a, b)\n    assert np.all(unit_norm == np.array([1, 0]))\n\n\ndef test_segment_normal_3d():\n    a = np.array([1, 1, 0])\n    b = np.array([1, 10, 0])\n    p = np.array([1, 0, 0])\n\n    unit_norm = segment_normal(a, b, p)\n    assert np.all(unit_norm == np.array([0, 0, -1]))\n\n\ndef test_dataframe_to_properties():\n    properties = {'point_type': np.array(['A', 'B'] * 5)}\n    properties_df = pd.DataFrame(properties)\n    converted_properties, _ = dataframe_to_properties(properties_df)\n    np.testing.assert_equal(converted_properties, properties)\n\n\ndef test_guess_continuous():\n    continuous_annotation = np.array([1, 2, 3], dtype=np.float32)\n    assert guess_continuous(continuous_annotation)\n\n    categorical_annotation_1 = np.array([True, False], dtype=np.bool)\n    assert not guess_continuous(categorical_annotation_1)\n\n    categorical_annotation_2 = np.array([1, 2, 3], dtype=np.int)\n    assert not guess_continuous(categorical_annotation_2)\n"""
napari/layers/vectors/_tests/test_vectors.py,99,"b'import numpy as np\nimport pandas as pd\nimport pytest\nfrom vispy.color import get_colormap\n\nfrom napari.layers import Vectors\nfrom napari.utils.colormaps.standardize_color import transform_color\n\n# Set random seed for testing\nnp.random.seed(0)\n\n\ndef test_random_vectors():\n    """"""Test instantiating Vectors layer with random coordinate-like 2D data.""""""\n    shape = (10, 2, 2)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert np.all(layer.data == data)\n    assert layer.data.shape == shape\n    assert layer.ndim == shape[2]\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_random_vectors_image():\n    """"""Test instantiating Vectors layer with random image-like 2D data.""""""\n    shape = (20, 10, 2)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Vectors(data)\n    assert layer.data.shape == (20 * 10, 2, 2)\n    assert layer.ndim == 2\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_empty_vectors():\n    """"""Test instantiating Vectors layer with empty coordinate-like 2D data.""""""\n    shape = (0, 2, 2)\n    data = np.empty(shape)\n    layer = Vectors(data)\n    assert np.all(layer.data == data)\n    assert layer.data.shape == shape\n    assert layer.ndim == shape[2]\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_empty_vectors_with_properties():\n    """"""Test instantiating Vectors layer with empty coordinate-like 2D data.""""""\n    shape = (0, 2, 2)\n    data = np.empty(shape)\n    properties = {\'angle\': np.array([0.5], dtype=np.float)}\n    layer = Vectors(data, properties=properties)\n    assert np.all(layer.data == data)\n    assert layer.data.shape == shape\n    assert layer.ndim == shape[2]\n    assert layer._view_data.shape[2] == 2\n    np.testing.assert_equal(layer._property_choices, properties)\n\n\ndef test_empty_layer_with_edge_colormap():\n    """""" Test creating an empty layer where the edge color is a colormap\n    """"""\n    shape = (0, 2, 2)\n    data = np.empty(shape)\n    default_properties = {\'angle\': np.array([1.5], dtype=np.float)}\n    layer = Vectors(\n        data=data,\n        properties=default_properties,\n        edge_color=\'angle\',\n        edge_colormap=\'grays\',\n    )\n\n    assert layer.edge_color_mode == \'colormap\'\n\n    # edge_color should remain empty when refreshing colors\n    layer.refresh_colors(update_color_mapping=True)\n    np.testing.assert_equal(layer.edge_color, np.empty((0, 4)))\n\n\ndef test_empty_layer_with_edge_color_cycle():\n    """""" Test creating an empty layer where the edge color is a color cycle\n    """"""\n    shape = (0, 2, 2)\n    data = np.empty(shape)\n    default_properties = {\'vector_type\': np.array([\'A\'])}\n    layer = Vectors(\n        data=data, properties=default_properties, edge_color=\'vector_type\',\n    )\n\n    assert layer.edge_color_mode == \'cycle\'\n\n    # edge_color should remain empty when refreshing colors\n    layer.refresh_colors(update_color_mapping=True)\n    np.testing.assert_equal(layer.edge_color, np.empty((0, 4)))\n\n\ndef test_random_3D_vectors():\n    """"""Test instantiating Vectors layer with random coordinate-like 3D data.""""""\n    shape = (10, 2, 3)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert np.all(layer.data == data)\n    assert layer.data.shape == shape\n    assert layer.ndim == shape[2]\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_random_3D_vectors_image():\n    """"""Test instantiating Vectors layer with random image-like 3D data.""""""\n    shape = (12, 20, 10, 3)\n    np.random.seed(0)\n    data = np.random.random(shape)\n    layer = Vectors(data)\n    assert layer.data.shape == (12 * 20 * 10, 2, 3)\n    assert layer.ndim == 3\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_empty_3D_vectors():\n    """"""Test instantiating Vectors layer with empty coordinate-like 3D data.""""""\n    shape = (0, 2, 3)\n    data = np.empty(shape)\n    layer = Vectors(data)\n    assert np.all(layer.data == data)\n    assert layer.data.shape == shape\n    assert layer.ndim == shape[2]\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_properties_dataframe():\n    """"""test if properties can be provided as a DataFrame""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\'vector_type\': np.array([\'A\', \'B\'] * int(shape[0] / 2))}\n    properties_df = pd.DataFrame(properties)\n    properties_df = properties_df.astype(properties[\'vector_type\'].dtype)\n    layer = Vectors(data, properties=properties_df)\n    np.testing.assert_equal(layer.properties, properties)\n\n    # test adding a dataframe via the properties setter\n    properties_2 = {\'vector_type2\': np.array([\'A\', \'B\'] * int(shape[0] / 2))}\n    properties_df2 = pd.DataFrame(properties_2)\n    layer.properties = properties_df2\n    np.testing.assert_equal(layer.properties, properties_2)\n\n\ndef test_adding_properties():\n    """"""test adding properties to a Vectors layer""""""\n    shape = (10, 2)\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\'vector_type\': np.array([\'A\', \'B\'] * int(shape[0] / 2))}\n    layer = Vectors(data)\n\n    # properties should start empty\n    assert layer.properties == {}\n\n    # add properties\n    layer.properties = properties\n    np.testing.assert_equal(layer.properties, properties)\n\n    # removing a property that was the _edge_color_property should give a warning\n    layer._edge_color_property = \'vector_type\'\n    properties_2 = {\n        \'not_vector_type\': np.array([\'A\', \'B\'] * int(shape[0] / 2))\n    }\n    with pytest.warns(UserWarning):\n        layer.properties = properties_2\n\n    # adding properties with the wrong length should raise an exception\n    bad_properties = {\'vector_type\': np.array([\'A\'])}\n    with pytest.raises(ValueError):\n        layer.properties = bad_properties\n\n\ndef test_changing_data():\n    """"""Test changing Vectors data.""""""\n    shape_a = (10, 2, 2)\n    np.random.seed(0)\n    data_a = np.random.random(shape_a)\n    data_a[:, 0, :] = 20 * data_a[:, 0, :]\n    shape_b = (16, 2, 2)\n    data_b = np.random.random(shape_b)\n    data_b[:, 0, :] = 20 * data_b[:, 0, :]\n    layer = Vectors(data_b)\n    layer.data = data_b\n    assert np.all(layer.data == data_b)\n    assert layer.data.shape == shape_b\n    assert layer.ndim == shape_b[2]\n    assert layer._view_data.shape[2] == 2\n\n\ndef test_name():\n    """"""Test setting layer name.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.name == \'Vectors\'\n\n    layer = Vectors(data, name=\'random\')\n    assert layer.name == \'random\'\n\n    layer.name = \'vcts\'\n    assert layer.name == \'vcts\'\n\n\ndef test_visiblity():\n    """"""Test setting layer visiblity.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.visible is True\n\n    layer.visible = False\n    assert layer.visible is False\n\n    layer = Vectors(data, visible=False)\n    assert layer.visible is False\n\n    layer.visible = True\n    assert layer.visible is True\n\n\ndef test_opacity():\n    """"""Test setting layer opacity.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.opacity == 0.7\n\n    layer.opacity = 0.5\n    assert layer.opacity == 0.5\n\n    layer = Vectors(data, opacity=0.6)\n    assert layer.opacity == 0.6\n\n    layer.opacity = 0.3\n    assert layer.opacity == 0.3\n\n\ndef test_blending():\n    """"""Test setting layer blending.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.blending == \'translucent\'\n\n    layer.blending = \'additive\'\n    assert layer.blending == \'additive\'\n\n    layer = Vectors(data, blending=\'additive\')\n    assert layer.blending == \'additive\'\n\n    layer.blending = \'opaque\'\n    assert layer.blending == \'opaque\'\n\n\ndef test_edge_width():\n    """"""Test setting edge width.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.edge_width == 1\n\n    layer.edge_width = 2\n    assert layer.edge_width == 2\n\n    layer = Vectors(data, edge_width=3)\n    assert layer.edge_width == 3\n\n\ndef test_invalid_edge_color():\n    """"""Test providing an invalid edge color raises an exception""""""\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n\n    with pytest.raises(ValueError):\n        layer.edge_color = 5\n\n\ndef test_edge_color_direct():\n    """"""Test setting edge color.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    np.testing.assert_allclose(\n        layer.edge_color, np.repeat([[1, 0, 0, 1]], data.shape[0], axis=0)\n    )\n\n    # set edge color as an RGB array\n    layer.edge_color = [0, 0, 1]\n    np.testing.assert_allclose(\n        layer.edge_color, np.repeat([[0, 0, 1, 1]], data.shape[0], axis=0)\n    )\n\n    # set edge color as an RGBA array\n    layer.edge_color = [0, 1, 0, 0.5]\n    np.testing.assert_allclose(\n        layer.edge_color, np.repeat([[0, 1, 0, 0.5]], data.shape[0], axis=0)\n    )\n\n    # set all edge colors directly\n    edge_colors = np.random.random((data.shape[0], 4))\n    layer.edge_color = edge_colors\n    np.testing.assert_allclose(layer.edge_color, edge_colors)\n\n\ndef test_edge_color_cycle():\n    """"""Test creating Vectors where edge color is set by a color cycle""""""\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\'vector_type\': np.array([\'A\', \'B\'] * int((shape[0] / 2)))}\n    color_cycle = [\'red\', \'blue\']\n    layer = Vectors(\n        data,\n        properties=properties,\n        edge_color=\'vector_type\',\n        edge_color_cycle=color_cycle,\n    )\n    np.testing.assert_equal(layer.properties, properties)\n    edge_color_array = transform_color(color_cycle * int((shape[0] / 2)))\n    assert np.all(layer.edge_color == edge_color_array)\n\n\ndef test_edge_color_colormap():\n    """"""Test creating Vectors where edge color is set by a colormap """"""\n    shape = (10, 2)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\'angle\': np.array([0, 1.5] * int((shape[0] / 2)))}\n    layer = Vectors(\n        data, properties=properties, edge_color=\'angle\', edge_colormap=\'gray\',\n    )\n    assert layer.properties == properties\n    assert layer.edge_color_mode == \'colormap\'\n    edge_color_array = transform_color(\n        [\'black\', \'white\'] * int((shape[0] / 2))\n    )\n    assert np.all(layer.edge_color == edge_color_array)\n\n    # change the color cycle - edge_color should not change\n    layer.edge_color_cycle = [\'red\', \'blue\']\n    assert np.all(layer.edge_color == edge_color_array)\n\n    # adjust the clims\n    layer.edge_contrast_limits = (0, 3)\n    layer.refresh_colors(update_color_mapping=False)\n    np.testing.assert_allclose(layer.edge_color[-1], [0.5, 0.5, 0.5, 1])\n\n    # change the colormap\n    new_colormap = \'viridis\'\n    layer.edge_colormap = new_colormap\n    assert layer.edge_colormap[1] == get_colormap(new_colormap)\n\n    # test adding a colormap with a vispy Colormap object\n    layer.edge_colormap = get_colormap(\'gray\')\n    assert \'unnamed colormap\' in layer.edge_colormap[0]\n\n\ndef test_edge_color_map_non_numeric_property():\n    """"""Test setting edge_color as a color map of a\n    non-numeric property raises an error\n    """"""\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\'vector_type\': np.array([\'A\', \'B\'] * int((shape[0] / 2)))}\n    color_cycle = [\'red\', \'blue\']\n    initial_color = [0, 1, 0, 1]\n    layer = Vectors(\n        data,\n        properties=properties,\n        edge_color=initial_color,\n        edge_color_cycle=color_cycle,\n        edge_colormap=\'gray\',\n    )\n    # layer should start out in direct edge color mode with all green vectors\n    assert layer.edge_color_mode == \'direct\'\n    np.testing.assert_allclose(\n        layer.edge_color, np.repeat([initial_color], shape[0], axis=0)\n    )\n\n    # switching to colormap mode should raise an error because the \'vector_type\' is non-numeric\n    layer.edge_color = \'vector_type\'\n    with pytest.raises(TypeError):\n        layer.edge_color_mode = \'colormap\'\n\n\ndef test_switching_edge_color_mode():\n    """"""Test transitioning between all color modes""""""\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    properties = {\n        \'magnitude\': np.arange(shape[0]),\n        \'vector_type\': np.array([\'A\', \'B\'] * int((shape[0] / 2))),\n    }\n    color_cycle = [\'red\', \'blue\']\n    initial_color = [0, 1, 0, 1]\n    layer = Vectors(\n        data,\n        properties=properties,\n        edge_color=initial_color,\n        edge_color_cycle=color_cycle,\n        edge_colormap=\'gray\',\n    )\n    # layer should start out in direct edge color mode with all green vectors\n    assert layer.edge_color_mode == \'direct\'\n    np.testing.assert_allclose(\n        layer.edge_color, np.repeat([initial_color], shape[0], axis=0)\n    )\n\n    # there should not be an edge_color_property\n    assert layer._edge_color_property == \'\'\n\n    # transitioning to colormap should raise a warning\n    # because there isn\'t an edge color property yet and\n    # the first property in Vectors.properties is being automatically selected\n    with pytest.warns(RuntimeWarning):\n        layer.edge_color_mode = \'colormap\'\n    assert layer._edge_color_property == next(iter(properties))\n    np.testing.assert_allclose(layer.edge_color[-1], [1, 1, 1, 1])\n\n    # switch to color cycle\n    layer.edge_color_mode = \'cycle\'\n    layer.edge_color = \'vector_type\'\n    edge_color_array = transform_color(color_cycle * int((shape[0] / 2)))\n    np.testing.assert_allclose(layer.edge_color, edge_color_array)\n\n    # switch back to direct, edge_colors shouldn\'t change\n    edge_colors = layer.edge_color\n    layer.edge_color_mode = \'direct\'\n    np.testing.assert_allclose(layer.edge_color, edge_colors)\n\n\ndef test_properties_color_mode_without_properties():\n    """"""Test that switching to a colormode requiring\n    properties without properties defined raises an exceptions\n    """"""\n    np.random.seed(0)\n    shape = (10, 2, 2)\n    data = np.random.random(shape)\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.properties == {}\n\n    with pytest.raises(ValueError):\n        layer.edge_color_mode = \'colormap\'\n\n    with pytest.raises(ValueError):\n        layer.edge_color_mode = \'cycle\'\n\n\ndef test_length():\n    """"""Test setting length.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    assert layer.length == 1\n\n    layer.length = 2\n    assert layer.length == 2\n\n    layer = Vectors(data, length=3)\n    assert layer.length == 3\n\n\ndef test_thumbnail():\n    """"""Test the image thumbnail for square data.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 18 * data[:, 0, :] + 1\n    data[0, :, :] = [0, 0]\n    data[-1, 0, :] = [20, 20]\n    data[-1, 1, :] = [0, 0]\n    layer = Vectors(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_big_thumbail():\n    """"""Test the image thumbnail with n_vectors > _max_vectors_thumbnail""""""\n    np.random.seed(0)\n    n_vectors = int(1.5 * Vectors._max_vectors_thumbnail)\n    data = np.random.random((n_vectors, 2, 2))\n    data[:, 0, :] = 18 * data[:, 0, :] + 1\n    data[0, :, :] = [0, 0]\n    data[-1, 0, :] = [20, 20]\n    data[-1, 1, :] = [0, 0]\n    layer = Vectors(data)\n    layer._update_thumbnail()\n    assert layer.thumbnail.shape == layer._thumbnail_shape\n\n\ndef test_value():\n    """"""Test getting the value of the data at the current coordinates.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    value = layer.get_value()\n    assert layer.coordinates == (0, 0)\n    assert value is None\n\n\ndef test_message():\n    """"""Test converting value and coords to message.""""""\n    np.random.seed(0)\n    data = np.random.random((10, 2, 2))\n    data[:, 0, :] = 20 * data[:, 0, :]\n    layer = Vectors(data)\n    msg = layer.get_message()\n    assert type(msg) == str\n'"
napari/utils/colormaps/vendored/__init__.py,0,b''
napari/utils/colormaps/vendored/_cm.py,27,"b'""""""\nNothing here but dictionaries for generating LinearSegmentedColormaps,\nand a dictionary of these dictionaries.\n\nDocumentation for each is in pyplot.colormaps().  Please update this\nwith the purpose and type of your colormap if you add data for one here.\n""""""\n\nfrom functools import partial\n\nimport numpy as np\n\n_binary_data = {\n    \'red\':    ((0., 1., 1.), (1., 0., 0.)),\n    \'green\':  ((0., 1., 1.), (1., 0., 0.)),\n    \'blue\':   ((0., 1., 1.), (1., 0., 0.))\n    }\n\n_autumn_data = {\'red\':   ((0., 1.0, 1.0), (1.0, 1.0, 1.0)),\n                \'green\': ((0., 0., 0.), (1.0, 1.0, 1.0)),\n                \'blue\':  ((0., 0., 0.), (1.0, 0., 0.))}\n\n_bone_data = {\'red\':   ((0., 0., 0.),\n                        (0.746032, 0.652778, 0.652778),\n                        (1.0, 1.0, 1.0)),\n              \'green\': ((0., 0., 0.),\n                        (0.365079, 0.319444, 0.319444),\n                        (0.746032, 0.777778, 0.777778),\n                        (1.0, 1.0, 1.0)),\n              \'blue\':  ((0., 0., 0.),\n                        (0.365079, 0.444444, 0.444444),\n                        (1.0, 1.0, 1.0))}\n\n_cool_data = {\'red\':   ((0., 0., 0.), (1.0, 1.0, 1.0)),\n              \'green\': ((0., 1., 1.), (1.0, 0.,  0.)),\n              \'blue\':  ((0., 1., 1.), (1.0, 1.,  1.))}\n\n_copper_data = {\'red\':   ((0., 0., 0.),\n                          (0.809524, 1.000000, 1.000000),\n                          (1.0, 1.0, 1.0)),\n                \'green\': ((0., 0., 0.),\n                          (1.0, 0.7812, 0.7812)),\n                \'blue\':  ((0., 0., 0.),\n                          (1.0, 0.4975, 0.4975))}\n\ndef _flag_red(x): return 0.75 * np.sin((x * 31.5 + 0.25) * np.pi) + 0.5\ndef _flag_green(x): return np.sin(x * 31.5 * np.pi)\ndef _flag_blue(x): return 0.75 * np.sin((x * 31.5 - 0.25) * np.pi) + 0.5\n_flag_data = {\'red\': _flag_red, \'green\': _flag_green, \'blue\': _flag_blue}\n\ndef _prism_red(x): return 0.75 * np.sin((x * 20.9 + 0.25) * np.pi) + 0.67\ndef _prism_green(x): return 0.75 * np.sin((x * 20.9 - 0.25) * np.pi) + 0.33\ndef _prism_blue(x): return -1.1 * np.sin((x * 20.9) * np.pi)\n_prism_data = {\'red\': _prism_red, \'green\': _prism_green, \'blue\': _prism_blue}\n\ndef _ch_helper(gamma, s, r, h, p0, p1, x):\n    """"""Helper function for generating picklable cubehelix color maps.""""""\n    # Apply gamma factor to emphasise low or high intensity values\n    xg = x ** gamma\n    # Calculate amplitude and angle of deviation from the black to white\n    # diagonal in the plane of constant perceived intensity.\n    a = h * xg * (1 - xg) / 2\n    phi = 2 * np.pi * (s / 3 + r * x)\n    return xg + a * (p0 * np.cos(phi) + p1 * np.sin(phi))\n\ndef cubehelix(gamma=1.0, s=0.5, r=-1.5, h=1.0):\n    """"""\n    Return custom data dictionary of (r,g,b) conversion functions, which can be\n    used with :func:`register_cmap`, for the cubehelix color scheme.\n\n    Unlike most other color schemes cubehelix was designed by D.A. Green to\n    be monotonically increasing in terms of perceived brightness.\n    Also, when printed on a black and white postscript printer, the scheme\n    results in a greyscale with monotonically increasing brightness.\n    This color scheme is named cubehelix because the r,g,b values produced\n    can be visualised as a squashed helix around the diagonal in the\n    r,g,b color cube.\n\n    For a unit color cube (i.e. 3-D coordinates for r,g,b each in the\n    range 0 to 1) the color scheme starts at (r,g,b) = (0,0,0), i.e. black,\n    and finishes at (r,g,b) = (1,1,1), i.e. white. For some fraction *x*,\n    between 0 and 1, the color is the corresponding grey value at that\n    fraction along the black to white diagonal (x,x,x) plus a color\n    element. This color element is calculated in a plane of constant\n    perceived intensity and controlled by the following parameters.\n\n    Optional keyword arguments:\n\n      =========   =======================================================\n      Keyword     Description\n      =========   =======================================================\n      gamma       gamma factor to emphasise either low intensity values\n                  (gamma < 1), or high intensity values (gamma > 1);\n                  defaults to 1.0.\n      s           the start color; defaults to 0.5 (i.e. purple).\n      r           the number of r,g,b rotations in color that are made\n                  from the start to the end of the color scheme; defaults\n                  to -1.5 (i.e. -> B -> G -> R -> B).\n      h           the hue parameter which controls how saturated the\n                  colors are. If this parameter is zero then the color\n                  scheme is purely a greyscale; defaults to 1.0.\n      =========   =======================================================\n    """"""\n    return {\'red\': partial(_ch_helper, gamma, s, r, h, -0.14861, 1.78277),\n            \'green\': partial(_ch_helper, gamma, s, r, h, -0.29227, -0.90649),\n            \'blue\': partial(_ch_helper, gamma, s, r, h, 1.97294, 0.0)}\n\n_cubehelix_data = cubehelix()\n\n_bwr_data = ((0.0, 0.0, 1.0), (1.0, 1.0, 1.0), (1.0, 0.0, 0.0))\n_brg_data = ((0.0, 0.0, 1.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0))\n\n# Gnuplot palette functions\ndef _g0(x): return 0\ndef _g1(x): return 0.5\ndef _g2(x): return 1\ndef _g3(x): return x\ndef _g4(x): return x ** 2\ndef _g5(x): return x ** 3\ndef _g6(x): return x ** 4\ndef _g7(x): return np.sqrt(x)\ndef _g8(x): return np.sqrt(np.sqrt(x))\ndef _g9(x): return np.sin(x * np.pi / 2)\ndef _g10(x): return np.cos(x * np.pi / 2)\ndef _g11(x): return np.abs(x - 0.5)\ndef _g12(x): return (2 * x - 1) ** 2\ndef _g13(x): return np.sin(x * np.pi)\ndef _g14(x): return np.abs(np.cos(x * np.pi))\ndef _g15(x): return np.sin(x * 2 * np.pi)\ndef _g16(x): return np.cos(x * 2 * np.pi)\ndef _g17(x): return np.abs(np.sin(x * 2 * np.pi))\ndef _g18(x): return np.abs(np.cos(x * 2 * np.pi))\ndef _g19(x): return np.abs(np.sin(x * 4 * np.pi))\ndef _g20(x): return np.abs(np.cos(x * 4 * np.pi))\ndef _g21(x): return 3 * x\ndef _g22(x): return 3 * x - 1\ndef _g23(x): return 3 * x - 2\ndef _g24(x): return np.abs(3 * x - 1)\ndef _g25(x): return np.abs(3 * x - 2)\ndef _g26(x): return (3 * x - 1) / 2\ndef _g27(x): return (3 * x - 2) / 2\ndef _g28(x): return np.abs((3 * x - 1) / 2)\ndef _g29(x): return np.abs((3 * x - 2) / 2)\ndef _g30(x): return x / 0.32 - 0.78125\ndef _g31(x): return 2 * x - 0.84\ndef _g32(x):\n    ret = np.zeros(len(x))\n    m = (x < 0.25)\n    ret[m] = 4 * x[m]\n    m = (x >= 0.25) & (x < 0.92)\n    ret[m] = -2 * x[m] + 1.84\n    m = (x >= 0.92)\n    ret[m] = x[m] / 0.08 - 11.5\n    return ret\ndef _g33(x): return np.abs(2 * x - 0.5)\ndef _g34(x): return 2 * x\ndef _g35(x): return 2 * x - 0.5\ndef _g36(x): return 2 * x - 1\n\ngfunc = {i: globals()[""_g{}"".format(i)] for i in range(37)}\n\n_gnuplot_data = {\n        \'red\': gfunc[7],\n        \'green\': gfunc[5],\n        \'blue\': gfunc[15],\n}\n\n_gnuplot2_data = {\n        \'red\': gfunc[30],\n        \'green\': gfunc[31],\n        \'blue\': gfunc[32],\n}\n\n_ocean_data = {\n        \'red\': gfunc[23],\n        \'green\': gfunc[28],\n        \'blue\': gfunc[3],\n}\n\n_afmhot_data = {\n        \'red\': gfunc[34],\n        \'green\': gfunc[35],\n        \'blue\': gfunc[36],\n}\n\n_rainbow_data = {\n        \'red\': gfunc[33],\n        \'green\': gfunc[13],\n        \'blue\': gfunc[10],\n}\n\n_seismic_data = (\n        (0.0, 0.0, 0.3), (0.0, 0.0, 1.0),\n        (1.0, 1.0, 1.0), (1.0, 0.0, 0.0),\n        (0.5, 0.0, 0.0))\n\n_terrain_data = (\n        (0.00, (0.2, 0.2, 0.6)),\n        (0.15, (0.0, 0.6, 1.0)),\n        (0.25, (0.0, 0.8, 0.4)),\n        (0.50, (1.0, 1.0, 0.6)),\n        (0.75, (0.5, 0.36, 0.33)),\n        (1.00, (1.0, 1.0, 1.0)))\n\n_gray_data = {\'red\':   ((0., 0, 0), (1., 1, 1)),\n              \'green\': ((0., 0, 0), (1., 1, 1)),\n              \'blue\':  ((0., 0, 0), (1., 1, 1))}\n\n_hot_data = {\'red\':   ((0., 0.0416, 0.0416),\n                       (0.365079, 1.000000, 1.000000),\n                       (1.0, 1.0, 1.0)),\n             \'green\': ((0., 0., 0.),\n                       (0.365079, 0.000000, 0.000000),\n                       (0.746032, 1.000000, 1.000000),\n                       (1.0, 1.0, 1.0)),\n             \'blue\':  ((0., 0., 0.),\n                       (0.746032, 0.000000, 0.000000),\n                       (1.0, 1.0, 1.0))}\n\n_hsv_data = {\'red\':   ((0., 1., 1.),\n                       (0.158730, 1.000000, 1.000000),\n                       (0.174603, 0.968750, 0.968750),\n                       (0.333333, 0.031250, 0.031250),\n                       (0.349206, 0.000000, 0.000000),\n                       (0.666667, 0.000000, 0.000000),\n                       (0.682540, 0.031250, 0.031250),\n                       (0.841270, 0.968750, 0.968750),\n                       (0.857143, 1.000000, 1.000000),\n                       (1.0, 1.0, 1.0)),\n             \'green\': ((0., 0., 0.),\n                       (0.158730, 0.937500, 0.937500),\n                       (0.174603, 1.000000, 1.000000),\n                       (0.507937, 1.000000, 1.000000),\n                       (0.666667, 0.062500, 0.062500),\n                       (0.682540, 0.000000, 0.000000),\n                       (1.0, 0., 0.)),\n             \'blue\':  ((0., 0., 0.),\n                       (0.333333, 0.000000, 0.000000),\n                       (0.349206, 0.062500, 0.062500),\n                       (0.507937, 1.000000, 1.000000),\n                       (0.841270, 1.000000, 1.000000),\n                       (0.857143, 0.937500, 0.937500),\n                       (1.0, 0.09375, 0.09375))}\n\n_jet_data = {\'red\':   ((0., 0, 0), (0.35, 0, 0), (0.66, 1, 1), (0.89, 1, 1),\n                         (1, 0.5, 0.5)),\n             \'green\': ((0., 0, 0), (0.125, 0, 0), (0.375, 1, 1), (0.64, 1, 1),\n                         (0.91, 0, 0), (1, 0, 0)),\n             \'blue\':  ((0., 0.5, 0.5), (0.11, 1, 1), (0.34, 1, 1),\n                         (0.65, 0, 0), (1, 0, 0))}\n\n_pink_data = {\'red\':   ((0., 0.1178, 0.1178), (0.015873, 0.195857, 0.195857),\n                        (0.031746, 0.250661, 0.250661),\n                        (0.047619, 0.295468, 0.295468),\n                        (0.063492, 0.334324, 0.334324),\n                        (0.079365, 0.369112, 0.369112),\n                        (0.095238, 0.400892, 0.400892),\n                        (0.111111, 0.430331, 0.430331),\n                        (0.126984, 0.457882, 0.457882),\n                        (0.142857, 0.483867, 0.483867),\n                        (0.158730, 0.508525, 0.508525),\n                        (0.174603, 0.532042, 0.532042),\n                        (0.190476, 0.554563, 0.554563),\n                        (0.206349, 0.576204, 0.576204),\n                        (0.222222, 0.597061, 0.597061),\n                        (0.238095, 0.617213, 0.617213),\n                        (0.253968, 0.636729, 0.636729),\n                        (0.269841, 0.655663, 0.655663),\n                        (0.285714, 0.674066, 0.674066),\n                        (0.301587, 0.691980, 0.691980),\n                        (0.317460, 0.709441, 0.709441),\n                        (0.333333, 0.726483, 0.726483),\n                        (0.349206, 0.743134, 0.743134),\n                        (0.365079, 0.759421, 0.759421),\n                        (0.380952, 0.766356, 0.766356),\n                        (0.396825, 0.773229, 0.773229),\n                        (0.412698, 0.780042, 0.780042),\n                        (0.428571, 0.786796, 0.786796),\n                        (0.444444, 0.793492, 0.793492),\n                        (0.460317, 0.800132, 0.800132),\n                        (0.476190, 0.806718, 0.806718),\n                        (0.492063, 0.813250, 0.813250),\n                        (0.507937, 0.819730, 0.819730),\n                        (0.523810, 0.826160, 0.826160),\n                        (0.539683, 0.832539, 0.832539),\n                        (0.555556, 0.838870, 0.838870),\n                        (0.571429, 0.845154, 0.845154),\n                        (0.587302, 0.851392, 0.851392),\n                        (0.603175, 0.857584, 0.857584),\n                        (0.619048, 0.863731, 0.863731),\n                        (0.634921, 0.869835, 0.869835),\n                        (0.650794, 0.875897, 0.875897),\n                        (0.666667, 0.881917, 0.881917),\n                        (0.682540, 0.887896, 0.887896),\n                        (0.698413, 0.893835, 0.893835),\n                        (0.714286, 0.899735, 0.899735),\n                        (0.730159, 0.905597, 0.905597),\n                        (0.746032, 0.911421, 0.911421),\n                        (0.761905, 0.917208, 0.917208),\n                        (0.777778, 0.922958, 0.922958),\n                        (0.793651, 0.928673, 0.928673),\n                        (0.809524, 0.934353, 0.934353),\n                        (0.825397, 0.939999, 0.939999),\n                        (0.841270, 0.945611, 0.945611),\n                        (0.857143, 0.951190, 0.951190),\n                        (0.873016, 0.956736, 0.956736),\n                        (0.888889, 0.962250, 0.962250),\n                        (0.904762, 0.967733, 0.967733),\n                        (0.920635, 0.973185, 0.973185),\n                        (0.936508, 0.978607, 0.978607),\n                        (0.952381, 0.983999, 0.983999),\n                        (0.968254, 0.989361, 0.989361),\n                        (0.984127, 0.994695, 0.994695), (1.0, 1.0, 1.0)),\n              \'green\': ((0., 0., 0.), (0.015873, 0.102869, 0.102869),\n                        (0.031746, 0.145479, 0.145479),\n                        (0.047619, 0.178174, 0.178174),\n                        (0.063492, 0.205738, 0.205738),\n                        (0.079365, 0.230022, 0.230022),\n                        (0.095238, 0.251976, 0.251976),\n                        (0.111111, 0.272166, 0.272166),\n                        (0.126984, 0.290957, 0.290957),\n                        (0.142857, 0.308607, 0.308607),\n                        (0.158730, 0.325300, 0.325300),\n                        (0.174603, 0.341178, 0.341178),\n                        (0.190476, 0.356348, 0.356348),\n                        (0.206349, 0.370899, 0.370899),\n                        (0.222222, 0.384900, 0.384900),\n                        (0.238095, 0.398410, 0.398410),\n                        (0.253968, 0.411476, 0.411476),\n                        (0.269841, 0.424139, 0.424139),\n                        (0.285714, 0.436436, 0.436436),\n                        (0.301587, 0.448395, 0.448395),\n                        (0.317460, 0.460044, 0.460044),\n                        (0.333333, 0.471405, 0.471405),\n                        (0.349206, 0.482498, 0.482498),\n                        (0.365079, 0.493342, 0.493342),\n                        (0.380952, 0.517549, 0.517549),\n                        (0.396825, 0.540674, 0.540674),\n                        (0.412698, 0.562849, 0.562849),\n                        (0.428571, 0.584183, 0.584183),\n                        (0.444444, 0.604765, 0.604765),\n                        (0.460317, 0.624669, 0.624669),\n                        (0.476190, 0.643958, 0.643958),\n                        (0.492063, 0.662687, 0.662687),\n                        (0.507937, 0.680900, 0.680900),\n                        (0.523810, 0.698638, 0.698638),\n                        (0.539683, 0.715937, 0.715937),\n                        (0.555556, 0.732828, 0.732828),\n                        (0.571429, 0.749338, 0.749338),\n                        (0.587302, 0.765493, 0.765493),\n                        (0.603175, 0.781313, 0.781313),\n                        (0.619048, 0.796819, 0.796819),\n                        (0.634921, 0.812029, 0.812029),\n                        (0.650794, 0.826960, 0.826960),\n                        (0.666667, 0.841625, 0.841625),\n                        (0.682540, 0.856040, 0.856040),\n                        (0.698413, 0.870216, 0.870216),\n                        (0.714286, 0.884164, 0.884164),\n                        (0.730159, 0.897896, 0.897896),\n                        (0.746032, 0.911421, 0.911421),\n                        (0.761905, 0.917208, 0.917208),\n                        (0.777778, 0.922958, 0.922958),\n                        (0.793651, 0.928673, 0.928673),\n                        (0.809524, 0.934353, 0.934353),\n                        (0.825397, 0.939999, 0.939999),\n                        (0.841270, 0.945611, 0.945611),\n                        (0.857143, 0.951190, 0.951190),\n                        (0.873016, 0.956736, 0.956736),\n                        (0.888889, 0.962250, 0.962250),\n                        (0.904762, 0.967733, 0.967733),\n                        (0.920635, 0.973185, 0.973185),\n                        (0.936508, 0.978607, 0.978607),\n                        (0.952381, 0.983999, 0.983999),\n                        (0.968254, 0.989361, 0.989361),\n                        (0.984127, 0.994695, 0.994695), (1.0, 1.0, 1.0)),\n              \'blue\':  ((0., 0., 0.), (0.015873, 0.102869, 0.102869),\n                        (0.031746, 0.145479, 0.145479),\n                        (0.047619, 0.178174, 0.178174),\n                        (0.063492, 0.205738, 0.205738),\n                        (0.079365, 0.230022, 0.230022),\n                        (0.095238, 0.251976, 0.251976),\n                        (0.111111, 0.272166, 0.272166),\n                        (0.126984, 0.290957, 0.290957),\n                        (0.142857, 0.308607, 0.308607),\n                        (0.158730, 0.325300, 0.325300),\n                        (0.174603, 0.341178, 0.341178),\n                        (0.190476, 0.356348, 0.356348),\n                        (0.206349, 0.370899, 0.370899),\n                        (0.222222, 0.384900, 0.384900),\n                        (0.238095, 0.398410, 0.398410),\n                        (0.253968, 0.411476, 0.411476),\n                        (0.269841, 0.424139, 0.424139),\n                        (0.285714, 0.436436, 0.436436),\n                        (0.301587, 0.448395, 0.448395),\n                        (0.317460, 0.460044, 0.460044),\n                        (0.333333, 0.471405, 0.471405),\n                        (0.349206, 0.482498, 0.482498),\n                        (0.365079, 0.493342, 0.493342),\n                        (0.380952, 0.503953, 0.503953),\n                        (0.396825, 0.514344, 0.514344),\n                        (0.412698, 0.524531, 0.524531),\n                        (0.428571, 0.534522, 0.534522),\n                        (0.444444, 0.544331, 0.544331),\n                        (0.460317, 0.553966, 0.553966),\n                        (0.476190, 0.563436, 0.563436),\n                        (0.492063, 0.572750, 0.572750),\n                        (0.507937, 0.581914, 0.581914),\n                        (0.523810, 0.590937, 0.590937),\n                        (0.539683, 0.599824, 0.599824),\n                        (0.555556, 0.608581, 0.608581),\n                        (0.571429, 0.617213, 0.617213),\n                        (0.587302, 0.625727, 0.625727),\n                        (0.603175, 0.634126, 0.634126),\n                        (0.619048, 0.642416, 0.642416),\n                        (0.634921, 0.650600, 0.650600),\n                        (0.650794, 0.658682, 0.658682),\n                        (0.666667, 0.666667, 0.666667),\n                        (0.682540, 0.674556, 0.674556),\n                        (0.698413, 0.682355, 0.682355),\n                        (0.714286, 0.690066, 0.690066),\n                        (0.730159, 0.697691, 0.697691),\n                        (0.746032, 0.705234, 0.705234),\n                        (0.761905, 0.727166, 0.727166),\n                        (0.777778, 0.748455, 0.748455),\n                        (0.793651, 0.769156, 0.769156),\n                        (0.809524, 0.789314, 0.789314),\n                        (0.825397, 0.808969, 0.808969),\n                        (0.841270, 0.828159, 0.828159),\n                        (0.857143, 0.846913, 0.846913),\n                        (0.873016, 0.865261, 0.865261),\n                        (0.888889, 0.883229, 0.883229),\n                        (0.904762, 0.900837, 0.900837),\n                        (0.920635, 0.918109, 0.918109),\n                        (0.936508, 0.935061, 0.935061),\n                        (0.952381, 0.951711, 0.951711),\n                        (0.968254, 0.968075, 0.968075),\n                        (0.984127, 0.984167, 0.984167), (1.0, 1.0, 1.0))}\n\n_spring_data = {\'red\':   ((0., 1., 1.), (1.0, 1.0, 1.0)),\n                \'green\': ((0., 0., 0.), (1.0, 1.0, 1.0)),\n                \'blue\':  ((0., 1., 1.), (1.0, 0.0, 0.0))}\n\n\n_summer_data = {\'red\':   ((0., 0., 0.), (1.0, 1.0, 1.0)),\n                \'green\': ((0., 0.5, 0.5), (1.0, 1.0, 1.0)),\n                \'blue\':  ((0., 0.4, 0.4), (1.0, 0.4, 0.4))}\n\n\n_winter_data = {\'red\':   ((0., 0., 0.), (1.0, 0.0, 0.0)),\n                \'green\': ((0., 0., 0.), (1.0, 1.0, 1.0)),\n                \'blue\':  ((0., 1., 1.), (1.0, 0.5, 0.5))}\n\n_nipy_spectral_data = {\n      \'red\': [(0.0, 0.0, 0.0), (0.05, 0.4667, 0.4667),\n              (0.10, 0.5333, 0.5333), (0.15, 0.0, 0.0),\n              (0.20, 0.0, 0.0), (0.25, 0.0, 0.0),\n              (0.30, 0.0, 0.0), (0.35, 0.0, 0.0),\n              (0.40, 0.0, 0.0), (0.45, 0.0, 0.0),\n              (0.50, 0.0, 0.0), (0.55, 0.0, 0.0),\n              (0.60, 0.0, 0.0), (0.65, 0.7333, 0.7333),\n              (0.70, 0.9333, 0.9333), (0.75, 1.0, 1.0),\n              (0.80, 1.0, 1.0), (0.85, 1.0, 1.0),\n              (0.90, 0.8667, 0.8667), (0.95, 0.80, 0.80),\n              (1.0, 0.80, 0.80)],\n    \'green\': [(0.0, 0.0, 0.0), (0.05, 0.0, 0.0),\n              (0.10, 0.0, 0.0), (0.15, 0.0, 0.0),\n              (0.20, 0.0, 0.0), (0.25, 0.4667, 0.4667),\n              (0.30, 0.6000, 0.6000), (0.35, 0.6667, 0.6667),\n              (0.40, 0.6667, 0.6667), (0.45, 0.6000, 0.6000),\n              (0.50, 0.7333, 0.7333), (0.55, 0.8667, 0.8667),\n              (0.60, 1.0, 1.0), (0.65, 1.0, 1.0),\n              (0.70, 0.9333, 0.9333), (0.75, 0.8000, 0.8000),\n              (0.80, 0.6000, 0.6000), (0.85, 0.0, 0.0),\n              (0.90, 0.0, 0.0), (0.95, 0.0, 0.0),\n              (1.0, 0.80, 0.80)],\n     \'blue\': [(0.0, 0.0, 0.0), (0.05, 0.5333, 0.5333),\n              (0.10, 0.6000, 0.6000), (0.15, 0.6667, 0.6667),\n              (0.20, 0.8667, 0.8667), (0.25, 0.8667, 0.8667),\n              (0.30, 0.8667, 0.8667), (0.35, 0.6667, 0.6667),\n              (0.40, 0.5333, 0.5333), (0.45, 0.0, 0.0),\n              (0.5, 0.0, 0.0), (0.55, 0.0, 0.0),\n              (0.60, 0.0, 0.0), (0.65, 0.0, 0.0),\n              (0.70, 0.0, 0.0), (0.75, 0.0, 0.0),\n              (0.80, 0.0, 0.0), (0.85, 0.0, 0.0),\n              (0.90, 0.0, 0.0), (0.95, 0.0, 0.0),\n              (1.0, 0.80, 0.80)],\n}\n\n\n# 34 colormaps based on color specifications and designs\n# developed by Cynthia Brewer (http://colorbrewer.org).\n# The ColorBrewer palettes have been included under the terms\n# of an Apache-stype license (for details, see the file\n# LICENSE_COLORBREWER in the license directory of the matplotlib\n# source distribution).\n\n# RGB values taken from Brewer\'s Excel sheet, divided by 255\n\n_Blues_data = (\n    (0.96862745098039216,  0.98431372549019602,  1.0                ),\n    (0.87058823529411766,  0.92156862745098034,  0.96862745098039216),\n    (0.77647058823529413,  0.85882352941176465,  0.93725490196078431),\n    (0.61960784313725492,  0.792156862745098  ,  0.88235294117647056),\n    (0.41960784313725491,  0.68235294117647061,  0.83921568627450982),\n    (0.25882352941176473,  0.5725490196078431 ,  0.77647058823529413),\n    (0.12941176470588237,  0.44313725490196076,  0.70980392156862748),\n    (0.03137254901960784,  0.31764705882352939,  0.61176470588235299),\n    (0.03137254901960784,  0.18823529411764706,  0.41960784313725491)\n    )\n\n_BrBG_data = (\n    (0.32941176470588235,  0.18823529411764706,  0.0196078431372549 ),\n    (0.5490196078431373 ,  0.31764705882352939,  0.0392156862745098 ),\n    (0.74901960784313726,  0.50588235294117645,  0.17647058823529413),\n    (0.87450980392156863,  0.76078431372549016,  0.49019607843137253),\n    (0.96470588235294119,  0.90980392156862744,  0.76470588235294112),\n    (0.96078431372549022,  0.96078431372549022,  0.96078431372549022),\n    (0.7803921568627451 ,  0.91764705882352937,  0.89803921568627454),\n    (0.50196078431372548,  0.80392156862745101,  0.75686274509803919),\n    (0.20784313725490197,  0.59215686274509804,  0.5607843137254902 ),\n    (0.00392156862745098,  0.4                ,  0.36862745098039218),\n    (0.0                ,  0.23529411764705882,  0.18823529411764706)\n    )\n\n_BuGn_data = (\n    (0.96862745098039216,  0.9882352941176471 ,  0.99215686274509807),\n    (0.89803921568627454,  0.96078431372549022,  0.97647058823529409),\n    (0.8                ,  0.92549019607843142,  0.90196078431372551),\n    (0.6                ,  0.84705882352941175,  0.78823529411764703),\n    (0.4                ,  0.76078431372549016,  0.64313725490196083),\n    (0.25490196078431371,  0.68235294117647061,  0.46274509803921571),\n    (0.13725490196078433,  0.54509803921568623,  0.27058823529411763),\n    (0.0                ,  0.42745098039215684,  0.17254901960784313),\n    (0.0                ,  0.26666666666666666,  0.10588235294117647)\n    )\n\n_BuPu_data = (\n    (0.96862745098039216,  0.9882352941176471 ,  0.99215686274509807),\n    (0.8784313725490196 ,  0.92549019607843142,  0.95686274509803926),\n    (0.74901960784313726,  0.82745098039215681,  0.90196078431372551),\n    (0.61960784313725492,  0.73725490196078436,  0.85490196078431369),\n    (0.5490196078431373 ,  0.58823529411764708,  0.77647058823529413),\n    (0.5490196078431373 ,  0.41960784313725491,  0.69411764705882351),\n    (0.53333333333333333,  0.25490196078431371,  0.61568627450980395),\n    (0.50588235294117645,  0.05882352941176471,  0.48627450980392156),\n    (0.30196078431372547,  0.0                ,  0.29411764705882354)\n    )\n\n_GnBu_data = (\n    (0.96862745098039216,  0.9882352941176471 ,  0.94117647058823528),\n    (0.8784313725490196 ,  0.95294117647058818,  0.85882352941176465),\n    (0.8                ,  0.92156862745098034,  0.77254901960784317),\n    (0.6588235294117647 ,  0.8666666666666667 ,  0.70980392156862748),\n    (0.4823529411764706 ,  0.8                ,  0.7686274509803922 ),\n    (0.30588235294117649,  0.70196078431372544,  0.82745098039215681),\n    (0.16862745098039217,  0.5490196078431373 ,  0.74509803921568629),\n    (0.03137254901960784,  0.40784313725490196,  0.67450980392156867),\n    (0.03137254901960784,  0.25098039215686274,  0.50588235294117645)\n    )\n\n_Greens_data = (\n    (0.96862745098039216,  0.9882352941176471 ,  0.96078431372549022),\n    (0.89803921568627454,  0.96078431372549022,  0.8784313725490196 ),\n    (0.7803921568627451 ,  0.9137254901960784 ,  0.75294117647058822),\n    (0.63137254901960782,  0.85098039215686272,  0.60784313725490191),\n    (0.45490196078431372,  0.7686274509803922 ,  0.46274509803921571),\n    (0.25490196078431371,  0.6705882352941176 ,  0.36470588235294116),\n    (0.13725490196078433,  0.54509803921568623,  0.27058823529411763),\n    (0.0                ,  0.42745098039215684,  0.17254901960784313),\n    (0.0                ,  0.26666666666666666,  0.10588235294117647)\n    )\n\n_Greys_data = (\n    (1.0                ,  1.0                ,  1.0                ),\n    (0.94117647058823528,  0.94117647058823528,  0.94117647058823528),\n    (0.85098039215686272,  0.85098039215686272,  0.85098039215686272),\n    (0.74117647058823533,  0.74117647058823533,  0.74117647058823533),\n    (0.58823529411764708,  0.58823529411764708,  0.58823529411764708),\n    (0.45098039215686275,  0.45098039215686275,  0.45098039215686275),\n    (0.32156862745098042,  0.32156862745098042,  0.32156862745098042),\n    (0.14509803921568629,  0.14509803921568629,  0.14509803921568629),\n    (0.0                ,  0.0                ,  0.0                )\n    )\n\n_Oranges_data = (\n    (1.0                ,  0.96078431372549022,  0.92156862745098034),\n    (0.99607843137254903,  0.90196078431372551,  0.80784313725490198),\n    (0.99215686274509807,  0.81568627450980391,  0.63529411764705879),\n    (0.99215686274509807,  0.68235294117647061,  0.41960784313725491),\n    (0.99215686274509807,  0.55294117647058827,  0.23529411764705882),\n    (0.94509803921568625,  0.41176470588235292,  0.07450980392156863),\n    (0.85098039215686272,  0.28235294117647058,  0.00392156862745098),\n    (0.65098039215686276,  0.21176470588235294,  0.01176470588235294),\n    (0.49803921568627452,  0.15294117647058825,  0.01568627450980392)\n    )\n\n_OrRd_data = (\n    (1.0                ,  0.96862745098039216,  0.92549019607843142),\n    (0.99607843137254903,  0.90980392156862744,  0.78431372549019607),\n    (0.99215686274509807,  0.83137254901960789,  0.61960784313725492),\n    (0.99215686274509807,  0.73333333333333328,  0.51764705882352946),\n    (0.9882352941176471 ,  0.55294117647058827,  0.34901960784313724),\n    (0.93725490196078431,  0.396078431372549  ,  0.28235294117647058),\n    (0.84313725490196079,  0.18823529411764706,  0.12156862745098039),\n    (0.70196078431372544,  0.0                ,  0.0                ),\n    (0.49803921568627452,  0.0                ,  0.0                )\n    )\n\n_PiYG_data = (\n    (0.55686274509803924,  0.00392156862745098,  0.32156862745098042),\n    (0.77254901960784317,  0.10588235294117647,  0.49019607843137253),\n    (0.87058823529411766,  0.46666666666666667,  0.68235294117647061),\n    (0.94509803921568625,  0.71372549019607845,  0.85490196078431369),\n    (0.99215686274509807,  0.8784313725490196 ,  0.93725490196078431),\n    (0.96862745098039216,  0.96862745098039216,  0.96862745098039216),\n    (0.90196078431372551,  0.96078431372549022,  0.81568627450980391),\n    (0.72156862745098038,  0.88235294117647056,  0.52549019607843139),\n    (0.49803921568627452,  0.73725490196078436,  0.25490196078431371),\n    (0.30196078431372547,  0.5725490196078431 ,  0.12941176470588237),\n    (0.15294117647058825,  0.39215686274509803,  0.09803921568627451)\n    )\n\n_PRGn_data = (\n    (0.25098039215686274,  0.0                ,  0.29411764705882354),\n    (0.46274509803921571,  0.16470588235294117,  0.51372549019607838),\n    (0.6                ,  0.4392156862745098 ,  0.6705882352941176 ),\n    (0.76078431372549016,  0.6470588235294118 ,  0.81176470588235294),\n    (0.90588235294117647,  0.83137254901960789,  0.90980392156862744),\n    (0.96862745098039216,  0.96862745098039216,  0.96862745098039216),\n    (0.85098039215686272,  0.94117647058823528,  0.82745098039215681),\n    (0.65098039215686276,  0.85882352941176465,  0.62745098039215685),\n    (0.35294117647058826,  0.68235294117647061,  0.38039215686274508),\n    (0.10588235294117647,  0.47058823529411764,  0.21568627450980393),\n    (0.0                ,  0.26666666666666666,  0.10588235294117647)\n    )\n\n_PuBu_data = (\n    (1.0                ,  0.96862745098039216,  0.98431372549019602),\n    (0.92549019607843142,  0.90588235294117647,  0.94901960784313721),\n    (0.81568627450980391,  0.81960784313725488,  0.90196078431372551),\n    (0.65098039215686276,  0.74117647058823533,  0.85882352941176465),\n    (0.45490196078431372,  0.66274509803921566,  0.81176470588235294),\n    (0.21176470588235294,  0.56470588235294117,  0.75294117647058822),\n    (0.0196078431372549 ,  0.4392156862745098 ,  0.69019607843137254),\n    (0.01568627450980392,  0.35294117647058826,  0.55294117647058827),\n    (0.00784313725490196,  0.2196078431372549 ,  0.34509803921568627)\n    )\n\n_PuBuGn_data = (\n    (1.0                ,  0.96862745098039216,  0.98431372549019602),\n    (0.92549019607843142,  0.88627450980392153,  0.94117647058823528),\n    (0.81568627450980391,  0.81960784313725488,  0.90196078431372551),\n    (0.65098039215686276,  0.74117647058823533,  0.85882352941176465),\n    (0.40392156862745099,  0.66274509803921566,  0.81176470588235294),\n    (0.21176470588235294,  0.56470588235294117,  0.75294117647058822),\n    (0.00784313725490196,  0.50588235294117645,  0.54117647058823526),\n    (0.00392156862745098,  0.42352941176470588,  0.34901960784313724),\n    (0.00392156862745098,  0.27450980392156865,  0.21176470588235294)\n    )\n\n_PuOr_data = (\n    (0.49803921568627452,  0.23137254901960785,  0.03137254901960784),\n    (0.70196078431372544,  0.34509803921568627,  0.02352941176470588),\n    (0.8784313725490196 ,  0.50980392156862742,  0.07843137254901961),\n    (0.99215686274509807,  0.72156862745098038,  0.38823529411764707),\n    (0.99607843137254903,  0.8784313725490196 ,  0.71372549019607845),\n    (0.96862745098039216,  0.96862745098039216,  0.96862745098039216),\n    (0.84705882352941175,  0.85490196078431369,  0.92156862745098034),\n    (0.69803921568627447,  0.6705882352941176 ,  0.82352941176470584),\n    (0.50196078431372548,  0.45098039215686275,  0.67450980392156867),\n    (0.32941176470588235,  0.15294117647058825,  0.53333333333333333),\n    (0.17647058823529413,  0.0                ,  0.29411764705882354)\n    )\n\n_PuRd_data = (\n    (0.96862745098039216,  0.95686274509803926,  0.97647058823529409),\n    (0.90588235294117647,  0.88235294117647056,  0.93725490196078431),\n    (0.83137254901960789,  0.72549019607843135,  0.85490196078431369),\n    (0.78823529411764703,  0.58039215686274515,  0.7803921568627451 ),\n    (0.87450980392156863,  0.396078431372549  ,  0.69019607843137254),\n    (0.90588235294117647,  0.16078431372549021,  0.54117647058823526),\n    (0.80784313725490198,  0.07058823529411765,  0.33725490196078434),\n    (0.59607843137254901,  0.0                ,  0.2627450980392157 ),\n    (0.40392156862745099,  0.0                ,  0.12156862745098039)\n    )\n\n_Purples_data = (\n    (0.9882352941176471 ,  0.98431372549019602,  0.99215686274509807),\n    (0.93725490196078431,  0.92941176470588238,  0.96078431372549022),\n    (0.85490196078431369,  0.85490196078431369,  0.92156862745098034),\n    (0.73725490196078436,  0.74117647058823533,  0.86274509803921573),\n    (0.61960784313725492,  0.60392156862745094,  0.78431372549019607),\n    (0.50196078431372548,  0.49019607843137253,  0.72941176470588232),\n    (0.41568627450980394,  0.31764705882352939,  0.63921568627450975),\n    (0.32941176470588235,  0.15294117647058825,  0.5607843137254902 ),\n    (0.24705882352941178,  0.0                ,  0.49019607843137253)\n    )\n\n_RdBu_data = (\n    (0.40392156862745099,  0.0                ,  0.12156862745098039),\n    (0.69803921568627447,  0.09411764705882353,  0.16862745098039217),\n    (0.83921568627450982,  0.37647058823529411,  0.30196078431372547),\n    (0.95686274509803926,  0.6470588235294118 ,  0.50980392156862742),\n    (0.99215686274509807,  0.85882352941176465,  0.7803921568627451 ),\n    (0.96862745098039216,  0.96862745098039216,  0.96862745098039216),\n    (0.81960784313725488,  0.89803921568627454,  0.94117647058823528),\n    (0.5725490196078431 ,  0.77254901960784317,  0.87058823529411766),\n    (0.2627450980392157 ,  0.57647058823529407,  0.76470588235294112),\n    (0.12941176470588237,  0.4                ,  0.67450980392156867),\n    (0.0196078431372549 ,  0.18823529411764706,  0.38039215686274508)\n    )\n\n_RdGy_data = (\n    (0.40392156862745099,  0.0                ,  0.12156862745098039),\n    (0.69803921568627447,  0.09411764705882353,  0.16862745098039217),\n    (0.83921568627450982,  0.37647058823529411,  0.30196078431372547),\n    (0.95686274509803926,  0.6470588235294118 ,  0.50980392156862742),\n    (0.99215686274509807,  0.85882352941176465,  0.7803921568627451 ),\n    (1.0                ,  1.0                ,  1.0                ),\n    (0.8784313725490196 ,  0.8784313725490196 ,  0.8784313725490196 ),\n    (0.72941176470588232,  0.72941176470588232,  0.72941176470588232),\n    (0.52941176470588236,  0.52941176470588236,  0.52941176470588236),\n    (0.30196078431372547,  0.30196078431372547,  0.30196078431372547),\n    (0.10196078431372549,  0.10196078431372549,  0.10196078431372549)\n    )\n\n_RdPu_data = (\n    (1.0                ,  0.96862745098039216,  0.95294117647058818),\n    (0.99215686274509807,  0.8784313725490196 ,  0.86666666666666667),\n    (0.9882352941176471 ,  0.77254901960784317,  0.75294117647058822),\n    (0.98039215686274506,  0.62352941176470589,  0.70980392156862748),\n    (0.96862745098039216,  0.40784313725490196,  0.63137254901960782),\n    (0.86666666666666667,  0.20392156862745098,  0.59215686274509804),\n    (0.68235294117647061,  0.00392156862745098,  0.49411764705882355),\n    (0.47843137254901963,  0.00392156862745098,  0.46666666666666667),\n    (0.28627450980392155,  0.0                ,  0.41568627450980394)\n    )\n\n_RdYlBu_data = (\n    (0.6470588235294118 , 0.0                 , 0.14901960784313725),\n    (0.84313725490196079, 0.18823529411764706 , 0.15294117647058825),\n    (0.95686274509803926, 0.42745098039215684 , 0.2627450980392157 ),\n    (0.99215686274509807, 0.68235294117647061 , 0.38039215686274508),\n    (0.99607843137254903, 0.8784313725490196  , 0.56470588235294117),\n    (1.0                , 1.0                 , 0.74901960784313726),\n    (0.8784313725490196 , 0.95294117647058818 , 0.97254901960784312),\n    (0.6705882352941176 , 0.85098039215686272 , 0.9137254901960784 ),\n    (0.45490196078431372, 0.67843137254901964 , 0.81960784313725488),\n    (0.27058823529411763, 0.45882352941176469 , 0.70588235294117652),\n    (0.19215686274509805, 0.21176470588235294 , 0.58431372549019611)\n    )\n\n_RdYlGn_data = (\n    (0.6470588235294118 , 0.0                 , 0.14901960784313725),\n    (0.84313725490196079, 0.18823529411764706 , 0.15294117647058825),\n    (0.95686274509803926, 0.42745098039215684 , 0.2627450980392157 ),\n    (0.99215686274509807, 0.68235294117647061 , 0.38039215686274508),\n    (0.99607843137254903, 0.8784313725490196  , 0.54509803921568623),\n    (1.0                , 1.0                 , 0.74901960784313726),\n    (0.85098039215686272, 0.93725490196078431 , 0.54509803921568623),\n    (0.65098039215686276, 0.85098039215686272 , 0.41568627450980394),\n    (0.4                , 0.74117647058823533 , 0.38823529411764707),\n    (0.10196078431372549, 0.59607843137254901 , 0.31372549019607843),\n    (0.0                , 0.40784313725490196 , 0.21568627450980393)\n    )\n\n_Reds_data = (\n    (1.0                , 0.96078431372549022 , 0.94117647058823528),\n    (0.99607843137254903, 0.8784313725490196  , 0.82352941176470584),\n    (0.9882352941176471 , 0.73333333333333328 , 0.63137254901960782),\n    (0.9882352941176471 , 0.5725490196078431  , 0.44705882352941179),\n    (0.98431372549019602, 0.41568627450980394 , 0.29019607843137257),\n    (0.93725490196078431, 0.23137254901960785 , 0.17254901960784313),\n    (0.79607843137254897, 0.094117647058823528, 0.11372549019607843),\n    (0.6470588235294118 , 0.058823529411764705, 0.08235294117647058),\n    (0.40392156862745099, 0.0                 , 0.05098039215686274)\n    )\n\n_Spectral_data = (\n    (0.61960784313725492, 0.003921568627450980, 0.25882352941176473),\n    (0.83529411764705885, 0.24313725490196078 , 0.30980392156862746),\n    (0.95686274509803926, 0.42745098039215684 , 0.2627450980392157 ),\n    (0.99215686274509807, 0.68235294117647061 , 0.38039215686274508),\n    (0.99607843137254903, 0.8784313725490196  , 0.54509803921568623),\n    (1.0                , 1.0                 , 0.74901960784313726),\n    (0.90196078431372551, 0.96078431372549022 , 0.59607843137254901),\n    (0.6705882352941176 , 0.8666666666666667  , 0.64313725490196083),\n    (0.4                , 0.76078431372549016 , 0.6470588235294118 ),\n    (0.19607843137254902, 0.53333333333333333 , 0.74117647058823533),\n    (0.36862745098039218, 0.30980392156862746 , 0.63529411764705879)\n    )\n\n_YlGn_data = (\n    (1.0                , 1.0                 , 0.89803921568627454),\n    (0.96862745098039216, 0.9882352941176471  , 0.72549019607843135),\n    (0.85098039215686272, 0.94117647058823528 , 0.63921568627450975),\n    (0.67843137254901964, 0.8666666666666667  , 0.55686274509803924),\n    (0.47058823529411764, 0.77647058823529413 , 0.47450980392156861),\n    (0.25490196078431371, 0.6705882352941176  , 0.36470588235294116),\n    (0.13725490196078433, 0.51764705882352946 , 0.2627450980392157 ),\n    (0.0                , 0.40784313725490196 , 0.21568627450980393),\n    (0.0                , 0.27058823529411763 , 0.16078431372549021)\n    )\n\n_YlGnBu_data = (\n    (1.0                , 1.0                 , 0.85098039215686272),\n    (0.92941176470588238, 0.97254901960784312 , 0.69411764705882351),\n    (0.7803921568627451 , 0.9137254901960784  , 0.70588235294117652),\n    (0.49803921568627452, 0.80392156862745101 , 0.73333333333333328),\n    (0.25490196078431371, 0.71372549019607845 , 0.7686274509803922 ),\n    (0.11372549019607843, 0.56862745098039214 , 0.75294117647058822),\n    (0.13333333333333333, 0.36862745098039218 , 0.6588235294117647 ),\n    (0.14509803921568629, 0.20392156862745098 , 0.58039215686274515),\n    (0.03137254901960784, 0.11372549019607843 , 0.34509803921568627)\n    )\n\n_YlOrBr_data = (\n    (1.0                , 1.0                 , 0.89803921568627454),\n    (1.0                , 0.96862745098039216 , 0.73725490196078436),\n    (0.99607843137254903, 0.8901960784313725  , 0.56862745098039214),\n    (0.99607843137254903, 0.7686274509803922  , 0.30980392156862746),\n    (0.99607843137254903, 0.6                 , 0.16078431372549021),\n    (0.92549019607843142, 0.4392156862745098  , 0.07843137254901961),\n    (0.8                , 0.29803921568627451 , 0.00784313725490196),\n    (0.6                , 0.20392156862745098 , 0.01568627450980392),\n    (0.4                , 0.14509803921568629 , 0.02352941176470588)\n    )\n\n_YlOrRd_data = (\n    (1.0                , 1.0                 , 0.8                ),\n    (1.0                , 0.92941176470588238 , 0.62745098039215685),\n    (0.99607843137254903, 0.85098039215686272 , 0.46274509803921571),\n    (0.99607843137254903, 0.69803921568627447 , 0.29803921568627451),\n    (0.99215686274509807, 0.55294117647058827 , 0.23529411764705882),\n    (0.9882352941176471 , 0.30588235294117649 , 0.16470588235294117),\n    (0.8901960784313725 , 0.10196078431372549 , 0.10980392156862745),\n    (0.74117647058823533, 0.0                 , 0.14901960784313725),\n    (0.50196078431372548, 0.0                 , 0.14901960784313725)\n    )\n\n\n# ColorBrewer\'s qualitative maps, implemented using ListedColormap\n# for use with mpl.colors.NoNorm\n\n_Accent_data = (\n    (0.49803921568627452, 0.78823529411764703, 0.49803921568627452),\n    (0.74509803921568629, 0.68235294117647061, 0.83137254901960789),\n    (0.99215686274509807, 0.75294117647058822, 0.52549019607843139),\n    (1.0,                 1.0,                 0.6                ),\n    (0.2196078431372549,  0.42352941176470588, 0.69019607843137254),\n    (0.94117647058823528, 0.00784313725490196, 0.49803921568627452),\n    (0.74901960784313726, 0.35686274509803922, 0.09019607843137254),\n    (0.4,                 0.4,                 0.4                ),\n    )\n\n_Dark2_data = (\n    (0.10588235294117647, 0.61960784313725492, 0.46666666666666667),\n    (0.85098039215686272, 0.37254901960784315, 0.00784313725490196),\n    (0.45882352941176469, 0.4392156862745098,  0.70196078431372544),\n    (0.90588235294117647, 0.16078431372549021, 0.54117647058823526),\n    (0.4,                 0.65098039215686276, 0.11764705882352941),\n    (0.90196078431372551, 0.6705882352941176,  0.00784313725490196),\n    (0.65098039215686276, 0.46274509803921571, 0.11372549019607843),\n    (0.4,                 0.4,                 0.4                ),\n    )\n\n_Paired_data = (\n    (0.65098039215686276, 0.80784313725490198, 0.8901960784313725 ),\n    (0.12156862745098039, 0.47058823529411764, 0.70588235294117652),\n    (0.69803921568627447, 0.87450980392156863, 0.54117647058823526),\n    (0.2,                 0.62745098039215685, 0.17254901960784313),\n    (0.98431372549019602, 0.60392156862745094, 0.6                ),\n    (0.8901960784313725,  0.10196078431372549, 0.10980392156862745),\n    (0.99215686274509807, 0.74901960784313726, 0.43529411764705883),\n    (1.0,                 0.49803921568627452, 0.0                ),\n    (0.792156862745098,   0.69803921568627447, 0.83921568627450982),\n    (0.41568627450980394, 0.23921568627450981, 0.60392156862745094),\n    (1.0,                 1.0,                 0.6                ),\n    (0.69411764705882351, 0.34901960784313724, 0.15686274509803921),\n    )\n\n_Pastel1_data = (\n    (0.98431372549019602, 0.70588235294117652, 0.68235294117647061),\n    (0.70196078431372544, 0.80392156862745101, 0.8901960784313725 ),\n    (0.8,                 0.92156862745098034, 0.77254901960784317),\n    (0.87058823529411766, 0.79607843137254897, 0.89411764705882357),\n    (0.99607843137254903, 0.85098039215686272, 0.65098039215686276),\n    (1.0,                 1.0,                 0.8                ),\n    (0.89803921568627454, 0.84705882352941175, 0.74117647058823533),\n    (0.99215686274509807, 0.85490196078431369, 0.92549019607843142),\n    (0.94901960784313721, 0.94901960784313721, 0.94901960784313721),\n    )\n\n_Pastel2_data = (\n    (0.70196078431372544, 0.88627450980392153, 0.80392156862745101),\n    (0.99215686274509807, 0.80392156862745101, 0.67450980392156867),\n    (0.79607843137254897, 0.83529411764705885, 0.90980392156862744),\n    (0.95686274509803926, 0.792156862745098,   0.89411764705882357),\n    (0.90196078431372551, 0.96078431372549022, 0.78823529411764703),\n    (1.0,                 0.94901960784313721, 0.68235294117647061),\n    (0.94509803921568625, 0.88627450980392153, 0.8                ),\n    (0.8,                 0.8,                 0.8                ),\n    )\n\n_Set1_data = (\n    (0.89411764705882357, 0.10196078431372549, 0.10980392156862745),\n    (0.21568627450980393, 0.49411764705882355, 0.72156862745098038),\n    (0.30196078431372547, 0.68627450980392157, 0.29019607843137257),\n    (0.59607843137254901, 0.30588235294117649, 0.63921568627450975),\n    (1.0,                 0.49803921568627452, 0.0                ),\n    (1.0,                 1.0,                 0.2                ),\n    (0.65098039215686276, 0.33725490196078434, 0.15686274509803921),\n    (0.96862745098039216, 0.50588235294117645, 0.74901960784313726),\n    (0.6,                 0.6,                 0.6),\n    )\n\n_Set2_data = (\n    (0.4,                 0.76078431372549016, 0.6470588235294118 ),\n    (0.9882352941176471,  0.55294117647058827, 0.3843137254901961 ),\n    (0.55294117647058827, 0.62745098039215685, 0.79607843137254897),\n    (0.90588235294117647, 0.54117647058823526, 0.76470588235294112),\n    (0.65098039215686276, 0.84705882352941175, 0.32941176470588235),\n    (1.0,                 0.85098039215686272, 0.18431372549019609),\n    (0.89803921568627454, 0.7686274509803922,  0.58039215686274515),\n    (0.70196078431372544, 0.70196078431372544, 0.70196078431372544),\n    )\n\n_Set3_data = (\n    (0.55294117647058827, 0.82745098039215681, 0.7803921568627451 ),\n    (1.0,                 1.0,                 0.70196078431372544),\n    (0.74509803921568629, 0.72941176470588232, 0.85490196078431369),\n    (0.98431372549019602, 0.50196078431372548, 0.44705882352941179),\n    (0.50196078431372548, 0.69411764705882351, 0.82745098039215681),\n    (0.99215686274509807, 0.70588235294117652, 0.3843137254901961 ),\n    (0.70196078431372544, 0.87058823529411766, 0.41176470588235292),\n    (0.9882352941176471,  0.80392156862745101, 0.89803921568627454),\n    (0.85098039215686272, 0.85098039215686272, 0.85098039215686272),\n    (0.73725490196078436, 0.50196078431372548, 0.74117647058823533),\n    (0.8,                 0.92156862745098034, 0.77254901960784317),\n    (1.0,                 0.92941176470588238, 0.43529411764705883),\n    )\n\n\n# The next 7 palettes are from the Yorick scientific visalisation package,\n# an evolution of the GIST package, both by David H. Munro.\n# They are released under a BSD-like license (see LICENSE_YORICK in\n# the license directory of the matplotlib source distribution).\n#\n# Most palette functions have been reduced to simple function descriptions\n# by Reinier Heeres, since the rgb components were mostly straight lines.\n# gist_earth_data and gist_ncar_data were simplified by a script and some\n# manual effort.\n\n_gist_earth_data = \\\n{\'red\': (\n(0.0, 0.0, 0.0000),\n(0.2824, 0.1882, 0.1882),\n(0.4588, 0.2714, 0.2714),\n(0.5490, 0.4719, 0.4719),\n(0.6980, 0.7176, 0.7176),\n(0.7882, 0.7553, 0.7553),\n(1.0000, 0.9922, 0.9922),\n), \'green\': (\n(0.0, 0.0, 0.0000),\n(0.0275, 0.0000, 0.0000),\n(0.1098, 0.1893, 0.1893),\n(0.1647, 0.3035, 0.3035),\n(0.2078, 0.3841, 0.3841),\n(0.2824, 0.5020, 0.5020),\n(0.5216, 0.6397, 0.6397),\n(0.6980, 0.7171, 0.7171),\n(0.7882, 0.6392, 0.6392),\n(0.7922, 0.6413, 0.6413),\n(0.8000, 0.6447, 0.6447),\n(0.8078, 0.6481, 0.6481),\n(0.8157, 0.6549, 0.6549),\n(0.8667, 0.6991, 0.6991),\n(0.8745, 0.7103, 0.7103),\n(0.8824, 0.7216, 0.7216),\n(0.8902, 0.7323, 0.7323),\n(0.8980, 0.7430, 0.7430),\n(0.9412, 0.8275, 0.8275),\n(0.9569, 0.8635, 0.8635),\n(0.9647, 0.8816, 0.8816),\n(0.9961, 0.9733, 0.9733),\n(1.0000, 0.9843, 0.9843),\n), \'blue\': (\n(0.0, 0.0, 0.0000),\n(0.0039, 0.1684, 0.1684),\n(0.0078, 0.2212, 0.2212),\n(0.0275, 0.4329, 0.4329),\n(0.0314, 0.4549, 0.4549),\n(0.2824, 0.5004, 0.5004),\n(0.4667, 0.2748, 0.2748),\n(0.5451, 0.3205, 0.3205),\n(0.7843, 0.3961, 0.3961),\n(0.8941, 0.6651, 0.6651),\n(1.0000, 0.9843, 0.9843),\n)}\n\n_gist_gray_data = {\n        \'red\': gfunc[3],\n        \'green\': gfunc[3],\n        \'blue\': gfunc[3],\n}\n\ndef _gist_heat_red(x): return 1.5 * x\ndef _gist_heat_green(x): return 2 * x - 1\ndef _gist_heat_blue(x): return 4 * x - 3\n_gist_heat_data = {\n    \'red\': _gist_heat_red, \'green\': _gist_heat_green, \'blue\': _gist_heat_blue}\n\n_gist_ncar_data = \\\n{\'red\': (\n(0.0, 0.0, 0.0000),\n(0.3098, 0.0000, 0.0000),\n(0.3725, 0.3993, 0.3993),\n(0.4235, 0.5003, 0.5003),\n(0.5333, 1.0000, 1.0000),\n(0.7922, 1.0000, 1.0000),\n(0.8471, 0.6218, 0.6218),\n(0.8980, 0.9235, 0.9235),\n(1.0000, 0.9961, 0.9961),\n), \'green\': (\n(0.0, 0.0, 0.0000),\n(0.0510, 0.3722, 0.3722),\n(0.1059, 0.0000, 0.0000),\n(0.1569, 0.7202, 0.7202),\n(0.1608, 0.7537, 0.7537),\n(0.1647, 0.7752, 0.7752),\n(0.2157, 1.0000, 1.0000),\n(0.2588, 0.9804, 0.9804),\n(0.2706, 0.9804, 0.9804),\n(0.3176, 1.0000, 1.0000),\n(0.3686, 0.8081, 0.8081),\n(0.4275, 1.0000, 1.0000),\n(0.5216, 1.0000, 1.0000),\n(0.6314, 0.7292, 0.7292),\n(0.6863, 0.2796, 0.2796),\n(0.7451, 0.0000, 0.0000),\n(0.7922, 0.0000, 0.0000),\n(0.8431, 0.1753, 0.1753),\n(0.8980, 0.5000, 0.5000),\n(1.0000, 0.9725, 0.9725),\n), \'blue\': (\n(0.0, 0.5020, 0.5020),\n(0.0510, 0.0222, 0.0222),\n(0.1098, 1.0000, 1.0000),\n(0.2039, 1.0000, 1.0000),\n(0.2627, 0.6145, 0.6145),\n(0.3216, 0.0000, 0.0000),\n(0.4157, 0.0000, 0.0000),\n(0.4745, 0.2342, 0.2342),\n(0.5333, 0.0000, 0.0000),\n(0.5804, 0.0000, 0.0000),\n(0.6314, 0.0549, 0.0549),\n(0.6902, 0.0000, 0.0000),\n(0.7373, 0.0000, 0.0000),\n(0.7922, 0.9738, 0.9738),\n(0.8000, 1.0000, 1.0000),\n(0.8431, 1.0000, 1.0000),\n(0.8980, 0.9341, 0.9341),\n(1.0000, 0.9961, 0.9961),\n)}\n\n_gist_rainbow_data = (\n        (0.000, (1.00, 0.00, 0.16)),\n        (0.030, (1.00, 0.00, 0.00)),\n        (0.215, (1.00, 1.00, 0.00)),\n        (0.400, (0.00, 1.00, 0.00)),\n        (0.586, (0.00, 1.00, 1.00)),\n        (0.770, (0.00, 0.00, 1.00)),\n        (0.954, (1.00, 0.00, 1.00)),\n        (1.000, (1.00, 0.00, 0.75))\n)\n\n_gist_stern_data = {\n        \'red\': (\n            (0.000, 0.000, 0.000), (0.0547, 1.000, 1.000),\n            (0.250, 0.027, 0.250),  # (0.2500, 0.250, 0.250),\n            (1.000, 1.000, 1.000)),\n        \'green\': ((0, 0, 0), (1, 1, 1)),\n        \'blue\': (\n            (0.000, 0.000, 0.000), (0.500, 1.000, 1.000),\n            (0.735, 0.000, 0.000), (1.000, 1.000, 1.000))\n}\n\ndef _gist_yarg(x): return 1 - x\n_gist_yarg_data = {\'red\': _gist_yarg, \'green\': _gist_yarg, \'blue\': _gist_yarg}\n\n# This bipolar color map was generated from CoolWarmFloat33.csv of\n# ""Diverging Color Maps for Scientific Visualization"" by Kenneth Moreland.\n# <http://www.kennethmoreland.com/color-maps/>\n_coolwarm_data = {\n    \'red\': [\n        (0.0, 0.2298057, 0.2298057),\n        (0.03125, 0.26623388, 0.26623388),\n        (0.0625, 0.30386891, 0.30386891),\n        (0.09375, 0.342804478, 0.342804478),\n        (0.125, 0.38301334, 0.38301334),\n        (0.15625, 0.424369608, 0.424369608),\n        (0.1875, 0.46666708, 0.46666708),\n        (0.21875, 0.509635204, 0.509635204),\n        (0.25, 0.552953156, 0.552953156),\n        (0.28125, 0.596262162, 0.596262162),\n        (0.3125, 0.639176211, 0.639176211),\n        (0.34375, 0.681291281, 0.681291281),\n        (0.375, 0.722193294, 0.722193294),\n        (0.40625, 0.761464949, 0.761464949),\n        (0.4375, 0.798691636, 0.798691636),\n        (0.46875, 0.833466556, 0.833466556),\n        (0.5, 0.865395197, 0.865395197),\n        (0.53125, 0.897787179, 0.897787179),\n        (0.5625, 0.924127593, 0.924127593),\n        (0.59375, 0.944468518, 0.944468518),\n        (0.625, 0.958852946, 0.958852946),\n        (0.65625, 0.96732803, 0.96732803),\n        (0.6875, 0.969954137, 0.969954137),\n        (0.71875, 0.966811177, 0.966811177),\n        (0.75, 0.958003065, 0.958003065),\n        (0.78125, 0.943660866, 0.943660866),\n        (0.8125, 0.923944917, 0.923944917),\n        (0.84375, 0.89904617, 0.89904617),\n        (0.875, 0.869186849, 0.869186849),\n        (0.90625, 0.834620542, 0.834620542),\n        (0.9375, 0.795631745, 0.795631745),\n        (0.96875, 0.752534934, 0.752534934),\n        (1.0, 0.705673158, 0.705673158)],\n    \'green\': [\n        (0.0, 0.298717966, 0.298717966),\n        (0.03125, 0.353094838, 0.353094838),\n        (0.0625, 0.406535296, 0.406535296),\n        (0.09375, 0.458757618, 0.458757618),\n        (0.125, 0.50941904, 0.50941904),\n        (0.15625, 0.558148092, 0.558148092),\n        (0.1875, 0.604562568, 0.604562568),\n        (0.21875, 0.648280772, 0.648280772),\n        (0.25, 0.688929332, 0.688929332),\n        (0.28125, 0.726149107, 0.726149107),\n        (0.3125, 0.759599947, 0.759599947),\n        (0.34375, 0.788964712, 0.788964712),\n        (0.375, 0.813952739, 0.813952739),\n        (0.40625, 0.834302879, 0.834302879),\n        (0.4375, 0.849786142, 0.849786142),\n        (0.46875, 0.860207984, 0.860207984),\n        (0.5, 0.86541021, 0.86541021),\n        (0.53125, 0.848937047, 0.848937047),\n        (0.5625, 0.827384882, 0.827384882),\n        (0.59375, 0.800927443, 0.800927443),\n        (0.625, 0.769767752, 0.769767752),\n        (0.65625, 0.734132809, 0.734132809),\n        (0.6875, 0.694266682, 0.694266682),\n        (0.71875, 0.650421156, 0.650421156),\n        (0.75, 0.602842431, 0.602842431),\n        (0.78125, 0.551750968, 0.551750968),\n        (0.8125, 0.49730856, 0.49730856),\n        (0.84375, 0.439559467, 0.439559467),\n        (0.875, 0.378313092, 0.378313092),\n        (0.90625, 0.312874446, 0.312874446),\n        (0.9375, 0.24128379, 0.24128379),\n        (0.96875, 0.157246067, 0.157246067),\n        (1.0, 0.01555616, 0.01555616)],\n    \'blue\': [\n        (0.0, 0.753683153, 0.753683153),\n        (0.03125, 0.801466763, 0.801466763),\n        (0.0625, 0.84495867, 0.84495867),\n        (0.09375, 0.883725899, 0.883725899),\n        (0.125, 0.917387822, 0.917387822),\n        (0.15625, 0.945619588, 0.945619588),\n        (0.1875, 0.968154911, 0.968154911),\n        (0.21875, 0.98478814, 0.98478814),\n        (0.25, 0.995375608, 0.995375608),\n        (0.28125, 0.999836203, 0.999836203),\n        (0.3125, 0.998151185, 0.998151185),\n        (0.34375, 0.990363227, 0.990363227),\n        (0.375, 0.976574709, 0.976574709),\n        (0.40625, 0.956945269, 0.956945269),\n        (0.4375, 0.931688648, 0.931688648),\n        (0.46875, 0.901068838, 0.901068838),\n        (0.5, 0.865395561, 0.865395561),\n        (0.53125, 0.820880546, 0.820880546),\n        (0.5625, 0.774508472, 0.774508472),\n        (0.59375, 0.726736146, 0.726736146),\n        (0.625, 0.678007945, 0.678007945),\n        (0.65625, 0.628751763, 0.628751763),\n        (0.6875, 0.579375448, 0.579375448),\n        (0.71875, 0.530263762, 0.530263762),\n        (0.75, 0.481775914, 0.481775914),\n        (0.78125, 0.434243684, 0.434243684),\n        (0.8125, 0.387970225, 0.387970225),\n        (0.84375, 0.343229596, 0.343229596),\n        (0.875, 0.300267182, 0.300267182),\n        (0.90625, 0.259301199, 0.259301199),\n        (0.9375, 0.220525627, 0.220525627),\n        (0.96875, 0.184115123, 0.184115123),\n        (1.0, 0.150232812, 0.150232812)]\n    }\n\n# Implementation of Carey Rappaport\'s CMRmap.\n# See `A Color Map for Effective Black-and-White Rendering of Color-Scale\n# Images\' by Carey Rappaport\n# http://www.mathworks.com/matlabcentral/fileexchange/2662-cmrmap-m\n_CMRmap_data = {\'red\':     ((0.000, 0.00, 0.00),\n                           (0.125, 0.15, 0.15),\n                           (0.250, 0.30, 0.30),\n                           (0.375, 0.60, 0.60),\n                           (0.500, 1.00, 1.00),\n                           (0.625, 0.90, 0.90),\n                           (0.750, 0.90, 0.90),\n                           (0.875, 0.90, 0.90),\n                           (1.000, 1.00, 1.00)),\n                \'green\':  ((0.000, 0.00, 0.00),\n                           (0.125, 0.15, 0.15),\n                           (0.250, 0.15, 0.15),\n                           (0.375, 0.20, 0.20),\n                           (0.500, 0.25, 0.25),\n                           (0.625, 0.50, 0.50),\n                           (0.750, 0.75, 0.75),\n                           (0.875, 0.90, 0.90),\n                           (1.000, 1.00, 1.00)),\n                \'blue\':   ((0.000, 0.00, 0.00),\n                           (0.125, 0.50, 0.50),\n                           (0.250, 0.75, 0.75),\n                           (0.375, 0.50, 0.50),\n                           (0.500, 0.15, 0.15),\n                           (0.625, 0.00, 0.00),\n                           (0.750, 0.10, 0.10),\n                           (0.875, 0.50, 0.50),\n                           (1.000, 1.00, 1.00))}\n\n\n# An MIT licensed, colorblind-friendly heatmap from Wistia:\n#   https://github.com/wistia/heatmap-palette\n#   http://wistia.com/blog/heatmaps-for-colorblindness\n#\n# >>> import matplotlib.colors as c\n# >>> colors = [""#e4ff7a"", ""#ffe81a"", ""#ffbd00"", ""#ffa000"", ""#fc7f00""]\n# >>> cm = c.LinearSegmentedColormap.from_list(\'wistia\', colors)\n# >>> _wistia_data = cm._segmentdata\n# >>> del _wistia_data[\'alpha\']\n#\n_wistia_data = {\n    \'red\': [(0.0, 0.8941176470588236, 0.8941176470588236),\n            (0.25, 1.0, 1.0),\n            (0.5, 1.0, 1.0),\n            (0.75, 1.0, 1.0),\n            (1.0, 0.9882352941176471, 0.9882352941176471)],\n    \'green\': [(0.0, 1.0, 1.0),\n              (0.25, 0.9098039215686274, 0.9098039215686274),\n              (0.5, 0.7411764705882353, 0.7411764705882353),\n              (0.75, 0.6274509803921569, 0.6274509803921569),\n              (1.0, 0.4980392156862745, 0.4980392156862745)],\n    \'blue\': [(0.0, 0.47843137254901963, 0.47843137254901963),\n             (0.25, 0.10196078431372549, 0.10196078431372549),\n             (0.5, 0.0, 0.0),\n             (0.75, 0.0, 0.0),\n             (1.0, 0.0, 0.0)],\n}\n\n\n# Categorical palettes from Vega:\n# https://github.com/vega/vega/wiki/Scales\n# (divided by 255)\n#\n\n_tab10_data = (\n    (0.12156862745098039, 0.4666666666666667,  0.7058823529411765  ),  # 1f77b4\n    (1.0,                 0.4980392156862745,  0.054901960784313725),  # ff7f0e\n    (0.17254901960784313, 0.6274509803921569,  0.17254901960784313 ),  # 2ca02c\n    (0.8392156862745098,  0.15294117647058825, 0.1568627450980392  ),  # d62728\n    (0.5803921568627451,  0.403921568627451,   0.7411764705882353  ),  # 9467bd\n    (0.5490196078431373,  0.33725490196078434, 0.29411764705882354 ),  # 8c564b\n    (0.8901960784313725,  0.4666666666666667,  0.7607843137254902  ),  # e377c2\n    (0.4980392156862745,  0.4980392156862745,  0.4980392156862745  ),  # 7f7f7f\n    (0.7372549019607844,  0.7411764705882353,  0.13333333333333333 ),  # bcbd22\n    (0.09019607843137255, 0.7450980392156863,  0.8117647058823529),    # 17becf\n)\n\n_tab20_data = (\n    (0.12156862745098039, 0.4666666666666667,  0.7058823529411765  ),  # 1f77b4\n    (0.6823529411764706,  0.7803921568627451,  0.9098039215686274  ),  # aec7e8\n    (1.0,                 0.4980392156862745,  0.054901960784313725),  # ff7f0e\n    (1.0,                 0.7333333333333333,  0.47058823529411764 ),  # ffbb78\n    (0.17254901960784313, 0.6274509803921569,  0.17254901960784313 ),  # 2ca02c\n    (0.596078431372549,   0.8745098039215686,  0.5411764705882353  ),  # 98df8a\n    (0.8392156862745098,  0.15294117647058825, 0.1568627450980392  ),  # d62728\n    (1.0,                 0.596078431372549,   0.5882352941176471  ),  # ff9896\n    (0.5803921568627451,  0.403921568627451,   0.7411764705882353  ),  # 9467bd\n    (0.7725490196078432,  0.6901960784313725,  0.8352941176470589  ),  # c5b0d5\n    (0.5490196078431373,  0.33725490196078434, 0.29411764705882354 ),  # 8c564b\n    (0.7686274509803922,  0.611764705882353,   0.5803921568627451  ),  # c49c94\n    (0.8901960784313725,  0.4666666666666667,  0.7607843137254902  ),  # e377c2\n    (0.9686274509803922,  0.7137254901960784,  0.8235294117647058  ),  # f7b6d2\n    (0.4980392156862745,  0.4980392156862745,  0.4980392156862745  ),  # 7f7f7f\n    (0.7803921568627451,  0.7803921568627451,  0.7803921568627451  ),  # c7c7c7\n    (0.7372549019607844,  0.7411764705882353,  0.13333333333333333 ),  # bcbd22\n    (0.8588235294117647,  0.8588235294117647,  0.5529411764705883  ),  # dbdb8d\n    (0.09019607843137255, 0.7450980392156863,  0.8117647058823529  ),  # 17becf\n    (0.6196078431372549,  0.8549019607843137,  0.8980392156862745),    # 9edae5\n)\n\n_tab20b_data = (\n    (0.2235294117647059,  0.23137254901960785, 0.4745098039215686 ),  # 393b79\n    (0.3215686274509804,  0.32941176470588235, 0.6392156862745098 ),  # 5254a3\n    (0.4196078431372549,  0.43137254901960786, 0.8117647058823529 ),  # 6b6ecf\n    (0.611764705882353,   0.6196078431372549,  0.8705882352941177 ),  # 9c9ede\n    (0.38823529411764707, 0.4745098039215686,  0.2235294117647059 ),  # 637939\n    (0.5490196078431373,  0.6352941176470588,  0.3215686274509804 ),  # 8ca252\n    (0.7098039215686275,  0.8117647058823529,  0.4196078431372549 ),  # b5cf6b\n    (0.807843137254902,   0.8588235294117647,  0.611764705882353  ),  # cedb9c\n    (0.5490196078431373,  0.42745098039215684, 0.19215686274509805),  # 8c6d31\n    (0.7411764705882353,  0.6196078431372549,  0.2235294117647059 ),  # bd9e39\n    (0.9058823529411765,  0.7294117647058823,  0.3215686274509804 ),  # e7ba52\n    (0.9058823529411765,  0.796078431372549,   0.5803921568627451 ),  # e7cb94\n    (0.5176470588235295,  0.23529411764705882, 0.2235294117647059 ),  # 843c39\n    (0.6784313725490196,  0.28627450980392155, 0.2901960784313726 ),  # ad494a\n    (0.8392156862745098,  0.3803921568627451,  0.4196078431372549 ),  # d6616b\n    (0.9058823529411765,  0.5882352941176471,  0.611764705882353  ),  # e7969c\n    (0.4823529411764706,  0.2549019607843137,  0.45098039215686275),  # 7b4173\n    (0.6470588235294118,  0.3176470588235294,  0.5803921568627451 ),  # a55194\n    (0.807843137254902,   0.42745098039215684, 0.7411764705882353 ),  # ce6dbd\n    (0.8705882352941177,  0.6196078431372549,  0.8392156862745098 ),  # de9ed6\n)\n\n_tab20c_data = (\n    (0.19215686274509805, 0.5098039215686274,  0.7411764705882353  ),  # 3182bd\n    (0.4196078431372549,  0.6823529411764706,  0.8392156862745098  ),  # 6baed6\n    (0.6196078431372549,  0.792156862745098,   0.8823529411764706  ),  # 9ecae1\n    (0.7764705882352941,  0.8588235294117647,  0.9372549019607843  ),  # c6dbef\n    (0.9019607843137255,  0.3333333333333333,  0.050980392156862744),  # e6550d\n    (0.9921568627450981,  0.5529411764705883,  0.23529411764705882 ),  # fd8d3c\n    (0.9921568627450981,  0.6823529411764706,  0.4196078431372549  ),  # fdae6b\n    (0.9921568627450981,  0.8156862745098039,  0.6352941176470588  ),  # fdd0a2\n    (0.19215686274509805, 0.6392156862745098,  0.32941176470588235 ),  # 31a354\n    (0.4549019607843137,  0.7686274509803922,  0.4627450980392157  ),  # 74c476\n    (0.6313725490196078,  0.8509803921568627,  0.6078431372549019  ),  # a1d99b\n    (0.7803921568627451,  0.9137254901960784,  0.7529411764705882  ),  # c7e9c0\n    (0.4588235294117647,  0.4196078431372549,  0.6941176470588235  ),  # 756bb1\n    (0.6196078431372549,  0.6039215686274509,  0.7843137254901961  ),  # 9e9ac8\n    (0.7372549019607844,  0.7411764705882353,  0.8627450980392157  ),  # bcbddc\n    (0.8549019607843137,  0.8549019607843137,  0.9215686274509803  ),  # dadaeb\n    (0.38823529411764707, 0.38823529411764707, 0.38823529411764707 ),  # 636363\n    (0.5882352941176471,  0.5882352941176471,  0.5882352941176471  ),  # 969696\n    (0.7411764705882353,  0.7411764705882353,  0.7411764705882353  ),  # bdbdbd\n    (0.8509803921568627,  0.8509803921568627,  0.8509803921568627  ),  # d9d9d9\n)\n\n\ndatad = {\n    \'Blues\': _Blues_data,\n    \'BrBG\': _BrBG_data,\n    \'BuGn\': _BuGn_data,\n    \'BuPu\': _BuPu_data,\n    \'CMRmap\': _CMRmap_data,\n    \'GnBu\': _GnBu_data,\n    \'Greens\': _Greens_data,\n    \'Greys\': _Greys_data,\n    \'OrRd\': _OrRd_data,\n    \'Oranges\': _Oranges_data,\n    \'PRGn\': _PRGn_data,\n    \'PiYG\': _PiYG_data,\n    \'PuBu\': _PuBu_data,\n    \'PuBuGn\': _PuBuGn_data,\n    \'PuOr\': _PuOr_data,\n    \'PuRd\': _PuRd_data,\n    \'Purples\': _Purples_data,\n    \'RdBu\': _RdBu_data,\n    \'RdGy\': _RdGy_data,\n    \'RdPu\': _RdPu_data,\n    \'RdYlBu\': _RdYlBu_data,\n    \'RdYlGn\': _RdYlGn_data,\n    \'Reds\': _Reds_data,\n    \'Spectral\': _Spectral_data,\n    \'Wistia\': _wistia_data,\n    \'YlGn\': _YlGn_data,\n    \'YlGnBu\': _YlGnBu_data,\n    \'YlOrBr\': _YlOrBr_data,\n    \'YlOrRd\': _YlOrRd_data,\n    \'afmhot\': _afmhot_data,\n    \'autumn\': _autumn_data,\n    \'binary\': _binary_data,\n    \'bone\': _bone_data,\n    \'brg\': _brg_data,\n    \'bwr\': _bwr_data,\n    \'cool\': _cool_data,\n    \'coolwarm\': _coolwarm_data,\n    \'copper\': _copper_data,\n    \'cubehelix\': _cubehelix_data,\n    \'flag\': _flag_data,\n    \'gist_earth\': _gist_earth_data,\n    \'gist_gray\': _gist_gray_data,\n    \'gist_heat\': _gist_heat_data,\n    \'gist_ncar\': _gist_ncar_data,\n    \'gist_rainbow\': _gist_rainbow_data,\n    \'gist_stern\': _gist_stern_data,\n    \'gist_yarg\': _gist_yarg_data,\n    \'gnuplot\': _gnuplot_data,\n    \'gnuplot2\': _gnuplot2_data,\n    \'gray\': _gray_data,\n    \'hot\': _hot_data,\n    \'hsv\': _hsv_data,\n    \'jet\': _jet_data,\n    \'nipy_spectral\': _nipy_spectral_data,\n    \'ocean\': _ocean_data,\n    \'pink\': _pink_data,\n    \'prism\': _prism_data,\n    \'rainbow\': _rainbow_data,\n    \'seismic\': _seismic_data,\n    \'spring\': _spring_data,\n    \'summer\': _summer_data,\n    \'terrain\': _terrain_data,\n    \'winter\': _winter_data,\n    # Qualitative\n    \'Accent\': {\'listed\': _Accent_data},\n    \'Dark2\': {\'listed\': _Dark2_data},\n    \'Paired\': {\'listed\': _Paired_data},\n    \'Pastel1\': {\'listed\': _Pastel1_data},\n    \'Pastel2\': {\'listed\': _Pastel2_data},\n    \'Set1\': {\'listed\': _Set1_data},\n    \'Set2\': {\'listed\': _Set2_data},\n    \'Set3\': {\'listed\': _Set3_data},\n    \'tab10\': {\'listed\': _tab10_data},\n    \'tab20\': {\'listed\': _tab20_data},\n    \'tab20b\': {\'listed\': _tab20b_data},\n    \'tab20c\': {\'listed\': _tab20c_data},\n}\n'"
napari/utils/colormaps/vendored/_cm_listed.py,0,"b""from .colors import ListedColormap\n\n_magma_data = [\n    [0.001462, 0.000466, 0.013866],\n    [0.002258, 0.001295, 0.018331],\n    [0.003279, 0.002305, 0.023708],\n    [0.004512, 0.003490, 0.029965],\n    [0.005950, 0.004843, 0.037130],\n    [0.007588, 0.006356, 0.044973],\n    [0.009426, 0.008022, 0.052844],\n    [0.011465, 0.009828, 0.060750],\n    [0.013708, 0.011771, 0.068667],\n    [0.016156, 0.013840, 0.076603],\n    [0.018815, 0.016026, 0.084584],\n    [0.021692, 0.018320, 0.092610],\n    [0.024792, 0.020715, 0.100676],\n    [0.028123, 0.023201, 0.108787],\n    [0.031696, 0.025765, 0.116965],\n    [0.035520, 0.028397, 0.125209],\n    [0.039608, 0.031090, 0.133515],\n    [0.043830, 0.033830, 0.141886],\n    [0.048062, 0.036607, 0.150327],\n    [0.052320, 0.039407, 0.158841],\n    [0.056615, 0.042160, 0.167446],\n    [0.060949, 0.044794, 0.176129],\n    [0.065330, 0.047318, 0.184892],\n    [0.069764, 0.049726, 0.193735],\n    [0.074257, 0.052017, 0.202660],\n    [0.078815, 0.054184, 0.211667],\n    [0.083446, 0.056225, 0.220755],\n    [0.088155, 0.058133, 0.229922],\n    [0.092949, 0.059904, 0.239164],\n    [0.097833, 0.061531, 0.248477],\n    [0.102815, 0.063010, 0.257854],\n    [0.107899, 0.064335, 0.267289],\n    [0.113094, 0.065492, 0.276784],\n    [0.118405, 0.066479, 0.286321],\n    [0.123833, 0.067295, 0.295879],\n    [0.129380, 0.067935, 0.305443],\n    [0.135053, 0.068391, 0.315000],\n    [0.140858, 0.068654, 0.324538],\n    [0.146785, 0.068738, 0.334011],\n    [0.152839, 0.068637, 0.343404],\n    [0.159018, 0.068354, 0.352688],\n    [0.165308, 0.067911, 0.361816],\n    [0.171713, 0.067305, 0.370771],\n    [0.178212, 0.066576, 0.379497],\n    [0.184801, 0.065732, 0.387973],\n    [0.191460, 0.064818, 0.396152],\n    [0.198177, 0.063862, 0.404009],\n    [0.204935, 0.062907, 0.411514],\n    [0.211718, 0.061992, 0.418647],\n    [0.218512, 0.061158, 0.425392],\n    [0.225302, 0.060445, 0.431742],\n    [0.232077, 0.059889, 0.437695],\n    [0.238826, 0.059517, 0.443256],\n    [0.245543, 0.059352, 0.448436],\n    [0.252220, 0.059415, 0.453248],\n    [0.258857, 0.059706, 0.457710],\n    [0.265447, 0.060237, 0.461840],\n    [0.271994, 0.060994, 0.465660],\n    [0.278493, 0.061978, 0.469190],\n    [0.284951, 0.063168, 0.472451],\n    [0.291366, 0.064553, 0.475462],\n    [0.297740, 0.066117, 0.478243],\n    [0.304081, 0.067835, 0.480812],\n    [0.310382, 0.069702, 0.483186],\n    [0.316654, 0.071690, 0.485380],\n    [0.322899, 0.073782, 0.487408],\n    [0.329114, 0.075972, 0.489287],\n    [0.335308, 0.078236, 0.491024],\n    [0.341482, 0.080564, 0.492631],\n    [0.347636, 0.082946, 0.494121],\n    [0.353773, 0.085373, 0.495501],\n    [0.359898, 0.087831, 0.496778],\n    [0.366012, 0.090314, 0.497960],\n    [0.372116, 0.092816, 0.499053],\n    [0.378211, 0.095332, 0.500067],\n    [0.384299, 0.097855, 0.501002],\n    [0.390384, 0.100379, 0.501864],\n    [0.396467, 0.102902, 0.502658],\n    [0.402548, 0.105420, 0.503386],\n    [0.408629, 0.107930, 0.504052],\n    [0.414709, 0.110431, 0.504662],\n    [0.420791, 0.112920, 0.505215],\n    [0.426877, 0.115395, 0.505714],\n    [0.432967, 0.117855, 0.506160],\n    [0.439062, 0.120298, 0.506555],\n    [0.445163, 0.122724, 0.506901],\n    [0.451271, 0.125132, 0.507198],\n    [0.457386, 0.127522, 0.507448],\n    [0.463508, 0.129893, 0.507652],\n    [0.469640, 0.132245, 0.507809],\n    [0.475780, 0.134577, 0.507921],\n    [0.481929, 0.136891, 0.507989],\n    [0.488088, 0.139186, 0.508011],\n    [0.494258, 0.141462, 0.507988],\n    [0.500438, 0.143719, 0.507920],\n    [0.506629, 0.145958, 0.507806],\n    [0.512831, 0.148179, 0.507648],\n    [0.519045, 0.150383, 0.507443],\n    [0.525270, 0.152569, 0.507192],\n    [0.531507, 0.154739, 0.506895],\n    [0.537755, 0.156894, 0.506551],\n    [0.544015, 0.159033, 0.506159],\n    [0.550287, 0.161158, 0.505719],\n    [0.556571, 0.163269, 0.505230],\n    [0.562866, 0.165368, 0.504692],\n    [0.569172, 0.167454, 0.504105],\n    [0.575490, 0.169530, 0.503466],\n    [0.581819, 0.171596, 0.502777],\n    [0.588158, 0.173652, 0.502035],\n    [0.594508, 0.175701, 0.501241],\n    [0.600868, 0.177743, 0.500394],\n    [0.607238, 0.179779, 0.499492],\n    [0.613617, 0.181811, 0.498536],\n    [0.620005, 0.183840, 0.497524],\n    [0.626401, 0.185867, 0.496456],\n    [0.632805, 0.187893, 0.495332],\n    [0.639216, 0.189921, 0.494150],\n    [0.645633, 0.191952, 0.492910],\n    [0.652056, 0.193986, 0.491611],\n    [0.658483, 0.196027, 0.490253],\n    [0.664915, 0.198075, 0.488836],\n    [0.671349, 0.200133, 0.487358],\n    [0.677786, 0.202203, 0.485819],\n    [0.684224, 0.204286, 0.484219],\n    [0.690661, 0.206384, 0.482558],\n    [0.697098, 0.208501, 0.480835],\n    [0.703532, 0.210638, 0.479049],\n    [0.709962, 0.212797, 0.477201],\n    [0.716387, 0.214982, 0.475290],\n    [0.722805, 0.217194, 0.473316],\n    [0.729216, 0.219437, 0.471279],\n    [0.735616, 0.221713, 0.469180],\n    [0.742004, 0.224025, 0.467018],\n    [0.748378, 0.226377, 0.464794],\n    [0.754737, 0.228772, 0.462509],\n    [0.761077, 0.231214, 0.460162],\n    [0.767398, 0.233705, 0.457755],\n    [0.773695, 0.236249, 0.455289],\n    [0.779968, 0.238851, 0.452765],\n    [0.786212, 0.241514, 0.450184],\n    [0.792427, 0.244242, 0.447543],\n    [0.798608, 0.247040, 0.444848],\n    [0.804752, 0.249911, 0.442102],\n    [0.810855, 0.252861, 0.439305],\n    [0.816914, 0.255895, 0.436461],\n    [0.822926, 0.259016, 0.433573],\n    [0.828886, 0.262229, 0.430644],\n    [0.834791, 0.265540, 0.427671],\n    [0.840636, 0.268953, 0.424666],\n    [0.846416, 0.272473, 0.421631],\n    [0.852126, 0.276106, 0.418573],\n    [0.857763, 0.279857, 0.415496],\n    [0.863320, 0.283729, 0.412403],\n    [0.868793, 0.287728, 0.409303],\n    [0.874176, 0.291859, 0.406205],\n    [0.879464, 0.296125, 0.403118],\n    [0.884651, 0.300530, 0.400047],\n    [0.889731, 0.305079, 0.397002],\n    [0.894700, 0.309773, 0.393995],\n    [0.899552, 0.314616, 0.391037],\n    [0.904281, 0.319610, 0.388137],\n    [0.908884, 0.324755, 0.385308],\n    [0.913354, 0.330052, 0.382563],\n    [0.917689, 0.335500, 0.379915],\n    [0.921884, 0.341098, 0.377376],\n    [0.925937, 0.346844, 0.374959],\n    [0.929845, 0.352734, 0.372677],\n    [0.933606, 0.358764, 0.370541],\n    [0.937221, 0.364929, 0.368567],\n    [0.940687, 0.371224, 0.366762],\n    [0.944006, 0.377643, 0.365136],\n    [0.947180, 0.384178, 0.363701],\n    [0.950210, 0.390820, 0.362468],\n    [0.953099, 0.397563, 0.361438],\n    [0.955849, 0.404400, 0.360619],\n    [0.958464, 0.411324, 0.360014],\n    [0.960949, 0.418323, 0.359630],\n    [0.963310, 0.425390, 0.359469],\n    [0.965549, 0.432519, 0.359529],\n    [0.967671, 0.439703, 0.359810],\n    [0.969680, 0.446936, 0.360311],\n    [0.971582, 0.454210, 0.361030],\n    [0.973381, 0.461520, 0.361965],\n    [0.975082, 0.468861, 0.363111],\n    [0.976690, 0.476226, 0.364466],\n    [0.978210, 0.483612, 0.366025],\n    [0.979645, 0.491014, 0.367783],\n    [0.981000, 0.498428, 0.369734],\n    [0.982279, 0.505851, 0.371874],\n    [0.983485, 0.513280, 0.374198],\n    [0.984622, 0.520713, 0.376698],\n    [0.985693, 0.528148, 0.379371],\n    [0.986700, 0.535582, 0.382210],\n    [0.987646, 0.543015, 0.385210],\n    [0.988533, 0.550446, 0.388365],\n    [0.989363, 0.557873, 0.391671],\n    [0.990138, 0.565296, 0.395122],\n    [0.990871, 0.572706, 0.398714],\n    [0.991558, 0.580107, 0.402441],\n    [0.992196, 0.587502, 0.406299],\n    [0.992785, 0.594891, 0.410283],\n    [0.993326, 0.602275, 0.414390],\n    [0.993834, 0.609644, 0.418613],\n    [0.994309, 0.616999, 0.422950],\n    [0.994738, 0.624350, 0.427397],\n    [0.995122, 0.631696, 0.431951],\n    [0.995480, 0.639027, 0.436607],\n    [0.995810, 0.646344, 0.441361],\n    [0.996096, 0.653659, 0.446213],\n    [0.996341, 0.660969, 0.451160],\n    [0.996580, 0.668256, 0.456192],\n    [0.996775, 0.675541, 0.461314],\n    [0.996925, 0.682828, 0.466526],\n    [0.997077, 0.690088, 0.471811],\n    [0.997186, 0.697349, 0.477182],\n    [0.997254, 0.704611, 0.482635],\n    [0.997325, 0.711848, 0.488154],\n    [0.997351, 0.719089, 0.493755],\n    [0.997351, 0.726324, 0.499428],\n    [0.997341, 0.733545, 0.505167],\n    [0.997285, 0.740772, 0.510983],\n    [0.997228, 0.747981, 0.516859],\n    [0.997138, 0.755190, 0.522806],\n    [0.997019, 0.762398, 0.528821],\n    [0.996898, 0.769591, 0.534892],\n    [0.996727, 0.776795, 0.541039],\n    [0.996571, 0.783977, 0.547233],\n    [0.996369, 0.791167, 0.553499],\n    [0.996162, 0.798348, 0.559820],\n    [0.995932, 0.805527, 0.566202],\n    [0.995680, 0.812706, 0.572645],\n    [0.995424, 0.819875, 0.579140],\n    [0.995131, 0.827052, 0.585701],\n    [0.994851, 0.834213, 0.592307],\n    [0.994524, 0.841387, 0.598983],\n    [0.994222, 0.848540, 0.605696],\n    [0.993866, 0.855711, 0.612482],\n    [0.993545, 0.862859, 0.619299],\n    [0.993170, 0.870024, 0.626189],\n    [0.992831, 0.877168, 0.633109],\n    [0.992440, 0.884330, 0.640099],\n    [0.992089, 0.891470, 0.647116],\n    [0.991688, 0.898627, 0.654202],\n    [0.991332, 0.905763, 0.661309],\n    [0.990930, 0.912915, 0.668481],\n    [0.990570, 0.920049, 0.675675],\n    [0.990175, 0.927196, 0.682926],\n    [0.989815, 0.934329, 0.690198],\n    [0.989434, 0.941470, 0.697519],\n    [0.989077, 0.948604, 0.704863],\n    [0.988717, 0.955742, 0.712242],\n    [0.988367, 0.962878, 0.719649],\n    [0.988033, 0.970012, 0.727077],\n    [0.987691, 0.977154, 0.734536],\n    [0.987387, 0.984288, 0.742002],\n    [0.987053, 0.991438, 0.749504],\n]\n\n_inferno_data = [\n    [0.001462, 0.000466, 0.013866],\n    [0.002267, 0.001270, 0.018570],\n    [0.003299, 0.002249, 0.024239],\n    [0.004547, 0.003392, 0.030909],\n    [0.006006, 0.004692, 0.038558],\n    [0.007676, 0.006136, 0.046836],\n    [0.009561, 0.007713, 0.055143],\n    [0.011663, 0.009417, 0.063460],\n    [0.013995, 0.011225, 0.071862],\n    [0.016561, 0.013136, 0.080282],\n    [0.019373, 0.015133, 0.088767],\n    [0.022447, 0.017199, 0.097327],\n    [0.025793, 0.019331, 0.105930],\n    [0.029432, 0.021503, 0.114621],\n    [0.033385, 0.023702, 0.123397],\n    [0.037668, 0.025921, 0.132232],\n    [0.042253, 0.028139, 0.141141],\n    [0.046915, 0.030324, 0.150164],\n    [0.051644, 0.032474, 0.159254],\n    [0.056449, 0.034569, 0.168414],\n    [0.061340, 0.036590, 0.177642],\n    [0.066331, 0.038504, 0.186962],\n    [0.071429, 0.040294, 0.196354],\n    [0.076637, 0.041905, 0.205799],\n    [0.081962, 0.043328, 0.215289],\n    [0.087411, 0.044556, 0.224813],\n    [0.092990, 0.045583, 0.234358],\n    [0.098702, 0.046402, 0.243904],\n    [0.104551, 0.047008, 0.253430],\n    [0.110536, 0.047399, 0.262912],\n    [0.116656, 0.047574, 0.272321],\n    [0.122908, 0.047536, 0.281624],\n    [0.129285, 0.047293, 0.290788],\n    [0.135778, 0.046856, 0.299776],\n    [0.142378, 0.046242, 0.308553],\n    [0.149073, 0.045468, 0.317085],\n    [0.155850, 0.044559, 0.325338],\n    [0.162689, 0.043554, 0.333277],\n    [0.169575, 0.042489, 0.340874],\n    [0.176493, 0.041402, 0.348111],\n    [0.183429, 0.040329, 0.354971],\n    [0.190367, 0.039309, 0.361447],\n    [0.197297, 0.038400, 0.367535],\n    [0.204209, 0.037632, 0.373238],\n    [0.211095, 0.037030, 0.378563],\n    [0.217949, 0.036615, 0.383522],\n    [0.224763, 0.036405, 0.388129],\n    [0.231538, 0.036405, 0.392400],\n    [0.238273, 0.036621, 0.396353],\n    [0.244967, 0.037055, 0.400007],\n    [0.251620, 0.037705, 0.403378],\n    [0.258234, 0.038571, 0.406485],\n    [0.264810, 0.039647, 0.409345],\n    [0.271347, 0.040922, 0.411976],\n    [0.277850, 0.042353, 0.414392],\n    [0.284321, 0.043933, 0.416608],\n    [0.290763, 0.045644, 0.418637],\n    [0.297178, 0.047470, 0.420491],\n    [0.303568, 0.049396, 0.422182],\n    [0.309935, 0.051407, 0.423721],\n    [0.316282, 0.053490, 0.425116],\n    [0.322610, 0.055634, 0.426377],\n    [0.328921, 0.057827, 0.427511],\n    [0.335217, 0.060060, 0.428524],\n    [0.341500, 0.062325, 0.429425],\n    [0.347771, 0.064616, 0.430217],\n    [0.354032, 0.066925, 0.430906],\n    [0.360284, 0.069247, 0.431497],\n    [0.366529, 0.071579, 0.431994],\n    [0.372768, 0.073915, 0.432400],\n    [0.379001, 0.076253, 0.432719],\n    [0.385228, 0.078591, 0.432955],\n    [0.391453, 0.080927, 0.433109],\n    [0.397674, 0.083257, 0.433183],\n    [0.403894, 0.085580, 0.433179],\n    [0.410113, 0.087896, 0.433098],\n    [0.416331, 0.090203, 0.432943],\n    [0.422549, 0.092501, 0.432714],\n    [0.428768, 0.094790, 0.432412],\n    [0.434987, 0.097069, 0.432039],\n    [0.441207, 0.099338, 0.431594],\n    [0.447428, 0.101597, 0.431080],\n    [0.453651, 0.103848, 0.430498],\n    [0.459875, 0.106089, 0.429846],\n    [0.466100, 0.108322, 0.429125],\n    [0.472328, 0.110547, 0.428334],\n    [0.478558, 0.112764, 0.427475],\n    [0.484789, 0.114974, 0.426548],\n    [0.491022, 0.117179, 0.425552],\n    [0.497257, 0.119379, 0.424488],\n    [0.503493, 0.121575, 0.423356],\n    [0.509730, 0.123769, 0.422156],\n    [0.515967, 0.125960, 0.420887],\n    [0.522206, 0.128150, 0.419549],\n    [0.528444, 0.130341, 0.418142],\n    [0.534683, 0.132534, 0.416667],\n    [0.540920, 0.134729, 0.415123],\n    [0.547157, 0.136929, 0.413511],\n    [0.553392, 0.139134, 0.411829],\n    [0.559624, 0.141346, 0.410078],\n    [0.565854, 0.143567, 0.408258],\n    [0.572081, 0.145797, 0.406369],\n    [0.578304, 0.148039, 0.404411],\n    [0.584521, 0.150294, 0.402385],\n    [0.590734, 0.152563, 0.400290],\n    [0.596940, 0.154848, 0.398125],\n    [0.603139, 0.157151, 0.395891],\n    [0.609330, 0.159474, 0.393589],\n    [0.615513, 0.161817, 0.391219],\n    [0.621685, 0.164184, 0.388781],\n    [0.627847, 0.166575, 0.386276],\n    [0.633998, 0.168992, 0.383704],\n    [0.640135, 0.171438, 0.381065],\n    [0.646260, 0.173914, 0.378359],\n    [0.652369, 0.176421, 0.375586],\n    [0.658463, 0.178962, 0.372748],\n    [0.664540, 0.181539, 0.369846],\n    [0.670599, 0.184153, 0.366879],\n    [0.676638, 0.186807, 0.363849],\n    [0.682656, 0.189501, 0.360757],\n    [0.688653, 0.192239, 0.357603],\n    [0.694627, 0.195021, 0.354388],\n    [0.700576, 0.197851, 0.351113],\n    [0.706500, 0.200728, 0.347777],\n    [0.712396, 0.203656, 0.344383],\n    [0.718264, 0.206636, 0.340931],\n    [0.724103, 0.209670, 0.337424],\n    [0.729909, 0.212759, 0.333861],\n    [0.735683, 0.215906, 0.330245],\n    [0.741423, 0.219112, 0.326576],\n    [0.747127, 0.222378, 0.322856],\n    [0.752794, 0.225706, 0.319085],\n    [0.758422, 0.229097, 0.315266],\n    [0.764010, 0.232554, 0.311399],\n    [0.769556, 0.236077, 0.307485],\n    [0.775059, 0.239667, 0.303526],\n    [0.780517, 0.243327, 0.299523],\n    [0.785929, 0.247056, 0.295477],\n    [0.791293, 0.250856, 0.291390],\n    [0.796607, 0.254728, 0.287264],\n    [0.801871, 0.258674, 0.283099],\n    [0.807082, 0.262692, 0.278898],\n    [0.812239, 0.266786, 0.274661],\n    [0.817341, 0.270954, 0.270390],\n    [0.822386, 0.275197, 0.266085],\n    [0.827372, 0.279517, 0.261750],\n    [0.832299, 0.283913, 0.257383],\n    [0.837165, 0.288385, 0.252988],\n    [0.841969, 0.292933, 0.248564],\n    [0.846709, 0.297559, 0.244113],\n    [0.851384, 0.302260, 0.239636],\n    [0.855992, 0.307038, 0.235133],\n    [0.860533, 0.311892, 0.230606],\n    [0.865006, 0.316822, 0.226055],\n    [0.869409, 0.321827, 0.221482],\n    [0.873741, 0.326906, 0.216886],\n    [0.878001, 0.332060, 0.212268],\n    [0.882188, 0.337287, 0.207628],\n    [0.886302, 0.342586, 0.202968],\n    [0.890341, 0.347957, 0.198286],\n    [0.894305, 0.353399, 0.193584],\n    [0.898192, 0.358911, 0.188860],\n    [0.902003, 0.364492, 0.184116],\n    [0.905735, 0.370140, 0.179350],\n    [0.909390, 0.375856, 0.174563],\n    [0.912966, 0.381636, 0.169755],\n    [0.916462, 0.387481, 0.164924],\n    [0.919879, 0.393389, 0.160070],\n    [0.923215, 0.399359, 0.155193],\n    [0.926470, 0.405389, 0.150292],\n    [0.929644, 0.411479, 0.145367],\n    [0.932737, 0.417627, 0.140417],\n    [0.935747, 0.423831, 0.135440],\n    [0.938675, 0.430091, 0.130438],\n    [0.941521, 0.436405, 0.125409],\n    [0.944285, 0.442772, 0.120354],\n    [0.946965, 0.449191, 0.115272],\n    [0.949562, 0.455660, 0.110164],\n    [0.952075, 0.462178, 0.105031],\n    [0.954506, 0.468744, 0.099874],\n    [0.956852, 0.475356, 0.094695],\n    [0.959114, 0.482014, 0.089499],\n    [0.961293, 0.488716, 0.084289],\n    [0.963387, 0.495462, 0.079073],\n    [0.965397, 0.502249, 0.073859],\n    [0.967322, 0.509078, 0.068659],\n    [0.969163, 0.515946, 0.063488],\n    [0.970919, 0.522853, 0.058367],\n    [0.972590, 0.529798, 0.053324],\n    [0.974176, 0.536780, 0.048392],\n    [0.975677, 0.543798, 0.043618],\n    [0.977092, 0.550850, 0.039050],\n    [0.978422, 0.557937, 0.034931],\n    [0.979666, 0.565057, 0.031409],\n    [0.980824, 0.572209, 0.028508],\n    [0.981895, 0.579392, 0.026250],\n    [0.982881, 0.586606, 0.024661],\n    [0.983779, 0.593849, 0.023770],\n    [0.984591, 0.601122, 0.023606],\n    [0.985315, 0.608422, 0.024202],\n    [0.985952, 0.615750, 0.025592],\n    [0.986502, 0.623105, 0.027814],\n    [0.986964, 0.630485, 0.030908],\n    [0.987337, 0.637890, 0.034916],\n    [0.987622, 0.645320, 0.039886],\n    [0.987819, 0.652773, 0.045581],\n    [0.987926, 0.660250, 0.051750],\n    [0.987945, 0.667748, 0.058329],\n    [0.987874, 0.675267, 0.065257],\n    [0.987714, 0.682807, 0.072489],\n    [0.987464, 0.690366, 0.079990],\n    [0.987124, 0.697944, 0.087731],\n    [0.986694, 0.705540, 0.095694],\n    [0.986175, 0.713153, 0.103863],\n    [0.985566, 0.720782, 0.112229],\n    [0.984865, 0.728427, 0.120785],\n    [0.984075, 0.736087, 0.129527],\n    [0.983196, 0.743758, 0.138453],\n    [0.982228, 0.751442, 0.147565],\n    [0.981173, 0.759135, 0.156863],\n    [0.980032, 0.766837, 0.166353],\n    [0.978806, 0.774545, 0.176037],\n    [0.977497, 0.782258, 0.185923],\n    [0.976108, 0.789974, 0.196018],\n    [0.974638, 0.797692, 0.206332],\n    [0.973088, 0.805409, 0.216877],\n    [0.971468, 0.813122, 0.227658],\n    [0.969783, 0.820825, 0.238686],\n    [0.968041, 0.828515, 0.249972],\n    [0.966243, 0.836191, 0.261534],\n    [0.964394, 0.843848, 0.273391],\n    [0.962517, 0.851476, 0.285546],\n    [0.960626, 0.859069, 0.298010],\n    [0.958720, 0.866624, 0.310820],\n    [0.956834, 0.874129, 0.323974],\n    [0.954997, 0.881569, 0.337475],\n    [0.953215, 0.888942, 0.351369],\n    [0.951546, 0.896226, 0.365627],\n    [0.950018, 0.903409, 0.380271],\n    [0.948683, 0.910473, 0.395289],\n    [0.947594, 0.917399, 0.410665],\n    [0.946809, 0.924168, 0.426373],\n    [0.946392, 0.930761, 0.442367],\n    [0.946403, 0.937159, 0.458592],\n    [0.946903, 0.943348, 0.474970],\n    [0.947937, 0.949318, 0.491426],\n    [0.949545, 0.955063, 0.507860],\n    [0.951740, 0.960587, 0.524203],\n    [0.954529, 0.965896, 0.540361],\n    [0.957896, 0.971003, 0.556275],\n    [0.961812, 0.975924, 0.571925],\n    [0.966249, 0.980678, 0.587206],\n    [0.971162, 0.985282, 0.602154],\n    [0.976511, 0.989753, 0.616760],\n    [0.982257, 0.994109, 0.631017],\n    [0.988362, 0.998364, 0.644924],\n]\n\n_plasma_data = [\n    [0.050383, 0.029803, 0.527975],\n    [0.063536, 0.028426, 0.533124],\n    [0.075353, 0.027206, 0.538007],\n    [0.086222, 0.026125, 0.542658],\n    [0.096379, 0.025165, 0.547103],\n    [0.105980, 0.024309, 0.551368],\n    [0.115124, 0.023556, 0.555468],\n    [0.123903, 0.022878, 0.559423],\n    [0.132381, 0.022258, 0.563250],\n    [0.140603, 0.021687, 0.566959],\n    [0.148607, 0.021154, 0.570562],\n    [0.156421, 0.020651, 0.574065],\n    [0.164070, 0.020171, 0.577478],\n    [0.171574, 0.019706, 0.580806],\n    [0.178950, 0.019252, 0.584054],\n    [0.186213, 0.018803, 0.587228],\n    [0.193374, 0.018354, 0.590330],\n    [0.200445, 0.017902, 0.593364],\n    [0.207435, 0.017442, 0.596333],\n    [0.214350, 0.016973, 0.599239],\n    [0.221197, 0.016497, 0.602083],\n    [0.227983, 0.016007, 0.604867],\n    [0.234715, 0.015502, 0.607592],\n    [0.241396, 0.014979, 0.610259],\n    [0.248032, 0.014439, 0.612868],\n    [0.254627, 0.013882, 0.615419],\n    [0.261183, 0.013308, 0.617911],\n    [0.267703, 0.012716, 0.620346],\n    [0.274191, 0.012109, 0.622722],\n    [0.280648, 0.011488, 0.625038],\n    [0.287076, 0.010855, 0.627295],\n    [0.293478, 0.010213, 0.629490],\n    [0.299855, 0.009561, 0.631624],\n    [0.306210, 0.008902, 0.633694],\n    [0.312543, 0.008239, 0.635700],\n    [0.318856, 0.007576, 0.637640],\n    [0.325150, 0.006915, 0.639512],\n    [0.331426, 0.006261, 0.641316],\n    [0.337683, 0.005618, 0.643049],\n    [0.343925, 0.004991, 0.644710],\n    [0.350150, 0.004382, 0.646298],\n    [0.356359, 0.003798, 0.647810],\n    [0.362553, 0.003243, 0.649245],\n    [0.368733, 0.002724, 0.650601],\n    [0.374897, 0.002245, 0.651876],\n    [0.381047, 0.001814, 0.653068],\n    [0.387183, 0.001434, 0.654177],\n    [0.393304, 0.001114, 0.655199],\n    [0.399411, 0.000859, 0.656133],\n    [0.405503, 0.000678, 0.656977],\n    [0.411580, 0.000577, 0.657730],\n    [0.417642, 0.000564, 0.658390],\n    [0.423689, 0.000646, 0.658956],\n    [0.429719, 0.000831, 0.659425],\n    [0.435734, 0.001127, 0.659797],\n    [0.441732, 0.001540, 0.660069],\n    [0.447714, 0.002080, 0.660240],\n    [0.453677, 0.002755, 0.660310],\n    [0.459623, 0.003574, 0.660277],\n    [0.465550, 0.004545, 0.660139],\n    [0.471457, 0.005678, 0.659897],\n    [0.477344, 0.006980, 0.659549],\n    [0.483210, 0.008460, 0.659095],\n    [0.489055, 0.010127, 0.658534],\n    [0.494877, 0.011990, 0.657865],\n    [0.500678, 0.014055, 0.657088],\n    [0.506454, 0.016333, 0.656202],\n    [0.512206, 0.018833, 0.655209],\n    [0.517933, 0.021563, 0.654109],\n    [0.523633, 0.024532, 0.652901],\n    [0.529306, 0.027747, 0.651586],\n    [0.534952, 0.031217, 0.650165],\n    [0.540570, 0.034950, 0.648640],\n    [0.546157, 0.038954, 0.647010],\n    [0.551715, 0.043136, 0.645277],\n    [0.557243, 0.047331, 0.643443],\n    [0.562738, 0.051545, 0.641509],\n    [0.568201, 0.055778, 0.639477],\n    [0.573632, 0.060028, 0.637349],\n    [0.579029, 0.064296, 0.635126],\n    [0.584391, 0.068579, 0.632812],\n    [0.589719, 0.072878, 0.630408],\n    [0.595011, 0.077190, 0.627917],\n    [0.600266, 0.081516, 0.625342],\n    [0.605485, 0.085854, 0.622686],\n    [0.610667, 0.090204, 0.619951],\n    [0.615812, 0.094564, 0.617140],\n    [0.620919, 0.098934, 0.614257],\n    [0.625987, 0.103312, 0.611305],\n    [0.631017, 0.107699, 0.608287],\n    [0.636008, 0.112092, 0.605205],\n    [0.640959, 0.116492, 0.602065],\n    [0.645872, 0.120898, 0.598867],\n    [0.650746, 0.125309, 0.595617],\n    [0.655580, 0.129725, 0.592317],\n    [0.660374, 0.134144, 0.588971],\n    [0.665129, 0.138566, 0.585582],\n    [0.669845, 0.142992, 0.582154],\n    [0.674522, 0.147419, 0.578688],\n    [0.679160, 0.151848, 0.575189],\n    [0.683758, 0.156278, 0.571660],\n    [0.688318, 0.160709, 0.568103],\n    [0.692840, 0.165141, 0.564522],\n    [0.697324, 0.169573, 0.560919],\n    [0.701769, 0.174005, 0.557296],\n    [0.706178, 0.178437, 0.553657],\n    [0.710549, 0.182868, 0.550004],\n    [0.714883, 0.187299, 0.546338],\n    [0.719181, 0.191729, 0.542663],\n    [0.723444, 0.196158, 0.538981],\n    [0.727670, 0.200586, 0.535293],\n    [0.731862, 0.205013, 0.531601],\n    [0.736019, 0.209439, 0.527908],\n    [0.740143, 0.213864, 0.524216],\n    [0.744232, 0.218288, 0.520524],\n    [0.748289, 0.222711, 0.516834],\n    [0.752312, 0.227133, 0.513149],\n    [0.756304, 0.231555, 0.509468],\n    [0.760264, 0.235976, 0.505794],\n    [0.764193, 0.240396, 0.502126],\n    [0.768090, 0.244817, 0.498465],\n    [0.771958, 0.249237, 0.494813],\n    [0.775796, 0.253658, 0.491171],\n    [0.779604, 0.258078, 0.487539],\n    [0.783383, 0.262500, 0.483918],\n    [0.787133, 0.266922, 0.480307],\n    [0.790855, 0.271345, 0.476706],\n    [0.794549, 0.275770, 0.473117],\n    [0.798216, 0.280197, 0.469538],\n    [0.801855, 0.284626, 0.465971],\n    [0.805467, 0.289057, 0.462415],\n    [0.809052, 0.293491, 0.458870],\n    [0.812612, 0.297928, 0.455338],\n    [0.816144, 0.302368, 0.451816],\n    [0.819651, 0.306812, 0.448306],\n    [0.823132, 0.311261, 0.444806],\n    [0.826588, 0.315714, 0.441316],\n    [0.830018, 0.320172, 0.437836],\n    [0.833422, 0.324635, 0.434366],\n    [0.836801, 0.329105, 0.430905],\n    [0.840155, 0.333580, 0.427455],\n    [0.843484, 0.338062, 0.424013],\n    [0.846788, 0.342551, 0.420579],\n    [0.850066, 0.347048, 0.417153],\n    [0.853319, 0.351553, 0.413734],\n    [0.856547, 0.356066, 0.410322],\n    [0.859750, 0.360588, 0.406917],\n    [0.862927, 0.365119, 0.403519],\n    [0.866078, 0.369660, 0.400126],\n    [0.869203, 0.374212, 0.396738],\n    [0.872303, 0.378774, 0.393355],\n    [0.875376, 0.383347, 0.389976],\n    [0.878423, 0.387932, 0.386600],\n    [0.881443, 0.392529, 0.383229],\n    [0.884436, 0.397139, 0.379860],\n    [0.887402, 0.401762, 0.376494],\n    [0.890340, 0.406398, 0.373130],\n    [0.893250, 0.411048, 0.369768],\n    [0.896131, 0.415712, 0.366407],\n    [0.898984, 0.420392, 0.363047],\n    [0.901807, 0.425087, 0.359688],\n    [0.904601, 0.429797, 0.356329],\n    [0.907365, 0.434524, 0.352970],\n    [0.910098, 0.439268, 0.349610],\n    [0.912800, 0.444029, 0.346251],\n    [0.915471, 0.448807, 0.342890],\n    [0.918109, 0.453603, 0.339529],\n    [0.920714, 0.458417, 0.336166],\n    [0.923287, 0.463251, 0.332801],\n    [0.925825, 0.468103, 0.329435],\n    [0.928329, 0.472975, 0.326067],\n    [0.930798, 0.477867, 0.322697],\n    [0.933232, 0.482780, 0.319325],\n    [0.935630, 0.487712, 0.315952],\n    [0.937990, 0.492667, 0.312575],\n    [0.940313, 0.497642, 0.309197],\n    [0.942598, 0.502639, 0.305816],\n    [0.944844, 0.507658, 0.302433],\n    [0.947051, 0.512699, 0.299049],\n    [0.949217, 0.517763, 0.295662],\n    [0.951344, 0.522850, 0.292275],\n    [0.953428, 0.527960, 0.288883],\n    [0.955470, 0.533093, 0.285490],\n    [0.957469, 0.538250, 0.282096],\n    [0.959424, 0.543431, 0.278701],\n    [0.961336, 0.548636, 0.275305],\n    [0.963203, 0.553865, 0.271909],\n    [0.965024, 0.559118, 0.268513],\n    [0.966798, 0.564396, 0.265118],\n    [0.968526, 0.569700, 0.261721],\n    [0.970205, 0.575028, 0.258325],\n    [0.971835, 0.580382, 0.254931],\n    [0.973416, 0.585761, 0.251540],\n    [0.974947, 0.591165, 0.248151],\n    [0.976428, 0.596595, 0.244767],\n    [0.977856, 0.602051, 0.241387],\n    [0.979233, 0.607532, 0.238013],\n    [0.980556, 0.613039, 0.234646],\n    [0.981826, 0.618572, 0.231287],\n    [0.983041, 0.624131, 0.227937],\n    [0.984199, 0.629718, 0.224595],\n    [0.985301, 0.635330, 0.221265],\n    [0.986345, 0.640969, 0.217948],\n    [0.987332, 0.646633, 0.214648],\n    [0.988260, 0.652325, 0.211364],\n    [0.989128, 0.658043, 0.208100],\n    [0.989935, 0.663787, 0.204859],\n    [0.990681, 0.669558, 0.201642],\n    [0.991365, 0.675355, 0.198453],\n    [0.991985, 0.681179, 0.195295],\n    [0.992541, 0.687030, 0.192170],\n    [0.993032, 0.692907, 0.189084],\n    [0.993456, 0.698810, 0.186041],\n    [0.993814, 0.704741, 0.183043],\n    [0.994103, 0.710698, 0.180097],\n    [0.994324, 0.716681, 0.177208],\n    [0.994474, 0.722691, 0.174381],\n    [0.994553, 0.728728, 0.171622],\n    [0.994561, 0.734791, 0.168938],\n    [0.994495, 0.740880, 0.166335],\n    [0.994355, 0.746995, 0.163821],\n    [0.994141, 0.753137, 0.161404],\n    [0.993851, 0.759304, 0.159092],\n    [0.993482, 0.765499, 0.156891],\n    [0.993033, 0.771720, 0.154808],\n    [0.992505, 0.777967, 0.152855],\n    [0.991897, 0.784239, 0.151042],\n    [0.991209, 0.790537, 0.149377],\n    [0.990439, 0.796859, 0.147870],\n    [0.989587, 0.803205, 0.146529],\n    [0.988648, 0.809579, 0.145357],\n    [0.987621, 0.815978, 0.144363],\n    [0.986509, 0.822401, 0.143557],\n    [0.985314, 0.828846, 0.142945],\n    [0.984031, 0.835315, 0.142528],\n    [0.982653, 0.841812, 0.142303],\n    [0.981190, 0.848329, 0.142279],\n    [0.979644, 0.854866, 0.142453],\n    [0.977995, 0.861432, 0.142808],\n    [0.976265, 0.868016, 0.143351],\n    [0.974443, 0.874622, 0.144061],\n    [0.972530, 0.881250, 0.144923],\n    [0.970533, 0.887896, 0.145919],\n    [0.968443, 0.894564, 0.147014],\n    [0.966271, 0.901249, 0.148180],\n    [0.964021, 0.907950, 0.149370],\n    [0.961681, 0.914672, 0.150520],\n    [0.959276, 0.921407, 0.151566],\n    [0.956808, 0.928152, 0.152409],\n    [0.954287, 0.934908, 0.152921],\n    [0.951726, 0.941671, 0.152925],\n    [0.949151, 0.948435, 0.152178],\n    [0.946602, 0.955190, 0.150328],\n    [0.944152, 0.961916, 0.146861],\n    [0.941896, 0.968590, 0.140956],\n    [0.940015, 0.975158, 0.131326],\n]\n\n_viridis_data = [\n    [0.267004, 0.004874, 0.329415],\n    [0.268510, 0.009605, 0.335427],\n    [0.269944, 0.014625, 0.341379],\n    [0.271305, 0.019942, 0.347269],\n    [0.272594, 0.025563, 0.353093],\n    [0.273809, 0.031497, 0.358853],\n    [0.274952, 0.037752, 0.364543],\n    [0.276022, 0.044167, 0.370164],\n    [0.277018, 0.050344, 0.375715],\n    [0.277941, 0.056324, 0.381191],\n    [0.278791, 0.062145, 0.386592],\n    [0.279566, 0.067836, 0.391917],\n    [0.280267, 0.073417, 0.397163],\n    [0.280894, 0.078907, 0.402329],\n    [0.281446, 0.084320, 0.407414],\n    [0.281924, 0.089666, 0.412415],\n    [0.282327, 0.094955, 0.417331],\n    [0.282656, 0.100196, 0.422160],\n    [0.282910, 0.105393, 0.426902],\n    [0.283091, 0.110553, 0.431554],\n    [0.283197, 0.115680, 0.436115],\n    [0.283229, 0.120777, 0.440584],\n    [0.283187, 0.125848, 0.444960],\n    [0.283072, 0.130895, 0.449241],\n    [0.282884, 0.135920, 0.453427],\n    [0.282623, 0.140926, 0.457517],\n    [0.282290, 0.145912, 0.461510],\n    [0.281887, 0.150881, 0.465405],\n    [0.281412, 0.155834, 0.469201],\n    [0.280868, 0.160771, 0.472899],\n    [0.280255, 0.165693, 0.476498],\n    [0.279574, 0.170599, 0.479997],\n    [0.278826, 0.175490, 0.483397],\n    [0.278012, 0.180367, 0.486697],\n    [0.277134, 0.185228, 0.489898],\n    [0.276194, 0.190074, 0.493001],\n    [0.275191, 0.194905, 0.496005],\n    [0.274128, 0.199721, 0.498911],\n    [0.273006, 0.204520, 0.501721],\n    [0.271828, 0.209303, 0.504434],\n    [0.270595, 0.214069, 0.507052],\n    [0.269308, 0.218818, 0.509577],\n    [0.267968, 0.223549, 0.512008],\n    [0.266580, 0.228262, 0.514349],\n    [0.265145, 0.232956, 0.516599],\n    [0.263663, 0.237631, 0.518762],\n    [0.262138, 0.242286, 0.520837],\n    [0.260571, 0.246922, 0.522828],\n    [0.258965, 0.251537, 0.524736],\n    [0.257322, 0.256130, 0.526563],\n    [0.255645, 0.260703, 0.528312],\n    [0.253935, 0.265254, 0.529983],\n    [0.252194, 0.269783, 0.531579],\n    [0.250425, 0.274290, 0.533103],\n    [0.248629, 0.278775, 0.534556],\n    [0.246811, 0.283237, 0.535941],\n    [0.244972, 0.287675, 0.537260],\n    [0.243113, 0.292092, 0.538516],\n    [0.241237, 0.296485, 0.539709],\n    [0.239346, 0.300855, 0.540844],\n    [0.237441, 0.305202, 0.541921],\n    [0.235526, 0.309527, 0.542944],\n    [0.233603, 0.313828, 0.543914],\n    [0.231674, 0.318106, 0.544834],\n    [0.229739, 0.322361, 0.545706],\n    [0.227802, 0.326594, 0.546532],\n    [0.225863, 0.330805, 0.547314],\n    [0.223925, 0.334994, 0.548053],\n    [0.221989, 0.339161, 0.548752],\n    [0.220057, 0.343307, 0.549413],\n    [0.218130, 0.347432, 0.550038],\n    [0.216210, 0.351535, 0.550627],\n    [0.214298, 0.355619, 0.551184],\n    [0.212395, 0.359683, 0.551710],\n    [0.210503, 0.363727, 0.552206],\n    [0.208623, 0.367752, 0.552675],\n    [0.206756, 0.371758, 0.553117],\n    [0.204903, 0.375746, 0.553533],\n    [0.203063, 0.379716, 0.553925],\n    [0.201239, 0.383670, 0.554294],\n    [0.199430, 0.387607, 0.554642],\n    [0.197636, 0.391528, 0.554969],\n    [0.195860, 0.395433, 0.555276],\n    [0.194100, 0.399323, 0.555565],\n    [0.192357, 0.403199, 0.555836],\n    [0.190631, 0.407061, 0.556089],\n    [0.188923, 0.410910, 0.556326],\n    [0.187231, 0.414746, 0.556547],\n    [0.185556, 0.418570, 0.556753],\n    [0.183898, 0.422383, 0.556944],\n    [0.182256, 0.426184, 0.557120],\n    [0.180629, 0.429975, 0.557282],\n    [0.179019, 0.433756, 0.557430],\n    [0.177423, 0.437527, 0.557565],\n    [0.175841, 0.441290, 0.557685],\n    [0.174274, 0.445044, 0.557792],\n    [0.172719, 0.448791, 0.557885],\n    [0.171176, 0.452530, 0.557965],\n    [0.169646, 0.456262, 0.558030],\n    [0.168126, 0.459988, 0.558082],\n    [0.166617, 0.463708, 0.558119],\n    [0.165117, 0.467423, 0.558141],\n    [0.163625, 0.471133, 0.558148],\n    [0.162142, 0.474838, 0.558140],\n    [0.160665, 0.478540, 0.558115],\n    [0.159194, 0.482237, 0.558073],\n    [0.157729, 0.485932, 0.558013],\n    [0.156270, 0.489624, 0.557936],\n    [0.154815, 0.493313, 0.557840],\n    [0.153364, 0.497000, 0.557724],\n    [0.151918, 0.500685, 0.557587],\n    [0.150476, 0.504369, 0.557430],\n    [0.149039, 0.508051, 0.557250],\n    [0.147607, 0.511733, 0.557049],\n    [0.146180, 0.515413, 0.556823],\n    [0.144759, 0.519093, 0.556572],\n    [0.143343, 0.522773, 0.556295],\n    [0.141935, 0.526453, 0.555991],\n    [0.140536, 0.530132, 0.555659],\n    [0.139147, 0.533812, 0.555298],\n    [0.137770, 0.537492, 0.554906],\n    [0.136408, 0.541173, 0.554483],\n    [0.135066, 0.544853, 0.554029],\n    [0.133743, 0.548535, 0.553541],\n    [0.132444, 0.552216, 0.553018],\n    [0.131172, 0.555899, 0.552459],\n    [0.129933, 0.559582, 0.551864],\n    [0.128729, 0.563265, 0.551229],\n    [0.127568, 0.566949, 0.550556],\n    [0.126453, 0.570633, 0.549841],\n    [0.125394, 0.574318, 0.549086],\n    [0.124395, 0.578002, 0.548287],\n    [0.123463, 0.581687, 0.547445],\n    [0.122606, 0.585371, 0.546557],\n    [0.121831, 0.589055, 0.545623],\n    [0.121148, 0.592739, 0.544641],\n    [0.120565, 0.596422, 0.543611],\n    [0.120092, 0.600104, 0.542530],\n    [0.119738, 0.603785, 0.541400],\n    [0.119512, 0.607464, 0.540218],\n    [0.119423, 0.611141, 0.538982],\n    [0.119483, 0.614817, 0.537692],\n    [0.119699, 0.618490, 0.536347],\n    [0.120081, 0.622161, 0.534946],\n    [0.120638, 0.625828, 0.533488],\n    [0.121380, 0.629492, 0.531973],\n    [0.122312, 0.633153, 0.530398],\n    [0.123444, 0.636809, 0.528763],\n    [0.124780, 0.640461, 0.527068],\n    [0.126326, 0.644107, 0.525311],\n    [0.128087, 0.647749, 0.523491],\n    [0.130067, 0.651384, 0.521608],\n    [0.132268, 0.655014, 0.519661],\n    [0.134692, 0.658636, 0.517649],\n    [0.137339, 0.662252, 0.515571],\n    [0.140210, 0.665859, 0.513427],\n    [0.143303, 0.669459, 0.511215],\n    [0.146616, 0.673050, 0.508936],\n    [0.150148, 0.676631, 0.506589],\n    [0.153894, 0.680203, 0.504172],\n    [0.157851, 0.683765, 0.501686],\n    [0.162016, 0.687316, 0.499129],\n    [0.166383, 0.690856, 0.496502],\n    [0.170948, 0.694384, 0.493803],\n    [0.175707, 0.697900, 0.491033],\n    [0.180653, 0.701402, 0.488189],\n    [0.185783, 0.704891, 0.485273],\n    [0.191090, 0.708366, 0.482284],\n    [0.196571, 0.711827, 0.479221],\n    [0.202219, 0.715272, 0.476084],\n    [0.208030, 0.718701, 0.472873],\n    [0.214000, 0.722114, 0.469588],\n    [0.220124, 0.725509, 0.466226],\n    [0.226397, 0.728888, 0.462789],\n    [0.232815, 0.732247, 0.459277],\n    [0.239374, 0.735588, 0.455688],\n    [0.246070, 0.738910, 0.452024],\n    [0.252899, 0.742211, 0.448284],\n    [0.259857, 0.745492, 0.444467],\n    [0.266941, 0.748751, 0.440573],\n    [0.274149, 0.751988, 0.436601],\n    [0.281477, 0.755203, 0.432552],\n    [0.288921, 0.758394, 0.428426],\n    [0.296479, 0.761561, 0.424223],\n    [0.304148, 0.764704, 0.419943],\n    [0.311925, 0.767822, 0.415586],\n    [0.319809, 0.770914, 0.411152],\n    [0.327796, 0.773980, 0.406640],\n    [0.335885, 0.777018, 0.402049],\n    [0.344074, 0.780029, 0.397381],\n    [0.352360, 0.783011, 0.392636],\n    [0.360741, 0.785964, 0.387814],\n    [0.369214, 0.788888, 0.382914],\n    [0.377779, 0.791781, 0.377939],\n    [0.386433, 0.794644, 0.372886],\n    [0.395174, 0.797475, 0.367757],\n    [0.404001, 0.800275, 0.362552],\n    [0.412913, 0.803041, 0.357269],\n    [0.421908, 0.805774, 0.351910],\n    [0.430983, 0.808473, 0.346476],\n    [0.440137, 0.811138, 0.340967],\n    [0.449368, 0.813768, 0.335384],\n    [0.458674, 0.816363, 0.329727],\n    [0.468053, 0.818921, 0.323998],\n    [0.477504, 0.821444, 0.318195],\n    [0.487026, 0.823929, 0.312321],\n    [0.496615, 0.826376, 0.306377],\n    [0.506271, 0.828786, 0.300362],\n    [0.515992, 0.831158, 0.294279],\n    [0.525776, 0.833491, 0.288127],\n    [0.535621, 0.835785, 0.281908],\n    [0.545524, 0.838039, 0.275626],\n    [0.555484, 0.840254, 0.269281],\n    [0.565498, 0.842430, 0.262877],\n    [0.575563, 0.844566, 0.256415],\n    [0.585678, 0.846661, 0.249897],\n    [0.595839, 0.848717, 0.243329],\n    [0.606045, 0.850733, 0.236712],\n    [0.616293, 0.852709, 0.230052],\n    [0.626579, 0.854645, 0.223353],\n    [0.636902, 0.856542, 0.216620],\n    [0.647257, 0.858400, 0.209861],\n    [0.657642, 0.860219, 0.203082],\n    [0.668054, 0.861999, 0.196293],\n    [0.678489, 0.863742, 0.189503],\n    [0.688944, 0.865448, 0.182725],\n    [0.699415, 0.867117, 0.175971],\n    [0.709898, 0.868751, 0.169257],\n    [0.720391, 0.870350, 0.162603],\n    [0.730889, 0.871916, 0.156029],\n    [0.741388, 0.873449, 0.149561],\n    [0.751884, 0.874951, 0.143228],\n    [0.762373, 0.876424, 0.137064],\n    [0.772852, 0.877868, 0.131109],\n    [0.783315, 0.879285, 0.125405],\n    [0.793760, 0.880678, 0.120005],\n    [0.804182, 0.882046, 0.114965],\n    [0.814576, 0.883393, 0.110347],\n    [0.824940, 0.884720, 0.106217],\n    [0.835270, 0.886029, 0.102646],\n    [0.845561, 0.887322, 0.099702],\n    [0.855810, 0.888601, 0.097452],\n    [0.866013, 0.889868, 0.095953],\n    [0.876168, 0.891125, 0.095250],\n    [0.886271, 0.892374, 0.095374],\n    [0.896320, 0.893616, 0.096335],\n    [0.906311, 0.894855, 0.098125],\n    [0.916242, 0.896091, 0.100717],\n    [0.926106, 0.897330, 0.104071],\n    [0.935904, 0.898570, 0.108131],\n    [0.945636, 0.899815, 0.112838],\n    [0.955300, 0.901065, 0.118128],\n    [0.964894, 0.902323, 0.123941],\n    [0.974417, 0.903590, 0.130215],\n    [0.983868, 0.904867, 0.136897],\n    [0.993248, 0.906157, 0.143936],\n]\n\n_cividis_data = [\n    [0.000000, 0.135112, 0.304751],\n    [0.000000, 0.138068, 0.311105],\n    [0.000000, 0.141013, 0.317579],\n    [0.000000, 0.143951, 0.323982],\n    [0.000000, 0.146877, 0.330479],\n    [0.000000, 0.149791, 0.337065],\n    [0.000000, 0.152673, 0.343704],\n    [0.000000, 0.155377, 0.350500],\n    [0.000000, 0.157932, 0.357521],\n    [0.000000, 0.160495, 0.364534],\n    [0.000000, 0.163058, 0.371608],\n    [0.000000, 0.165621, 0.378769],\n    [0.000000, 0.168204, 0.385902],\n    [0.000000, 0.170800, 0.393100],\n    [0.000000, 0.173420, 0.400353],\n    [0.000000, 0.176082, 0.407577],\n    [0.000000, 0.178802, 0.414764],\n    [0.000000, 0.181610, 0.421859],\n    [0.000000, 0.184550, 0.428802],\n    [0.000000, 0.186915, 0.435532],\n    [0.000000, 0.188769, 0.439563],\n    [0.000000, 0.190950, 0.441085],\n    [0.000000, 0.193366, 0.441561],\n    [0.003602, 0.195911, 0.441564],\n    [0.017852, 0.198528, 0.441248],\n    [0.032110, 0.201199, 0.440785],\n    [0.046205, 0.203903, 0.440196],\n    [0.058378, 0.206629, 0.439531],\n    [0.068968, 0.209372, 0.438863],\n    [0.078624, 0.212122, 0.438105],\n    [0.087465, 0.214879, 0.437342],\n    [0.095645, 0.217643, 0.436593],\n    [0.103401, 0.220406, 0.435790],\n    [0.110658, 0.223170, 0.435067],\n    [0.117612, 0.225935, 0.434308],\n    [0.124291, 0.228697, 0.433547],\n    [0.130669, 0.231458, 0.432840],\n    [0.136830, 0.234216, 0.432148],\n    [0.142852, 0.236972, 0.431404],\n    [0.148638, 0.239724, 0.430752],\n    [0.154261, 0.242475, 0.430120],\n    [0.159733, 0.245221, 0.429528],\n    [0.165113, 0.247965, 0.428908],\n    [0.170362, 0.250707, 0.428325],\n    [0.175490, 0.253444, 0.427790],\n    [0.180503, 0.256180, 0.427299],\n    [0.185453, 0.258914, 0.426788],\n    [0.190303, 0.261644, 0.426329],\n    [0.195057, 0.264372, 0.425924],\n    [0.199764, 0.267099, 0.425497],\n    [0.204385, 0.269823, 0.425126],\n    [0.208926, 0.272546, 0.424809],\n    [0.213431, 0.275266, 0.424480],\n    [0.217863, 0.277985, 0.424206],\n    [0.222264, 0.280702, 0.423914],\n    [0.226598, 0.283419, 0.423678],\n    [0.230871, 0.286134, 0.423498],\n    [0.235120, 0.288848, 0.423304],\n    [0.239312, 0.291562, 0.423167],\n    [0.243485, 0.294274, 0.423014],\n    [0.247605, 0.296986, 0.422917],\n    [0.251675, 0.299698, 0.422873],\n    [0.255731, 0.302409, 0.422814],\n    [0.259740, 0.305120, 0.422810],\n    [0.263738, 0.307831, 0.422789],\n    [0.267693, 0.310542, 0.422821],\n    [0.271639, 0.313253, 0.422837],\n    [0.275513, 0.315965, 0.422979],\n    [0.279411, 0.318677, 0.423031],\n    [0.283240, 0.321390, 0.423211],\n    [0.287065, 0.324103, 0.423373],\n    [0.290884, 0.326816, 0.423517],\n    [0.294669, 0.329531, 0.423716],\n    [0.298421, 0.332247, 0.423973],\n    [0.302169, 0.334963, 0.424213],\n    [0.305886, 0.337681, 0.424512],\n    [0.309601, 0.340399, 0.424790],\n    [0.313287, 0.343120, 0.425120],\n    [0.316941, 0.345842, 0.425512],\n    [0.320595, 0.348565, 0.425889],\n    [0.324250, 0.351289, 0.426250],\n    [0.327875, 0.354016, 0.426670],\n    [0.331474, 0.356744, 0.427144],\n    [0.335073, 0.359474, 0.427605],\n    [0.338673, 0.362206, 0.428053],\n    [0.342246, 0.364939, 0.428559],\n    [0.345793, 0.367676, 0.429127],\n    [0.349341, 0.370414, 0.429685],\n    [0.352892, 0.373153, 0.430226],\n    [0.356418, 0.375896, 0.430823],\n    [0.359916, 0.378641, 0.431501],\n    [0.363446, 0.381388, 0.432075],\n    [0.366923, 0.384139, 0.432796],\n    [0.370430, 0.386890, 0.433428],\n    [0.373884, 0.389646, 0.434209],\n    [0.377371, 0.392404, 0.434890],\n    [0.380830, 0.395164, 0.435653],\n    [0.384268, 0.397928, 0.436475],\n    [0.387705, 0.400694, 0.437305],\n    [0.391151, 0.403464, 0.438096],\n    [0.394568, 0.406236, 0.438986],\n    [0.397991, 0.409011, 0.439848],\n    [0.401418, 0.411790, 0.440708],\n    [0.404820, 0.414572, 0.441642],\n    [0.408226, 0.417357, 0.442570],\n    [0.411607, 0.420145, 0.443577],\n    [0.414992, 0.422937, 0.444578],\n    [0.418383, 0.425733, 0.445560],\n    [0.421748, 0.428531, 0.446640],\n    [0.425120, 0.431334, 0.447692],\n    [0.428462, 0.434140, 0.448864],\n    [0.431817, 0.436950, 0.449982],\n    [0.435168, 0.439763, 0.451134],\n    [0.438504, 0.442580, 0.452341],\n    [0.441810, 0.445402, 0.453659],\n    [0.445148, 0.448226, 0.454885],\n    [0.448447, 0.451053, 0.456264],\n    [0.451759, 0.453887, 0.457582],\n    [0.455072, 0.456718, 0.458976],\n    [0.458366, 0.459552, 0.460457],\n    [0.461616, 0.462405, 0.461969],\n    [0.464947, 0.465241, 0.463395],\n    [0.468254, 0.468083, 0.464908],\n    [0.471501, 0.470960, 0.466357],\n    [0.474812, 0.473832, 0.467681],\n    [0.478186, 0.476699, 0.468845],\n    [0.481622, 0.479573, 0.469767],\n    [0.485141, 0.482451, 0.470384],\n    [0.488697, 0.485318, 0.471008],\n    [0.492278, 0.488198, 0.471453],\n    [0.495913, 0.491076, 0.471751],\n    [0.499552, 0.493960, 0.472032],\n    [0.503185, 0.496851, 0.472305],\n    [0.506866, 0.499743, 0.472432],\n    [0.510540, 0.502643, 0.472550],\n    [0.514226, 0.505546, 0.472640],\n    [0.517920, 0.508454, 0.472707],\n    [0.521643, 0.511367, 0.472639],\n    [0.525348, 0.514285, 0.472660],\n    [0.529086, 0.517207, 0.472543],\n    [0.532829, 0.520135, 0.472401],\n    [0.536553, 0.523067, 0.472352],\n    [0.540307, 0.526005, 0.472163],\n    [0.544069, 0.528948, 0.471947],\n    [0.547840, 0.531895, 0.471704],\n    [0.551612, 0.534849, 0.471439],\n    [0.555393, 0.537807, 0.471147],\n    [0.559181, 0.540771, 0.470829],\n    [0.562972, 0.543741, 0.470488],\n    [0.566802, 0.546715, 0.469988],\n    [0.570607, 0.549695, 0.469593],\n    [0.574417, 0.552682, 0.469172],\n    [0.578236, 0.555673, 0.468724],\n    [0.582087, 0.558670, 0.468118],\n    [0.585916, 0.561674, 0.467618],\n    [0.589753, 0.564682, 0.467090],\n    [0.593622, 0.567697, 0.466401],\n    [0.597469, 0.570718, 0.465821],\n    [0.601354, 0.573743, 0.465074],\n    [0.605211, 0.576777, 0.464441],\n    [0.609105, 0.579816, 0.463638],\n    [0.612977, 0.582861, 0.462950],\n    [0.616852, 0.585913, 0.462237],\n    [0.620765, 0.588970, 0.461351],\n    [0.624654, 0.592034, 0.460583],\n    [0.628576, 0.595104, 0.459641],\n    [0.632506, 0.598180, 0.458668],\n    [0.636412, 0.601264, 0.457818],\n    [0.640352, 0.604354, 0.456791],\n    [0.644270, 0.607450, 0.455886],\n    [0.648222, 0.610553, 0.454801],\n    [0.652178, 0.613664, 0.453689],\n    [0.656114, 0.616780, 0.452702],\n    [0.660082, 0.619904, 0.451534],\n    [0.664055, 0.623034, 0.450338],\n    [0.668008, 0.626171, 0.449270],\n    [0.671991, 0.629316, 0.448018],\n    [0.675981, 0.632468, 0.446736],\n    [0.679979, 0.635626, 0.445424],\n    [0.683950, 0.638793, 0.444251],\n    [0.687957, 0.641966, 0.442886],\n    [0.691971, 0.645145, 0.441491],\n    [0.695985, 0.648334, 0.440072],\n    [0.700008, 0.651529, 0.438624],\n    [0.704037, 0.654731, 0.437147],\n    [0.708067, 0.657942, 0.435647],\n    [0.712105, 0.661160, 0.434117],\n    [0.716177, 0.664384, 0.432386],\n    [0.720222, 0.667618, 0.430805],\n    [0.724274, 0.670859, 0.429194],\n    [0.728334, 0.674107, 0.427554],\n    [0.732422, 0.677364, 0.425717],\n    [0.736488, 0.680629, 0.424028],\n    [0.740589, 0.683900, 0.422131],\n    [0.744664, 0.687181, 0.420393],\n    [0.748772, 0.690470, 0.418448],\n    [0.752886, 0.693766, 0.416472],\n    [0.756975, 0.697071, 0.414659],\n    [0.761096, 0.700384, 0.412638],\n    [0.765223, 0.703705, 0.410587],\n    [0.769353, 0.707035, 0.408516],\n    [0.773486, 0.710373, 0.406422],\n    [0.777651, 0.713719, 0.404112],\n    [0.781795, 0.717074, 0.401966],\n    [0.785965, 0.720438, 0.399613],\n    [0.790116, 0.723810, 0.397423],\n    [0.794298, 0.727190, 0.395016],\n    [0.798480, 0.730580, 0.392597],\n    [0.802667, 0.733978, 0.390153],\n    [0.806859, 0.737385, 0.387684],\n    [0.811054, 0.740801, 0.385198],\n    [0.815274, 0.744226, 0.382504],\n    [0.819499, 0.747659, 0.379785],\n    [0.823729, 0.751101, 0.377043],\n    [0.827959, 0.754553, 0.374292],\n    [0.832192, 0.758014, 0.371529],\n    [0.836429, 0.761483, 0.368747],\n    [0.840693, 0.764962, 0.365746],\n    [0.844957, 0.768450, 0.362741],\n    [0.849223, 0.771947, 0.359729],\n    [0.853515, 0.775454, 0.356500],\n    [0.857809, 0.778969, 0.353259],\n    [0.862105, 0.782494, 0.350011],\n    [0.866421, 0.786028, 0.346571],\n    [0.870717, 0.789572, 0.343333],\n    [0.875057, 0.793125, 0.339685],\n    [0.879378, 0.796687, 0.336241],\n    [0.883720, 0.800258, 0.332599],\n    [0.888081, 0.803839, 0.328770],\n    [0.892440, 0.807430, 0.324968],\n    [0.896818, 0.811030, 0.320982],\n    [0.901195, 0.814639, 0.317021],\n    [0.905589, 0.818257, 0.312889],\n    [0.910000, 0.821885, 0.308594],\n    [0.914407, 0.825522, 0.304348],\n    [0.918828, 0.829168, 0.299960],\n    [0.923279, 0.832822, 0.295244],\n    [0.927724, 0.836486, 0.290611],\n    [0.932180, 0.840159, 0.285880],\n    [0.936660, 0.843841, 0.280876],\n    [0.941147, 0.847530, 0.275815],\n    [0.945654, 0.851228, 0.270532],\n    [0.950178, 0.854933, 0.265085],\n    [0.954725, 0.858646, 0.259365],\n    [0.959284, 0.862365, 0.253563],\n    [0.963872, 0.866089, 0.247445],\n    [0.968469, 0.869819, 0.241310],\n    [0.973114, 0.873550, 0.234677],\n    [0.977780, 0.877281, 0.227954],\n    [0.982497, 0.881008, 0.220878],\n    [0.987293, 0.884718, 0.213336],\n    [0.992218, 0.888385, 0.205468],\n    [0.994847, 0.892954, 0.203445],\n    [0.995249, 0.898384, 0.207561],\n    [0.995503, 0.903866, 0.212370],\n    [0.995737, 0.909344, 0.217772],\n]\n\n_twilight_data = [\n    [0.88575015840754434, 0.85000924943067835, 0.8879736506427196],\n    [0.88378520195539056, 0.85072940540310626, 0.88723222096949894],\n    [0.88172231059285788, 0.85127594077653468, 0.88638056925514819],\n    [0.8795410528270573, 0.85165675407495722, 0.8854143767924102],\n    [0.87724880858965482, 0.85187028338870274, 0.88434120381311432],\n    [0.87485347508575972, 0.85191526123023187, 0.88316926967613829],\n    [0.87233134085124076, 0.85180165478080894, 0.88189704355001619],\n    [0.86970474853509816, 0.85152403004797894, 0.88053883390003362],\n    [0.86696015505333579, 0.8510896085314068, 0.87909766977173343],\n    [0.86408985081463996, 0.85050391167507788, 0.87757925784892632],\n    [0.86110245436899846, 0.84976754857001258, 0.87599242923439569],\n    [0.85798259245670372, 0.84888934810281835, 0.87434038553446281],\n    [0.85472593189256985, 0.84787488124672816, 0.8726282980930582],\n    [0.85133714570857189, 0.84672735796116472, 0.87086081657350445],\n    [0.84780710702577922, 0.8454546229209523, 0.86904036783694438],\n    [0.8441261828674842, 0.84406482711037389, 0.86716973322690072],\n    [0.84030420805957784, 0.8425605950855084, 0.865250882410458],\n    [0.83634031809191178, 0.84094796518951942, 0.86328528001070159],\n    [0.83222705712934408, 0.83923490627754482, 0.86127563500427884],\n    [0.82796894316013536, 0.83742600751395202, 0.85922399451306786],\n    [0.82357429680252847, 0.83552487764795436, 0.85713191328514948],\n    [0.81904654677937527, 0.8335364929949034, 0.85500206287010105],\n    [0.81438982121143089, 0.83146558694197847, 0.85283759062147024],\n    [0.8095999819094809, 0.82931896673505456, 0.85064441601050367],\n    [0.80469164429814577, 0.82709838780560663, 0.84842449296974021],\n    [0.79967075421267997, 0.82480781812080928, 0.84618210029578533],\n    [0.79454305089231114, 0.82245116226304615, 0.84392184786827984],\n    [0.78931445564608915, 0.82003213188702007, 0.8416486380471222],\n    [0.78399101042764918, 0.81755426400533426, 0.83936747464036732],\n    [0.77857892008227592, 0.81502089378742548, 0.8370834463093898],\n    [0.77308416590170936, 0.81243524735466011, 0.83480172950579679],\n    [0.76751108504417864, 0.8098007598713145, 0.83252816638059668],\n    [0.76186907937980286, 0.80711949387647486, 0.830266486168872],\n    [0.75616443584381976, 0.80439408733477935, 0.82802138994719998],\n    [0.75040346765406696, 0.80162699008965321, 0.82579737851082424],\n    [0.74459247771890169, 0.79882047719583249, 0.82359867586156521],\n    [0.73873771700494939, 0.79597665735031009, 0.82142922780433014],\n    [0.73284543645523459, 0.79309746468844067, 0.81929263384230377],\n    [0.72692177512829703, 0.7901846863592763, 0.81719217466726379],\n    [0.72097280665536778, 0.78723995923452639, 0.81513073920879264],\n    [0.71500403076252128, 0.78426487091581187, 0.81311116559949914],\n    [0.70902078134539304, 0.78126088716070907, 0.81113591855117928],\n    [0.7030297722540817, 0.77822904973358131, 0.80920618848056969],\n    [0.6970365443886174, 0.77517050008066057, 0.80732335380063447],\n    [0.69104641009309098, 0.77208629460678091, 0.80548841690679074],\n    [0.68506446154395928, 0.7689774029354699, 0.80370206267176914],\n    [0.67909554499882152, 0.76584472131395898, 0.8019646617300199],\n    [0.67314422559426212, 0.76268908733890484, 0.80027628545809526],\n    [0.66721479803752815, 0.7595112803730375, 0.79863674654537764],\n    [0.6613112930078745, 0.75631202708719025, 0.7970456043491897],\n    [0.65543692326454717, 0.75309208756768431, 0.79550271129031047],\n    [0.64959573004253479, 0.74985201221941766, 0.79400674021499107],\n    [0.6437910831099849, 0.7465923800833657, 0.79255653201306053],\n    [0.63802586828545982, 0.74331376714033193, 0.79115100459573173],\n    [0.6323027138710603, 0.74001672160131404, 0.78978892762640429],\n    [0.62662402022604591, 0.73670175403699445, 0.78846901316334561],\n    [0.62099193064817548, 0.73336934798923203, 0.78718994624696581],\n    [0.61540846411770478, 0.73001995232739691, 0.78595022706750484],\n    [0.60987543176093062, 0.72665398759758293, 0.78474835732694714],\n    [0.60439434200274855, 0.7232718614323369, 0.78358295593535587],\n    [0.5989665814482068, 0.71987394892246725, 0.78245259899346642],\n    [0.59359335696837223, 0.7164606049658685, 0.78135588237640097],\n    [0.58827579780555495, 0.71303214646458135, 0.78029141405636515],\n    [0.58301487036932409, 0.70958887676997473, 0.77925781820476592],\n    [0.5778116438998202, 0.70613106157153982, 0.77825345121025524],\n    [0.5726668948158774, 0.7026589535425779, 0.77727702680911992],\n    [0.56758117853861967, 0.69917279302646274, 0.77632748534275298],\n    [0.56255515357219343, 0.69567278381629649, 0.77540359142309845],\n    [0.55758940419605174, 0.69215911458254054, 0.7745041337932782],\n    [0.55268450589347129, 0.68863194515166382, 0.7736279426902245],\n    [0.54784098153018634, 0.68509142218509878, 0.77277386473440868],\n    [0.54305932424018233, 0.68153767253065878, 0.77194079697835083],\n    [0.53834015575176275, 0.67797081129095405, 0.77112734439057717],\n    [0.53368389147728401, 0.67439093705212727, 0.7703325054879735],\n    [0.529090861832473, 0.67079812302806219, 0.76955552292313134],\n    [0.52456151470593582, 0.66719242996142225, 0.76879541714230948],\n    [0.52009627392235558, 0.66357391434030388, 0.76805119403344102],\n    [0.5156955988596057, 0.65994260812897998, 0.76732191489596169],\n    [0.51135992541601927, 0.65629853981831865, 0.76660663780645333],\n    [0.50708969576451657, 0.65264172403146448, 0.76590445660835849],\n    [0.5028853540415561, 0.64897216734095264, 0.76521446718174913],\n    [0.49874733661356069, 0.6452898684900934, 0.76453578734180083],\n    [0.4946761847863938, 0.64159484119504429, 0.76386719002130909],\n    [0.49067224938561221, 0.63788704858847078, 0.76320812763163837],\n    [0.4867359599430568, 0.63416646251100506, 0.76255780085924041],\n    [0.4828677867260272, 0.6304330455306234, 0.76191537149895305],\n    [0.47906816236197386, 0.62668676251860134, 0.76128000375662419],\n    [0.47533752394906287, 0.62292757283835809, 0.76065085571817748],\n    [0.47167629518877091, 0.61915543242884641, 0.76002709227883047],\n    [0.46808490970531597, 0.61537028695790286, 0.75940789891092741],\n    [0.46456376716303932, 0.61157208822864151, 0.75879242623025811],\n    [0.46111326647023881, 0.607760777169989, 0.75817986436807139],\n    [0.45773377230160567, 0.60393630046586455, 0.75756936901859162],\n    [0.45442563977552913, 0.60009859503858665, 0.75696013660606487],\n    [0.45118918687617743, 0.59624762051353541, 0.75635120643246645],\n    [0.44802470933589172, 0.59238331452146575, 0.75574176474107924],\n    [0.44493246854215379, 0.5885055998308617, 0.7551311041857901],\n    [0.44191271766696399, 0.58461441100175571, 0.75451838884410671],\n    [0.43896563958048396, 0.58070969241098491, 0.75390276208285945],\n    [0.43609138958356369, 0.57679137998186081, 0.7532834105961016],\n    [0.43329008867358393, 0.57285941625606673, 0.75265946532566674],\n    [0.43056179073057571, 0.56891374572457176, 0.75203008099312696],\n    [0.42790652284925834, 0.5649543060909209, 0.75139443521914839],\n    [0.42532423665011354, 0.56098104959950301, 0.75075164989005116],\n    [0.42281485675772662, 0.55699392126996583, 0.75010086988227642],\n    [0.42037822361396326, 0.55299287158108168, 0.7494412559451894],\n    [0.41801414079233629, 0.54897785421888889, 0.74877193167001121],\n    [0.4157223260454232, 0.54494882715350401, 0.74809204459000522],\n    [0.41350245743314729, 0.54090574771098476, 0.74740073297543086],\n    [0.41135414697304568, 0.53684857765005933, 0.74669712855065784],\n    [0.4092768899914751, 0.53277730177130322, 0.74598030635707824],\n    [0.40727018694219069, 0.52869188011057411, 0.74524942637581271],\n    [0.40533343789303178, 0.52459228174983119, 0.74450365836708132],\n    [0.40346600333905397, 0.52047847653840029, 0.74374215223567086],\n    [0.40166714010896104, 0.51635044969688759, 0.7429640345324835],\n    [0.39993606933454834, 0.51220818143218516, 0.74216844571317986],\n    [0.3982719152586337, 0.50805166539276136, 0.74135450918099721],\n    [0.39667374905665609, 0.50388089053847973, 0.74052138580516735],\n    [0.39514058808207631, 0.49969585326377758, 0.73966820211715711],\n    [0.39367135736822567, 0.49549655777451179, 0.738794102296364],\n    [0.39226494876209317, 0.49128300332899261, 0.73789824784475078],\n    [0.39092017571994903, 0.48705520251223039, 0.73697977133881254],\n    [0.38963580160340855, 0.48281316715123496, 0.73603782546932739],\n    [0.38841053300842432, 0.47855691131792805, 0.73507157641157261],\n    [0.38724301459330251, 0.47428645933635388, 0.73408016787854391],\n    [0.38613184178892102, 0.4700018340988123, 0.7330627749243106],\n    [0.38507556793651387, 0.46570306719930193, 0.73201854033690505],\n    [0.38407269378943537, 0.46139018782416635, 0.73094665432902683],\n    [0.38312168084402748, 0.45706323581407199, 0.72984626791353258],\n    [0.38222094988570376, 0.45272225034283325, 0.72871656144003782],\n    [0.38136887930454161, 0.44836727669277859, 0.72755671317141346],\n    [0.38056380696565623, 0.44399837208633719, 0.72636587045135315],\n    [0.37980403744848751, 0.43961558821222629, 0.72514323778761092],\n    [0.37908789283110761, 0.43521897612544935, 0.72388798691323131],\n    [0.378413635091359, 0.43080859411413064, 0.72259931993061044],\n    [0.37777949753513729, 0.4263845142616835, 0.72127639993530235],\n    [0.37718371844251231, 0.42194680223454828, 0.71991841524475775],\n    [0.37662448930806297, 0.41749553747893614, 0.71852454736176108],\n    [0.37610001286385814, 0.41303079952477062, 0.71709396919920232],\n    [0.37560846919442398, 0.40855267638072096, 0.71562585091587549],\n    [0.37514802505380473, 0.4040612609993941, 0.7141193695725726],\n    [0.37471686019302231, 0.3995566498711684, 0.71257368516500463],\n    [0.37431313199312338, 0.39503894828283309, 0.71098796522377461],\n    [0.37393499330475782, 0.39050827529375831, 0.70936134293478448],\n    [0.3735806215098284, 0.38596474386057539, 0.70769297607310577],\n    [0.37324816143326384, 0.38140848555753937, 0.70598200974806036],\n    [0.37293578646665032, 0.37683963835219841, 0.70422755780589941],\n    [0.37264166757849604, 0.37225835004836849, 0.7024287314570723],\n    [0.37236397858465387, 0.36766477862108266, 0.70058463496520773],\n    [0.37210089702443822, 0.36305909736982378, 0.69869434615073722],\n    [0.3718506155898596, 0.35844148285875221, 0.69675695810256544],\n    [0.37161133234400479, 0.3538121372967869, 0.69477149919380887],\n    [0.37138124223736607, 0.34917126878479027, 0.69273703471928827],\n    [0.37115856636209105, 0.34451911410230168, 0.69065253586464992],\n    [0.37094151551337329, 0.33985591488818123, 0.68851703379505125],\n    [0.37072833279422668, 0.33518193808489577, 0.68632948169606767],\n    [0.37051738634484427, 0.33049741244307851, 0.68408888788857214],\n    [0.37030682071842685, 0.32580269697872455, 0.68179411684486679],\n    [0.37009487130772695, 0.3210981375964933, 0.67944405399056851],\n    [0.36987980329025361, 0.31638410101153364, 0.67703755438090574],\n    [0.36965987626565955, 0.31166098762951971, 0.67457344743419545],\n    [0.36943334591276228, 0.30692923551862339, 0.67205052849120617],\n    [0.36919847837592484, 0.30218932176507068, 0.66946754331614522],\n    [0.36895355306596778, 0.29744175492366276, 0.66682322089824264],\n    [0.36869682231895268, 0.29268709856150099, 0.66411625298236909],\n    [0.36842655638020444, 0.28792596437778462, 0.66134526910944602],\n    [0.36814101479899719, 0.28315901221182987, 0.65850888806972308],\n    [0.36783843696531082, 0.27838697181297761, 0.65560566838453704],\n    [0.36751707094367697, 0.27361063317090978, 0.65263411711618635],\n    [0.36717513650699446, 0.26883085667326956, 0.64959272297892245],\n    [0.36681085540107988, 0.26404857724525643, 0.64647991652908243],\n    [0.36642243251550632, 0.25926481158628106, 0.64329409140765537],\n    [0.36600853966739794, 0.25448043878086224, 0.64003361803368586],\n    [0.36556698373538982, 0.24969683475296395, 0.63669675187488584],\n    [0.36509579845886808, 0.24491536803550484, 0.63328173520055586],\n    [0.36459308890125008, 0.24013747024823828, 0.62978680155026101],\n    [0.36405693022088509, 0.23536470386204195, 0.62621013451953023],\n    [0.36348537610385145, 0.23059876218396419, 0.62254988622392882],\n    [0.36287643560041027, 0.22584149293287031, 0.61880417410823019],\n    [0.36222809558295926, 0.22109488427338303, 0.61497112346096128],\n    [0.36153829010998356, 0.21636111429594002, 0.61104880679640927],\n    [0.36080493826624654, 0.21164251793458128, 0.60703532172064711],\n    [0.36002681809096376, 0.20694122817889948, 0.60292845431916875],\n    [0.35920088560930186, 0.20226037920758122, 0.5987265295935138],\n    [0.35832489966617809, 0.197602942459778, 0.59442768517501066],\n    [0.35739663292915563, 0.19297208197842461, 0.59003011251063131],\n    [0.35641381143126327, 0.18837119869242164, 0.5855320765920552],\n    [0.35537415306906722, 0.18380392577704466, 0.58093191431832802],\n    [0.35427534960663759, 0.17927413271618647, 0.57622809660668717],\n    [0.35311574421123737, 0.17478570377561287, 0.57141871523555288],\n    [0.35189248608873791, 0.17034320478524959, 0.56650284911216653],\n    [0.35060304441931012, 0.16595129984720861, 0.56147964703993225],\n    [0.34924513554955644, 0.16161477763045118, 0.55634837474163779],\n    [0.34781653238777782, 0.15733863511152979, 0.55110853452703257],\n    [0.34631507175793091, 0.15312802296627787, 0.5457599924248665],\n    [0.34473901574536375, 0.14898820589826409, 0.54030245920406539],\n    [0.34308600291572294, 0.14492465359918028, 0.53473704282067103],\n    [0.34135411074506483, 0.1409427920655632, 0.52906500940336754],\n    [0.33954168752669694, 0.13704801896718169, 0.52328797535085236],\n    [0.33764732090671112, 0.13324562282438077, 0.51740807573979475],\n    [0.33566978565015315, 0.12954074251271822, 0.51142807215168951],\n    [0.33360804901486002, 0.12593818301005921, 0.50535164796654897],\n    [0.33146154891145124, 0.12244245263391232, 0.49918274588431072],\n    [0.32923005203231409, 0.11905764321981127, 0.49292595612342666],\n    [0.3269137124539796, 0.1157873496841953, 0.48658646495697461],\n    [0.32451307931207785, 0.11263459791730848, 0.48017007211645196],\n    [0.32202882276069322, 0.10960114111258401, 0.47368494725726878],\n    [0.31946262395497965, 0.10668879882392659, 0.46713728801395243],\n    [0.31681648089023501, 0.10389861387653518, 0.46053414662739794],\n    [0.31409278414755532, 0.10123077676403242, 0.45388335612058467],\n    [0.31129434479712365, 0.098684771934052201, 0.44719313715161618],\n    [0.30842444457210105, 0.096259385340577736, 0.44047194882050544],\n    [0.30548675819945936, 0.093952764840823738, 0.43372849999361113],\n    [0.30248536364574252, 0.091761187397303601, 0.42697404043749887],\n    [0.29942483960214772, 0.089682253716750038, 0.42021619665853854],\n    [0.29631000388905288, 0.087713250960463951, 0.41346259134143476],\n    [0.29314593096985248, 0.085850656889620708, 0.40672178082365834],\n    [0.28993792445176608, 0.08409078829085731, 0.40000214725256295],\n    [0.28669151388283165, 0.082429873848480689, 0.39331182532243375],\n    [0.28341239797185225, 0.080864153365499375, 0.38665868550105914],\n    [0.28010638576975472, 0.079389994802261526, 0.38005028528138707],\n    [0.27677939615815589, 0.078003941033788216, 0.37349382846504675],\n    [0.27343739342450812, 0.076702800237496066, 0.36699616136347685],\n    [0.27008637749114051, 0.075483675584275545, 0.36056376228111864],\n    [0.26673233211995284, 0.074344018028546205, 0.35420276066240958],\n    [0.26338121807151404, 0.073281657939897077, 0.34791888996380105],\n    [0.26003895187439957, 0.072294781043362205, 0.3417175669546984],\n    [0.25671191651083902, 0.071380106242082242, 0.33560648984600089],\n    [0.25340685873736807, 0.070533582926851829, 0.3295945757321303],\n    [0.25012845306199383, 0.069758206429106989, 0.32368100685760637],\n    [0.24688226237958999, 0.069053639449204451, 0.31786993834254956],\n    [0.24367372557466271, 0.068419855150922693, 0.31216524050888372],\n    [0.24050813332295939, 0.067857103814855602, 0.30657054493678321],\n    [0.23739062429054825, 0.067365888050555517, 0.30108922184065873],\n    [0.23433055727563878, 0.066935599661639394, 0.29574009929867601],\n    [0.23132955273021344, 0.066576186939090592, 0.29051361067988485],\n    [0.2283917709422868, 0.06628997924139618, 0.28541074411068496],\n    [0.22552164337737857, 0.066078173119395595, 0.28043398847505197],\n    [0.22272706739121817, 0.065933790675651943, 0.27559714652053702],\n    [0.22001251100779617, 0.065857918918907604, 0.27090279994325861],\n    [0.21737845072382705, 0.065859661233562045, 0.26634209349669508],\n    [0.21482843531473683, 0.065940385613778491, 0.26191675992376573],\n    [0.21237411048541005, 0.066085024661758446, 0.25765165093569542],\n    [0.21001214221188125, 0.066308573918947178, 0.2535289048041211],\n    [0.2077442377448806, 0.06661453200418091, 0.24954644291943817],\n    [0.20558051999470117, 0.066990462397868739, 0.24572497420147632],\n    [0.20352007949514977, 0.067444179612424215, 0.24205576625191821],\n    [0.20156133764129841, 0.067983271026200248, 0.23852974228695395],\n    [0.19971571438603364, 0.068592710553704722, 0.23517094067076993],\n    [0.19794834061899208, 0.069314066071660657, 0.23194647381302336],\n    [0.1960826032659409, 0.070321227242423623, 0.22874673279569585],\n    [0.19410351363791453, 0.071608304856891569, 0.22558727307410353],\n    [0.19199449184606268, 0.073182830649273306, 0.22243385243433622],\n    [0.18975853639094634, 0.075019861862143766, 0.2193005075652994],\n    [0.18739228342697645, 0.077102096899588329, 0.21618875376309582],\n    [0.18488035509396164, 0.079425730279723883, 0.21307651648984993],\n    [0.18774482037046955, 0.077251588468039312, 0.21387448578597812],\n    [0.19049578401722037, 0.075311278416787641, 0.2146562337112265],\n    [0.1931548636579131, 0.073606819040117955, 0.21542362939081539],\n    [0.19571853588267552, 0.072157781039602742, 0.21617499187076789],\n    [0.19819343656336558, 0.070974625252738788, 0.21690975060032436],\n    [0.20058760685133747, 0.070064576149984209, 0.21762721310371608],\n    [0.20290365333558247, 0.069435248580458964, 0.21833167885096033],\n    [0.20531725273301316, 0.068919592266397572, 0.21911516689288835],\n    [0.20785704662965598, 0.068484398797025281, 0.22000133917653536],\n    [0.21052882914958676, 0.06812195249816172, 0.22098759107715404],\n    [0.2133313859647627, 0.067830148426026665, 0.22207043213024291],\n    [0.21625279838647882, 0.067616330270516389, 0.22324568672294431],\n    [0.21930503925136402, 0.067465786362940039, 0.22451023616807558],\n    [0.22247308588973624, 0.067388214053092838, 0.22585960379408354],\n    [0.2257539681670791, 0.067382132300147474, 0.22728984778098055],\n    [0.22915620278592841, 0.067434730871152565, 0.22879681433956656],\n    [0.23266299920501882, 0.067557104388479783, 0.23037617493752832],\n    [0.23627495835774248, 0.06774359820987802, 0.23202360805926608],\n    [0.23999586188690308, 0.067985029964779953, 0.23373434258507808],\n    [0.24381149720247919, 0.068289851529011875, 0.23550427698321885],\n    [0.24772092990501099, 0.068653337909486523, 0.2373288009471749],\n    [0.25172899728289466, 0.069064630826035506, 0.23920260612763083],\n    [0.25582135547481771, 0.06953231029187984, 0.24112190491594204],\n    [0.25999463887892144, 0.070053855603861875, 0.24308218808684579],\n    [0.26425512207060942, 0.070616595622995437, 0.24507758869355967],\n    [0.26859095948172862, 0.071226716277922458, 0.24710443563450618],\n    [0.27299701518897301, 0.071883555446163511, 0.24915847093232929],\n    [0.27747150809142801, 0.072582969899254779, 0.25123493995942769],\n    [0.28201746297366942, 0.073315693214040967, 0.25332800295084507],\n    [0.28662309235899847, 0.074088460826808866, 0.25543478673717029],\n    [0.29128515387578635, 0.074899049847466703, 0.25755101595750435],\n    [0.2960004726065818, 0.075745336000958424, 0.25967245030364566],\n    [0.30077276812918691, 0.076617824336164764, 0.26179294097819672],\n    [0.30559226007249934, 0.077521963107537312, 0.26391006692119662],\n    [0.31045520848595526, 0.078456871676182177, 0.2660200572779356],\n    [0.31535870009205808, 0.079420997315243186, 0.26811904076941961],\n    [0.32029986557994061, 0.080412994737554838, 0.27020322893039511],\n    [0.32527888860401261, 0.081428390076546092, 0.27226772884656186],\n    [0.33029174471181438, 0.08246763389003825, 0.27430929404579435],\n    [0.33533353224455448, 0.083532434119003962, 0.27632534356790039],\n    [0.34040164359597463, 0.084622236191702671, 0.27831254595259397],\n    [0.34549355713871799, 0.085736654965126335, 0.28026769921081435],\n    [0.35060678246032478, 0.08687555176033529, 0.28218770540182386],\n    [0.35573889947341125, 0.088038974350243354, 0.2840695897279818],\n    [0.36088752387578377, 0.089227194362745205, 0.28591050458531014],\n    [0.36605031412464006, 0.090440685427697898, 0.2877077458811747],\n    [0.37122508431309342, 0.091679997480262732, 0.28945865397633169],\n    [0.3764103053221462, 0.092945198093777909, 0.29116024157313919],\n    [0.38160247377467543, 0.094238731263712183, 0.29281107506269488],\n    [0.38679939079544168, 0.09556181960083443, 0.29440901248173756],\n    [0.39199887556812907, 0.09691583650296684, 0.29595212005509081],\n    [0.39719876876325577, 0.098302320968278623, 0.29743856476285779],\n    [0.40239692379737496, 0.099722930314950553, 0.29886674369733968],\n    [0.40759120392688708, 0.10117945586419633, 0.30023519507728602],\n    [0.41277985630360303, 0.1026734006932461, 0.30154226437468967],\n    [0.41796105205173684, 0.10420644885760968, 0.30278652039631843],\n    [0.42313214269556043, 0.10578120994917611, 0.3039675809469457],\n    [0.42829101315789753, 0.1073997763055258, 0.30508479060294547],\n    [0.4334355841041439, 0.1090642347484701, 0.30613767928289148],\n    [0.43856378187931538, 0.11077667828375456, 0.30712600062348083],\n    [0.44367358645071275, 0.11253912421257944, 0.30804973095465449],\n    [0.44876299173174822, 0.11435355574622549, 0.30890905921943196],\n    [0.45383005086999889, 0.11622183788331528, 0.30970441249844921],\n    [0.45887288947308297, 0.11814571137706886, 0.31043636979038808],\n    [0.46389102840284874, 0.12012561256850712, 0.31110343446582983],\n    [0.46888111384598413, 0.12216445576414045, 0.31170911458932665],\n    [0.473841437035254, 0.12426354237989065, 0.31225470169927194],\n    [0.47877034239726296, 0.12642401401409453, 0.31274172735821959],\n    [0.48366628618847957, 0.12864679022013889, 0.31317188565991266],\n    [0.48852847371852987, 0.13093210934893723, 0.31354553695453014],\n    [0.49335504375145617, 0.13328091630401023, 0.31386561956734976],\n    [0.49814435462074153, 0.13569380302451714, 0.314135190862664],\n    [0.50289524974970612, 0.13817086581280427, 0.31435662153833671],\n    [0.50760681181053691, 0.14071192654913128, 0.31453200120082569],\n    [0.51227835105321762, 0.14331656120063752, 0.3146630922831542],\n    [0.51690848800544464, 0.14598463068714407, 0.31475407592280041],\n    [0.52149652863229956, 0.14871544765633712, 0.31480767954534428],\n    [0.52604189625477482, 0.15150818660835483, 0.31482653406646727],\n    [0.53054420489856446, 0.15436183633886777, 0.31481299789187128],\n    [0.5350027976174474, 0.15727540775107324, 0.31477085207396532],\n    [0.53941736649199057, 0.16024769309971934, 0.31470295028655965],\n    [0.54378771313608565, 0.16327738551419116, 0.31461204226295625],\n    [0.54811370033467621, 0.1663630904279047, 0.31450102990914708],\n    [0.55239521572711914, 0.16950338809328983, 0.31437291554615371],\n    [0.55663229034969341, 0.17269677158182117, 0.31423043195101424],\n    [0.56082499039117173, 0.17594170887918095, 0.31407639883970623],\n    [0.56497343529017696, 0.17923664950367169, 0.3139136046337036],\n    [0.56907784784011428, 0.18258004462335425, 0.31374440956796529],\n    [0.57313845754107873, 0.18597036007065024, 0.31357126868520002],\n    [0.57715550812992045, 0.18940601489760422, 0.31339704333572083],\n    [0.58112932761586555, 0.19288548904692518, 0.31322399394183942],\n    [0.58506024396466882, 0.19640737049066315, 0.31305401163732732],\n    [0.58894861935544707, 0.19997020971775276, 0.31288922211590126],\n    [0.59279480536520257, 0.20357251410079796, 0.31273234839304942],\n    [0.59659918109122367, 0.207212956082026, 0.31258523031121233],\n    [0.60036213010411577, 0.21089030138947745, 0.31244934410414688],\n    [0.60408401696732739, 0.21460331490206347, 0.31232652641170694],\n    [0.60776523994818654, 0.21835070166659282, 0.31221903291870201],\n    [0.6114062072731884, 0.22213124697023234, 0.31212881396435238],\n    [0.61500723236391375, 0.22594402043981826, 0.31205680685765741],\n    [0.61856865258877192, 0.22978799249179921, 0.31200463838728931],\n    [0.62209079821082613, 0.2336621873300741, 0.31197383273627388],\n    [0.62557416500434959, 0.23756535071152696, 0.31196698314912269],\n    [0.62901892016985872, 0.24149689191922535, 0.31198447195645718],\n    [0.63242534854210275, 0.24545598775548677, 0.31202765974624452],\n    [0.6357937104834237, 0.24944185818822678, 0.31209793953300591],\n    [0.6391243387840212, 0.25345365461983138, 0.31219689612063978],\n    [0.642417577481186, 0.257490519876798, 0.31232631707560987],\n    [0.64567349382645434, 0.26155203161615281, 0.31248673753935263],\n    [0.64889230169458245, 0.26563755336209077, 0.31267941819570189],\n    [0.65207417290277303, 0.26974650525236699, 0.31290560605819168],\n    [0.65521932609327127, 0.27387826652410152, 0.3131666792687211],\n    [0.6583280801134499, 0.27803210957665631, 0.3134643447952643],\n    [0.66140037532601781, 0.28220778870555907, 0.31379912926498488],\n    [0.66443632469878844, 0.28640483614256179, 0.31417223403606975],\n    [0.66743603766369131, 0.29062280081258873, 0.31458483752056837],\n    [0.67039959547676198, 0.29486126309253047, 0.31503813956872212],\n    [0.67332725564817331, 0.29911962764489264, 0.31553372323982209],\n    [0.67621897924409746, 0.30339762792450425, 0.3160724937230589],\n    [0.67907474028157344, 0.30769497879760166, 0.31665545668946665],\n    [0.68189457150944521, 0.31201133280550686, 0.31728380489244951],\n    [0.68467850942494535, 0.31634634821222207, 0.31795870784057567],\n    [0.68742656435169625, 0.32069970535138104, 0.31868137622277692],\n    [0.6901389321505248, 0.32507091815606004, 0.31945332332898302],\n    [0.69281544846764931, 0.32945984647042675, 0.3202754315314667],\n    [0.69545608346891119, 0.33386622163232865, 0.32114884306985791],\n    [0.6980608153581771, 0.33828976326048621, 0.32207478855218091],\n    [0.70062962477242097, 0.34273019305341756, 0.32305449047765694],\n    [0.70316249458814151, 0.34718723719597999, 0.32408913679491225],\n    [0.70565951122610093, 0.35166052978120937, 0.32518014084085567],\n    [0.70812059568420482, 0.35614985523380299, 0.32632861885644465],\n    [0.7105456546582587, 0.36065500290840113, 0.32753574162788762],\n    [0.71293466839773467, 0.36517570519856757, 0.3288027427038317],\n    [0.71528760614847287, 0.36971170225223449, 0.3301308728723546],\n    [0.71760444908133847, 0.37426272710686193, 0.33152138620958932],\n    [0.71988521490549851, 0.37882848839337313, 0.33297555200245399],\n    [0.7221299918421461, 0.38340864508963057, 0.33449469983585844],\n    [0.72433865647781592, 0.38800301593162145, 0.33607995965691828],\n    [0.72651122900227549, 0.3926113126792577, 0.3377325942005665],\n    [0.72864773856716547, 0.39723324476747235, 0.33945384341064017],\n    [0.73074820754845171, 0.401868526884681, 0.3412449533046818],\n    [0.73281270506268747, 0.4065168468778026, 0.34310715173410822],\n    [0.73484133598564938, 0.41117787004519513, 0.34504169470809071],\n    [0.73683422173585866, 0.41585125850290111, 0.34704978520758401],\n    [0.73879140024599266, 0.42053672992315327, 0.34913260148542435],\n    [0.74071301619506091, 0.4252339389526239, 0.35129130890802607],\n    [0.7425992159973317, 0.42994254036133867, 0.35352709245374592],\n    [0.74445018676570673, 0.43466217184617112, 0.35584108091122535],\n    [0.74626615789163442, 0.43939245044973502, 0.35823439142300639],\n    [0.74804739275559562, 0.44413297780351974, 0.36070813602540136],\n    [0.74979420547170472, 0.44888333481548809, 0.36326337558360278],\n    [0.75150685045891663, 0.45364314496866825, 0.36590112443835765],\n    [0.75318566369046569, 0.45841199172949604, 0.36862236642234769],\n    [0.75483105066959544, 0.46318942799460555, 0.3714280448394211],\n    [0.75644341577140706, 0.46797501437948458, 0.37431909037543515],\n    [0.75802325538455839, 0.4727682731566229, 0.37729635531096678],\n    [0.75957111105340058, 0.47756871222057079, 0.380360657784311],\n    [0.7610876378057071, 0.48237579130289127, 0.38351275723852291],\n    [0.76257333554052609, 0.48718906673415824, 0.38675335037837993],\n    [0.76402885609288662, 0.49200802533379656, 0.39008308392311997],\n    [0.76545492593330511, 0.49683212909727231, 0.39350254000115381],\n    [0.76685228950643891, 0.5016608471009063, 0.39701221751773474],\n    [0.76822176599735303, 0.50649362371287909, 0.40061257089416885],\n    [0.7695642334401418, 0.5113298901696085, 0.40430398069682483],\n    [0.77088091962302474, 0.51616892643469103, 0.40808667584648967],\n    [0.77217257229605551, 0.5210102658711383, 0.41196089987122869],\n    [0.77344021829889886, 0.52585332093451564, 0.41592679539764366],\n    [0.77468494746063199, 0.53069749384776732, 0.41998440356963762],\n    [0.77590790730685699, 0.53554217882461186, 0.42413367909988375],\n    [0.7771103295521099, 0.54038674910561235, 0.42837450371258479],\n    [0.77829345807633121, 0.54523059488426595, 0.432706647838971],\n    [0.77945862731506643, 0.55007308413977274, 0.43712979856444761],\n    [0.78060774749483774, 0.55491335744890613, 0.44164332426364639],\n    [0.78174180478981836, 0.55975098052594863, 0.44624687186865436],\n    [0.78286225264440912, 0.56458533111166875, 0.45093985823706345],\n    [0.78397060836414478, 0.56941578326710418, 0.45572154742892063],\n    [0.78506845019606841, 0.5742417003617839, 0.46059116206904965],\n    [0.78615737132332963, 0.5790624629815756, 0.46554778281918402],\n    [0.78723904108188347, 0.58387743744557208, 0.47059039582133383],\n    [0.78831514045623963, 0.58868600173562435, 0.47571791879076081],\n    [0.78938737766251943, 0.5934875421745599, 0.48092913815357724],\n    [0.79045776847727878, 0.59828134277062461, 0.48622257801969754],\n    [0.79152832843475607, 0.60306670593147205, 0.49159667021646397],\n    [0.79260034304237448, 0.60784322087037024, 0.49705020621532009],\n    [0.79367559698664958, 0.61261029334072192, 0.50258161291269432],\n    [0.79475585972654039, 0.61736734400220705, 0.50818921213102985],\n    [0.79584292379583765, 0.62211378808451145, 0.51387124091909786],\n    [0.79693854719951607, 0.62684905679296699, 0.5196258425240281],\n    [0.79804447815136637, 0.63157258225089552, 0.52545108144834785],\n    [0.7991624518501963, 0.63628379372029187, 0.53134495942561433],\n    [0.80029415389753977, 0.64098213306749863, 0.53730535185141037],\n    [0.80144124292560048, 0.64566703459218766, 0.5433300863249918],\n    [0.80260531146112946, 0.65033793748103852, 0.54941691584603647],\n    [0.80378792531077625, 0.65499426549472628, 0.55556350867083815],\n    [0.80499054790810298, 0.65963545027564163, 0.56176745110546977],\n    [0.80621460526927058, 0.66426089585282289, 0.56802629178649788],\n    [0.8074614045096935, 0.6688700095398864, 0.57433746373459582],\n    [0.80873219170089694, 0.67346216702194517, 0.58069834805576737],\n    [0.81002809466520687, 0.67803672673971815, 0.58710626908082753],\n    [0.81135014011763329, 0.68259301546243389, 0.59355848909050757],\n    [0.81269922039881493, 0.68713033714618876, 0.60005214820435104],\n    [0.81407611046993344, 0.69164794791482131, 0.6065843782630862],\n    [0.81548146627279483, 0.69614505508308089, 0.61315221209322646],\n    [0.81691575775055891, 0.70062083014783982, 0.61975260637257923],\n    [0.81837931164498223, 0.70507438189635097, 0.62638245478933297],\n    [0.81987230650455289, 0.70950474978787481, 0.63303857040067113],\n    [0.8213947205565636, 0.7139109141951604, 0.63971766697672761],\n    [0.82294635110428427, 0.71829177331290062, 0.6464164243818421],\n    [0.8245268129450285, 0.72264614312088882, 0.65313137915422603],\n    [0.82613549710580259, 0.72697275518238258, 0.65985900156216504],\n    [0.8277716072353446, 0.73127023324078089, 0.66659570204682972],\n    [0.82943407816481474, 0.7355371221572935, 0.67333772009301907],\n    [0.83112163529096306, 0.73977184647638616, 0.68008125203631464],\n    [0.83283277185777982, 0.74397271817459876, 0.68682235874648545],\n    [0.8345656905566583, 0.7481379479992134, 0.69355697649863846],\n    [0.83631898844737929, 0.75226548952875261, 0.70027999028864962],\n    [0.83809123476131964, 0.75635314860808633, 0.70698561390212977],\n    [0.83987839884120874, 0.76039907199779677, 0.71367147811129228],\n    [0.84167750766845151, 0.76440101200982946, 0.72033299387284622],\n    [0.84348529222933699, 0.76835660399870176, 0.72696536998972039],\n    [0.84529810731955113, 0.77226338601044719, 0.73356368240541492],\n    [0.84711195507965098, 0.77611880236047159, 0.74012275762807056],\n    [0.84892245563117641, 0.77992021407650147, 0.74663719293664366],\n    [0.85072697023178789, 0.78366457342383888, 0.7530974636118285],\n    [0.85251907207708444, 0.78734936133548439, 0.7594994148789691],\n    [0.85429219611470464, 0.79097196777091994, 0.76583801477914104],\n    [0.85604022314725403, 0.79452963601550608, 0.77210610037674143],\n    [0.85775662943504905, 0.79801963142713928, 0.77829571667247499],\n    [0.8594346370300241, 0.8014392309950078, 0.78439788751383921],\n    [0.86107117027565516, 0.80478517909812231, 0.79039529663736285],\n    [0.86265601051127572, 0.80805523804261525, 0.796282666437655],\n    [0.86418343723941027, 0.81124644224653542, 0.80204612696863953],\n    [0.86564934325605325, 0.81435544067514909, 0.80766972324164554],\n    [0.86705314907048503, 0.81737804041911244, 0.81313419626911398],\n    [0.86839954695818633, 0.82030875512181523, 0.81841638963128993],\n    [0.86969131502613806, 0.82314158859569164, 0.82350476683173168],\n    [0.87093846717297507, 0.82586857889438514, 0.82838497261149613],\n    [0.87215331978454325, 0.82848052823709672, 0.8330486712880828],\n    [0.87335171360916275, 0.83096715251272624, 0.83748851001197089],\n    [0.87453793320260187, 0.83331972948645461, 0.84171925358069011],\n    [0.87571458709961403, 0.8355302318472394, 0.84575537519027078],\n    [0.87687848451614692, 0.83759238071186537, 0.84961373549150254],\n    [0.87802298436649007, 0.83950165618540074, 0.85330645352458923],\n    [0.87913244240792765, 0.84125554884475906, 0.85685572291039636],\n    [0.88019293315695812, 0.84285224824778615, 0.86027399927156634],\n    [0.88119169871341951, 0.84429066717717349, 0.86356595168669881],\n    [0.88211542489401606, 0.84557007254559347, 0.86673765046233331],\n    [0.88295168595448525, 0.84668970275699273, 0.86979617048190971],\n    [0.88369127145898041, 0.84764891761519268, 0.87274147101441557],\n    [0.88432713054113543, 0.84844741572055415, 0.87556785228242973],\n    [0.88485138159908572, 0.84908426422893801, 0.87828235285372469],\n    [0.88525897972630474, 0.84955892810989209, 0.88088414794024839],\n    [0.88554714811952384, 0.84987174283631584, 0.88336206121170946],\n    [0.88571155122845646, 0.85002186115856315, 0.88572538990087124],\n]\n\n_turbo_data = [\n    [0.18995, 0.07176, 0.23217],\n    [0.19483, 0.08339, 0.26149],\n    [0.19956, 0.09498, 0.29024],\n    [0.20415, 0.10652, 0.31844],\n    [0.20860, 0.11802, 0.34607],\n    [0.21291, 0.12947, 0.37314],\n    [0.21708, 0.14087, 0.39964],\n    [0.22111, 0.15223, 0.42558],\n    [0.22500, 0.16354, 0.45096],\n    [0.22875, 0.17481, 0.47578],\n    [0.23236, 0.18603, 0.50004],\n    [0.23582, 0.19720, 0.52373],\n    [0.23915, 0.20833, 0.54686],\n    [0.24234, 0.21941, 0.56942],\n    [0.24539, 0.23044, 0.59142],\n    [0.24830, 0.24143, 0.61286],\n    [0.25107, 0.25237, 0.63374],\n    [0.25369, 0.26327, 0.65406],\n    [0.25618, 0.27412, 0.67381],\n    [0.25853, 0.28492, 0.69300],\n    [0.26074, 0.29568, 0.71162],\n    [0.26280, 0.30639, 0.72968],\n    [0.26473, 0.31706, 0.74718],\n    [0.26652, 0.32768, 0.76412],\n    [0.26816, 0.33825, 0.78050],\n    [0.26967, 0.34878, 0.79631],\n    [0.27103, 0.35926, 0.81156],\n    [0.27226, 0.36970, 0.82624],\n    [0.27334, 0.38008, 0.84037],\n    [0.27429, 0.39043, 0.85393],\n    [0.27509, 0.40072, 0.86692],\n    [0.27576, 0.41097, 0.87936],\n    [0.27628, 0.42118, 0.89123],\n    [0.27667, 0.43134, 0.90254],\n    [0.27691, 0.44145, 0.91328],\n    [0.27701, 0.45152, 0.92347],\n    [0.27698, 0.46153, 0.93309],\n    [0.27680, 0.47151, 0.94214],\n    [0.27648, 0.48144, 0.95064],\n    [0.27603, 0.49132, 0.95857],\n    [0.27543, 0.50115, 0.96594],\n    [0.27469, 0.51094, 0.97275],\n    [0.27381, 0.52069, 0.97899],\n    [0.27273, 0.53040, 0.98461],\n    [0.27106, 0.54015, 0.98930],\n    [0.26878, 0.54995, 0.99303],\n    [0.26592, 0.55979, 0.99583],\n    [0.26252, 0.56967, 0.99773],\n    [0.25862, 0.57958, 0.99876],\n    [0.25425, 0.58950, 0.99896],\n    [0.24946, 0.59943, 0.99835],\n    [0.24427, 0.60937, 0.99697],\n    [0.23874, 0.61931, 0.99485],\n    [0.23288, 0.62923, 0.99202],\n    [0.22676, 0.63913, 0.98851],\n    [0.22039, 0.64901, 0.98436],\n    [0.21382, 0.65886, 0.97959],\n    [0.20708, 0.66866, 0.97423],\n    [0.20021, 0.67842, 0.96833],\n    [0.19326, 0.68812, 0.96190],\n    [0.18625, 0.69775, 0.95498],\n    [0.17923, 0.70732, 0.94761],\n    [0.17223, 0.71680, 0.93981],\n    [0.16529, 0.72620, 0.93161],\n    [0.15844, 0.73551, 0.92305],\n    [0.15173, 0.74472, 0.91416],\n    [0.14519, 0.75381, 0.90496],\n    [0.13886, 0.76279, 0.89550],\n    [0.13278, 0.77165, 0.88580],\n    [0.12698, 0.78037, 0.87590],\n    [0.12151, 0.78896, 0.86581],\n    [0.11639, 0.79740, 0.85559],\n    [0.11167, 0.80569, 0.84525],\n    [0.10738, 0.81381, 0.83484],\n    [0.10357, 0.82177, 0.82437],\n    [0.10026, 0.82955, 0.81389],\n    [0.09750, 0.83714, 0.80342],\n    [0.09532, 0.84455, 0.79299],\n    [0.09377, 0.85175, 0.78264],\n    [0.09287, 0.85875, 0.77240],\n    [0.09267, 0.86554, 0.76230],\n    [0.09320, 0.87211, 0.75237],\n    [0.09451, 0.87844, 0.74265],\n    [0.09662, 0.88454, 0.73316],\n    [0.09958, 0.89040, 0.72393],\n    [0.10342, 0.89600, 0.71500],\n    [0.10815, 0.90142, 0.70599],\n    [0.11374, 0.90673, 0.69651],\n    [0.12014, 0.91193, 0.68660],\n    [0.12733, 0.91701, 0.67627],\n    [0.13526, 0.92197, 0.66556],\n    [0.14391, 0.92680, 0.65448],\n    [0.15323, 0.93151, 0.64308],\n    [0.16319, 0.93609, 0.63137],\n    [0.17377, 0.94053, 0.61938],\n    [0.18491, 0.94484, 0.60713],\n    [0.19659, 0.94901, 0.59466],\n    [0.20877, 0.95304, 0.58199],\n    [0.22142, 0.95692, 0.56914],\n    [0.23449, 0.96065, 0.55614],\n    [0.24797, 0.96423, 0.54303],\n    [0.26180, 0.96765, 0.52981],\n    [0.27597, 0.97092, 0.51653],\n    [0.29042, 0.97403, 0.50321],\n    [0.30513, 0.97697, 0.48987],\n    [0.32006, 0.97974, 0.47654],\n    [0.33517, 0.98234, 0.46325],\n    [0.35043, 0.98477, 0.45002],\n    [0.36581, 0.98702, 0.43688],\n    [0.38127, 0.98909, 0.42386],\n    [0.39678, 0.99098, 0.41098],\n    [0.41229, 0.99268, 0.39826],\n    [0.42778, 0.99419, 0.38575],\n    [0.44321, 0.99551, 0.37345],\n    [0.45854, 0.99663, 0.36140],\n    [0.47375, 0.99755, 0.34963],\n    [0.48879, 0.99828, 0.33816],\n    [0.50362, 0.99879, 0.32701],\n    [0.51822, 0.99910, 0.31622],\n    [0.53255, 0.99919, 0.30581],\n    [0.54658, 0.99907, 0.29581],\n    [0.56026, 0.99873, 0.28623],\n    [0.57357, 0.99817, 0.27712],\n    [0.58646, 0.99739, 0.26849],\n    [0.59891, 0.99638, 0.26038],\n    [0.61088, 0.99514, 0.25280],\n    [0.62233, 0.99366, 0.24579],\n    [0.63323, 0.99195, 0.23937],\n    [0.64362, 0.98999, 0.23356],\n    [0.65394, 0.98775, 0.22835],\n    [0.66428, 0.98524, 0.22370],\n    [0.67462, 0.98246, 0.21960],\n    [0.68494, 0.97941, 0.21602],\n    [0.69525, 0.97610, 0.21294],\n    [0.70553, 0.97255, 0.21032],\n    [0.71577, 0.96875, 0.20815],\n    [0.72596, 0.96470, 0.20640],\n    [0.73610, 0.96043, 0.20504],\n    [0.74617, 0.95593, 0.20406],\n    [0.75617, 0.95121, 0.20343],\n    [0.76608, 0.94627, 0.20311],\n    [0.77591, 0.94113, 0.20310],\n    [0.78563, 0.93579, 0.20336],\n    [0.79524, 0.93025, 0.20386],\n    [0.80473, 0.92452, 0.20459],\n    [0.81410, 0.91861, 0.20552],\n    [0.82333, 0.91253, 0.20663],\n    [0.83241, 0.90627, 0.20788],\n    [0.84133, 0.89986, 0.20926],\n    [0.85010, 0.89328, 0.21074],\n    [0.85868, 0.88655, 0.21230],\n    [0.86709, 0.87968, 0.21391],\n    [0.87530, 0.87267, 0.21555],\n    [0.88331, 0.86553, 0.21719],\n    [0.89112, 0.85826, 0.21880],\n    [0.89870, 0.85087, 0.22038],\n    [0.90605, 0.84337, 0.22188],\n    [0.91317, 0.83576, 0.22328],\n    [0.92004, 0.82806, 0.22456],\n    [0.92666, 0.82025, 0.22570],\n    [0.93301, 0.81236, 0.22667],\n    [0.93909, 0.80439, 0.22744],\n    [0.94489, 0.79634, 0.22800],\n    [0.95039, 0.78823, 0.22831],\n    [0.95560, 0.78005, 0.22836],\n    [0.96049, 0.77181, 0.22811],\n    [0.96507, 0.76352, 0.22754],\n    [0.96931, 0.75519, 0.22663],\n    [0.97323, 0.74682, 0.22536],\n    [0.97679, 0.73842, 0.22369],\n    [0.98000, 0.73000, 0.22161],\n    [0.98289, 0.72140, 0.21918],\n    [0.98549, 0.71250, 0.21650],\n    [0.98781, 0.70330, 0.21358],\n    [0.98986, 0.69382, 0.21043],\n    [0.99163, 0.68408, 0.20706],\n    [0.99314, 0.67408, 0.20348],\n    [0.99438, 0.66386, 0.19971],\n    [0.99535, 0.65341, 0.19577],\n    [0.99607, 0.64277, 0.19165],\n    [0.99654, 0.63193, 0.18738],\n    [0.99675, 0.62093, 0.18297],\n    [0.99672, 0.60977, 0.17842],\n    [0.99644, 0.59846, 0.17376],\n    [0.99593, 0.58703, 0.16899],\n    [0.99517, 0.57549, 0.16412],\n    [0.99419, 0.56386, 0.15918],\n    [0.99297, 0.55214, 0.15417],\n    [0.99153, 0.54036, 0.14910],\n    [0.98987, 0.52854, 0.14398],\n    [0.98799, 0.51667, 0.13883],\n    [0.98590, 0.50479, 0.13367],\n    [0.98360, 0.49291, 0.12849],\n    [0.98108, 0.48104, 0.12332],\n    [0.97837, 0.46920, 0.11817],\n    [0.97545, 0.45740, 0.11305],\n    [0.97234, 0.44565, 0.10797],\n    [0.96904, 0.43399, 0.10294],\n    [0.96555, 0.42241, 0.09798],\n    [0.96187, 0.41093, 0.09310],\n    [0.95801, 0.39958, 0.08831],\n    [0.95398, 0.38836, 0.08362],\n    [0.94977, 0.37729, 0.07905],\n    [0.94538, 0.36638, 0.07461],\n    [0.94084, 0.35566, 0.07031],\n    [0.93612, 0.34513, 0.06616],\n    [0.93125, 0.33482, 0.06218],\n    [0.92623, 0.32473, 0.05837],\n    [0.92105, 0.31489, 0.05475],\n    [0.91572, 0.30530, 0.05134],\n    [0.91024, 0.29599, 0.04814],\n    [0.90463, 0.28696, 0.04516],\n    [0.89888, 0.27824, 0.04243],\n    [0.89298, 0.26981, 0.03993],\n    [0.88691, 0.26152, 0.03753],\n    [0.88066, 0.25334, 0.03521],\n    [0.87422, 0.24526, 0.03297],\n    [0.86760, 0.23730, 0.03082],\n    [0.86079, 0.22945, 0.02875],\n    [0.85380, 0.22170, 0.02677],\n    [0.84662, 0.21407, 0.02487],\n    [0.83926, 0.20654, 0.02305],\n    [0.83172, 0.19912, 0.02131],\n    [0.82399, 0.19182, 0.01966],\n    [0.81608, 0.18462, 0.01809],\n    [0.80799, 0.17753, 0.01660],\n    [0.79971, 0.17055, 0.01520],\n    [0.79125, 0.16368, 0.01387],\n    [0.78260, 0.15693, 0.01264],\n    [0.77377, 0.15028, 0.01148],\n    [0.76476, 0.14374, 0.01041],\n    [0.75556, 0.13731, 0.00942],\n    [0.74617, 0.13098, 0.00851],\n    [0.73661, 0.12477, 0.00769],\n    [0.72686, 0.11867, 0.00695],\n    [0.71692, 0.11268, 0.00629],\n    [0.70680, 0.10680, 0.00571],\n    [0.69650, 0.10102, 0.00522],\n    [0.68602, 0.09536, 0.00481],\n    [0.67535, 0.08980, 0.00449],\n    [0.66449, 0.08436, 0.00424],\n    [0.65345, 0.07902, 0.00408],\n    [0.64223, 0.07380, 0.00401],\n    [0.63082, 0.06868, 0.00401],\n    [0.61923, 0.06367, 0.00410],\n    [0.60746, 0.05878, 0.00427],\n    [0.59550, 0.05399, 0.00453],\n    [0.58336, 0.04931, 0.00486],\n    [0.57103, 0.04474, 0.00529],\n    [0.55852, 0.04028, 0.00579],\n    [0.54583, 0.03593, 0.00638],\n    [0.53295, 0.03169, 0.00705],\n    [0.51989, 0.02756, 0.00780],\n    [0.50664, 0.02354, 0.00863],\n    [0.49321, 0.01963, 0.00955],\n    [0.47960, 0.01583, 0.01055],\n]\n\n_twilight_shifted_data = (\n    _twilight_data[len(_twilight_data) // 2 :]\n    + _twilight_data[: len(_twilight_data) // 2]\n)\n_twilight_shifted_data.reverse()\n\ncmaps = {}\nfor (name, data) in (\n    ('magma', _magma_data),\n    ('inferno', _inferno_data),\n    ('plasma', _plasma_data),\n    ('viridis', _viridis_data),\n    ('cividis', _cividis_data),\n    ('twilight', _twilight_data),\n    ('twilight_shifted', _twilight_shifted_data),\n    ('turbo', _turbo_data),\n):\n\n    cmaps[name] = ListedColormap(data, name=name)\n    # generate reversed colormap\n    name = name + '_r'\n    cmaps[name] = ListedColormap(list(reversed(data)), name=name)\n"""
napari/utils/colormaps/vendored/_color_data.py,0,"b'from collections import OrderedDict\n\n\nBASE_COLORS = {\n    \'b\': \'#0000ff\',\n    \'g\': \'#008000\',\n    \'r\': \'#ff0000\',\n    \'c\': \'#00bfbf\',\n    \'m\': \'#bf00bf\',\n    \'y\': \'#bfbf00\',\n    \'k\': \'#000000\',\n    \'w\': \'#ffffff\',\n}\n\n\nNTH_COLORS = {\n    \'C0\': \'#1f77b4\',\n    \'C1\': \'#ff7f0e\',\n    \'C2\': \'#2ca02c\',\n    \'C3\': \'#d62728\',\n    \'C4\': \'#9467bd\',\n    \'C5\': \'#8c564b\',\n    \'C6\': \'#e377c2\',\n    \'C7\': \'#7f7f7f\',\n    \'C8\': \'#bcbd22\',\n    \'C9\': \'#17becf\',\n}\n\n\n# These colors are from Tableau\nTABLEAU_COLOR_TUPLES = (\n    (\'blue\', \'#1f77b4\'),\n    (\'orange\', \'#ff7f0e\'),\n    (\'green\', \'#2ca02c\'),\n    (\'red\', \'#d62728\'),\n    (\'purple\', \'#9467bd\'),\n    (\'brown\', \'#8c564b\'),\n    (\'pink\', \'#e377c2\'),\n    (\'gray\', \'#7f7f7f\'),\n    (\'olive\', \'#bcbd22\'),\n    (\'cyan\', \'#17becf\'),\n)\n\n# Normalize name to ""tab:<name>"" to avoid name collisions.\nTABLEAU_COLORS = OrderedDict(\n    (\'tab:\' + name, value) for name, value in TABLEAU_COLOR_TUPLES)\n\n# This mapping of color names -> hex values is taken from\n# a survey run by Randall Munroe see:\n# http://blog.xkcd.com/2010/05/03/color-survey-results/\n# for more details.  The results are hosted at\n# https://xkcd.com/color/rgb.txt\n#\n# License: http://creativecommons.org/publicdomain/zero/1.0/\nXKCD_COLORS = {\n    \'cloudy blue\': \'#acc2d9\',\n    \'dark pastel green\': \'#56ae57\',\n    \'dust\': \'#b2996e\',\n    \'electric lime\': \'#a8ff04\',\n    \'fresh green\': \'#69d84f\',\n    \'light eggplant\': \'#894585\',\n    \'nasty green\': \'#70b23f\',\n    \'really light blue\': \'#d4ffff\',\n    \'tea\': \'#65ab7c\',\n    \'warm purple\': \'#952e8f\',\n    \'yellowish tan\': \'#fcfc81\',\n    \'cement\': \'#a5a391\',\n    \'dark grass green\': \'#388004\',\n    \'dusty teal\': \'#4c9085\',\n    \'grey teal\': \'#5e9b8a\',\n    \'macaroni and cheese\': \'#efb435\',\n    \'pinkish tan\': \'#d99b82\',\n    \'spruce\': \'#0a5f38\',\n    \'strong blue\': \'#0c06f7\',\n    \'toxic green\': \'#61de2a\',\n    \'windows blue\': \'#3778bf\',\n    \'blue blue\': \'#2242c7\',\n    \'blue with a hint of purple\': \'#533cc6\',\n    \'booger\': \'#9bb53c\',\n    \'bright sea green\': \'#05ffa6\',\n    \'dark green blue\': \'#1f6357\',\n    \'deep turquoise\': \'#017374\',\n    \'green teal\': \'#0cb577\',\n    \'strong pink\': \'#ff0789\',\n    \'bland\': \'#afa88b\',\n    \'deep aqua\': \'#08787f\',\n    \'lavender pink\': \'#dd85d7\',\n    \'light moss green\': \'#a6c875\',\n    \'light seafoam green\': \'#a7ffb5\',\n    \'olive yellow\': \'#c2b709\',\n    \'pig pink\': \'#e78ea5\',\n    \'deep lilac\': \'#966ebd\',\n    \'desert\': \'#ccad60\',\n    \'dusty lavender\': \'#ac86a8\',\n    \'purpley grey\': \'#947e94\',\n    \'purply\': \'#983fb2\',\n    \'candy pink\': \'#ff63e9\',\n    \'light pastel green\': \'#b2fba5\',\n    \'boring green\': \'#63b365\',\n    \'kiwi green\': \'#8ee53f\',\n    \'light grey green\': \'#b7e1a1\',\n    \'orange pink\': \'#ff6f52\',\n    \'tea green\': \'#bdf8a3\',\n    \'very light brown\': \'#d3b683\',\n    \'egg shell\': \'#fffcc4\',\n    \'eggplant purple\': \'#430541\',\n    \'powder pink\': \'#ffb2d0\',\n    \'reddish grey\': \'#997570\',\n    \'baby shit brown\': \'#ad900d\',\n    \'liliac\': \'#c48efd\',\n    \'stormy blue\': \'#507b9c\',\n    \'ugly brown\': \'#7d7103\',\n    \'custard\': \'#fffd78\',\n    \'darkish pink\': \'#da467d\',\n    \'deep brown\': \'#410200\',\n    \'greenish beige\': \'#c9d179\',\n    \'manilla\': \'#fffa86\',\n    \'off blue\': \'#5684ae\',\n    \'battleship grey\': \'#6b7c85\',\n    \'browny green\': \'#6f6c0a\',\n    \'bruise\': \'#7e4071\',\n    \'kelley green\': \'#009337\',\n    \'sickly yellow\': \'#d0e429\',\n    \'sunny yellow\': \'#fff917\',\n    \'azul\': \'#1d5dec\',\n    \'darkgreen\': \'#054907\',\n    \'green/yellow\': \'#b5ce08\',\n    \'lichen\': \'#8fb67b\',\n    \'light light green\': \'#c8ffb0\',\n    \'pale gold\': \'#fdde6c\',\n    \'sun yellow\': \'#ffdf22\',\n    \'tan green\': \'#a9be70\',\n    \'burple\': \'#6832e3\',\n    \'butterscotch\': \'#fdb147\',\n    \'toupe\': \'#c7ac7d\',\n    \'dark cream\': \'#fff39a\',\n    \'indian red\': \'#850e04\',\n    \'light lavendar\': \'#efc0fe\',\n    \'poison green\': \'#40fd14\',\n    \'baby puke green\': \'#b6c406\',\n    \'bright yellow green\': \'#9dff00\',\n    \'charcoal grey\': \'#3c4142\',\n    \'squash\': \'#f2ab15\',\n    \'cinnamon\': \'#ac4f06\',\n    \'light pea green\': \'#c4fe82\',\n    \'radioactive green\': \'#2cfa1f\',\n    \'raw sienna\': \'#9a6200\',\n    \'baby purple\': \'#ca9bf7\',\n    \'cocoa\': \'#875f42\',\n    \'light royal blue\': \'#3a2efe\',\n    \'orangeish\': \'#fd8d49\',\n    \'rust brown\': \'#8b3103\',\n    \'sand brown\': \'#cba560\',\n    \'swamp\': \'#698339\',\n    \'tealish green\': \'#0cdc73\',\n    \'burnt siena\': \'#b75203\',\n    \'camo\': \'#7f8f4e\',\n    \'dusk blue\': \'#26538d\',\n    \'fern\': \'#63a950\',\n    \'old rose\': \'#c87f89\',\n    \'pale light green\': \'#b1fc99\',\n    \'peachy pink\': \'#ff9a8a\',\n    \'rosy pink\': \'#f6688e\',\n    \'light bluish green\': \'#76fda8\',\n    \'light bright green\': \'#53fe5c\',\n    \'light neon green\': \'#4efd54\',\n    \'light seafoam\': \'#a0febf\',\n    \'tiffany blue\': \'#7bf2da\',\n    \'washed out green\': \'#bcf5a6\',\n    \'browny orange\': \'#ca6b02\',\n    \'nice blue\': \'#107ab0\',\n    \'sapphire\': \'#2138ab\',\n    \'greyish teal\': \'#719f91\',\n    \'orangey yellow\': \'#fdb915\',\n    \'parchment\': \'#fefcaf\',\n    \'straw\': \'#fcf679\',\n    \'very dark brown\': \'#1d0200\',\n    \'terracota\': \'#cb6843\',\n    \'ugly blue\': \'#31668a\',\n    \'clear blue\': \'#247afd\',\n    \'creme\': \'#ffffb6\',\n    \'foam green\': \'#90fda9\',\n    \'grey/green\': \'#86a17d\',\n    \'light gold\': \'#fddc5c\',\n    \'seafoam blue\': \'#78d1b6\',\n    \'topaz\': \'#13bbaf\',\n    \'violet pink\': \'#fb5ffc\',\n    \'wintergreen\': \'#20f986\',\n    \'yellow tan\': \'#ffe36e\',\n    \'dark fuchsia\': \'#9d0759\',\n    \'indigo blue\': \'#3a18b1\',\n    \'light yellowish green\': \'#c2ff89\',\n    \'pale magenta\': \'#d767ad\',\n    \'rich purple\': \'#720058\',\n    \'sunflower yellow\': \'#ffda03\',\n    \'green/blue\': \'#01c08d\',\n    \'leather\': \'#ac7434\',\n    \'racing green\': \'#014600\',\n    \'vivid purple\': \'#9900fa\',\n    \'dark royal blue\': \'#02066f\',\n    \'hazel\': \'#8e7618\',\n    \'muted pink\': \'#d1768f\',\n    \'booger green\': \'#96b403\',\n    \'canary\': \'#fdff63\',\n    \'cool grey\': \'#95a3a6\',\n    \'dark taupe\': \'#7f684e\',\n    \'darkish purple\': \'#751973\',\n    \'true green\': \'#089404\',\n    \'coral pink\': \'#ff6163\',\n    \'dark sage\': \'#598556\',\n    \'dark slate blue\': \'#214761\',\n    \'flat blue\': \'#3c73a8\',\n    \'mushroom\': \'#ba9e88\',\n    \'rich blue\': \'#021bf9\',\n    \'dirty purple\': \'#734a65\',\n    \'greenblue\': \'#23c48b\',\n    \'icky green\': \'#8fae22\',\n    \'light khaki\': \'#e6f2a2\',\n    \'warm blue\': \'#4b57db\',\n    \'dark hot pink\': \'#d90166\',\n    \'deep sea blue\': \'#015482\',\n    \'carmine\': \'#9d0216\',\n    \'dark yellow green\': \'#728f02\',\n    \'pale peach\': \'#ffe5ad\',\n    \'plum purple\': \'#4e0550\',\n    \'golden rod\': \'#f9bc08\',\n    \'neon red\': \'#ff073a\',\n    \'old pink\': \'#c77986\',\n    \'very pale blue\': \'#d6fffe\',\n    \'blood orange\': \'#fe4b03\',\n    \'grapefruit\': \'#fd5956\',\n    \'sand yellow\': \'#fce166\',\n    \'clay brown\': \'#b2713d\',\n    \'dark blue grey\': \'#1f3b4d\',\n    \'flat green\': \'#699d4c\',\n    \'light green blue\': \'#56fca2\',\n    \'warm pink\': \'#fb5581\',\n    \'dodger blue\': \'#3e82fc\',\n    \'gross green\': \'#a0bf16\',\n    \'ice\': \'#d6fffa\',\n    \'metallic blue\': \'#4f738e\',\n    \'pale salmon\': \'#ffb19a\',\n    \'sap green\': \'#5c8b15\',\n    \'algae\': \'#54ac68\',\n    \'bluey grey\': \'#89a0b0\',\n    \'greeny grey\': \'#7ea07a\',\n    \'highlighter green\': \'#1bfc06\',\n    \'light light blue\': \'#cafffb\',\n    \'light mint\': \'#b6ffbb\',\n    \'raw umber\': \'#a75e09\',\n    \'vivid blue\': \'#152eff\',\n    \'deep lavender\': \'#8d5eb7\',\n    \'dull teal\': \'#5f9e8f\',\n    \'light greenish blue\': \'#63f7b4\',\n    \'mud green\': \'#606602\',\n    \'pinky\': \'#fc86aa\',\n    \'red wine\': \'#8c0034\',\n    \'shit green\': \'#758000\',\n    \'tan brown\': \'#ab7e4c\',\n    \'darkblue\': \'#030764\',\n    \'rosa\': \'#fe86a4\',\n    \'lipstick\': \'#d5174e\',\n    \'pale mauve\': \'#fed0fc\',\n    \'claret\': \'#680018\',\n    \'dandelion\': \'#fedf08\',\n    \'orangered\': \'#fe420f\',\n    \'poop green\': \'#6f7c00\',\n    \'ruby\': \'#ca0147\',\n    \'dark\': \'#1b2431\',\n    \'greenish turquoise\': \'#00fbb0\',\n    \'pastel red\': \'#db5856\',\n    \'piss yellow\': \'#ddd618\',\n    \'bright cyan\': \'#41fdfe\',\n    \'dark coral\': \'#cf524e\',\n    \'algae green\': \'#21c36f\',\n    \'darkish red\': \'#a90308\',\n    \'reddy brown\': \'#6e1005\',\n    \'blush pink\': \'#fe828c\',\n    \'camouflage green\': \'#4b6113\',\n    \'lawn green\': \'#4da409\',\n    \'putty\': \'#beae8a\',\n    \'vibrant blue\': \'#0339f8\',\n    \'dark sand\': \'#a88f59\',\n    \'purple/blue\': \'#5d21d0\',\n    \'saffron\': \'#feb209\',\n    \'twilight\': \'#4e518b\',\n    \'warm brown\': \'#964e02\',\n    \'bluegrey\': \'#85a3b2\',\n    \'bubble gum pink\': \'#ff69af\',\n    \'duck egg blue\': \'#c3fbf4\',\n    \'greenish cyan\': \'#2afeb7\',\n    \'petrol\': \'#005f6a\',\n    \'royal\': \'#0c1793\',\n    \'butter\': \'#ffff81\',\n    \'dusty orange\': \'#f0833a\',\n    \'off yellow\': \'#f1f33f\',\n    \'pale olive green\': \'#b1d27b\',\n    \'orangish\': \'#fc824a\',\n    \'leaf\': \'#71aa34\',\n    \'light blue grey\': \'#b7c9e2\',\n    \'dried blood\': \'#4b0101\',\n    \'lightish purple\': \'#a552e6\',\n    \'rusty red\': \'#af2f0d\',\n    \'lavender blue\': \'#8b88f8\',\n    \'light grass green\': \'#9af764\',\n    \'light mint green\': \'#a6fbb2\',\n    \'sunflower\': \'#ffc512\',\n    \'velvet\': \'#750851\',\n    \'brick orange\': \'#c14a09\',\n    \'lightish red\': \'#fe2f4a\',\n    \'pure blue\': \'#0203e2\',\n    \'twilight blue\': \'#0a437a\',\n    \'violet red\': \'#a50055\',\n    \'yellowy brown\': \'#ae8b0c\',\n    \'carnation\': \'#fd798f\',\n    \'muddy yellow\': \'#bfac05\',\n    \'dark seafoam green\': \'#3eaf76\',\n    \'deep rose\': \'#c74767\',\n    \'dusty red\': \'#b9484e\',\n    \'grey/blue\': \'#647d8e\',\n    \'lemon lime\': \'#bffe28\',\n    \'purple/pink\': \'#d725de\',\n    \'brown yellow\': \'#b29705\',\n    \'purple brown\': \'#673a3f\',\n    \'wisteria\': \'#a87dc2\',\n    \'banana yellow\': \'#fafe4b\',\n    \'lipstick red\': \'#c0022f\',\n    \'water blue\': \'#0e87cc\',\n    \'brown grey\': \'#8d8468\',\n    \'vibrant purple\': \'#ad03de\',\n    \'baby green\': \'#8cff9e\',\n    \'barf green\': \'#94ac02\',\n    \'eggshell blue\': \'#c4fff7\',\n    \'sandy yellow\': \'#fdee73\',\n    \'cool green\': \'#33b864\',\n    \'pale\': \'#fff9d0\',\n    \'blue/grey\': \'#758da3\',\n    \'hot magenta\': \'#f504c9\',\n    \'greyblue\': \'#77a1b5\',\n    \'purpley\': \'#8756e4\',\n    \'baby shit green\': \'#889717\',\n    \'brownish pink\': \'#c27e79\',\n    \'dark aquamarine\': \'#017371\',\n    \'diarrhea\': \'#9f8303\',\n    \'light mustard\': \'#f7d560\',\n    \'pale sky blue\': \'#bdf6fe\',\n    \'turtle green\': \'#75b84f\',\n    \'bright olive\': \'#9cbb04\',\n    \'dark grey blue\': \'#29465b\',\n    \'greeny brown\': \'#696006\',\n    \'lemon green\': \'#adf802\',\n    \'light periwinkle\': \'#c1c6fc\',\n    \'seaweed green\': \'#35ad6b\',\n    \'sunshine yellow\': \'#fffd37\',\n    \'ugly purple\': \'#a442a0\',\n    \'medium pink\': \'#f36196\',\n    \'puke brown\': \'#947706\',\n    \'very light pink\': \'#fff4f2\',\n    \'viridian\': \'#1e9167\',\n    \'bile\': \'#b5c306\',\n    \'faded yellow\': \'#feff7f\',\n    \'very pale green\': \'#cffdbc\',\n    \'vibrant green\': \'#0add08\',\n    \'bright lime\': \'#87fd05\',\n    \'spearmint\': \'#1ef876\',\n    \'light aquamarine\': \'#7bfdc7\',\n    \'light sage\': \'#bcecac\',\n    \'yellowgreen\': \'#bbf90f\',\n    \'baby poo\': \'#ab9004\',\n    \'dark seafoam\': \'#1fb57a\',\n    \'deep teal\': \'#00555a\',\n    \'heather\': \'#a484ac\',\n    \'rust orange\': \'#c45508\',\n    \'dirty blue\': \'#3f829d\',\n    \'fern green\': \'#548d44\',\n    \'bright lilac\': \'#c95efb\',\n    \'weird green\': \'#3ae57f\',\n    \'peacock blue\': \'#016795\',\n    \'avocado green\': \'#87a922\',\n    \'faded orange\': \'#f0944d\',\n    \'grape purple\': \'#5d1451\',\n    \'hot green\': \'#25ff29\',\n    \'lime yellow\': \'#d0fe1d\',\n    \'mango\': \'#ffa62b\',\n    \'shamrock\': \'#01b44c\',\n    \'bubblegum\': \'#ff6cb5\',\n    \'purplish brown\': \'#6b4247\',\n    \'vomit yellow\': \'#c7c10c\',\n    \'pale cyan\': \'#b7fffa\',\n    \'key lime\': \'#aeff6e\',\n    \'tomato red\': \'#ec2d01\',\n    \'lightgreen\': \'#76ff7b\',\n    \'merlot\': \'#730039\',\n    \'night blue\': \'#040348\',\n    \'purpleish pink\': \'#df4ec8\',\n    \'apple\': \'#6ecb3c\',\n    \'baby poop green\': \'#8f9805\',\n    \'green apple\': \'#5edc1f\',\n    \'heliotrope\': \'#d94ff5\',\n    \'yellow/green\': \'#c8fd3d\',\n    \'almost black\': \'#070d0d\',\n    \'cool blue\': \'#4984b8\',\n    \'leafy green\': \'#51b73b\',\n    \'mustard brown\': \'#ac7e04\',\n    \'dusk\': \'#4e5481\',\n    \'dull brown\': \'#876e4b\',\n    \'frog green\': \'#58bc08\',\n    \'vivid green\': \'#2fef10\',\n    \'bright light green\': \'#2dfe54\',\n    \'fluro green\': \'#0aff02\',\n    \'kiwi\': \'#9cef43\',\n    \'seaweed\': \'#18d17b\',\n    \'navy green\': \'#35530a\',\n    \'ultramarine blue\': \'#1805db\',\n    \'iris\': \'#6258c4\',\n    \'pastel orange\': \'#ff964f\',\n    \'yellowish orange\': \'#ffab0f\',\n    \'perrywinkle\': \'#8f8ce7\',\n    \'tealish\': \'#24bca8\',\n    \'dark plum\': \'#3f012c\',\n    \'pear\': \'#cbf85f\',\n    \'pinkish orange\': \'#ff724c\',\n    \'midnight purple\': \'#280137\',\n    \'light urple\': \'#b36ff6\',\n    \'dark mint\': \'#48c072\',\n    \'greenish tan\': \'#bccb7a\',\n    \'light burgundy\': \'#a8415b\',\n    \'turquoise blue\': \'#06b1c4\',\n    \'ugly pink\': \'#cd7584\',\n    \'sandy\': \'#f1da7a\',\n    \'electric pink\': \'#ff0490\',\n    \'muted purple\': \'#805b87\',\n    \'mid green\': \'#50a747\',\n    \'greyish\': \'#a8a495\',\n    \'neon yellow\': \'#cfff04\',\n    \'banana\': \'#ffff7e\',\n    \'carnation pink\': \'#ff7fa7\',\n    \'tomato\': \'#ef4026\',\n    \'sea\': \'#3c9992\',\n    \'muddy brown\': \'#886806\',\n    \'turquoise green\': \'#04f489\',\n    \'buff\': \'#fef69e\',\n    \'fawn\': \'#cfaf7b\',\n    \'muted blue\': \'#3b719f\',\n    \'pale rose\': \'#fdc1c5\',\n    \'dark mint green\': \'#20c073\',\n    \'amethyst\': \'#9b5fc0\',\n    \'blue/green\': \'#0f9b8e\',\n    \'chestnut\': \'#742802\',\n    \'sick green\': \'#9db92c\',\n    \'pea\': \'#a4bf20\',\n    \'rusty orange\': \'#cd5909\',\n    \'stone\': \'#ada587\',\n    \'rose red\': \'#be013c\',\n    \'pale aqua\': \'#b8ffeb\',\n    \'deep orange\': \'#dc4d01\',\n    \'earth\': \'#a2653e\',\n    \'mossy green\': \'#638b27\',\n    \'grassy green\': \'#419c03\',\n    \'pale lime green\': \'#b1ff65\',\n    \'light grey blue\': \'#9dbcd4\',\n    \'pale grey\': \'#fdfdfe\',\n    \'asparagus\': \'#77ab56\',\n    \'blueberry\': \'#464196\',\n    \'purple red\': \'#990147\',\n    \'pale lime\': \'#befd73\',\n    \'greenish teal\': \'#32bf84\',\n    \'caramel\': \'#af6f09\',\n    \'deep magenta\': \'#a0025c\',\n    \'light peach\': \'#ffd8b1\',\n    \'milk chocolate\': \'#7f4e1e\',\n    \'ocher\': \'#bf9b0c\',\n    \'off green\': \'#6ba353\',\n    \'purply pink\': \'#f075e6\',\n    \'lightblue\': \'#7bc8f6\',\n    \'dusky blue\': \'#475f94\',\n    \'golden\': \'#f5bf03\',\n    \'light beige\': \'#fffeb6\',\n    \'butter yellow\': \'#fffd74\',\n    \'dusky purple\': \'#895b7b\',\n    \'french blue\': \'#436bad\',\n    \'ugly yellow\': \'#d0c101\',\n    \'greeny yellow\': \'#c6f808\',\n    \'orangish red\': \'#f43605\',\n    \'shamrock green\': \'#02c14d\',\n    \'orangish brown\': \'#b25f03\',\n    \'tree green\': \'#2a7e19\',\n    \'deep violet\': \'#490648\',\n    \'gunmetal\': \'#536267\',\n    \'blue/purple\': \'#5a06ef\',\n    \'cherry\': \'#cf0234\',\n    \'sandy brown\': \'#c4a661\',\n    \'warm grey\': \'#978a84\',\n    \'dark indigo\': \'#1f0954\',\n    \'midnight\': \'#03012d\',\n    \'bluey green\': \'#2bb179\',\n    \'grey pink\': \'#c3909b\',\n    \'soft purple\': \'#a66fb5\',\n    \'blood\': \'#770001\',\n    \'brown red\': \'#922b05\',\n    \'medium grey\': \'#7d7f7c\',\n    \'berry\': \'#990f4b\',\n    \'poo\': \'#8f7303\',\n    \'purpley pink\': \'#c83cb9\',\n    \'light salmon\': \'#fea993\',\n    \'snot\': \'#acbb0d\',\n    \'easter purple\': \'#c071fe\',\n    \'light yellow green\': \'#ccfd7f\',\n    \'dark navy blue\': \'#00022e\',\n    \'drab\': \'#828344\',\n    \'light rose\': \'#ffc5cb\',\n    \'rouge\': \'#ab1239\',\n    \'purplish red\': \'#b0054b\',\n    \'slime green\': \'#99cc04\',\n    \'baby poop\': \'#937c00\',\n    \'irish green\': \'#019529\',\n    \'pink/purple\': \'#ef1de7\',\n    \'dark navy\': \'#000435\',\n    \'greeny blue\': \'#42b395\',\n    \'light plum\': \'#9d5783\',\n    \'pinkish grey\': \'#c8aca9\',\n    \'dirty orange\': \'#c87606\',\n    \'rust red\': \'#aa2704\',\n    \'pale lilac\': \'#e4cbff\',\n    \'orangey red\': \'#fa4224\',\n    \'primary blue\': \'#0804f9\',\n    \'kermit green\': \'#5cb200\',\n    \'brownish purple\': \'#76424e\',\n    \'murky green\': \'#6c7a0e\',\n    \'wheat\': \'#fbdd7e\',\n    \'very dark purple\': \'#2a0134\',\n    \'bottle green\': \'#044a05\',\n    \'watermelon\': \'#fd4659\',\n    \'deep sky blue\': \'#0d75f8\',\n    \'fire engine red\': \'#fe0002\',\n    \'yellow ochre\': \'#cb9d06\',\n    \'pumpkin orange\': \'#fb7d07\',\n    \'pale olive\': \'#b9cc81\',\n    \'light lilac\': \'#edc8ff\',\n    \'lightish green\': \'#61e160\',\n    \'carolina blue\': \'#8ab8fe\',\n    \'mulberry\': \'#920a4e\',\n    \'shocking pink\': \'#fe02a2\',\n    \'auburn\': \'#9a3001\',\n    \'bright lime green\': \'#65fe08\',\n    \'celadon\': \'#befdb7\',\n    \'pinkish brown\': \'#b17261\',\n    \'poo brown\': \'#885f01\',\n    \'bright sky blue\': \'#02ccfe\',\n    \'celery\': \'#c1fd95\',\n    \'dirt brown\': \'#836539\',\n    \'strawberry\': \'#fb2943\',\n    \'dark lime\': \'#84b701\',\n    \'copper\': \'#b66325\',\n    \'medium brown\': \'#7f5112\',\n    \'muted green\': \'#5fa052\',\n    ""robin\'s egg"": \'#6dedfd\',\n    \'bright aqua\': \'#0bf9ea\',\n    \'bright lavender\': \'#c760ff\',\n    \'ivory\': \'#ffffcb\',\n    \'very light purple\': \'#f6cefc\',\n    \'light navy\': \'#155084\',\n    \'pink red\': \'#f5054f\',\n    \'olive brown\': \'#645403\',\n    \'poop brown\': \'#7a5901\',\n    \'mustard green\': \'#a8b504\',\n    \'ocean green\': \'#3d9973\',\n    \'very dark blue\': \'#000133\',\n    \'dusty green\': \'#76a973\',\n    \'light navy blue\': \'#2e5a88\',\n    \'minty green\': \'#0bf77d\',\n    \'adobe\': \'#bd6c48\',\n    \'barney\': \'#ac1db8\',\n    \'jade green\': \'#2baf6a\',\n    \'bright light blue\': \'#26f7fd\',\n    \'light lime\': \'#aefd6c\',\n    \'dark khaki\': \'#9b8f55\',\n    \'orange yellow\': \'#ffad01\',\n    \'ocre\': \'#c69c04\',\n    \'maize\': \'#f4d054\',\n    \'faded pink\': \'#de9dac\',\n    \'british racing green\': \'#05480d\',\n    \'sandstone\': \'#c9ae74\',\n    \'mud brown\': \'#60460f\',\n    \'light sea green\': \'#98f6b0\',\n    \'robin egg blue\': \'#8af1fe\',\n    \'aqua marine\': \'#2ee8bb\',\n    \'dark sea green\': \'#11875d\',\n    \'soft pink\': \'#fdb0c0\',\n    \'orangey brown\': \'#b16002\',\n    \'cherry red\': \'#f7022a\',\n    \'burnt yellow\': \'#d5ab09\',\n    \'brownish grey\': \'#86775f\',\n    \'camel\': \'#c69f59\',\n    \'purplish grey\': \'#7a687f\',\n    \'marine\': \'#042e60\',\n    \'greyish pink\': \'#c88d94\',\n    \'pale turquoise\': \'#a5fbd5\',\n    \'pastel yellow\': \'#fffe71\',\n    \'bluey purple\': \'#6241c7\',\n    \'canary yellow\': \'#fffe40\',\n    \'faded red\': \'#d3494e\',\n    \'sepia\': \'#985e2b\',\n    \'coffee\': \'#a6814c\',\n    \'bright magenta\': \'#ff08e8\',\n    \'mocha\': \'#9d7651\',\n    \'ecru\': \'#feffca\',\n    \'purpleish\': \'#98568d\',\n    \'cranberry\': \'#9e003a\',\n    \'darkish green\': \'#287c37\',\n    \'brown orange\': \'#b96902\',\n    \'dusky rose\': \'#ba6873\',\n    \'melon\': \'#ff7855\',\n    \'sickly green\': \'#94b21c\',\n    \'silver\': \'#c5c9c7\',\n    \'purply blue\': \'#661aee\',\n    \'purpleish blue\': \'#6140ef\',\n    \'hospital green\': \'#9be5aa\',\n    \'shit brown\': \'#7b5804\',\n    \'mid blue\': \'#276ab3\',\n    \'amber\': \'#feb308\',\n    \'easter green\': \'#8cfd7e\',\n    \'soft blue\': \'#6488ea\',\n    \'cerulean blue\': \'#056eee\',\n    \'golden brown\': \'#b27a01\',\n    \'bright turquoise\': \'#0ffef9\',\n    \'red pink\': \'#fa2a55\',\n    \'red purple\': \'#820747\',\n    \'greyish brown\': \'#7a6a4f\',\n    \'vermillion\': \'#f4320c\',\n    \'russet\': \'#a13905\',\n    \'steel grey\': \'#6f828a\',\n    \'lighter purple\': \'#a55af4\',\n    \'bright violet\': \'#ad0afd\',\n    \'prussian blue\': \'#004577\',\n    \'slate green\': \'#658d6d\',\n    \'dirty pink\': \'#ca7b80\',\n    \'dark blue green\': \'#005249\',\n    \'pine\': \'#2b5d34\',\n    \'yellowy green\': \'#bff128\',\n    \'dark gold\': \'#b59410\',\n    \'bluish\': \'#2976bb\',\n    \'darkish blue\': \'#014182\',\n    \'dull red\': \'#bb3f3f\',\n    \'pinky red\': \'#fc2647\',\n    \'bronze\': \'#a87900\',\n    \'pale teal\': \'#82cbb2\',\n    \'military green\': \'#667c3e\',\n    \'barbie pink\': \'#fe46a5\',\n    \'bubblegum pink\': \'#fe83cc\',\n    \'pea soup green\': \'#94a617\',\n    \'dark mustard\': \'#a88905\',\n    \'shit\': \'#7f5f00\',\n    \'medium purple\': \'#9e43a2\',\n    \'very dark green\': \'#062e03\',\n    \'dirt\': \'#8a6e45\',\n    \'dusky pink\': \'#cc7a8b\',\n    \'red violet\': \'#9e0168\',\n    \'lemon yellow\': \'#fdff38\',\n    \'pistachio\': \'#c0fa8b\',\n    \'dull yellow\': \'#eedc5b\',\n    \'dark lime green\': \'#7ebd01\',\n    \'denim blue\': \'#3b5b92\',\n    \'teal blue\': \'#01889f\',\n    \'lightish blue\': \'#3d7afd\',\n    \'purpley blue\': \'#5f34e7\',\n    \'light indigo\': \'#6d5acf\',\n    \'swamp green\': \'#748500\',\n    \'brown green\': \'#706c11\',\n    \'dark maroon\': \'#3c0008\',\n    \'hot purple\': \'#cb00f5\',\n    \'dark forest green\': \'#002d04\',\n    \'faded blue\': \'#658cbb\',\n    \'drab green\': \'#749551\',\n    \'light lime green\': \'#b9ff66\',\n    \'snot green\': \'#9dc100\',\n    \'yellowish\': \'#faee66\',\n    \'light blue green\': \'#7efbb3\',\n    \'bordeaux\': \'#7b002c\',\n    \'light mauve\': \'#c292a1\',\n    \'ocean\': \'#017b92\',\n    \'marigold\': \'#fcc006\',\n    \'muddy green\': \'#657432\',\n    \'dull orange\': \'#d8863b\',\n    \'steel\': \'#738595\',\n    \'electric purple\': \'#aa23ff\',\n    \'fluorescent green\': \'#08ff08\',\n    \'yellowish brown\': \'#9b7a01\',\n    \'blush\': \'#f29e8e\',\n    \'soft green\': \'#6fc276\',\n    \'bright orange\': \'#ff5b00\',\n    \'lemon\': \'#fdff52\',\n    \'purple grey\': \'#866f85\',\n    \'acid green\': \'#8ffe09\',\n    \'pale lavender\': \'#eecffe\',\n    \'violet blue\': \'#510ac9\',\n    \'light forest green\': \'#4f9153\',\n    \'burnt red\': \'#9f2305\',\n    \'khaki green\': \'#728639\',\n    \'cerise\': \'#de0c62\',\n    \'faded purple\': \'#916e99\',\n    \'apricot\': \'#ffb16d\',\n    \'dark olive green\': \'#3c4d03\',\n    \'grey brown\': \'#7f7053\',\n    \'green grey\': \'#77926f\',\n    \'true blue\': \'#010fcc\',\n    \'pale violet\': \'#ceaefa\',\n    \'periwinkle blue\': \'#8f99fb\',\n    \'light sky blue\': \'#c6fcff\',\n    \'blurple\': \'#5539cc\',\n    \'green brown\': \'#544e03\',\n    \'bluegreen\': \'#017a79\',\n    \'bright teal\': \'#01f9c6\',\n    \'brownish yellow\': \'#c9b003\',\n    \'pea soup\': \'#929901\',\n    \'forest\': \'#0b5509\',\n    \'barney purple\': \'#a00498\',\n    \'ultramarine\': \'#2000b1\',\n    \'purplish\': \'#94568c\',\n    \'puke yellow\': \'#c2be0e\',\n    \'bluish grey\': \'#748b97\',\n    \'dark periwinkle\': \'#665fd1\',\n    \'dark lilac\': \'#9c6da5\',\n    \'reddish\': \'#c44240\',\n    \'light maroon\': \'#a24857\',\n    \'dusty purple\': \'#825f87\',\n    \'terra cotta\': \'#c9643b\',\n    \'avocado\': \'#90b134\',\n    \'marine blue\': \'#01386a\',\n    \'teal green\': \'#25a36f\',\n    \'slate grey\': \'#59656d\',\n    \'lighter green\': \'#75fd63\',\n    \'electric green\': \'#21fc0d\',\n    \'dusty blue\': \'#5a86ad\',\n    \'golden yellow\': \'#fec615\',\n    \'bright yellow\': \'#fffd01\',\n    \'light lavender\': \'#dfc5fe\',\n    \'umber\': \'#b26400\',\n    \'poop\': \'#7f5e00\',\n    \'dark peach\': \'#de7e5d\',\n    \'jungle green\': \'#048243\',\n    \'eggshell\': \'#ffffd4\',\n    \'denim\': \'#3b638c\',\n    \'yellow brown\': \'#b79400\',\n    \'dull purple\': \'#84597e\',\n    \'chocolate brown\': \'#411900\',\n    \'wine red\': \'#7b0323\',\n    \'neon blue\': \'#04d9ff\',\n    \'dirty green\': \'#667e2c\',\n    \'light tan\': \'#fbeeac\',\n    \'ice blue\': \'#d7fffe\',\n    \'cadet blue\': \'#4e7496\',\n    \'dark mauve\': \'#874c62\',\n    \'very light blue\': \'#d5ffff\',\n    \'grey purple\': \'#826d8c\',\n    \'pastel pink\': \'#ffbacd\',\n    \'very light green\': \'#d1ffbd\',\n    \'dark sky blue\': \'#448ee4\',\n    \'evergreen\': \'#05472a\',\n    \'dull pink\': \'#d5869d\',\n    \'aubergine\': \'#3d0734\',\n    \'mahogany\': \'#4a0100\',\n    \'reddish orange\': \'#f8481c\',\n    \'deep green\': \'#02590f\',\n    \'vomit green\': \'#89a203\',\n    \'purple pink\': \'#e03fd8\',\n    \'dusty pink\': \'#d58a94\',\n    \'faded green\': \'#7bb274\',\n    \'camo green\': \'#526525\',\n    \'pinky purple\': \'#c94cbe\',\n    \'pink purple\': \'#db4bda\',\n    \'brownish red\': \'#9e3623\',\n    \'dark rose\': \'#b5485d\',\n    \'mud\': \'#735c12\',\n    \'brownish\': \'#9c6d57\',\n    \'emerald green\': \'#028f1e\',\n    \'pale brown\': \'#b1916e\',\n    \'dull blue\': \'#49759c\',\n    \'burnt umber\': \'#a0450e\',\n    \'medium green\': \'#39ad48\',\n    \'clay\': \'#b66a50\',\n    \'light aqua\': \'#8cffdb\',\n    \'light olive green\': \'#a4be5c\',\n    \'brownish orange\': \'#cb7723\',\n    \'dark aqua\': \'#05696b\',\n    \'purplish pink\': \'#ce5dae\',\n    \'dark salmon\': \'#c85a53\',\n    \'greenish grey\': \'#96ae8d\',\n    \'jade\': \'#1fa774\',\n    \'ugly green\': \'#7a9703\',\n    \'dark beige\': \'#ac9362\',\n    \'emerald\': \'#01a049\',\n    \'pale red\': \'#d9544d\',\n    \'light magenta\': \'#fa5ff7\',\n    \'sky\': \'#82cafc\',\n    \'light cyan\': \'#acfffc\',\n    \'yellow orange\': \'#fcb001\',\n    \'reddish purple\': \'#910951\',\n    \'reddish pink\': \'#fe2c54\',\n    \'orchid\': \'#c875c4\',\n    \'dirty yellow\': \'#cdc50a\',\n    \'orange red\': \'#fd411e\',\n    \'deep red\': \'#9a0200\',\n    \'orange brown\': \'#be6400\',\n    \'cobalt blue\': \'#030aa7\',\n    \'neon pink\': \'#fe019a\',\n    \'rose pink\': \'#f7879a\',\n    \'greyish purple\': \'#887191\',\n    \'raspberry\': \'#b00149\',\n    \'aqua green\': \'#12e193\',\n    \'salmon pink\': \'#fe7b7c\',\n    \'tangerine\': \'#ff9408\',\n    \'brownish green\': \'#6a6e09\',\n    \'red brown\': \'#8b2e16\',\n    \'greenish brown\': \'#696112\',\n    \'pumpkin\': \'#e17701\',\n    \'pine green\': \'#0a481e\',\n    \'charcoal\': \'#343837\',\n    \'baby pink\': \'#ffb7ce\',\n    \'cornflower\': \'#6a79f7\',\n    \'blue violet\': \'#5d06e9\',\n    \'chocolate\': \'#3d1c02\',\n    \'greyish green\': \'#82a67d\',\n    \'scarlet\': \'#be0119\',\n    \'green yellow\': \'#c9ff27\',\n    \'dark olive\': \'#373e02\',\n    \'sienna\': \'#a9561e\',\n    \'pastel purple\': \'#caa0ff\',\n    \'terracotta\': \'#ca6641\',\n    \'aqua blue\': \'#02d8e9\',\n    \'sage green\': \'#88b378\',\n    \'blood red\': \'#980002\',\n    \'deep pink\': \'#cb0162\',\n    \'grass\': \'#5cac2d\',\n    \'moss\': \'#769958\',\n    \'pastel blue\': \'#a2bffe\',\n    \'bluish green\': \'#10a674\',\n    \'green blue\': \'#06b48b\',\n    \'dark tan\': \'#af884a\',\n    \'greenish blue\': \'#0b8b87\',\n    \'pale orange\': \'#ffa756\',\n    \'vomit\': \'#a2a415\',\n    \'forrest green\': \'#154406\',\n    \'dark lavender\': \'#856798\',\n    \'dark violet\': \'#34013f\',\n    \'purple blue\': \'#632de9\',\n    \'dark cyan\': \'#0a888a\',\n    \'olive drab\': \'#6f7632\',\n    \'pinkish\': \'#d46a7e\',\n    \'cobalt\': \'#1e488f\',\n    \'neon purple\': \'#bc13fe\',\n    \'light turquoise\': \'#7ef4cc\',\n    \'apple green\': \'#76cd26\',\n    \'dull green\': \'#74a662\',\n    \'wine\': \'#80013f\',\n    \'powder blue\': \'#b1d1fc\',\n    \'off white\': \'#ffffe4\',\n    \'electric blue\': \'#0652ff\',\n    \'dark turquoise\': \'#045c5a\',\n    \'blue purple\': \'#5729ce\',\n    \'azure\': \'#069af3\',\n    \'bright red\': \'#ff000d\',\n    \'pinkish red\': \'#f10c45\',\n    \'cornflower blue\': \'#5170d7\',\n    \'light olive\': \'#acbf69\',\n    \'grape\': \'#6c3461\',\n    \'greyish blue\': \'#5e819d\',\n    \'purplish blue\': \'#601ef9\',\n    \'yellowish green\': \'#b0dd16\',\n    \'greenish yellow\': \'#cdfd02\',\n    \'medium blue\': \'#2c6fbb\',\n    \'dusty rose\': \'#c0737a\',\n    \'light violet\': \'#d6b4fc\',\n    \'midnight blue\': \'#020035\',\n    \'bluish purple\': \'#703be7\',\n    \'red orange\': \'#fd3c06\',\n    \'dark magenta\': \'#960056\',\n    \'greenish\': \'#40a368\',\n    \'ocean blue\': \'#03719c\',\n    \'coral\': \'#fc5a50\',\n    \'cream\': \'#ffffc2\',\n    \'reddish brown\': \'#7f2b0a\',\n    \'burnt sienna\': \'#b04e0f\',\n    \'brick\': \'#a03623\',\n    \'sage\': \'#87ae73\',\n    \'grey green\': \'#789b73\',\n    \'white\': \'#ffffff\',\n    ""robin\'s egg blue"": \'#98eff9\',\n    \'moss green\': \'#658b38\',\n    \'steel blue\': \'#5a7d9a\',\n    \'eggplant\': \'#380835\',\n    \'light yellow\': \'#fffe7a\',\n    \'leaf green\': \'#5ca904\',\n    \'light grey\': \'#d8dcd6\',\n    \'puke\': \'#a5a502\',\n    \'pinkish purple\': \'#d648d7\',\n    \'sea blue\': \'#047495\',\n    \'pale purple\': \'#b790d4\',\n    \'slate blue\': \'#5b7c99\',\n    \'blue grey\': \'#607c8e\',\n    \'hunter green\': \'#0b4008\',\n    \'fuchsia\': \'#ed0dd9\',\n    \'crimson\': \'#8c000f\',\n    \'pale yellow\': \'#ffff84\',\n    \'ochre\': \'#bf9005\',\n    \'mustard yellow\': \'#d2bd0a\',\n    \'light red\': \'#ff474c\',\n    \'cerulean\': \'#0485d1\',\n    \'pale pink\': \'#ffcfdc\',\n    \'deep blue\': \'#040273\',\n    \'rust\': \'#a83c09\',\n    \'light teal\': \'#90e4c1\',\n    \'slate\': \'#516572\',\n    \'goldenrod\': \'#fac205\',\n    \'dark yellow\': \'#d5b60a\',\n    \'dark grey\': \'#363737\',\n    \'army green\': \'#4b5d16\',\n    \'grey blue\': \'#6b8ba4\',\n    \'seafoam\': \'#80f9ad\',\n    \'puce\': \'#a57e52\',\n    \'spring green\': \'#a9f971\',\n    \'dark orange\': \'#c65102\',\n    \'sand\': \'#e2ca76\',\n    \'pastel green\': \'#b0ff9d\',\n    \'mint\': \'#9ffeb0\',\n    \'light orange\': \'#fdaa48\',\n    \'bright pink\': \'#fe01b1\',\n    \'chartreuse\': \'#c1f80a\',\n    \'deep purple\': \'#36013f\',\n    \'dark brown\': \'#341c02\',\n    \'taupe\': \'#b9a281\',\n    \'pea green\': \'#8eab12\',\n    \'puke green\': \'#9aae07\',\n    \'kelly green\': \'#02ab2e\',\n    \'seafoam green\': \'#7af9ab\',\n    \'blue green\': \'#137e6d\',\n    \'khaki\': \'#aaa662\',\n    \'burgundy\': \'#610023\',\n    \'dark teal\': \'#014d4e\',\n    \'brick red\': \'#8f1402\',\n    \'royal purple\': \'#4b006e\',\n    \'plum\': \'#580f41\',\n    \'mint green\': \'#8fff9f\',\n    \'gold\': \'#dbb40c\',\n    \'baby blue\': \'#a2cffe\',\n    \'yellow green\': \'#c0fb2d\',\n    \'bright purple\': \'#be03fd\',\n    \'dark red\': \'#840000\',\n    \'pale blue\': \'#d0fefe\',\n    \'grass green\': \'#3f9b0b\',\n    \'navy\': \'#01153e\',\n    \'aquamarine\': \'#04d8b2\',\n    \'burnt orange\': \'#c04e01\',\n    \'neon green\': \'#0cff0c\',\n    \'bright blue\': \'#0165fc\',\n    \'rose\': \'#cf6275\',\n    \'light pink\': \'#ffd1df\',\n    \'mustard\': \'#ceb301\',\n    \'indigo\': \'#380282\',\n    \'lime\': \'#aaff32\',\n    \'sea green\': \'#53fca1\',\n    \'periwinkle\': \'#8e82fe\',\n    \'dark pink\': \'#cb416b\',\n    \'olive green\': \'#677a04\',\n    \'peach\': \'#ffb07c\',\n    \'pale green\': \'#c7fdb5\',\n    \'light brown\': \'#ad8150\',\n    \'hot pink\': \'#ff028d\',\n    \'black\': \'#000000\',\n    \'lilac\': \'#cea2fd\',\n    \'navy blue\': \'#001146\',\n    \'royal blue\': \'#0504aa\',\n    \'beige\': \'#e6daa6\',\n    \'salmon\': \'#ff796c\',\n    \'olive\': \'#6e750e\',\n    \'maroon\': \'#650021\',\n    \'bright green\': \'#01ff07\',\n    \'dark purple\': \'#35063e\',\n    \'mauve\': \'#ae7181\',\n    \'forest green\': \'#06470c\',\n    \'aqua\': \'#13eac9\',\n    \'cyan\': \'#00ffff\',\n    \'tan\': \'#d1b26f\',\n    \'dark blue\': \'#00035b\',\n    \'lavender\': \'#c79fef\',\n    \'turquoise\': \'#06c2ac\',\n    \'dark green\': \'#033500\',\n    \'violet\': \'#9a0eea\',\n    \'light purple\': \'#bf77f6\',\n    \'lime green\': \'#89fe05\',\n    \'grey\': \'#929591\',\n    \'sky blue\': \'#75bbfd\',\n    \'yellow\': \'#ffff14\',\n    \'magenta\': \'#c20078\',\n    \'light green\': \'#96f97b\',\n    \'orange\': \'#f97306\',\n    \'teal\': \'#029386\',\n    \'light blue\': \'#95d0fc\',\n    \'red\': \'#e50000\',\n    \'brown\': \'#653700\',\n    \'pink\': \'#ff81c0\',\n    \'blue\': \'#0343df\',\n    \'green\': \'#15b01a\',\n    \'purple\': \'#7e1e9c\'}\n\n# Normalize name to ""xkcd:<name>"" to avoid name collisions.\nXKCD_COLORS = {\'xkcd:\' + name: value for name, value in XKCD_COLORS.items()}\n\n\n# https://drafts.csswg.org/css-color-4/#named-colors\nCSS4_COLORS = {\n    \'aliceblue\':            \'#F0F8FF\',\n    \'antiquewhite\':         \'#FAEBD7\',\n    \'aqua\':                 \'#00FFFF\',\n    \'aquamarine\':           \'#7FFFD4\',\n    \'azure\':                \'#F0FFFF\',\n    \'beige\':                \'#F5F5DC\',\n    \'bisque\':               \'#FFE4C4\',\n    \'black\':                \'#000000\',\n    \'blanchedalmond\':       \'#FFEBCD\',\n    \'blue\':                 \'#0000FF\',\n    \'blueviolet\':           \'#8A2BE2\',\n    \'brown\':                \'#A52A2A\',\n    \'burlywood\':            \'#DEB887\',\n    \'cadetblue\':            \'#5F9EA0\',\n    \'chartreuse\':           \'#7FFF00\',\n    \'chocolate\':            \'#D2691E\',\n    \'coral\':                \'#FF7F50\',\n    \'cornflowerblue\':       \'#6495ED\',\n    \'cornsilk\':             \'#FFF8DC\',\n    \'crimson\':              \'#DC143C\',\n    \'cyan\':                 \'#00FFFF\',\n    \'darkblue\':             \'#00008B\',\n    \'darkcyan\':             \'#008B8B\',\n    \'darkgoldenrod\':        \'#B8860B\',\n    \'darkgray\':             \'#A9A9A9\',\n    \'darkgreen\':            \'#006400\',\n    \'darkgrey\':             \'#A9A9A9\',\n    \'darkkhaki\':            \'#BDB76B\',\n    \'darkmagenta\':          \'#8B008B\',\n    \'darkolivegreen\':       \'#556B2F\',\n    \'darkorange\':           \'#FF8C00\',\n    \'darkorchid\':           \'#9932CC\',\n    \'darkred\':              \'#8B0000\',\n    \'darksalmon\':           \'#E9967A\',\n    \'darkseagreen\':         \'#8FBC8F\',\n    \'darkslateblue\':        \'#483D8B\',\n    \'darkslategray\':        \'#2F4F4F\',\n    \'darkslategrey\':        \'#2F4F4F\',\n    \'darkturquoise\':        \'#00CED1\',\n    \'darkviolet\':           \'#9400D3\',\n    \'deeppink\':             \'#FF1493\',\n    \'deepskyblue\':          \'#00BFFF\',\n    \'dimgray\':              \'#696969\',\n    \'dimgrey\':              \'#696969\',\n    \'dodgerblue\':           \'#1E90FF\',\n    \'firebrick\':            \'#B22222\',\n    \'floralwhite\':          \'#FFFAF0\',\n    \'forestgreen\':          \'#228B22\',\n    \'fuchsia\':              \'#FF00FF\',\n    \'gainsboro\':            \'#DCDCDC\',\n    \'ghostwhite\':           \'#F8F8FF\',\n    \'gold\':                 \'#FFD700\',\n    \'goldenrod\':            \'#DAA520\',\n    \'gray\':                 \'#808080\',\n    \'green\':                \'#008000\',\n    \'greenyellow\':          \'#ADFF2F\',\n    \'grey\':                 \'#808080\',\n    \'honeydew\':             \'#F0FFF0\',\n    \'hotpink\':              \'#FF69B4\',\n    \'indianred\':            \'#CD5C5C\',\n    \'indigo\':               \'#4B0082\',\n    \'ivory\':                \'#FFFFF0\',\n    \'khaki\':                \'#F0E68C\',\n    \'lavender\':             \'#E6E6FA\',\n    \'lavenderblush\':        \'#FFF0F5\',\n    \'lawngreen\':            \'#7CFC00\',\n    \'lemonchiffon\':         \'#FFFACD\',\n    \'lightblue\':            \'#ADD8E6\',\n    \'lightcoral\':           \'#F08080\',\n    \'lightcyan\':            \'#E0FFFF\',\n    \'lightgoldenrodyellow\': \'#FAFAD2\',\n    \'lightgray\':            \'#D3D3D3\',\n    \'lightgreen\':           \'#90EE90\',\n    \'lightgrey\':            \'#D3D3D3\',\n    \'lightpink\':            \'#FFB6C1\',\n    \'lightsalmon\':          \'#FFA07A\',\n    \'lightseagreen\':        \'#20B2AA\',\n    \'lightskyblue\':         \'#87CEFA\',\n    \'lightslategray\':       \'#778899\',\n    \'lightslategrey\':       \'#778899\',\n    \'lightsteelblue\':       \'#B0C4DE\',\n    \'lightyellow\':          \'#FFFFE0\',\n    \'lime\':                 \'#00FF00\',\n    \'limegreen\':            \'#32CD32\',\n    \'linen\':                \'#FAF0E6\',\n    \'magenta\':              \'#FF00FF\',\n    \'maroon\':               \'#800000\',\n    \'mediumaquamarine\':     \'#66CDAA\',\n    \'mediumblue\':           \'#0000CD\',\n    \'mediumorchid\':         \'#BA55D3\',\n    \'mediumpurple\':         \'#9370DB\',\n    \'mediumseagreen\':       \'#3CB371\',\n    \'mediumslateblue\':      \'#7B68EE\',\n    \'mediumspringgreen\':    \'#00FA9A\',\n    \'mediumturquoise\':      \'#48D1CC\',\n    \'mediumvioletred\':      \'#C71585\',\n    \'midnightblue\':         \'#191970\',\n    \'mintcream\':            \'#F5FFFA\',\n    \'mistyrose\':            \'#FFE4E1\',\n    \'moccasin\':             \'#FFE4B5\',\n    \'navajowhite\':          \'#FFDEAD\',\n    \'navy\':                 \'#000080\',\n    \'oldlace\':              \'#FDF5E6\',\n    \'olive\':                \'#808000\',\n    \'olivedrab\':            \'#6B8E23\',\n    \'orange\':               \'#FFA500\',\n    \'orangered\':            \'#FF4500\',\n    \'orchid\':               \'#DA70D6\',\n    \'palegoldenrod\':        \'#EEE8AA\',\n    \'palegreen\':            \'#98FB98\',\n    \'paleturquoise\':        \'#AFEEEE\',\n    \'palevioletred\':        \'#DB7093\',\n    \'papayawhip\':           \'#FFEFD5\',\n    \'peachpuff\':            \'#FFDAB9\',\n    \'peru\':                 \'#CD853F\',\n    \'pink\':                 \'#FFC0CB\',\n    \'plum\':                 \'#DDA0DD\',\n    \'powderblue\':           \'#B0E0E6\',\n    \'purple\':               \'#800080\',\n    \'rebeccapurple\':        \'#663399\',\n    \'red\':                  \'#FF0000\',\n    \'rosybrown\':            \'#BC8F8F\',\n    \'royalblue\':            \'#4169E1\',\n    \'saddlebrown\':          \'#8B4513\',\n    \'salmon\':               \'#FA8072\',\n    \'sandybrown\':           \'#F4A460\',\n    \'seagreen\':             \'#2E8B57\',\n    \'seashell\':             \'#FFF5EE\',\n    \'sienna\':               \'#A0522D\',\n    \'silver\':               \'#C0C0C0\',\n    \'skyblue\':              \'#87CEEB\',\n    \'slateblue\':            \'#6A5ACD\',\n    \'slategray\':            \'#708090\',\n    \'slategrey\':            \'#708090\',\n    \'snow\':                 \'#FFFAFA\',\n    \'springgreen\':          \'#00FF7F\',\n    \'steelblue\':            \'#4682B4\',\n    \'tan\':                  \'#D2B48C\',\n    \'teal\':                 \'#008080\',\n    \'thistle\':              \'#D8BFD8\',\n    \'tomato\':               \'#FF6347\',\n    \'turquoise\':            \'#40E0D0\',\n    \'violet\':               \'#EE82EE\',\n    \'wheat\':                \'#F5DEB3\',\n    \'white\':                \'#FFFFFF\',\n    \'whitesmoke\':           \'#F5F5F5\',\n    \'yellow\':               \'#FFFF00\',\n    \'yellowgreen\':          \'#9ACD32\'}\n'"
napari/utils/colormaps/vendored/cm.py,6,"b'""""""\nBuiltin colormaps, colormap handling utilities, and the `ScalarMappable` mixin.\n\n.. seealso::\n\n  :doc:`/gallery/color/colormap_reference` for a list of builtin\n  colormaps.\n\n  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n  make colormaps and\n\n  :doc:`/tutorials/colors/colormaps` an in-depth discussion of\n  choosing colormaps.\n\n  :doc:`/tutorials/colors/colormapnorms` for more details about data\n  normalization\n\n\n""""""\n\nimport functools\n\nimport numpy as np\nfrom numpy import ma\n\nfrom . import colors\nfrom ._cm import datad\nfrom ._cm_listed import cmaps as cmaps_listed\n\n\ncmap_d = {}\n\n\n# reverse all the colormaps.\n# reversed colormaps have \'_r\' appended to the name.\n\n\ndef _reverser(f, x=None):\n    """"""Helper such that ``_reverser(f)(x) == f(1 - x)``.""""""\n    if x is None:\n        # Returning a partial object keeps it picklable.\n        return functools.partial(_reverser, f)\n    return f(1 - x)\n\n\ndef revcmap(data):\n    """"""Can only handle specification *data* in dictionary format.""""""\n    data_r = {}\n    for key, val in data.items():\n        if callable(val):\n            valnew = _reverser(val)\n            # This doesn\'t work: lambda x: val(1-x)\n            # The same ""val"" (the first one) is used\n            # each time, so the colors are identical\n            # and the result is shades of gray.\n        else:\n            # Flip x and exchange the y values facing x = 0 and x = 1.\n            valnew = [(1.0 - x, y1, y0) for x, y0, y1 in reversed(val)]\n        data_r[key] = valnew\n    return data_r\n\n\ndef _reverse_cmap_spec(spec):\n    """"""Reverses cmap specification *spec*, can handle both dict and tuple\n    type specs.""""""\n\n    if \'listed\' in spec:\n        return {\'listed\': spec[\'listed\'][::-1]}\n\n    if \'red\' in spec:\n        return revcmap(spec)\n    else:\n        revspec = list(reversed(spec))\n        if len(revspec[0]) == 2:    # e.g., (1, (1.0, 0.0, 1.0))\n            revspec = [(1.0 - a, b) for a, b in revspec]\n        return revspec\n\n\ndef _generate_cmap(name, lutsize):\n    """"""Generates the requested cmap from its *name*.  The lut size is\n    *lutsize*.""""""\n\n    spec = datad[name]\n\n    # Generate the colormap object.\n    if \'red\' in spec:\n        return colors.LinearSegmentedColormap(name, spec, lutsize)\n    elif \'listed\' in spec:\n        return colors.ListedColormap(spec[\'listed\'], name)\n    else:\n        return colors.LinearSegmentedColormap.from_list(name, spec, lutsize)\n\n\nLUTSIZE = 256\n\n# Generate the reversed specifications (all at once, to avoid\n# modify-when-iterating).\ndatad.update({cmapname + \'_r\': _reverse_cmap_spec(spec)\n              for cmapname, spec in datad.items()})\n\n# Precache the cmaps with ``lutsize = LUTSIZE``.\n# Also add the reversed ones added in the section above:\nfor cmapname in datad:\n    cmap_d[cmapname] = _generate_cmap(cmapname, LUTSIZE)\n\ncmap_d.update(cmaps_listed)\n\nlocals().update(cmap_d)\n\n\n# Continue with definitions ...\n\n\ndef register_cmap(name=None, cmap=None, data=None, lut=None):\n    """"""\n    Add a colormap to the set recognized by :func:`get_cmap`.\n\n    It can be used in two ways::\n\n        register_cmap(name=\'swirly\', cmap=swirly_cmap)\n\n        register_cmap(name=\'choppy\', data=choppydata, lut=128)\n\n    In the first case, *cmap* must be a :class:`matplotlib.colors.Colormap`\n    instance.  The *name* is optional; if absent, the name will\n    be the :attr:`~matplotlib.colors.Colormap.name` attribute of the *cmap*.\n\n    In the second case, the three arguments are passed to\n    the :class:`~matplotlib.colors.LinearSegmentedColormap` initializer,\n    and the resulting colormap is registered.\n\n    """"""\n    if name is None:\n        try:\n            name = cmap.name\n        except AttributeError:\n            raise ValueError(""Arguments must include a name or a Colormap"")\n\n    if not isinstance(name, str):\n        raise ValueError(""Colormap name must be a string"")\n\n    if isinstance(cmap, colors.Colormap):\n        cmap_d[name] = cmap\n        return\n\n    # For the remainder, let exceptions propagate.\n    if lut is None:\n        lut = LUTSIZE\n    cmap = colors.LinearSegmentedColormap(name, data, lut)\n    cmap_d[name] = cmap\n\n\ndef get_cmap(name=None, lut=None):\n    """"""\n    Get a colormap instance, defaulting to rc values if *name* is None.\n\n    Colormaps added with :func:`register_cmap` take precedence over\n    built-in colormaps.\n\n    If *name* is a :class:`matplotlib.colors.Colormap` instance, it will be\n    returned.\n\n    If *lut* is not None it must be an integer giving the number of\n    entries desired in the lookup table, and *name* must be a standard\n    mpl colormap name.\n    """"""\n    if name is None:\n        name = \'magma\'\n\n    if isinstance(name, colors.Colormap):\n        return name\n\n    if name in cmap_d:\n        if lut is None:\n            return cmap_d[name]\n        else:\n            return cmap_d[name]._resample(lut)\n    else:\n        raise ValueError(\n            ""Colormap %s is not recognized. Possible values are: %s""\n            % (name, \', \'.join(sorted(cmap_d))))\n\n\nclass ScalarMappable(object):\n    """"""\n    This is a mixin class to support scalar data to RGBA mapping.\n    The ScalarMappable makes use of data normalization before returning\n    RGBA colors from the given colormap.\n\n    """"""\n    def __init__(self, norm=None, cmap=None):\n        r""""""\n\n        Parameters\n        ----------\n        norm : :class:`matplotlib.colors.Normalize` instance\n            The normalizing object which scales data, typically into the\n            interval ``[0, 1]``.\n            If *None*, *norm* defaults to a *colors.Normalize* object which\n            initializes its scaling based on the first data processed.\n        cmap : str or :class:`~matplotlib.colors.Colormap` instance\n            The colormap used to map normalized data values to RGBA colors.\n        """"""\n        if cmap is None:\n            cmap = get_cmap()\n        if norm is None:\n            norm = colors.Normalize()\n\n        self._A = None\n        #: The Normalization instance of this ScalarMappable.\n        self.norm = norm\n        #: The Colormap instance of this ScalarMappable.\n        self.cmap = get_cmap(cmap)\n        #: The last colorbar associated with this ScalarMappable. May be None.\n        self.colorbar = None\n        self.update_dict = {\'array\': False}\n\n    def to_rgba(self, x, alpha=None, bytes=False, norm=True):\n        """"""\n        Return a normalized rgba array corresponding to *x*.\n\n        In the normal case, *x* is a 1-D or 2-D sequence of scalars, and\n        the corresponding ndarray of rgba values will be returned,\n        based on the norm and colormap set for this ScalarMappable.\n\n        There is one special case, for handling images that are already\n        rgb or rgba, such as might have been read from an image file.\n        If *x* is an ndarray with 3 dimensions,\n        and the last dimension is either 3 or 4, then it will be\n        treated as an rgb or rgba array, and no mapping will be done.\n        The array can be uint8, or it can be floating point with\n        values in the 0-1 range; otherwise a ValueError will be raised.\n        If it is a masked array, the mask will be ignored.\n        If the last dimension is 3, the *alpha* kwarg (defaulting to 1)\n        will be used to fill in the transparency.  If the last dimension\n        is 4, the *alpha* kwarg is ignored; it does not\n        replace the pre-existing alpha.  A ValueError will be raised\n        if the third dimension is other than 3 or 4.\n\n        In either case, if *bytes* is *False* (default), the rgba\n        array will be floats in the 0-1 range; if it is *True*,\n        the returned rgba array will be uint8 in the 0 to 255 range.\n\n        If norm is False, no normalization of the input data is\n        performed, and it is assumed to be in the range (0-1).\n\n        """"""\n        # First check for special case, image input:\n        try:\n            if x.ndim == 3:\n                if x.shape[2] == 3:\n                    if alpha is None:\n                        alpha = 1\n                    if x.dtype == np.uint8:\n                        alpha = np.uint8(alpha * 255)\n                    m, n = x.shape[:2]\n                    xx = np.empty(shape=(m, n, 4), dtype=x.dtype)\n                    xx[:, :, :3] = x\n                    xx[:, :, 3] = alpha\n                elif x.shape[2] == 4:\n                    xx = x\n                else:\n                    raise ValueError(""third dimension must be 3 or 4"")\n                if xx.dtype.kind == \'f\':\n                    if norm and (xx.max() > 1 or xx.min() < 0):\n                        raise ValueError(""Floating point image RGB values ""\n                                         ""must be in the 0..1 range."")\n                    if bytes:\n                        xx = (xx * 255).astype(np.uint8)\n                elif xx.dtype == np.uint8:\n                    if not bytes:\n                        xx = xx.astype(np.float32) / 255\n                else:\n                    raise ValueError(""Image RGB array must be uint8 or ""\n                                     ""floating point; found %s"" % xx.dtype)\n                return xx\n        except AttributeError:\n            # e.g., x is not an ndarray; so try mapping it\n            pass\n\n        # This is the normal case, mapping a scalar array:\n        x = ma.asarray(x)\n        if norm:\n            x = self.norm(x)\n        rgba = self.cmap(x, alpha=alpha, bytes=bytes)\n        return rgba\n\n    def set_array(self, A):\n        """"""Set the image array from numpy array *A*.\n\n        Parameters\n        ----------\n        A : ndarray\n        """"""\n        self._A = A\n        self.update_dict[\'array\'] = True\n\n    def get_array(self):\n        \'Return the array\'\n        return self._A\n\n    def get_cmap(self):\n        \'return the colormap\'\n        return self.cmap\n\n    def get_clim(self):\n        \'return the min, max of the color limits for image scaling\'\n        return self.norm.vmin, self.norm.vmax\n\n    def set_clim(self, vmin=None, vmax=None):\n        """"""\n        set the norm limits for image scaling; if *vmin* is a length2\n        sequence, interpret it as ``(vmin, vmax)`` which is used to\n        support setp\n\n        ACCEPTS: a length 2 sequence of floats; may be overridden in methods\n        that have ``vmin`` and ``vmax`` kwargs.\n        """"""\n        if vmax is None:\n            try:\n                vmin, vmax = vmin\n            except (TypeError, ValueError):\n                pass\n        if vmin is not None:\n            self.norm.vmin = colors._sanitize_extrema(vmin)\n        if vmax is not None:\n            self.norm.vmax = colors._sanitize_extrema(vmax)\n        self.changed()\n\n    def set_cmap(self, cmap):\n        """"""\n        set the colormap for luminance data\n\n        Parameters\n        ----------\n        cmap : colormap or registered colormap name\n        """"""\n        cmap = get_cmap(cmap)\n        self.cmap = cmap\n        self.changed()\n\n    def set_norm(self, norm):\n        """"""Set the normalization instance.\n\n        Parameters\n        ----------\n        norm : `.Normalize`\n        """"""\n        if norm is None:\n            norm = colors.Normalize()\n        self.norm = norm\n        self.changed()\n\n    def autoscale(self):\n        """"""\n        Autoscale the scalar limits on the norm instance using the\n        current array\n        """"""\n        if self._A is None:\n            raise TypeError(\'You must first set_array for mappable\')\n        self.norm.autoscale(self._A)\n        self.changed()\n\n    def autoscale_None(self):\n        """"""\n        Autoscale the scalar limits on the norm instance using the\n        current array, changing only limits that are None\n        """"""\n        if self._A is None:\n            raise TypeError(\'You must first set_array for mappable\')\n        self.norm.autoscale_None(self._A)\n        self.changed()\n\n    def add_checker(self, checker):\n        """"""\n        Add an entry to a dictionary of boolean flags\n        that are set to True when the mappable is changed.\n        """"""\n        self.update_dict[checker] = False\n\n    def check_update(self, checker):\n        """"""\n        If mappable has changed since the last check,\n        return True; else return False\n        """"""\n        if self.update_dict[checker]:\n            self.update_dict[checker] = False\n            return True\n        return False\n\n    def changed(self):\n        for key in self.update_dict:\n            self.update_dict[key] = True\n        self.stale = True\n'"
napari/utils/colormaps/vendored/colorconv.py,39,"b'""""""Functions for converting between color spaces.\n\nThe ""central"" color space in this module is RGB, more specifically the linear\nsRGB color space using D65 as a white-point [1]_.  This represents a\nstandard monitor (w/o gamma correction). For a good FAQ on color spaces see\n[2]_.\n\nThe API consists of functions to convert to and from RGB as defined above, as\nwell as a generic function to convert to and from any supported color space\n(which is done through RGB in most cases).\n\n\nSupported color spaces\n----------------------\n* RGB : Red Green Blue.\n        Here the sRGB standard [1]_.\n* HSV : Hue, Saturation, Value.\n        Uniquely defined when related to sRGB [3]_.\n* RGB CIE : Red Green Blue.\n        The original RGB CIE standard from 1931 [4]_. Primary colors are 700 nm\n        (red), 546.1 nm (blue) and 435.8 nm (green).\n* XYZ CIE : XYZ\n        Derived from the RGB CIE color space. Chosen such that\n        ``x == y == z == 1/3`` at the whitepoint, and all color matching\n        functions are greater than zero everywhere.\n* LAB CIE : Lightness, a, b\n        Colorspace derived from XYZ CIE that is intended to be more\n        perceptually uniform\n* LUV CIE : Lightness, u, v\n        Colorspace derived from XYZ CIE that is intended to be more\n        perceptually uniform\n* LCH CIE : Lightness, Chroma, Hue\n        Defined in terms of LAB CIE.  C and H are the polar representation of\n        a and b.  The polar angle C is defined to be on ``(0, 2*pi)``\n\n:author: Nicolas Pinto (rgb2hsv)\n:author: Ralf Gommers (hsv2rgb)\n:author: Travis Oliphant (XYZ and RGB CIE functions)\n:author: Matt Terry (lab2lch)\n:author: Alex Izvorski (yuv2rgb, rgb2yuv and related)\n\n:license: modified BSD\n\nReferences\n----------\n.. [1] Official specification of sRGB, IEC 61966-2-1:1999.\n.. [2] http://www.poynton.com/ColorFAQ.html\n.. [3] https://en.wikipedia.org/wiki/HSL_and_HSV\n.. [4] https://en.wikipedia.org/wiki/CIE_1931_color_space\n""""""\n\n\nimport numpy as np\nfrom scipy import linalg\n\n\ndef guess_spatial_dimensions(image):\n    """"""Make an educated guess about whether an image has a channels dimension.\n\n    Parameters\n    ----------\n    image : ndarray\n        The input image.\n\n    Returns\n    -------\n    spatial_dims : int or None\n        The number of spatial dimensions of `image`. If ambiguous, the value\n        is ``None``.\n\n    Raises\n    ------\n    ValueError\n        If the image array has less than two or more than four dimensions.\n    """"""\n    if image.ndim == 2:\n        return 2\n    if image.ndim == 3 and image.shape[-1] != 3:\n        return 3\n    if image.ndim == 3 and image.shape[-1] == 3:\n        return None\n    if image.ndim == 4 and image.shape[-1] == 3:\n        return 3\n    else:\n        raise ValueError(""Expected 2D, 3D, or 4D array, got %iD."" % image.ndim)\n\n\ndef _prepare_colorarray(arr):\n    """"""Check the shape of the array and convert it to\n    floating point representation.\n\n    """"""\n    arr = np.asanyarray(arr)\n\n    if arr.shape[-1] != 3:\n        msg = (""the input array must be have a shape == ([ ..,] 3)), "" +\n               ""got ("" + ("", "".join(map(str, arr.shape))) + "")"")\n        raise ValueError(msg)\n\n    return arr.astype(float)\n\n\ndef _prepare_rgba_array(arr):\n    """"""Check the shape of the array to be RGBA and convert it to\n    floating point representation.\n\n    """"""\n    arr = np.asanyarray(arr)\n\n    if arr.shape[-1] != 4:\n        msg = (""the input array must have a shape == ([ ..,] 4)), ""\n               ""got {0}"".format(arr.shape))\n        raise ValueError(msg)\n\n    return arr.astype(float)\n\n\ndef rgba2rgb(rgba, background=(1, 1, 1)):\n    """"""RGBA to RGB conversion.\n\n    Parameters\n    ----------\n    rgba : array_like\n        The image in RGBA format, in a 3-D array of shape ``(.., .., 4)``.\n    background : array_like\n        The color of the background to blend the image with. A tuple\n        containing 3 floats between 0 to 1 - the RGB value of the background.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgba` is not a 3-D array of shape ``(.., .., 4)``.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending\n\n    Examples\n    --------\n    >>> from skimage import color\n    >>> from skimage import data\n    >>> img_rgba = data.logo()\n    >>> img_rgb = color.rgba2rgb(img_rgba)\n    """"""\n    arr = _prepare_rgba_array(rgba)\n    if isinstance(background, tuple) and len(background) != 3:\n        raise ValueError(\'the background must be a tuple with 3 items - the \'\n                         \'RGB color of the background. Got {0} items.\'\n                         .format(len(background)))\n\n    alpha = arr[..., -1]\n    channels = arr[..., :-1]\n    out = np.empty_like(channels)\n\n    for ichan in range(channels.shape[-1]):\n        out[..., ichan] = np.clip(\n            (1 - alpha) * background[ichan] + alpha * channels[..., ichan],\n            a_min=0, a_max=1)\n    return out\n\n\ndef rgb2hsv(rgb):\n    """"""RGB to HSV color space conversion.\n\n    Parameters\n    ----------\n    rgb : array_like\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in HSV format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgb` is not a 3-D array of shape ``(.., .., 3)``.\n\n    Notes\n    -----\n    Conversion between RGB and HSV color spaces results in some loss of\n    precision, due to integer arithmetic and rounding [1]_.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/HSL_and_HSV\n\n    Examples\n    --------\n    >>> from skimage import color\n    >>> from skimage import data\n    >>> img = data.astronaut()\n    >>> img_hsv = color.rgb2hsv(img)\n    """"""\n    arr = _prepare_colorarray(rgb)\n    out = np.empty_like(arr)\n\n    # -- V channel\n    out_v = arr.max(-1)\n\n    # -- S channel\n    delta = arr.ptp(-1)\n    # Ignore warning for zero divided by zero\n    old_settings = np.seterr(invalid=\'ignore\')\n    out_s = delta / out_v\n    out_s[delta == 0.] = 0.\n\n    # -- H channel\n    # red is max\n    idx = (arr[:, :, 0] == out_v)\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n\n    # green is max\n    idx = (arr[:, :, 1] == out_v)\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n\n    # blue is max\n    idx = (arr[:, :, 2] == out_v)\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n    out_h = (out[:, :, 0] / 6.) % 1.\n    out_h[delta == 0.] = 0.\n\n    np.seterr(**old_settings)\n\n    # -- output\n    out[:, :, 0] = out_h\n    out[:, :, 1] = out_s\n    out[:, :, 2] = out_v\n\n    # remove NaN\n    out[np.isnan(out)] = 0\n\n    return out\n\n\ndef hsv2rgb(hsv):\n    """"""HSV to RGB color space conversion.\n\n    Parameters\n    ----------\n    hsv : array_like\n        The image in HSV format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `hsv` is not a 3-D array of shape ``(.., .., 3)``.\n\n    Notes\n    -----\n    Conversion between RGB and HSV color spaces results in some loss of\n    precision, due to integer arithmetic and rounding [1]_.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/HSL_and_HSV\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> img = data.astronaut()\n    >>> img_hsv = rgb2hsv(img)\n    >>> img_rgb = hsv2rgb(img_hsv)\n    """"""\n    arr = _prepare_colorarray(hsv)\n\n    hi = np.floor(arr[:, :, 0] * 6)\n    f = arr[:, :, 0] * 6 - hi\n    p = arr[:, :, 2] * (1 - arr[:, :, 1])\n    q = arr[:, :, 2] * (1 - f * arr[:, :, 1])\n    t = arr[:, :, 2] * (1 - (1 - f) * arr[:, :, 1])\n    v = arr[:, :, 2]\n\n    hi = np.dstack([hi, hi, hi]).astype(np.uint8) % 6\n    out = np.choose(hi, [np.dstack((v, t, p)),\n                         np.dstack((q, v, p)),\n                         np.dstack((p, v, t)),\n                         np.dstack((p, q, v)),\n                         np.dstack((t, p, v)),\n                         np.dstack((v, p, q))])\n\n    return out\n\n\n# ---------------------------------------------------------------\n# Primaries for the coordinate systems\n# ---------------------------------------------------------------\ncie_primaries = np.array([700, 546.1, 435.8])\nsb_primaries = np.array([1. / 155, 1. / 190, 1. / 225]) * 1e5\n\n# ---------------------------------------------------------------\n# Matrices that define conversion between different color spaces\n# ---------------------------------------------------------------\n\n# From sRGB specification\nxyz_from_rgb = np.array([[0.412453, 0.357580, 0.180423],\n                         [0.212671, 0.715160, 0.072169],\n                         [0.019334, 0.119193, 0.950227]])\n\nrgb_from_xyz = linalg.inv(xyz_from_rgb)\n\n# From https://en.wikipedia.org/wiki/CIE_1931_color_space\n# Note: Travis\'s code did not have the divide by 0.17697\nxyz_from_rgbcie = np.array([[0.49, 0.31, 0.20],\n                            [0.17697, 0.81240, 0.01063],\n                            [0.00, 0.01, 0.99]]) / 0.17697\n\nrgbcie_from_xyz = linalg.inv(xyz_from_rgbcie)\n\n# construct matrices to and from rgb:\nrgbcie_from_rgb = rgbcie_from_xyz @ xyz_from_rgb\nrgb_from_rgbcie = rgb_from_xyz @ xyz_from_rgbcie\n\n\ngray_from_rgb = np.array([[0.2125, 0.7154, 0.0721],\n                          [0, 0, 0],\n                          [0, 0, 0]])\n\nyuv_from_rgb = np.array([[ 0.299     ,  0.587     ,  0.114      ],\n                         [-0.14714119, -0.28886916,  0.43601035 ],\n                         [ 0.61497538, -0.51496512, -0.10001026 ]])\n\nrgb_from_yuv = linalg.inv(yuv_from_rgb)\n\n\n# CIE LAB constants for Observer=2A, Illuminant=D65\n# NOTE: this is actually the XYZ values for the illuminant above.\nlab_ref_white = np.array([0.95047, 1., 1.08883])\n\n# XYZ coordinates of the illuminants, scaled to [0, 1]. For each illuminant I\n# we have:\n#\n#   illuminant[I][0] corresponds to the XYZ coordinates for the 2 degree\n#   field of view.\n#\n#   illuminant[I][1] corresponds to the XYZ coordinates for the 10 degree\n#   field of view.\n#\n# The XYZ coordinates are calculated from [1], using the formula:\n#\n#   X = x * ( Y / y )\n#   Y = Y\n#   Z = ( 1 - x - y ) * ( Y / y )\n#\n# where Y = 1. The only exception is the illuminant ""D65"" with aperture angle\n# 2, whose coordinates are copied from \'lab_ref_white\' for\n# backward-compatibility reasons.\n#\n#     References\n#    ----------\n#    .. [1] https://en.wikipedia.org/wiki/Standard_illuminant\n\nilluminants = \\\n    {""A"": {\'2\': (1.098466069456375, 1, 0.3558228003436005),\n           \'10\': (1.111420406956693, 1, 0.3519978321919493)},\n     ""D50"": {\'2\': (0.9642119944211994, 1, 0.8251882845188288),\n             \'10\': (0.9672062750333777, 1, 0.8142801513128616)},\n     ""D55"": {\'2\': (0.956797052643698, 1, 0.9214805860173273),\n             \'10\': (0.9579665682254781, 1, 0.9092525159847462)},\n     ""D65"": {\'2\': (0.95047, 1., 1.08883),   # This was: `lab_ref_white`\n             \'10\': (0.94809667673716, 1, 1.0730513595166162)},\n     ""D75"": {\'2\': (0.9497220898840717, 1, 1.226393520724154),\n             \'10\': (0.9441713925645873, 1, 1.2064272211720228)},\n     ""E"": {\'2\': (1.0, 1.0, 1.0),\n           \'10\': (1.0, 1.0, 1.0)}}\n\n\ndef get_xyz_coords(illuminant, observer):\n    """"""Get the XYZ coordinates of the given illuminant and observer [1]_.\n\n    Parameters\n    ----------\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    (x, y, z) : tuple\n        A tuple with 3 elements containing the XYZ coordinates of the given\n        illuminant.\n\n    Raises\n    ------\n    ValueError\n        If either the illuminant or the observer angle are not supported or\n        unknown.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Standard_illuminant\n\n    """"""\n    illuminant = illuminant.upper()\n    try:\n        return illuminants[illuminant][observer]\n    except KeyError:\n        raise ValueError(""Unknown illuminant/observer combination\\\n        (\\\'{0}\\\', \\\'{1}\\\')"".format(illuminant, observer))\n\n# -------------------------------------------------------------\n# The conversion functions that make use of the matrices above\n# -------------------------------------------------------------\n\n\ndef _convert(matrix, arr):\n    """"""Do the color space conversion.\n\n    Parameters\n    ----------\n    matrix : array_like\n        The 3x3 matrix to use.\n    arr : array_like\n        The input array.\n\n    Returns\n    -------\n    out : ndarray, dtype=float\n        The converted array.\n    """"""\n    arr = _prepare_colorarray(arr)\n\n    return arr @ matrix.T.copy()\n\n\ndef xyz2rgb(xyz):\n    """"""XYZ to RGB color space conversion.\n\n    Parameters\n    ----------\n    xyz : array_like\n        The image in XYZ format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `xyz` is not a 3-D array of shape ``(.., .., 3)``.\n\n    Notes\n    -----\n    The CIE XYZ color space is derived from the CIE RGB color space. Note\n    however that this function converts to sRGB.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/CIE_1931_color_space\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.color import rgb2xyz, xyz2rgb\n    >>> img = data.astronaut()\n    >>> img_xyz = rgb2xyz(img)\n    >>> img_rgb = xyz2rgb(img_xyz)\n    """"""\n    # Follow the algorithm from http://www.easyrgb.com/index.php\n    # except we don\'t multiply/divide by 100 in the conversion\n    arr = _convert(rgb_from_xyz, xyz)\n    mask = arr > 0.0031308\n    arr[mask] = 1.055 * np.power(arr[mask], 1 / 2.4) - 0.055\n    arr[~mask] *= 12.92\n    return arr\n\n\ndef rgb2xyz(rgb):\n    """"""RGB to XYZ color space conversion.\n\n    Parameters\n    ----------\n    rgb : array_like\n        The image in RGB format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in XYZ format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgb` is not a 3- or 4-D array of shape ``(.., ..,[ ..,] 3)``.\n\n    Notes\n    -----\n    The CIE XYZ color space is derived from the CIE RGB color space. Note\n    however that this function converts from sRGB.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/CIE_1931_color_space\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> img = data.astronaut()\n    >>> img_xyz = rgb2xyz(img)\n    """"""\n    # Follow the algorithm from http://www.easyrgb.com/index.php\n    # except we don\'t multiply/divide by 100 in the conversion\n    arr = _prepare_colorarray(rgb).copy()\n    mask = arr > 0.04045\n    arr[mask] = np.power((arr[mask] + 0.055) / 1.055, 2.4)\n    arr[~mask] /= 12.92\n    return _convert(xyz_from_rgb, arr)\n\n\ndef rgb2rgbcie(rgb):\n    """"""RGB to RGB CIE color space conversion.\n\n    Parameters\n    ----------\n    rgb : array_like\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB CIE format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgb` is not a 3-D array of shape ``(.., .., 3)``.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/CIE_1931_color_space\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.color import rgb2rgbcie\n    >>> img = data.astronaut()\n    >>> img_rgbcie = rgb2rgbcie(img)\n    """"""\n    return _convert(rgbcie_from_rgb, rgb)\n\n\ndef rgbcie2rgb(rgbcie):\n    """"""RGB CIE to RGB color space conversion.\n\n    Parameters\n    ----------\n    rgbcie : array_like\n        The image in RGB CIE format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgbcie` is not a 3-D array of shape ``(.., .., 3)``.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/CIE_1931_color_space\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.color import rgb2rgbcie, rgbcie2rgb\n    >>> img = data.astronaut()\n    >>> img_rgbcie = rgb2rgbcie(img)\n    >>> img_rgb = rgbcie2rgb(img_rgbcie)\n    """"""\n    return _convert(rgb_from_rgbcie, rgbcie)\n\n\ndef rgb2gray(rgb):\n    """"""Compute luminance of an RGB image.\n\n    Parameters\n    ----------\n    rgb : array_like\n        The image in RGB format, in a 3-D or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``, or in RGBA format with shape\n        ``(.., ..,[ ..,] 4)``.\n\n    Returns\n    -------\n    out : ndarray\n        The luminance image - an array which is the same size as the input\n        array, but with the channel dimension removed.\n\n    Raises\n    ------\n    ValueError\n        If `rgb2gray` is not a 3-D or 4-D arrays of shape\n        ``(.., ..,[ ..,] 3)`` or ``(.., ..,[ ..,] 4)``.\n\n    References\n    ----------\n    .. [1] http://www.poynton.com/PDFs/ColorFAQ.pdf\n\n    Notes\n    -----\n    The weights used in this conversion are calibrated for contemporary\n    CRT phosphors::\n\n        Y = 0.2125 R + 0.7154 G + 0.0721 B\n\n    If there is an alpha channel present, it is ignored.\n\n    Examples\n    --------\n    >>> from skimage.color import rgb2gray\n    >>> from skimage import data\n    >>> img = data.astronaut()\n    >>> img_gray = rgb2gray(img)\n    """"""\n\n    if rgb.ndim == 2:\n        return np.ascontiguousarray(rgb)\n\n    rgb = _prepare_colorarray(rgb[..., :3])\n    coeffs = np.array([0.2125, 0.7154, 0.0721], dtype=rgb.dtype)\n    return rgb @ coeffs\n\n\nrgb2grey = rgb2gray\n\n\ndef xyz2lab(xyz, illuminant=""D65"", observer=""2""):\n    """"""XYZ to CIE-LAB color space conversion.\n\n    Parameters\n    ----------\n    xyz : array_like\n        The image in XYZ format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : ndarray\n        The image in CIE-LAB format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `xyz` is not a 3-D array of shape ``(.., ..,[ ..,] 3)``.\n    ValueError\n        If either the illuminant or the observer angle is unsupported or\n        unknown.\n\n    Notes\n    -----\n    By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values\n    x_ref=95.047, y_ref=100., z_ref=108.883. See function `get_xyz_coords` for\n    a list of supported illuminants.\n\n    References\n    ----------\n    .. [1] http://www.easyrgb.com/index.php?X=MATH&H=07#text7\n    .. [2] https://en.wikipedia.org/wiki/Lab_color_space\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.color import rgb2xyz, xyz2lab\n    >>> img = data.astronaut()\n    >>> img_xyz = rgb2xyz(img)\n    >>> img_lab = xyz2lab(img_xyz)\n    """"""\n    arr = _prepare_colorarray(xyz)\n\n    xyz_ref_white = get_xyz_coords(illuminant, observer)\n\n    # scale by CIE XYZ tristimulus values of the reference white point\n    arr = arr / xyz_ref_white\n\n    # Nonlinear distortion and linear transformation\n    mask = arr > 0.008856\n    arr[mask] = np.cbrt(arr[mask])\n    arr[~mask] = 7.787 * arr[~mask] + 16. / 116.\n\n    x, y, z = arr[..., 0], arr[..., 1], arr[..., 2]\n\n    # Vector scaling\n    L = (116. * y) - 16.\n    a = 500.0 * (x - y)\n    b = 200.0 * (y - z)\n\n    return np.concatenate([x[..., np.newaxis] for x in [L, a, b]], axis=-1)\n\n\ndef lab2xyz(lab, illuminant=""D65"", observer=""2""):\n    """"""CIE-LAB to XYZcolor space conversion.\n\n    Parameters\n    ----------\n    lab : array_like\n        The image in lab format, in a 3-D array of shape ``(.., .., 3)``.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : ndarray\n        The image in XYZ format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `lab` is not a 3-D array of shape ``(.., .., 3)``.\n    ValueError\n        If either the illuminant or the observer angle are not supported or\n        unknown.\n    UserWarning\n        If any of the pixels are invalid (Z < 0).\n\n\n    Notes\n    -----\n    By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values x_ref\n    = 95.047, y_ref = 100., z_ref = 108.883. See function \'get_xyz_coords\' for\n    a list of supported illuminants.\n\n    References\n    ----------\n    .. [1] http://www.easyrgb.com/index.php?X=MATH&H=07#text7\n    .. [2] https://en.wikipedia.org/wiki/Lab_color_space\n\n    """"""\n\n    arr = _prepare_colorarray(lab).copy()\n\n    L, a, b = arr[..., 0], arr[..., 1], arr[..., 2]\n    y = (L + 16.) / 116.\n    x = (a / 500.) + y\n    z = y - (b / 200.)\n\n    out = np.stack([x, y, z], axis=-1)\n\n    mask = out > 0.2068966\n    out[mask] = np.power(out[mask], 3.)\n    out[~mask] = (out[~mask] - 16.0 / 116.) / 7.787\n\n    # rescale to the reference white (illuminant)\n    xyz_ref_white = get_xyz_coords(illuminant, observer)\n    out *= xyz_ref_white\n    return out\n\n\ndef rgb2lab(rgb, illuminant=""D65"", observer=""2""):\n    """"""RGB to lab color space conversion.\n\n    Parameters\n    ----------\n    rgb : array_like\n        The image in RGB format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : ndarray\n        The image in Lab format, in a 3- or 4-D array of shape\n        ``(.., ..,[ ..,] 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `rgb` is not a 3- or 4-D array of shape ``(.., ..,[ ..,] 3)``.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Standard_illuminant\n\n    Notes\n    -----\n    This function uses rgb2xyz and xyz2lab.\n    By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values\n    x_ref=95.047, y_ref=100., z_ref=108.883. See function `get_xyz_coords` for\n    a list of supported illuminants.\n    """"""\n    return xyz2lab(rgb2xyz(rgb), illuminant, observer)\n\n\ndef lab2rgb(lab, illuminant=""D65"", observer=""2""):\n    """"""Lab to RGB color space conversion.\n\n    Parameters\n    ----------\n    lab : array_like\n        The image in Lab format, in a 3-D array of shape ``(.., .., 3)``.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : ndarray\n        The image in RGB format, in a 3-D array of shape ``(.., .., 3)``.\n\n    Raises\n    ------\n    ValueError\n        If `lab` is not a 3-D array of shape ``(.., .., 3)``.\n\n    References\n    ----------\n    .. [1] https://en.wikipedia.org/wiki/Standard_illuminant\n\n    Notes\n    -----\n    This function uses lab2xyz and xyz2rgb.\n    By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values\n    x_ref=95.047, y_ref=100., z_ref=108.883. See function `get_xyz_coords` for\n    a list of supported illuminants.\n    """"""\n    return xyz2rgb(lab2xyz(lab, illuminant, observer))\n\n\ndef xyz2luv(xyz, illuminant=""D65"", observer=""2""):\n    """"""XYZ to CIE-Luv color space conversion.\n\n    Parameters\n    ----------\n    xyz : (M, N, [P,] 3) array_like\n        The 3 or 4 dimensional image in XYZ format. Final dimension denotes\n        channels.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : (M, N, [P,] 3) ndarray\n        The image in CIE-Luv format. Same dimensions as input.\n\n    Raises\n    ------\n    ValueError\n        If `xyz` is not a 3-D or 4-D array of shape ``(M, N, [P,] 3)``.\n    ValueError\n        If either the illuminant or the observer angle are not supported or\n        unknown.\n\n    Notes\n    -----\n    By default XYZ conversion weights use observer=2A. Reference whitepoint\n    for D65 Illuminant, with XYZ tristimulus values of ``(95.047, 100.,\n    108.883)``. See function \'get_xyz_coords\' for a list of supported\n    illuminants.\n\n    References\n    ----------\n    .. [1] http://www.easyrgb.com/index.php?X=MATH&H=16#text16\n    .. [2] https://en.wikipedia.org/wiki/CIELUV\n\n    Examples\n    --------\n    >>> from skimage import data\n    >>> from skimage.color import rgb2xyz, xyz2luv\n    >>> img = data.astronaut()\n    >>> img_xyz = rgb2xyz(img)\n    >>> img_luv = xyz2luv(img_xyz)\n    """"""\n    arr = _prepare_colorarray(xyz)\n\n    # extract channels\n    x, y, z = arr[..., 0], arr[..., 1], arr[..., 2]\n\n    eps = np.finfo(np.float).eps\n\n    # compute y_r and L\n    xyz_ref_white = np.array(get_xyz_coords(illuminant, observer))\n    L = y / xyz_ref_white[1]\n    mask = L > 0.008856\n    L[mask] = 116. * np.cbrt(L[mask]) - 16.\n    L[~mask] = 903.3 * L[~mask]\n\n    u0 = 4 * xyz_ref_white[0] / ([1, 15, 3] @ xyz_ref_white)\n    v0 = 9 * xyz_ref_white[1] / ([1, 15, 3] @ xyz_ref_white)\n\n    # u\' and v\' helper functions\n    def fu(X, Y, Z):\n        return (4. * X) / (X + 15. * Y + 3. * Z + eps)\n\n    def fv(X, Y, Z):\n        return (9. * Y) / (X + 15. * Y + 3. * Z + eps)\n\n    # compute u and v using helper functions\n    u = 13. * L * (fu(x, y, z) - u0)\n    v = 13. * L * (fv(x, y, z) - v0)\n\n    return np.concatenate([q[..., np.newaxis] for q in [L, u, v]], axis=-1)\n\n\ndef luv2xyz(luv, illuminant=""D65"", observer=""2""):\n    """"""CIE-Luv to XYZ color space conversion.\n\n    Parameters\n    ----------\n    luv : (M, N, [P,] 3) array_like\n        The 3 or 4 dimensional image in CIE-Luv format. Final dimension denotes\n        channels.\n    illuminant : {""A"", ""D50"", ""D55"", ""D65"", ""D75"", ""E""}, optional\n        The name of the illuminant (the function is NOT case sensitive).\n    observer : {""2"", ""10""}, optional\n        The aperture angle of the observer.\n\n    Returns\n    -------\n    out : (M, N, [P,] 3) ndarray\n        The image in XYZ format. Same dimensions as input.\n\n    Raises\n    ------\n    ValueError\n        If `luv` is not a 3-D or 4-D array of shape ``(M, N, [P,] 3)``.\n    ValueError\n        If either the illuminant or the observer angle are not supported or\n        unknown.\n\n    Notes\n    -----\n    XYZ conversion weights use observer=2A. Reference whitepoint for D65\n    Illuminant, with XYZ tristimulus values of ``(95.047, 100., 108.883)``. See\n    function \'get_xyz_coords\' for a list of supported illuminants.\n\n    References\n    ----------\n    .. [1] http://www.easyrgb.com/index.php?X=MATH&H=16#text16\n    .. [2] https://en.wikipedia.org/wiki/CIELUV\n\n    """"""\n\n    arr = _prepare_colorarray(luv).copy()\n\n    L, u, v = arr[..., 0], arr[..., 1], arr[..., 2]\n\n    eps = np.finfo(np.float).eps\n\n    # compute y\n    y = L.copy()\n    mask = y > 7.999625\n    y[mask] = np.power((y[mask] + 16.) / 116., 3.)\n    y[~mask] = y[~mask] / 903.3\n    xyz_ref_white = get_xyz_coords(illuminant, observer)\n    y *= xyz_ref_white[1]\n\n    # reference white x,z\n    uv_weights = np.array([1, 15, 3])\n    u0 = 4 * xyz_ref_white[0] / (uv_weights @ xyz_ref_white)\n    v0 = 9 * xyz_ref_white[1] / (uv_weights @ xyz_ref_white)\n\n    # compute intermediate values\n    a = u0 + u / (13. * L + eps)\n    b = v0 + v / (13. * L + eps)\n    c = 3 * y * (5 * b - 3)\n\n    # compute x and z\n    z = ((a - 4) * c - 15 * a * b * y) / (12 * b)\n    x = -(c / b + 3. * z)\n\n    return np.stack([x, y, z], axis=-1)\n\n\ndef rgb2luv(rgb):\n    """"""RGB to CIE-Luv color space conversion.\n\n    Parameters\n    ----------\n    rgb : (M, N, [P,] 3) array_like\n        The 3 or 4 dimensional image in RGB format. Final dimension denotes\n        channels.\n\n    Returns\n    -------\n    out : (M, N, [P,] 3) ndarray\n        The image in CIE Luv format. Same dimensions as input.\n\n    Raises\n    ------\n    ValueError\n        If `rgb` is not a 3-D or 4-D array of shape ``(M, N, [P,] 3)``.\n\n    Notes\n    -----\n    This function uses rgb2xyz and xyz2luv.\n\n    References\n    ----------\n    .. [1] http://www.easyrgb.com/index.php?X=MATH&H=16#text16\n    .. [2] http://www.easyrgb.com/index.php?X=MATH&H=02#text2\n    .. [3] https://en.wikipedia.org/wiki/CIELUV\n\n    """"""\n    return xyz2luv(rgb2xyz(rgb))\n\n\ndef luv2rgb(luv):\n    """"""Luv to RGB color space conversion.\n\n    Parameters\n    ----------\n    luv : (M, N, [P,] 3) array_like\n        The 3 or 4 dimensional image in CIE Luv format. Final dimension denotes\n        channels.\n\n    Returns\n    -------\n    out : (M, N, [P,] 3) ndarray\n        The image in RGB format. Same dimensions as input.\n\n    Raises\n    ------\n    ValueError\n        If `luv` is not a 3-D or 4-D array of shape ``(M, N, [P,] 3)``.\n\n    Notes\n    -----\n    This function uses luv2xyz and xyz2rgb.\n    """"""\n    return xyz2rgb(luv2xyz(luv))\n'"
napari/utils/colormaps/vendored/colors.py,122,"b'""""""\nA module for converting numbers or color arguments to *RGB* or *RGBA*\n\n*RGB* and *RGBA* are sequences of, respectively, 3 or 4 floats in the\nrange 0-1.\n\nThis module includes functions and classes for color specification\nconversions, and for mapping numbers to colors in a 1-D array of colors called\na colormap.\n\nMapping data onto colors using a colormap typically involves two steps:\na data array is first mapped onto the range 0-1 using a subclass of\n:class:`Normalize`, then this number is mapped to a color using\na subclass of :class:`Colormap`.  Two are provided here:\n:class:`LinearSegmentedColormap`, which uses piecewise-linear interpolation\nto define colormaps, and :class:`ListedColormap`, which makes a colormap\nfrom a list of colors.\n\n.. seealso::\n\n  :doc:`/tutorials/colors/colormap-manipulation` for examples of how to\n  make colormaps and\n\n  :doc:`/tutorials/colors/colormaps` for a list of built-in colormaps.\n\n  :doc:`/tutorials/colors/colormapnorms` for more details about data\n  normalization\n\n  More colormaps are available at palettable_\n\nThe module also provides functions for checking whether an object can be\ninterpreted as a color (:func:`is_color_like`), for converting such an object\nto an RGBA tuple (:func:`to_rgba`) or to an HTML-like hex string in the\n`#rrggbb` format (:func:`to_hex`), and a sequence of colors to an `(n, 4)`\nRGBA array (:func:`to_rgba_array`).  Caching is used for efficiency.\n\nMatplotlib recognizes the following formats to specify a color:\n\n* an RGB or RGBA tuple of float values in ``[0, 1]`` (e.g., ``(0.1, 0.2, 0.5)``\n  or  ``(0.1, 0.2, 0.5, 0.3)``);\n* a hex RGB or RGBA string (e.g., ``\'#0F0F0F\'`` or ``\'#0F0F0F0F\'``);\n* a string representation of a float value in ``[0, 1]`` inclusive for gray\n  level (e.g., ``\'0.5\'``);\n* one of ``{\'b\', \'g\', \'r\', \'c\', \'m\', \'y\', \'k\', \'w\'}``;\n* a X11/CSS4 color name;\n* a name from the `xkcd color survey <https://xkcd.com/color/rgb/>`__;\n  prefixed with ``\'xkcd:\'`` (e.g., ``\'xkcd:sky blue\'``);\n* one of ``{\'tab:blue\', \'tab:orange\', \'tab:green\',\n  \'tab:red\', \'tab:purple\', \'tab:brown\', \'tab:pink\',\n  \'tab:gray\', \'tab:olive\', \'tab:cyan\'}`` which are the Tableau Colors from the\n  \'T10\' categorical palette (which is the default color cycle);\n* a ""CN"" color spec, i.e. `\'C\'` followed by a number, which is an index into\n  the default property cycle (``matplotlib.rcParams[\'axes.prop_cycle\']``); the\n  indexing is intended to occur at rendering time, and defaults to black if the\n  cycle does not include color.\n\nAll string specifications of color, other than ""CN"", are case-insensitive.\n\n.. _palettable: https://jiffyclub.github.io/palettable/\n\n""""""\n\nfrom collections.abc import Sized\nimport itertools\nimport re\n\nimport numpy as np\nfrom ._color_data import (BASE_COLORS, TABLEAU_COLORS, CSS4_COLORS,\n                          XKCD_COLORS, NTH_COLORS)\n\n\nclass _ColorMapping(dict):\n    def __init__(self, mapping):\n        super().__init__(mapping)\n        self.cache = {}\n\n    def __setitem__(self, key, value):\n        super().__setitem__(key, value)\n        self.cache.clear()\n\n    def __delitem__(self, key):\n        super().__delitem__(key)\n        self.cache.clear()\n\n\n_colors_full_map = {}\n# Set by reverse priority order.\n_colors_full_map.update(XKCD_COLORS)\n_colors_full_map.update({k.replace(\'grey\', \'gray\'): v\n                         for k, v in XKCD_COLORS.items()\n                         if \'grey\' in k})\n_colors_full_map.update(CSS4_COLORS)\n_colors_full_map.update(TABLEAU_COLORS)\n_colors_full_map.update({k.replace(\'gray\', \'grey\'): v\n                         for k, v in TABLEAU_COLORS.items()\n                         if \'gray\' in k})\n_colors_full_map.update(BASE_COLORS)\n_colors_full_map.update(NTH_COLORS)\n_colors_full_map = _ColorMapping(_colors_full_map)\n\n\ndef get_named_colors_mapping():\n    """"""Return the global mapping of names to named colors.""""""\n    return _colors_full_map\n\n\ndef _sanitize_extrema(ex):\n    if ex is None:\n        return ex\n    try:\n        ret = ex.item()\n    except AttributeError:\n        ret = float(ex)\n    return ret\n\n\ndef is_color_like(c):\n    """"""Return whether *c* can be interpreted as an RGB(A) color.""""""\n    try:\n        to_rgba(c)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\ndef same_color(c1, c2):\n    """"""\n    Compare two colors to see if they are the same.\n\n    Parameters\n    ----------\n    c1, c2 : Matplotlib colors\n\n    Returns\n    -------\n    bool\n        ``True`` if *c1* and *c2* are the same color, otherwise ``False``.\n    """"""\n    return (to_rgba_array(c1) == to_rgba_array(c2)).all()\n\n\ndef to_rgba(c, alpha=None):\n    """"""\n    Convert *c* to an RGBA color.\n\n    Parameters\n    ----------\n    c : Matplotlib color\n\n    alpha : scalar, optional\n        If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n        ``""none""`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n\n    Returns\n    -------\n    tuple\n        Tuple of ``(r, g, b, a)`` scalars.\n    """"""\n    try:\n        rgba = _colors_full_map.cache[c, alpha]\n    except (KeyError, TypeError):  # Not in cache, or unhashable.\n        rgba = _to_rgba_no_colorcycle(c, alpha)\n        try:\n            _colors_full_map.cache[c, alpha] = rgba\n        except TypeError:\n            pass\n    return rgba\n\n\ndef _to_rgba_no_colorcycle(c, alpha=None):\n    """"""Convert *c* to an RGBA color, with no support for color-cycle syntax.\n\n    If *alpha* is not ``None``, it forces the alpha value, except if *c* is\n    ``""none""`` (case-insensitive), which always maps to ``(0, 0, 0, 0)``.\n    """"""\n    orig_c = c\n    if isinstance(c, str):\n        if c.lower() == ""none"":\n            return (0., 0., 0., 0.)\n        # Named color.\n        try:\n            # This may turn c into a non-string, so we check again below.\n            c = _colors_full_map[c.lower()]\n        except KeyError:\n            pass\n    if isinstance(c, str):\n        # hex color with no alpha.\n        match = re.match(r""\\A#[a-fA-F0-9]{6}\\Z"", c)\n        if match:\n            return (tuple(int(n, 16) / 255\n                          for n in [c[1:3], c[3:5], c[5:7]])\n                    + (alpha if alpha is not None else 1.,))\n        # hex color with alpha.\n        match = re.match(r""\\A#[a-fA-F0-9]{8}\\Z"", c)\n        if match:\n            color = [int(n, 16) / 255\n                     for n in [c[1:3], c[3:5], c[5:7], c[7:9]]]\n            if alpha is not None:\n                color[-1] = alpha\n            return tuple(color)\n        # string gray.\n        try:\n            return (float(c),) * 3 + (alpha if alpha is not None else 1.,)\n        except ValueError:\n            pass\n        raise ValueError(""Invalid RGBA argument: {!r}"".format(orig_c))\n    # tuple color.\n    c = np.array(c)\n    if not np.can_cast(c.dtype, float, ""same_kind"") or c.ndim != 1:\n        # Test the dtype explicitly as `map(float, ...)`, `np.array(...,\n        # float)` and `np.array(...).astype(float)` all convert ""0.5"" to 0.5.\n        # Test dimensionality to reject single floats.\n        raise ValueError(""Invalid RGBA argument: {!r}"".format(orig_c))\n    # Return a tuple to prevent the cached value from being modified.\n    c = tuple(c.astype(float))\n    if len(c) not in [3, 4]:\n        raise ValueError(""RGBA sequence should have length 3 or 4"")\n    if len(c) == 3 and alpha is None:\n        alpha = 1\n    if alpha is not None:\n        c = c[:3] + (alpha,)\n    if any(elem < 0 or elem > 1 for elem in c):\n        raise ValueError(""RGBA values should be within 0-1 range"")\n    return c\n\n\ndef to_rgba_array(c, alpha=None):\n    """"""Convert *c* to a (n, 4) array of RGBA colors.\n\n    If *alpha* is not ``None``, it forces the alpha value.  If *c* is\n    ``""none""`` (case-insensitive) or an empty list, an empty array is returned.\n    """"""\n    # Special-case inputs that are already arrays, for performance.  (If the\n    # array has the wrong kind or shape, raise the error during one-at-a-time\n    # conversion.)\n    if (isinstance(c, np.ndarray) and c.dtype.kind in ""if""\n            and c.ndim == 2 and c.shape[1] in [3, 4]):\n        if c.shape[1] == 3:\n            result = np.column_stack([c, np.zeros(len(c))])\n            result[:, -1] = alpha if alpha is not None else 1.\n        elif c.shape[1] == 4:\n            result = c.copy()\n            if alpha is not None:\n                result[:, -1] = alpha\n        if np.any((result < 0) | (result > 1)):\n            raise ValueError(""RGBA values should be within 0-1 range"")\n        return result\n    # Handle single values.\n    # Note that this occurs *after* handling inputs that are already arrays, as\n    # `to_rgba(c, alpha)` (below) is expensive for such inputs, due to the need\n    # to format the array in the ValueError message(!).\n    if isinstance(c, str) and c.lower() == ""none"":\n        return np.zeros((0, 4), float)\n    try:\n        return np.array([to_rgba(c, alpha)], float)\n    except (ValueError, TypeError):\n        pass\n    # Convert one at a time.\n    result = np.empty((len(c), 4), float)\n    for i, cc in enumerate(c):\n        result[i] = to_rgba(cc, alpha)\n    return result\n\n\ndef to_rgb(c):\n    """"""Convert *c* to an RGB color, silently dropping the alpha channel.""""""\n    return to_rgba(c)[:3]\n\n\ndef to_hex(c, keep_alpha=False):\n    """"""Convert *c* to a hex color.\n\n    Uses the ``#rrggbb`` format if *keep_alpha* is False (the default),\n    ``#rrggbbaa`` otherwise.\n    """"""\n    c = to_rgba(c)\n    if not keep_alpha:\n        c = c[:3]\n    return ""#"" + """".join(format(int(np.round(val * 255)), ""02x"")\n                         for val in c)\n\n\ndef makeMappingArray(N, data, gamma=1.0):\n    """"""Create an *N* -element 1-d lookup table\n\n    *data* represented by a list of x,y0,y1 mapping correspondences.\n    Each element in this list represents how a value between 0 and 1\n    (inclusive) represented by x is mapped to a corresponding value\n    between 0 and 1 (inclusive). The two values of y are to allow\n    for discontinuous mapping functions (say as might be found in a\n    sawtooth) where y0 represents the value of y for values of x\n    <= to that given, and y1 is the value to be used for x > than\n    that given). The list must start with x=0, end with x=1, and\n    all values of x must be in increasing order. Values between\n    the given mapping points are determined by simple linear interpolation.\n\n    Alternatively, data can be a function mapping values between 0 - 1\n    to 0 - 1.\n\n    The function returns an array ""result"" where ``result[x*(N-1)]``\n    gives the closest value for values of x between 0 and 1.\n    """"""\n\n    if callable(data):\n        xind = np.linspace(0, 1, N) ** gamma\n        lut = np.clip(np.array(data(xind), dtype=float), 0, 1)\n        return lut\n\n    try:\n        adata = np.array(data)\n    except Exception:\n        raise TypeError(""data must be convertible to an array"")\n    shape = adata.shape\n    if len(shape) != 2 or shape[1] != 3:\n        raise ValueError(""data must be nx3 format"")\n\n    x = adata[:, 0]\n    y0 = adata[:, 1]\n    y1 = adata[:, 2]\n\n    if x[0] != 0. or x[-1] != 1.0:\n        raise ValueError(\n            ""data mapping points must start with x=0 and end with x=1"")\n    if (np.diff(x) < 0).any():\n        raise ValueError(""data mapping points must have x in increasing order"")\n    # begin generation of lookup table\n    x = x * (N - 1)\n    xind = (N - 1) * np.linspace(0, 1, N) ** gamma\n    ind = np.searchsorted(x, xind)[1:-1]\n\n    distance = (xind[1:-1] - x[ind - 1]) / (x[ind] - x[ind - 1])\n    lut = np.concatenate([\n        [y1[0]],\n        distance * (y0[ind] - y1[ind - 1]) + y1[ind - 1],\n        [y0[-1]],\n    ])\n    # ensure that the lut is confined to values between 0 and 1 by clipping it\n    return np.clip(lut, 0.0, 1.0)\n\n\nclass Colormap(object):\n    """"""\n    Baseclass for all scalar to RGBA mappings.\n\n    Typically Colormap instances are used to convert data values (floats) from\n    the interval ``[0, 1]`` to the RGBA color that the respective Colormap\n    represents. For scaling of data into the ``[0, 1]`` interval see\n    :class:`matplotlib.colors.Normalize`. It is worth noting that\n    :class:`matplotlib.cm.ScalarMappable` subclasses make heavy use of this\n    ``data->normalize->map-to-color`` processing chain.\n\n    """"""\n    def __init__(self, name, N=256):\n        """"""\n        Parameters\n        ----------\n        name : str\n            The name of the colormap.\n        N : int\n            The number of rgb quantization levels.\n\n        """"""\n        self.name = name\n        self.N = int(N)  # ensure that N is always int\n        self._rgba_bad = (0.0, 0.0, 0.0, 0.0)  # If bad, don\'t paint anything.\n        self._rgba_under = None\n        self._rgba_over = None\n        self._i_under = self.N\n        self._i_over = self.N + 1\n        self._i_bad = self.N + 2\n        self._isinit = False\n\n        #: When this colormap exists on a scalar mappable and colorbar_extend\n        #: is not False, colorbar creation will pick up ``colorbar_extend`` as\n        #: the default value for the ``extend`` keyword in the\n        #: :class:`matplotlib.colorbar.Colorbar` constructor.\n        self.colorbar_extend = False\n\n    def __call__(self, X, alpha=None, bytes=False):\n        """"""\n        Parameters\n        ----------\n        X : scalar, ndarray\n            The data value(s) to convert to RGBA.\n            For floats, X should be in the interval ``[0.0, 1.0]`` to\n            return the RGBA values ``X*100`` percent along the Colormap line.\n            For integers, X should be in the interval ``[0, Colormap.N)`` to\n            return RGBA values *indexed* from the Colormap with index ``X``.\n        alpha : float, None\n            Alpha must be a scalar between 0 and 1, or None.\n        bytes : bool\n            If False (default), the returned RGBA values will be floats in the\n            interval ``[0, 1]`` otherwise they will be uint8s in the interval\n            ``[0, 255]``.\n\n        Returns\n        -------\n        Tuple of RGBA values if X is scalar, otherwise an array of\n        RGBA values with a shape of ``X.shape + (4, )``.\n\n        """"""\n        # See class docstring for arg/kwarg documentation.\n        if not self._isinit:\n            self._init()\n        mask_bad = None\n        if not np.iterable(X):\n            vtype = \'scalar\'\n            xa = np.array([X])\n        else:\n            vtype = \'array\'\n            xma = np.ma.array(X, copy=True)  # Copy here to avoid side effects.\n            mask_bad = xma.mask              # Mask will be used below.\n            xa = xma.filled()                # Fill to avoid infs, etc.\n            del xma\n\n        # Calculations with native byteorder are faster, and avoid a\n        # bug that otherwise can occur with putmask when the last\n        # argument is a numpy scalar.\n        if not xa.dtype.isnative:\n            xa = xa.byteswap().newbyteorder()\n\n        if xa.dtype.kind == ""f"":\n            xa *= self.N\n            # Negative values are out of range, but astype(int) would truncate\n            # them towards zero.\n            xa[xa < 0] = -1\n            # xa == 1 (== N after multiplication) is not out of range.\n            xa[xa == self.N] = self.N - 1\n            # Avoid converting large positive values to negative integers.\n            np.clip(xa, -1, self.N, out=xa)\n            xa = xa.astype(int)\n        # Set the over-range indices before the under-range;\n        # otherwise the under-range values get converted to over-range.\n        xa[xa > self.N - 1] = self._i_over\n        xa[xa < 0] = self._i_under\n        if mask_bad is not None:\n            if mask_bad.shape == xa.shape:\n                np.copyto(xa, self._i_bad, where=mask_bad)\n            elif mask_bad:\n                xa.fill(self._i_bad)\n        if bytes:\n            lut = (self._lut * 255).astype(np.uint8)\n        else:\n            lut = self._lut.copy()  # Don\'t let alpha modify original _lut.\n\n        if alpha is not None:\n            alpha = np.clip(alpha, 0, 1)\n            if bytes:\n                alpha = int(alpha * 255)\n            if (lut[-1] == 0).all():\n                lut[:-1, -1] = alpha\n                # All zeros is taken as a flag for the default bad\n                # color, which is no color--fully transparent.  We\n                # don\'t want to override this.\n            else:\n                lut[:, -1] = alpha\n                # If the bad value is set to have a color, then we\n                # override its alpha just as for any other value.\n\n        rgba = lut.take(xa, axis=0, mode=\'clip\')\n        if vtype == \'scalar\':\n            rgba = tuple(rgba[0, :])\n        return rgba\n\n    def __copy__(self):\n        """"""Create new object with the same class, update attributes\n        """"""\n        cls = self.__class__\n        cmapobject = cls.__new__(cls)\n        cmapobject.__dict__.update(self.__dict__)\n        if self._isinit:\n            cmapobject._lut = np.copy(self._lut)\n        return cmapobject\n\n    def set_bad(self, color=\'k\', alpha=None):\n        """"""Set color to be used for masked values.\n        """"""\n        self._rgba_bad = to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_under(self, color=\'k\', alpha=None):\n        """"""Set color to be used for low out-of-range values.\n           Requires norm.clip = False\n        """"""\n        self._rgba_under = to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def set_over(self, color=\'k\', alpha=None):\n        """"""Set color to be used for high out-of-range values.\n           Requires norm.clip = False\n        """"""\n        self._rgba_over = to_rgba(color, alpha)\n        if self._isinit:\n            self._set_extremes()\n\n    def _set_extremes(self):\n        if self._rgba_under:\n            self._lut[self._i_under] = self._rgba_under\n        else:\n            self._lut[self._i_under] = self._lut[0]\n        if self._rgba_over:\n            self._lut[self._i_over] = self._rgba_over\n        else:\n            self._lut[self._i_over] = self._lut[self.N - 1]\n        self._lut[self._i_bad] = self._rgba_bad\n\n    def _init(self):\n        """"""Generate the lookup table, self._lut""""""\n        raise NotImplementedError(""Abstract class only"")\n\n    def is_gray(self):\n        if not self._isinit:\n            self._init()\n        return (np.all(self._lut[:, 0] == self._lut[:, 1]) and\n                np.all(self._lut[:, 0] == self._lut[:, 2]))\n\n    def _resample(self, lutsize):\n        """"""\n        Return a new color map with *lutsize* entries.\n        """"""\n        raise NotImplementedError()\n\n    def reversed(self, name=None):\n        """"""\n        Make a reversed instance of the Colormap.\n\n        .. note :: Function not implemented for base class.\n\n        Parameters\n        ----------\n        name : str, optional\n            The name for the reversed colormap. If it\'s None the\n            name will be the name of the parent colormap + ""_r"".\n\n        Notes\n        -----\n        See :meth:`LinearSegmentedColormap.reversed` and\n        :meth:`ListedColormap.reversed`\n        """"""\n        raise NotImplementedError()\n\n\nclass LinearSegmentedColormap(Colormap):\n    """"""Colormap objects based on lookup tables using linear segments.\n\n    The lookup table is generated using linear interpolation for each\n    primary color, with the 0-1 domain divided into any number of\n    segments.\n    """"""\n    def __init__(self, name, segmentdata, N=256, gamma=1.0):\n        """"""Create color map from linear mapping segments\n\n        segmentdata argument is a dictionary with a red, green and blue\n        entries. Each entry should be a list of *x*, *y0*, *y1* tuples,\n        forming rows in a table. Entries for alpha are optional.\n\n        Example: suppose you want red to increase from 0 to 1 over\n        the bottom half, green to do the same over the middle half,\n        and blue over the top half.  Then you would use::\n\n            cdict = {\'red\':   [(0.0,  0.0, 0.0),\n                               (0.5,  1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     \'green\': [(0.0,  0.0, 0.0),\n                               (0.25, 0.0, 0.0),\n                               (0.75, 1.0, 1.0),\n                               (1.0,  1.0, 1.0)],\n\n                     \'blue\':  [(0.0,  0.0, 0.0),\n                               (0.5,  0.0, 0.0),\n                               (1.0,  1.0, 1.0)]}\n\n        Each row in the table for a given color is a sequence of\n        *x*, *y0*, *y1* tuples.  In each sequence, *x* must increase\n        monotonically from 0 to 1.  For any input value *z* falling\n        between *x[i]* and *x[i+1]*, the output value of a given color\n        will be linearly interpolated between *y1[i]* and *y0[i+1]*::\n\n            row i:   x  y0  y1\n                           /\n                          /\n            row i+1: x  y0  y1\n\n        Hence y0 in the first row and y1 in the last row are never used.\n\n\n        .. seealso::\n\n               :meth:`LinearSegmentedColormap.from_list`\n               Static method; factory function for generating a\n               smoothly-varying LinearSegmentedColormap.\n\n               :func:`makeMappingArray`\n               For information about making a mapping array.\n        """"""\n        # True only if all colors in map are identical; needed for contouring.\n        self.monochrome = False\n        Colormap.__init__(self, name, N)\n        self._segmentdata = segmentdata\n        self._gamma = gamma\n\n    def _init(self):\n        self._lut = np.ones((self.N + 3, 4), float)\n        self._lut[:-3, 0] = makeMappingArray(\n            self.N, self._segmentdata[\'red\'], self._gamma)\n        self._lut[:-3, 1] = makeMappingArray(\n            self.N, self._segmentdata[\'green\'], self._gamma)\n        self._lut[:-3, 2] = makeMappingArray(\n            self.N, self._segmentdata[\'blue\'], self._gamma)\n        if \'alpha\' in self._segmentdata:\n            self._lut[:-3, 3] = makeMappingArray(\n                self.N, self._segmentdata[\'alpha\'], 1)\n        self._isinit = True\n        self._set_extremes()\n\n    def set_gamma(self, gamma):\n        """"""\n        Set a new gamma value and regenerate color map.\n        """"""\n        self._gamma = gamma\n        self._init()\n\n    @staticmethod\n    def from_list(name, colors, N=256, gamma=1.0):\n        """"""\n        Make a linear segmented colormap with *name* from a sequence\n        of *colors* which evenly transitions from colors[0] at val=0\n        to colors[-1] at val=1.  *N* is the number of rgb quantization\n        levels.\n        Alternatively, a list of (value, color) tuples can be given\n        to divide the range unevenly.\n        """"""\n\n        if not np.iterable(colors):\n            raise ValueError(\'colors must be iterable\')\n\n        if (isinstance(colors[0], Sized) and len(colors[0]) == 2\n                and not isinstance(colors[0], str)):\n            # List of value, color pairs\n            vals, colors = zip(*colors)\n        else:\n            vals = np.linspace(0, 1, len(colors))\n\n        cdict = dict(red=[], green=[], blue=[], alpha=[])\n        for val, color in zip(vals, colors):\n            r, g, b, a = to_rgba(color)\n            cdict[\'red\'].append((val, r, r))\n            cdict[\'green\'].append((val, g, g))\n            cdict[\'blue\'].append((val, b, b))\n            cdict[\'alpha\'].append((val, a, a))\n\n        return LinearSegmentedColormap(name, cdict, N, gamma)\n\n    def _resample(self, lutsize):\n        """"""\n        Return a new color map with *lutsize* entries.\n        """"""\n        return LinearSegmentedColormap(self.name, self._segmentdata, lutsize)\n\n    def reversed(self, name=None):\n        """"""\n        Make a reversed instance of the Colormap.\n\n        Parameters\n        ----------\n        name : str, optional\n            The name for the reversed colormap. If it\'s None the\n            name will be the name of the parent colormap + ""_r"".\n\n        Returns\n        -------\n        LinearSegmentedColormap\n            The reversed colormap.\n        """"""\n        if name is None:\n            name = self.name + ""_r""\n\n        # Function factory needed to deal with \'late binding\' issue.\n        def factory(dat):\n            def func_r(x):\n                return dat(1.0 - x)\n            return func_r\n\n        data_r = {key: (factory(data) if callable(data) else\n                        [(1.0 - x, y1, y0) for x, y0, y1 in reversed(data)])\n                  for key, data in self._segmentdata.items()}\n\n        return LinearSegmentedColormap(name, data_r, self.N, self._gamma)\n\n\nclass ListedColormap(Colormap):\n    """"""Colormap object generated from a list of colors.\n\n    This may be most useful when indexing directly into a colormap,\n    but it can also be used to generate special colormaps for ordinary\n    mapping.\n    """"""\n    def __init__(self, colors, name=\'from_list\', N=None):\n        """"""\n        Make a colormap from a list of colors.\n\n        *colors*\n            a list of matplotlib color specifications,\n            or an equivalent Nx3 or Nx4 floating point array\n            (*N* rgb or rgba values)\n        *name*\n            a string to identify the colormap\n        *N*\n            the number of entries in the map.  The default is *None*,\n            in which case there is one colormap entry for each\n            element in the list of colors.  If::\n\n                N < len(colors)\n\n            the list will be truncated at *N*.  If::\n\n                N > len(colors)\n\n            the list will be extended by repetition.\n        """"""\n        self.monochrome = False  # True only if all colors in map are\n                                 # identical; needed for contouring.\n        if N is None:\n            self.colors = colors\n            N = len(colors)\n        else:\n            if isinstance(colors, str):\n                self.colors = [colors] * N\n                self.monochrome = True\n            elif np.iterable(colors):\n                if len(colors) == 1:\n                    self.monochrome = True\n                self.colors = list(\n                    itertools.islice(itertools.cycle(colors), N))\n            else:\n                try:\n                    gray = float(colors)\n                except TypeError:\n                    pass\n                else:\n                    self.colors = [gray] * N\n                self.monochrome = True\n        Colormap.__init__(self, name, N)\n\n    def _init(self):\n        self._lut = np.zeros((self.N + 3, 4), float)\n        self._lut[:-3] = to_rgba_array(self.colors)\n        self._isinit = True\n        self._set_extremes()\n\n    def _resample(self, lutsize):\n        """"""\n        Return a new color map with *lutsize* entries.\n        """"""\n        colors = self(np.linspace(0, 1, lutsize))\n        return ListedColormap(colors, name=self.name)\n\n    def reversed(self, name=None):\n        """"""\n        Make a reversed instance of the Colormap.\n\n        Parameters\n        ----------\n        name : str, optional\n            The name for the reversed colormap. If it\'s None the\n            name will be the name of the parent colormap + ""_r"".\n\n        Returns\n        -------\n        ListedColormap\n            A reversed instance of the colormap.\n        """"""\n        if name is None:\n            name = self.name + ""_r""\n\n        colors_r = list(reversed(self.colors))\n        return ListedColormap(colors_r, name=name, N=self.N)\n\n\nclass Normalize(object):\n    """"""\n    A class which, when called, can normalize data into\n    the ``[0.0, 1.0]`` interval.\n\n    """"""\n    def __init__(self, vmin=None, vmax=None, clip=False):\n        """"""\n        If *vmin* or *vmax* is not given, they are initialized from the\n        minimum and maximum value respectively of the first input\n        processed.  That is, *__call__(A)* calls *autoscale_None(A)*.\n        If *clip* is *True* and the given value falls outside the range,\n        the returned value will be 0 or 1, whichever is closer.\n        Returns 0 if::\n\n            vmin==vmax\n\n        Works with scalars or arrays, including masked arrays.  If\n        *clip* is *True*, masked values are set to 1; otherwise they\n        remain masked.  Clipping silently defeats the purpose of setting\n        the over, under, and masked colors in the colormap, so it is\n        likely to lead to surprises; therefore the default is\n        *clip* = *False*.\n        """"""\n        self.vmin = _sanitize_extrema(vmin)\n        self.vmax = _sanitize_extrema(vmax)\n        self.clip = clip\n\n    @staticmethod\n    def process_value(value):\n        """"""\n        Homogenize the input *value* for easy and efficient normalization.\n\n        *value* can be a scalar or sequence.\n\n        Returns *result*, *is_scalar*, where *result* is a\n        masked array matching *value*.  Float dtypes are preserved;\n        integer types with two bytes or smaller are converted to\n        np.float32, and larger types are converted to np.float64.\n        Preserving float32 when possible, and using in-place operations,\n        can greatly improve speed for large arrays.\n\n        Experimental; we may want to add an option to force the\n        use of float32.\n        """"""\n        is_scalar = not np.iterable(value)\n        if is_scalar:\n            value = [value]\n        dtype = np.min_scalar_type(value)\n        if np.issubdtype(dtype, np.integer) or dtype.type is np.bool_:\n            # bool_/int8/int16 -> float32; int32/int64 -> float64\n            dtype = np.promote_types(dtype, np.float32)\n        # ensure data passed in as an ndarray subclass are interpreted as\n        # an ndarray. See issue #6622.\n        mask = np.ma.getmask(value)\n        data = np.asarray(np.ma.getdata(value))\n        result = np.ma.array(data, mask=mask, dtype=dtype, copy=True)\n        return result, is_scalar\n\n    def __call__(self, value, clip=None):\n        """"""\n        Normalize *value* data in the ``[vmin, vmax]`` interval into\n        the ``[0.0, 1.0]`` interval and return it.  *clip* defaults\n        to *self.clip* (which defaults to *False*).  If not already\n        initialized, *vmin* and *vmax* are initialized using\n        *autoscale_None(value)*.\n        """"""\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        # Convert at least to float, without losing precision.\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n        if vmin == vmax:\n            result.fill(0)   # Or should it be all masked?  Or 0.5?\n        elif vmin > vmax:\n            raise ValueError(""minvalue must be less than or equal to maxvalue"")\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # ma division is very slow; we can take a shortcut\n            resdat = result.data\n            resdat -= vmin\n            resdat /= (vmax - vmin)\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(""Not invertible until scaled"")\n        (vmin,), _ = self.process_value(self.vmin)\n        (vmax,), _ = self.process_value(self.vmax)\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin + val * (vmax - vmin)\n        else:\n            return vmin + value * (vmax - vmin)\n\n    def autoscale(self, A):\n        """"""Set *vmin*, *vmax* to min, max of *A*.""""""\n        A = np.asanyarray(A)\n        self.vmin = A.min()\n        self.vmax = A.max()\n\n    def autoscale_None(self, A):\n        """"""Autoscale only None-valued vmin or vmax.""""""\n        A = np.asanyarray(A)\n        if self.vmin is None and A.size:\n            self.vmin = A.min()\n        if self.vmax is None and A.size:\n            self.vmax = A.max()\n\n    def scaled(self):\n        """"""Return whether vmin and vmax are set.""""""\n        return self.vmin is not None and self.vmax is not None\n\n\nclass LogNorm(Normalize):\n    """"""Normalize a given value to the 0-1 range on a log scale.""""""\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        result = np.ma.masked_less_equal(result, 0, copy=False)\n\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(""minvalue must be less than or equal to maxvalue"")\n        elif vmin <= 0:\n            raise ValueError(""values must all be positive"")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = result.data\n            mask = result.mask\n            if mask is np.ma.nomask:\n                mask = (resdat <= 0)\n            else:\n                mask |= resdat <= 0\n            np.copyto(resdat, 1, where=mask)\n            np.log(resdat, resdat)\n            resdat -= np.log(vmin)\n            resdat /= (np.log(vmax) - np.log(vmin))\n            result = np.ma.array(resdat, mask=mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(""Not invertible until scaled"")\n        vmin, vmax = self.vmin, self.vmax\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return vmin * np.ma.power((vmax / vmin), val)\n        else:\n            return vmin * pow((vmax / vmin), value)\n\n    def autoscale(self, A):\n        # docstring inherited.\n        super().autoscale(np.ma.masked_less_equal(A, 0, copy=False))\n\n    def autoscale_None(self, A):\n        # docstring inherited.\n        super().autoscale_None(np.ma.masked_less_equal(A, 0, copy=False))\n\n\nclass SymLogNorm(Normalize):\n    """"""\n    The symmetrical logarithmic scale is logarithmic in both the\n    positive and negative directions from the origin.\n\n    Since the values close to zero tend toward infinity, there is a\n    need to have a range around zero that is linear.  The parameter\n    *linthresh* allows the user to specify the size of this range\n    (-*linthresh*, *linthresh*).\n    """"""\n    def __init__(self,  linthresh, linscale=1.0,\n                 vmin=None, vmax=None, clip=False):\n        """"""\n        *linthresh*:\n        The range within which the plot is linear (to\n        avoid having the plot go to infinity around zero).\n\n        *linscale*:\n        This allows the linear range (-*linthresh* to *linthresh*)\n        to be stretched relative to the logarithmic range.  Its\n        value is the number of decades to use for each half of the\n        linear range.  For example, when *linscale* == 1.0 (the\n        default), the space used for the positive and negative\n        halves of the linear range will be equal to one decade in\n        the logarithmic range. Defaults to 1.\n        """"""\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.linthresh = float(linthresh)\n        self._linscale_adj = (linscale / (1.0 - np.e ** -1))\n        if vmin is not None and vmax is not None:\n            self._transform_vmin_vmax()\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n        self.autoscale_None(result)\n        vmin, vmax = self.vmin, self.vmax\n\n        if vmin > vmax:\n            raise ValueError(""minvalue must be less than or equal to maxvalue"")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            # in-place equivalent of above can be much faster\n            resdat = self._transform(result.data)\n            resdat -= self._lower\n            resdat /= (self._upper - self._lower)\n\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def _transform(self, a):\n        """"""Inplace transformation.""""""\n        with np.errstate(invalid=""ignore""):\n            masked = np.abs(a) > self.linthresh\n        sign = np.sign(a[masked])\n        log = (self._linscale_adj + np.log(np.abs(a[masked]) / self.linthresh))\n        log *= sign * self.linthresh\n        a[masked] = log\n        a[~masked] *= self._linscale_adj\n        return a\n\n    def _inv_transform(self, a):\n        """"""Inverse inplace Transformation.""""""\n        masked = np.abs(a) > (self.linthresh * self._linscale_adj)\n        sign = np.sign(a[masked])\n        exp = np.exp(sign * a[masked] / self.linthresh - self._linscale_adj)\n        exp *= sign * self.linthresh\n        a[masked] = exp\n        a[~masked] /= self._linscale_adj\n        return a\n\n    def _transform_vmin_vmax(self):\n        """"""Calculates vmin and vmax in the transformed system.""""""\n        vmin, vmax = self.vmin, self.vmax\n        arr = np.array([vmax, vmin]).astype(float)\n        self._upper, self._lower = self._transform(arr)\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(""Not invertible until scaled"")\n        val = np.ma.asarray(value)\n        val = val * (self._upper - self._lower) + self._lower\n        return self._inv_transform(val)\n\n    def autoscale(self, A):\n        # docstring inherited.\n        super().autoscale(A)\n        self._transform_vmin_vmax()\n\n    def autoscale_None(self, A):\n        # docstring inherited.\n        super().autoscale_None(A)\n        self._transform_vmin_vmax()\n\n\nclass PowerNorm(Normalize):\n    """"""\n    Linearly map a given value to the 0-1 range and then apply\n    a power-law normalization over that range.\n    """"""\n    def __init__(self, gamma, vmin=None, vmax=None, clip=False):\n        Normalize.__init__(self, vmin, vmax, clip)\n        self.gamma = gamma\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        result, is_scalar = self.process_value(value)\n\n        self.autoscale_None(result)\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n        if vmin > vmax:\n            raise ValueError(""minvalue must be less than or equal to maxvalue"")\n        elif vmin == vmax:\n            result.fill(0)\n        else:\n            if clip:\n                mask = np.ma.getmask(result)\n                result = np.ma.array(np.clip(result.filled(vmax), vmin, vmax),\n                                     mask=mask)\n            resdat = result.data\n            resdat -= vmin\n            resdat[resdat < 0] = 0\n            np.power(resdat, gamma, resdat)\n            resdat /= (vmax - vmin) ** gamma\n\n            result = np.ma.array(resdat, mask=result.mask, copy=False)\n        if is_scalar:\n            result = result[0]\n        return result\n\n    def inverse(self, value):\n        if not self.scaled():\n            raise ValueError(""Not invertible until scaled"")\n        gamma = self.gamma\n        vmin, vmax = self.vmin, self.vmax\n\n        if np.iterable(value):\n            val = np.ma.asarray(value)\n            return np.ma.power(val, 1. / gamma) * (vmax - vmin) + vmin\n        else:\n            return pow(value, 1. / gamma) * (vmax - vmin) + vmin\n\n\nclass BoundaryNorm(Normalize):\n    """"""\n    Generate a colormap index based on discrete intervals.\n\n    Unlike `Normalize` or `LogNorm`, `BoundaryNorm` maps values to integers\n    instead of to the interval 0-1.\n\n    Mapping to the 0-1 interval could have been done via piece-wise linear\n    interpolation, but using integers seems simpler, and reduces the number of\n    conversions back and forth between integer and floating point.\n    """"""\n    def __init__(self, boundaries, ncolors, clip=False):\n        """"""\n        Parameters\n        ----------\n        boundaries : array-like\n            Monotonically increasing sequence of boundaries\n        ncolors : int\n            Number of colors in the colormap to be used\n        clip : bool, optional\n            If clip is ``True``, out of range values are mapped to 0 if they\n            are below ``boundaries[0]`` or mapped to ncolors - 1 if they are\n            above ``boundaries[-1]``.\n\n            If clip is ``False``, out of range values are mapped to -1 if\n            they are below ``boundaries[0]`` or mapped to ncolors if they are\n            above ``boundaries[-1]``. These are then converted to valid indices\n            by :meth:`Colormap.__call__`.\n\n        Notes\n        -----\n        *boundaries* defines the edges of bins, and data falling within a bin\n        is mapped to the color with the same index.\n\n        If the number of bins doesn\'t equal *ncolors*, the color is chosen\n        by linear interpolation of the bin number onto color numbers.\n        """"""\n        self.clip = clip\n        self.vmin = boundaries[0]\n        self.vmax = boundaries[-1]\n        self.boundaries = np.asarray(boundaries)\n        self.N = len(self.boundaries)\n        self.Ncmap = ncolors\n        if self.N - 1 == self.Ncmap:\n            self._interp = False\n        else:\n            self._interp = True\n\n    def __call__(self, value, clip=None):\n        if clip is None:\n            clip = self.clip\n\n        xx, is_scalar = self.process_value(value)\n        mask = np.ma.getmaskarray(xx)\n        xx = np.atleast_1d(xx.filled(self.vmax + 1))\n        if clip:\n            np.clip(xx, self.vmin, self.vmax, out=xx)\n            max_col = self.Ncmap - 1\n        else:\n            max_col = self.Ncmap\n        iret = np.zeros(xx.shape, dtype=np.int16)\n        for i, b in enumerate(self.boundaries):\n            iret[xx >= b] = i\n        if self._interp:\n            scalefac = (self.Ncmap - 1) / (self.N - 2)\n            iret = (iret * scalefac).astype(np.int16)\n        iret[xx < self.vmin] = -1\n        iret[xx >= self.vmax] = max_col\n        ret = np.ma.array(iret, mask=mask)\n        if is_scalar:\n            ret = int(ret[0])  # assume python scalar\n        return ret\n\n    def inverse(self, value):\n        """"""\n        Raises\n        ------\n        ValueError\n            BoundaryNorm is not invertible, so calling this method will always\n            raise an error\n        """"""\n        return ValueError(""BoundaryNorm is not invertible"")\n\n\nclass NoNorm(Normalize):\n    """"""\n    Dummy replacement for `Normalize`, for the case where we want to use\n    indices directly in a `~matplotlib.cm.ScalarMappable`.\n    """"""\n    def __call__(self, value, clip=None):\n        return value\n\n    def inverse(self, value):\n        return value\n\n\ndef rgb_to_hsv(arr):\n    """"""\n    Convert float rgb values (in the range [0, 1]), in a numpy array to hsv\n    values.\n\n    Parameters\n    ----------\n    arr : (..., 3) array-like\n       All values must be in the range [0, 1]\n\n    Returns\n    -------\n    hsv : (..., 3) ndarray\n       Colors converted to hsv values in range [0, 1]\n    """"""\n    arr = np.asarray(arr)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if arr.shape[-1] != 3:\n        raise ValueError(""Last dimension of input array must be 3; ""\n                         ""shape {} was found."".format(arr.shape))\n\n    in_shape = arr.shape\n    arr = np.array(\n        arr, copy=False,\n        dtype=np.promote_types(arr.dtype, np.float32),  # Don\'t work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n    out = np.zeros_like(arr)\n    arr_max = arr.max(-1)\n    ipos = arr_max > 0\n    delta = arr.ptp(-1)\n    s = np.zeros_like(delta)\n    s[ipos] = delta[ipos] / arr_max[ipos]\n    ipos = delta > 0\n    # red is max\n    idx = (arr[..., 0] == arr_max) & ipos\n    out[idx, 0] = (arr[idx, 1] - arr[idx, 2]) / delta[idx]\n    # green is max\n    idx = (arr[..., 1] == arr_max) & ipos\n    out[idx, 0] = 2. + (arr[idx, 2] - arr[idx, 0]) / delta[idx]\n    # blue is max\n    idx = (arr[..., 2] == arr_max) & ipos\n    out[idx, 0] = 4. + (arr[idx, 0] - arr[idx, 1]) / delta[idx]\n\n    out[..., 0] = (out[..., 0] / 6.0) % 1.0\n    out[..., 1] = s\n    out[..., 2] = arr_max\n\n    return out.reshape(in_shape)\n\n\ndef hsv_to_rgb(hsv):\n    """"""\n    Convert hsv values to rgb.\n\n    Parameters\n    ----------\n    hsv : (..., 3) array-like\n       All values assumed to be in range [0, 1]\n\n    Returns\n    -------\n    rgb : (..., 3) ndarray\n       Colors converted to RGB values in range [0, 1]\n    """"""\n    hsv = np.asarray(hsv)\n\n    # check length of the last dimension, should be _some_ sort of rgb\n    if hsv.shape[-1] != 3:\n        raise ValueError(""Last dimension of input array must be 3; ""\n                         ""shape {shp} was found."".format(shp=hsv.shape))\n\n    in_shape = hsv.shape\n    hsv = np.array(\n        hsv, copy=False,\n        dtype=np.promote_types(hsv.dtype, np.float32),  # Don\'t work on ints.\n        ndmin=2,  # In case input was 1D.\n    )\n\n    h = hsv[..., 0]\n    s = hsv[..., 1]\n    v = hsv[..., 2]\n\n    r = np.empty_like(h)\n    g = np.empty_like(h)\n    b = np.empty_like(h)\n\n    i = (h * 6.0).astype(int)\n    f = (h * 6.0) - i\n    p = v * (1.0 - s)\n    q = v * (1.0 - s * f)\n    t = v * (1.0 - s * (1.0 - f))\n\n    idx = i % 6 == 0\n    r[idx] = v[idx]\n    g[idx] = t[idx]\n    b[idx] = p[idx]\n\n    idx = i == 1\n    r[idx] = q[idx]\n    g[idx] = v[idx]\n    b[idx] = p[idx]\n\n    idx = i == 2\n    r[idx] = p[idx]\n    g[idx] = v[idx]\n    b[idx] = t[idx]\n\n    idx = i == 3\n    r[idx] = p[idx]\n    g[idx] = q[idx]\n    b[idx] = v[idx]\n\n    idx = i == 4\n    r[idx] = t[idx]\n    g[idx] = p[idx]\n    b[idx] = v[idx]\n\n    idx = i == 5\n    r[idx] = v[idx]\n    g[idx] = p[idx]\n    b[idx] = q[idx]\n\n    idx = s == 0\n    r[idx] = v[idx]\n    g[idx] = v[idx]\n    b[idx] = v[idx]\n\n    rgb = np.stack([r, g, b], axis=-1)\n\n    return rgb.reshape(in_shape)\n\n\ndef _vector_magnitude(arr):\n    # things that don\'t work here:\n    #  * np.linalg.norm\n    #    - doesn\'t broadcast in numpy 1.7\n    #    - drops the mask from ma.array\n    #  * using keepdims - broken on ma.array until 1.11.2\n    #  * using sum - discards mask on ma.array unless entire vector is masked\n\n    sum_sq = 0\n    for i in range(arr.shape[-1]):\n        sum_sq += np.square(arr[..., i, np.newaxis])\n    return np.sqrt(sum_sq)\n\n\nclass LightSource(object):\n    """"""\n    Create a light source coming from the specified azimuth and elevation.\n    Angles are in degrees, with the azimuth measured\n    clockwise from north and elevation up from the zero plane of the surface.\n\n    The :meth:`shade` is used to produce ""shaded"" rgb values for a data array.\n    :meth:`shade_rgb` can be used to combine an rgb image with\n    The :meth:`shade_rgb`\n    The :meth:`hillshade` produces an illumination map of a surface.\n    """"""\n    def __init__(self, azdeg=315, altdeg=45, hsv_min_val=0, hsv_max_val=1,\n                 hsv_min_sat=1, hsv_max_sat=0):\n        """"""\n        Specify the azimuth (measured clockwise from south) and altitude\n        (measured up from the plane of the surface) of the light source\n        in degrees.\n\n        Parameters\n        ----------\n        azdeg : number, optional\n            The azimuth (0-360, degrees clockwise from North) of the light\n            source. Defaults to 315 degrees (from the northwest).\n        altdeg : number, optional\n            The altitude (0-90, degrees up from horizontal) of the light\n            source.  Defaults to 45 degrees from horizontal.\n\n        Notes\n        -----\n        For backwards compatibility, the parameters *hsv_min_val*,\n        *hsv_max_val*, *hsv_min_sat*, and *hsv_max_sat* may be supplied at\n        initialization as well.  However, these parameters will only be used if\n        ""blend_mode=\'hsv\'"" is passed into :meth:`shade` or :meth:`shade_rgb`.\n        See the documentation for :meth:`blend_hsv` for more details.\n        """"""\n        self.azdeg = azdeg\n        self.altdeg = altdeg\n        self.hsv_min_val = hsv_min_val\n        self.hsv_max_val = hsv_max_val\n        self.hsv_min_sat = hsv_min_sat\n        self.hsv_max_sat = hsv_max_sat\n\n    @property\n    def direction(self):\n        """""" The unit vector direction towards the light source """"""\n\n        # Azimuth is in degrees clockwise from North. Convert to radians\n        # counterclockwise from East (mathematical notation).\n        az = np.radians(90 - self.azdeg)\n        alt = np.radians(self.altdeg)\n\n        return np.array([\n            np.cos(az) * np.cos(alt),\n            np.sin(az) * np.cos(alt),\n            np.sin(alt)\n        ])\n\n    def hillshade(self, elevation, vert_exag=1, dx=1, dy=1, fraction=1.):\n        """"""\n        Calculates the illumination intensity for a surface using the defined\n        azimuth and elevation for the light source.\n\n        This computes the normal vectors for the surface, and then passes them\n        on to `shade_normals`\n\n        Parameters\n        ----------\n        elevation : array-like\n            A 2d array (or equivalent) of the height values used to generate an\n            illumination map\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topographic effects.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        """"""\n\n        # Because most image and raster GIS data has the first row in the array\n        # as the ""top"" of the image, dy is implicitly negative.  This is\n        # consistent to what `imshow` assumes, as well.\n        dy = -dy\n\n        # compute the normal vectors from the partial derivatives\n        e_dy, e_dx = np.gradient(vert_exag * elevation, dy, dx)\n\n        # .view is to keep subclasses\n        normal = np.empty(elevation.shape + (3,)).view(type(elevation))\n        normal[..., 0] = -e_dx\n        normal[..., 1] = -e_dy\n        normal[..., 2] = 1\n        normal /= _vector_magnitude(normal)\n\n        return self.shade_normals(normal, fraction)\n\n    def shade_normals(self, normals, fraction=1.):\n        """"""\n        Calculates the illumination intensity for the normal vectors of a\n        surface using the defined azimuth and elevation for the light source.\n\n        Imagine an artificial sun placed at infinity in some azimuth and\n        elevation position illuminating our surface. The parts of the surface\n        that slope toward the sun should brighten while those sides facing away\n        should become darker.\n\n        Parameters\n        ----------\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n\n        Returns\n        -------\n        intensity : ndarray\n            A 2d array of illumination values between 0-1, where 0 is\n            completely in shadow and 1 is completely illuminated.\n        """"""\n\n        intensity = normals.dot(self.direction)\n\n        # Apply contrast stretch\n        imin, imax = intensity.min(), intensity.max()\n        intensity *= fraction\n\n        # Rescale to 0-1, keeping range before contrast stretch\n        # If constant slope, keep relative scaling (i.e. flat should be 0.5,\n        # fully occluded 0, etc.)\n        if (imax - imin) > 1e-6:\n            # Strictly speaking, this is incorrect. Negative values should be\n            # clipped to 0 because they\'re fully occluded. However, rescaling\n            # in this manner is consistent with the previous implementation and\n            # visually appears better than a ""hard"" clip.\n            intensity -= imin\n            intensity /= (imax - imin)\n        intensity = np.clip(intensity, 0, 1, intensity)\n\n        return intensity\n\n    def shade(self, data, cmap, norm=None, blend_mode=\'overlay\', vmin=None,\n              vmax=None, vert_exag=1, dx=1, dy=1, fraction=1, **kwargs):\n        """"""\n        Combine colormapped data values with an illumination intensity map\n        (a.k.a.  ""hillshade"") of the values.\n\n        Parameters\n        ----------\n        data : array-like\n            A 2d array (or equivalent) of the height values used to generate a\n            shaded map.\n        cmap : `~matplotlib.colors.Colormap` instance\n            The colormap used to color the *data* array. Note that this must be\n            a `~matplotlib.colors.Colormap` instance.  For example, rather than\n            passing in `cmap=\'gist_earth\'`, use\n            `cmap=plt.get_cmap(\'gist_earth\')` instead.\n        norm : `~matplotlib.colors.Normalize` instance, optional\n            The normalization used to scale values before colormapping. If\n            None, the input will be linearly scaled between its min and max.\n        blend_mode : {\'hsv\', \'overlay\', \'soft\'} or callable, optional\n            The type of blending used to combine the colormapped data\n            values with the illumination intensity.  Default is\n            ""overlay"".  Note that for most topographic surfaces,\n            ""overlay"" or ""soft"" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to\n            combine an MxNx3 RGB array of floats (ranging 0 to 1) with\n            an MxNx1 hillshade array (also 0 to 1).  (Call signature\n            `func(rgb, illum, **kwargs)`) Additional kwargs supplied\n            to this function will be passed on to the *blend_mode*\n            function.\n        vmin : scalar or None, optional\n            The minimum value used in colormapping *data*. If *None* the\n            minimum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vmax : scalar or None, optional\n            The maximum value used in colormapping *data*. If *None* the\n            maximum value in *data* is used. If *norm* is specified, then this\n            argument will be ignored.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        fraction : number, optional\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        rgba : ndarray\n            An MxNx4 array of floats ranging between 0-1.\n        """"""\n        if vmin is None:\n            vmin = data.min()\n        if vmax is None:\n            vmax = data.max()\n        if norm is None:\n            norm = Normalize(vmin=vmin, vmax=vmax)\n\n        rgb0 = cmap(norm(data))\n        rgb1 = self.shade_rgb(rgb0, elevation=data, blend_mode=blend_mode,\n                              vert_exag=vert_exag, dx=dx, dy=dy,\n                              fraction=fraction, **kwargs)\n        # Don\'t overwrite the alpha channel, if present.\n        rgb0[..., :3] = rgb1[..., :3]\n        return rgb0\n\n    def shade_rgb(self, rgb, elevation, fraction=1., blend_mode=\'hsv\',\n                  vert_exag=1, dx=1, dy=1, **kwargs):\n        """"""\n        Use this light source to adjust the colors of the *rgb* input array to\n        give the impression of a shaded relief map with the given `elevation`.\n\n        Parameters\n        ----------\n        rgb : array-like\n            An (M, N, 3) RGB array, assumed to be in the range of 0 to 1.\n        elevation : array-like\n            An (M, N) array of the height values used to generate a shaded map.\n        fraction : number\n            Increases or decreases the contrast of the hillshade.  Values\n            greater than one will cause intermediate values to move closer to\n            full illumination or shadow (and clipping any values that move\n            beyond 0 or 1). Note that this is not visually or mathematically\n            the same as vertical exaggeration.\n        blend_mode : {\'hsv\', \'overlay\', \'soft\'} or callable, optional\n            The type of blending used to combine the colormapped data values\n            with the illumination intensity.  For backwards compatibility, this\n            defaults to ""hsv"". Note that for most topographic surfaces,\n            ""overlay"" or ""soft"" appear more visually realistic. If a\n            user-defined function is supplied, it is expected to combine an\n            MxNx3 RGB array of floats (ranging 0 to 1) with an MxNx1 hillshade\n            array (also 0 to 1).  (Call signature `func(rgb, illum, **kwargs)`)\n            Additional kwargs supplied to this function will be passed on to\n            the *blend_mode* function.\n        vert_exag : number, optional\n            The amount to exaggerate the elevation values by when calculating\n            illumination. This can be used either to correct for differences in\n            units between the x-y coordinate system and the elevation\n            coordinate system (e.g. decimal degrees vs meters) or to exaggerate\n            or de-emphasize topography.\n        dx : number, optional\n            The x-spacing (columns) of the input *elevation* grid.\n        dy : number, optional\n            The y-spacing (rows) of the input *elevation* grid.\n        Additional kwargs are passed on to the *blend_mode* function.\n\n        Returns\n        -------\n        shaded_rgb : ndarray\n            An (m, n, 3) array of floats ranging between 0-1.\n        """"""\n        # Calculate the ""hillshade"" intensity.\n        intensity = self.hillshade(elevation, vert_exag, dx, dy, fraction)\n        intensity = intensity[..., np.newaxis]\n\n        # Blend the hillshade and rgb data using the specified mode\n        lookup = {\n                \'hsv\': self.blend_hsv,\n                \'soft\': self.blend_soft_light,\n                \'overlay\': self.blend_overlay,\n                }\n        if blend_mode in lookup:\n            blend = lookup[blend_mode](rgb, intensity, **kwargs)\n        else:\n            try:\n                blend = blend_mode(rgb, intensity, **kwargs)\n            except TypeError:\n                raise ValueError(\'""blend_mode"" must be callable or one of {}\'\n                                 .format(lookup.keys))\n\n        # Only apply result where hillshade intensity isn\'t masked\n        if hasattr(intensity, \'mask\'):\n            mask = intensity.mask[..., 0]\n            for i in range(3):\n                blend[..., i][mask] = rgb[..., i][mask]\n\n        return blend\n\n    def blend_hsv(self, rgb, intensity, hsv_max_sat=None, hsv_max_val=None,\n                  hsv_min_val=None, hsv_min_sat=None):\n        """"""\n        Take the input data array, convert to HSV values in the given colormap,\n        then adjust those color values to give the impression of a shaded\n        relief map with a specified light source.  RGBA values are returned,\n        which can then be used to plot the shaded image with imshow.\n\n        The color of the resulting image will be darkened by moving the (s,v)\n        values (in hsv colorspace) toward (hsv_min_sat, hsv_min_val) in the\n        shaded regions, or lightened by sliding (s,v) toward (hsv_max_sat\n        hsv_max_val) in regions that are illuminated.  The default extremes are\n        chose so that completely shaded points are nearly black (s = 1, v = 0)\n        and completely illuminated points are nearly white (s = 0, v = 1).\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n        hsv_max_sat : number, optional\n            The maximum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 1.\n        hsv_min_sat : number, optional\n            The minimum saturation value that the *intensity* map can shift the\n            output image to. Defaults to 0.\n        hsv_max_val : number, optional\n            The maximum value (""v"" in ""hsv"") that the *intensity* map can shift\n            the output image to. Defaults to 1.\n        hsv_min_val : number, optional\n            The minimum value (""v"" in ""hsv"") that the *intensity* map can shift\n            the output image to. Defaults to 0.\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        """"""\n        # Backward compatibility...\n        if hsv_max_sat is None:\n            hsv_max_sat = self.hsv_max_sat\n        if hsv_max_val is None:\n            hsv_max_val = self.hsv_max_val\n        if hsv_min_sat is None:\n            hsv_min_sat = self.hsv_min_sat\n        if hsv_min_val is None:\n            hsv_min_val = self.hsv_min_val\n\n        # Expects a 2D intensity array scaled between -1 to 1...\n        intensity = intensity[..., 0]\n        intensity = 2 * intensity - 1\n\n        # convert to rgb, then rgb to hsv\n        hsv = rgb_to_hsv(rgb[:, :, 0:3])\n\n        # modify hsv values to simulate illumination.\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity > 0),\n                                ((1. - intensity) * hsv[:, :, 1] +\n                                 intensity * hsv_max_sat),\n                                hsv[:, :, 1])\n\n        hsv[:, :, 2] = np.where(intensity > 0,\n                                ((1. - intensity) * hsv[:, :, 2] +\n                                 intensity * hsv_max_val),\n                                hsv[:, :, 2])\n\n        hsv[:, :, 1] = np.where(np.logical_and(np.abs(hsv[:, :, 1]) > 1.e-10,\n                                               intensity < 0),\n                                ((1. + intensity) * hsv[:, :, 1] -\n                                 intensity * hsv_min_sat),\n                                hsv[:, :, 1])\n        hsv[:, :, 2] = np.where(intensity < 0,\n                                ((1. + intensity) * hsv[:, :, 2] -\n                                 intensity * hsv_min_val),\n                                hsv[:, :, 2])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] < 0., 0, hsv[:, :, 1:])\n        hsv[:, :, 1:] = np.where(hsv[:, :, 1:] > 1., 1, hsv[:, :, 1:])\n        # convert modified hsv back to rgb.\n        return hsv_to_rgb(hsv)\n\n    def blend_soft_light(self, rgb, intensity):\n        """"""\n        Combines an rgb image with an intensity map using ""soft light""\n        blending.  Uses the ""pegtop"" formula.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        """"""\n        return 2 * intensity * rgb + (1 - 2 * intensity) * rgb**2\n\n    def blend_overlay(self, rgb, intensity):\n        """"""\n        Combines an rgb image with an intensity map using ""overlay"" blending.\n\n        Parameters\n        ----------\n        rgb : ndarray\n            An MxNx3 RGB array of floats ranging from 0 to 1 (color image).\n        intensity : ndarray\n            An MxNx1 array of floats ranging from 0 to 1 (grayscale image).\n\n        Returns\n        -------\n        rgb : ndarray\n            An MxNx3 RGB array representing the combined images.\n        """"""\n        low = 2 * intensity * rgb\n        high = 1 - 2 * (1 - intensity) * (1 - rgb)\n        return np.where(rgb <= 0.5, low, high)\n\n\ndef from_levels_and_colors(levels, colors, extend=\'neither\'):\n    """"""\n    A helper routine to generate a cmap and a norm instance which\n    behave similar to contourf\'s levels and colors arguments.\n\n    Parameters\n    ----------\n    levels : sequence of numbers\n        The quantization levels used to construct the :class:`BoundaryNorm`.\n        Values ``v`` are quantizized to level ``i`` if\n        ``lev[i] <= v < lev[i+1]``.\n    colors : sequence of colors\n        The fill color to use for each level. If `extend` is ""neither"" there\n        must be ``n_level - 1`` colors. For an `extend` of ""min"" or ""max"" add\n        one extra color, and for an `extend` of ""both"" add two colors.\n    extend : {\'neither\', \'min\', \'max\', \'both\'}, optional\n        The behaviour when a value falls out of range of the given levels.\n        See :func:`~matplotlib.pyplot.contourf` for details.\n\n    Returns\n    -------\n    (cmap, norm) : tuple containing a :class:`Colormap` and a \\\n                   :class:`Normalize` instance\n    """"""\n    colors_i0 = 0\n    colors_i1 = None\n\n    if extend == \'both\':\n        colors_i0 = 1\n        colors_i1 = -1\n        extra_colors = 2\n    elif extend == \'min\':\n        colors_i0 = 1\n        extra_colors = 1\n    elif extend == \'max\':\n        colors_i1 = -1\n        extra_colors = 1\n    elif extend == \'neither\':\n        extra_colors = 0\n    else:\n        raise ValueError(\'Unexpected value for extend: {0!r}\'.format(extend))\n\n    n_data_colors = len(levels) - 1\n    n_expected_colors = n_data_colors + extra_colors\n    if len(colors) != n_expected_colors:\n        raise ValueError(\'With extend == {0!r} and n_levels == {1!r} expected\'\n                         \' n_colors == {2!r}. Got {3!r}.\'\n                         \'\'.format(extend, len(levels), n_expected_colors,\n                                   len(colors)))\n\n    cmap = ListedColormap(colors[colors_i0:colors_i1], N=n_data_colors)\n\n    if extend in [\'min\', \'both\']:\n        cmap.set_under(colors[0])\n    else:\n        cmap.set_under(\'none\')\n\n    if extend in [\'max\', \'both\']:\n        cmap.set_over(colors[-1])\n    else:\n        cmap.set_over(\'none\')\n\n    cmap.colorbar_extend = extend\n\n    norm = BoundaryNorm(levels, ncolors=n_data_colors)\n    return cmap, norm\n'"
napari/layers/shapes/_shapes_models/_tests/test_shapes_models.py,32,"b'import numpy as np\nfrom napari.layers.shapes._shapes_models import (\n    Rectangle,\n    Polygon,\n    Path,\n    Line,\n    Ellipse,\n)\n\n\ndef test_rectangle():\n    """"""Test creating Shape with a random rectangle.""""""\n    # Test a single four corner rectangle\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 2))\n    shape = Rectangle(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n    # If given two corners, representation will be exapanded to four\n    data = 20 * np.random.random((2, 2))\n    shape = Rectangle(data)\n    assert len(shape.data) == 4\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n\ndef test_nD_rectangle():\n    """"""Test creating Shape with a random nD rectangle.""""""\n    # Test a single four corner planar 3D rectangle\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 3))\n    data[:, 0] = 0\n    shape = Rectangle(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 1)\n\n    shape.ndisplay = 3\n    assert shape.data_displayed.shape == (4, 3)\n\n\ndef test_polygon():\n    """"""Test creating Shape with a random polygon.""""""\n    # Test a single six vertex polygon\n    np.random.seed(0)\n    data = 20 * np.random.random((6, 2))\n    shape = Polygon(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (6, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n\ndef test_nD_polygon():\n    """"""Test creating Shape with a random nD polygon.""""""\n    # Test a single six vertex planar 3D polygon\n    np.random.seed(0)\n    data = 20 * np.random.random((6, 3))\n    data[:, 0] = 0\n    shape = Polygon(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (6, 2)\n    assert shape.slice_key.shape == (2, 1)\n\n    shape.ndisplay = 3\n    assert shape.data_displayed.shape == (6, 3)\n\n\ndef test_path():\n    """"""Test creating Shape with a random path.""""""\n    # Test a single six vertex path\n    np.random.seed(0)\n    data = 20 * np.random.random((6, 2))\n    shape = Path(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (6, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n\ndef test_nD_path():\n    """"""Test creating Shape with a random nD path.""""""\n    # Test a single six vertex 3D path\n    np.random.seed(0)\n    data = 20 * np.random.random((6, 3))\n    shape = Path(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (6, 2)\n    assert shape.slice_key.shape == (2, 1)\n\n    shape.ndisplay = 3\n    assert shape.data_displayed.shape == (6, 3)\n\n\ndef test_line():\n    """"""Test creating Shape with a random line.""""""\n    # Test a single two vertex line\n    np.random.seed(0)\n    data = 20 * np.random.random((2, 2))\n    shape = Line(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (2, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n\ndef test_nD_line():\n    """"""Test creating Shape with a random nD line.""""""\n    # Test a single two vertex 3D line\n    np.random.seed(0)\n    data = 20 * np.random.random((2, 3))\n    shape = Line(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (2, 2)\n    assert shape.slice_key.shape == (2, 1)\n\n    shape.ndisplay = 3\n    assert shape.data_displayed.shape == (2, 3)\n\n\ndef test_ellipse():\n    """"""Test creating Shape with a random ellipse.""""""\n    # Test a single four corner ellipse\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 2))\n    shape = Ellipse(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n    # If center radii, representation will be exapanded to four corners\n    data = 20 * np.random.random((2, 2))\n    shape = Ellipse(data)\n    assert len(shape.data) == 4\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 0)\n\n\ndef test_nD_ellipse():\n    """"""Test creating Shape with a random nD ellipse.""""""\n    # Test a single four corner planar 3D ellipse\n    np.random.seed(0)\n    data = 20 * np.random.random((4, 3))\n    data[:, 0] = 0\n    shape = Ellipse(data)\n    assert np.all(shape.data == data)\n    assert shape.data_displayed.shape == (4, 2)\n    assert shape.slice_key.shape == (2, 1)\n\n    shape.ndisplay = 3\n    assert shape.data_displayed.shape == (4, 3)\n'"
