file_path,api_count,code
RK_DAE_solver.py,13,"b'import numpy as np\n\n\nclass RK_DAE:\n    """"""Base class for Runge-Kutta family of methods for DAE systems.\n\n    It should be inherited for each type of RK methods (explicit and implicit),\n    and for different indices of DAE.\n    Those classes should implement `find_next_y_z` method.\n\n    Attributes:\n        name (string): name of a method\n        s (int): number of stages of a method\n        A (np.array, (s, s)): matrix A of Butcher tableau\n        b (np.array, (s,)): vector b of Butcher tableau\n        ex (class instance): defined in `pendulum.py` module.\n            Defines the properties of a problem and equations for solving it.\n        h (float): time-step size\n        ts (np.array): all time steps\n        ys (np.array): results for `y` for all time steps (after running `solve`)\n        zs (np.array): results for `z` for all time steps (after running `solve`)\n    """"""\n    def __init__(self, example, method, simulation_duration, step_size):\n        """"""Initializes RK method instance.\n\n        Args:\n            example (class instance): defined in `pendulum.py` module.\n                Defines the properties of a problem and equations for solving it.\n            method (namedtuple): defined in `methods.py` module.\n                Tuple consisting of method name and Butcher tableau (matrix `A`,\n                vectors `b` and `c`).\n            simulation_duration (float): total duration of a simulation\n            step_size (float): time-step size\n        """"""\n        self.name = method.name\n        self.A = method.A\n        self.b = method.b\n        self.s = len(method.A)\n        self.ex = example\n        self.h = step_size\n        self.ts = self._get_time_steps(simulation_duration, step_size)\n        self.ys = self._initialize_array(example.y_0, len(self.ts))\n        self.zs = self._initialize_array(example.z_0, len(self.ts))\n\n    def solve(self):\n        """"""Solves the system `ex` for all time-steps `ts` by calling\n        `find_next_y_z` (should be implemented by child class) method\n        for each time step.\n\n        Returns:\n            class instance\n        """"""\n        for i, _ in enumerate(self.ts[1:], 1):\n            self.ys[i], self.zs[i] = self.find_next_y_z(self.ys[i-1], self.zs[i-1])\n        return self\n\n    def find_next_y_z(self, y, z):\n        raise NotImplementedError\n\n    @staticmethod\n    def _initialize_array(initial_value, length):\n        x = np.zeros((length, len(initial_value)))\n        x[0] = initial_value\n        return x\n\n    @staticmethod\n    def _get_time_steps(total_time, step_size):\n        nr_of_steps = int(total_time / step_size) + 1\n        return np.linspace(0, total_time, nr_of_steps)\n\n\nclass ERK_DAE1(RK_DAE):\n    """"""Class for explicit RK family of methods for DAE of index 1.\n\n    Inherits all methods from its parent class, implemets the `find_next_y_z`\n    method.\n    """"""\n\n    def find_next_y_z(self, y, z):\n        """"""Calculates the next values of `y` and `z` for a given RK method.\n\n        The values of `y\'` for each intermediate step are saved, to avoid\n        duplicate calculations and to speed up the process.\n\n        Args:\n            y (np.array, (n,)): positions and velocities vector\n            z (np.array, (m,)): Lagrange multipliers vector\n\n        Returns\n            tuple (y, z): values of `y` and `z` at the end of a time-step\n        """"""\n        Y = np.zeros((self.s, len(y)))\n        k = np.zeros((self.s, len(y)))\n        Y[0] = y\n        for i in range(1, self.s):\n            k[i-1] = self.ex.get_dy(Y[i-1])\n            Y[i] = y + self.h * np.sum(self.A[i, j] * k[j] for j in range(i))\n\n        k[-1] = self.ex.get_dy(Y[-1])\n        new_y = y + self.h * np.sum((self.b[i] * k[i] for i in range(self.s)), axis=0)\n        new_z = self.ex.get_z(new_y)\n        return new_y, new_z\n\n\ndef __run_basic_example():\n    from pendulum import Pendulum, DoublePendulum\n    from methods import RK4\n\n    p1 = Pendulum(m=5, x=1.5, y=-2, u=0, v=0)\n    p2 = Pendulum(m=15, x=5.5, y=-5, u=0, v=0)\n    dp = DoublePendulum(p1, p2)\n    rk = ERK_DAE1(dp, RK4, 5, 0.1).solve()\n    l1_start = (rk.ys[0, 0]**2 + rk.ys[0, 2]**2)**0.5\n    l2_start = (rk.ys[0, 1]**2 + rk.ys[0, 3]**2)**0.5\n    l1_end = (rk.ys[-1, 0]**2 + rk.ys[-1, 2]**2)**0.5\n    l2_end = (rk.ys[-1, 1]**2 + rk.ys[-1, 3]**2)**0.5\n    print(l1_start, l2_start)\n    print(l1_end, l2_end)\n\n\nif __name__ == \'__main__\':\n    __run_basic_example()\n'"
animations.py,1,"b'from datetime import datetime\r\nimport os\r\nimport numpy as np\r\nimport matplotlib\r\nmatplotlib.use(\'Agg\')\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib import animation\r\n\r\n\r\ndef create_metadata(title, comment=\'\', author=None):\r\n    """"""Creates metadata for video.\r\n\r\n    Args:\r\n        title (string): title of the video\r\n        comment (string): comment of the video\r\n        author (strin): author of the video\r\n\r\n    Returns:\r\n        dict\r\n    """"""\r\n    author = \'https://github.com/narimiran\' if author is None else author\r\n    return dict(artist=author, title=title, comment=comment)\r\n\r\n\r\ndef create_comment(example):\r\n    """"""Creates a comment for video, by listing the initial values of the\r\n    example `example`.\r\n\r\n    Args:\r\n        example (`DoublePendulum` class instance)\r\n\r\n    Returns:\r\n        string\r\n    """"""\r\n    status = [\'Initial conditions:\']\r\n    for i, b in enumerate((example._b1, example._b2), 1):\r\n        s = \'Pendulum {i}: position: ({b.x:.2f}, {b.y:.2f}), mass: {b.m:.2f}\'.format(i=i, b=b)\r\n        status.append(s)\r\n    return \'\\n\'.join(status)\r\n\r\n\r\ndef single_animation(system, ex, fig_size=(8, 8), hide_axes=True, filename=None):\r\n    """"""Creates and saves an animation of a single example/system.\r\n\r\n    The animation is saved in `./animations` subdirectory.\r\n    Animations are done in 50 fps.\r\n    Bob size is proportional to bob mass.\r\n    Trailing dots show previous pendulum positions.\r\n\r\n    Args:\r\n        system (`ERK_DAE1` class instance): DAE system with the results in\r\n            `ys` and `zs` attributes.\r\n        ex (`DoublePendulum` class instance)\r\n        fig_size (tuple (float, float)): size of the figure\r\n        hide_axes (bool): should axis label be hidden of visible. Hidden is\r\n            the default, as it makes animation creation much faster\r\n        filename (string): name of the file (without an extension) where\r\n            animation should be saved\r\n\r\n    Returns:\r\n        filename (string)\r\n    """"""\r\n    fig = plt.figure(figsize=fig_size)\r\n    ax = plt.axes(\r\n        xlim=(system.ys[:, 1].min() * 1.2, system.ys[:, 1].max() * 1.2),\r\n        ylim=(system.ys[:, 3].min() * 1.2, max(0.2, system.ys[:, (2, 3)].max()) * 1.2)\r\n    )\r\n    if hide_axes:\r\n        ax.get_xaxis().set_visible(False)\r\n        ax.get_yaxis().set_visible(False)\r\n    ax.set_aspect(\'equal\')\r\n\r\n    ax.plot(0, 0, \'o\', ms=8, c=\'C0\')\r\n    line, = ax.plot([], [], \'-\', lw=3, c=\'C0\')\r\n    m1, = ax.plot([], [], \'o\', ms=4*ex.M[0, 0], c=\'C1\')\r\n    m2, = ax.plot([], [], \'o\', ms=4*ex.M[1, 1], c=\'C2\')\r\n    p1, = ax.plot([], [], \'o\', ms=1, c=\'C1\')\r\n    p2, = ax.plot([], [], \'o\', ms=1, c=\'C2\')\r\n\r\n    fig.tight_layout()\r\n\r\n    skip = int(0.02 / system.h) # 50fps --> 0.02 sec per frame\r\n\r\n    def animate(i):\r\n        i *= skip\r\n        line.set_data(\r\n            [0, system.ys[i, 0], system.ys[i, 1]],\r\n            [0, system.ys[i, 2], system.ys[i, 3]])\r\n        p1.set_data(\r\n            system.ys[0:i:skip, 0],\r\n            system.ys[0:i:skip, 2])\r\n        p2.set_data(\r\n            system.ys[0:i:skip, 1],\r\n            system.ys[0:i:skip, 3])\r\n        m1.set_data(\r\n            system.ys[i, 0],\r\n            system.ys[i, 2])\r\n        m2.set_data(\r\n            system.ys[i, 1],\r\n            system.ys[i, 3])\r\n        return line, p1, p2, m1, m2\r\n\r\n    anim = animation.FuncAnimation(\r\n        fig=fig,\r\n        func=animate,\r\n        frames=len(system.ys)//skip,\r\n        interval=20,\r\n        blit=True,\r\n    )\r\n\r\n    filename = datetime.now().strftime(\'%Y-%m-%d_%H-%M\') if filename is None else filename\r\n    metadata = create_metadata(filename, comment=create_comment(ex))\r\n\r\n    if not os.path.isdir(os.path.join(os.getcwd(), \'animations\')):\r\n        os.mkdir(\'animations\')\r\n\r\n    try:\r\n        writer = animation.AVConvWriter(fps=50, bitrate=-1, metadata=metadata)\r\n        anim.save(\'./animations/{}.mp4\'.format(filename), writer=writer)\r\n    except FileNotFoundError:\r\n        writer = animation.FFMpegWriter(fps=50, bitrate=-1, metadata=metadata)\r\n        anim.save(\'./animations/{}.mp4\'.format(filename), writer=writer)\r\n\r\n    return filename\r\n\r\n\r\ndef multi_animation(systems, ex, fig_size=(8, 8), hide_axes=True, filename=None):\r\n    """"""Creates and saves an animation of a multiple systems.\r\n\r\n    The animation is saved in `./animations` subdirectory.\r\n    Animations are done in 50 fps.\r\n    Bob size is proportional to bob mass.\r\n    Trailing dots show previous pendulum positions.\r\n\r\n    Args:\r\n        systems (list of `ERK_DAE1` class instance): list of DAE systems with\r\n            the results in `ys` and `zs` attributes.\r\n        ex (`DoublePendulum` class instance)\r\n        fig_size (tuple (float, float)): size of the figure\r\n        hide_axes (bool): should axis label be hidden of visible. Hidden is\r\n            the default, as it makes animation creation much faster\r\n        filename (string): name of the file (without an extension) where\r\n            animation should be saved\r\n\r\n    Returns:\r\n        filename (string)\r\n    """"""\r\n    ys = np.array([s.ys for s in systems])\r\n\r\n    fig = plt.figure(figsize=fig_size)\r\n    ax = plt.axes(\r\n        xlim=(ys[:, :, 1].min() * 1.2, ys[:, :, 1].max() * 1.2),\r\n        ylim=(ys[:, :, 3].min() * 1.2, max(0.2, ys[:, :, (2, 3)].max()) * 1.2)\r\n    )\r\n    if hide_axes:\r\n        ax.get_xaxis().set_visible(False)\r\n        ax.get_yaxis().set_visible(False)\r\n    ax.set_aspect(\'equal\')\r\n\r\n    ax.plot(0, 0, \'o\', ms=8, c=\'k\')\r\n\r\n    lines, m1s, m2s, trails = [], [], [], []\r\n    for k in range(len(systems)):\r\n        lines.append(ax.plot([], [], \'-\', lw=3, c=\'C{}\'.format(k))[0])\r\n        m1s.append(ax.plot([], [], \'o\', ms=4*ex.M[0, 0], c=\'C{}\'.format(k))[0])\r\n        m2s.append(ax.plot([], [], \'o\', ms=4*ex.M[1, 1], c=\'C{}\'.format(k))[0])\r\n        trails.append(ax.plot([], [], \'o\', ms=1, c=\'C{}\'.format(k))[0])\r\n\r\n    fig.tight_layout()\r\n\r\n    skip = int(0.02 / systems[0].h) # 50fps --> 0.02 sec per frame\r\n\r\n    def animate(i):\r\n        i *= skip\r\n        for k in range(len(systems)):\r\n            lines[k].set_data(\r\n                [0, ys[k, i, 0], ys[k, i, 1]],\r\n                [0, ys[k, i, 2], ys[k, i, 3]])\r\n            m1s[k].set_data(\r\n                ys[k, i, 0],\r\n                ys[k, i, 2])\r\n            m2s[k].set_data(\r\n                ys[k, i, 1],\r\n                ys[k, i, 3])\r\n            trails[k].set_data(\r\n                ys[k, max(0, i-100*skip):i:skip, 1],\r\n                ys[k, max(0, i-100*skip):i:skip, 3])\r\n        return lines, m1s, m2s, trails\r\n\r\n    anim = animation.FuncAnimation(\r\n        fig=fig,\r\n        func=animate,\r\n        frames=ys.shape[1]//skip,\r\n        interval=20,\r\n        blit=False,\r\n    )\r\n\r\n    filename = datetime.now().strftime(\'%Y-%m-%d_%H-%M\') if filename is None else filename\r\n    metadata = create_metadata(filename, comment=create_comment(ex))\r\n\r\n    if not os.path.isdir(os.path.join(os.getcwd(), \'animations\')):\r\n        os.mkdir(\'animations\')\r\n\r\n    try:\r\n        writer = animation.AVConvWriter(fps=50, bitrate=-1, metadata=metadata)\r\n        anim.save(\'./animations/{}.mp4\'.format(filename), writer=writer)\r\n    except FileNotFoundError:\r\n        writer = animation.FFMpegWriter(fps=50, bitrate=-1, metadata=metadata)\r\n        anim.save(\'./animations/{}.mp4\'.format(filename), writer=writer)\r\n\r\n    return filename\r\n\r\n\r\ndef __run_basic_example():\r\n    import simulation\r\n    while True:\r\n        rs = simulation.create_random_example()\r\n        try:\r\n            r = simulation.simulate(rs, method=simulation.Euler, step_size=0.005)\r\n            break\r\n        except FloatingPointError:\r\n            continue\r\n    print(rs._b1)\r\n    print(r.ys[:3])\r\n    print(create_metadata(\'\'))\r\n    single_animation(r, rs)\r\n\r\n    mtd = [simulation.Euler, simulation.DOPRI5, simulation.ExplicitMidpoint]\r\n    mms = simulation.simulate_multiple_methods(rs, mtd, duration=20, step_size=0.01)\r\n    multi_animation(mms, rs)\r\n\r\n    exes = simulation.create_perturbations(5, rs, amount=1e-2)\r\n    ps = simulation.simulate_multiple_examples(exes, simulation.RK4, 30, 0.005)\r\n    multi_animation(ps, rs)\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    __run_basic_example()\r\n'"
methods.py,58,"b'""""""Butcher tableaux for some popular Runge Kutta methods.\n\nSee https://en.wikipedia.org/wiki/List_of_Runge\xe2\x80\x93Kutta_methods for more details.\n""""""\n\n\nfrom collections import namedtuple\nimport numpy as np\n\n\nbutcher = namedtuple(\'Butcher\', \'name A b c\')\n\n# partitioned half-explicit methods\nbutcher_phem = namedtuple(\'Butcher\', \'name A b c A_hat\')\n\nr3 = 3**0.5\nr6 = 6**0.5\nr15 = 15**0.5\n\n\n\n\n####################\n# EXPLICIT METHODS #\n####################\n\neuler_a = np.array([[0]])\neuler_b = np.array([1])\neuler_c = np.array([0])\n\nEuler = butcher(\'Forward Euler\', euler_a, euler_b, euler_c)\n\n\nem_a = np.zeros((2, 2))\nem_a[1, 0] = 1/2\nem_b = np.array([0, 1])\nem_c = np.array([0, 1/2])\n\nExplicitMidpoint = butcher(\'Explicit midpoint\', em_a, em_b, em_c)\n\n\nralston_a = np.zeros((2, 2))\nralston_a[1, 0] = 2/3\nralston_b = np.array([1/4, 3/4])\nralston_c = np.array([0, 2/3])\n\nRalston = butcher(\'Ralston\', ralston_a, ralston_b, ralston_c)\n\n\nkutta_a = np.zeros((3, 3))\nkutta_a[1, 0] = 1/2\nkutta_a[2, :2] = [-1, 2]\nkutta_b = np.array([1/6, 2/3, 1/6])\nkutta_c = np.array([0, 1/2, 1])\n\nKutta3 = butcher(\'Kutta3\', kutta_a, kutta_b, kutta_c)\n\n\nrk4_a = np.zeros((4, 4))\nrk4_a[1, 0] = rk4_a[2, 1] = 1/2\nrk4_a[3, 2] = 1\nrk4_b = np.array([1/6, 1/3, 1/3, 1/6])\nrk4_c = np.array([0, 1/2, 1/2, 1])\n\nRK4 = butcher(\'RK4\', rk4_a, rk4_b, rk4_c)\n\n\npho4_a = np.zeros((4, 4))\npho4_a[1, 0] = 1/3\npho4_a[2, :2] = [-1/3, 1]\npho4_a[3, :3] = [1, -1, 1]\npho4_b = np.array([1/8, 3/8, 3/8, 1/8])\npho4_c = np.array([0, 1/3, 2/3, 1])\npho4_a_hat = np.array([[0, 0, 0, 0, 0],\n                       [1/8, 3/8, 0, 0, 0],\n                       [161/1024, 147/512, 441/1024, 0, 0],\n                       [1/8, 3/8, 3/8, 1/8, 0],\n                       [693/5000, 1701/5000, 243/625, 81/1250, -81/2500]\n                      ])\n\nPHO4 = butcher_phem(\'3/8\', pho4_a, pho4_b, pho4_c, pho4_a_hat)\n\n\n\nrkf_a = np.zeros((6, 6))\nrkf_a[1, 0] = 1/4\nrkf_a[2, :2] = [3/32, 9/32]\nrkf_a[3, :3] = [1932/2197, -7200/2197, 7296/2197]\nrkf_a[4, :4] = [439/216, -8, 3680/513, -845/4104]\nrkf_a[5, :5] = [-8/27, 2, -3544/2565, 1859/4104, -11/40]\nrkf_b = np.array([16/135, 0, 6656/12825, 28561/56430, -9/50, 2/55])\nrkf_c = np.array([0, 1/4, 3/8, 12/13, 1, 1/2])\n\nRKF = butcher(\'RKF\', rkf_a, rkf_b, rkf_c)\n\n\nck_a = np.zeros((6, 6))\nck_a[1, 0] = 1/5\nck_a[2, :2] = [3/40, 9/40]\nck_a[3, :3] = [3/10, -9/10, 6/5]\nck_a[4, :4] = [-11/54, 5/2, -70/27, 35/27]\nck_a[5, :5] = [1631/55296, 175/512, 575/13824, 44275/110592, 253/4096]\nck_b = np.array([2825/27648, 0, 18575/48384, 13525/55296, 277/14336, 1/4])\nck_c = np.array([0, 1/5, 3/10, 3/5, 1, 7/8])\n\nCK = butcher(\'Cash-Karp\', ck_a, ck_b, ck_c)\n\n\ndopri_a = np.zeros((7, 7))\ndopri_a[1, 0] = 1/5\ndopri_a[2, :2] = [3/40, 9/40]\ndopri_a[3, :3] = [44/45, -56/15, 32/9]\ndopri_a[4, :4] = [19372/6561, -25360/2187, 64448/6561, -212/729]\ndopri_a[5, :5] = [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656]\ndopri_a[6, :6] = [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84]\ndopri_b = dopri_a[-1]\ndopri_c = np.array([0, 1/5, 3/10, 4/5, 8/9, 1, 1])\n\ndopri_a_hat = np.zeros((7, 7))\ndopri_a_hat[:6] = dopri_a[1:]\ndopri_a_hat[6] = [-18611506045861/19738176307200,\n                  59332529/14479296,\n                  -2509441598627/893904224850,\n                  2763523204159/3289696051200,\n                  -41262869588913/116235927142400,\n                  46310205821/287848404480,\n                  -3280/75413\n                 ]\n\nDOPRI5 = butcher_phem(\'DOPRI5\', dopri_a, dopri_b, dopri_c, dopri_a_hat)\n\n\n\n\n\n\n\n\n\n####################\n# IMPLICIT METHODS #\n####################\n\n\n\nbe_a = np.array([[1]])\nbe_b = np.array([1])\nbe_c = np.array([1])\n\nBackwardEuler = butcher(\'Backward Euler\', be_a, be_b, be_c)\n\n\n\n#########################\n# Gauss-Legendre family #\n#########################\n\nim_a = np.array([[1/2]])\nim_b = np.array([1])\nim_c = np.array([1/2])\n\nImplicitMidpoint = butcher(\'Implicit midpoint\', im_a, im_b, im_c)\n\n\ngl4_a = np.array([[1/4, 1/4 - r3/6],\n                  [1/4 + r3/6, 1/4]])\ngl4_b = np.array([0.5, 0.5])\ngl4_c = np.array([1/2 - r3/6, 1/2 + r3/6])\n\nGauss4 = butcher(\'Gauss-Legendre (4)\', gl4_a, gl4_b, gl4_c)\n\n\ngl6_a = np.array([[5/36, 2/9 - r15/15, 5/36 - r15/30],\n                  [5/36 + r15/24, 2/9, 5/36 - r15/24],\n                  [5/36 + r15/30, 2/9 + r15/15, 5/36]])\ngl6_b = np.array([5/18, 4/9, 5/18])\ngl6_c = np.array([1/2 - r15/10, 1/2, 1/2 + r15/10])\n\nGauss6 = butcher(\'Gauss-Legendre (6)\', gl6_a, gl6_b, gl6_c)\n\n\n\n################\n# Radau family #\n################\n\nrad3IA_a = np.array([[1/4, -1/4],\n                     [1/4, 5/12]])\nrad3IA_b = np.array([1/4, 3/4])\nrad3IA_c = np.array([0, 2/3])\n\nRadauIA_3 = butcher(\'Radau IA (3)\', rad3IA_a, rad3IA_b, rad3IA_c)\n\n\nrad5IA_a = np.array([[1/9, (-1-r6)/18, (-1+r6)/18],\n                     [1/9, 11/45 + 7*r6/360, 11/45 - 43*r6/360],\n                     [1/9, 11/45 + 43*r6/360, 11/45 - 7*r6/360]])\nrad5IA_b = np.array([1/9, 4/9 + r6/36, 4/9 - r6/36])\nrad5IA_c = np.array([0, 3/5 - r6/10, 3/5 + r6/10])\n\nRadauIA_5 = butcher(\'Radau IA (5)\', rad5IA_a, rad5IA_b, rad5IA_c)\n\n\nrad3IIA_a = np.array([[5/12, -1/12],\n                      [3/4, 1/4]])\nrad3IIA_b = rad3IIA_a[-1]\nrad3IIA_c = np.array([1/3, 1])\n\nRadauIIA_3 = butcher(\'Radau IIA (3)\', rad3IIA_a, rad3IIA_b, rad3IIA_c)\n\n\nrad5IIA_a = np.array([[11/45 - 7*r6/360, 37/225 - 169*r6/1800, -2/225 + r6/75],\n                      [37/225 + 169*r6/1800, 11/45 + 7*r6/360, -2/225 - r6/75],\n                      [4/9 - r6/36, 4/9 + r6/36, 1/9]])\nrad5IIA_b = rad5IIA_a[-1]\nrad5IIA_c = np.array([2/5 - r6/10, 2/5 + r6/10, 1])\n\nRadauIIA_5 = butcher(\'Radau IIA (5)\', rad5IIA_a, rad5IIA_b, rad5IIA_c)\n\n\n\n##################\n# Lobatto family #\n##################\n\nlob2IIIA_a = np.array([[0, 0],\n                       [1/2, 1/2]])\nlob2IIIA_b = lob2IIIA_a[-1]\nlob2IIIA_c = np.array([0, 1])\n\nLobattoIIIA_2 = butcher(\'Lobatto IIIA (2)\', lob2IIIA_a, lob2IIIA_b, lob2IIIA_c)\n\n\nlob4IIIA_a = np.array([[0, 0, 0],\n                       [5/24, 1/3, -1/24],\n                       [1/6, 2/3, 1/6]])\nlob4IIIA_b = lob4IIIA_a[-1]\nlob4IIIA_c = np.array([0, 1/2, 1])\n\nLobattoIIIA_4 = butcher(\'Lobatto IIIA (4)\', lob4IIIA_a, lob4IIIA_b, lob4IIIA_c)\n\n\nlob2IIIC_a = np.array([[1/2, -1/2],\n                       [1/2, 1/2]])\nlob2IIIC_b = lob2IIIC_a[-1]\nlob2IIIC_c = np.array([0, 1])\n\nLobattoIIIC_2 = butcher(\'Lobatto IIIC (2)\', lob2IIIC_a, lob2IIIC_b, lob2IIIC_c)\n\n\nlob4IIIC_a = np.array([[1/6, -1/3, 1/6],\n                       [1/6, 5/12, -1/12],\n                       [1/6, 2/3, 1/6]])\nlob4IIIC_b = lob4IIIC_a[-1]\nlob4IIIC_c = np.array([1, 1/2, 1])\n\nLobattoIIIC_4 = butcher(\'Lobatto IIIC (4)\', lob4IIIC_a, lob4IIIC_b, lob4IIIC_c)\n'"
pendulum.py,25,"b'from collections import namedtuple\nimport numpy as np\n\n\nnp.seterr(over=\'raise\')\n\ng = 9.81\nPendulum = namedtuple(\'Pendulum\', \'m x y u v\')\n\n\nclass DoublePendulum:\n    """"""Double pendulum consisting of two massless bodies and a point masses on\n    their ends.\n\n    Attributes:\n        M     (np.array, (4, 4)): mass matrix\n        M_inv (np.array, (4, 4)): inverse of mass matrix\n        f     (np.array, (4, 1)): vector of gravitational forces\n        y_0   (np.array, (8,)):   initial positions and velocities\n        z_0   (np.array, (2, 1)): initial Lagrange multipliers\n    """"""\n\n    def __init__(self, body_1, body_2):\n        """"""Initializes double pendulum instance.\n\n        Args:\n            body_1, body_2 (namedtuple):\n                m: point mass on the end of the body\n                x: x-coordinate of the point mass\n                y: y-coordinate of the point mass\n                u: velocity in x-direction of the point mass\n                v: velocity in y-direction of the point mass\n        """"""\n        self._check_consistency(body_1, body_2)\n        self.M = np.diag([body_1.m, body_2.m, body_1.m, body_2.m])\n        self.M_inv = np.linalg.inv(self.M)\n        self.f = -g * np.array([0, 0, body_1.m, body_2.m]).reshape((4, 1))\n        self.y_0 = np.array([body_1.x, body_2.x, body_1.y, body_2.y,\n                             body_1.u, body_2.u, body_1.v, body_2.v])\n        self.z_0 = self.get_z(self.y_0)\n        self._b1 = body_1\n        self._b2 = body_2\n\n    def get_z(self, y):\n        """"""Calculate Lagrange multipliers for `y`.\n        See AP98, p. 248.\n\n        Args:\n            y (np.array, (8,)): <x1, x2, y1, y2, u1, u2, v1, v2>\n\n        Returns:\n            np.array, (2,)\n        """"""\n        G = self.get_G(y)\n        g_uu = self.get_g_uu(y)\n        G_Mi = G.dot(self.M_inv)\n\n        A = G_Mi.dot(G.T)\n        b = G_Mi.dot(self.f) + g_uu\n        return np.linalg.solve(A, b).reshape(2,)\n\n    def get_dy(self, y):\n        """"""Calculate `y\' = dy/dt` by solving the system\n                [[M  G.T]    [[du]    [[ f  ]\n                 [G   0 ]] @  [z ]] =  [g_uu]]\n        See HW96, p. 465 for more details.\n\n        Args:\n            y (np.array, (8,)): <x1, x2, y1, y2, u1, u2, v1, v2>\n\n        Returns:\n            np.array, (8,): <dx1, dx2, dy1, dy2, du1, du2, dv1, dv2>\n        """"""\n        G = self.get_G(y)\n        g_uu = self.get_g_uu(y)\n\n        A = np.zeros((6, 6))\n        b = np.zeros((6, 1))\n\n        A[:4, :4] = self.M\n        A[:4, -2:] = G.T\n        A[-2:, :4] = G\n\n        b[:4] = self.f\n        b[-2:] = -1 * g_uu\n\n        x = np.linalg.solve(A, b)\n        return np.concatenate((y[-4:], x[:4, 0]))\n\n    @staticmethod\n    def get_G(y):\n        """"""Calculate matrix `G = grad(g)`, where `g` are algebraic constraints.\n\n        Args:\n            y (np.array, (8,)): <x1, x2, y1, y2, u1, u2, v1, v2>\n\n        Returns:\n            np.array, (2, 4)\n        """"""\n        x1, x2, y1, y2 = y[:4]\n        return np.array([[x1, 0, y1, 0],\n                         [-(x2-x1), (x2-x1), -(y2-y1), (y2-y1)]])\n\n    @staticmethod\n    def get_g_uu(y):\n        """"""Calculate vector `g_uu = G\' @ u`, needed to solve double pendulum\n        as index 1 DAE system. (See HW96, p. 465)\n\n        Args:\n            y (np.array, (8,)): <x1, x2, y1, y2, u1, u2, v1, v2>\n\n        Returns:\n            np.array, (2, 1)\n\n        """"""\n        u1, u2, v1, v2 = y[-4:]\n        return np.array([[u1**2 + v1**2],\n                         [(u2 - u1)**2 + (v2 - v1)**2]])\n\n    @staticmethod\n    def _check_consistency(body_1, body_2):\n        """"""Checks if the initial values satisfy an index 2 constraint.""""""\n\n        if body_1.x * body_1.u + body_1.y * body_1.v != 0:\n            raise InconsistentInitialValues(""First pendulum has inconsistent ""\n                ""initial values. Try setting velocities to zero."")\n\n        if ((body_2.x - body_1.x) * (body_2.u - body_1.u) +\n            (body_2.y - body_1.y) * (body_2.v - body_1.v)) != 0:\n            raise InconsistentInitialValues(""Second pendulum has inconsistent ""\n                ""initial values. Try setting velocities to zero."")\n\n\nclass InconsistentInitialValues(Exception):\n    pass\n\n\ndef __run_basic_example():\n    p1 = Pendulum(m=5, x=1.5, y=-2, u=10, v=0)\n    p2 = Pendulum(m=15, x=5.5, y=-5, u=0, v=20)\n    dp = DoublePendulum(p1, p2)\n    help(dp)\n    print(dp.M)\n    print(dp.M_inv)\n    print(dp.f)\n    print(dp.y_0)\n    print(dp.z_0)\n    print(dp.get_dy(dp.y_0))\n\n\nif __name__ == \'__main__\':\n    __run_basic_example()\n'"
simulation.py,0,"b'import random\n\nfrom pendulum import Pendulum, DoublePendulum\nfrom RK_DAE_solver import ERK_DAE1\nfrom methods import Euler, ExplicitMidpoint, RK4, DOPRI5\n\n\ndef random_initial_values(p_mag, m_mag=5):\n    """"""Returns tuple of random initial values of mass `m`, and positional\n    coordinates `x` and `y`.\n\n    Prefers initial positions above the fixed end.\n    Function `round` is used to get reproducible simulation results.\n\n    Args:\n        p_mag (float): magnitude of the maximum allowed position coordinate\n        m_mag (float): magnitude of the highest allowed mass\n\n    Returns:\n        tuple (m, x, y)\n    """"""\n    m = round(random.random() * m_mag + 1, 2)\n    x = round(random.random() * p_mag * random.choice([-1, 1]), 2)\n    y = round((random.random() - 0.2) * p_mag, 2)\n    return (m, x, y)\n\n\ndef create_random_example(p1_mag=4, p2_mag=6, m1_mag=5, m2_mag=5):\n    """"""Creates a random double pendulum example.\n\n    Positions and masses are chosen via `random_initial_values` function,\n    velocities in both directions are zero.\n\n    Args:\n        p1_mag, p2_mag (float): magnitudes of the maximum allowed position\n            coordinate for each pendulum\n        m1_mag, m2_mag (float): magnitude of the highest allowed mass\n\n    Returns:\n        `DoublePendulum` class instance\n    """"""\n    p1_0 = random_initial_values(p1_mag, m1_mag)\n    p2_0 = random_initial_values(p2_mag, m2_mag)\n\n    p1 = Pendulum(*p1_0, u=0, v=0)\n    p2 = Pendulum(*p2_0, u=0, v=0)\n    dp = DoublePendulum(p1, p2)\n    return dp\n\n\ndef create_perturbations(number, ex=None, amount=1e-6):\n    """"""Creates perturbations of DoublePendulum example by changing the\n    initial conditions by `amount` in each direction for both pendulums.\n\n    Args:\n        number (int): number of perturbations\n        ex (`DoublePendulum` class instance): if not defined, a random example\n            is created.\n        amount (float): amount of change we want to introduce to the `y`\n            coordinate of the second pendulum.\n\n    Returns:\n        list of `DoublePendulum` class instances\n    """"""\n    if ex is None:\n        ex = create_random_example()\n    p1 = ex._b1\n    p2 = ex._b2\n\n    examples = []\n    for n in range(number):\n        p1_per = Pendulum(p1.m, (p1.x - n*amount), (p1.y + n*amount), p1.u, p1.v)\n        p2_per = Pendulum(p2.m, (p2.x + n*amount), (p2.y - n*amount), p2.u, p2.v)\n        examples.append(DoublePendulum(p1_per, p2_per))\n    return examples\n\n\ndef simulate(example, method=RK4, duration=30, step_size=0.001):\n    """"""Solves `example` with an explicit Runge-Kutta method.\n\n    Args:\n        example (class instance): the example we want to solve, e.g. `DoublePendulum`\n        method (namedtuple): explicit Runge-Kutta method defined in `methods.py`\n        duration (int): total duration of the simulation\n        step_size (float): size of a time-step. Too high value might produce\n            unstable results.\n\n    Returns:\n        `ERK_DAE1` class instance with the results in `ys` and `zs` attributes.\n    """"""\n    return ERK_DAE1(example, method, duration, step_size).solve()\n\n\ndef simulate_multiple_methods(example, methods, duration=30, step_size=0.001):\n    """"""Solve one example with different methods.\n\n    Args:\n        example (class instance): the example we want to solve, e.g. `DoublePendulum`\n        methods (list of namedtuple): list of explicit Runge-Kutta methods\n            defined in `methods.py`\n        duration (int): total duration of the simulation\n        step_size (float): size of a time-step. Too high value might produce\n            unstable results.\n\n    Returns:\n        list of `ERK_DAE1` class instances\n    """"""\n    return [simulate(example, method, duration, step_size) for method in methods]\n\n\ndef simulate_multiple_examples(examples, method=RK4, duration=30, step_size=0.001):\n    """"""Solve multiple examples. Usually used in conjunction with\n    `create_perturbations` function.\n\n    Args:\n        examples (list of class instances): list of examples we want to solve,\n            e.g. `DoublePendulum`\n        method (namedtuple): explicit Runge-Kutta method defined in `methods.py`\n        duration (int): total duration of the simulation\n        step_size (float): size of a time-step. Too high value might produce\n            unstable results.\n\n    Returns:\n        list of `ERK_DAE1` class instances\n    """"""\n    return [simulate(ex, method, duration, step_size) for ex in examples]\n\n\ndef __run_basic_example():\n    rsys = create_random_example()\n    r1 = simulate(rsys, method=Euler, duration=15)\n    print(r1.ys[:3])\n    print(r1)\n\n    exes = create_perturbations(5, amount=1e-3)\n    for e in exes:\n        print(e.y_0)\n        print(e.z_0)\n\n    mtd = [Euler, DOPRI5, ExplicitMidpoint]\n    mms = simulate_multiple_methods(rsys, mtd, duration=10, step_size=0.01)\n    for mm in mms:\n        print(mm.name)\n        print(mm.ys[-1])\n\n\nif __name__ == \'__main__\':\n    __run_basic_example()\n'"
tweet_it.py,0,"b'from twython import Twython\nfrom simulation import create_random_example, simulate\nfrom animations import create_comment, single_animation\n\n\ndef create_content():\n    """"""Creates an animation of a random double pendulum example.\n\n    Returns:\n        tuple (string, string):\n            - name of the file of a .mp4 video (without extension), created\n                in ./animations subdirectory\n            - string with initial conditions which will be posted as\n                Twitter status\n    """"""\n    while True:\n        rs = create_random_example()\n        try:\n            r = simulate(rs, step_size=0.004)\n            break\n        except FloatingPointError:\n            continue\n    filename = single_animation(r, rs)\n    comment = create_comment(rs)\n    return filename, comment\n\n\ndef new_tweet(filename=None, status=None):\n    """"""Posts a new tweet.\n\n    Status are the initial conditions, video is attached.\n    To successfully post, a valid API key is needed to be stored in `api_key.txt`.\n\n    Args:\n        filename (string): name of the file containing video (without extension)\n        status (string): text which will be posted as Twitter status\n    """"""\n    if filename is None:\n        filename, comment = create_content()\n        if status is None:\n            status = comment\n\n    with open(""api_key.txt"") as f:\n        api_data = f.readline().split(\';\')\n    twitter = Twython(*api_data)\n\n    video = open(\'./animations/{}.mp4\'.format(filename), \'rb\')\n    response = twitter.upload_video(media=video, media_type=\'video/mp4\')\n    twitter.update_status(status=status, media_ids=[response[\'media_id\']])\n\n\nif __name__ == \'__main__\':\n    new_tweet()\n'"
