file_path,api_count,code
demo.py,4,"b'import py_kernel_pca\nimport sklearn.decomposition\nfrom time import time\nimport numpy as np\n\n\ngpu_pca = py_kernel_pca.KernelPCA(4)\n\ncpu_pca = sklearn.decomposition.KernelPCA(n_components=4)\n\n\nprint ""PCA for 10000x500 matrix. Computing 4 principal components\\n\\n""\n\nX = np.random.rand(10000, 500).astype(np.float32)\n\nX_f = np.copy(X) # make  copy of X, otherwise T1 and T2 share the same reference. Additionally, the gpu pca currently only takes float32 type.i\n\nt0 = time()\nT1 = gpu_pca.fit_transform(X_f, verbose=True)\nprint ""GPU PCA compute time = "", (time() - t0), "" sec""\n\nprint ""\\nStarting CPU PCA computation ...""\n\nt1 = time()\nT2 = cpu_pca.fit_transform(X)\nprint ""CPU PCA compute time = "" , (time() - t1), ""sec""\n\n\nprint ""\\n\\nOrthogonality Test. All dot products of the resulting principal components should be ~ 0.""\nprint ""This is tested by dotting the first and second largest eigenvectors (principal components) of the output for the sklearn\'s pca and this library\'s pca.""\n\nprint ""\\n\\nThis library\'s GPU PCA: T0 . T1 = "", np.dot(T1[:,0], T1[:,1])\nprint ""sklearns\'s CPU PCA: T0 . T1 = "", np.dot(T2[:,0], T2[:,1])\n\n\n\n\n'"
test/py_kernel_pca_test.py,20,"b'import unittest\nimport numpy as np\nfrom py_kernel_pca import KernelPCA\n\nclass TestKernelPCA(unittest.TestCase):\n\n\tdef setUp(self):\n\t\tself.M = 1000\n\t\tself.N = 100\n\t\tself.test_pca = KernelPCA(-1)\n\t\tself.max_sdot = np.float32(0.0001)\n\t\tself.max_ddot = np.float64(0.0000001)\n\t\tself.K = 2\n\t\tself.test_pca2 = KernelPCA(self.K)\n\t\tself.Xd = np.random.rand(self.M, self.N)\n\t\tself.Xf = np.random.rand(self.M, self.N).astype(np.float32)\n\t\tself.Td_all = np.zeros((self.M, self.N), dtype=np.float64)\t\n\t\tself.Tf_2 = np.zeros((self.M, self.K), dtype=np.float32)\t\n\t\tself.Tf_all = np.zeros((self.M, self.N), dtype=np.float32)\t\n\t\tself.Td_2 = np.zeros((self.M, self.K), dtype=np.float64)\n\n\tdef test_type_and_shape_double_all(self):\n\t\t# test that the shape is what we think it should be\n\t\t\n\t\tTd_all = self.test_pca.fit_transform(self.Xd, verbose=True)\n\n\t\tself.assertIsNotNone(Td_all)\n\n\t\tself.assertEqual(type(Td_all[0,0]), np.float64)\n\n\t\tself.assertEqual(Td_all.shape, (self.M, self.N))\n\n\t\tself.Td_all = Td_all\n\n\tdef test_ortho_double_all(self):\n\t\t# test the orthogonality of the eigenvectors\n\t\t\t\t\n\t\tfor i in range(self.N-1):\n\t\t\tself.assertTrue(np.dot(self.Td_all[:,i], self.Td_all[:,i+1]) < self.max_ddot)\n\n\tdef test_type_and_shape_all(self):\n\t\t# test that the shape is what we think it should be\n\t\t\n\t\tTf_all = self.test_pca.fit_transform(self.Xf, verbose=True)\n\n\t\tself.assertIsNotNone(Tf_all)\n\n\t\tself.assertEqual(type(Tf_all[0,0]), np.float32)\n\n\t\tself.assertEqual(Tf_all.shape, (self.M, self.N))\n\n\t\tself.Tf_all = Tf_all\n\n\tdef test_ortho_all(self):\n\t\t# test the orthogonality of the eigenvectors\n\t\t\t\t\n\t\tfor i in range(self.N-1):\n\t\t\tself.assertTrue(np.dot(self.Tf_all[:,i], self.Tf_all[:,i+1]) < self.max_sdot)\n\n\tdef test_type_and_shape_double(self):\n\t\t# test that the shape is what we think it should be\n\t\t\n\t\tTd_2 = self.test_pca2.fit_transform(self.Xd, verbose=True)\n\n\t\tself.assertIsNotNone(Td_2)\n\n\t\tself.assertEqual(type(Td_2[0,0]), np.float64)\n\n\t\tself.assertEqual(Td_2.shape, (self.M, self.K))\n\n\t\tself.Td_2 = Td_2\n\n\tdef test_ortho_double(self):\n\t\t# test the orthogonality of the eigenvectors\n\t\t\t\t\n\t\tself.assertTrue(np.dot(self.Td_all[:,0], self.Td_all[:,1]) < self.max_ddot)\n\n\tdef test_type_and_shape(self):\n\t\t# test that the shape is what we think it should be\n\t\t\n\t\tTf_2 = self.test_pca2.fit_transform(self.Xf, verbose=True)\n\n\t\tself.assertIsNotNone(Tf_2)\n\n\t\tself.assertEqual(type(Tf_2[0,0]), np.float32)\n\n\t\tself.assertEqual(Tf_2.shape, (self.M, self.K))\n\n\t\tself.Tf_2 = Tf_2\n\n\tdef test_ortho(self):\n\t\t# test the orthogonality of the eigenvectors\n\t\t\t\t\n\t\tself.assertTrue(np.dot(self.Tf_2[:,0], self.Tf_2[:,1]) < self.max_sdot)\n\n\n\t\t\t\n\n\tdef test_c_contiguous_check(self):\n\t\t\n\t\ttry:\n\t\t\tX_trash = np.random.rand(self.M, self.M)\n\t\t\tT_trash = self.test_pca2(X_trash.T)\n\t\t\tfail(msg=""C-contiguous array check failed"") # should not reach this line. The prev line should fail and go to the except block\n\t\texcept:\n\t\t\t\n\t\t\tprint \'\' # need some sort of code her, or else there is an error\n\t\t\t\n\n\tdef arr_2d_check(self):\n\n\t\ttry:\n\t\t\tX_trash = np.random.rand(self.M, self.Mi, 3)\n\t\t\tT_trash = self.test_pca2(X_trash.T)\n\t\t\tfail(msg=""Array dimensions check failed"") # should not reach this line. The prev line should fail and go to the except block\n\t\texcept:\n\t\t\t\n\t\t\tprint \'\' # need some sort of code her, or else there is an error\n\t\t\t\n\t\n\tdef test_k_bigger_than_array_dims_and_getset(self):\n\n\t\tself.test_pca.set_n_components(self.N+1)\n\n\t\tself.assertEqual(self.test_pca.get_n_components(), self.N+1)\n\n\t\tX = np.random.rand(self.M, self.N).astype(np.float32)\n\t\tT = self.test_pca.fit_transform(X, verbose=True)\n\n\t\tself.assertEqual(self.test_pca.get_n_components(), self.N) # should have been reset internally once the algorithm saw K was bigger than N\n\t\t\n\t\tX2 = np.random.rand(self.N-2, self.N-1).astype(np.float32)\n\t\tT = self.test_pca.fit_transform(X2, verbose=True)\n\n\t\tself.assertEqual(self.test_pca.get_n_components(), self.N-2) # should have been reset internally once the algorithm saw K was bigger than N\n\t\n\n'"
