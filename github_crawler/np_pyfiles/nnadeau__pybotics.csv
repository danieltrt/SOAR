file_path,api_count,code
docs/conf.py,0,"b'import sys\nfrom pathlib import Path\n\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\nDOCS_DIR = Path(__file__).parent\nROOT_DIR = DOCS_DIR.parent\nsys.path.insert(0, str(ROOT_DIR.resolve()))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = ""pybotics""\nauthor = ""Nicholas Nadeau""\ncopyright = f""2019, {author}""\n\n\n# -- General configuration ---------------------------------------------------\n\nmaster_doc = ""index""\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    ""sphinx.ext.autodoc"",\n    ""sphinx.ext.viewcode"",\n    ""sphinx.ext.todo"",\n    ""sphinx_rtd_theme"",\n    ""sphinx.ext.autosectionlabel"",\n    ""sphinx.ext.graphviz"",\n    ""sphinx.ext.inheritance_diagram"",\n]\n\n# Add any paths that contain templates here, relative to this directory.\n# templates_path = [""_templates""]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = ""en""\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = ""sphinx_rtd_theme""\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\n# html_static_path = [""_static""]\n\n# -- Theme configuration -------------------------------------------------\n\nhtml_logo = str((ROOT_DIR / ""media"" / ""robotic-arm.svg"").resolve())\nhtml_theme_options = {""canonical_url"": ""https://pybotics.readthedocs.io""}\n\n# -- Extension configuration -------------------------------------------------\n\n\n# -- Options for todo extension ----------------------------------------------\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = True\n'"
examples/basic_usage.py,0,"b'""""""Basic usage of the pybotics package.""""""\nfrom pybotics.geometry import vector_2_matrix\nfrom pybotics.predefined_models import ur10\nfrom pybotics.robot import Robot\nfrom pybotics.tool import Tool\n\n\ndef main():\n    """"""\n    Demonstrate pybotics usage.\n\n    View source for more info.\n    """"""\n    # init robot\n    robot = Robot.from_parameters(ur10())\n\n    # add tool\n    tool = Tool()\n    tool.position = [1, 2, 3]\n    robot.tool = tool\n\n    # set world frame\n    world_frame = vector_2_matrix([100, 200, 300, 0, 0, 0])\n    robot.world_frame = world_frame\n\n    print(f""Robot: {robot}"")\n    print(f""Kinematic Chain: {robot.kinematic_chain}"")\n\n\nif __name__ == ""__main__"":\n    main()\n'"
pybotics/__init__.py,0,"b'""""""Pybotics modules.""""""\n'"
pybotics/errors.py,0,"b'""""""Pybotics errors.""""""\nimport attr\n\n\n@attr.s\nclass PyboticsError(Exception):\n    """"""Base class for Pybotics errors.""""""\n\n    message = attr.ib(""Pybotics error"", type=str)\n\n    def __str__(self) -> str:\n        """"""\n        Convert exception to string.\n\n        :return: string\n        """"""\n        return self.message\n'"
pybotics/geometry.py,30,"b'""""""Geometry functions and utilities.""""""\nfrom enum import Enum\nfrom typing import Sequence, Union\n\nimport numpy as np  # type: ignore\n\nfrom pybotics.errors import PyboticsError\n\n\nclass OrientationConvention(Enum):\n    """"""Orientation of a body with respect to a fixed coordinate system.""""""\n\n    EULER_XYX = ""xyx""\n    EULER_XYZ = ""xyz""\n    EULER_XZX = ""xzx""\n    EULER_XZY = ""xzy""\n    EULER_YXY = ""yxy""\n    EULER_YXZ = ""yxz""\n    EULER_YZX = ""yzx""\n    EULER_YZY = ""yzy""\n    EULER_ZXY = ""zxy""\n    EULER_ZXZ = ""zxz""\n    EULER_ZYX = ""zyx""\n    EULER_ZYZ = ""zyz""\n\n    FIXED_XYX = ""xyx""\n    FIXED_XYZ = ""zyx""\n    FIXED_XZX = ""xzx""\n    FIXED_XZY = ""yzx""\n    FIXED_YXY = ""yxy""\n    FIXED_YXZ = ""zxy""\n    FIXED_YZX = ""xzy""\n    FIXED_YZY = ""yzy""\n    FIXED_ZXY = ""yxz""\n    FIXED_ZXZ = ""zxz""\n    FIXED_ZYX = ""xyz""\n    FIXED_ZYZ = ""zyz""\n\n\ndef vector_2_matrix(\n    vector: Sequence[float],\n    convention: Union[OrientationConvention, str] = OrientationConvention.EULER_ZYX,\n) -> np.ndarray:\n    """"""\n    Calculate the pose from the position and euler angles.\n\n    :param convention:\n    :param vector: transform vector\n    :return: 4x4 transform matrix\n    """"""\n    # get individual variables\n    translation_component = vector[:3]\n    rotation_component = vector[-3:]\n\n    # validate and extract orientation info\n    if isinstance(convention, OrientationConvention):\n        convention = convention.value\n    try:\n        OrientationConvention(convention)\n    except ValueError as e:\n        raise PyboticsError(str(e))\n\n    # iterate through rotation order\n    # build rotation matrix\n    transform_matrix = np.eye(4)\n    for axis, value in zip(convention, rotation_component):  # type: ignore\n        current_rotation = globals()[f""rotation_matrix_{axis}""](value)\n        transform_matrix = np.dot(transform_matrix, current_rotation)\n\n    # add translation component\n    transform_matrix[:-1, -1] = translation_component\n\n    return transform_matrix\n\n\ndef position_from_matrix(matrix: np.ndarray) -> np.ndarray:\n    """"""Get the position values from a 4x4 transform matrix.""""""\n    return matrix[:-1, -1]\n\n\ndef matrix_2_vector(\n    matrix: np.ndarray,\n    convention: OrientationConvention = OrientationConvention.EULER_ZYX,\n) -> np.ndarray:\n    """"""Convert 4x4 matrix to a vector.""""""\n    # call function\n    try:\n        return globals()[f""_matrix_2_{convention.name.lower()}""](matrix)\n    except KeyError:  # pragma: no cover\n        raise NotImplementedError\n\n\ndef _matrix_2_euler_zyx(matrix: np.ndarray) -> np.ndarray:\n    """"""\n    Calculate the equivalent position and euler angles of the given pose.\n\n    From: Craig, John J. Introduction to robotics: mechanics and control, 2005\n    :param matrix: 4x4 transform matrix\n    :return: transform vector\n    """"""\n    # solution degenerates near ry = +/- 90deg\n    sb = -matrix[2, 0]\n    cb = np.sqrt(matrix[0, 0] ** 2 + matrix[1, 0] ** 2)\n\n    if np.isclose(cb, 0):\n        a = 0.0\n        b = np.sign(sb) * np.pi / 2\n\n        sc = matrix[0, 1]\n        cc = matrix[1, 1]\n        c = np.sign(sb) * np.arctan2(sc, cc)\n    else:\n        b = np.arctan2(sb, cb)\n\n        sa = matrix[1, 0] / cb\n        ca = matrix[0, 0] / cb\n        a = np.arctan2(sa, ca)\n\n        sc = matrix[2, 1] / cb\n        cc = matrix[2, 2] / cb\n        c = np.arctan2(sc, cc)\n\n    vector = np.hstack((matrix[:-1, -1], [a, b, c]))\n    return vector\n\n\ndef wrap_2_pi(angle: float) -> float:\n    """"""\n    Wrap given angle to +/- PI.\n\n    :param angle: angle to wrap\n    :return: wrapped angle\n    """"""\n    # FIXME: remove float() cast when numpy is supported in mypy\n    result = float((angle + np.pi) % (2 * np.pi) - np.pi)\n    return result\n\n\ndef rotation_matrix_x(angle: float) -> np.ndarray:\n    """"""Generate a basic 4x4 rotation matrix about the X axis.""""""\n    s = np.sin(angle)\n    c = np.cos(angle)\n\n    matrix = np.array([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]).reshape((4, 4))\n\n    return matrix\n\n\ndef rotation_matrix_y(angle: float) -> np.ndarray:\n    """"""Generate a basic 4x4 rotation matrix about the Y axis.""""""\n    s = np.sin(angle)\n    c = np.cos(angle)\n\n    matrix = np.array([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]).reshape((4, 4))\n\n    return matrix\n\n\ndef rotation_matrix_z(angle: float) -> np.ndarray:\n    """"""Generate a basic 4x4 rotation matrix about the Z axis.""""""\n    s = np.sin(angle)\n    c = np.cos(angle)\n\n    matrix = np.array([c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]).reshape((4, 4))\n\n    return matrix\n\n\ndef translation_matrix(xyz: Sequence[float]) -> np.ndarray:\n    """"""Generate a basic 4x4 translation matrix.""""""\n    # validate\n    if len(xyz) != 3:\n        raise PyboticsError(""len(xyz) must be 3"")\n\n    matrix = np.eye(4)\n    matrix[:-1, -1] = xyz\n\n    return matrix\n'"
pybotics/json_encoder.py,3,"b'""""""JSON Encoder for Pybotics classes.""""""\nimport json\nfrom typing import Any\n\nimport numpy as np  # type: ignore\n\n\nclass JSONEncoder(json.JSONEncoder):\n    """"""Pybotics JSON Encoder class.""""""\n\n    def default(self, o: Any) -> Any:  # pragma: no cover\n        """"""Return serializable robot objects.""""""\n        # TODO: use @overload to split function\n        # BODY: Reduces cyclomatic complexity; but requires NumPy typing\n        if isinstance(o, np.ndarray):\n            return o.tolist()\n        elif isinstance(o, np.random.RandomState):\n            return None\n        elif isinstance(o, np.generic):\n            return str(o)\n        else:\n            try:\n                o = o.__dict__\n            except AttributeError:\n                pass\n            else:\n                return o\n\n        # let the base class default method raise the TypeError\n        # https://docs.python.org/3/library/json.html\n        return json.JSONEncoder.default(self, o)\n'"
pybotics/kinematic_chain.py,15,"b'""""""Kinematic chain module.""""""\nimport logging\nfrom abc import abstractmethod\nfrom typing import Any, Optional, Sequence, Sized, Union\n\nimport attr\nimport numpy as np  # type: ignore\n\nfrom pybotics.errors import PyboticsError\nfrom pybotics.json_encoder import JSONEncoder\nfrom pybotics.link import Link, MDHLink, RevoluteMDHLink\n\n# set logging\nlogger = logging.getLogger(__name__)\n\n\n@attr.s\nclass KinematicChain(Sized):\n    """"""\n    An assembly of rigid bodies connected by joints.\n\n    Provides constrained (or desired) motion that is the\n    mathematical model for a mechanical system.\n    """"""\n\n    def to_json(self) -> str:\n        """"""Encode model as JSON.""""""\n        encoder = JSONEncoder(sort_keys=True)\n        return encoder.encode(self)\n\n    @property  # type: ignore\n    @abstractmethod\n    def matrix(self) -> np.ndarray:\n        """"""\n        Convert chain to matrix of link parameters.\n\n        Rows = links\n        Columns = parameters\n        """"""\n        raise NotImplementedError\n\n    @matrix.setter  # type: ignore\n    @abstractmethod\n    def matrix(self, value: np.ndarray) -> None:\n        """"""\n        Set to matrix of link parameters.\n\n        Rows = links\n        Columns = parameters\n        """"""\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def links(self) -> Sequence[Link]:\n        """"""Get links.""""""\n        raise NotImplementedError\n\n    @property\n    def ndof(self) -> int:\n        """"""\n        Get number of degrees of freedom.\n\n        :return: number of degrees of freedom\n        """"""\n        return len(self)\n\n    @property\n    def num_parameters(self) -> int:\n        """"""Get number of parameters of all links.""""""\n        # noinspection PyProtectedMember\n        raise NotImplementedError\n\n    @abstractmethod\n    def transforms(self, q: Optional[Sequence[float]] = None) -> Sequence[np.ndarray]:\n        """"""\n        Generate a sequence of spatial transforms.\n\n        The sequence represents the given position of the kinematic chain.\n        :param q: given position of kinematic chain\n        :return: sequence of transforms\n        """"""\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def vector(self) -> np.ndarray:\n        """"""\n        Get the vector representation of the kinematic chain.\n\n        :return: vectorized kinematic chain\n        """"""\n        raise NotImplementedError\n\n    @vector.setter\n    def vector(self, value: Sequence[float]) -> None:\n        """"""Set parameters of all links.""""""\n        raise NotImplementedError\n\n\ndef _validate_links(value: Union[Sequence[MDHLink], np.ndarray]) -> Sequence[MDHLink]:\n    if isinstance(value, np.ndarray):\n        try:\n            value = value.reshape((-1, MDHLink._size))\n        except ValueError as e:\n            logger.error(str(e))\n            raise PyboticsError(f""MDH links have {MDHLink.size} parameters per link."")\n\n        # FIXME: only assumes revolute joints\n        value = [RevoluteMDHLink(*x) for x in value]\n    return value\n\n\n@attr.s\nclass MDHKinematicChain(KinematicChain):\n    """"""Kinematic Chain of MDH links.""""""\n\n    _links = attr.ib(type=Union[Sequence[MDHLink], np.ndarray])\n\n    def __attrs_post_init__(self) -> None:\n        """"""Post-attrs initialization.""""""\n        self._links = _validate_links(self._links)\n\n    @classmethod\n    def from_parameters(cls: Any, parameters: Sequence[float]) -> Any:\n        """"""Construct Kinematic Chain from parameters.""""""\n        kc = cls(parameters)\n        return kc\n\n    @property\n    def matrix(self) -> np.ndarray:\n        """"""\n        Convert chain to matrix of link parameters.\n\n        Rows = links\n        Columns = parameters\n        """"""\n        return np.array([l.vector for l in self._links])\n\n    @matrix.setter\n    def matrix(self, value: np.ndarray) -> None:\n        """"""\n        Set matrix of link parameters.\n\n        Rows = links\n        Columns = parameters\n        """"""\n        for i, v in enumerate(value):\n            self.links[i].vector = v\n\n    @property\n    def links(self) -> Sequence[MDHLink]:\n        """"""Get links.""""""\n        x = self._links  # type: Sequence[MDHLink]\n        return x\n\n    @links.setter\n    def links(self, value: Union[Sequence[MDHLink], np.ndarray]) -> None:\n        """"""Set links.""""""\n        self._links = _validate_links(value)\n\n    def __len__(self) -> int:\n        """"""Get ndof.""""""\n        return len(self._links)\n\n    @property\n    def num_parameters(self) -> int:\n        """"""Get number of parameters of all links.""""""\n        # noinspection PyProtectedMember\n        return len(self) * MDHLink._size\n\n    def transforms(self, q: Optional[Sequence[float]] = None) -> Sequence[np.ndarray]:\n        """"""Get sequence of 4x4 transforms.""""""\n        q = np.zeros(len(self)) if q is None else q\n        transforms = [link.transform(p) for link, p in zip(self._links, q)]\n        return transforms\n\n    @property\n    def vector(self) -> np.ndarray:\n        """"""Get parameters of all links.""""""\n        return self.matrix.ravel()\n\n    # noinspection PyMethodOverriding\n    @vector.setter\n    def vector(self, value: Sequence[float]) -> None:\n        """"""Set parameters of all links.""""""\n        # noinspection PyProtectedMember\n        value = np.array(value).reshape((-1, MDHLink._size))\n        self.matrix = value\n'"
pybotics/link.py,16,"b'""""""Link module.""""""\nfrom abc import abstractmethod\nfrom collections import Sized\nfrom typing import Sequence, Union\n\nimport attr\nimport numpy as np  # type: ignore\n\nfrom pybotics.json_encoder import JSONEncoder\n\n\n@attr.s\nclass Link(Sized):\n    """"""Links: connected joints allowing relative motion of neighboring link.""""""\n\n    def to_json(self) -> str:\n        """"""Encode model as JSON.""""""\n        encoder = JSONEncoder(sort_keys=True)\n        return encoder.encode(self)\n\n    def __len__(self) -> int:\n        """"""Get number of parameters.""""""\n        return self.size\n\n    @abstractmethod\n    def displace(self, q: float) -> Union[Sequence[float], np.ndarray]:\n        """"""\n        Generate a vector of the new link state given a displacement.\n\n        :param q: given displacement\n        :return vector of new displacement state\n        """"""\n        raise NotImplementedError\n\n    @abstractmethod\n    def transform(self, q: float = 0) -> np.ndarray:\n        """"""\n        Generate a 4x4 transform matrix given a displacement.\n\n        :param q: given displacement\n        :return vector of new displacement state\n        """"""\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def vector(self) -> np.ndarray:\n        """"""\n        Return the vector representation of the link.\n\n        :return: vectorized kinematic chain\n        """"""\n        raise NotImplementedError\n\n    @property\n    @abstractmethod\n    def size(self) -> int:\n        """"""Get number of parameters.""""""\n        raise NotImplementedError\n\n\n@attr.s\nclass MDHLink(Link):\n    """"""\n    Link class that uses Modified DH parameters.\n\n    https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters\n    """"""\n\n    _size = 4\n    alpha = attr.ib(0, type=float)\n    a = attr.ib(0, type=float)\n    theta = attr.ib(0, type=float)\n    d = attr.ib(0, type=float)\n\n    @property\n    def size(self) -> int:\n        """"""Get number of parameters.""""""\n        return self._size\n\n    def transform(self, q: float = 0) -> np.ndarray:\n        """"""\n        Generate a 4x4 transform matrix with a displacement.\n\n        :param q: given displacement\n        :return vector of new displacement state\n        """"""\n        vector = self.displace(q)\n\n        alpha = vector[0]\n        a = vector[1]\n        theta = vector[2]\n        d = vector[3]\n\n        crx = np.cos(alpha)\n        srx = np.sin(alpha)\n        crz = np.cos(theta)\n        srz = np.sin(theta)\n\n        transform = np.array(\n            [\n                [crz, -srz, 0, a],\n                [crx * srz, crx * crz, -srx, -d * srx],\n                [srx * srz, crz * srx, crx, d * crx],\n                [0, 0, 0, 1],\n            ],\n            dtype=np.float64,\n        )\n\n        return transform\n\n    @property\n    def vector(self) -> np.ndarray:\n        """"""\n        Return the vector representation of the link.\n\n        :return: vectorized kinematic chain\n        """"""\n        return np.array([self.alpha, self.a, self.theta, self.d], dtype=float)\n\n    # noinspection PyMethodOverriding\n    @vector.setter\n    def vector(self, value: Sequence[float]) -> None:\n        """"""Set parameters.""""""\n        self.alpha = value[0]\n        self.a = value[1]\n        self.theta = value[2]\n        self.d = value[3]\n\n\n@attr.s\nclass RevoluteMDHLink(MDHLink):\n    """"""\n    Link class that uses Modified DH parameters for a revolute joint.\n\n    https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters\n    """"""\n\n    def displace(self, q: float = 0) -> Union[Sequence[float], np.ndarray]:\n        """"""\n        Generate a vector of the new link state given a displacement.\n\n        :param q: given displacement\n        :return vector of new displacement state\n        """"""\n        v = np.copy(self.vector)\n        v[2] += q\n        return v\n\n\n@attr.s\nclass PrismaticMDHLink(MDHLink):\n    """"""\n    Link class that uses Modified DH parameters for a revolute joint.\n\n    https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters\n    """"""\n\n    def displace(self, q: float = 0) -> Union[Sequence[float], np.ndarray]:\n        """"""\n        Generate a vector of the new link state given a displacement.\n\n        :param q: given displacement\n        :return vector of new displacement state\n        """"""\n        v = np.copy(self.vector)\n        v[3] += q\n        return v\n'"
pybotics/optimization.py,20,"b'""""""Optimization module.\n\nisort:skip_file\n""""""\nfrom copy import deepcopy\nfrom itertools import repeat\nfrom typing import Sequence, Union\n\nimport attr\nimport numpy as np  # type: ignore\n\nfrom pybotics.robot import Robot\nfrom pybotics.errors import PyboticsError\nfrom pybotics.geometry import matrix_2_vector, position_from_matrix, vector_2_matrix\n\n\ndef _validate_transform_mask(\n    mask: Union[bool, Sequence[bool]], name: str, size: int\n) -> Sequence[bool]:\n    """"""Validate mask arguments.""""""\n    # validate input\n    if isinstance(mask, bool):\n        return [mask] * size\n    elif len(mask) != size:\n        raise PyboticsError(f""{name} must be of length {size}"")\n    else:\n        return mask\n\n\n@attr.s\nclass OptimizationHandler:\n    """"""Handler for optimization tasks.""""""\n\n    robot = attr.ib(type=Robot)\n    kinematic_chain_mask = attr.ib(False, type=Union[bool, Sequence[bool]])\n    tool_mask = attr.ib(False, type=Union[bool, Sequence[bool]])\n    world_mask = attr.ib(False, type=Union[bool, Sequence[bool]])\n\n    def __attrs_post_init__(self) -> None:\n        """"""Post-init handler.""""""\n        self.world_mask = _validate_transform_mask(\n            mask=self.world_mask, name=""world_mask"", size=6\n        )\n        self.tool_mask = _validate_transform_mask(\n            mask=self.tool_mask, name=""tool_mask"", size=6\n        )\n        self.robot = deepcopy(self.robot)\n        self.kinematic_chain_mask = _validate_transform_mask(\n            mask=self.kinematic_chain_mask,\n            name=""kinematic_chain_mask"",\n            size=self.robot.kinematic_chain.num_parameters,\n        )\n\n    def apply_optimization_vector(self, vector: np.ndarray) -> None:\n        """"""Apply vector.""""""\n        # get number of parameters\n        num_kc_parameters = np.sum(self.kinematic_chain_mask)\n        num_tool_parameters = np.sum(self.tool_mask)\n\n        # extract vector segments\n        segments = np.split(\n            vector, [num_kc_parameters, num_kc_parameters + num_tool_parameters]\n        )\n        kc_segment = segments[0]\n        tool_segment = segments[1]\n        world_segment = segments[2]\n\n        # update vectors\n        kc_vector = self.robot.kinematic_chain.vector\n        kc_vector[self.kinematic_chain_mask] = kc_segment\n        self.robot.kinematic_chain.vector = kc_vector\n\n        tool_vector = self.robot.tool.vector\n        tool_vector[self.tool_mask] = tool_segment\n        self.robot.tool.vector = tool_vector\n\n        world_vector = matrix_2_vector(self.robot.world_frame)\n        world_vector[self.world_mask] = world_segment\n        self.robot.world_frame = vector_2_matrix(world_vector)\n\n    def generate_optimization_vector(self) -> np.ndarray:\n        """"""Generate vector.""""""\n        kc_vector = np.compress(\n            self.kinematic_chain_mask, self.robot.kinematic_chain.vector\n        )\n        tool_vector = np.compress(self.tool_mask, self.robot.tool.vector)\n        world_vector = np.compress(\n            self.world_mask, matrix_2_vector(self.robot.world_frame)\n        )\n        return np.hstack((kc_vector, tool_vector, world_vector))\n\n\ndef optimize_accuracy(\n    optimization_vector: np.ndarray,\n    handler: OptimizationHandler,\n    qs: Sequence[Sequence[float]],\n    positions: Sequence[Sequence[float]],\n) -> np.ndarray:\n    """"""Fitness function for accuracy optimization.""""""\n    handler.apply_optimization_vector(optimization_vector)\n    errors = compute_absolute_errors(qs=qs, positions=positions, robot=handler.robot)\n    return errors\n\n\ndef compute_absolute_error(q: np.ndarray, position: np.ndarray, robot: Robot) -> float:\n    """"""Compute the absolute error of a given position.""""""\n    pose = robot.fk(q)\n    actual_position = position_from_matrix(pose)\n    error = position - actual_position\n    return float(np.linalg.norm(error))\n\n\ndef compute_absolute_errors(\n    qs: np.ndarray, positions: np.ndarray, robot: Robot\n) -> np.ndarray:\n    """"""\n    Compute the absolute errors of a given set of positions.\n\n    :param qs: Array of joints, shape=(n-poses, n-dof) [rad]\n    :param positions: Array of Cartesian positions, shape=(n-poses, 3)\n    :param robot: Robot model\n    """"""\n    return list(map(compute_absolute_error, qs, positions, repeat(robot)))\n\n\ndef compute_relative_error(\n    q_a: np.ndarray, q_b: np.ndarray, distance: float, robot: Robot\n) -> float:\n    """"""Compute the relative error of a given position combination.""""""\n    pose_a = robot.fk(q_a)\n    pose_b = robot.fk(q_b)\n\n    actual_position_a = position_from_matrix(pose_a)\n    actual_position_b = position_from_matrix(pose_b)\n\n    actual_distance = actual_position_a - actual_position_b\n    actual_distance = np.linalg.norm(actual_distance)\n\n    error = float(np.linalg.norm(distance - actual_distance))\n\n    return error\n\n\ndef compute_relative_errors(\n    qs_a: np.ndarray, qs_b: np.ndarray, distances: np.ndarray, robot: Robot\n) -> np.array:\n    """"""Compute the relative errors of a given set of position combinations.""""""\n    return list(map(compute_relative_error, qs_a, qs_b, distances, repeat(robot)))\n'"
pybotics/predefined_models.py,24,"b'""""""Predefined robot models.""""""\nimport numpy as np  # type: ignore\n\n\ndef kuka_lbr_iiwa_7() -> np.ndarray:  # pragma: no cover\n    """"""Get KUKA LBR iiwa 7 MDH model.""""""\n    return np.array(\n        [\n            [0, 0, 0, 340],\n            [-np.pi / 2, 0, 0, 0],\n            [np.pi / 2, 0, 0, 400],\n            [np.pi / 2, 0, 0, 0],\n            [-np.pi / 2, 0, 0, 400],\n            [-np.pi / 2, 0, 0, 0],\n            [np.pi / 2, 0, 0, 126],\n        ]\n    )\n\n\ndef mecademic_meca500() -> np.ndarray:  # pragma: no cover\n    """"""Get Meca500 MDH model.""""""\n    return np.array(\n        [\n            [0, 0, 0, 135],\n            [-np.pi / 2, 0, -np.pi / 2, 0],\n            [0, 135, 0, 0],\n            [-np.pi / 2, 38, 0, 120],\n            [np.pi / 2, 0, 0, 0],\n            [-np.pi / 2, 0, np.pi, 72],\n        ]\n    )\n\n\ndef puma560() -> np.ndarray:  # pragma: no cover\n    """"""Get PUMA560 MDH model.""""""\n    return np.array(\n        [\n            [0, 0, 0, 0],\n            [-np.pi / 2, 0, 0, 0],\n            [0, 612.7, 0, 0],\n            [0, 571.6, 0, 163.9],\n            [-np.pi / 2, 0, 0, 115.7],\n            [np.pi / 2, 0, np.pi, 92.2],\n        ]\n    )\n\n\ndef ur10() -> np.ndarray:  # pragma: no cover\n    """"""Get UR10 MDH model.""""""\n    return np.array(\n        [\n            [0, 0, 0, 118],\n            [np.pi / 2, 0, np.pi, 0],\n            [0, 612.7, 0, 0],\n            [0, 571.6, 0, 163.9],\n            [-np.pi / 2, 0, 0, 115.7],\n            [np.pi / 2, 0, np.pi, 92.2],\n        ]\n    )\n'"
pybotics/robot.py,38,"b'""""""Robot module.""""""\nfrom typing import Any, Optional, Sequence, Sized, Union\n\nimport attr\nimport numpy as np  # type: ignore\nimport scipy.optimize  # type: ignore\n\nfrom pybotics.errors import PyboticsError\nfrom pybotics.json_encoder import JSONEncoder\nfrom pybotics.kinematic_chain import KinematicChain, MDHKinematicChain\nfrom pybotics.tool import Tool\n\n\ndef _ndof_zeros_factory(robot: Any) -> np.ndarray:\n    return np.zeros(len(robot.kinematic_chain))\n\n\ndef _joint_limits_factory(robot: Any) -> np.ndarray:\n    return np.repeat((-np.pi, np.pi), len(robot.kinematic_chain)).reshape((2, -1))\n\n\n@attr.s\nclass Robot(Sized):\n    """"""Robot manipulator class.""""""\n\n    kinematic_chain = attr.ib(type=KinematicChain)\n    tool = attr.ib(factory=lambda: Tool(), type=Tool)\n    world_frame = attr.ib(factory=lambda: np.eye(4), type=np.ndarray)  # type: ignore\n    random_state = attr.ib(\n        factory=lambda: np.random.RandomState(),  # type: ignore\n        type=np.random.RandomState,\n    )\n    home_position = attr.ib(\n        default=attr.Factory(factory=_ndof_zeros_factory, takes_self=True),\n        type=np.ndarray,\n    )\n    _joints = attr.ib(\n        default=attr.Factory(factory=_ndof_zeros_factory, takes_self=True),\n        type=np.ndarray,\n    )\n    _joint_limits = attr.ib(\n        default=attr.Factory(factory=_joint_limits_factory, takes_self=True),\n        type=np.ndarray,\n    )\n\n    def __len__(self) -> int:\n        """"""\n        Get the number of degrees of freedom.\n\n        :return: number of degrees of freedom\n        """"""\n        return len(self.kinematic_chain)\n\n    def to_json(self) -> str:\n        """"""Encode robot model as JSON.""""""\n        encoder = JSONEncoder(sort_keys=True)\n        return encoder.encode(self)\n\n    def fk(self, q: Optional[Sequence[float]] = None) -> np.ndarray:\n        """"""\n        Compute the forward kinematics of a given position.\n\n        Uses the current position if None is given.\n        :param q:\n        :return: 4x4 transform matrix of the FK pose\n        """"""\n        # validate\n        q = self.joints if q is None else q\n\n        # gather transforms\n        # noinspection PyListCreation\n        transforms = []\n        transforms.append(self.world_frame)\n        transforms.extend(self.kinematic_chain.transforms(q))\n        transforms.append(self.tool.matrix)\n\n        # matrix multiply through transforms\n        pose = np.eye(4, dtype=float)\n        for t in transforms:\n            pose = np.dot(pose, t)\n\n        return pose\n\n    def ik(\n        self, pose: np.ndarray, q: Optional[Sequence[float]] = None\n    ) -> Optional[np.ndarray]:\n        """"""Solve the inverse kinematics.""""""\n        x0 = self.joints if q is None else q\n        result = scipy.optimize.least_squares(\n            fun=_ik_cost_function, x0=x0, bounds=self.joint_limits, args=(pose, self)\n        )  # type: scipy.optimize.OptimizeResult\n\n        if result.success:  # pragma: no cover\n            actual_pose = self.fk(result.x)\n            if np.allclose(actual_pose, pose, atol=1e-3):\n                return result.x\n        return None\n\n    @property\n    def ndof(self) -> int:\n        """"""\n        Get the number of degrees of freedom.\n\n        :return: number of degrees of freedom\n        """"""\n        return len(self)\n\n    @property\n    def joints(self) -> Union[Sequence[float], np.ndarray]:\n        """"""\n        Get the robot configuration (e.g., joint positions for serial robot).\n\n        :return: robot position\n        """"""\n        return self._joints\n\n    @joints.setter\n    def joints(self, value: np.ndarray) -> None:\n        """"""Set joints.""""""\n        if np.any(value < self.joint_limits[0]) or np.any(value > self.joint_limits[1]):\n            raise PyboticsError(""Joint limits exceeded."")\n        self._joints = value\n\n    @property\n    def joint_limits(self) -> np.ndarray:\n        """"""\n        Limits of the robot position (e.g., joint limits).\n\n        :return: limits with shape (2,num_dof) where first row is upper limits\n        """"""\n        return self._joint_limits\n\n    @joint_limits.setter\n    def joint_limits(self, value: np.ndarray) -> None:\n        """"""Set joint limits.""""""\n        if value.shape[0] != 2 or value.shape[1] != len(self):\n            raise PyboticsError(f""position_limits must have shape=(2,{len(self)})"")\n        self._joint_limits = value\n\n    def jacobian_world(self, q: Optional[Sequence[float]] = None) -> np.ndarray:\n        """"""Calculate the Jacobian wrt the world frame.""""""\n        q = self.joints if q is None else q\n        j_fl = self.jacobian_flange(q)\n        pose = self.fk(q)\n        rotation = pose[:3, :3]\n        j_tr = np.zeros((6, 6), dtype=float)\n        j_tr[:3, :3] = rotation\n        j_tr[3:, 3:] = rotation\n        j_w = np.dot(j_tr, j_fl)\n\n        return j_w\n\n    def jacobian_flange(self, q: Optional[Sequence[float]] = None) -> np.ndarray:\n        """"""Calculate the Jacobian wrt the flange frame.""""""\n        q = self.joints if q is None else q\n\n        # init Cartesian jacobian (6-dof in space)\n        jacobian_flange = np.zeros((6, self.ndof))\n        current_transform = self.tool.matrix.copy()\n\n        for i in reversed(range(self.ndof)):\n            d = np.array(\n                [\n                    -current_transform[0, 0] * current_transform[1, 3]\n                    + current_transform[1, 0] * current_transform[0, 3],\n                    -current_transform[0, 1] * current_transform[1, 3]\n                    + current_transform[1, 1] * current_transform[0, 3],\n                    -current_transform[0, 2] * current_transform[1, 3]\n                    + current_transform[1, 2] * current_transform[0, 3],\n                ]\n            )\n            delta = current_transform[2, 0:3]\n\n            jacobian_flange[:, i] = np.hstack((d, delta))\n\n            current_link = self.kinematic_chain.links[i]\n            p = q[i]\n            current_link_transform = current_link.transform(p)\n            current_transform = np.dot(current_link_transform, current_transform)\n\n        return jacobian_flange\n\n    def compute_joint_torques(\n        self, wrench: Sequence[float], q: Optional[Sequence[float]] = None\n    ) -> np.ndarray:\n        """"""\n        Calculate the joint torques due to external flange force.\n\n        Method from:\n        5.9 STATIC FORCES IN MANIPULATORS\n        Craig, John J. Introduction to robotics: mechanics and control.\n        Vol. 3. Upper Saddle River: Pearson Prentice Hall, 2005.\n        :param wrench:\n        :param q:\n        :return:\n        """"""\n        if q is None:\n            q = self.joints\n\n        # split wrench into components\n        force = wrench[:3]\n        moment = wrench[-3:]\n\n        # init output\n        joint_torques = [moment[-1]]\n\n        # loop through links from flange to base\n        # each iteration calculates for link i-1\n        for i, p in reversed(list(enumerate(q))):  # pragma: no cover\n            if i == 0:\n                break\n\n            # get current link transform\n            transform = self.kinematic_chain.links[i].transform(p)\n\n            # calculate force applied to current link\n            rotation = transform[:3, :3]\n            force = np.dot(rotation, force)\n\n            # calculate moment applied to current link\n            q = transform[:3, -1]\n            moment = np.dot(rotation, moment) + np.cross(q, force)\n\n            # append z-component as joint torque\n            joint_torques.append(moment[-1])\n\n        # reverse torques into correct order\n        return np.array(list(reversed(joint_torques)), dtype=float)\n\n    def clamp_joints(self, q: Sequence[float]) -> Optional[np.ndarray]:\n        """"""Limit joints to joint limits.""""""\n        return np.clip(q, self.joint_limits[0], self.joint_limits[1])\n\n    def random_joints(self, in_place: bool = False) -> Optional[np.ndarray]:\n        """"""Generate random joints within limits.""""""\n        q = self.random_state.uniform(\n            low=self.joint_limits[0], high=self.joint_limits[1]\n        )\n\n        if in_place:\n            self.joints = q\n            return None\n        else:\n            return q\n\n    @classmethod\n    def from_parameters(cls, parameters: Sequence[float]) -> Sized:\n        """"""Construct Robot from Kinematic Chain parameters.""""""\n        # FIXME: assumes MDH revolute robot\n        kc = MDHKinematicChain.from_parameters(parameters)\n        return cls(kinematic_chain=kc)\n\n\ndef _ik_cost_function(q: np.ndarray, pose: np.ndarray, robot: Robot) -> np.ndarray:\n    actual_pose = robot.fk(q)\n    diff = np.abs(actual_pose - pose)\n    return diff.ravel()\n'"
pybotics/tool.py,4,"b'""""""Tool module.\n\nisort:skip_file\n""""""\nfrom typing import Sequence, Union\n\nimport attr\nimport numpy as np  # type: ignore\n\nfrom pybotics.geometry import matrix_2_vector, position_from_matrix, vector_2_matrix\n\n\n@attr.s\nclass Tool:\n    """"""Tool class.""""""\n\n    matrix = attr.ib(factory=lambda: np.eye(4), type=np.ndarray)  # type: ignore\n    mass = attr.ib(0, type=float)\n    cg = attr.ib(factory=lambda: np.zeros(3), type=np.ndarray)  # type: ignore\n\n    @property\n    def position(self) -> Union[Sequence[float], np.ndarray]:\n        """"""\n        Get the position XYZ of the frame.\n\n        :return:\n        """"""\n        return position_from_matrix(self.matrix)\n\n    @position.setter\n    def position(self, value: Sequence[float]) -> None:\n        self.matrix[:-1, -1] = value\n\n    @property\n    def vector(self) -> np.ndarray:\n        """"""\n        Return the vector representation of the frame as EULER ZYX.\n\n        :return: vectorized frame\n        """"""\n        return matrix_2_vector(self.matrix)\n\n    @vector.setter\n    def vector(self, value: Sequence[float]) -> None:\n        self.matrix = vector_2_matrix(value)\n'"
tests/conftest.py,2,"b'""""""Pytest config.""""""\nfrom pathlib import Path\n\nimport numpy as np\nfrom pytest import fixture\n\nfrom pybotics.kinematic_chain import MDHKinematicChain\nfrom pybotics.robot import Robot\n\n\n@fixture()\ndef planar_robot():\n    """"""Generate planar robot.""""""\n    return Robot(\n        MDHKinematicChain(np.array([[0, 0, 0, 0], [0, 10, 0, 0], [0, 20, 0, 0]]))\n    )\n\n\n@fixture()\ndef resources_path():\n    """"""Get resources path.""""""\n    return (Path(__file__).parent / ""resources"").resolve()\n\n\n@fixture()\ndef vector_transforms(resources_path: Path):\n    """"""Get resource data.""""""\n    data = np.genfromtxt(\n        fname=resources_path / ""vector-transforms.csv"", delimiter="","", dtype=str\n    )\n    return [\n        {\n            ""vector"": d[:6].astype(float),\n            ""transform"": d[6:-1].astype(float),\n            ""order"": d[-1],\n        }\n        for d in data\n    ]\n'"
tests/test_errors.py,0,"b'""""""Test errors.""""""\n\nfrom pytest import raises\n\nfrom pybotics.errors import PyboticsError\n\n\ndef test_errors():\n    """"""\n    Test error.\n\n    :return:\n    """"""\n    with raises(PyboticsError):\n        raise PyboticsError()\n\n    assert str(PyboticsError()) == PyboticsError().message\n    assert str(PyboticsError(""test"")) == ""test""\n'"
tests/test_geometry.py,21,"b'""""""Test geometry.""""""\nfrom collections import Counter\nfrom pathlib import Path\nfrom typing import Sequence\n\nimport hypothesis.strategies as st\nimport numpy as np\nfrom hypothesis import given, settings\nfrom hypothesis.extra.numpy import arrays\nfrom pytest import raises\n\nimport pybotics.geometry\nfrom pybotics.errors import PyboticsError\nfrom pybotics.geometry import OrientationConvention, matrix_2_vector\n\n\n@given(st.floats(allow_nan=False, allow_infinity=False))\ndef test_wrap_2_pi(angle):\n    """"""\n    Test angle wrapping.\n\n    :return:\n    """"""\n    # hypothesis testing\n    assert -np.pi <= pybotics.geometry.wrap_2_pi(angle) < np.pi\n\n    # standard testing\n    angles = np.array(\n        [[0, 0], [-np.pi, -np.pi], [np.pi, -np.pi], [2 * np.pi, 0], [-2 * np.pi, 0]]\n    )\n\n    test_angles = angles[:, 0]\n    expected_angles = angles[:, 1]\n\n    actual_angles = np.array(list(map(pybotics.geometry.wrap_2_pi, test_angles)))\n    assert len(test_angles) == len(expected_angles)\n    assert len(actual_angles) == len(expected_angles)\n    np.testing.assert_allclose(actual_angles, expected_angles)\n\n    # test single elements\n    for i, _ in enumerate(expected_angles):\n        actual_angle = pybotics.geometry.wrap_2_pi(test_angles[i])\n        np.testing.assert_allclose([actual_angle], expected_angles[i])\n\n\n@given(angle=st.floats(allow_nan=False, allow_infinity=False))\n@settings(deadline=None)\ndef test_rotation_matrix_xyz(angle, resources_path: Path):\n    """"""Test.""""""\n    # define functions to test\n    rotation_functions = {\n        ""x"": pybotics.geometry.rotation_matrix_x,\n        ""y"": pybotics.geometry.rotation_matrix_y,\n        ""z"": pybotics.geometry.rotation_matrix_z,\n    }\n\n    # iterate through rotation axes\n    for i, axis in enumerate(""xyz""):\n        # get resource file\n        path = resources_path / f""rot{axis}-transforms.csv""\n        data = np.loadtxt(str(path.resolve()), delimiter="","")\n        if data.ndim == 1:\n            data = np.expand_dims(data, axis=0)\n\n        # test resource transforms\n        for d in data:\n            actual_matrix = rotation_functions[axis](d[0])\n            np.testing.assert_allclose(\n                actual=actual_matrix, desired=d[1:].reshape((4, 4)), atol=1e-6\n            )\n\n        # test hypothesis transforms\n        actual_matrix = rotation_functions[axis](angle)\n\n        # check orthogonality\n        for row in actual_matrix:\n            # noinspection PyTypeChecker\n            np.testing.assert_allclose(np.linalg.norm(row), 1)\n\n        for column in actual_matrix.T:\n            # noinspection PyTypeChecker\n            np.testing.assert_allclose(np.linalg.norm(column), 1)\n\n        # check no translation\n        # noinspection PyTypeChecker\n        np.testing.assert_allclose(actual_matrix[:-1, -1], 0)\n\n        # check homogeneous matrix\n        # noinspection PyTypeChecker\n        np.testing.assert_allclose(actual_matrix[-1, :-1], 0)\n\n        # check unit vector location\n        # noinspection PyTypeChecker\n        np.testing.assert_allclose(actual_matrix[i, i], 1)\n\n\n@given(\n    arrays(\n        shape=(3,),\n        dtype=float,\n        elements=st.floats(allow_nan=False, allow_infinity=False),\n    )\n)\ndef test_translation_matrix(xyz):\n    """"""Test.""""""\n    matrix = pybotics.geometry.translation_matrix(xyz)\n\n    # check orthogonality\n    for row in matrix[:-1, :-1]:\n        # noinspection PyTypeChecker\n        np.testing.assert_allclose(np.linalg.norm(row), 1)\n\n    for column in matrix[:, :-1].T:\n        # noinspection PyTypeChecker\n        np.testing.assert_allclose(np.linalg.norm(column), 1)\n\n    # check translation\n    # noinspection PyTypeChecker\n    np.testing.assert_allclose(matrix[:-1, -1], xyz)\n\n    # check homogeneous matrix\n    # noinspection PyTypeChecker\n    np.testing.assert_allclose(matrix[-1, :-1], 0)\n\n    # test exception\n    with raises(PyboticsError):\n        pybotics.geometry.translation_matrix(np.zeros(10))\n\n\ndef test_vector_2_matrix(vector_transforms: Sequence[dict]):\n    """"""Test.""""""\n    # test regular usage\n    for d in vector_transforms:\n        for c in [d[""order""], OrientationConvention(d[""order""])]:\n            actual = pybotics.geometry.vector_2_matrix(d[""vector""], convention=c)\n            np.testing.assert_allclose(\n                actual=actual, desired=d[""transform""].reshape((4, 4)), atol=1e-6\n            )\n\n        # test exception\n        with raises(PyboticsError):\n            pybotics.geometry.vector_2_matrix(d[""vector""], convention=""foobar"")\n\n\ndef test_matrix_2_vector(vector_transforms: Sequence[dict]):\n    """"""Test.""""""\n    for d in vector_transforms:\n        for c in [\n            e\n            for e in OrientationConvention.__members__.values()\n            if d[""order""] == e.value\n        ]:\n            try:\n                actual_vector = matrix_2_vector(d[""transform""].reshape((4, 4)), c)\n            except NotImplementedError:\n                # TODO: implement other conversions\n                # don\'t fail for NotImplementedError\n                continue\n            np.testing.assert_allclose(\n                actual=actual_vector, desired=d[""vector""], atol=1e-6\n            )\n\n\ndef test_orientation():\n    """"""Test.""""""\n    # ensure order and name match\n    for e in list(OrientationConvention.__members__.values()):\n        name_order = e.name.split(""_"")[-1].lower()\n        assert name_order == e.value\n\n    # ensure that there are only two of each value (euler and fixed)\n    values = [e.value for e in OrientationConvention.__members__.values()]\n    counts = Counter(values).values()\n    assert all([v == 2 for v in counts])\n\n    # ensure only x,y,z are used\n    good_letters = set(""xyz"")\n    values = set([e.value for e in OrientationConvention.__members__.values()])\n    leftover_values = [x for x in values if set(x).difference(good_letters)]\n    assert not leftover_values\n'"
tests/test_kinematic_chain.py,2,"b'""""""Test.""""""\nimport numpy as np\nfrom pytest import raises\n\nfrom pybotics.errors import PyboticsError\nfrom pybotics.kinematic_chain import MDHKinematicChain\nfrom pybotics.link import MDHLink, RevoluteMDHLink\n\n\ndef test_init():\n    """"""Test.""""""\n    # test error\n    with raises(PyboticsError):\n        MDHKinematicChain(np.eye(5))\n\n    # test sequence of links\n    MDHKinematicChain([RevoluteMDHLink()])\n\n\ndef test_num_parameters():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    assert kc.num_parameters == MDHLink._size\n\n\ndef test_vector():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    np.testing.assert_allclose(kc.vector, link.vector)\n\n\ndef test_repr():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    repr(kc)\n\n\ndef test_to_json():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    kc.to_json()\n\n\ndef test_links_setter():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    kc.links = link\n\n\ndef test_ndof():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    kc = MDHKinematicChain([link])\n    assert kc.ndof == 1\n'"
tests/test_link.py,1,"b'""""""Test.""""""\nimport numpy as np\n\nfrom pybotics.link import PrismaticMDHLink, RevoluteMDHLink\n\n\ndef test_len():\n    """"""Test.""""""\n    assert len(RevoluteMDHLink()) == 4\n\n\ndef test_displace():\n    """"""Test.""""""\n    link = PrismaticMDHLink()\n    np.testing.assert_allclose(link.displace(), link.vector)\n\n\ndef test_repr():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    repr(link)\n\n\ndef test_json():\n    """"""Test.""""""\n    link = RevoluteMDHLink()\n    link.to_json()\n'"
tests/test_optimization.py,18,"b'""""""Test.\n\nisort:skip_file\n""""""\nimport hypothesis.strategies as st\nimport numpy as np\nimport scipy.optimize\nfrom hypothesis import given\nfrom hypothesis.extra.numpy import arrays\nfrom pytest import raises\n\nfrom pybotics.errors import PyboticsError\nfrom pybotics.optimization import (\n    OptimizationHandler,\n    compute_absolute_error,\n    compute_absolute_errors,\n    optimize_accuracy,\n    compute_relative_error,\n    compute_relative_errors,\n)\nfrom pybotics.predefined_models import ur10\nfrom pybotics.robot import Robot\n\n\n@given(\n    q=arrays(\n        shape=(len(ur10()),),\n        dtype=float,\n        elements=st.floats(allow_nan=False, allow_infinity=False),\n    )\n)\ndef test_compute_absolute_errors(q: np.ndarray):\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n    pose = robot.fk(q)\n    p = pose[:-1, -1]\n\n    # test 1D input\n    actual_error = compute_absolute_error(q=q, position=p, robot=robot)\n    np.testing.assert_allclose(actual_error, 0)\n\n    # test 2D input\n    actual_error = compute_absolute_errors(\n        qs=np.tile(q, (10, 1)), positions=np.tile(p, (10, 1)), robot=robot\n    )\n    np.testing.assert_allclose(actual_error, 0)\n\n\n@given(\n    q_a=arrays(\n        shape=(len(ur10()),),\n        dtype=float,\n        elements=st.floats(allow_nan=False, allow_infinity=False),\n    ),\n    q_b=arrays(\n        shape=(len(ur10()),),\n        dtype=float,\n        elements=st.floats(allow_nan=False, allow_infinity=False),\n    ),\n)\ndef test_compute_relative_errors(q_a: np.ndarray, q_b: np.ndarray):\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n\n    p_a = robot.fk(q_a)[:-1, -1]\n    p_b = robot.fk(q_b)[:-1, -1]\n    distance = np.linalg.norm(p_a - p_b)\n\n    # test 1D input\n    actual_error = compute_relative_error(\n        q_a=q_a, q_b=q_b, distance=distance, robot=robot\n    )\n    np.testing.assert_allclose(actual_error, 0)\n\n    # test 2D input\n    actual_error = compute_relative_errors(\n        qs_a=np.tile(q_a, (10, 1)),\n        qs_b=np.tile(q_b, (10, 1)),\n        distances=np.tile(distance, (10, 1)),\n        robot=robot,\n    )\n    np.testing.assert_allclose(actual_error, 0)\n\n\ndef test_optimization():\n    """"""Test.""""""\n    # init robot model and error wrt nominal\n    actual_robot = Robot.from_parameters(ur10())\n    actual_robot.tool.position = [0.1, 0, 0]\n    actual_robot.kinematic_chain.links[0].a += 0.1\n\n    # calculate fk\n    qs = np.tile(\n        np.linspace(start=-np.pi, stop=np.pi, num=100), (len(ur10()), 1)\n    ).transpose()\n\n    poses = np.array(list(map(actual_robot.fk, qs)))\n    positions = poses[:, :-1, -1]\n\n    # init handler\n    handler = OptimizationHandler(robot=Robot.from_parameters(ur10()))\n    handler.kinematic_chain_mask[1] = True\n    handler.tool_mask[0] = True\n\n    # run optimization\n    result = scipy.optimize.least_squares(\n        fun=optimize_accuracy,\n        x0=handler.generate_optimization_vector(),\n        args=(handler, qs, positions),\n        verbose=2,\n    )  # type: scipy.optimize.OptimizeResult\n\n    # validate\n    atol = 1e-2\n    np.testing.assert_allclose(\n        actual=result.x, desired=handler.generate_optimization_vector(), atol=atol\n    )\n    np.testing.assert_allclose(\n        actual=handler.robot.kinematic_chain.vector,\n        desired=actual_robot.kinematic_chain.vector,\n        atol=atol,\n    )\n    np.testing.assert_allclose(\n        actual=handler.robot.tool.vector, desired=actual_robot.tool.vector, atol=atol\n    )\n    np.testing.assert_allclose(\n        actual=handler.robot.world_frame, desired=actual_robot.world_frame, atol=atol\n    )\n\n\ndef test_handler_validate_transform_mask():\n    """"""Test.""""""\n    # test predesigned mask sequence\n    OptimizationHandler(robot=Robot.from_parameters(ur10()), tool_mask=[False] * 6)\n\n    # test error\n    with raises(PyboticsError):\n        OptimizationHandler(\n            robot=Robot.from_parameters(ur10()), kinematic_chain_mask=[False]\n        )\n'"
tests/test_robot.py,30,"b'""""""Test robot.""""""\nfrom pathlib import Path\n\nimport hypothesis\nimport numpy as np\nfrom hypothesis import given\nfrom hypothesis.extra.numpy import arrays\nfrom hypothesis.strategies import floats\nfrom pytest import raises\n\nfrom pybotics.errors import PyboticsError\nfrom pybotics.predefined_models import ur10\nfrom pybotics.robot import Robot\n\n\ndef test_fk(resources_path: Path):\n    """"""\n    Test robot.\n\n    :param robot:\n    :return:\n    """"""\n    # get resource\n    path = resources_path / ""ur10-joints-poses.csv""\n    data = np.loadtxt(str(path), delimiter="","")\n\n    # load robot\n    robot = Robot.from_parameters(ur10())\n\n    # test\n    for d in data:\n        n = robot.ndof\n        joints = np.deg2rad(d[:n])\n        desired_pose = d[n:].reshape((4, 4))\n\n        atol = 1e-3\n\n        # test with position argument\n        actual_pose = robot.fk(q=joints)\n        np.testing.assert_allclose(actual_pose, desired_pose, atol=atol)\n\n        # test with internal position attribute\n        robot.joints = joints\n        actual_pose = robot.fk()\n        np.testing.assert_allclose(actual_pose, desired_pose, atol=atol)\n\n\ndef test_home_position():\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n    x = np.ones(len(robot))\n    robot.home_position = x\n    np.testing.assert_allclose(robot.home_position, x)\n\n\ndef test_joint_limits():\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n\n    # test setter\n    robot.joint_limits = robot.joint_limits.copy()\n\n    # test errors\n    with raises(PyboticsError):\n        robot.joint_limits = np.zeros(1)\n\n    with raises(PyboticsError):\n        robot.joints = robot.joint_limits.copy()[1] + 10\n\n\ndef test_compute_joint_torques(planar_robot: Robot):\n    """"""\n    Test.\n\n    From EXAMPLE 5.7 of\n    Craig, John J. Introduction to robotics: mechanics and control.\n    Vol. 3. Upper Saddle River: Pearson Prentice Hall, 2005.\n    :return:\n    """"""\n    # set test force and angles\n    force = [-100, -200, 0]\n    moment = [0] * 3\n    wrench = force + moment\n    joint_angles = np.deg2rad([30, 60, 0])\n\n    # get link lengths\n    lengths = [\n        planar_robot.kinematic_chain.links[1].a,\n        planar_robot.kinematic_chain.links[2].a,\n    ]\n\n    # calculate expected torques\n    expected_torques = [\n        lengths[0] * np.sin(joint_angles[1]) * force[0]\n        + (lengths[1] + lengths[0] * np.cos(joint_angles[1])) * force[1],\n        lengths[1] * force[1],\n        0,\n    ]\n\n    # test\n    actual_torques = planar_robot.compute_joint_torques(q=joint_angles, wrench=wrench)\n    np.testing.assert_allclose(actual_torques, expected_torques)\n\n    planar_robot.joints = joint_angles\n    actual_torques = planar_robot.compute_joint_torques(wrench=wrench)\n    np.testing.assert_allclose(actual_torques, expected_torques)\n\n\n@given(\n    q=arrays(\n        shape=(3,),\n        dtype=float,\n        elements=floats(\n            max_value=1e9, min_value=-1e9, allow_nan=False, allow_infinity=False\n        ),\n    )\n)\ndef test_jacobian_world(q: np.ndarray, planar_robot: Robot):\n    """"""Test.""""""\n    # get link lengths\n    lengths = [\n        planar_robot.kinematic_chain.links[1].a,\n        planar_robot.kinematic_chain.links[2].a,\n    ]\n\n    # example from Craig has last joint set to 0\n    q[-1] = 0\n\n    s0 = np.sin(q[0])\n    c0 = np.cos(q[0])\n\n    s01 = np.sin(q[0] + q[1])\n    c01 = np.cos(q[0] + q[1])\n\n    expected = np.zeros((6, 3))\n    expected[0, 0] = -lengths[0] * s0 - lengths[1] * s01\n    expected[0, 1] = -lengths[1] * s01\n    expected[1, 0] = lengths[0] * c0 + lengths[1] * c01\n    expected[1, 1] = lengths[1] * c01\n    expected[-1, :] = 1\n\n    actual = planar_robot.jacobian_world(q)\n    np.testing.assert_allclose(actual, expected, atol=1e-3)\n\n\n@given(\n    q=arrays(\n        shape=(3,), dtype=float, elements=floats(allow_nan=False, allow_infinity=False)\n    )\n)\ndef test_jacobian_flange(q: np.ndarray, planar_robot: Robot):\n    """"""Test.""""""\n    # get link lengths\n    lengths = [\n        planar_robot.kinematic_chain.links[1].a,\n        planar_robot.kinematic_chain.links[2].a,\n    ]\n\n    # example from Craig has last joint set to 0\n    q[-1] = 0\n\n    s1 = np.sin(q[1])\n    c1 = np.cos(q[1])\n\n    expected = np.zeros((6, 3))\n    expected[0, 0] = lengths[0] * s1\n    expected[1, 0] = lengths[0] * c1 + lengths[1]\n    expected[1, 1] = lengths[1]\n    expected[-1, :] = 1\n\n    actual = planar_robot.jacobian_flange(q)\n    np.testing.assert_allclose(actual, expected, atol=1e-6)\n\n\n@given(\n    q=arrays(\n        shape=(len(ur10()),),\n        dtype=float,\n        elements=floats(\n            allow_nan=False, allow_infinity=False, max_value=np.pi, min_value=-np.pi\n        ),\n    ),\n    q_offset=arrays(\n        shape=(len(ur10()),),\n        dtype=float,\n        elements=floats(\n            allow_nan=False,\n            allow_infinity=False,\n            max_value=np.deg2rad(1),\n            min_value=np.deg2rad(-1),\n        ),\n    ),\n)\n@hypothesis.settings(deadline=None)\ndef test_ik(q: np.ndarray, q_offset: np.ndarray):\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n    pose = robot.fk(q)\n\n    # IK is hard to solve without a decent seed\n    q_actual = robot.ik(pose, q=robot.clamp_joints(q + q_offset))\n\n    if q_actual is None:\n        # ik couldn\'t be solved\n        # don\'t fail test\n        return\n\n    actual_pose = robot.fk(q_actual)\n\n    # test the matrix with lower accuracy\n    # rotation components are hard to achieve when x0 isn\'t good\n    np.testing.assert_allclose(actual_pose, pose, atol=1)\n\n    # test the position with higher accuracy\n    desired_position = pose[:-1, -1]\n    actual_position = actual_pose[:-1, -1]\n    np.testing.assert_allclose(actual_position, desired_position, atol=1e-1)\n\n\ndef test_random_joints():\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n    robot.random_joints()\n    robot.random_joints(in_place=True)\n\n\ndef test_to_json():\n    """"""Test.""""""\n    robot = Robot.from_parameters(ur10())\n    robot.to_json()\n'"
tests/test_tool.py,3,"b'""""""Test.""""""\nimport numpy as np\n\nfrom pybotics.geometry import matrix_2_vector\nfrom pybotics.tool import Tool\n\n\ndef test_tool():\n    """"""Test.""""""\n    tool = Tool()\n\n    cg = [1, 2, 3]\n    tool.cg = cg\n    np.testing.assert_allclose(tool.cg, cg)\n\n    p = [1, 2, 3]\n    tool.position = p\n    np.testing.assert_allclose(tool.position, p)\n    np.testing.assert_allclose(tool.vector, matrix_2_vector(tool.matrix))\n'"
