file_path,api_count,code
demoLambert.py,0,"b'from orbits.orbit import Orbit\nfrom examples import Earth, Mars, Sun\nfrom plot.plotlyManager import PlotManager3D\nimport numpy as np\nfrom tools.trajOpt import getC3\n\nif __name__ == \'__main__\':\n    initialShift = 500\n    Earth.Orbit.updTime(initialShift*3600*24)\n    Mars.Orbit.updTime(initialShift*3600*24)\n    pointDict = {   \'color\' : \'rgba(0,0,0,255)\',\n                    \'size\'  : 5}\n    orbitDict = {   \'color\' : \'rgba(100, 100, 100, 255)\',\n                    \'width\' : 2}\n    pltMgr = PlotManager3D(iterOrbit = 300,\n    iterAnim = 100, title = ""Earth -> Mars in 168 days"",\n    range = Mars.Orbit.getApoapsis()*1.5, pointBase = pointDict,\n    orbitBase = orbitDict, filename=""MarsTransfer.html"")\n\n    days = 168*5\n\n    pltMgr.addBody(Sun)\n    pltMgr.addOrbit(Earth.Orbit, paramDict = {\'color\' : \'blue\'})\n    pltMgr.addOrbit(Mars.Orbit, paramDict = {\'color\' : \'orange\'})\n    pltMgr.animPoint(Earth.Orbit, tAnStart=Earth.Orbit.tAn, time = 3600*24*days)\n    pltMgr.animPoint(Mars.Orbit, tAnStart=Mars.Orbit.tAn, time = 3600*24*days)\n\n\n    Mars.Orbit.updTime(3600*24*days)\n    transferOrbit = Orbit.fromLambert(Earth.Orbit.cartesianCoordinates(),\n                Mars.Orbit.cartesianCoordinates(), 3600*24*days, primBody=Sun, nRev=2,\n                    name=""Transfer Orbit {} days"".format(days))\n\n\n    tTrans1 = transferOrbit.tAn\n    tTrans2 = transferOrbit.tAnAtTime(3600*24*days)\n\n    pltMgr.addOrbit(transferOrbit, paramDict={\'color\' : \'green\'})\n    pltMgr.animPoint(transferOrbit, tAnStart=transferOrbit.tAn, time = 3600*24*days)\n    # print(getC3(Earth, Mars.Orbit.cartesianCoordinates(), days*3600*24))\n    pltMgr.show()\n'"
examples.py,6,"b'from tools.body import Body\nfrom orbits.orbit import Orbit\nimport numpy as np\n\nSun = Body(name=""Sun"",mu = 1.327124400*10**11, r = 695700)\n\n_earthOrbit = Orbit.fromElements(semiMajorAxis=149597887.1558,\neccentricity=0.01671022, inclination = np.radians(0.00005),\nlAn = np.radians(348.7394), primBody=Sun,\nargumentPeriapsis=np.radians(114.2078),\ntrueAnomaly=6.23837308813, name=""Earth Orbit"")\n\nEarth = Body(name=""Earth"", mu = 398600.4418, r = 6371,\nOrbit=_earthOrbit, primBody=Sun)\n\n_marsOrbit = Orbit.fromElements(semiMajorAxis=227936637.2418,\neccentricity=0.09341233, inclination = np.radians(1.85061),\nlAn = np.radians(49.57854), primBody=Sun,\nargumentPeriapsis=np.radians(286.4623),\ntrueAnomaly=0.40848952017, name=""Mars Orbit"")\n\nMars = Body(name=""Mars"", mu = 4.2828372854187757e+04, r = 3390, Orbit=_marsOrbit, primBody=Sun)\n'"
main.py,0,"b""from orbits.orbit import Orbit\nfrom examples import Earth, Mars, Sun\nimport numpy as np\nfrom tools.trajOpt import getPorkChop\nfrom plot.plotlyManager import PlotManager3D\n\nif __name__ == '__main__':\n    plt = PlotManager3D()\n"""
test_main.py,9,"b'import numpy as np\nfrom orbits.orbit import Orbit\nfrom examples import Earth, Sun\nfrom plot.plotlyManager import PlotManager3D\nfrom tools.utils import uLambert\n\nnTest = 100\n\n\npointDict = {   \'color\' : \'rgba(0,0,0,255)\',\n                \'size\'  : 5}\norbitDict = {   \'color\' : \'rgba(100, 100, 100, 255)\',\n                \'width\' : 2}\n\npltMgr = PlotManager3D(iterOrbit = 300,\niterAnim = 100, title = ""Lambert test"",\nrange = 1E6, pointBase = pointDict,\norbitBase = orbitDict, filename=""LambertTest.html"")\n\nfor j in range(nTest):\n    if j%100 == 0:\n        print(j)\n\n    hPa = np.random.uniform(low = 150, high = 100*10**4)\n    hPe = np.random.uniform(low = 150, high = 100*10**4)\n    i = np.random.uniform(low=0, high=np.pi)\n    aPe = np.random.uniform(high = 2*np.pi)\n    lAn = np.random.uniform(high = 2*np.pi)\n    tAn = np.random.uniform(high = 2*np.pi)\n\n    if hPe > hPa:\n        hPe, hPa = hPa, hPe\n\n    orbitTest = Orbit.fromApsis(hPe, hPa, inclination=i, argumentPeriapsis=aPe, lAn = lAn, trueAnomaly=tAn, name=""test orbit - {}"".format(j), primBody = Earth)\n\n    pltMgr.addOrbit(orbitTest)\n    # plt.plotOrbit(orbitTest.id)\n    #\n\n    r1 = orbitTest.cartesianCoordinates()\n\n    tof = np.random.uniform()*orbitTest.getPeriod()*0.1\n    # tof=3600*24\n    orbitTest.updTime(tof)\n\n    r2 = orbitTest.cartesianCoordinates()\n    try:\n        orbitComparison = Orbit.fromLambert(r1, r2, tof, primBody = Earth)\n    except:\n        print(""""""ERROR LAMBERT SOLVER\n        KEPLERIAN ELEMENTS INITIAL ORBIT:\n                hPa   - {}\n                hPe   - {}\n                i   - {}\n                aPe - {}\n                lAn - {}\n                tAn - {}\n                tof - {}"""""".format(hPa,hPe,i,aPe,lAn,tAn,tof))\n\n        continue\n    print(""""""COMPARISON OF KEPLERIAN ELEMENTS :\n            a   - {}\n            e   - {}\n            i   - {}\n            aPe - {}\n            lAn - {}\n            tAn - {}\n            """""".format(a-orbitComparison.a, e-orbitComparison.e, i-orbitComparison.i, aPe-orbitComparison.aPe, lAn-orbitComparison.lAn, tAn - orbitComparison.lAn))\npltMgr.show()\n\n# testOrbit = Orbit.fromLambert(np.array([5000,10000,2100]),np.array([-14600,2500,7000]),3600,primBody=Earth, name=""test"")\n# print(testOrbit.cartesianCoordinates())\n# testOrbit.updTime(3600)\n# print(testOrbit.cartesianCoordinates())\n# print(uLambert(np.array([-26503064.373261325, 144693278.60351047, 119.32162712262743]),np.array([208034201.40482172, -1959743.5511186407, -5158244.7539406745]), 300*3600*24, primBody=Sun))\n'"
orbits/__init__.py,0,b''
orbits/orbit.py,27,"b'import numpy as np\nfrom astropy.time import Time, TimeDelta\nfrom tools import utils\n\nclass OrbitalElements:\n    def __init__(self, a=None, e=0, i=0, lAn=0, tAn=0, primBody=None, aPe = 0, epoch=Time(\'2000-01-01\'),\n                name=None):\n        self._a = a #[0-inf] km\n        self._e = e #[0-1]\n        self._i = i\n        self._lAn = lAn\n        self._aPe = aPe #[0-359] deg\n        self._tAn = tAn #000\n        self._primBody = primBody\n        self._id = name\n        self._epoch = epoch\n\n    @property\n    def a(self):\n        return self._a\n\n    @a.setter\n    def a(self,SMA):\n        if SMA<=0:\n            raise ValueError(""Semi-Major Axis inferior or equal to zero"")\n        self._a = SMA\n\n    @property\n    def e(self):\n        return self._e\n\n    @e.setter\n    def e(self,eccentricity):\n        if 1<=eccentricity<0:\n            raise ValueError(""eccentricity not between 0 and 1"")\n        self._e = eccentricity\n\n    @property\n    def i(self):\n        return self._i\n\n    @i.setter\n    def i(self, value):\n        if value<0:\n            raise ValueError(""negative inclination"")\n        self._i = value%2*np.pi\n\n    @property\n    def lAn(self):\n        return self._lAn\n\n    @lAn.setter\n    def lAn(self, value):\n        if value<0:\n            raise ValueError(""negative longitude of the ascending node"")\n        self._lAn = value%2*np.pi\n\n    @property\n    def aPe(self):\n        return self._aPe\n\n    @aPe.setter\n    def aPe(self, value):\n        if value<0:\n            raise ValueError(""negative argument of perapsis"")\n        self._aPe = value%2*np.pi\n\n    @property\n    def tAn(self):\n        return self._tAn\n\n    @tAn.setter\n    def tAn(self, value):\n        if value<0:\n            raise ValueError(""negative true anomaly"")\n        self._tAn = value%(2*np.pi)\n\n    @property\n    def epoch(self):\n        return self._epoch\n\n    @epoch.setter\n    def epoch(self, value):\n        if not isinstance(value, Time):\n            raise TypeError(""The epoch should be an astropy Time object"")\n        self._epoch = value\n\n    @property\n    def primBody(self):\n        return self._primBody\n\n    @primBody.setter\n    def primBody(self,value):\n        if type(value) != dict:\n            raise TypeError(""The body should be a dict, check bodies.py for ref"")\n        self._primBody = value\n\n    @property\n    def id(self):\n        return self._id\n\n    @id.setter\n    def id(self, value):\n        if type(value) != str:\n            raise TypeError(""Name provided is not a string"")\n        self._id = value\n\n\n    def __str__(self):\n        return """"""\n            ID       - {}\n            primBody - {}\n\n            a    - {}\n            e    - {}\n            i    - {}\n            lAn  - {}\n            aPe  - {}\n            tAn  - {}\n\n            epoch - {}"""""".format(self.id, self.primBody.name, self.a, self.e, self.i, self.lAn, self.aPe, self.tAn, self.epoch)\n\nclass Orbit(OrbitalElements):\n    def __init__(self,  a = None, e=0, i=0, lAn=0, tAn=0, primBody=None, aPe = 0, epoch=Time(\'2000-01-01\'),\n                name=None):\n        OrbitalElements.__init__(self,  a, e, i, lAn, tAn, primBody, aPe, epoch,\n                    name)\n    @classmethod\n    def fromElements(cls, a=None, e = 0, i=0,\n                    lAn=0, primBody = None, aPe = 0,\n                    tAn = 0, refEpoch=Time(\'2000-01-01\'), name=None):\n        """"""\n        fromElements is callable from the class itself in order to create an\n        orbit from the classical Keplerian elements.\n        """"""\n\n        if a==None:\n            raise ValueError(""Semi-Major Axis required !"")\n\n        if name == None:\n            raise ValueError(""The orbit needs a name !"")\n\n        return cls(a=a, e=e, i=i, primBody=primBody, aPe=aPe, tAn=tAn, lAn=lAn, epoch=refEpoch, name=name)\n\n    @classmethod\n    def fromApsis(cls, periapsis, apoapsis, i=0, lAn=0,\n                    primBody = None, argumentPeriapsis = 0, trueAnomaly = 0, refEpoch=Time(\'2000-01-01\'),\n                    name=None):\n        """"""\n        fromApsis is to be called from the class itself as well, replaces the\n        need for SMA and eccentricity by Apoapsis and Periapss\n        """"""\n        if name == None:\n            raise ValueError(""The orbit needs a name !"")\n\n        a = (periapsis+apoapsis)/2\n        e = (apoapsis-periapsis)/(apoapsis+periapsis)\n\n        return cls(a=a, e=e, i=i, primBody=primBody, aPe=aPe, tAn=tAn, lAn=lAn, epoch=refEpoch, name=name)\n\n    @classmethod\n    def fromStateVector(cls, r1, v1, primBody = None, refEpoch=Time(\'2000-01-01\'),\n                    name=None):\n        """"""\n        fromStateVector determines orbital parameters based on position & velocity vectors\n\n        the reference epoch is associated with the state vector\n        """"""\n        if name == None:\n            raise ValueError(""The orbit needs a name !"")\n\n        mu = primBody.mu\n\n        r = np.linalg.norm(r1)\n        v = np.linalg.norm(v1)\n\n        vr = np.dot(r1,v1)/r\n        h = np.cross(r1,v1)\n        hMag = np.linalg.norm(h)\n\n        i = np.arccos(h[2]/hMag)\n\n        N = np.cross([0,0,1], h)\n        NMag = np.linalg.norm(N)\n\n        lAn = np.arccos(N[0]/NMag)\n        if N[1]<0:\n            lAn = 2*np.pi - lAn\n\n        e = 1/mu*((v**2-mu/r)*r1-r*vr*v1)\n        eMag = np.linalg.norm(e)\n\n        if eMag < 0 or eMag >= 1:\n            raise ValueError(""e = ""+str(eMag)+"", not an ellipse"")\n\n        aPe = np.arccos(np.dot(N/NMag, e/eMag))\n        if e[2] < 0 :\n            aPe = 2*np.pi - aPe\n\n        tAn = np.arccos(1/eMag*((hMag**2/(mu*r))-1))\n        if vr < 0:\n            tAn = 2*np.pi-tAn\n\n        SMA = -(mu/(2*(v**2/2 - mu/r)))\n        return cls(a=SMA, e=eMag, i=i, primBody=primBody, aPe=aPe, tAn=tAn, lAn=lAn, epoch=refEpoch, name=name)\n\n    @classmethod\n    def fromLambert(cls,r1,r2,t, DM=None, nRev=0, primBody = None, refEpoch=Time(\'2000-01-01\'),name=None):\n        """"""\n        fromLambert solves the lambert problem and use the first state vector\n        returned to determine orbital parameters\n        """"""\n        try:\n            r1,v1,_,_ = utils.uLambert(r1,r2,t,primBody,nRev=nRev, DM=DM)\n        except RuntimeWarning:\n            print(""ERROR : Runtime warning detected, incorrect values ?"")\n            return None\n        return Orbit.fromStateVector(r1, v1, primBody, refEpoch, name)\n\n    def getRadius(self,trueAnomaly):\n        return (self.a*(1-self.e**2))/(1+self.e*np.cos(trueAnomaly))\n\n    def currentAltitude(self):\n        return self.getRadius(self.tAn)\n\n    def altitudeFromRadius(self,radius):\n        alt = radius-self.primBody.r\n        if alt < 0:\n            raise ValueError(""Altitude smaller than zero !"")\n        return alt\n\n    def getApoapsis(self):\n        apAngle = (self.aPe + 180)%(2*np.pi)\n        return self.getRadius(apAngle)\n\n    def getPeriapsis(self):\n        return self.getRadius(self.aPe)\n\n    def getPeriod(self):\n        return (2*np.pi)*np.sqrt(self.a**3/self.primBody.mu)\n\n    def getMeanMotion(self):\n        return ((2*np.pi)/(self.getPeriod()))\n\n    def tAnAtTime(self, sec):\n        actualMe = utils.trueToMean(self.tAn, self.e)\n        updMe = actualMe+self.getMeanMotion()*sec\n        updtAn = utils.meanToTrue(updMe, self.e)\n        return updtAn\n\n    def updTime(self, sec):\n        updtAn = self.tAnAtTime(sec)\n        self.tAn = updtAn\n\n    def isCrashing(self):\n        try:\n            altPe = self.altitudeFromRadius(self.getPeriapsis())\n        except ValueError:\n            return True\n        return False\n\n    def cartesianCoordinates(self, trueAnomaly=None):\n        lAn = self.lAn\n        aPe = self.aPe\n\n        if trueAnomaly == None:\n            tAn = self.tAn\n        else:\n            tAn = trueAnomaly\n\n        i = self.i\n        r = self.getRadius(tAn)\n\n        x = r * ( np.cos(lAn)*np.cos(aPe+tAn) - np.sin(lAn)*np.sin(aPe+tAn)*np.cos(i))\n        y = r * ( np.sin(lAn)*np.cos(aPe+tAn) + np.cos(lAn)*np.sin(aPe+tAn)*np.cos(i))\n        z = r * ( np.sin(i)*np.sin(aPe+tAn))\n\n        return x,y,z\n\n    def getSpeed(self, trueAnomaly=None):\n        if trueAnomaly == None:\n            tAn = self.tAn\n        else:\n            tAn = trueAnomaly\n\n        r = self.getRadius(tAn)\n        mu = self.primBody.mu\n\n        return np.sqrt(mu*(2/r -1/self.a))\n'"
orbits/uniTraj.py,4,"b'import numpy as np\nfrom astropy.time import Time, TimeDelta\nimport utils\n\nclass TrajectoryElements:\n    """"""\n    TODO: Implement properties getter/setter and sanity checks\n    """"""\n    def __init__(self, universalAnomaly, radiusAtZero, velocityAtZero, reciprocalSMA, primaryBody, epoch, name):\n        self._uAnom = universalAnomaly\n        self._r0 = radiusAtZero\n        self._v0 = velocityAtZero\n        self._alpha = reciprocalSMA\n        self._primBody = primaryBody\n        self._epoch = epoch\n        self._id = name\n\n    @property\n    def uAnom(self):\n        return self._uAnom\n\n    @uAnom.setter\n    def uAnom(self, uAnomaly):\n        self._uAnom = uAnomaly\n\n    @property\n    def r0(self):\n        return self._r0\n\n    @r0.setter\n    def r0(self, radiusAtZero):\n        if len(radiusAtZero) != 3 or type(radiusAtZero) != tuple:\n                raise ValueError(""radiusAtZero should be a tuple of length 3"")\n        self._r0 = radiusAtZero\n\n    @property\n    def v0(self):\n        return self._v0\n\n    @v0.setter\n    def v0(self, velocityAtZero):\n        if len(velocityAtZero) != 3 or type(velocityAtZero) != tuple:\n                raise ValueError(""velocityAtZero should be a tuple of length 3"")\n        self._v0 = velocityAtZero\n\n    @property\n    def alpha(self):\n        return self._alpha\n\n    @alpha.setter\n    def alpha(self, reciprocalSMA):\n        if type(reciprocalSMA) != int and type(reciprocalSMA) != float:\n            raise TypeError(""The reciprocal of the semi major axis should be an integer or a float"")\n        self._alpha = reciprocalSMA\n\n    @property\n    def epoch(self):\n        return self._epoch\n\n    @epoch.setter\n    def epoch(self, value):\n        if not isinstance(value, Time):\n            raise TypeError(""The epoch should be an astropy Time object"")\n        self._epoch = value\n\n    @property\n    def primBody(self):\n        return self._primBody\n\n    @primBody.setter\n    def primBody(self,value):\n        if type(value) != dict:\n            raise TypeError(""The body should be a dict, check bodies.py for ref"")\n        self._primBody = value\n\n    @property\n    def id(self):\n        return self._id\n\n    @id.setter\n    def id(self, value):\n        if type(value) != str:\n            raise TypeError(""Name provided is not a string"")\n        self._id = value\n\nclass Trajectory(TrajectoryElements):\n    # TODO: Implement universal kepler solver\n    # TODO: Implement lagrange coefficients calculation\n    # TODO: Allow conversion between Orbit class and Trajectory for e<1\n    def __init__(self, universalAnomaly, radiusAtZero, velocityAtZero, reciprocalSMA, primaryBody, epoch, name):\n        TrajectoryElements.__init__(self, universalAnomaly, radiusAtZero, velocityAtZero, reciprocalSMA, primaryBody, epoch, name)\n    #\n    # def uKeplerSolver(self, dt):\n    #     nMax = 1000\n    #     mu = self.primBody[""gParam""]\n    #     uAnom = np.sqrt(mu)*np.abs(self.alpha)*dt\n    #     h = np.linalg.norm(np.cross(self.r0, self.v0))\n    #     ratio = 1\n    #     n = 0\n    #     while ratio < 10**-8 and n <= nMax:\n    #         C=utils.stumpC(self.alpha*uAnom**2)\n    #         S=utils.stumpS(self.alpha*uAnom**2)\n    #\n    #         r0Norm = np.linalg.norm(self.r0)\n    #\n    #         f = (r0Norm*self.v0[0])/np.sqrt(mu)*uAnom**2*C + (1-self.alpha*r0Norm)*uAnom**3*S + r0Norm*uAnom-sqrt(mu)*dt\n    #         df =\n'"
plot/__init__.py,0,b''
plot/plotManager2D.py,10,"b""import tools.utils\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\n\nITERORBIT = 200\n\nclass PlotManager():\n    def __init__(self):\n        self.orbitList = {}\n        self.fig, self.ax = plt.subplots()\n        plt.axis('equal')\n\n    def addOrbit(self, Orbit):\n        self.orbitList[Orbit.id] = Orbit\n\n    def plotOrbit(self, orbitID):\n        Orbit2D = self.orbitList[orbitID]\n\n        tAnArray = np.linspace(0, 2*np.pi, ITERORBIT)\n        xArray, yArray = np.array([]), np.array([])\n\n        for i in np.nditer(tAnArray):\n            # i = utils.meanToTrue(i, Orbit2D.e)\n            x,y,_ = Orbit2D.cartesianCoordinates(i)\n\n            xArray = np.append(xArray,x)\n            yArray = np.append(yArray,y)\n\n        self.ax.plot(xArray, yArray)\n\n\n        # ELLIPSE METHOD, far more efficient, need to debug however\n        #BUG: Doesnt'display properly based on aPe, fix the ellipse patches\n\n\n        # SMA = Orbit2D.a #SMajor\n        # SMI = Orbit2D.a*np.sqrt(1-Orbit2D.e**2)\n        # linEccentricity = np.sqrt(SMA**2-SMI**2)\n        # xF, yF = utils.sphereToCartesian2D(-Orbit2D.aPe, linEccentricity)\n        # body = mpatches.Ellipse([xF, yF], SMA*2, SMi*2, Orbit2D.aPe, fill=False, edgecolor=np.random.rand(3), linestyle='--')\n        # self.ax.add_patch(body)\n\n    def plotPoint(self, orbitID, area=25):\n        Orbit2D = self.orbitList[orbitID]\n        x, y, _ = Orbit2D.cartesianCoordinates(Orbit2D.tAn)\n\n        self.ax.scatter(x,y, s=area)\n\n    def plotBody(self, body):\n        xArray = np.array([])\n        yArray = np.array([])\n\n        radius = body.r\n\n        body = mpatches.Circle([0,0],radius)\n        self.ax.add_patch(body)\n\n    def show(self):\n        self.ax.set_aspect('equal')\n        self.ax.autoscale()\n        plt.show()\n"""
plot/plotManager3D.py,21,"b'import tools.utils\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as mpatches\nfrom mpl_toolkits.mplot3d import Axes3D\nimport mpl_toolkits.mplot3d.art3d as art3d\n\n\nITERORBIT = 200\n\ndef set_axes_equal(ax):\n    \'\'\'Make axes of 3D plot have equal scale so that spheres appear as spheres,\n    cubes as cubes, etc..  This is one possible solution to Matplotlib\'s\n    ax.set_aspect(\'equal\') and ax.axis(\'equal\') not working for 3D.\n\n    Input\n      ax: a matplotlib axis, e.g., as output from plt.gca().\n\n      Thanks to karlo for this function : https://stackoverflow.com/a/31364297/7886572\n    \'\'\'\n    print(ax.get_xlim3d())\n    print(ax.get_ylim3d())\n    print(ax.get_zlim3d())\n    x_limits = ax.get_xlim3d()\n    y_limits = ax.get_ylim3d()\n    z_limits = ax.get_zlim3d()\n\n    x_range = abs(x_limits[1] - x_limits[0])\n    x_middle = np.mean(x_limits)\n    y_range = abs(y_limits[1] - y_limits[0])\n    y_middle = np.mean(y_limits)\n    z_range = abs(z_limits[1] - z_limits[0])\n    z_middle = np.mean(z_limits)\n\n    # The plot bounding box is a sphere in the sense of the infinity\n    # norm, hence I call half the max range the plot radius.\n    plot_radius = 0.5*max([x_range, y_range, z_range])\n\n    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])\n    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])\n    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])\n\n\nclass PlotManager3D():\n    def __init__(self):\n        self.fig = plt.figure()\n        self.ax = self.fig.add_subplot(111, projection=\'3d\')\n\n        self.ax.set_xlabel(\'X axis\')\n        self.ax.set_ylabel(\'Y axis\')\n        self.ax.set_zlabel(\'Z axis\')\n        self.orbitList = {}\n\n    def addOrbit(self, Orbit):\n        self.orbitList[Orbit.id] = Orbit\n\n    def plotBody(self, body):\n        r = body.r\n\n        u = np.linspace(0, 2 * np.pi, 100)\n        v = np.linspace(0, np.pi, 100)\n\n        x = r * np.outer(np.cos(u), np.sin(v))\n        y = r * np.outer(np.sin(u), np.sin(v))\n        z = r * np.outer(np.ones(np.size(u)), np.cos(v))\n        print(np.amax(x))\n        print(np.amax(y))\n        print(np.amax(z))\n        self.ax.plot_surface(x, y, z, color=\'b\')\n\n    def plotOrbit(self, orbitID, color=None):\n        Orbit3D = self.orbitList[orbitID]\n        xArray, yArray, zArray = np.array([]), np.array([]), np.array([])\n        tAnArray = np.linspace(0, 2*np.pi, ITERORBIT)\n\n        for i in np.nditer(tAnArray):\n            i = tools.utils.meanToTrue(i, Orbit3D.e)\n            x,y,z = Orbit3D.cartesianCoordinates(i)\n            xArray = np.append(xArray, x)\n            yArray = np.append(yArray, y)\n            zArray = np.append(zArray, z)\n\n        self.ax.plot(xArray, yArray, zArray, c=color, lw = 0.5)\n\n    def show(self):\n        # self.ax.set_aspect(\'equal\')\n        # self.ax.axis(\'equal\')\n        # set_axes_equal(self.ax)\n        # u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]\n        # x = np.cos(u)*np.sin(v)\n        # y = np.sin(u)*np.sin(v)\n        # z = np.cos(v)\n        # self.ax.plot_wireframe(x, y, z, color=""r"")\n        self.ax.view_init(elev = 90, azim= 0)\n        plt.show()\n'"
plot/plotlyManager.py,12,"b'import plotly\nimport plotly.graph_objs as go\nimport numpy as np\nimport tools.utils\n\nITERORBIT = 300\nITERANIM = 300\nrmax = 2.4923E+8*1.1\n\nclass PlotManager3D:\n    """"""\n    3D Plot manager based on plotly due to matplotlib\'s poor 3D performance\n\n    currently supports :\n    - Plotting of bodies\n    - Plotting of elliptical orbits\n    - Plotting of points on an orbit with true anomaly\n    - Animating points along an orbit based on true anomaly and time\n\n    TODO :\n    - Support a config manager for color, iteration numbers etc\n    - Support hyperbolic trajectory\n    - 2D Plotting\n    - 2D Map trajectory\n    outputs a file called ""temp-plot.html"" in the main directory\n    BEWARE : Files can get huge very quickly with animation of points\n    """"""\n    def __init__(self, iterOrbit = 300, iterAnim = 300, title = ""Default Title"",\n    range = 10E6, pointBase = None  , orbitBase = None, filename=""plot""):\n        self.orbitDict = {}\n        self.bodyDict = {}\n        self.animList = []\n        self.framesList = []\n        self.xPoint, self.yPoint, self.zPoint = [],[],[]\n\n        self.ITERORBIT = iterOrbit\n        self.ITERANIM = iterAnim\n\n        self.defaultOrbit = orbitBase\n        self.defaultPoint = pointBase\n        self.fileName = filename\n\n        self.layout = go.Layout(\n            scene=dict(\n            xaxis = dict(range = [-range,range],),\n            yaxis = dict(range = [-range,range],),\n            zaxis = dict(range = [-range,range],),),\n            title=title,\n            showlegend=False,\n            updatemenus= [{\'type\': \'buttons\',\n                           \'buttons\': [{\'label\': \'Play\',\n                                        \'method\': \'animate\',\n                                        \'args\': [None, dict(frame=dict(duration=20, redraw=False),\n                                                     transition=dict(duration=10, easing=""quadratic-in-out""),\n                                                     fromcurrent=True,\n                                                     mode=\'immediate\'\n                                                    )]},\n                                                {\n                                                    \'args\': [[None], {\'frame\': {\'duration\': 0, \'redraw\': False}, \'mode\': \'immediate\',\n                                                    \'transition\': {\'duration\': 0}}],\n                                                    \'label\': \'Pause\',\n                                                    \'method\': \'animate\'\n                                                }]}])\n\n    def _plotOrbit(self, orbit, paramDict, limits):\n        """"""\n        Sub-function called by addOrbit, in order to plot an orbit\n\n        INPUT :\n            orbit           -> an Orbit object\n            paramDict       -> a dictionary containing width and and color for the line plot\n            limits          -> An optional list giving the limits for the plotting (true anomaly)\n\n        OUTPUT :\n            scatterOrbit    -> a Scatter3d object used by plotly\n        """"""\n        xArray, yArray, zArray = np.array([]), np.array([]), np.array([])\n\n        tAnArray = np.linspace(0, 2*np.pi, ITERORBIT)\n        if limits != None:\n            tAnArray=np.linspace(limits[0], limits[1], ITERORBIT)\n\n        for i in np.nditer(tAnArray):\n            # i = tools.utils.meanToTrue(i, orbit.e)\n            x,y,z = orbit.cartesianCoordinates(i)\n            xArray = np.append(xArray, x)\n            yArray = np.append(yArray, y)\n            zArray = np.append(zArray, z)\n\n        pDict = self.defaultOrbit\n        if paramDict != None:\n            pDict = paramDict\n\n        scatterOrbit = go.Scatter3d(x=xArray, y=yArray, z=zArray, mode=\'line\', line=pDict, marker=dict(size=0.0001, opacity=0))\n\n        return scatterOrbit\n\n    def addOrbit(self, orbit, paramDict = None, limits=None):\n        """"""\n        function called by the user to plot an orbit\n\n\n        INPUT :\n            See _plotOrbit documentation for details\n\n        OUTPUT :\n            add to orbitDict a list containing the Orbit object and the Scatter3d associated\n        """"""\n        plotOrbit = self._plotOrbit(orbit, paramDict, limits)\n\n        self.orbitDict[orbit.id] = [orbit, plotOrbit]\n\n    def _plotBody(self, body):\n        """"""\n        Sub-function called by addBody, in order to plot the spherical body\n\n        INPUT :\n            body -> A Body object generated by the user\n\n        OUTPUT :\n            surfaceBody -> a Surface object used by plotly to 3D plot the sphere\n        """"""\n        r = body.r\n\n        theta = np.linspace(0,2*np.pi,100)\n        phi = np.linspace(0,np.pi,100)\n\n        x = r*np.outer(np.cos(theta),np.sin(phi))\n        y = r*np.outer(np.sin(theta),np.sin(phi))\n        z = r*np.outer(np.ones(100),np.cos(phi))\n\n        surfaceBody = go.Surface(x=x, y=y, z=z)\n        return surfaceBody\n\n    def addBody(self, body):\n        """"""\n        function called by the user to plot a spherical Body\n\n        INPUT :\n            See _plotBody for details\n\n        OUTPUT :\n            add to bodyDict a list containing the Body object and the Surface associated\n        """"""\n        plotBody = self._plotBody(body)\n        self.bodyDict[body.name] = [body, plotBody]\n\n    def plotPoint(self, orbit, tAn=None):\n        """"""\n        function called by the user to display a simple point\n\n        INPUT :\n            orbit   -> An Orbit object on which the point stands\n            tAn     -> the true anomaly of the point on the orbit\n                       if no value is passed, the default tAn of Orbit is used\n        OUTPUT :\n            appends x,y and z values to xPoint, yPoint and zPoint lists containing\n            coordinates for points in order\n        """"""\n        x,y,z = orbit.cartesianCoordinates(trueAnomaly=tAn)\n        self.xPoint.append(x)\n        self.yPoint.append(y)\n        self.zPoint.append(z)\n\n    def animPoint(self, orbit, tAnStart=None, time=3600):\n        """"""\n        function called by the user to animate a point on the orbit\n\n        INPUT :\n            orbit       -> An Orbit objct which is the point trajectory\n            tAnStart    -> starting true anomaly, if none is given then default true anomaly is used\n            time        -> the period over which the animation takes place\n\n        OUTPUT :\n            appends a list containing x y and z lists to the global animation list\n        """"""\n        legTan = orbit.tAn\n        if tAnStart != None:\n            orbit.tAn = tAnStart\n\n        xValues, yValues, zValues = [],[],[]\n        tIter = time/ITERANIM\n\n        for i in range(ITERANIM):\n            x,y,z = orbit.cartesianCoordinates()\n            xValues.append(x)\n            yValues.append(y)\n            zValues.append(z)\n            orbit.updTime(tIter)\n\n        orbit.updTime(-time)\n        orbit.tAn = legTan\n\n        self.animList.append([xValues, yValues, zValues])\n\n    def show(self):\n        """"""\n        Function called by the user to generate the plot file defined by filename\n\n        INPUT :\n            nothing\n        OUTPUT :\n            returns a file named filename + "".html"" in the main folder containing\n            the plot\n\n        """"""\n        data = list()\n        for i in self.bodyDict.values():\n            data.append(i[1])\n\n        for i in self.orbitDict.values():\n            data.append(i[1])\n\n        points = go.Scatter3d(x=self.xPoint, y=self.yPoint, z=self.zPoint, mode=\'markers\', marker=dict(size=3))\n        data.append(points)\n\n        if self.animList != []:\n            x,y,z = [],[],[]\n            for i in range(ITERANIM):\n                xTime, yTime, zTime = [],[],[]\n                for j in range(len(self.animList)):\n                    xTime.append(self.animList[j][0][i])\n                    yTime.append(self.animList[j][1][i])\n                    zTime.append(self.animList[j][2][i])\n\n                if i==0:\n                    data.append(go.Scatter3d(x=xTime, y=yTime, z=zTime, mode=\'markers\', marker={\'color\': \'green\', \'size\': 5}))\n\n\n                frame = {\'data\':\n                [{\n                \'type\' :\'scatter3d\',\n                \'x\': xTime,\n                \'y\': yTime,\n                \'z\': zTime,\n                \'mode\': \'markers\',\n                \'marker\': {\'color\': \'black\', \'size\': 4}\n                }],\n                \'traces\' : [len(data)-1]\n                }\n\n                self.framesList.append(frame)\n\n        fig = go.Figure(data=data, layout=self.layout, frames=self.framesList)\n        plotly.offline.plot(fig, filename=self.fileName)\n'"
tools/__init__.py,0,b''
tools/body.py,0,"b'class Body:\n    def __init__(self, name=None, mu=0, r=0, primBody = None, Orbit=None, Atmosphere=None, Moons=None):\n        self._name = name\n        self._mu = mu\n        self._r = r\n        self._Orbit = Orbit\n        self._Atmosphere = Atmosphere  #NOT_IMPLEMENTED\n        self._Moons = Moons #NOT_IMPLEMENTED\n        self._primBody = primBody\n\n    @property\n    def name(self):\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        if type(value) != str:\n            raise TypeError(""The body name must be a string"")\n\n        self._name = value\n\n    @property\n    def mu(self):\n        return self._mu\n\n    @mu.setter\n    def mu(self, value):\n        if type(value) != int:\n            raise TypeError(""The gravitational parameter must be an integer"")\n        if value <= 0:\n            raise ValueError(""The gravitational parameter must be positive"")\n        self._mu = value\n\n    @property\n    def r(self):\n        return self._r\n\n    @r.setter\n    def r(self, value):\n        if type(value) != int:\n            raise TypeError(""The radius must be an integer"")\n        if value <= 0:\n            raise ValueError(""The radius must be positive"")\n        self._r = value\n\n    @property\n    def Orbit(self):\n        return self._Orbit\n\n    @Orbit.setter\n    def Orbit(self, value):\n        self._Orbit = value\n\n    @property\n    def primBody(self):\n        return self._primBody\n\n    @primBody.setter\n    def primBody(self, value):\n        if type(value) != Body:\n            raise TypeError(""The primary body must be another body"")\n\n        self._primBody = value\n'"
tools/trajOpt.py,10,"b'import numpy as np\nfrom orbits.orbit import Orbit\nfrom tools.utils import uLambert\n\n#FIXME: Seems to return low values\ndef getC3(body, r2, tof):\n    """"""\n    Determines depart energy needed between a body and a destination\n    INPUT :\n        body    : The primary body we\'re departing from\n        r2      : The destination (x,y,z) tuple\n        tof     : The time of flight in seconds\n\n    OUTPUT :\n        c3      : The depart energy required\n    """"""\n    try:\n        r1 = body.Orbit.cartesianCoordinates()\n        v1 = body.Orbit.getSpeed()\n        _,vE,_,_ = uLambert(r1, r2, tof, body.primBody)\n        vE = np.linalg.norm(vE)\n        print(vE)\n        print(v1)\n    except:\n        return np.nan\n    return (vE-v1)**2\n\n\ndef getPorkChop(body1, body2, departInterval, arrivalInterval, ITER):\n    depArray, stepD = np.linspace(departInterval[0], departInterval[1], num = ITER, retstep=True)\n    arrArray, stepA = np.linspace(arrivalInterval[1], arrivalInterval[0],num = ITER, retstep=True)\n\n    retGrid = list()\n    tofGrid = list()\n    i=0\n\n    for arr in np.nditer(arrArray):\n        i+=1\n\n        body1.Orbit.updTime(stepD)\n        body2.Orbit.updTime(stepD)\n\n        C3tof = list()\n        tofList = list()\n\n        for dep in np.nditer(depArray):\n            tof = arr-dep\n            if tof < 100*3600*24:\n                C3 = np.nan\n                C3tof.append(C3)\n                tofList.append(tof/(3600*24))\n                continue\n\n            C3 = getDepartEnergy(body1, body2, tof)\n\n            # if C3 is not np.nan:\n            #     C3 = np.round(C3)\n\n            C3tof.append(C3)\n            tofList.append(tof/(3600*24))\n\n        retGrid.append(C3tof)\n        tofGrid.append(tofList)\n\n        if i%5==0:\n            print(str((i/ITER)*100)+""%"")\n\n    return np.array(retGrid, dtype=float), np.array(tofGrid)\n'"
tools/utils.py,44,"b'import numpy as np\nfrom scipy.optimize import fmin\n\ndef sphereToCartesian2D(angle, distance):\n    """"""\n    INPUT :\n        angle     - between (0, 2pi)\n        distance  - between (0, inf)\n    OUTPUT :\n        tuple (x,y), 2d coordinates\n    """"""\n    x,y = 0,0\n    x = distance*np.cos(angle)\n    y = distance*np.sin(angle)\n\n    return (x,y)\n\ndef sphereToCartesian3D(theta, phi, distance):\n    """"""\n    INPUT :\n        theta       - between (0,2pi)   - azimuthal angle   (x-y plane from x  )\n        phi         - between (0,pi)    - polar angle       (from z+ to direct.)\n        distance    - between (0, inf)  - distance to origin\n    OUTPUT :\n        tuple (x,y,z), 3d coordinates\n    """"""\n    x = distance*np.cos(theta)*np.sin(phi)\n    y = distance*np.sin(theta)*np.sin(phi)\n    z = distance*np.cos(phi)\n    return (x,y,z)\n\ndef meanToTrue(Me, ecc):\n    """"""\n    INPUT :\n        Me          - between(0, 2pi)   - Mean anomaly\n        ecc         - between(0, 1)     - eccentricity of the orbit\n    OUTPUT :\n        trueAn      - between(0 , 2pi)  - True anomaly\n\n\n    Solves Kepler\'s equation for the true anomaly using Alg. 3.1\n\n    """"""\n    Me = Me%(2*np.pi)\n    if Me==0:\n        return 0\n\n    if Me<np.pi:\n        linEcc = Me+ecc/2\n    else:\n        linEcc = Me-ecc/2\n\n    func = linEcc-ecc*np.sin(linEcc)-Me\n    deriv = 1-ecc*np.cos(linEcc)\n    ratio = func/deriv\n\n    while np.abs(ratio)>10**-6:\n        linEcc = linEcc - ratio\n        func = linEcc-ecc*np.sin(linEcc)-Me\n        deriv = 1-ecc*np.cos(linEcc)\n        ratio = func/deriv\n\n    trueAn = np.sqrt((1+ecc)/(1-ecc))*np.tan(linEcc/2)\n    trueAn = 2*np.arctan(trueAn)\n\n    return trueAn%(2*np.pi)\n\ndef trueToMean(tAn, ecc):\n    """"""\n    Return the mean anomaly based on the true anomaly\n\n    INPUT:\n        tAn : True anomaly float\n        ecc : Eccentricity of the orbit float\n    OUTPUT:\n        The mean anomaly for the corresponding orbit\n    """"""\n    linEcc = 2*np.arctan(np.sqrt((1-ecc)/(1+ecc))*np.tan(tAn/2))\n    return (linEcc-ecc*np.sin(linEcc))%(2*np.pi)\n\n#TODO: Create fuzzy testing for lambert problem\ndef uLambert(r1,r2,dt0, primBody, nRev=0, DM=None):\n    """"""\n    Based on http://ccar.colorado.edu/imd/2015/documents/LambertHandout.pdf\n    Solution to the Lambert problem\n    The algorithm doesn\'t seem very robust and tends to fail for weird tof values\n\n    INPUT:\n        r1  : Initial position vector (x,y,z)\n        r2  : Final position vector   (x,y,z)\n        dt0 : Time of flight between r1 and r2 (in seconds)\n        primBody : The primary body around which r1 and r2 are positioned, Body object\n        DM : Optional, direction of motion, can take values of 1 and -1\n\n    OUTPUT:\n        r1  : Initial position vector (x,y,z)\n        v1  : Initial velocity vector (x,y,z)\n        r2  : Final position vector (x,y,z)\n        v2  : Final velocity vector (x,y,z)\n    """"""\n    def _detCFunctions(psi):\n        if psi > 1*10**-6:\n            c2 = (1 - np.cos(np.sqrt(psi)))/psi\n            c3 = (np.sqrt(psi) - np.sin(np.sqrt(psi)))/np.sqrt(psi**3)\n        elif psi < -1*10**-6:\n            c2 = (1 - np.cosh(np.sqrt(-psi)))/psi\n            c3 = (np.sinh(np.sqrt(-psi))-np.sqrt(-psi))/np.sqrt((-psi)**3)\n        else:\n            c2 = 1/2\n            c3 = 1/6\n        return c2,c3\n\n    def _detTOF(psi, A, mu, r1Mag, r2Mag):\n        c2, c3 = _detCFunctions(psi)\n        y = r1Mag+r2Mag+A*(psi*c3-1)/(np.sqrt(c2))\n        chi = np.sqrt(y/c2)\n        dt = (c3*np.power(chi,3)+A*np.sqrt(y))/np.sqrt(mu)\n        return dt\n\n    r1 = np.array(r1)\n    r2 = np.array(r2)\n    mu = primBody.mu\n\n    if DM==None: # If we don\'t know the direction of motion we determine it\n        nu1 = np.arctan2(r1[1], r1[0])\n        nu2 = np.arctan2(r2[1], r2[0])\n        dnu = (nu2 - nu1)%(2*np.pi)\n\n        if 2*np.pi < dnu or dnu < 0:\n            raise ValueError(""dnu not in correct range"")\n        if dnu < np.pi:\n            DM = 1\n        else:\n            DM = -1\n\n    r1Mag = np.linalg.norm(r1)\n    r2Mag = np.linalg.norm(r2)\n    print(r1Mag)\n    cosdnu = np.dot(r1,r2)/(r1Mag*r2Mag)\n\n    A = DM*np.sqrt(r1Mag*r2Mag*(1+cosdnu))\n\n    if A == 0:\n        raise ValueError(""Trajectory can\'t be computed"")\n\n    if nRev == 0:\n        psi, psiUp, psiLow = 0, 4*np.pi**2, -4*np.pi\n        c2, c3 = 1/2, 1/6\n    else:\n        psiUp, psiLow = 4*((nRev+1)**2)*np.pi**2, 4*(nRev**2)*np.pi**2\n        psi = (psiUp+psiLow)/2\n        c2, c3 = _detCFunctions(psi)\n\n    #We verify that a solution exists for the time of flight and the nRev\n    psiMini = fmin(_detTOF, psi, args=(A, mu, r1Mag, r2Mag))\n    tofMini = _detTOF(psiMini[0], A, mu, r1Mag, r2Mag)\n    if tofMini > dt0:\n        raise ValueError(""""""\n                        No solution : Time of flight too low\n\n                        Number of revolutions   - {}\n                        TOF Chosen              - {}\n                        TOF Minimum for nRev    - {}\n                        """""".format(nRev, dt0, tofMini))\n    dt = 0\n    nIter = 0\n\n    while abs(dt - dt0) > 1*10**-6:\n        y = r1Mag+r2Mag+A*(psi*c3-1)/(np.sqrt(c2))\n        if A > 0 and y < 0: #We make sure that y>0 by tweaking its value\n            while y<0:\n                c2,c3 = _detCFunctions(psi)\n                psi += 0.1\n                y = r1Mag+r2Mag+A*(psi*c3-1)/(np.sqrt(c2))\n\n\n        chi = np.sqrt(y/c2)\n        dt = (c3*np.power(chi,3)+A*np.sqrt(y))/np.sqrt(mu)\n\n        if dt <= dt0:\n            psiLow = psi\n        else:\n            psiUp = psi\n        psi = (psiUp + psiLow)/2\n\n        c2, c3 = _detCFunctions(psi)\n\n        nIter+=1\n\n        if nIter > 500:\n            raise ValueError(""""""Maximum iterations reached in Lambert solver\n\n            psi  - {}\n            dt   - {}\n            y    - {}\n            dnu  - {}\n            c2/3 - {} , {}\n\n            Make sure your values are sensible and try again.\n            """""".format(psi, dt, y, dnu, c2, c3))\n\n    f = 1 - y/r1Mag\n    g = A*np.sqrt(y/mu)\n    gDot = 1 - y/r2Mag\n    v1 = (r2 - f*r1)/g\n    v2 = (gDot*r2 - r1)/g\n\n    return r1,v1,r2,v2\n\nif __name__ == ""__main__"":\n    from examples import Earth, Sun\n\n    print(uLambert(np.array([5000,10000,2100]),np.array([-14600,2500,7000]),3600,primBody=Earth))\n    print(uLambert(np.array([-26503064.373261325, 144693278.60351047, 119.32162712262743]),np.array([208034201.40482172, -1959743.5511186407, -5158244.7539406745]), 300*3600*24, primBody=Sun))\n'"
