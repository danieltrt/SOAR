file_path,api_count,code
setup.py,0,"b'import sys\n\nimport setuptools\nfrom setuptools import Extension, find_packages, setup\nfrom setuptools.command.build_ext import build_ext\n\n\n# https://github.com/pybind/python_example/\nclass get_pybind_include:\n    def __str__(self):\n        import pybind11\n\n        return pybind11.get_include()\n\n\next_modules = [\n    Extension(\n        ""_accupy"",\n        [""src/pybind11.cpp""],\n        language=""c++"",\n        include_dirs=[""/usr/include/eigen3/"", get_pybind_include()],\n    )\n]\n\n\n# cf http://bugs.python.org/issue26689\ndef has_flag(compiler, flagname):\n    """"""Return a boolean indicating whether a flag name is supported on\n    the specified compiler.\n    """"""\n    import tempfile\n    import os\n\n    with tempfile.NamedTemporaryFile(""w"", suffix="".cpp"", delete=False) as f:\n        f.write(""int main (int argc, char **argv) { return 0; }"")\n        fname = f.name\n    try:\n        compiler.compile([fname], extra_postargs=[flagname])\n    except setuptools.distutils.errors.CompileError:\n        return False\n    finally:\n        try:\n            os.remove(fname)\n        except OSError:\n            pass\n    return True\n\n\ndef cpp_flag(compiler):\n    flags = [""-std=c++17"", ""-std=c++14"", ""-std=c++11""]\n\n    for flag in flags:\n        if has_flag(compiler, flag):\n            return flag\n\n    raise RuntimeError(""Unsupported compiler -- at least C++11 support is needed!"")\n\n\nclass BuildExt(build_ext):\n    c_opts = {\n        ""msvc"": [""/EHsc""],\n        ""unix"": [],\n    }\n    l_opts = {\n        ""msvc"": [],\n        ""unix"": [],\n    }\n\n    if sys.platform == ""darwin"":\n        darwin_opts = [""-stdlib=libc++"", ""-mmacosx-version-min=10.7""]\n        c_opts[""unix""] += darwin_opts\n        l_opts[""unix""] += darwin_opts\n\n    def build_extensions(self):\n        ct = self.compiler.compiler_type\n        opts = self.c_opts.get(ct, [])\n        link_opts = self.l_opts.get(ct, [])\n        if ct == ""unix"":\n            opts.append(cpp_flag(self.compiler))\n            if has_flag(self.compiler, ""-fvisibility=hidden""):\n                opts.append(""-fvisibility=hidden"")\n\n        for ext in self.extensions:\n            ext.define_macros = [\n                (""VERSION_INFO"", \'""{}""\'.format(self.distribution.get_version()))\n            ]\n            ext.extra_compile_args = opts\n            ext.extra_link_args = link_opts\n        build_ext.build_extensions(self)\n\n\nsetup(\n    name=""accupy"",\n    version=""0.3.1"",\n    packages=find_packages(),\n    ext_modules=ext_modules,\n    url=""https://github.com/nschloe/accupy"",\n    author=""Nico Schl\xc3\xb6mer"",\n    author_email=""nico.schloemer@gmail.com"",\n    # importlib_metadata can be removed when we support Python 3.8+ only\n    install_requires=[\n        ""importlib_metadata"",\n        ""mpmath"",\n        ""numpy"",\n        ""pybind11 >= 2.5.0"",\n        ""pyfma"",\n    ],\n    setup_requires=[""pybind11 >= 2.5.0""],\n    cmdclass={""build_ext"": BuildExt},\n    python_requires="">=3.6"",\n    description=""Accurate sums and dot products for Python"",\n    long_description=open(""README.md"").read(),\n    long_description_content_type=""text/markdown"",\n    license=""GPLv3+"",\n    classifiers=[\n        ""Development Status :: 4 - Beta"",\n        ""License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)"",\n        ""Operating System :: OS Independent"",\n        ""Programming Language :: Python"",\n        ""Programming Language :: Python :: 3"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n        ""Programming Language :: Python :: 3.8"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Scientific/Engineering :: Mathematics"",\n    ],\n)\n'"
accupy/__about__.py,0,"b'try:\n    # Python 3.8\n    from importlib import metadata\nexcept ImportError:\n    import importlib_metadata as metadata\n\ntry:\n    __version__ = metadata.version(""accupy"")\nexcept Exception:\n    __version__ = ""unknown""\n'"
accupy/__init__.py,0,"b'from .__about__ import __version__\nfrom .dot import fdot, kdot\nfrom .ill_cond import generate_ill_conditioned_dot_product, generate_ill_conditioned_sum\nfrom .sums import decker_sum, distill, fsum, kahan_sum, knuth_sum, ksum\n\n__all__ = [\n    ""__version__"",\n    ""kdot"",\n    ""fdot"",\n    ""generate_ill_conditioned_sum"",\n    ""generate_ill_conditioned_dot_product"",\n    ""knuth_sum"",\n    ""decker_sum"",\n    ""distill"",\n    ""ksum"",\n    ""fsum"",\n    ""kahan_sum"",\n]\n'"
accupy/dot.py,0,"b'import _accupy\nimport numpy\n\nfrom .sums import fsum, ksum\n\n# def dot2(x, y, prod2=prod2_fma):\n#     \'\'\'Algorithm 5.3. Dot product in twice the working precision.\n#     in <https://doi.org/10.1137/030601818>.\n#     \'\'\'\n#     p, s = prod2(x[0], y[0])\n#     n = len(x)\n#     for k in range(1, n):\n#         h, r = prod2(x[k], y[k])\n#         p, q = knuth_sum(p, h)\n#         s += q+r\n#     return p + s\n\n\ndef kdot(x, y, K=2):\n    """"""Algorithm 5.10. Dot product algorithm in K-fold working precision,\n    K >= 3.\n    """"""\n    xx = x.reshape(-1, x.shape[-1])\n    yy = y.reshape(y.shape[0], -1)\n\n    xx = numpy.ascontiguousarray(xx)\n    yy = numpy.ascontiguousarray(yy)\n\n    r = _accupy.kdot_helper(xx, yy).reshape((-1,) + x.shape[:-1] + y.shape[1:])\n    return ksum(r, K - 1)\n\n\ndef fdot(x, y):\n    """"""Algorithm 5.10. Dot product algorithm in K-fold working precision,\n    K >= 3.\n    """"""\n    xx = x.reshape(-1, x.shape[-1])\n    yy = y.reshape(y.shape[0], -1)\n\n    xx = numpy.ascontiguousarray(xx)\n    yy = numpy.ascontiguousarray(yy)\n\n    r = _accupy.kdot_helper(xx, yy).reshape((-1,) + x.shape[:-1] + y.shape[1:])\n    return fsum(r)\n'"
accupy/ill_cond.py,0,"b'import math\n\nimport numpy\nimport pyfma\nfrom mpmath import mp\n\n\ndef generate_ill_conditioned_sum(n, c, dps=100):\n    # From <https://doi.org/10.1137/030601818>:\n    # Ill-conditioned sums of length 2n are generated from dot products of\n    # length n using Algorithm 3.3 (TwoProduct) and randomly permuting the\n    # summands.\n    x, y, _, C = generate_ill_conditioned_dot_product(n, c, dps)\n\n    prod = x * y\n    err = pyfma.fma(x, y, -prod)\n    res = numpy.array([prod, err])\n\n    out = numpy.random.permutation(res.flatten())\n\n    def sum_exact(p):\n        mp.dps = dps\n        return mp.fsum(p)\n\n    exact = sum_exact(out)\n    # cond = sum_exact(numpy.abs(out)) / abs(exact)\n    cond = C / 2\n\n    return out, exact, cond\n\n\ndef generate_ill_conditioned_dot_product(n, c, dps=100):\n    """"""n ... length of vector\n    c ... target condition number\n    """"""\n    # Algorithm 6.1 from\n    #\n    # ACCURATE SUM AND DOT PRODUCT,\n    # TAKESHI OGITA, SIEGFRIED M. RUMP, AND SHIN\'ICHI OISHI.\n    assert n >= 6\n    n2 = round(n / 2)\n    x = numpy.zeros(n)\n    y = numpy.zeros(n)\n\n    b = math.log2(c)\n    # vector of exponents between 0 and b/2:\n    e = numpy.rint(numpy.random.rand(n2) * b / 2).astype(int)\n    # make sure exponents b/2 and 0 actually occur in e\n    # vectors x,y\n    e[0] = round(b / 2) + 1\n    e[-1] = 0\n\n    # generate first half of vectors x, y\n    rx, ry = numpy.random.rand(2, n2)\n    x[:n2] = (2 * rx - 1) * 2 ** e\n    y[:n2] = (2 * ry - 1) * 2 ** e\n\n    def dot_exact(x, y):\n        mp.dps = dps\n        # convert to list first, see\n        # <https://github.com/fredrik-johansson/mpmath/pull/385>\n        return mp.fdot(x.tolist(), y.tolist())\n\n    # for i=n2+1:n and v=1:i,\n    #     generate x_i, y_i such that (*) x(v)\xe2\x80\x99*y(v) ~ 2^e(i-n2)\n    # generate exponents for second half\n    e = numpy.rint(numpy.linspace(b / 2, 0, n - n2)).astype(int)\n    rx, ry = numpy.random.rand(2, n2)\n    for i in range(n2, n):\n        # x_i random with generated exponent\n        x[i] = (2 * rx[i - n2] - 1) * 2 ** e[i - n2]\n        # y_i according to (*)\n        y[i] = (\n            (2 * ry[i - n2] - 1) * 2 ** e[i - n2] - dot_exact(x[: i + 1], y[: i + 1])\n        ) / x[i]\n\n    x, y = numpy.random.permutation((x, y))\n    # the true dot product rounded to nearest floating point\n    d = dot_exact(x, y)\n    # the actual condition number\n    C = 2 * dot_exact(abs(x), abs(y)) / abs(d)\n\n    return x, y, d, C\n'"
accupy/sums.py,0,"b'import math\n\nimport _accupy\nimport numpy\n\n\ndef knuth_sum(a, b):\n    """"""Error-free transformation of the sum of two floating point numbers\n    according to\n\n    D.E. Knuth.\n    The Art of Computer Programming: Seminumerical Algorithms, volume 2.\n    Addison Wesley, Reading, Massachusetts, second edition, 1981.\n\n    The underlying problem is that the exact sum a+b of two floating point\n    number a and b is not necessarily a floating point number; for example if\n    you add a very large and a very small number. It is however known that the\n    difference between the best floating point approximation of a+b and the\n    exact a+b is again a floating point number. This routine returns the sum\n    and the error.\n\n    Algorithm 3.1 in <https://doi.org/10.1137/030601818>.\n    """"""\n    x = a + b\n    z = x - a\n    y = (a - (x - z)) + (b - z)\n    return x, y\n\n\ndef decker_sum(a, b):\n    """"""Computationally equivalent to knuth_sum, but formally a bit cheaper.\n    Only works for floats though (and not arrays), and the branch make it in\n    fact less favorable in terms of actual speed.\n    """"""\n    x = a + b\n    y = b - (x - a) if abs(a) > abs(b) else a - (x - b)\n    return x, y\n\n\ndef distill(p, K):\n    """"""Algorithm 4.3. Error-free vector transformation for summation.\n\n    The vector p is transformed without changing the sum, and p_n is replaced\n    by float(sum(p)). Kahan [21] calls this a \'distillation algorithm.\'\n    """"""\n    q = p.reshape(p.shape[0], -1)\n    for _ in range(K):\n        _accupy.distill(q)\n    return q.reshape(p.shape)\n\n\ndef ksum(p, K=2):\n    """"""From\n\n    T. Ogita, S.M. Rump, and S. Oishi.\n    Accurate Sum and Dot Product,\n    SIAM J. Sci. Comput., 26(6), 1955\xe2\x80\x931988 (34 pages).\n    <https://doi.org/10.1137/030601818>.\n\n    Algorithm 4.8. Summation as in K-fold precision by (K\xe2\x88\x921)-fold error-free\n    vector transformation.\n    """"""\n    # Don\'t override the input data.\n    q = p.copy()\n    distill(q, K - 1)\n    return numpy.sum(q[:-1], axis=0) + q[-1]\n\n\n_math_fsum_vec = numpy.vectorize(math.fsum, signature=""(m)->()"")\n\n\ndef fsum(p):\n    return _math_fsum_vec(p.T).T\n\n\ndef kahan_sum(p):\n    """"""Kahan summation\n    <https://en.wikipedia.org/wiki/Kahan_summation_algorithm>.\n    """"""\n    q = p.reshape(p.shape[0], -1)\n    s = _accupy.kahan(q)\n    return s.reshape(p.shape[1:])\n'"
test/test_dot.py,0,"b'import matplotlib.pyplot as plt\nimport numpy\nimport pytest\n\nimport accupy\nimport perfplot\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15])\ndef test_kdot2(cond):\n    x, y, ref, _ = accupy.generate_ill_conditioned_dot_product(100, cond)\n    assert abs(accupy.kdot(x, y, K=2) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15, 1.0e30])\ndef test_kdot3(cond):\n    x, y, ref, _ = accupy.generate_ill_conditioned_dot_product(100, cond)\n    assert abs(accupy.kdot(x, y, K=3) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15, 1.0e30, 1.0e38])\ndef test_fdot(cond):\n    x, y, ref, _ = accupy.generate_ill_conditioned_dot_product(100, cond)\n    assert abs(accupy.fdot(x, y) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\ndef test_accuracy_comparison_illcond(target_cond=None):\n    if target_cond is None:\n        target_cond = [10 ** k for k in range(2)]\n\n    kernels = [\n        numpy.dot,\n        lambda x, y: accupy.kdot(x, y, K=2),\n        lambda x, y: accupy.kdot(x, y, K=3),\n        accupy.fdot,\n    ]\n    labels = [""numpy.dot"", ""accupy.kdot[2]"", ""accupy.kdot[3]"", ""accupy.fdot""]\n    data = numpy.empty((len(target_cond), len(kernels)))\n    condition_numbers = numpy.empty(len(target_cond))\n    numpy.random.seed(0)\n    for k, tc in enumerate(target_cond):\n        x, y, ref, C = accupy.generate_ill_conditioned_dot_product(1000, tc)\n        condition_numbers[k] = C\n        data[k] = [abs(kernel(x, y) - ref) / abs(ref) for kernel in kernels]\n\n    # sort\n    s = numpy.argsort(condition_numbers)\n    condition_numbers = condition_numbers[s]\n    data = data[s]\n\n    for label, d in zip(labels, data.T):\n        plt.loglog(condition_numbers, d, label=label)\n\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    plt.grid()\n    plt.ylim(5.0e-18, 1.0)\n    plt.xlabel(""condition number"")\n    plt.ylabel(""relative error"")\n    plt.gca().set_aspect(1.3)\n\n    # plt.show()\n    # <https://stackoverflow.com/a/10154763/353337>\n    plt.savefig(\n        ""accuracy-dot.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_speed_comparison1(n_range=None):\n    if n_range is None:\n        n_range = [2 ** k for k in range(2)]\n\n    numpy.random.seed(0)\n    perfplot.plot(\n        setup=lambda n: (numpy.random.rand(n, 100), numpy.random.rand(100, n)),\n        kernels=[\n            lambda xy: numpy.dot(*xy),\n            lambda xy: accupy.kdot(*xy, K=2),\n            lambda xy: accupy.kdot(*xy, K=3),\n            lambda xy: accupy.fdot(*xy),\n        ],\n        labels=[""numpy.dot"", ""accupy.kdot[2]"", ""accupy.kdot[3]"", ""accupy.fdot""],\n        colors=plt.rcParams[""axes.prop_cycle""].by_key()[""color""][:4],\n        n_range=n_range,\n        title=""dot(random(n, 100), random(100, n))"",\n        xlabel=""n"",\n        logx=True,\n        logy=True,\n    )\n    plt.gca().set_aspect(0.2)\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    # plt.show()\n    plt.savefig(\n        ""speed-comparison-dot1.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_speed_comparison2(n_range=None):\n    if n_range is None:\n        n_range = [2 ** k for k in range(2)]\n\n    numpy.random.seed(0)\n    perfplot.plot(\n        setup=lambda n: (numpy.random.rand(100, n), numpy.random.rand(n, 100)),\n        kernels=[\n            lambda xy: numpy.dot(*xy),\n            lambda xy: accupy.kdot(*xy, K=2),\n            lambda xy: accupy.kdot(*xy, K=3),\n            lambda xy: accupy.fdot(*xy),\n        ],\n        labels=[""numpy.dot"", ""accupy.kdot[2]"", ""accupy.kdot[3]"", ""accupy.fdot""],\n        colors=plt.rcParams[""axes.prop_cycle""].by_key()[""color""][:4],\n        n_range=n_range,\n        title=""dot(random(100, n), random(n, 100))"",\n        xlabel=""n"",\n        logx=True,\n        logy=True,\n    )\n    plt.gca().set_aspect(0.2)\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    # plt.show()\n    plt.savefig(\n        ""speed-comparison-dot2.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_discontiguous():\n    x = numpy.random.rand(3, 10)\n    y = numpy.random.rand(3, 10)\n\n    accupy.kdot(x.T, y)\n    accupy.fdot(x.T, y)\n    return\n\n\nif __name__ == ""__main__"":\n    # test_accuracy_comparison_illcond([10 ** k for k in range(0, 37, 1)])\n    # test_speed_comparison1(n_range=[2**k for k in range(8)])\n    test_speed_comparison2(n_range=[2 ** k for k in range(8)])\n'"
test/test_sums.py,0,"b'import matplotlib.pyplot as plt\nimport numpy\nimport pytest\n\nimport accupy\nimport perfplot\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15])\ndef test_ksum2(cond):\n    p, ref, _ = accupy.generate_ill_conditioned_sum(100, cond)\n    assert abs(accupy.ksum(p, K=2) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15, 1.0e30])\ndef test_ksum3(cond):\n    p, ref, _ = accupy.generate_ill_conditioned_sum(100, cond)\n    assert abs(accupy.ksum(p, K=3) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\n@pytest.mark.parametrize(""cond"", [1.0, 1.0e15, 1.0e30, 1.0e35])\ndef test_fsum(cond):\n    p, ref, _ = accupy.generate_ill_conditioned_sum(100, cond)\n    assert abs(accupy.fsum(p) - ref) < 1.0e-15 * abs(ref)\n    return\n\n\ndef test_accuracy_comparison_illcond(target_conds=None):\n    if target_conds is None:\n        target_conds = [10 ** k for k in range(1, 2)]\n\n    kernels = [\n        sum,\n        numpy.sum,\n        accupy.kahan_sum,\n        lambda p: accupy.ksum(p, K=2),\n        lambda p: accupy.ksum(p, K=3),\n        accupy.fsum,\n    ]\n    labels = [\n        ""sum"",\n        ""numpy.sum"",\n        ""accupy.kahan_sum"",\n        ""accupy.ksum[2]"",\n        ""accupy.ksum[3]"",\n        ""accupy.fsum"",\n    ]\n    colors = plt.rcParams[""axes.prop_cycle""].by_key()[""color""][: len(labels)]\n\n    data = numpy.empty((len(target_conds), len(kernels)))\n    condition_numbers = numpy.empty(len(target_conds))\n    numpy.random.seed(0)\n    for k, target_cond in enumerate(target_conds):\n        p, ref, C = accupy.generate_ill_conditioned_sum(1000, target_cond)\n        condition_numbers[k] = C\n        data[k] = [abs(kernel(p) - ref) / abs(ref) for kernel in kernels]\n\n    # sort\n    s = numpy.argsort(condition_numbers)\n    condition_numbers = condition_numbers[s]\n    data = data[s]\n\n    for label, color, d in zip(labels, colors, data.T):\n        plt.loglog(condition_numbers, d, label=label, color=color)\n\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    plt.grid()\n    plt.ylim(5.0e-18, 1.0)\n    plt.xlabel(""condition number"")\n    plt.ylabel(""relative error"")\n    plt.gca().set_aspect(1.3)\n\n    # plt.show()\n    # <https://stackoverflow.com/a/10154763/353337>\n    plt.savefig(\n        ""accuracy-sums.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_speed_comparison1(n_range=None):\n    if n_range is None:\n        n_range = [2 ** k for k in range(2)]\n\n    numpy.random.seed(0)\n    perfplot.plot(\n        setup=lambda n: numpy.random.rand(n, 100),\n        kernels=[\n            sum,\n            lambda p: numpy.sum(p, axis=0),\n            accupy.kahan_sum,\n            lambda p: accupy.ksum(p, K=2),\n            lambda p: accupy.ksum(p, K=3),\n            accupy.fsum,\n        ],\n        labels=[\n            ""sum"",\n            ""numpy.sum"",\n            ""accupy.kahan_sum"",\n            ""accupy.ksum[2]"",\n            ""accupy.ksum[3]"",\n            ""accupy.fsum"",\n        ],\n        colors=plt.rcParams[""axes.prop_cycle""].by_key()[""color""][:6],\n        n_range=n_range,\n        title=""Sum(random(n, 100))"",\n        xlabel=""n"",\n        logx=True,\n        logy=True,\n    )\n    plt.gca().set_aspect(0.5)\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    # plt.show()\n    plt.savefig(\n        ""speed-comparison1.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_speed_comparison2(n_range=None):\n    if n_range is None:\n        n_range = [2 ** k for k in range(2)]\n\n    numpy.random.seed(0)\n    perfplot.plot(\n        setup=lambda n: numpy.random.rand(100, n),\n        kernels=[\n            sum,\n            lambda p: numpy.sum(p, axis=0),\n            accupy.kahan_sum,\n            lambda p: accupy.ksum(p, K=2),\n            lambda p: accupy.ksum(p, K=3),\n            accupy.fsum,\n        ],\n        labels=[\n            ""sum"",\n            ""numpy.sum"",\n            ""accupy.kahan_sum"",\n            ""accupy.ksum[2]"",\n            ""accupy.ksum[3]"",\n            ""accupy.fsum"",\n        ],\n        colors=plt.rcParams[""axes.prop_cycle""].by_key()[""color""][:6],\n        n_range=n_range,\n        title=""Sum(random(100, n))"",\n        xlabel=""n"",\n        logx=True,\n        logy=True,\n    )\n    plt.gca().set_aspect(0.5)\n    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.0)\n    # plt.show()\n    plt.savefig(\n        ""speed-comparison2.svg"",\n        transparent=True,\n        bbox_extra_artists=(lgd,),\n        bbox_inches=""tight"",\n    )\n    return\n\n\ndef test_knuth_sum():\n    a16 = numpy.float16(1.0e1)\n    b16 = numpy.float16(1.0e-1)\n\n    x16, y16 = accupy.knuth_sum(a16, b16)\n\n    xy = numpy.float64(x16) + numpy.float64(y16)\n    ab = numpy.float64(a16) + numpy.float64(b16)\n\n    assert abs(xy - ab) < 1.0e-15 * ab\n    return\n\n\ndef test_decker_sum():\n    a16 = numpy.float16(1.0e1)\n    b16 = numpy.float16(1.0e-1)\n\n    x16, y16 = accupy.decker_sum(a16, b16)\n\n    xy = numpy.float64(x16) + numpy.float64(y16)\n    ab = numpy.float64(a16) + numpy.float64(b16)\n\n    assert abs(xy - ab) < 1.0e-15 * ab\n    return\n\n\ndef test_discontiguous():\n    x = numpy.random.rand(3, 10).T\n\n    accupy.ksum(x.T)\n    accupy.fsum(x.T)\n    return\n\n\nif __name__ == ""__main__"":\n    # test_accuracy_comparison_illcond([10 ** k for k in range(0, 37, 1)])\n    # test_speed_comparison1(n_range=[2**k for k in range(15)])\n    test_speed_comparison2(n_range=[2 ** k for k in range(15)])\n'"
