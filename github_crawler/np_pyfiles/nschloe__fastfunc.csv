file_path,api_count,code
setup.py,0,"b'import codecs\nimport os\nimport sys\n\nimport setuptools\nfrom setuptools import Extension, find_packages, setup\nfrom setuptools.command.build_ext import build_ext\n\n# https://packaging.python.org/single_source_version/\nbase_dir = os.path.abspath(os.path.dirname(__file__))\nabout = {}\nwith open(os.path.join(base_dir, ""fastfunc"", ""__about__.py""), ""rb"") as f:\n    exec(f.read(), about)\n\n\nclass get_pybind_include(object):\n    """"""Helper class to determine the pybind11 include path\n    The purpose of this class is to postpone importing pybind11\n    until it is actually installed, so that the ``get_include()``\n    method can be invoked.\n    """"""\n\n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        import pybind11\n\n        return pybind11.get_include(self.user)\n\n\ndef read(fname):\n    return codecs.open(os.path.join(base_dir, fname), encoding=""utf-8"").read()\n\n\n# <https://github.com/pybind/python_example/blob/master/setup.py>\n# As of Python 3.6, CCompiler has a `has_flag` method.\n# cf http://bugs.python.org/issue26689\ndef has_flag(compiler, flagname):\n    """"""Return a boolean indicating whether a flag name is supported on the specified\n    compiler.\n    """"""\n    import tempfile\n\n    with tempfile.NamedTemporaryFile(""w"", suffix="".cpp"") as f:\n        f.write(""int main (int argc, char **argv) { return 0; }"")\n        try:\n            compiler.compile([f.name], extra_postargs=[flagname])\n        except setuptools.distutils.errors.CompileError:\n            return False\n    return True\n\n\n# <https://github.com/pybind/python_example/blob/master/setup.py>\ndef cpp_flag(compiler):\n    """"""Return the -std=c++[11/14] compiler flag.\n    The c++14 is prefered over c++11 (when it is available).\n    """"""\n    if has_flag(compiler, ""-std=c++14""):\n        return ""-std=c++14""\n    elif has_flag(compiler, ""-std=c++11""):\n        return ""-std=c++11""\n    else:\n        raise RuntimeError(\n            ""Unsupported compiler -- at least C++11 support "" ""is needed!""\n        )\n\n\n# <https://github.com/pybind/python_example/blob/master/setup.py>\nclass BuildExt(build_ext):\n    """"""A custom build extension for adding compiler-specific options.""""""\n\n    c_opts = {""msvc"": [""/EHsc""], ""unix"": []}\n\n    if sys.platform == ""darwin"":\n        c_opts[""unix""] += [""-stdlib=libc++"", ""-mmacosx-version-min=10.7""]\n\n    def build_extensions(self):\n        ct = self.compiler.compiler_type\n        opts = self.c_opts.get(ct, [])\n        if ct == ""unix"":\n            opts.append(\'-DVERSION_INFO=""%s""\' % self.distribution.get_version())\n            opts.append(cpp_flag(self.compiler))\n            if has_flag(self.compiler, ""-fvisibility=hidden""):\n                opts.append(""-fvisibility=hidden"")\n        elif ct == ""msvc"":\n            opts.append(\'/DVERSION_INFO=\\\\""%s\\\\""\' % self.distribution.get_version())\n        for ext in self.extensions:\n            ext.extra_compile_args = opts\n        build_ext.build_extensions(self)\n\n\next_modules = [\n    Extension(\n        ""_fastfunc"",\n        [""src/pybind11.cpp""],\n        language=""c++"",\n        include_dirs=[\n            # Path to pybind11 headers\n            get_pybind_include(),\n            get_pybind_include(user=True),\n        ],\n    )\n]\n\n\nsetup(\n    name=""fastfunc"",\n    packages=find_packages(),\n    ext_modules=ext_modules,\n    #\n    # <https://github.com/pybind/python_example/blob/master/setup.py>\n    cmdclass={""build_ext"": BuildExt},\n    zip_safe=False,\n    #\n    version=about[""__version__""],\n    author=about[""__author__""],\n    author_email=about[""__author_email__""],\n    description=(""Fast numpy ufunc operations""),\n    long_description=read(""README.md""),\n    long_description_content_type=""text/markdown"",\n    url=about[""__url__""],\n    license=about[""__license__""],\n    platforms=""any"",\n    install_requires=[""numpy"", ""pybind11>=2.2""],\n    setup_requires=[""pybind11>=2.2""],\n    python_requires="">3="",\n    classifiers=[\n        about[""__status__""],\n        about[""__license__""],\n        ""Intended Audience :: Science/Research"",\n        ""Operating System :: OS Independent"",\n        ""Programming Language :: Python"",\n        ""Programming Language :: Python :: 3"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Software Development :: Libraries"",\n    ],\n)\n'"
fastfunc/__about__.py,0,"b'__author__ = ""Nico Schl\xc3\xb6mer""\n__author_email__ = ""nico.schloemer@gmail.com""\n__copyright__ = ""Copyright (c) 2018-2019, {} <{}>"".format(__author__, __author_email__)\n__license__ = ""License :: OSI Approved :: MIT License""\n__version__ = ""0.2.2""\n__maintainer__ = ""Nico Schl\xc3\xb6mer""\n__status__ = ""Development Status :: 4 - Beta""\n__url__ = ""https://github.com/nschloe/fastfunc""\n'"
fastfunc/__init__.py,0,"b'from . import add, divide, multiply, subtract\nfrom .__about__ import (\n    __author__,\n    __author_email__,\n    __copyright__,\n    __license__,\n    __maintainer__,\n    __status__,\n    __version__,\n)\n\n__all__ = [\n    ""__author__"",\n    ""__author_email__"",\n    ""__copyright__"",\n    ""__license__"",\n    ""__version__"",\n    ""__maintainer__"",\n    ""__status__"",\n    ""add"",\n    ""subtract"",\n    ""multiply"",\n    ""divide"",\n]\n'"
fastfunc/add.py,0,"b'from _fastfunc import _add_at\n\nfrom .helpers import _operator_at\n\n\ndef at(a, k, vals):\n    _operator_at(_add_at, a, k, vals)\n    return\n'"
fastfunc/divide.py,0,"b'from _fastfunc import _divide_at\n\nfrom .helpers import _operator_at\n\n\ndef at(a, k, vals):\n    _operator_at(_divide_at, a, k, vals)\n    return\n'"
fastfunc/helpers.py,0,"b'import sys\n\n\ndef _operator_at(operator, a, k, vals):\n    assert (\n        k.shape == vals.shape[: len(k.shape)]\n    ), ""Shape mismatch! (target.shape = {}, index.shape = {}, values.shape = {}"".format(\n        a.shape, k.shape, vals.shape\n    )\n\n    assert (\n        a.shape[1:] == vals.shape[len(k.shape) :]\n    ), ""Shape mismatch! (target.shape = {}, index.shape = {}, values.shape = {}"".format(\n        a.shape, k.shape, vals.shape\n    )\n\n    a_shape = a.shape\n\n    # Never copy the target, a.\n    _assert_native_byteorder(a)\n    k = _copy_to_native_byteorder(k)\n    vals = _copy_to_native_byteorder(vals)\n\n    a = a.reshape(a.shape[0], -1)\n    idx = k.reshape(-1)\n    v = vals.reshape(idx.shape[0], -1)\n\n    operator(a, idx, v)\n\n    a.reshape(a_shape)\n    return\n\n\ndef _assert_native_byteorder(a):\n    native_code = {""little"": ""<"", ""big"": "">""}[sys.byteorder]\n    assert a.dtype.byteorder in [""="", ""|"", native_code]\n    return\n\n\ndef _copy_to_native_byteorder(a):\n    native_code = {""little"": ""<"", ""big"": "">""}[sys.byteorder]\n    if a.dtype.byteorder in [""="", ""|"", native_code]:\n        return a\n    return a.byteswap().newbyteorder(native_code)\n'"
fastfunc/multiply.py,0,"b'from _fastfunc import _multiply_at\n\nfrom .helpers import _operator_at\n\n\ndef at(a, k, vals):\n    _operator_at(_multiply_at, a, k, vals)\n    return\n'"
fastfunc/subtract.py,0,"b'from _fastfunc import _subtract_at\n\nfrom .helpers import _operator_at\n\n\ndef at(a, k, vals):\n    _operator_at(_subtract_at, a, k, vals)\n    return\n'"
test/performance.py,0,"b'import numpy\nimport numpy_groupies\n\nimport fastfunc\nimport perfplot\n\nm = 100\n\n\ndef numpy_add_at(data):\n    vals, idx = data\n    a = numpy.zeros(m)\n    numpy.add.at(a, idx, vals)\n    return a\n\n\ndef fastfunc_add_at(data):\n    vals, idx = data\n    a = numpy.zeros(m)\n    fastfunc.add.at(a, idx, vals)\n    return a\n\n\ndef numpy_groupies_aggregate_sum(data):\n    a, i = data\n    return numpy_groupies.aggregate(i, a, func=""sum"", size=m)\n\n\ndef numpy_bincount(data):\n    a, i = data\n    return numpy.bincount(i, weights=a, minlength=m)\n\n\ndef setup(n):\n    a = numpy.random.rand(n)\n    i = numpy.random.randint(0, m, n)\n    return a, i\n\n\nperfplot.show(\n    setup=setup,\n    kernels=[\n        numpy_add_at,\n        fastfunc_add_at,\n        numpy_groupies_aggregate_sum,\n        numpy_bincount,\n    ],\n    labels=[\n        ""numpy.add.at"",\n        ""fastfunc.add.at"",\n        \'numpy_groupies.aggregate(""sum"")\',\n        ""numpy.bincount"",\n    ],\n    n_range=[2 ** k for k in range(25)],\n    logx=True,\n    logy=True,\n    xlabel=""num additions"",\n)\n'"
test/test_at.py,0,"b'import numpy\nimport pytest\n\nimport fastfunc\n\n\n@pytest.mark.parametrize(\n    ""dtype_data"",\n    [\n        int,\n        float,\n        numpy.int8,\n        numpy.int16,\n        numpy.int32,\n        numpy.int64,\n        numpy.uint8,\n        numpy.uint16,\n        numpy.uint32,\n        numpy.uint64,\n        # numpy.float16: not workingm has no C++ equivalent\n        numpy.float32,\n        numpy.float64,\n        # numpy.dtype("">i4""): not working, byte order in target must be native\n        numpy.dtype(""<i4""),\n    ],\n)\n@pytest.mark.parametrize(\n    ""dtype_idx"",\n    [\n        int,\n        numpy.int8,\n        numpy.int16,\n        numpy.int32,\n        numpy.int64,\n        numpy.uint8,\n        numpy.uint16,\n        numpy.uint32,\n        numpy.uint64,\n        numpy.dtype("">i4""),\n        numpy.dtype(""<i4""),\n    ],\n)\n@pytest.mark.parametrize(\n    ""numpy_fun, fastfunc_fun"",\n    [\n        (numpy.add.at, fastfunc.add.at),\n        (numpy.subtract.at, fastfunc.subtract.at),\n        (numpy.multiply.at, fastfunc.multiply.at),\n        (numpy.divide.at, fastfunc.divide.at),\n    ],\n)\ndef test_dtypes(dtype_data, dtype_idx, numpy_fun, fastfunc_fun):\n    numpy.random.seed(123)\n\n    a0 = numpy.zeros(10, dtype=dtype_data)\n    k = numpy.random.randint(10, size=5).astype(dtype_idx)\n    v = (17 * numpy.random.rand(5)).astype(dtype_data)\n    numpy_fun(a0, k, v)\n\n    a1 = numpy.zeros(10, dtype=dtype_data)\n    fastfunc_fun(a1, k, v)\n\n    print(a0)\n    print(a1)\n    assert numpy.all(a0 == a1)\n    return\n\n\n@pytest.mark.parametrize(\n    ""numpy_fun, fastfunc_fun"",\n    [\n        (numpy.add.at, fastfunc.add.at),\n        (numpy.subtract.at, fastfunc.subtract.at),\n        (numpy.multiply.at, fastfunc.multiply.at),\n        (numpy.divide.at, fastfunc.divide.at),\n    ],\n)\ndef test_rows(numpy_fun, fastfunc_fun):\n    numpy.random.seed(123)\n\n    a0 = numpy.zeros((10, 3))\n    k = numpy.random.randint(10, size=(5, 7))\n    vals = numpy.random.rand(5, 7, 3)\n    numpy_fun(a0, k, vals)\n\n    a1 = numpy.zeros((10, 3))\n    fastfunc_fun(a1, k, vals)\n\n    assert numpy.all(a0 == a1)\n    return\n\n\n@pytest.mark.parametrize(\n    ""numpy_fun, fastfunc_fun"",\n    [\n        (numpy.add.at, fastfunc.add.at),\n        (numpy.subtract.at, fastfunc.subtract.at),\n        (numpy.multiply.at, fastfunc.multiply.at),\n        (numpy.divide.at, fastfunc.divide.at),\n    ],\n)\ndef test_multi(numpy_fun, fastfunc_fun):\n    numpy.random.seed(123)\n\n    a0 = numpy.zeros((10, 3, 4))\n    k = numpy.random.randint(10, size=(5, 7))\n    vals = numpy.random.rand(5, 7, 3, 4)\n    numpy_fun(a0, k, vals)\n\n    a1 = numpy.zeros((10, 3, 4))\n    fastfunc_fun(a1, k, vals)\n\n    assert numpy.all(a0 == a1)\n    return\n\n\nif __name__ == ""__main__"":\n    test_rows(numpy.add.at, fastfunc.add.at)\n'"
