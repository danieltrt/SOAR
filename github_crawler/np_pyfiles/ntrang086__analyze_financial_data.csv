file_path,api_count,code
util.py,0,"b'""""""Utility code.""""""\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef symbol_to_path(symbol, base_dir=os.path.join(""../.."", ""data"")):\n    """"""Return CSV file path given ticker symbol.""""""\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\n\ndef get_data(symbols, dates, addSPY=True):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if addSPY and \'SPY\' not in symbols:  # add SPY for reference, if absent\n        symbols = [\'SPY\'] + symbols\n\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=\'Date\',\n                parse_dates=True, usecols=[\'Date\', \'Adj Close\'], na_values=[\'nan\'])\n        df_temp = df_temp.rename(columns={\'Adj Close\': symbol})\n        df = df.join(df_temp)\n        if symbol == \'SPY\':  # drop dates SPY did not trade\n            df = df.dropna(subset=[""SPY""])\n\n    return df\n\n\ndef normalize_data(df):\n    """"""Normalize stock prices using the first row of the dataframe""""""\n    return df/df.iloc[0,:]\n\n\ndef compute_daily_returns(df):\n    """"""Compute and return the daily return values""""""\n    daily_returns = df.pct_change()\n    daily_returns.iloc[0,:] = 0\n    return daily_returns\n\n\ndef compute_sharpe_ratio(k, avg_return, risk_free_rate, std_return):\n    """"""\n    Compute and return the Sharpe ratio\n    Parameters:\n    k: adjustment factor, sqrt(252) for daily data, sqrt(52) for weekly data, sqrt(12) for monthly data\n    avg_return: daily, weekly or monthly return\n    risk_free_rate: daily, weekly or monthly risk free rate\n    std_return: daily, weekly or monthly standard deviation\n    Returns: \n    sharpe_ratio: k * (avg_return - risk_free_rate) / std_return\n    """"""\n    return k * (avg_return - risk_free_rate) / std_return\n    \n\ndef plot_data(df, title=""Stock prices"", xlabel=""Date"", ylabel=""Price""):\n    """"""Plot stock prices with a custom title and meaningful axis labels.""""""\n    ax = df.plot(title=title, fontsize=12)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    plt.show()\n'"
01 read_plot_stocks/compute_mean.py,0,"b'""""""Compute mean volume""""""\n\nimport pandas as pd\n\ndef get_mean_volume(symbol):\n    """"""Return the mean volume for stock indicated by symbol.\n    \n    Note: Data for a stock is stored in file: data/<symbol>.csv\n    """"""\n    df = pd.read_csv(""../../data/{}.csv"".format(symbol))  # read in data\n    # TODO: Compute and return the mean volume for this stock\n    return df[\'Volume\'].mean()\n\n\ndef test_run():\n    """"""Function called by Test Run.""""""\n    for symbol in [\'AAPL\', \'IBM\']:\n        print (""Mean Volume"")\n        print (symbol, get_mean_volume(symbol))\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
01 read_plot_stocks/plot_stock.py,0,"b'""""""Plot High prices for IBM""""""\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef test_run():\n    df = pd.read_csv(""../../data/IBM.csv"")\n    df[\'High\'].plot()\n    plt.show()\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
02 read_plot_multiple_stocks/read_plot_utils.py,0,"b'""""""Utility functions""""""\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef symbol_to_path(symbol, base_dir=""../../data""):\n    """"""Return CSV file path given ticker symbol.""""""\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\n\ndef get_data(symbols, dates):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if \'SPY\' not in symbols:  # add SPY for reference, if absent\n        symbols.insert(0, \'SPY\')\n\n    # Read and join data for each symbol\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=\'Date\', \n        parse_dates=True, usecols=[\'Date\', \'Adj Close\'], na_values=[\'nan\'])\n        \n        # Rename to \'Adj Close\' for each symbol to prevent clash\n        df_temp = df_temp.rename(columns={\'Adj Close\': symbol})\n        \n        df = df.join(df_temp)\n        if symbol == \'SPY\': # drop dates SPY didn\'t trade\n            df = df.dropna(subset=[\'SPY\'])\n\n    return df\n\n\ndef normalize_data(df):\n    """"""Normalize stock prices using the first row of the dataframe""""""\n    return df/df.iloc[0,:]\n\n\ndef plot_data(df, title=""Stock prices""):\n    """"""Plot stock prices with a custom title and meaningful axis labels.""""""\n    ax = df.plot(title=title, fontsize=12)\n    ax.set_xlabel(""Date"")\n    ax.set_ylabel(""Price"")\n    plt.show()\n\n\ndef plot_selected(df, columns, start_index, end_index):\n    """"""Plot the desired columns over index values in the given range.""""""\n    plot_data(df.loc[start_index:end_index, columns])\n\n\ndef test_run():\n    # Define a date range\n    dates = pd.date_range(\'2010-01-22\', \'2010-12-31\')\n\n    # Choose stock symbols to read\n    symbols = [\'GOOG\', \'IBM\', \'GLD\']\n    \n    # Get stock data\n    df = get_data(symbols, dates)\n\n    # Normalize the stock data\n    df = normalize_data(df)\n    print (df)\n\n    # Slice and plot\n    plot_selected(df, [\'SPY\', \'IBM\'], \'2010-01-22\', \'2010-04-01\')\n\nif __name__ == ""__main__"":\n    test_run()\n'"
03 numpy/locate_max_value.py,2,"b'""""""Locate maximum value.""""""\n\nimport numpy as np\n\n\ndef get_max_index(a):\n    """"""Return the index of the maximum value in given 1D array.""""""\n    return np.argmax(a)\n\n\ndef test_run():\n    a = np.array([9, 6, 2, 3, 12, 14, 7, 10], dtype=np.int32)  # 32-bit integer array\n    print (""Array:"", a)\n    \n    # Find the maximum and its index in array\n    print (""Maximum value:"", a.max())\n    print (""Index of max.:"", get_max_index(a))\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
04 stat_analysis_time_series/stat_analysis.py,0,"b'""""""Stat analysis for time series""""""\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef symbol_to_path(symbol, base_dir=""../../data""):\n    """"""Return CSV file path given ticker symbol.""""""\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\n\ndef get_data(symbols, dates):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if \'SPY\' not in symbols:  # add SPY for reference, if absent\n        symbols.insert(0, \'SPY\')\n\n    # Read and join data for each symbol\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=\'Date\', \n        parse_dates=True, usecols=[\'Date\', \'Adj Close\'], na_values=[\'nan\'])\n        \n        # Rename to \'Adj Close\' for each symbol to prevent clash\n        df_temp = df_temp.rename(columns={\'Adj Close\': symbol})\n        \n        df = df.join(df_temp)\n        if symbol == \'SPY\': # drop dates SPY didn\'t trade\n            df = df.dropna(subset=[\'SPY\'])\n\n    return df\n\n\ndef get_bollinger_bands(rm, rstd):\n    """"""\n    Return upper and lower Bollinger Bands.\n    :param rm: rolling mean of a series\n    :param rmstd: rolling std of a series\n    :return: Bollinger upper band and lower band\n    """"""\n    upper_band = rm + rstd*2\n    lower_band = rm - rstd*2\n    return upper_band, lower_band    \n\n\ndef compute_daily_returns(df):\n    """"""Compute and return the daily return values""""""\n    daily_returns = df.pct_change()\n    daily_returns.iloc[0,:] = 0\n    return daily_returns\n\n\ndef plot_data(df, title=""Stock prices"", xlabel=""Date"", ylabel=""Price""):\n    """"""Plot stock prices with a custom title and meaningful axis labels.""""""\n    ax = df.plot(title=title, fontsize=12)\n    ax.set_xlabel(""Date"")\n    ax.set_ylabel(""Price"")\n    plt.show()\n\n\ndef test_run():\n    # Define a date range\n    dates = pd.date_range(\'2012-01-01\', \'2012-12-31\')\n\n    # Choose stock symbols to read\n    symbols = [\'SPY\', \'XOM\']\n    \n    # Get stock data\n    df = get_data(symbols, dates)\n\n    # Compute Bollinger Bands for SPY\n    # 1. Compute rolling mean\n    rm_SPY = df[\'SPY\'].rolling(window=20).mean()\n\n    # 2. Compute rolling standard deviation\n    rstd_SPY = df[\'SPY\'].rolling(window=20).std()\n\n    # 3. Compute upper and lower bands\n    upper_band, lower_band = get_bollinger_bands(rm_SPY, rstd_SPY)\n    \n    # Plot raw SPY values, rolling mean and Bollinger Bands\n    ax = df[\'SPY\'].plot(title=""Bollinger Bands"", label=\'SPY\')\n    rm_SPY.plot(label=\'Rolling mean\', ax=ax)\n    upper_band.plot(label=\'upper band\', ax=ax)\n    lower_band.plot(label=\'lower band\', ax=ax)\n\n    # Add axis labels and legend\n    ax.set_xlabel(""Date"")\n    ax.set_ylabel(""Price"")\n    ax.legend(loc=\'upper left\')\n    plt.show()\n\n    # Compute and plot daily returns for SPY and XOM\n    daily_returns = compute_daily_returns(df)\n    plot_data(daily_returns, title=""Daily returns"", ylabel=""Daily returns"")\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
05 incomplete_data/fill_missing_values.py,0,"b'""""""Fill missing values""""""\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef symbol_to_path(symbol, base_dir=""../../data""):\n    """"""Return CSV file path given ticker symbol.""""""\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\n\ndef get_data(symbols, dates):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if \'SPY\' not in symbols:  # add SPY for reference, if absent\n        symbols.insert(0, \'SPY\')\n\n    # Read and join data for each symbol\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=\'Date\', \n        parse_dates=True, usecols=[\'Date\', \'Adj Close\'], na_values=[\'nan\'])\n        \n        # Rename to \'Adj Close\' for each symbol to prevent clash\n        df_temp = df_temp.rename(columns={\'Adj Close\': symbol})\n        \n        df = df.join(df_temp)\n        if symbol == \'SPY\': # drop dates SPY didn\'t trade\n            df = df.dropna(subset=[\'SPY\'])\n\n    return df\n\n\ndef fill_missing_values(df_data):\n    """"""Fill missing values in data frame, in place.""""""\n    df_data.fillna(method=\'ffill\', inplace=True)\n    df_data.fillna(method=\'bfill\', inplace=True) \n    return df_data\n\n\ndef plot_data(df_data):\n    """"""Plot stock data with appropriate axis labels.""""""\n    ax = df_data.plot(title=""Stock Data"", fontsize=2)\n    ax.set_xlabel(""Date"")\n    ax.set_ylabel(""Price"")\n    plt.show()\n\n\ndef test_run():\n    """"""Function called by Test Run.""""""\n    # Read data\n    symbol_list = [""JAVA"", ""FAKE1"", ""FAKE2""]  # list of symbols\n    start_date = ""2005-12-31""\n    end_date = ""2014-12-07""\n    dates = pd.date_range(start_date, end_date)  # date range as index\n    df_data = get_data(symbol_list, dates)  # get data for each symbol\n\n    # Fill missing values\n    fill_missing_values(df_data)\n\n    # Plot\n    plot_data(df_data)\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
06 histograms_scatter_plots/histograms_scatter_plots.py,4,"b'""""""Histograms and scatter plots""""""\n\nimport os\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef symbol_to_path(symbol, base_dir=""../../data""):\n    """"""Return CSV file path given ticker symbol.""""""\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\n\ndef get_data(symbols, dates):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if ""SPY"" not in symbols:  # add SPY for reference, if absent\n        symbols.insert(0, ""SPY"")\n\n    # Read and join data for each symbol\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=""Date"", \n        parse_dates=True, usecols=[""Date"", ""Adj Close""], na_values=[""nan""])\n        \n        # Rename to ""Adj Close"" for each symbol to prevent clash\n        df_temp = df_temp.rename(columns={""Adj Close"": symbol})\n        \n        df = df.join(df_temp)\n        if symbol == ""SPY"": # drop dates SPY didn""t trade\n            df = df.dropna(subset=[""SPY""])\n\n    return df\n\n\ndef compute_daily_returns(df):\n    """"""Compute and return the daily return values""""""\n    daily_returns = df.pct_change()\n    daily_returns.iloc[0,:] = 0\n    return daily_returns\n\n\ndef test_run():\n    # Define a date range\n    dates = pd.date_range(""2009-01-01"", ""2012-12-31"")\n\n    # Choose stock symbols to read\n    symbols = [""SPY"", ""XOM"", ""GLD""]\n    \n    # Get stock data\n    df = get_data(symbols, dates)\n\n    # Compute daily returns for SPY and XOM\n    daily_returns = compute_daily_returns(df)\n\n    # Plot both histograms on the same plot\n    daily_returns[""SPY""].hist(bins=20, label=""SPY"")\n    daily_returns[""XOM""].hist(bins=20, label=""XOM"")\n    plt.legend(loc=""upper right"")\n    plt.show()\n    # Another way to plot the above histogram\n    #daily_returns.plot(kind=""hist"", bins=20, y=[""SPY"", ""XOM""])\n\n\n    # Scatterplot SPY vs. XOM and SPY vs. GLD and the respective best fitting lines\n    # Two subplots appear side by side\n    f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n    \n    # The first subplot SPY vs. XOM and its best fitting line\n    ax1.scatter(daily_returns[""SPY""], daily_returns[""XOM""])\n    beta_XOM, alpha_XOM = np.polyfit(daily_returns[""SPY""], daily_returns[""XOM""], 1)\n    print (""beta_XOM = {}\\nalpha_XOM = {}"".format(beta_XOM, alpha_XOM))\n    ax1.plot(daily_returns[""SPY""], beta_XOM*daily_returns[""SPY""] + alpha_XOM, ""-"", color=""r"")\n    \n    # The first subplot SPY vs. GLD and its best fitting line\n    ax2.scatter(daily_returns[""SPY""], daily_returns[""GLD""])\n    beta_GLD, alpha_GLD = np.polyfit(daily_returns[""SPY""], daily_returns[""GLD""], 1)\n    print (""beta_GLD = {}\\nalpha_GLD = {}"".format(beta_GLD, alpha_GLD))\n    ax2.plot(daily_returns[""SPY""], beta_GLD*daily_returns[""SPY""] + alpha_GLD, ""-"", color=""r"")\n    \n    plt.show()\n\n\n    """"""\n    # Plot the above scatterplots into separate graphs\n    # Scatterplot SPY vs. XOM    \n    daily_returns.plot(kind=""scatter"", x=""SPY"", y=""XOM"")\n    beta_XOM, alpha_XOM = np.polyfit(daily_returns[""SPY""], daily_returns[""XOM""], 1)\n    print (""beta_XOM = {}\\nalpha_XOM={}"".format(beta_XOM, alpha_XOM))\n    plt.plot(daily_returns[""SPY""], beta_XOM*daily_returns[""SPY""] + alpha_XOM, ""-"", color=""r"")\n    plt.show()\n\n    # Scatterplot SPY vs. GLD    \n    daily_returns.plot(kind=""scatter"", x=""SPY"", y=""GLD"")\n    beta_GLD, alpha_GLD = np.polyfit(daily_returns[""SPY""], daily_returns[""GLD""], 1)\n    print (""beta_GLD = {}\\nalpha_GLD={}"".format(beta_GLD, alpha_GLD))\n    plt.plot(daily_returns[""SPY""], beta_GLD*daily_returns[""SPY""] + alpha_GLD, ""-"", color=""r"")\n    plt.show()\n    """"""\n\n    # Calculate the correlation coefficient\n    print (daily_returns.corr(method=""pearson""))\n\nif __name__ == ""__main__"":\n    test_run()\n'"
07 sharpe ratio/sharpe_ratio.py,1,"b'""""""Compute Sharpe ratio""""""\n\nimport numpy as np\n\n\ndef compute_sharpe_ratio(k, avg_return, risk_free_rate, std_return):\n    """"""\n    Compute and return the Sharpe ratio\n    :param k: adjustment factor, sqrt(252) for daily data, sqrt(52) for weekly data, sqrt(12) for monthly data\n    :param avg_return: daily, weekly or monthly return\n    :param risk_free_rate: daily, weekly or monthly risk free rate\n    :param std_return: daily, weekly or monthly standard deviation\n    :return: sharpe_ratio, k * (avg_return - risk_free_rate) / std_return\n    """"""\n    return k * (avg_return - risk_free_rate) / std_return\n    \n\n\ndef test_run():\n    # 60 days of data\n    avg_daily_return = 0.001\n    daily_risk_free_rate = 0.0002\n    std_daily_return = 0.001\n\n    # Calculate Sharpe ratio for the above data\n    print (compute_sharpe_ratio(np.sqrt(252), avg_daily_return, daily_risk_free_rate, std_daily_return))\n    \nif __name__ == ""__main__"":\n    test_run()\n'"
08 optimizers_parameterized_model/minimizer.py,0,"b'""""""Minimize an objective function, using SciPy""""""\n\nimport numpy as np\nimport scipy.optimize as spo\n\n\ndef f(X):\n    """"""Given a scalar X, return some value (a real number)""""""\n    Y = (X - 1.5)**2 + 0.5\n    print (""X = {}, Y = {}"".format(X, Y)) # for tracing\n    return Y\n\n\ndef test_run():\n    Xguess = 2.0\n    min_result = spo.minimize(f, Xguess, method=""SLSQP"", options={""disp"": True})\n    print (""Minima found at:"")\n    print (""X = {}, Y = {}"".format(min_result.x, min_result.fun))\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
08 optimizers_parameterized_model/parameterized_model.py,18,"b'""""""Build a parameterized model""""""\n\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.optimize as spo\n\n\ndef error_line(coefficients, data):\n\t""""""Compute error between given line model f(x) = mx + b and observed data\n\n\tParameters:\n\tcoefficients: tuple/list/array (m,b) where m is slope and b is Y-intercept of the line model\n\tdata: 2D array where each row is a point (x, y)\n\t\n\tReturns error as a single real value\n\t""""""\n\t\n\t# Error = sum of squared differences between actual Y-axis data and estimated data by the line model\n\terr = np.sum((data[:, 1] - (coefficients[0] * data[:, 0] + coefficients[1]))**2)\n\treturn err\n\n\ndef fit_line(data, error_func):\n\t""""""Fit a line to given data, using a supplied error function.\n\t\n\tParameters:\n\tdata: 2D array where each row is a point (x, y)\n\terror_func: function that computes the error between a line and observed data\n\n\tReturns line that minimizes the error function\n\t""""""\n\t\n\t# Generate initial guess for line model\n\tl = np.float32([0, np.mean(data[:, 1])]) # m = 0, b = mean of the data\n\n\t# Plot initial guess\n\tx_initial_guess = np.float32([-5, 5])\n\tplt.plot(x_initial_guess, l[0] * x_initial_guess + l[1], ""m--"", linewidth=2.0, label=""Initial guess"")\n\n\t# Call optimizer to minimize error function\n\tresult = spo.minimize(error_func, l, args=(data,), method=""SLSQP"", options={""disp"": True}) # args: used to pass data to error_func\n\treturn result.x\n\n\ndef error_poly(coefficients, data):\n\t""""""Compute error between given polynomial model and observed data\n\n\tParameters:\n\tcoefficients: numpy.poly1d object or equivalent array representing polynomial coefficients\n\tdata: 2D array where each row is a point (x, y)\n\t\n\tReturns error as a single real value\n\t""""""\n\n\t# Error = sum of squared differences between actual Y-axis data and estimated data by the line model\n\terr = np.sum((data[:, 1] - np.polyval(coefficients, data[:, 0]))**2)\n\treturn err\n\n\ndef fit_poly(data, error_func, degree=3):\n\t""""""Fit a polynomial to given data, using a supplied error function.\n\t\n\tParameters:\n\tdata: 2D array where each row is a point (x, y)\n\terror_func: function that computes the error between a polynomial and observed data\n\n\tReturns polynomial that minimizes the error function\n\t""""""\n\n\t# Generate initial guess for polynomial model\n\tpoly_guess = np.poly1d(np.ones(degree + 1, dtype=np.float32))\n\n\t# Plot initial guess\n\tx_initial_guess = np.linspace(-5, 5, 21)\n\tplt.plot(x_initial_guess, np.polyval(poly_guess, x_initial_guess), ""m--"", linewidth=2.0, label=""Initial guess"")\n\n\t# Call optimizer to minimize error function\n\tresult = spo.minimize(error_func, poly_guess, args=(data,), method=""SLSQP"", options={""disp"": True}) # args: used to pass data to error_func\n\treturn np.poly1d(result.x)\n\n\ndef test_run():\n    """"""Build a line model""""""\n    # Define original line\n    l_orig = np.float32([4,2])\n    print (""Original line: m = {}, b = {}"".format(l_orig[0], l_orig[1]))\n    X_orig = np.linspace(0, 10, 21)\n    Y_orig = l_orig[0] * X_orig + l_orig[1]\n    plt.plot(X_orig, Y_orig, ""b--"", linewidth=2.0, label=""Original line"")\n\n    # Generate noisy data points from a normal distribution\n    scale = 3.0 # Standard deviation (spread or \xe2\x80\x9cwidth\xe2\x80\x9d) of the distribution\n    noise = np.random.normal(0.0, scale, Y_orig.shape)\n    data = np.asarray([X_orig, Y_orig + noise]).T\n    plt.plot(data[:, 0], data[:, 1], ""go"", label=""Data points"")\n\n    # Try to fit a line to this data\n    l_fit = fit_line(data, error_line)\n    print (""Fitted line: m = {}, b = {}"".format(l_fit[0], l_fit[1]))\n    plt.plot(data[:, 0], l_fit[0] * data[:, 0] + l_fit[1], ""r--"", linewidth=2.0, label=""Fitted line"")\n\n    # Add a legend and show plot\n    plt.legend(loc=""upper left"")\n    plt.show()\n    \n\n    """"""Build a polynomial model""""""\n    # Define original polynomial\n    poly_orig = np.poly1d([1.5, -10, -5, 60, 50])\n    print (""Original polynomial:\\n"", poly_orig)\n    X_poly_orig = np.linspace(-5, 5, 21)\n    Y_poly_orig = np.polyval(poly_orig, X_poly_orig)\n    plt.plot(X_poly_orig, Y_poly_orig, ""b--"", linewidth=2.0, label=""Original polynomial"")\n\n    # Generate noisy data points from a normal distribution\n    scale_poly = 3.0 # Standard deviation (spread or \xe2\x80\x9cwidth\xe2\x80\x9d) of the distribution\n    noise_poly = np.random.normal(0.0, scale_poly, Y_poly_orig.shape)\n    data_poly = np.asarray([X_poly_orig, Y_poly_orig + noise_poly]).T\n    plt.plot(data_poly[:, 0], data_poly[:, 1], ""go"", label=""Data points"")\n\n    # Try to fit a polynomial to this data\n    poly_fit = fit_poly(data_poly, error_poly, degree=4)\n    print (""Fitted polynomial:\\n"", poly_fit)\n    plt.plot(data_poly[:, 0], np.polyval(poly_fit, data_poly[:, 0]), ""r--"", linewidth=2.0, label=""Fitted polynomial"")\n\n    # Add a legend and show plot\n    plt.legend(loc=""upper left"")  \n    plt.show()\n\n\nif __name__ == ""__main__"":\n    test_run()\n'"
09a_portfolio_analysis/__init__.py,0,b''
09a_portfolio_analysis/analysis.py,1,"b'""""""Analyze a portfolio""""""\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport datetime as dt\nimport sys\n# Append the path of the directory one level above the current directory to import util\nsys.path.append(\'../\')\nfrom util import *\n\n\ndef assess_portfolio(sd = dt.datetime(2008,1,1), ed = dt.datetime(2009,1,1), \\\n    syms = [""GOOG"",""AAPL"",""GLD"",""XOM""], \\\n    allocs=[0.1,0.2,0.3,0.4], \\\n    sv=1000000, rfr=0.0, sf=252.0, \\\n    gen_plot=False):\n\n    """"""Assess a portfolio by computing statistics\n\n    Parameters:\n    sd: A datetime object that represents the start date\n    ed: A datetime object that represents the end date\n    syms: A list of symbols that make up the portfolio\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    rfr: The risk free return per sample period for the entire date range, assuming it does not change\n    sf: Sampling frequency per year\n    gen_plot: If True, create a plot named plot.png\n\n    Returns:\n    cr: Cumulative return\n    adr: Average period return (if sf == 252 this is daily return)\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    ev: End value of portfolio\n    """"""\n\n    # Read in adjusted closing prices for given symbols, date range\n    dates = pd.date_range(sd, ed)\n    prices_all = get_data(syms, dates)  # automatically adds SPY\n    prices = prices_all[syms]  # only portfolio symbols\n    prices_SPY = prices_all[""SPY""]  # only SPY, for comparison later\n\n    # Get daily portfolio value\n    port_val = get_portfolio_value(prices, allocs, sv)\n\n    # Get portfolio statistics (sddr == volatility)\n    cr, adr, sddr, sr = get_portfolio_stats(port_val, rfr, sf)\n\n    # Compare daily portfolio value with SPY using a normalized plot\n    if gen_plot:\n        # Create a temporary dataframe with both the SPY and Portfolio\n        df_temp = pd.concat([port_val, prices_SPY], keys=[""Portfolio"", ""SPY""], axis=1)\n        plot_normalized_data(df_temp, title=""Daily portfolio and SPY"", xlabel=""Date"", ylabel=""Normalized price"")    \n\n    # Compute end value\n    ev = port_val.iloc[-1, 0]\n\n    return cr, adr, sddr, sr, ev\n\n\ndef get_portfolio_value(prices, allocs, sv):\n    """"""Helper function to compute portfolio value\n\n    Parameters:\n    prices: Adjusted closing prices for portfolio symbols\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    \n    Returns:\n    port_val: A dataframe object showing the portfolio value for each day\n    """"""\n\n    # Normalize the prices according to the first day\n    norm_prices = normalize_data(prices)\n\n    # Compute prices based on the allocations\n    alloc_prices = norm_prices * allocs\n\n    # Calculate position values\n    pos_vals = alloc_prices * sv\n\n    # Get daily portfolio value\n    port_val = pos_vals.sum(axis=1).to_frame()\n    port_val.columns = [""port_val""]\n\n    return port_val\n\n\ndef get_portfolio_stats(port_val, daily_rf, samples_per_year):\n    """"""Helper function to compute portfolio statistics\n\n    Parameters:\n    port_val: Portfolio value\n    daily_rf: Daily risk-free rate, assuming it does not change\n    samples_per_year: Sampling frequency per year\n    \n    Returns:\n    cr: Cumulative return\n    adr: Average daily return\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    """"""\n    cr = port_val.iloc[-1, 0]/port_val.iloc[0, 0] - 1\n\n    daily_returns = compute_daily_returns(port_val)[1:]\n    adr = daily_returns[""port_val""].mean()\n    sddr = daily_returns[""port_val""].std()\n    sr = compute_sharpe_ratio(np.sqrt(samples_per_year), adr, daily_rf, sddr)\n\n    return cr, adr, sddr, sr\n\n\ndef plot_normalized_data(df, title, xlabel, ylabel):\n    """"""Helper function to normalize and plot data""""""\n\n    # Normalize the data\n    df = normalize_data(df)\n\n    # Plot the normalized data\n    plot_data(df, title=title, xlabel=xlabel, ylabel=ylabel)\n\n\ndef test_code():\n    # Define input parameters\n    start_date = dt.datetime(2010,1,1)\n    end_date = dt.datetime(2010,12,31)\n    symbols = [""GOOG"", ""AAPL"", ""GLD"", ""XOM""]\n    allocations = [0.2, 0.3, 0.4, 0.1]\n    start_val = 1000000  \n    risk_free_rate = 0.0\n    sample_freq = 252\n\n    # Assess the portfolio\n    cr, adr, sddr, sr, ev = assess_portfolio(sd = start_date, ed = end_date,\\\n        syms = symbols, \\\n        allocs = allocations,\\\n        sv = start_val, \\\n        gen_plot = True)\n\n    # Print statistics\n    print (""Start Date:"", start_date)\n    print (""End Date:"", end_date)\n    print (""Symbols:"", symbols)\n    print (""Allocations:"", allocations)\n    print (""Sharpe Ratio:"", sr)\n    print (""Volatility (stdev of daily returns):"", sddr)\n    print (""Average Daily Return:"", adr)\n    print (""Cumulative Return:"", cr)\n    print (""End value:"", ev)\n\nif __name__ == ""__main__"":\n    test_code()\n'"
09b_optimize_portfolio/__init__.py,0,b''
09b_optimize_portfolio/analysis.py,1,"b'""""""Analyze a portfolio""""""\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport datetime as dt\nimport sys\n# Append the path of the directory one level above the current directory to import util\nsys.path.append(\'../\')\nfrom util import *\n\n\ndef assess_portfolio(sd = dt.datetime(2008,1,1), ed = dt.datetime(2009,1,1), \\\n    syms = [""GOOG"",""AAPL"",""GLD"",""XOM""], \\\n    allocs=[0.1,0.2,0.3,0.4], \\\n    sv=1000000, rfr=0.0, sf=252.0, \\\n    gen_plot=False):\n\n    """"""Assess a portfolio by computing statistics\n\n    Parameters:\n    sd: A datetime object that represents the start date\n    ed: A datetime object that represents the end date\n    syms: A list of symbols that make up the portfolio\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    rfr: The risk free return per sample period for the entire date range, assuming it does not change\n    sf: Sampling frequency per year\n    gen_plot: If True, create a plot named plot.png\n\n    Returns:\n    cr: Cumulative return\n    adr: Average period return (if sf == 252 this is daily return)\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    ev: End value of portfolio\n    """"""\n\n    # Read in adjusted closing prices for given symbols, date range\n    dates = pd.date_range(sd, ed)\n    prices_all = get_data(syms, dates)  # automatically adds SPY\n    prices = prices_all[syms]  # only portfolio symbols\n    prices_SPY = prices_all[""SPY""]  # only SPY, for comparison later\n\n    # Get daily portfolio value\n    port_val = get_portfolio_value(prices, allocs, sv)\n\n    # Get portfolio statistics (sddr == volatility)\n    cr, adr, sddr, sr = get_portfolio_stats(port_val, rfr, sf)\n\n    # Compare daily portfolio value with SPY using a normalized plot\n    if gen_plot:\n        # Create a temporary dataframe with both the SPY and Portfolio\n        df_temp = pd.concat([port_val, prices_SPY], keys=[""Portfolio"", ""SPY""], axis=1)\n        plot_normalized_data(df_temp, title=""Daily portfolio and SPY"", xlabel=""Date"", ylabel=""Normalized price"")    \n\n    # Compute end value\n    ev = port_val.ix[-1, 0]\n\n    return cr, adr, sddr, sr, ev\n\n\ndef get_portfolio_value(prices, allocs, sv):\n    """"""Helper function to compute portfolio value\n\n    Parameters:\n    prices: Adjusted closing prices for portfolio symbols\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    \n    Returns:\n    port_val: A dataframe object showing the portfolio value for each day\n    """"""\n\n    # Normalize the prices according to the first day\n    norm_prices = normalize_data(prices)\n\n    # Compute prices based on the allocations\n    alloc_prices = norm_prices * allocs\n\n    # Calculate position values\n    pos_vals = alloc_prices * sv\n\n    # Get daily portfolio value\n    port_val = pos_vals.sum(axis=1).to_frame()\n    port_val.columns = [""port_val""]\n\n    return port_val\n\n\ndef get_portfolio_stats(port_val, daily_rf, samples_per_year):\n    """"""Helper function to compute portfolio statistics\n\n    Parameters:\n    port_val: Portfolio value\n    daily_rf: Daily risk-free rate, assuming it does not change\n    samples_per_year: Sampling frequency per year\n    \n    Returns:\n    cr: Cumulative return\n    adr: Average daily return\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    """"""\n    cr = port_val.iloc[-1, 0]/port_val.iloc[0, 0] - 1\n\n    daily_returns = compute_daily_returns(port_val)[1:]\n    adr = daily_returns[""port_val""].mean()\n    sddr = daily_returns[""port_val""].std()\n    sr = compute_sharpe_ratio(np.sqrt(samples_per_year), adr, daily_rf, sddr)\n\n    return cr, adr, sddr, sr\n\n\ndef plot_normalized_data(df, title, xlabel, ylabel):\n    """"""Helper function to normalize and plot data""""""\n\n    # Normalize the data\n    df = normalize_data(df)\n\n    # Plot the normalized data\n    plot_data(df, title=title, xlabel=xlabel, ylabel=ylabel)\n\n\ndef test_code():\n    # Define input parameters\n    start_date = dt.datetime(2010,1,1)\n    end_date = dt.datetime(2010,12,31)\n    symbols = [""GOOG"", ""AAPL"", ""GLD"", ""XOM""]\n    allocations = [0.2, 0.3, 0.4, 0.1]\n    start_val = 1000000  \n    risk_free_rate = 0.0\n    sample_freq = 252\n\n    # Assess the portfolio\n    cr, adr, sddr, sr, ev = assess_portfolio(sd = start_date, ed = end_date,\\\n        syms = symbols, \\\n        allocs = allocations,\\\n        sv = start_val, \\\n        gen_plot = True)\n\n    # Print statistics\n    print (""Start Date:"", start_date)\n    print (""End Date:"", end_date)\n    print (""Symbols:"", symbols)\n    print (""Allocations:"", allocations)\n    print (""Sharpe Ratio:"", sr)\n    print (""Volatility (stdev of daily returns):"", sddr)\n    print (""Average Daily Return:"", adr)\n    print (""Cumulative Return:"", cr)\n    print (""End value:"", ev)\n\nif __name__ == ""__main__"":\n    test_code()\n'"
09b_optimize_portfolio/optimization.py,2,"b'""""""Project: Optimize a portfolio""""""\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport datetime as dt\nimport scipy.optimize as spo\nfrom analysis import *\nimport sys\n# Append the path of the directory one level above the current directory to import util\nsys.path.append(\'../\')\nfrom util import *\n\n\ndef optimize_portfolio(sd=dt.datetime(2008,1,1), ed=dt.datetime(2009,1,1), \\\n    syms=[""GOOG"",""AAPL"",""GLD"",""XOM""], gen_plot=False):\n\n    """"""Optimize a portfolio and compute its statistics\n\n    Parameters:\n    sd: A datetime object that represents the start date\n    ed: A datetime object that represents the end date\n    syms: A list of symbols that make up the portfolio\n    gen_plot: If True, create a plot named plot.png\n\n    Returns:\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    cr: Cumulative return\n    adr: Average period return (if sf == 252 this is daily return)\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    """"""\n\n    # Read in adjusted closing prices for given symbols, date range\n    dates = pd.date_range(sd, ed)\n    prices_all = get_data(syms, dates)  # automatically adds SPY\n    prices = prices_all[syms]  # only portfolio symbols\n    prices_SPY = prices_all[""SPY""]  # only SPY, for comparison later\n\n    # find the allocations for the optimal portfolio\n    allocs = find_optimal_allocations(prices, get_negative_sharpe_ratio, syms)\n\n    # Get daily portfolio value\n    port_val = get_portfolio_value(prices, allocs, sv=1000000)\n    cr, adr, sddr, sr = get_portfolio_stats(port_val, daily_rf=0.0, samples_per_year=252)\n\n    # Compare daily portfolio value with SPY using a normalized plot\n    if gen_plot:\n        # add code to plot here\n        df_temp = pd.concat([port_val, prices_SPY], keys=[""Portfolio"", ""SPY""], axis=1)\n        plot_normalized_data(df_temp, title=""Daily portfolio and SPY"", xlabel=""Date"", ylabel=""Normalized price"")    \n\n    return allocs, cr, adr, sddr, sr\n\n\ndef find_optimal_allocations(prices, function, syms):\n    bounds = ((0,1),(0,1),(0,1),(0,1))\n\n    constraints = ({\'type\': \'eq\', \'fun\': lambda x:  np.sum(x)-1.0})\n\n    initial_guess = np.ones((len(syms)), dtype=np.float32)/(len(syms))\n\n    result = spo.minimize(function, initial_guess, args=(prices,), method=\'SLSQP\', constraints=constraints, bounds=bounds)\n    return result.x\n\n\ndef get_negative_sharpe_ratio(allocs, prices, sv=1000000, rfr=0.0, sf=252):\n    # Get daily portfolio value\n    port_val = get_portfolio_value(prices, allocs, sv)\n\n    # Get portfolio statistics\n    neg_sr = get_portfolio_stats(port_val, rfr, sf)[3] * (-1)\n\n    return neg_sr'"
09b_optimize_portfolio/test_optimization.py,0,"b'""""""Test for optimization.py""""""\n\n\nimport datetime as dt\nfrom optimization import *\nimport unittest\nimport math\n\n\nclass TestOptimizePortfolio(unittest.TestCase):\n\n    def test_optimize(self):\n        sd = dt.datetime(2010,1,1)\n        ed = dt.datetime(2010,12,31)\n        syms = [""GOOG"", ""AAPL"", ""GLD"", ""XOM""]\n        allocs, cr, adr, sddr, sr = optimize_portfolio(sd, ed, syms)\n\n        # sum(allocations) == 1.0 +- 0.02\n        self.assertTrue(math.isclose(sum(allocs), 1.0, rel_tol=0.02), ""sum(allocations is not within 0.2 of 1.0"")\n\n        # Test allocations\n        reference_solution = [5.38105153e-16, 3.96661695e-01, 6.03338305e-01, -5.42000166e-17]\n        for i in range(len(allocs)):\n            # Each allocation is between 0 and 1.0 +- 0.02\n            self.assertTrue(allocs[i] >= -0.02, ""Allocation is negative"")\n            self.assertTrue(allocs[i] <= 1.02, ""Allocation is greater than 1"")\n\n            # Each allocation matches reference solution +- 0.10\n            self.assertTrue(math.isclose(round(allocs[i], 3), round(reference_solution[i], 3), rel_tol=1))\n\n        # Test cumulative return\n        self.assertTrue(math.isclose(cr, 0.360090826885, rel_tol=0.02), ""Cumulative return is incorrect"")\n\n        # Test average daily return\n        self.assertTrue(math.isclose(adr, 0.00127710312803, rel_tol=0.02), ""Average daily return is incorrect"")\n\n        # Test standard deviation of daily returns\n        self.assertTrue(math.isclose(sddr, 0.0101163831312, rel_tol=0.02), ""Standard deviation is incorrect"")\n\n        # Test Sharpe Ratio\n        self.assertTrue(math.isclose(sr, 2.00401501102, rel_tol=0.02), ""Sharpe ratio is incorrect"")\n    \n\nif __name__ == \'__main__\':\n    unittest.main()'"
