file_path,api_count,code
QLearner.py,2,"b'""""""Implement QLearner, a Reinforcement Learning class""""""\n\nimport numpy as np\nimport random as rand\nfrom copy import deepcopy\n\nclass QLearner(object):\n\n    def __init__(self, num_states=100, num_actions=4, alpha=0.2,\n        gamma=0.9, rar=0.5, radr=0.99, dyna=0, verbose=False):\n        """"""The constructor QLearner() reserves space for keeping track of Q[s, a] for \n        the number of states and actions. It initializes Q[] with all zeros.\n\n        Parameters:\n        num_states: int, the number of states to consider\n        num_actions: int, the number of actions available\n        alpha: float, the learning rate used in the update rule. \n               Should range between 0.0 and 1.0 with 0.2 as a typical value\n        gamma: float, the discount rate used in the update rule. \n               Should range between 0.0 and 1.0 with 0.9 as a typical value.\n        rar: float, random action rate. The probability of selecting a random action \n             at each step. Should range between 0.0 (no random actions) to 1.0 \n             (always random action) with 0.5 as a typical value.\n        radr: float, random action decay rate, after each update, rar = rar * radr. \n              Ranges between 0.0 (immediate decay to 0) and 1.0 (no decay). Typically 0.99.\n        dyna: int, conduct this number of dyna updates for each regular update. \n              When Dyna is used, 200 is a typical value.\n        verbose: boolean, if True, your class is allowed to print debugging \n                 statements, if False, all printing is prohibited.\n        """"""        \n        self.num_states = num_states\n        self.num_actions = num_actions\n        self.alpha = alpha\n        self.gamma = gamma\n        self.rar = rar\n        self.radr = radr\n        self.dyna = dyna\n        self.verbose = verbose\n\n        # Keep track of the latest state and action which are initialized to 0\n        self.s = 0\n        self.a = 0\n        \n        # Initialize a Q table which records and updates Q value for\n        # each action in each state\n        self.Q = np.zeros(shape=(num_states, num_actions))\n        # Keep track of the number of transitions from s to s_prime for when taking \n        # an action a when doing Dyna-Q\n        self.T = {}\n        # Keep track of reward for each action in each state when doing Dyna-Q\n        self.R = np.zeros(shape=(num_states, num_actions))\n\n    def query_set_state(self, s):\n        """"""Find the next action to take in state s. Update the latest state and action \n        without updating the Q table. Two main uses for this method: 1) To set the  \n        initial state, and 2) when using a learned policy, but not updating it.\n\n        Parameters:\n        s: The new state\n        \n        Returns: The selected action to take in s\n        """"""\n        if rand.uniform(0.0, 1.0) < self.rar:\n            action = rand.randint(0, self.num_actions - 1)\n        else:\n            action = self.Q[s, :].argmax()\n        self.s = s\n        self.a = action\n        if self.verbose: \n            print (""s ="", s,""a ="",action)\n        return action\n\n    def query(self, s_prime, r):\n        """"""Find the next action to take in state s_prime. Update the latest state \n        and action and the Q table. Update rule:\n        Q\'[s, a] = (1 - \xce\xb1) \xc2\xb7 Q[s, a] + \xce\xb1 \xc2\xb7 (r + \xce\xb3 \xc2\xb7 Q[s\', argmax a\'(Q[s\', a\'])]).\n\n        Parameters:\n        s_prime: int, the new state\n        r: float, a real valued immediate reward for taking the previous action\n        \n        Returns: The selected action to take in s_prime\n        """"""\n        # Update the Q value of the latest state and action based on s_prime and r\n        self.Q[self.s, self.a] = (1 - self.alpha) * self.Q[self.s, self.a] \\\n                                    + self.alpha * (r + self.gamma \n                                    * self.Q[s_prime, self.Q[s_prime, :].argmax()])\n\n        # Implement Dyna-Q\n        if self.dyna > 0:\n            # Update the reward table\n            self.R[self.s, self.a] = (1 - self.alpha) * self.R[self.s, self.a] \\\n                                        + self.alpha * r\n            \n            if (self.s, self.a) in self.T:\n                if s_prime in self.T[(self.s, self.a)]:\n                    self.T[(self.s, self.a)][s_prime] += 1\n                else:\n                    self.T[(self.s, self.a)][s_prime] = 1\n            else:\n                self.T[(self.s, self.a)] = {s_prime: 1}\n            \n            Q = deepcopy(self.Q)\n            for i in range(self.dyna):\n                s = rand.randint(0, self.num_states - 1)\n                a = rand.randint(0, self.num_actions - 1)\n                if (s, a) in self.T:\n                    # Find the most common s_prime as a result of taking a in s\n                    s_pr = max(self.T[(s, a)], key=lambda k: self.T[(s, a)][k])\n                    # Update the temporary Q table\n                    Q[s, a] = (1 - self.alpha) * Q[s, a] \\\n                                + self.alpha * (self.R[s, a] + self.gamma \n                                * Q[s_pr, Q[s_pr, :].argmax()])\n            # Update the Q table of the learner once Dyna-Q is complete\n            self.Q = deepcopy(Q)\n        \n        # Find the next action to take and update the latest state and action\n        a_prime = self.query_set_state(s_prime)\n        self.rar *= self.radr\n        if self.verbose: \n            print (""s ="", s_prime,""a ="",a_prime,""r ="",r)\n        return a_prime'"
StrategyLearner.py,2,"b'""""""Implement a StrategyLearner that trains a QLearner for trading a symbol.""""""\n\nimport numpy as np\nimport datetime as dt\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom util import get_data, create_df_benchmark, create_df_trades\nimport QLearner as ql\nfrom indicators import get_momentum, get_sma_indicator, compute_bollinger_value\nfrom marketsim import compute_portvals_single_symbol, market_simulator\nfrom analysis import get_portfolio_stats\n\n\nclass StrategyLearner(object):\n    # Constants for positions and order signals\n    LONG = 1\n    CASH = 0\n    SHORT = -1\n\n    def __init__(self, num_shares=1000, epochs=100, num_steps=10, \n                 impact=0.0, commission=0.00, verbose=False, **kwargs):\n        """"""Instantiate a StrategLearner that can learn a trading policy.\n\n        Parameters:\n        num_shares: The number of shares that can be traded in one order\n        epochs: The number of times to train the QLearner\n        num_steps: The number of steps used in getting thresholds for the\n        discretization process. It is the number of groups to put data into.\n        impact: The amount the price moves against the trader compared to the\n        historical data at each transaction\n        commission: The fixed amount in dollars charged for each transaction\n        verbose: If True, print and plot data in add_evidence\n        **kwargs: Arguments for QLearner\n        """"""\n        self.epochs = epochs\n        self.num_steps = num_steps\n        self.num_shares = num_shares\n        self.impact = impact\n        self.commission = commission\n        self.verbose = verbose\n        # Initialize a QLearner\n        self.q_learner = ql.QLearner(**kwargs)\n\n    def get_features(self, prices):\n        """"""Compute technical indicators and use them as features to be fed\n        into a Q-learner.\n        \n        Parameters:\n        prices: Adjusted close prices of the given symbol\n        \n        Returns:\n        df_features: A pandas dataframe of the technical indicators\n        """"""\n        window = 10\n        # Compute rolling mean\n        rolling_mean = prices.rolling(window=window).mean()\n        # Compute_rolling_std\n        rolling_std = prices.rolling(window=window).std()\n        # Compute momentum\n        momentum = get_momentum(prices, window)\n        # Compute SMA indicator\n        sma_indicator = get_sma_indicator(prices, rolling_mean)\n        # Compute Bollinger value\n        bollinger_val = compute_bollinger_value(prices, rolling_mean, rolling_std)\n        # Create a dataframe with three features\n        df_features = pd.concat([momentum, sma_indicator], axis=1)\n        df_features = pd.concat([df_features, bollinger_val], axis=1)\n        df_features.columns = [""ind{}"".format(i) \n                                for i in range(len(df_features.columns))]\n        df_features.dropna(inplace=True)\n        return df_features\n\n    def get_thresholds(self, df_features, num_steps):\n        """"""Compute the thresholds to be used in the discretization of features.\n        thresholds is a 2-d numpy array where the first dimesion indicates the \n        indices of features in df_features and the second dimension refers to \n        the value of a feature at a particular threshold.\n        """"""\n        step_size = round(df_features.shape[0] / num_steps)\n        df_copy = df_features.copy()\n        thres = np.zeros(shape=(df_features.shape[1], num_steps))\n        for i, feat in enumerate(df_features.columns):\n            df_copy.sort_values(by=[feat], inplace=True)\n            for step in range(num_steps):\n                if step < num_steps - 1:\n                    thres[i, step] = df_copy[feat].iloc[(step + 1) * step_size]\n                # The last threshold must be = the largest value in df_copy\n                else:\n                    thres[i, step] = df_copy[feat].iloc[-1]\n        return thres\n\n    def discretize(self, df_features, non_neg_position, thresholds):\n        """"""Discretize features and return a state.\n\n        Parameters:\n        df_features: The technical indicators to be discretized. They were  \n        computed in get_features()\n        non_neg_position: The position at the beginning of a particular day,\n        before taking any action on that day. It is >= 0 so that state >= 0\n\n        Returns:\n        state: A state in the Q-table from which we will query for an action.\n        It indicates an index of the first dimension in the Q-table\n        """"""\n        state = non_neg_position * pow(self.num_steps, len(df_features))\n        for i in range(len(df_features)):\n            thres = thresholds[i][thresholds[i] >= df_features[i]][0]\n            thres_i = np.where(thresholds == thres)[1][0]\n            state += thres_i * pow(self.num_steps, i)\n        return state\n\n    def get_position(self, old_pos, signal):\n        """"""Find a new position based on the old position and the given signal.\n        signal = action - 1; action is a result of querying a state, which was\n        computed in discretize(), in the Q-table. An action is 0, 1 or 2. It is\n        an index of the second dimension in the Q-table. We have to subtract 1\n        from action to get a signal of -1, 0 or 1 (short, cash or long).\n        """"""\n        new_pos = self.CASH\n        # If old_pos is not long and signal is to buy, new_pos will be long\n        if old_pos < self.LONG and signal == self.LONG:\n            new_pos = self.LONG\n        # If old_pos is not short and signal is to sell, new_pos will be short\n        elif old_pos > self.SHORT and signal == self.SHORT:\n            new_pos = self.SHORT\n        return new_pos\n\n    def get_daily_reward(self, prev_price, curr_price, position):\n        """"""Calculate the daily reward as a percentage change in prices: \n        - Position is long: if the price goes up (curr_price > prev_price),\n          we get a positive reward; otherwise, we get a negative reward\n        - Position is short: if the price goes down, we get a positive reward;\n        otherwise, we a negative reward\n        - Position is cash: we get no reward\n        """"""\n        return position * ((curr_price / prev_price) - 1)\n\n    def has_converged(self, cum_returns, patience=10):\n        """"""Check if the cumulative returns have converged.\n\n        Paramters:\n        cum_returns: A list of cumulative returns for respective epochs\n        patience: The number of epochs with no improvement in cum_returns\n\n        Returns: True if converged, False otherwise\n        """"""\n        # The number of epochs should be at least patience before checking\n        # for convergence\n        if patience > len(cum_returns):\n            return False\n        latest_returns = cum_returns[-patience:]\n        # If all the latest returns are the same, return True\n        if len(set(latest_returns)) == 1:\n            return True\n        max_return = max(cum_returns)\n        if max_return in latest_returns:\n            # If one of recent returns improves, not yet converged\n            if max_return not in cum_returns[:len(cum_returns) - patience]:\n                return False\n            else:\n                return True\n        # If none of recent returns is greater than max_return, it has converged\n        return True\n\n    def add_evidence(self, symbol=""IBM"", start_date=dt.datetime(2008,1,1),\n        end_date=dt.datetime(2009,12,31), start_val = 10000):\n        """"""Create a QLearner, and train it for trading.\n\n        Parameters:\n        symbol: The stock symbol to act on\n        start_date: A datetime object that represents the start date\n        end_date: A datetime object that represents the end date\n        start_val: Start value of the portfolio which contains only the symbol\n        """"""\n        dates = pd.date_range(start_date, end_date)\n        # Get adjusted close prices for symbol\n        df_prices = get_data([symbol], dates)\n        # Get features and thresholds\n        df_features = self.get_features(df_prices[symbol])\n        thresholds = self.get_thresholds(df_features, self.num_steps)\n        cum_returns = []\n        for epoch in range(1, self.epochs + 1):\n            # Initial position is holding nothing\n            position = self.CASH\n            # Create a series that captures order signals based on actions taken\n            orders = pd.Series(index=df_features.index)\n            # Iterate over the data by date\n            for day, date in enumerate(df_features.index):\n                # Get a state; add 1 to position so that states >= 0\n                state = self.discretize(df_features.loc[date], \n                                        position + 1, thresholds)\n                # On the first day, get an action without updating the Q-table\n                if date == df_features.index[0]:\n                    action = self.q_learner.query_set_state(state)\n                # On other days, calculate the reward and update the Q-table\n                else:\n                    prev_price = df_prices[symbol].iloc[day-1]\n                    curr_price = df_prices[symbol].loc[date]\n                    reward = self.get_daily_reward(prev_price, \n                                                   curr_price, position)\n                    action = self.q_learner.query(state, reward)\n                # On the last day, close any open positions\n                if date == df_features.index[-1]:\n                    new_pos = -position\n                else:\n                    new_pos = self.get_position(position, action - 1)\n                # Add new_pos to orders\n                orders.loc[date] = new_pos\n                # Update current position\n                position += new_pos\n            \n            df_trades = create_df_trades(orders, symbol, self.num_shares)\n            portvals = compute_portvals_single_symbol(df_orders=df_trades, \n                                                      symbol=symbol, \n                                                      start_val=start_val, \n                                                      commission=self.commission,\n                                                      impact=self.impact)\n            cum_return = get_portfolio_stats(portvals)[0]\n            cum_returns.append(cum_return)\n            if self.verbose: \n                print (epoch, cum_return)\n            # Check for convergence after running for at least 20 epochs\n            if epoch > 20:\n                # Stop if the cum_return doesn\'t improve for 10 epochs\n                if self.has_converged(cum_returns):\n                    break\n        if self.verbose:\n            plt.plot(cum_returns)\n            plt.xlabel(""Epoch"")\n            plt.ylabel(""Cumulative return (%)"")\n            plt.show()\n\n    def test_policy(self, symbol=""IBM"", start_date=dt.datetime(2010,1,1),\n        end_date=dt.datetime(2011,12,31), start_val=10000):\n        """"""Use the existing policy and test it against new data.\n\n        Parameters:\n        symbol: The stock symbol to act on\n        start_date: A datetime object that represents the start date\n        end_date: A datetime object that represents the end date\n        start_val: Start value of the portfolio which contains only the symbol\n        \n        Returns:\n        df_trades: A dataframe whose values represent trades for each day: \n        +1000 indicating a BUY of 1000 shares, and -1000 indicating a SELL of \n        1000 shares\n        """"""\n\n        dates = pd.date_range(start_date, end_date)\n        # Get adjusted close pricess for symbol\n        df_prices = get_data([symbol], dates)\n        # Get features and thresholds\n        df_features = self.get_features(df_prices[symbol])\n        thresholds = self.get_thresholds(df_features, self.num_steps)\n        # Initial position is holding nothing\n        position = self.CASH\n        # Create a series that captures order signals based on actions taken\n        orders = pd.Series(index=df_features.index)\n        # Iterate over the data by date\n        for date in df_features.index:\n            # Get a state; add 1 to position so that states >= 0\n            state = self.discretize(df_features.loc[date], \n                                    position + 1, thresholds)\n            action = self.q_learner.query_set_state(state)\n            # On the last day, close any open positions\n            if date == df_features.index[-1]:\n                new_pos = -position\n            else:\n                new_pos = self.get_position(position, action - 1)\n            # Add new_pos to orders\n            orders.loc[date] = new_pos\n            # Update current position\n            position += new_pos\n        # Create a trade dataframe\n        df_trades = create_df_trades(orders, symbol, self.num_shares)\n        return df_trades\n        \n\nif __name__==""__main__"":\n    start_val = 100000\n    symbol = ""JPM""\n    commission = 0.00\n    impact = 0.0\n    num_shares = 1000\n\n    # In-sample or training period\n    start_date = dt.datetime(2008, 1, 1)\n    end_date = dt.datetime(2009, 12, 31)\n    \n    # Get a dataframe of benchmark data. Benchmark is a portfolio starting with\n    # $100,000, investing in 1000 shares of symbol and holding that position\n    df_benchmark_trades = create_df_benchmark(symbol, start_date, end_date, \n                                              num_shares)\n\n    # Train and test a StrategyLearner\n    stl = StrategyLearner(num_shares=num_shares, impact=impact, \n                          commission=commission, verbose=True,\n                          num_states=3000, num_actions=3)\n    stl.add_evidence(symbol=symbol, start_val=start_val, \n                     start_date=start_date, end_date=end_date)\n    df_trades = stl.test_policy(symbol=symbol, start_date=start_date,\n                                end_date=end_date)\n\n    # Retrieve performance stats via a market simulator\n    print (""Performances during training period for {}"".format(symbol))\n    print (""Date Range: {} to {}"".format(start_date, end_date))\n    market_simulator(df_trades, df_benchmark_trades, symbol=symbol, \n                     start_val=start_val, commission=commission, impact=impact)\n\n    # Out-of-sample or testing period: Perform similiar steps as above,\n    # except that we don\'t train the data (i.e. run add_evidence again)\n    start_date = dt.datetime(2010, 1, 1)\n    end_date = dt.datetime(2011, 12, 31)\n    df_benchmark_trades = create_df_benchmark(symbol, start_date, end_date, \n                                              num_shares)\n    df_trades = stl.test_policy(symbol=symbol, start_date=start_date, \n                                end_date=end_date)\n    print (""\\nPerformances during testing period for {}"".format(symbol))\n    print (""Date Range: {} to {}"".format(start_date, end_date))\n    market_simulator(df_trades, df_benchmark_trades, symbol=symbol, \n                     start_val=start_val, commission=commission, impact=impact)'"
analysis.py,1,"b'""""""Analyze a portfolio""""""\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport datetime as dt\nimport sys\n# Append the path of the directory one level above the current one\nsys.path.append(\'../\')\nfrom util import *\n\n\ndef assess_portfolio(sd = dt.datetime(2008,1,1), ed = dt.datetime(2009,1,1), \\\n    syms = [""GOOG"",""AAPL"",""GLD"",""XOM""], \\\n    allocs=[0.1,0.2,0.3,0.4], \\\n    sv=1000000, rfr=0.0, sf=252.0, \\\n    gen_plot=False):\n    """"""Assess a portfolio by computing statistics.\n\n    Parameters:\n    sd: A datetime object that represents the start date\n    ed: A datetime object that represents the end date\n    syms: A list of symbols that make up the portfolio\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    rfr: The risk free return per sample period for the entire date range, \n    assuming it does not change\n    sf: Sampling frequency per year\n    gen_plot: If True, create a plot named plot.png\n\n    Returns:\n    cr: Cumulative return\n    adr: Average period return (if sf == 252 this is daily return)\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    ev: End value of portfolio\n    """"""\n\n    # Read in adjusted closing prices for given symbols, date range\n    dates = pd.date_range(sd, ed)\n    prices_all = get_data(syms, dates)  # automatically adds SPY\n    prices = prices_all[syms]  # only portfolio symbols\n    prices_SPY = prices_all[""SPY""]  # only SPY, for comparison later\n\n    # Get daily portfolio value\n    port_val = get_portfolio_value(prices, allocs, sv)\n\n    # Get portfolio statistics (sddr == volatility)\n    cr, adr, sddr, sr = get_portfolio_stats(port_val, rfr, sf)\n\n    # Compare daily portfolio value with SPY using a normalized plot\n    if gen_plot:\n        # Create a temporary dataframe with both the SPY and Portfolio\n        df_temp = pd.concat([port_val, prices_SPY], keys=[""Portfolio"", ""SPY""],\n                            axis=1)\n        plot_normalized_data(df_temp, title=""Daily portfolio and SPY"", \n                             xlabel=""Date"", ylabel=""Normalized price"")    \n\n    # Compute end value\n    ev = port_val.ix[-1, 0]\n\n    return cr, adr, sddr, sr, ev\n\n\ndef get_portfolio_value(prices, allocs, sv):\n    """"""Helper function to compute portfolio value.\n\n    Parameters:\n    prices: Adjusted closing prices for portfolio symbols\n    allocs: A list of allocations to the stocks, must sum to 1.0\n    sv: Start value of the portfolio\n    \n    Returns:\n    port_val: A dataframe object showing the portfolio value for each day\n    """"""\n\n    # Normalize the prices according to the first day\n    norm_prices = normalize_data(prices)\n\n    # Compute prices based on the allocations\n    alloc_prices = norm_prices * allocs\n\n    # Calculate position values\n    pos_vals = alloc_prices * sv\n\n    # Get daily portfolio value\n    port_val = pos_vals.sum(axis=1).to_frame()\n\n    return port_val\n\n\ndef get_portfolio_stats(port_val, daily_rf=0.0, samples_per_year=252.0):\n    """"""Helper function to compute portfolio statistics.\n\n    Parameters:\n    port_val: A dataframe object showing the portfolio value for each day\n    daily_rf: Daily risk-free rate, assuming it does not change\n    samples_per_year: Sampling frequency per year\n    \n    Returns:\n    cr: Cumulative return\n    adr: Average daily return\n    sddr: Standard deviation of daily return\n    sr: Sharpe ratio\n    """"""\n    cr = port_val.iloc[-1, 0]/port_val.iloc[0, 0] - 1\n\n    daily_returns = compute_daily_returns(port_val)[1:]\n    adr = daily_returns.iloc[:, 0].mean()\n    sddr = daily_returns.iloc[:, 0].std()\n    sr = compute_sharpe_ratio(np.sqrt(samples_per_year), adr, daily_rf, sddr)\n\n    return cr, adr, sddr, sr\n\n\ndef plot_normalized_data(df, title, xlabel, ylabel, save_fig=False, \n                         fig_name=""plot.png""):\n    """"""Helper function to normalize and plot data.""""""\n\n    # Normalize the data\n    df = normalize_data(df)\n\n    # Plot the normalized data\n    plot_data(df, title=title, xlabel=xlabel, ylabel=ylabel, save_fig=save_fig,\n              fig_name=fig_name)\n\n\ndef test_code():\n    # Define input parameters\n    start_date = dt.datetime(2010,1,1)\n    end_date = dt.datetime(2010,12,31)\n    symbols = [""GOOG"", ""AAPL"", ""GLD"", ""XOM""]\n    allocations = [0.2, 0.3, 0.4, 0.1]\n    start_val = 1000000  \n    risk_free_rate = 0.0\n    sample_freq = 252\n\n    # Assess the portfolio\n    cr, adr, sddr, sr, ev = assess_portfolio(sd = start_date, ed = end_date,\\\n        syms = symbols, \\\n        allocs = allocations,\\\n        sv = start_val, \\\n        gen_plot = True)\n\n    # Print statistics\n    print (""Start Date:"", start_date)\n    print (""End Date:"", end_date)\n    print (""Symbols:"", symbols)\n    print (""Allocations:"", allocations)\n    print (""Sharpe Ratio:"", sr)\n    print (""Volatility (stdev of daily returns):"", sddr)\n    print (""Average Daily Return:"", adr)\n    print (""Cumulative Return:"", cr)\n    print (""End value:"", ev)\n\nif __name__ == ""__main__"":\n    test_code()'"
grade_strategy_learner.py,2,"b'""""""Testing code for StrategyLearner.\nMostly based on the code provided by Georgia Tech, with the following edits:\n- code edits to make the code compatible with Python 3x\n- a lot of reformatting to make code readable and understandable\n""""""\n\nimport pytest\nfrom grading import grader, GradeResult, run_with_timeout, IncorrectOutput\n\nimport os\nimport sys\nimport traceback as tb\n\nimport datetime as dt\nimport numpy as np\nimport pandas as pd\nfrom collections import namedtuple\n\nimport time\nimport util\nimport random\n\n# Module name to import\nmain_code = [""StrategyLearner"",]\n\n# Test cases\nStrategyTestCase = namedtuple(""Strategy"", [""description"",""insample_args"",\n    ""outsample_args"",""benchmark_type"",""benchmark"",""impact"", ""num_states"", \n    ""num_actions"", ""train_time"",""test_time"",""max_time"",""seed""])\nstrategy_test_cases = [\n    StrategyTestCase(\n        description=""ML4T-220"",\n        insample_args=dict(symbol=""ML4T-220"", start_date=dt.datetime(2008,1,1),\n                           end_date=dt.datetime(2009,12,31), start_val=100000),\n        outsample_args=dict(symbol=""ML4T-220"", start_date=dt.datetime(2010,1,1),\n                            end_date=dt.datetime(2011,12,31), start_val=100000),\n        benchmark_type=""clean"",\n        benchmark=1.0,\n        impact=0.0,\n        num_states=3000,\n        num_actions=3,\n        train_time=25,\n        test_time=5,\n        max_time=60,\n        seed=1481090000\n        ),\n    StrategyTestCase(\n        description=""AAPL"",\n        insample_args=dict(symbol=""AAPL"", start_date=dt.datetime(2008,1,1),\n                           end_date=dt.datetime(2009,12,31),start_val=100000),\n        outsample_args=dict(symbol=""AAPL"", start_date=dt.datetime(2010,1,1),\n                            end_date=dt.datetime(2011,12,31),start_val=100000),\n        benchmark_type=""stock"",\n        benchmark=0.1581999999999999,\n        impact=0.0,\n        num_states=3000,\n        num_actions=3,\n        train_time=25,\n        test_time=5,\n        max_time=60,\n        seed=1481090000\n        ),\n    StrategyTestCase(\n        description=""SINE_FAST_NOISE"",\n        insample_args=dict(symbol=""SINE_FAST_NOISE"",\n                           start_date=dt.datetime(2008,1,1),\n                           end_date=dt.datetime(2009,12,31), start_val=100000),\n        outsample_args=dict(symbol=""SINE_FAST_NOISE"",\n                            start_date=dt.datetime(2010,1,1),\n                            end_date=dt.datetime(2011,12,31), start_val=100000),\n        benchmark_type=""noisy"",\n        benchmark=2.0,\n        impact=0.0,\n        num_states=3000,\n        num_actions=3,\n        train_time=25,\n        test_time=5,\n        max_time=60,\n        seed=1481090000\n        ),\n    StrategyTestCase(\n        description=""UNH - In sample"",\n        insample_args=dict(symbol=""UNH"", start_date=dt.datetime(2008,1,1),\n                           end_date=dt.datetime(2009,12,31),start_val=100000),\n        outsample_args=dict(symbol=""UNH"", start_date=dt.datetime(2010,1,1),\n                            end_date=dt.datetime(2011,12,31),start_val=100000),\n        benchmark_type=""stock"",\n        benchmark= -0.25239999999999996,\n        impact=0.0,\n        num_states=3000,\n        num_actions=3,\n        train_time=25,\n        test_time=5,\n        max_time=60,\n        seed=1481090000\n        ),\n]\n\nmax_points = 60.0 \n# Surround comments with HTML <pre> tag (for T-Square comments field)\nhtml_pre_block = True\n\nMAX_HOLDINGS = 1000\n\n# Test functon(s)\n@pytest.mark.parametrize(""description, insample_args, outsample_args, \\\n    benchmark_type, benchmark, impact, num_states, num_actions, train_time, \\\n    test_time, max_time, seed"", strategy_test_cases)\n\ndef test_strategy(description, insample_args, outsample_args, benchmark_type, \\\n    benchmark, impact, num_states, num_actions, train_time, test_time, \\\n    max_time, seed, grader):\n    """"""Test StrategyLearner.""""""\n    # Initialize points for this test case\n    points_earned = 0.0\n    try:\n        incorrect = True\n        if not ""StrategyLearner"" in globals():\n            import importlib\n            m = importlib.import_module(""StrategyLearner"")\n            globals()[""StrategyLearner""] = m\n        outsample_cr_to_beat = None\n        if benchmark_type == ""clean"":\n            outsample_cr_to_beat = benchmark\n        def timeoutwrapper_strategylearner():\n            # Set fixed seed for repetability\n            np.random.seed(seed)\n            random.seed(seed)\n            learner = StrategyLearner.StrategyLearner(verbose=False,\n                                                      impact=impact,\n                                                      num_states=num_states,\n                                                      num_actions=num_actions)\n            tmp = time.time()\n            learner.add_evidence(**insample_args)\n            train_t = time.time()-tmp\n            tmp = time.time()\n            insample_trades_1 = learner.test_policy(**insample_args)\n            test_t = time.time()-tmp\n            insample_trades_2 = learner.test_policy(**insample_args)\n            tmp = time.time()\n            outsample_trades = learner.test_policy(**outsample_args)\n            out_test_t = time.time()-tmp\n            return insample_trades_1, insample_trades_2, outsample_trades, \\\n                   train_t, test_t, out_test_t\n        msgs = []\n        in_trades_1, in_trades_2, out_trades, train_t, test_t, out_test_t = \\\n                run_with_timeout(timeoutwrapper_strategylearner,max_time,(),{})\n        incorrect = False\n        if len(in_trades_1.shape)!= 2 or in_trades_1.shape[1]!= 1:\n            incorrect = True\n            msgs.append(""  First insample trades DF has invalid shape: {}"".\n                        format(in_trades_1.shape))\n        elif len(in_trades_2.shape)!= 2 or in_trades_2.shape[1]!= 1:\n            incorrect = True\n            msgs.append(""  Second insample trades DF has invalid shape: {}"".\n                        format(in_trades_2.shape))\n        elif len(out_trades.shape)!=2 or out_trades.shape[1]!= 1:\n            incorrect = True\n            msgs.append(""  Out-of-sample trades DF has invalid shape: {}"".\n                        format(out_trades.shape))\n        else:\n            tmp_csum = 0.0\n            for date,trade in in_trades_1.iterrows():\n                tmp_csum += trade.iloc[0]\n                if (trade.iloc[0] != 0) and \\\n                   (trade.abs().iloc[0]!= MAX_HOLDINGS) and \\\n                   (trade.abs().iloc[0]!= 2 * MAX_HOLDINGS):\n                   incorrect = True\n                   msgs.append(""  Illegal trade in first insample DF. \\\n                    abs(trade) not one of ({},{},{}).\\n  Date {}, Trade {}"".\n                    format(0, MAX_HOLDINGS, 2 * MAX_HOLDINGS, date, trade))\n                   break\n                elif abs(tmp_csum) > MAX_HOLDINGS:\n                    incorrect = True\n                    msgs.append(""  Holdings more than {} long or short in \\\n                        first insample DF. Date {}, Trade {}"".\n                        format(MAX_HOLDINGS,date,trade))\n                    break\n            tmp_csum = 0.0\n            for date,trade in in_trades_2.iterrows():\n                tmp_csum += trade.iloc[0]\n                if (trade.iloc[0] != 0) and \\\n                   (trade.abs().iloc[0]!= MAX_HOLDINGS) and \\\n                   (trade.abs().iloc[0]!= 2 * MAX_HOLDINGS):\n                   incorrect = True\n                   msgs.append(""  illegal trade in second insample DF. \\\n                    abs(trade) not one of ({},{},{}).\\n  Date {}, Trade {}"".\n                    format(0, MAX_HOLDINGS, 2 * MAX_HOLDINGS, date, trade))\n                   break\n                elif abs(tmp_csum) > MAX_HOLDINGS:\n                    incorrect = True\n                    msgs.append(""  holdings more than {} long or short in \\\n                        second insample DF. Date {}, Trade {}"".\n                        format(MAX_HOLDINGS, date, trade))\n                    break\n            tmp_csum = 0.0\n            for date,trade in out_trades.iterrows():\n                tmp_csum += trade.iloc[0]\n                if (trade.iloc[0] != 0) and \\\n                   (trade.abs().iloc[0] != MAX_HOLDINGS) and \\\n                   (trade.abs().iloc[0] != 2 * MAX_HOLDINGS):\n                   incorrect = True\n                   msgs.append(""  illegal trade in out-of-sample DF. \\\n                    abs(trade) not one of ({},{},{}).\\n  Date {}, Trade {}"".\n                    format(0, MAX_HOLDINGS, 2 * MAX_HOLDINGS, date, trade))\n                   break\n                elif abs(tmp_csum) > MAX_HOLDINGS:\n                    incorrect = True\n                    msgs.append(""  holdings more than {} long or short in \\\n                        out-of-sample DF. Date {}, Trade {}"".format(MAX_HOLDINGS,date,trade))\n                    break\n        if not(incorrect):\n            if train_t > train_time:\n                incorrect = True\n                msgs.append(""  add_evidence() took {} seconds, max allowed {}"".\n                    format(train_t,train_time))\n            else:\n                points_earned += 1.0\n            if test_t > test_time:\n                incorrect = True\n                msgs.append(""  test_policy() took {} seconds, max allowed {}"".\n                    format(test_t,test_time))\n            else:\n                points_earned += 2.0\n            if not((in_trades_1 == in_trades_2).all()[0]):\n                incorrect = True\n                mismatches = in_trades_1.join(in_trades_2,how=""outer"",lsuffix=""1"",rsuffix=""2"")\n                mismatches = mismatches[mismatches.ix[:,0]!=mismatches.ix[:,1]]\n                msgs.append(""  consecutive calls to test_policy() with same \\\n                    input did not produce same output:"")\n                msgs.append(""  Mismatched trades:\\n {}"".format(mismatches))\n            else:\n                points_earned += 2.0\n            insample_cr = evaluate_policy(insample_args[""symbol""],in_trades_1,\n                                          insample_args[""start_val""],\n                                          insample_args[""start_date""],\n                                          insample_args[""end_date""],\n                                          market_impact=impact,\n                                          commission_cost=0.0)\n            outsample_cr = evaluate_policy(outsample_args[""symbol""],out_trades,\n                                           outsample_args[""start_val""],\n                                           outsample_args[""start_date""],\n                                           outsample_args[""end_date""],\n                                           market_impact=impact,\n                                           commission_cost=0.0)\n            if insample_cr <= benchmark:\n                incorrect = True\n                msgs.append(""  in-sample return ({}) did not beat benchmark ({})"".\n                            format(insample_cr,benchmark))\n            else:\n                points_earned += 5.0\n            if outsample_cr_to_beat is None:\n                if out_test_t > test_time:\n                    incorrect = True\n                    msgs.append(""  out-sample took {} seconds, max of {}"".\n                                format(out_test_t,test_time))\n                else:\n                    points_earned += 5.0\n            else:\n                if outsample_cr < outsample_cr_to_beat:\n                    incorrect = True\n                    msgs.append(""  out-sample return ({}) did not beat benchmark ({})"".\n                                format(outsample_cr,outsample_cr_to_beat))\n                else:\n                    points_earned += 5.0\n        if incorrect:\n            inputs_str = ""    insample_args: {}\\n"" \\\n                         ""    outsample_args: {}\\n"" \\\n                         ""    benchmark_type: {}\\n"" \\\n                         ""    benchmark: {}\\n"" \\\n                         ""    train_time: {}\\n"" \\\n                         ""    test_time: {}\\n"" \\\n                         ""    max_time: {}\\n"" \\\n                         ""    seed: {}\\n"".format(insample_args, outsample_args,\n                            benchmark_type, benchmark, train_time, test_time,\n                            max_time,seed)\n            raise IncorrectOutput(""Test failed on one or more output criteria. \\\n                                  \\n  Inputs:\\n{}\\n  Failures:\\n{}"".format(inputs_str, \n                                  ""\\n"".join(msgs)))\n    except Exception as e:\n        # Test result: failed\n        msg = ""Test case description: {}\\n"".format(description)\n        \n        # Generate a filtered stacktrace, only showing erroneous lines\n        tb_list = tb.extract_tb(sys.exc_info()[2])\n        for i in range(len(tb_list)):\n            row = tb_list[i]\n            # Show only filename instead of long absolute path\n            tb_list[i] = (os.path.basename(row[0]), row[1], row[2], row[3])\n        if tb_list:\n            msg += ""Traceback:\\n""\n            msg += """".join(tb.format_list(tb_list))\n        elif ""grading_traceback"" in dir(e):\n            msg += ""Traceback:\\n""\n            msg += """".join(tb.format_list(e.grading_traceback))\n        msg += ""{}: {}"".format(e.__class__.__name__, str(e))\n\n        # Report failure result to grader, with stacktrace\n        grader.add_result(GradeResult(outcome=""failed"", points=points_earned, msg=msg))\n        raise\n    else:\n        # Test result: passed (no exceptions)\n        grader.add_result(GradeResult(outcome=""passed"", points=points_earned, msg=None))\n\ndef evaluate_policy(symbol, trades, startval, start_date, end_date, \n                    market_impact, commission_cost):\n    """"""Compute the cumulative return for a portfolio.""""""\n    orders_df = pd.DataFrame(columns=[""Shares"",""Order"",""Symbol""])\n    for row_idx in trades.index:\n        nshares = trades.loc[row_idx][0]\n        if nshares == 0:\n            continue\n        order = ""sell"" if nshares < 0 else ""buy""\n        new_row = pd.DataFrame([[abs(nshares),order,symbol],],\n                               columns=[""Shares"",""Order"",""Symbol""],index=[row_idx,])\n        orders_df = orders_df.append(new_row)\n    portvals = compute_portvals(orders_df, start_date, end_date, startval,\n                                market_impact,commission_cost)\n    return float(portvals[-1]/portvals[0])-1\n\ndef compute_portvals(orders_df, start_date, end_date, startval, \n                     market_impact=0.0, commission_cost=0.0):\n    """"""Simulate the market for the given date range and orders file.""""""\n    symbols = []\n    orders = []\n    orders_df = orders_df.sort_index()\n    for date, order in orders_df.iterrows():\n        shares = order[""Shares""]\n        action = order[""Order""]\n        symbol = order[""Symbol""]\n        if action.lower() == ""sell"":\n            shares *= -1\n        order = (date, symbol, shares)\n        orders.append(order)\n        symbols.append(symbol)\n    symbols = list(set(symbols))\n    dates = pd.date_range(start_date, end_date)\n    prices_all = util.get_data(symbols, dates)\n    prices = prices_all[symbols]\n    prices = prices.fillna(method=""ffill"").fillna(method=""bfill"")\n    prices[""_CASH""] = 1.0\n    trades = pd.DataFrame(index=prices.index, columns=symbols)\n    trades = trades.fillna(0)\n    cash = pd.Series(index=prices.index)\n    cash = cash.fillna(0)\n    cash.ix[0] = startval\n    for date, symbol, shares in orders:\n        price = prices[symbol][date]\n        val = shares * price\n        # Transaction cost model\n        val += commission_cost + (pd.np.abs(shares) * price * market_impact)\n        positions = prices.ix[date] * trades.sum()\n        totalcash = cash.sum()\n        if (date < prices.index.min()) or (date > prices.index.max()):\n            continue\n        trades[symbol][date] += shares\n        cash[date] -= val\n    trades[""_CASH""] = cash\n    holdings = trades.cumsum()\n    df_portvals = (prices * holdings).sum(axis=1)\n    return df_portvals\n\nif __name__ == ""__main__"":\n    pytest.main([""-s"", __file__])\n'"
grading.py,0,"b'""""""Testing code for StrategyLearner.\nMostly based on the code provided by Georgia Tech, with the following edits:\n- code edits to make the code compatible with Python 3x\n- a lot of reformatting to make code readable and understandable\n""""""\n\nimport pytest\nimport signal\nfrom collections import namedtuple\nfrom contextlib import contextmanager\nimport multiprocessing\nimport sys, traceback\n\ntimeout_manager = multiprocessing.Manager()\n\nGradeResult = namedtuple(""GradeResult"", [""outcome"", ""points"", ""msg""])\n\nclass IncorrectOutput(Exception): pass\n\nclass TimeoutException(Exception): pass\n\nclass Grader(object):\n    """"""Main grader class; an instance is passed in through a pytest fixture.""""""\n\n    def __init__(self, max_points=None, html_pre_block=False):\n        self.max_points = max_points\n        self.html_pre_block = html_pre_block\n        self.total_points = 0.0\n        self.results = []\n        self.performance = None\n\n    def add_result(self, result):\n        self.results.append(result)\n        self.add_points(result.points)\n\n    def add_points(self, points):\n        self.total_points += points\n\n    def add_performance(self,perf):\n        if self.performance is None:\n            self.performance = perf\n        else:\n            self.performance = self.performance + perf\n\n    def summary(self):\n        num_tests = len(self.results)\n        if self.max_points is not None:\n            max_points = self.max_points  \n        else:\n            float(num_tests)\n        tests_passed = len([result for result in self.results \n                           if result.outcome == ""passed""])\n        return ""Tests passed: {} out of {}"".format(tests_passed, num_tests)\n\n    def details(self):\n        return ""\\n"".join(""Test #{}: {} {}"".format(i, self.results[i].outcome, \n                ((""\\n"" + self.results[i].msg + ""\\n"") \n                if self.results[i].msg is not None \n                else """")) for i in range(len(self.results)))\n\n    def write_points(self, filename=""points.txt""):\n        print (""[GRADER] Writing points to \\""{}\\""..."".format(filename))\n        with open(filename, ""w"") as f:\n            f.write(""{}\\n"".format(self.total_points))\n    \n    def write_performance(self,filename=""performance.txt""):\n        if self.performance is None:\n            print (""No performance metric collected, skipping"")\n        else:\n            print (""[GRADER] Writing performance to \\""{}\\""..."".format(filename))\n            with open(filename,""w"") as f:\n                f.write(""{}\\n"".format(self.performance))\n    \n    def write_comments(self, filename=""comments.txt""):\n        # Build comments string\n        print (""[GRADER] Writing comments to \\""{}\\""..."".format(filename))\n        comments = ""--- Summary ---\\n"" + self.summary() + ""\\n""\n        details = self.details()\n        if details:\n            comments += ""\\n--- Details ---\\n"" + details + ""\\n""\n        print (""\\n{}"".format(comments))\n\n        # Write to file\n        with open(filename, ""w"") as f:\n            if self.html_pre_block:\n                f.write(""<pre>"")\n            f.write(comments)\n            if self.html_pre_block:\n                f.write(""</pre>\\n"")\n\n    def __str__(self):\n        return ""<{} at {:x}: total_points: {}, #results: {}>"".\\\n               format(self.__class__.__name__, id(self), \n                self.total_points, len(self.results))\n\n\n@contextmanager\ndef time_limit(seconds, msg=""Exceeded time limit!""):\n    """"""A contextmanager that raises a TimeoutException if \n    execution takes longer than specified time.\n\n    Usage:\n        with time_limit(1):\n            # do stuff within 1 second\n\n    Note: seconds must be an integer.\n    Based on: http://stackoverflow.com/a/601168\n    """"""\n    \n    def signal_handler(signum, frame):\n        raise (TimeoutException, msg)\n    signal.signal(signal.SIGALRM, signal_handler)\n    signal.alarm(seconds)\n    try:\n        yield\n    finally:\n        signal.alarm(0)\n\n\ndef proc_wrapper(func,rv,pos_args,keyword_args):\n    try:\n        rv[""output""] = func(*pos_args,**keyword_args)\n    except Exception as e:\n        rv[""exception""] = e\n        rv[""traceback""] = traceback.extract_tb(sys.exc_info()[2])\n\ndef run_with_timeout(func,timeout_seconds,pos_args,keyword_args):\n    rv_dict = timeout_manager.dict()\n    p = multiprocessing.Process(target=proc_wrapper,\n                                args=(func,rv_dict,pos_args,keyword_args))\n    p.start()\n    p.join(timeout_seconds)\n    if p.is_alive():\n        p.terminate()\n        raise TimeoutException(""Exceeded time limit!"")\n    if not(""output"" in rv_dict):\n        if ""exception"" in rv_dict:\n            e = rv_dict[""exception""]\n            e.grading_traceback=None\n            if ""traceback"" in rv_dict:\n                e.grading_traceback = rv_dict[""traceback""]\n            raise e\n        raise Exception(""Unknown Exception"")\n    return rv_dict[""output""]\n\n# Test fixtures\n@pytest.fixture(scope=""module"")\ndef grader(request):\n    """"""A module-level grading fixture.""""""\n    # Picked up from test module, if defined\n    max_points = getattr(request.module, ""max_points"", None)\n    # Surround with HTML <pre> tag\n    html_pre_block = getattr(request.module, ""html_pre_block"", False) \n    _grader = Grader(max_points=max_points, html_pre_block=html_pre_block)\n    def fin():\n        _grader.write_points()\n        _grader.write_comments()\n        _grader.write_performance()\n        print (""[GRADER] Done!"")\n    request.addfinalizer(fin)\n    return _grader'"
indicators.py,3,"b'""""""Implement technical indicators""""""\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport copy\nimport datetime as dt\nfrom util import get_exchange_days, get_data, normalize_data\n\n\ndef get_momentum(price, window=5):\n    """"""Calculate momentum indicator: \n    momentum[t] = (price[t]/price[t-window]) - 1\n\n    Parameters:\n    price: Price, typically adjusted close price, series of a symbol\n    window: Number of days to look back\n    \n    Returns: Momentum, series of the same size as input data\n    """"""    \n    momentum = pd.Series(np.nan, index=price.index)\n    momentum.iloc[window:] = price.iloc[window:] / price.values[:-window] - 1\n    return momentum\n\ndef get_sma_indicator(price, rolling_mean):\n    """"""Calculate simple moving average indicator, i.e. price / rolling_mean.\n\n    Parameters:\n    price: Price, typically adjusted close price, series of a symbol\n    rolling_mean: Rolling mean of a series\n\n    Returns: The simple moving average indicator\n    """"""\n    return price / rolling_mean - 1\n\ndef get_bollinger_bands(rolling_mean, rolling_std, num_std=2):\n    """"""Calculate upper and lower Bollinger Bands.\n\n    Parameters:\n    rolling_mean: Rolling mean of a series\n    rolling_meanstd: Rolling std of a series\n    num_std: Number of standard deviations for the bands\n\n    Returns: Bollinger upper band and lower band\n    """"""\n    upper_band = rolling_mean + rolling_std * num_std\n    lower_band = rolling_mean - rolling_std * num_std\n    return upper_band, lower_band\n\ndef compute_bollinger_value(price, rolling_mean, rolling_std):\n    """"""Output a value indicating how many standard deviations \n    a price is from the mean.\n\n    Parameters:\n    price: Price, typically adjusted close price, series of a symbol\n    rolling_mean: Rolling mean of a series\n    rolling_std: Rolling std of a series\n\n    Returns:\n    bollinger_val: the number of standard deviations a price is from the mean\n    """"""\n\n    bollinger_val = (price - rolling_mean) / rolling_std\n    return bollinger_val\n\ndef plot_momentum(sym_price, sym_mom, title=""Momentum Indicator"",\n                  fig_size=(12, 6)):\n    """"""Plot momentum and prices for a symbol.\n\n    Parameters:\n    sym_price: Price, typically adjusted close price, series of symbol\n    sym_mom: Momentum of symbol\n    fig_size: Width and height of the chart in inches\n    \n    Returns:\n    Plot momentum and prices on the sample plot with two scales\n    """"""\n    # Create two subplots on the same axes with different left and right scales\n    fig, ax1 = plt.subplots()\n\n    # The first subplot with the left scale: prices\n    ax1.grid(linestyle=\'--\')\n    line1 = ax1.plot(sym_price.index, sym_price, label=""Adjusted Close Price"",\n                     color=""b"")\n    ax1.set_xlabel(""Date"")\n    # Make the y-axis label, ticks and tick labels match the line color\n    ax1.set_ylabel(""Adjusted Close Price"", color=""b"")\n    ax1.tick_params(""y"", colors=""b"")\n\n    # The second subplot with the right scale: momentum\n    ax2 = ax1.twinx()\n    line2 = ax2.plot(sym_mom.index, sym_mom, label=""Momentum"", color=""k"",\n                     alpha=0.4)\n    ax2.set_ylabel(""Momentum"", color=""k"")\n    ax2.tick_params(""y"", colors=""k"")\n\n    # Align gridlines for the two scales\n    align_y_axis(ax1, ax2, .1, .1)\n\n    # Show legend with all labels on the same legend\n    lines = line1 + line2\n    line_labels = [l.get_label() for l in lines]\n    ax1.legend(lines, line_labels, loc=""upper center"")\n\n    #Set figure size\n    fig = plt.gcf()\n    fig.set_size_inches(fig_size)\n\n    plt.suptitle(title)\n    plt.show()\n\ndef plot_sma_indicator(sym_price, sma_indicator, rolling_mean, \n                       title=""SMA Indicator"", fig_size=(12, 6)):\n    """"""Plot SMA indicator, price and rolling_mean for a symbol.\n\n    Parameters:\n    sym_price: Price, typically adjusted close price, series of symbol\n    sma_indicator: The simple moving average indicator\n    rolling_mean (a.k.a SMA): Rolling mean of sym_price\n    title: The chart title\n    fig_size: Width and height of the chart in inches\n\n    Returns:\n    Plot all the three series on the same plot with two scales\n    """"""\n    # Create two subplots on the same axes with different left and right scales\n    fig, ax1 = plt.subplots()\n\n    # The first subplot with the left scale: prices\n    ax1.grid(linestyle=\'--\')\n    line1 = ax1.plot(sym_price.index, sym_price, label=""Adjusted Close Price"",\n                     color=""b"")\n    line2 = ax1.plot(rolling_mean.index, rolling_mean, label=""SMA"", color=""g"")\n    ax1.set_xlabel(""Date"")\n    # Make the y-axis label, ticks and tick labels match the line color\n    ax1.set_ylabel(""Adjusted Close Price"", color=""b"")\n    ax1.tick_params(""y"", colors=""b"")\n\n    # The second subplot with the right scale: momentum\n    ax2 = ax1.twinx()\n    line3 = ax2.plot(sma_indicator.index, sma_indicator, \n        label=""SMA Indicator"", color=""k"", alpha=0.4)\n    ax2.set_ylabel(""SMA indicator"", color=""k"")\n    ax2.tick_params(""y"", colors=""k"")\n\n    # Align gridlines for the two scales\n    align_y_axis(ax1, ax2, .1, .1)\n\n    # Show legend with all labels on the same legend\n    lines = line1 + line2 + line3\n    line_labels = [l.get_label() for l in lines]\n    ax1.legend(lines, line_labels, loc=""upper center"")\n\n    #Set figure size\n    fig = plt.gcf()\n    fig.set_size_inches(fig_size)\n\n    plt.title(title)\n    plt.show()\n\ndef plot_bollinger(sym_price, upper_band, lower_band, bollinger_val, \n                   num_std=1, title=""Bollinger Indicator"", fig_size=(12, 6)):\n    """"""Plot Bollinger bands and value for a symbol.\n\n    Parameters:\n    sym_price: Price, typically adjusted close price, series of symbol\n    upper_band: Bollinger upper band\n    lower_band: Bollinger lower band\n    bollinger_val: The number of standard deviations a price is from the mean\n    num_std: Number of standard deviations for the bands\n    fig_size: Width and height of the chart in inches\n\n    Returns:\n    Plot two subplots, one for the Adjusted Close Price and Bollinger bands,\n    the other for the Bollinger value\n    """"""\n    # Create 2 subplots\n    # Plot symbol\'s adjusted close price, rolling mean and Bollinger Bands\n    f, ax = plt.subplots(2, sharex=True)\n    ax[0].fill_between(upper_band.index, upper_band, lower_band, color=""gray"",\n                       alpha=0.4, linewidth=2.0,\n                       label=""Region btwn Bollinger Bands"")\n    ax[0].plot(sym_price, label=""Adjusted Close Price"", color=""b"")\n    ax[0].set_ylabel(""Adjusted Close Price"")\n    ax[0].legend(loc=""upper center"")\n\n    # Plot the bollinger value\n    ax[1].axhspan(-num_std, num_std, color=""gray"", alpha=0.4, linewidth=2.0,\n        label=""Region btwn {} & {} std"".format(-num_std, num_std))\n    ax[1].plot(bollinger_val, label=""Bollinger Value"", color=""b"")\n    ax[1].set_xlabel(""Date"")\n    ax[1].set_ylabel(""Bollinger Value"")\n    ax[1].set_xlim(bollinger_val.index.min(), bollinger_val.index.max())\n    ax[1].legend(loc=""upper center"")\n\n    #Set figure size\n    fig = plt.gcf()\n    fig.set_size_inches(fig_size)\n\n    plt.suptitle(title)\n    plt.show()\n\ndef align_y_axis(ax1, ax2, minresax1, minresax2):\n    """"""Set tick marks of twinx axes to line up with 7 total tick marks.\n\n    ax1 and ax2 are matplotlib axes\n    Spacing between tick marks will be a factor of minresax1 and minresax2\n    from https://stackoverflow.com/questions/26752464/how-do-i-align-gridlines\n    -for-two-y-axis-scales-using-matplotlib\n    """"""\n\n    ax1ylims = ax1.get_ybound()\n    ax2ylims = ax2.get_ybound()\n    ax1factor = minresax1 * 6\n    ax2factor = minresax2 * 6\n    ax1.set_yticks(np.linspace(ax1ylims[0],\n                               ax1ylims[1] + (ax1factor -\n                               (ax1ylims[1] - ax1ylims[0]) % ax1factor) %\n                               ax1factor, 7))\n    ax2.set_yticks(np.linspace(ax2ylims[0],\n                               ax2ylims[1] + (ax2factor -\n                               (ax2ylims[1] - ax2ylims[0]) % ax2factor) %\n                               ax2factor, 7))\n\n\nif __name__ == ""__main__"":\n    start_date = dt.datetime(2008, 1, 1)\n    end_date = dt.datetime(2009, 12, 31)\n\n    # Get NYSE trading dates\n    dates = get_exchange_days(start_date, end_date, \n                              dirpath=""../data/dates_lists"", \n                              filename=""NYSE_dates.txt"")\n\n    symbols = [""AAPL""]\n    # Get stock data and normalize it\n    df_price = get_data(symbols, dates)\n    norm_price = normalize_data(df_price)\n    window = 20\n    num_std = 2\n\n    for symbol in symbols:\n        # Compute rolling mean\n        rolling_mean = norm_price[symbol].rolling(window=window).mean()\n\n        # Compute rolling standard deviation\n        rolling_std = norm_price[symbol].rolling(window=window).std()\n\n        # Get momentum\n        momentum = get_momentum(norm_price[symbol], window)\n\n        # Plot momentum\n        plot_momentum(norm_price[symbol], momentum, \n            ""Momentum Indicator for {} with lookback={} days \\n \\\n            Prices are normalized to the first date)"".format(symbol, window))\n\n        # Get SMA indicator\n        sma_indicator = get_sma_indicator(norm_price[symbol], rolling_mean)\n\n        # Plot SMA indicator\n        plot_sma_indicator(norm_price[symbol], sma_indicator, rolling_mean, \n            ""SMA Indicator for {} with lookback={} days \\n \\\n            (Prices are normalized to the first date)"".format(symbol, window))\n\n        # Compute Bollinger bands and value\n        upper_band, lower_band = get_bollinger_bands(rolling_mean, rolling_std,\n                                                     num_std)\n        bollinger_val = compute_bollinger_value(norm_price[symbol], \n                                                rolling_mean, rolling_std)\n\n        # Plot Bollinger bands and values\n        plot_bollinger(norm_price[symbol], upper_band, lower_band, \n            bollinger_val, num_std, \n            ""Bollinger Indicator for {} with num_std={}, lookback={} days \\\n            \\n(Prices are normalized to the first date)"".\n            format(symbol, num_std, window))\n'"
marketsim.py,2,"b'""""""Implement a market simulator that processes a dataframe instead of \na csv file.\n""""""\n\nimport pandas as pd\nimport numpy as np\nimport datetime as dt\nimport matplotlib.pyplot as plt\nfrom analysis import get_portfolio_value, get_portfolio_stats, \\\nplot_normalized_data\nfrom util import get_data, normalize_data\n\n\ndef compute_portvals_single_symbol(df_orders, symbol, start_val=1000000, \n    commission=9.95, impact=0.005):\n    """"""Compute portfolio values for a single symbol.\n\n    Parameters:\n    df_orders: A dataframe with orders for buying or selling stocks. There is\n    no value for cash (i.e. 0).\n    symbol: The stock symbol whose portfolio values need to be computed\n    start_val: The starting value of the portfolio (initial cash available)\n    commission: The fixed amount in dollars charged for each transaction\n    impact: The amount the price moves against the trader compared to the \n    historical data at each transaction\n    \n    Returns:\n    portvals: A dataframe with one column containing the value of the portfolio\n    for each trading day\n    """"""\n\n    # Sort the orders dataframe by date\n    df_orders.sort_index(ascending=True, inplace=True)\n    \n    # Get the start and end dates\n    start_date = df_orders.index.min()\n    end_date = df_orders.index.max()\n\n    # Create a dataframe with adjusted close prices for the symbol and for cash\n    df_prices = get_data([symbol], pd.date_range(start_date, end_date))\n    del df_prices[""SPY""]\n    df_prices[""cash""] = 1.0\n\n    # Fill NAN values if any\n    df_prices.fillna(method=""ffill"", inplace=True)\n    df_prices.fillna(method=""bfill"", inplace=True)\n    df_prices.fillna(1.0, inplace=True)\n\n    # Create a dataframe that represents changes in the number of shares by day\n    df_trades = pd.DataFrame(np.zeros((df_prices.shape)), df_prices.index, \n        df_prices.columns)\n    for index, row in df_orders.iterrows():\n        # Total value of shares purchased or sold\n        traded_share_value = df_prices.loc[index, symbol] * row[""Shares""]\n        # Transaction cost \n        transaction_cost = commission + impact * df_prices.loc[index, symbol] \\\n                            * abs(row[""Shares""])\n\n        # Update the number of shares and cash based on the type of transaction\n        # Note: The same asset may be traded more than once on a particular day\n        # If the shares were bought\n        if row[""Shares""] > 0:\n            df_trades.loc[index, symbol] = df_trades.loc[index, symbol] \\\n                                            + row[""Shares""]\n            df_trades.loc[index, ""cash""] = df_trades.loc[index, ""cash""] \\\n                                            - traded_share_value \\\n                                            - transaction_cost\n        # If the shares were sold\n        elif row[""Shares""] < 0:\n            df_trades.loc[index, symbol] = df_trades.loc[index, symbol] \\\n                                            + row[""Shares""]\n            df_trades.loc[index, ""cash""] = df_trades.loc[index, ""cash""] \\\n                                            - traded_share_value \\\n                                            - transaction_cost\n    # Create a dataframe that represents on each particular day how much of\n    # each asset in the portfolio\n    df_holdings = pd.DataFrame(np.zeros((df_prices.shape)), df_prices.index, \n        df_prices.columns)\n    for row_count in range(len(df_holdings)):\n        # In the first row, the number shares are the same as in df_trades, \n        # but start_val must be added to cash\n        if row_count == 0:\n            df_holdings.iloc[0, :-1] = df_trades.iloc[0, :-1].copy()\n            df_holdings.iloc[0, -1] = df_trades.iloc[0, -1] + start_val\n        # The rest of the rows show cumulative values\n        else:\n            df_holdings.iloc[row_count] = df_holdings.iloc[row_count-1] \\\n                                            + df_trades.iloc[row_count]\n        row_count += 1\n\n    # Create a dataframe that represents the monetary value of each asset \n    df_value = df_prices * df_holdings\n    \n    # Create portvals dataframe\n    portvals = pd.DataFrame(df_value.sum(axis=1), df_value.index, [""port_val""])\n    return portvals\n\ndef market_simulator(df_orders, df_orders_benchmark, symbol, start_val=1000000,\n    commission=9.95, impact=0.005, daily_rf=0.0, samples_per_year=252.0, \n    save_fig=False, fig_name=""plot.png""):\n    """"""\n    This function takes in and executes trades from orders dataframes\n\n    Parameters:\n    df_orders: A dataframe that contains portfolio orders\n    df_orders_benchmark: A dataframe that contains benchmark orders\n    start_val: The starting cash in dollars\n    commission: The fixed amount in dollars charged for each transaction\n    impact: The amount the price moves against the trader compared to the \n    historical data at each transaction\n    daily_rf: Daily risk-free rate, assuming it does not change\n    samples_per_year: Sampling frequency per year\n    save_fig: Whether to save the plot or not\n    fig_name: The name of the saved figure\n\n    Returns:\n    Print out final portfolio value of the portfolio, Sharpe ratio, cumulative\n    return, average daily return and standard deviation of the portfolio and \n    Benchmark. Plot a chart of the portfolio and benchmark performances.\n    """"""    \n    # Process portfolio orders\n    portvals = compute_portvals_single_symbol(df_orders=df_orders, symbol=symbol,\n        start_val=start_val, commission=commission, impact=impact)\n\n    # Get portfolio stats\n    cum_ret, avg_daily_ret, std_daily_ret, sharpe_ratio = get_portfolio_stats(\n        portvals, daily_rf=daily_rf, samples_per_year=samples_per_year)\n    \n    # Process benchmark orders\n    portvals_bm = compute_portvals_single_symbol(df_orders=df_orders_benchmark, \n        symbol=symbol, start_val=start_val, commission=commission, impact=impact)\n    \n    # Get benchmark stats\n    cum_ret_bm, avg_daily_ret_bm, std_daily_ret_bm, sharpe_ratio_bm = \\\n    get_portfolio_stats(portvals_bm, daily_rf=daily_rf, \n        samples_per_year=samples_per_year)\n\n    # Compare portfolio against Benchmark\n    print (""Sharpe Ratio of Portfolio: {}"".format(sharpe_ratio))\n    print (""Sharpe Ratio of Benchmark : {}"".format(sharpe_ratio_bm))\n    print ()\n    print (""Cumulative Return of Portfolio: {}"".format(cum_ret))\n    print (""Cumulative Return of Benchmark : {}"".format(cum_ret_bm))\n    print ()\n    print (""Standard Deviation of Portfolio: {}"".format(std_daily_ret))\n    print (""Standard Deviation of Benchmark : {}"".format(std_daily_ret_bm))\n    print ()\n    print (""Average Daily Return of Portfolio: {}"".format(avg_daily_ret))\n    print (""Average Daily Return of Benchmark : {}"".format(avg_daily_ret_bm))\n    print ()\n    print (""Final Portfolio Value: {}"".format(portvals.iloc[-1, -1]))\n    print (""Final Benchmark Value: {}"".format(portvals_bm.iloc[-1, -1]))\n\n    # Rename columns and normalize data to the first date of the date range\n    portvals.rename(columns={""port_val"": ""Portfolio""}, inplace=True)\n    portvals_bm.rename(columns={""port_val"": ""Benchmark""}, inplace=True)\n    plot_norm_data_vertical_lines(df_orders, portvals, portvals_bm,\n        save_fig=False, fig_name=""plot.png"")\n\ndef plot_norm_data_vertical_lines(df_orders, portvals, portvals_bm, \n    plot_vertical_lines=False, save_fig=False, fig_name=""plot.png""):\n    """"""Plots portvals and portvals_bm, showing vertical lines for orderss\n    \n    Parameters:\n    df_orders: A dataframe that contains portfolio orders\n    portvals: A dataframe with one column containing daily portfolio value\n    portvals_bm: A dataframe with one column containing daily benchmark value\n    save_fig: Whether to save the plot or not\n    fig_name: The name of the saved figure\n\n    Returns: Plot a chart of the portfolio and benchmark performances\n    """"""\n    # Normalize data\n    portvals = normalize_data(portvals)\n    portvals_bm = normalize_data(portvals_bm)\n    df = portvals_bm.join(portvals)\n\n    # Plot the normalized benchmark and portfolio\n    plt.plot(df.loc[:, ""Benchmark""], label=""Benchmark"")\n    plt.plot(df.loc[:, ""Portfolio""], label=""Portfolio"")\n\n    # Plot the vertical lines for buy and sell signals\n    if plot_vertical_lines == True:\n        for date in df_orders.index:\n            if df_orders.loc[date, ""Shares""] > 0:\n                plt.axvline(date, color = \'g\', linestyle = \'--\')\n            elif df_orders.loc[date, ""Shares""] < 0:\n                plt.axvline(date, color = \'r\', linestyle = \'--\')\n\n    plt.title(""Portfolio vs. Benchmark"")\n    plt.xlabel(""Date"")\n    plt.ylabel(""Normalized prices"")\n    plt.legend()\n\n    # Set figure size\n    fig = plt.gcf()\n    fig.set_size_inches(12, 6)\n\n    if save_fig == True:\n        plt.savefig(fig_name)\n    else:\n        plt.show()\n'"
util.py,1,"b'""""""Util functions for StrategyLearner.""""""\n\nimport datetime as dt\nimport os\nimport pandas as pd\nimport numpy as np\n\ndef symbol_to_path(symbol, base_dir=None):\n    """"""Return CSV file path given ticker symbol.""""""\n    if base_dir is None:\n        base_dir = os.environ.get(""MARKET_DATA_DIR"", \'../data/\')\n    return os.path.join(base_dir, ""{}.csv"".format(str(symbol)))\n\ndef get_data(symbols, dates, addSPY=True, colname = \'Adj Close\'):\n    """"""Read stock data (adjusted close) for given symbols from CSV files.""""""\n    df = pd.DataFrame(index=dates)\n    if addSPY and \'SPY\' not in symbols:  # add SPY for reference, if absent\n        symbols = [\'SPY\'] + symbols\n\n    for symbol in symbols:\n        df_temp = pd.read_csv(symbol_to_path(symbol), index_col=\'Date\',\n                parse_dates=True, usecols=[\'Date\', colname], na_values=[\'nan\'])\n        df_temp = df_temp.rename(columns={colname: symbol})\n        df = df.join(df_temp)\n        if symbol == \'SPY\':  # drop dates SPY did not trade\n            df = df.dropna(subset=[""SPY""])\n\n    return df\n\ndef get_orders_data_file(basefilename):\n    return open(os.path.join(os.environ.get(""ORDERS_DATA_DIR"",\'orders/\'),basefilename))\n\ndef get_learner_data_file(basefilename):\n    return open(os.path.join(os.environ.get(""LEARNER_DATA_DIR"",\'Data/\'),basefilename),\'r\')\n\ndef get_robot_world_file(basefilename):\n    return open(os.path.join(os.environ.get(""ROBOT_WORLDS_DIR"",\'testworlds/\'),basefilename))\n\n\ndef normalize_data(df):\n    """"""Normalize stock prices using the first row of the dataframe""""""\n    return df/df.iloc[0,:]\n\n\ndef compute_daily_returns(df):\n    """"""Compute and return the daily return values""""""\n    daily_returns = df.pct_change()\n    daily_returns.iloc[0,:] = 0\n    return daily_returns\n\n\ndef compute_sharpe_ratio(k, avg_return, risk_free_rate, std_return):\n    """"""\n    Compute and return the Sharpe ratio\n    Parameters:\n    k: adjustment factor, sqrt(252) for daily data, sqrt(52) for weekly data, sqrt(12) for monthly data\n    avg_return: daily, weekly or monthly return\n    risk_free_rate: daily, weekly or monthly risk free rate\n    std_return: daily, weekly or monthly standard deviation\n    Returns: \n    sharpe_ratio: k * (avg_return - risk_free_rate) / std_return\n    """"""\n    return k * (avg_return - risk_free_rate) / std_return\n    \n\ndef plot_data(df, title=""Stock prices"", xlabel=""Date"", ylabel=""Price"", save_fig=False, fig_name=""plot.png""):\n    """"""Plot stock prices with a custom title and meaningful axis labels.""""""\n    ax = df.plot(title=title, fontsize=12)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    if save_fig == True:\n        plt.savefig(fig_name)\n    else:\n        plt.show()\n\n\ndef load_txt_data(dirpath, filename):\n    """""" Load the data from a txt file and store them as a numpy array\n\n    Parameters:\n    dirpath: The path to the directory where the file is stored\n    filename: The name of the file in the dirpath\n    \n    Returns:\n    np_data: A numpy array of the data\n    """"""\n\n    try:\n        filepath= os.path.join(dirpath, filename)\n    except KeyError:\n        print (""The file is missing"")\n\n    np_data = np.loadtxt(filepath, dtype=str)\n\n    return np_data\n\n\ndef get_exchange_days(start_date = dt.datetime(1964,7,5), end_date = dt.datetime(2020,12,31),\n    dirpath = ""../data/dates_lists"", filename=""NYSE_dates.txt""):\n    """""" Create a list of dates between start_date and end_date (inclusive) that correspond \n    to the dates there was trading at an exchange. Default values are given based on NYSE.\n\n    Parameters:\n    start_date: First timestamp to consider (inclusive)\n    end_date: Last day to consider (inclusive)\n    dirpath: The path to the directory where the file is stored\n    filename: The name of the file in the dirpath\n    \n    Returns:\n    dates: A list of dates between start_date and end_date on which an exchange traded\n    """"""\n\n    # Load a text file located in dirpath\n    dates_str = load_txt_data(dirpath, filename)\n    all_dates_frome_file = [dt.datetime.strptime(date, ""%m/%d/%Y"") for date in dates_str]\n    df_all_dates = pd.Series(index=all_dates_frome_file, data=all_dates_frome_file)\n\n    selected_dates = [date for date in df_all_dates[start_date:end_date]]\n\n    return selected_dates\n\n\ndef get_data_as_dict(dates, symbols, keys):\n    """""" Create a dictionary with types of data (Adj Close, Volume, etc.) as keys. Each value is \n    a dataframe with symbols as columns and dates as rows\n\n    Parameters:\n    dates: A list of dates of interest\n    symbols: A list of symbols of interest\n    keys: A list of types of data of interest, e.g. Adj Close, Volume, etc.\n    \n    Returns:\n    data_dict: A dictionary whose keys are types of data, e.g. Adj Close, Volume, etc. and \n    values are dataframes with dates as indices and symbols as columns\n    """"""\n\n    data_dict = {}\n    for key in keys:\n        df = pd.DataFrame(index=dates)\n        for symbol in symbols:\n            df_temp = pd.read_csv(symbol_to_path(symbol), index_col=""Date"",\n                    parse_dates=True, usecols=[""Date"", key], na_values=[""nan""])\n            df_temp = df_temp.rename(columns={key: symbol})\n            df = df.join(df_temp) \n        data_dict[key] = df\n    return data_dict\n\ndef create_df_benchmark(symbol, start_date, end_date, num_shares):\n    """"""Create a dataframe of benchmark data. Benchmark is a portfolio consisting of\n    num_shares of the symbol in use and holding them until end_date.\n    """"""\n    # Get adjusted close price data\n    benchmark_prices = get_data([symbol], pd.date_range(start_date, end_date), \n                                addSPY=False).dropna()\n    # Create benchmark df: buy num_shares and hold them till the last date\n    df_benchmark_trades = pd.DataFrame(\n        data=[(benchmark_prices.index.min(), num_shares), \n        (benchmark_prices.index.max(), -num_shares)], \n        columns=[""Date"", ""Shares""])\n    df_benchmark_trades.set_index(""Date"", inplace=True)\n    return df_benchmark_trades\n\ndef create_df_trades(orders, symbol, num_shares, cash_pos=0, long_pos=1, short_pos=-1):\n    """"""Create a dataframe of trades based on the orders executed. +1000 \n    indicates a BUY of 1000 shares, and -1000 indicates a SELL of 1000 shares.\n    """"""\n    # Remove cash positions to make the ""for"" loop below run faster\n    non_cash_orders = orders[orders != cash_pos]\n    trades = []\n    for date in non_cash_orders.index:\n        if non_cash_orders.loc[date] == long_pos:\n            trades.append((date, num_shares))\n        elif non_cash_orders.loc[date] == short_pos:\n            trades.append((date, -num_shares))\n    df_trades = pd.DataFrame(trades, columns=[""Date"", ""Shares""])\n    df_trades.set_index(""Date"", inplace=True)\n    return df_trades'"
