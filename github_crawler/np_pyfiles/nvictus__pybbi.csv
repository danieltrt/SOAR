file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom setuptools import setup, Extension\nfrom setuptools.command.build_ext import build_ext as _build_ext\nfrom subprocess import check_call\nfrom distutils import log\nimport os.path as op\nimport sys\nimport os\nimport re\nimport io\n\n\nthisdir = op.dirname(op.realpath(__file__))\n\n\nclass lazylist(list):\n    \'\'\'\n    Used to delay the build-time Cython and numpy imports required to configure\n    our list of extension modules until after setup_requires has been processed.\n\n    \'\'\'\n    def __init__(self, callback):\n        self._list = None\n        self.callback = callback\n\n    def _cached_list(self):\n        if self._list is None:\n            self._list = self.callback()\n        return self._list\n\n    def __len__(self):\n        return len(self._cached_list())\n\n    def __iter__(self):\n        for e in self._cached_list():\n            yield e\n\n    def __getitem__(self, i):\n        return self._cached_list()[i]\n\n\ndef read(*parts, **kwargs):\n    encoding = kwargs.pop(\'encoding\', \'utf-8\')\n    filepath = op.join(op.dirname(__file__), *parts)\n    return io.open(filepath, encoding=encoding).read()\n\n\ndef get_version(pkg):\n    version = re.search(\n        r\'^__version__\\s*=\\s*[\\\'""]([^\\\'""]*)[\\\'""]\',\n        read(pkg, \'__init__.py\'),\n        re.MULTILINE).group(1)\n    return version\n\n\nclass build_ext(_build_ext):\n    def run(self):\n        os.environ[\'SETUP_PY\'] = \'1\'\n\n        # First, compile our C library: libkent.a\n        # import sysconfig\n        # log.info(sysconfig.get_config_vars())\n        # log.info(""CPATH: "" + os.environ.get(""CPATH"", """"))\n        # log.info(""LIBRARY_PATH: "" + os.environ.get(""LIBRARY_PATH"", """"))\n        log.info(""Compiling libkent archive..."")\n        check_call([\'make\', \'build-ucsc\'])\n\n        # Now, proceed to build extension modules\n        log.info(""Building extension module..."")\n        _build_ext.run(self)\n\n\ndef get_ext_modules():\n    from Cython.Build import cythonize\n    import numpy\n    import pkgconfig\n    import sysconfig\n\n    # https://solitum.net/openssl-os-x-el-capitan-and-brew/\n    if sys.platform == ""darwin"":\n        s = \'/usr/local/opt/openssl/lib/pkgconfig\'\n        old = os.environ.get(\'PKG_CONFIG_PATH\')\n        if old:\n            s = old + \':\' + s\n        os.environ[\'PKG_CONFIG_PATH\'] = s\n        os.environ[\'MACOSX_DEPLOYMENT_TARGET\'] = \\\n            sysconfig.get_config_var(\'MACOSX_DEPLOYMENT_TARGET\')\n        os.environ[\'BLDSHARED\'] = \\\n            \'gcc -bundle -undefined dynamic_lookup -arch x86_64 -g\'\n        os.environ[\'LDSHARED\'] = \\\n            \'gcc -bundle -undefined dynamic_lookup -arch x86_64 -g\'\n\n    if sys.platform == ""linux"":\n        s = \'-Wl,--no-as-needed\'\n        old = os.environ.get(""LDFLAGS"")\n        if old:\n            s = s + \' \' + old\n        os.environ[""LDFLAGS""] = s\n\n    d = pkgconfig.parse(\'zlib openssl libpng\')\n\n    ext_modules = [\n        Extension(\n            name=\'bbi.cbbi\',\n            sources=[\n                op.join(thisdir, \'bbi/cbbi.pyx\')\n            ],\n            libraries=[\n                \'kent\',\n            ] + d.pop(\'libraries\', []),\n            library_dirs=[\n                op.join(thisdir, \'src/x86_64\'),\n            ] + d.pop(\'library_dirs\', []),\n            include_dirs=[\n                numpy.get_include(),\n                op.join(thisdir, \'include\'),\n            ] + d.pop(\'include_dirs\', []),\n            **d\n        ),\n    ]\n    return cythonize(ext_modules)\n\n\nsetup(\n    name=\'pybbi\',\n    author=\'Nezar Abdennur\',\n    author_email=\'nabdennur@gmail.com\',\n    license=\'MIT\',\n    version=get_version(\'bbi\'),\n    packages=[\'bbi\'],\n    description=\'Python bindings to UCSC Big Binary (bigWig/bigBed) file library\',\n    long_description=read(\'README.md\'),\n    long_description_content_type=\'text/markdown\',\n    url=\'https://github.com/nvictus/pybbi\',\n    classifiers=[\n        \'Development Status :: 4 - Beta\',\n        \'License :: OSI Approved :: MIT License\',\n        \'Operating System :: POSIX\',\n        \'Operating System :: Unix\',\n        \'Operating System :: MacOS\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: 3\',\n        \'Topic :: Scientific/Engineering :: Bio-Informatics\',\n    ],\n    zip_safe=False,\n    setup_requires=[\n        \'setuptools>=18.0\',\n        \'cython\',\n        \'numpy\',\n        \'pkgconfig\'\n    ],\n    install_requires=[\n        \'six\',\n        \'numpy\'\n    ],\n    tests_require=[\n        \'pytest\'\n    ],\n    ext_modules=lazylist(get_ext_modules),\n    cmdclass={\n        \'build_ext\': build_ext\n    }\n)\n'"
bbi/__init__.py,0,"b""#-*- coding: utf-8 -*-\nfrom __future__ import division, print_function, absolute_import\nfrom .cbbi import (\n    is_bbi,\n    is_bigwig,\n    is_bigbed,\n    info,\n    zooms,\n    chromsizes,\n    fetch,\n    stackup,\n    fetch_intervals,\n)\n\n__all__ = ['is_bbi', 'is_bigwig', 'is_bigbed', 'info', 'zooms', 'chromsizes',\n           'fetch', 'stackup', 'fetch_intervals']\n\n__version__ = '0.2.2'\n"""
tests/__init__.py,0,b''
tests/test_bbi.py,16,"b""# -*- coding: utf-8 -*-\nfrom __future__ import division, print_function\nimport os.path as op\nimport numpy as np\n\nimport bbi\nimport pytest\n\nthisdir = op.dirname(op.realpath(__file__))\nBW_FILE = op.join(thisdir, 'bigWigExample.bw')\nBB_FILE = op.join(thisdir, 'bigBedExample.bb')\nBW_URL = 'http://genome.ucsc.edu/goldenPath/help/examples/bigWigExample.bw'\nBB_URL = 'http://genome.ucsc.edu/goldenPath/help/examples/bigBedExample.bb'\n\nbbi_paths_and_urls = [BW_FILE, BW_URL, BB_FILE, BB_URL]\nbbi_paths = [BW_FILE, BB_FILE]\nbbi_urls = [BW_URL, BB_URL]\n\n\ndef test_sigs():\n    assert bbi.is_bbi(BW_FILE)\n    assert bbi.is_bigwig(BW_FILE)\n    assert not bbi.is_bigbed(BW_FILE)\n\n    assert bbi.is_bbi(BW_URL)\n    assert bbi.is_bigwig(BW_URL)\n    assert not bbi.is_bigbed(BW_URL)\n\n    assert bbi.is_bbi(BB_FILE)\n    assert not bbi.is_bigwig(BB_FILE)\n    assert bbi.is_bigbed(BB_FILE)\n\n    assert bbi.is_bbi(BB_URL)\n    assert not bbi.is_bigwig(BB_URL)\n    assert bbi.is_bigbed(BB_URL)\n\n\n@pytest.mark.parametrize('uri', bbi_paths_and_urls)\ndef test_chromsizes(uri):\n    chromsizes = bbi.chromsizes(uri)\n    assert len(chromsizes) == 1 and 'chr21' in chromsizes\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_fetch(path):\n    x = bbi.fetch(path, 'chr21', 0, 1000)\n    assert len(x) == 1000\n\n    x = bbi.fetch(path, 'chr21', 0, 1000, bins=10)\n    assert len(x) == 10\n\n    with pytest.raises(KeyError):\n        bbi.fetch(path, 'chr1', 0, 1000)\n\n\ndef test_fetch_remote():\n    x_local = bbi.fetch(BW_FILE, 'chr21', 0, 100)\n    x_remote = bbi.fetch(BW_URL, 'chr21', 0, 100)\n    assert np.allclose(x_local, x_remote, equal_nan=True)\n\n    x_local = bbi.fetch(BB_FILE, 'chr21', 0, 100)\n    x_remote = bbi.fetch(BB_URL, 'chr21', 0, 100)\n    assert np.allclose(x_local, x_remote, equal_nan=True)\n\n\ndef test_fetch_remote_https():\n    x_local = bbi.fetch(BW_FILE, 'chr21', 0, 100)\n    x_remote = bbi.fetch(\n        BW_URL.replace('http://', 'https://'), 'chr21', 0, 100)\n    assert np.allclose(x_local, x_remote, equal_nan=True)\n\n    x_local = bbi.fetch(BB_FILE, 'chr21', 0, 100)\n    x_remote = bbi.fetch(\n        BB_URL.replace('http://', 'https://'), 'chr21', 0, 100)\n    assert np.allclose(x_local, x_remote, equal_nan=True)\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_fetch_missing(path):\n    x = bbi.fetch(path, 'chr21', 0, 1000, oob=0)\n    assert np.all(x[:10] == 0)\n    x = bbi.fetch(path, 'chr21', 0, 1000, missing=np.nan)\n    assert np.all(np.isnan(x[:10]))\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_fetch_oob(path):\n    x = bbi.fetch(path, 'chr21', -10, 1000, oob=np.nan)\n    assert np.all(np.isnan(x[:10]))\n    x = bbi.fetch(path, 'chr21', -10, 1000, oob=0)\n    assert np.all(x[:10] == 0)\n\n    n = bbi.chromsizes(path)['chr21']\n    x = bbi.fetch(path, 'chr21', n - 1000, n + 10, oob=np.nan)\n    assert np.all(np.isnan(x[-10:]))\n    x = bbi.fetch(path, 'chr21', n - 1000, n + 10, oob=0)\n    assert np.all(x[-10:] == 0)\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_fetch_intervals(path):\n    x = list(bbi.fetch_intervals(path, 'chr21', 0, 1000))  # unmappable region\n    assert len(x) == 0\n    x = list(bbi.fetch_intervals(path, 'chr21', 0, 10000000))\n    assert len(x) > 0\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_fetch_summary_stats(path):\n    x = bbi.fetch(path, 'chr21', 20000000, 20001000, bins=10, summary='mean')\n    y = bbi.fetch(path, 'chr21', 20000000, 20001000, bins=10)\n    assert np.allclose(x, y)\n\n    values = bbi.fetch(path, 'chr21', 20000000, 20001000)\n    vmin = bbi.fetch(\n        path, 'chr21', 20000000, 20001000, bins=10, summary='min'\n    ).min()\n    assert np.isclose(vmin, np.min(values))\n    vmax = bbi.fetch(\n        path, 'chr21', 20000000, 20001000, bins=10, summary='max'\n    ).max()\n    assert np.isclose(vmax, np.max(values))\n\n    with pytest.raises(ValueError):\n        bbi.fetch(path, 'chr21', 20000000, 20001000, bins=10, summary='foo')\n\n\n@pytest.mark.parametrize('path', bbi_paths)\ndef test_stackup(path):\n    x = bbi.stackup(path, ['chr21', 'chr21'], [0, 2000], [1000, 3000])\n    assert x.shape == (2, 1000)\n\n    x = bbi.stackup(path, ['chr21', 'chr21'], [0, 2000], [1000, 3000], bins=10)\n    assert x.shape == (2, 10)\n\n    # unequal interval lengths\n    with pytest.raises(ValueError):\n        bbi.stackup(path, ['chr21', 'chr21'], [0, 2000], [1000, 3500])\n\n    x = bbi.stackup(path, ['chr21', 'chr21'], [0, 2000], [1000, 3500], bins=10)\n    assert x.shape == (2, 10)\n\n\ndef test_aws_403_redirect():\n    # See https://stat.ethz.ch/pipermail/bioc-devel/2016-May/009241.html\n    url = 'https://www.encodeproject.org/files/ENCFF620UMO/@@download/ENCFF620UMO.bigWig'\n    bbi.fetch(url, 'chr21', 0, 1000)\n"""
