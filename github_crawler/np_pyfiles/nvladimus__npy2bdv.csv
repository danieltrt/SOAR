file_path,api_count,code
setup.py,0,"b'from setuptools import setup, find_packages\n\nsetup(\n        name=\'npy2bdv\',\n        version=\'2020.03.25\',\n        description=\'Package for writing/reading 3d numpy arrays to/from HDF5 files (Fiji/BigDataViewer/BigStitcher format).\',\n        url=\'https://github.com/nvladimus/npy2bdv\',\n        author=\'Nikita Vladimirov\',\n        author_email=""nvladimus@gmail.com"",\n        install_requires=[\n            \'h5py\',\n            \'numpy\',\n            \'scikit-image\',\n        ],\n        packages=find_packages()\n)\n'"
npy2bdv/__init__.py,0,b'from .npy2bdv import BdvWriter\nfrom .npy2bdv import BdvReader\n\n'
npy2bdv/examples.py,6,"b'import time\nimport sys\nimport os\nimport numpy as np\nimport npy2bdv\n\n\ndef generate_test_image(dim_yx):\n    """"""Gaussian blob spanning the whole range of uint16 type""""""\n    x = np.linspace(-3, 3, dim_yx[1])\n    y = np.linspace(-3, 3, dim_yx[0])\n    x, y = np.meshgrid(x, y)\n    return 65535 * np.exp(- ((x ** 2) / 2 + (y ** 2) / 2))\n\n\n######################\n## 1. Basic writing ##\n######################\nprint(""Example1: writing 2 time points, 2 channels, 2 illuminations, 2 angles"")\nplane = generate_test_image((1024, 2048))\nstack = []\nfor z in range(50):\n    stack.append(plane)\nstack = np.asarray(stack)\n\nif not os.path.exists(""./test""):\n    os.mkdir(""./test"")\nfname = ""./test/ex1_t2_ch2_illum2_angle2.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=2, nilluminations=2, nangles=2, subsamp=((1, 1, 1),))\nfor t in range(2):\n    for i_ch in range(2):\n        for i_illum in range(2):\n            for i_angle in range(2):\n                bdv_writer.append_view(stack, time=t, channel=i_ch, illumination=i_illum, angle=i_angle)\n\nbdv_writer.write_xml_file(ntimes=2)\nbdv_writer.close()\nprint(""dataset in "" + fname)\n\n#########################\n# 2. Writing speed test #\n#########################\nprint(""Example2: speed test for 20 time points and 2 channels. File size is 7 GB!"")\nntimes = 20\nnchannels = 2\nstart_time_total = time.time()\ni_stacks = 0\ntime_list = []\nfname = ""./test/ex2_t20_chan2.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=2, subsamp=((1, 1, 1),))\nfor ichannel in range(nchannels):\n    for itime in range(ntimes):\n        start_time = time.time()\n        bdv_writer.append_view(stack, time=itime, channel=ichannel)\n        time_interval = time.time() - start_time\n        time_list.append(time_interval)\n        i_stacks += 1.0\n\nbdv_writer.write_xml_file(ntimes=ntimes)\nbdv_writer.close()\ntime_per_stack = (time.time() - start_time_total) / i_stacks\nprint(""H5 mean writing time per stack: {:1.3f}"".format(time_per_stack) + "" sec."")\nprint(""H5 mean writing speed: "" + str(int(sys.getsizeof(stack) / time_per_stack / 1e6)) + "" MB/s"")\nprint(""speed test dataset in "" + fname)\n\n#################################################################\n# 3. Writing with affine transformations defined in XML file ####\n#################################################################\nprint(""Example3: writing 1 time point and 1 channel with 10-px un-shear transformation along X axis.\\n"" +\n      ""With non-isotropic voxel size calibration."")\nshear_x_px = 10\naffine_matrix = np.array(((1.0, 0.0, -shear_x_px, 0.0),\n                          (0.0, 1.0, 0.0, 0.0),\n                          (0.0, 0.0, 1.0, 0.0)))\n\nfname = ""./test/ex3_t1_ch1_unshear.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=1, subsamp=((1, 1, 1),))\nbdv_writer.append_view(stack, time=0, channel=0,\n                       m_affine=affine_matrix,\n                       name_affine=""unshearing transformation"",\n                       calibration=(1, 1, 1))\nbdv_writer.write_xml_file(ntimes=1)\nbdv_writer.close()\nprint(""unsheared stack in "" + fname)\n\n############################################\n# 4. Writing with experiment metadata ######\n############################################\nprint(""Example4: writing 1 time point and 1 channel with voxel size, exposure, camera and microscope properties"")\nfname = ""./test/ex4_t1_ch1_cam_props.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=1, subsamp=((1, 1, 1),))\nbdv_writer.append_view(stack, time=0, channel=0,\n                       voxel_size_xyz=(1, 1, 5), voxel_units=\'um\',\n                       exposure_time=10, exposure_units=\'ms\')\nbdv_writer.write_xml_file(ntimes=1, camera_name=""Hamamatsu OrcaFlash100"",\n                          microscope_name=\'Superscope\',\n                          user_name=\'nvladimus\')\nbdv_writer.close()\nprint(""dataset is in "" + fname)\n\n################################################\n# 5. Writing with subsampling and compression ##\n################################################\nprint(""Example5: 1 time point and 1 channel with 3-level subsampling and compression"")\nfname = ""./test/ex5_t1_ch1_level3_gzip.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=1,\n                               subsamp=((1, 1, 1), (2, 4, 4), (4, 16, 16)),\n                               blockdim=((64, 64, 64),),\n                               compression=\'gzip\')\nbdv_writer.append_view(stack, time=0, channel=0)\nbdv_writer.write_xml_file(ntimes=1)\nbdv_writer.close()\nprint(""dataset is in "" + fname)\n\n##########################################################\n# 6. Writing virtual stacks that are too big to fit RAM ##\n##########################################################\nprint(""Example6: 1 time point, 2 channels, HUGE virtual stack, 20 GB!"")\nstack_dim_zyx = (250, 3648, 5472)\nimage_plane = generate_test_image(stack_dim_zyx[1:])\nfname = ""./test/ex6_t1_ch1_huge_virtual.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=2,\n                               blockdim=((1, int(image_plane.shape[0]/4), int(image_plane.shape[1]/4)),))\n\nfor i_ch in range(2):\n    bdv_writer.append_view(stack=None, virtual_stack_dim=stack_dim_zyx, time=0, channel=i_ch)\n    for i_plane in range(stack_dim_zyx[0]):\n        bdv_writer.append_plane(plane=image_plane, plane_index=i_plane, time=0, channel=i_ch)\n\nbdv_writer.write_xml_file(ntimes=1)\nbdv_writer.close()\nprint(""virtual stack is in "" + fname)\n\n############################################\n## 7. Missing views, normal stack writing ##\n############################################\nprint(""Example7: Automatic calculation of missing views."")\nfname = ""./test/ex7_missing_views.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=2, subsamp=((1, 1, 1),))\nbdv_writer.append_view(stack, time=0, channel=0)\nbdv_writer.append_view(stack, time=1, channel=1)\nbdv_writer.write_xml_file(ntimes=2)\nbdv_writer.close()\nprint(""dataset with missing views in "" + fname)\n\n#####################################\n## 8. Missing views, virtual stack ##\n#####################################\nprint(""Example8: Automatic calculation of missing views, virtual stack."")\nstack_dim_zyx = (50, 1000, 2000)\nimage_plane = generate_test_image(stack_dim_zyx[1:])\nfname = ""./test/ex8_virtual_stack_missing_views.h5""\nbdv_writer = npy2bdv.BdvWriter(fname, nchannels=2, subsamp=((1, 1, 1),))\nbdv_writer.append_view(stack=None, virtual_stack_dim=stack_dim_zyx, time=0, channel=0)\nbdv_writer.append_view(stack=None, virtual_stack_dim=stack_dim_zyx, time=1, channel=1)\n\nfor i_plane in range(stack_dim_zyx[0]):\n    bdv_writer.append_plane(plane=image_plane, plane_index=i_plane, time=0, channel=0)\n    bdv_writer.append_plane(plane=image_plane, plane_index=i_plane, time=1, channel=1)\n\nbdv_writer.write_xml_file(ntimes=2)\nbdv_writer.close()\nprint(""dataset with missing views in "" + fname)\n'"
npy2bdv/npy2bdv.py,6,"b'# Fast writing of numpy arrays to HDF5 format compatible with Fiji/BigDataViewer and BigStitcher\n# Author: Nikita Vladimirov\n# License: GPL-3.0\nimport os\nimport h5py\nimport numpy as np\nfrom xml.etree import ElementTree as ET\nimport skimage.transform\n\n\nclass BdvWriter:\n    def __init__(self, filename,\n                 subsamp=((1, 1, 1),),\n                 blockdim=((4, 256, 256),),\n                 compression=None,\n                 nilluminations=1, nchannels=1, ntiles=1, nangles=1):\n        """"""Class for writing multiple numpy 3d-arrays into BigDataViewer/BigStitcher HDF5 file.\n\n        Parameters:\n            filename: (string) full path to a new file\n            subsamp: (tuple of tuples),\n                Subsampling levels in (z,y,x) order. Integers >= 1, default value ((1, 1, 1),)\n            blockdim: (tuple of tuples),\n                Block size for h5 storage, in pixels, in (z,y,x) order. Default ((4,256,256),), see notes.\n            compression: str\n                (None, \'gzip\', \'lzf\'), HDF5 compression method. Default is None for high-speed writing.\n            nilluminations, nchannels, ntiles, nangles, (int)\n                number of view attributes, default 1.\n\n        Notes:\n        Input stacks and output files are assumed uint16 type.\n\n        The h5 recommended block (chunk) size should be between 10 KB and 1 MB, larger for large arrays.\n        For example, block dimensions (4,256,256)px gives ~0.5MB block size for type int16 (2 bytes) and writes very fast.\n        Block size can be larger than stack dimension.\n        """"""\n        assert nilluminations >= 1, ""Total number of illuminations must be at least 1.""\n        assert nchannels >= 1, ""Total number of channels must be at least 1.""\n        assert ntiles >= 1, ""Total number of tiles must be at least 1.""\n        assert nangles >= 1, ""Total number of angles must be at least 1.""\n        assert compression in (None, \'gzip\', \'lzf\'), \'Unknown compression type\'\n        assert all([isinstance(element, int) for tupl in subsamp for element in\n                    tupl]), \'subsamp values should be integers >= 1.\'\n        if len(blockdim) < len(subsamp):\n            print(""Number of blockdim levels ("" + str (len(blockdim)) +\n                  "") is less than subsamp levels ("" + str(len(subsamp)) + "")\\n"" +\n                  ""First-level block size "" + str(blockdim[0]) + "" will be used for all levels"")\n\n        self.nsetups = nilluminations * nchannels * ntiles * nangles\n        self.nilluminations = nilluminations\n        self.nchannels = nchannels\n        self.ntiles = ntiles\n        self.nangles = nangles\n        self.subsamp = np.asarray(subsamp)\n        self.nlevels = len(subsamp)\n        self.chunks = self._compute_chunk_size(blockdim)\n        self.stack_shapes = {}\n        self.affine_matrices = {}\n        self.affine_names = {}\n        self.calibrations = {}\n        self.voxel_size_xyz = {}\n        self.voxel_units = {}\n        self.exposure_time = {}\n        self.exposure_units = {}\n        self.compression = compression\n        self.filename = filename\n        self.file_object = h5py.File(filename, \'a\')\n        self._write_setups_header()\n        self.virtual_stacks = False\n        self.setup_id_present = [[False] * self.nsetups]\n        self.__version__ = ""2020.03""\n\n    def _write_setups_header(self):\n        """"""Write resolutions and subdivisions for all setups into h5 file.""""""\n        for isetup in range(self.nsetups):\n            group_name = \'s{:02d}\'.format(isetup)\n            if group_name in self.file_object:\n                del self.file_object[group_name]\n            grp = self.file_object.create_group(group_name)\n            data_subsamp = np.flip(self.subsamp, 1)\n            data_chunks = np.flip(self.chunks, 1)\n            grp.create_dataset(\'resolutions\', data=data_subsamp, dtype=\'<f8\')\n            grp.create_dataset(\'subdivisions\', data=data_chunks, dtype=\'<i4\')\n\n    def append_plane(self, plane, plane_index, time=0, illumination=0, channel=0, tile=0, angle=0):\n        """"""Append a plane to initialized virtual stack. Requires stack initialization by calling e.g.\n        append_view(stack=None, virtual_stack_dim=(1000,2048,2048)).\n        Parameters:\n            plane: numpy array(uint16)\n                A 2d array of (y,x) pixel values.\n            plane_index: (int)\n                Plane z-position in the virtual stack.\n            time: (int)\n                time index, starting from 0.\n            illumination, channel, view, angle: (int)\n                indices of the view attributes, starting from 0.\n        """"""\n        assert self.virtual_stacks, ""Appending planes requires initialization with virtual stack, "" \\\n                                    ""see append_view(stack=None,...)""\n        isetup = self._determine_setup_id(illumination, channel, tile, angle)\n        self.update_setup_id_present(isetup, time)\n        assert plane.shape == self.stack_shapes[isetup][1:], ""Plane dimensions must match (y,x) size of virtual stack.""\n        assert plane_index < self.stack_shapes[isetup][0], ""Plane index must be less than virtual stack z-dimension.""\n        assert self.nlevels == 1, ""No subsampling currently implemented for virtual stack writing.""\n        fmt = \'t{:05d}/s{:02d}/{}\'\n        for ilevel in range(self.nlevels):\n            group_name = fmt.format(time, isetup, ilevel)\n            dataset = self.file_object[group_name][""cells""]\n            dataset[plane_index, :, :] = plane.astype(\'int16\')\n\n    def append_view(self, stack, virtual_stack_dim=None,\n                    time=0, illumination=0, channel=0, tile=0, angle=0,\n                    m_affine=None, name_affine=\'manually defined\',\n                    voxel_size_xyz=(1, 1, 1), voxel_units=\'px\', calibration=(1, 1, 1),\n                    exposure_time=0, exposure_units=\'s\'):\n        """"""Write numpy 3-dimensional array (stack) to h5 file at specified timepint (itime) and setup number (isetup).\n        Parameters:\n            stack: numpy array (uint16) or None\n                A 3-dimensional stack of uint16 data in (z,y,x) axis order.\n                If None, creates an empty dataset of size huge_stack_dim.\n            virtual_stack_dim: None or tuple of (z,y,x) dimensions, optional\n                Dimensions to allocate a huge stack and fill it later by individual planes.\n            time: (int)\n                time index, starting from 0.\n            illumination, channel, view, angle: (int)\n                indices of the view attributes, starting from 0.\n            m_affine: a (3,4) numpy array, optional\n                Coefficients of affine transformation matrix (m00, m01m ...)\n            name_affine: str, optional\n                Name of affine transformation\n            voxel_size_xyz: tuple of 3 elements, optional\n                The physical size of voxel, in voxel_units. Default (1, 1, 1).\n            voxel_units: str, optional\n                spatial units (default is \'px\').\n            calibration: tuple of 3 elements, optional\n                The anisotropy factors for (x,y,z) voxel calibration. Default (1, 1, 1).\n                Leave it default unless you are expert in BigStitcher and know how it affects transformations.\n            exposure_time: scalar, optional\n                Camera exposure time for this view, default 0.\n            exposure_units: str, optional\n                Time units for this view, default ""s"".\n\n        """"""\n        assert len(calibration) == 3, ""Calibration must be a tuple of 3 elements (x, y, z).""\n        assert len(voxel_size_xyz) == 3, ""Voxel size must be a tuple of 3 elements (x, y, z).""\n        fmt = \'t{:05d}/s{:02d}/{}\'\n        isetup = self._determine_setup_id(illumination, channel, tile, angle)\n        self.update_setup_id_present(isetup, time)\n        if stack is not None:\n            assert len(stack.shape) == 3, ""Stack should be a 3-dimensional numpy array (z,y,x)""\n            self.stack_shapes[isetup] = stack.shape\n        else:\n            assert len(virtual_stack_dim) == 3, ""Stack is virtual, so parameter virtual_stack_dim must be defined.""\n            self.stack_shapes[isetup] = virtual_stack_dim\n            self.virtual_stacks = True\n\n        for ilevel in range(self.nlevels):\n            group_name = fmt.format(time, isetup, ilevel)\n            if group_name in self.file_object:\n                del self.file_object[group_name]\n            grp = self.file_object.create_group(group_name)\n            if stack is not None:\n                subdata = self._subsample_stack(stack, self.subsamp[ilevel]).astype(\'int16\')\n                grp.create_dataset(\'cells\', data=subdata, chunks=self.chunks[ilevel],\n                                   maxshape=(None, None, None), compression=self.compression, dtype=\'int16\')\n            else:  # a huge virtual stack can be initialized\n                assert self.nlevels == 1, ""No subsampling currently implemented for virtual stacks.""\n                grp.create_dataset(\'cells\', chunks=self.chunks[ilevel],\n                                   shape=virtual_stack_dim, compression=self.compression, dtype=\'int16\')\n        if m_affine is not None:\n            self.affine_matrices[isetup] = m_affine\n            self.affine_names[isetup] = name_affine\n        self.calibrations[isetup] = calibration\n        self.voxel_size_xyz[isetup] = voxel_size_xyz\n        self.voxel_units[isetup] = voxel_units\n        self.exposure_time[isetup] = exposure_time\n        self.exposure_units[isetup] = exposure_units\n\n    def _compute_chunk_size(self, blockdim):\n        """"""Populate the size of h5 chunks.\n        Use first-level chunk size if there are more subsampling levels than chunk size levels.\n        """"""\n        chunks = []\n        base_level = blockdim[0]\n        if len(blockdim) < len(self.subsamp):\n            for ilevel in range(len(self.subsamp)):\n                chunks.append(base_level)\n            chunks_tuple = tuple(chunks)\n        else:\n            chunks_tuple = blockdim\n        return chunks_tuple\n\n    def _subsample_stack(self, stack, subsamp_level):\n        """"""Subsampling of 3d stack.\n        Parameters:\n            stack, numpy 3d array (z,y,x) of int16\n            subsamp_level, array-like with 3 elements, eg (2,4,4) for downsampling z(x2), x and y (x4).\n        Return:\n            down-scaled stack, unit16 type.\n        """"""\n        if all(subsamp_level[:] == 1):\n            stack_sub = stack\n        else:\n            stack_sub = skimage.transform.downscale_local_mean(stack, tuple(subsamp_level)).astype(np.uint16)\n        return stack_sub\n\n    def write_xml_file(self, ntimes=1,\n                       camera_name=""default"",  microscope_name=""default"",\n                       microscope_version=""0.0"", user_name=""user""):\n        """"""\n        Write XML header file for the HDF5 file.\n\n        Parameters:\n            ntimes: int\n                number of time points\n            camera_name: str, optional\n                Name of the camera (same for all setups at the moment, ToDo)\n            microscope_name: str, optional\n            microscope_version: str, optional\n            user_name: str, optional\n        """"""\n        assert ntimes >= 1, ""Total number of time points must be at least 1.""\n        root = ET.Element(\'SpimData\')\n        root.set(\'version\', \'0.2\')\n        bp = ET.SubElement(root, \'BasePath\')\n        bp.set(\'type\', \'relative\')\n        bp.text = \'.\'\n        # new XML data, added by @nvladimus\n        generator = ET.SubElement(root, \'generatedBy\')\n        library = ET.SubElement(generator, \'library\')\n        library.set(\'version\', self.__version__)\n        library.text = ""npy2bdv""\n        microscope = ET.SubElement(generator, \'microscope\')\n        ET.SubElement(microscope, \'name\').text = microscope_name\n        ET.SubElement(microscope, \'version\').text = microscope_version\n        ET.SubElement(microscope, \'user\').text = user_name\n        # end of new XML data\n\n        seqdesc = ET.SubElement(root, \'SequenceDescription\')\n        imgload = ET.SubElement(seqdesc, \'ImageLoader\')\n        imgload.set(\'format\', \'bdv.hdf5\')\n        el = ET.SubElement(imgload, \'hdf5\')\n        el.set(\'type\', \'relative\')\n        el.text = os.path.basename(self.filename)\n        # write ViewSetups\n        viewsets = ET.SubElement(seqdesc, \'ViewSetups\')\n        for iillumination in range(self.nilluminations):\n            for ichannel in range(self.nchannels):\n                for itile in range(self.ntiles):\n                    for iangle in range(self.nangles):\n                        isetup = self._determine_setup_id(iillumination, ichannel, itile, iangle)\n                        if any([self.setup_id_present[t][isetup] for t in range(len(self.setup_id_present))]):\n                            vs = ET.SubElement(viewsets, \'ViewSetup\')\n                            ET.SubElement(vs, \'id\').text = str(isetup)\n                            ET.SubElement(vs, \'name\').text = \'setup \' + str(isetup)\n                            nz, ny, nx = tuple(self.stack_shapes[isetup])\n                            ET.SubElement(vs, \'size\').text = \'{} {} {}\'.format(nx, ny, nz)\n                            vox = ET.SubElement(vs, \'voxelSize\')\n                            ET.SubElement(vox, \'unit\').text = self.voxel_units[isetup]\n                            dx, dy, dz = self.voxel_size_xyz[isetup]\n                            ET.SubElement(vox, \'size\').text = \'{} {} {}\'.format(dx, dy, dz)\n                            # new XML data, added by @nvladimus\n                            cam = ET.SubElement(vs, \'camera\')\n                            ET.SubElement(cam, \'name\').text = camera_name\n                            ET.SubElement(cam, \'exposureTime\').text = \'{}\'.format(self.exposure_time[isetup])\n                            ET.SubElement(cam, \'exposureUnits\').text = self.exposure_units[isetup]\n                            # end of new XML data\n                            a = ET.SubElement(vs, \'attributes\')\n                            ET.SubElement(a, \'illumination\').text = str(iillumination)\n                            ET.SubElement(a, \'channel\').text = str(ichannel)\n                            ET.SubElement(a, \'tile\').text = str(itile)\n                            ET.SubElement(a, \'angle\').text = str(iangle)\n\n        # write Attributes (range of values)\n        attrs_illum = ET.SubElement(viewsets, \'Attributes\')\n        attrs_illum.set(\'name\', \'illumination\')\n        for iilumination in range(self.nilluminations):\n            illum = ET.SubElement(attrs_illum, \'Illumination\')\n            ET.SubElement(illum, \'id\').text = str(iilumination)\n            ET.SubElement(illum, \'name\').text = \'illumination \' + str(iilumination)\n\n        attrs_chan = ET.SubElement(viewsets, \'Attributes\')\n        attrs_chan.set(\'name\', \'channel\')\n        for ichannel in range(self.nchannels):\n            chan = ET.SubElement(attrs_chan, \'Channel\')\n            ET.SubElement(chan, \'id\').text = str(ichannel)\n            ET.SubElement(chan, \'name\').text = \'channel \' + str(ichannel)\n\n        attrs_tile = ET.SubElement(viewsets, \'Attributes\')\n        attrs_tile.set(\'name\', \'tile\')\n        for itile in range(self.ntiles):\n            tile = ET.SubElement(attrs_tile, \'Tile\')\n            ET.SubElement(tile, \'id\').text = str(itile)\n            ET.SubElement(tile, \'name\').text = \'tile \' + str(itile)\n\n        attrs_ang = ET.SubElement(viewsets, \'Attributes\')\n        attrs_ang.set(\'name\', \'angle\')\n        for iangle in range(self.nangles):\n            ang = ET.SubElement(attrs_ang, \'Angle\')\n            ET.SubElement(ang, \'id\').text = str(iangle)\n            ET.SubElement(ang, \'name\').text = \'angle \' + str(iangle)\n\n        # Time points\n        tpoints = ET.SubElement(seqdesc, \'Timepoints\')\n        tpoints.set(\'type\', \'range\')\n        ET.SubElement(tpoints, \'first\').text = str(0)\n        ET.SubElement(tpoints, \'last\').text = str(ntimes - 1)\n\n        # missing views\n        if any(True in l for l in self.setup_id_present):\n            miss_views = ET.SubElement(seqdesc, \'MissingViews\')\n            for t in range(len(self.setup_id_present)):\n                for i in range(len(self.setup_id_present[t])):\n                    if not self.setup_id_present[t][i]:\n                        miss_view = ET.SubElement(miss_views, \'MissingView\')\n                        miss_view.set(\'timepoint\', str(t))\n                        miss_view.set(\'setup\', str(i))\n\n        # Transformations of coordinate system\n        vregs = ET.SubElement(root, \'ViewRegistrations\')\n        for itime in range(ntimes):\n            for isetup in range(self.nsetups):\n                if self.setup_id_present[itime][isetup]:\n                    vreg = ET.SubElement(vregs, \'ViewRegistration\')\n                    vreg.set(\'timepoint\', str(itime))\n                    vreg.set(\'setup\', str(isetup))\n                    # write arbitrary affine transformation, specific for each view\n                    if isetup in self.affine_matrices.keys():\n                        vt = ET.SubElement(vreg, \'ViewTransform\')\n                        vt.set(\'type\', \'affine\')\n                        ET.SubElement(vt, \'Name\').text = self.affine_names[isetup]\n                        n_prec = 6\n                        mx_string = np.array2string(self.affine_matrices[isetup].flatten(), separator=\' \',\n                                                    precision=n_prec, floatmode=\'fixed\',\n                                                    max_line_width=(n_prec+5)*4)\n                        ET.SubElement(vt, \'affine\').text = mx_string[1:-1].strip()\n\n                    # write registration transformation (calibration)\n                    vt = ET.SubElement(vreg, \'ViewTransform\')\n                    vt.set(\'type\', \'affine\')\n                    ET.SubElement(vt, \'Name\').text = \'calibration\'\n                    calx, caly, calz = self.calibrations[isetup]\n                    ET.SubElement(vt, \'affine\').text = \\\n                        \'{} 0.0 0.0 0.0 0.0 {} 0.0 0.0 0.0 0.0 {} 0.0\'.format(calx, caly, calz)\n\n        self._xml_indent(root)\n        tree = ET.ElementTree(root)\n        tree.write(os.path.splitext(self.filename)[0] + "".xml"", xml_declaration=True, encoding=\'utf-8\', method=""xml"")\n        return\n\n    def _xml_indent(self, elem, level=0):\n        """"""Pretty printing function""""""\n        i = ""\\n"" + level * ""  ""\n        if len(elem):\n            if not elem.text or not elem.text.strip():\n                elem.text = i + ""  ""\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = i\n            for elem in elem:\n                self._xml_indent(elem, level + 1)\n            if not elem.tail or not elem.tail.strip():\n                elem.tail = i\n        else:\n            if level and (not elem.tail or not elem.tail.strip()):\n                elem.tail = i\n\n    def _determine_setup_id(self, illumination=0, channel=0, tile=0, angle=0):\n        """"""Takes the view attributes (illumination, channel, tile, angle) and converts them into unique setup_id.\n        Parameters:\n            illumination (int) >=0\n            channel (int) >= 0\n            tile (int) >= 0\n            angle (int) >= 0\n        Returns\n            setup_id (int), starting from 0 (first setup)\n            """"""\n        setup_id_matrix = np.arange(self.nsetups)\n        setup_id_matrix = setup_id_matrix.reshape((self.nilluminations, self.nchannels, self.ntiles, self.nangles))\n        setup_id = setup_id_matrix[illumination, channel, tile, angle]\n        return setup_id\n\n    def update_setup_id_present(self, isetup, itime):\n        """"""Update the lookup table (list of lists) for missing setups""""""\n        if len(self.setup_id_present) <= itime:\n            self.setup_id_present.append([False] * self.nsetups)\n        self.setup_id_present[itime][isetup] = True\n\n    def close(self):\n        """"""Close the file object.""""""\n        self.file_object.close()\n\n\nclass BdvReader:\n    def __init__(self, filename_h5=None):\n        """"""Class for reading a BigDataViewer/BigStitcher HDF5 file into numpy array.\n\n        Constructor parameters\n            filename_h5: (string), optional, full path to a HDF5 file (default None).\n        """"""\n        self.__version__ = ""2020.01.07""\n        self.__fmt = \'t{:05d}/s{:02d}/{}\'\n        self.filename_h5 = filename_h5\n        if filename_h5 is not None:\n            assert os.path.exists(filename_h5), ""Error: HDF5 file not found""\n            self.__file_object = h5py.File(filename_h5, \'r\')\n        else:\n            self.__file_object = None\n\n    def set_path_h5(self, filename_h5):\n        """"""Set the file path to HDF5 file. If another file was already open, it closes it before proceeding""""""\n        assert os.path.exists(filename_h5), ""Error: HDF5 file not found""\n        if self.__file_object is not None:\n            self.__file_object.close()\n        self.__file_object = h5py.File(filename_h5, \'r\')\n\n    def read_view(self, time=0, isetup=0, ilevel=0):\n        """"""Read a view (stack) specified by its time, setup ID, and downsampling level.\n\n        Parameters\n            time: (int) index of time point (default 0).\n            isetup: (int), index of setup ID (default 0)\n            ilevel: (int), level of subsampling, if available (default 0, no subsampling)\n\n        Returns\n            dataset: a numpy array (ndim=3)""""""\n        group_name = self.__fmt.format(time, isetup, ilevel)\n        dataset = self.__file_object[group_name][""cells""]\n        return dataset\n\n    def close(self):\n        """"""Close the file object.""""""\n        self.__file_object.close()\n'"
