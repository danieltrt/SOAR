file_path,api_count,code
ugen/python/api.py,15,"b'import numpy as np\n\nsample_rate = 0 # this is set externally later\n\ndef out(dst, src):\n    """"""\n    Write the data in src to the buffer dst.\n    """"""\n    if type(dst) is list:\n        for i in range(0, len(dst)):\n            dst[i][:] = src[i]\n    elif type(dst) is array:\n        dst[:] = src[:]\n    else:\n        raise ""invalid output type""\n\ndef to_polar(x):\n    """"""\n    Convert from cartesian to polar coordinates, where the magnitude and\n    phase are stored as the real and imaginary parts of a complex number,\n    respectively.\n    """"""\n    return np.abs(x) + 1j * np.angle(x)\n\ndef from_polar(x):\n    """"""\n    Convert from polar to cartesian coordinates. The polar input is expected\n    to have its magnitude and phase stored as the real and imaginary parts\n    of a complex number, respectively.\n    """"""\n    return x.real * np.exp(1j * x.imag)\n\nclass BackBuffer:\n    """"""\n    A simple class that stores previous frames in a buffer.\n    """"""\n    def __init__(self, size):\n        self.size = size\n        self.items = []\n\n    def push(self, item):\n        """"""\n        Add an item to the end of the buffer.\n        If the size is exceeded, the last element will be removed.\n        """"""\n        if len(self.items) == self.size:\n            del self.items[0]\n        self.items.append(item)\n\n    def get(self, idx=-1):\n        """"""\n        Retrieve an item from the buffer at a given index.\n        Positive indices index forward in time, where as negative indices index\n        backward in time.\n        Indices outsize the bounds of the buffer will wrap around.\n        """"""\n        return self.items[idx % len(self.items)]\n\nclass PhaseVocoder:\n    """"""\n    The phase vocoder is a transformation that allows for more fine grained\n    frequency analysis and manipulation than can be achieved from a basic\n    fourier transform. It requires that some state is maintained between\n    calls, so a PhaseVocoder object should be preserved globally.\n    """"""\n    def __init__(self, hop):\n        """"""\n        Create a new phase vocoder with a given hop size. This size should be\n        the same as the STFT hop size. In SuperCollider, it is an optional\n        argument to FFT() which defaults to 1/2. For optimal quality, try 1/4\n        or 1/8.\n        """"""\n        self.last_phase = None\n        self.sum_phase = None\n        self.shape = None\n        self.hop = hop\n\n    def forward(self, x):\n        """"""\n        Performs a forwards phase vocoder transform on x. x is expected to be\n        in cartesian form. An array of complex numbers is returned where the\n        real part represents amplitude and the imaginary part represents\n        frequency.\n        """"""\n        if self.shape != x.shape:\n            self.shape = x.shape\n            self.last_phase = np.zeros(x.shape)\n            self.sum_phase = np.zeros(x.shape)\n            self.frame_size = x.shape[-1]\n            self.freq_per_bin = sample_rate / self.frame_size / 2.0\n            self.step_size = self.frame_size * self.hop\n            self.expect = 2.0 * np.pi * self.hop\n            self.bins = np.arange(self.frame_size)\n        polar = to_polar(x)\n        p = polar.imag - self.last_phase\n        self.last_phase = polar.imag\n        p -= self.bins * self.expect\n        qpd = (p / np.pi).astype(int)\n        qpd = qpd + (qpd >= 0) * (qpd & 1) - (qpd < 0) * (qpd & 1)\n        p -= np.pi * qpd.astype(float)\n        p = p / self.hop / (2.0 * np.pi)\n        p = self.bins * self.freq_per_bin + p * self.freq_per_bin\n        return polar.real + p*1j\n\n    def backward(self, x):\n        """"""\n        Performs a backwards phase vocoder transform on x. x is expected to be\n        in the form returned by forward(). An array of complex numbers in\n        cartesian form is returned.\n        """"""\n        if self.shape != x.shape:\n            raise ""wrong shape!""\n        p = x.imag - self.bins * self.freq_per_bin\n        p /= self.freq_per_bin\n        p *= self.expect\n        p += self.bins * self.expect\n        self.sum_phase += p\n        return from_polar(x.real + 1j*self.sum_phase)\n\n    def shift(self, x, fn):\n        """"""\n        A shift operation, which can be used to implement various pitch shift\n        operations, among many other more exotic effects.\n\n        x is transformed by applying fn to the frequencies in x, then fn is\n        applied to the expected center frequencies of the bins in x, to handle\n        bin overflow.\n        """"""\n        row, col = np.indices(x.shape)\n\n        # transform coordinates\n        col = col.astype(float)\n        col = fn(col*self.freq_per_bin)/self.freq_per_bin\n        col = np.round(col).astype(int)\n        col = np.clip(col, 0, x.shape[-1]-1)\n\n        # transform frequencies\n        x.imag = fn(x.imag)\n\n        # remap\n        y = np.zeros(x.shape, np.complex128)\n        y[row, col] += x\n        return y\n\n    def to_bin_offset(self, x):\n        """"""\n        Converts frequency into bin relative form - the center of each bin\n        becomes that bin\'s zero frequency.\n        """"""\n        return x.real + 1j*(x.imag - self.freq_per_bin*np.indices(x.shape)[1] + self.freq_per_bin/2)\n\n    def from_bin_offset(self, x):\n        """"""\n        The inverse of to_bin_offset().\n        """"""\n        return x.real + 1j*(x.imag + self.freq_per_bin*np.indices(x.shape)[1] - self.freq_per_bin/2)\n'"
