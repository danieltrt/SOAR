file_path,api_count,code
__main__.py,0,b'from cli import main\n\nmain()\n'
cli.py,0,"b'import argparse\nimport agents\n\n\ndef list_agents():\n    for a in agents.__all__:\n        print(a)\n\n\ndef _get_args():\n    """"""Parse arguments from the command line and return them.""""""\n    parser = argparse.ArgumentParser(description=__doc__)\n    # add the argument for the Super Mario Bros environment to run\n    parser.add_argument(\'--rom\', \'-r\',\n                        type=str,\n                        help=\'The path to the ROM to play.\'\n                        )\n    # add the argument for the mode of execution as either human or random\n    parser.add_argument(\'--mode\', \'-m\',\n                        type=str,\n                        default=\'human\',\n                        choices=[\'human\', \'random\'],\n                        help=\'The execution mode for the emulation.\',\n                        )\n    # add the argument for the number of steps to take in random mode\n    parser.add_argument(\'--steps\', \'-s\',\n                        type=int,\n                        default=500,\n                        help=\'The number of random steps to take.\',\n                        )\n\n    # name of agent\n    parser.add_argument(\'--agentName\', \'-a\',\n                        type=str,\n                        default=\'RandomAgent\',\n                        help=\'The name of the agent to be used\'\n                        )\n\n    # agent configuration file path\n    parser.add_argument(\'--agentConfig\', \'-ac\',\n                        type=str,\n                        help=\'The location of an agent configuration file\'\n                        )\n\n    # list agents\n    parser.add_argument(\'--agentList\', \'-al\',\n                        action=\'store_true\',\n                        help=\'Print all agent names\'\n                        )\n\n    return parser.parse_args()\n\n\ndef main():\n    args = _get_args()\n    if args.agentList:\n        list_agents()\n        return\n\n    if args.agentName:\n        agentName = args.agentName\n        if agentName in agents.__all__:\n            mod = getattr(agents, agentName)\n            AC = getattr(mod, agentName)\n            AC(args)\n        else:\n            raise Exception(""Invalid agent name: "" + agentName)\n'"
agents/BasicAgent.py,0,"b'class BasicAgent():\n    def __init__(self, args):\n        print(""Basic Agent!"")\n'"
agents/DQRAgent.py,2,"b'from envs.rom_wrapper import ROMWrapper\nfrom nes_py.wrappers import JoypadSpace\nfrom nes_py._image_viewer import ImageViewer\nfrom nes_py.app.play_human import play_human\nfrom nes_py.app.cli import _get_args\nimport time\n\nimport numpy as np\nimport math\nimport random\nfrom itertools import count\nfrom PIL import Image\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torchvision.transforms as T\nimport torch.optim as optim\nfrom torch.distributions import Categorical\n\nsteps_done = 0\n\n\nclass DQRAgent():\n    def __init__(self, args):\n        # required arg\n        rom_path = args.rom\n\n        # if gpu is to be used\n        device = torch.device(""cuda"" if torch.cuda.is_available() else ""cpu"")\n\n        print(""Device: "", device)\n\n        actions = [\n            [\'start\'],\n            [\'NOOP\'],\n            [\'right\', \'A\'],\n            [\'left\', \'A\'],\n            [\'left\', \'B\'],\n            [\'right\', \'B\'],\n            [\'down\', \'A\'],\n            [\'down\', \'B\'],\n            [\'up\', \'A\'],\n            [\'up\', \'B\'],\n            [\'up\'],\n            [\'down\'],\n            [\'A\'],\n            [\'B\']\n        ]\n\n        # create the environment\n        env = ROMWrapper(rom_path)\n\n        screen_height = 240\n        screen_width = 256\n\n        DATA_PATH = ""data/dqr_model.pt""\n        SHOULD_LOAD_STATE = False  # use pre-trained model or not\n        SHOULD_RENDER = True\n        SHOULD_TRAIN = True\n        FLAT_STATE_SIZE = 2048\n        GAMMA = 0.2\n        log_interval = 100\n        num_steps_per_episode = 2250\n        reward_threshold = 1500.0\n\n        resize = T.Compose([T.ToPILImage(),\n                            T.Resize(40, interpolation=Image.CUBIC),\n                            T.ToTensor()])\n\n        # DQR STUFF\n\n        class Policy(nn.Module):\n            def __init__(self, h, w, outputs):\n                super(Policy, self).__init__()\n                self.conv1 = nn.Conv2d(3, 16, kernel_size=5, stride=2)\n                self.bn1 = nn.BatchNorm2d(16)\n                self.conv2 = nn.Conv2d(16, 32, kernel_size=5, stride=2)\n                self.bn2 = nn.BatchNorm2d(32)\n                self.conv3 = nn.Conv2d(32, 32, kernel_size=5, stride=2)\n                self.bn3 = nn.BatchNorm2d(32)\n\n                # Number of Linear input connections depends on output of conv2d layers\n                # and therefore the input image size, so compute it.\n\n                def conv2d_size_out(size, kernel_size=5, stride=2):\n                    return (size - (kernel_size - 1) - 1) // stride + 1\n                convw = conv2d_size_out(conv2d_size_out(conv2d_size_out(w)))\n                convh = conv2d_size_out(conv2d_size_out(conv2d_size_out(h)))\n                linear_input_size = convw * convh * 32\n                self.head = nn.Linear(linear_input_size, outputs)\n\n                self.saved_log_probs = []\n                self.rewards = []\n\n            def forward(self, x):\n                x = F.relu(self.bn1(self.conv1(x)))\n                x = F.relu(self.bn2(self.conv2(x)))\n                x = F.relu(self.bn3(self.conv3(x)))\n                return self.head(x.view(x.size(0), -1))\n\n        def get_screen():\n            # Returned screen requested by gym is 400x600x3, but is sometimes larger\n            # such as 800x1200x3. Transpose it into torch order (CHW).\n            screen = env.render(mode=\'rgb_array\').transpose((2, 0, 1))\n            # Cart is in the lower half, so strip off the top and bottom of the screen\n            _, screen_height, screen_width = screen.shape\n            screen = screen[:, int(screen_height*0.4):int(screen_height * 0.8)]\n            view_width = int(screen_width * 0.6)\n            # cart_location = get_cart_location(screen_width)\n            # if cart_location < view_width // 2:\n            #     slice_range = slice(view_width)\n            # elif cart_location > (screen_width - view_width // 2):\n            #     slice_range = slice(-view_width, None)\n            # else:\n            #     slice_range = slice(cart_location - view_width // 2,\n            #                         cart_location + view_width // 2)\n            # Strip off the edges, so that we have a square image centered on a cart\n            # screen = screen[:, :, slice_range]\n            # Convert to float, rescale, convert to torch tensor\n            # (this doesn\'t require a copy)\n            screen = np.ascontiguousarray(screen, dtype=np.float32) / 255\n            screen = torch.from_numpy(screen)\n            # Resize, and add a batch dimension (BCHW)\n            return resize(screen).unsqueeze(0).to(device)\n\n        # MAIN FUNCTIONS\n\n        def play_human_custom(env):\n            """"""\n            re-using default nes-py play human function\n            https://github.com/Kautenja/nes-py/blob/1dda1ad37a84e3ca67dfbebd7cc0c2d8e4cf2489/nes_py/app/play_human.py\n\n            """"""\n            play_human(env)\n\n        def play_random_custom(env, steps):\n            _NOP = 0\n\n            env = JoypadSpace(env, actions)\n\n            env.reset()\n\n            action = 0\n            start = time.time()\n\n            if SHOULD_TRAIN:\n\n                init_screen = get_screen()\n                _, _, screen_height, screen_width = init_screen.shape\n\n                # INIT Neural Network\n                policy = Policy(screen_height, screen_width, len(actions))\n\n                if SHOULD_LOAD_STATE:\n                    print(""Loading model from: "", DATA_PATH)\n                    policy.load_state_dict(torch.load(DATA_PATH))\n\n                optimizer = optim.Adam(policy.parameters(), lr=1e-2)\n                eps = np.finfo(np.float32).eps.item()\n\n                # Helper functions\n                def select_action(state):\n                    global steps_done\n                    sample = random.random()\n                    eps_threshold = reward_threshold\n                    # eps_threshold = EPS_END + (EPS_START - EPS_END) * \\\n                    #     math.exp(-1. * steps_done / EPS_DECAY)\n                    steps_done += 1\n                    if sample > eps_threshold:\n                        with torch.no_grad():\n                            # t.max(1) will return largest column value of each row.\n                            # second column on max result is index of where max element was\n                            # found, so we pick action with the larger expected reward.\n                            return policy(state).max(1)[1].view(1, 1)\n                    else:\n                        return torch.tensor([[random.randrange(len(actions))]], device=device, dtype=torch.long)\n\n                def finish_episode():\n                    R = 0\n                    policy_loss = []\n                    returns = []\n                    for r in policy.rewards[::-1]:\n                        R = r + GAMMA * R\n                        returns.insert(0, R)\n                    returns = torch.tensor(returns)\n                    returns = (returns - returns.mean()) / \\\n                        (returns.std() + eps)\n                    for log_prob, R in zip(policy.saved_log_probs, returns):\n                        policy_loss.append(-log_prob * R)\n                    optimizer.zero_grad()\n                    print(""POLICY LOSS: "", policy_loss)\n                    # policy_loss = torch.cat(policy_loss).sum()\n                    # policy_loss.backward()\n                    optimizer.step()\n                    torch.save(policy.state_dict(), DATA_PATH)\n                    del policy.rewards[:]\n                    del policy.saved_log_probs[:]\n\n                running_reward = 10\n                for i_episode in count(1):\n                    print(""Episode: "", i_episode)\n                    state, ep_reward = env.reset(), 0\n                    # Don\'t infinite loop while learning\n                    for t in range(1, num_steps_per_episode):\n                        action = select_action(state).data.cpu().numpy()[0][0]\n                        # print(""ACTION:"", action)\n                        state, reward, done, info = env.step(action)\n                        if SHOULD_RENDER:\n                            env.render()\n                        policy.rewards.append(reward)\n                        ep_reward += reward\n                        if done:\n                            break\n\n                    running_reward = 0.05 * ep_reward + \\\n                        (1 - 0.05) * running_reward\n                    finish_episode()\n                    if i_episode % log_interval == 0:\n                        print(\'Episode {}\\tLast reward: {:.2f}\\tAverage reward: {:.2f}\'.format(\n                            i_episode, ep_reward, running_reward))\n                    print(""Running reward: "", running_reward)\n                    if running_reward > reward_threshold:\n                        print(""Solved! Running reward is now {} and ""\n                              ""the last episode runs to {} time steps!"".format(running_reward, t))\n                        break\n            else:\n                # PLAY RANDOMLY\n                for t in range(0, steps):\n                    # get the mapping of keyboard keys to actions in the environment\n                    if hasattr(env, \'get_keys_to_action\'):\n                        keys_to_action = env.get_keys_to_action()\n                    elif hasattr(env.unwrapped, \'get_keys_to_action\'):\n                        keys_to_action = env.unwrapped.get_keys_to_action()\n                    else:\n                        raise ValueError(\n                            \'env has no get_keys_to_action method\')\n\n                    # # change action every 6 frames\n                    if t % 6 == 0:\n                        action = env.action_space.sample()\n\n                        # after 500 timesteps, stop pressing start button\n                        if t > 500:\n                            while action == 0:\n                                action = env.action_space.sample()\n\n                    observation, reward, done, info = env.step(action)\n                    print(""---------------------------t: "", t)\n                    print(""action space: "", action, env.action_space)\n                    print(""obs: "", observation.shape)\n                    print(""reward: "", reward)\n                    print(""info: "", info)\n                    # runs game at about 60fps\n                    time.sleep(0.016667)\n                    env.render()\n\n            end = time.time()\n            env.close()\n            print(""time: "", (end - start), "" seconds  for "", steps, ""steps"")\n\n        if args.mode == \'human\':\n            print(""Playing as human"")\n            play_human_custom(env)\n        else:\n            print(""Playing with random custom agent"")\n            play_random_custom(env, args.steps)\n'"
agents/HillClimberAgent.py,7,"b'from envs.rom_wrapper import ROMWrapper\nfrom nes_py.wrappers import JoypadSpace\nfrom nes_py._image_viewer import ImageViewer\nfrom nes_py.app.play_human import play_human\nfrom nes_py.app.cli import _get_args\nimport time\nimport numpy as np\nimport cv2\nimport random\nfrom matplotlib import pyplot as plt\n\n\ndef play_human_custom(env):\n    """"""\n    re-using default nes-py play human function\n    https://github.com/Kautenja/nes-py/blob/1dda1ad37a84e3ca67dfbebd7cc0c2d8e4cf2489/nes_py/app/play_human.py\n\n    """"""\n    play_human(env)\n\n\nclass HillClimberAgent:\n    def __init__(self, args):\n        # required arg\n        rom_path = args.rom\n\n        # create the environment\n        env = ROMWrapper(rom_path)\n\n        self.actions = [\n            [\'start\'],\n            [\'NOOP\'],\n            [\'right\', \'A\'],\n            [\'left\', \'A\'],\n            [\'left\', \'B\'],\n            [\'right\', \'B\'],\n            [\'up\'],\n            [\'down\'],\n            [\'left\'],\n            [\'right\'],\n            [\'A\'],\n            [\'B\']\n        ]\n\n        self.action_to_num = {\n            \'-\'.join(a for a in possible): index\n            for index, possible in enumerate(self.actions)\n        }\n\n        if args.mode == \'human\':\n            print(""Playing as human"")\n            play_human_custom(env)\n        else:\n            print(""Playing with hill climber"")\n            self.play_hill_climber(env, args.steps)\n\n\n    def manual_menu_solve(self, env):\n        print(\'manually solving menu\')\n        env.step(self.action_to_num[\'NOOP\'])\n        env.render()\n        print(\'go\')\n\n        manual_solve = [\'NOOP\',\n                        \'start\',\n                        \'NOOP\',\n                        \'NOOP\',\n                        \'left\',\n                        \'NOOP\',\n                        \'left\',\n                        \'start\',\n                        \'NOOP\',\n                        \'NOOP\']\n        solve_step = 0\n        frames = 500\n        change_every = int(frames / len(manual_solve)) + 1\n        print(\'change_every\', change_every)\n        for t in range(frames):\n            if t % change_every == 0:\n                step = manual_solve[solve_step]\n                act_num = self.action_to_num[step]\n                solve_step += 1\n                # print(\'pressing\', step, act_num)\n            env.step(act_num)\n            env.render()\n        print(\'speeding through wait\')\n        loading_screen_frames = 500\n        for t in range(loading_screen_frames):\n            env.step(self.action_to_num[\'NOOP\'])\n            env.render()\n        print(\'playing game\')\n\n\n    def get_max_shift(self, poi1, poi2):\n        x_range = int(poi1.shape[1] / 10)\n        y_range = int(poi1.shape[0] / 10)\n        outs = []\n        out_coords = []\n        for x in range(-1 * x_range, x_range):\n            for y in range(-1 * y_range, y_range):\n                poi2_tmp = np.roll(poi2, x, axis=1)\n                poi2_tmp = np.roll(poi2_tmp, y, axis=0)\n                count = np.sum(poi1 & poi2_tmp)\n                outs.append(count)\n                out_coords.append((x, y))\n\n        shift_index = outs.index(max(outs))\n        return out_coords[shift_index]\n\n    def combine_images_for_shift(self, img1, img2, x, y, alpha):\n        new_x = img1.shape[1] + abs(x)\n        new_y = img1.shape[0] + abs(y)\n        pad_img_1 = np.zeros((new_y, new_x), dtype=np.float32)\n        pad_img_1[:img1.shape[0], :img1.shape[1]] = img1\n        pad_img_2 = np.zeros((new_y, new_x), dtype=np.float32)\n        pad_img_2[y:y + img2.shape[0], x:x + img2.shape[1]] = img2\n        out_img = cv2.addWeighted(pad_img_1, alpha, pad_img_2, 1 - alpha, 0.0)\n        return out_img\n\n\n    def play_hill_climber(self, env, steps):\n        _NOP = 0\n        steps = 100\n        env = JoypadSpace(env, self.actions)\n\n        change_button_interval = 6 # every 6 steps\n        actions_in_sequence = int(steps / change_button_interval) + 1\n\n        best_action_sequence = [self.sample_no_start(env) for _ in range(actions_in_sequence)]\n        env.reset()\n        best_score = self.evaluate_action_sequence(env, steps, change_button_interval, best_action_sequence)\n        while True:\n            env.reset()\n            new_action_sequence = self.get_modified_actions(env, best_action_sequence, 0.2)\n            new_score = self.evaluate_action_sequence(env, steps, change_button_interval, new_action_sequence)\n            print(\'eval seq:\', new_action_sequence)\n            print(\'got score:\', new_score, \'vs best score:\', best_score)\n            if new_score > best_score:\n                best_score, best_action_sequence = new_score, new_action_sequence\n\n        env.close()\n\n    def get_modified_actions(self, env, best_action_sequence, dropout_probability):\n        modified_actions = []\n        for action in best_action_sequence:\n            if random.random() < dropout_probability:\n                modified_actions.append(action)\n            else:\n                modified_actions.append(self.sample_no_start(env))\n        return modified_actions\n\n    def evaluate_action_sequence(self, env, steps, change_button_interval, action_sequence):\n        self.manual_menu_solve(env)\n\n        action = 0\n        start = time.time()\n        screens = []\n        action_iter = 0\n        score = 0\n\n        # play_human\n        for t in range(steps):\n            if t % change_button_interval == 0:\n                action = action_sequence[action_iter]\n                action_iter += 1\n                # print(\'changed to \', self.actions[action], action)\n\n            observation, reward, done, info = env.step(action)\n            # runs game at about 60fps\n            time.sleep(0.016667)\n            env.render()\n\n            if t % 50 == 0:\n                screen = self.get_simple_screen(env)\n                screens.append(screen)\n            if (t % 500 == 0 and t > 0) or t == steps - 1:\n                def get_poi(img):\n                    img = np.copy(img)\n                    gray = np.float32(img)\n                    dst = cv2.cornerHarris(gray, 2, 3, 0.04)\n                    mask = dst > 0.01 * dst.max()\n                    return mask\n\n                print(\'stitching\')\n                # is grayscale here\n                shifted = screens[0]\n\n                poi1 = get_poi(shifted)\n                for i in range(1, len(screens)):\n                    poi2 = get_poi(screens[i])\n                    x, y = self.get_max_shift(poi1, poi2)\n                    print(\'shift: \', x, y)\n                    try:\n                        shifted = self.combine_images_for_shift(shifted, screens[i], x, y, 0.7)\n                    except Exception:\n                        print(\'exception combining\')\n\n                    # cv2.imshow(\'image_{}\'.format(i), shifted)\n\n                score = shifted.shape[0] * shifted.shape[1]\n                print(\'score\', score)\n\n                # cv2.waitForKey(0)\n                # grayscale: what is wrong?\n        end = time.time()\n        print(""time: "", (end - start), "" seconds  for "", steps, ""steps"")\n        return score\n\n    def sample_no_start(self, env):\n        action = env.action_space.sample()\n        while action == 0:  # no start button\n            action = env.action_space.sample()\n        return action\n\n    def get_simple_screen(self, env, grayscale=True):\n        color_screen = env.render(mode=\'rgb_array\')\n        screen = cv2.cvtColor(color_screen, cv2.COLOR_BGR2GRAY) if grayscale else color_screen\n        # cv2.imshow(\'image\', screen)\n        return screen'"
agents/RandomAgent.py,0,"b'from envs.rom_wrapper import ROMWrapper\nfrom nes_py.wrappers import JoypadSpace\nfrom nes_py._image_viewer import ImageViewer\nfrom nes_py.app.play_human import play_human\nfrom nes_py.app.cli import _get_args\nimport time\n\n\ndef play_human_custom(env):\n    """"""\n    re-using default nes-py play human function\n    https://github.com/Kautenja/nes-py/blob/1dda1ad37a84e3ca67dfbebd7cc0c2d8e4cf2489/nes_py/app/play_human.py\n\n    """"""\n    play_human(env)\n\n\ndef play_random_custom(env, steps):\n    _NOP = 0\n\n    actions = [\n        [\'start\'],\n        [\'NOOP\'],\n        [\'right\', \'A\'],\n        [\'left\', \'A\'],\n        [\'left\', \'B\'],\n        [\'right\', \'B\'],\n        [\'up\'],\n        [\'down\'],\n        [\'A\'],\n        [\'B\']\n    ]\n\n    env = JoypadSpace(env, actions)\n\n    env.reset()\n\n    action = 0\n    start = time.time()\n    # play_human\n    for t in range(0, steps):\n        # get the mapping of keyboard keys to actions in the environment\n        if hasattr(env, \'get_keys_to_action\'):\n            keys_to_action = env.get_keys_to_action()\n        elif hasattr(env.unwrapped, \'get_keys_to_action\'):\n            keys_to_action = env.unwrapped.get_keys_to_action()\n        else:\n            raise ValueError(\'env has no get_keys_to_action method\')\n\n        # # change action every 6 frames\n        if t % 6 == 0:\n            action = env.action_space.sample()\n\n            # after 500 timesteps, stop pressing start button\n            if t > 500:\n                while action == 0:\n                    action = env.action_space.sample()\n\n        observation, reward, done, info = env.step(action)\n        # print(""---------------------------t: "", t)\n        # print(""action space: "", action, env.action_space)\n        # print(""obs: "", observation)\n        # print(""reward: "", reward)\n        # print(""info: "", info)\n        # runs game at about 60fps\n        time.sleep(0.016667)\n        env.render()\n\n    end = time.time()\n    env.close()\n    print(""time: "", (end - start), "" seconds  for "", steps, ""steps"")\n\n\nclass RandomAgent():\n    def __init__(self, args):\n        # required arg\n        rom_path = args.rom\n\n        # create the environment\n        env = ROMWrapper(rom_path)\n\n        if args.mode == \'human\':\n            print(""Playing as human"")\n            play_human_custom(env)\n        else:\n            print(""Playing with random custom agent"")\n            play_random_custom(env, args.steps)\n'"
agents/TestAgent.py,0,"b'import gym\nimport time\n\nROM_PATH = ""../roms/megaman2.nes""\n\n\nclass TestAgent():\n    def __init__(self, args):\n        env = gym.make(""SpaceInvaders-v0"")\n        observation = env.reset()\n        for t in range(1000):\n            env.render()\n            action = env.action_space.sample()  # your agent here (this takes random actions)\n            observation, reward, done, info = env.step(action)\n            print(""---------------------------t: "", t)\n            print(""action space: "", env.action_space)\n            # print(""obs: "", observation)\n            print(""reward: "", reward)\n            print(""info: "", info)\n            # runs game at about 60fps\n            time.sleep(0.016667)\n            if done:\n                observation = env.reset()\n        env.close()\n'"
agents/__init__.py,0,"b""from . import TestAgent\nfrom . import BasicAgent\nfrom . import DQRAgent\nfrom . import RandomAgent\nfrom . import HillClimberAgent\n\n__all__ = [\n    'TestAgent',\n    'BasicAgent',\n    'DQRAgent',\n    'RandomAgent',\n    'HillClimberAgent'\n]\n"""
envs/__init__.py,0,"b""from . import rom_wrapper\n\n__all__ = [\n    'rom_wrapper'\n]\n"""
envs/rom_wrapper.py,4,"b'""""""An OpenAI Gym interface to the NES game MEGAMAN2""""""\nfrom nes_py import NESEnv\nimport numpy as np\n\n""""""\nThis is a generic wrapper based on the example on nes_py wiki\n""""""\n\n\nclass ROMWrapper(NESEnv):\n    """"""An OpenAI Gym interface to the NES game MEGAMAN2""""""\n\n    def __init__(self, rom_path):\n        """"""Initialize a new MEGAMAN2 environment.""""""\n        super(ROMWrapper, self).__init__(rom_path)\n        self.last_screen = None\n        self.screen_distance = 0\n        self.step_num = 0\n        self.score = 0.0\n        # setup any variables to use in the below callbacks here\n\n    def _will_reset(self):\n        """"""Handle any RAM hacking after a reset occurs.""""""\n        # use this method to perform setup before and episode resets.\n        # the method returns None\n        pass\n\n    def _did_reset(self):\n        """"""Handle any RAM hacking after a reset occurs.""""""\n        # use this method to access the RAM of the emulator\n        # and perform setup for each episode.\n        # the method returns None\n        pass\n\n    def _did_step(self, done):\n        """"""\n        Handle any RAM hacking after a step occurs.\n\n        Args:\n            done: whether the done flag is set to true\n\n        Returns:\n            None\n\n        """"""\n\n        # TWO Ways of analyzing state:\n\n        # 1. as RAM: array\n        # print(""RAM: "", self.ram)  # debugging RAM\n        # print(""MEGAMAN SCORE: "", self.ram[114:120])\n        score_vec = self.ram[114:120]\n        self.score = 0.0\n        for i in range(0, len(score_vec)):\n            self.score = self.score + (score_vec[i] * 10**i)\n        # print(""IntScore: "", self.score)\n        # 2. as Screen Image Array\n\n        # https://github.com/Kautenja/nes-py/blob/master/nes_py/nes_env.py#L69\n        # shape of the screen as 32-bit RGB (C++ memory arrangement)\n        ## SCREEN_SHAPE_32_BIT = SCREEN_HEIGHT, SCREEN_WIDTH, 4\n        # print(""Screen: "", self.screen.shape)  # debugging screen\n        if self.step_num > 0:\n            a = np.array(self.screen.flatten())\n            b = self.last_screen\n            self.screen_distance = np.linalg.norm(a - b)\n        self.last_screen = np.array(self.screen.flatten())\n        # print(""Screen Distance: "", self.screen_distance)\n        self.step_num = self.step_num + 1\n        pass\n\n    def _get_reward(self):\n        """"""Return the reward after a step occurs.""""""\n        screen_dist = (self.screen_distance * 0.0000001)\n        score = (self.score * 0.001)\n        return max(screen_dist, score)\n\n    def _get_done(self):\n        """"""Return True if the episode is over, False otherwise.""""""\n        return False\n\n    def _get_info(self):\n        """"""Return the info after a step occurs.""""""\n        return {\n            \'ram\': np.array(self.ram)\n        }\n\n\n# explicitly define the outward facing API for the module\n__all__ = [ROMWrapper.__name__]\n'"
nes_ai/__init__.py,0,"b'class NesAI():\n    def __init__(self):\n        # add more logic here\n        print(""NesAI"")\n\n\n# explicitly define the outward facing API of this package\n__all__ = [NesAI.__name__]\n'"
tools/inestool.py,0,"b'#!/usr/bin/env python\n#\n# Copyright (c) 2015 Dale Sedivec\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the ""Software""), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport argparse\nimport sys\nimport zipfile\nimport logging\nimport os\nimport os.path\nimport binascii\nfrom StringIO import StringIO\nimport collections\nfrom xml.etree import ElementTree\nimport tempfile\nimport shutil\nimport math\nimport zlib\n\ntry:\n    import py7zlib\nexcept ImportError:\n    py7zlib = None\n\n\n# Used in a few places to determine how much we read at a time.\nREAD_SIZE = 65536\n\n\n# Limit for the file size we\'ll read into memory.  Seems like 4 MiB is\n# a good limit for reading ROMs.  I\'m not even exactly sure how we\'d\n# represent 4 MiB with iNES headers (as documented at the below link).\n# Maybe PlayChoice-10?  Of course, even 4 MiB is laughable on any\n# modern system.\n#\n# http://wiki.nesdev.com/w/index.php/Myths#Largest_game\nMAX_MEMORY_FILE_SIZE = 4 * 2**20\n\n\nclass SkipROM(Exception):\n    """"""Indicates that we found a ROM format we can\'t parse.\n\n    For example, NES 2.0 is not implemented as of this writing.\n\n    """"""\n    pass\n\n\nMIN_HEADER_READ_SIZE = 16\n\n\ndef parse_header(header_bytes):\n    assert len(header_bytes) >= MIN_HEADER_READ_SIZE, len(header_bytes)\n    if header_bytes.startswith(""UNIF""):\n        raise SkipROM(""UNIF currently unsupported"")\n    if not header_bytes.startswith(""NES\\x1a""):\n        return None\n    header_ints = [ord(byte) for byte in header_bytes]\n    if header_ints[7] & 0xc == 8:\n        raise SkipROM(""NES 2.0 currently unsupported"")\n    if header_ints[6] & 4:\n        raise SkipROM(\'ROMs with ""trainers"" currently unsupported\')\n    return ROMInfo(\n        prg_rom_size=header_ints[4] * 16384,\n        chr_rom_size=header_ints[5] * 8192,\n        mapper=(header_ints[7] & 0xf0) + ((header_ints[6] & 0xf0) >> 4),\n        mirroring=header_ints[6] & 9,\n        has_trainer=bool(header_ints[6] & 4),\n        has_nvram=bool(header_ints[6] & 2),\n        is_playchoice_10=bool(header_ints[7] & 2),\n        is_vs_unisystem=bool(header_ints[7] & 1),\n        prg_ram_size=header_ints[8] * 8192,\n        tv_system=header_ints[9] & 1)\n\n\nclass FileInfo(object):\n    def __init__(self, name, crc32, rom_info, handler_data=None):\n        self.name = name\n        self.crc32 = crc32\n        self.rom_info = rom_info\n        self.handler_data = handler_data\n\n\nclass IOHandler(object):\n    def __iter__(self):\n        raise NotImplementedError\n\n    def _make_file_info(self, name, file_obj, handler_data=None):\n        header_bytes = file_obj.read(MIN_HEADER_READ_SIZE)\n        try:\n            rom_info = parse_header(header_bytes)\n        except SkipROM, ex:\n            logging.warn(""%s: %s"", name, ex)\n            raise\n        if rom_info:\n            crc32 = 0\n        else:\n            crc32 = binascii.crc32(header_bytes)\n        while True:\n            data = file_obj.read(READ_SIZE)\n            if not data:\n                break\n            crc32 = binascii.crc32(data, crc32)\n        return FileInfo(name, ""%08X"" % (crc32 & 0xffffffff,), rom_info,\n                        handler_data=handler_data)\n\n\nclass WritableIOHandler(IOHandler):\n    def update(self, requests):\n        raise NotImplementedError\n\n    def _update_file(self, path, requests):\n        # Note: There is currently no case I know of where we\'d want\n        # more than one request for a given file.  This design just\n        # leaves the door open for some future functionality.\n        for request in requests:\n            header_bytes = make_ines_header(request.rom_info)\n            if request.type == UpdateRequest.REQ_HEADER_REPLACE:\n                with open(path, ""r+b"") as the_file:\n                    the_file.write(header_bytes)\n            elif request.type == UpdateRequest.REQ_HEADER_INSERT:\n                try:\n                    temp_file = tempfile.NamedTemporaryFile(\n                        dir=os.path.dirname(path), delete=False)\n                    temp_file.write(header_bytes)\n                    with open(path, ""rb"") as orig_file:\n                        shutil.copyfileobj(orig_file, temp_file)\n                    temp_file.close()\n                    os.rename(temp_file.name, path)\n                finally:\n                    if (""temp_file"" in locals() and\n                            os.path.exists(temp_file.name)):\n                        if not temp_file.closed:\n                            temp_file.close()\n                        os.unlink(temp_file.name)\n            else:\n                raise Exception(""unknown request type %r"" % (request.type,))\n\n\nclass UpdateRequest(object):\n    REQ_HEADER_INSERT = 1\n    REQ_HEADER_REPLACE = 2\n\n    def __init__(self, file_info, req_type, rom_info):\n        self.file_info = file_info\n        self.type = req_type\n        self.rom_info = rom_info\n\n\nclass FileIOHandler(WritableIOHandler):\n    def __init__(self, path):\n        self._path = path\n\n    def __iter__(self):\n        with open(self._path, ""rb"") as the_file:\n            try:\n                file_info = self._make_file_info(self._path, the_file)\n            except SkipROM:\n                return\n        yield file_info\n\n    def update(self, requests):\n        for request in requests:\n            if request.file_info.name != self._path:\n                raise Exception(""can only accept requests for %r, not for %r"" %\n                                (self._path, request.file_info.name))\n        self._update_file(self._path, requests)\n\n\nclass ZipIOHandler(WritableIOHandler):\n    def __init__(self, path):\n        self._path = path\n        self._updates = 0\n\n    def __iter__(self):\n        expected_updates = self._updates\n        with zipfile.ZipFile(self._path, ""r"") as zip_file:\n            for name in zip_file.namelist():\n                if self._updates != expected_updates:\n                    raise Exception(\n                        ""iterator invalidated by concurrent modification"")\n                full_name = os.path.join(self._path, name)\n                try:\n                    yield self._make_file_info(full_name, zip_file.open(name),\n                                               name)\n                except (zipfile.BadZipfile, zlib.error) as ex:\n                    logging.warn(""can\'t read %s within %s: %s"", name,\n                                 self._path, ex)\n                except SkipROM, ex:\n                    pass\n\n    def update(self, requests):\n        requests_by_file = collections.defaultdict(list)\n        for request in requests:\n            requests_by_file[request.file_info.handler_data].append(request)\n        try:\n            temp_file = tempfile.NamedTemporaryFile(\n                dir=os.path.dirname(self._path), delete=False)\n            temp_dir = tempfile.mkdtemp()\n            with zipfile.ZipFile(self._path, ""r"") as orig_zip_file, \\\n                 zipfile.ZipFile(temp_file, ""w"") as new_zip_file:\n                for name in orig_zip_file.namelist():\n                    member_path = orig_zip_file.extract(name, temp_dir)\n                    requests = requests_by_file.pop(name, ())\n                    self._update_file(member_path, requests)\n                    new_zip_file.write(member_path, name, zipfile.ZIP_DEFLATED)\n                    os.unlink(member_path)\n            if requests_by_file:\n                print repr(requests)\n                raise Exception(""requests for unknown files: %s"" %\n                                ("", "".join(requests_by_file),))\n            temp_file.close()\n            os.rename(temp_file.name, self._path)\n            self._updates += 1\n        finally:\n            if ""temp_file"" in locals():\n                if os.path.exists(temp_file.name):\n                    if not temp_file.closed:\n                        temp_file.close()\n                    os.remove(temp_file.name)\n                if ""temp_dir"" in locals() and os.path.exists(temp_dir):\n                    shutil.rmtree(temp_dir, True)\n\n\nclass SevenZipIOHandler(IOHandler):\n    def __init__(self, path):\n        self._path = path\n\n    def __iter__(self):\n        with open(self._path, ""rb"") as sz_file:\n            archive = py7zlib.Archive7z(sz_file)\n            for member in archive.files:\n                if member.size > MAX_MEMORY_FILE_SIZE:\n                    logging.warn(""skipping %s in %s: too big (%d bytes)"",\n                                 member.filename, self._path, member.size)\n                    continue\n                contents = StringIO(member.read())\n                full_name = os.path.join(self._path, member.filename)\n                try:\n                    yield self._make_file_info(full_name, contents)\n                except SkipROM:\n                    pass\n\n\nEXTENSION_TO_IO_HANDLER = {\n    "".zip"": ZipIOHandler,\n}\nif py7zlib:\n    EXTENSION_TO_IO_HANDLER["".7z""] = SevenZipIOHandler\n\n\ndef format_kib(value):\n    if value % 1024:\n        kib = ""%f KiB"" % (value / 1024.0,)\n    else:\n        kib = ""%d KiB"" % (value / 1024,)\n    return kib\n\n\ndef format_chr_rom(value):\n    if value == 0:\n        return ""CHR RAM""\n    else:\n        return format_kib(value)\n\n\nclass ROMInfo(object):\n    MIRROR_HORIZONTAL = 0\n    MIRROR_VERTICAL = 1\n    MIRROR_FOUR_SCREEN = 8\n    MIRROR_FOUR_SCREEN_ODD = 9\n    # Signifies mapper-controlled mirroring, where the low bit in the\n    # iNES flags 6 header field is ignored.  We just guess that it\'s\n    # mapper-controlled if the cartridge DB doesn\'t obviously indicate\n    # horizontal or vertical mirroring (nor four screen mirroring).\n    #\n    # This value chosen so that it turns into MIRROR_HORIZONTAL (but\n    # remember: ignored) if/when written to an iNES header.\n    MIRROR_CONTROLLED = 16\n\n    MIRROR_LABELS = {\n        MIRROR_HORIZONTAL: ""Horizontal"",\n        MIRROR_VERTICAL: ""Vertical"",\n        MIRROR_FOUR_SCREEN: ""Four screen"",\n        MIRROR_FOUR_SCREEN_ODD: ""Four screen (odd)"",\n        MIRROR_CONTROLLED: ""Mapper controlled"",\n    }\n\n    TV_NTSC = 0\n    TV_PAL = 1\n    # Sometimes the same ROM is used for both TV systems, as far as I\n    # can tell.\n    #\n    # This value chosen so that it turns into TV_NTSC if/when written\n    # to an iNES header.  See comment in make_ines_header.\n    TV_BOTH = 2\n\n    TV_LABELS = {\n        TV_NTSC: ""NTSC"",\n        TV_PAL: ""PAL"",\n        TV_BOTH: ""NTSC and PAL"",\n    }\n\n    FIELD_LABELS = collections.OrderedDict((\n        (""prg_rom_size"", ""PRG ROM""),\n        (""prg_ram_size"", ""PRG RAM""),\n        (""chr_rom_size"", ""CHR ROM""),\n        (""mapper"", ""Mapper""),\n        (""mirroring"", ""Mirroring""),\n        (""tv_system"", ""TV System""),\n        (""has_nvram"", ""Has NVRAM""),\n        (""has_trainer"", ""Has Trainer""),\n        (""is_playchoice_10"", ""Is PlayChoice-10""),\n        (""is_vs_unisystem"", ""Is VS. UniSystem""),\n    ))\n\n    FIELD_FORMATTERS = {\n        ""prg_rom_size"": format_kib,\n        ""prg_ram_size"": format_kib,\n        ""chr_rom_size"": format_chr_rom,\n        ""mirroring"": MIRROR_LABELS.get,\n        ""tv_system"": TV_LABELS.get,\n    }\n\n    FIELDS = tuple(FIELD_LABELS)\n\n    def __init__(self, prg_rom_size, prg_ram_size, chr_rom_size, mapper,\n                 mirroring, tv_system, has_nvram, has_trainer,\n                 is_playchoice_10, is_vs_unisystem):\n        self.prg_rom_size = prg_rom_size\n        self.prg_ram_size = prg_ram_size\n        self.chr_rom_size = chr_rom_size\n        self.mapper = mapper\n        self.mirroring = mirroring\n        self.tv_system = tv_system\n        self.has_nvram = has_nvram\n        self.has_trainer = has_trainer\n        self.is_playchoice_10 = is_playchoice_10\n        self.is_vs_unisystem = is_vs_unisystem\n\n    def _is_ignored_mirroring_diff(self, mirror_val_a, mirror_val_b):\n        # Mapper-controlled mirroring ignores the low bit, which is\n        # H/V mirroring.  Therefore if one mirroring value is\n        # CONTROLLED, and neither is FOUR_SCREEN, then we can ignore\n        # the difference in mirroring values.\n        return (((mirror_val_a | mirror_val_b) & (self.MIRROR_CONTROLLED |\n                                                  self.MIRROR_FOUR_SCREEN)) ==\n                self.MIRROR_CONTROLLED)\n\n    def diff(self, other):\n        differences = collections.OrderedDict()\n        for attr in self.FIELDS:\n            self_val = getattr(self, attr)\n            other_val = getattr(other, attr)\n            if self_val != other_val and not (\n                (attr == ""mirroring"" and\n                 self._is_ignored_mirroring_diff(self_val, other_val))\n                or\n                (attr == ""tv_system"" and self.TV_BOTH in (self_val, other_val))\n            ):\n                differences[attr] = (self_val, other_val)\n        return differences\n\n\ndef visit_roms(rom_paths, visitor, *args, **kwargs):\n    for rom_path in rom_paths:\n        extension = os.path.splitext(rom_path)[1]\n        io_handler_cls = EXTENSION_TO_IO_HANDLER.get(extension.lower(),\n                                                     FileIOHandler)\n        io_handler = io_handler_cls(rom_path)\n        requests = []\n        for file_info in io_handler:\n            request = visitor(file_info, *args, **kwargs)\n            if request:\n                requests.append(request)\n        if requests:\n            try:\n                update = io_handler.update\n            except AttributeError:\n                logging.warn(""cannot update file of this type: %s"", rom_path)\n            else:\n                update(requests)\n\n\ndef make_ines_header(rom_info):\n    if (rom_info.prg_rom_size & 16383 or\n            rom_info.prg_rom_size > (0xff * 16384) or\n            rom_info.prg_rom_size < 0):\n        raise Exception(""can\'t represent PRG ROM size %d in iNES header"" %\n                        (rom_info.prg_rom_size,))\n    prg_rom = rom_info.prg_rom_size / 16384\n    if (rom_info.chr_rom_size & 8191 or\n            rom_info.chr_rom_size > (0xff * 8192) or\n            rom_info.chr_rom_size < 0):\n        raise Exception(""can\'t represent CHR ROM size %d in iNES header"" %\n                        (rom_info.chr_rom_size,))\n    chr_rom = rom_info.chr_rom_size / 8192\n    if rom_info.mapper < 0 or rom_info.mapper > 255:\n        raise Exception(""can\'t represent mapper %d in iNES header"" %\n                        (rom_info.mapper,))\n    flags_6 = (((rom_info.mapper & 0xf) << 4) |\n               # Mask of 0xF turns MIRROR_CONTROLLED into 0\n               # (technically MIRROR_HORIZONTAL, but hopefully ignored\n               # entirely by the mapper).\n               (rom_info.mirroring & 0xf) |\n               (rom_info.has_trainer << 2) |\n               (rom_info.has_nvram << 1))\n    flags_7 = ((rom_info.mapper & 0xf0) |\n               (rom_info.is_playchoice_10 << 1) |\n               rom_info.is_vs_unisystem)\n    if rom_info.prg_ram_size > (0xff * 8192) or rom_info.prg_ram_size < 0:\n        raise Exception(""can\'t represent PRG RAM size %d in iNES header"" %\n                        (rom_info.prg_ram_size,))\n    # Crisis Force, for example, has a 2 KiB PRG RAM, which can\'t be\n    # represented in iNES\'s increments of 8 KiB.  I\'m going to go\n    # ahead and round up to the nearest 8 KiB, in hopes that\'s better\n    # than just writing e.g. 0 here.\n    prg_ram = int(math.ceil(rom_info.prg_ram_size / 8192.0))\n    # If the same ROM exists for both NTSC and PAL we\'ll just default\n    # to NTSC because because NTSC seems more common (NTSC NES,\n    # Famicom, PlayChoice-10, VS. UniSystem) than PAL.  This mask,\n    # along with the purposely chosen values for these constants,\n    # accomplishes exactly this.\n    flags_9 = rom_info.tv_system & 1\n    return (""NES\\x1a%s%s%s%s%s%s\\0\\0\\0\\0\\0\\0"" %\n            tuple(chr(byte) for byte in (\n                prg_rom,\n                chr_rom,\n                flags_6,\n                flags_7,\n                prg_ram,\n                flags_9,\n            )))\n\n\ndef parse_size(str_value):\n    if not str_value.endswith(""k"") or not str_value[:-1].isdigit():\n        raise Exception(""can\'t parse size %r"" % (str_value,))\n    return int(str_value[:-1]) * 2**10\n\n\ndef etree_find_one(elem, path, optional=False):\n    children = elem.findall(path)\n    if len(children) > 1:\n        raise Exception(""too many %r children of %s"" %\n                        (path, ElementTree.tostring(elem)))\n    elif not optional and len(children) == 0:\n        raise Exception(""no %r children of %s"" %\n                        (path, ElementTree.tostring(elem)))\n    return children[0] if children else None\n\n\nFOUR_SCREEN_BOARDS = frozenset([\n    # Gauntlet\n    ""NES-DRROM"",\n    ""NES-TR1ROM"",\n    ""TENGEN-800004"",\n    # Rad Racer II\n    ""NES-TVROM"",\n    # Napoleon Senki\n    ""IREM-74*161/161/21/138"",\n    # May not exist, but are in Nestopia\'s source\n    ""HVC-DRROM"",\n    ""HVC-TVROM"",\n])\n\n\n# Dendy is close enough to PAL, I think?\nPAL_SYSTEMS = frozenset([""NES-PAL"", ""NES-PAL-A"", ""NES-PAL-B"", ""Dendy""])\n\n\ndef parse_db_entry(elem):\n    crc32 = elem.attrib[""crc""].upper()\n    system = elem.attrib[""system""]\n    tv_system = ROMInfo.TV_PAL if system in PAL_SYSTEMS else ROMInfo.TV_NTSC\n    board = etree_find_one(elem, ""board"")\n    mapper = int(board.attrib.get(""mapper"", 0))\n    prg_rom_size = sum(parse_size(prg.attrib[""size""])\n                       for prg in board.findall(""prg""))\n    prg_ram_size = sum(parse_size(wram.attrib[""size""])\n                       for wram in board.findall(""wram""))\n    chr_rom_size = sum(parse_size(chr.attrib[""size""])\n                       for chr in board.findall(""chr""))\n    has_nvram = board.find("".//*[@battery=\'1\']"") is not None\n    pad = etree_find_one(board, ""pad"", optional=True)\n    if pad is not None:\n        pad_h = int(pad.attrib.get(""h"", ""0""))\n        pad_v = int(pad.attrib.get(""v"", ""0""))\n        if pad_h and pad_v:\n            raise Exception(""both H and V solder pads set on %s"" % (crc32,))\n        if not (pad_h or pad_v):\n            raise Exception(""neither H nor V set on pad element of %s"" %\n                            (crc32,))\n    board_type = board.attrib.get(""type"")\n    if board_type in FOUR_SCREEN_BOARDS:\n        mirroring = ROMInfo.MIRROR_FOUR_SCREEN\n        if pad and (pad_h or pad_v):\n            raise Exception(\n                ""H and/or V pads set on four screen mirroring game %s"" %\n                (crc32,))\n    elif pad is None:\n        # I\'ve decided that no <pad> on a non-four-screen-mirroring\n        # board means that mirroring must be mapper-controlled.\n        mirroring = ROMInfo.MIRROR_CONTROLLED\n    elif pad_h:\n        mirroring = ROMInfo.MIRROR_VERTICAL\n    elif pad_v:\n        mirroring = ROMInfo.MIRROR_HORIZONTAL\n    else:\n        raise Exception(""should never get here"")\n    return crc32, ROMInfo(\n        prg_rom_size,\n        prg_ram_size,\n        chr_rom_size,\n        mapper,\n        mirroring,\n        tv_system,\n        has_nvram,\n        0,\n        system.lower() == ""playchoice-10"",\n        system.lower() == ""vs-unisystem"")\n\n\ndef load_db(path):\n    db = {}\n    xml_iter = iter(ElementTree.iterparse(path or ""NstDatabase.xml"",\n                                          events=(""start"", ""end"")))\n    event, root = next(xml_iter)\n    for event, elem in xml_iter:\n        if event == ""end"" and elem.tag in (""cartridge"", ""arcade""):\n            crc32, rom_info = parse_db_entry(elem)\n            existing_rom_info = db.get(crc32)\n            if existing_rom_info:\n                # XXX BUG: if PRG RAM is not a multiple of 8192 bytes,\n                # we\'ll report a difference against the header which\n                # is irrelevant because it cannot be corrected.  Not\n                # sure how to fix this right now.\n                differences = existing_rom_info.diff(rom_info)\n                # Some ROMs are apparently identical between TV\n                # systems (PAL vs. NTSC).  That\'s what we have\n                # ROMInfo.TV_BOTH for.\n                existing_tv_system = differences.pop(""tv_system"", None)\n                if differences:\n                    logging.warn((""multiple different database entries for""\n                                  "" CRC %s, ignoring differing entries""\n                                  "" after the first""), crc32)\n                # If we already wrote TV_BOTH then that means we\'ve\n                # seen both PAL and NTSC for this ROM, so this third\n                # one must be a duplicate.\n                elif ((existing_tv_system == ROMInfo.TV_BOTH) or\n                      rom_info.tv_system == existing_tv_system):\n                    logging.warn(""duplicate identical entries for CRC %s"",\n                                 crc32)\n                else:\n                    # ""Upgrade"" the existing entry to TV_BOTH, since\n                    # we\'ve now seen both TV types for this ROM.\n                    existing_rom_info.tv_system = ROMInfo.TV_BOTH\n            else:\n                db[crc32] = rom_info\n            # Free memory\n            elem.clear()\n        elif event == ""end"" and elem.tag == ""game"":\n            # Free more memory\n            root.clear()\n    return db\n\n\ndef cmd_read(args):\n    file_info_line = ""{file_info.name} ({file_info.crc32}):""\n    template_lines = [file_info_line]\n    max_label_len = max(len(label)\n                        for label in ROMInfo.FIELD_LABELS.itervalues())\n    for attr, label in ROMInfo.FIELD_LABELS.iteritems():\n        template_lines.append(""\\t%-*s: {formatted_rom_values[%s]}"" %\n                              (max_label_len, label, attr))\n    formatters = tuple((attr, ROMInfo.FIELD_FORMATTERS.get(attr, str))\n                       for attr in ROMInfo.FIELDS)\n    template = ""\\n"".join(template_lines)\n    def print_rom_info(file_info):\n        if file_info.rom_info:\n            formatted_rom_values = {\n                attr: formatter(getattr(file_info.rom_info, attr))\n                for attr, formatter in formatters\n            }\n            print template.format(file_info=file_info,\n                                  formatted_rom_values=formatted_rom_values)\n        else:\n            print file_info_line.format(file_info=file_info), ""no header""\n    visit_roms(args.roms, print_rom_info)\n\n\ndef cmd_write(args):\n    db = load_db(args.db)\n    file_info_line = ""{file_info.name} ({file_info.crc32}): {0}""\n    def update_rom_header(file_info):\n        db_rom_info = db.get(file_info.crc32)\n        if not file_info.rom_info and not db_rom_info:\n            print file_info_line.format(\n                ""no header, not in database, cannot add header"",\n                file_info=file_info)\n            return None\n        elif not db_rom_info:\n            print file_info_line.format(""not in database, skipping"",\n                                        file_info=file_info)\n            return None\n        elif not file_info.rom_info:\n            print file_info_line.format(""no header, will add header"",\n                                        file_info=file_info)\n            if args.dry_run:\n                return None\n            else:\n                return UpdateRequest(file_info,\n                                     UpdateRequest.REQ_HEADER_INSERT,\n                                     db_rom_info)\n        diff = db_rom_info.diff(file_info.rom_info)\n        if not diff:\n            print file_info_line.format(""header matches database"",\n                                        file_info=file_info)\n        else:\n            print file_info_line.format(\n                ""header differs from database, will update header"",\n                file_info=file_info)\n            for attr, (db_val, header_val) in diff.iteritems():\n                formatter = ROMInfo.FIELD_FORMATTERS.get(attr, str)\n                print ""\\t%s: expected %s, read %s"" % (\n                    ROMInfo.FIELD_LABELS[attr],\n                    formatter(db_val), formatter(header_val))\n            if args.dry_run:\n                return None\n            else:\n                return UpdateRequest(file_info,\n                                     UpdateRequest.REQ_HEADER_REPLACE,\n                                     db_rom_info)\n    visit_roms(args.roms, update_rom_header)\n\n\ndef main():\n    logging.basicConfig()\n    parser = argparse.ArgumentParser()\n    roms_help = ""ROM files, or archives containing ROMs""\n    # XXX Currently nothing logs at anything other than warn.  See\n    # commented code below, too.\n    # parser.add_argument(""--verbose"", ""-v"", default=False, action=""store_true"")\n    subparsers = parser.add_subparsers()\n    read_parser = subparsers.add_parser(""read"", help=""read iNES headers"")\n    read_parser.set_defaults(handler=cmd_read)\n    read_parser.add_argument(""roms"", nargs=""+"", metavar=""rom"", help=roms_help)\n    write_parser = subparsers.add_parser(\n        ""write"", help=""add/correct iNES headers from database"")\n    write_parser.set_defaults(handler=cmd_write)\n    write_parser.add_argument(\n        ""--db"", ""-d"", default=""NstDatabase.xml"",\n        help=(""path to NES database (download ""\n              "" https://raw.githubusercontent.com/rdanbrook/nestopia/master/""\n              ""NstDatabase.xml""\n              "" or from http://bootgod.dyndns.org:7777/xml.php""))\n    write_parser.add_argument(\n        ""--dry-run"", ""-n"", default=False,\n        action=""store_true"",\n        help=""don\'t actually change ROMs, just report changes"")\n    write_parser.add_argument(""roms"", nargs=""+"", metavar=""rom"", help=roms_help)\n    args = parser.parse_args()\n    # if args.verbose:\n    #     logging.getLogger().setLevel(logging.INFO)\n    return args.handler(args)\n\n\nif __name__ == ""__main__"":\n    sys.exit(main() or 0)\n'"
