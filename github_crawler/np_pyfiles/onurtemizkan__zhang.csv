file_path,api_count,code
__init__.py,0,b''
main.py,0,"b'from steps.parser import parse_data\nfrom steps.dlt import compute_homography\nfrom steps.intrinsics import get_camera_intrinsics\nfrom steps.extrinsics import get_camera_extrinsics\nfrom steps.distortion import estimate_lens_distortion\nfrom utils.timer import timer\n\n\ndef calibrate():\n    data = parse_data()\n\n    end = timer()\n    homographies = compute_homography(data)\n    end(""Homography Estimation"")\n    print(""homographies"")\n    print(homographies)\n\n    end = timer()\n    intrinsics = get_camera_intrinsics(homographies)\n    end(""Intrinsics"")\n\n    print(""intrinsics"")\n    print(intrinsics)\n\n    end = timer()\n    extrinsics = get_camera_extrinsics(intrinsics, homographies)\n    end(""Extrinsics"")\n\n    print(""extrinsics"")\n    print(extrinsics)\n\n    end = timer()\n    distortion = estimate_lens_distortion(\n        intrinsics,\n        extrinsics,\n        data[""real""],\n        data[""sensed""]\n    )\n    end(""Distortion"")\n\n    return\n\ncalibrate()\n'"
data/__init__.py,0,b''
steps/__init__.py,0,b''
steps/distortion.py,9,"b'import numpy as np\n\n\ndef estimate_lens_distortion(intrinsics, extrinsics, model, sensor):\n\n    uc = intrinsics[0, 2]\n    vc = intrinsics[1, 2]\n\n    D = []\n    d = []\n\n    l = 0\n\n    for i in range(0, len(extrinsics)):\n        for j in range(0, model.size/2):\n\n            homog_model_coords = np.array([model[j][0], model[j][1], 0, 1])\n            homog_coords = np.dot(extrinsics[i], homog_model_coords)\n\n            coords = homog_coords / homog_coords[-1]\n            [x, y, hom] = coords\n\n            r = np.sqrt(x*x + y*y)\n\n            P = np.dot(intrinsics, homog_coords)\n            P = P / P[2]\n\n            [u, v, trash] = P\n\n            du = u - uc\n            dv = v - vc\n\n            D.append(\n                np.array([\n                    du * r**2, du * r**4\n                ])\n            )\n\n            D.append(\n                np.array([\n                    dv * r**2, dv * r**4\n                ])\n            )\n\n            up = sensor[i][j][0]\n            vp = sensor[i][j][1]\n\n            d.append(up - u)\n            d.append(vp - v)\n\n    k = np.linalg.lstsq(\n        np.array(D),\n        np.array(d)\n    )\n\n    return k\n'"
steps/dlt.py,21,"b'import numpy as np\nfrom scipy import optimize as opt\nfrom utils.timer import timer\n\n\ndef get_normalisation_matrix(flattened_corners):\n    end = timer()\n\n    avg_x = flattened_corners[:, 0].mean()\n    avg_y = flattened_corners[:, 1].mean()\n\n    s_x = np.sqrt(2 / flattened_corners[0].std())\n    s_y = np.sqrt(2 / flattened_corners[1].std())\n\n    end(""get_normalization_matrix"")\n    return np.matrix([\n        [s_x,   0,   -s_x * avg_x],\n        [0,   s_y,   -s_y * avg_y],\n        [0,     0,              1]\n    ])\n\n\ndef estimate_homography(first, second):\n    end = timer()\n\n    first_normalisation_matrix = get_normalisation_matrix(first)\n    second_normalisation_matrix = get_normalisation_matrix(second)\n\n    M = []\n\n    for j in range(0, first.size / 2):\n        homogeneous_first = np.array([\n            first[j][0],\n            first[j][1],\n            1\n        ])\n\n        homogeneous_second = np.array([\n            second[j][0],\n            second[j][1],\n            1\n        ])\n\n        pr_1 = np.dot(first_normalisation_matrix, homogeneous_first)\n\n        pr_2 = np.dot(second_normalisation_matrix, homogeneous_second)\n\n        M.append(np.array([\n            pr_1.item(0), pr_1.item(1), 1,\n            0, 0, 0,\n            -pr_1.item(0)*pr_2.item(0), -pr_1.item(1)*pr_2.item(0), -pr_2.item(0)\n        ]))\n\n        M.append(np.array([\n            0, 0, 0, pr_1.item(0), pr_1.item(1),\n            1, -pr_1.item(0)*pr_2.item(1), -pr_1.item(1)*pr_2.item(1), -pr_2.item(1)\n        ]))\n\n    U, S, Vh = np.linalg.svd(np.array(M).reshape((512, 9)))\n\n    L = Vh[-1]\n\n    H = L.reshape(3, 3)\n\n    denormalised = np.dot(\n        np.dot(\n            np.linalg.inv(first_normalisation_matrix),\n            H\n        ),\n        second_normalisation_matrix\n    )\n\n    end(""estimate_homography"")\n    return denormalised / denormalised[-1, -1]\n\n\ndef cost(homography, data):\n    [sensed, real] = data\n\n    Y = []\n\n    for i in range(0, sensed.size / 2):\n        x = sensed[i][0]\n        y = sensed[i][1]\n\n        w = homography[6] * x + homography[7] * y + homography[8]\n\n        M = np.array([\n            [homography[0], homography[1], homography[2]],\n            [homography[3], homography[4], homography[5]]\n        ])\n\n        homog = np.transpose(np.array([x, y, 1]))\n        [u, v] = (1/w) * np.dot(M, homog)\n\n        Y.append(u)\n        Y.append(v)\n\n    return np.array(Y)\n\n\ndef jac(homography, data):\n    [sensed, real] = data\n\n    J = []\n\n    for i in range(0, sensed.size / 2):\n        x = sensed[i][0]\n        y = sensed[i][1]\n\n        s_x = homography[0] * x + homography[1] * y + homography[2]\n        s_y = homography[3] * x + homography[4] * y + homography[5]\n        w = homography[6] * x + homography[7] * y + homography[8]\n\n        J.append(\n            np.array([\n                x / w, y / w, 1/w,\n                0, 0, 0,\n                (-s_x * x) / (w*w), (-s_x * y) / (w*w), -s_x / (w*w)\n            ])\n        )\n\n        J.append(\n            np.array([\n                0, 0, 0,\n                x / w, y / w, 1 / w,\n                (-s_y * x) / (w*w), (-s_y * y) / (w*w), -s_y / (w*w)\n            ])\n        )\n\n    return np.array(J)\n\n\ndef refine_homography(homography, sensed, real):\n    return opt.root(\n        cost,\n        homography,\n        jac=jac,\n        args=[sensed, real],\n        method=\'lm\'\n    ).x\n\n\ndef compute_homography(data):\n    end = timer()\n\n    real = data[\'real\']\n\n    refined_homographies = []\n\n    for i in range(0, len(data[\'sensed\'])):\n        sensed = data[\'sensed\'][i]\n        estimated = estimate_homography(real, sensed)\n        end = timer()\n        refined = refine_homography(estimated, sensed, real)\n        refined = refined / refined[-1]\n        end(""refine_homography"")\n        refined_homographies.append(estimated)\n\n    end(""compute_homography"")\n    return np.array(refined_homographies)\n'"
steps/extrinsics.py,8,"b'import numpy as np\n\n\ndef estimate_view_transform(intrinsics, homography):\n\n    homography = homography.reshape(3, 3)\n    inv_intrinsics = np.linalg.inv(intrinsics)\n\n    h1 = homography[:, 0]\n    h2 = homography[:, 1]\n    h3 = homography[:, 2]\n\n    ld1 = 1 / np.linalg.norm(np.dot(inv_intrinsics, h1))\n    ld2 = 1 / np.linalg.norm(np.dot(inv_intrinsics, h2))\n    ld3 = (ld1 + ld2) / 2\n\n    r0 = ld1 * np.dot(inv_intrinsics, h1)\n    r1 = ld2 * np.dot(inv_intrinsics, h2)\n    r2 = np.cross(r0, r1)\n\n    t = np.array(ld3 * np.dot(inv_intrinsics, h3)).transpose()\n\n    Rt = np.array(\n            [r0.transpose(), r1.transpose(), r2.transpose(), t.transpose()]\n         ).transpose()\n\n    # todo: Add optimization?\n    return Rt\n\n\ndef get_camera_extrinsics(intrinsics, homographies):\n\n    extrinsics = []\n    for i in range(0, len(homographies)):\n        extrinsics.append(estimate_view_transform(intrinsics, homographies[i]))\n\n    return extrinsics\n'"
steps/intrinsics.py,9,"b'import numpy as np\nfrom utils.timer import timer\n\n\n\ndef v(p, q, H):\n\n    return np.array([\n        H[0, p] * H[0, q],\n        H[0, p] * H[1, q] + H[1, p] * H[0, q],\n        H[1, p] * H[1, q],\n        H[2, p] * H[0, q] + H[0, p] * H[2, q],\n        H[2, p] * H[1, q] + H[1, p] * H[2, q],\n        H[2, p] * H[2, q]\n    ])\n\n\ndef get_camera_intrinsics(homographies):\n\n    h_count = len(homographies)\n\n    vec = []\n\n    for i in range(0, h_count):\n        curr = np.reshape(homographies[i], (3, 3))\n\n        vec.append(v(0, 1, curr))\n        vec.append(v(0, 0, curr) - v(1, 1, curr))\n\n    vec = np.array(vec)\n\n    b = np.linalg.lstsq(\n        vec,\n        np.zeros(h_count * 2),\n    )[-1]\n\n    w = b[0] * b[2] * b[5] - b[1]**2 * b[5] - b[0] * b[4]**2 + 2 * b[1] * b[3] * b[4] - b[2] * b[3]**2\n    d = b[0] * b[2] - b[1]**2\n\n    # if (d < 0):\n    #     d = 0.01\n    d = -d\n\n    #\n    alpha = np.sqrt(w / (d * b[0]))\n    beta = np.sqrt(w / d**2 * b[0])\n    gamma = np.sqrt(w / (d**2 * b[0])) * b[1]\n    uc = (b[1] * b[4] - b[2] * b[3]) / d\n    vc = (b[1] * b[3] - b[0] * b[4]) / d\n\n    return np.array([\n        [alpha, gamma, uc],\n        [0,     beta,  vc],\n        [0,     0,      1]\n    ])\n'"
steps/parser.py,2,"b'import numpy as np\n\n\ndef parse_data(basepath=""data/corners_"", ext="".dat""):\n\n    sensed = []\n    for i in range(1, 6):\n        sensed.append(np.loadtxt(basepath + str(i) + ext).reshape((256, 2)))\n\n    return {\n        \'real\': np.loadtxt(basepath + ""real"" + ext).reshape((256, 2)),\n        \'sensed\': sensed\n    }\n'"
utils/__init__.py,0,b''
utils/timer.py,0,"b'import time\nimport inspect\n\n\ndef timer():\n    start = time.time()\n\n    def end(method_name=""Unnamed function""):\n\n        print(method_name + "" took : "" + str(time.time() - start) + "" seconds."")\n        return\n\n    return end\n'"
