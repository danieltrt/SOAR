file_path,api_count,code
Ford_GoBike-Analysis/datacheck.py,5,"b'# Bay Area Bike Share Data Check Script\n\n# Imports\nimport numpy as np\nimport pandas as pd\nfrom babs_visualizations import usage_stats\n\ndef question_3(data):\n    # This function will check that the sample data has been wrangled properly.\n    n_correct = 0\n\n    # Check that there are a correct number of lines in the dataset.\n    if data.shape[0] != 27345:\n        print(""Expected 27,345 data points, found only {:d}."".format(data.shape[0]))\n    else:\n        n_correct += 1\n\n    # Check that the durations have been converted into terms of minutes.\n    data_duration_stats = usage_stats(data, verbose = False)\n    expected_duration_stats = np.array([6.816667, 10.716667, 17.28333])\n    if not np.allclose(data_duration_stats, expected_duration_stats):\n        print(""Duration statistics do not match expected units (minutes)."")\n        if np.allclose(data_duration_stats, np.array([409, 643, 1037])):\n            print(""  It looks like the units are still in terms of seconds."")\n        elif np.allclose(data_duration_stats, np.array([24520, 38580, 62220])):\n            print(""  It looks like you might have used the wrong operator in your conversion."")\n        print(""  Remember that there are 60 seconds in each minute."")\n    else:\n        n_correct += 1\n\n    # Check that the timestamps have been wrangled properly.\n    expected_time_vals = {\'start_month\': [25243, 2102],\n                          \'start_hour\': [2851, 2291, 2219, 2171, 2131, 1976,\n                                      1833, 1799, 1791, 1644, 1359, 1269,\n                                      1071,  797,  644,  440,  394,  276,\n                                       153,   65,   55,   45,   42,   29],\n                          \'weekday\': [4712, 4493, 4370, 3860, 3637, 3138, 3135]}\n\n    for column in expected_time_vals.keys():\n        col_data = data[column].value_counts().values\n        n_values = len(col_data)\n        n_values_expected = len(expected_time_vals[column])\n        if not n_values == n_values_expected:\n            print(""Wrong number of unique values found for column: {}"".format(column))\n            print(""  {:d} unique values expected; {:d} values found."".format(n_values_expected, n_values))\n        elif not np.array_equal(col_data, expected_time_vals[column]):\n            expected_max = expected_time_vals[column][0]\n            expected_min = expected_time_vals[column][-1]\n            print(""Unexpected count of values for column: {}"".format(column))\n            print(""  Most common value expected {:d} data points; {:d} trips found."".format(expected_max, col_data[0]))\n            print(""  Least common value expected {:d} data points; {:d} trips found."".format(expected_min, col_data[-1]))\n        else:\n            n_correct += 1\n\n    if n_correct == len(expected_time_vals.keys()) + 2:\n        print(""All counts are as expected!"")\n'"
Ford_GoBike-Analysis/visualizations.py,2,"b'# Bay Area Bike Share Visualization Script\n\n# Imports\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Functions\ndef filter_data(data, condition):\n    """"""\n    Remove elements that do not match the condition provided.\n    Takes a data list as input and returns a filtered list.\n    Conditions should be a list of strings of the following format:\n      \'<field> <op> <value>\'\n    where the following operations are valid: >, <, >=, <=, ==, !=\n    \n    Example: [""duration < 15"", ""start_city == \'San Francisco\'""]\n    """"""\n\n    # Only want to split on first two spaces separating field from operator and operator from value,\n    # spaces within value should be retained.\n    field, op, value = condition.split("" "", 2)\n    \n    # Check if field is valid\n    if field not in data.columns.values :\n        raise Exception(""\'{}\' is not a feature of the dataframe. Did you spell something wrong?"".format(field))\n\n    # Convert value into number or strip excess quotes if string\n    try:\n        value = float(value)\n    except:\n        value = value.strip(""\\\'\\"""")\n\n    # Get booleans for filtering\n    if op == "">"":\n        matches = data[field] > value\n    elif op == ""<"":\n        matches = data[field] < value\n    elif op == "">="":\n        matches = data[field] >= value\n    elif op == ""<="":\n        matches = data[field] <= value\n    elif op == ""=="":\n        matches = data[field] == value\n    elif op == ""!="":\n        matches = data[field] != value\n    else: # Catch invalid operation codes\n        raise Exception(""Invalid comparison operator. Only >, <, >=, <=, ==, != allowed."")\n    \n    # Filter data and outcomes\n    data = data[matches].reset_index(drop = True)\n    return data\n\ndef usage_stats(data, filters = [], verbose = True):\n    # Report number of trips and average trip duration for data points that meet specified filtering criteria.\n    n_data_all = data.shape[0]\n\n    # Apply filters to data\n    for condition in filters:\n        data = filter_data(data, condition)\n\n    # Compute number of data points that met the filter criteria.\n    n_data = data.shape[0]\n\n    # Compute statistics for trip durations.\n    duration_mean = data[\'duration\'].mean()\n    duration_qtiles = data[\'duration\'].quantile([.25, .5, .75]).as_matrix()\n    \n    # Report computed statistics if verbosity is set to True (default).\n    if verbose:\n        if filters:\n            print(\'There are {:d} data points ({:.2f}%) matching the filter criteria.\'.format(n_data, 100. * n_data / n_data_all))\n        else:\n            print(\'There are {:d} data points in the dataset.\'.format(n_data))\n\n        print(\'The average duration of trips is {:.2f} minutes.\'.format(duration_mean))\n        print(\'The median trip duration is {:.2f} minutes.\'.format(duration_qtiles[1]))\n        print(\'25% of trips are shorter than {:.2f} minutes.\'.format(duration_qtiles[0]))\n        print(\'25% of trips are longer than {:.2f} minutes.\'.format(duration_qtiles[2]))\n\n    # Return three-number summary\n    return duration_qtiles\n\n\ndef usage_plot(data, key = \'\', filters = [], **kwargs):\n    """"""\n    Plot number of trips, given a feature of interest and any number of filters\n    (including no filters). Function takes a number of optional arguments for\n    plotting data on continuously-valued variables:\n      - n_bins: number of bars (default = 10)\n      - bin_width: width of each bar (default divides the range of the data by\n        number of bins). ""n_bins"" and ""bin_width"" cannot be used simultaneously.\n      - boundary: specifies where one of the bar edges will be placed; other\n        bar edges will be placed around that value (may result in an additional\n        bar being plotted). Can be used with ""n_bins"" and ""bin_width"".\n    """"""\n    \n    # Check that the key exists\n    if not key:\n        raise Exception(""No key has been provided. Make sure you provide a variable on which to plot the data."")\n    if key not in data.columns.values :\n        raise Exception(""\'{}\' is not a feature of the dataframe. Did you spell something wrong?"".format(key))\n\n    # Apply filters to data\n    for condition in filters:\n        data = filter_data(data, condition)\n\n    # Create plotting figure\n    plt.figure(figsize=(8,6))\n\n    if isinstance(data[key][0] , str): # Categorical features\n        # For strings, collect unique strings and then count number of\n        # outcomes for survival and non-survival.\n        \n        # Summarize dataframe to get counts in each group\n        data[\'count\'] = 1\n        data = data.groupby(key, as_index = False).count()\n        \n        levels = data[key].unique()\n        n_levels = len(levels)\n        bar_width = 0.8\n        \n        for i in range(n_levels):\n            trips_bar = plt.bar(i - bar_width/2, data.loc[i][\'count\'], width = bar_width)\n        \n        # add labels to ticks for each group of bars.\n        plt.xticks(range(n_levels), levels)\n        \n    else: # Numeric features\n        # For numbers, divide the range of data into bins and count\n        # number of outcomes for survival and non-survival in each bin.\n        \n        # Set up bin boundaries for plotting\n        if kwargs and \'n_bins\' in kwargs and \'bin_width\' in kwargs:\n            raise Exception(""Arguments \'n_bins\' and \'bin_width\' cannot be used simultaneously."")\n\n        min_value = data[key].min()\n        max_value = data[key].max()\n        value_range = max_value - min_value\n        n_bins = 10\n        bin_width = float(value_range) / n_bins\n\n        if kwargs and \'n_bins\' in kwargs:\n            n_bins = int(kwargs[\'n_bins\'])\n            bin_width = float(value_range) / n_bins\n        elif kwargs and \'bin_width\' in kwargs:\n            bin_width = kwargs[\'bin_width\']\n            n_bins = int(np.ceil(float(value_range) / bin_width))\n        \n        if kwargs and \'boundary\' in kwargs:\n            bound_factor = np.floor(( min_value - kwargs[\'boundary\'] ) / bin_width)\n            min_value = kwargs[\'boundary\'] + bound_factor * bin_width\n            if min_value + n_bins * bin_width <= max_value:\n                n_bins += 1\n\n        bins = [i*bin_width + min_value for i in range(n_bins+1)]\n        \n        # plot the data\n        plt.hist(data[key], bins = bins)\n\n    # Common attributes for plot formatting\n    key_name = \' \'.join([x.capitalize() for x in key.split(\'_\')])\n    plt.xlabel(key_name)\n    plt.ylabel(""Number of Trips"")\n    plt.title(""Number of Trips by {:s}"".format(key_name))\n    plt.show()\n'"
Numpy-Playground/numpy_playground.py,13,"b'\'\'\'\nThe following code is to play with the Numpy library\n\nNumpy is a library that provides functions that are especially useful \nwhen you have to work with large arrays and matrices of numeric data, \nlike doing matrix matrix multiplications. \n\nAlso, Numpy is battle tested and optimized so that it runs fast,\nmuch faster than if you were working with Python lists directly.\n\'\'\'\n\n## Imports\nimport numpy as np\n\n## Playground\n\n### Arrays\n\'\'\'\nThe array object class is the foundation of Numpy\n\nNumpy arrays are like lists in Python,\nexcept that every thing inside an array must be of the same type,\nlike int, str, or float.\n\'\'\'\n#### Change False to True to see Numpy Arrays in action\nif True:\n    array = np.array([1, 4, 5, 8], float)\n    print(""Numpy Arrays"")\n    print(array)\n    print ("""")\n    array = np.array([[1, 2, 3], [4, 5, 6]], float)  # a 2D array/Matrix\n    print (array)\n\n\'\'\'\nYou can index, slice, and manipulate a Numpy array \nmuch like you would with a Python list.\n\'\'\'\n#### Change False to True to see array indexing and slicing in action\nif True:\n    array = np.array([1, 4, 5, 8], float)\n    print("""")\n    print(""Numpy Arrays Slices & Indexes"")\n    print(array)\n    print("""")\n    print(array[1])\n    print("""")\n    print(array[:2])\n    print("""")\n    array[1] = 5.0\n    print(array[1])\n\n#### Change False to True to see Matrix indexing and slicing in action\nif True:\n    two_D_array = np.array([[1, 2, 3], [4, 5, 6]], float)\n    print("""")\n    print(""Numpy Arrays Indexing and Slicing"")\n    print(two_D_array)\n    print("""")\n    print(two_D_array[1][1])\n    print("""")\n    print(two_D_array[1, :])\n    print("""")\n    print(two_D_array[:, 2])\n\n\n### Arithmetic Operations\n\'\'\'\nHere are some arithmetic operations that you can do with Numpy arrays\n\'\'\'\n#### Change False to True to see Array arithmetics in action\nif True:\n    array_1 = np.array([1, 2, 3], float)\n    array_2 = np.array([5, 2, 6], float)\n    print("""")\n    print(""Numpy Arrays Arithmetic Operations"")\n    print(array_1 + array_2)\n    print("""")\n    print(array_1 - array_2)\n    print("""")\n    print(array_1 * array_2)\n\n#### Change False to True to see Matrix arithmetics in action\nif True:\n    array_1 = np.array([[1, 2], [3, 4]], float)\n    array_2 = np.array([[5, 6], [7, 8]], float)\n    print("""")\n    print(""Numpy Array Matrix Arithmetic"")\n    print(array_1 + array_2)\n    print("""")\n    print(array_1 - array_2)\n    print("""")\n    print(array_1 * array_2)\n\n\n### Mathematical Operations\n\'\'\'\nIn addition to the standard arthimetic operations,\nNumpy also has a range of other mathematical operations \nthat you can apply to Numpy arrays, \nsuch as mean and dot product.\n\'\'\'\n#### Change False to True to see Mathematical Operations in action\nif True:\n    array_1 = np.array([1, 2, 3], float)\n    array_2 = np.array([[6], [7], [8]], float)\n    print("""")\n    print(""Mathematical Operations"")\n    print(np.mean(array_1))\n    print(np.mean(array_2))\n    print("""")\n    print(np.dot(array_1, array_2))\n'"
