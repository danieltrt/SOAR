file_path,api_count,code
setup.py,0,"b'# To use a consistent encoding\nfrom codecs import open\nfrom os import path\nfrom setuptools import setup, find_packages\nimport sys\n\nif sys.version_info[0] > 2:\n    sys.exit(""Incompatible with Python 3. IronPython 2.7 from Rhino can only be ""\n             ""connected to a Python 2 instance."")\n\nhere = path.abspath(path.dirname(__file__))\n\n# Default version\n__version__ = \'0.1.0\'\n# Get __version__, __version_info__\nexecfile(path.join(here, \'ghpythonremote\', \'version.py\'))\n\n# Get the long description from the README file\nwith open(path.join(here, \'README.rst\'), encoding=\'utf-8\') as f:\n    long_description = f.read()\n# Append the CHANGELOG to it\nwith open(path.join(here, \'CHANGELOG.rst\'), encoding=\'utf-8\') as f:\n    long_description += \'\\n\\n====\\n\\n\' + f.read()\n\nsetup(\n    name=\'gh-python-remote\',\n    description=(\'GH Python Remote is a package to get Rhinoceros3D/Grasshopper and \'\n                 + \'Python to collaborate better: connect an external python instance\'\n                 + \' to Grasshopper, and vice-versa.\'),\n    long_description=long_description,\n    long_description_content_type=\'text/x-rst\',\n    version=__version__,\n\n    author=\'Pierre Cuvilliers\',\n    author_email=\'pcuvil@mit.edu\',\n    url=\'https://github.com/Digital-Structures/ghpythonremote\',\n\n    license=\'MIT\',\n\n    classifiers=[\n        \'Development Status :: 5 - Production/Stable\',\n\n        \'Intended Audience :: Developers\',\n        \'Intended Audience :: End Users/Desktop\',\n        \'Topic :: Software Development :: Interpreters\',\n        \'Topic :: Scientific/Engineering\',\n\n        \'License :: OSI Approved :: MIT License\',\n\n        \'Programming Language :: Python :: 2 :: Only\',\n        \'Programming Language :: Python :: 2.7\',\n        \'Programming Language :: Python :: Implementation :: CPython\',\n        \'Programming Language :: Python :: Implementation :: IronPython\',\n    ],\n    keywords=\'CAD design engineering scientific numpy scipy IronPython Rhinoceros3D\',\n\n    python_requires=\'>=2.6,<3\',\n    platforms=[""Windows"", ],\n    zip_safe=False,\n\n    use_2to3=False,\n\n    packages=find_packages(),\n    package_data={\n        \'ghpythonremote\': [\n            \'examples/curves.3dm\',\n            \'examples/GH_python_remote.ghx\',\n            \'examples/GH_python_remote_plt_example.ghx\',\n            \'examples/CPython_to_GH.py\',\n            \'ghcluster/GHPythonRemote.ghuser\',\n        ],\n    },\n    data_files=[\n    ],\n    install_requires=[\n        \'rpyc==4.1.4\'\n    ],\n    extras_require={\n        \'dev\': [\'check-manifest\'],\n        \'test\': [\'coverage\'],\n    },\n)\n'"
ghpythonremote/__init__.py,0,"b'from ghpythonremote.version import __version__\nimport monkey\nfrom monkey import rpyc\nfrom rpyc.utils.classic import deliver, obtain\n'"
ghpythonremote/_configure_ironpython_installation.py,0,"b'import logging\nimport os\nfrom shutil import copy, rmtree\nimport subprocess\nimport sys\n\nfrom .helpers import get_rhino_ironpython_path\n\nlogging.basicConfig(format=""%(levelname)s:%(message)s"", level=logging.INFO)\n\nif __name__ == ""__main__"":\n    location = None\n    if len(sys.argv) > 1:\n        location = sys.argv[1]\n        try:\n            location = int(location)\n        except ValueError:\n            pass\n\n    rhino_ironpython_path = get_rhino_ironpython_path(location=location)\n\n    # Install the package to Rhino IronPython Users lib\n    package_name = ""gh-python-remote""\n    pip_cmd = [\n        sys.executable,\n        ""-m"",\n        ""pip"",\n        ""install"",\n        ""--upgrade"",\n        ""--target="" + rhino_ironpython_path,\n        ""--no-compile"",\n        ""--ignore-requires-python"",\n        package_name,\n    ]\n    print(\n        ""The gh-python-remote package will be installed in Rhino IronPython with the ""\n        ""command:""\n    )\n    print("" "".join(pip_cmd))\n    subprocess.check_call(pip_cmd)\n\n    # Get the Grasshopper libraries base dir\n    gh_userobjects_path = os.path.join(\n        os.getenv(""APPDATA"", """"), ""Grasshopper"", ""UserObjects""\n    )\n    if os.path.isdir(gh_userobjects_path):\n        dest_dir_path = os.path.join(gh_userobjects_path, package_name)\n    else:\n        logging.warning(\n            \'Could not find Grasshopper ""UserObjects"" special folder; \'\n            + ""example files will be installed to default temp dir.""\n        )\n        dest_dir_path = os.path.join(os.getenv(""TEMP"", ""C:\\\\""), package_name)\n    # Get the filepath in the installed package\n    source_dir_path = os.path.dirname(os.path.realpath(__file__))\n    # Send the files there\n    if os.path.isdir(dest_dir_path):\n        rmtree(dest_dir_path)\n    os.mkdir(dest_dir_path)\n    copy_pairs = [\n        (\n            ""examples"",\n            [\n                ""examples/curves.3dm"",\n                ""examples/GH_python_remote.ghx"",\n                ""examples/GH_python_remote_plt_example.ghx"",\n                ""examples/CPython_to_GH.py"",\n            ],\n        ),\n        ("""", [""ghcluster/GHPythonRemote.ghuser""]),\n    ]\n    for copy_pair in copy_pairs:\n        dest = os.path.join(dest_dir_path, copy_pair[0])\n        if not os.path.isdir(dest):\n            os.mkdir(dest)\n        for file_rel_path in copy_pair[1]:\n            source = os.path.join(source_dir_path, *file_rel_path.split(""/""))\n            copy(source, dest)\n    logging.info(""Copied example files to {!s}"".format(dest_dir_path))\n'"
ghpythonremote/connectors.py,0,"b'import errno\nimport logging\nimport os\nimport platform\nimport socket\nimport subprocess\nfrom time import sleep\n\ntry:\n    import _winreg as winreg\nexcept ImportError:\n    import winreg\n\nfrom ghpythonremote import rpyc\nfrom .helpers import get_python_path, get_extended_env_path_conda\n\nlogger = logging.getLogger(""ghpythonremote.connectors"")\n\n\nclass GrasshopperToPythonRemote:\n    def __init__(\n        self,\n        rpyc_server_py,\n        python_exe=None,\n        location=None,\n        timeout=60,\n        max_retry=3,\n        port=None,\n        log_level=logging.WARNING,\n        working_dir=None,\n    ):\n        if python_exe is None:\n            self.python_exe = get_python_path(location)\n        else:\n            if location is not None:\n                logger.debug(\n                    ""python_exe and env_name specified at the same time, ignoring ""\n                    ""env_name.""\n                )\n            self.python_exe = python_exe\n        self.env = get_extended_env_path_conda(self.python_exe)\n        self.rpyc_server_py = rpyc_server_py\n        self.timeout = timeout\n        self.retry = 0\n        self.max_retry = max(0, max_retry)\n        self.log_level = log_level\n        self.working_dir = working_dir\n        if port is None:\n            self.port = _get_free_tcp_port()\n        else:\n            self.port = port\n        self.python_popen = self._launch_python()\n        self.connection = self._get_connection()\n        self.py_remote_modules = self.connection.root.getmodule\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        """"""Cleanup the connection on error and exit.\n\n        Parameters\n        ----------\n        exc_type : Error\n            Type of the exception that caused the __exit__.\n        exc_val : str\n            Value of the exception that caused the __exit__.\n        exc_tb : type\n            Exception log.\n\n        Returns\n        -------\n        True if the connection was successfully closed.""""""\n        try:\n            if exc_type:\n                logger.error(""{!s}, {!s}, {!s}"".format(exc_type, exc_val, exc_tb))\n        except NameError:\n            pass\n        self.close()\n        return True\n\n    def run_py_function(self, module_name, function_name, *nargs, **kwargs):\n        """"""Run a specific Python function on the remote, with Python crash handling.""""""\n        remote_module = self.py_remote_modules(module_name)\n        function = getattr(remote_module, function_name)\n        function_output = kwargs.pop(""function_output"", None)\n\n        try:\n            result = function(*nargs, **kwargs)\n        except (socket.error, EOFError):\n            self._rebuild_py_remote()\n            return self.run_py_function(*nargs, **kwargs)\n\n        if function_output is not None:\n            try:\n                result = result[function_output]\n            except NameError:\n                pass\n        return result\n\n    def close(self):\n        if not self.connection.closed:\n            logger.info(""Closing connection."")\n            self.connection.close()\n        if self.python_popen.poll() is None:\n            logger.info(""Closing Python."")\n            self.python_popen.terminate()\n\n    def _launch_python(self):\n        logger.debug(""Using python executable: {!s}"".format(self.python_exe))\n        logger.debug(""Using rpyc_server module: {!s}"".format(self.rpyc_server_py))\n        logger.debug(""Using port: {}"".format(self.port))\n        logger.debug(""Using log_level: {!s}"".format(self.log_level))\n        logger.debug(""Using working_dir: {!s}"".format(self.working_dir))\n        assert self.python_exe is not """" and self.python_exe is not None\n        assert self.rpyc_server_py is not """" and self.rpyc_server_py is not None\n        assert self.port is not """" and self.port is not None\n        assert self.log_level is not """" and self.log_level is not None\n        python_call = \'""{!s}"" ""{!s}"" ""{}"" ""{!s}""\'.format(\n            self.python_exe, self.rpyc_server_py, self.port, self.log_level\n        )\n        cwd = self.working_dir\n        python_popen = subprocess.Popen(\n            python_call,\n            stdout=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            cwd=cwd,\n            env=self.env,\n        )\n        return python_popen\n\n    def _get_connection(self):\n        connection = None\n        logger.info(""Connecting..."")\n        for i in range(self.timeout):\n            try:\n                if not connection:\n                    logger.debug(\n                        ""Connecting. Timeout in {:d} seconds."".format(self.timeout - i)\n                    )\n                    connection = rpyc.utils.factory.connect(\n                        ""localhost"",\n                        self.port,\n                        service=rpyc.core.service.ClassicService,\n                        config={""sync_request_timeout"": None},\n                        ipv6=False,\n                        keepalive=True,\n                    )\n                else:\n                    logger.debug(\n                        ""Found connection, testing. Timeout in {:d} seconds."".format(\n                            self.timeout - i\n                        )\n                    )\n                    connection.ping(timeout=1)\n                    logger.debug(""Connection ok, returning."")\n                    logger.info(""Connected."")\n                    return connection\n            except socket.error as e:\n                if self.python_popen.poll() is not None:\n                    raise RuntimeError(\n                        ""Remote python {!s} failed on launch. "".format(self.python_exe)\n                        + ""Does the remote python have rpyc installed?""\n                    )\n                if i == self.timeout - 1 or not e.errno == errno.ECONNREFUSED:\n                    raise RuntimeError(\n                        ""Could not connect to remote python {!s}. "".format(\n                            self.python_exe\n                        )\n                        + ""Does the remote python have rpyc installed?""\n                    )\n                sleep(1)\n            except (\n                rpyc.core.protocol.PingError,\n                rpyc.core.async_.AsyncResultTimeout,\n            ) as e:\n                logger.debug(str(e))\n                raise e\n\n    def _rebuild_py_remote(self):\n        if self.retry < self.max_retry:\n            logger.info(""Lost Rhino connection, retrying."")\n            self.retry += 1\n            self.close()\n            [self.rhino_popen, self.connection, self.gh_remote] = [None, None, None]\n            logger.info(""Waiting 10 seconds."")\n            sleep(10)\n            self.python_popen = self._launch_python()\n            self.connection = self._get_connection()\n        else:\n            raise RuntimeError(\n                ""Lost connection to Python, and reconnection attempts limit ({:d}) ""\n                ""reached. Exiting."".format(self.max_retry)\n            )\n\n\nclass PythonToGrasshopperRemote:\n    """"""Creates a remote Rhino/IronPython instance (with Grasshopper functions)\n    connected to a local python engine.\n    \n    The local instance will be able to import all objects from the Rhino IronPython\n    engine, as well as Grasshopper components. Rhino will appear frozen on a python\n    script it is reading.\n        \n    Parameters\n    ----------\n    rhino_file_path : str\n        Absolute file path to a Rhino .3dm file to open in the remote Rhino. Can be\n        empty.\n    rpyc_server_py : str\n        Absolute path to the ghcompservice.py module that launches the server on the\n        remote.\n    rhino_ver : int\n        A Rhino version to use, from 5 to 7. Overridden by rhino_exe. Defaults to 6.\n    rhino_exe : str\n        Absolute path to the Rhino executable. By default, fetches from the windows\n        registry the Rhino install with the same bitness as the platform, and version\n        given by rhino_ver.\n    timeout : int\n        Number of seconds to wait for Rhino and IronPython to startup.\n    max_retry : int\n        Number of times Rhino will be restarted if it crashes, before declaring the\n        connection dead.\n    \n    Examples\n    --------\n    >>> ROOT = os.path.abspath(os.path.join(os.path.curdir, \'..\'))\n    >>> rhino_file_path = os.path.join(ROOT, \'examples\', \'curves.3dm\')\n    >>> rpyc_server_py = os.path.join(ROOT, \'ghcompservice.py\')\n    >>> with PythonToGrasshopperRemote(\n    >>>     rhino_file_path, rpyc_server_py, rhino_ver=6, timeout=60\n    >>> ) as py2gh:\n    >>>     rghcomp = py2gh.gh_remote_components\n    >>>     rgh = py2gh.connection\n    >>>     Rhino = rgh.modules.Rhino\n    >>>     rs = rgh.modules.rhinoscriptsyntax\n    >>>     # Do stuff with all this\n    >>>     # See CPython_to_GH.py for a longer example\n    """"""\n\n    def __init__(\n        self,\n        rhino_file_path,\n        rpyc_server_py,\n        rhino_ver=6,\n        rhino_exe=None,\n        timeout=60,\n        max_retry=3,\n        port=None,\n        log_level=logging.WARNING\n    ):\n        if rhino_exe is None:\n            self.rhino_exe = self._get_rhino_path(version=rhino_ver)\n        else:\n            self.rhino_exe = rhino_exe\n        self.rhino_file_path = rhino_file_path\n        self.rpyc_server_py = rpyc_server_py\n        self.timeout = timeout\n        self.retry = 0\n        self.max_retry = max(0, max_retry)\n        if port is None:\n            self.port = _get_free_tcp_port()\n        else:\n            self.port = port\n        self.log_level = log_level\n        self.rhino_popen = self._launch_rhino()\n        self.connection = self._get_connection()\n        self.gh_remote_components = self.connection.root.ghcomp\n        self.gh_remote_userobjects = self.connection.root.ghuo\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        """"""Cleanup the connection on error and exit.\n        \n        Parameters\n        ----------\n        exc_type : Error\n            Type of the exception that caused the __exit__.\n        exc_val : str\n            Value of the exception that caused the __exit__.\n        exc_tb : type\n            Exception log.\n            \n        Returns\n        -------\n        True if the connection was successfully closed.""""""\n        try:\n            if exc_type:\n                logger.error(""{!s}, {!s}, {!s}"".format(exc_type, exc_val, exc_tb))\n        except NameError:\n            pass\n        self.close()\n        return True\n\n    def run_gh_component(self, component_name, *nargs, **kwargs):\n        """"""Run a specific Grasshopper component on the remote, with Rhino crash\n        handling.\n        """"""\n        is_cluster = kwargs.pop(""is_cluster"", False)\n        # TODO: improve ghcomp to get clusters the same way we get compiled components,\n        # thus removing the need for a custom getter\n        component = self.gh_remote_components(component_name, is_cluster=is_cluster)\n        component_output = kwargs.pop(""component_output"", None)\n\n        try:\n            result = component(*nargs, **kwargs)\n        except (socket.error, EOFError):\n            self._rebuild_gh_remote()\n            return self.run_gh_component(*nargs, **kwargs)\n\n        if component_output is not None:\n            try:\n                result = result[component_output]\n            except NameError:\n                pass\n        return result\n\n    def close(self):\n        if not self.connection.closed:\n            logger.info(""Closing connection."")\n            self.connection.close()\n        if self.rhino_popen.poll() is None:\n            logger.info(""Closing Rhino."")\n            self.rhino_popen.terminate()\n\n    @staticmethod\n    def _get_rhino_path(version=6, preferred_bitness=""same""):\n        rhino_reg_key_path = None\n        version_str = ""{!s}.0"".format(version)\n        if platform.architecture()[0] == ""64bit"":\n            if preferred_bitness == ""same"" or preferred_bitness == ""64"":\n                if version == 5:\n                    version_str += ""x64""\n                rhino_reg_key_path = r""SOFTWARE\\McNeel\\Rhinoceros\\{}\\Install"".format(\n                    version_str\n                )\n                if version < 5:\n                    rhino_reg_key_path = None\n            elif preferred_bitness == ""32"":\n                rhino_reg_key_path = (\n                    r""SOFTWARE\\WOW6432Node\\McNeel\\Rhinoceros\\{}\\Install""\n                )\n                rhino_reg_key_path = rhino_reg_key_path.format(version_str)\n        elif platform.architecture()[0] == ""32bit"":\n            if preferred_bitness == ""same"" or preferred_bitness == ""32"":\n                rhino_reg_key_path = r""SOFTWARE\\McNeel\\Rhinoceros\\{}\\Install"".format(\n                    version_str\n                )\n            if version > 5:\n                rhino_reg_key_path = None\n\n        if rhino_reg_key_path is None:\n            logger.error(\n                ""Did not understand Rhino version ({!s}) and bitness ({!s}) options ""\n                ""for platform {!s}."".format(\n                    version, preferred_bitness, platform.machine()\n                )\n            )\n\n        # In Python 3, OpenKey might throw a FileNotFoundError, which is not defined in\n        # Python 2. Just pretend to work around that\n        try:\n            FileNotFoundError\n        except NameError:\n            FileNotFoundError = IOError\n        try:\n            rhino_reg_key = winreg.OpenKey(\n                winreg.HKEY_LOCAL_MACHINE, rhino_reg_key_path\n            )\n            rhino_path = winreg.QueryValueEx(rhino_reg_key, ""Path"")[0]\n        except (FileNotFoundError, OSError) as e:\n            logger.error(\n                ""Unable to find Rhino installation in registry. Are you running ""\n                ""Windows with Rhinoceros installed?""\n            )\n            raise e\n        return os.path.join(rhino_path, ""Rhino.exe"")\n\n    def _launch_rhino(self):\n        assert self.rhino_exe is not """" and self.rhino_exe is not None\n        assert self.rpyc_server_py is not """" and self.rpyc_server_py is not None\n        assert self.port is not """" and self.port is not None\n        rhino_call = [\n            \'""\' + self.rhino_exe + \'""\',\n            ""/nosplash"",\n            ""/notemplate"",\n            \'/runscript=""-_RunPythonScript """"{!s}"""" {!s} {!s} -_Exit ""\'.format(\n                self.rpyc_server_py, self.port, self.log_level,\n            ),\n        ]\n        if self.rhino_file_path:\n            rhino_call.append(self.rhino_file_path)\n        # Default escaping in subprocess.line2cmd does not work here,\n        # manually convert to string\n        rhino_call = "" "".join(rhino_call)\n        rhino_popen = subprocess.Popen(\n            rhino_call, stdout=subprocess.PIPE, stdin=subprocess.PIPE\n        )\n        return rhino_popen\n\n    def _get_connection(self):\n        connection = None\n        logger.info(""Connecting..."")\n        for i in range(self.timeout):\n            try:\n                if not connection:\n                    logger.debug(\n                        ""Connecting. Timeout in {:d} seconds."".format(self.timeout - i)\n                    )\n                    connection = rpyc.utils.factory.connect(\n                        ""localhost"",\n                        self.port,\n                        service=rpyc.core.service.ClassicService,\n                        config={""sync_request_timeout"": None},\n                        ipv6=False,\n                        keepalive=True,\n                    )\n                else:\n                    logger.debug(\n                        ""Found connection, testing. Timeout in {:d} seconds."".format(\n                            self.timeout - i\n                        )\n                    )\n                    connection.ping(timeout=1)\n                    logger.debug(""Connection ok, returning."")\n                    logger.info(""Connected."")\n                    return connection\n            except (\n                socket.error,\n                rpyc.core.protocol.PingError,\n                rpyc.core.async_.AsyncResultTimeout,\n            ) as e:\n                if e is socket.error and not e.errno == errno.ECONNREFUSED:\n                    raise\n                if i == self.timeout - 1:\n                    raise\n                elif e is socket.error:\n                    sleep(1)\n\n    def _rebuild_gh_remote(self):\n        if self.retry < self.max_retry:\n            logger.info(""Lost Rhino connection, retrying."")\n            self.retry += 1\n            self.close()\n            [self.rhino_popen, self.connection, self.gh_remote] = [None, None, None]\n            logger.info(""Waiting 10 seconds."")\n            sleep(10)\n            self.rhino_popen = self._launch_rhino()\n            self.connection = self._get_connection()\n            self.gh_remote_components = self.connection.root.get_component\n        else:\n            raise RuntimeError(\n                ""Lost connection to Rhino, and reconnection attempts limit ({:d}) ""\n                ""reached. Exiting."".format(self.max_retry)\n            )\n\n\ndef _get_free_tcp_port():\n    tcp = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    tcp.bind(("""", 0))\n    addr, port = tcp.getsockname()\n    tcp.close()\n    return port\n'"
ghpythonremote/ghcompservice.py,0,"b'import logging\nimport sys\n\nfrom ghpythonremote import rpyc\nfrom rpyc.utils.server import OneShotServer\n\n\nclass GhcompService(rpyc.ClassicService):\n    def on_connect(self, conn):\n        print(""Incoming connection."")\n        super(GhcompService, self).on_connect(conn)\n        import ghpythonlib.components as ghcomp\n        from ghpythonremote import ghuserobjects as ghuo\n\n        self.ghcomp = ghcomp\n        self.ghuo = ghuo\n\n    def on_disconnect(self, conn):\n        print(""Disconnected."")\n\n\nif __name__ == ""__main__"":\n    import rhinoscriptsyntax as rs\n\n    port = rs.GetInteger(""Server bind port"", 18871, 1023, 65535)\n    log_level = rs.GetInteger(""Log level as int"", 30, 0, 100)\n\n    logger = logging.getLogger()\n    logger.setLevel(log_level)\n    ch = logging.StreamHandler()\n    ch.setLevel(log_level)\n    formatter = logging.Formatter(\n        ""\\n%(asctime)s - %(name)s - %(levelname)s -\\n%(message)s""\n    )\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    logger = logging.getLogger(""ghpythonremote.ghcompservice"")\n    logger.info(""Starting server..."")\n\n    server = OneShotServer(\n        GhcompService, hostname=""localhost"", port=port, listener_timeout=None\n    )\n    server.start()\n'"
ghpythonremote/ghuserobjects.py,0,"b'""""""\nCopyright (c) 2011-2013 Robert McNeel & Associates. All Rights Reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the ""Software""),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software.\n\nTHIS SOFTWARE IS PROVIDED ""AS IS"" WITHOUT EXPRESS OR IMPLIED WARRANTY.\nALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF\nMERCHANTABILITY ARE HEREBY DISCLAIMED.\n""""""\n\nimport sys\n\nif sys.platform != ""cli"":\n    raise(RuntimeError, ""This module is only intended to be run in Rhino Python"")\n\nfrom collections import namedtuple\nimport clr\n\nclr.AddReference(\'Grasshopper, Culture=neutral, PublicKeyToken=dda4f5ec2cd80803\')\n\nimport System\nimport Rhino\nimport Grasshopper as gh\nimport sys\nimport re\n\n\nclass namespace_object(object):\n    pass\n\n\ndef __make_function_uo__(helper):\n    def component_function(*args, **kwargs):\n        comp = helper.proxy.CreateInstance()\n        comp.ClearData()\n        if args:\n            for i, arg in enumerate(args):\n                if arg is None: continue\n                param = comp.Params.Input[i]\n                param.PersistentData.Clear()\n                if hasattr(arg, \'__iter__\'):  # TODO deal with polyline, str\n                    [param.AddPersistentData(a) for a in arg]\n                else:\n                    param.AddPersistentData(arg)\n        if kwargs:\n            for param in comp.Params.Input:\n                name = param.Name.lower()\n                if name in kwargs:\n                    param.PersistentData.Clear()\n                    arg = kwargs[name]\n                    if hasattr(arg, \'__iter__\'):  # TODO deal with polyline, str\n                        [param.AddPersistentData(a) for a in arg]\n                    else:\n                        param.AddPersistentData(arg)\n        doc = gh.Kernel.GH_Document()\n        doc.AddObject(comp, False, 0)\n        comp.CollectData()\n        comp.ComputeData()\n        output = helper.create_output(comp.Params)\n        comp.ClearData()\n        doc.Dispose()\n        return output\n\n    return component_function\n\n\nclass function_helper(object):\n    def __init__(self, proxy, name):\n        self.proxy = proxy\n        self.return_type = None\n\n    def create_output(self, params, output_values=None):\n        if not output_values:\n            output_values = []\n            for output in params.Output:\n                data = output.VolatileData.AllData(True)\n                # We could call Value, but ScriptVariable seems to do a better job\n                v = [x.ScriptVariable() for x in data]\n                if len(v) < 1:\n                    output_values.append(None)\n                elif len(v) == 1:\n                    output_values.append(v[0])\n                else:\n                    output_values.append(v)\n        if len(output_values) == 1: return output_values[0]\n        if self.return_type is None:\n            names = [output.Name.lower() for output in params.Output]\n            try:\n                self.return_type = namedtuple(\'Output\', names, rename=True)\n            except:\n                self.return_type = False\n        if not self.return_type: return output_values\n        return self.return_type(*output_values)\n\n    def runfast(self, args, kwargs):\n        return False, None\n\n\ndef __build_module_uo():\n    core_module = sys.modules[__name__]\n    translate_from = u""|+-*\\u2070\\u00B9\\u00B2\\u00B3\\u2074\\u2075\\u2076\\u2077\\u2078\\u2079""\n    translate_to = ""X__x0123456789""\n    transl = dict(zip(translate_from, translate_to))\n\n    def regex_helper(match):\n        if match.group() in transl:\n            return transl[match.group()]\n        return \'\'\n\n    def function_description(description, params):\n        rc = [\'\', description, ""Input:""]\n        for param in params.Input:\n            s = ""\\t{0} [{1}] - {2}""\n            if param.Optional:\n                s = ""\\t{0} (in, optional) [{1}] - {2}""\n            rc.append(s.format(param.Name.lower(), param.TypeName, param.Description))\n        if params.Output.Count == 1:\n            param = params.Output[0]\n            rc.append(""Returns: [{0}] - {1}"".format(param.TypeName, param.Description))\n        elif params.Output.Count > 1:\n            rc.append(""Returns:"")\n            for out in params.Output:\n                s = ""\\t{0} [{1}] - {2}""\n                rc.append(s.format(out.Name.lower(), out.TypeName, out.Description))\n        return \'\\n\'.join(rc)\n\n    for obj in gh.Instances.ComponentServer.ObjectProxies:\n        if obj.Exposure == gh.Kernel.GH_Exposure.hidden or obj.Obsolete:\n            continue\n\n        library_id = obj.LibraryGuid\n        assembly = gh.Instances.ComponentServer.FindAssembly(library_id)\n        name = obj.Desc.Name\n\n        if ""LEGACY"" in name or ""#"" in name:\n            continue\n        name = re.sub(""[^_a-zA-Z0-9]"", regex_helper, name)\n        if not name[0].isalpha():\n            name = \'x\' + name\n\n        if assembly is not None:\n            # Compiled components, leave them to ghpythonlib\n            continue\n\n        function = __make_function_uo__(function_helper(obj, name))\n        m = core_module\n        try:\n            setattr(m, name, function)\n            a = m.__dict__[name]\n            a.__name__ = name\n            comp = obj.CreateInstance()\n            a.__doc__ = function_description(obj.Desc.Description, comp.Params)\n        except Exception as err:\n            Rhino.RhinoApp.WriteLine(str(err))\n            Rhino.Runtime.HostUtils.ExceptionReport(""ghpythonlib.components.py|"" + name,\n                                                    err.clsException)\n\n\n__build_module_uo()\n'"
ghpythonremote/helpers.py,0,"b'import json\nimport logging\nimport os\nimport subprocess\n\nlogger = logging.getLogger(""ghpythonremote.helpers"")\n\n\ndef get_python_path(location=None):\n    if location is None or location == """":\n        return get_python_from_windows_path()\n\n    if os.path.exists(location):\n        logger.debug("" Directly trying python executable at {!s}\\n"".format(location))\n        return get_python_from_path(location)\n\n    try:\n        [method, env_name] = location.split(""://"")\n    except ValueError as e:\n        logger.warning(\n            ""Location format for {!s} did not match expected format: ""\n            \'""method://env_name""({!s}).\\n\'.format(location, e.message)\n            + ""Falling back to getting python path from windows %PATH%.\\n""\n        )\n        return get_python_from_windows_path()\n    if method == ""conda"":\n        return get_python_from_conda_env(env_name)\n\n    logger.warning(\n        ""Method {!s} for location not implemented.\\n"".format(method)\n        + ""Falling back to getting python path from windows %PATH%.\\n""\n    )\n    return get_python_from_windows_path()\n\n\ndef get_python_from_path(path):\n    path = os.path.normpath(os.path.realpath(path))\n    if os.path.isdir(path):\n        path = os.path.join(path, ""python.exe"")\n    if os.path.isfile(path) and os.access(path, os.X_OK):\n        return path\n    else:\n        logger.warning(""Path {!s} is not executable.\\n"".format(path))\n        return get_python_from_windows_path()\n\n\ndef get_python_from_windows_path():\n    try:\n        python_exe = subprocess.check_output([""where"", ""python""]).split(""\\n"")[0].strip()\n        return python_exe\n    except (OSError, subprocess.CalledProcessError) as e:\n        logger.error(\n            ""Unable to find a python installation in your windows %PATH%. ""\n            + ""Are you running Windows with python accessible in your path?\\n""\n        )\n        raise e\n\n\ndef get_python_from_conda_env(env_name):\n    try:\n        envs = json.loads(subprocess.check_output([""conda"", ""env"", ""list"", ""--json""]))[\n            ""envs""\n        ]\n    except OSError:\n        logger.warning(\n            ""conda not found in your windows %PATH%, cannot fetch environment by ""\n            + ""name.\\nFalling back to getting python path from windows %PATH%.\\n""\n        )\n        return get_python_path()\n    except subprocess.CalledProcessError:\n        logger.warning(\n            ""conda env list failed, cannot fetch environment by name.\\n""\n            + ""Falling back to getting python path from windows %PATH%.\\n""\n        )\n        return get_python_path()\n\n    env_dir = [path for path in envs if os.path.split(path)[-1] == env_name]\n    if len(env_dir) > 1:\n        logger.warning(\n            ""Found several environments with target name; selecting first one.""\n        )\n\n    try:\n        python_exe = os.path.join(env_dir[0], ""python.exe"")\n        return python_exe\n    except IndexError:\n        logger.warning(\n            ""Environment {!s} was not found in your conda list of ""\n            ""environments.\\n"".format(env_name)\n            + ""Falling back to getting python path from windows %PATH%.\\n""\n        )\n        return get_python_from_windows_path()\n\n\ndef get_extended_env_path_conda(python_exe):\n    # Conda stores useful DLLs in these paths, add them to the path like they would be\n    # by conda activate\n    new_env = os.environ.copy()\n    conda_folders = [\n        """",\n        ""/Library/mingw-w64/bin"",\n        ""/Library/usr/bin"",\n        ""/Library/bin"",\n        ""/Scripts"",\n        ""/bin"",\n    ]\n    add_path = [\n        os.path.normpath(os.path.dirname(python_exe) + folder)\n        for folder in conda_folders\n    ]\n    new_env[""PATH""] = os.pathsep.join(add_path) + os.pathsep + new_env[""PATH""]\n    return new_env\n\n\ndef get_rhino_ironpython_path(location=None):\n    if location is None or location == """":\n        return get_ironpython_from_appdata()\n\n    if type(location) == int:\n        logger.debug(\n            "" Looking for IronPython installation of Rhino version {!s}.\\n"".format(\n                location\n            )\n        )\n        return get_ironpython_from_appdata(location)\n\n    if os.path.isdir(location):\n        logger.debug("" Directly using IronPython lib folder at {!s}\\n"".format(location))\n        return get_ironpython_from_path(location)\n\n    logger.warning(\n        "" Path {!s} is not a directory or does not exist.\\n"".format(location)\n        + "" "" * 9\n        + ""Falling back to getting IronPython lib folder path from windows %APPDATA%.\\n""\n    )\n    return get_ironpython_from_appdata()\n\n\nDEFAULT_RHINO_VERSION = 6\n\n\ndef get_ironpython_from_appdata(rhino_version=DEFAULT_RHINO_VERSION):\n    appdata_path = os.getenv(""APPDATA"", """")\n    if rhino_version == 6:\n        ironpython_settings_path = os.path.join(\n            appdata_path,\n            ""McNeel"",\n            ""Rhinoceros"",\n            ""6.0"",\n            ""Plug-ins"",\n            ""IronPython (814d908a-e25c-493d-97e9-ee3861957f49)"",\n            ""settings"",\n        )\n    elif rhino_version == 5:\n        ironpython_settings_path = os.path.join(\n            appdata_path,\n            ""McNeel"",\n            ""Rhinoceros"",\n            ""5.0"",\n            ""Plug-ins"",\n            ""IronPython (814d908a-e25c-493d-97e9-ee3861957f49)"",\n            ""settings"",\n        )\n    else:\n        logger.warning(\n            \' Unknown Rhino version ""{!s}"". Defaulting to Rhino {!s}.\\n\'.format(\n                rhino_version, DEFAULT_RHINO_VERSION\n            )\n        )\n        return get_ironpython_from_appdata()\n\n    if rhino_version == 5:\n        ghpython_version_path = os.path.join(\n            ironpython_settings_path, ""ghpy_version.txt""\n        )\n\n        if os.path.isfile(ghpython_version_path):\n            with open(ghpython_version_path) as ghpython_version:\n                ghpython_version_list = ghpython_version.readline().split(""."")\n            try:\n                ghpython_version_tuple = tuple(int(x) for x in ghpython_version_list)\n                if ghpython_version_tuple < (0, 6, 0, 3):\n                    logger.warning(\n                        "" ghpy_version.txt indicates obsolete version {!s}.\\n"".format(\n                            ""."".join(ghpython_version_list)\n                        )\n                        + "" "" * 9\n                        + ""Please install version 0.6.0.3 or superior from ""\n                        + ""http://www.food4rhino.com/app/ghpython\\n""\n                    )\n                logger.info(\n                    "" Found ghpython version {!s} in {!s}\\n"".format(\n                        ""."".join(ghpython_version_list), ironpython_settings_path\n                    )\n                )\n            except ValueError:\n                logger.warning(\n                    "" Could not parse ghpy_version.txt file installation found in ""\n                    ""{!s}.\\n"".format(ironpython_settings_path)\n                    + "" "" * 9\n                    + ""Was ghpython installed and opened in Grasshopper at least once ""\n                    + ""on this machine?\\n""\n                )\n        else:\n            logger.warning(\n                "" No ghpy_version.txt file installation found in {!s}.\\n"".format(\n                    ironpython_settings_path\n                )\n                + "" "" * 9\n                + ""Was ghpython installed and opened in Grasshopper at least once on ""\n                + ""this machine?\\n""\n            )\n    if rhino_version == 6:\n        # Rhino 6 does not have a ghpy_version.txt file, check that there is a\n        # ghpythonlib __init__.py\n        ghpythonlib_init_path = os.path.join(\n            ironpython_settings_path, ""lib"", ""ghpythonlib"", ""__init__.py""\n        )\n\n        if not os.path.isfile(ghpythonlib_init_path):\n            logger.warning(\n                "" No ghpythonlib package found in {!s}.\\n"".format(\n                    os.path.join(ironpython_settings_path, ""lib"")\n                )\n                + "" "" * 9\n                + ""Was Grasshopper for Rhino 6 opened at least once on this machine?\\n""\n            )\n\n    ironpython_lib_path = os.path.join(ironpython_settings_path, ""lib"")\n    if not os.path.isdir(ironpython_lib_path):\n        logger.error(\n            "" IronPython lib directory for Rhinoceros not found in {!s}.\\n"".format(\n                ironpython_settings_path\n            )\n            + "" "" * 7\n            + ""Please provide a full path to one of the folders in your IronPython for ""\n            + ""Rhinoceros path.\\n""\n            + "" "" * 7\n            + ""These folders are listed in the settings of the window opened with the ""\n            + ""command `_EditPythonScript` in Rhinoceros.\\n""\n        )\n        raise RuntimeError(\n            ""No IronPython lib folder found in %APPDATA%\\\\McNeel\\\\Rhinoceros""\n        )\n    logger.info("" Found IronPython lib folder {!s}\\n"".format(ironpython_lib_path))\n\n    return ironpython_lib_path\n\n\ndef get_ironpython_from_path(location):\n    return location\n'"
ghpythonremote/monkey.py,0,"b'import inspect\nimport sys\n\nimport rpyc\n\nif sys.platform == ""cli"":\n    # Some compatibility fixes for IronPython\n    rpyc.core.brine.IMM_INTS = dict((i, bytes([i + 0x50])) for i in range(-0x30, 0xA0))\n\n    def BYTES_LITERAL(text):\n        return bytes(text)\n\n    rpyc.lib.compat.BYTES_LITERAL = BYTES_LITERAL\n\n    # TODO: This will not be found in Rhino 5!\n    # TODO: This will not work if in IronPython outside Rhino!\n    # TODO: This loads the gh components early?? not needed if not accessing them??\n    # TODO: Remove that when ghpythonlib.components.__namedtuple.__getattr__ is fixed\n    import ghpythonlib.components\n\n    def get_id_pack(obj):\n        """"""introspects the given ""local"" object, returns id_pack as expected by BaseNetref\n\n        The given object is ""local"" in the sense that it is from the local cache. Any object in the local cache exists\n        in the current address space or is a netref. A netref in the local cache could be from a chained-connection.\n        To handle type related behavior properly, the attribute `__class__` is a descriptor for netrefs.\n\n        So, check thy assumptions regarding the given object when creating `id_pack`.\n        """"""\n\n        # TODO: Remove that when ghpythonlib.components.__namedtuple.__getattr__ is fixed\n        if hasattr(obj, ""____id_pack__"") and not isinstance(\n            obj, ghpythonlib.components.__namedtuple\n        ):\n            # netrefs are handled first since __class__ is a descriptor\n            return obj.____id_pack__\n        # str(obj).split(\':\')[0] == ""Microsoft.Scripting.Actions.NamespaceTracker"" should also work\n        elif (\n            inspect.ismodule(obj)\n            or getattr(obj, ""__name__"", None) == ""module""\n            or str(type(obj)) == ""<type \'namespace#\'>""\n        ):\n            # TODO: not sure about this, need to enumerate cases in units\n            if isinstance(obj, type):  # module\n                obj_cls = type(obj)\n                name_pack = ""{0}.{1}"".format(obj_cls.__module__, obj_cls.__name__)\n                return (name_pack, id(type(obj)), id(obj))\n            else:\n                if inspect.ismodule(obj) and obj.__name__ != ""module"":\n                    if obj.__name__ in sys.modules:\n                        name_pack = obj.__name__\n                    else:\n                        name_pack = ""{0}.{1}"".format(\n                            obj.__class__.__module__, obj.__name__\n                        )\n                elif inspect.ismodule(obj):\n                    name_pack = ""{0}.{1}"".format(obj.__module__, obj.__name__)\n                    print(name_pack)\n                elif hasattr(obj, ""__module__""):\n                    name_pack = ""{0}.{1}"".format(obj.__module__, obj.__name__)\n                else:\n                    obj_cls = type(obj)\n                    name_pack = ""{0}"".format(obj.__name__)\n                return (name_pack, id(type(obj)), id(obj))\n        elif not inspect.isclass(obj):\n            name_pack = ""{0}.{1}"".format(\n                obj.__class__.__module__, obj.__class__.__name__\n            )\n            return (name_pack, id(type(obj)), id(obj))\n        else:\n            name_pack = ""{0}.{1}"".format(obj.__module__, obj.__name__)\n            return (name_pack, id(obj), 0)\n\n    rpyc.lib.get_id_pack = get_id_pack\n    rpyc.core.netref.get_id_pack = get_id_pack\n    rpyc.core.protocol.get_id_pack = get_id_pack\n\n    # TODO: Remove that when ghpythonlib.components.__namedtuple.__getattr__ is fixed\n    def _handle_inspect(self, id_pack):  # request handler\n        obj = self._local_objects[id_pack]\n        if hasattr(obj, ""____conn__"") and not isinstance(\n            obj, ghpythonlib.components.__namedtuple\n        ):\n            # When RPyC is chained (RPyC over RPyC), id_pack is cached in local objects as a netref\n            # since __mro__ is not a safe attribute the request is forwarded using the proxy connection\n            # see issue #346 or tests.test_rpyc_over_rpyc.Test_rpyc_over_rpyc\n            conn = self._local_objects[id_pack].____conn__\n            return conn.sync_request(rpyc.core.consts.HANDLE_INSPECT, id_pack)\n        else:\n            return tuple(\n                rpyc.lib.get_methods(\n                    rpyc.core.netref.LOCAL_ATTRS, self._local_objects[id_pack]\n                )\n            )\n\n    # TODO: Remove that when ghpythonlib.components.__namedtuple.__getattr__ is fixed\n    rpyc.core.protocol.Connection._handle_inspect = _handle_inspect\n\n    if sys.version_info < (2, 7, 5):\n\n        def dump(obj):\n            stream = []\n            rpyc.core.brine._dump(obj, stream)\n            return b"""".join(map(bytes, stream))\n\n        rpyc.core.brine.dump = dump\n\n        import socket\n        def write(self, data):\n            try:\n                while data:\n                    count = self.sock.send(buffer(data[:self.MAX_IO_CHUNK]))\n                    data = data[count:]\n            except socket.error:\n                ex = sys.exc_info()[1]\n                self.close()\n                raise EOFError(ex)\n\n        rpyc.core.stream.SocketStream.write = write\nelse:\n    # This is only needed if the local is CPython and the remote is IronPython, doesn\'t\n    # really hurt otherwise\n    _netref_factory_orig = rpyc.core.protocol.Connection._netref_factory\n\n    def _netref_factory_str(self, id_pack):\n        return _netref_factory_orig(self, (str(id_pack[0]), id_pack[1], id_pack[2]))\n\n    rpyc.core.protocol.Connection._netref_factory = _netref_factory_str\n'"
ghpythonremote/pythonservice.py,0,"b'import logging\nimport sys\n\nfrom ghpythonremote import rpyc\nfrom rpyc.utils.server import OneShotServer\n\n\nclass PythonService(rpyc.ClassicService):\n    def on_connect(self, conn):\n        logger.info(""Incoming connection."")\n        super(PythonService, self).on_connect(conn)\n\n    def on_disconnect(self, conn):\n        logger.info(""Disconnected."")\n\n\nif __name__ == ""__main__"":\n\n    if len(sys.argv) >= 3:\n        log_level = sys.argv[2]\n        try:\n            log_level = int(log_level)\n        except (TypeError, ValueError):\n            log_level = getattr(logging, log_level, logging.WARNING)\n    else:\n        log_level = logging.WARNING\n    if len(sys.argv) >= 2:\n        port = sys.argv[1]\n    else:\n        port = 18871\n    try:\n        port = int(port)\n    except (TypeError, ValueError):\n        port = 18871\n\n    # Log everything that happens on the Python server in the console\n    logger = logging.getLogger()\n    logger.setLevel(log_level)\n    ch = logging.StreamHandler()\n    ch.setLevel(log_level)\n    formatter = logging.Formatter(\n        ""\\n%(asctime)s - %(name)s - %(levelname)s -\\n%(message)s""\n    )\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\n    logger = logging.getLogger(""ghpythonremote.pythonservice"")\n    logger.info(""Starting server..."")\n    server = OneShotServer(\n        PythonService,\n        hostname=""localhost"",\n        port=port,\n        listener_timeout=None,\n        logger=logger,\n    )\n    server.start()\n'"
ghpythonremote/version.py,0,"b'__version__ = ""1.3.1""\n__version_info__ = tuple(\n    [\n        int(num) if num.isdigit() else num\n        for num in __version__.replace(""-"", ""."", 1).split(""."")\n    ]\n)\n'"
ghpythonremote/examples/CPython_to_GH.py,0,"b'import inspect\nimport logging\nfrom os import path\n\nimport ghpythonremote\nfrom ghpythonremote.connectors import PythonToGrasshopperRemote\n\nlocal_log_level = logging.DEBUG\nlogger = logging.getLogger(""ghpythonremote"")\nlogger.setLevel(local_log_level)\nch = logging.StreamHandler()\nch.setLevel(local_log_level)\nformatter = logging.Formatter(""%(levelname)s: %(name)s:\\n%(message)s"")\nch.setFormatter(formatter)\nlogger.handlers = []\nlogger.addHandler(ch)\nlogger = logging.getLogger(""ghpythonremote.Python_to_GH"")\n\nROOT = path.abspath(path.dirname(inspect.getfile(ghpythonremote)))\nrpyc_server_py = path.join(ROOT, ""pythonservice.py"")\n\n\n# TODO: This could be made a console script in setup.py, with some additional config\nif __name__ == ""__main__"":\n    ROOT = path.abspath(path.dirname(inspect.getfile(ghpythonremote)))\n    rhino_file_path = path.join(ROOT, ""examples"", ""curves.3dm"")\n    rpyc_server_py = path.join(ROOT, ""ghcompservice.py"")\n\n    with PythonToGrasshopperRemote(\n        None, rpyc_server_py, rhino_ver=6, timeout=60, log_level=logging.DEBUG\n    ) as py2gh:\n        # Stuff that we can reach\n        rghcomp = py2gh.gh_remote_components  # Named Grasshopper compiled components\n        rghuo = py2gh.gh_remote_userobjects  # Named Grasshopper user objects\n        rgh = py2gh.connection  # Represents the remote instance root object\n        Rhino = (\n            rgh.modules.Rhino\n        )  # rgh.modules.something is like ``import something`` on the remote\n        rs = rgh.modules.rhinoscriptsyntax  # Same\n\n        # Opening a Rhino file\n        readopt = Rhino.FileIO.FileReadOptions()\n        readopt.BatchMode = True\n        Rhino.RhinoDoc.ReadFile(\n            rhino_file_path, readopt\n        )  # Or pass in a first argument to py2gh to open a file\n\n        # Doing stuff in that file\n        type_curve = Rhino.DocObjects.ObjectType.Curve\n        curves = Rhino.RhinoDoc.ActiveDoc.Objects.FindByObjectType(type_curve)\n        curves_id = tuple(\n            c.Id for c in curves\n        )  # rhinoscriptsyntax doesn\'t like mutable objects through the connection\n        gh_curves = rs.coerceguidlist(curves_id)\n        # Call a GH component\n        print(sum(rghcomp.Area(gh_curves)[0]))\n        # Call a GH user object, previously created with the name ""TestClusterGHPR""\n        print(rghuo.TestClusterGHPR(3, y=4))\n'"
ghpythonremote/examples/CPython_to_GH_manual.py,0,"b'import rpyc\n\nc = rpyc.utils.factory.connect(\n    ""localhost"",\n    18871,\n    service=rpyc.core.service.ClassicService,\n    config={""sync_request_timeout"": None},\n    ipv6=False,\n    keepalive=True,\n)\n\nrghcomp = c.root.get_component\nrgh = c\nRhino = rgh.modules.Rhino\nrs = rgh.modules.rhinoscriptsyntax\n\nreadopt = Rhino.FileIO.FileReadOptions()\nreadopt.BatchMode = True\nRhino.RhinoDoc.ReadFile(\n    r""C:\\Users\\pcuvil\\CODE\\ghpythonremote\\ghpythonremote\\examples\\curves.3dm"", readopt\n)\ntype_curve = Rhino.DocObjects.ObjectType.Curve\ncurves = Rhino.RhinoDoc.ActiveDoc.Objects.FindByObjectType(type_curve)\ncurves_id = tuple(c.Id for c in curves)\ngh_curves = rs.coerceguidlist(curves_id)\narea = rghcomp(""Area"", is_cluster_component=False)\nprint(sum(area(gh_curves)[0]))\n\n\n########################################\n### Below is what to paste in Rhino Python\n\nfrom ghpythonremote import rpyc\nfrom rpyc.utils.server import OneShotServer\n\n\nclass GhcompService(rpyc.ClassicService):\n    def on_connect(self, conn):\n        print(""Incoming connection."")\n        super(GhcompService, self).on_connect(conn)\n        import ghpythonlib.components as ghcomp\n\n        self.ghcomp = ghcomp\n\n    def on_disconnect(self, conn):\n        print(""Disconnected."")\n\n    def get_component(self, component_name, is_cluster_component=False):\n        component = getattr(self.ghcomp, component_name)\n        if is_cluster_component:\n            component = getattr(\n                component, component_name\n            )\n            # TODO: improve ghcomp to get clusters the same way we get compiled\n            # components, thus removing the need for a custom getter\n        return component\n\nserver = OneShotServer(\n    GhcompService, hostname=""localhost"", port=18871, listener_timeout=None\n)\nserver.start()\n'"
ghpythonremote/examples/GH_to_CPython.py,0,"b'import inspect\nimport logging\nfrom os import path\nimport sys\nfrom time import sleep\n\nimport scriptcontext\n\nimport ghpythonremote\nfrom ghpythonremote.connectors import GrasshopperToPythonRemote\n\nlocal_log_level = getattr(logging, log_level, logging.WARNING)\nlogger = logging.getLogger(""ghpythonremote"")\nlogger.setLevel(local_log_level)\nch = logging.StreamHandler()\nch.setLevel(local_log_level)\nformatter = logging.Formatter(""%(levelname)s: %(name)s:\\n%(message)s"")\nch.setFormatter(formatter)\nlogger.handlers = []\nlogger.addHandler(ch)\nlogger = logging.getLogger(""ghpythonremote.GH_to_python"")\n\nROOT = path.abspath(path.dirname(inspect.getfile(ghpythonremote)))\nrpyc_server_py = path.join(ROOT, ""pythonservice.py"")\n\n# Set connection to CLOSED if this is the first run\n# and initialize set of linked modules\ntry:\n    remote_python_status\nexcept NameError:\n    remote_python_status = ""CLOSED""\n    lkd_modules = set()\n\n# Wait for connection to connect or terminate\ntimer = 0\nwhile remote_python_status == ""CONNECTING"" or remote_python_status == ""CLOSING"":\n    sleep(1)\n    timer += 1\n    if timer == 10:\n        try:\n            gh2py_manager.__exit__(*sys.exc_info())\n        except Exception:\n            pass\n        remote_python_status = ""CLOSED""\n        lkd_modules = set()\n        raise RuntimeError(\n            ""Connection left in an inconsistent state and not returning. Reset ""\n            ""everything.""\n        )\n\nif run:\n    if not remote_python_status == ""OPEN"":\n        remote_python_status = ""CONNECTING""\n        gh2py_manager = GrasshopperToPythonRemote(\n            rpyc_server_py,\n            location=location,\n            timeout=10,\n            port=None,\n            log_level=log_level,\n            working_dir=working_dir,\n        )\n        gh2py = gh2py_manager.__enter__()\n        remote_python_status = ""OPEN""\n\n    # Stuff that we can reach\n    rpymod = gh2py.py_remote_modules  # A getter function for a named python module\n    rpy = gh2py.connection  # Represents the remote instance root object\n    scriptcontext.sticky[""rpy""] = rpy\n    # Add modules\n    for mod in modules:\n        try:\n            scriptcontext.sticky[mod] = rpymod(mod)\n            lkd_modules.add(mod)\n        except ImportError:\n            gh2py_manager.__exit__(*sys.exc_info())\n            raise\n\nelif not remote_python_status == ""CLOSED"":\n    remote_python_status = ""CLOSING""\n    # Remove linked modules\n    for mod in lkd_modules:\n        del scriptcontext.sticky[mod]\n    del scriptcontext.sticky[""rpy""]\n    gh2py_manager.__exit__(*sys.exc_info())\n    lkd_modules = set()\n    remote_python_status = ""CLOSED""\n\n# Change variable name because ghpython resets outputs to None before each run\nlinked_modules = lkd_modules\n\nlogger.info(""GH to python connection is {}"".format(remote_python_status))\n'"
ghpythonremote/examples/IronPython_to_CPython.py,0,"b'import inspect\nimport logging\nfrom os import path\nimport sys\n\nimport ghpythonremote\nfrom ghpythonremote.connectors import GrasshopperToPythonRemote\n\n# Fakes the GH_to_python script for testing outside of GH\n\n# Define the variables normally created in GH\nlocation = ""conda://rhinoremote""\nrun = True\nmodules = [""numpy"", ""scipy"", ""matplotlib"", ""matplotlib.pyplot"", ""cv2""]\nlog_level = ""DEBUG""\nworking_dir = r""C:\\Users\\pierre\\Pierre\\CODE\\ghpythonremote\\ghpythonremote\\examples""\n# Replace sticky dict\nsticky = {}\n\n\nlocal_log_level = getattr(logging, log_level, logging.WARNING)\nlogger = logging.getLogger(""ghpythonremote"")\nlogger.setLevel(local_log_level)\nch = logging.StreamHandler()\nch.setLevel(local_log_level)\nformatter = logging.Formatter(""%(levelname)s: %(name)s:\\n%(message)s"")\nch.setFormatter(formatter)\nlogger.handlers = []\nlogger.addHandler(ch)\nlogger = logging.getLogger(""ghpythonremote.GH_to_Python"")\n\nROOT = path.abspath(path.dirname(inspect.getfile(ghpythonremote)))\nrpyc_server_py = path.join(ROOT, ""pythonservice.py"")\n\nremote_python_status = ""CLOSED""\nlkd_modules = set()\n\ngh2py_manager = GrasshopperToPythonRemote(\n    rpyc_server_py,\n    location=location,\n    timeout=10,\n    port=None,\n    log_level=log_level,\n    working_dir=working_dir,\n)\ngh2py = gh2py_manager.__enter__()\n\n# Stuff that we can reach\nrpymod = gh2py.py_remote_modules  # A getter function for a named python module\nrpy = gh2py.connection  # Represents the remote instance root object\n# Add modules\nfor mod in modules:\n    try:\n        sticky[mod] = rpymod(mod)\n        lkd_modules.add(mod)\n    except ImportError:\n        gh2py_manager.__exit__(*sys.exc_info())\n        raise\n\n# Change variable name because ghpython resets outputs to None before each run\nlinked_modules = lkd_modules\n\nlogger.info(""GH to python connection is {}"".format(remote_python_status))\n'"
