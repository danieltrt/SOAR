file_path,api_count,code
snn.py,7,"b""'''\nSimulates 1000 neurons for 1000 ms.\nEach neuron receives (random) 10% of the 100 Poisson spike trains of rate f_rate = 2 Hz between time 200 ms and 700 ms. \nNeurons are not inter-connected.\n'''\n\n\nimport tensorflow as tf\nimport numpy as np\nimport math\n\nn = 1000 # Number of neurons\ndt = 0.5\na = 0.02\nb = 0.2\nc = -65.0\nd = 8.0\nT = math.ceil(1000/dt)\nv_init = -65\nu_init = -14.0\nn_in = 100\nrate = 2*1e-3\ntau_g = 10.0\n\n\nwith tf.Graph().as_default() as tf_graph:\n    \n    E_in = tf.constant(0.0, shape=[n_in, 1])\n    conections = tf.greater_equal(tf.random_uniform([n, n_in]), 0.1)\n    w_in = tf.where(conections, tf.constant(0.0, shape=[n, n_in]), tf.constant(0.07, shape=[n, n_in]))\n    \n    \n    inh = tf.less_equal(tf.random_uniform([n, 1]), 0.2)\n    exc = tf.logical_not(inh)\n    inh_num = tf.cast(inh, tf.float32)\n    exc_num = tf.cast(exc, tf.float32)\n    d = (8.0 * exc_num) + (2.0 * inh_num)\n    a = (0.02 * exc_num) + (0.1 * inh_num)\n\n    v_shape = [n, 1]\n    p_shape = [n_in, 1]\n    g_in_shape = [n_in, 1]\n    \n    v = tf.Variable(tf.ones(shape=v_shape) * v_init, dtype=tf.float32, name='v')\n    u = tf.Variable(tf.ones(shape=v_shape) * u_init, dtype=tf.float32, name='u')\n    g_in = tf.Variable(tf.zeros(shape=g_in_shape), dtype=tf.float32, name='g_in')\n    fired = tf.Variable(np.zeros(v_shape, dtype=bool), dtype=tf.bool, name='fired')\n    \n    \n    p_in = tf.placeholder(tf.float32, shape=p_shape)\n    g_inp = g_in + p_in\n    iapp = tf.reshape(tf.matmul(w_in, np.multiply(g_inp, E_in)) - \\\n                    tf.multiply(tf.matmul(w_in, g_inp), v),\n                    tf.shape(v))\n    \n    g_in_op = g_in.assign((1 - dt / tau_g) * g_inp)\n    \n    v_in = tf.where(fired, tf.ones(tf.shape(v))*c, v)\n    u_in = tf.where(fired, tf.ones(tf.shape(u))*tf.add(u, d), u)\n\n    '''\n    ODEs to be updated\n\n    dv =(0.04*v[:,t]+5)*v[:,t]+140\xe2\x88\x92u[:,t]\n    v(:,t+1) = v[:,t] + (dv+I_app)*dt\n    du = a*(0.2*v[:,t]\xe2\x88\x92u[:,t])\n    u[:,t+1] = u[:,t] + dt*du\n\n    Written below in TF\n    '''\n\n    dv = tf.subtract(tf.add(tf.multiply(\n                tf.add(tf.multiply(0.04, v_in), 5.0), v_in), 140), u_in)\n    v_updated = tf.add(v_in, tf.multiply(tf.add(dv, iapp), dt))\n    du = tf.multiply(a, tf.subtract(tf.multiply(b, v_in), u_in))\n    u_out = tf.add(u_in, tf.multiply(dt, du))\n    \n    fired_op = fired.assign(tf.greater_equal(v_updated, tf.ones(tf.shape(v)) * 35))\n    v_out = tf.where(fired_op, tf.ones(tf.shape(v)) * 35, v_updated)\n    \n    p_in_mean = tf.reduce_mean(v_out)\n    v_op = v.assign(v_out)\n    u_op = u.assign(u_out)\n    \nvs = [np.ones([n, 1]) * v_init]\nus = [np.ones([n, 1]) * u_init]\nfires = [np.array(u_init).reshape(1)]\nmeans = []\nwith tf.Session(graph=tf_graph) as sess:\n    sess.run(tf.global_variables_initializer())\n    \n    for t in range(T):\n        \n        if t * dt > 200 and t*dt < 700:\n            p = np.random.rand(n_in, 1) < rate*dt\n        else:\n            p = np.zeros([n_in,1])\n            \n        feed = {p_in: p}\n        \n        vo, uo, _, fire, meanv = sess.run(\n                    [v_op, u_op, g_in_op, fired_op, p_in_mean],\n                    feed_dict=feed)\n\n        # Reset spikes\n        vs.append(vo)\n        us.append(uo)\n        fires.append(fire)\n        means.append(meanv)\n    \n    inh_logical, exc_logical = sess.run([inh, exc])"""
