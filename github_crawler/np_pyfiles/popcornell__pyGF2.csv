file_path,api_count,code
test_pyGF2.py,24,"b'import unittest\nimport numpy as np\nfrom pyGF2 import gf2_add, gf2_mul, gf2_div, gf2_xgcd, strip_zeros\n\n\nclass test_gf2(unittest.TestCase):\n    """"""Test pyGF2 functions with random polynomials""""""\n\n\n\n    def test_gf2_add(self):\n        """"""Check if addition and subtraction are the same""""""\n\n\n        for i in range(100):\n            degree1 = np.random.randint(0, 11084, 1)\n            degree2 = np.random.randint(0, 11084, 1)\n\n            a = np.random.randint(0, 2, degree1, dtype=\'uint8\')\n            b = np.random.randint(0, 2, degree2, dtype=\'uint8\')\n\n            sum = gf2_add(a, b)\n\n            a_2 = gf2_add(sum, b)\n            b_2 = gf2_add(sum, a)\n\n            assert np.array_equal(a_2, strip_zeros(a)) == True\n            assert np.array_equal(b_2, strip_zeros(b)) == True\n\n\n    def test_gf2_mul(self):\n        """"""Check multiplication using distributive property""""""\n\n        for i in range(100):\n\n            degree1 = np.random.randint(0, 11084, 1)\n            degree2 = np.random.randint(0, 11084, 1)\n            degree3 = np.random.randint(0, 11084, 1)\n\n            # distributive property\n\n            a = np.random.randint(0, 2, degree1, dtype=\'uint8\')\n            b = np.random.randint(0, 2, degree2, dtype=\'uint8\')\n            c = np.random.randint(0, 2, degree3, dtype=\'uint8\')\n\n            res1 = gf2_mul(c, gf2_add(a,b))\n\n            res2 = gf2_add(gf2_mul(c, a), gf2_mul(c, b))\n\n            assert np.array_equal(res1, res2) == True\n\n            # check if same with np.convolve\n\n            res1_2  = np.mod(np.convolve(c, gf2_add(a, b)),2).astype(""uint8"")\n\n            assert np.array_equal(res1, strip_zeros(res1_2)) == True\n\n\n    def test_gf2_div(self):\n        """"""Test polynomial divisiopn in GF2""""""\n\n        for i in range(100):\n            \n            degree1 = np.random.randint(0, 11084, 1)\n            degree2 = np.random.randint(0, 11084, 1)\n\n            dividend = np.random.randint(0, 2, degree1, dtype=""uint8"")\n            divisor = np.random.randint(0, 2, degree2, dtype=""uint8"")\n\n            quotient, remainder = gf2_div(dividend, divisor)\n\n            dividend2 = gf2_add(gf2_mul(quotient, divisor), remainder)\n\n            assert np.array_equal(strip_zeros(dividend), dividend2) == True\n\n\n    def test_gf2_xgcd(self):\n        """"""Test Extended Euclidean Algorithm in GF2""""""\n\n        p = 11083\n\n        for i in range(100):\n\n            a = np.random.randint(0, 2, p).astype(""uint8"")\n\n            irr_poly = np.array([1] + [0] * (p - 1) + [1], dtype=\'uint8\')\n\n            s,t, h = gf2_xgcd(a, irr_poly)\n\n            check = gf2_add( gf2_mul(a, s), gf2_mul(irr_poly, t))\n\n            assert np.array_equal(check, h) == True\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'"
pyGF2/__init__.py,0,"b'from pyGF2.gf2_add import gf2_add\nfrom pyGF2.gf2_mul import gf2_mul\nfrom pyGF2.gf2_div import gf2_div\nfrom pyGF2.gf2_inv import gf2_inv, gf2_xgcd\nfrom pyGF2.generic_functions import strip_zeros, zerodegree_pol, zeros, padding, to_same_dim'"
pyGF2/generic_functions.py,7,"b'import numpy as np\n\n\ndef strip_zeros(a):\n    """"""Strip un-necessary leading (rightmost) zeroes\n    from a polynomial""""""\n\n    return np.trim_zeros(a, trim=\'b\')\n\n\ndef check_type(a, b):\n    """"""Type check and force cast to uint8 ndarray\n\n    Notes\n    -----\n    Ideally for best performance one should always use uint8 or bool when using this library.\n\n    """"""\n\n    if isinstance(a, np.ndarray):\n        a = np.array(a, dtype=""uint8"")\n    if isinstance(b, np.ndarray):\n        b = np.array(b, dtype=""uint8"")\n\n    if a.dtype is not ""uint8"":\n        a = a.astype(""uint8"")\n\n    if b.dtype is not ""uint8"":\n        b = b.astype(""uint8"")\n\n    return a, b\n\n\ndef padding(a, dim):\n    """"""Zero-pad input array a a to length dim, zeroes are appended at the right""""""\n\n    return np.pad(a, (0, dim-len(a)), \'constant\', constant_values=(0))\n\n\ndef to_same_dim(a, b):\n    """"""Given two arrays a and b returns the two arrays with the shorter zero-padded to have\n    the same dimension of the longer. The arrays are padded with zeroes appended to the right.\n    """"""\n\n    if len(a) > len(b):\n       return a, padding(b, len(a))\n\n    elif len(a) < len(b):\n        return padding(a, len(b)), b\n\n    else:\n        return a, b\n\n\ndef zeros(dim):\n    """"""Returns dim coefficients for -1 degree polynomial""""""\n\n    return np.zeros(dim, dtype=\'uint8\')\n\n\ndef zerodegree_pol(dim):\n    """"""Returns dim coefficients for a zero degree polynomial""""""\n\n    out = zeros(dim)\n    out[0] = 1\n\n    return out\n'"
pyGF2/gf2_add.py,5,"b'import numpy as np\nfrom pyGF2.generic_functions import strip_zeros, check_type\n\n\n\ndef xor(a, b):\n    """"""Computes the element-wise XOR of two ndarrays""""""\n\n    return np.logical_xor(a, b, dtype=\'uint8\').astype(""uint8"")\n\n\n\n\ndef gf2_add(a, b):\n\n    """"""Add two polynomials in GF(p)[x]\n\n    Parameters\n    ----------\n    a : ndarray (uint8 or uint8) or list\n        Addend polynomial\'s coefficients.\n    b : ndarray (uint8 or uint8) or list\n        Addend polynomial\'s coefficients.\n    Returns\n    -------\n    q : ndarray of uint8\n        Resulting polynomial\'s coefficients.\n\n\n    Notes\n    -----\n    Rightmost element in the arrays is the leading coefficient of the polynomial.\n    In other words, the ordering for the coefficients of the polynomials is like the one used in MATLAB while\n    in Sympy, for example, the leftmost element is the leading coefficient.\n\n    Examples\n    ========\n\n    >>> a = np.array([1,0,1], dtype=""uint8"")\n    >>> b = np.array([1,1], dtype=""uint8"")\n    >>> gf2_add(a,b)\n    array([0, 1, 1], dtype=uint8)\n""""""\n    a, b = check_type(a, b)\n\n    a, b = strip_zeros(a), strip_zeros(b)\n\n    N = len(a)\n\n    D = len(b)\n\n    if N == D:\n        res = xor(a, b)\n\n    elif N > D:\n\n        res = np.concatenate((xor(a[:D], b), a[D:]))\n\n    else:\n\n        res = np.concatenate((xor(a, b[:N]), b[N:]))\n\n    return strip_zeros(res)\n\n\n'"
pyGF2/gf2_div.py,5,"b'import numpy as np\nfrom pyGF2.generic_functions import strip_zeros\n\n\ndef gf2_div(dividend, divisor):\n    """"""This function implements polynomial division over GF2.\n\n    Given univariate polynomials ``dividend`` and ``divisor`` with coefficients in GF2,\n    returns polynomials ``q`` and ``r``\n    (quotient and remainder) such that ``f = q*g + r`` (operations are intended for polynomials in GF2).\n\n    The input arrays are the coefficients (including any coefficients\n    equal to zero) of the dividend and ""denominator\n    divisor polynomials, respectively.\n    This function was created by heavy modification of numpy.polydiv.\n\n    Parameters\n    ----------\n    dividend : ndarray (uint8 or bool)\n        Dividend polynomial\'s coefficients.\n    divisor : ndarray (uint8 or bool)\n        Divisor polynomial\'s coefficients.\n\n    Returns\n    -------\n    q : ndarray of uint8\n        Quotient polynomial\'s coefficients.\n\n    r : ndarray of uint8\n        Quotient polynomial\'s coefficients.\n\n    Notes\n    -----\n    Rightmost element in the arrays is the leading coefficient of the polynomial.\n    In other words, the ordering for the coefficients of the polynomials is like the one used in MATLAB while\n    in Sympy, for example, the leftmost element is the leading coefficient.\n\n\n    Examples\n    ========\n\n    >>> x = np.array([1, 0, 1, 1, 1, 0, 1], dtype=""uint8"")\n    >>> y = np.array([1, 1, 1], dtype=""uint8"")\n    >>> gf2_div(x, y)\n    (array([1, 1, 1, 1, 1], dtype=uint8), array([], dtype=uint8))\n\n    """"""\n\n    N = len(dividend) - 1\n    D = len(divisor) - 1\n\n    if dividend[N] == 0 or divisor[D] == 0:\n        dividend, divisor = strip_zeros(dividend), strip_zeros(divisor)\n\n    if not divisor.any():  # if every element is zero\n        raise ZeroDivisionError(""polynomial division"")\n    elif D > N:\n        q = np.array([])\n        return q, dividend\n\n    else:\n        u = dividend.astype(""uint8"")\n        v = divisor.astype(""uint8"")\n\n        m = len(u) - 1\n        n = len(v) - 1\n        scale = v[n].astype(""uint8"")\n        q = np.zeros((max(m - n + 1, 1),), u.dtype)\n        r = u.astype(u.dtype)\n\n        for k in range(0, m - n + 1):\n            d = scale and r[m - k].astype(""uint8"")\n            q[-1 - k] = d\n            r[m - k - n:m - k + 1] = np.logical_xor(r[m - k - n:m - k + 1], np.logical_and(d, v))\n\n        r = strip_zeros(r)\n\n    return q, r\n'"
pyGF2/gf2_inv.py,9,"b'import numpy as np\nfrom pyGF2.generic_functions import strip_zeros\nfrom pyGF2.gf2_div import gf2_div\nfrom pyGF2.gf2_add import gf2_add\n\n\ndef gf2_inv(f, g):\n    """""" Given a polynomial ``f`` and an irriducible polynomial ``g`` both in GF(p)[x], computes the\n        multiplicative inverse ``out``, such that f*out == 1 mod(g) (All operations are intended in GF(p)[x]).\n\n        Parameters\n        ----------\n        f : ndarray (uint8 or bool) or list\n            Input polynomial\'s coefficients.\n        g : ndarray (uint8 or bool) or list\n            Irriducible polynomial\'s coefficients.\n\n        Returns\n        -------\n        out : ndarray of uint8\n            Multiplicative inverse polynomial\'s coefficients.\n\n        Notes\n        -----\n        Rightmost element in the arrays is the leading coefficient of the polynomial.\n        In other words, the ordering for the coefficients of the polynomials is like the one used in MATLAB while\n        in Sympy, for example, the leftmost element is the leading coefficient.\n\n\n        Examples\n        ========\n\n        >>> x = np.array([1, 1, 0, 1], dtype=""uint8"")\n        >>> y = np.array([1, 0, 0, 0, 0, 1], dtype=""uint8"")\n        >>> gf2_inv(x,y)\n        array([0, 1, 1, 1], dtype=uint8)\n\n        """"""\n\n    out = gf2_xgcd(f, g)[0]\n\n    return out\n\n\ndef gf2_xgcd(b, a):\n    """"""Perform Extended Euclidean Algorithm over GF2\n\n    Given polynomials ``b`` and ``a`` in ``GF(p)[x]``, computes polynomials\n    ``s``, ``t`` and ``h``, such that ``h = gcd(f, g)`` and ``s*b + t*a = h``.\n    The typical application of EEA is solving polynomial diophantine equations and findining multiplicative inverse.\n\n\n    Parameters\n    ----------\n    b : ndarray (uint8 or bool) or list\n        b polynomial\'s coefficients.\n    a : ndarray (uint8 or bool) or list\n        a polynomial\'s coefficients.\n    Returns\n    -------\n    y2 : ndarray of uint8\n         s polynomial\'s coefficients.\n    x2 : ndarray of uint8\n         t polynomial\'s coefficients.\n    b : ndarray of uint8\n        h polynomial\'s coefficients.\n\n    Notes\n    -----\n    Rightmost element in the arrays is the leading coefficient of the polynomial.\n    In other words, the ordering for the coefficients of the polynomials is like the one used in MATLAB while\n    in Sympy, for example, the leftmost element is the leading coefficient.\n\n    Examples\n    ========\n\n    >>> x = np.array([1, 1, 1, 1, 1, 0, 1, 0, 1], dtype=""uint8"")\n    >>> y = np.array([1, 0, 1], dtype=""uint8"")\n    >>> gf2_xgcd(x,y)\n    (array([0, 1, 1, 1], dtype=uint8),\n     array([1, 1], dtype=uint8),\n     array([1], dtype=uint8))\n\n    """"""\n\n    x1 = np.array([1], dtype=""uint8"")\n    y0 = np.array([1], dtype=""uint8"")\n\n    x0 = np.array([], dtype=""uint8"")\n    y1 = np.array([], dtype=""uint8"")\n\n    while True:\n\n        q, r = gf2_div(b, a)\n\n        b = a\n\n        if not r.any():\n            break\n\n        a = r\n\n        if not (q.any() and x1.any()):  # if q is zero or x1 is zero\n            x2 = x0\n        elif not x0.any():  # if x0 is zero\n            x2 = mul(x1, q)\n        else:\n            mulres = mul(x1, q)\n\n            x2 = gf2_add(x0, mulres)\n\n        if not (q.any() and y1.any()):\n            y2 = y0\n        elif not y0.any():\n            y2 = mul(y1, q)\n        else:\n            mulres = mul(y1, q)\n\n            y2 = gf2_add(y0, mulres)\n\n        # update\n        y0 = y1\n        x0 = x1\n        y1 = y2\n        x1 = x2\n\n    return y2, x2, b\n\n\ndef mul(a, b):\n    """"""Performs polynomial multiplication over GF2.\n\n       Parameters\n       ----------\n       b : ndarray (uint8 or bool) or list\n           Multiplicand polynomial\'s coefficients.\n       a : ndarray (uint8 or bool) or list\n           Multiplier polynomial\'s coefficients.\n       Returns\n       -------\n       out : ndarray of uint8\n\n\n       Notes\n       -----\n       This function performs exactly the same operation as gf2_mul but here instead of the fft, convolution\n       in time domain is used. This is because this function must be used multiple times in gf2_xgcd and performing the\n       fft in that instance introduced significant overhead.\n    """"""\n\n    out = np.mod(np.convolve(a, b), 2).astype(""uint8"")\n\n    return strip_zeros(out)\n'"
pyGF2/gf2_mul.py,7,"b'import numpy as np\nfrom pyGF2.generic_functions import strip_zeros\n\ndef gf2_mul(a, b):\n    """"""Multiply polynomials in GF(2), FFT instead of convolution in time domain is used\n       to speed up computation significantly.\n\n    Parameters\n    ----------\n    a : ndarray (uint8 or bool) or list\n        Multiplicand polynomial\'s coefficients.\n    b : ndarray (uint8 or bool) or list\n        Multiplier polynomial\'s coefficients.\n    Returns\n    -------\n    q : ndarray of uint8\n        Resulting polynomial\'s coefficients.\n\n    Examples\n    ========\n\n    >>> a = np.array([1,0,1], dtype=""uint8"")\n    >>> b = np.array([1,1,1], dtype=""uint8"")\n    >>> gf2_mul(a,b)\n    array([1, 1, 0, 1, 1], dtype=uint8)\n""""""\n\n    fsize = len(a) + len(b) - 1\n\n    fsize = 2**np.ceil(np.log2(fsize)).astype(int) #use nearest power of two much faster\n\n    fslice = slice(0, fsize)\n\n    ta = np.fft.fft(a, fsize)\n    tb = np.fft.fft(b, fsize)\n\n    res = np.fft.ifft(ta*tb)[fslice].copy()\n\n    k = np.mod(np.rint(np.real(res)), 2).astype(\'uint8\')\n\n    return strip_zeros(k)'"
