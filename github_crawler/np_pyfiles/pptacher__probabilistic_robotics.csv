file_path,api_count,code
ch12_the_sparse_extended_information_filter/src/python/correspondence.py,3,"b""from numpy import *\nimport numpy as np\nimport scipy.linalg as la\nfrom scipy.stats import chi2\nfrom scipy.sparse import csr_matrix\nfrom equation_measurement import equation_measurement\nfrom jacobian_measurement import jacobian_measurement\nfrom markov_blanket import markov_blanket\n\nfrom pdb import set_trace as bp\n\n#@profile\ndef correspondence(z,m0,omega,m,G):\n\n    k = z.shape[1]\n    if k==0:\n        return zeros([1,0])\n    n = (m.size-3)//2\n    Q = diag([5.0,0.02])\n\n    co=zeros(k,dtype=int)\n\n    if n>0:\n\n        t = m[3:]\n        t1 = t[0::2]\n        t2 = t[1::2]\n        lst  = nonzero(logical_and(logical_and(abs(t1-m[0])<= 75\\\n                       , abs(t2-m[1])<= 75)\\\n                       , (t1-m[0])*cos(m[2])+(t2-m[1])*sin(m[2]) >= -5 ))[0]\n        a  = lst.size\n        aa = zeros([2*a,2])\n\n        J = jacobian_measurement(m,lst+1)\n        zhat = equation_measurement(m,lst+1).reshape((2,1,a))\n\n        for i in range(0,a):\n                ind = markov_blanket(lst[i]+1,m0,G)\n                ind = ind[1:]-1\n                c1 = 3+2*ind\n                ind = vstack((c1,c1+1)).flatten(order='F')\n                ind1 = nonzero(ind==3+2*lst[i])[0][0]\n                f = fxmd(ind1,3+ind.size)\n                ind2 = np.hstack((r_[0:3],ind))\n                ind3 = np.hstack((r_[0:3],array([3+ind1,4+ind1])))\n\n                s = la.solve(omega[ix_(ind2,ind2)],f.T@J[:,:,i].T)\n                d,u = la.eigh(J[:,:,i]@s[ind3,:]+Q)\n                u = diag(sqrt(1/d)).dot(u.T)\n                aa[2*i:2*i+2,:] = u\n\n        f =  np.transpose(zhat-z.reshape((2,k,1)),(2,0,1)).reshape((2*a,k))\n        f[1::2,:] = measure(f[1::2,:])\n\n        d1 = zeros([2*a,k]);\n        ia = arange(a)[in1d(lst, m0-1)]\n        cc = lst[ia]\n\n        for j in range(0,cc.size):\n                ind=ia[j]\n                d1[2*ind:2*ind+2,:] = aa[2*ind:2*ind+2,:].dot(f[2*ind:2*ind+2,:])\n\n        d2 = d1[vstack((2*ia,2*ia+1)).flatten(order='F'),:]\n        d2 = d2**2\n        m2 = d2[1::2,:]\n        d3 = d2[0::2,:] + m2\n\n        m1 = amin(d3,axis=0)\n        co = argmin(d3,axis=0)\n        new = nonzero(m1>chi2.ppf(0.50,2))[0]\n        new1 = nonzero(m1[new]<chi2.ppf(0.95,2))[0]\n        ia = ia[setdiff1d(r_[0:cc.size],co[new[new1]])]\n\n        co = cc[co]+1\n\n        if (new.size >0 and cc.size<a) or cc.size==0:\n                if cc.size==0:\n                        new = r_[0:k]\n                ib = setdiff1d(r_[0:a],ia)\n                lst = lst[ib]\n\n                for j in range(0,lst.size):\n                        ind = ib[j]\n\n                        d1[ix_([2*ind,2*ind+1],new)] = aa[2*ind:2*ind+2,:].dot(f[ix_([2*ind,2*ind+1],new)])\n                if ib.size>0:\n                        d2 = d1[ix_(vstack((2*ib,2*ib+1)).flatten(order='F'),new)]\n                        d2 = d2**2\n                        m2 = d2[1::2,:]\n                        d3 = d2[0::2,:] + m2\n                        m1 = amin(d3,axis=0)\n                        co[new] = argmin(d3,axis=0)\n\n                        co[new] = lst[co[new]]+1\n                        new = new[m1>chi2.ppf(0.95,2)]\n                        new1 = zeros(0)\n    else:\n        new = r_[0:k]\n        new1 = zeros(0)\n\n    if new1.size>0:\n            new = new[setdiff1d(r_[0:new.size],new1)]\n    if new.size>0:\n            co[new] = n+ r_[1:new.size+1]\n\n    return co\n\ndef fxmd(p,n):\n        if p>=0:\n                res=zeros([5,n])\n                res[0:3,0:3] = eye(3)\n                res[3,3+p] = 1\n                res[4,4+p] = 1\n                return res\n\ndef measure(theta):\n        tmp = theta%(2*pi)\n        return tmp-minimum(floor(tmp/pi),1)*2*pi\n"""
ch12_the_sparse_extended_information_filter/src/python/equation_measurement.py,0,"b'from numpy import *\n\ndef equation_measurement(m,ind):\n    N = ind.size\n    ind1 = 1+2*ind\n    x = m[ind1]\n    y = m[ind1+1]\n\n    delta = vstack((x,y))-m[0:2].reshape((2,1))\n    q = sqrt(sum(delta**2,axis=0))\n    return vstack((q,arctan2(delta[1,:],delta[0,:])-m[2]+pi/2))\n'"
ch12_the_sparse_extended_information_filter/src/python/equation_motion.py,0,"b'from numpy import *\n\ndef equation_motion(theta,v,a,dt):\n    H = 0.74\n    L = 2.83\n    a1 = 0.95 + L\n    b1 = 0.5\n\n    v = v/(1-tan(a)*H/L)\n\n    return array([dt*(v*cos(theta)-v/L*tan(a)*(a1*sin(theta)+b1*cos(theta))),\\\n                  dt*(v*sin(theta)+v/L*tan(a)*(a1*cos(theta)-b1*sin(theta))),\\\n                  dt*v/L*tan(a)])\n'"
ch12_the_sparse_extended_information_filter/src/python/estimate.py,0,"b'from numpy import *\nfrom scipy.linalg import solve\n\nfrom pdb import set_trace as bp\n\ndef estimate(m0,xi,omega,m):\n    n = (xi.size-3)//2\n\n    if n < 100:\n\n       m1 = solve(omega,xi)\n\n    else:\n       m1=m\n       for i in range(0,m0.size):\n           ind = 2*m0[i]+1\n\n           m1[ind:ind+2] = solve(omega[ind:ind+2,ind:ind+2],xi[ind:ind+2]-omega[ind:ind+2,:].dot(m1)+omega[ind:ind+2,ind:ind+2].dot(m1[ind:ind+2]))\n       m1[0:3] = solve(omega[0:3,0:3],xi[0:3]-omega[0:3,:].dot(m1)+omega[0:3,0:3].dot(m1[0:3]))\n    return m1\n'"
ch12_the_sparse_extended_information_filter/src/python/inverse_measurement.py,0,"b'from numpy import *\n\ndef inverse_measurement(m,z):\n    c = cos(m[2]+z[1,:])\n    s = sin(m[2]+z[1,:])\n\n    return m[0:2].reshape((2,1)) + vstack((z[0,:]*s,-z[0,:]*c))\n'"
ch12_the_sparse_extended_information_filter/src/python/jacobian_measurement.py,0,"b""from numpy import *\n\nfrom pdb import set_trace as bp\n\ndef jacobian_measurement(m,ind):\n    N = ind.size\n    ind1 = 1+2*ind\n\n    x = m[ind1]\n    y = m[ind1+1]\n\n    delta = vstack((x,y))-m[0:2].reshape((2,1))\n    q = sum(delta**2,axis=0)\n\n    J = array([[1,0],[0,-1],[0,1],[1,0]]).dot(delta)\n    #ugly\n    J = vstack((vstack((vstack((-J,zeros([1,N]))),-ones([1,N]))),J))\n    J[0::2,:] = J[0::2,:] *1/sqrt(q)\n    J[array([1,3,7,9]),:] = J[array([1,3,7,9]),:] *1/q\n\n    return J.reshape((2,5,N), order='F')\n"""
ch12_the_sparse_extended_information_filter/src/python/jacobian_motion.py,0,"b'from numpy import *\n\ndef jacobian_motion(theta,v,a,dt):\n    H = 0.74\n    L = 2.83\n    a1 = 0.95 + L\n    b1 = 0.5\n\n    return array([[1,0,-dt*(v*sin(theta)+v/L*tan(a)*(a1*cos(theta)-b1*sin(theta)))], \\\n                           [0,1,dt*(v*cos(theta)-v/L*tan(a)*(a1*sin(theta)+b1*cos(theta)))], \\\n                           [0,0,1]])\n'"
ch12_the_sparse_extended_information_filter/src/python/markov_blanket.py,0,"b'from numpy import *\n\nfrom pdb import set_trace as bp\n\ndef markov_blanket(n,m0,G):\n    s = G.shape[0]\n    mb1 = m0\n    mb2 = G[n,:].nonzero()[1]\n\n    mb12 = intersect_int(mb1,mb2,s)\n    if mb12.size == 0:\n        mb = bfs(n,G)\n        mb2 = union_int(mb2,mb,s)\n\n    mb2 = hstack(([0,n],mb2))\n    mb = union_int(mb1,mb2,s)\n    return mb\n\ndef union_int(m1,m2,s):\n    x = zeros(s)\n    y = zeros(s)\n    x[m1] = 1\n    y[m2] = 1\n    return nonzero(x+y)[0]\n\ndef intersect_int(m1,m2,s):\n    x = zeros(s)\n    y = zeros(s)\n    x[m1] = 1\n    y[m2] = 1\n    return nonzero(x*y)[0]\n\ndef bfs(n,G):\n    s = G.shape[0]\n    d = -ones(s,dtype=int)\n    d[0] = 0\n    q = zeros(s,dtype=int)\n    i=0\n    j=1\n    q[0]=0\n    found=False\n    p=zeros(0)\n    curr=0\n    while (not found) and i<j:\n        curr = q[i]\n        i += 1\n        next = nonzero(logical_and(G[curr,:].astype(int).toarray().ravel(),d==-1))[0]\n        s1 = next.size\n        q[j:j+s1]=next\n        j += s1\n        d[next]=curr\n        found=d[n]==curr\n\n    if found:\n        p = curr\n        prev = d[curr]\n        while prev!=0:\n            p = hstack((p,prev))\n            prev = d[prev]\n\n    return p\n'"
ch12_the_sparse_extended_information_filter/src/python/measurement.py,0,"b'from numpy import *\nimport numpy as np\nfrom scipy.linalg import inv\nfrom scipy.sparse import csr_matrix,vstack,hstack\n\nfrom jacobian_measurement import jacobian_measurement\nfrom equation_measurement import equation_measurement\nfrom inverse_measurement import inverse_measurement\n\nfrom pdb import set_trace as bp\n\ndef measurement(z,c,xi,omega,m,G):\n    n = (xi.size-3)//2\n    Q = diag([5.0,0.02])\n    c = c.astype(int)\n    new = max(c)-n\n\n    if new>0:\n        nsize = xi.size+2*new\n        omega1 = zeros([nsize,nsize])\n        omega1[0:xi.size,0:xi.size] = omega\n        xi1 = zeros(nsize)\n        xi1[0:xi.size] = xi\n        m1 = zeros(nsize)\n        m1[0:xi.size] = m\n        m1[xi.size:] = inverse_measurement(m[0:3],z[:,c>n]).T.ravel()\n        s = G.shape[0]\n        G.resize((s+new,s+new))\n    else:\n        omega1=omega\n        xi1=xi\n        m1=m\n\n    J = jacobian_measurement(m1,c)\n    zhat = equation_measurement(m1,c)\n\n    for i in range(0,c.size):\n           j = c[i]\n           h = J[:,:,i]\n           dz = z[:,i]-zhat[:,i]\n\n           dz[1] = measure(dz[1])\n           dz = dz.reshape((2,1))\n           ind = hstack((r_[0:3],[2*j+1,2*j+2])).toarray().ravel()\n\n           Q1 = inv(Q)\n           xi1[ind] = xi1[ind]+ h.T@Q1@(dz+h@m1[ind].reshape((5,1))).flatten()\n           omega1[ix_(ind,ind)] = omega1[ix_(ind,ind)] + h.T@Q1@h\n\n    c = unique(c)\n    row = zeros(c.size)\n    col = c\n    data = ones(c.size)\n    nl = csr_matrix((data,(row,col)),shape=(G.shape[0],G.shape[0]),dtype=bool)\n    G = G + nl + nl.T\n\n    return xi1,omega1,m1,G\n\n\ndef measure(theta):\n                   tmp = theta%(2*pi)\n                   return tmp-minimum(floor(tmp/pi),1)*2*pi\n'"
ch12_the_sparse_extended_information_filter/src/python/motion.py,2,"b""from numpy import *\nfrom scipy.sparse import csr_matrix,csc_matrix,lil_matrix\nfrom scipy.linalg import inv,solve\nimport numpy as np\n\nfrom jacobian_motion import jacobian_motion\nfrom equation_motion import equation_motion\n\nfrom pdb import set_trace as bp\n\ndef motion(v,a,dt,m0,xi,omega,m,G):\n    n = xi.size\n    R = diag([8e-4,8e-4,1e-6])\n    J = jacobian_motion(m[2],v,a,dt)\n\n    psi = inv(J)-eye(3)\n    ind = 2*sort(m0) + 1\n    ind = vstack((ind,ind+1)).flatten(order='F')\n    ind  = hstack((r_[0:3],ind)).astype(int)\n    omega_s = omega[ix_(ind,r_[0:3])]\n    psi1 = omega_s@psi\n\n    lmbd = zeros([n,n])\n    lmbd[ix_(ind,r_[0:3])] = psi1;lmbd[ix_(r_[0:3],ind)]=lmbd[ix_(r_[0:3],ind)]+psi1.T\n    lmbd[0:3,0:3] =  lmbd[0:3,0:3] + psi.T@omega[0:3,0:3]@psi\n    phi = omega + lmbd\n\n    phiX = phi[ix_(r_[0:3],ind)]\n    k=zeros([n,n])\n    k[ix_(ind,ind)] = phiX.T@inv(inv(R)+phi[0:3,0:3])@phiX\n    omega1 = phi-k\n\n    dx = equation_motion(m[2],v,a,dt)\n    omega_s = omega1[ix_(ind,r_[0:3])]\n\n    xi1 = xi\n    xi1[ind] = xi1[ind] + omega_s@dx\n    xi1[ind] = xi1[ind] + (lmbd-k)[ind,:]@m\n    m1 = m\n    m1[0:3] = m1[0:3] + dx\n\n    if m0.size>0:\n        s,t = meshgrid(m0,m0)\n        s = s.flatten()\n        t = t.flatten()\n        edges = sort(np.vstack((s,t)),axis=0)\n        edges = unique(edges,axis=1)   #needs version >=1.13\n        #edges = np.vstack({tuple(row) for row in edges.T}).T\n        edges = edges[:,edges[0,:]-edges[1,:]!=0]\n        if edges.shape[1]>0:\n            sg = G.shape[0]\n\n            nl = csr_matrix((ones(edges.shape[1]),(edges[0,:],edges[1,:])),shape=(sg,sg),dtype=bool)\n            G = G + nl + nl.T\n\n    return xi1,omega1,m1,G\n"""
ch12_the_sparse_extended_information_filter/src/python/seif.py,0,"b'from numpy import *\nimport scipy.linalg as la\nfrom scipy.sparse import csr_matrix, save_npz\nimport scipy.io as sio\nimport os\nimport time as timechr\n\nimport matplotlib.pyplot as plt\nfrom motion import motion\nfrom estimate import estimate\nfrom correspondence import correspondence\nfrom measurement import measurement\nfrom sparsification import sparsification\n\nfrom pdb import set_trace as bp\n\ndef seif():\n    filename1 = \'z.mat\'\n    filename2 = \'aa3_dr.mat\'\n    filename3 = \'aa3_lsr2.mat\'\n    filename4 = \'c_5000.mat\'\n    include_dir = \'./data/\'\n\n    z_contents = sio.loadmat(include_dir +filename1)\n    z = z_contents[\'z\'];\n\n    z_contents = sio.loadmat(include_dir +filename2)\n    speed = z_contents[\'speed\'].ravel();\n    steering = z_contents[\'steering\'].ravel();\n    time = z_contents[\'time\'].ravel();\n\n    z_contents = sio.loadmat(include_dir +filename3)\n    timeLsr = z_contents[\'TLsr\'].ravel();\n    L = size(timeLsr,0);\n\n    z_contents = sio.loadmat(include_dir +filename4)\n    corresp = z_contents[\'corresp\']\n    Lc = size(corresp,0);\n\n    del z_contents\n\n    dt = 25e-3\n    G = csr_matrix((1,1),dtype=bool)\n    Q = diag([5.0,0.02])\n    m = zeros(3)\n    xi = zeros(3)\n    omega = 10e4*eye(3)\n    m0=zeros(0)\n\n    #max active landmarks\n    N = 20\n    plt.ion()\n\n    fig,ax = plt.subplots(1,1)\n    ax.set_aspect(\'equal\')\n    ax.set_xlim(-100, 300)\n    ax.set_ylim(-50, 350)\n    ax.hold(True)\n    plt.show(False)\n    plt.draw()\n    #background = fig.canvas.copy_from_bbox(ax.bbox)\n    line1 = ax.plot(0,0,\'b-\')[0]\n    line2 = ax.plot(-1000,1000,\'ro\',markersize=2)[0]\n\n    poses = zeros([3,5000])\n    stindex=0\n    j=searchsorted(timeLsr,time[stindex])\n    timechr.sleep(3)\n    t1 = timechr.time()\n\n    for i in range(stindex, time.shape[0]):\n    #for i in range(stindex, 10000):\n        t3= timechr.time()\n\n        if i>stindex and i%5000==0:\n            save(include_dir +\'poses_\'+str(i),poses)\n            save(include_dir +\'landmarks_\'+str(i),m)\n            save(include_dir +\'xi_\'+str(i),xi)\n            save(include_dir +\'omega_\'+str(i),omega)\n            save(include_dir +\'m0_\'+str(i),m0)\n            save_npz(include_dir +\'G_\', G)\n\n        xi,omega,m,G = motion(speed[i],steering[i],dt,m0,xi,omega,m,G)\n\n        m = estimate(m0,xi,omega,m)\n\n        while j<L and timeLsr[j]<time[i]+dt*1000:\n           \n           z1=z[0:2,nonzero(z[0,:,j]),j].transpose((0,2,1))[:,:,0]\n           if z1.size >0:\n               co = correspondence(z1,m0,omega,m,G)\n               xi,omega,m,G = measurement(z1,co,xi,omega,m,G)\n           j+=1\n\n           if co.size>0:\n               n=(xi.size-3)//2\n               m0a = setdiff1d(m0,co)\n               #returns float when m0 empty\n               tq = hstack((m0a,unique(co))).astype(int)\n               tq = tq[max(0,tq.size-N):]\n               m1 = setdiff1d(m0,tq)\n               m1 = union1d(m1,setdiff1d(co,tq))\n               m0 = tq\n               if m1.size>0:\n                   xi,omega,G = sparsification(m0,m1,xi,omega,m,G)\n\n        print(""\\x1b[2J\\x1b[H"")\n        t2=timechr.time()\n        print(\'iter: \'+str(i))\n        print(\'iter time: {0:.5f}\'.format(t2-t3))\n        print(\'avg: {0:.5f}\'.format((t2-t1)/(i+1)))\n        poses[:,i%5000]=m[0:3]\n\n        if i%5000==4999:\n            line2.set_data(m[3::2],m[4::2])\n            line1.set_xdata(hstack((line1.get_xdata(),poses[0,:])))\n            line1.set_ydata(hstack((line1.get_ydata(),poses[1,:])))\n            #fig.canvas.restore_region(background)\n            #ax.draw_artist(line1)\n            #ax.draw_artist(line2)\n            fig.canvas.blit(ax.bbox)\n            fig.canvas.draw()\n            #plt.show()\n            #fig.canvas.flush_events()\n\n\nif __name__ == ""__main__"":\n    # execute only if run as a script\n    import cProfile\n    pr = cProfile.Profile()\n    pr.enable()\n    seif()\n    pr.disable()\n    pr.print_stats(sort=\'cumtime\')\n'"
ch12_the_sparse_extended_information_filter/src/python/sparsification.py,0,"b""from numpy import *\nfrom scipy.sparse import csr_matrix\nfrom scipy.linalg import solve\n\nfrom pdb import set_trace as bp\n\ndef sparsification(m0,m1,xi,omega,m,G):\n    sg = G.shape[0]\n    ol = csr_matrix((ones(m1.size),(zeros(m1.size),m1)),shape=(sg,sg),dtype=bool)\n    G = G - ol - ol.T\n    G = G.astype(bool)\n    s,t = meshgrid(union1d(m0,m1),m1)\n    s = s.flatten()\n    t = t.flatten()\n    edges = sort(vstack((s,t)),axis=0)\n    edges = unique(edges,axis=1)   #needs version >=1.13\n    #edges = vstack({tuple(row) for row in edges.T}).T\n    edges = edges[:,edges[0,:]-edges[1,:]!=0]\n    nl = csr_matrix((ones(edges.shape[1]),(edges[0,:],edges[1,:])),shape=(sg,sg),dtype=bool)\n    G = G + nl + nl.T\n\n    m0 = sort(m0)\n    m1 = sort(m1)\n    m0 = 2*m0 + 1\n    m0 = vstack((m0,m0+1)).flatten(order='F')\n    m1 = 2*m1 + 1\n    m1 = vstack((m1,m1+1)).flatten(order='F')\n\n    omega2 = omega[ix_(hstack((hstack((r_[0:3],m0)),m1)),m1)]\n    l1 = omega2.dot(solve(omega[ix_(m1,m1)],omega2.T))\n\n    omega3 = omega[ix_(hstack((hstack((r_[0:3],m0)),m1)),hstack((r_[0:3],m1)))]\n    l2 = omega3.dot(solve(omega[ix_(hstack((r_[0:3],m1)),hstack((r_[0:3],m1)))],omega3.T))\n\n    omega4 = omega[:,r_[0:3]]\n    l3 = omega4.dot(solve(omega[ix_(r_[0:3],r_[0:3])],omega4.T))\n\n    omega1 = copy(omega)\n    omega1[ix_(hstack((hstack((r_[0:3],m0)),m1)),hstack((hstack((r_[0:3],m0)),m1)))] -= l1\n    omega1[ix_(hstack((hstack((r_[0:3],m0)),m1)),hstack((hstack((r_[0:3],m0)),m1)))] += l2\n    omega1 -= l3\n\n    omega1[ix_(r_[0:3],m1)] = 0\n    omega1[ix_(m1,r_[0:3])] = 0\n\n    xi1 = xi + (omega1-omega)@m\n\n    return xi1,omega1,G\n"""
