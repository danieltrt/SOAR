file_path,api_count,code
create_tag.py,0,"b'""""""Bump version and create tag in git.""""""\nfrom pathlib import Path\n\nfrom git import Repo\n\n\ndef main() -> None:\n    """"""Run the script.""""""\n    repo = Repo()\n    assert not repo.is_dirty(), ""please commit or stash all other changes""\n    assert repo.active_branch.name == ""master"", ""only tag versions on master""\n\n    # find out the version number\n    tags_minor_versions = [tag.name.split(""."")[-1] for tag in repo.tags]\n    minor_versions_as_ints = [int(mv) for mv in tags_minor_versions if mv.isdigit()]\n    latest_minor_version = max(minor_versions_as_ints)\n    new_version = f""0.2.{latest_minor_version + 1}""\n    print(f""new version will be: {new_version}"")\n\n    # change version in setup.py\n    setup_path = Path(""setup.py"")\n    with setup_path.open(""r"") as fhandle:\n        new_content = fhandle.read().replace(""0.3.0.dev1"", new_version)\n    with setup_path.open(""w"") as fhandle:\n        fhandle.write(new_content)\n    print(""modified setup.py"")\n\n    # commit change\n    git = repo.git\n    branch_name = f""releases/{new_version}""\n    print(f""commit to branch {branch_name}"")\n    git.checkout(""-b"", branch_name)\n    repo.index.add([""setup.py""])\n    repo.index.commit(""Bump version"")\n\n    # create tag and push\n    tag_name = f""v{new_version}""\n    repo.create_tag(tag_name)\n    print(f""git push origin {tag_name} {branch_name}"")\n    git.push(""origin"", tag_name, branch_name)\n\n    # clean up\n    git.checkout(""master"")\n    git.branch(""-D"", branch_name)\n    print(f""Deleted branch {branch_name}"")\n\n\nif __name__ == ""__main__"":\n    main()\n'"
gen_pyi.py,0,"b'""""""Generate pyi files from pyi.in files""""""\nfrom pathlib import Path\nimport json\n\nfrom tools.code_template import CodeTemplate\n\nWARNING_STR = """"""# ========================================================= #\n#      This file has been generated automatically!!!!\n#                     DO NOT EDIT IT!\n# ========================================================= #\n""""""\n\n\ndef main() -> None:\n    variables_path = Path(""."") / ""matplotlib-stubs"" / ""shared.json""\n    pattern_path = Path(""."") / ""matplotlib-stubs"" / ""pyplot.pyi.in""\n    output_path = Path(""."") / ""matplotlib-stubs"" / ""pyplot.pyi""\n\n    generator = CodeTemplate.from_file(pattern_path)\n    with variables_path.open(""r"") as fp:\n        variables = json.load(fp)\n    with output_path.open(""w"") as fp:\n        fp.write(WARNING_STR + generator.substitute(variables))\n\n\nif __name__ == ""__main__"":\n    main()\n'"
setup.py,0,"b'""""""Package setup""""""\nfrom setuptools import setup\n\nfrom gen_pyi import main as gen_pyi\n\nwith open(""README.md"", ""r"") as fh:\n    long_description = fh.read()\n\n# generate pyi files from pyi.in files\ngen_pyi()\n\nsetup(\n    name=""data-science-types"",\n    version=""0.3.0.dev1"",\n    author=""PAL"",\n    description=""Type stubs for Python machine learning libraries"",\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    package_data={\n        ""matplotlib-stubs"": [\n            ""__init__.pyi"",\n            ""artist.pyi"",\n            ""axes.pyi"",\n            ""backend_bases.pyi"",\n            ""collections.pyi"",\n            ""color.pyi"",\n            ""cm.pyi"",\n            ""font_manager.pyi"",\n            ""image.pyi"",\n            ""legend.pyi"",\n            ""patheffects.pyi"",\n            ""pyplot.pyi"",\n            ""style.pyi"",\n            ""text.pyi"",\n            ""transforms.pyi"",\n        ],\n        ""numpy-stubs"": [""__init__.pyi"", ""linalg.pyi"", ""ma.pyi"", ""random.pyi"", ""testing.pyi""],\n        ""pandas-stubs"": [""__init__.pyi"", ""testing.pyi""],\n        ""pandas-stubs.core"": [\n            ""__init__.pyi"",\n            ""frame.pyi"",\n            ""indexing.pyi"",\n            ""series.pyi"",\n            ""strings.pyi"",\n        ],\n        ""pandas-stubs.core.groupby"": [""__init__.pyi"", ""generic.pyi""],\n        ""pandas-stubs.core.indexes"": [""__init__.pyi"", ""base.pyi"", ""frozen.pyi"", ""multi.pyi""],\n    },\n    packages=[\n        ""matplotlib-stubs"",\n        ""numpy-stubs"",\n        ""pandas-stubs"",\n        ""pandas-stubs.core"",\n        ""pandas-stubs.core.groupby"",\n        ""pandas-stubs.core.indexes"",\n    ],\n    python_requires="">=3.6"",\n    # use `pip install data-science-types[dev]` to install development packages\n    extras_require={""dev"": [""black"", ""mypy"", ""flake8"", ""flake8-pyi""]},\n    classifiers=[  # classifiers can be found here: https://pypi.org/classifiers/\n        ""Programming Language :: Python :: 3"",\n        ""License :: OSI Approved :: GNU General Public License v3 (GPLv3)"",\n        ""Typing :: Typed"",\n    ],\n    zip_safe=False,\n)\n'"
tests/matplotlib_test.py,4,"b'from typing import List\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport pandas as pd\n\nfig: plt.Figure\nplot: plt.Axes\nplot_list: List[plt.Axes]\nplot_grid: List[List[plt.Axes]]\n\nfig, plot = plt.subplots()\nplot.hist(np.random.randn(100), bins=np.linspace(0, 1, 100))\n\nfig, plot_grid = plt.subplots(nrows=2, ncols=2)\nfig, plot_list = plt.subplots(nrows=2)\nfig, plot_list = plt.subplots(ncols=2)\nfig, plot_grid = plt.subplots(squeeze=False)\nfig, plot_grid = plt.subplots(nrows=2, squeeze=False)\nfig, plot_grid = plt.subplots(ncols=2, squeeze=False)\nfig, plot_grid = plt.subplots(nrows=2, ncols=2, squeeze=False)\n\nplt.xticks(ticks=[0, 1], labels=[""foo"", ""bar""])\nplt.yticks(ticks=[0, 1], labels=[""foo"", ""bar""])\nplt.xticks(ticks=np.array([0, 1]), labels=np.array([""foo"", ""bar""]))\nplt.xticks(ticks=pd.Series([0, 1]), labels=pd.Series([""foo"", ""bar""]))\nplt.xlim(0, 1)\nplt.ylim(0, 1)\nplt.fill_between((0, 1), y1=(0, 1), y2=(1, 1), where=[True], interpolate=False, data=[])\n\n\ndef test_data_types() -> None:\n    x = np.linspace(0, 2)\n    y = np.exp(x)\n    plt.plot(x, y)\n'"
tests/numpy_test.py,75,"b'""""""Tests for numpy""""""\nfrom __future__ import annotations\n\nfrom typing import List, Sequence, TypeVar, Type\n\nimport numpy as np\n\nDType = TypeVar(\n    ""DType"", np.bool_, np.float32, np.float64, np.int8, np.int16, np.int32, np.int64, np.str_\n)\n\n\ndef assert_dtype(array: np.ndarray[DType], dtype: Type[DType]) -> None:\n    assert array.dtype.type is dtype\n\n\n# these variables are available to all other functions\na: np.ndarray[np.float64] = np.array([3.0, 2.0])\na = a.astype(dtype=float)\nb: np.ndarray[np.bool_] = a == a\nc: np.ndarray[np.int64] = np.array([[2, 3], [3, 4]])\nd: np.ndarray[np.int32] = np.array([[1, -2], [3, 5]], dtype=np.int32)\ne: np.ndarray[np.float32] = a.astype(np.float32)\n\n\ndef test_mean_std() -> None:\n    f: np.ndarray[np.float32] = np.std(e, axis=0, keepdims=True)\n    g: np.ndarray[np.float64] = np.std(c, axis=0, keepdims=True)\n    h1: np.float64 = np.mean(c)\n    i1: float = np.mean(c)\n    j1: np.float32 = np.mean(e)\n    k1: float = np.mean(e)\n    l1: np.float64 = np.mean(b)\n    # member method\n    h2: np.float64 = c.mean()\n    i2: float = c.mean()\n    j2: np.float32 = e.mean()\n    k2: float = e.mean()\n    l2: np.float64 = b.mean()\n\n\ndef test_random_choice() -> None:\n    f: int = np.random.choice(7)\n    g: np.ndarray[np.int64] = np.random.choice(7, size=1)\n    h: np.ndarray[np.int64] = np.random.choice(range(7), size=1)\n    i: np.ndarray[np.int16] = np.random.choice(np.array([3, 7], dtype=np.int16), size=3)\n    assert_dtype(i, np.int16)\n\n\ndef test_non_numeric() -> None:\n    f: np.ndarray[np.str_] = np.array([""hello"", ""world""])\n    g: np.ndarray[np.bool_] = np.array([True, False, True])\n\n\ndef test_division() -> None:\n    f1: np.ndarray[np.float64] = d / c\n    g1: np.ndarray[np.float32] = e / e\n    h1: np.ndarray[np.float64] = e / c\n\n    f2: np.ndarray[np.float64] = np.divide(d, c)\n    g2: np.ndarray[np.float32] = np.divide(e, e)\n    h2: np.ndarray[np.float64] = np.divide(e, c)\n    i2: np.float64 = np.divide(60, 5)\n    j2: np.ndarray[np.float64] = np.divide((60, 5, 6), 5)\n    k2: np.ndarray[np.float64] = np.divide(c, 5)\n\n\ndef test_astype() -> None:\n    f1: np.ndarray[np.float64] = e.astype(float)\n    g1: np.ndarray[np.float64] = e.astype(np.float64)\n    h1: np.ndarray[np.bool_] = c.astype(bool)\n    i1: np.ndarray[np.int64] = d.astype(int)\n    j1: np.ndarray[np.int64] = d.astype(np.int64)\n    k1: np.ndarray[np.int32] = e.astype(np.int32)\n    l1: np.ndarray[np.str_] = c.astype(str)\n\n    f2: np.ndarray[np.float64] = np.asarray(e, float)\n    g2: np.ndarray[np.float64] = np.asarray(e, np.float64)\n    h2: np.ndarray[np.bool_] = np.asarray(c, bool)\n    i2: np.ndarray[np.int64] = np.asarray(d, int)\n    j2: np.ndarray[np.int64] = np.asarray(d, np.int64)\n    k2: np.ndarray[np.int32] = np.asarray(e, np.int32)\n    l2: np.ndarray[np.str_] = np.asarray(c, str)\n\n\ndef test_tolist() -> None:\n    # tolist() actually returns a list, but we have to type it as Sequence because they\'re covariant\n    f: Sequence[int] = c.tolist()\n    g: Sequence[float] = e.tolist()\n\n\ndef test_reducing_funcs() -> None:\n    """"""The behavior of these functions depends on whether an axis is specified""""""\n    sum1: np.int32 = np.sum(d)\n    sum2: np.int32 = np.sum(d, axis=None)\n    sum3: np.ndarray[np.int32] = np.sum(d, axis=0)\n\n    max1: np.int32 = np.max(d)\n    max2: np.int32 = np.max(d, axis=None)\n    max3: np.ndarray[np.int32] = np.max(d, axis=0)\n\n    min1: np.int32 = np.min(d)\n    min2: np.int32 = np.min(d, axis=None)\n    min3: np.ndarray[np.int32] = np.min(d, axis=0)\n\n    prod1: np.int32 = np.prod(d)\n    prod2: np.int32 = np.prod(d, axis=None)\n    prod3: np.ndarray[np.int32] = np.prod(d, axis=0)\n\n\ndef test_repeat() -> None:\n    f: np.ndarray[np.int16] = np.repeat(np.int16(5), 3)\n    g: np.ndarray[np.int64] = np.repeat(5, 3)\n\n\ndef test_concatenate() -> None:\n    d2: np.ndarray[np.int32] = np.concatenate([d, d], axis=1)\n    d3: np.ndarray[np.int32] = np.concatenate((d, d), axis=0)\n    scalar: np.float32 = np.float32(3.0)\n    assert isinstance(scalar, np.float32)\n\n\ndef test_at_least_2d() -> None:\n    arr: np.ndarray[np.float64] = np.atleast_2d(3.0)\n    assert isinstance(arr, np.ndarray)\n    assert_dtype(arr, np.float64)\n\n    a: List[np.ndarray[np.int64]] = np.atleast_2d(1, [1, 2], [[1, 2]], 1)\n    assert isinstance(a, list)\n\n\ndef test_where() -> None:\n    f: np.ndarray[np.int64] = np.where(c == 2, c, d)\n    g: np.ndarray[np.int64] = np.where(True, c, d)\n    h1: np.ndarray[np.int64] = np.where(True, 2, 3)\n    h2: np.ndarray[np.float64] = np.where(True, 2.0, 3)\n    i: np.ndarray[np.int64] = np.where(c == 2, c, 3)\n    j: np.ndarray[np.int32] = np.where(c == 2, 2, d)\n'"
tests/pandas_test.py,1,"b'from __future__ import annotations\nfrom typing import TypeVar, Type\n\nimport pandas as pd\nimport numpy as np\n\nT = TypeVar(""T"", pd.DataFrame, pd.Series)\n\n\ndef assert_type(v: T, t: Type[T]) -> None:\n    assert isinstance(v, t)\n\n\na: pd.DataFrame = pd.DataFrame([[1, 2, 3], [1, 2, 3]], columns=[""a"", ""b"", ""c""])\ndf: pd.DataFrame = pd.DataFrame(\n    [[1.0, 2.0], [4.0, 5.0], [7.0, 8.0]],\n    index=[""cobra"", ""viper"", ""sidewinder""],\n    columns=[""max_speed"", ""shield""],\n)\nfd: pd.DataFrame = pd.DataFrame(\n    [[1.0, 2.0], [4.0, 5.0], [7.0, 8.0]], columns=[""max_speed"", ""shield""],\n)\ns: pd.Series[float] = df[""shield""].copy()\n\n\ndef test_getitem() -> None:\n    b: pd.Series = a[""a""]\n    c: pd.DataFrame = a[[""a"", ""b""]]\n    d: pd.DataFrame = a[np.array([""a"", ""b""])]\n    e: pd.DataFrame = a[pd.Series([""a"", ""b""])]\n    f: pd.DataFrame = a[pd.Index([""a"", ""b""])]\n\n\ndef test_frame_loc() -> None:\n    b: pd.DataFrame = df.loc[s > 6]\n    c: float = df.loc[""cobra"", ""shield""]\n    d: pd.DataFrame = df.loc[df[""shield""] > 6, [""max_speed""]]\n    e: pd.DataFrame = df.loc[[""cobra"", ""viper""]]\n    assert_type(e, pd.DataFrame)\n    df.loc[[""viper"", ""sidewinder""], [""shield""]] = 50.0\n    df.loc[""cobra""] = 10.0\n    df.loc[[""cobra"", ""viper""]] = df\n\n    fd.loc[[0, 1], ""shield""] = 4.0\n\n\ndef test_series_loc() -> None:\n    b: float = s.loc[""cobra""]\n    c: pd.Series = s.loc[s > 6]\n    s.loc[""cobra""] = 3.0\n    s.loc[[""cobra"", ""viper""]] = 3.0\n\n\ndef test_indexing_with_df() -> None:\n    b: pd.DataFrame = df[s.to_frame().isin([df])]\n    assert_type(b, pd.DataFrame)\n\n\ndef test_frame_iloc() -> None:\n    b: pd.Series = df.iloc[0]\n    c: float = df.iloc[0, 0]\n    d: pd.DataFrame = df.iloc[[0, 0]]\n    e: pd.DataFrame = df.iloc[:2]\n    f: pd.DataFrame = df.iloc[[0, 1], [0, 1]]\n    g: pd.DataFrame = df.iloc[1:3, 0:3]\n    h: pd.Series = df.iloc[:, 1]\n    i: pd.Series = df.iloc[1, :]\n    assert_type(i, pd.Series)\n    df.iloc[0] = s\n    df.iloc[0, 0] = 3.0\n    df.iloc[[0, 0]] = df\n    df.iloc[:2] = df\n    df.iloc[[0, 1], [0, 1]] = df\n    df.iloc[1:3, 0:3] = df\n    df.iloc[:, 1] = s\n    df.iloc[1, :] = s\n\n\ndef test_series_iloc() -> None:\n    b: float = s.iloc[0]\n    c: pd.Series[float] = s.iloc[[0, 1]]\n    d: pd.Series[float] = s.iloc[:2]\n\n\ndef test_multiindex() -> None:\n    tuples = [(""bar"", ""one""), (""bar"", ""two""), (""baz"", ""one"")]\n    index: pd.MultiIndex = pd.MultiIndex.from_tuples(tuples, names=[""first"", ""second""])\n'"
tools/__init__.py,0,b''
tools/code_template.py,0,"b'""""""Code taken from pytorch\n\nhttps://github.com/pytorch/pytorch/blob/385165ec674b764eb42ffe396f98fadd08a513eb/aten/src/ATen/code_template.py\n""""""\nfrom pathlib import Path\nimport re\nfrom typing import Optional, Dict, Union, List\n\n\nReplacementType = Union[str, int, List[Union[str, int]]]\n\n\nclass CodeTemplate:\n    """"""Match $identifier or ${identifier} and replace with value in env\n\n    If this identifier is at the beginning of whitespace on a line and its value is a list then it\n    is treated as block subsitution by indenting to that depth and putting each element of the list\n    on its own line. If the identifier is on a line starting with non-whitespace and a list\n    then it is comma separated. ${,foo} will insert a comma before the list. If this list is not\n    empty and ${foo,} will insert one after.\n    """"""\n\n    # Python 2.7.5 has a bug where the leading (^[^\\n\\S]*)? does not work,\n    # workaround via appending another [^\\n\\S]? inside\n\n    substitution_str = r""(^[^\\n\\S]*[^\\n\\S]?)?\\$([^\\d\\W]\\w*|\\{,?[^\\d\\W]\\w*\\,?})""\n\n    # older versions of Python have a bug where \\w* does not work,\n    # so we need to replace with the non-shortened version [a-zA-Z0-9_]*\n    # https://bugs.python.org/issue18647\n\n    substitution_str = substitution_str.replace(r""\\w"", r""[a-zA-Z0-9_]"")\n\n    subtitution = re.compile(substitution_str, re.MULTILINE)\n\n    @classmethod\n    def from_file(cls, filename: Path) -> ""CodeTemplate"":\n        with filename.open(""r"") as f:\n            return cls(f.read())\n\n    def __init__(self, pattern: str):\n        self.pattern = pattern\n\n    @staticmethod\n    def indent_lines(indent: str, v: List[Union[str, int]], after: str) -> str:\n        return ""\\n"".join([indent + l + after for e in v for l in str(e).splitlines()])  # .rstrip()\n\n    def substitute(\n        self, env_: Optional[Dict[str, ReplacementType]] = None, **kwargs: ReplacementType\n    ) -> str:\n        env = env_ or {}\n\n        def replace(match: ""re.Match"") -> str:\n            indent = match.group(1)\n            key = match.group(2)\n            comma_before = """"\n            comma_after = """"\n            if key[0] == ""{"":\n                key = key[1:-1]\n                if key[0] == "","":\n                    comma_before = "", ""\n                    key = key[1:]\n                if key[-1] == "","":\n                    comma_after = "", ""\n                    key = key[:-1]\n\n            # lookup\n            v = kwargs[key] if key in kwargs else env[key]\n\n            if indent is not None:\n                if not isinstance(v, list):\n                    v = [v]\n                return self.indent_lines(indent, v, comma_after.rstrip())\n            elif isinstance(v, list):\n                middle = "", "".join([str(x) for x in v])\n                if len(v) == 0:\n                    return middle\n                return comma_before + middle + comma_after\n            else:\n                return str(v)\n\n        return self.subtitution.sub(replace, self.pattern)\n\n\nif __name__ == ""__main__"":\n    pattern = """"""\\\n    def plot($text_args, $label_args)\n    def bar(\n        $text_args\n        $label_args\n    )\n    def scatter(\n        ${text_args,}\n        ${label_args,}\n    )\n    """"""\n    c = CodeTemplate(pattern)\n    print(\n        c.substitute(\n            text_args=[""fontsize: int"", ""tickness: float""],\n            label_args=[""size: float"", ""color: str""],\n        )\n    )\n'"
