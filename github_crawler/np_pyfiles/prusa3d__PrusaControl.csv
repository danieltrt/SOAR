file_path,api_count,code
analyzer.py,2,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport numpy as np\nfrom PyQt4.QtCore import QObject\nfrom PyQt4.QtCore import QThread\nfrom PyQt4.QtCore import pyqtSignal\n\n__author__ = \'Tibor Vavra\'\n\n\nclass Analyzer(object):\n    def __init__(self, controller):\n        self.controller = controller\n        self.analyzer_runner = AnalyzerRunner(controller)\n        self.analyzer_runner_thread = QThread()\n        self.finish_function = None\n        self.send_result_function = None\n\n    def make_analyze(self, finish_function, result_function):\n        self.finish_function = finish_function\n        self.send_result_function = result_function\n        if self.analyzer_runner.is_running:\n            print(""cancel old analyze"")\n            self.cancel_analyz()\n\n        print(""start new analyze"")\n        #self.analyzer_runner.whole_scene = whole_scene\n        self.analyzer_runner.moveToThread(self.analyzer_runner_thread)\n        self.analyzer_runner_thread.started.connect(self.analyzer_runner.start_analyze)\n\n        self.analyzer_runner.finished.connect(self.set_finished_read)\n        self.analyzer_runner.send_result.connect(self.set_result)\n\n        self.analyzer_runner.is_running = True\n        self.analyzer_runner_thread.start()\n\n\n    def cancel_analyz(self):\n        self.analyzer_runner.is_running = False\n        self.analyzer_runner_thread.quit()\n        self.analyzer_runner_thread.wait()\n\n        self.analyzer_runner_thread = QThread()\n        self.analyzer_runner = AnalyzerRunner(self.controller)\n\n\n    def set_finished_read(self):\n        print(""analyze done"")\n        if self.finish_function:\n            self.finish_function()\n\n    def set_result(self, result):\n        print(result)\n        if self.send_result_function:\n            self.send_result_function(result)\n\n\n\n    \'\'\'\n    def make_analyze(self, whole_scene):\n        #Some initialization\n        result = []\n        support = {\n            \'name\': \'Support\',\n            \'result\': False,\n            \'message\': \'\',\n            \'gui_name\': \'supportCheckBox\'\n        }\n        if self.is_support_needed(whole_scene):\n            support[\'result\'] = True\n            support[\'message\'] = ""Some places in scene is hard to print without support. We are recommending to turn Support material parameter on""\n        result.append(support)\n\n        brim = {\n            \'name\': \'Brim\',\n            \'result\': False,\n            \'message\': \'\',\n            \'gui_name\': \'brimCheckBox\'\n        }\n        if self.is_brim_needed(whole_scene):\n            brim[\'result\'] = True\n            brim[\'message\'] = ""Contact area between printed object and printing surface is too small, it is possible that object will be detach during printing. We are recommending to turn Brim parametr on""\n        result.append(brim)\n\n        return result\n\n\n\n    def is_support_needed(self, scene):\n        #detect angles between normal vector of face and normal of printing surface\n        #angel bigger than something is problem\n        data = self.controller.scene.get_faces_by_smaller_angel_normal_and_vector(np.array([0.,0.,-1.]), 35., scene)\n        #something returned? problematic printing without support, recommended to turn it on\n        if len(data) == 0:\n            return False\n        else:\n            return True\n\n        return True\n\n    def is_brim_needed(self, scene):\n        #detect small area on printing surface, it is need to generate brim\n        #something returned? problematic printing without brim, recommended to turn it on\n        return self.controller.scene.get_contact_faces_with_area_smaller_than(2., scene)\n    \'\'\'\n\n\nclass AnalyzerRunner(QObject):\n    finished = pyqtSignal()\n    send_result = pyqtSignal(dict)\n\n    def __init__(self, controller):\n        super(AnalyzerRunner, self).__init__()\n        self.is_running = False\n        self.controller = controller\n        self.whole_scene = None\n\n    def start_analyze(self):\n        print(""get whole scene"")\n        self.whole_scene = self.controller.scene.get_whole_scene_in_one_mesh()\n        print(""analyze started"")\n        result = {}\n        if self.is_running:\n            if self.is_support_needed(self.whole_scene):\n                result[\'support\'] = True\n            else:\n                result[\'support\'] = False\n        else:\n            result = {}\n        if self.is_running:\n            if self.is_brim_needed(self.whole_scene):\n                result[\'brim\'] = True\n            else:\n                result[\'brim\'] = False\n        else:\n            result = {}\n        self.is_running = False\n        self.send_result.emit(result)\n\n        self.finished.emit()\n\n\n    def is_support_needed(self, scene):\n        # detect angles between normal vector of face and normal of printing surface\n        # angel bigger than something is problem\n        data = self.controller.scene.get_faces_by_smaller_angel_normal_and_vector(np.array([0., 0., -1.]), 35., scene)\n        # something returned? problematic printing without support, recommended to turn it on\n        if len(data) == 0:\n            return False\n        else:\n            return True\n        return True\n\n    def is_brim_needed(self, scene):\n        # detect small area on printing surface, it is need to generate brim\n        # something returned? problematic printing without brim, recommended to turn it on\n        return self.controller.scene.get_contact_faces_with_area_smaller_than(2., scene)\n\n\n\n\n\n\n'"
controller.py,0,"b'# -*- coding: utf-8 -*-\n#import json\nimport json\nimport logging\n\n#import functools\n\n\nimport time\nimport webbrowser\n#from pprint import pprint\nfrom configparser import RawConfigParser\nfrom pprint import pprint\n\nfrom shutil import copyfile, Error\n\nimport numpy\n#import pyrr\nimport urllib3\nfrom PyQt4.QtCore import QObject\nfrom PyQt4.QtCore import QTranslator, Qt, QPoint\n#from PyQt4 import QtGui\nfrom PyQt4.QtGui import QApplication\nfrom zeroconf import Zeroconf, ServiceBrowser, ServiceInfo\n\nimport sceneData\nfrom analyzer import Analyzer\nfrom gcode import GCode\nfrom gui import PrusaControlView, QMessageBox\nfrom parameters import AppParameters, PrintingParameters\nfrom projectFile import ProjectFile\nfrom sceneData import AppScene, ModelTypeStl\n#from sceneRender import GLWidget\nfrom copy import deepcopy\n\nfrom itertools import compress\n\n\n#import xml.etree.cElementTree as ET\n#from zipfile import ZipFile\n\n#from PyQt4 import QtCore, QtGui\n\n#Mesure\nfrom slicer import SlicerEngineManager\n\n__author__ = \'Tibor Vavra\'\n\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        logging.debug(\'%s function took %0.3f ms\' % (f.func_name, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\n\nclass MyListener(object):\n\n    def __init__(self, controller):\n        pass\n        self.controller = controller\n\n    def remove_service(self, zeroconf, type, name):\n        print(""Service %s removed"" % (name,))\n        print(""FIXME: Remove printer from dropdown menu here"")\n        # self.controlview.printerCombo.removeItem(???) # FIXME: Remove the correct one\n        # Do we ever get remove_service notices when a printer is shut down?\n\n    def add_service(self, zeroconf, type, name):\n        info = zeroconf.get_service_info(type, name)\n        print(""Service %s added, service info: %s"" % (name, info))\n\n        # Try zeroconf cache first\n        info = ServiceInfo(type, name, properties = {})\n        for record in zeroconf.cache.entries_with_name(name.lower()):\n            info.update_record(zeroconf, time.time(), record)\n        for record in zeroconf.cache.entries_with_name(info.server):\n            info.update_record(zeroconf, time.time(), record)\n            if info.address and info.address[:2] != b\'\\xa9\\xfe\': # 169.254.x.x addresses are self-assigned; reject them\n                break\n        # Request more data if info from cache is not complete\n        if not info.address or not info.port:\n            info = zeroconf.get_service_info(type, name)\n            if not info:\n                print(""Could not get information about %s"" % name)\n                return\n        if info.address and info.port:\n            address = \'.\'.join(map(lambda n: str(n), info.address))\n\n        self.controller.list_of_printing_services.add(address)\n\n\n\nclass Controller(QObject):\n    def __init__(self, app, local_path=\'\', progress_bar=None):\n        super(Controller, self).__init__()\n        logging.info(\'Local path: \' + local_path)\n        self.view = []\n\n        #this flag is only for development only, Development = True, Production = False\n        self.development_flag = False\n        progress_bar(10)\n\n        self.app_config = AppParameters(self, local_path)\n\n        self.printing_parameters = PrintingParameters(self.app_config, self)\n        progress_bar(30)\n\n        self.analyzer = Analyzer(self)\n        self.gcode = None\n\n        #looking for printing services\n        self.zeroconf = Zeroconf()\n        self.listener = MyListener(self)\n        self.browser = ServiceBrowser(self.zeroconf, ""_octoprint._tcp.local."", self.listener)\n\n        self.default_printing_service = None\n        self.list_of_printing_services = set()\n        self.print_on_service = False\n\n        self.printing_settings = {}\n        self.settings = {}\n        if not self.settings:\n            self.settings[\'debug\'] = self.app_config.config.getboolean(\'settings\', \'debug\')\n            self.settings[\'automatic_placing\'] = self.app_config.config.getboolean(\'settings\', \'automatic_placing\')\n            self.settings[\'language\'] = self.app_config.config.get(\'settings\', \'language\')\n            self.settings[\'printer\'] = self.app_config.config.get(\'settings\', \'printer\')\n            self.settings[\'printer_type\'] = self.app_config.config.get(\'settings\', \'printer_type\')\n            self.settings[\'analyze\'] = self.app_config.config.getboolean(\'settings\', \'analyze\')\n            self.settings[\'automatic_update_parameters\'] = self.app_config.config.getboolean(\'settings\', \'automatic_update_parameters\')\n\n            self.settings[\'toolButtons\'] = {\n                \'selectButton\': False,\n                \'moveButton\': False,\n                \'rotateButton\': False,\n                \'scaleButton\': False,\n                \'supportButton\': False\n        }\n\n        self.actual_printer = deepcopy(self.settings[\'printer\'])\n        self.actual_printer_mod = """"\n\n        self.gcode_help_button_pressed = False\n\n        self.enumeration = {\n            \'language\': {\n                \'cs_CZ\': \'Czech\',\n                \'en_US\': \'English\',\n                \'es_ES\': \'Spanish\',\n\t\t        \'de_DE\': \'German\'\n            },\n            \'printer\': {\n                \'i3\': \'i3\',\n                \'i3_mk2\': \'i3 mark2\'\n            },\n            \'materials\': {\n                \'pla\': \'PLA\',\n                \'abs\': \'ABS\',\n                \'flex\': \'FLEX\'\n            },\n            \'quality\': {\n                \'draft\': \'Draft\',\n                \'normal\': \'Normal\',\n                \'detail\': \'Detail\',\n                \'ultradetail\': \'Ultra detail\'\n            }\n        }\n\n        self.warning_message_buffer = []\n\n\n        #variables for help\n        self.last_pos = QPoint()\n        self.ray_start = [.0, .0, .0]\n        self.ray_end = [.0, .0, .0]\n        self.hitPoint = [.0, .0, .0]\n        self.last_ray_pos = [.0, .0, .0]\n        self.original_scale = 0.0\n        self.original_scale_point = numpy.array([0.,0.,0.])\n        self.origin_rotation_point = numpy.array([0.,0.,0.])\n        self.res_old = numpy.array([0., 0., 0.])\n        self.render_status = \'model_view\'   #\'gcode_view\'\n        self.status = \'edit\'\n        self.is_model_loaded = False\n        self.canceled = False\n        self.filament_use = \'\'\n        self.resolution_of_texture = 16\n        self.soluble_extruder = -1\n\n        #event flow flags\n        self.mouse_double_click_event_flag = False\n        self.mouse_press_event_flag = False\n        self.mouse_move_event_flag = False\n        self.mouse_release_event_flag = False\n        self.tool_press_event_flag = False\n        self.tool_helper_press_event_flag = False\n        self.object_select_event_flag = False\n        self.cursor_over_object = False\n\n        #scene work flags\n        self.scene_was_saved = False\n        self.scene_was_generated = False\n        self.gcode_was_saved = False\n        self.scene_is_not_empty = True\n\n        self.printer_number_of_materials = False\n\n        self.gcode_layer = \'0.0\'\n        self.gcode_draw_from_button = True\n\n        self.over_object = False\n        self.models_selected = False\n        self.advance_settings = False\n        self.incompatible_materials = False\n\n        self.analyze_result = {}\n\n        self.app = app\n        self.app_parameters = app.arguments()\n        #calculate dpi coeficient for scale of widgets\n        self.dpi_coef = app.desktop().logicalDpiX() / 96.\n        self.dpi_scale = 0 if self.dpi_coef == 1.0 else 2\n\n        print(""Dpi coef: "" + str(self.dpi_coef))\n        print(""Dpi scale: "" + str(self.dpi_scale))\n\n        self.translator = QTranslator()\n        self.set_language(self.settings[\'language\'])\n        progress_bar(40)\n\n        progress_bar(85)\n        self.slicer_manager = SlicerEngineManager(self)\n\n        self.scene = AppScene(self)\n        progress_bar(90)\n        self.view = PrusaControlView(self)\n        self.update_object_extruders()\n\n        progress_bar(92)\n\n        self.tools = self.view.get_tool_buttons()\n        self.tool = \'\'\n        self.camera_move = False\n        self.camera_rotate = False\n        self.view.update_gui_for_material()\n        progress_bar(95)\n\n        printer_settings = self.printing_parameters.get_printer_parameters(self.settings[\'printer\'])\n        self.printer_number_of_materials = printer_settings[\'multimaterial\']\n        if self.printer_number_of_materials > 1:\n            self.single_material_mode = False\n            self.view.set_multimaterial_gui_on(True)\n        else:\n            self.view.set_multimaterial_gui_off(True)\n\n        progress_bar(97)\n\n\n        #logging.info(\'Parameters: %s\' % ([unicode(i.toUtf8(), encoding=""UTF-8"") for i in self.app_parameters]))\n\n        #print(str(type(self.app_parameters)))\n        if len(self.app_parameters) >= 3:\n            for file in self.app_parameters[2:]:\n                #logging.info(\'%s\' %unicode(file.toUtf8(), encoding=""UTF-8""))\n                #self.open_file(unicode(file.toUtf8(), encoding=""UTF-8""))\n                self.open_file(file)\n\n        progress_bar(99)\n\n        self.message_object00 = """"\n        self.message_object01 = """"\n        self.message_object02 = """"\n        self.message_object03 = """"\n        self.message_object04 = """"\n        self.message_object05 = """"\n\n        self.show_message_on_status_bar(""Ready"")\n        self.create_messages()\n\n        self.single_material_mode = False\n\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            self.add_wipe_tower()\n\n    def update_object_extruders(self):\n        self.view.update_object_extruders_cb()\n\n    def open_color_pick_dialog1(self):\n        self.view.open_color_pick_dialog1()\n\n    def open_color_pick_dialog2(self):\n        self.view.open_color_pick_dialog2()\n\n    def open_color_pick_dialog3(self):\n        self.view.open_color_pick_dialog3()\n\n    def open_color_pick_dialog4(self):\n        self.view.open_color_pick_dialog4()\n\n    def get_extruder_color(self, extruder_number):\n        #print(extruder_number)\n        #print(self.view.extruder1_color)\n        extruders_color_lst = [self.view.extruder1_color, self.view.extruder2_color, self.view.extruder3_color, self.view.extruder4_color]\n        return extruders_color_lst[extruder_number-1]\n\n\n    def is_multimaterial(self):\n        if self.printer_number_of_materials > 1:\n            return True\n        else:\n            return False\n        return False\n\n    def set_unset_single_material_mode(self):\n        if not self.is_multimaterial():\n            return\n\n        self.single_material_mode = self.view.single_material_mode_checkbox.isChecked()\n\n        if self.single_material_mode:\n            #set single material GUI\n            #print(""set single material mode"")\n            self.set_printer_mod(self.is_actual_printer_multimode())\n            self.view.set_multimaterial_gui_off()\n            self.remove_wipe_tower()\n            self.update_scene()\n            self.incompatible_materials = False\n        else:\n            #set multi material GUI\n            #print(""set multimaterial mode"")\n            self.set_printer_mod("""")\n            self.view.set_multimaterial_gui_on()\n            self.change_of_wipe_tower_settings(1)\n            self.update_wipe_tower()\n            self.update_scene()\n\n\n        self.view.update_gui_for_material(1)\n\n    def is_actual_printer_multimode(self):\n        data = self.printing_parameters.get_printer_parameters(self.actual_printer)[\'material_mode\']\n        if not data == """":\n            return data\n        else:\n            return """"\n\n    def is_single_material_mode(self):\n        if self.is_multimaterial():\n            return self.single_material_mode\n        else:\n            True\n\n    def set_analyze_result_messages(self, result):\n        self.analyze_result = result\n\n    def filtrate_warning_msgs(self):\n        self.warning_message_buffer = []\n        if self.analyze_result:\n            if self.analyze_result[\'support\'] and self.view.supportCombo.currentIndex() == 0:\n                self.warning_message_buffer.append(u""\xe2\x80\xa2 "" + self.message_object02)\n\n            if self.analyze_result[\'brim\'] and self.view.brimCheckBox.isChecked() == False:\n                self.warning_message_buffer.append(u""\xe2\x80\xa2 "" + self.message_object03)\n\n        if self.incompatible_materials:\n            self.warning_message_buffer.append(u""\xe2\x80\xa2 "" + self.message_object04)\n\n\n        if self.scene.is_collision_of_wipe_tower_and_objects():\n            self.warning_message_buffer.append(u""\xe2\x80\xa2 "" + self.message_object05)\n\n\n\n    def get_warnings(self):\n        messages = self.scene.get_warnings()\n        self.filtrate_warning_msgs()\n        return messages + self.warning_message_buffer\n\n\n    def create_messages(self):\n        self.message_object00 = self.tr(""Object "")\n        self.message_object01 = self.tr("" is out of printable area!"")\n        self.message_object02 = self.tr(""Scene is hard to print without support."")\n        self.message_object03 = self.tr(""For better adhesion turn Brim parametr on."")\n        self.message_object04 = self.tr(""Incompatible materials, its possible the print will fail."")\n        self.message_object05 = self.tr(""Collision of wipe tower and object."")\n\n\n    def check_version(self):\n        if not self.app_config.is_version_actual:\n            ret = self.view.show_new_version_message()\n            if ret == QMessageBox.Yes:\n                self.open_web_browser(self.app_config.prusacontrol_update_page)\n\n    def actualize_extruders(self):\n        self.show_warning_if_used_materials_are_not_compatible()\n        self.actualize_extruder_set()\n\n    def actualize_extruder_set(self):\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            pass\n        else:\n            return\n\n        extruders_set_tmp = list(set([ m.extruder for m in self.scene.get_models(with_wipe_tower=False)]))\n\n        if self.view.get_support_option() >=1 :\n            extruders_set_tmp.append(self.soluble_extruder)\n            extruders_set = list(extruders_set_tmp)\n        else:\n            extruders_set = list(extruders_set_tmp)\n\n        if 1 in extruders_set:\n            #self.view.extruder1_l.setStyleSheet(""font-weight: bold;"")\n            self.view.extruder1_l.setStyleSheet(""QLabel { font-weight: bold;}"")\n            self.view.extruder1_l.setToolTip(self.view.used_extruder_tooltip)\n        else:\n            self.view.extruder1_l.setStyleSheet(""font-weight: normal;"")\n            self.view.extruder1_l.setToolTip("""")\n\n        if 2 in extruders_set:\n            self.view.extruder2_l.setStyleSheet(""QLabel { font-weight: bold;}"")\n            self.view.extruder2_l.setToolTip(self.view.used_extruder_tooltip)\n        else:\n            self.view.extruder2_l.setStyleSheet(""font-weight: normal;"")\n            self.view.extruder2_l.setToolTip("""")\n\n        if 3 in extruders_set:\n            self.view.extruder3_l.setStyleSheet(""QLabel { font-weight: bold;}"")\n            self.view.extruder3_l.setToolTip(self.view.used_extruder_tooltip)\n        else:\n            self.view.extruder3_l.setStyleSheet(""font-weight: normal;"")\n            self.view.extruder3_l.setToolTip("""")\n\n        if 4 in extruders_set:\n            self.view.extruder4_l.setStyleSheet(""QLabel { font-weight: bold;}"")\n            self.view.extruder4_l.setToolTip(self.view.used_extruder_tooltip)\n        else:\n            self.view.extruder4_l.setStyleSheet(""font-weight: normal;"")\n            self.view.extruder4_l.setToolTip("""")\n\n\n        self.update_wipe_tower()\n\n\n\n\n    def exit_event(self):\n        self.zeroconf.close()\n\n        if self.status in [\'loading_gcode\']:\n            self.analyzer.cancel_analyz()\n            self.gcode.cancel_parsing_gcode()\n            return True\n        elif self.status in [\'generating\']:\n            self.analyzer.cancel_analyz()\n            ret = self.view.show_exit_message_generating_scene()\n            if ret == QMessageBox.Yes:\n                self.cancel_generation()\n                return True\n            elif ret == QMessageBox.No:\n                return False\n        elif self.is_something_to_save() and not self.scene_was_saved:\n            self.analyzer.cancel_analyz()\n            ret = self.view.show_exit_message_scene_not_saved()\n            if ret == QMessageBox.Save:\n                self.save_project_file()\n                return True\n            elif ret == QMessageBox.Discard:\n                return True\n            elif ret == QMessageBox.Cancel:\n                return False\n        else:\n            self.analyzer.cancel_analyz()\n            return True\n\n\n\n    def is_something_to_save(self):\n        models_lst = self.scene.get_models(with_wipe_tower=False)\n        if len(models_lst) == 0:\n            return False\n        else:\n            return True\n\n    def get_informations(self):\n        if not self.gcode:\n            return\n\n        printing_time = self.gcode.printing_time\n        filament_length = self.filament_use\n\n        printing_time_str = self.convert_printing_time_from_seconds(printing_time)\n        filament_length_str = self.convert_filament_length_units(filament_length)\n\n        data = {\'info_text\': \'info total:\',\n                \'printing_time\': printing_time_str,\n                \'filament_lenght\': filament_length_str}\n\n        return data\n\n    def convert_printing_time_from_seconds(self, seconds):\n        m, s = divmod(seconds, 60)\n        h, m = divmod(m, 60)\n\n        if h == 0:\n            return ""{:2.0f}min"".format(m)\n        else:\n            return ""{:2.0f}h {:2.0f}min"".format(h, m)\n\n    def convert_filament_length_units(self, filament_lenght_mm):\n        if not filament_lenght_mm:\n            return """"\n        original_filament_lenght = float(filament_lenght_mm[:-2])\n        original_units = filament_lenght_mm[-2:]\n        if original_units == ""mm"":\n            if original_filament_lenght >= 1000.:\n                recalculated_filament_lenght = original_filament_lenght*0.001\n                recalculated_units = ""m""\n            elif original_filament_lenght >= 10.:\n                recalculated_filament_lenght = original_filament_lenght * 0.1\n                recalculated_units = ""cm""\n            elif original_filament_lenght >= 1.:\n                recalculated_filament_lenght = original_filament_lenght\n                recalculated_units = original_units\n\n            recalculated_filament_lenght_str = ""{:.1f}"".format(recalculated_filament_lenght)\n            recalculated_filament_lenght_str = recalculated_filament_lenght_str.rstrip(""0"")\n            recalculated_filament_lenght_str = recalculated_filament_lenght_str.rstrip(""."")\n            new_filament_format = ""{}{}"".format(recalculated_filament_lenght_str, recalculated_units)\n        else:\n            new_filament_format = ""{}"".format(filament_lenght_mm)\n        return new_filament_format\n\n    def clear_event_flag_status(self):\n        self.mouse_double_click_event_flag = False\n        self.mouse_press_event_flag = False\n        self.mouse_move_event_flag = False\n        self.mouse_release_event_flag = False\n        self.tool_press_event_flag = False\n        self.object_select_event_flag = False\n        self.tool_helper_press_event_flag = False\n        self.cursor_over_object = False\n\n    def clear_gcode(self):\n        self.gcode = None\n        self.gcode_layer = \'0.0\'\n        self.gcode_draw_from_button = False\n\n\n    def write_config(self):\n        config = RawConfigParser()\n        config.add_section(\'settings\')\n        config.set(\'settings\', \'printer\', self.settings[\'printer\'])\n        config.set(\'settings\', \'printer_type\', self.settings[\'printer_type\'])\n        config.set(\'settings\', \'debug\', str(self.settings[\'debug\']))\n        config.set(\'settings\', \'automatic_placing\', str(self.settings[\'automatic_placing\']))\n        config.set(\'settings\', \'language\', self.settings[\'language\'])\n        config.set(\'settings\', \'analyze\', self.settings[\'analyze\'])\n        config.set(\'settings\', \'automatic_update_parameters\', self.settings[\'automatic_update_parameters\'])\n\n\n        with open(self.app_config.config_path, \'w\') as configfile:\n            config.write(configfile)\n\n    def set_basic_settings(self):\n        self.advance_settings = False\n        self.view.object_variable_layer_box.setVisible(False)\n        self.view.object_group_box.setVisible(True)\n        self.update_scene()\n\n    def set_advance_settings(self):\n        self.advance_settings = True\n        self.view.object_group_box.setVisible(False)\n        self.view.object_variable_layer_box.setVisible(True)\n        #self.view.variable_layer_widget.set_model(self.ac)\n        self.update_scene()\n\n    def set_gcode_slider(self, min, max, min_l, max_l):\n        self.view.gcode_slider.setMinimum(min, min_l)\n        self.view.gcode_slider.setMaximum(max, max_l)\n\n\n    def set_gcode_instance(self, gcode_instance):\n        self.gcode = gcode_instance\n        self.gcode.done_loading_callback = self.set_gcode\n        self.gcode.writing_done_callback = self.set_saved_gcode\n        self.set_gcode()\n\n    def print_progress(self, progress):\n        print(""Progress: "" + str(progress))\n\n\n    def read_gcode(self, filename = \'\'):\n        #print(""reading gcode"")\n        if filename:\n            self.gcode = GCode(filename, self, self.set_gcode, self.set_saved_gcode)\n        else:\n            self.gcode = GCode(self.app_config.tmp_place + \'out.gcode\', self, self.set_gcode, self.set_saved_gcode)\n\n        self.view.set_cancel_of_loading_gcode_file()\n        self.status = \'loading_gcode\'\n        self.view.disable_editing()\n        self.gcode.read_in_thread(self.set_progress_bar, self.set_gcode)\n\n\n    def set_saved_gcode(self):\n        self.set_progress_bar(100)\n        self.status = \'generated\'\n        self.set_gcode_view()\n        self.show_message_on_status_bar(self.view.tr(""GCode saved""))\n\n\n    def set_gcode(self):\n        #print(""Set gcode"")\n        if not self.gcode.is_loaded:\n            return\n        self.status = \'generated\'\n\n        min = 0\n        max = len(self.gcode.data_keys) - 1\n\n        min_l = float(self.gcode.data_keys[0])\n        max_l = float(self.gcode.data_keys[-1])\n\n        self.set_gcode_slider(min, max, min_l, max_l)\n\n        #What layer had to be show at start\n        self.gcode_layer = self.gcode.data_keys[1]\n\n        self.view.gcode_label.setText(self.gcode.data_keys[0])\n        self.view.gcode_slider.setValue(float(self.gcode.data_keys[0]))\n\n        self.set_gcode_view()\n\n\n    def set_variable_layer_cursor(self, double_value):\n        for m in self.scene.models:\n            if m.isVisible and m.selected:\n                m.z_cursor = double_value\n        self.update_scene()\n\n\n    def set_gcode_layer(self, value):\n        self.gcode_layer = self.gcode.data_keys[value]\n        self.update_scene()\n        #self.view.update_scene()\n\n    def set_gcode_draw_from_button(self, val):\n        self.gcode_draw_from_button = val\n\n    def scene_was_sliced(self):\n        #self.set_save_gcode_button()\n        #self.read_gcode()\n        self.view.gcode_slider.init_points()\n        self.set_gcode_view()\n        self.status = \'generated\'\n        self.app.alert(self.view, 0)\n\n    def check_rotation_helper(self, event):\n        #print(""check rotation"")\n        id = self.get_id_under_cursor(event)\n        if self.is_some_tool_under_cursor(id):\n            self.view.update_scene()\n\n    def unselect_tool_buttons(self):\n        for tool in self.tools:\n            tool.unpress_button()\n\n\n    def set_gcode_view(self):\n        self.unselect_objects()\n        self.render_status = \'gcode_view\'\n        self.open_gcode_gui()\n\n    def set_model_edit_view(self):\n        self.render_status = \'model_view\'\n        self.set_generate_button()\n        self.view.enable_editing()\n        self.status = \'edit\'\n        #self.editable = editable\n        self.view.close_gcode_view()\n        self.show_message_on_status_bar("""")\n\n    def open_gcode_gui(self):\n        self.view.disable_editing()\n        self.view.open_gcode_view()\n\n    def close_gcode_gui(self):\n        self.view.close_gcode_view()\n\n    def set_language(self, language):\n        full_name = self.app_config.local_path + \'translation/\' + language + \'.qm\'\n        self.translate_app(full_name)\n\n    def translate_app(self, translation=""""):\n        if translation == """":\n            translation = self.app_config.local_path + ""translation/en_US.qm""\n\n        self.translator.load(translation)\n        self.app.installTranslator(self.translator)\n        if self.view:\n            self.view.retranslateUI()\n\n    def cancel_generation(self):\n        self.slicer_manager.cancel()\n\n    def get_enumeration(self, section, enum):\n        return self.enumeration[section][enum] if section in self.enumeration and enum in self.enumeration[section] else str(section)+\':\'+str(enum)\n\n    def get_printer_name(self):\n        #TODO:Add code for read and detect printer name\n        return ""Original Prusa i3""\n\n    def get_firmware_version_number(self):\n        #TODO:Add code for download firmware version\n        return \'1.0.1\'\n\n    def get_printers_labels_ls(self, only_visible=False):\n        printers = self.printing_parameters.get_printers_parameters()\n        if only_visible and \'visible\' in printers[list(printers.keys())[0]]:\n            unsorted = [[printers[printer][""label""], [printers[printer][\'sort\']]] for printer in printers if printers[printer][\'visible\'] == 1]\n            sort_lst = sorted(unsorted, key=lambda mem: mem[1])\n            return [a[0] for a in sort_lst]\n        else:\n            unsorted = [[printers[printer][""label""], [printers[printer][\'sort\']]] for printer in printers]\n            sort_lst = sorted(unsorted, key=lambda mem: mem[1])\n            return [a[0] for a in sort_lst]\n\n    def get_printers_names_ls(self, only_visible=False):\n        return self.printing_parameters.get_printers_names(only_visible)\n\n    def get_printer_variations_labels_ls(self, printer_name):\n        first = 0\n        data = self.printing_parameters.get_printer_parameters(printer_name)\n        if \'sort\' in data[""printer_type""][list(data[""printer_type""])[0]] and \'first\' in data[""printer_type""][list(data[""printer_type""])[0]]:\n            unsorted = [[data[""printer_type""][printer_type][""label""], data[""printer_type""][printer_type][\'sort\'], data[""printer_type""][printer_type][\'first\']] for printer_type in data[""printer_type""]]\n            sort_lst = sorted(unsorted, key=lambda mem: mem[1])\n            for i, d in enumerate(sort_lst):\n                if d[2] == 1:\n                    first = i\n                    break\n            return [mem[0] for mem in sort_lst], first\n        else:\n            return [data[""printer_type""][printer_type][""label""] for printer_type in data[""printer_type""]], first\n\n    def get_printer_variations_names_ls(self, printer_name):\n        first = 0\n        data = self.printing_parameters.get_printer_parameters(printer_name)\n        if \'sort\' in data[""printer_type""][list(data[""printer_type""])[0]] and \'first\' in data[""printer_type""][list(data[""printer_type""])[0]]:\n            unsorted = [[data[""printer_type""][printer_type][""name""], data[""printer_type""][printer_type][\'sort\'], data[""printer_type""][printer_type][\'first\']] for printer_type in data[""printer_type""]]\n            sort_lst = sorted(unsorted, key=lambda mem: mem[1])\n            for i, d in enumerate(sort_lst):\n                if d[2] == 1:\n                    first = i\n                    break\n            return [mem[0] for mem in sort_lst], first\n        else:\n            return list(data[""printer_type""]), first\n\n    def get_printer_materials_names_ls(self, printer_name):\n        #return self.printing_settings[\'materials\']\n        #return [i[\'label\'] for i in self.printing_settings[\'materials\'] if i[\'name\'] not in [\'default\']]\n        return self.printing_parameters.get_materials_for_printer(printer_name).keys()\n\n    def get_printer_materials_labels_ls(self, printer_name):\n        first_index = 0\n        data = self.printing_parameters.get_materials_for_printer(printer_name)\n        list = [[data[material][\'label\'], data[material][""sort""], data[material][""first""]] for material in data]\n        list = sorted(list, key=lambda a: a[1])\n        for i, data in enumerate(list):\n            if data[2] == 1:\n                first_index = i\n                break\n        return [a[0] for a in list], first_index\n\n    def get_printer_material_quality_labels_ls_by_material_name(self, material_name):\n        #return [self.printing_parameters.get_materials_quality_for_printer(self.actual_printer, material_name)[\'quality\'][i][\'label\']\n        #        for i in self.printing_parameters.get_materials_quality_for_printer(self.actual_printer, material_name)[\'quality\']]\n        first_index = 0\n        data = self.printing_parameters.get_materials_quality_for_printer(self.get_actual_printer(), material_name)[\'quality\']\n        list = [[data[quality][\'label\'], data[quality][""sort""], data[quality][""first""]] for quality in data]\n        list = sorted(list, key=lambda a: a[1])\n        for i, data in enumerate(list):\n            if data[2] == 1:\n                first_index = i\n                break\n        return [a[0] for a in list], first_index\n\n    def get_material_name_by_material_label(self, material_label):\n        data = self.printing_parameters.get_materials_for_printer(self.get_actual_printer())\n        for i in data:\n            if data[i][\'label\']==material_label:\n                return i\n        return None\n\n    def get_material_quality_name_by_quality_label(self, material_name, quality_label):\n        data = self.printing_parameters.get_materials_for_printer(self.get_actual_printer())[material_name]\n        for i in data[""quality""]:\n            if data[""quality""][i][\'label\'] == quality_label:\n                return i\n        return None\n\n\n\n    def get_printer_material_quality_labels_ls_by_material_label(self, material_label):\n        materials_ls = self.printing_parameters.get_materials_for_printer(self.get_actual_printer())\n        material_name = """"\n        for material in materials_ls:\n            if materials_ls[material][\'label\'] == material_label:\n                material_name = material\n                break\n\n        return self.get_printer_material_quality_labels_ls_by_material_name(material_name)\n\n    def get_printer_material_quality_names_ls(self, material):\n        # return [i[\'label\'] for i in self.printing_settings[\'materials\'][index][\'quality\'] if i[\'name\'] not in [\'default\']]\n        data = self.printing_parameters.get_materials_quality_for_printer(self.get_actual_printer(), material)[\'quality\']\n        list = [[quality, data[quality][""sort""]] for quality in data]\n        list = sorted(list, key=lambda a: a[1])\n        return [a[0] for a in list]\n        #return [i for i in self.printing_parameters.get_materials_quality_for_printer(self.get_actual_printer(), material)[\'quality\']]\n\n    def get_printing_settings_for_material_in_extruder(self, extruder_number):\n        if extruder_number in [1, 2, 3, 4]:\n            if extruder_number == 1:\n                return self.get_printing_settings_for_material_by_label(self.view.extruder1_c.currentText())\n            elif extruder_number == 2:\n                return self.get_printing_settings_for_material_by_label(self.view.extruder2_c.currentText())\n            elif extruder_number == 3:\n                return self.get_printing_settings_for_material_by_label(self.view.extruder3_c.currentText())\n            elif extruder_number == 4:\n                return self.get_printing_settings_for_material_by_label(self.view.extruder4_c.currentText())\n        else:\n            return None\n\n\n    def get_printing_settings_for_material_by_name(self, material_name):\n        # material = self.printing_settings[\'materials\'][material_index]\n        printing_settings_tmp = []\n        printing_settings_tmp = self.printing_parameters.get_materials_for_printer(self.get_actual_printer())\n        material_printing_setting = printing_settings_tmp[material_name]\n\n        return material_printing_setting\n\n    def get_printing_settings_for_material_by_label(self, material_label):\n        printing_settings_tmp = []\n        for material in self.printing_parameters.get_materials_for_printer(self.get_actual_printer()):\n            if self.printing_parameters.get_materials_for_printer(self.get_actual_printer())[material][""label""] == material_label:\n                printing_settings_tmp = self.printing_parameters.get_materials_for_printer(self.get_actual_printer())[material]\n                break\n\n        return printing_settings_tmp\n\n    def update_mm_material_settings(self):\n        #print(""Update mm material settigns"")\n        # get combobox materials\n        soluble_material_tmp = []\n\n        if not self.is_multimaterial():\n            return\n\n        soluble_material_tmp.append(self.get_printing_settings_for_material_by_label(self.view.extruder1_c.currentText())[""soluble""])\n        soluble_material_tmp.append(self.get_printing_settings_for_material_by_label(self.view.extruder2_c.currentText())[""soluble""])\n        soluble_material_tmp.append(self.get_printing_settings_for_material_by_label(self.view.extruder3_c.currentText())[""soluble""])\n        soluble_material_tmp.append(self.get_printing_settings_for_material_by_label(self.view.extruder4_c.currentText())[""soluble""])\n        soluble_material = soluble_material_tmp[:self.printer_number_of_materials]\n\n        # if one of them soluble then add special support form, if not support combo without it\n        if 1 in soluble_material:\n            soluble_extruders = [i+1 for i, m in enumerate(soluble_material) if m == 1]\n            self.soluble_extruder = soluble_extruders[0]\n            self.set_special_support_settings()\n        else:\n            self.soluble_extruder = -1\n            self.set_normal_support_settings()\n\n\n        self.show_warning_if_used_materials_are_not_compatible()\n        self.actualize_extruder_set()\n\n\n\n    def show_warning_if_used_materials_are_not_compatible(self):\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            pass\n        else:\n            self.incompatible_materials = False\n            return\n        list_of_materials = [self.get_printing_settings_for_material_by_label(self.view.extruder1_c.currentText())[""name""],\n                             self.get_printing_settings_for_material_by_label(self.view.extruder2_c.currentText())[""name""],\n                             self.get_printing_settings_for_material_by_label(self.view.extruder3_c.currentText())[""name""],\n                             self.get_printing_settings_for_material_by_label(self.view.extruder4_c.currentText())[""name""]]\n\n        compatible_with_lst = []\n        # if some materials are not compatible\n        # read compatible with list for all selected materials\n        compatible_with_lst.append(\n            self.check_compatible_with_lst(self.get_printing_settings_for_material_by_label(\n                self.view.extruder1_c.currentText())[""compatible_with""]))\n        compatible_with_lst.append(\n            self.check_compatible_with_lst(self.get_printing_settings_for_material_by_label(\n                self.view.extruder2_c.currentText())[""compatible_with""]))\n        compatible_with_lst.append(\n            self.check_compatible_with_lst(self.get_printing_settings_for_material_by_label(\n                self.view.extruder3_c.currentText())[""compatible_with""]))\n        compatible_with_lst.append(\n            self.check_compatible_with_lst(self.get_printing_settings_for_material_by_label(\n                self.view.extruder4_c.currentText())[""compatible_with""]))\n\n\n        # find out which extruders are used and create filter it\n        used_extruders_tmp = list(set([m.extruder-1 for m in self.scene.get_models(with_wipe_tower=False)]))\n\n        if self.view.get_support_option() >=1 :\n            used_extruders_tmp.append(self.soluble_extruder-1)\n\n        used_extruders = [i in used_extruders_tmp for i in range(0,4)]\n        #print(used_extruders_tmp)\n        #print(used_extruders)\n\n\n        show_warning = False\n        # generate warning message if some material is not compatible\n        if len(used_extruders_tmp) > 1:\n            # compare compatibility\n            #print(""List compatibility: "" + str(compatible_with_lst))\n            #print(""List pouzitych extruderu: "" + str(used_extruders))\n\n            filtrated_used_materials = list(compress(list_of_materials, used_extruders))\n            filtrated_compatible_lst = list(compress(compatible_with_lst, used_extruders))\n\n            for i, material in enumerate(filtrated_used_materials):\n                #print(""Material: "" + str(material))\n                compatible_materials = [ mat for o, mat in enumerate(filtrated_compatible_lst) if not i==o ]\n                #print(""Compatible materials: "" + str(compatible_materials))\n                for compat_mat in compatible_materials:\n                    if not material in compat_mat:\n                        #print(""Nekompatibilni"")\n                        show_warning = True\n\n        if show_warning:\n            self.incompatible_materials = True\n        else:\n            self.incompatible_materials = False\n        self.update_scene()\n\n\n    def check_compatible_with_lst(self, lst):\n        if lst == []:\n            return list(self.get_printer_materials_names_ls(self.get_actual_printer()))\n        else:\n            return lst\n\n\n    def set_special_support_settings(self):\n        self.view.set_special_support_settings()\n\n    def set_normal_support_settings(self):\n        self.view.set_normal_support_settings()\n\n\n    def get_infill_ls_and_index_of_default(self, default):\n        first = 0\n        #infill_ls = [""0%"", ""10%"", ""15%"", ""20%"", ""30%"", ""50%"", ""70%""]\n        infill_ls = [self.tr(""Hollow/Shell - "") + ""0%"",\n                     self.tr(""Sparse - "") + ""10%"",\n                     self.tr(""Light - "") + ""15%"",\n                     self.tr(""Standard - "") + ""20%"",\n                     self.tr(""Dense - "") + ""30%"",\n                     self.tr(""Denser - "") + ""50%"",\n                     self.tr(""Solid - "") + ""70%""]\n        for i, data in enumerate(infill_ls):\n            if default in data:\n                first = i\n                break\n\n        return infill_ls, first\n\n    def get_infill_values_ls(self):\n        return [0, 10, 15, 20, 30, 50, 70]\n\n    def get_actual_printing_data(self):\n        #GUI parameters\n        gui_parameters = self.view.get_actual_printing_data()\n        #Scene parameters(wipe tower possition)\n        scene_parameters = self.scene.get_wipe_tower_possition_and_size()\n\n        #multimaterial parameters\n        multimat = dict()\n        multimat[""is_multimat""] = int(self.is_multimaterial() and not self.is_single_material_mode())\n\n        out = {}\n\n        for param in (gui_parameters, scene_parameters, multimat):\n            out.update(param)\n\n        return out\n\n\n    def open_cancel_generating_dialog(self):\n        ret = self.view.show_cancel_generating_dialog_and_load_file()\n        if ret == QMessageBox.Yes:\n            self.cancel_generation()\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n\n    def open_cancel_gcode_reading_dialog(self):\n        ret = self.view.show_cancel_generating_dialog_and_load_file()\n        if ret == QMessageBox.Yes:\n            self.cancel_gcode_loading()\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n    def generate_button_pressed(self):\n        if self.status in [\'edit\', \'canceled\']:\n            self.clear_tool_button_states()\n\n            #prepared to be g-code generated\n            self.canceled = False\n            self.close_object_settings()\n            self.view.disable_editing()\n\n            if not self.canceled:\n                self.generate_gcode()\n                self.set_cancel_button()\n                self.status = \'generating\'\n        elif self.status == \'saving_gcode\':\n            self.gcode.cancel_writing_gcode()\n            self.status = \'generated\'\n            self.view.open_gcode_view()\n\n        elif self.status == \'generating\':\n            #generating in progress\n            self.cancel_generation()\n            self.cancel_gcode_loading()\n            self.status = \'canceled\'\n            self.view.enable_editing()\n            self.set_generate_button()\n\n        elif self.status == \'loading_gcode\':\n            self.cancel_gcode_loading()\n            self.show_message_on_status_bar("""")\n        elif self.status == \'generated\':\n            #already generated\n            if self.print_on_service:\n                self.print_on_actual_service()\n            else:\n                self.save_gcode_file()\n\n    def print_on_actual_service(self):\n        #TODO: Ask if prusacontrol dont have apikey for service, other way use one from file\n        apikey = \'CA54B5013E8C4C4B8BE6031F436133F5\'\n\n        http = urllib3.PoolManager()\n\n        print(""Printing on octoprint:"")\n        url = ""http://"" + self.default_printing_service + \'/api/files/local\'\n        print(""Sending to %s"" % (url))\n\n        with open(self.app_config.tmp_place + \'out.gcode\') as fp:\n            binary_data = fp.read()\n            print(""Suggested gcode filename: "" + self.generate_gcode_filename())\n            # TODO:Add check if printer is in use, denide to upload/print new thing\n            r = http.request(\'POST\',\n                             url,\n                             fields={\'file\': (\'%s.gcode\' % self.generate_gcode_filename(), binary_data),\n                                     ""command"": ""select"", ""print"": \'true\'},\n                             headers={\'X-Api-Key\': apikey})\n\n        #TODO:Add progress bar for uploading gcode to printer\n\n\n\n\n        print(""Start sending gcode"")\n        print(""..."")\n        #r = post(url, files=files)\n        print(str(r.status))\n        print(""gcode recieved OK"")\n        print(""starting printing"")\n        print(""Printing on OctoPrint"")\n\n\n    def cancel_gcode_loading(self):\n        if self.gcode:\n            self.gcode.cancel_parsing_gcode()\n        self.gcode = None\n        self.status = \'canceled\'\n        self.disable_generate_button()\n        self.set_generate_button()\n        self.set_progress_bar(0)\n        #print(""Cancel gcode loading end"")\n\n\n    #TODO:Better way\n    def generate_gcode_filename(self):\n        suggest_filename = """"\n        filename = """"\n        \'\'\'\n        list = []\n        if len(self.scene.models) == 1:\n            filename = self.scene.models[0].filename\n            suggest_filename = filename.split(""."")\n            suggest_filename = suggest_filename[0]\n        else:\n            #for m in self.scene.models:\n            #    list.append(m.filename)\n            suggest_filename = ""mix""\n        \'\'\'\n        for m in self.scene.models:\n            if m.isVisible and not m.is_wipe_tower:\n                filename = m.filename\n                break\n\n        if filename == \'\' and self.gcode:\n            suggest_filename = self.gcode.filename\n        else:\n            suggest_filename = filename.split(""."")\n            suggest_filename = suggest_filename[0]\n            data = self.get_actual_printing_data()\n            material_name = data[\'material\']\n\n            quality_name = data[\'quality\']\n            material_names_lst = [mat.split(\'_\')[-1] for mat in material_name]\n\n            material_info = ""_"".join(material_names_lst)\n            suggest_filename += ""_"" + material_info.upper() + ""_"" + quality_name.upper()\n\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            suggest_filename = suggest_filename + ""_MM""\n\n\n        return suggest_filename\n\n\n    def open_web_browser(self, url):\n        webbrowser.open(url, 1)\n\n    def set_printer(self, name):\n        #index = [i for i, data in enumerate(self.printers) if data[\'name\']== name]\n        #print(""Setting actual printer on: "" + str(name))\n        self.actual_printer = deepcopy(name)\n        self.settings[\'printer\'] = deepcopy(name)\n        self.actual_printer_mod = """"\n\n    def set_printer_mod(self, special_mode):\n        self.actual_printer_mod = special_mode\n\n    def get_actual_printer(self):\n        if self.actual_printer_mod:\n            return self.actual_printer_mod\n        else:\n            return self.actual_printer\n\n    def change_of_wipe_tower_settings(self, value):\n        #print(""change of wipe tower settings: "" +str(value))\n        # value reduce 0 - small wipe tower 5\n        # value normal 1 - normal wipe tower 15\n        # value increase/soluble 2 - bigger wipe tower 20\n\n        if value == 0:\n            self.scene.wipe_tower_size_y = 7.5\n        elif value == 1:\n            self.scene.wipe_tower_size_y = 15.\n        elif value == 2:\n            self.scene.wipe_tower_size_y = 20.\n\n\n        self.recalculate_wipe_tower()\n\n\n\n    def send_feedback(self):\n        if self.settings[\'language\'] == \'cs_CZ\':\n            self.open_web_browser(self.app_config.prusacontrol_questionnaire_cz)\n        else:\n            self.open_web_browser(self.app_config.prusacontrol_questionnaire_en)\n\n    def open_help(self):\n        self.open_web_browser(self.app_config.prusacontrol_help_page)\n\n    def open_shop(self):\n        self.open_web_browser(self.app_config.prusa_eshop_page)\n\n    def set_save_gcode_button(self):\n        self.view.set_save_gcode_button()\n\n    def set_cancel_button(self):\n        self.view.set_cancel_button()\n\n    def set_generate_button(self):\n        self.view.set_generate_button()\n        if not self.scene.is_scene_printable():\n            self.disable_generate_button()\n\n    def update_gui(self):\n        self.view.update_gui()\n\n    def set_progress_bar(self, value):\n        self.view.progressBar.setValue(value)\n\n    def get_view(self):\n        return self.view\n\n    def get_model(self):\n        return self.scene\n\n    def open_printer_info(self):\n        self.view.open_printer_info_dialog()\n\n    def set_gcode_help_button_pressed(self):\n        self.gcode_help_button_pressed = True\n        self.update_scene()\n\n    def set_gcode_help_button_released(self):\n        self.gcode_help_button_pressed = False\n        self.view.gcode_help_b.setChecked(False)\n        self.update_scene()\n\n    def show_gcode_help(self):\n        if self.render_status == \'gcode_view\' and self.gcode_help_button_pressed:\n            return True\n        return False\n\n    def open_update_firmware(self):\n        self.view.open_firmware_dialog()\n\n    def open_project_file(self, url=None):\n        if self.is_something_to_save():\n            ret = self.view.open_project_asking_dialog()\n            if ret == False:\n                return\n            elif ret == \'Open\':\n                self.scene.clear_scene()\n            elif ret == \'Insert\':\n                print(""Nic nebudu mazat scena zustane stejna"")\n\n        if url:\n            data = url\n        else:\n            data = self.view.open_project_file_dialog()\n        #logging.debug(\'open project file %s\' %data)\n        self.import_project(data)\n        self.show_warning_if_used_materials_are_not_compatible()\n        self.actualize_extruder_set()\n        self.show_message_on_status_bar(self.view.tr(""Project loaded""))\n\n    def save_project_file(self):\n        path = self.view.save_project_file_dialog()\n        if path == \'\':\n            return\n        filename = path.split(\'.\')\n        if filename[-1] in [\'prusa\', \'PRUSA\']:\n            filename_out = path\n        else:\n            filename_out = path + \'.prusa\'\n\n        self.save_project(filename_out)\n        self.show_message_on_status_bar(self.view.tr(""Project was saved""))\n\n    def set_print_on(self, printer_text):\n        printer_ip = printer_text.split(\' \')[-1]\n        print(""Printer IP: "" + str(printer_ip))\n        self.default_printing_service = printer_ip\n        self.print_on_service = True\n\n    def add_new_octoprint(self):\n        print(""show dialog for new octoprint service"")\n        self.open_new_octoprint_dialog()\n        print(""save octoprint settings"")\n        print(""add new settings to list"")\n\n    def open_new_octoprint_dialog(self):\n        new_octoprint_settings, ret = self.view.open_new_octoprint_dialog()\n        if ret == QMessageBox.Yes:\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n    def save_gcode_file(self):\n        suggested_filename = self.generate_gcode_filename()\n        color_change_layers = self.view.gcode_slider.get_color_change_layers()\n        color_change_data = self.gcode.get_first_extruding_line_number_of_gcode_for_layers(color_change_layers)\n        path = self.view.save_gcode_file_dialog(suggested_filename)\n        if path == \'\':\n            return\n        filename = path.split(\'.\')\n        if filename[-1] in [\'gcode\', \'GCODE\']:\n            filename_out = path\n        else:\n            filename_out = path + \'.gcode\'\n        try:\n            self.status = ""saving_gcode""\n            self.view.saving_gcode()\n            #copyfile(self.app_config.tmp_place + ""out.gcode"", filename_out)\n            self.gcode.set_color_change_data(color_change_data)\n            self.gcode.write_with_changes_in_thread(self.gcode.filename, filename_out, self.set_progress_bar)\n\n        except Error as e:\n            logging.debug(\'Error: %s\' % e)\n        except IOError as e:\n            logging.debug(\'Error: %s\' % e.strerror)\n\n    def open_gcode_file(self):\n        path = self.view.open_gcode_file_dialog()\n        self.open_file(path)\n\n    def open_model_file(self):\n        data = self.view.open_model_file_dialog()\n        #logging.debug(\'open model#  file %s\' %data)\n        for path in data:\n            #print(""File path type: "" + str(type(path)))\n            self.import_model(path)\n\n    def open_multipart_model(self):\n        data = self.view.open_model_file_dialog()\n        self.load_multipart_model(data)\n        self.actualize_extruder_set()\n\n\n\n    def load_multipart_model(self, lst_of_urls):\n        self.show_message_on_status_bar(self.tr(""Loading multi part model""))\n        model_lst = []\n        extruder_counter = 1\n        for path in lst_of_urls:\n            model = ModelTypeStl().load(path, False)\n            model.parent = self.scene\n            model.is_multipart_model = True\n            self.scene.models.append(model)\n            model.extruder = extruder_counter\n            if extruder_counter <= 3:\n                extruder_counter +=1\n            else:\n                extruder_counter = 1\n            model_lst.append(model)\n\n\n        multiModel = sceneData.MultiModel(model_lst, self.scene)\n        self.scene.multipart_models.append(multiModel)\n\n        self.is_model_loaded = True\n\n        self.scene.normalize_group_of_models(model_lst)\n        multiModel.update_min_max()\n\n        if self.is_multimaterial():\n            self.recalculate_wipe_tower()\n\n\n    def import_model(self, path, one_model=False):\n        self.view.statusBar().showMessage(\'Load file name: \' + path)\n\n        model = ModelTypeStl().load(path, True)\n        model.parent = self.scene\n        self.scene.models.append(model)\n        if self.settings[\'automatic_placing\'] and not one_model:\n            self.scene.automatic_models_position()\n        self.scene.clear_history()\n        self.scene.save_change(self.scene.models)\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            self.recalculate_wipe_tower()\n        self.update_scene()\n        self.is_model_loaded = True\n        return model\n        #self.view.update_scene()\n\n    def import_project(self, path):\n        project_file = ProjectFile(self.scene, path)\n\n        if self.is_multimaterial() and not self.is_single_material_mode():\n            self.recalculate_wipe_tower()\n        self.update_scene()\n\n        #self.view.update_scene()\n\n\n    def save_project(self, path):\n        self.scene.check_models_name()\n        project_file = ProjectFile(self.scene)\n        project_file.save(path)\n        self.scene_was_saved = True\n\n    def update_scene(self, reset=False):\n        self.view.update_scene(reset)\n        if self.status in [\'edit\', \'canceled\']:\n            if self.scene.is_scene_printable():\n                self.enable_generate_button()\n            else:\n                self.disable_generate_button()\n\n    def update_firmware(self):\n        #TODO:Add code for update of firmware\n        pass\n\n    def open_object_settings_dialog(self, object_id):\n        object_settings = self.view.open_object_settings_dialog(object_id)\n\n    def open_settings(self):\n        is_change = False\n        if self.status in [\'generating\', \'generated\', \'loading_gcode\']:\n            editable = False\n        else:\n            editable = True\n        temp_settings, ok = self.view.open_settings_dialog(editable=editable)\n        if not ok:\n            return\n\n        if not temp_settings[\'language\'] == self.settings[\'language\']:\n            self.set_language(temp_settings[\'language\'])\n\n        if not temp_settings[\'printer\'] == self.settings[\'printer\']:\n            is_change = True\n\n        printer_settings = self.printing_parameters.get_printer_parameters(temp_settings[\'printer\'])\n        self.printer_number_of_materials = printer_settings[\'multimaterial\']\n\n        if is_change:\n            self.set_printer(temp_settings[\'printer\'])\n            if self.printer_number_of_materials>1:\n                self.view.set_multimaterial_gui_on(True)\n                #self.view.update_gui_for_material(1)\n                self.update_mm_material_settings()\n                #self.add_wipe_tower()\n                self.update_wipe_tower()\n            else:\n                self.view.set_multimaterial_gui_off(True)\n                #self.view.update_gui_for_material(1)\n                self.remove_wipe_tower()\n            self.view.update_gui_for_material(1)\n\n        self.settings = temp_settings\n\n\n\n    def add_wipe_tower(self):\n        self.scene.create_wipe_tower()\n\n    def remove_wipe_tower(self):\n        self.scene.remove_wipe_tower()\n\n    def update_wipe_tower(self):\n        self.scene.update_wipe_tower()\n\n    def open_about(self):\n        self.view.open_about_dialog()\n\n    def generate_gcode(self):\n        self.set_progress_bar(int((100. / 9.)))\n        if self.scene.models:\n            self.save_whole_scene_to_one_prusa_file(self.app_config.tmp_place + ""tmp.prusa"")\n            #if self.is_multimaterial() and not self.is_single_material_mode():\n            #    self.save_whole_scene_to_one_prusa_file(self.app_config.tmp_place + ""tmp.prusa"")\n            #else:\n            #    self.scene.save_whole_scene_to_one_stl_file(self.app_config.tmp_place + ""tmp.stl"")\n            self.slicer_manager.slice()\n\n    def gcode_generated(self):\n        self.view.enable_save_gcode_button()\n\n    def save_whole_scene_to_one_prusa_file(self, path):\n        self.save_project(path)\n        self.scene_was_saved = False\n\n    def close(self):\n        self.analyzer.cancel_analyz()\n        self.app.exit()\n\n    def set_print_info_text(self, string):\n        #print(""Nejaky text ze Sliceru: "" + string)\n        string = string.split(\' \')\n        self.filament_use = string[0]\n        #self.gcode.set_print_info_text(string[0])\n\n    def scene_was_changed(self):\n        if self.status == \'generating\':\n            self.cancel_generation()\n        self.status = \'edit\'\n        self.scene.analyze_result_data_tmp = []\n        self.set_generate_button()\n        self.set_progress_bar(0.0)\n\n    def wheel_event(self, event):\n        self.view.set_zoom(event.delta() / 120)\n\n        event.accept()\n        self.update_scene()\n\n    def set_camera_move_function(self):\n        self.camera_move=True\n        self.camera_rotate=False\n\n    def set_camera_rotation_function(self):\n        self.camera_move = False\n        self.camera_rotate = True\n        self.cursor_over_object = False\n\n    def set_camera_function_false(self):\n        self.camera_move = False\n        self.camera_rotate = False\n        self.cursor_over_object = False\n\n    def is_some_tool_under_cursor(self, object_id):\n        #print(""Is some tool under cursor"")\n        for tool in self.tools:\n            if tool.id == object_id:\n                return True\n        return False\n\n    def get_tool_by_id(self, object_id):\n        for tool in self.tools:\n            if tool.id == object_id:\n                return tool\n        return None\n\n    def get_object_by_id(self, object_id):\n        for model in self.scene.models:\n            if object_id == model.id:\n                return model\n        return None\n\n\n    def is_some_tool_helper_under_cursor(self, object_id):\n        if object_id == 0:\n            return False\n        for model in self.scene.models:\n            if model.is_wipe_tower:\n                continue\n            if model.selected:\n                if model.rotateXId == object_id:\n                    model.scalenAxis = []\n                    model.selected = True\n                    model.rotationAxis = \'x\'\n                    self.tool = \'rotate\'\n                    return True\n                elif model.rotateYId == object_id:\n                    model.scalenAxis = []\n                    model.selected = True\n                    model.rotationAxis = \'y\'\n                    self.tool = \'rotate\'\n                    return True\n                elif model.rotateZId == object_id:\n                    model.scalenAxis = []\n                    model.selected = True\n                    model.rotationAxis = \'z\'\n                    self.tool = \'rotate\'\n                    return True\n                elif model.scaleXId == object_id:\n                    model.rotationAxis = []\n                    model.selected = True\n                    model.scaleAxis = \'x\'\n                    self.tool = \'scale\'\n                    return True\n                elif model.scaleYId == object_id:\n                    model.rotationAxis = []\n                    model.selected = True\n                    model.scaleAxis = \'y\'\n                    self.tool = \'scale\'\n                    return True\n                elif model.scaleZId == object_id:\n                    model.rotationAxis = []\n                    model.selected = True\n                    model.scaleAxis = \'z\'\n                    self.tool = \'scale\'\n                    return True\n                elif model.scaleXYZId == object_id:\n                    model.rotationAxis = []\n                    model.selected = True\n                    model.scaleAxis = \'XYZ\'\n                    self.tool = \'scale\'\n                    return True\n                else:\n                    model.rotationAxis = []\n                    model.scalenAxis = []\n                    #model.selected = False\n\n\n    def set_active_tool_helper_by_id(self, object_id):\n        pass\n\n\n    def recalculate_wipe_tower(self):\n        #print(""calculating wipe tower"")\n        self.scene.update_wipe_tower()\n\n\n\n\n\n    @staticmethod\n    def is_ctrl_pressed():\n        #print(""is_ctrl_pressed"")\n        modifiers = QApplication.keyboardModifiers()\n        if modifiers == Qt.ControlModifier:\n            return True\n        else:\n            return False\n\n    def is_object_already_selected(self, object_id):\n        #print(""is_object_already_selected"")\n        for model in self.scene.models:\n            #object founded\n            if object_id == model.id:\n                #print(""Je model oznaceny: "" + str(model.selected))\n                if model.selected:\n                    #object is selected\n                    #print(""return True"")\n                    return True\n                else:\n                    #object is not selected\n                    #print(""return False"")\n                    return False\n        #No object with id in scene.models\n        return None\n\n    def unselect_objects_and_select_this_one(self, object_id):\n        self.unselect_objects()\n        one_selected = False\n        for model in self.scene.models:\n            #object founded\n            if object_id == model.id:\n                model.selected = True\n                one_selected = True\n                self.object_select_event_flag = True\n\n        if one_selected:\n            return True\n        else:\n            return False\n\n\n    def unselect_object(self, object_id):\n        for model in self.scene.models:\n            # object founded\n            if object_id == model.id:\n                model.selected = False\n                return True\n        return False\n\n    def select_object(self, object_id):\n        for model in self.scene.models:\n            # object founded\n            if object_id == model.id:\n                model.selected = True\n                self.object_select_event_flag = True\n                self.open_object_settings(object_id)\n                self.scene.last_selected_object = object_id\n                return True\n        return False\n\n\n\n    def unselect_objects(self):\n        #print(""Unselect objects"")\n        for model in self.scene.models:\n            model.selected = False\n\n        if self.status in [\'edit\', \'canceled\']:\n            self.close_object_settings()\n\n    def add_camera_position(self, vec):\n        self.view.add_camera_position(vec)\n\n    def check_rotation_axis(self, event):\n        if self.settings[\'toolButtons\'][\'rotateButton\']:\n            if self.find_object_and_rotation_axis_by_color(event):\n                self.update_scene()\n                #self.view.update_scene()\n\n    def copy_selected_objects(self):\n        self.scene.copy_selected_objects()\n\n    def paste_selected_objects(self):\n        self.scene.paste_selected_objects()\n\n    def delete_selected_objects(self):\n        self.scene.delete_selected_models()\n        self.view.close_object_settings_panel()\n        self.actualize_extruder_set()\n\n    def do_function(self):\n        self.view.glWidget.do_button.press_button()\n\n    def undo_function(self):\n        self.view.glWidget.undo_button.press_button()\n\n\n\n    def key_press_event(self, event):\n        key = event.key()\n\n        if self.status in [\'generating\', \'loading_gcode\']:\n            event.accept()\n            return\n\n        if key in [Qt.Key_Delete, Qt.Key_Backspace] and self.render_status == \'model_view\' and not self.is_ctrl_pressed():\n            self.delete_selected_objects()\n            self.update_scene()\n        elif key in [Qt.Key_C] and self.is_ctrl_pressed() and self.render_status == \'model_view\':\n            #print(""Copy models"")\n            self.copy_selected_objects()\n            self.update_scene()\n        elif key in [Qt.Key_V] and self.is_ctrl_pressed() and self.render_status == \'model_view\':\n            #print(""Paste models"")\n            self.paste_selected_objects()\n            self.update_scene()\n        elif key in [Qt.Key_Z] and self.is_ctrl_pressed() and self.render_status == \'model_view\':\n            #print(""Undo pressed"")\n            self.unselect_tool_buttons()\n            self.undo_function()\n            #self.undo_button_pressed()\n            self.update_scene()\n        elif key in [Qt.Key_Y] and self.is_ctrl_pressed() and self.render_status == \'model_view\':\n            #print(""Redo pressed"")\n            self.unselect_tool_buttons()\n            self.do_function()\n            #self.do_button_pressed()\n            self.update_scene()\n        elif key in [Qt.Key_R] and self.render_status == \'model_view\' and not self.is_ctrl_pressed():\n            #print(""R pressed "")\n            if self.view.glWidget.rotateTool.is_pressed():\n                self.unselect_tool_buttons()\n            else:\n                self.unselect_tool_buttons()\n                self.view.glWidget.rotateTool.press_button()\n            self.update_scene()\n        elif key in [Qt.Key_S] and self.render_status == \'model_view\' and not self.is_ctrl_pressed():\n            #print(""S pressed "")\n            if self.view.glWidget.scaleTool.is_pressed():\n                self.unselect_tool_buttons()\n            else:\n                self.unselect_tool_buttons()\n                self.view.glWidget.scaleTool.press_button()\n            self.update_scene()\n        elif key in [Qt.Key_A] and self.render_status == \'model_view\':\n            if self.is_ctrl_pressed() and not self.settings[\'toolButtons\'][\'rotateButton\'] and not self.settings[\'toolButtons\'][\'scaleButton\']:\n                #print(""A and ctrl pressed"")\n                self.select_all()\n                self.update_scene()\n            elif not self.is_ctrl_pressed() and not self.settings[\'toolButtons\'][\'rotateButton\'] and not self.settings[\'toolButtons\'][\'scaleButton\']:\n                #print(""just A pressed"")\n                self.unselect_tool_buttons()\n                self.scene.automatic_models_position()\n                self.update_scene()\n        elif key in [Qt.Key_I] and self.render_status == \'model_view\' and not self.settings[\'toolButtons\'][\'rotateButton\'] and not self.settings[\'toolButtons\'][\'scaleButton\']:\n            if self.is_ctrl_pressed():\n                #print(""I and ctrl pressed "")\n                self.invert_selection()\n                self.update_scene()\n\n        event.accept()\n\n\n    def mouse_double_click(self, event):\n        event.accept()\n\n\n    def select_all(self):\n        for m in self.scene.models:\n            if m.isVisible:\n                m.selected = True\n\n    def invert_selection(self):\n        for m in self.scene.models:\n            if m.isVisible:\n                m.selected = not m.selected\n\n    \'\'\'\n    def mouse_double_click(self, event):\n        self.mouse_double_click_event_flag = True\n        if self.render_status == \'model_view\' and event.button() & QtCore.Qt.LeftButton:\n            object_id = self.get_id_under_cursor(event)\n            if object_id == 0 or self.is_some_tool_under_cursor(object_id):\n                return\n            else:\n                self.open_object_settings(object_id)\n    \'\'\'\n\n\n    def mouse_press_event(self, event):\n        #print(""Mouse press event"")\n        self.clear_event_flag_status()\n        self.mouse_press_event_flag = True\n\n        newRayStart, newRayEnd = self.view.get_cursor_position(event)\n        self.res_old = sceneData.intersection_ray_plane(newRayStart, newRayEnd)\n        #Je stisknuto prave tlacitko?\n        if event.button() & Qt.RightButton:\n            self.set_camera_move_function()\n        #Je stisknuto leve tlacitko?\n        elif event.button() & Qt.LeftButton:\n            #Je kurzor nad nejakym objektem?\n            if self.render_status == \'model_view\' and self.status in [\'edit\', \'canceled\']:\n                object_id = self.get_id_under_cursor(event)\n                if object_id == 0 and self.settings[\'toolButtons\'][\'supportButton\']:\n                    if self.scene.actual_support:\n                        self.scene.save_actual_support()\n                elif object_id==0:\n                    self.set_camera_rotation_function()\n                else:\n                    #Je pod kurzorem nejaky tool?\n                    if self.is_some_tool_under_cursor(object_id):\n                        #print(""pod kurzorem je Tool"")\n                        #self.unselect_objects()\n                        self.tool_press_event_flag = True\n                        self.tool = self.get_tool_by_id(object_id)\n                        for t in self.tools:\n                            if not t == self.tool:\n                                t.unpress_button()\n                            else:\n                                self.tool.press_button()\n                        #tool.activate_tool()\n\n                    #Je pod kurzorem nejaky tool helper?\n                    elif self.is_some_tool_helper_under_cursor(object_id):\n                        #print(""tool helper under cursor"")\n                        self.tool_helper_press_event_flag = True\n                        #self.set_active_tool_helper_by_id(object_id)\n                        self.prepare_tool(event)\n\n                    elif self.is_object_already_selected(object_id) and self.is_ctrl_pressed():\n                        #print(""object already selected and ctrl pressed"")\n                        self.object_select_event_flag = True\n                        self.cursor_over_object = True\n                        self.unselect_object(object_id)\n                    elif self.is_ctrl_pressed():\n                        #print(""ctrl pressed"")\n                        if self.settings[\'toolButtons\'][\'rotateButton\'] or self.settings[\'toolButtons\'][\'scaleButton\']:\n                            self.unselect_objects()\n                        self.select_object(object_id)\n                        #disable object edit gui, its not possible for group\n                        self.view.disable_object_settings_panel()\n                        self.cursor_over_object = True\n                    elif self.is_object_already_selected(object_id) and self.is_some_tool_active():\n                        #print(""object already selected and tool placeonface is on"")\n                        self.tool=self.get_active_tool()\n                        self.prepare_tool(event)\n                        self.cursor_over_object = True\n                    elif self.is_object_already_selected(object_id):\n                        #print(""object already selected"")\n                        pass\n                        self.cursor_over_object = True\n                    else:\n                        #print(""else"")\n                        self.unselect_objects()\n                        self.select_object(object_id)\n                        self.cursor_over_object = True\n\n                    #print(""Aktualni tool je: "" + self.tool)\n                    self.tool = self.get_active_tool()\n                    #Je objekt oznaceny?\n                    \'\'\'\n                    elif self.is_ctrl_pressed():\n                        if self.is_object_already_selected(object_id):\n                            self.unselect_object(object_id)\n                        else:\n                            self.select_object(object_id)\n                    \'\'\'\n                    #elif self.is_object_already_selected(object_id):\n\n\n                    \'\'\'\n                    elif self.unselect_objects_and_select_this_one(object_id):\n                        print(""Klikani na objekt"")\n                        #nastav funkci na provedeni toolu\n\n                        self.tool = self.get_active_tool()\n                        print(""Aktualni tool je "" + self.tool)\n\n                        #TODO:add function get_active_tool(self) return class tool\n                        #tool = self.get_toolsactive_tool()\n                        #TODO:add function do(self) to class tool\n                        self.prepare_tool(event)\n                    else:\n                        #select object\n                        print(""Else:"")\n                        self.unselect_objects()\n                        self.select_object(object_id)\n                    \'\'\'\n\n\n            else:\n                #print(""Jiny status nez model_view"")\n                self.unselect_objects()\n                self.set_camera_rotation_function()\n        self.update_scene()\n        #self.view.update_scene()\n        event.accept()\n\n\n    def is_some_tool_active(self):\n        for tool in self.tools:\n            if tool.is_pressed() and tool.tool_name==\'placeonface\':\n                return True\n\n        return False\n\n    #def get_active_tool(self):\n    #    for tool in self.tools:\n    #        if tool.is_pressed():\n    #            return tool.tool_name\n\n\n    def prepare_tool(self, event):\n        #print(""prepare tool"")\n        if self.tool == \'rotate\':\n            for model in self.scene.models:\n                if model.selected:\n                    #newRayStart, newRayEnd = self.view.get_cursor_position(event)\n                    #self.origin_rotation_point = sceneData.intersection_ray_plane(newRayStart, newRayEnd)\n                    #self.res_old = self.origin_rotation_point\n                    self.origin_rotation_point = numpy.array([1.,0.,0.])\n                    self.origin_rotation_point += model.pos\n                    self.origin_rotation_point[2] = 0.\n                    self.res_old = self.origin_rotation_point\n                    self.old_angle = model.rot[2]\n            #self.view.glWidget.oldHitPoint = numpy.array([0., 0., 0.])\n            #self.view.glWidget.hitPoint = numpy.array([0., 0., 0.])\n\n\n        elif self.tool == \'placeonface\':\n            #print(""inside placeonface"")\n            ray_start, ray_end = self.view.get_cursor_position(event)\n            for model in self.scene.models:\n                if model.selected:\n                    self.view.glWidget.rayStart = ray_start\n                    self.view.glWidget.rayDir = numpy.array(ray_end) - numpy.array(ray_start)\n                    face = model.place_on_face(ray_start, ray_end)\n                    if not face == []:\n                        self.view.glWidget.v0 = face[0]\n                        self.view.glWidget.v1 = face[1]\n                        self.view.glWidget.v2 = face[2]\n                        #print(""Nalezen objekt "" + str(model))\n        elif self.tool == \'scale\':\n            ray_start, ray_end = self.view.get_cursor_position(event)\n\n            for model in self.scene.models:\n                if model.selected:\n                    if model.is_multipart_model:\n                        #pos = deepcopy(model.multipart_parent.pos)\n                        #pos[2] = 0.\n                        self.original_scale = deepcopy(model.multipart_parent.scale)\n                    else:\n                        #pos = deepcopy(model.pos)\n                        #pos[2] = 0.\n                        self.original_scale = deepcopy(model.scale)\n\n\n    def mouse_move_event(self, event):\n        #print(""Mouse move event"")\n        self.mouse_move_event_flag = True\n        dx = event.x() - self.last_pos.x()\n        dy = event.y() - self.last_pos.y()\n        #diff = numpy.linalg.norm(numpy.array([dx, dy]))\n\n        if self.camera_move and self.mouse_press_event_flag:\n            #print(""camera move"")\n            camStart, camDir, camUp, camRight = self.view.get_camera_direction(event)\n            right_move = -0.025*dx * camRight\n            up_move = 0.025*dy * camUp\n\n            move_vector = right_move + up_move\n            self.add_camera_position(move_vector)\n\n        elif self.camera_rotate and self.mouse_press_event_flag:\n            #print(""camera rotate"")\n            self.view.set_x_rotation(self.view.get_x_rotation() + 8 * dy)\n            self.view.set_z_rotation(self.view.get_z_rotation() + 8 * dx)\n            #camera_pos, direction, _, _ = self.view.get_camera_direction(event)\n            #self.scene.camera_vector = direction - camera_pos\n        #Check if some tool helper is pressed after that decide which tool is selected and\n        #make some change, other way move\n        elif self.tool_helper_press_event_flag:\n            if self.tool == \'rotate\':\n                #print(""rotate function"")\n                newRayStart, newRayEnd = self.view.get_cursor_position(event)\n                res = sceneData.intersection_ray_plane(newRayStart, newRayEnd)\n                if res is not None:\n                    res_new = res - self.res_old\n                    for model in self.scene.models:\n                        if model.selected:\n                            if model.is_multipart_model:\n                                pos = deepcopy(model.multipart_parent.pos)\n                            else:\n                                pos = deepcopy(model.pos)\n                            pos[2] = 0.\n\n                            #New\n                            new_vec = res - pos\n                            #self.view.glWidget.hitPoint = deepcopy(new_vec)\n                            new_vect_leng = numpy.linalg.norm(new_vec)\n                            new_vec /= new_vect_leng\n\n                            old_vec = self.res_old - pos\n                            #self.view.glWidget.oldHitPoint = deepcopy(old_vec)\n                            old_vec /= numpy.linalg.norm(old_vec)\n\n                            cos_ang = numpy.dot(old_vec, new_vec)\n                            cross = numpy.cross(old_vec, new_vec)\n\n                            neg = numpy.dot(cross, numpy.array([0., 0., 1.]))\n                            sin_ang = numpy.linalg.norm(cross) * numpy.sign(neg) * -1.\n\n                            alpha = numpy.arctan2(sin_ang, cos_ang)\n\n                            radius = model.max_bs\n\n                            if radius < 2.5:\n                                radius = 2.5\n                            radius *=.7\n\n                            if new_vect_leng >= radius:\n                                if numpy.abs(alpha - numpy.pi) <= 0.05:\n                                    alpha = numpy.pi\n\n                                if model.is_multipart_model:\n                                    model.set_rot(model.multipart_parent.rot[0], model.multipart_parent.rot[1], numpy.around(alpha, decimals=3), False, False, False)\n                                else:\n                                    model.set_rot(model.rot[0], model.rot[1], numpy.around(alpha, decimals=3), False, False, False)\n                            else:\n                                alpha_new = numpy.degrees(alpha) // 45.\n                                if model.is_multipart_model:\n                                    model.set_rot(model.multipart_parent.rot[0], model.multipart_parent.rot[1], alpha_new*(numpy.pi*.25), False, False, False)\n                                else:\n                                    model.set_rot(model.rot[0], model.rot[1], alpha_new*(numpy.pi*.25), False, False, False)\n\n                            #self.view.update_object_settings(model.id)\n                            self.view.update_rotate_widgets(model.id)\n                            self.scene_was_changed()\n            elif self.tool == \'scale\':\n                #print(""scale function"")\n                ray_start, ray_end = self.view.get_cursor_position(event)\n                # camera_pos, direction, _, _ = self.view.get_camera_direction(event)\n                for model in self.scene.models:\n                    if model.selected:\n                        if model.is_multipart_model:\n                            pos = deepcopy(model.multipart_parent.pos)\n                            model_size_origin = deepcopy(model.multipart_parent.size_origin)\n                        else:\n                            pos = deepcopy(model.pos)\n                            model_size_origin = deepcopy(model.size_origin)\n\n                        pos[2] = 0.\n                        new_scale_point = numpy.array(sceneData.intersection_ray_plane(ray_start, ray_end))\n                        new_scale_vect = new_scale_point - pos\n\n                        l = numpy.linalg.norm(new_scale_vect)\n                        l -= .5\n\n                        new_size = self.original_scale * model_size_origin\n                        new_size[2] = 0.\n                        new_size *= .5\n\n                        origin_size = deepcopy(model_size_origin)\n                        origin_size[2] = 0.\n                        origin_size *= .5\n\n                        if self.original_scale[0] == self.original_scale[1] == self.original_scale[2]:\n                            #same proportion\n                            v = l / numpy.linalg.norm(origin_size)\n                            new_scale = numpy.array([v, v, v])\n                        else:\n                            v = l / numpy.linalg.norm(new_size)\n                            new_scale = numpy.array([v*(self.original_scale)[0],\n                                                v*(self.original_scale)[1],\n                                                v*(self.original_scale)[2]])\n\n\n                        new_scale = numpy.abs(new_scale)\n                        model.set_scale_abs(new_scale[0], new_scale[1], new_scale[2])\n\n\n                        #self.last_l = l\n\n                        self.view.update_scale_widgets(model.id)\n                        self.scene_was_changed()\n        #Move function\n        elif self.settings[\'toolButtons\'][\'supportButton\']:\n            #print(""support function"")\n            newRayStart, newRayEnd = self.view.get_cursor_position(event)\n            res = sceneData.intersection_ray_plane(newRayStart, newRayEnd)\n            if res is not None:\n                self.scene.calculate_support(res)\n\n        elif not self.tool_helper_press_event_flag \\\n                and self.mouse_press_event_flag \\\n                and self.cursor_over_object:\n            #print(""move function"")\n            newRayStart, newRayEnd = self.view.get_cursor_position(event)\n            res = sceneData.intersection_ray_plane(newRayStart, newRayEnd)\n            if res is not None:\n                res_new = res - self.res_old\n                for model in self.scene.models:\n                    if model.selected:\n                        model.set_move(res_new)\n                        #self.view.update_object_settings(model.id)\n                        self.view.update_position_widgets(model.id)\n                        self.scene_was_changed()\n                self.res_old = res\n\n        else:\n            #print(""Mouse move event else vetev"")\n            if self.render_status == \'model_view\':\n                object_id = self.get_id_under_cursor(event)\n                #TOOLs hover effect\n                if object_id > 0:\n                    #Je pod kurzorem nejaky tool?\n                    for tool in self.tools:\n                        if tool.id == object_id:\n                            tool.mouse_is_over(True)\n                            self.view.glWidget.setToolTip(tool.tool_tip)\n                        else:\n                            tool.mouse_is_over(False)\n\n                    #if self.settings[\'toolButtons\'][\'rotateButton\']:\n                    #    self.select_tool_helper_by_id(object_id)\n                        #for tool_helper in self.get_tools_helpers_id(1,0):\n                        #    if tool_helper == object_id:\n                else:\n                    #TODO:Disable tooltip\n                    self.view.glWidget.setToolTip("""")\n                    for tool in self.tools:\n                        tool.mouse_is_over(False)\n        event.accept()\n\n\n        self.last_pos = QPoint(event.pos())\n        self.update_scene()\n        #self.view.update_scene()\n\n    def select_tool_helper(self, event):\n        object_id = self.get_id_under_cursor(event)\n        if object_id > 0:\n            self.select_tool_helper_by_id(object_id)\n\n    def select_tool_helper_by_id(self, object_id):\n        for m in self.scene.models:\n            if m.isVisible:\n                if object_id == m.rotateZId:\n                    m.rotationAxis = ""Z""\n                    m.scaleAxis = """"\n                elif object_id == m.scaleXYZId:\n                    m.scaleAxis = ""XYZ""\n                    m.rotationAxis = """"\n                else:\n                    m.rotationAxis = """"\n                    m.scaleAxis = """"\n\n    #def support_tool_button_pressed(self):\n    #    self.tool = ""support""\n\n    def organize_button_pressed(self):\n        self.scene.automatic_models_position()\n\n    def get_active_tool(self):\n        for tool in self.tools:\n            if tool.pressed:\n                #print(""Tool name: "" + str(tool.tool_name))\n                return tool.tool_name\n        return \'move\'\n\n    def mouse_release_event(self, event):\n        models_list = []\n        #print(""Mouse releas event"")\n        self.mouse_release_event_flag = True\n        self.set_camera_function_false()\n        if self.tool in [\'move\', \'rotate\', \'scale\', \'placeonface\']:\n            self.old_angle = 0.0\n            for model in self.scene.models:\n                if model.selected:\n                    if model.is_multipart_model:\n                        model.multipart_parent.update_min_max()\n                        if not self.tool == \'scale\':\n                            model.multipart_parent.recalc_bounding_sphere()\n                        #TODO: add history for operations\n                    else:\n                        model.update_min_max()\n                        if not self.tool == \'scale\':\n                            model.recalc_bounding_sphere()\n                        models_list.append(model)\n            if models_list and self.mouse_move_event_flag:\n                self.scene.save_change(self.scene.models)\n                #self.scene.save_change(models_list)\n\n            self.update_wipe_tower()\n\n        self.tool = \'\'\n        self.res_old = numpy.array([0.,0.,0.])\n\n        if event.button() & Qt.LeftButton and self.mouse_press_event_flag and\\\n                self.mouse_release_event_flag and self.mouse_move_event_flag == False and\\\n                self.object_select_event_flag==False and self.tool_press_event_flag == False:\n            #print(""Podminky splneny"")\n            self.clear_event_flag_status()\n            self.unselect_objects()\n        self.update_scene()\n        event.accept()\n\n        self.make_analyze()\n\n\n    def make_analyze(self):\n        if self.scene.was_changed() and self.settings[\'analyze\']:\n            self.scene.set_no_changes()\n            self.analyzer.make_analyze(self.analyze_done, self.set_analyze_result_messages)\n\n\n    def analyze_done(self):\n        self.scene.set_no_changes()\n\n\n    def open_object_settings(self, object_id):\n        self.set_basic_settings()\n        self.view.create_object_settings_menu(object_id)\n\n    def close_object_settings(self):\n        self.set_basic_settings()\n        self.view.close_object_settings_panel()\n\n    def set_printable(self, is_printable):\n        self.scene.printable = is_printable\n        if is_printable == False:\n            #print(""Disable genrate button"")\n            self.disable_generate_button()\n        else:\n            #print(""Enable genrate button"")\n            self.enable_generate_button()\n\n    def disable_generate_button(self):\n        self.view.disable_generate_button()\n\n    def enable_generate_button(self):\n        self.view.enable_generate_button()\n\n    def hit_objects(self, event):\n        possible_hit = []\n        nSelected = 0\n\n        self.ray_start, self.ray_end = self.view.get_cursor_position(event)\n\n        for model in self.scene.models:\n            if model.intersection_ray_bounding_sphere(self.ray_start, self.ray_end):\n                possible_hit.append(model)\n                nSelected+=1\n            else:\n                #print(""Tady bych to necekal"")\n                model.selected = False\n\n        if not nSelected:\n            return False\n\n        #print(""A tady taky ne"")\n        for model in possible_hit:\n            if model.intersection_ray_model(self.ray_start, self.ray_end):\n                model.selected = not model.selected\n            else:\n                model.selected = False\n\n        return False\n\n    def hit_first_object(self, event):\n        possible_hit = []\n        nSelected = 0\n        self.ray_start, self.ray_end = self.view.get_cursor_position(event)\n        self.scene.clear_selected_models()\n\n        for model in self.scene.models:\n            if model.intersection_ray_bounding_sphere(self.ray_start, self.ray_end):\n                possible_hit.append(model)\n                nSelected+=1\n\n        if not nSelected:\n            return False\n\n        for model in possible_hit:\n            if model.intersection_ray_model(self.ray_start, self.ray_end):\n                model.selected = True\n                return True\n\n        return False\n\n    def reset_transformation_on_object(self, object_id):\n        object = self.get_object_by_id(object_id)\n        object.reset_transformation()\n\n\n\n#    @timing\n    def get_id_under_cursor(self, event):\n        return self.view.glWidget.get_id_under_cursor(event.x(), event.y())\n\n    def hit_tool_button_by_color(self, event):\n        find_id = self.get_id_under_cursor(event)\n        if find_id == 0:\n            return False\n        id_list = [i.id for i in self.view.get_tool_buttons()]\n        if find_id in id_list:\n            for toolButton in self.view.get_tool_buttons():\n                if find_id == toolButton.id:\n                    toolButton.press_button()\n                else:\n                    toolButton.unpress_button()\n        return False\n\n    def hit_first_object_by_color(self, event, add=False):\n        if not add:\n            self.scene.clear_selected_models()\n        find_id = self.get_id_under_cursor(event)\n        if find_id == 0:\n            return False\n        for model in self.scene.models:\n            if find_id in model.get_id():\n                #print(""Tady to je!!!"")\n                model.selected = not model.selected\n                return True\n\n    def reset_scene(self):\n        self.scene.clear_scene()\n        self.update_scene(True)\n        self.is_model_loaded = False\n        self.scene.is_wipe_tower_position_manual = False\n        if self.is_multimaterial():\n            self.actualize_extruder_set()\n            self.add_wipe_tower()\n        #self.view.update_scene(True)\n\n    def clear_gui(self):\n        self.view.reinit()\n\n    def reset(self):\n        #reset render mode\n        self.scene_was_changed()\n        self.set_model_edit_view()\n        #reset gcode data\n        self.clear_gcode()\n        #reset gui\n        self.clear_gui()\n        self.reset_scene()\n        self.analyze_result = {}\n\n    def import_image(self, path):\n        #TODO:Add importing of image(just plane with texture?)\n        pass\n\n    def undo_button_pressed(self):\n        #print(""Undo"")\n        self.clear_tool_button_states()\n        self.scene.make_undo()\n        self.update_scene()\n\n    def do_button_pressed(self):\n        #print(""Do"")\n        self.clear_tool_button_states()\n        self.scene.make_do()\n        self.update_scene()\n\n    def select_button_pressed(self):\n        self.clear_tool_button_states()\n        self.settings[\'toolButtons\'][\'selectButton\'] = True\n        self.update_scene()\n        #self.view.update_scene()\n\n    def move_button_pressed(self):\n        if self.settings[\'toolButtons\'][\'moveButton\']:\n            self.settings[\'toolButtons\'][\'moveButton\'] = not(self.settings[\'toolButtons\'][\'moveButton\'])\n        else:\n            self.clear_tool_button_states()\n            self.settings[\'toolButtons\'][\'moveButton\'] = True\n        self.update_scene()\n        #self.view.update_scene()\n\n    def rotate_button_pressed(self):\n        if self.settings[\'toolButtons\'][\'rotateButton\']:\n            self.settings[\'toolButtons\'][\'rotateButton\'] = not(self.settings[\'toolButtons\'][\'rotateButton\'])\n        else:\n            self.clear_tool_button_states()\n            self.settings[\'toolButtons\'][\'rotateButton\'] = True\n        self.update_scene()\n        self.unselect_objects()\n        self.select_object(self.scene.last_selected_object)\n        #self.view.update_scene()\n\n    def support_button_pressed(self):\n        if self.settings[\'toolButtons\'][\'supportButton\']:\n            self.settings[\'toolButtons\'][\'supportButton\'] = not(self.settings[\'toolButtons\'][\'supportButton\'])\n        else:\n            self.clear_tool_button_states()\n            self.settings[\'toolButtons\'][\'supportButton\'] = True\n        self.update_scene()\n\n\n    def scale_button_pressed(self):\n        if self.settings[\'toolButtons\'][\'scaleButton\']:\n            self.settings[\'toolButtons\'][\'scaleButton\'] = not(self.settings[\'toolButtons\'][\'scaleButton\'])\n        else:\n            self.clear_tool_button_states()\n            self.settings[\'toolButtons\'][\'scaleButton\'] = True\n        self.update_scene()\n        self.unselect_objects()\n        self.select_object(self.scene.last_selected_object)\n        #self.view.update_scene()\n\n    def place_on_face_button_pressed(self):\n        #TODO:Add new tool\n        pass\n\n    def clear_tool_button_states(self):\n        self.settings[\'toolButtons\'] = {a: False for a in self.settings[\'toolButtons\']}\n\n    def slicing_message(self, string_in):\n        #Translation of messages from slicing engine\n        translation_table = {\'Generating perimeters\': self.tr(\'Generating perimeters\'),\n                             \'Processing triangulated mesh\': self.tr(\'Processing triangulated mesh\'),\n                             \'Infilling layers\': self.tr(\'Infilling layers\'),\n                             \'Preparing infill\': self.tr(\'Preparing infill\'),\n                             \'Generating skirt\': self.tr(\'Generating skirt\'),\n                             \'Exporting G-code to\': self.tr(\'Exporting G-code to\'),\n                             \'Done. Process took\': self.tr(\'Done. Process took\')\n                             }\n\n        string_in_str = str(string_in)\n        if string_in_str in translation_table:\n            string_out = translation_table[string_in_str]\n        else:\n            string_out = string_in\n\n        self.show_message_on_status_bar(string_out)\n\n\n    def show_message_on_status_bar(self, string):\n        self.view.statusBar().showMessage(string)\n\n    def open_clear_scene_and_load_gcode_file(self):\n        ret = self.view.show_clear_scene_and_load_gcode_file_dialog()\n        if ret == QMessageBox.Yes:\n            self.scene.clear_scene()\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n    def open_cancel_gcode_preview_dialog(self):\n        ret = self.view.show_open_cancel_gcode_preview_dialog()\n        if ret == QMessageBox.Yes:\n            self.status = \'edit\'\n            self.set_model_edit_view()\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n\n    def get_url_from_local_fileid(self, localFileID):\n        if not self.app_config.system_platform in [""Darwin""]:\n            return """"\n        else:\n            import objc\n            import CoreFoundation as CF\n\n            relCFURL = CF.CFURLCreateWithFileSystemPath(\n                CF.kCFAllocatorDefault,\n                localFileID,\n                CF.kCFURLPOSIXPathStyle,\n                False  # is directory\n            )\n            absCFURL = CF.CFURLCreateFilePathURL(\n                CF.kCFAllocatorDefault,\n                relCFURL,\n                objc.NULL\n            )\n            url_tmp = str(absCFURL[0])\n            if url_tmp.startswith(\'file://\'):\n                url = url_tmp[7:]\n            else:\n                url = url_tmp\n            url = url.replace(\'%20\', \' \')\n\n            return url\n\n    def open_ask_multipart_model_dialog(self):\n        ret = self.view.show_ask_multipart_model_dialog()\n        if ret == QMessageBox.Yes:\n            self.cancel_generation()\n            return True\n        elif ret == QMessageBox.No:\n            return False\n\n    def open_files(self, list_of_urls_tmp):\n        list_of_urls = []\n        list_of_urls_tmp2 = []\n        if self.app_config.system_platform in [""Darwin""]:\n            for url in list_of_urls_tmp:\n                if url.startswith(\'/.file/id=\'):\n                    list_of_urls_tmp2.append(self.get_url_from_local_fileid(url))\n                else:\n                    list_of_urls_tmp2.append(url)\n        else:\n            list_of_urls_tmp2 = list_of_urls_tmp\n\n        list_of_urls = sorted(list_of_urls_tmp2)\n\n        extensions_lst = []\n        for url in list_of_urls:\n            urlSplited = url.split(\'.\')\n            if len(urlSplited) == 2:\n                fileEnd = urlSplited[1]\n            elif len(urlSplited) > 2:\n                fileEnd = urlSplited[-1]\n            else:\n                fileEnd = \'\'\n            extensions_lst.append(fileEnd.lower())\n\n        extensions_set = set(extensions_lst)\n        if len(extensions_set) == 1:\n            if list(extensions_set)[0] in [\'stl\']:\n                #show message of multipart model\n                if self.open_ask_multipart_model_dialog():\n                    #load together\n                    self.load_multipart_model(list_of_urls)\n                else:\n                    #load separately\n                    for url in list_of_urls:\n                        self.import_model(url)\n            self.show_warning_if_used_materials_are_not_compatible()\n        else:\n            self.view.statusBar().showMessage(""Some files mismatch"")\n\n        self.actualize_extruder_set()\n\n    def find_network_printers(self):\n        pass\n\n\n    def open_file(self, url):\n        \'\'\'\n        function for resolve which file type will be loaded\n        \'\'\'\n        #print(""Urls type: "" + str(type(url)))\n\n        if self.status in [\'generating\']:\n            if not self.open_cancel_generating_dialog():\n                return\n        elif self.status in [\'loading_gcode\']:\n            if not self.open_cancel_gcode_reading_dialog():\n                return\n        elif self.status in [\'generated\']:\n            if not self.open_cancel_gcode_preview_dialog():\n                return\n\n\n        if self.app_config.system_platform in [""Darwin""]:\n            if url.startswith(\'/.file/id=\'):\n                url = self.get_url_from_local_fileid(url)\n\n\n\n        urlSplited = url.split(\'.\')\n        if len(urlSplited)==2:\n            fileEnd = urlSplited[1]\n        elif len(urlSplited)>2:\n            fileEnd = urlSplited[-1]\n        else:\n            fileEnd=\'\'\n\n        if fileEnd in [\'stl\', \'STL\', \'Stl\']:\n            #print(\'import model\')\n            self.import_model(url)\n        elif fileEnd in [\'prusa\', \'PRUSA\']:\n            #print(\'open project\')\n\n            self.open_project_file(url)\n        elif fileEnd in [\'jpeg\', \'jpg\', \'png\', \'bmp\']:\n            #print(\'import image\')\n            self.import_image(url)\n        elif fileEnd in [\'gcode\']:\n            if self.is_something_to_save():\n                if not self.open_clear_scene_and_load_gcode_file():\n                    return\n            self.read_gcode(url)\n\n        self.actualize_extruder_set()\n\n\n'"
gcode.py,97,"b'# -*- coding: utf-8 -*-\n__author__ = \'Tibor Vavra\'\n\nimport time\n#from fastnumbers import fast_float\nfrom collections import defaultdict\nfrom copy import deepcopy\nfrom pprint import pprint\nimport os\n\nimport numpy as np\nfrom PyQt4.QtCore import QFile\nfrom PyQt4.QtCore import QIODevice\nfrom PyQt4.QtCore import QObject\nfrom PyQt4.QtCore import QTextStream\nfrom PyQt4.QtCore import QThread\nfrom PyQt4.QtCore import pyqtSignal\n\n\nDEBUG = False\n\nclass GCode(object):\n\n    def __init__(self, filename, controller, done_loading_callback, done_writing_callback):\n        self.controller = controller\n        self.done_loading_callback = done_loading_callback\n        self.writing_done_callback = done_writing_callback\n        self.data = defaultdict(list)\n        self.all_data = []\n        self.data_keys = set()\n        self.color_change_data = []\n        self.actual_z = \'0.0\'\n        self.speed = 0.0\n        self.z_hop = False\n        self.last_point = np.array([0.0, 0.0, 0.0])\n        self.actual_point = [0.0, 0.0, 0.0]\n\n        self.printing_time = 0.0\n        self.filament_length = 0.0\n        #print(""Filename type: "" + str(type(filename)))\n        #print(""Filename: "" + filename)\n        #if type(filename)==:\n        #self.filename = u\'c:\\\\models\\\\super mega testovac\xc3\xad Jind\xc5\x99ich \xc5\xa1lo\xc5\xbeka \xc4\x8d\xc4\x9b\xc3\xbd\xc3\xa1\xc3\xa9\xc5\xaf\xc3\xba\\\\anubis_PLA_OPTIMAL.gcode\'\n        self.filename = filename\n\n        self.is_loaded = False\n\n        self.gcode_parser = GcodeParserRunner(controller, self.filename)\n        self.gcode_parser_thread = QThread()\n\n        self.gcode_copy = GcodeCopyRunner(self.filename, """", color_change_lst=self.color_change_data)\n        self.gcode_copy_thread = QThread()\n\n    def set_running_variable(self, variable):\n        if self.gcode_parser:\n            self.gcode_parser.is_running = variable\n\n    def cancel_parsing_gcode(self):\n        print(""Cancel presset"")\n        if self.gcode_parser and self.gcode_parser_thread and self.gcode_parser_thread.isRunning():\n            self.gcode_parser.is_running = False\n            self.gcode_parser_thread.quit()\n            self.gcode_parser_thread.wait()\n            self.is_loaded = False\n            self.data = {}\n            self.all_data = []\n            self.data_keys = []\n        elif self.gcode_parser and self.gcode_parser.is_running==True:\n            self.gcode_parser.is_running = False\n        self.controller.set_progress_bar(0)\n\n    def cancel_writing_gcode(self):\n        print(""Cancel writing gcode"")\n        if self.gcode_copy and self.gcode_copy_thread and self.gcode_copy_thread.isRunning():\n            self.gcode_copy.quit()\n            self.gcode_copy_thread.wait()\n\n    def get_first_extruding_line_number_of_gcode_for_layers(self, layers_keys_lst):\n        lines_number = []\n        for i in layers_keys_lst:\n            line = self.data[i]\n            for o in line:\n                _a, _b, type, _speed, _extr, _extruder, line_n = o\n                if type >= 1.0:\n                    lines_number.append(line_n)\n                    break\n\n        return lines_number\n\n\n\n    def read_in_thread(self, update_progressbar_function, after_done_function):\n        print(""reading in thread"")\n        self.gcode_parser.moveToThread(self.gcode_parser_thread)\n        self.done_loading_callback = after_done_function\n\n        # connect all signals to thread class\n        self.gcode_parser_thread.started.connect(self.gcode_parser.load_gcode_file)\n        # connect all signals to parser class\n        self.gcode_parser.finished.connect(self.set_finished_read)\n        self.gcode_parser.update_progressbar=True\n        self.gcode_parser.set_update_progress.connect(update_progressbar_function)\n        self.gcode_parser.set_data_keys.connect(self.set_data_keys)\n        self.gcode_parser.set_data.connect(self.set_data)\n        self.gcode_parser.set_all_data.connect(self.set_all_data)\n        self.gcode_parser.set_printing_time.connect(self.set_printig_time)\n\n        self.gcode_parser_thread.start()\n\n\n    def read_in_realtime(self, update_progressbar=False, progressbar_func=None):\n        self.gcode_parser.set_data_keys.connect(self.set_data_keys)\n        self.gcode_parser.set_data.connect(self.set_data)\n        self.gcode_parser.set_all_data.connect(self.set_all_data)\n        self.gcode_parser.set_printing_time.connect(self.set_printig_time)\n        if update_progressbar and progressbar_func:\n            self.gcode_parser.update_progressbar = update_progressbar\n            self.gcode_parser.set_update_progress.connect(progressbar_func)\n\n        if self.gcode_parser.load_gcode_file():\n            self.is_loaded = True\n            return True\n        else:\n            return False\n\n\n    def set_printig_time(self, time):\n        self.printing_time = time\n\n    def set_data_keys(self, data_keys):\n        self.data_keys = data_keys\n\n    def set_all_data(self, all_data):\n        self.all_data = all_data\n\n    def set_data(self, data):\n        self.data = data\n\n    def set_finished_read(self):\n        self.gcode_parser_thread.quit()\n        self.is_loaded = True\n        self.done_loading_callback()\n        #self.controller.set_gcode()\n\n    def set_finished_copy(self):\n        self.gcode_copy_thread.quit()\n        #print(str(self.writing_done_callback))\n        self.writing_done_callback()\n\n    def set_color_change_data(self, data):\n        self.color_change_data = data\n\n\n    def write_with_changes_in_thread(self, filename_in, filename_out, update_function):\n        self.gcode_copy.filename_in = filename_in\n        self.gcode_copy.filename_out = filename_out\n        self.gcode_copy.color_change_lst = self.color_change_data\n        self.gcode_copy.moveToThread(self.gcode_copy_thread)\n\n        self.gcode_copy_thread.started.connect(self.gcode_copy.write_file)\n\n        self.gcode_copy.finished.connect(self.set_finished_copy)\n        self.gcode_copy.set_update_progress.connect(update_function)\n\n        self.gcode_copy_thread.start()\n\n\n\n\nclass GcodeCopyRunner(QObject):\n    finished = pyqtSignal()\n    set_update_progress = pyqtSignal(int)\n\n    def __init__(self, filename_in, filename_out, color_change_lst):\n        super(GcodeCopyRunner, self).__init__()\n        self.filename_in = filename_in\n        self.filename_out = filename_out\n        self.color_change_lst = color_change_lst\n        self.is_running = True\n\n\n    def write_file(self):\n\n        if self.color_change_lst:\n            self.copy_file_with_progress_and_color_changes(self.filename_in, self.filename_out)\n        else:\n            self.copy_file_with_progress(self.filename_in, self.filename_out)\n\n    def copy_file_with_progress_and_color_changes(self, filename_in, filename_out, length=16*1024):\n        f_src = open(filename_in, \'r\')\n        f_dst = open(filename_out, \'w\')\n\n        fsrc_size = os.fstat(f_src.fileno()).st_size\n\n        copied = 0\n        line_number = 0\n        while self.is_running is True:\n            buf = f_src.readline()\n            line_number += 1\n            if not buf:\n                self.finished.emit()\n                break\n            if line_number in self.color_change_lst:\n                f_dst.write(""M600\\n"")\n            f_dst.write(buf)\n            copied += len(buf)\n            self.set_update_progress.emit((copied * 1. / fsrc_size * 1.)*100)\n\n            #progress_callback((copied * 1. / fsrc_size * 1.))\n\n\n    def copy_file_with_progress(self, filename_in, filename_out, length=16*1024):\n        f_src = open(filename_in, \'r\')\n        f_dst = open(filename_out, \'w\')\n\n        fsrc_size = os.fstat(f_src.fileno()).st_size\n\n        copied = 0\n        while self.is_running is True:\n            buf = f_src.read(length)\n            if not buf:\n                self.finished.emit()\n                break\n            f_dst.write(buf)\n            copied += len(buf)\n            self.set_update_progress.emit((copied * 1. / fsrc_size * 1.)*100)\n            #progress_callback((copied * 1. / fsrc_size * 1.))\n\n\n\nclass GcodeParserRunner(QObject):\n    finished = pyqtSignal()\n    set_data_keys = pyqtSignal(list)\n    set_data = pyqtSignal(dict)\n    set_all_data = pyqtSignal(list)\n    set_printing_time = pyqtSignal(float)\n    set_update_progress = pyqtSignal(int)\n\n\n    def __init__(self, controller, filename):\n        super(GcodeParserRunner, self).__init__()\n        self.is_running = True\n        self.controller = controller\n        self.filename = filename\n        self.update_progressbar=False\n\n        self.data = defaultdict(list)\n        self.all_data = []\n        self.sleep_data = []\n        self.tool_change_data = []\n        self.data_keys = set()\n        self.actual_z = \'0.0\'\n        self.actual_tool = 0\n        self.speed = 1500.0\n        self.extrusion = 0.0\n        self.z_hop = False\n        self.last_point = np.array([0.0, 0.0, 0.0])\n        self.actual_point = np.array([0.0, 0.0, 0.0])\n        self.absolute_coordinates = True\n\n        self.printing_time = 0.0\n        self.filament_length = 0.0\n\n\n    def cancel_parsing(self):\n        self.is_running = False\n\n    def load_gcode_file(self):\n        file = QFile(self.filename)\n        file.open(QIODevice.ReadOnly | QIODevice.Text)\n        in_stream = QTextStream(file)\n        file_size = file.size()\n        counter = 0\n        line = 0\n        line_number = 0\n        while not in_stream.atEnd():\n            if self.is_running == False:\n                return False\n\n            if self.update_progressbar:\n                if counter==10000:\n                    #in_stream.pos() je hodne pomala funkce takze na ni pozor!!!\n                    progress = (in_stream.pos()*1./file_size*1.) * 100.\n                    self.set_update_progress.emit(int(progress))\n                    counter=0\n                else:\n                    counter+=1\n\n            line = in_stream.readLine()\n            bits = line.split(\';\', 1)\n            bits_len = len(bits)\n\n            if bits[0] == \'\':\n                line_number+=1\n                if bits_len > 1:\n                    if bits[0] == \'\' and bits[1] == ""END gcode for filament"":\n                        break\n                continue\n\n            if \'G1 \' in bits[0]:\n                self.parse_g1_line_new(bits, line_number)\n            elif \'G4\' in bits[0]:\n                self.parse_g4_line(bits, line_number)\n            elif \'T0\' in bits[0] or \'T1\' in bits[0] or \'T2\' in bits[0] or \'T3\' in bits[0]:\n                self.parse_t_line(bits, line_number)\n            elif \'G90\' in bits[0]:\n                self.absolute_coordinates = True\n            elif \'G91\' in bits[0]:\n                self.absolute_coordinates = False\n            elif \'G92\' in bits[0]:\n                self.parse_g92_line(bits, line_number)\n            else:\n                if DEBUG:\n                    print(""Nezpracovano: "" + str(bits))\n                line_number += 1\n                continue\n            line_number += 1\n\n        if self.is_running is False and self.update_progressbar is True:\n            self.set_update_progress.emit(0)\n            return False\n\n        self.printing_time = self.calculate_time_of_print()\n        self.filament_length = 0.0  # self.calculate_length_of_filament()\n\n        ###\n        self.non_extruding_layers = []\n\n        for i in self.data:\n            layer_flag = \'M\'\n            for l in self.data[i]:\n                _start, _end, flag, _speed, _extrusion, _extruder, _line = l\n                if flag >= 1.0:\n                    layer_flag = \'E\'\n                    break\n            if layer_flag == \'M\':\n                self.non_extruding_layers.append(i)\n\n\n\n        for i in self.non_extruding_layers:\n            self.data.pop(i, None)\n\n        #print(""data after:"")\n        #pprint(len(self.data))\n\n        self.data_keys = set()\n        self.data_keys = set(self.data)\n        self.data_keys = sorted(self.data_keys, key=float)\n\n\n        self.set_data_keys.emit(self.data_keys)\n        self.set_data.emit(self.data)\n        self.set_all_data.emit(self.all_data)\n        self.set_printing_time.emit(self.printing_time)\n\n        self.finished.emit()\n        return True\n\n\n    def calculate_time_of_print(self):\n        time_of_print = 0.0\n        all_data = self.all_data\n        number_of_tool_change = len(self.tool_change_data)\n\n        #vectorization speed up\n        a_vect = np.array([i[0] for i in all_data])\n        b_vect = np.array([i[1] for i in all_data])\n        speed_vect = np.array([i[3] for i in all_data])\n\n        vect_vect = b_vect - a_vect\n        #print(""vect_vect: "" + str(vect_vect.tolist()))\n        leng_vect = np.linalg.norm(vect_vect, axis=1)\n        #print(""leng_vect: "" + str(leng_vect.tolist()))\n        time_vect = np.divide(leng_vect, speed_vect)\n        time_of_print = np.sum(time_vect)\n\n        print(""Time of print0: "" + str(time_of_print))\n\n        #Magic constant :-)\n        time_of_print *= 1.1\n        print(""Time of print1: "" + str(time_of_print))\n\n        sum_of_sleep = np.sum(self.sleep_data)\n        print(""Sum of sleep: "" + str(sum_of_sleep))\n        time_of_print += sum_of_sleep\n\n        print(""Time of print2: "" +str(time_of_print))\n\n        #speed is in mm/min => mm/sec\n        return time_of_print*60.\n\n    def calculate_length_of_filament(self):\n        length = 0.0\n        for line in self.all_data:\n            if line[2]==\'M\':\n                continue\n            a = np.array(line[0])\n            b = np.array(line[1])\n            vect = b-a\n            leng = np.linalg.norm(vect)\n            length+=leng\n\n        return length\n\n    def set_print_info_text(self, string):\n        print(""Info: "" + string)\n\n    #only T lines\n    def parse_t_line(self, data, line_number):\n        if len(data)>1:\n            text = data[0]\n            comment = data[1]\n        else:\n            text = data[0]\n            comment = """"\n\n        line = text.split(\' \')\n        line = list(filter(None, line))\n        line_len = len(line)\n\n        comment_line = comment.split(\' \')\n        comment_line = list(filter(None, comment_line))\n\n        if \'T?\' in line[0]:\n            return\n        else:\n            self.tool_change_data.append(int(line[0][1:]))\n            self.actual_tool = int(line[0][1:])\n\n\n    #only G4 lines\n    def parse_g4_line(self, data, line_number):\n        if len(data)>1:\n            text = data[0]\n            comment = data[1]\n        else:\n            text = data[0]\n            comment = """"\n\n        line = text.split(\' \')\n        line = list(filter(None, line))\n        line_len = len(line)\n\n        comment_line = comment.split(\' \')\n        comment_line = list(filter(None, comment_line))\n\n        if line_len > 1:\n            if \'S\' in line[1]:\n                self.sleep_data.append(float(line[1][1:]))\n                #set sleep\n\n\n\n    \'\'\'\n    #only G1 lines\n    def parse_g1_line(self, data, line_number):\n        if len(data)>1:\n            text = data[0]\n            comment = data[1]\n        else:\n            text = data[0]\n            comment = """"\n\n        line = text.split(\' \')\n        line = list(filter(None, line))\n\n        #print(comment)\n        comment_line = comment.split(\' \')\n        comment_line = list(filter(None, comment_line))\n\n        if len(comment_line)==0:\n            # Uncomented gcode\n            if \'Z\' in line[1]:\n                # Set of Z axis\n                new_z = float(line[1][1:])\n                self.actual_z = ""%.2f"" % new_z\n                self.last_point[2] = new_z\n                return\n            elif \'F\' in line[1]:\n                self.speed = float(line[1][1:])\n            elif \'X\' in line[1] and \'Y\' in line[2] and not (\'E\' in line[3]) and \'F\' in line[3]:\n                # elif \'X\' in line[1] and \'Y\' in line[2] and not (\'E\' in line[3]) and \'F\' in line[3]:\n                # Move point\n                self.actual_point = np.array([np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n                if self.last_point.any():\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, \'M\', np.float(line[3][1:]), self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n            elif \'X\' in line[1] and \'Y\' in line[2] and \'E\' in line[3]:\n                # elif \'X\' in line[1] and \'Y\' in line[2] and \'E\' in line[3]:\n                # Extrusion point\n                self.actual_point = np.array([np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n                self.extrusion = np.float(line[3][1:])\n                if self.last_point.any():\n                    if np.float(line[3][1:]) > 0.:\n                        if len(comment_line) > 0:\n                            if \'infill\' in comment_line[0]:\n                                type = \'E-i\'\n                            elif \'perimeter\' in comment_line[0]:\n                                type = \'E-p\'\n                            elif \'support\' in comment_line[0] and \'material\' in comment_line[1]:\n                                type = \'E-su\'\n                            elif \'skirt\' in comment_line[0]:\n                                type = \'E-sk\'\n                            else:\n                                type = \'E\'\n                        else:\n                            type = \'E\'\n                    else:\n                        type = \'M\'\n\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, type, self.speed, self.extrusion, self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n\n            elif \'X\' in line[1] and \'E\' in line[2] and \'F\' in line[3]:\n                # elif \'X\' in line[1] and \'E\' in line[2] and \'F\' in line[3]:\n                # Extrusion point\n                self.actual_point[0] = np.float(line[1][1:])\n                self.extrusion = np.float(line[2][1:])\n                if self.last_point.any():\n                    if np.float(line[2][1:]) > 0.:\n                        if len(comment_line) > 0:\n                            if \'infill\' in comment_line[0]:\n                                type = \'E-i\'\n                            elif \'perimeter\' in comment_line[0]:\n                                type = \'E-p\'\n                            elif \'support\' in comment_line[0] and \'material\' in comment_line[1]:\n                                type = \'E-su\'\n                            elif \'skirt\' in comment_line[0]:\n                                type = \'E-sk\'\n                            else:\n                                type = \'E\'\n                        else:\n                            type = \'E\'\n                    else:\n                        type = \'M\'\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, type, np.float(line[3][1:]), self.extrusion, self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n            elif \'Y\' in line[1] and \'F\' in line[2]:\n                # elif \'Y\' in line[1] and \'F\' in line[2]:\n                # Move point\n                self.actual_point[1] = np.float(line[1][1:])\n\n                if self.last_point:\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, \'M\', np.float(line[2][1:]), self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n\n            elif \'Y\' in line[1] and \'E\' in line[2]:\n                # G1 Y199.750 E0.3154 F2400\n                # G1 Y199.750 E0.3154\n                speed = 0.\n\n                if len(line) > 3:\n                    if \'F\' in line[3]:\n                        speed = np.float(line[3][1:])\n\n                self.actual_point[1] = np.float(line[1][1:])\n                self.extrusion = np.float(line[2][1:])\n\n                self.add_line(self.last_point, self.actual_point, self.actual_z, \'E\', speed, self.extrusion, self.actual_tool, line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n\n            elif \'X\' in line[1]:\n                print(""Zpracovavam: "" + str(line))\n                # G1 X179.750 F7000\n                # G1 X240.250 E1.9299\n                speed = 0.\n\n                if len(line) > 2:\n                    if \'F\' in line[2]:\n                        speed = np.float(line[2][1:])\n                    elif \'E\' in line[2]:\n                        self.extrusion = np.float(line[2][1:])\n\n                self.actual_point[0] = np.float(line[1][1:])\n\n                self.add_line(self.last_point, self.actual_point, self.actual_z, \'E\', speed, self.extrusion, self.actual_tool, line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n\n            elif DEBUG:\n                print(""Nezpracovano: "" + str(line) + \' \' + str(comment_line))\n\n        else:\n            #Comented gcode\n            if \'Z\' in line[1]:\n                # G1 Z0.350 F7200.000 ; move to next layer (1)\n                # Set of Z axis\n                new_z = np.float(line[1][1:])\n                self.actual_z = ""%.2f"" % new_z\n                self.last_point[2] = new_z\n                return\n            elif \'F\' in line[1]:\n                # G1 F5760\n                self.speed = np.float(line[1][1:])\n\n            elif \'X\' in line[1] and \'Y\' in line[2] and not (\'E\' in line[3]) and \'F\' in line[3] and not (\n                    \'intro\' in comment_line[0] and \'line\' in comment_line[1]):\n                # elif \'X\' in line[1] and \'Y\' in line[2] and not (\'E\' in line[3]) and \'F\' in line[3]:\n                # Move point\n                #\n                self.actual_point = np.array([np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n                if self.last_point.any():\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, \'M\', np.float(line[3][1:]), self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n            elif \'X\' in line[1] and \'Y\' in line[2] and \'E\' in line[3] and not (\n                    \'intro\' in comment_line[0] and \'line\' in comment_line[1]):\n                # G1 X122.438 Y106.154 E0.01540 ; infill\n                # elif \'X\' in line[1] and \'Y\' in line[2] and \'E\' in line[3]:\n                # Extrusion point\n                self.actual_point = np.array([np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n                self.extrusion = np.float(line[3][1:])\n                if self.last_point.any():\n                    if np.float(line[3][1:]) > 0.:\n                        if len(comment_line) > 0:\n                            if \'infill\' in comment_line[0]:\n                                type = \'E-i\'\n                            elif \'perimeter\' in comment_line[0]:\n                                type = \'E-p\'\n                            elif \'support\' in comment_line[0] and \'material\' in comment_line[1]:\n                                type = \'E-su\'\n                            elif \'skirt\' in comment_line[0]:\n                                type = \'E-sk\'\n                            else:\n                                type = \'E\'\n                        else:\n                            type = \'E\'\n                    else:\n                        type = \'M\'\n\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, type, self.speed, self.extrusion, self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n            elif \'X\' in line[1] and \'E\' in line[2] and \'F\' in line[3] and not (\n                    \'intro\' in comment_line[0] and \'line\' in comment_line[1]):\n                # elif \'X\' in line[1] and \'E\' in line[2] and \'F\' in line[3]:\n                # Extrusion point\n                self.actual_point[0] = np.float(line[1][1:])\n                self.extrusion = np.float(line[2][1:])\n                if self.last_point.any():\n                    if np.float(line[2][1:]) > 0.:\n                        if len(comment_line) > 0:\n                            if \'infill\' in comment_line[0]:\n                                type = \'E-i\'\n                            elif \'perimeter\' in comment_line[0]:\n                                type = \'E-p\'\n                            elif \'support\' in comment_line[0] and \'material\' in comment_line[1]:\n                                type = \'E-su\'\n                            elif \'skirt\' in comment_line[0]:\n                                type = \'E-sk\'\n                            else:\n                                type = \'E\'\n                        else:\n                            type = \'E\'\n                    else:\n                        type = \'M\'\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, type, np.float(line[3][1:]), self.extrusion, self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n            elif \'Y\' in line[1] and \'F\' in line[2] and not (\'go\' in comment_line[0] and \'outside\' in comment_line[1]):\n                # elif \'Y\' in line[1] and \'F\' in line[2]:\n                # Move point\n                self.actual_point[1] = np.float(line[1][1:])\n\n                if self.last_point.any():\n                    self.add_line(self.last_point, self.actual_point, self.actual_z, \'M\', np.float(line[2][1:]), self.actual_tool, line_number=line_number)\n                    self.last_point = np.array(self.actual_point)\n                else:\n                    self.last_point = np.array(self.actual_point)\n\n            elif \'Y\' in line[1] and \'E\' in line[2]:\n                # G1 Y199.750 E0.3154 F2400\n                # G1 Y199.750 E0.3154\n                speed = 0.\n\n                if len(line) > 3:\n                    if \'F\' in line[3]:\n                        speed = np.float(line[3][1:])\n\n                self.actual_point[1] = np.float(line[1][1:])\n                self.extrusion = np.float(line[2][1:])\n\n                self.add_line(self.last_point, self.actual_point, self.actual_z, \'E\', speed, self.extrusion, self.actual_tool, line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n\n            elif \'X\' in line[1]:\n                #print(""Zpracovavam: "" + str(line))\n                # G1 X179.750 F7000\n                # G1 X240.250 E1.9299\n                speed = 0.\n\n                if len(line) > 2:\n                    if \'F\' in line[2]:\n                        speed = np.float(line[2][1:])\n                    elif \'E\' in line[2]:\n                        self.extrusion = np.float(line[2][1:])\n\n                self.actual_point[0] = np.float(line[1][1:])\n\n                self.add_line(self.last_point, self.actual_point, self.actual_z, \'E\', speed, self.extrusion, self.actual_tool,\n                              line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n\n            elif DEBUG:\n                print(""Nezpracovano: "" + str(line) +\' \' +str(comment_line))\n\n        return\n    \'\'\'\n    @staticmethod\n    def type_convert(type):\n        if type == 0.0:\n            type_out = ""M""  #Move type\n\n        elif type == 1.0:\n            type_out = ""E""  # Extrusion type\n\n        elif type == 2.0:\n            type_out = ""E-i""  # Extrusion-infill type\n\n        elif type == 3.0:\n            type_out = ""E-p""  # Extrusion-perimeter type\n\n        elif type == 4.0:\n            type_out = ""E-su""  # Extrusion-support type\n\n        elif type == 5.0:\n            type_out = ""E-sk""  # Extrusion-support type\n\n        else:\n            type_out = ""E""\n\n        return type_out\n\n    def parse_g1_line_new(self, data, line_number):\n        # get raw line data and line_number to know position in file\n        # data is list from line from file devided by ;\n        # [0] data and [1] is comment\n\n        if len(data)>1:\n            text = data[0]\n            comment = data[1]\n        else:\n            text = data[0]\n            comment = """"\n\n        line = text.split(\' \')\n        line = list(filter(None, line))\n        line_len = len(line)\n\n        #print(comment)\n        comment_line = comment.split(\' \')\n        comment_line = list(filter(None, comment_line))\n        comment_line_len = len(comment_line)\n\n        if \'Z\' in line[1]:\n            # Set of Z axis\n            # G1 Z1.850 F7200.000 ; lift Z\n            new_z = float(line[1][1:])\n            if self.absolute_coordinates:\n                self.actual_z = ""%.2f"" % new_z\n                self.last_point = np.array([self.last_point[0], self.last_point[1], new_z])\n            else:\n                self.actual_z = ""%.2f"" % (self.last_point[2] + new_z)\n                self.last_point = np.array([self.last_point[0], self.last_point[1], self.last_point[2] + new_z])\n            return\n        elif \'F\' in line[1]:\n            # Set of feed rate(speed mm/m)\n            # G1 F5760\n            self.speed = np.float(line[1][1:])\n        elif \'X\' in line[1]:\n            # Set move point(possible extrusion)\n            # G1 X119.784 Y109.613 E0.00507 ; perimeter\n            # G1 X119.731 Y110.014 F7200.000 ; move to first perimeter point\n            # G1 X118.109 Y101.483 E0.03127 ; infill\n            # G1 X121.899 Y107.591 E-0.97707 ; wipe and retract\n            # G1 X179.750 F7000\n            # G1 X240.250 E1.9299\n            # G1 X60 Y60 Z1 F1000.0\n\n            if line_len == 5:\n                if \'X\' in line[1] and \'Y\' in line[2] and \'Z\' in line[3] and \'F\' in line[4]:\n                    self.speed = np.float(line[4][1:])\n                    self.actual_point = np.array([np.float(line[1][1:]), self.actual_point[1], np.float(self.actual_z)])\n                else:\n                    if DEBUG:\n                        print(""Nezpracovano: "" + str(line) + \' \' + str(comment_line))\n\n\n            elif line_len == 4:\n\n                if \'E\' in line[2] and \'F\' in line[3]:\n                    # G1 X181.500 E0.0217 F2900\n                    self.extrusion = np.float(line[2][1:])\n                    self.speed = np.float(line[3][1:])\n                    self.actual_point = np.array([np.float(line[1][1:]), self.actual_point[1], np.float(self.actual_z)])\n                elif \'E\' in line[3]:\n                    # G1 X119.784 Y109.613 E0.00507 ; perimeter\n                    # G1 X118.109 Y101.483 E0.03127 ; infill\n                    # G1 X121.899 Y107.591 E-0.97707 ; wipe and retract\n                    self.extrusion = np.float(line[3][1:])\n                    self.actual_point = np.array(\n                        [np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n                elif \'F\' in line[3]:\n                    # G1 X119.731 Y110.014 F7200.000 ; move to first perimeter point\n                    self.speed = np.float(line[3][1:])\n                    self.extrusion = 0.\n                    self.actual_point = np.array([np.float(line[1][1:]), np.float(line[2][1:]), np.float(self.actual_z)])\n\n            elif line_len == 3:\n                # G1 X179.750 F7000\n                # G1 X240.250 E1.9299\n\n                if \'E\' in line[2]:\n                    self.extrusion = np.float(line[2][1:])\n                elif \'F\' in line[2]:\n                    self.speed = np.float(line[2][1:])\n\n                self.actual_point = np.array([np.float(line[1][1:]), self.actual_point[1], self.actual_point[2]])\n\n\n            if self.extrusion > 0.:\n                if comment_line_len > 0:\n                    if \'infill\' in comment_line[0]:\n                        type = 2.0\n                    elif \'perimeter\' in comment_line[0]:\n                        type = 3.0\n                    elif \'support\' in comment_line[0] and \'material\' in comment_line[1]:\n                        type = 4.0\n                    elif \'skirt\' in comment_line[0]:\n                        type = 5.0\n                    else:\n                        type = 1.0\n                else:\n                    type = 1.0\n            else:\n                type = 0.0\n\n            if self.last_point.any():\n                self.add_line(self.last_point, self.actual_point, self.actual_z, type, self.speed, self.extrusion,\n                              self.actual_tool, line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n            else:\n                self.last_point = np.array(self.actual_point)\n\n\n        elif \'Y\' in line[1]:\n            # Set move point(possible extrusion)\n            # G1 Y199.750 E0.3154 F2400\n            # G1 Y185.250 E0.3154\n\n            if line_len == 4:\n                if \'F\' in line[3]:\n                    # G1 Y199.750 E0.3154 F2400\n                    self.speed = np.float(line[3][1:])\n\n            self.extrusion = np.float(line[2][1:])\n\n            self.actual_point = np.array([self.actual_point[0], np.float(line[1][1:]), self.actual_point[2]])\n\n            if self.extrusion > 0.:\n                type = 1.0\n            else:\n                type = 0.0\n\n            if self.last_point.any():\n                self.add_line(self.last_point, self.actual_point, self.actual_z, type, self.speed, self.extrusion,\n                              self.actual_tool, line_number=line_number)\n                self.last_point = np.array(self.actual_point)\n            else:\n                self.last_point = np.array(self.actual_point)\n\n        elif \'E\' in line[1] and \'F\' in line[2]:\n            # G1 E-15.0000 F5000\n\n            self.extrusion = np.float(line[1][1:])\n            self.speed = np.float(line[2][1:])\n\n\n        else:\n            if DEBUG:\n                print(""Nezpracovano: "" + str(line) + \' \' + str(comment_line))\n\n        return\n\n\n    def parse_g92_line(self, data, line_number):\n        # get raw line data and line_number to know position in file\n        # data is list from line from file devided by ;\n        # [0] data and [1] is comment\n\n        if len(data)>1:\n            text = data[0]\n            comment = data[1]\n        else:\n            text = data[0]\n            comment = """"\n\n        line = text.split(\' \')\n        line = list(filter(None, line))\n        line_len = len(line)\n\n        #print(comment)\n        comment_line = comment.split(\' \')\n        comment_line = list(filter(None, comment_line))\n        comment_line_len = len(comment_line)\n\n        if \'E\' in line[1]:\n            self.extrusion = np.float(line[1][1:])\n\n\n\n\n    def add_line(self, first_point, second_point, actual_z, type, speed=0., extrusion=0., extruder=0, line_number = -1):\n        #print(""Add line: "" + str(first_point) + \' \' + str(second_point) + \' type: \' + str(type) + \' \' + str(line_number))\n        #print(""actual data:"")\n        #print(self.data_keys)\n\n        key = deepcopy(actual_z)\n        \'\'\'\n        if key in self.data_keys:\n            self.data[key].append([deepcopy(first_point),\n                                   deepcopy(second_point),\n                                   deepcopy(type),\n                                   deepcopy(speed),\n                                   deepcopy(extrusion),\n                                   deepcopy(extruder),\n                                   deepcopy(line_number)])\n            self.all_data.append([deepcopy(first_point),\n                                  deepcopy(second_point),\n                                  deepcopy(type),\n                                  deepcopy(speed),\n                                  deepcopy(extrusion),\n                                  deepcopy(extruder),\n                                  deepcopy(line_number)])\n        else:\n            self.data_keys.add(key)\n            self.data[key] = []\n            self.data[key].append([deepcopy(first_point),\n                                   deepcopy(second_point),\n                                   deepcopy(type),\n                                   deepcopy(speed),\n                                   deepcopy(extrusion),\n                                   deepcopy(extruder),\n                                   deepcopy(line_number)])\n            self.all_data.append([deepcopy(first_point),\n                                  deepcopy(second_point),\n                                  deepcopy(type),\n                                  deepcopy(speed),\n                                  deepcopy(extrusion),\n                                  deepcopy(extruder),\n                                  deepcopy(line_number)])\n        \'\'\'\n        if not key in self.data_keys:\n            self.data_keys.add(key)\n            self.data[key] = []\n\n        self.data[key].append(np.array([first_point,\n                               second_point,\n                               type,\n                               speed,\n                               extrusion,\n                               extruder,\n                               line_number]))\n        self.all_data.append(np.array([first_point,\n                              second_point,\n                              type,\n                              speed,\n                              extrusion,\n                              extruder,\n                              line_number]))\n\n\n\n    \'\'\'\n    def add_point(self, x, y, z, actual_z):\n        key = actual_z\n        if key in self.data_keys:\n            self.data[key].append([x, y, z])\n            self.all_data.append([x, y, z])\n        else:\n            self.data_keys.add(key)\n            self.data[key] = []\n            self.data[key].append([x, y, z])\n            self.all_data.append([x, y, z])\n    \'\'\''"
glButton.py,0,"b'# -*- coding: utf-8 -*-\n\nimport itertools\nimport logging\n\n__author__ = \'Tibor Vavra\'\n\nclass GlButton(object):\n\n    newid = itertools.count(1)\n    def __init__(self, texture_off=None, texture_on=None, texture_hover=None, texture_background=None, size=[10., 10.], position=[0.0, 0.0], auto_release=False, tool_tip=\'\', tool_name=\'\', dpi_coef = 1.0):\n        self.id = next(self.newid) * 7013\n        self.color_id = [(self.id & 0x000000FF) >> 0, (self.id & 0x0000FF00) >> 8, (self.id & 0x00FF0000) >> 16]\n\n        self.texture_off = texture_off\n        self.texture_on = texture_on\n        self.texture_hover = texture_hover\n        self.texture_background = texture_background\n\n        self.size = [size[0] * dpi_coef, size[1] * dpi_coef]\n        self.position = [position[0] * dpi_coef, position[1] * dpi_coef]\n\n        self.pressed = False\n        self.mouse_over = False\n        self.callback_function = None\n        self.press_variable = None\n        self.auto_release = auto_release\n\n        self.key = None\n        self.subkey = None\n\n        self.tool_name=tool_name\n        self.tool_tip=tool_tip\n\n    def set_callback(self, func):\n        self.callback_function = func\n\n    def mouse_is_over(self, Is):\n        self.mouse_over = Is\n\n    def press_button(self):\n        if self.auto_release:\n            self.pressed = False\n        else:\n            self.pressed = not self.pressed\n        #print(""Byl stisknut "" + self.tool_name)\n        self.callback_function()\n\n    def unpress_button(self):\n        self.pressed = False\n\n    def set_press_variable(self, variable, key, subkey):\n        self.press_variable = variable\n        self.key = key\n        self.subkey = subkey\n\n    def set_viewport(self, width, height):\n        self.xW = width\n        self.yH = height\n\n    def is_pressed(self):\n        if self.pressed:\n            return True\n        else:\n            return False\n\n    def get_size(self):\n        pass\n\n    def render(self, picking=False):\n        pass\n\n    def run_callback(self):\n        if self.callback_function:\n            self.callback_function()\n\n    def check_button(self, color):\n        #return True if checked color is same as button color\n        #else return False\n\n        color_id = color[0] + (color[1]*255) + (color[2]*255*255)\n\n        if color_id == self.id:\n            return True\n        else:\n            return False\n\n\n\n\n'"
gui.py,9,"b'# -*- coding: utf-8 -*-\nfrom PyQt4.QtGui import QColor, QScrollArea, QLayout, QAction, QMenu, QLineEdit, QFormLayout\nfrom PyQt4.QtGui import QColorDialog\nfrom PyQt4.QtGui import QStandardItem\n\n__author__ = \'Tibor Vavra\'\n\nimport logging\nimport math\nimport os\nfrom copy import deepcopy\n\nimport numpy as np\nimport time\n#from OpenGL.GL import *\nfrom PyQt4.QtCore import QFileInfo\nfrom PyQt4.QtCore import QPropertyAnimation\nfrom PyQt4.QtCore import QTextCodec\n\nfrom PyQt4.QtCore import Qt, SIGNAL, QSettings, QFile, QIODevice, QVariant, QEvent\nfrom PyQt4.QtGui import QFont, QFontDatabase, QGridLayout, QGroupBox, QHBoxLayout, QLabel, QMainWindow, \\\nQMessageBox, QProgressBar, QPushButton, QSizePolicy, QSpacerItem, QVBoxLayout, QWidget, \\\nQPainter, QPainterPath, QPen, QSlider, QStyleOptionSlider, QDialog, QDialogButtonBox, \\\nQComboBox, QCheckBox, QApplication, QSpinBox, QDoubleSpinBox, QFileDialog, QStyleFactory, \\\nQScrollArea\n\nfrom PyQt4.QtOpenGL import QGLWidget\n\nimport projectFile\nimport sceneRender\n\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print(\'%s function took %0.3f ms\' % (f.func_name, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\nclass Gcode_slider(QWidget):\n    def __init__(self, other, controller):\n        super(Gcode_slider, self).__init__()\n        self.controller = controller\n        self.initUI()\n\n    def initUI(self):\n        self.points = []\n        self.init_points()\n\n        self.rangeMin = 0.\n        self.rangeMax = 0.\n\n\n        self.max_label = QLabel(self)\n        self.max_label.setObjectName(""gcode_slider_max_label"")\n        #self.max_label.setFixedWidth(150)\n        self.max_label.setText(""Max"")\n        self.max_label.setAlignment(Qt.AlignCenter)\n        self.min_label = QLabel(self)\n        self.min_label.setObjectName(""gcode_slider_min_label"")\n        self.min_label.setText(""Min"")\n        self.min_label.setAlignment(Qt.AlignCenter)\n\n        main_layout = QVBoxLayout(self)\n        main_layout.setAlignment(Qt.AlignCenter)\n\n        self.slider = QSlider()\n        self.slider.setOrientation(Qt.Vertical)\n        #self.slider.setFixedWidth(144)\n        #self.connect(self.slider, SIGNAL(""valueChanged(int)""), self.set_value_label)\n        self.slider.valueChanged.connect(self.set_value_label)\n\n        self.slider.setTickInterval(1)\n\n        self.value_label = QLabel(self)\n        self.value_label.setObjectName(""gcode_slider_value_label"")\n        self.value_label.setVisible(False)\n        self.value_label.setText(u""\xe2\x94\x80  0.00mm"")\n        self.value_label.setFixedWidth((int)(70*self.controller.dpi_coef))\n\n        self.add_button = QPushButton("""", self)\n        if self.controller.app_config.system_platform in [""Darwin""]:\n            self.add_button.setStyle(QStyleFactory.create(""Macintosh""))\n        self.add_button.setObjectName(""gcode_slider_add_button"")\n        self.add_button.setVisible(False)\n        self.add_button.setFixedWidth((int)(20*self.controller.dpi_coef))\n        self.add_button.setToolTip(self.tr(""Add color change point""))\n\n        self.add_button.clicked.connect(self.add_point)\n\n        main_layout.addWidget(self.max_label)\n\n        main_layout.addWidget(self.slider)\n\n        main_layout.addWidget(self.min_label)\n\n        self.setLayout(main_layout)\n\n\n        self.style = QApplication.style()\n        self.opt = QStyleOptionSlider()\n        self.slider.initStyleOption(self.opt)\n\n        self.set_value_label(0.00)\n\n\n    def init_points(self):\n        if self.points:\n            for point in self.points:\n                point[\'value\'] = -1\n\n                point[\'label\'].setText(\'\')\n                point[\'label\'].move(0,0)\n                point[\'label\'].setVisible(False)\n                point[\'button\'].move(0,0)\n                point[\'button\'].setVisible(False)\n\n        else:\n            for i in range(0, 20):\n                label = QLabel(self)\n                label.setObjectName(""gcode_slider_point_label"")\n                label.setVisible(False)\n                label.setFixedWidth((int)(60*self.controller.dpi_coef))\n                button = QPushButton(\'\', self)\n                if self.controller.app_config.system_platform in [""Darwin""]:\n                    button.setStyle(QStyleFactory.create(""Macintosh""))\n                button.setObjectName(""gcode_slider_point_button"")\n                button.setVisible(False)\n                button.setFixedWidth((int)(20*self.controller.dpi_coef))\n                button.setToolTip(self.tr(""Delete color change point""))\n\n                self.points.append({\'value\': -1,\n                                    \'label\': label,\n                                    \'button\': button\n                                    })\n\n    def add_point(self):\n        self.slider.initStyleOption(self.opt)\n\n        rectHandle = self.style.subControlRect(self.style.CC_Slider, self.opt, self.style.SC_SliderHandle)\n        myPoint = rectHandle.topRight() + self.slider.pos()\n\n        value = self.slider.value()\n        layer_value = self.controller.gcode.data_keys[value]\n\n        #delete_button = QtGui.QPushButton(""X"", self)\n        #delete_button.setFixedWidth(20)\n        #self.point_label = QtGui.QLabel(self)\n        number = 0\n\n\n        for p in self.points:\n            if p[\'value\'] == layer_value:\n                return\n\n        for i, p in enumerate(self.points):\n            number = i\n            if p[\'value\'] == -1:\n                break\n\n        self.points[number][\'value\'] = layer_value\n\n        self.points[number][\'button\'].setVisible(True)\n        self.points[number][\'button\'].move((int)(2*self.controller.dpi_coef), myPoint.y() - 9)\n        self.points[number][\'button\'].clicked.connect(lambda: self.delete_point(number))\n\n        self.points[number][\'label\'].setText(u""%smm \xe2\x94\x80"" % layer_value)\n        self.points[number][\'label\'].setVisible(True)\n        self.points[number][\'label\'].move((int)(20*self.controller.dpi_coef), myPoint.y() - 9)\n\n    def delete_point(self, number):\n        self.points[number][\'value\'] = -1\n        self.points[number][\'button\'].setVisible(False)\n        self.points[number][\'label\'].setVisible(False)\n\n    def set_value_label(self, value):\n        self.slider.initStyleOption(self.opt)\n\n        #rectHandle = style.subControlRect(QtGui.QStyle.CC_Slider, opt, QtGui.QStyle.SC_SliderHandle, self)\n        rectHandle = self.style.subControlRect(self.style.CC_Slider, self.opt, self.style.SC_SliderHandle)\n        myPoint = rectHandle.topRight() + self.slider.pos()\n\n        if self.controller.gcode:\n            layer_value = self.controller.gcode.data_keys[value]\n        else:\n            layer_value = ""0.00""\n        self.value_label.setText(u""\xe2\x94\x80 %smm"" % layer_value)\n        self.value_label.move(self.slider.width() + (int)(75*self.controller.dpi_coef), myPoint.y() - 9)\n        self.add_button.move(self.slider.width() + (int)(145*self.controller.dpi_coef), myPoint.y() - 9)\n\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            self.add_button.setVisible(False)\n        else:\n            self.add_button.setVisible(True)\n        self.value_label.setVisible(True)\n\n    def setRange(self, rangeMin, rangeMax):\n        self.rangeMin = rangeMin\n        self.rangeMax = rangeMax\n        self.max_label.setText(""%.2fmm"" % rangeMax)\n        self.min_label.setText(""%.2fmm"" % rangeMin)\n\n        self.slider.setRange(rangeMin, rangeMax)\n\n    def setSingleStep(self, step):\n        self.slider.setSingleStep(step)\n\n    def setPageStep(self, step):\n        self.slider.setPageStep(step)\n\n    def setTickInterval(self, tick):\n        self.slider.setTickInterval(tick)\n\n    def setValue(self, value):\n        self.value_label.setText(u""\xe2\x94\x80 %3.2fmm"" % value)\n        #self.max_label.setText(""%3.2fmm"" % self.rangeMax)\n        #self.min_label.setText(""%3.2fmm"" % self.rangeMin)\n\n        self.slider.setValue(value)\n\n    def setTickPosition(self, position):\n        self.slider.setTickPosition(position)\n\n    def setMinimum(self, minimum, minimum_label):\n        self.rangeMin = minimum_label\n        self.min_label.setText(""%.2fmm"" % self.rangeMin)\n        #print(str(minimum))\n        self.slider.setMinimum(minimum)\n\n    def setMaximum(self, maximum, maximum_label):\n        self.rangeMax = maximum_label\n        self.max_label.setText(""%.2fmm"" % self.rangeMax)\n        #print(str(maximum))\n        self.slider.setMaximum(maximum)\n\n\n    def get_color_change_layers(self):\n        #return [[i[\'value\'], self.controller.gcode.data[i[\'value\']][0][-1]] for i in self.parent.gcode_slider.points if not i[\'value\'] == -1]\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            return []\n        else:\n            return [i[\'value\'] for i in self.points if not i[\'value\'] == -1]\n\n\nclass Spline_editor(QWidget):\n    def __init__(self, other, controller):\n        super(Spline_editor, self).__init__()\n        self.controller = controller\n        self.initUI()\n\n    def initUI(self):\n        self.data = np.zeros((11), dtype=np.float32)\n        self.points = []\n        #self.init_points()\n\n        self.double_value = 0.0\n        self.number_of_ticks = 10\n        self.min = 0.0\n        self.max = 1.0\n        self.label_height = 0\n\n\n        self.max_label = QLabel(self)\n        self.max_label.setObjectName(""gcode_slider_max_label"")\n        self.max_label.setText(""Max"")\n        self.max_label.setAlignment(Qt.AlignCenter)\n\n        \'\'\'\n        self.minimal_detail_l = QtGui.QLabel(self)\n        self.minimal_detail_l.setObjectName(""gcode_slider_max_label"")\n        self.minimal_detail_l.setText(self.tr(""Minimal detail""))\n        self.minimal_detail_l.setAlignment(Qt.AlignCenter)\n\n        self.maximal_detail_l = QtGui.QLabel(self)\n        self.maximal_detail_l.setObjectName(""gcode_slider_max_label"")\n        self.maximal_detail_l.setText(self.tr(""Maximal detail""))\n        self.maximal_detail_l.setAlignment(Qt.AlignCenter)\n\n\n        top_labels_widget = QtGui.QWidget()\n        top_labels_layout = QtGui.QHBoxLayout()\n        top_labels_layout.setSpacing(0)\n        top_labels_layout.setMargin(0)\n        top_labels_layout.addWidget(self.minimal_detail_l)\n        top_labels_layout.addWidget(self.max_label)\n        top_labels_layout.addWidget(self.maximal_detail_l)\n        top_labels_widget.setLayout(top_labels_layout)\n        \'\'\'\n\n        self.min_label = QLabel(self)\n        self.min_label.setObjectName(""spline_slider_min_label"")\n        self.min_label.setText(""Min"")\n        self.min_label.setAlignment(Qt.AlignCenter)\n\n        main_layout = QVBoxLayout(self)\n        main_layout.setAlignment(Qt.AlignCenter)\n        #main_layout.setSpacing(2)\n        #main_layout.setMargin(2)\n\n        self.slider = QSlider(parent=self)\n        self.slider.setOrientation(Qt.Vertical)\n        self.slider.setObjectName(""spline_slider"")\n        self.slider.setFixedHeight(350)\n\n        #self.connect(self.slider, pyqtSignal(""valueChanged(int)""), self.set_value_label)\n        self.slider.valueChanged.connect(self.set_value_label)\n\n        self.value_label = QLabel(parent=self)\n        self.value_label.setObjectName(""spline_slider_value_label"")\n        self.value_label.setVisible(False)\n        self.value_label.setText(u""\xe2\x94\x800.00mm"")\n        self.value_label.setFixedWidth(75)\n\n        self.plus_button = QPushButton("""", parent=self)\n        self.plus_button.setAutoRepeat(True)\n        self.plus_button.setObjectName(""variable_hight_plus_button"")\n        self.plus_button.setVisible(False)\n        self.plus_button.setFixedWidth(20)\n        self.plus_button.clicked.connect(self.plus_value)\n\n        self.minus_button = QPushButton("""", parent=self)\n        self.minus_button.setAutoRepeat(True)\n        self.minus_button.setObjectName(""variable_hight_minus_button"")\n        self.minus_button.setVisible(False)\n        self.minus_button.setFixedWidth(20)\n        self.minus_button.clicked.connect(self.minus_value)\n\n\n        main_layout.addWidget(self.max_label)\n        main_layout.addWidget(self.slider)\n        main_layout.addWidget(self.min_label)\n\n        self.setLayout(main_layout)\n\n        self.style = QApplication.style()\n        self.opt = QStyleOptionSlider()\n        self.slider.initStyleOption(self.opt)\n\n        self.label_height = self.max_label.height() -1\n\n\n    def init_points(self):\n        start_y = self.label_height\n        end_y = 350.+self.label_height\n\n\n        if self.points:\n            for point in self.points:\n                #TODO: set for other objects on scene\n                pass\n        else:\n            for i in range(0, self.number_of_ticks+1):\n                #first and last layer\n                \'\'\'\n                if i == 0:\n                    value = i\n                    y = start_y\n                elif i == self.number_of_ticks-1:\n                    value = i\n                    y = end_y\n                else:\n                    value = 0\n                    y = (400/self.number_of_ticks-1) * i\n                \'\'\'\n                y = (350./ (self.number_of_ticks)) * i + start_y\n                #clear points values\n                \'\'\'\n                self.points.append({\'value\': 0,\n                                    \'detail\' : 0.0,      #x value\n                                    \'y\' : y\n                                    })\n                \'\'\'\n\n\n\n\n    def compute_double_value(self, value):\n        return ((self.max-self.min)/self.number_of_ticks) * value\n\n\n    def set_model(self, mesh):\n        self.mesh = mesh\n        self.data = mesh.variable_layer_height_data\n\n    def paintEvent(self, event):\n        path = QPainterPath()\n        start_y = self.label_height\n        #path.moveTo(85, self.label_height)\n        #path.moveTo(85, 400-self.label_height)\n\n        #defined_points = [p for p in self.points if not p[\'value\'] == -1]\n\n        #if len(defined_points)>2:\n        for i, p in enumerate(self.data):\n            y = (350./ (self.number_of_ticks)) * i + start_y\n            if i == 0:\n                path.moveTo((p * 20.) + 85, y)\n            else:\n                path.lineTo((p * 20.) + 85, y)\n\n            #path.cubicTo((defined_points[0][\'detail\'] * 10.) + 85, self.label_height,\n            #            (defined_points[1][\'detail\'] * 10.) + 85, 200,\n            #            (defined_points[2][\'detail\'] * 10.) + 85, 400-self.label_height)\n        #else:\n            #print(""Count of height for point: "" + str((((self.max-self.min)/self.number_of_ticks) * defined_points[0][\'value\'])))\n        #    path.lineTo((defined_points[0][\'detail\']*10.)+85, self.label_height)\n        #    path.lineTo((defined_points[1][\'detail\']*10.)+85, 350+self.label_height)\n\n        #path.lineTo(100, 100)\n        #path.lineTo(150, 150)\n        #path.cubicTo(50, 50, 50, 50, 80, 80)\n        #path.cubicTo(80, 80, 50, 50, 80, 80)\n        pen01 = QPen(Qt.white)\n        pen01.setWidthF(2.0)\n        pen02 = QPen(Qt.green)\n        pen03 = QPen(Qt.red)\n        pen02.setWidthF(2.5)\n\n        qp = QPainter()\n        qp.begin(self)\n        qp.setRenderHint(QPainter.Antialiasing)\n        #grid\n        qp.setPen(pen01)\n        qp.drawLine(20, self.label_height, 160, self.label_height)\n        qp.drawLine(20, self.label_height + 350, 160, 350 + self.label_height)\n        qp.drawLine(20, self.label_height, 20, 350 + self.label_height)\n        qp.drawLine(160, self.label_height, 160, 350 + self.label_height)\n\n        #path\n        qp.setPen(pen02)\n        qp.drawPath(path)\n\n\n        qp.end()\n\n\n    def plus_value(self):\n        #print(""Slider plus"")\n        #TODO:read value from slider and increment quality for this layer\n        slider_value = (self.number_of_ticks) - self.slider.value()\n        #print(slider_value)\n        for n, p in enumerate(self.data):\n            if n == slider_value:\n                if self.data[n] <= 0.99:\n                    self.data[n] += 0.2\n        #print(self.data)\n        self.repaint()\n        self.mesh.recalculate_texture()\n        self.controller.update_scene()\n\n    def minus_value(self):\n        #print(""Slider minus"")\n        # TODO:read value from slider and decrease quality for this layer\n        slider_value = (self.number_of_ticks) - self.slider.value()\n        #print(slider_value)\n        for n, p in enumerate(self.data):\n            if n == slider_value:\n                if self.data[n] >= -0.99:\n                    self.data[n] -= 0.2\n        #print(self.data)\n        self.repaint()\n        self.mesh.recalculate_texture()\n        self.controller.update_scene()\n\n\n    def set_value_label(self, value):\n        self.slider.initStyleOption(self.opt)\n\n        rectHandle = self.style.subControlRect(self.style.CC_Slider, self.opt, self.style.SC_SliderHandle)\n        myPoint = rectHandle.topRight() + self.slider.pos()\n\n        self.double_value = ((self.max-self.min)/self.number_of_ticks) * value\n        self.value_label.setText(u"" \xe2\x94\x80 %3.2fmm"" % self.double_value)\n        self.value_label.move(self.slider.width() + 70, myPoint.y() - 9)\n        self.plus_button.move(self.slider.width() + 25, myPoint.y() - 9)\n        self.minus_button.move(self.slider.width(), myPoint.y() - 9)\n\n        self.plus_button.setVisible(True)\n        self.minus_button.setVisible(True)\n        self.value_label.setVisible(True)\n\n    def setRange(self, rangeMin, rangeMax):\n        self.max_label.setText(""%3.2f"" % rangeMax)\n        self.min_label.setText(""%3.2f"" % rangeMin)\n        self.slider.setRange(rangeMin, rangeMax)\n\n    def setSingleStep(self, step):\n        self.slider.setSingleStep(step)\n\n    def setPageStep(self, step):\n        self.slider.setPageStep(step)\n\n    def setTickInterval(self, tick):\n        self.slider.setTickInterval(tick)\n\n    def setValue(self, value):\n        self.value_label.setText(u""\xe2\x94\x80%3.2fmm"" % value)\n        self.slider.setValue(value)\n\n    def setTickPosition(self, position):\n        self.slider.setTickPosition(position)\n\n    def set_number_of_ticks(self, number):\n        self.number_of_ticks = number\n        self.slider.setTickInterval(1)\n        self.slider.setMaximum(number)\n        self.init_points()\n\n    def setMinimum(self, minimum):\n        self.min = minimum\n        self.min_label.setText(""%.2fmm"" % minimum)\n        self.slider.setMinimum(0)\n\n    def setMaximum(self, maximum):\n        self.max = maximum\n        self.max_label.setText(""%.2fmm"" % maximum)\n        self.slider.setMaximum(10)\n\n\nclass SettingsDialog(QDialog):\n    def __init__(self, controller, editable=True,  parent = None):\n        super(SettingsDialog, self).__init__(controller.view, Qt.WindowSystemMenuHint | Qt.WindowTitleHint)\n\n        self.controller = controller\n\n        layout = QVBoxLayout(self)\n\n        # nice widget for editing the date\n        self.language_label = QLabel(self.tr(""Language""))\n        self.language_combo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.language_combo.setStyle(QStyleFactory.create(\'Windows\'))\n        #set enumeration\n        self.language_combo.addItems(list(self.controller.enumeration[\'language\'].values()))\n        l = list(self.controller.enumeration[\'language\'])\n        self.language_combo.setCurrentIndex(l.index(self.controller.settings[\'language\']))\n\n        self.printer_label = QLabel(self.tr(""Printer model""))\n        self.printer_combo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.printer_combo.setStyle(QStyleFactory.create(\'Windows\'))\n        self.printer_combo.addItems(self.controller.get_printers_labels_ls(only_visible=True))\n        self.printer_combo.setCurrentIndex(self.controller.get_printers_names_ls(only_visible=True).index(self.controller.settings[\'printer\']))\n        self.printer_combo.currentIndexChanged.connect(self.update_printer_variations)\n\n        self.printer_type_label = QLabel(self.tr(""Printer variation""))\n        self.printer_type_combo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.printer_type_combo.setStyle(QStyleFactory.create(\'Windows\'))\n        ##\n        labels, _f = self.controller.get_printer_variations_labels_ls(self.controller.actual_printer)\n        self.printer_type_combo.addItems(labels)\n        names, _ = self.controller.get_printer_variations_names_ls(self.controller.actual_printer)\n        self.printer_type_combo.setCurrentIndex(names.index(self.controller.settings[\'printer_type\']))\n\n        self.debug_checkbox = QCheckBox(self.tr(""Debug""))\n        self.debug_checkbox.setChecked(self.controller.settings[\'debug\'])\n\n        self.automatic_placing_checkbox = QCheckBox(self.tr(""Automatic placing""))\n        self.automatic_placing_checkbox.setChecked(self.controller.settings[\'automatic_placing\'])\n\n        self.analyze_checkbox = QCheckBox(self.tr(""Analyzer""))\n        self.analyze_checkbox.setChecked(self.controller.settings[\'analyze\'])\n\n        self.update_parameters_checkbox = QCheckBox(self.tr(""Auto update parameters""))\n        self.update_parameters_checkbox.setChecked(self.controller.settings[\'automatic_update_parameters\'])\n\n        layout.addWidget(self.language_label)\n        layout.addWidget(self.language_combo)\n\n        layout.addWidget(self.printer_label)\n        layout.addWidget(self.printer_combo)\n\n        layout.addWidget(self.printer_type_label)\n        layout.addWidget(self.printer_type_combo)\n\n        layout.addWidget(self.debug_checkbox)\n        layout.addWidget(self.automatic_placing_checkbox)\n        layout.addWidget(self.analyze_checkbox)\n        layout.addWidget(self.update_parameters_checkbox)\n\n        # OK and Cancel buttons\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\n            Qt.Horizontal, self)\n        if not editable:\n            ok_button = buttons.button(QDialogButtonBox.Ok)\n            ok_button.setEnabled(False)\n\n        buttons.accepted.connect(self.accept)\n        buttons.rejected.connect(self.reject)\n        layout.addWidget(buttons)\n\n    def update_printer_variations(self):\n        self.printer_type_combo.clear()\n        labels_lst, first = self.controller.get_printer_variations_labels_ls(self.controller.get_printers_names_ls(only_visible=True)[self.printer_combo.currentIndex()])\n        self.printer_type_combo.addItems(labels_lst)\n        self.printer_type_combo.setCurrentIndex(first)\n\n\n\n    @staticmethod\n    def get_settings_data(controller, editable=True, parent = None):\n        data = deepcopy(controller.settings)\n        dialog = SettingsDialog(controller, editable, parent)\n        dialog.setWindowTitle(""Settings"")\n        result = dialog.exec_()\n        data[\'language\'] = list(controller.enumeration[\'language\'])[dialog.language_combo.currentIndex()]\n        data[\'printer\'] = controller.get_printers_names_ls(only_visible=True)[dialog.printer_combo.currentIndex()]\n        printer_variations, _f = controller.get_printer_variations_names_ls(data[\'printer\'])\n        data[\'printer_type\'] = printer_variations[dialog.printer_type_combo.currentIndex()]\n\n        data[\'debug\'] = dialog.debug_checkbox.isChecked()\n        data[\'automatic_placing\'] = dialog.automatic_placing_checkbox.isChecked()\n        data[\'analyze\'] = dialog.analyze_checkbox.isChecked()\n        data[\'automatic_update_parameters\'] = dialog.update_parameters_checkbox.isChecked()\n        return (data, result == QDialog.Accepted)\n\n\nclass NewOctoPrintDialog(QDialog):\n    def __init__(self, controller):\n        super(NewOctoPrintDialog, self).__init__(controller.view, Qt.WindowSystemMenuHint | Qt.WindowTitleHint)\n\n        self.controller = controller\n\n        layout = QFormLayout(self)\n\n        # nice widget for editing the date\n        self.name_label = QLabel(self.tr(""Name""))\n        self.name_edit = QLineEdit()\n\n        self.ip_address_label = QLabel(self.tr(""IP""))\n        self.ip_address_edit = QLineEdit()\n\n        self.apikey_label = QLabel(self.tr(""ApiKey""))\n        self.apikey_edit = QLineEdit()\n\n        #self.username_label = QLabel(self.tr(""User""))\n        #self.username_edit = QLineEdit()\n\n        #self.password_label = QLabel(self.tr(""Password""))\n        #self.password_edit = QLineEdit()\n\n        layout.addRow(self.name_label, self.name_edit)\n        layout.addRow(self.ip_address_label, self.ip_address_edit)\n        layout.addRow(self.apikey_label, self.apikey_edit)\n        #layout.addRow(self.username_label, self.username_edit)\n        #layout.addRow(self.password_label, self.password_edit)\n\n        # OK and Cancel buttons\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.Ok | QDialogButtonBox.Cancel,\n            Qt.Horizontal, self)\n\n        buttons.accepted.connect(self.accept)\n        buttons.rejected.connect(self.reject)\n        layout.addWidget(buttons)\n\n\n\n    @staticmethod\n    def get_settings_data(controller, ):\n        data = {}\n        dialog = NewOctoPrintDialog(controller)\n        dialog.setWindowTitle(""New OctoPrint service"")\n        result = dialog.exec_()\n\n        data[\'name\'] = dialog.name_edit.text()\n        data[\'ip\'] = dialog.ip_address_edit.text()\n        data[\'apikey\'] = dialog.apikey_edit.text()\n        #data[\'user\'] = dialog.username_edit.text()\n        #data[\'password\'] = dialog.password_edit.text()\n\n\n        return (data, result == QDialog.Accepted)\n\n\nclass FirmwareUpdateDialog(QDialog):\n    def __init__(self, controller, parent = None):\n        super(FirmwareUpdateDialog, self).__init__(parent)\n\n        self.controller = controller\n        #self.differentVersion = True\n        #self.actualVersion = \'1.0.2\'\n        #self.yourVersion = \'1.0.1\'\n\n        layout = QVBoxLayout(self)\n\n\n        #self.actualVersionLabel = QtGui.QLabel(""Actual version of firmware is %s"" % self.actualVersion)\n        #self.yourVersionLabel = QtGui.QLabel(""Your version of firmware is %s"" % self.yourVersion)\n\n        self.open_file_button = QPushButton(self.tr(""Open file""))\n\n        self.update_button = QPushButton(self.tr(""Update""))\n        #TODO:Doplnit\n        #self.updateButton.clicked.connect(self.controller.updateFirmware)\n        #self.updateButton.setEnabled(self.differentVersion)\n\n        #layout.addWidget(self.actualVersionLabel)\n        #layout.addWidget(self.yourVersionLabel)\n        layout.addWidget(self.open_file_button)\n        layout.addWidget(self.update_button)\n\n        # Close button\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.Close,\n            Qt.Horizontal, self)\n        buttons.clicked.connect(self.close)\n        layout.addWidget(buttons)\n\n    @staticmethod\n    def get_firmware_update(controller, parent = None):\n        dialog = FirmwareUpdateDialog(controller, parent)\n        dialog.setWindowTitle(""Firmware update"")\n        result = dialog.exec_()\n        data = {\'msg\': \'Update is complete. New version is ....\'}\n        return (data, result == QDialog.Accepted)\n\n\nclass AboutDialog(QDialog):\n    def __init__(self, controller, parent = None):\n        super(AboutDialog, self).__init__(parent)\n\n        self.controller = controller\n        self.different_version = True\n        #self.actual_version = \'1.0.2\'\n        self.your_version = self.controller.app_config.version\n        self.slic3r_version = self.controller.slicer_manager.get_version()\n\n        layout = QVBoxLayout(self)\n\n        self.prusa_control_label = QLabel(""PrusaControl"")\n        self.prusa_control_label.setAlignment(Qt.AlignCenter)\n\n        self.prusa_control_text = QLabel(controller.view.tr(""PrusaControl\\nTibor Vavra, Prusa Research\\nDominik Cisar, Prusa Research\\n\\nSlic3r engine\\nVojtech Bubnik, Prusa Research\\nAlessandro Ranellucci""))\n\n\n\n        self.local_version_label = QLabel(controller.view.tr(""PrusaControl version is "") + str(self.your_version))\n        self.slic3r_engine_version_label = QLabel(controller.view.tr(""Slic3r engine version is "") + str(self.slic3r_version))\n\n\n        #self.check_version_button = QtGui.QPushButton(self.tr(""Check version""))\n        #TODO:Doplnit\n        #self.checkVersionButton.clicked.connect(self.controller.checkVersion)\n        #self.checkVersionButton.setEnabled(self.differentVersion)\n\n        layout.addWidget(self.prusa_control_label)\n        layout.addWidget(self.prusa_control_text)\n\n        layout.addWidget(self.local_version_label)\n        layout.addWidget(self.slic3r_engine_version_label)\n        #layout.addWidget(self.check_version_button)\n\n        # Close button\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.Ok,\n            Qt.Horizontal, self)\n        buttons.clicked.connect(self.close)\n        layout.addWidget(buttons)\n\n    @staticmethod\n    def get_about_dialog(controller, parent = None):\n        dialog = AboutDialog(controller, parent)\n        dialog.setWindowTitle(controller.view.tr(""About""))\n        result = dialog.exec_()\n        data = {\'msg\':\'Update is complete. New version is ....\'}\n        return (data, result == QDialog.Accepted)\n\n\nclass PrinterInfoDialog(QDialog):\n    def __init__(self, controller, parent= None):\n        super(PrinterInfoDialog, self).__init__(parent)\n\n        self.controller = controller\n        self.printer_name = self.controller.get_printer_name()\n        self.your_firmware_version = self.controller.get_firmware_version_number()\n\n        layout = QVBoxLayout(self)\n\n        self.printerNameLabel = QLabel(controller.view.tr(""Your printer is"") + "" %s"" % self.printer_name)\n\n        self.printerFirmwareText = QLabel(controller.view.tr(""Version of firmware is"") + "" %s"" % self.your_firmware_version)\n\n\n        #TODO:Doplnit\n        #self.checkVersionButton.clicked.connect(self.controller.checkVersion)\n        #self.checkVersionButton.setEnabled(self.differentVersion)\n\n        layout.addWidget(self.printerNameLabel)\n        layout.addWidget(self.printerFirmwareText)\n\n        buttons = QDialogButtonBox(\n            QDialogButtonBox.Ok,\n            Qt.Horizontal, self)\n        buttons.clicked.connect(self.close)\n        layout.addWidget(buttons)\n\n    @staticmethod\n    def get_printer_info_dialog(controller, parent = None):\n        dialog = PrinterInfoDialog(controller, parent)\n        dialog.setWindowTitle(""Printer info"")\n        result = dialog.exec_()\n        data = {\'msg\': \'Update is complete. New version is ....\'}\n        return (data, result == QDialog.Accepted)\n\n\nclass PrusaControlView(QMainWindow):\n    def __init__(self, c):\n        self.controller = c\n        super(PrusaControlView, self).__init__()\n\n        #print(""initialization of PrusaControlView"")\n        self.settings = QSettings(""Prusa Research"", ""PrusaControl"")\n        self.restoreGeometry(self.settings.value(""geometry"", """"))\n        self.restoreState(self.settings.value(""windowState"", """"))\n\n        #print(""font load of PrusaControlView"")\n        font_id = QFontDatabase.addApplicationFont(self.controller.app_config.local_path + ""data/font/TitilliumWeb-Light.ttf"")\n        font_family = QFontDatabase.applicationFontFamilies(font_id)[0]\n        self.font = QFont(font_family)\n        self.setFont(self.font)\n\n        #print(""enable of Drop"")\n        self.setAcceptDrops(True)\n\n        self.is_setting_panel_opened = True\n\n        self.setObjectName(\'PrusaControlView\')\n\n\n        self.infillValue = 20\n        self.changable_widgets = {}\n\n        self.object_id = 0\n\n        self.setVisible(False)\n        #print(""creating of widgets"")\n\n        self.centralWidget = QWidget(self)\n        self.object_settings_panel = None\n\n        self.menubar = self.menuBar()\n        #print(""menu bar"")\n\n        #self.create_menu()\n\n        #self.prusa_control_widget = PrusaControlWidget(self)\n\n        self.glWidget = sceneRender.GLWidget(self)\n        self.glWidget.setObjectName(\'glWidget\')\n        #print(""GL widgets"")\n\n        #Object settings layout\n        #self.object_groupbox_layout = QtGui.QFormLayout()\n\n        self.object_group_box = QGroupBox()\n        self.object_group_box.setObjectName(\'object_group_box\')\n\n        self.object_variable_layer_box = QGroupBox()\n        self.object_variable_layer_box.setObjectName(\'object_variable_layer_box\')\n\n        self.gcode_group_box = QGroupBox()\n        self.gcode_group_box.setObjectName(\'gcode_group_box\')\n\n\n        #print(""right menu"")\n        self.name_l = QLabel(self.object_group_box)\n        self.name_l.setObjectName(""name_l"")\n\n        self.object_extruder_l = QLabel("""", self.object_group_box)\n        self.object_extruder_l.setObjectName(""object_extruder_l"")\n        self.object_extruder_c = QComboBox(self.object_group_box)\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.object_extruder_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.object_extruder_c.setObjectName(""object_extruder_c"")\n\n        self.object_extruder_c.insertItems(4, [\'Extruder 1\', \'Extruder 2\', \'Extruder 3\', \'Extruder 4\'])\n        self.object_extruder_c.setCurrentIndex(0)\n\n        self.object_extruder_c.currentIndexChanged.connect(lambda: self.set_extruder_on_object(self.object_extruder_c,\n                                                                                               self.get_object_id()))\n\n\n        self.filename_label = QLabel("""", self.object_group_box)\n        self.filename_label.setObjectName(""filename_label"")\n        self.filename_c = QComboBox(self.object_group_box)\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.filename_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.filename_c.setObjectName(""filename_c"")\n        self.filename_c.setVisible(False)\n\n        self.filename_c.currentIndexChanged.connect(lambda: self.select_model_by_filename(self.filename_c.currentText()))\n        #TODO: Add logic for selecting different part from combobox\n\n\n\n\n        self.position_l = QLabel("""", self.object_group_box)\n        self.position_l.setObjectName(""position_l"")\n        self.edit_pos_x = QSpinBox(self.object_group_box)\n        self.edit_pos_x.setObjectName(""edit_pos_x"")\n        self.edit_pos_x.setMaximum(200)\n        self.edit_pos_x.setMinimum(-200)\n        self.edit_pos_x.setSuffix(""mm"")\n        self.edit_pos_x.valueChanged.connect(lambda: self.set_position_on_object(self.edit_pos_x,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_pos_x.value(),\n                                                                                 self.edit_pos_y.value(),\n                                                                                 self.edit_pos_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.edit_pos_y = QSpinBox(self.object_group_box)\n        self.edit_pos_y.setObjectName(""edit_pos_y"")\n        self.edit_pos_y.setMaximum(200)\n        self.edit_pos_y.setMinimum(-200)\n        self.edit_pos_y.setSuffix(""mm"")\n        self.edit_pos_y.valueChanged.connect(lambda: self.set_position_on_object(self.edit_pos_y,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_pos_x.value(),\n                                                                                 self.edit_pos_y.value(),\n                                                                                 self.edit_pos_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.edit_pos_z = QSpinBox(self.object_group_box)\n        self.edit_pos_z.setObjectName(""edit_pos_z"")\n        self.edit_pos_z.setMaximum(300)\n        self.edit_pos_z.setMinimum(-50)\n        self.edit_pos_z.setSuffix(""mm"")\n        self.edit_pos_z.valueChanged.connect(lambda: self.set_position_on_object(self.edit_pos_z,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_pos_x.value(),\n                                                                                 self.edit_pos_y.value(),\n                                                                                 self.edit_pos_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.rotation_l = QLabel("""", self.object_group_box)\n        self.rotation_l.setObjectName(""rotation_l"")\n        self.edit_rot_x = QSpinBox(self.object_group_box)\n        self.edit_rot_x.setObjectName(""edit_rot_x"")\n        self.edit_rot_x.setMaximum(360)\n        self.edit_rot_x.setMinimum(-360)\n        self.edit_rot_x.setSuffix(u""\xc2\xb0"")\n        self.edit_rot_x.valueChanged.connect(lambda: self.set_rotation_on_object(self.edit_rot_x,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_rot_x.value(),\n                                                                                 self.edit_rot_y.value(),\n                                                                                 self.edit_rot_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.edit_rot_y = QSpinBox(self.object_group_box)\n        self.edit_rot_y.setObjectName(""edit_rot_y"")\n        self.edit_rot_y.setMaximum(360)\n        self.edit_rot_y.setMinimum(-360)\n        self.edit_rot_y.setSuffix(u""\xc2\xb0"")\n        self.edit_rot_y.valueChanged.connect(lambda: self.set_rotation_on_object(self.edit_rot_y,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_rot_x.value(),\n                                                                                 self.edit_rot_y.value(),\n                                                                                 self.edit_rot_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.edit_rot_z = QSpinBox(self.object_group_box)\n        self.edit_rot_z.setObjectName(""edit_rot_z"")\n        self.edit_rot_z.setMaximum(360)\n        self.edit_rot_z.setMinimum(-360)\n        self.edit_rot_z.setSuffix(u""\xc2\xb0"")\n        self.edit_rot_z.valueChanged.connect(lambda: self.set_rotation_on_object(self.edit_rot_z,\n                                                                                 self.get_object_id(),\n                                                                                 self.edit_rot_x.value(),\n                                                                                 self.edit_rot_y.value(),\n                                                                                 self.edit_rot_z.value(),\n                                                                                 self.place_on_zero.isChecked()))\n\n        self.scale_l = QLabel("""", self.object_group_box)\n        self.scale_l.setObjectName(""scale_l"")\n        self.edit_scale_x = QDoubleSpinBox(self.object_group_box)\n        self.edit_scale_x.setObjectName(""edit_scale_x"")\n        self.edit_scale_x.setMaximum(9999)\n        self.edit_scale_x.setMinimum(-999)\n        self.edit_scale_x.setSuffix(""%"")\n        self.edit_scale_x.setDecimals(0)\n        self.edit_scale_x.valueChanged.connect(lambda: self.set_scale_on_object(self.edit_scale_x,\n                                                                                \'x\',\n                                                                                self.get_object_id(),\n                                                                                self.edit_scale_x.value(),\n                                                                                self.edit_scale_y.value(),\n                                                                                self.edit_scale_z.value(),\n                                                                                self.place_on_zero.isChecked()))\n\n        self.edit_scale_y = QDoubleSpinBox(self.object_group_box)\n        self.edit_scale_y.setObjectName(""edit_scale_y"")\n        self.edit_scale_y.setMaximum(9999)\n        self.edit_scale_y.setMinimum(-999)\n        self.edit_scale_y.setSuffix(""%"")\n        self.edit_scale_y.setDecimals(0)\n        self.edit_scale_y.valueChanged.connect(lambda: self.set_scale_on_object(self.edit_scale_y,\n                                                                                \'y\',\n                                                                                self.get_object_id(),\n                                                                                self.edit_scale_x.value(),\n                                                                                self.edit_scale_y.value(),\n                                                                                self.edit_scale_z.value(),\n                                                                                self.place_on_zero.isChecked()))\n\n        self.edit_scale_z = QDoubleSpinBox(self.object_group_box)\n        self.edit_scale_z.setObjectName(""edit_scale_z"")\n        self.edit_scale_z.setMaximum(9999)\n        self.edit_scale_z.setMinimum(-999)\n        self.edit_scale_z.setSuffix(""%"")\n        self.edit_scale_z.setDecimals(0)\n        self.edit_scale_z.valueChanged.connect(lambda: self.set_scale_on_object(self.edit_scale_z,\n                                                                                \'z\',\n                                                                                self.get_object_id(),\n                                                                                self.edit_scale_x.value(),\n                                                                                self.edit_scale_y.value(),\n                                                                                self.edit_scale_z.value(),\n                                                                                self.place_on_zero.isChecked()))\n        self.combobox_scale_units = QComboBox(self.object_group_box)\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.combobox_scale_units.setStyle(QStyleFactory.create(\'Windows\'))\n        self.combobox_scale_units.setObjectName(""combobox_scale_units"")\n        self.combobox_scale_units.addItems([""%"", ""mm""])\n        self.combobox_scale_units.setCurrentIndex(0)\n\n        self.scale_units = self.combobox_scale_units.currentText()\n        self.combobox_scale_units.currentIndexChanged.connect(self.change_scale_units)\n\n        self.lock_scale_axes_checkbox = QCheckBox("""")\n        self.lock_scale_axes_checkbox.setObjectName(""lock_axis_checkbox"")\n        self.lock_scale_axes_checkbox.stateChanged.connect(self.lock_scale_axes_change)\n        self.lock_scale_axes_checkbox.setChecked(True)\n\n        self.place_on_zero = QCheckBox("""", self.object_group_box)\n        self.place_on_zero.setChecked(True)\n        self.place_on_zero.setObjectName(""place_on_zero"")\n        self.place_on_zero.stateChanged.connect(self.place_on_zero_changed)\n\n        self.x_pos_l = QLabel(\'X\', self.object_group_box)\n        self.x_pos_l.setAlignment(Qt.AlignRight)\n        self.x_pos_l.setObjectName(""x_pos_l"")\n        self.y_pos_l = QLabel(\'Y\', self.object_group_box)\n        self.y_pos_l.setAlignment(Qt.AlignRight)\n        self.y_pos_l.setObjectName(""y_pos_l"")\n        self.z_pos_l = QLabel(\'Z\', self.object_group_box)\n        self.z_pos_l.setAlignment(Qt.AlignRight)\n        self.z_pos_l.setObjectName(""z_pos_l"")\n\n        self.x_rot_l = QLabel(\'X\', self.object_group_box)\n        self.x_rot_l.setAlignment(Qt.AlignRight)\n        self.x_rot_l.setObjectName(""x_rot_l"")\n        self.y_rot_l = QLabel(\'Y\', self.object_group_box)\n        self.y_rot_l.setAlignment(Qt.AlignRight)\n        self.y_rot_l.setObjectName(""y_rot_l"")\n        self.z_rot_l = QLabel(\'Z\', self.object_group_box)\n        self.z_rot_l.setAlignment(Qt.AlignRight)\n        self.z_rot_l.setObjectName(""z_rot_l"")\n\n        self.x_scale_l = QLabel(\'X\', self.object_group_box)\n        self.x_scale_l.setAlignment(Qt.AlignRight)\n        self.x_scale_l.setObjectName(""x_scale_l"")\n        self.y_scale_l = QLabel(\'Y\', self.object_group_box)\n        self.y_scale_l.setAlignment(Qt.AlignRight)\n        self.y_scale_l.setObjectName(""y_scale_l"")\n        self.z_scale_l = QLabel(\'Z\', self.object_group_box)\n        self.z_scale_l.setAlignment(Qt.AlignRight)\n        self.z_scale_l.setObjectName(""z_scale_l"")\n\n        self.units_l = QLabel("""", self.object_group_box)\n        self.units_l.setAlignment(Qt.AlignRight)\n        self.units_l.setObjectName(""units_l"")\n        self.lock_scale_axes_l = QLabel()\n        self.lock_scale_axes_l.setAlignment(Qt.AlignRight)\n        self.lock_scale_axes_l.setObjectName(""lock_scale_axes_l"")\n        self.place_on_zero_l = QLabel("""", self.object_group_box)\n        self.place_on_zero_l.setObjectName(""place_on_zero_l"")\n\n        self.advance_settings_b = QPushButton("""", self.object_group_box)\n        self.advance_settings_b.setObjectName(""advance_settings_b"")\n        self.advance_settings_b.clicked.connect(self.controller.set_advance_settings)\n        if self.controller.development_flag:\n            self.advance_settings_b.setVisible(True)\n        else:\n            self.advance_settings_b.setVisible(False)\n        # Object settings layout\n\n        # Object variable layer widget\n        self.variable_layer_widget = Spline_editor(self, self.controller)\n        self.variable_layer_widget.setObjectName(""variable_layer_widget"")\n        self.variable_layer_widget.setFixedHeight((int)(400*self.controller.dpi_coef))\n        #self.connect(self.variable_layer_widget.slider, SIGNAL(""valueChanged(int)""), self.set_variable_layer_slider)\n        self.variable_layer_widget.slider.valueChanged.connect(self.set_variable_layer_slider)\n\n        self.basic_settings_b = QPushButton()\n        self.basic_settings_b.setObjectName(""basic_settings_b"")\n        self.basic_settings_b.clicked.connect(self.controller.set_basic_settings)\n        # Object variable layer widget\n\n        # Gcode view layout\n        #self.gcode_view_layout = QtGui.QVBoxLayout()\n\n        self.color_change_l = QLabel()\n        self.color_change_l.setObjectName(""color_change_l"")\n\n        self.gcode_help_b= QPushButton(""?"", self.gcode_group_box)\n        self.gcode_help_b.setCheckable(True)\n        if self.controller.app_config.system_platform in [""Darwin""]:\n            self.gcode_help_b.setStyle(QStyleFactory.create(""Macintosh""))\n        else:\n            self.gcode_help_b.setFixedHeight((int)(19 * self.controller.dpi_coef))\n            self.gcode_help_b.setFixedWidth((int)(19 * self.controller.dpi_coef))\n        self.gcode_help_b.setObjectName(""gcode_help_b"")\n        self.gcode_help_b.clicked.connect(self.controller.set_gcode_help_button_pressed)\n        #self.gcode_help_b.released.connect(self.controller.set_gcode_help_button_released)\n        #self.gcode_help_b.setToolTip(""<img src=\':img.png\'>"")\n\n\n\n        self.gcode_slider = self.create_slider(self.set_gcode_slider, 0, 0, 100 ,Qt.Vertical, Gcode_slider)\n        self.gcode_slider.setObjectName(""gcode_slider"")\n\n        self.gcode_back_b = QPushButton()\n        self.gcode_back_b.setObjectName(""gcode_back_b"")\n        self.gcode_back_b.clicked.connect(self.controller.set_model_edit_view)\n        self.gcode_back_b.setVisible(False)\n        # Gcode view layout\n\n        self.right_panel = QWidget(self)\n        self.right_panel.setObjectName(\'right_panel\')\n        #self.right_panel_layout = QtGui.QFormLayout()\n        self.right_panel_layout = QVBoxLayout()\n        self.right_panel_layout.setObjectName(\'right_panel_layout\')\n        #self.right_panel_layout.setSpacing(5)\n        self.right_panel_layout.setContentsMargins(0, 0, 0, 0)\n        #self.right_panel_layout.setMargin(0)\n        #self.right_panel_layout.setContentsMargins(0, 0, 0, 0)\n\n        self.scroll_area = QScrollArea(self)\n\n        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff )\n        #self.scroll_area.setWidget(self.right_panel)\n\n        #QAbstractScrollArea.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff )\n\n        self.printer_settings_l = QLabel()\n        self.printer_settings_l.setObjectName(\'printer_settings_l\')\n        # print tab\n        self.materialLabel = QLabel()\n        self.materialLabel.setObjectName(\'materialLabel\')\n        self.materialCombo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.materialCombo.setStyle(QStyleFactory.create(\'Windows\'))\n        self.materialCombo.setObjectName(\'materialCombo\')\n        material_label_ls, first = self.controller.get_printer_materials_labels_ls(self.controller.get_actual_printer())\n        self.materialCombo.addItems(material_label_ls)\n        self.materialCombo.setCurrentIndex(first)\n        self.materialCombo.currentIndexChanged.connect(self.controller.update_gui)\n        self.materialCombo.setMaxVisibleItems(len(material_label_ls))\n\n\n        self.qualityLabel = QLabel()\n        self.qualityLabel.setObjectName(\'qualityLabel\')\n        self.qualityCombo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.qualityCombo.setStyle(QStyleFactory.create(\'Windows\'))\n        self.qualityCombo.setObjectName(\'qualityCombo\')\n\n        #self.infillLabel = QtGui.QLabel(self.tr(""Infill"") + "" %s"" % str(self.infillValue) + \'%\')\n        #self.infillLabel.setObjectName(\'infillLabel\')\n        #self.infillLabel.setFixedWidth(75)\n        #self.infillSlider = self.create_slider(self.set_infill, self.infillValue)\n        #self.infillSlider.setObjectName(\'infillSlider\')\n\n        self.infillLabel = QLabel()\n        self.infillLabel.setObjectName(\'infillLabel\')\n        self.infillLabel.setFixedWidth((int)(75*self.controller.dpi_coef))\n        self.infillCombo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.infillCombo.setStyle(QStyleFactory.create(\'Windows\'))\n        self.infillCombo.setObjectName(\'infillCombo\')\n        infill_ls, f = self.controller.get_infill_ls_and_index_of_default(""0%"")\n        self.infillCombo.insertItems(len(infill_ls), infill_ls)\n        self.infillCombo.setMaxVisibleItems(len(infill_ls))\n\n\n        #self.supportCheckBox = QtGui.QCheckBox(self.tr(""Support material""))\n        self.supportLabel = QLabel()\n        self.supportLabel.setObjectName(\'supportLabel\')\n        self.supportCombo = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.supportCombo.setStyle(QStyleFactory.create(\'Windows\'))\n        self.supportCombo.addItems([self.tr(""None""), self.tr(""Build plate only""), self.tr(""Everywhere"")])\n        self.supportCombo.setObjectName(\'supportCombo\')\n        self.supportCombo.setMaxVisibleItems(10)\n\n        self.brim_label = QLabel()\n        self.brim_label.setObjectName(\'brim_label\')\n        self.brimCheckBox = QCheckBox("""")\n        self.brimCheckBox.setObjectName(\'brimCheckBox\')\n\n\n        #multimaterial settings\n        self.single_material_mode_tooltip = self.tr(""Do you want to print only from one material?"")\n        self.single_material_mode_checkbox = QCheckBox(""Single material Mode"")\n        self.single_material_mode_checkbox.setObjectName(""single_material_mode_checkbox"")\n        self.single_material_mode_checkbox.setToolTip(self.single_material_mode_tooltip)\n        self.single_material_mode_checkbox.stateChanged.connect(self.controller.set_unset_single_material_mode)\n\n        self.materials_settings_l = QLabel()\n        self.materials_settings_l.setObjectName(""materials_settings_l"")\n\n        self.extruder1_cb = QPushButton()\n        self.extruder1_color = QColor.fromRgb(255, 170, 85)\n        self.extruder1_cb.setObjectName(""extruder1_cb"")\n        self.extruder1_cb.clicked.connect(self.controller.open_color_pick_dialog1)\n        self.extruder1_l = QLabel()\n        self.extruder1_l.setObjectName(""extruder1_l"")\n\n        self.extruder1_c = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.extruder1_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.extruder1_c.addItems(material_label_ls)\n        self.extruder1_c.setCurrentIndex(first)\n        self.extruder1_c.currentIndexChanged.connect(self.update_material_settings)\n        self.extruder1_c.setObjectName(""extruder1_c"")\n        self.extruder1_c.setMaxVisibleItems(len(material_label_ls))\n\n        self.extruder2_cb = QPushButton()\n        self.extruder2_color = QColor.fromRgb(81, 130, 219)\n        self.extruder2_cb.setObjectName(""extruder2_cb"")\n        self.extruder2_cb.clicked.connect(self.controller.open_color_pick_dialog2)\n        self.extruder2_l = QLabel()\n        self.extruder2_l.setObjectName(""extruder2_l"")\n        self.extruder2_c = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.extruder2_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.extruder2_c.addItems(material_label_ls)\n        self.extruder2_c.setCurrentIndex(first)\n        self.extruder2_c.currentIndexChanged.connect(self.update_material_settings)\n        self.extruder2_c.setObjectName(""extruder2_c"")\n        self.extruder2_c.setMaxVisibleItems(len(material_label_ls))\n\n        self.extruder3_cb = QPushButton()\n        self.extruder3_color = QColor.fromRgb(78, 205, 211)\n        self.extruder3_cb.setObjectName(""extruder3_cb"")\n        self.extruder3_cb.clicked.connect(self.controller.open_color_pick_dialog3)\n        self.extruder3_l = QLabel()\n        self.extruder3_l.setObjectName(""extruder3_l"")\n        self.extruder3_c = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.extruder3_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.extruder3_c.addItems(material_label_ls)\n        self.extruder3_c.setCurrentIndex(first)\n        self.extruder3_c.currentIndexChanged.connect(self.update_material_settings)\n        self.extruder3_c.setObjectName(""extruder3_c"")\n        self.extruder3_c.setMaxVisibleItems(len(material_label_ls))\n\n        self.extruder4_cb = QPushButton()\n        self.extruder4_color = QColor.fromRgb(251, 114, 89)\n        self.extruder4_cb.setObjectName(""extruder4_cb"")\n        self.extruder4_cb.clicked.connect(self.controller.open_color_pick_dialog4)\n        self.extruder4_l = QLabel()\n        self.extruder4_l.setObjectName(""extruder4_l"")\n        self.extruder4_c = QComboBox()\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.extruder4_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.extruder4_c.addItems(material_label_ls)\n        self.extruder4_c.setCurrentIndex(first)\n        self.extruder4_c.currentIndexChanged.connect(self.update_material_settings)\n        self.extruder4_c.setObjectName(""extruder4_c"")\n        self.extruder4_c.setMaxVisibleItems(len(material_label_ls))\n\n        self.used_extruder_tooltip = self.tr(""Extruder is used"")\n\n        self.wipe_tower_tooltip = self.tr(""Amount of material in wipe tower, material clearing"")\n        self.wipe_tower_l = QLabel()\n        self.wipe_tower_l.setObjectName(""wipe_tower_l"")\n        self.wipe_tower_l.setToolTip(self.wipe_tower_tooltip)\n        self.wipe_tower_c = QComboBox()\n        self.wipe_tower_c.setToolTip(self.wipe_tower_tooltip)\n        if self.controller.app_config.system_platform in [\'Linux\']:\n            self.wipe_tower_c.setStyle(QStyleFactory.create(\'Windows\'))\n        self.wipe_tower_c.setObjectName(""wipe_tower_c"")\n        self.wipe_tower_c.addItems(self.get_list_of_wipe_tower_labels())\n        self.wipe_tower_c.setCurrentIndex(1)\n        self.wipe_tower_c.currentIndexChanged.connect(self.change_of_wipe_tower_settings)\n        self.wipe_tower_c.setMaxVisibleItems(len(self.get_list_of_wipe_tower_labels()))\n        # multimaterial settings\n\n\n        self.object_settings_layout = self.create_object_settings_layout()\n        self.object_group_box.setLayout(self.object_settings_layout)\n        self.object_group_box.setEnabled(False)\n        self.transformation_reset_b = QPushButton("""", self.object_group_box)\n        if self.controller.app_config.system_platform in [""Darwin""]:\n            self.transformation_reset_b.setStyle(QStyleFactory.create(""Macintosh""))\n        else:\n            self.transformation_reset_b.setFixedHeight((int)(19 * self.controller.dpi_coef))\n            self.transformation_reset_b.setFixedWidth((int)(19 * self.controller.dpi_coef))\n        self.transformation_reset_b.setObjectName(""transformation_reset_b"")\n        self.transformation_reset_b.clicked.connect(lambda: self.reset_transformation_on_object(self.get_object_id()))\n\n\n        self.object_variable_layer_box.setLayout(self.create_object_advance_settings_layout())\n        self.object_variable_layer_box.setVisible(False)\n\n\n        self.gcode_group_box.setLayout(self.create_gcode_view_layout())\n        self.gcode_group_box.setVisible(False)\n\n        self.progressBar = QProgressBar()\n        self.progressBar.setObjectName(\'progressBar\')\n        self.progressBar.setMinimum(0)\n        self.progressBar.setMaximum((int)(100*self.controller.dpi_coef))\n        self.progressBar.setValue(0)\n        self.progressBar.setAlignment(Qt.AlignCenter)\n        #self.progressBar.setFormat(""Generovani GCodu %p%"")\n\n        self.generateButton = QPushButton()\n        self.generateButton.setObjectName(\'generateButton\')\n        self.generateButton.clicked.connect(self.controller.generate_button_pressed)\n        self.generateButton.setEnabled(False)\n\n        saveBWLayout = QHBoxLayout()\n        saveBWLayout.setSpacing(0)\n        self.saveMenuButton = QPushButton()\n        self.saveMenuButton.setObjectName(""saveMenuButton"")\n        self.saveButton = QPushButton(self.tr(""Save G-Code""))\n        self.saveButton.setObjectName(""saveButton"")\n        self.saveButton.clicked.connect(self.controller.generate_button_pressed)\n\n        self.saveMenu = QMenu()\n        self.saveMenu.setObjectName(""saveMenu"")\n\n        #self.saveMenu.addActions(self.get_actual_action_list(self.saveButton))\n\n        self.update_actions_in_menu()\n        self.saveMenuButton.setMenu(self.saveMenu)\n\n        saveBWLayout.addWidget(self.saveButton)\n        saveBWLayout.addWidget(self.saveMenuButton)\n        saveBWLayout.setMargin(0)\n        self.saveBW = QWidget()\n        self.saveBW.setLayout(saveBWLayout)\n        self.saveBW.setObjectName(\'saveBW\')\n        self.saveBW.setVisible(False)\n\n        #self.right_panel_layout.setAlignment(Qt.AlignTop)\n        printing_mm_parameters_layout = QGridLayout()\n        printing_parameters_layout = QGridLayout()\n        #printing_parameters_layout.setRowMinimumHeight(0, 65)\n\n        printing_mm_parameters_layout.setColumnMinimumWidth(0, 10)\n        printing_mm_parameters_layout.addWidget(self.single_material_mode_checkbox, 0, 1, 1, 3)\n        #printing_mm_parameters_layout.addWidget(self.single_material_mode_l, 0, 2, 1, 2)\n\n        printing_mm_parameters_layout.addWidget(self.materials_settings_l, 1, 0, 1, 3)\n\n        printing_mm_parameters_layout.addWidget(self.extruder1_cb, 2, 0)\n        printing_mm_parameters_layout.addWidget(self.extruder1_l, 2, 1)\n        printing_mm_parameters_layout.addWidget(self.extruder1_c, 2, 2, 1, 2)\n\n        printing_mm_parameters_layout.addWidget(self.extruder2_cb, 3, 0)\n        printing_mm_parameters_layout.addWidget(self.extruder2_l, 3, 1)\n        printing_mm_parameters_layout.addWidget(self.extruder2_c, 3, 2, 1, 2)\n\n        printing_mm_parameters_layout.addWidget(self.extruder3_cb, 4, 0)\n        printing_mm_parameters_layout.addWidget(self.extruder3_l, 4, 1)\n        printing_mm_parameters_layout.addWidget(self.extruder3_c, 4, 2, 1, 2)\n\n        printing_mm_parameters_layout.addWidget(self.extruder4_cb, 5, 0)\n        printing_mm_parameters_layout.addWidget(self.extruder4_l, 5, 1)\n        printing_mm_parameters_layout.addWidget(self.extruder4_c, 5, 2, 1, 2)\n\n        #add size of wipe tower combobox\n        printing_mm_parameters_layout.addWidget(self.wipe_tower_l, 6, 1)\n        printing_mm_parameters_layout.addWidget(self.wipe_tower_c, 6, 2, 1, 2)\n\n\n\n\n        printing_parameters_layout.addWidget(self.printer_settings_l, 6, 0, 1, 3)\n        printing_parameters_layout.addWidget(self.materialLabel, 7,0)\n        printing_parameters_layout.addWidget(self.materialCombo, 7, 1, 1, 3)\n        printing_parameters_layout.addWidget(self.qualityLabel, 8, 0)\n        printing_parameters_layout.addWidget(self.qualityCombo, 8, 1, 1, 3)\n        printing_parameters_layout.addWidget(self.infillLabel, 9, 0)\n        #printing_parameters_layout.addWidget(self.infillSlider, 3, 1, 1, 3)\n        printing_parameters_layout.addWidget(self.infillCombo, 9, 1, 1, 3)\n        printing_parameters_layout.addWidget(self.supportLabel, 10, 0)\n        printing_parameters_layout.addWidget(self.supportCombo, 10, 1, 1, 3)\n        printing_parameters_layout.addWidget(self.brim_label, 11, 0)\n        printing_parameters_layout.addWidget(self.brimCheckBox, 11, 1, 1, 3)\n\n        self.right_panel_layout.addLayout(printing_mm_parameters_layout)\n        self.right_panel_layout.addLayout(printing_parameters_layout)\n\n        self.right_panel_layout.addWidget(self.object_group_box)\n        self.right_panel_layout.addWidget(self.object_variable_layer_box)\n        self.right_panel_layout.addWidget(self.gcode_group_box)\n        self.right_panel_layout.addStretch()\n        #self.right_panel_layout.addItem(QtGui.QSpacerItem(0, 0, QtGui.QSizePolicy.Minimum, QtGui.QSizePolicy.Expanding))\n\n        self.right_panel_layout.addWidget(self.generateButton)\n        self.right_panel_layout.addWidget(self.saveBW)\n        self.right_panel_layout.addWidget(self.progressBar)\n        self.right_panel_layout.addWidget(self.gcode_back_b)\n        self.right_panel_layout.addSpacerItem(QSpacerItem(0, 5, QSizePolicy.Minimum, QSizePolicy.Minimum))\n\n        self.right_panel.setLayout(self.right_panel_layout)\n\n\n        if self.controller.app_config.system_platform in [\'Windows\', \'Linux\']:\n            printing_parameters_layout.setColumnMinimumWidth(1, (int)(100 * self.controller.dpi_coef))\n            self.right_panel.setFixedWidth((int)(250 * self.controller.dpi_coef))\n        else:\n            printing_parameters_layout.setColumnMinimumWidth(1, 150)\n            self.right_panel.setFixedWidth((int) (300*self.controller.dpi_coef))\n\n\n        #self.right_panel.setMinimumWidth((int)(250*self.controller.dpi_coef))\n        #self.right_panel.setMaximumWidth((int)(275*self.controller.dpi_coef))\n\n        print(""Sirka praveho panelu: "" + str(self.right_panel.width()))\n        self.transformation_reset_b.move((int)(self.right_panel.width() - 27*self.controller.dpi_coef), 13)\n        self.gcode_help_b.move((int)(self.right_panel.width() - 27*self.controller.dpi_coef), 13)\n\n        #print(""create gcode panel"")\n        self.gcode_panel = QWidget()\n        self.gcode_label = QLabel(""0"")\n        self.gcode_label.setMaximumWidth((int)(40*self.controller.dpi_coef))\n        self.gcode_label.setAlignment(Qt.AlignCenter)\n\n        mainLayout = QHBoxLayout()\n        mainLayout.setSpacing(0)\n        mainLayout.setContentsMargins(0, 0, 0, 0)\n        #mainLayout.setContentsMargin(0, 0, 0, 0)\n        #mainLayout.setMargin(0)\n        #mainLayout.setContentsMargins(0, 0, 0, 0)\n        mainLayout.addWidget(self.glWidget)\n        mainLayout.addWidget(self.scroll_area)\n        #mainLayout.addWidget(self.right_panel)\n        self.scroll_area.setWidget(self.right_panel)\n        self.scroll_area.setAutoFillBackground(True)\n        self.scroll_area.setWidgetResizable(True)\n        self.scroll_area.setFixedWidth(self.right_panel.width())\n        self.scroll_area.show()\n\n        self.centralWidget.setLayout(mainLayout)\n        self.setCentralWidget(self.centralWidget)\n\n        #self.statusBar().showMessage(\'Ready\')\n        self.setWindowTitle(""PrusaControl "" + self.controller.app_config.version)\n        #print(""Set window title"")\n\n        #print(""Retranslate UI"")\n        self.retranslateUI()\n\n        self.setVisible(True)\n\n        #self.changable_widgets[\'brimCheckBox\'] = self.brimCheckBox\n        #self.changable_widgets[\'supportCheckBox\'] = self.supportCheckBox\n        #self.changable_widgets[\'supportCombo\'] = self.supportCombo\n\n\n        self.qualityCombo.currentIndexChanged.connect(self.controller.scene_was_changed)\n        #self.infillSlider.valueChanged.connect(self.controller.scene_was_changed)\n        #self.supportCheckBox.clicked.connect(self.controller.scene_was_changed)\n        #self.supportCombo.currentIndexChanged.connect(self.controller.scene_was_changed)\n        self.supportCombo.currentIndexChanged.connect(self.controller.actualize_extruders)\n        self.brimCheckBox.clicked.connect(self.controller.scene_was_changed)\n\n        #print(""created all widgets"")\n        self.glWidget.setFocusPolicy(Qt.StrongFocus)\n        #print(""set strong focus for GL"")\n\n        #self.set_scale(self.controller.dpi_coef)\n\n        #print(""Show all"")\n        self.show()\n\n    def get_list_of_wipe_tower_labels(self):\n        return [self.tr(""Reduced""), self.tr(""Normal""), self.tr(""Increased/Soluble"")]\n\n    def change_of_wipe_tower_settings(self):\n        index = self.wipe_tower_c.currentIndex()\n        self.controller.change_of_wipe_tower_settings(index)\n\n    def update_object_extruders_cb(self):\n        actual_index = self.object_extruder_c.currentIndex()\n        self.object_extruder_c.clear()\n\n        model = self.object_extruder_c.model()\n        for n, i in enumerate([\'Extruder 1\', \'Extruder 2\', \'Extruder 3\', \'Extruder 4\']):\n            item = QStandardItem(str(i))\n            item.setBackground(self.controller.get_extruder_color(n+1))\n            model.appendRow(item)\n\n        self.object_extruder_c.setCurrentIndex(actual_index)\n\n\n    def set_scale(self, scale):\n        #resize window\n        #self.setFixedSize((int)(scale * self.maximumWidth()), (int)(scale * self.maximumHeight()))\n        #resize layouts with widgets\n        for widget in self.centralWidget.children():\n            if not type(widget) is QHBoxLayout and \\\n                not type(widget) is QPropertyAnimation and \\\n                not type(widget) is sceneRender.GLWidget:\n                #print(str(type(widget)))\n                #print(scale* widget.maximumWidth())\n                #print(scale * widget.maximumHeight())\n                widget.setFixedSize((int)(scale * widget.maximumWidth()), (int)(scale * widget.maximumHeight()))\n\n    def update_actions_in_menu(self):\n        self.saveMenu.clear()\n        self.saveMenu.addActions(self.get_actual_action_list(self.saveButton))\n\n\n    def get_actual_action_list(self, button_widget):\n        actionList = []\n\n        action = QAction(self.tr(""Save G-Code""), self)\n        action.triggered.connect(self.controller.generate_button_pressed)\n        actionList.append(action)\n\n        for address in self.controller.list_of_printing_services:\n            action_tmp = QAction(""Print on %s"" % address, self)\n            action_tmp.triggered.connect(self.make_action)\n            actionList.append(action_tmp)\n\n        action_tmp = QAction(""Add OctoPrint"", self)\n        action_tmp.triggered.connect(self.controller.add_new_octoprint)\n        actionList.append(action_tmp)\n\n        return actionList\n\n    def make_action(self):\n        sender = self.sender()\n        self.saveButton.setText(sender.text())\n        self.controller.set_print_on(sender.text())\n\n\n    def open_color_pick_dialog1(self):\n        color = QColorDialog.getColor(self.extruder1_color)\n        if color.isValid():\n            self.extruder1_color = color\n            self.extruder1_cb.setStyleSheet(""background-color: rgb(%s, %s, %s)"" % (color.red(), color.green(), color.blue()))\n            self.update_object_extruders_cb()\n\n    def open_color_pick_dialog2(self):\n        color = QColorDialog.getColor(self.extruder2_color)\n        if color.isValid():\n            self.extruder2_color = color\n            self.extruder2_cb.setStyleSheet(""background-color: rgb(%s, %s, %s)"" % (color.red(), color.green(), color.blue()))\n            self.update_object_extruders_cb()\n\n    def open_color_pick_dialog3(self):\n        color = QColorDialog.getColor(self.extruder3_color)\n        if color.isValid():\n            self.extruder3_color = color\n            self.extruder3_cb.setStyleSheet(""background-color: rgb(%s, %s, %s)"" % (color.red(), color.green(), color.blue()))\n            self.update_object_extruders_cb()\n\n    def open_color_pick_dialog4(self):\n        color = QColorDialog.getColor(self.extruder4_color)\n        if color.isValid():\n            self.extruder4_color = color\n            self.extruder4_cb.setStyleSheet(""background-color: rgb(%s, %s, %s)"" % (color.red(), color.green(), color.blue()))\n            self.update_object_extruders_cb()\n\n\n    def set_default(self):\n        _, first = self.controller.get_printer_materials_labels_ls(self.controller.get_actual_printer())\n        self.materialCombo.setCurrentIndex(first)\n\n        self.extruder1_c.setCurrentIndex(first)\n        self.extruder2_c.setCurrentIndex(first)\n        self.extruder3_c.setCurrentIndex(first)\n        self.extruder4_c.setCurrentIndex(first)\n\n        self.brimCheckBox.setChecked(False)\n        self.supportCombo.setCurrentIndex(0)\n\n\n    def retranslateUI(self):\n        self.name_l.setText(self.tr(""Name""))\n        self.object_extruder_l.setText(self.tr(""Extruder""))\n        self.position_l.setText(self.tr(""Position""))\n        self.rotation_l.setText(self.tr(""Rotation""))\n        self.scale_l.setText(self.tr(""Scale""))\n\n        self.combobox_scale_units.setToolTip(self.tr(""In what units you want to scale?""))\n\n        self.lock_scale_axes_l.setText(self.tr(""Lock axes""))\n        self.lock_scale_axes_checkbox.setToolTip(self.tr(""Lock of scaling axis""))\n\n        self.place_on_zero_l.setText(self.tr(""Place on bed""))\n        self.place_on_zero.setToolTip(self.tr(""Automatic placing of models\\n on printing bed in Z axis""))\n\n        self.units_l.setText(self.tr(\'Units\'))\n\n        self.advance_settings_b.setText(self.tr(""Advance Settings""))\n        self.basic_settings_b.setText(self.tr(""Basic Settings""))\n\n        self.color_change_l.setText(self.tr(""And color change""))\n        self.gcode_back_b.setText(self.tr(""Back""))\n\n        self.printer_settings_l.setText(self.tr(""Printer settings""))\n\n        self.materialLabel.setText(self.tr(""Material""))\n        self.material_tooltip = self.tr(""Select material for printing"")\n        self.materialLabel.setToolTip(self.material_tooltip)\n        self.materialCombo.setToolTip(self.material_tooltip)\n\n\n        self.qualityLabel.setText(self.tr(""Quality""))\n        self.quality_tooltip = self.tr(""Select quality for printing"")\n        self.qualityLabel.setToolTip(self.quality_tooltip)\n        self.qualityCombo.setToolTip(self.quality_tooltip)\n\n        self.infillLabel.setText(self.tr(""Infill""))\n        self.infill_tooltip = self.tr(""Select how much space inside of model have to be filled"")\n        self.infillLabel.setToolTip(self.infill_tooltip)\n        self.infillCombo.setToolTip(self.infill_tooltip)\n\n        self.supportLabel.setText(self.tr(""Support""))\n        self.support_tooltip = self.tr(""Select what kind of supports do you need, if any"")\n        self.supportCombo.clear()\n        self.set_normal_support_settings()\n        self.supportLabel.setToolTip(self.support_tooltip)\n        self.supportCombo.setToolTip(self.support_tooltip)\n\n        self.brim_tooltip = self.tr(""Do you need better adhesive of model and printing bed?"")\n        self.brim_label.setText(self.tr(""Brim""))\n        self.brim_label.setToolTip(self.brim_tooltip)\n        self.brimCheckBox.setToolTip(self.brim_tooltip)\n\n        self.single_material_mode_tooltip = self.tr(""Do you want to print only from one material?"")\n        self.single_material_mode_checkbox.setText(self.tr(""Single material mode""))\n        self.materials_settings_l.setText(self.tr(""Material Settings""))\n        self.extruder1_l.setText(self.tr(""Extruder 1""))\n        self.extruder2_l.setText(self.tr(""Extruder 2""))\n        self.extruder3_l.setText(self.tr(""Extruder 3""))\n        self.extruder4_l.setText(self.tr(""Extruder 4""))\n        self.wipe_tower_tooltip = self.tr(""Amount of material in wipe tower, material clearing"")\n        self.wipe_tower_l.setText(self.tr(""Wipe amount""))\n        self.wipe_tower_c.setToolTip(self.wipe_tower_tooltip)\n        self.wipe_tower_l.setToolTip(self.wipe_tower_tooltip)\n\n        self.used_extruder_tooltip = self.tr(""Extruder is used"")\n\n\n        self.object_group_box.setTitle(self.tr(""Object settings""))\n        self.object_variable_layer_box.setTitle(self.tr(""Object advance settings""))\n        self.gcode_group_box.setTitle(self.tr(""Gcode preview""))\n\n        self.transformation_reset_b.setToolTip(self.tr(""Reset transformations""))\n\n        self.generateButton.setText(self.tr(""Generate""))\n        self.generateButton.setToolTip(self.tr(""Generate scene with actual options to gcode file""))\n\n        self.create_menu()\n\n        self.controller.create_messages()\n\n\n    def set_special_support_settings(self):\n        item_lst = [[self.tr(""None""), self.tr(""None"")],\n                    [self.tr(""Build plate only, soluble""), self.tr(""Build plate only, soluble"")],\n                    [self.tr(""Everywhere, soluble""), self.tr(""Everywhere, soluble"")],\n                    [self.tr(""Build plate only, soluble interface""), self.tr(""Build plate only with soluble interface"")],\n                    [self.tr(""Everywhere, soluble interface""), self.tr(""Everywhere with soluble interface"")]]\n\n        print(""GUI set special support settings"")\n        self.supportCombo.clear()\n        for i in item_lst:\n            self.supportCombo.addItem(i[0], i[1])\n\n\n    def set_normal_support_settings(self):\n        print(""GUI set normal support settings"")\n        self.supportCombo.clear()\n        self.supportCombo.addItems([self.tr(""None""), self.tr(""Build plate only""), self.tr(""Everywhere"")])\n\n    def set_multimaterial_gui_on(self, apply_on_single_mode_switch=False):\n        self.create_menu()\n\n        if apply_on_single_mode_switch:\n            self.single_material_mode_checkbox.setVisible(True)\n            self.single_material_mode_checkbox.setChecked(False)\n\n        self.materials_settings_l.setVisible(True)\n\n\n        self.extruder1_cb.setVisible(True)\n        self.extruder1_l.setVisible(True)\n        self.extruder1_c.setVisible(True)\n        self.extruder2_cb.setVisible(True)\n        self.extruder2_l.setVisible(True)\n        self.extruder2_c.setVisible(True)\n\n        self.extruder3_cb.setVisible(True)\n        self.extruder3_l.setVisible(True)\n        self.extruder3_c.setVisible(True)\n        self.extruder4_cb.setVisible(True)\n        self.extruder4_l.setVisible(True)\n        self.extruder4_c.setVisible(True)\n\n        self.wipe_tower_l.setVisible(True)\n        self.wipe_tower_c.setVisible(True)\n\n        self.object_extruder_l.setVisible(True)\n        self.object_extruder_c.setVisible(True)\n\n        self.materialCombo.setVisible(False)\n        self.materialLabel.setVisible(False)\n\n        self.color_change_l.setVisible(False)\n\n\n\n    def set_multimaterial_gui_off(self, apply_on_single_mode_switch=False):\n        self.create_menu()\n\n        if apply_on_single_mode_switch:\n            self.single_material_mode_checkbox.setVisible(False)\n\n        #self.printing_mm_parameters_layout\n\n        self.materials_settings_l.setVisible(False)\n        self.extruder1_cb.setVisible(False)\n        self.extruder1_l.setVisible(False)\n        self.extruder1_c.setVisible(False)\n\n        self.extruder2_cb.setVisible(False)\n        self.extruder2_l.setVisible(False)\n        self.extruder2_c.setVisible(False)\n\n        self.extruder3_cb.setVisible(False)\n        self.extruder3_l.setVisible(False)\n        self.extruder3_c.setVisible(False)\n\n        self.extruder4_cb.setVisible(False)\n        self.extruder4_l.setVisible(False)\n        self.extruder4_c.setVisible(False)\n\n        self.wipe_tower_l.setVisible(False)\n        self.wipe_tower_c.setVisible(False)\n\n        self.object_extruder_l.setVisible(False)\n        self.object_extruder_c.setVisible(False)\n\n        self.materialCombo.setVisible(True)\n        self.materialLabel.setVisible(True)\n\n        self.color_change_l.setVisible(True)\n\n        self.set_normal_support_settings()\n\n\n    def create_menu(self):\n        self.menubar.clear()\n        # file menu definition\n        self.file_menu = self.menubar.addMenu(self.tr(\'&File\'))\n        self.file_menu.addAction(self.tr(\'Import model file\'), self.controller.open_model_file)\n        self.file_menu.addAction(self.tr(\'Import multipart model file\'), self.controller.open_multipart_model)\n        self.file_menu.addAction(self.tr(\'Import gcode file\'), self.controller.open_gcode_file)\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(self.tr(\'Open project\'), self.controller.open_project_file)\n        self.file_menu.addAction(self.tr(\'Save project\'), self.controller.save_project_file)\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(self.tr(\'Reset\'), self.controller.reset)\n        self.file_menu.addSeparator()\n        self.file_menu.addAction(self.tr(\'Close\'), self.controller.close)\n        # file menu definition\n\n        # edit menu definition\n        self.edit_menu = self.menubar.addMenu(self.tr(\'&Edit\'))\n        self.edit_menu.addAction(self.tr(\'Undo\') + \'\\tCtrl+Z\', self.controller.undo_function)\n        self.edit_menu.addAction(self.tr(\'Redo\') + \'\\tCtrl+Y\', self.controller.do_function)\n        self.edit_menu.addSeparator()\n        self.edit_menu.addAction(self.tr(\'Copy\') +\'\\tCtrl+C\', self.controller.copy_selected_objects)\n        self.edit_menu.addAction(self.tr(\'Paste\') + \'\\tCtrl+V\', self.controller.paste_selected_objects)\n        self.edit_menu.addAction(self.tr(\'Delete\') + \'\\tDel\', self.controller.delete_selected_objects)\n        # self.edit_menu.addSeparator()\n        # self.edit_menu.addAction(self.tr(\'Info\'), self.controller.close)\n        # edit menu definition\n\n        # TODO:Uncoment after new function created/tested\n        # printer menu\n        # self.printer_menu = self.menubar.addMenu(self.tr(\'&Printer\'))\n        # self.printer_menu.addAction(self.tr(\'Printer info\'), self.controller.open_printer_info)\n        # self.printer_menu.addAction(self.tr(\'Update firmware\'), self.controller.open_update_firmware)\n        # printer menu\n\n        # Settings menu\n        self.settings_menu = self.menubar.addMenu(self.tr(\'&Settings\'))\n        self.settings_menu.addAction(self.tr(\'PrusaControl settings\'), self.controller.open_settings)\n        # Settings menu\n\n        # Help menu\n        self.help_menu = self.menubar.addMenu(self.tr(\'&Help\'))\n        self.help_menu.addAction(self.tr(\'Help\'), self.controller.open_help)\n        self.help_menu.addAction(self.tr(\'Prusa Online\'), self.controller.open_shop)\n        self.help_menu.addSeparator()\n        self.help_menu.addAction(self.tr(""Send feedback""), self.controller.send_feedback)\n        self.help_menu.addSeparator()\n        self.help_menu.addAction(self.tr(\'About\'), self.controller.open_about)\n        # Help menu\n\n    def reset_transformation_on_object(self, object_id):\n        self.controller.reset_transformation_on_object(object_id)\n        mesh = self.controller.get_object_by_id(object_id)\n        if mesh.is_wipe_tower:\n            self.update_position_widgets(object_id)\n        else:\n            self.update_position_widgets(object_id)\n            self.update_rotate_widgets(object_id)\n            self.update_scale_widgets(object_id)\n        self.update_scene()\n\n    def show_new_version_message(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""New version""))\n        msgBox.setText(self.tr(""New version is out!""))\n        msgBox.setInformativeText(self.tr(""Do you want to download new version?""))\n        msgBox.setStandardButtons(QMessageBox.Yes |  QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n        msgBox.setDefaultButton(QMessageBox.Yes)\n\n        return msgBox.exec_()\n\n\n    def show_exit_message_scene_not_saved(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Save""))\n        msgBox.setText(self.tr(""Scene is not saved.""))\n        msgBox.setInformativeText(self.tr(""Do you want to save your changes?""))\n        msgBox.setStandardButtons(QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel)\n        msgBox.setDefaultButton(QMessageBox.Save)\n        msgBox.button(msgBox.Save).setText(self.tr(""Save""))\n        msgBox.button(msgBox.Discard).setText(self.tr(""Discard""))\n        msgBox.button(msgBox.Cancel).setText(self.tr(""Cancel""))\n\n\n        return msgBox.exec_()\n\n\n    def show_exit_message_generating_scene(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Exit""))\n        msgBox.setText(self.tr(""GCode is in generating process.""))\n        msgBox.setInformativeText(self.tr(""Do you want to cancel generating of GCode and exit?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_cancel_generating_dialog_and_load_file(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Load file""))\n        msgBox.setText(self.tr(""GCode is in generating process.""))\n        msgBox.setInformativeText(self.tr(""Do you want to cancel generating of GCode and load file?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_ask_multipart_model_dialog(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Load file""))\n        msgBox.setText(self.tr(""List of Stl files""))\n        msgBox.setInformativeText(self.tr(""Do you want to load multiple stl files as one multipart object?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_cancel_generating_dialog_and_load_file(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Load file""))\n        msgBox.setText(self.tr(""GCode file is in loading process.""))\n        msgBox.setInformativeText(self.tr(""Do you want to cancel loading of GCode file and load this file?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_clear_scene_and_load_gcode_file_dialog(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Scene not empty""))\n        msgBox.setText(self.tr(""Some objects are in scene""))\n        msgBox.setInformativeText(self.tr(""Do you want to clear scene and load GCode file?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_open_cancel_gcode_preview_dialog(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""GCode is generated""))\n        msgBox.setText(self.tr(""Scene is generated to GCode""))\n        msgBox.setInformativeText(self.tr(""Do you want to close GCode preview and import new file?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def show_open_new_octoprint_dialog(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""GCode is generated""))\n        msgBox.setText(self.tr(""Scene is generated to GCode""))\n        msgBox.setInformativeText(self.tr(""Do you want to close GCode preview and import new file?""))\n        msgBox.setStandardButtons(QMessageBox.Yes | QMessageBox.No)\n        msgBox.setDefaultButton(QMessageBox.No)\n        msgBox.button(msgBox.Yes).setText(self.tr(""Yes""))\n        msgBox.button(msgBox.No).setText(self.tr(""No""))\n\n        return msgBox.exec_()\n\n    def open_project_asking_dialog(self):\n        msgBox = QMessageBox(self)\n        msgBox.setObjectName(""msgBox"")\n        msgBox.setWindowTitle(self.tr(""Open project file""))\n        msgBox.setText(self.tr(""In scene are some objects""))\n        msgBox.setInformativeText(self.tr(""Do you want to open project file and clear actual scene?""))\n        butt_open = msgBox.addButton(self.tr(""Open""), QMessageBox.YesRole)\n        butt_insert = msgBox.addButton(self.tr(""Insert""), QMessageBox.YesRole)\n        msgBox.addButton(QMessageBox.Cancel)\n        msgBox.setDefaultButton(butt_open)\n        ret = msgBox.exec_()\n\n        if msgBox.clickedButton() == butt_open:\n            return ""Open""\n        elif ret == QMessageBox.Cancel:\n            return False\n        elif msgBox.clickedButton() == butt_insert:\n            return ""Insert""\n\n        return False\n\n\n    def place_on_zero_changed(self):\n        if self.place_on_zero.isChecked():\n            self.edit_pos_z.setDisabled(True)\n            model = self.controller.get_object_by_id(self.object_id)\n            if model.is_multipart_model:\n                model.multipart_parent.place_on_zero()\n            else:\n                model.place_on_zero()\n            self.update_position_widgets(self.object_id)\n            self.update_scene()\n        else:\n            self.edit_pos_z.setDisabled(False)\n\n\n    def eventFilter(self, source, event):\n        if event.type() == QEvent.MouseMove:\n            if event.buttons() == Qt.NoButton and isinstance(source, sceneRender.GLWidget):\n                if self.controller.settings[\'toolButtons\'][\'rotateButton\'] or\\\n                        self.controller.settings[\'toolButtons\'][\'scaleButton\']:\n\n                    self.controller.select_tool_helper(event)\n                    self.update_scene()\n\n        if event.type() == QEvent.MouseButtonPress:\n            if (event.buttons() == Qt.LeftButton or event.buttons() == Qt.RightButton) and self.controller.show_gcode_help():\n                self.controller.set_gcode_help_button_released()\n\n        return QMainWindow.eventFilter(self, source, event)\n\n\n    def closeEvent(self, event):\n        if self.controller.exit_event():\n        #if self.exit_message_continue_exitting():\n            self.settings.setValue(""geometry"", self.saveGeometry())\n            self.settings.setValue(""windowState"", self.saveState())\n            QMainWindow.closeEvent(self, event)\n        else:\n            event.ignore()\n\n\n    def reinit(self):\n        self.set_default()\n        self.update_gui_for_material()\n        self.gcode_slider.init_points()\n\n    def set_progress_bar(self, value):\n        self.progressBar.setValue(value)\n        #self.progressBar.setAlignment(Qt.AlignCenter)\n\n    def set_save_gcode_button(self):\n        self.saveBW.setVisible(True)\n\n        self.generateButton.setVisible(False)\n        self.generateButton.setText(self.tr(""Save G-Code""))\n        self.generateButton.setToolTip(self.tr(""Save generated gcode file""))\n\n    def set_cancel_button(self):\n        self.generateButton.setText(self.tr(""Cancel""))\n        self.generateButton.setToolTip(self.tr(""Cancel of generating gcode file""))\n\n    def set_cancel_saving_gcode_button(self):\n        self.generateButton.setText(self.tr(""Cancel""))\n        self.generateButton.setToolTip(self.tr(""Cancel of saving gcode file""))\n\n    def set_generate_button(self):\n        self.generateButton.setText(self.tr(""Generate""))\n        self.generateButton.setToolTip(self.tr(""Generate scene with actual options to gcode file""))\n\n    def set_cancel_of_loading_gcode_file(self):\n        self.generateButton.setEnabled(True)\n        self.generateButton.setText(self.tr(""Cancel file read""))\n        self.generateButton.setToolTip(self.tr(""Cancel of reading file""))\n\n    def set_print_info_text(self, string):\n        self.printing_filament_data.setText(string)\n\n    def get_changable_widgets(self):\n        return self.changable_widgets\n\n    def get_object_id(self):\n        return self.object_id\n\n    def enable_editing(self):\n        self.single_material_mode_checkbox.setEnabled(True)\n        self.materials_settings_l.setEnabled(True)\n        self.extruder1_l.setEnabled(True)\n        self.extruder1_cb.setEnabled(True)\n        self.extruder1_c.setEnabled(True)\n        self.extruder2_l.setEnabled(True)\n        self.extruder2_cb.setEnabled(True)\n        self.extruder2_c.setEnabled(True)\n        self.extruder3_l.setEnabled(True)\n        self.extruder3_cb.setEnabled(True)\n        self.extruder3_c.setEnabled(True)\n        self.extruder4_l.setEnabled(True)\n        self.extruder4_cb.setEnabled(True)\n        self.extruder4_c.setEnabled(True)\n\n        self.wipe_tower_l.setEnabled(True)\n        self.wipe_tower_c.setEnabled(True)\n\n        self.materialCombo.setEnabled(True)\n        self.qualityCombo.setEnabled(True)\n        self.infillCombo.setEnabled(True)\n        self.supportCombo.setEnabled(True)\n        self.brimCheckBox.setEnabled(True)\n\n        self.printer_settings_l.setEnabled(True)\n        self.materialLabel.setEnabled(True)\n        self.qualityLabel.setEnabled(True)\n        self.infillLabel.setEnabled(True)\n        self.supportLabel.setEnabled(True)\n        self.brim_label.setEnabled(True)\n\n        for a in self.file_menu.actions() + self.edit_menu.actions() + self.settings_menu.actions():\n            a.setEnabled(True)\n\n\n    def disable_editing(self):\n        self.single_material_mode_checkbox.setEnabled(False)\n        self.materials_settings_l.setEnabled(False)\n        self.extruder1_l.setEnabled(False)\n        self.extruder1_cb.setEnabled(False)\n        self.extruder1_c.setEnabled(False)\n        self.extruder2_l.setEnabled(False)\n        self.extruder2_cb.setEnabled(False)\n        self.extruder2_c.setEnabled(False)\n        self.extruder3_l.setEnabled(False)\n        self.extruder3_cb.setEnabled(False)\n        self.extruder3_c.setEnabled(False)\n        self.extruder4_l.setEnabled(False)\n        self.extruder4_cb.setEnabled(False)\n        self.extruder4_c.setEnabled(False)\n\n        self.wipe_tower_l.setEnabled(False)\n        self.wipe_tower_c.setEnabled(False)\n\n        self.materialCombo.setEnabled(False)\n        self.qualityCombo.setEnabled(False)\n        self.infillCombo.setEnabled(False)\n        self.supportCombo.setEnabled(False)\n        self.brimCheckBox.setEnabled(False)\n\n        self.printer_settings_l.setEnabled(False)\n        self.materialLabel.setEnabled(False)\n        self.qualityLabel.setEnabled(False)\n        self.infillLabel.setEnabled(False)\n        self.supportLabel.setEnabled(False)\n        self.brim_label.setEnabled(False)\n\n        for a in self.file_menu.actions() + self.edit_menu.actions() + self.settings_menu.actions():\n            a.setEnabled(False)\n\n\n    def update_position_widgets(self, object_id):\n        mesh_tmp = self.controller.get_object_by_id(object_id)\n        if not mesh_tmp:\n            return\n        if mesh_tmp.is_multipart_model:\n            mesh = mesh_tmp.multipart_parent\n        else:\n            mesh = mesh_tmp\n        self.object_id = object_id\n\n        self.edit_pos_x.setDisabled(True)\n        self.edit_pos_x.setValue(mesh.pos[0] * 10)\n        self.edit_pos_x.setDisabled(False)\n\n        self.edit_pos_y.setDisabled(True)\n        self.edit_pos_y.setValue(mesh.pos[1] * 10)\n        self.edit_pos_y.setDisabled(False)\n\n        self.edit_pos_z.setDisabled(True)\n        self.edit_pos_z.setValue(mesh.pos[2] * 10)\n        if self.place_on_zero.isChecked():\n            self.edit_pos_z.setDisabled(True)\n        else:\n            self.edit_pos_z.setDisabled(False)\n\n\n    def update_rotate_widgets(self, object_id):\n        mesh_tmp = self.controller.get_object_by_id(object_id)\n        if not mesh_tmp:\n            return\n        if mesh_tmp.is_multipart_model:\n            mesh = mesh_tmp.multipart_parent\n        else:\n            mesh = mesh_tmp\n        self.object_id = object_id\n        self.edit_rot_x.setDisabled(True)\n        self.edit_rot_x.setValue(np.rad2deg(mesh.rot[0]))\n        self.edit_rot_x.setDisabled(False)\n\n        self.edit_rot_y.setDisabled(True)\n        self.edit_rot_y.setValue(np.rad2deg(mesh.rot[1]))\n        self.edit_rot_y.setDisabled(False)\n\n        self.edit_rot_z.setDisabled(True)\n        self.edit_rot_z.setValue(np.rad2deg(mesh.rot[2]))\n        self.edit_rot_z.setDisabled(False)\n\n\n    def update_scale_widgets(self, object_id):\n        mesh_tmp = self.controller.get_object_by_id(object_id)\n        if not mesh_tmp:\n            return\n        if mesh_tmp.is_multipart_model:\n            mesh = mesh_tmp.multipart_parent\n        else:\n            mesh = mesh_tmp\n        self.object_id = object_id\n        self.set_scale_widgets(mesh)\n\n\n    def select_model_by_filename(self, filename):\n        mesh_tmp = self.controller.get_object_by_id(self.object_id)\n        if filename == mesh_tmp.filename:\n            return\n\n        if mesh_tmp.is_multipart_model:\n            parent = mesh_tmp.multipart_parent\n            parts_lst = [[m.filename, m.id] for m in parent.models]\n            for model in parts_lst:\n                if filename == model[0]:\n                    self.controller.unselect_objects()\n                    self.controller.select_object(model[1])\n                    #self.set_gui_for_object(model[1])\n\n\n\n    def update_object_settings(self, object_id):\n        if self.is_setting_panel_opened:\n            self.set_gui_for_object(object_id)\n        else:\n            return\n\n    def create_object_settings_menu(self, object_id):\n        if self.is_setting_panel_opened:\n            self.set_gui_for_object(object_id)\n        else:\n            mesh = self.controller.get_object_by_id(object_id)\n            if not mesh:\n                return\n            self.object_group_box.setEnabled(True)\n            self.object_group_box.setHidden(False)\n            self.set_gui_for_object(object_id)\n            self.is_setting_panel_opened = True\n        self.glWidget.setFocusPolicy(Qt.NoFocus)\n\n    def set_gui_for_object(self, object_id, scale_units_perc=True):\n        mesh_tmp = self.controller.get_object_by_id(object_id)\n        extruder_index = 0\n        models_names_lst = []\n\n        if not mesh_tmp:\n            return\n\n        if mesh_tmp.is_multipart_model:\n            mesh = mesh_tmp.multipart_parent\n\n            self.object_settings_layout.addWidget(self.filename_c, 0, 1, 1, 2)\n            self.filename_c.setVisible(True)\n            self.filename_label.setVisible(False)\n\n            mesh_tmp_filename = mesh_tmp.filename\n            models_names_lst = [m.filename for m in mesh.models]\n\n            self.filename_c.blockSignals(True)\n            self.filename_c.clear()\n            self.filename_c.addItems(models_names_lst)\n            self.filename_c.setCurrentIndex(models_names_lst.index(mesh_tmp_filename))\n            self.filename_c.blockSignals(False)\n\n        else:\n            mesh = mesh_tmp\n            self.filename_c.setVisible(False)\n            self.filename_label.setVisible(True)\n            self.object_settings_layout.addWidget(self.filename_label, 0, 1, 1, 2)\n\n        self.object_group_box.setEnabled(True)\n        self.object_id = object_id\n\n        if self.controller.is_multimaterial():\n            extruder_index = mesh_tmp.extruder\n            self.object_extruder_c.setCurrentIndex(extruder_index-1)\n\n        self.filename_label.setText(mesh_tmp.filename)\n        self.filename_label.setToolTip(mesh_tmp.filename)\n\n        self.edit_pos_x.setDisabled(True)\n        self.edit_pos_x.setValue(mesh.pos[0]*10)\n        self.edit_pos_x.setDisabled(False)\n\n        self.edit_pos_y.setDisabled(True)\n        self.edit_pos_y.setValue(mesh.pos[1]*10)\n        self.edit_pos_y.setDisabled(False)\n\n        self.edit_pos_z.setDisabled(True)\n        self.edit_pos_z.setValue(mesh.pos[2]*10)\n        #default is disabled, after unticked of place_on_zero is enabled\n        #self.edit_pos_z.setDisabled(False)\n\n        self.edit_rot_x.setDisabled(True)\n        self.edit_rot_x.setValue(np.rad2deg(mesh.rot[0]))\n        self.edit_rot_x.setDisabled(False)\n\n        self.edit_rot_y.setDisabled(True)\n        self.edit_rot_y.setValue(np.rad2deg(mesh.rot[1]))\n        self.edit_rot_y.setDisabled(False)\n\n        self.edit_rot_z.setDisabled(True)\n        self.edit_rot_z.setValue(np.rad2deg(mesh.rot[2]))\n        self.edit_rot_z.setDisabled(False)\n\n        self.set_scale_widgets(mesh)\n\n        if mesh.is_wipe_tower:\n            self.disable_edit_for_wipe_tower()\n        else:\n            self.enable_edit_for_normal_objects()\n\n        self.variable_layer_widget.setMaximum(mesh.size[2]*10.)\n        self.variable_layer_widget.setMinimum(0.0)\n        self.variable_layer_widget.set_number_of_ticks(10)\n        self.variable_layer_widget.set_model(mesh)\n\n    def disable_edit_for_wipe_tower(self):\n        self.edit_scale_x.setEnabled(False)\n        self.edit_scale_y.setEnabled(False)\n        self.edit_scale_z.setEnabled(False)\n        self.combobox_scale_units.setEnabled(False)\n\n        self.edit_rot_x.setEnabled(False)\n        self.edit_rot_y.setEnabled(False)\n        self.edit_rot_z.setEnabled(False)\n\n        self.object_extruder_c.setEnabled(False)\n        self.place_on_zero.setEnabled(False)\n        self.lock_scale_axes_checkbox.setEnabled(False)\n\n    def enable_edit_for_normal_objects(self):\n        self.edit_scale_x.setEnabled(True)\n        self.edit_scale_y.setEnabled(True)\n        self.edit_scale_z.setEnabled(True)\n        self.combobox_scale_units.setEnabled(True)\n\n        self.edit_rot_x.setEnabled(True)\n        self.edit_rot_y.setEnabled(True)\n        self.edit_rot_z.setEnabled(True)\n\n        self.object_extruder_c.setEnabled(True)\n        self.place_on_zero.setEnabled(True)\n        self.lock_scale_axes_checkbox.setEnabled(True)\n\n\n    def set_scale_widgets(self, mesh):\n        self.edit_scale_x.setDisabled(True)\n        self.edit_scale_y.setDisabled(True)\n        self.edit_scale_z.setDisabled(True)\n\n        if self.scale_units == \'%\':\n            self.edit_scale_x.setSuffix(""%"")\n            self.edit_scale_x.setValue(mesh.scale[0] * 100)\n            self.edit_scale_y.setSuffix(""%"")\n            self.edit_scale_y.setValue(mesh.scale[1] * 100)\n            self.edit_scale_z.setSuffix(""%"")\n            self.edit_scale_z.setValue(mesh.scale[2] * 100)\n        else:\n            self.edit_scale_x.setSuffix(""mm"")\n            self.edit_scale_x.setValue(mesh.scale[0] * mesh.size_origin[0] * 10)\n            self.edit_scale_y.setSuffix(""mm"")\n            self.edit_scale_y.setValue(mesh.scale[1] * mesh.size_origin[1] * 10)\n            self.edit_scale_z.setSuffix(""mm"")\n            self.edit_scale_z.setValue(mesh.scale[2] * mesh.size_origin[2] * 10)\n\n        self.edit_scale_x.setDisabled(False)\n        self.edit_scale_y.setDisabled(False)\n        self.edit_scale_z.setDisabled(False)\n\n\n    def change_scale_units(self):\n        mesh_tmp = self.controller.get_object_by_id(self.object_id)\n        if not mesh_tmp:\n            return\n        if mesh_tmp.is_multipart_model:\n            mesh = mesh_tmp.multipart_parent\n        else:\n            mesh = mesh_tmp\n        self.scale_units = self.combobox_scale_units.currentText()\n        self.set_scale_widgets(mesh)\n\n    def lock_scale_axes_change(self):\n        self.lock_scale_axis = self.lock_scale_axes_checkbox.isChecked()\n        #if self.lock_scale_axis:\n            #self.scale_ration = [1.,.5,.5]\n\n    def clear_object_settings_panel(self):\n        self.filename_label.setText("""")\n\n        self.edit_pos_x.setValue(0.0)\n        self.edit_pos_y.setValue(0.0)\n        self.edit_pos_z.setValue(0.0)\n\n        self.edit_rot_x.setValue(0)\n        self.edit_rot_y.setValue(0)\n        self.edit_rot_z.setValue(0)\n\n        self.edit_scale_x.setValue(100)\n        self.edit_scale_y.setValue(100)\n        self.edit_scale_z.setValue(100)\n\n\n    def close_object_settings_panel(self):\n        self.is_setting_panel_opened = False\n        self.filename_c.setVisible(False)\n        self.filename_label.setVisible(True)\n        self.object_settings_layout.addWidget(self.filename_label, 0, 1, 1, 2)\n\n        self.object_group_box.setDisabled(True)\n        self.clear_object_settings_panel()\n        self.object_id = 0\n        self.glWidget.setFocusPolicy(Qt.StrongFocus)\n\n    def disable_object_settings_panel(self):\n        self.clear_object_settings_panel()\n        self.filename_c.setVisible(False)\n        self.filename_label.setVisible(True)\n        self.object_settings_layout.addWidget(self.filename_label, 0, 1, 1, 2)\n        self.object_group_box.setDisabled(True)\n\n    def set_extruder_on_object(self, widget, object_id):\n        if widget.hasFocus():\n            model = self.controller.get_object_by_id(object_id)\n            if not model:\n                return\n            model.set_extruder(widget.currentIndex()+1)\n            self.controller.show_warning_if_used_materials_are_not_compatible()\n            self.controller.recalculate_wipe_tower()\n            self.controller.actualize_extruder_set()\n\n    def set_position_on_object(self, widget, object_id, x, y, z, place_on_zero):\n        if widget.hasFocus():\n            self.controller.scene_was_changed()\n            model = self.controller.get_object_by_id(object_id)\n            if not model:\n                return\n            model.set_move(np.array([x*.1, y*.1, z*.1]), False, place_on_zero)\n            self.controller.update_scene()\n\n    #@timing\n    def set_rotation_on_object(self, widget, object_id, x, y, z, place_on_zero):\n        if widget.hasFocus():\n            self.controller.scene_was_changed()\n            model = self.controller.get_object_by_id(object_id)\n            if not model:\n                return\n            model.set_rot(np.deg2rad(x), np.deg2rad(y), np.deg2rad(z), False, True, place_on_zero)\n            self.controller.update_wipe_tower()\n            self.controller.update_scene()\n            self.controller.make_analyze()\n\n    def set_scale_on_object(self, widget, active_axis, object_id, x, y, z, place_on_zero):\n        if widget.hasFocus():\n            self.controller.scene_was_changed()\n            model_tmp = self.controller.get_object_by_id(object_id)\n            if not model_tmp:\n                return\n            if model_tmp.is_multipart_model:\n                model = model_tmp.multipart_parent\n            else:\n                model = model_tmp\n\n            if self.scale_units == \'%\':\n                if self.lock_scale_axis:\n\n                    if active_axis==\'x\':\n                        x_recalc = x\n                        x_ration = x/(model.scale[0]*100.)\n\n                        y_recalc = (model.scale[1]*100.) * x_ration\n                        self.edit_scale_y.setDisabled(True)\n                        self.edit_scale_y.setValue(y_recalc)\n                        self.edit_scale_y.setDisabled(False)\n                        z_recalc = (model.scale[2]*100.) * x_ration\n                        self.edit_scale_z.setDisabled(True)\n                        self.edit_scale_z.setValue(z_recalc)\n                        self.edit_scale_z.setDisabled(False)\n                    elif active_axis==\'y\':\n                        y_recalc = y\n                        y_ration = y / (model.scale[1]*100.)\n\n                        x_recalc = (model.scale[0]*100.) * y_ration\n                        self.edit_scale_x.setDisabled(True)\n                        self.edit_scale_x.setValue(x_recalc)\n                        self.edit_scale_x.setDisabled(False)\n                        z_recalc = (model.scale[2]*100.) * y_ration\n                        self.edit_scale_z.setDisabled(True)\n                        self.edit_scale_z.setValue(z_recalc)\n                        self.edit_scale_z.setDisabled(False)\n                    elif active_axis == \'z\':\n                        z_recalc = z\n                        z_ration = z / (model.scale[2]*100.)\n\n                        x_recalc = (model.scale[0]*100.) * z_ration\n                        self.edit_scale_x.setDisabled(True)\n                        self.edit_scale_x.setValue(x_recalc)\n                        self.edit_scale_x.setDisabled(False)\n                        y_recalc = (model.scale[1]*100.) * z_ration\n                        self.edit_scale_y.setDisabled(True)\n                        self.edit_scale_y.setValue(y_recalc)\n                        self.edit_scale_y.setDisabled(False)\n                else:\n                    x_recalc = x\n                    y_recalc = y\n                    z_recalc = z\n\n                model_tmp.set_scale_abs(x_recalc * .01, y_recalc * .01, z_recalc * .01)\n\n            else:\n                #mm\n                if self.lock_scale_axis:\n                    #x = (x/model.size_origin[0])*0.1\n                    #y = (y/model.size_origin[1])*0.1\n                    #z = (z/model.size_origin[2])*0.1\n                    #print(""Vstupni parametry pro mm: %s %s %s"" % (str(x), str(y), str(z)))\n\n                    if active_axis == \'x\':\n                        x_ration = x/model.size_origin[0]\n\n                        self.edit_scale_y.setDisabled(True)\n                        self.edit_scale_y.setValue(model.size_origin[1] * x_ration)\n                        self.edit_scale_y.setDisabled(False)\n                        self.edit_scale_z.setDisabled(True)\n                        self.edit_scale_z.setValue(model.size_origin[2] * x_ration)\n                        self.edit_scale_z.setDisabled(False)\n\n                        x_recalc = x_ration\n                        y_recalc = x_ration\n                        z_recalc = x_ration\n\n                    elif active_axis == \'y\':\n                        y_ration = y / model.size_origin[1]\n\n                        self.edit_scale_x.setDisabled(True)\n                        self.edit_scale_x.setValue(model.size_origin[0] * y_ration)\n                        self.edit_scale_x.setDisabled(False)\n                        self.edit_scale_z.setDisabled(True)\n                        self.edit_scale_z.setValue(model.size_origin[2] * y_ration)\n                        self.edit_scale_z.setDisabled(False)\n\n                        y_recalc = y_ration\n                        x_recalc = y_ration\n                        z_recalc = y_ration\n\n                    elif active_axis == \'z\':\n                        z_ration = z / model.size_origin[2]\n\n                        self.edit_scale_x.setDisabled(True)\n                        self.edit_scale_x.setValue(model.size_origin[0] * z_ration)\n                        self.edit_scale_x.setDisabled(False)\n                        self.edit_scale_y.setDisabled(True)\n                        self.edit_scale_y.setValue(model.size_origin[1] * z_ration)\n                        self.edit_scale_y.setDisabled(False)\n\n                        z_recalc = z_ration\n                        x_recalc = z_ration\n                        y_recalc = z_ration\n\n\n                    x_recalc *= .1\n                    y_recalc *= .1\n                    z_recalc *= .1\n\n                    #print(""Vystupni parametry pro mm: %s %s %s"" % (str(x_recalc), str(y_recalc), str(z_recalc)))\n                    model_tmp.set_scale_abs(x_recalc, y_recalc, z_recalc)\n                else:\n                    model_tmp.set_scale_abs((x/model.size_origin[0])*0.1, (y/model.size_origin[1])*.1, (z/model.size_origin[2])*.1)\n\n\n            #model.update_min_max()\n            self.controller.update_wipe_tower()\n        #self.update_object_settings(self.object_id)\n        self.controller.update_scene()\n\n\n    def create_object_settings_layout(self):\n        object_settings_layout = QGridLayout()\n        object_settings_layout.setRowMinimumHeight(5, 10)\n        object_settings_layout.setRowMinimumHeight(9, 10)\n        object_settings_layout.setRowMinimumHeight(15, 10)\n        object_settings_layout.setVerticalSpacing(2)\n\n\n        object_settings_layout.addWidget(self.name_l, 0, 0)\n        self.name_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.filename_label, 0, 1, 1, 2)\n        self.filename_label.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.filename_c, 0, 2, 1, 1)\n        self.filename_c.setFixedHeight((int)(22*self.controller.dpi_coef))\n\n        self.object_extruder_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        self.object_extruder_c.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.object_extruder_l, 1, 0, 1, 1)\n        object_settings_layout.addWidget(self.object_extruder_c, 1, 1, 1, 2)\n        #1\n        object_settings_layout.addWidget(self.position_l, 2, 0)\n        self.position_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.x_pos_l, 2, 1)\n        self.x_pos_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_pos_x, 2, 2)\n        self.edit_pos_x.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.y_pos_l, 3, 1)\n        self.y_pos_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_pos_y, 3, 2)\n        self.edit_pos_y.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.z_pos_l, 4, 1)\n        self.z_pos_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_pos_z, 4, 2)\n        self.edit_pos_z.setFixedHeight((int)(22*self.controller.dpi_coef))\n        self.edit_pos_z.setDisabled(True)\n        #5\n        object_settings_layout.addWidget(self.rotation_l, 6, 0)\n        self.rotation_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.x_rot_l, 6, 1)\n        self.x_rot_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_rot_x, 6, 2)\n        self.edit_rot_x.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.y_rot_l, 7, 1)\n        self.y_rot_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_rot_y, 7, 2)\n        self.edit_rot_y.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.z_rot_l, 8, 1)\n        self.z_rot_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_rot_z, 8, 2)\n        self.edit_rot_z.setFixedHeight((int)(22*self.controller.dpi_coef))\n        #9\n        object_settings_layout.addWidget(self.scale_l, 10, 0)\n        self.scale_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.x_scale_l, 10, 1)\n        self.x_scale_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_scale_x, 10, 2)\n        self.edit_scale_x.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.y_scale_l, 11, 1)\n        self.y_scale_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_scale_y, 11, 2)\n        self.edit_scale_y.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.z_scale_l, 12, 1)\n        self.z_scale_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.edit_scale_z, 12, 2)\n        self.edit_scale_z.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.lock_scale_axes_checkbox, 10, 1, 3, 1, Qt.AlignRight)\n        self.lock_scale_axes_checkbox.setFixedHeight(51)\n        object_settings_layout.addWidget(self.units_l, 13, 1)\n        self.units_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.combobox_scale_units, 13, 2)\n        self.combobox_scale_units.setFixedHeight((int)(22*self.controller.dpi_coef))\n        #object_settings_layout.addWidget(self.lock_scale_axes_l, 13, 1)\n        #self.lock_scale_axes_l.setFixedHeight(22)\n\n        #14\n        object_settings_layout.addWidget(self.place_on_zero_l, 15, 0, 1, 2)\n        self.place_on_zero_l.setFixedHeight((int)(22*self.controller.dpi_coef))\n        object_settings_layout.addWidget(self.place_on_zero, 15, 2)\n        self.place_on_zero.setFixedHeight((int)(22*self.controller.dpi_coef))\n\n        object_settings_layout.addWidget(self.advance_settings_b, 16, 0, 1, 3)\n\n        return object_settings_layout\n\n    def create_object_advance_settings_layout(self):\n        object_variable_layer_layout = QGridLayout()\n        object_variable_layer_layout.setRowMinimumHeight(0, (int)(350*self.controller.dpi_coef))\n\n        object_variable_layer_layout.addWidget(self.variable_layer_widget, 0, 0, 3, 3)\n        object_variable_layer_layout.addWidget(self.basic_settings_b, 4, 0, 1, 3)\n\n        return object_variable_layer_layout\n\n\n    def create_gcode_view_layout(self):\n\n        gcode_view_layout = QGridLayout()\n        gcode_view_layout.setRowMinimumHeight(3, (int)(350*self.controller.dpi_coef))\n        gcode_view_layout.setRowStretch(1, 0)\n        gcode_view_layout.setRowStretch(2, 0)\n        gcode_view_layout.setRowStretch(3, 2)\n\n        gcode_view_layout.addWidget(self.color_change_l, 1, 0)\n        gcode_view_layout.addWidget(self.gcode_slider, 2, 0, 3, 3)\n        #gcode_view_layout.addWidget(self.gcode_back_b, 4, 0, 1, 3)\n\n        return gcode_view_layout\n\n    def saving_gcode(self):\n        self.set_cancel_saving_gcode_button()\n        self.progressBar.setVisible(True)\n        self.gcode_back_b.setVisible(False)\n\n    def open_gcode_view(self):\n        self.update_actions_in_menu()\n        self.set_save_gcode_button()\n        self.object_group_box.setVisible(False)\n        self.gcode_group_box.setVisible(True)\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            self.gcode_help_b.setVisible(False)\n        else:\n            self.gcode_help_b.setVisible(True)\n\n        self.progressBar.setVisible(False)\n        self.gcode_back_b.setVisible(True)\n        self.controller.view.update_scene()\n        self.gcode_slider.setTickInterval(0)\n\n    #def set_gcode_slider(self, number_of_layers=0, maximal_value=0):\n    #    self.gcode_slider.setTickInterval(0)\n\n    def close_gcode_view(self):\n        self.gcode_group_box.setVisible(False)\n        self.gcode_back_b.setVisible(False)\n        self.saveBW.setVisible(False)\n        self.generateButton.setVisible(True)\n        self.progressBar.setVisible(True)\n        self.object_group_box.setVisible(True)\n        self.progressBar.setValue(0)\n\n        self.controller.view.update_scene()\n\n\n    def open_new_octoprint_dialog(self):\n        data, ok = NewOctoPrintDialog.get_settings_data(self.controller)\n        return data, ok\n\n    def open_settings_dialog(self, editable=True):\n        data, ok = SettingsDialog.get_settings_data(self.controller, editable, self.parent())\n        return data, ok\n\n    def open_printer_info_dialog(self):\n        PrinterInfoDialog.get_printer_info_dialog(self.controller, self.parent())\n\n    def open_about_dialog(self):\n        AboutDialog.get_about_dialog(self.controller, self.parent())\n\n    def open_firmware_dialog(self):\n        data, ok = FirmwareUpdateDialog.get_firmware_update(self.controller, self.parent())\n\n    def disable_generate_button(self):\n        self.generateButton.setDisabled(True)\n\n    def enable_generate_button(self):\n        self.generateButton.setDisabled(False)\n\n    def open_project_file_dialog(self):\n        filters = ""Prusa (*.prusa *.PRUSA)""\n        title = \'Open project file\'\n        open_at = self.settings.value(""project_path"", """")\n        data = QFileDialog.getOpenFileName(None, title, open_at, filters)\n        if data:\n            self.settings.setValue(""project_path"", QFileInfo(data).absolutePath())\n        return data\n\n    def open_gcode_file_dialog(self):\n        filters = ""GCODE (*.gcode *.GCODE *.Gcode)""\n        title = ""Import gcode file""\n        open_at = self.settings.value(""gcode_path"", """")\n        data = QFileDialog.getOpenFileName(None, title, open_at, filters)\n        if data:\n            self.settings.setValue(""gcode_path"", QFileInfo(data).absolutePath())\n        return data\n\n    def open_model_file_dialog(self):\n        filters = ""STL (*.stl *.STL)""\n        title = ""Import model file""\n        open_at = self.settings.value(""model_path"", """")\n        data = QFileDialog.getOpenFileNames(None, title, open_at, filters)\n        if data:\n            self.settings.setValue(""model_path"", QFileInfo(data[0]).absolutePath())\n        filenames_list = []\n        for path in data:\n            filenames_list.append(self.convert_file_path_to_unicode(path))\n        return filenames_list\n\n    def save_project_file_dialog(self):\n        filters = ""Prusa (*.prusa *.PRUSA)""\n        title = \'Save project file\'\n        open_at = self.settings.value(""project_path"", """")\n        data = QFileDialog.getSaveFileName(None, title, open_at, filters)\n        if data:\n            self.settings.setValue(""project_path"", QFileInfo(data).absolutePath())\n        if data == \'\':\n            return data\n\n        return data\n\n    def save_gcode_file_dialog(self, filename = ""sliced_model""):\n        filters = ""gcode (*.gcode *.GCODE)""\n        title = \'Save G-Code file\'\n        open_at = self.settings.value(""gcode_path"", """")\n        filename_list = filename.split(\'/\')\n        open_at += \'/\' + filename_list[-1]\n        data = QFileDialog.getSaveFileName(None, title, open_at, filters)\n        if data:\n            self.settings.setValue(""gcode_path"", QFileInfo(data).absolutePath())\n        return data\n\n    #TODO:Move to controller class\n    def dragEnterEvent(self, event):\n        if event.mimeData().hasUrls():\n            event.acceptProposedAction()\n        else:\n            super(PrusaControlView, self).dragEnterEvent(event)\n\n    def dragMoveEvent(self, event):\n        super(PrusaControlView, self).dragMoveEvent(event)\n\n    def dropEvent(self, event):\n        if event.mimeData().hasUrls():\n            urls = [url.toLocalFile() for url in event.mimeData().urls()]\n            if len(urls) > 1:\n                self.controller.open_files(urls)\n            else:\n                path = urls[0]\n                self.statusBar().showMessage(\'Dropped file name is \' + path)\n                self.controller.open_file(path)\n\n            event.acceptProposedAction()\n        else:\n            super(PrusaControlView, self).dropEvent(event)\n\n    def convert_file_path_to_unicode(self, path):\n        converted_path = path\n        return converted_path\n\n\n    def update_material_settings(self):\n        self.controller.update_mm_material_settings()\n\n\n    def update_gui(self):\n        self.controller.scene_was_changed()\n        self.update_gui_for_material()\n\n    def update_gui_for_material(self, set_materials=0):\n        labels, first = self.controller.get_printer_materials_labels_ls(self.controller.get_actual_printer())\n        #print(""Labels of materials: "" + str(labels))\n        #if self.controller.is_multimaterial():\n\n\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            if set_materials:\n                self.extruder1_c.blockSignals(True)\n                self.extruder1_c.clear()\n                self.extruder2_c.blockSignals(True)\n                self.extruder2_c.clear()\n                self.extruder3_c.blockSignals(True)\n                self.extruder3_c.clear()\n                self.extruder4_c.blockSignals(True)\n                self.extruder4_c.clear()\n\n                self.extruder1_c.addItems(labels)\n                self.extruder2_c.addItems(labels)\n                self.extruder3_c.addItems(labels)\n                self.extruder4_c.addItems(labels)\n\n                self.extruder1_c.setCurrentIndex(first)\n                self.extruder1_c.setMaxVisibleItems((len(labels)))\n                self.extruder2_c.setCurrentIndex(first)\n                self.extruder2_c.setMaxVisibleItems((len(labels)))\n                self.extruder3_c.setCurrentIndex(first)\n                self.extruder3_c.setMaxVisibleItems((len(labels)))\n                self.extruder4_c.setCurrentIndex(first)\n                self.extruder4_c.setMaxVisibleItems((len(labels)))\n\n                self.extruder1_c.blockSignals(False)\n                self.extruder2_c.blockSignals(False)\n                self.extruder3_c.blockSignals(False)\n                self.extruder4_c.blockSignals(False)\n\n            self.wipe_tower_c.blockSignals(True)\n            self.wipe_tower_c.clear()\n            self.wipe_tower_c.addItems(self.get_list_of_wipe_tower_labels())\n            self.wipe_tower_c.setCurrentIndex(1)\n            self.wipe_tower_c.blockSignals(False)\n\n            material_label = self.extruder1_c.currentText()\n\n            material_printing_settings = self.controller.get_printing_settings_for_material_by_label(material_label)\n\n            self.qualityCombo.clear()\n            material_printing_settings_quality_ls, first = self.controller.get_printer_material_quality_labels_ls_by_material_label(material_label)\n            self.qualityCombo.addItems(material_printing_settings_quality_ls)\n            self.qualityCombo.setCurrentIndex(first)\n            self.qualityCombo.setMaxVisibleItems(len(material_printing_settings_quality_ls))\n\n            infill_value = str(material_printing_settings[\'infill\']) + \'%\'\n            infill_list, first_infill = self.controller.get_infill_ls_and_index_of_default(infill_value)\n            self.infillCombo.setCurrentIndex(first_infill)\n\n        else:\n            if set_materials:\n                self.materialCombo.blockSignals(True)\n                self.materialCombo.clear()\n                #labels, first = self.controller.get_printer_materials_labels_ls(self.controller.actual_printer)\n                self.materialCombo.addItems(labels)\n                self.materialCombo.setCurrentIndex(first)\n                self.materialCombo.setMaxVisibleItems((len(labels)))\n                self.materialCombo.blockSignals(False)\n\n            # material_label = self.materialCombo.currentText()\n            material_label = self.materialCombo.currentText()\n\n            material_printing_settings = self.controller.get_printing_settings_for_material_by_label(material_label)\n            #print(str(material_printing_settings))\n\n            # update print quality widget\n            self.qualityCombo.clear()\n            material_printing_settings_quality_ls, first = self.controller.get_printer_material_quality_labels_ls_by_material_label(material_label)\n            #print(""Quality list: "" + str(material_printing_settings_quality_ls))\n            self.qualityCombo.addItems(material_printing_settings_quality_ls)\n            self.qualityCombo.setCurrentIndex(first)\n            self.qualityCombo.setMaxVisibleItems(len(material_printing_settings_quality_ls))\n\n            # infill slider\n            #self.infillSlider.setValue(material_printing_settings[\'infill\'])\n            #self.infillSlider.setMinimum(material_printing_settings[\'infillRange\'][0])\n            #self.infillSlider.setMaximum(material_printing_settings[\'infillRange\'][1])\n\n            #material_printing_settings_infill_ls, first = self.controller.get_printer_material_quality_labels_ls_by_material_label(material_label)\n\n\n            infill_value = str(material_printing_settings[\'infill\'])+\'%\'\n            infill_list, first_infill = self.controller.get_infill_ls_and_index_of_default(infill_value)\n            self.infillCombo.setCurrentIndex(first_infill)\n\n    def get_actual_printing_data(self):\n        material_names = []\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            print(""Multimat"")\n            material_labels = []\n            material_labels.append(self.extruder1_c.currentText())\n            material_labels.append(self.extruder2_c.currentText())\n            material_labels.append(self.extruder3_c.currentText())\n            material_labels.append(self.extruder4_c.currentText())\n\n\n            for mat in material_labels:\n                material_names.append(self.controller.get_material_name_by_material_label(mat))\n        else:\n            print(""Singlemat"")\n            material_label = self.materialCombo.currentText()\n            material_names = [self.controller.get_material_name_by_material_label(material_label)]\n\n        quality_label = self.qualityCombo.currentText()\n        quality_name = self.controller.get_material_quality_name_by_quality_label(material_names[0], quality_label)\n\n        infill_index = self.infillCombo.currentIndex()\n        infill_value_ls = self.controller.get_infill_values_ls()\n        infill_value = infill_value_ls[infill_index]\n        brim = self.brimCheckBox.isChecked()\n        support = self.supportCombo.currentIndex()\n\n        if self.controller.soluble_extruder == -1:\n            support_material_extruder = 0\n            support_material_interface_extruder = 0\n        else:\n            support_material_extruder = self.controller.soluble_extruder\n            support_material_interface_extruder = self.controller.soluble_extruder\n\n        data = {\'material\': material_names,\n                \'quality\': quality_name,\n                \'infill\': infill_value,\n                \'brim\': brim,\n                \'support_on_off\': support,\n                \'support_build_plate\': support,\n                \'overhangs\': support,\n                #for multimaterial special settings(soluble supports)\n                \'support_material_extruder\': [support_material_extruder, support],\n                \'support_material_interface_extruder\' : support_material_interface_extruder\n                }\n        return data\n\n    def get_support_option(self):\n        return self.supportCombo.currentIndex()\n\n    def add_camera_position(self, vec):\n        self.glWidget.camera_target += vec\n\n    def set_x_rotation(self, angle):\n        self.glWidget.set_x_rotation(angle)\n\n    def set_z_rotation(self, angle):\n        self.glWidget.set_z_rotation(angle)\n\n    def get_x_rotation(self):\n        return self.glWidget.xRot\n\n    def get_z_rotation(self):\n        return self.glWidget.zRot\n\n    def get_zoom(self):\n        return self.glWidget.get_zoom()\n\n    def set_zoom(self, diff):\n        self.glWidget.set_zoom(diff)\n\n    def get_cursor_position(self, event):\n        return self.glWidget.get_cursor_position(event)\n\n    def get_cursor_pixel_color(self, event):\n        return self.glWidget.get_cursor_pixel_color(event)\n\n    def get_camera_direction(self, event):\n        return self.glWidget.get_camera_direction(event)\n\n    def get_tool_buttons(self):\n        return self.glWidget.tools\n\n    def update_scene(self, reset=False):\n        self.glWidget.update_scene(reset)\n\n    def set_gcode_slider(self, val):\n        self.controller.set_gcode_layer(val)\n        self.gcode_label.setText(self.controller.gcode.data_keys[val])\n\n    def set_variable_layer_slider(self, val):\n        self.controller.set_variable_layer_cursor(self.variable_layer_widget.double_value)\n\n\n    def set_infill(self, val):\n        self.infillValue = val\n        infill_value_str = ""%2d"" % val\n        self.infillLabel.setText(self.tr(""Infill"") + "" "" + infill_value_str + ""%"")\n\n    def create_slider(self, setterSlot, defaultValue=0, rangeMin=0, rangeMax=100, orientation=Qt.Horizontal, base_class=QSlider):\n        if base_class == Gcode_slider:\n            slider = base_class(orientation, self.controller)\n        else:\n            slider = base_class(orientation)\n\n        slider.setRange(rangeMin, rangeMax)\n        slider.setSingleStep(1)\n        slider.setPageStep(1)\n        slider.setTickInterval(1)\n        slider.setValue(defaultValue)\n        slider.setTickPosition(QSlider.TicksRight)\n\n        if base_class == Gcode_slider:\n            #self.connect(slider.slider, SIGNAL(""valueChanged(int)""), setterSlot)\n            slider.slider.valueChanged.connect(setterSlot)\n        else:\n            #self.connect(slider, SIGNAL(""valueChanged(int)""), setterSlot)\n            slider.valueChanged.connect(setterSlot)\n        return slider\n'"
init.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n__author__ = \'Tibor Vavra\'\n\nimport vcversioner\n\nversion = vcversioner.find_version(root=\'.\', version_file=\'%(root)s/data/v.txt\').version\nversion_lst = version.split(\'.\')\nmajor_version = int(version_lst[0])\nminor_version = int(version_lst[1])\nbugfix_version = int(version_lst[2])\nbuild_version = int(version_lst[3][4:])\n\n#print(""Splitted: "" + str(major_version) + \' \' + str(minor_version) + \' \' + str(bugfix_version) + \' \' + str(build_version))\n\nversion_string_uni = u\'%i, %i, %i, %i\' % (major_version, minor_version, bugfix_version, build_version)\nversion_string = ""(%i, %i, %i, %i)"" % (major_version, minor_version, bugfix_version, build_version)\nprint(version_string)\n\n\nwith open(""version.txt"", ""w"") as version_file:\n    version_file.write(""VSVersionInfo(\\n"")\n    version_file.write(""  ffi=FixedFileInfo(\\n"")\n    version_file.write(""    filevers=""+ version_string+\',\\n\')\n    version_file.write(""    prodvers=""+ version_string+\',\\n\')\n    version_file.write(""    mask=0x3f,\\n"")\n    version_file.write(""    flags=0x0,\\n"")\n    version_file.write(""    OS=0x4,\\n"")\n    version_file.write(""    fileType=0x1,\\n"")\n    version_file.write(""    subtype=0x0,\\n"")\n    version_file.write(""    date=(0, 0)\\n"")\n    version_file.write(""    ),\\n"")\n    version_file.write(""  kids=[\\n"")\n    version_file.write(""    StringFileInfo(\\n"")\n    version_file.write(""      [\\n"")\n    version_file.write(""      StringTable(\\n"")\n    version_file.write(""        u\'040904b0\',\\n"")\n    version_file.write(""        [StringStruct(u\'CompanyName\', u\'Prusa Research, s.r.o.\'),\\n"")\n    version_file.write(""        StringStruct(u\'ProductName\', u\'PrusaControl\'),\\n"")\n    version_file.write(""        StringStruct(u\'ProductVersion\', u\'""+version_string_uni+""\'),\\n"")\n    version_file.write(""        StringStruct(u\'InternalName\', u\'PrusaControl\'),\\n"")\n    version_file.write(""        StringStruct(u\'OriginalFilename\', u\'PrusaControl.exe\'),\\n"")\n    version_file.write(""        StringStruct(u\'FileVersion\', u\'""+version_string_uni+""\'),\\n"")\n    version_file.write(""        StringStruct(u\'FileDescription\', u\'PrusaControl\'),\\n"")\n    version_file.write(""        StringStruct(u\'LegalCopyright\', u\'Copyright 2017 Prusa Research s.r.o.\'),\\n"")\n    version_file.write(""        StringStruct(u\'LegalTrademarks\', u\'\'),])\\n"")\n    version_file.write(""      ]),\\n"")\n    version_file.write(""    VarFileInfo([VarStruct(u\'Translation\', [1033, 1200])])\\n"")\n    version_file.write(""  ]\\n"")\n    version_file.write("")\\n"")\n\n\n\n\n\n\n'"
main.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport atexit\n#import inspect\n#from msilib.schema import File\n\n#from PyQt4.QtGui import QApplication, QIcon\n#from PyQt4.QtCore import QCoreApplication\n\nfrom controller import Controller\nfrom parameters import AppParameters\nfrom sceneRender import *\n#from sceneData import *\nimport logging\nimport cProfile\nimport os\nimport platform\n#import shutil\n\n\n__author__ = \'Tibor Vavra\'\n\nDEBUG = False\n\nclass EventLoopRunner(QObject):\n    finished = pyqtSignal()\n\n    def __init__(self, app, base_path=""""):\n        super(EventLoopRunner, self).__init__()\n        self.base_path = base_path\n        self.app = app\n        self.version = """"\n        self.system_platform = platform.system()\n        self.progressbar_on = 0\n\n\n        with __builtins__.open(self.base_path + ""data/v.txt"", \'r\') as version_file:\n            self.version_full = version_file.read()\n            self.version = AppParameters.strip_version_string(self.version_full)\n\n\n        self.is_running = True\n        self.css = []\n        self.splash_pix = []\n        self.splash = []\n        self.progressBar = []\n        self.version_label = []\n\n        self.initializeGUI()\n\n    def initializeGUI(self):\n\n        self.css = QFile(self.base_path + \'data/my_stylesheet.qss\')\n        self.css.open(QIODevice.ReadOnly)\n\n\n        if self.system_platform in [""Darwin""]:\n            self.splash_pix = QPixmap(self.base_path + \'data/img/splashscreen_osx.png\')    \n            self.progressbar_on = 0\n        else:\n            self.splash_pix = QPixmap(self.base_path + \'data/img/splashscreen.png\')\n            self.progressbar_on = 1\n        self.splash = QSplashScreen(self.splash_pix, Qt.SplashScreen | Qt.WindowStaysOnTopHint)\n\n        if self.progressbar_on:\n            self.progressBar = QProgressBar(self.splash)\n            self.progressBar.setStyleSheet(str(self.css.readAll(), ""utf-8""))\n            self.progressBar.setObjectName(""splash_progressbar"")\n            self.progressBar.setFormat("""")\n            self.progressBar.setFixedWidth(209)\n            self.progressBar.setFixedHeight(6)\n            self.progressBar.move(245, 453)\n\n        self.version_label = QLabel(self.version, self.splash)\n        self.version_label.setObjectName(""version_label"")\n        self.version_label.move(620, 647)\n        self.version_label.setFixedWidth(100)\n\n        self.splash.show()\n\n        self.set_progress(0)\n\n    def process_event_loop(self):\n        while self.is_running == True:\n            self.app.processEvents()\n\n    def set_progress(self, value):\n        if self.progressbar_on:\n            self.progressBar.setValue(value)\n\n\n\ndef log_exception(excType, excValue, traceback):\n    logging.error(""Logging an uncaught exception"",\n                 exc_info=(excType, excValue, traceback))\n\n    sys.__excepthook__(excType, excValue, traceback)\n\n\n\ndef main():\n    QCoreApplication.setAttribute(QtCore.Qt.AA_X11InitThreads, True)\n    if getattr(sys, \'frozen\', False):\n        # it is freeze app\n        base_dir = sys._MEIPASS\n    else:\n        # we are running in a normal Python environment\n        base_dir = os.path.dirname(os.path.abspath(__file__))\n\n    system_platform = platform.system()\n    if system_platform in [\'Windows\']:\n        base_dir+=\'\\\\\'\n    else:\n        base_dir+=\'/\'\n\n    sys.excepthook = log_exception\n    app = QApplication(sys.argv)\n\n    event_loop_runner = EventLoopRunner(app, base_dir)\n    event_loop_runner_thread = QThread()\n    event_loop_runner.moveToThread(event_loop_runner_thread)\n    event_loop_runner_thread.started.connect(event_loop_runner.process_event_loop)\n\n    progressBar = event_loop_runner.set_progress\n\n    event_loop_runner_thread.start()\n\n     \n    app.setApplicationName(""PrusaControl"")\n    app.setOrganizationName(""Prusa Research"")\n    app.setOrganizationDomain(""prusa3d.com"")\n\n    dpi = app.desktop().logicalDpiX()\n\n    app.setWindowIcon(QIcon(base_dir + ""data/icon/favicon.ico""))\n    if dpi == 96:\n        file = QFile(base_dir + ""data/my_stylesheet.qss"")\n    #elif dpi == 72:\n    #    file = QFile(base_dir + ""data/my_stylesheet.qss"")\n    else:\n        file = QFile(base_dir + ""data/my_stylesheet_without_f.qss"")\n    file.open(QFile.ReadOnly)\n    \n    StyleSheet_tmp = str(file.readAll(), \'utf-8\')\n    if system_platform in [\'Windows\']:\n        StyleSheet = StyleSheet_tmp.replace(\'base_dir\', """")\n    else:\n        StyleSheet = StyleSheet_tmp.replace(\'base_dir\', base_dir)\n\n    if not system_platform in [\'Windows\', \'Linux\']:\n        app.setStyle(QStyleFactory.create(""Windows""))\n        \n    app.setStyleSheet(StyleSheet)    \n\n\n\n    #local_path = os.path.realpath(__file__)\n\n    controller = Controller(app, base_dir, progressBar)\n    progressBar(100)\n    window = controller.get_view()\n\n    event_loop_runner.is_running = False\n    event_loop_runner_thread.quit()\n    event_loop_runner_thread.wait()\n    event_loop_runner.splash.finish(window)\n\n    controller.check_version()\n    app.installEventFilter(window)\n    app.exec_()\n    atexit.register(controller.write_config)\n\n\n\nif __name__ == \'__main__\':\n    system_platform = platform.system()\n    log_path = ""/""\n    if system_platform in [\'Windows\']:\n        log_path = ""\\\\""\n    else:\n        log_path = ""/""\n    FORMAT = ""[%(levelname)s][%(filename)s:%(lineno)s:%(funcName)s()]-%(message)s""\n\n    if DEBUG:\n        logging.basicConfig(filename=os.path.expanduser(""~"" + log_path + ""prusacontrol.log""), format=FORMAT, filemode=\'w\', level=logging.DEBUG)\n        #cProfile.runctx(\'main()\', globals(), locals(), \'prusacontrol.profile\')\n    else:\n        logging.basicConfig(filename=os.path.expanduser(""~"" + log_path + ""prusacontrol.log""), format=FORMAT, filemode=\'w\', level=logging.WARNING)\n\n    if DEBUG:\n        cProfile.runctx(\'main()\', globals(), locals(), \'prusacontrol.profile\')\n    else:\n        main()\n'"
parameters.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport json\nimport logging\nimport os\nimport platform\nimport shutil\nimport tempfile\nimport sys\n\n#from urllib.request import Request, urlopen\n#from urllib.error import URLError, HTTPError\nimport certifi\nimport urllib3\n\nfrom configparser import ConfigParser, RawConfigParser, MissingSectionHeaderError\nfrom copy import deepcopy\nfrom pprint import pprint\n\nimport errno\nfrom shutil import copyfile, Error\n\nimport time\n\n__author__ = \'Tibor Vavra\'\n\n\n#Mesure\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print(\'%s function took %0.3f ms\' % (f.func_name, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\n\nclass PrintingParameters(object):\n    def __init__(self, app_config, controller= None):\n        self.application_parameters = app_config\n        self.controller = controller\n\n        self.all_printers_parameters = {}\n        self.all_materials_quality_parameters = {}\n\n        self.printers_parameters = {}\n        self.materials_quality_parameters = {}\n\n        #read printers json file\n        #print(self.application_parameters.printers_parameters_file)\n        self.all_printers_parameters = self.read_printers_parameters(self.application_parameters.printers_parameters_file)[\'printers\']\n\n        #apply default printer type settings\n        #print(""Printer type before:"")\n        #pprint(self.all_printers_parameters[\'default\'][\'printer_type\'])\n        out = dict(self.apply_default_parameters(self.all_printers_parameters[\'default\'][\'printer_type\']))\n        self.all_printers_parameters[\'default\'][\'printer_type\'] = out\n        #apply default printer settings\n        self.printers_parameters = self.apply_default_parameters(self.all_printers_parameters)\n\n        #read all material configuration files for every printer\n        for printer in self.get_printers_names():\n            self.all_materials_quality_parameters[printer] = self.read_material_quality_parameters_for_printer(\n                                                        self.application_parameters.user_folder + self.printers_parameters[printer][\'material_parameters_file\'])[\'materials\']\n        #apply default materials and default quality\n        for printer in self.all_materials_quality_parameters:\n            self.materials_quality_parameters[printer] = self.apply_default_material_parameters(\n                                                        self.all_materials_quality_parameters[printer])\n\n            #apply default material quality on other quality\n            for material in self.materials_quality_parameters[printer]:\n                self.materials_quality_parameters[printer][material][""quality""] = self.apply_default_quality_parameters(\n                                                    self.materials_quality_parameters[printer][material][""quality""])\n\n            #print(""Material list without defaults quality: "")\n            #pprint(self.materials_quality_parameters[printer])\n\n            #merge printers dict with materials dict to one super list with all parameters\n            self.printers_parameters[printer][\'materials\'] = self.materials_quality_parameters[printer]\n\n            #print(""Material list without default: "")\n            #pprint(self.materials_quality_parameters[printer])\n\n\n    def get_printers_names(self, only_visible=False):\n        printers = self.printers_parameters\n        if only_visible and \'visible\' in printers[list(printers.keys())[0]]:\n            unsorted =  [[printer, printers[printer][\'sort\']] for printer in printers if printers[printer][\'visible\'] == 1]\n            sort_list = sorted(unsorted, key=lambda mem: mem[1])\n            return [a[0] for a in sort_list]\n        else:\n            unsorted = [[printer, printers[printer][\'sort\']] for printer in printers]\n            sort_list = sorted(unsorted, key=lambda mem: mem[1])\n            return [a[0] for a in sort_list]\n\n    def get_printers_parameters(self):\n        return self.printers_parameters\n\n    def get_printer_parameters(self, printer_name):\n        if printer_name in self.printers_parameters.keys():\n            return self.printers_parameters[printer_name]\n        else:\n            return None\n\n    def get_materials_for_printer(self, printer_name):\n        if printer_name in self.materials_quality_parameters.keys():\n            return self.materials_quality_parameters[printer_name]\n        else:\n            return []\n\n    def get_materials_quality_for_printer(self, printer_name, material):\n        if printer_name in self.printers_parameters and material in self.printers_parameters[printer_name][""materials""]:\n            return self.printers_parameters[printer_name][""materials""][material]\n        else:\n            return []\n\n    def apply_default_material_parameters(self, dict_with_default):\n        return_dict = {}\n        for i in dict_with_default:\n            if i == u\'default\':\n                continue\n            return_dict[i] = deepcopy(dict_with_default[u\'default\'])\n            return_dict[i].update(dict_with_default[i])\n\n            if u\'quality\' in dict_with_default[i]:\n                return_dict[i][u\'quality\'] = deepcopy(dict_with_default[u\'default\'][u\'quality\'])\n                return_dict[i][u\'quality\'].update(deepcopy(dict_with_default[i][u\'quality\']))\n                if u\'parameters\' in return_dict[i][u\'quality\'][u\'default\']:\n                    return_dict[i][u\'quality\'][u\'default\'][u\'parameters\'] = deepcopy(dict_with_default[u\'default\'][u\'quality\'][u\'default\'][u\'parameters\'])\n                    return_dict[i][u\'quality\'][u\'default\'][u\'parameters\'].update(deepcopy(dict_with_default[i][u\'quality\'][u\'default\'][u\'parameters\']))\n\n        return return_dict\n\n\n    def apply_default_quality_parameters(self, dict_with_default):\n        return_dict = {}\n        for i in dict_with_default:\n            if i == u\'default\':\n                continue\n            return_dict[i] = deepcopy(dict_with_default[u\'default\'])\n            return_dict[i].update(dict_with_default[i])\n\n            if u\'parameters\' in return_dict[i]:\n                return_dict[i][u\'parameters\'] = deepcopy(dict_with_default[u\'default\'][u\'parameters\'])\n                return_dict[i][u\'parameters\'].update(deepcopy(dict_with_default[i][u\'parameters\']))\n\n        return return_dict\n\n    def apply_default_parameters(self, dict_with_default):\n        return_dict = {}\n        for i in dict_with_default:\n            updating_dict = {}\n            if i == u\'default\':\n                continue\n            if \'parameters\' in dict_with_default[i]:\n                return_dict[i] = deepcopy(dict_with_default[u\'default\'])\n                updating_dict = deepcopy(dict_with_default[i])\n                del updating_dict[\'parameters\']\n                return_dict[i].update(updating_dict)\n                return_dict[i][\'parameters\'].update(deepcopy(dict_with_default[i][\'parameters\']))\n            else:\n                return_dict[i] = deepcopy(dict_with_default[u\'default\'])\n                return_dict[i].update(deepcopy(dict_with_default[i]))\n\n        return return_dict\n\n\n    def get_actual_settings_for_one_material(self, printer_name, printer_variation, material_name, quality_seting):\n        if not printer_name or not printer_variation or not material_name or not quality_seting:\n            return None\n        else:\n            if printer_name in self.printers_parameters:\n                if printer_variation in self.printers_parameters[printer_name][""printer_type""]:\n                    if material_name in self.printers_parameters[printer_name][""materials""]:\n                        if quality_seting in self.printers_parameters[printer_name][""materials""][material_name][\'quality\']:\n                            material_quality_pl = deepcopy(self.printers_parameters[printer_name][""materials""][material_name][\'quality\'][quality_seting][""parameters""])\n                            final_pl = deepcopy(self.printers_parameters[printer_name][""parameters""])\n                            printer_variation_pl = deepcopy(self.printers_parameters[printer_name][""printer_type""][printer_variation][\'parameters\'])\n                            final_pl.update(material_quality_pl)\n                            final_pl.update(printer_variation_pl)\n                            return final_pl\n                        else:\n                            return None\n                    else:\n                        return None\n                else:\n                    return None\n            else:\n                return None\n        return None\n\n    def get_actual_settings(self, printer_name, printer_variation, material_names, quality_settings, slicer):\n        if len(material_names) > 1:\n            #print(""Multi material version"")\n            # multimaterial version\n            settings_lst = []\n            for mat in material_names:\n                settings_lst.append(self.get_actual_settings_for_one_material(printer_name, printer_variation, mat, quality_settings))\n\n            multimaterial_settings =  self.connect_different_settings(slicer.multimaterial_spec_parameters, settings_lst)\n            #print(""Material settings:"")\n            #pprint(multimaterial_settings)\n\n            if self.controller:\n                if self.controller.soluble_extruder > -1:\n                    # detect if soluble material is used\n                    # if yes use it for update multimaterial_settings\n                    #soluble_material_settings = self.controller.get_printing_settings_for_material_in_extruder(self.controller.soluble_extruder)\n                    soluble_material_settings = self.get_actual_settings_for_one_material(printer_name, printer_variation, material_names[self.controller.soluble_extruder-1], quality_settings)\n                    #print(""Soluble material settings:"")\n                    #pprint(soluble_material_settings)\n\n                    #soluble_material_settings_shorted = {key:soluble_material_settings[key] for key in slicer.support_parameters if key in soluble_material_settings}\n                    soluble_material_settings_shorted = {key:soluble_material_settings[key] for key in slicer.support_parameters}\n                    multimaterial_settings_change = deepcopy(multimaterial_settings)\n                    multimaterial_settings_change.update(soluble_material_settings_shorted)\n                    return multimaterial_settings_change\n                else:\n                    #normal materials\n                    return multimaterial_settings\n\n            return multimaterial_settings\n        else:\n            #print(""Single material version"")\n            #print(""Printing settings: %s %s %s %s"" % (str(printer_name), str(printer_variation), str(material_names[0]), str(quality_settings)))\n            # one material version\n            return self.get_actual_settings_for_one_material(printer_name, printer_variation, material_names[0], quality_settings)\n\n\n    def connect_different_settings(self, keys_lst, lst):\n        out = dict()\n\n        for mat in lst:\n            out.update(mat)\n\n        for key in keys_lst:\n            out[key] = [mat[key] for mat in lst if key in mat]\n\n        return out\n\n\n    def read_printers_parameters(self, filename):\n        printers = {}\n        with open(filename, \'rb\') as json_file:\n            printers = json.loads(json_file.read().decode(\'utf8\'))\n        return printers\n\n\n\n    def read_material_quality_parameters_for_printer(self, printer_config_file):\n        if not printer_config_file:\n            return None\n\n        material_config = []\n        with open(printer_config_file, \'r\') as json_file:\n            text = json_file.read()\n            material_config = json.loads(text)\n\n        return material_config\n\n\n\n\nclass AppParameters(object):\n    def __init__(self, controller=None, local_path=\'\'):\n        self.http = urllib3.PoolManager(cert_reqs=\'CERT_REQUIRED\', ca_certs=certifi.where())\n\n        self.local_path = local_path\n        self.controller = controller\n        self.system_platform = platform.system()\n\n        self.is_version_actual = True\n\n        self.config = ConfigParser()\n\n        # read from v.txt\n        with open(self.local_path + ""data/v.txt"", \'r\') as version_file:\n            self.version_full = version_file.read()\n            self.version = self.strip_version_string(self.version_full)\n\n        self.json_settings_url = ""https://raw.githubusercontent.com/prusa3d/PrusaControl-settings/master/""\n        #self.json_settings_url = ""https://raw.githubusercontent.com/tibor-vavra/PrusaControl-settings/master/""\n\n        self.printers_filename = ""printers.json""\n\n        self.prusacontrol_url = ""http://www.prusacontrol.org/""\n        self.prusacontrol_version_file = ""version.info""\n\n        self.prusacontrol_webpage = ""http://www.prusacontrol.org/""\n        self.prusacontrol_update_page = ""http://www.prusacontrol.org/update""\n\n        self.prusacontrol_questionnaire_cz = ""https://goo.gl/forms/5rJPSUMrZJIcBsL12""\n        self.prusacontrol_questionnaire_en = ""https://goo.gl/forms/R7rRNPgiIq87WA4R2""\n\n        self.prusacontrol_help_page = ""http://www.prusa3d.com""\n        self.prusa_eshop_page = ""http://shop.prusa3d.com""\n\n\n\n        if self.system_platform in [\'Linux\']:\n            self.tmp_place = tempfile.gettempdir() + \'/\'\n            self.data_folder = ""data/""\n            self.config_path = os.path.expanduser(""~/.prusacontrol/prusacontrol.cfg"")\n            self.user_folder = os.path.expanduser(""~/.prusacontrol/data/"")\n            self.default_printers_parameters_file = os.path.expanduser(self.data_folder + self.printers_filename)\n            self.printers_parameters_file = self.user_folder + self.printers_filename\n            self.config.readfp(open(\'data/defaults.cfg\'))\n        elif self.system_platform in [\'Darwin\']:\n            self.data_folder = self.local_path + ""data/""\n            self.tmp_place = tempfile.gettempdir() + \'/\'\n            self.config_path = os.path.expanduser(""~/Library/Application Support/PrusaControl/PrusaControl.cfg"")\n            self.user_folder = os.path.expanduser(""~/Library/Application Support/PrusaControl/data/"")\n            self.default_printers_parameters_file = os.path.expanduser(self.data_folder + self.printers_filename)\n            self.printers_parameters_file = self.user_folder + self.printers_filename\n            self.config.readfp(open(self.local_path + \'data/defaults.cfg\'))\n        elif self.system_platform in [\'Windows\']:\n            self.data_folder = ""data\\\\""\n            self.tmp_place = tempfile.gettempdir() + ""\\\\""\n\n            self.config_path = os.path.expanduser(""~\\\\prusacontrol.cfg"")\n            self.user_folder = os.path.expanduser(""~\\\\.prusacontrol\\\\"")\n            #self.user_folder = self.tmp_place.split(""\\\\appdata"")[0] + ""\\\\.prusacontrol\\\\""\n\n            self.default_printers_parameters_file = os.path.expanduser(self.data_folder + self.printers_filename)\n            self.printers_parameters_file = self.user_folder + self.printers_filename\n            self.config.readfp(open(\'data\\\\defaults.cfg\'))\n            #print(""Executable: "" + sys.executable)\n        else:\n            self.data_folder = self.local_path + ""data/""\n            self.tmp_place = \'./\'\n            self.config_path = \'prusacontrol.cfg\'\n            self.user_folder = os.path.expanduser(""~/.prusacontrol/"")\n            self.default_printers_parameters_file = os.path.expanduser(self.data_folder + self.printers_filename)\n            self.printers_parameters_file = self.user_folder + self.printers_filename\n            self.config.readfp(open(self.local_path + \'data/defaults.cfg\'))\n\n        #print(self.user_folder)\n        #print(self.tmp_place)\n        #print(self.default_printers_parameters_file)\n        #print(self.printers_parameters_file)\n        #print(self.config_path)\n\n\n        try:\n            self.config.read(self.config_path)\n        except MissingSectionHeaderError:\n            logging.error(""Config file is corrupted, using default one!"")\n\n\n        self.first_run()\n\n        is_internet_on = self.internet_on()\n\n        if is_internet_on:\n            self.check_new_version_of_prusacontrol()\n\n        # Check connections and update flag\n        if is_internet_on and self.config.getboolean(\'settings\', \'automatic_update_parameters\'):\n            if self.download_new_settings_files():\n                self.check_versions()\n\n\n\n\n    @staticmethod\n    def strip_version_string(string_in):\n        try:\n            if type(string_in) is str:\n                string_out = string_in\n            else:\n                string_out = str(string_in, ""utf8"")\n            string_out = string_out.split(\'-\')\n            string_out = string_out[:2]\n            string_out = ""{}_{}"".format(string_out[0], string_out[1])[1:]\n        except IndexError as e:\n            string_out = ""0.0.1""\n\n        return string_out\n\n    def internet_on(self):\n        try:\n            r = self.http.request(\'GET\', \'https://google.com\')\n            if r.status == 200:\n                return True\n            else:\n                return False\n        except urllib3.exceptions.NewConnectionError:\n            logging.warning(\'Connection failed.\')\n            return False\n        except urllib3.exceptions.MaxRetryError:\n            logging.warning(\'Connection failed.\')\n            return False\n\n\n    def first_run(self):\n        #check is there settings files in user folders\n        printer_file_config = self.user_folder + self.printers_filename\n        # if yes no first run\n        if os.path.exists(printer_file_config):\n            #print(""printers.json is existing "")\n            old_printers_res = self.get_printers_info(printer_file_config)\n            default_printers_res = self.get_printers_info(self.data_folder + self.printers_filename)\n            if old_printers_res and default_printers_res:\n                old_version, _ = old_printers_res\n                default_version, _ = default_printers_res\n                if default_version > old_version:\n                    self.use_default_files()\n                else:\n                    return\n            else:\n                return\n        # else copy from data folder to user folder\n        else:\n            #print(""printers.json is not existing, first run "")\n            try:\n                os.makedirs(self.user_folder)\n            except OSError as exception:\n                if exception.errno != errno.EEXIST:\n                    raise\n            try:\n                copyfile(self.data_folder + self.printers_filename, self.user_folder + self.printers_filename)\n            except Error as e:\n                logging.debug(\'Error: %s\' % e)\n            except IOError as e:\n                logging.debug(\'Error: %s\' % e.strerror)\n\n            printers_data = json.load(open(self.user_folder + self.printers_filename, \'r\'))\n            materials_files_list = [printers_data[\'printers\'][i][\'material_parameters_file\'] for i in\n                                    printers_data[\'printers\'] if i not in [\'default\']]\n\n            for i in materials_files_list:\n                try:\n                    copyfile(self.data_folder + i, self.user_folder + i)\n                except Error as e:\n                    logging.debug(\'Error: %s\' % e)\n                except IOError as e:\n                    logging.debug(\'Error: %s\' % e.strerror)\n\n\n    #@timing\n    def download_new_settings_files(self):\n        printers_data = {}\n        #req = Request(self.json_settings_url + self.printers_filename)\n        try:\n            r = self.http.request(\'GET\', self.json_settings_url + self.printers_filename)\n\n        except urllib3.exceptions.NewConnectionError as e:\n            logging.error(""prusacontrol-settings repository is not reachable"")\n            print(\'Error code: \', e.code)\n            return False\n        except urllib3.exceptions.HTTPError as e:\n            print(\'We failed to reach a server.\')\n            print(\'Reason: \', e.reason)\n            return False\n        else:\n\n            with open(self.tmp_place+self.printers_filename, \'wb\') as out_file:\n                #shutil.copyfileobj(r, out_file)\n                out_file.write(r.data)\n\n            with open(self.tmp_place+self.printers_filename, \'r\') as in_file:\n                printers_data = json.load(in_file)\n                materials_files_list = [printers_data[\'printers\'][i][\'material_parameters_file\'] for i in\n                                    printers_data[\'printers\'] if i not in [\'default\']]\n\n            if materials_files_list == []:\n                logging.error(""No internet connection or different network problem"")\n                return\n\n            for i in materials_files_list:\n                r_mat = self.http.request(\'GET\', self.json_settings_url + i)\n                with open(self.tmp_place+i, \'wb\') as out_file:\n                    out_file.write(r_mat.data)\n        return True\n\n    def check_versions(self):\n        old = self.user_folder + self.printers_filename\n        new = self.tmp_place + self.printers_filename\n        #print(old)\n        #print(new)\n        #out = self.get_actual_version(old, new)\n\n        res_old = self.get_printers_info(old)\n        if res_old:\n            old_version, old_material_list = res_old\n        else:\n            return\n\n        res_new = self.get_printers_info(new)\n        if res_new:\n            new_version, new_material_list = res_new\n        else:\n            return\n\n        if new_version > old_version:\n            #print(""nova verze printers-kopiruji"")\n            copyfile(new, self.user_folder + self.printers_filename)\n\n        for i in new_material_list:\n            new_material_version = self.get_materials_info(self.tmp_place + i)\n            old_material_version = self.get_materials_info(self.user_folder + i)\n            if new_material_version:\n                if old_material_version:\n                    if new_material_version > old_material_version:\n                        copyfile(self.tmp_place + i, self.user_folder + i)\n                else:\n                    copyfile(self.tmp_place + i, self.user_folder + i)\n            else:\n                self.use_default_files()\n\n    def use_default_files(self):\n        #delete .prusacontrol\n        try:\n            shutil.rmtree(self.user_folder)\n        except OSError as exception:\n            if exception.errno != errno.EEXIST:\n                raise\n\n        #copy default files from data folder\n        try:\n            os.makedirs(self.user_folder)\n        except OSError as exception:\n            if exception.errno != errno.EEXIST:\n                raise\n        try:\n            copyfile(self.data_folder + self.printers_filename, self.user_folder + self.printers_filename)\n        except Error as e:\n            logging.debug(\'Error: %s\' % e)\n        except IOError as e:\n            logging.debug(\'Error: %s\' % e.strerror)\n\n        printers_data = json.load(open(self.user_folder + self.printers_filename, \'r\'))\n        materials_files_list = [printers_data[\'printers\'][i][\'material_parameters_file\'] for i in\n                                printers_data[\'printers\'] if i not in [\'default\']]\n\n        for i in materials_files_list:\n            try:\n                copyfile(self.data_folder + i, self.user_folder + i)\n            except Error as e:\n                logging.debug(\'Error: %s\' % e)\n            except IOError as e:\n                logging.debug(\'Error: %s\' % e.strerror)\n\n\n    def check_new_version_of_prusacontrol(self):\n        #download json file with actual version\n        try:\n            #r = urlopen(self.prusacontrol_url + self.prusacontrol_version_file)\n            r = self.http.request(\'GET\', self.prusacontrol_url + self.prusacontrol_version_file)\n        except urllib3.exceptions.HTTPError as e:\n            return None\n        except urllib3.exceptions.NewConnectionError as e:\n            return None\n        else:\n            data = r.data\n            if data:\n                if self.is_higher(self.strip_version_string(data)):\n                    self.is_version_actual = False\n                else:\n                    self.is_version_actual = True\n            else:\n                return None\n\n\n    def get_printers_info(self, json_path):\n        with open(json_path, \'r\') as in_file:\n            printers_data = json.load(in_file)\n            materials_files_list = [printers_data[\'printers\'][i][\'material_parameters_file\'] for i in\n                                    printers_data[\'printers\'] if i not in [\'default\']]\n\n            version = printers_data[\'info\'][\'version\']\n            return [version, materials_files_list]\n\n        return None\n\n    def get_materials_info(self, json_path):\n        try:\n            with open(json_path, \'r\') as in_file:\n                printers_data = json.load(in_file)\n                return printers_data[\'info\'][\'version\']\n        except FileNotFoundError:\n            logging.error(""Something is wrong with configuration files, delete all, use defaults"")\n\n        return None\n\n\n    def is_higher(self, version_from_internet):\n        splitted_version_from_internet = version_from_internet.split(""_"")\n        splitted_local_version = self.version.split(""_"")\n\n        #print(""Local version: "" + str(splitted_local_version))\n        #print(""Internet version: "" + str(splitted_version_from_internet))\n        try:\n            version_from_internet_lst = splitted_version_from_internet[0].split(""."")\n            local_version_lst = splitted_local_version[0].split(""."")\n\n            if len(version_from_internet_lst) == len(local_version_lst):\n                for i, o in zip(version_from_internet_lst, local_version_lst):\n                    if int(i) > int(o):\n                        return True\n                if int(splitted_version_from_internet[1]) > int(splitted_local_version[1]):\n                    return True\n                else:\n                    return False\n            else:\n                return True\n        except IndexError as e:\n            return False\n\n        return False\n\n\n\n\n    def make_full_os_path(self, file):\n        return os.path.expanduser(file)\n'"
projectFile.py,0,"b'# -*- coding: utf-8 -*-\nfrom copy import deepcopy\nfrom pprint import pprint\nfrom xml.dom import minidom\n\nimport unicodedata\n\n__author__ = \'Tibor Vavra\'\n\nimport ast\nimport logging\nfrom abc import ABCMeta, abstractmethod\nfrom io import StringIO\nfrom zipfile import ZipFile, ZIP_DEFLATED\nimport xml.etree.cElementTree as ET\nimport os\n#import io\n\nimport numpy\nfrom io import BytesIO\nimport stl\n\nfrom stl.mesh import Mesh\n\nfrom sceneData import ModelTypeStl, MultiModel\n\nfileExtension = \'prusa\'\n\n\nclass ProjectFile(object):\n\n    def __init__(self, scene, filename=""""):\n        if filename:\n            self.scene_xml = None\n            self.scene = scene\n\n            #TODO:check which version is scene.xml version and according to chose class to read project file\n            self.version = Version_1_0()\n            self.version.load(scene, filename)\n        else:\n            self.version = Version_1_0()\n            self.scene = scene\n\n    def save(self, filename):\n        self.version.save(self.scene, filename)\n\n\nclass VersionAbstract(object):\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        pass\n\n    @abstractmethod\n    def check_version(self, filename):\n        return False\n\n    @abstractmethod\n    def get_version(self):\n        return ""Abstract version""\n\n    @abstractmethod\n    def load(self, scene, filename):\n        logging.debug(""This is abstract version class load function"")\n        return False\n\n    @abstractmethod\n    def save(self, scene, filename):\n        logging.debug(""This is abstract version class save function"")\n        return False\n\n\nclass Version_1_0(VersionAbstract):\n\n    def __init__(self):\n        self.xmlFilename = \'scene.xml\'\n\n    def check_version(self, filename):\n        return True\n\n    def get_version(self):\n        return ""1.0""\n\n    def load(self, scene, filename):\n        #open zipfile\n        with ZipFile(filename, \'r\') as openedZipfile:\n            tree = ET.fromstring(openedZipfile.read(self.xmlFilename))\n            version = tree.find(\'version\').text\n            if self.get_version() == version:\n                logging.debug(""Ano, soubor je stejna verze jako knihovna pro jeho nacitani. Pokracujeme"")\n            else:\n                logging.debug(""Problem, tuto verzi neumim nacitat."")\n                return False\n            models = tree.find(\'models\')\n            models_data = []\n            for model in models.findall(\'model\'):\n                model_data = {}\n                model_data[\'file_name\'] = model.get(\'name\')\n\n                if not model.find(\'extruder\') == None:\n                    model_data[\'extruder\'] = ast.literal_eval(model.find(\'extruder\').text)\n                if not model.find(\'group\') == None:\n                    model_data[\'group\'] = ast.literal_eval(model.find(\'group\').text)\n\n                model_data[\'normalization\'] = ast.literal_eval(model.find(\'normalization\').text)\n                model_data[\'position\'] = ast.literal_eval(model.find(\'position\').text)\n                model_data[\'rotation\'] = ast.literal_eval(model.find(\'rotation\').text)\n                model_data[\'scale\'] = ast.literal_eval(model.find(\'scale\').text)\n                models_data.append(model_data)\n\n            #scene.models = []\n            models_groups = {}\n            groups_properties = {}\n            for m in models_data:\n                logging.debug(""Jmeno souboru je: "" + m[\'file_name\'])\n\n                tmp = scene.controller.app_config.tmp_place\n                model_filename = tmp + m[\'file_name\']\n                openedZipfile.extract(m[\'file_name\'], tmp)\n\n                mesh = Mesh.from_file(filename=model_filename)\n                os.remove(model_filename)\n\n                #mesh = Mesh.from_file(filename="""", fh=openedZipfile.open(m[\'file_name\']))\n                if \'group\' in m:\n                    model = ModelTypeStl.load_from_mesh(mesh, filename=m[\'file_name\'], normalize=not m[\'normalization\'])\n                else:\n                    model = ModelTypeStl.load_from_mesh(mesh, filename=m[\'file_name\'], normalize=not m[\'normalization\'])\n\n                if \'extruder\' in m:\n                    model.extruder = int(m[\'extruder\'])\n\n                if \'group\' in m:\n                    model.is_multipart_model = True\n                    model.parent = scene\n                    model.normalization_flag = m[\'normalization\']\n                    if m[\'group\'] in models_groups:\n                        models_groups[m[\'group\']].append(model)\n                    else:\n                        models_groups[m[\'group\']] = []\n                        models_groups[m[\'group\']].append(model)\n\n                    if m[\'group\'] in groups_properties:\n                        groups_properties[m[\'group\']][\'pos\'] = numpy.array(m[\'position\']) * 0.1\n                        groups_properties[m[\'group\']][\'rot\'] = numpy.array(m[\'rotation\'])\n                        groups_properties[m[\'group\']][\'scale\'] = numpy.array(m[\'scale\'])\n                    else:\n                        groups_properties[m[\'group\']] = {}\n                        groups_properties[m[\'group\']][\'pos\'] = numpy.array(m[\'position\']) * 0.1\n                        groups_properties[m[\'group\']][\'rot\'] = numpy.array(m[\'rotation\'])\n                        groups_properties[m[\'group\']][\'scale\'] = numpy.array(m[\'scale\'])\n\n                else:\n                    model.rot = numpy.array(m[\'rotation\'])\n                    model.pos = numpy.array(m[\'position\'])\n                    model.pos *= 0.1\n                    model.scale = numpy.array(m[\'scale\'])\n                    model.update_min_max()\n                    model.parent = scene\n                    model.update_min_max()\n                    model.normalization_flag = m[\'normalization\']\n\n                scene.models.append(model)\n\n\n            for group in models_groups:\n                mm = MultiModel(models_groups[group], scene)\n                mm.pos = groups_properties[group][\'pos\']\n                mm.rot = groups_properties[group][\'rot\']\n                mm.scale = groups_properties[group][\'scale\']\n\n                scene.multipart_models.append(mm)\n\n                mm.update_min_max()\n\n    def remove_accents(str, input_str):\n        nfkd_form = unicodedata.normalize(\'NFKD\', input_str)\n        stripped = u"""".join([c for c in nfkd_form if not unicodedata.combining(c)])\n        return stripped\n\n    def save(self, scene, filename):\n        printing_space =  scene.controller.printing_parameters.get_printer_parameters(scene.controller.actual_printer)\n        zero = numpy.array(printing_space[\'printing_space\'], dtype=float)\n        zero *= -0.5\n        zero[2] = 0.\n        #print(str(zero))\n        #create zipfile\n        with ZipFile(filename, \'w\', ZIP_DEFLATED) as zip_fh:\n            #create xml file describing scene\n            root = ET.Element(""scene"")\n            ET.SubElement(root, ""version"").text=self.get_version()\n            ET.SubElement(root, ""zero"").text = str(zero.tolist())\n            models_tag = ET.SubElement(root, ""models"")\n\n            #this 3 lines are for slic3r, it cant handle diacritics in files inside zip file\n            for m in scene.models:\n                m.filename = self.remove_accents(m.filename)\n            scene.check_models_name()\n\n            models_from_scene = [m for m in scene.get_models(with_wipe_tower=False)]\n            single_part_models = [m for m in models_from_scene if not m.is_multipart_model]\n            multipart_models = [m for m in models_from_scene if m.is_multipart_model]\n\n            multipart_groups = {}\n            for m in multipart_models:\n                if m.multipart_parent.group_id in multipart_groups:\n                    multipart_groups[m.multipart_parent.group_id].append(m)\n                else:\n                    multipart_groups[m.multipart_parent.group_id] = []\n                    multipart_groups[m.multipart_parent.group_id].append(m)\n\n            multipart_groups_sorted = []\n            for g in multipart_groups:\n                multipart_groups_sorted = multipart_groups_sorted + sorted(multipart_groups[g], key=lambda model: model.filename)\n\n            models_from_scene_sorted = single_part_models + multipart_groups_sorted\n\n            for model in models_from_scene_sorted:\n                if model.is_multipart_model:\n                    model_tmp = model.multipart_parent\n                    #pos = deepcopy(model.pos)\n                    pos = deepcopy(model_tmp.pos)\n                    pos *= 10.\n                    model_element = ET.SubElement(models_tag, ""model"", name=model.filename)\n                    ET.SubElement(model_element, ""extruder"").text = str(model.extruder)\n                    if model.is_multipart_model:\n                        ET.SubElement(model_element, ""group"").text = str(model.multipart_parent.group_id)\n                    ET.SubElement(model_element, ""normalization"").text = str(deepcopy(model.normalization_flag))\n                    ET.SubElement(model_element, ""position"").text = str(pos.tolist())\n                    ET.SubElement(model_element, ""rotation"").text = str(model_tmp.rot.tolist())\n                    ET.SubElement(model_element, ""scale"").text = str(model_tmp.scale.tolist())\n                else:\n                    pos = model.pos*10.\n                    model_element = ET.SubElement(models_tag, ""model"", name=model.filename)\n                    ET.SubElement(model_element, ""extruder"").text = str(model.extruder)\n                    if model.is_multipart_model:\n                        ET.SubElement(model_element, ""group"").text = str(model.multipart_parent.group_id)\n                    ET.SubElement(model_element, ""normalization"").text = str(model.normalization_flag)\n                    ET.SubElement(model_element, ""position"").text = str(pos.tolist())\n                    ET.SubElement(model_element, ""rotation"").text = str(model.rot.tolist())\n                    ET.SubElement(model_element, ""scale"").text = str(model.scale.tolist())\n\n\n            #save xml file to new created zip file\n            newXml = ET.tostring(root, encoding=""utf-8"")\n            nice_formated_xml = minidom.parseString(newXml).toprettyxml(indent=""   "", encoding=""utf-8"")\n            zip_fh.writestr(self.xmlFilename, nice_formated_xml)\n\n            #write stl files to zip file\n            for model in models_from_scene_sorted:\n                if model.isVisible and not model.is_wipe_tower:\n                    #transform data to stl file\n                    mesh = model.get_mesh(False, False)\n\n                    model_filename = scene.controller.app_config.tmp_place + model.filename\n                    mesh.save(model_filename, mode=stl.Mode.BINARY, update_normals=False)\n                    zip_fh.write(model_filename, model.filename)\n                    os.remove(model_filename)\n\n        return True\n\n\n'"
sceneData.py,200,"b'# -*- coding: utf-8 -*-\nimport stl\n\n__author__ = \'Tibor Vavra\'\n\nimport logging\nfrom collections import defaultdict\n\nimport gc\nimport numpy as np\nfrom abc import ABCMeta, abstractmethod\nfrom os.path import basename\n\nimport time\nfrom PyQt4.QtCore import QObject\nfrom PyQt4.QtGui import QFont\nfrom PyQt4.QtOpenGL import QGLBuffer\n#from stl import Mode\nfrom stl.mesh import Mesh\n\nfrom random import randint\nimport math\nimport itertools\nfrom pprint import pprint\n\n\nimport OpenGL\n\nOpenGL.ERROR_CHECKING = False\nOpenGL.ERROR_LOGGING = False\n\nfrom OpenGL.GL import *\n#from OpenGL.GLU import *\n#from OpenGL.GLUT import *\n\nfrom copy import deepcopy\nfrom pyrr import matrix44, Vector3, geometric_tests, line, ray, plane, matrix33\n\nfrom collections import namedtuple\n\n#glutInit()\n\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print(\'%s function took %0.3f ms\' % (f.__name__, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\nclass AppScene(object):\n    \'\'\'\n    Class holding data of scene, models, positions, parameters\n    it can be used for generating sliced data and rendering data\n    \'\'\'\n    def __init__(self, controller):\n        self.controller = controller\n        self.model_position_offset = 0.25\n\n        self.wipe_tower_size_x = 60.\n        self.wipe_tower_size_y = 15.\n        self.wipe_tower_size_z = 0.10\n        self.wipe_tower_number_of_section = 0\n\n        self.sceneZero = [.0, .0, .0]\n        self.models = []\n        self.multipart_models = []\n        self.supports = []\n        self.actual_support = []\n        self.copied_models = []\n        self.printable = True\n        self.camera_vector = np.array([0.,0.,0.])\n        self.last_selected_object = []\n\n        self.place_offset = np.array([0., 0., 0.])\n\n        self.transformation_list = []\n        self.actual_list_position = 0\n\n        self.analyze_result_data_tmp = []\n\n        self.is_wipe_tower = False\n        self.wipe_tower_model = []\n        self.is_wipe_tower_position_manual = False\n        self.wipe_tower_pos = np.array([0.0, 0.0, 0.0])\n\n\n\n    def create_wipe_tower(self):\n        if self.wipe_tower_number_of_section == 0 or len(self.get_models(with_wipe_tower=False)) == 0:\n            return\n\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            pass\n        else:\n            return\n\n        n_sections = self.wipe_tower_number_of_section\n\n        size_x = self.wipe_tower_size_x\n        size_y = self.wipe_tower_size_y * n_sections\n        size_z = self.wipe_tower_size_z\n\n\n        # Define the 8 vertices of the cube\n        vertices = np.array([ \\\n            [-1.*(size_x*.5), -1.*(size_y*.5), -1.*(size_z*.5)],\n            [1.*(size_x*.5), -1.*(size_y*.5), -1.*(size_z*.5)],\n            [1.*(size_x*.5), 1.*(size_y*.5), -1.*(size_z*.5)],\n            [-1.*(size_x*.5), 1.*(size_y*.5), -1.*(size_z*.5)],\n            [-1.*(size_x*.5), -1.*(size_y*.5), 1.*(size_z*.5)],\n            [1.*(size_x*.5), -1.*(size_y*.5), 1.*(size_z*.5)],\n            [1.*(size_x*.5), 1.*(size_y*.5), 1.*(size_z*.5)],\n            [-1.*(size_x*.5), 1.*(size_y*.5), 1.*(size_z*.5)]])\n\n        # Define the 12 triangles composing the cube\n        faces = np.array([ \\\n            [0, 3, 1],\n            [1, 3, 2],\n            [0, 4, 7],\n            [0, 7, 3],\n            [4, 5, 6],\n            [4, 6, 7],\n            [5, 1, 2],\n            [5, 2, 6],\n            [2, 3, 6],\n            [3, 7, 6],\n            [0, 1, 5],\n            [0, 5, 4]])\n\n\n        # Create the mesh\n        cube = Mesh(np.zeros(faces.shape[0], dtype=Mesh.dtype), calculate_normals=False)\n\n        for i, f in enumerate(faces):\n            for j in range(3):\n                cube.vectors[i][j] = vertices[f[j], :]\n\n        cube.update_normals()\n\n        m = ModelTypeStl.load_from_mesh(cube, ""maximal wipe tower"")\n\n        m.wipe_tower_texture = self.controller.view.glWidget.texture_from_png(self.controller.app_config.local_path + ""data/img/LineAngle3.png"")\n\n        m.parent = self\n        m.is_wipe_tower = True\n        self.wipe_tower_model = m\n\n        printer_parameters = self.controller.printing_parameters.get_printer_parameters(self.controller.actual_printer)\n\n        m.set_2d_pos([(printer_parameters[\'printing_space\'][0]*.05)-(size_x*.05)-1.,\n                               (printer_parameters[\'printing_space\'][1]*.05)-(size_y*.05)-1.])\n\n        #m.set_2d_pos(np.array([(size_x * .05),\n        #                       (size_y * .05),\n        #                       0.0]))\n\n        self.models.append(m)\n\n    def remove_wipe_tower(self):\n        if self.wipe_tower_model:\n            self.models.remove(self.wipe_tower_model)\n            self.wipe_tower_model = None\n\n    def get_size(self, model):\n        print(model.filename)\n        if model.is_multipart_model:\n            return model.multipart_parent.size\n        else:\n            return model.size\n\n    def update_wipe_tower(self):\n        #get maximal z in scene\n        z_list = [self.get_size(m)[2]*10. for m in self.get_models(with_wipe_tower=False)]\n        if z_list == []:\n            self.wipe_tower_size_z = 0.1\n        else:\n            max_z = max(z_list)\n            self.wipe_tower_size_z = max_z\n\n        #update number of section by number of used extruders -1\n        extruders_set_tmp = list(set([m.extruder for m in self.get_models(with_wipe_tower=False)]))\n        if self.controller.view.get_support_option() >=1 :\n            extruders_set_tmp.append(self.controller.soluble_extruder)\n            extruders_set = list(extruders_set_tmp)\n        else:\n            extruders_set = list(extruders_set_tmp)\n\n        self.wipe_tower_number_of_section = len(extruders_set) - 1\n\n        if self.wipe_tower_model:\n            self.wipe_tower_pos = deepcopy(self.wipe_tower_model.pos)\n\n        self.remove_wipe_tower()\n        self.create_wipe_tower()\n        if self.is_wipe_tower_position_manual and self.wipe_tower_model:\n            self.wipe_tower_model.pos[0] = self.wipe_tower_pos[0]\n            self.wipe_tower_model.pos[1] = self.wipe_tower_pos[1]\n\n        if self.wipe_tower_model:\n            self.wipe_tower_model.update_min_max()\n\n        self.controller.update_scene()\n\n\n    def get_wipe_tower_possition_and_size(self):\n        printer_parameters = self.controller.printing_parameters.get_printer_parameters(self.controller.actual_printer)\n\n        parameters = {}\n\n        parameters[\'is_wipe_tower\'] = int(self.controller.is_multimaterial() and not self.controller.is_single_material_mode())\n\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode() and self.wipe_tower_model:\n            parameters[\'wipe_pos_x\'] = int((self.wipe_tower_model.pos[0] - self.wipe_tower_size_x * .05) * 10. + printer_parameters[\'printing_space\'][0] * .5)\n            parameters[\'wipe_pos_y\'] = int((self.wipe_tower_model.pos[1] - self.wipe_tower_size_y * self.wipe_tower_number_of_section * .05) * 10. + printer_parameters[\'printing_space\'][1] * .5)\n            parameters[\'wipe_size_x\'] = int(self.wipe_tower_size_x)\n            parameters[\'wipe_size_y\'] = int(self.wipe_tower_size_y)\n        else:\n            parameters[\'wipe_pos_x\'] = 0\n            parameters[\'wipe_pos_y\'] = 0\n            parameters[\'wipe_size_x\'] = 0\n            parameters[\'wipe_size_y\'] = 0\n\n        return parameters\n\n    def set_no_changes(self):\n        for m in self.models:\n            m.is_changed = False\n\n    def was_changed(self):\n        #print(""scene was changed?"")\n        for m in self.models:\n            if m.is_changed:\n                #print(""True"")\n                return True\n        #print(""False"")\n        return False\n\n    def save_actual_support(self):\n        self.supports.append(self.actual_support)\n        self.actual_support = []\n\n    def clear_history(self):\n        #print(""Mazu historii"")\n        self.transformation_list = []\n        self.actual_list_position = 0\n\n    def save_change(self, old_instances_list):\n        #print(""Ukladam stav objektu"")\n        if self.actual_list_position < len(self.transformation_list)-1:\n            self.transformation_list = self.transformation_list[:self.actual_list_position+1]\n\n        list_of_states = [[i, deepcopy(i.isVisible), deepcopy(i.scale), deepcopy(i.rot), deepcopy(i.pos)] for i in old_instances_list]\n\n        self.transformation_list.append(list_of_states)\n        self.actual_list_position = len(self.transformation_list)-1\n        #self.controller.show_message_on_status_bar(""Set state %s from %s"" % (\'{:2}\'.format(self.actual_list_position), \'{:2}\'.format(len(self.transformation_list))))\n\n        #pprint(self.transformation_list)\n\n\n    def make_undo(self):\n        #just move pointer of transformation to -1 or leave on 0\n        #print(""Aktualni pozice je: "" + str(self.actual_list_position))\n        #pprint(self.transformation_list)\n        if self.actual_list_position >= 1:\n            self.actual_list_position -= 1\n            list_of_states = self.transformation_list[self.actual_list_position]\n            #print(""Vraceny stav:"")\n            #pprint(list_of_states)\n            for i in list_of_states:\n                old_instance, isVisible, scale, rot, pos = i\n                old_instance.isVisible = deepcopy(isVisible)\n                old_instance.scale = deepcopy(scale)\n                old_instance.rot = deepcopy(rot)\n                old_instance.pos = deepcopy(pos)\n                old_instance.is_changed = True\n                old_instance.update_min_max()\n            #self.controller.show_message_on_status_bar(""Set state %s from %s"" % (\'{:2}\'.format(self.actual_list_position), \'{:2}\'.format(len(self.transformation_list))))\n        #print(""Konec stavu"")\n\n    def make_do(self):\n        #move pointer of transformation to +1 or leave on last\n        #print(""Aktualni pozice je: "" + str(self.actual_list_position))\n        #pprint(self.transformation_list)\n        if self.actual_list_position < len(self.transformation_list)-1:\n            #print(""jsem uvnitr"")\n            self.actual_list_position += 1\n            list_of_states = self.transformation_list[self.actual_list_position]\n            for i in list_of_states:\n                old_instance, isVisible, scale, rot, pos = i\n                old_instance.isVisible = deepcopy(isVisible)\n                old_instance.scale = deepcopy(scale)\n                old_instance.rot = deepcopy(rot)\n                old_instance.pos = deepcopy(pos)\n                old_instance.is_changed = True\n                old_instance.update_min_max()\n\n            #self.controller.show_message_on_status_bar(""Set state %s from %s"" % (\'{:2}\'.format(self.actual_list_position), \'{:2}\'.format(len(self.transformation_list))))\n\n\n    def calculate_support(self, pos):\n        height = 25\n        # self.supports.append({""pos"": pos, ""height"": height})\n        for m in self.models:\n            height = self.find_support_height(m, pos)\n            if height:\n                self.actual_support = {""pos"": pos, ""height"": height}\n            else:\n                self.actual_support = {""pos"": pos, ""height"": 25}\n\n    def create_support(self, pos):\n        height = 25\n        #self.supports.append({""pos"": pos, ""height"": height})\n        for m in self.models:\n            height = self.find_support_height(m, pos)\n            if height:\n                self.supports.append({""pos"": pos, ""height"": height})\n                break\n\n\n    def is_collision_of_wipe_tower_and_objects(self):\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            pass\n        else:\n            return False\n\n        if not self.wipe_tower_model:\n            return False\n\n        wipe_tower = self.wipe_tower_model\n        if wipe_tower.intersection_model_list_model_(self.get_models(with_wipe_tower=False)):\n            return True\n        return False\n\n\n\n    def find_support_height(self, m, pos):\n        ret, point = m.intersectionRayModel3(pos, np.array([pos[0], pos[1], 1.]))\n        if ret:\n            return np.sqrt(point.dot(point))\n        else:\n            return False\n\n\n    def check_models_name(self):\n        for m in self.models:\n            number = 0\n            for o in self.models:\n                if m.filename == o.filename:\n                    number+=1\n                if number>1:\n                    name_list = o.filename.split(""."")\n                    name_list[0] = ""%s-%s"" % (name_list[0], str(number))\n                    o.filename = ""."".join(name_list)\n\n    @staticmethod\n    def get_area_of_triangle(triangle):\n        a = np.linalg.norm(triangle[2]-triangle[1])\n        b = np.linalg.norm(triangle[2]-triangle[0])\n        c = np.linalg.norm(triangle[1]-triangle[0])\n        s = (a+b+c)/2.\n        area_tmp = s*((s-a)*(s-b)*(s-c))\n        area = np.sqrt(area_tmp)\n\n        return area\n\n\n\n    #@timing\n    @staticmethod\n    def normalize_group_of_models(models_lst):\n        #it takes list of models, concate them, calculate mass point, set it to boundingSphereCenter and normalize\n        m = Mesh(np.concatenate([m.get_mesh(False, False, False).data for m in models_lst]))\n        m.update_max()\n        m.update_min()\n        min = m.min_\n        max = m.max_\n\n        data = m.get_mass_properties()\n        bounding_center =  np.array([((max[0]-min[0])*.5), ((max[1]-min[1])*.5), ((max[2]-min[2])*.5)])\n        r = np.array([.0, .0, .0]) - data[1]\n\n        m.vectors = m.vectors + r\n\n        m.update_max()\n        m.update_min()\n        min = np.array(m.min_)\n        max = np.array(m.max_)\n\n        size = max - min\n        size_origin = deepcopy(size)\n\n        max_l = np.linalg.norm(m.max_)\n        min_l = np.linalg.norm(m.min_)\n\n        models_lst[0].multipart_parent.size = size\n        models_lst[0].multipart_parent.size_origin = size_origin\n\n        max_bs = []\n\n\n        models_lst[0].multipart_parent.min = min\n        models_lst[0].multipart_parent.max = max\n\n        models_lst[0].multipart_parent.pos = np.array([0., 0., 0.])\n        models_lst[0].multipart_parent.pos[2] -= min[2]\n\n        if max_l > min_l:\n            models_lst[0].multipart_parent.boundingSphereSize = max_l\n        else:\n            models_lst[0].multipart_parent.boundingSphereSize = min_l\n\n        for obj in models_lst:\n            obj.boundingSphereCenter = bounding_center\n            obj.mesh.vectors += r\n\n            obj.pos = np.array([0., 0., 0.])\n            #obj.pos[2] -= min[2]\n\n            obj.zeroPoint = np.array([0., 0., 0.])\n            #obj.zeroPoint = deepcopy(bounding_center)\n            #obj.zeroPoint[2] = deepcopy(min[2])\n\n            #obj.pos = np.array([.0, .0, .0]) - obj.zeroPoint\n            #obj.zeroPoint += r\n\n            obj.min = deepcopy(min)\n            obj.max = deepcopy(max)\n\n            max_bs.append(obj.max_bs)\n\n\n            #obj.min_scene = obj.min + obj.pos\n            #obj.max_scene = obj.max + obj.pos\n\n            #obj.place_on_zero()\n\n            obj.normalization_flag = True\n\n            #obj.normalize_object()\n\n        models_lst[0].multipart_parent.max_bs = np.max(max_bs)\n\n        models_lst[0].multipart_parent.update_min_max()\n\n        return True\n\n    #@timing\n    def get_contact_faces_with_area_smaller_than(self, area_size, whole_scene):\n        #whole_scene = self.get_whole_scene_in_one_mesh()\n\n        b= whole_scene.vectors[:, :, 2] < 0.1\n        b_tmp = np.array([i.all() for i in b])\n        tmp_brim = whole_scene.vectors[b_tmp]\n\n        #tmp_brim = np.array([i+whole_scene.normals[n]*0.001 for n, i in enumerate(whole_scene.vectors) if (i[0][2]<0.1 and i[1][2]<0.1 and i[2][2]<0.1)])\n\n        whole_scene.update_max()\n        whole_scene.update_min()\n\n        boundingSphereCenter = np.array([0., 0., 0.])\n        boundingSphereCenter[0] = (whole_scene.max_[0] + whole_scene.min_[0]) * .5\n        boundingSphereCenter[1] = (whole_scene.max_[1] + whole_scene.min_[1]) * .5\n        boundingSphereCenter[2] = (whole_scene.max_[2] + whole_scene.min_[2]) * .5\n\n        max_l = np.linalg.norm(whole_scene.max_)\n        min_l = np.linalg.norm(whole_scene.min_)\n        if max_l > min_l:\n            boundingSphereSize = max_l\n        else:\n            boundingSphereSize = min_l\n\n        object_space = 4.189*(boundingSphereSize*.5)**3\n\n        areas = [AppScene.get_area_of_triangle(i) for i in tmp_brim]\n        connection_area = np.sum(areas)\n\n        if not len(tmp_brim) == 0:\n            tmp_brim *= np.array([.1, .1, .1])\n\n        if connection_area == 0:\n            brim = True\n        elif object_space/connection_area <= 300.:\n            brim = False\n        else:\n            brim = True\n\n        if len(self.analyze_result_data_tmp) == 0 and len(tmp_brim) == 0:\n            self.analyze_result_data_tmp = []\n        elif len(self.analyze_result_data_tmp) == 0:\n            self.analyze_result_data_tmp = tmp_brim\n        elif not (len(tmp_brim) == 0) and not (len(self.analyze_result_data_tmp) == 0):\n            np.concatenate((tmp_brim, self.analyze_result_data_tmp), axis=0)\n\n        return brim\n\n    #@timing\n    def get_faces_by_smaller_angel_normal_and_vector(self, vector, angle, whole_scene):\n        #calculate angel between normal vector and given vector\n        #return list of faces with smaller\n        #whole_scene = self.get_whole_scene_in_one_mesh()\n        d = 0.1\n        self.analyze_result_data_tmp = np.array([])\n        self.analyze_result_data_tmp = np.array([i+whole_scene.normals[n]*d for n, i in enumerate(whole_scene.vectors) if AppScene.calc_angle(whole_scene.normals[n], vector) <= 90.-angle ])\n        self.analyze_result_data_tmp = np.array([i for n, i in enumerate(self.analyze_result_data_tmp) if not (i[0][2]<0.1 and i[1][2]<0.1 and i[2][2]<0.1) and AppScene.is_length_in_z_bigger_then(i, 0.75)])\n\n        if not len(self.analyze_result_data_tmp) == 0:\n            self.analyze_result_data_tmp *= np.array([.1, .1, .1])\n\n        return self.analyze_result_data_tmp\n\n    @staticmethod\n    def calc_angle(normal, vector):\n        normal /= np.sqrt(normal.dot(normal))\n        #normal /= np.linalg.norm(normal)\n        vector /= np.sqrt(vector.dot(vector))\n        #vector /= np.linalg.norm(vector)\n        cos_ang = np.dot(normal, vector)\n        sin_ang = np.linalg.norm(np.cross(normal, vector))\n        deg = np.degrees(np.arctan2(sin_ang, cos_ang))\n        return deg\n\n    @staticmethod\n    def calc_angle2(old_vec, new_vec):\n        cos_ang = np.dot(old_vec, new_vec)\n        cross = np.cross(old_vec, new_vec)\n\n        neg = np.dot(cross, np.array([0., 0., 1.]))\n        sin_ang = np.linalg.norm(cross) * np.sign(neg) * -1.\n\n        alpha = np.arctan2(sin_ang, cos_ang)\n\n    @staticmethod\n    def is_length_in_z_bigger_then(triangle, minimal_z):\n        max_z = max([i[2] for i in triangle])\n        min_z = min([i[2] for i in triangle])\n        length = max_z - min_z\n        if length >= minimal_z:\n            return True\n        else:\n            return False\n\n    def delete_selected_models(self):\n        for m in self.get_models():\n            if m.selected and m.isVisible:\n                if m.is_multipart_model:\n                    m.multipart_parent.delete_models()\n                else:\n                    if m.is_wipe_tower:\n                        pass\n                    else:\n                        m.isVisible = False\n\n        if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n            self.update_wipe_tower()\n\n        #TODO: Add state to history\n        self.clear_selected_models()\n        self.controller.view.update_scene()\n\n    def copy_selected_objects(self):\n        self.place_offset = np.array([0.,0.,0.])\n        self.copied_models = []\n        for m in self.get_models():\n            if m.selected and m.isVisible:\n                self.copied_models.append(m)\n\n    def unselect_all_models(self):\n        for m in self.get_models():\n            m.selected = False\n\n    def paste_selected_objects(self):\n        copied_mm_models = []\n        self.place_offset += np.array([0.5, 0.5, 0.])\n        self.unselect_all_models()\n        for i in self.copied_models:\n            if i.is_wipe_tower:\n                continue\n            if i.is_multipart_model:\n                if i.multipart_parent.group_id in copied_mm_models:\n                    continue\n                else:\n                    copied_mm_models.append(i.multipart_parent.group_id)\n                models_lst = i.multipart_parent.models\n                new_models_lst = []\n                for model in models_lst:\n                    m = deepcopy(model)\n                    #m.set_move(self.place_offset, True, False)\n                    self.last_selected_object = m.id\n                    self.models.append(m)\n                    new_models_lst.append(m)\n                mm = MultiModel(new_models_lst, self)\n\n                mm.pos = i.multipart_parent.pos + self.place_offset\n                mm.scale = deepcopy(i.multipart_parent.scale)\n                mm.rot = deepcopy(i.multipart_parent.rot)\n                mm.size = deepcopy(i.multipart_parent.size)\n                mm.size_origin = deepcopy(i.multipart_parent.size_origin)\n                mm.old_scale = deepcopy(i.multipart_parent.old_scale)\n\n\n                mm.update_min_max()\n                self.multipart_models.append(mm)\n            else:\n                m = deepcopy(i)\n                m.set_move(self.place_offset, True, False)\n                m.selected = True\n                self.last_selected_object = m.id\n                self.models.append(m)\n\n        self.controller.update_scene()\n        #self.automatic_models_position()\n\n    def get_warnings(self):\n        messages = []\n        text00 = self.controller.message_object00\n        text01 = self.controller.message_object01\n\n        for model in self.get_models():\n            if model.isVisible:\n                if not model.is_in_printing_area:\n                    if len(model.filename)>7:\n                        filename = model.filename[:7] + ""...""\n                    else:\n                        filename = model.filename\n                    messages.append(u""\xe2\x80\xa2 "" + text00 + \' \' + filename + \' \' + text01)\n                    #messages.append(text00 + filename + text01)\n        return messages\n\n    def reset_wipe_tower(self):\n        self.wipe_tower_size_x = 60.\n        self.wipe_tower_size_y = 15.\n        self.wipe_tower_size_z = 0.10\n        self.wipe_tower_number_of_section = 0\n\n\n    def clear_scene(self):\n        del self.transformation_list\n        if self.wipe_tower_model:\n            self.wipe_tower_model = []\n            self.reset_wipe_tower()\n        self.transformation_list = []\n        del self.models\n        self.models = []\n        self.actual_list_position = 0\n\n    def clear_selected_models(self):\n        for m in self.models:\n            m.selected = False\n\n    def get_models(self, with_wipe_tower=True, sort=False):\n        if with_wipe_tower:\n            model_lst = [m for m in self.models if m.isVisible]\n        else:\n            model_lst = [m for m in self.models if m.isVisible and not m.is_wipe_tower]\n\n        if sort:\n            cam_pos, _, _, _ = self.controller.view.glWidget.get_camera_direction()\n            final_model_lst = sorted(model_lst, key=lambda model: np.linalg.norm(model.get_pos() - cam_pos), reverse=True)\n        else:\n            final_model_lst = model_lst\n\n\n        return final_model_lst\n\n\n\n\n    def automatic_models_position(self):\n        if not len(self.get_models(with_wipe_tower=False)) >= 1:\n            #TODO:Add placing of first model(MultiModel model)\n            return\n        #sort objects over size of bounding sphere\n\n        #self.models = sorted(self.models, key=lambda k: k.boundingSphereSize, reverse=True)\n        self.models = sorted(self.models, key=lambda k: np.sqrt(k.size.dot(k.size)), reverse=True)\n\n        placed = []\n        #null position of all objects\n        for m in self.get_models(with_wipe_tower=False):\n            #Set possition by fce\n            zer = np.array([.0, .0, .0])\n            if m.is_multipart_model:\n                if m.multipart_parent.group_id in placed:\n                    continue\n                else:\n                    m.set_2d_pos(zer)\n                    placed.append(m.multipart_parent.group_id)\n            else:\n                m.set_2d_pos(zer)\n\n            #m.pos[0] = zer[0]\n            #m.pos[1] = zer[1]\n\n            #m.max_scene = m.max + m.pos\n            #m.min_scene = m.min + m.pos\n\n        #place biggest object(first one) on center\n        #place next object in array on place around center(in clockwise direction) on place zero(center) + 1st object size/2 + 2nd object size/2 + offset\n        if self.models_are_same(with_wipe_tower=False):\n            #grid placing algoritm\n            placed_groups = []\n            self.place_objects_in_grid(placed_groups, False)\n        else:\n            placed_groups = []\n            for i, m in enumerate(self.get_models(with_wipe_tower=False)):\n                self.find_new_position(i, m, placed_groups)\n\n        self.save_change(self.models)\n\n    #TODO: Find bigger size and rotate of 90deg if Y is bigger then X\n    def place_objects_in_grid(self, placed_groups, with_wipe_tower):\n        m_0 = self.get_models(with_wipe_tower=with_wipe_tower)[0]\n\n        if m_0.is_multipart_model:\n            #multimodel version\n            number_of_groups = len(\n                set([m.multipart_parent.group_id for m in self.get_models(with_wipe_tower) if m.is_multipart_model]))\n            number_x = np.floor(np.sqrt(number_of_groups))\n\n            size = deepcopy(m_0.multipart_parent.size) #deepcopy(m_0.max - m_0.min)\n\n            i=0\n            for m in self.get_models(with_wipe_tower):\n                if m.is_multipart_model:\n                    if m.multipart_parent.group_id in placed_groups:\n                        continue\n\n                x = i // number_x\n                y = i - (x * number_x)\n\n                #m.multipart_parent.pos[0] = ((size[0] + self.model_position_offset) * x) - self.model_position_offset\n                #m.multipart_parent.pos[1] = ((size[1] + self.model_position_offset) * y) - self.model_position_offset\n\n                m.set_2d_pos([((size[0] + self.model_position_offset) * x) - self.model_position_offset,\n                              ((size[1] + self.model_position_offset) * y) - self.model_position_offset])\n\n                placed_groups.append(m.multipart_parent.group_id)\n                i+=1\n\n            all_pos = np.array([m.multipart_parent.pos for m in self.get_models(with_wipe_tower)])\n\n            min = np.min(all_pos, axis=0)\n            max = np.max(all_pos, axis=0)\n\n            x_center = (max[0] - min[0]) * .5\n            y_center = (max[1] - min[1]) * .5\n\n            placed_groups = []\n\n            for m in self.get_models(with_wipe_tower=with_wipe_tower):\n                if m.multipart_parent.group_id in placed_groups:\n                    m.multipart_parent.update_min_max_quick_for_move()\n                    continue\n                else:\n                    m.multipart_parent.pos[0] -= x_center\n                    m.multipart_parent.pos[1] -= y_center\n                    placed_groups.append(m.multipart_parent.group_id)\n                    m.multipart_parent.update_min_max_quick_for_move()\n\n        else:\n            #just models version\n            number_x = np.floor(np.sqrt(len(self.get_models(with_wipe_tower=with_wipe_tower))))\n            size = deepcopy(m_0.size)  # deepcopy(m_0.max - m_0.min)\n\n            for i, m in enumerate(self.get_models(with_wipe_tower=with_wipe_tower)):\n                x = i // number_x\n                y = i - (x * number_x)\n\n                m.set_2d_pos([((size[0] + self.model_position_offset) * x) - self.model_position_offset,\n                              ((size[1] + self.model_position_offset) * y) - self.model_position_offset])\n\n\n            all_pos = np.array([deepcopy(m.pos) for m in self.get_models(with_wipe_tower=with_wipe_tower)])\n\n            min = np.min(all_pos, axis=0)\n            max = np.max(all_pos, axis=0)\n\n            x_center = (max[0] - min[0]) * .5\n            y_center = (max[1] - min[1]) * .5\n\n            for m in self.get_models(with_wipe_tower=with_wipe_tower):\n                m.pos[0] -= x_center\n                m.pos[1] -= y_center\n                m.update_min_max()\n\n\n\n    def find_new_position(self, index, model, placed_groups):\n        position_vector = [.0, .0]\n        pos = np.array([.0,.0,.0])\n        if index == 0:\n            if self.get_models(with_wipe_tower=False)[0].is_multipart_model:\n                placed_groups.append(self.get_models(with_wipe_tower=False)[0].multipart_parent.group_id)\n            self.get_models(with_wipe_tower=False)[0].set_2d_pos(position_vector)\n            #self.get_models()[0].pos[0] = position_vector[0]\n            #self.get_models()[0].pos[1] = position_vector[1]\n\n            #self.get_models()[0].max_scene = self.get_models()[0].max + self.get_models()[0].pos\n            #self.get_models()[0].min_scene = self.get_models()[0].min + self.get_models()[0].pos\n            return\n        scene_tmp = self.get_models(with_wipe_tower=False)[:index]\n        if index > 0:\n            if model.is_multipart_model:\n                if model.multipart_parent.group_id in placed_groups:\n                    return\n            while model.intersection_model_list_model_(scene_tmp):\n                #for angle in range(0, 360, 20):\n                for angle in range(0, 360, 45):\n                    pos[0] = math.cos(math.radians(angle)) * (position_vector[0])\n                    pos[1] = math.sin(math.radians(angle)) * (position_vector[1])\n                    model.set_2d_pos(pos)\n\n                    #TODO:Add some test for checking if object is inside of printing space of printer\n                    if not model.intersection_model_list_model_(scene_tmp):\n                        if model.is_multipart_model:\n                            placed_groups.append(model.multipart_parent.group_id)\n                        return\n\n\n                for angle in range(0, 360, 5):\n                    #this angels are tried\n                    if angle in [0, 45, 90, 135, 180, 225, 270, 315, 360]:\n                        continue\n                    pos[0] = math.cos(math.radians(angle)) * (position_vector[0])\n                    pos[1] = math.sin(math.radians(angle)) * (position_vector[1])\n                    model.set_2d_pos(pos)\n\n                    #TODO:Add some test for checking if object is inside of printing space of printer\n                    if not model.intersection_model_list_model_(scene_tmp):\n                        if model.is_multipart_model:\n                            placed_groups.append(model.multipart_parent.group_id)\n                        return\n\n                position_vector[0] += model.boundingSphereSize*.1\n                position_vector[1] += model.boundingSphereSize*.1\n\n\n    def models_are_same(self, with_wipe_tower=True):\n        default_data = self.get_data(self.get_models(with_wipe_tower)[0])\n        default_scale = self.get_scale(self.get_models(with_wipe_tower)[0])\n        default_rot = self.get_rot(self.get_models(with_wipe_tower)[0])\n\n        for m in self.get_models(with_wipe_tower):\n            if not(np.array_equal(default_data, self.get_data(m))):\n                return False\n\n            if not(np.array_equal(default_scale, self.get_scale(m))):\n                return False\n\n            if not(np.array_equal(default_rot, self.get_rot(m))):\n                return False\n\n        return True\n\n\n    def get_data(self, model):\n        if model.is_multipart_model:\n            #small hack, compare just first model data of multimodel\n            return model.multipart_parent.models[0].mesh.vectors\n        else:\n            return model.mesh.vectors\n\n    def get_scale(self, model):\n        if model.is_multipart_model:\n            return model.multipart_parent.scale\n        else:\n            return model.scale\n\n    def get_rot(self, model):\n        if model.is_multipart_model:\n            return model.multipart_parent.rot\n        else:\n            return model.rot\n\n\n    def get_whole_scene_in_one_mesh(self, gcode_generate=False):\n        return Mesh(np.concatenate([m.get_mesh(True, gcode_generate).data for m in self.get_models()]))\n\n    def save_whole_scene_to_one_stl_file(self, filename):\n        whole_scene = self.get_whole_scene_in_one_mesh(True)\n        whole_scene.save(filename, None, mode=stl.Mode.BINARY, update_normals=True)\n\n    def is_scene_printable(self):\n        scene_models = [m for m in self.models if m.isVisible]\n        if len(scene_models) == 0:\n            return False\n        if len(scene_models) == 1 and scene_models[0].is_wipe_tower:\n            return False\n        for model in scene_models:\n            if not model.is_in_printing_space(self.controller.printing_parameters.get_printer_parameters(self.controller.actual_printer)):\n                return False\n        return True\n\n\n\n\nclass Model(object):\n    \'\'\'\n    this is reprezentation of model data\n    \'\'\'\n    newid = itertools.count(1)\n    def __init__(self):\n        #IDs\n        self.id = next(self.newid)\n\n        self.isVisible = True\n        self.is_in_printing_area = True\n\n        self.colorId = [(self.id & 0x000000FF) >> 0, (self.id & 0x0000FF00) >> 8, (self.id & 0x00FF0000) >> 16]\n        self.select_color = [255, 75, 0, 255]\n        self.color = [235, 235, 235, 255]\n\n        self.z_cursor = 0.0\n\n        self.face_colors = []\n        self.normal_groups = {}\n\n        self.rotateXId = self.id * 1001\n        self.rotateColorXId = [(self.rotateXId & 0x000000FF) >> 0, (self.rotateXId & 0x0000FF00) >> 8, (self.rotateXId & 0x00FF0000) >> 16]\n        self.rotateYId = self.id * 1002\n        self.rotateColorYId = [(self.rotateYId & 0x000000FF) >> 0, (self.rotateYId & 0x0000FF00) >> 8, (self.rotateYId & 0x00FF0000) >> 16]\n        self.rotateZId = self.id * 1003\n        self.rotateColorZId = [(self.rotateZId & 0x000000FF) >> 0, (self.rotateZId & 0x0000FF00) >> 8, (self.rotateZId & 0x00FF0000) >> 16]\n\n        self.scaleXId = self.id * 2005\n        self.scaleColorXId = [(self.scaleXId & 0x000000FF) >> 0, (self.scaleXId & 0x0000FF00) >> 8, (self.scaleXId & 0x00FF0000) >> 16]\n        self.scaleYId = self.id * 2007\n        self.scaleColorYId = [(self.scaleYId & 0x000000FF) >> 0, (self.scaleYId & 0x0000FF00) >> 8, (self.scaleYId & 0x00FF0000) >> 16]\n        self.scaleZId = self.id * 2009\n        self.scaleColorZId = [(self.scaleZId & 0x000000FF) >> 0, (self.scaleZId & 0x0000FF00) >> 8, (self.scaleZId & 0x00FF0000) >> 16]\n        self.scaleXYZId = self.id * 2011\n        self.scaleColorXYZId = [(self.scaleXYZId & 0x000000FF) >> 0, (self.scaleXYZId & 0x0000FF00) >> 8, (self.scaleXYZId & 0x00FF0000) >> 16]\n\n        self.parent = None\n        #structural data\n        self.v0 = []\n        self.v1 = []\n        self.v2 = []\n\n        self.t0 = []\n        self.t1 = []\n        self.t2 = []\n\n        self.n0 = []\n        self.n1 = []\n        self.n2 = []\n\n        self.tex = np.array([])\n        self.wipe_tower_texture = None\n\n        self.rotationAxis = []\n        self.scaleAxis = []\n\n        self.dataTmp = []\n\n        self.normal = []\n        self.displayList = []\n\n        self.mesh = None\n        self.temp_mesh = None\n        self.vao = None\n\n        #multimaterial upgrade\n        self.is_multipart_model = False\n        self.multipart_parent = []\n        self.extruder = 1\n        self.is_wipe_tower = False\n\n        self.texture_size = 16\n        self.variable_texture_data = np.full((self.texture_size*self.texture_size*4), 255, dtype=np.int)\n        self.variable_layer_height_data = np.zeros((11), dtype=np.float32)\n\n        self.variable_texture = []\n\n\n        #transformation data, connected to scene\n        self.pos = np.array([.0, .0, .0])\n        self.pos_old = np.array([.0, .0, .0])\n        self.rot = np.array([.0, .0, .0])\n        self.rot_scene = np.array([.0, .0, .0])\n        self.scale = np.array([1., 1., 1.])\n        self.old_scale = np.array([1., 1., 1.])\n        self.scaleDefault = [.1, .1, .1]\n\n        self.min_scene = np.array([.0, .0, .0])\n        self.max_scene = np.array([.0, .0, .0])\n\n        #history state\n        self.pos_hist = np.array([.0, .0, .0])\n        self.rot_hist = np.array([.0, .0, .0])\n        self.scale_hist = np.array([1., 1., 1.])\n        #history state\n\n        self.scale_matrix = np.array([[ 1.,  0.,  0.],\n                                            [ 0.,  1.,  0.],\n                                            [ 0.,  0.,  1.]])\n        self.temp_scale = np.array([[ 1.,  0.,  0.],\n                                            [ 0.,  1.,  0.],\n                                            [ 0.,  0.,  1.]])\n\n        self.rotation_matrix = np.array([[ 1.,  0.,  0.],\n                                            [ 0.,  1.,  0.],\n                                            [ 0.,  0.,  1.]])\n        self.temp_rotation = np.array([[ 1.,  0.,  0.],\n                                            [ 0.,  1.,  0.],\n                                            [ 0.,  0.,  1.]])\n\n        self.tiled_normals = np.array([])\n\n        #helping data\n        self.selected = False\n        self.boundingSphereSize = .0\n        self.boundingSphereCenter = np.array([.0, .0, .0])\n        self.boundingBox = []\n        self.boundingMinimalPoint = [.0, .0, .0]\n        self.zeroPoint = np.array([.0, .0, .0])\n        self.min = np.array([.0, .0, .0])\n        self.max = np.array([.0, .0, .0])\n        self.max_bs = np.array([0.])\n        self.size = np.array([.0, .0, .0])\n        self.size_origin = np.array([.0, .0, .0])\n\n        #status of object\n        self.is_changed = True\n\n        #source file data\n        #example car.stl\n        self.filename = """"\n        self.normalization_flag = False\n\n        #self.recalculate_texture()\n\n\n    def __deepcopy__(self, memodict={}):\n        m = Model()\n\n        m.filename = deepcopy(self.filename)\n        m.mesh = deepcopy(self.mesh)\n        m.normal = deepcopy(self.normal)\n\n        m.pos = deepcopy(self.pos)\n        m.scale = deepcopy(self.scale)\n        m.rot = deepcopy(self.rot)\n\n        m.tiled_normals = deepcopy(self.tiled_normals)\n        m.parent = self.parent\n\n        m.min = deepcopy(self.min)\n        m.max = deepcopy(self.max)\n\n        m.v0 = deepcopy(self.v0)\n        m.v1 = deepcopy(self.v1)\n        m.v2 = deepcopy(self.v2)\n\n        m.t0 = deepcopy(self.v0)\n        m.t1 = deepcopy(self.t1)\n        m.t2 = deepcopy(self.t2)\n\n        m.n0 = deepcopy(self.n0)\n        m.n1 = deepcopy(self.n1)\n        m.n2 = deepcopy(self.n2)\n\n        m.extruder = self.extruder\n\n        m.min_scene = deepcopy(self.min_scene)\n        m.max_scene = deepcopy(self.max_scene)\n\n        m.size = deepcopy(self.size)\n        m.size_origin = deepcopy(self.size_origin)\n\n        m.boundingSphereSize = deepcopy(self.boundingSphereSize)\n        m.boundingSphereCenter = deepcopy(self.boundingSphereCenter)\n        m.boundingBox = deepcopy(self.boundingBox)\n        m.boundingMinimalPoint = deepcopy(self.boundingMinimalPoint)\n        m.zeroPoint = deepcopy(self.zeroPoint)\n\n        m.normalization_flag = deepcopy(self.normalization_flag)\n\n        m.temp_mesh = deepcopy(self.mesh)\n        return m\n\n\n    def get_id(self):\n        return self.id\n\n    def set_extruder(self, extruder_number):\n        self.extruder = extruder_number\n\n\n    def reset_transformation(self):\n        if self.is_multipart_model:\n            self.multipart_parent.scale[0] = 1.\n            self.multipart_parent.scale[1] = 1.\n            self.multipart_parent.scale[2] = 1.\n\n            self.multipart_parent.rot[0] = 0.\n            self.multipart_parent.rot[1] = 0.\n            self.multipart_parent.rot[2] = 0.\n\n            self.multipart_parent.pos[0] = 0.\n            self.multipart_parent.pos[1] = 0.\n\n            #TODO:\n            self.multipart_parent.update_min_max()\n            self.multipart_parent.place_on_zero()\n\n        elif self.is_wipe_tower:\n            printer_parameters = self.parent.controller.printing_parameters.get_printer_parameters(\n                self.parent.controller.actual_printer)\n\n            size_x = self.parent.wipe_tower_size_x\n            size_y = self.parent.wipe_tower_size_y * self.parent.wipe_tower_number_of_section\n\n            self.pos[0] = (printer_parameters[\'printing_space\'][0]*.05)-(size_x*.05)-1.\n            self.pos[1] = (printer_parameters[\'printing_space\'][1]*.05)-(size_y*.05)-1.\n\n            self.parent.is_wipe_tower_position_manual = False\n        else:\n            self.scale[0] = 1.\n            self.scale[1] = 1.\n            self.scale[2] = 1.\n\n            self.rot[0] = 0.\n            self.rot[1] = 0.\n            self.rot[2] = 0.\n\n            self.pos[0] = 0.\n            self.pos[1] = 0.\n\n            self.update_min_max()\n            self.place_on_zero()\n\n        self.parent.controller.update_wipe_tower()\n\n\n    def calculate_normal_groups(self):\n        actual_id = 0\n        id=0\n\n        #d = defaultdict(int)\n\n        self.mesh.normals = np.array([n for n in self.mesh.normals])\n\n        Vect = namedtuple(""Vect"", [""x"", ""y"", ""z""])\n        d = {}\n\n\n        for normal in self.mesh.normals:\n            if Vect(self.str_c(normal[0]), self.str_c(normal[1]), self.str_c(normal[2])) in d:\n                id = d[Vect(self.str_c(normal[0]), self.str_c(normal[1]), self.str_c(normal[2]))]\n            else:\n                d[Vect(self.str_c(normal[0]), self.str_c(normal[1]), self.str_c(normal[2]))] = actual_id\n                actual_id += 1\n\n\n        self.face_colors = [[[(d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x000000FF) >> 0,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x0000FF00) >> 8,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x00FF0000) >> 16],\n                                      [(d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x000000FF) >> 0,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x0000FF00) >> 8,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x00FF0000) >> 16],\n                                      [(d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x000000FF) >> 0,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x0000FF00) >> 8,\n                                       (d[Vect(self.str_c(i[0]), self.str_c(i[1]), self.str_c(i[2]))] & 0x00FF0000) >> 16]] for i in self.mesh.normals]\n\n\n    def str_c(self, input):\n        if input == 0.0:\n            input = 0.0\n        return str(input)\n\n    def clear_state(self):\n        self.is_changed = False\n\n    def changing(self):\n        self.is_changed = True\n\n    def is_in_printing_space(self, printer):\n        if self.is_multipart_model:\n            min = deepcopy(self.multipart_parent.min_scene)\n            max = deepcopy(self.multipart_parent.max_scene)\n        else:\n            min = deepcopy(self.min_scene)\n            max = deepcopy(self.max_scene)\n\n        if max[0] <= (printer[\'printing_space\'][0]*.05) and min[0] >= (printer[\'printing_space\'][0]*-.05):\n                if max[1] <= (printer[\'printing_space\'][1]*.05) and min[1] >= (printer[\'printing_space\'][1]*-.05):\n                    if max[2] <= printer[\'printing_space\'][2]*0.1 and min[2] >= -0.1:\n                        #print(""Printing space[2] "" + str(printer[\'printing_space\'][2]))\n                        self.is_in_printing_area = True\n                        return True\n                    else:\n                        #print(""naruseni v Z"")\n                        self.is_in_printing_area = False\n                        return False\n                else:\n                    #print(""naruseni v Y"")\n                    self.is_in_printing_area = False\n                    return False\n        else:\n            #print(""naruseni v X"")\n            self.is_in_printing_area = False\n            return False\n\n    #@timing\n    def get_mesh(self, transform=True, generate_gcode=False, default_scale=True):\n        data = np.zeros(len(self.mesh.vectors), dtype=Mesh.dtype)\n\n        vectors = self.mesh.vectors.copy()\n\n        rx_matrix = Mesh.rotation_matrix([1.0, 0.0, 0.0], self.rot[0])\n        ry_matrix = Mesh.rotation_matrix([0.0, 1.0, 0.0], self.rot[1])\n        rz_matrix = Mesh.rotation_matrix([0.0, 0.0, 1.0], self.rot[2])\n\n        rotation_matrix = np.dot(np.dot(rx_matrix, ry_matrix), rz_matrix)\n\n        scale_matrix = np.array([[1., 0., 0.],\n                                 [0., 1., 0.],\n                                 [0., 0., 1.]]) * self.scale\n\n\n        final_rotation = rotation_matrix\n        final_scale = scale_matrix\n        #final_matrix = np.dot(final_rotation, final_scale)\n        final_matrix = np.dot(final_scale, final_rotation)\n\n\n        if transform and generate_gcode:\n            for i in range(3):\n                vectors[:, i] = vectors[:, i].dot(final_matrix)\n\n            printer = self.parent.controller.printing_parameters.get_printer_parameters(self.parent.controller.actual_printer)\n            #print(""Printer: "" + str(printer))\n            vectors += self.pos + (np.array([printer[\'printing_space\'][0]*0.5*.1,\n                                             printer[\'printing_space\'][1]*0.5*.1,\n                                             printer[\'printing_space\'][2]*0.5*.1]))\n        elif transform and not generate_gcode:\n            vectors += self.pos\n\n        if default_scale:\n            vectors /= np.array(self.scaleDefault)\n\n        data[\'vectors\'] = vectors\n\n        return Mesh(data)\n\n    def get_pos(self):\n        if self.is_multipart_model:\n            return self.multipart_parent.pos\n        else:\n            return self.pos\n\n    def normalize_object(self):\n        #vektor od nuly po boundingSphereCenter, tedy rozdil ktery je potreba pricist ke vsem souradnicim\n        r = np.array([.0, .0, .0]) - np.array(self.boundingSphereCenter)\n\n        self.mesh.vectors = self.mesh.vectors + r\n\n        self.mesh.update_min()\n        self.mesh.update_max()\n        self.min = self.mesh.min_\n        self.max = self.mesh.max_\n\n        self.boundingSphereCenter = np.array(self.boundingSphereCenter) + r\n\n        self.zeroPoint = np.array(self.zeroPoint) + r\n        self.zeroPoint[2] = self.min[2]\n\n        self.pos = np.array([.0, .0, .0]) - self.zeroPoint\n        self.zeroPoint[2] = 0.\n\n        print(""N Zero point: "" +str(self.zeroPoint))\n        print(""N Possition: "" + str(self.pos))\n\n        self.normalization_flag = True\n\n    def set_2d_pos(self, vector):\n        vector = np.array(vector)\n        if self.is_multipart_model:\n            self.multipart_parent.pos[0] = vector[0]\n            self.multipart_parent.pos[1] = vector[1]\n\n            #self.multipart_parent.min_scene = self.multipart_parent.min + self.multipart_parent.pos\n            #self.multipart_parent.max_scene = self.multipart_parent.max + self.multipart_parent.pos\n\n            self.multipart_parent.update_min_max_quick_for_move()\n        else:\n            self.pos[0] = vector[0]\n            self.pos[1] = vector[1]\n\n            self.min_scene = self.min + self.pos\n            self.max_scene = self.max + self.pos\n\n\n\n    def set_move(self, vector, add=True, place_on_zero=False):\n        vector = np.array(vector)\n\n        if self.is_wipe_tower:\n            self.parent.is_wipe_tower_position_manual = True\n\n        if self.is_multipart_model:\n            if add:\n                self.multipart_parent.pos += vector\n            else:\n                self.multipart_parent.pos = vector\n\n            #TODO:\n            #self.multipart_parent.update_min_max()\n            self.multipart_parent.update_min_max_quick_for_move()\n\n\n            if place_on_zero:\n                #TODO:\n                self.multipart_parent.place_on_zero()\n        else:\n            if add:\n                self.pos += vector\n            else:\n                self.pos = vector\n        #self.parent.controller.show_message_on_status_bar(""Place on %s %s"" % (\'{:.2}\'.format(self.pos[0]), \'{:.2}\'.format(self.pos[1])))\n\n            self.min_scene = self.min + self.pos\n            self.max_scene = self.max + self.pos\n\n            if place_on_zero:\n                self.place_on_zero()\n\n    def make_normals(self):\n        self.tiled_normals = np.tile(self.mesh.normals, 3)\n\n    def apply_rotation(self):\n        self.rotation_matrix = np.dot(self.rotation_matrix, self.temp_rotation)\n        self.temp_rotation = np.array([[ 1.,  0.,  0.],\n                                        [ 0.,  1.,  0.],\n                                        [ 0.,  0.,  1.]])\n\n    def set_scale(self, value):\n        printing_space = self.parent.controller.actual_printer[\'printing_space\']\n        new_size = np.dot(self.size_origin, self.scale_matrix*value)\n        if new_size[0] < printing_space[0]*0.98 and new_size[1] < printing_space[1]*0.98 and new_size[2] < printing_space[2]*0.98 and new_size[0] > 0.5 and new_size[1] > 0.5 and new_size[2] > 0.5:\n            self.temp_scale = np.array([[ 1.,  0.,  0.],\n                                        [ 0.,  1.,  0.],\n                                        [ 0.,  0.,  1.]]) * value\n            self.is_changed = True\n\n\n    def get_maximal_z(self):\n        return self.max_scene[2]\n\n\n\n    def place_on_zero(self):\n        min = self.min_scene\n        max = self.max_scene\n        pos = self.pos\n\n        if min[2] < 0.0:\n            diff = min[2] * -1.0\n            pos[2]+=diff\n            self.pos = pos\n        elif min[2] > 0.0:\n            diff = min[2] * -1.0\n            pos[2]+=diff\n            self.pos = pos\n\n        self.min_scene = self.min + pos\n        self.max_scene = self.max + pos\n\n\n    #@timing\n    def set_rot(self, x, y, z, add=False, update_min_max=True, place_on_zero=True):\n        self.is_changed = True\n\n        if self.is_multipart_model:\n            if add:\n                self.multipart_parent.rot[0] += x\n                self.multipart_parent.rot[1] += y\n                self.multipart_parent.rot[2] += z\n            else:\n                self.multipart_parent.rot[0] = x\n                self.multipart_parent.rot[1] = y\n                self.multipart_parent.rot[2] = z\n\n\n            if update_min_max:\n                self.multipart_parent.update_min_max()\n            if place_on_zero:\n                self.multipart_parent.place_on_zero()\n        else:\n            if add:\n                self.rot[0] += x\n                self.rot[1] += y\n                self.rot[2] += z\n            else:\n                self.rot[0] = x\n                self.rot[1] = y\n                self.rot[2] = z\n\n\n            if update_min_max:\n                self.update_min_max()\n            if place_on_zero:\n                self.place_on_zero()\n\n    def set_scale_abs(self, x, y, z):\n        #printer = self.parent.controller.printing_parameters.get_printer_parameters(self.parent.controller.actual_printer)\n        #if (x * self.size_origin[0] > .5) and (y * self.size_origin[1] > .5) and (z * self.size_origin[2] > .5)\\\n        #    and (x * self.size_origin[0] < printer[\'printing_space\'][0]*.1) and\\\n        #        (y * self.size_origin[1] < printer[\'printing_space\'][1]*.1) and\\\n        #        (z * self.size_origin[2] < printer[\'printing_space\'][2]*.1):\n\n        if self.is_multipart_model:\n            self.multipart_parent.old_scale = deepcopy(self.multipart_parent.scale)\n\n            self.multipart_parent.scale[0] = x\n            self.multipart_parent.scale[1] = y\n            self.multipart_parent.scale[2] = z\n\n            self.multipart_parent.update_min_max_quick_change_of_scale()\n\n            self.multipart_parent.place_on_zero()\n\n        else:\n            self.old_scale = deepcopy(self.scale)\n\n            self.scale[0] = x\n            self.scale[1] = y\n            self.scale[2] = z\n\n            #self.update_min_max()\n            self.update_min_max_quick_change_of_scale()\n            self.place_on_zero()\n\n    def set_scale_coef(self, coef):\n        self.old_scale = deepcopy(self.scale)\n\n        self.scale *= coef\n\n        # self.update_min_max()\n        self.update_min_max_quick_change_of_scale()\n        self.place_on_zero()\n\n    def update_position(self):\n        self.update_min_max()\n        if self.min[2] < 0.:\n            len = self.min[2] * -1.0\n            self.pos[2]+=len\n            self.update_min_max()\n\n    #@timing\n    def update_min_max(self):\n        #self.temp_mesh = deepcopy(self.mesh)\n        if self.is_multipart_model:\n            rx_matrix = Mesh.rotation_matrix([1.0, 0.0, 0.0], self.multipart_parent.rot[0])\n            ry_matrix = Mesh.rotation_matrix([0.0, 1.0, 0.0], self.multipart_parent.rot[1])\n            rz_matrix = Mesh.rotation_matrix([0.0, 0.0, 1.0], self.multipart_parent.rot[2])\n\n            rotation_matrix = np.dot(np.dot(rx_matrix, ry_matrix), rz_matrix)\n\n            scale_matrix = np.array([[1., 0., 0.],\n                                     [0., 1., 0.],\n                                     [0., 0., 1.]]) * self.multipart_parent.scale\n\n            final_rotation = rotation_matrix\n            final_scale = scale_matrix\n            # final_matrix = np.dot(final_rotation, final_scale)\n            final_matrix = np.dot(final_scale, final_rotation)\n\n            for i in range(3):\n                self.temp_mesh.vectors[:, i] = self.mesh.vectors[:, i].dot(final_matrix)\n\n            # self.temp_mesh.normals = self.mesh.normals.dot(final_rotation)\n\n            self.temp_mesh.update_min()\n            self.temp_mesh.update_max()\n            self.min = self.temp_mesh.min_\n            self.max = self.temp_mesh.max_\n\n            self.size = self.max - self.min\n            self.max_bs = np.linalg.norm(self.size[:2]) * 0.5\n\n            self.min_scene = self.min + self.multipart_parent.pos\n            self.max_scene = self.max + self.multipart_parent.pos\n        else:\n            rx_matrix = Mesh.rotation_matrix([1.0, 0.0, 0.0], self.rot[0])\n            ry_matrix = Mesh.rotation_matrix([0.0, 1.0, 0.0], self.rot[1])\n            rz_matrix = Mesh.rotation_matrix([0.0, 0.0, 1.0], self.rot[2])\n\n            rotation_matrix = np.dot(np.dot(rx_matrix, ry_matrix), rz_matrix)\n\n            scale_matrix = np.array([[1., 0., 0.],\n                                 [0., 1., 0.],\n                                 [0., 0., 1.]]) * self.scale\n\n            final_rotation = rotation_matrix\n            final_scale = scale_matrix\n            #final_matrix = np.dot(final_rotation, final_scale)\n            final_matrix = np.dot(final_scale, final_rotation)\n\n            for i in range(3):\n                self.temp_mesh.vectors[:, i] = self.mesh.vectors[:, i].dot(final_matrix)\n\n            #self.temp_mesh.normals = self.mesh.normals.dot(final_rotation)\n\n            self.temp_mesh.update_min()\n            self.temp_mesh.update_max()\n            self.min = self.temp_mesh.min_\n            self.max = self.temp_mesh.max_\n\n            self.size = self.max - self.min\n            self.max_bs = np.linalg.norm(self.size[:2]) * 0.5\n\n            self.min_scene = self.min + self.pos\n            self.max_scene = self.max + self.pos\n\n\n    def update_min_max_quick_change_of_scale(self):\n        diff_scale = np.array([self.scale[0] / self.old_scale[0],\n                                self.scale[1] / self.old_scale[1],\n                                self.scale[2] / self.old_scale[2]])\n\n        self.max *= diff_scale\n        self.min *= diff_scale\n\n        self.size = self.max - self.min\n        self.max_bs = np.linalg.norm(self.size[:2]) *0.5\n\n        self.min_scene = self.min + self.pos\n        self.max_scene = self.max + self.pos\n\n\n    #def sort_triangles(self, cam_pos):\n    #    self.mesh\n\n\n    def recalc_bounding_sphere(self):\n        max_l = np.linalg.norm(self.max)\n        min_l = np.linalg.norm(self.min)\n        if max_l > min_l:\n            self.boundingSphereSize = max_l\n        else:\n            self.boundingSphereSize = min_l\n\n    def put_array_to_gl(self):\n        glNormalPointerf(self.tiled_normals)\n        #print(""Data normals:"")\n        #pprint(self.face_colors)\n        #print(""Data vectors:"")\n        #pprint(self.mesh.vectors)\n        #glColorPointerf(self.face_colors)\n        #if self.is_wipe_tower:\n        #    glTexCoordPointerf(self.tex)\n\n        glVertexPointerf(self.mesh.vectors)\n\n        #glNormalPointerf(np.tile(self.draw_mesh[\'normals\'], 3))\n        #glVertexPointerf(self.draw_mesh[\'vectors\'])\n\n    def render(self, picking=False, gcode_preview=False):\n        is_special_blending = self.is_wipe_tower\n        is_in_printing_space = True\n\n        if not self.isVisible:\n            return\n        glPushMatrix()\n\n        if self.parent.controller.settings[\'debug\']:\n            glPointSize(5.0)\n            glColor3f(1., .0, .0)\n\n            if self.is_multipart_model:\n                min_scene = self.multipart_parent.min_scene\n                max_scene = self.multipart_parent.max_scene\n            else:\n                min_scene = self.min_scene\n                max_scene = self.max_scene\n\n            glBegin(GL_POINTS)\n            glVertex3f(min_scene[0], min_scene[1], min_scene[2])\n            glVertex3f(max_scene[0], min_scene[1], min_scene[2])\n            glVertex3f(min_scene[0], max_scene[1], min_scene[2])\n            glVertex3f(min_scene[0], min_scene[1], max_scene[2])\n            glVertex3f(max_scene[0], min_scene[1], max_scene[2])\n            glVertex3f(max_scene[0], max_scene[1], min_scene[2])\n            glVertex3f(min_scene[0], max_scene[1], max_scene[2])\n            glVertex3f(max_scene[0], max_scene[1], max_scene[2])\n            glEnd()\n\n            glColor3f(.0, .0, 1.)\n            glBegin(GL_POINTS)\n            glVertex3f(self.zeroPoint[0], self.zeroPoint[1], self.zeroPoint[2])\n            glEnd()\n\n        if self.is_multipart_model:\n            #glTranslatef(self.multipart_parent.pos[0] + self.pos[0],\n            #             self.multipart_parent.pos[1] + self.pos[1],\n            #             self.multipart_parent.pos[2] + self.pos[2])\n            glTranslatef(self.multipart_parent.pos[0],\n                         self.multipart_parent.pos[1],\n                         self.multipart_parent.pos[2])\n        else:\n            glTranslatef(self.pos[0], self.pos[1], self.pos[2])\n\n\n        if self.is_multipart_model:\n            rx_matrix = Mesh.rotation_matrix([1.0, 0.0, 0.0], self.multipart_parent.rot[0])\n            ry_matrix = Mesh.rotation_matrix([0.0, 1.0, 0.0], self.multipart_parent.rot[1])\n            rz_matrix = Mesh.rotation_matrix([0.0, 0.0, 1.0], self.multipart_parent.rot[2])\n        else:\n            rx_matrix = Mesh.rotation_matrix([1.0, 0.0, 0.0], self.rot[0])\n            ry_matrix = Mesh.rotation_matrix([0.0, 1.0, 0.0], self.rot[1])\n            rz_matrix = Mesh.rotation_matrix([0.0, 0.0, 1.0], self.rot[2])\n\n        rotation_matrix = np.dot(np.dot(rx_matrix, ry_matrix), rz_matrix)\n\n        if self.is_multipart_model:\n            scale_matrix = np.array([[ 1.,  0.,  0.],\n                                        [ 0.,  1.,  0.],\n                                        [ 0.,  0.,  1.]]) * self.multipart_parent.scale\n        else:\n            scale_matrix = np.array([[ 1.,  0.,  0.],\n                                        [ 0.,  1.,  0.],\n                                        [ 0.,  0.,  1.]]) * self.scale\n\n        final_rotation = rotation_matrix\n        final_scale = scale_matrix\n        #final_matrix = np.dot(final_rotation, final_scale)\n        final_matrix = np.dot(final_scale, final_rotation)\n\n        glMultMatrixf(self.matrix3_to_matrix4(final_matrix))\n\n        #m = np.array([1.,0.,0.,0.,\n        #          0.,1.,0.,0.,\n        #          0.,0.,1.,0.,\n        #          0.,0.,0.,1.0])\n        #glGetFloatv(GL_MODELVIEW_MATRIX, m)\n        #print(str(m))\n\n\n        self.put_array_to_gl()\n\n        glEnableClientState(GL_VERTEX_ARRAY)\n        #if self.is_wipe_tower:\n        #    glEnableClientState(GL_TEXTURE_COORD_ARRAY)\n        glEnableClientState(GL_NORMAL_ARRAY)\n\n        if picking:\n            glDisable(GL_BLEND)\n            glDisable(GL_LIGHTING)\n            #glDisable(GL_TEXTURE_2D)\n            glDisable(GL_TEXTURE_GEN_S)\n            glDisable(GL_TEXTURE_GEN_T)\n        elif gcode_preview and not self.is_wipe_tower:\n            glDisable(GL_BLEND)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_TEXTURE_GEN_S)\n            glDisable(GL_TEXTURE_GEN_T)\n        elif gcode_preview and self.is_wipe_tower:\n            glEnable(GL_TEXTURE_GEN_S)\n            glEnable(GL_TEXTURE_GEN_T)\n\n            SplaneCoefficients = [0., 0.25, 0.25, 0.]\n            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR)\n            glTexGenfv(GL_S, GL_EYE_PLANE, SplaneCoefficients)\n            glTexGenfv(GL_S, GL_OBJECT_PLANE, SplaneCoefficients)\n\n            TplaneCoefficients = [0.25, 0., 0, 0.]\n            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR)\n            glTexGenfv(GL_T, GL_EYE_PLANE, TplaneCoefficients)\n            glTexGenfv(GL_T, GL_OBJECT_PLANE, TplaneCoefficients)\n\n            glEnable(GL_TEXTURE_2D)\n            glBindTexture(GL_TEXTURE_2D, self.wipe_tower_texture)\n        elif self.is_wipe_tower:\n            glEnable(GL_BLEND)\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_DEPTH_TEST)\n\n            glEnable(GL_TEXTURE_GEN_S)\n            glEnable(GL_TEXTURE_GEN_T)\n\n\n            SplaneCoefficients = [0., 0.25, 0.25, 0.]\n            glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR)\n            glTexGenfv(GL_S, GL_EYE_PLANE, SplaneCoefficients)\n            glTexGenfv(GL_S, GL_OBJECT_PLANE, SplaneCoefficients)\n\n            TplaneCoefficients = [0.25, 0., 0, 0.]\n            glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR)\n            glTexGenfv(GL_T, GL_EYE_PLANE, TplaneCoefficients)\n            glTexGenfv(GL_T, GL_OBJECT_PLANE, TplaneCoefficients)\n\n\n            glEnable(GL_TEXTURE_2D)\n            glBindTexture(GL_TEXTURE_2D, self.wipe_tower_texture)\n        else:\n            #glEnable(GL_TEXTURE_2D)\n            #glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)\n            glDisable(GL_BLEND)\n            glEnable(GL_LIGHTING)\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_TEXTURE_GEN_S)\n            glDisable(GL_TEXTURE_GEN_T)\n            #glEnable(GL_CULL_FACE)\n\n        if picking:\n            glColor3ubv(self.colorId)\n        else:\n            if gcode_preview:\n                if self.parent.controller.is_multimaterial() and not self.parent.controller.is_single_material_mode():\n                    if self.is_wipe_tower:\n                        glColor4ub(175, 175, 175, 150)\n                    else:\n                        #c = self.parent.controller.get_extruder_color(self.extruder)\n                        #glColor3ub(c.red(), c.green(), c.blue())\n                        glColor4ub(175, 175, 175, 150)\n                else:\n                    glColor4ub(175, 175, 175, 150)\n            else:\n                if self.selected:\n                    glColor4ubv(self.select_color)\n                else:\n                    if self.is_in_printing_space(self.parent.controller.printing_parameters.get_printer_parameters(self.parent.controller.actual_printer)):\n                        if self.parent.controller.is_multimaterial() and not self.parent.controller.is_single_material_mode() and not self.is_wipe_tower:\n                            c = self.parent.controller.get_extruder_color(self.extruder)\n                            glColor3ub(c.red(), c.green(), c.blue())\n                        else:\n                            glColor4ubv(self.color)\n                    else:\n                        glColor4f(0.25, 0.25, 0.25, 1.)\n\n\n        glDrawArrays(GL_TRIANGLES, 0, len(self.mesh.vectors) * 3)\n\n        glDisable(GL_TEXTURE_2D)\n\n\n        glDisableClientState(GL_VERTEX_ARRAY)\n        #if not picking:\n        #    glDisableClientState(GL_COLOR_ARRAY)\n        #if self.is_wipe_tower:\n        #    glDisableClientState(GL_TEXTURE_COORD_ARRAY)\n        glDisableClientState(GL_NORMAL_ARRAY)\n\n        if self.is_in_printing_area == False:\n            #font = self.parent.controller.view.font\n            #font.setPointSize(35)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_DEPTH_TEST)\n            glColor3ub(255, 97, 0)\n        if gcode_preview and not self.is_wipe_tower:\n            glCullFace(GL_BACK)\n            glDisable(GL_CULL_FACE)\n            glDisable(GL_BLEND)\n            glEnable(GL_LIGHTING)\n            glEnable(GL_DEPTH_TEST)\n        elif gcode_preview and self.is_wipe_tower:\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n            glEnable(GL_LIGHTING)\n            glDisable(GL_TEXTURE_GEN_S)\n            glDisable(GL_TEXTURE_GEN_T)\n        elif self.is_wipe_tower:\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n            glEnable(GL_LIGHTING)\n            glDisable(GL_TEXTURE_GEN_S)\n            glDisable(GL_TEXTURE_GEN_T)\n        else:\n            #glDisable(GL_CULL_FACE)\n            #glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE)\n            #glCullFace(GL_FRONT)\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n            glEnable(GL_LIGHTING)\n            glEnable(GL_DEPTH_TEST)\n\n        glPopMatrix()\n\n\n\n    def matrix3_to_matrix4(self, matrix3):\n        mat = [i+[0.] for i in matrix3.tolist()]\n        mat += [[0.,0.,0.,1.]]\n        return mat\n\n\n    def make_display_list(self):\n        #vert = [[ 1., 0., 0.], [ 0., 1., 0.], [ 1., 1., 0.]]\n        #norm = [[ 0., 0., 1.], [ 0., 0., 1.], [ 0., 0., 1.]]\n\n\n        genList = glGenLists(1)\n\n        glEnableClientState(GL_VERTEX_ARRAY)\n        glEnableClientState(GL_NORMAL_ARRAY)\n\n        glNormalPointerf(np.tile(self.mesh.normals, 3))\n        glVertexPointerf(self.mesh.vectors)\n\n        #glNormalPointerf(norm)\n        #glVertexPointerf(vert)\n\n\n        glNewList(genList, GL_COMPILE)\n\n        glDrawArrays(GL_TRIANGLES, 0, len(self.mesh.vectors)*3)\n\n        glEndList()\n\n        glDisableClientState(GL_VERTEX_ARRAY)\n        glDisableClientState(GL_NORMAL_ARRAY)\n\n        return genList\n\n    def intersection_model_model_by_BB(self, model):\n        #intersection by collision of BB\n        min = self.min_scene\n        max = self.max_scene\n        model_min = model.min_scene\n        model_max = model.max_scene\n        d = self.parent.model_position_offset\n        #print(""intersection model model: "" + str(d))\n        return not(max[0]+d<model_min[0] or model_max[0]<min[0]-d or max[1]+d<model_min[1] or model_max[1]<min[1]-d)\n\n    def intersection_model_list_model_(self, list):\n        for m in list:\n            if m.isVisible:\n                if self.intersection_model_model_by_BB(m):\n                    return True\n        return False\n\n    #@timing\n    def intersectionRayModel(self, rayStart, rayEnd):\n        ray = rayEnd - rayStart\n        ray /= np.linalg.norm(ray)\n\n        data = self.temp_mesh\n\n        counter = 0\n        for tri in data.vectors+self.pos:\n            b = [.0, .0, .0]\n\n            e1 = tri[1]\n            e1 -= tri[0]\n            e2 = tri[2]\n            e2 -= tri[0]\n\n            n = self.temp_mesh.normals[counter]\n\n            q = np.cross(ray, e2)\n            a = np.dot(e1, q)\n\n            counter += 1\n            if (np.dot(n, ray) >= .0) or (abs(a) <= .0001):\n                continue\n\n            s = np.array(rayStart)\n            s -= tri[0]\n            s /= a\n\n            r = np.cross(s, e1)\n            b[0] = np.dot(s, q)\n            b[1] = np.dot(r, ray)\n            b[2] = 1.0 - b[0] - b[1]\n\n            if (b[0] < .0) or (b[1] < .0) or (b[2] < .0):\n                continue\n\n            t = np.dot(e2, r)\n            if t >= .0:\n                point = rayStart + t*ray\n                return True, point\n            else:\n                continue\n        return False, None\n\n    #@timing\n    def intersectionRayModel2(self, rayStart, rayEnd):\n        ray = rayEnd - rayStart\n        ray /= np.linalg.norm(ray)\n\n        # data = self.get_mesh(True, False, False)\n        data = self.temp_mesh\n\n        tri_0 = data.vectors[:, 0]\n        tri_1 = data.vectors[:, 1]\n        tri_2 = data.vectors[:, 2]\n\n        e1 = tri_1\n        e1 -= tri_0\n        e2 = tri_2\n        e2 -= tri_0\n\n        n = data.normals\n\n        q = np.cross(ray, e2)\n        a = np.dot(e1, q)\n\n\n\n\n        counter = 0\n        for tri in data.vectors + self.pos:\n            # for tri in np.nditer(data.vectors):\n\n            # v0 = tri[0]# + self.pos\n            # v1 = tri[1]# + self.pos\n            # v2 = tri[2]# + self.pos\n\n            b = [.0, .0, .0]\n            # e1 = np.array(v1)\n            # e1 -= v0\n            # e2 = np.array(v2)\n            # e2 -= v0\n\n            e1 = tri[1]\n            e1 -= tri[0]\n            e2 = tri[2]\n            e2 -= tri[0]\n\n            n = self.temp_mesh.normals[counter]\n\n            q = np.cross(ray, e2)\n            a = np.dot(e1, q)\n\n            counter += 1\n            if (np.dot(n, ray) >= .0) or (abs(a) <= .0001):\n                continue\n\n            s = np.array(rayStart)\n            s -= tri[0]\n            s /= a\n\n            r = np.cross(s, e1)\n            b[0] = np.dot(s, q)\n            b[1] = np.dot(r, ray)\n            b[2] = 1.0 - b[0] - b[1]\n\n            if (b[0] < .0) or (b[1] < .0) or (b[2] < .0):\n                continue\n\n            t = np.dot(e2, r)\n            if t >= .0:\n                point = rayStart + t * ray\n                return tri, point\n            else:\n                continue\n        return False\n\n    #@timing\n    def intersectionRayModel3(self, rayStart, rayEnd):\n        ray = rayEnd - rayStart\n        ray /= np.linalg.norm(ray)\n\n        n = self.temp_mesh.normals\n        vectors = self.temp_mesh.vectors+self.pos\n\n        #b = np.array([0., 0., 0.])\n\n        # print(tri_1)\n\n        tri_0 = vectors[:, 0]\n        tri_1 = vectors[:, 1]\n        tri_2 = vectors[:, 2]\n\n        e1 = tri_1\n        e1 -= tri_0\n        e2 = tri_2\n        e2 -= tri_0\n\n        q = np.cross(ray, e2)\n        # a = np.dot(e1, q)\n        a = np.einsum(\'ij,ij->i\', e1, q)\n        shape_tri = tri_0.shape\n\n\n        f1 = (np.dot(n, ray) >= .0) | (np.absolute(a) <= .0001)\n        #print(""F1:"" + str(f1))\n        if not f1.any():\n            print(""Nic v F1"")\n            return False, None\n\n        s = np.tile(rayStart, shape_tri[0])\n        s = s.reshape(shape_tri)\n        s -= tri_0\n        # s = np.divide(s, a[:, None])\n        # s /= a[:, None]\n        s = np.nan_to_num(s / a[:, None])\n\n        r = np.nan_to_num(np.cross(s, e1))\n\n        # b[0] = np.dot(s, q)\n        b_0 = np.nan_to_num(np.einsum(\'ij,ij->i\', s, q))\n        # b[1] = np.dot(r, ray)\n        # b_1 = np.einsum(\'ij,ij->i\', r, ray)\n        b_1 = np.nan_to_num(np.dot(r, ray))\n        # b[2] = 1.0 - b[0] - b[1]\n        b_2 = np.nan_to_num(1.0 - b_0 - b_1)\n\n        f2 = (b_0 < .0) | (b_1 < .0) | (b_2 < .0)\n        #print(""F2:"" + str(f2))\n        if not np.logical_xor(f1, f2).any():\n            print(""Nic v F2"")\n            return False, None\n\n        # t = np.dot(e2, r)\n        t = np.nan_to_num(np.einsum(\'ij,ij->i\', e2, r))\n        f3 = (t >= 0.)\n        f_final = np.logical_xor(f1, f2, f3)\n        if not f_final.any():\n            print(""Nic v F3"")\n            return False, None\n        else:\n            #t_fin = np.min(t[f_final])\n            t_fin = t[f_final][0]*.001\n            point = rayStart + t_fin * ray\n            return True, point\n\n\n\n    #TODO:Better!!!\n    def place_on_face(self, ray_start, ray_end):\n        value = self.intersectionRayModel(np.array(ray_start), np.array(ray_end))\n        if type(value) == bool:\n            return []\n        else:\n            hit_face, normal = value\n\n        up_vector = np.array([0., 0., -1.])\n\n        #calc alpha\n        #rotation around X vector\n        normal_face_vector_tmp1 = deepcopy(normal)\n        normal_face_vector_tmp1[0] = 0.\n        alpha = AppScene.calc_angle(up_vector, normal_face_vector_tmp1)\n\n        #calc beta\n        #rotation around Y vector\n        normal_face_vector_tmp2 = deepcopy(normal)\n        normal_face_vector_tmp2[1] = 0.\n        beta = AppScene.calc_angle(up_vector, normal_face_vector_tmp2)\n\n\n        print(""Nalezeny uhly alpha %s a beta %s"" % (str(alpha), str(beta)))\n        if alpha<=beta:\n            print(""Alpha"")\n            self.set_rot(np.deg2rad(alpha), 0., 0.)\n        else:\n            print(""Beta"")\n            self.set_rot(0., np.deg2rad(beta), 0.)\n        return deepcopy(hit_face)\n\n#TODO:####\nclass MultiModel(Model):\n    \'\'\'\n    this is class for object constructed from more models(mainly for multimaterial printing)\n    \'\'\'\n    group_id_counter = itertools.count(1)\n    def __init__(self, models_lst, parent):\n        super(MultiModel, self).__init__()\n        self.group_id = next(self.group_id_counter)\n        self.models = models_lst\n        self.parent = parent\n        self.filename = ""multi""\n        self.id = [m.id for m in self.models]\n\n        #set bounding box from concated mesh\n        #Moving of whole MultiModel object, not parts\n        #get mesh by concating all models to one model\n\n        for m in self.models:\n            m.is_multipart_model = True\n            m.multipart_parent = self\n\n        #self.update_min_max()\n\n    #TODO:Nekde tady to je\n    def update_min_max(self):\n        max_lst = []\n        min_lst = []\n\n        for m in self.models:\n            m.update_min_max()\n            #m.min_scene = m.min + self.pos\n            min_lst.append((m.min))\n\n            #m.max_scene = m.max + self.pos\n            max_lst.append(m.max)\n\n        self.min = np.min(min_lst, axis=0)\n        self.max = np.max(max_lst, axis=0)\n\n        self.min_scene = self.pos + self.min\n        self.max_scene = self.pos + self.max\n\n        self.size = self.max - self.min\n\n    def update_min_max_quick_for_move(self):\n        for m in self.models:\n            m.min_scene = m.min + self.pos\n            m.max_scene = m.max + self.pos\n\n        self.max_scene = self.max + self.pos\n        self.min_scene = self.min + self.pos\n\n\n\n    def update_min_max_quick_change_of_scale(self):\n        diff_scale = np.array([self.scale[0] / self.old_scale[0],\n                               self.scale[1] / self.old_scale[1],\n                               self.scale[2] / self.old_scale[2]])\n\n        self.max *= diff_scale\n        self.min *= diff_scale\n\n        self.size = self.max - self.min\n\n        self.min_scene = self.min + self.pos\n        self.max_scene = self.max + self.pos\n\n    """"""\n    def set_2d_pos(self, vector):\n        vector = np.array(vector)\n        self.pos[0] = vector[0]\n        self.pos[1] = vector[1]\n\n        self.min_scene = self.min + self.pos\n        self.max_scene = self.max + self.pos\n    """"""\n\n    def place_on_zero(self):\n        #TODO:bug with place on zero\n        #self.update_min_max()\n\n        min = self.min_scene\n        max = self.max_scene\n\n        pos = deepcopy(self.pos)\n\n        if min[2] < 0.0:\n            diff = min[2] * -1.0\n            print(""Mensi nez 0.0: "" + str(diff))\n            pos[2] += diff\n            self.pos = pos\n        elif min[2] > 0.0:\n            diff = min[2] * -1.0\n            print(""Vetsi nez 0.0: "" + str(diff))\n            pos[2] += diff\n            self.pos = pos\n\n        self.min_scene = self.min + self.pos\n        self.max_scene = self.max + self.pos\n\n\n\n\n    def delete_models(self):\n        for m in self.models:\n            m.isVisible = False\n\n\n\n\nclass ModelTypeAbstract(object):\n    \'\'\'\n    model type is abstract class, reprezenting reading of specific model data file\n    \'\'\'\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        pass\n\n    @abstractmethod\n    def load(self, filename):\n        #logging.debug(""This is abstract model type"")\n        return None\n\nclass ModelTypeObj(ModelTypeAbstract):\n\n\n    @staticmethod\n    def load(filename):\n        logging.debug(""this is OBJ file reader"")\n        swapyz = False\n        vertices = []\n        normals = []\n        texcoords_array = []\n        faces = []\n\n        for line in open(filename, ""r""):\n            if line.startswith(\'#\'): continue\n            values = line.split()\n            if not values: continue\n            if values[0] == \'v\':\n                #print(values[1:4])\n                v = list(map(float, values[1:4]))\n                if swapyz:\n                    v = v[0], v[2], v[1]\n                vertices.append(v)\n            elif values[0] == \'vn\':\n                v = list(map(float, values[1:4]))\n                if swapyz:\n                    v = v[0], v[2], v[1]\n                normals.append(v)\n            elif values[0] == \'vt\':\n                m = list(map(float, values[1:3]))\n                texcoords_array.append(m)\n            #elif values[0] in (\'usemtl\', \'usemat\'):\n            #    material = values[1]\n            #elif values[0] == \'mtllib\':\n            #    mtl = MTL(values[1])\n            elif values[0] == \'f\':\n                face = []\n                texcoords = []\n                norms = []\n                for v in values[1:]:\n                    w = v.split(\'/\')\n                    face.append(int(w[0]))\n                    if len(w) >= 2 and len(w[1]) > 0:\n                        texcoords.append(int(w[1]))\n                    else:\n                        texcoords.append(0)\n                    if len(w) >= 3 and len(w[2]) > 0:\n                        norms.append(int(w[2]))\n                    else:\n                        norms.append(0)\n                faces.append((face, norms, texcoords))\n\n        model = Model()\n\n        if filename:\n            model.filename = basename(filename)\n        else:\n            model.filename = """"\n\n\n        #print(""Vertices N: "" + str(len(vertices)))\n        #print(""Texcoords N: "" + str(len(texcoords_array)))\n        #print(""Normals N: "" + str(len(normals)))\n        #print(""Faces N: "" + str(len(faces)))\n\n\n        for face in faces:\n            vert, norm, texcoord = face\n            #print(""Vertex indexes: "" + str(vert))\n            #print(""Texcoord indexes: "" + str(texcoord))\n            model.v0.append(vertices[vert[0] - 1])\n            model.n0.append(normals[norm[0] - 1])\n            model.t0.append(texcoords_array[texcoord[0] - 1])\n\n            model.v1.append(vertices[vert[1] - 1])\n            model.n1.append(normals[norm[1] - 1])\n            model.t1.append(texcoords_array[texcoord[1] - 1])\n\n            model.v2.append(vertices[vert[2] - 1])\n            model.n2.append(normals[norm[2] - 1])\n            model.t2.append(texcoords_array[texcoord[2] - 1])\n\n\n        return model\n\n\nclass ModelTypeStl(ModelTypeAbstract):\n    \'\'\'\n    Concrete ModelType class for STL type file, it can load binary and char file\n    \'\'\'\n\n    @staticmethod\n    def load(filename, normalize=True):\n        #logging.debug(""this is STL file reader"")\n        #print(filename)\n        mesh = Mesh.from_file(filename)\n        return ModelTypeStl.load_from_mesh(mesh, filename, normalize)\n\n    @staticmethod\n    def load_from_mesh(mesh, filename="""", normalize=True):\n        model = Model()\n\n        if filename:\n            model.filename = basename(filename)\n        else:\n            model.filename = """"\n\n        \'\'\'\n        some magic with model data...\n        I need normals, transformations...\n        \'\'\'\n\n        #mesh.normals /= np.sqrt(np.einsum(\'...i,...i\', mesh.normals, mesh.normals))\n        mesh.normals /= np.sqrt((mesh.normals ** 2).sum(-1))[..., np.newaxis]\n\n        #scale of imported data\n        mesh.points *= model.scaleDefault[0]\n\n        mesh.update_max()\n        mesh.update_min()\n        #model.recalculate_min_max()\n\n        #calculate min and max for BoundingBox and center of object\n        model.max = mesh.max_\n        model.min = mesh.min_\n\n        model.boundingSphereCenter[0] = (model.max[0] + model.min[0]) * .5\n        model.boundingSphereCenter[1] = (model.max[1] + model.min[1]) * .5\n        model.boundingSphereCenter[2] = (model.max[2] + model.min[2]) * .5\n\n        model.zeroPoint = deepcopy(model.boundingSphereCenter)\n        model.zeroPoint[2] = model.min[2]\n        #print(model.zeroPoint)\n\n        #print(str(model.zeroPoint))\n\n        model.mesh = mesh\n\n        #normalize position of object on 0\n        if normalize:\n            model.normalize_object()\n\n        model.max_bs = np.max(np.linalg.norm(model.mesh.vectors, axis=2))\n\n        max_l = np.linalg.norm(mesh.max_)\n        min_l = np.linalg.norm(mesh.min_)\n        if max_l > min_l:\n            model.boundingSphereSize = max_l\n        else:\n            model.boundingSphereSize = min_l\n\n        model.min_scene = model.min + model.pos\n        model.max_scene = model.max + model.pos\n\n        model.size = model.max-model.min\n        model.size_origin = deepcopy(model.size)\n\n        model.temp_mesh = deepcopy(model.mesh)\n        model.make_normals()\n        model.isVisible = True\n\n        #model.calculate_normal_groups()\n\n        #model.face_colors = np.array([[np.absolute(i), np.absolute(i), np.absolute(i)] for i in mesh.normals])\n\n\n        #model.displayList = model.make_display_list()\n        #model.make_vao()\n\n        gc.collect()\n\n        return model\n\n\ndef intersection_ray_plane(start, end, pos=np.array([.0, .0, .0]), n=np.array([.0, .0, 1.])):\n    r = ray.create_from_line(line.create_from_points(start, end))\n    res = geometric_tests.ray_intersect_plane(r, plane.create_from_position(-pos, n))\n    return res\n\ndef intersection_ray_plane2(O, D, P=np.array([0., 0., 0.]), N=np.array([.0, .0, 1.])):\n    # Return the distance from O to the intersection of the ray (O, D) with the\n    # plane (P, N), or +inf if there is no intersection.\n    # O and P are 3D points, D and N (normal) are normalized vectors.\n    denom = np.dot(D, N)\n    if np.abs(denom) < 1e-6:\n        return np.inf\n    d = np.dot(P - O, N) / denom\n    if d < 0:\n        return np.inf\n    res = D*d + O\n    return np.array([res[0], res[1], res[2]])\n'"
sceneRender.py,3,"b'# -*- coding: utf-8 -*-\n\n__author__ = \'Tibor Vavra\'\n\n#import inspect\n#import logging\nfrom copy import deepcopy\nfrom pprint import pprint\n\nimport OpenGL\nimport numpy as np\n\nfrom sceneData import ModelTypeStl, ModelTypeObj, MultiModel\n\nOpenGL.ERROR_CHECKING = False\nOpenGL.ERROR_LOGGING = False\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLU import *\n\nimport math\n\nimport numpy\nimport time\n\n#from PyQt4.QtCore import QTimer\n#from PyQt4.QtGui import QColor, QCursor\nfrom PyQt4.QtCore import *\nfrom PyQt4.QtGui import *\nfrom PyQt4.QtOpenGL import *\nfrom PyQt4 import QtCore\n\nfrom PIL.Image import *\n\nimport controller\n#from camera import TargetedCamera\nfrom glButton import GlButton\n\n#Mesure\ndef timing(f):\n    def wrap(*args):\n        time1 = time.time()\n        ret = f(*args)\n        time2 = time.time()\n        print(\'%s function took %0.3f ms\' % (f.func_name, (time2-time1)*1000.0))\n        return ret\n    return wrap\n\n\nclass GLWidget(QGLWidget):\n    def __init__(self, parent=None):\n        #QGLWidget.__init__(self, parent)\n        if hasattr(QGLFormat, \'setVersion\'):\n            f = QGLFormat()\n            f.setVersion(2, 1)\n            f.setDoubleBuffer(True)\n            f.setSampleBuffers(True)\n            f.setSamples(4)\n            f.setSwapInterval(1)\n            f.setProfile(QGLFormat.CoreProfile)\n            c = QGLContext(f, None)\n            QGLWidget.__init__(self, c, parent)\n        else:\n            QGLWidget.__init__(self, parent)\n\n        self.setMouseTracking(True)\n\n        self.parent = parent\n        self.controller = self.parent.controller\n        self.init_parametres()\n\n        self.last_time = time.time()\n        self.delta_t = 0.016\n        self.last_fps = 100.\n        self.fps_count = 0\n        self.fps_time = 0.\n\n        self.hitPoint = numpy.array([0.,0.,0.])\n        self.oldHitPoint = numpy.array([0.,0.,0.])\n\n        self.lightning_shader_program = QGLShaderProgram()\n        self.variable_layer_shader_program = QGLShaderProgram()\n\n        #properties definition\n        self.xRot = 0\n        self.yRot = 0\n        self.zRot = 0\n        self.zoom = 0\n        self.camera_target = numpy.array([0., 0. , 0.])\n\n        self.lightning_shader_ok = False\n\n        self.oldPos3d = [.0, .0, .0]\n\n        #self.lightAmbient = [.0, .0, .0, .0]\n        #self.lightDiffuse = [.0, .0, .0, .0]\n        #self.lightPossition = [.0, .0, .0, .0]\n\n        self.materialSpecular = [.0,.0,.0,.0]\n        self.materialShiness = [.0]\n\n        #DEBUG\n        self.rayStart = numpy.array([0., 0. ,0.])\n        self.rayDir = numpy.array([0., 0. ,0.])\n        self.rayUp = numpy.array([0., 0. ,0.])\n        self.rayRight = numpy.array([0., 0. ,0.])\n        self.v0 = numpy.array([0., 0. ,0.])\n        self.v1 = numpy.array([0., 0., 0.])\n        self.v2 = numpy.array([0., 0., 0.])\n        #DEBUG\n\n        #screen properties\n        self.w = 0\n        self.h = 0\n\n        self.init_parametres()\n\n        self.sceneFrameBuffer = []\n        self.image_background = []\n        self.image_hotbed = []\n        self.test_img = []\n        self.wipe_tower_texture = []\n\n        #tools\n        self.selectTool = None\n        self.moveTool = None\n        self.rotateTool = None\n        self.scaleTool = None\n        self.placeOnFaceTool = None\n        self.tool_background = None\n        self.do_button = None\n        self.undo_button = None\n\n        self.tools = []\n\n\n    def init_parametres(self):\n        #TODO:Add camera instance initialization\n        #properties initialization\n        self.xRot = 424\n        self.yRot = 0\n        self.zRot = 5576\n        self.zoom = -39\n        self.last_fps = 100.\n        self.fps_count = 0\n        self.fps_time = 0.\n\n\n        self.oldPos3d = [.0, .0, .0]\n\n        #self.lightAmbient = [.95, .95, .95, 1.0]\n        #self.lightDiffuse = [.5, .5, .5, 1.0]\n        #self.lightPossition = [29.0, -48.0, 37.0, 1.0]\n\n        self.materialSpecular = [.0, .0, .0, 1.]\n        self.materialShiness = [0.0]\n\n        #screen properties\n        self.w = 0\n        self.h = 0\n\n        #self.tools = []\n\n\n    \'\'\'\n    def keyPressEvent(self, e):\n        print(str(e))\n        if e.key() == QtCore.Qt.Key_Escape:\n            self.close()\n    \'\'\'\n\n    def keyPressEvent(self, event):\n        self.controller.key_press_event(event)\n\n\n    def mousePressEvent(self, event):\n        self.controller.mouse_press_event(event)\n\n\n    def mouseDoubleClickEvent(self, event):\n        self.controller.mouse_press_event(event)\n        #self.controller.mouse_double_click(event)\n\n    def mouseReleaseEvent(self, event):\n        self.controller.mouse_release_event(event)\n\n    def mouseMoveEvent(self, event):\n        self.controller.mouse_move_event(event)\n\n    def wheelEvent(self, event):\n        self.controller.wheel_event(event)\n\n\n    def update_scene(self, reset=False):\n        if reset:\n            self.init_parametres()\n\n        #self.updateGL()\n        self.update()\n\n    def contentsMouseDoubleClickEvent(self, event):\n        pass\n\n    #TODO:All this function will be changed to control camera instance\n    def set_zoom(self, diff):\n        #self.camera.add_zoom(diff)\n        if (self.zoom + diff >= -60.0) and (self.zoom + diff <= -5.0):\n            self.zoom += diff\n\n\n    def get_zoom(self):\n        #return self.camera.get_zoom()\n        return self.zoom\n\n    def get_x_rotation(self):\n        return self.xRot\n\n    def get_y_rotation(self):\n        return self.yRot\n\n    def get_z_rotation(self):\n        return self.zRot\n\n    def minimumSizeHint(self):\n        return QtCore.QSize(50, 50)\n\n    def sizeHint(self):\n        return QtCore.QSize(1024, 600)\n\n    def set_x_rotation(self, angle):\n        angle = self.normalize_angle_x(angle)\n        if angle != self.xRot:\n            self.xRot = angle\n            #print(""X rot: "" + str(self.xRot))\n\n    def set_y_rotation(self, angle):\n        angle = self.normalize_angle(angle)\n        if angle != self.yRot:\n            self.yRot = angle\n\n    def set_z_rotation(self, angle):\n        angle = self.normalize_angle(angle)\n        if angle != self.zRot:\n            self.zRot = angle\n            #print(""Z rot: "" + str(self.zRot))\n\n    def texture_from_png(self, filename, gen_mipmap=True):\n        mode_to_bpp = {\'1\':1, \'L\':8, \'P\':8, \'RGB\':24, \'RGBA\':32, \'CMYK\':32, \'YCbCr\':24, \'I\':32, \'F\':32}\n\n        img = open(filename)\n        img = img.transpose(FLIP_TOP_BOTTOM)\n        bpp = mode_to_bpp[img.mode]\n        if bpp == 32:\n            type = GL_RGBA\n        else:\n            type = GL_RGB\n        img_data = numpy.array(list(img.getdata()), numpy.uint8)\n\n        texture = glGenTextures(1)\n        glPixelStorei(GL_UNPACK_ALIGNMENT, 1)\n        glBindTexture(GL_TEXTURE_2D, texture)\n        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)\n        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)\n\n\n        if bool(glGenerateMipmap) and gen_mipmap:\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR)\n            glTexImage2D(GL_TEXTURE_2D, 0, type, img.size[0], img.size[1], 0, type, GL_UNSIGNED_BYTE, img_data)\n            glGenerateMipmap(GL_TEXTURE_2D)\n        else:\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n            glTexImage2D(GL_TEXTURE_2D, 0, type, img.size[0], img.size[1], 0, type, GL_UNSIGNED_BYTE, img_data)\n\n        return texture\n\n    def initializeGL(self):\n        #load textures\n        self.image_background = self.texture_from_png(self.controller.app_config.local_path + ""data/img/background.png"")\n        self.catching_point = self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/slider_knob_2.png"")\n\n\n        #tools\n        #self.selectTool = GlButton(self.texture_from_png(""data/img/select_ns.png""), [3.,3.], [95.5, 18])\n        #self.moveTool = GlButton(self.texture_from_png(""data/img/move_ns.png""), [3.,3.], [95.5, 12.])\n        self.scaleTool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/scale_off.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/scale_on.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/scale_hover.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n        #                          [40., 40.], [10., -200.], False,\n                                  [40., 40.], [10., -245.], False,\n                                  self.tr(""Scale tool""),\'scale\')\n\n        self.placeOnFaceTool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/placeonface_off.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/placeonface_on.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/placeonface_hover.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                        [40., 40.], [10., -245.], False,\n                                        self.tr(""Place on face tool""), \'placeonface\')\n\n        self.rotateTool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/rotate_off.png""),\n                                   self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/rotate_on.png""),\n                                   self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/rotate_hover.png""),\n                                   self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                   [40., 40.], [10., -290.], False,\n                                   self.tr(""Rotate tool""), \'rotate\')\n        self.organize_tool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/organize_off.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/organize_on.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/organize_hover.png""),\n                                        self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                        [40., 40.], [10., -335.], True,\n                                      self.tr(""Arrange tool""), \'organize\')\n        self.multiply_tool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/multi_off.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/multi_on.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/multi_hover.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                      [40., 40.], [10., -380.], False,\n                                      self.tr(""Multiplication tool""), \'multi\')\n\n        self.support_tool = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/support_off.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/support_on.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/support_hover.png""),\n                                      self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                      [40., 40.], [10., -425.], False,\n                                      self.tr(""Support tool""), \'support\')\n\n\n\n        #back, forward buttons\n        self.undo_button = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/backarrow_off.png""),\n                                    self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/backarrow_on.png""),\n                                    self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/backarrow_hover.png""),\n                                    self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                    [40., 40.], [10, -50], True,\n                                    self.tr(""Undo""), ""undo"")\n        self.do_button = GlButton(self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/forwardarrow_off.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/forwardarrow_on.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/forwardarrow_hover.png""),\n                                  self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png""),\n                                  [40., 40.], [60, -50], True,\n                                  self.tr(""Redo""), ""redo"")\n\n\n        #self.selectTool.set_callback(self.parent.controller.select_button_pressed)\n        #self.moveTool.set_callback(self.parent.controller.move_button_pressed)\n        self.rotateTool.set_callback(self.controller.rotate_button_pressed)\n        self.scaleTool.set_callback(self.controller.scale_button_pressed)\n        self.placeOnFaceTool.set_callback(self.controller.place_on_face_button_pressed)\n        self.organize_tool.set_callback(self.controller.organize_button_pressed)\n\n        self.support_tool.set_callback(self.controller.support_button_pressed)\n\n        self.undo_button.set_callback(self.controller.undo_button_pressed)\n        self.do_button.set_callback(self.controller.do_button_pressed)\n\n\n        self.tool_background = self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/tool_mask.png"")\n        self.popup_widget = self.texture_from_png(self.controller.app_config.local_path + ""data/img/gui/popup_window.png"")\n        self.color_change_help = self.texture_from_png(\n            self.controller.app_config.local_path + ""data/img/gui/help.png"", False)\n\n\n        #self.tools = [self.scaleTool, self.rotateTool, self.organize_tool, self.multiply_tool, self.support_tool, self.undo_button, self.do_button]\n        #production\n        self.tools = [self.scaleTool, self.rotateTool, self.organize_tool, self.undo_button, self.do_button]\n\n        #self.wipe_tower_texture = self.texture_from_png(self.controller.app_config.local_path + ""data/img/LineAngle1.png"")\n\n        #self.tools = []\n\n        self.bed = {}\n        self.printing_space = {}\n\n        for i in self.parent.controller.printing_parameters.get_printers_names():\n            self.bed[self.parent.controller.printing_parameters.get_printer_parameters(i)[\'name\']] = self.make_printing_bed(self.parent.controller.printing_parameters.get_printer_parameters(i))\n            self.printing_space[self.parent.controller.printing_parameters.get_printer_parameters(i)[\'name\']] = self.make_printing_space(self.parent.controller.printing_parameters.get_printer_parameters(i))\n\n        glClearDepth(1.0)\n        #glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE)\n        glShadeModel(GL_FLAT)\n        glEnable(GL_DEPTH_TEST)\n        glDepthFunc(GL_LEQUAL)\n\n        #NICE\n        glCullFace(GL_FRONT)\n\n        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)\n\n        glEnable(GL_LIGHT0)\n        glEnable(GL_LIGHT1)\n        glEnable(GL_LIGHTING)\n\n        #new light settings\n        glLightfv(GL_LIGHT0, GL_POSITION, _gl_vector(50, 50, 100, 0))\n        glLightfv(GL_LIGHT0, GL_DIFFUSE, _gl_vector(1., 1., 1., 1.))\n        glLightfv(GL_LIGHT0, GL_AMBIENT, _gl_vector(0.15, 0.15, 0.15, 1.))\n        #glLightfv(GL_LIGHT0, GL_SPECULAR, _gl_vector(.5, .5, 1., 1.))\n\n        glLightfv(GL_LIGHT1, GL_POSITION, _gl_vector(100, 0, 50, 0))\n        glLightfv(GL_LIGHT1, GL_DIFFUSE, _gl_vector(1., 1., 1., 1.0))\n        glLightfv(GL_LIGHT1, GL_AMBIENT, _gl_vector(0.15, 0.15, 0.15, 1.))\n        #glLightfv(GL_LIGHT1, GL_SPECULAR, _gl_vector(1., 1., 1., 1.))\n        #new light settings\n\n        #material\n        #glMaterialfv(GL_FRONT, GL_SPECULAR, self.materialSpecular)\n        #glMaterialfv(GL_FRONT, GL_SHININESS, self.materialShiness)\n\n\n        glColorMaterial(GL_FRONT, GL_DIFFUSE)\n        glEnable(GL_COLOR_MATERIAL)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n\n\n\n        glEnable(GL_MULTISAMPLE)\n        glEnable(GL_LINE_SMOOTH)\n        glEnable(GL_NORMALIZE)\n\n\n\n        if self.lightning_shader_program.addShaderFromSourceFile(QGLShader.Vertex, self.controller.app_config.local_path + ""data/shaders/lightning.vert"") \\\n                and self.lightning_shader_program.addShaderFromSourceFile(QGLShader.Fragment, self.controller.app_config.local_path + ""data/shaders/lightning.frag""):\n            self.lightning_shader_program.link()\n            if not self.lightning_shader_program.log():\n                self.lightning_shader_ok = True\n            self.lightning_shader_program.release()\n\n\n        if self.variable_layer_shader_program.addShaderFromSourceFile(QGLShader.Vertex, self.controller.app_config.local_path + ""data/shaders/variable_height_slic3r.vert"") \\\n                and self.variable_layer_shader_program.addShaderFromSourceFile(QGLShader.Fragment, self.controller.app_config.local_path + ""data/shaders/variable_height_slic3r.frag""):\n            self.variable_layer_shader_program.link()\n            if not self.variable_layer_shader_program.log():\n                self.variable_layer_shader_ok = True\n            self.variable_layer_shader_program.release()\n\n\n\n    #@timing\n    def picking_render(self):\n        glClearColor(0., 0., 0., 0.0)\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n\n        glLoadIdentity()\n        glTranslatef(0.0, 0.0, self.zoom)\n        glRotated(-90.0, 1.0, 0.0, 0.0)\n        glRotated(self.xRot / 16.0, 1.0, 0.0, 0.0)\n        glRotated(self.zRot / 16.0, 0.0, 0.0, 1.0)\n\n        glTranslatef(-self.camera_target[0], -self.camera_target[1], -self.camera_target[2])\n\n        glDisable(GL_LIGHTING)\n        glDisable(GL_BLEND)\n\n        glDisable(GL_MULTISAMPLE)\n\n        for model in self.parent.controller.scene.get_models(with_wipe_tower=True, sort=True):\n            model.render(picking=True, gcode_preview=False)\n\n        for model in self.parent.controller.scene.get_models(with_wipe_tower=False, sort=True):\n            if model.selected:\n                self.draw_tools_helper(model, self.controller.settings, True)\n\n        if self.parent.controller.status in [\'edit\', \'canceled\']:\n            self.draw_tools(picking=True)\n\n        glEnable(GL_MULTISAMPLE)\n\n\n    def get_id_under_cursor(self, x, y):\n        #print(""color_picking"")\n        self.picking_render()\n        viewport = glGetIntegerv(GL_VIEWPORT)\n        color = glReadPixels(x, viewport[3] - y, 1, 1, GL_RGBA, GL_UNSIGNED_BYTE)\n        return int(color[0])+(256*int(color[1]))+(256*256*int(color[2]))\n\n\n\n    def paintGL(self, selection = 1):\n        #print(""Draw"")\n        t0 = time.time()\n\n        if not self.bed and self.printing_space:\n            return\n        heat_bed = self.bed[self.controller.settings[\'printer\']]\n        printing_space = self.printing_space[self.controller.settings[\'printer\']]\n        printer = None\n\n        #for p in self.controller.printers:\n        #    if p[\'name\'] == self.controller.settings[\'printer\']:\n        #        printer = p[\'printing_space\']\n        printer = self.controller.printing_parameters.get_printer_parameters(self.controller.actual_printer)\n\n        model_view = self.controller.render_status in [\'model_view\']\n\n        #glDepthMask(GL_TRUE)\n        glEnable( GL_LIGHTING )\n\n        glClearColor(0., 0., 0., 1.0)\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n        self.draw_background_texture()\n        glLoadIdentity()\n\n        glTranslatef(0.0, 0.0, self.zoom)\n        glRotated(-90.0, 1.0, 0.0, 0.0)\n        glRotated(self.xRot / 16.0, 1.0, 0.0, 0.0)\n        glRotated(self.zRot / 16.0, 0.0, 0.0, 1.0)\n\n        glTranslatef(-self.camera_target[0], -self.camera_target[1], -self.camera_target[2])\n\n        #print(""Camera position and Zoom and X Angle: "" + str(self.camera_target[2]) + \';\' + str(self.zoom) + \';\' + str(self.xRot))\n\n\n\n        if self.xRot >= 0.:\n            glDisable(GL_BLEND)\n            glCallList(heat_bed[0])\n\n\n\n\n        glEnable(GL_DEPTH_TEST)\n\n        if model_view:\n\n            #render solid objects, possible to edit transformation, select objects\n            for model in self.parent.controller.scene.get_models(with_wipe_tower=True, sort=True):\n                if self.lightning_shader_ok and not model.is_wipe_tower:\n                    self.lightning_shader_program.bind()\n                model.render(picking=False, gcode_preview=not model_view)\n                if self.lightning_shader_ok and not model.is_wipe_tower:\n                    self.lightning_shader_program.release()\n\n\n            if not self.controller.advance_settings:\n                for support in self.parent.controller.scene.supports:\n                    self.draw_support(support)\n\n\n            if self.parent.controller.settings[\'toolButtons\'][\'supportButton\'] and self.parent.controller.scene.actual_support:\n                print(""Support height: "" + str(self.parent.controller.scene.actual_support[\'height\']))\n                self.draw_support(self.parent.controller.scene.actual_support)\n\n            for model in self.parent.controller.scene.get_models(with_wipe_tower=False, sort=True):\n                if model.selected:\n                    self.draw_tools_helper(model, self.parent.controller.settings)\n\n            glCallList(printing_space)\n\n            if self.parent.controller.status in [\'edit\', \'canceled\']:\n                self.draw_tools()\n\n        elif not model_view:\n            #render blended objects and layers of gcode to inspect it\n\n            #uncomment for enable clipping(be sure to uncomment glDisable(GL_CLIP_PLANE0) too)\n            #TODO:add cliping by shaders, this clipping is function only for no shaders drawing\n            \'\'\'\n            eqn = np.array([0.0, 0.0, -1.0, float(self.controller.gcode_layer)*.1])\n            glClipPlane(GL_CLIP_PLANE0, eqn)\n            glEnable(GL_CLIP_PLANE0)\n            \'\'\'\n\n            for model in self.parent.controller.scene.get_models(with_wipe_tower=True, sort=True):\n                if self.lightning_shader_ok and not model.is_wipe_tower:\n                    self.lightning_shader_program.bind()\n                model.render(picking=False, gcode_preview=not model_view)\n                if self.lightning_shader_ok and not model.is_wipe_tower:\n                    self.lightning_shader_program.release()\n            \'\'\'\n            glDisable(GL_CLIP_PLANE0)\n            \'\'\'\n\n            color_change_list = [i[\'value\'] for i in self.parent.gcode_slider.points if not i[\'value\'] == -1]\n\n            color = [13, 82, 78]\n            for color_change in color_change_list:\n                self.draw_layer(color_change, color, printer, 1)\n\n                #Add text note for ColorChange\n\n\n            color = [255, 97, 0]\n            self.draw_layer(self.controller.gcode_layer, color, printer)\n            glCallList(printing_space)\n\n\n\n\n        self.draw_axis(self.parent.controller.printing_parameters.get_printer_parameters(self.controller.settings[\'printer\'])[\'printing_space\'])\n\n        if self.xRot < 0:\n\n            glEnable(GL_BLEND)\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n            glDisable(GL_DEPTH_TEST)\n            glCallList(heat_bed[1])\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n\n        self.draw_warning_window()\n        self.draw_help_window()\n\n        if self.controller.status in [\'generated\', \'saving_gcode\']:\n            self.draw_information_window()\n\n        #if self.controller.settings[\'debug\']:\n        #    self.picking_render()\n\n        if self.controller.settings[\'debug\']:\n            #print(""draw_debug"")\n            self.draw_debug()\n\n        glFlush()\n\n        t1 = time.time()\n\n        if self.controller.settings[\'debug\']:\n            if self.fps_count==100:\n                self.last_fps = 1./(self.fps_time/self.fps_count)\n                self.fps_count = 0\n                self.fps_time = 0.\n                self.renderText(100, 100, \'FPS: %3.1f\' % self.last_fps)\n            else:\n                self.fps_count+=1\n                self.fps_time+=t1-t0\n                self.renderText(100, 100, \'FPS: %3.1f\' % self.last_fps)\n\n\n    def draw_support(self, support):\n        pos = support[\'pos\']\n        height = support[\'height\']\n\n        glPushMatrix()\n        glTranslatef(pos[0], pos[1], 0.0)\n        glDisable(GL_LIGHTING)\n        glDisable(GL_DEPTH_TEST)\n\n        glLineWidth(2.5)\n        glColor3f(1.0, 0.0, 0.0)\n        glBegin(GL_LINES)\n        glVertex3f(0.0, 0.0, 0.0)\n        glVertex3f(0.0, 0.0, height)\n        glEnd()\n\n        glEnable(GL_DEPTH_TEST)\n        glEnable(GL_LIGHTING)\n        glPopMatrix()\n\n    def draw_help_window(self):\n        #set camera view\n        if self.controller.show_gcode_help():\n            glMatrixMode(GL_PROJECTION)\n            glPushMatrix()\n            glLoadIdentity()\n            viewport = glGetIntegerv(GL_VIEWPORT)\n            glOrtho(0.0, viewport[2], 0.0, viewport[3], -1.0, 1.0)\n            glMatrixMode(GL_MODELVIEW)\n            glPushMatrix()\n\n            sW = viewport[2] * 1.0\n            sH = viewport[3] * 1.0\n\n            glLoadIdentity()\n            glEnable(GL_BLEND)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_DEPTH_TEST)\n            glEnable(GL_TEXTURE_2D)\n\n            #draw frame for warning messages\n            position = [-575, 150]\n\n            position_x = sW - abs(position[0] * self.controller.dpi_coef) if position[\n                                                                                 0] * self.controller.dpi_coef < 0 else \\\n            position[0] * self.controller.dpi_coef\n            position_y = sH - abs(position[1] * self.controller.dpi_coef) if position[\n                                                                                 1] * self.controller.dpi_coef < 0 else \\\n            position[1] * self.controller.dpi_coef\n\n            size_w = 550 * self.controller.dpi_coef\n            size_h = 413 * self.controller.dpi_coef\n\n            coef_sH = size_h\n            coef_sW = size_w\n\n            glBindTexture(GL_TEXTURE_2D, self.color_change_help)\n            glColor4f(1.0, 1.0, 1.0, 0.80)\n            glBegin(GL_QUADS)\n            glTexCoord2f(0, 0)\n            glVertex3f(position_x, position_y, 0)\n            glTexCoord2f(0, 1)\n            glVertex3f(position_x, (position_y + coef_sH), 0)\n            glTexCoord2f(1, 1)\n            glVertex3f((position_x + coef_sW), (position_y + coef_sH), 0)\n            glTexCoord2f(1, 0)\n            glVertex3f((position_x + coef_sW), position_y, 0)\n            glEnd()\n\n            glDisable(GL_TEXTURE_2D)\n\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n\n            glColor4f(1., 1., 1., 1.)\n            font = self.controller.view.font\n            if self.controller.app_config.system_platform in [\'Darwin\']:\n                font_size = 14\n                space = 2.\n            else:\n                if self.controller.dpi_scale == 2:\n                    font_size = 9 * self.controller.dpi_coef\n                    space = 2.\n                else:\n                    font_size = 13 * self.controller.dpi_coef\n                    space = 2.5\n\n            font.setPointSize(font_size)\n\n            self.renderText(position_x + 4.*self.controller.dpi_coef, sH - position_y - size_h + font_size + (4.*self.controller.dpi_coef),\n                            self.tr(""Add stops at specific layer heights where you can manually""), font)\n            self.renderText(position_x + 4.*self.controller.dpi_coef, sH - position_y - size_h + font_size*space*self.controller.dpi_coef + (4.*self.controller.dpi_coef),\n                            self.tr(""change filament. Learn more about Colorprint at prusaprinters.""), font)\n\n\n            glPopMatrix()\n\n            glMatrixMode(GL_PROJECTION)\n            glPopMatrix()\n\n            glMatrixMode(GL_MODELVIEW)\n\n    def draw_warning_window(self):\n        #set camera view\n        messages = self.controller.get_warnings()\n        if len(messages) > 0:\n            mes_max_len = max([len(m) for m in messages])\n            glMatrixMode(GL_PROJECTION)\n            glPushMatrix()\n            glLoadIdentity()\n            viewport = glGetIntegerv(GL_VIEWPORT)\n            glOrtho(0.0, viewport[2], 0.0, viewport[3], -1.0, 1.0)\n            glMatrixMode(GL_MODELVIEW)\n            glPushMatrix()\n\n            sW = viewport[2] * 1.0\n            sH = viewport[3] * 1.0\n\n            glLoadIdentity()\n            glEnable(GL_BLEND)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_DEPTH_TEST)\n            glEnable(GL_TEXTURE_2D)\n\n            #draw frame for warning messages\n            position_x = 25\n            position_y = 25\n\n            if mes_max_len>51:\n                size_w = 400 * self.controller.dpi_coef\n            else:\n                size_w = 350 * self.controller.dpi_coef\n            size_h = 180*self.controller.dpi_coef\n\n            coef_sH = size_h\n            coef_sW = size_w\n\n            glBindTexture(GL_TEXTURE_2D, self.popup_widget)\n            glColor4f(1., 1., 1., .8)\n            glBegin(GL_QUADS)\n            glTexCoord2f(0, 0)\n            glVertex3f(position_x, position_y, 0)\n            glTexCoord2f(0, 1)\n            glVertex3f(position_x, (position_y + coef_sH), 0)\n            glTexCoord2f(1, 1)\n            glVertex3f((position_x + coef_sW), (position_y + coef_sH), 0)\n            glTexCoord2f(1, 0)\n            glVertex3f((position_x + coef_sW), position_y, 0)\n            glEnd()\n\n            glDisable(GL_TEXTURE_2D)\n\n            glColor4f(1.,1.,1.,1.)\n            font = self.controller.view.font\n            if self.controller.app_config.system_platform in [\'Darwin\']:\n                font.setPointSize(28)\n            else:\n                font.setPointSize(25*self.controller.dpi_coef - self.controller.dpi_scale)\n            #font.setPointSize(25)\n            self.renderText(115*self.controller.dpi_coef, sH - 153*self.controller.dpi_coef, self.tr(""WARNING""), font)\n\n            if self.controller.app_config.system_platform in [\'Darwin\']:\n                font.setPointSize(10)\n            else:\n                font.setPointSize(8*self.controller.dpi_coef - self.controller.dpi_scale)\n            #font.setPointSize(8)\n            for n, message in enumerate(messages):\n                #Maximum of massages in warning box\n                if n > 5:\n                    break\n                self.renderText(57, sH-122*self.controller.dpi_coef+15*n,  message, font)\n\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n\n            glPopMatrix()\n\n            glMatrixMode(GL_PROJECTION)\n            glPopMatrix()\n\n            glMatrixMode(GL_MODELVIEW)\n\n\n    def draw_information_window(self):\n        # set camera view\n        messages = self.controller.get_informations()\n\n        if len(messages) > 0:\n            glMatrixMode(GL_PROJECTION)\n            glPushMatrix()\n            glLoadIdentity()\n            viewport = glGetIntegerv(GL_VIEWPORT)\n            glOrtho(0.0, viewport[2], 0.0, viewport[3], -1.0, 1.0)\n            glMatrixMode(GL_MODELVIEW)\n            glPushMatrix()\n\n            sW = viewport[2] * 1.0\n            sH = viewport[3] * 1.0\n\n            glLoadIdentity()\n            glEnable(GL_BLEND)\n            glDisable(GL_LIGHTING)\n            glDisable(GL_DEPTH_TEST)\n            glEnable(GL_TEXTURE_2D)\n\n            # draw frame for information messages\n            position = [-325, 25]\n\n            position_x = sW - abs(position[0]*self.controller.dpi_coef) if position[0]*self.controller.dpi_coef < 0 else position[0]*self.controller.dpi_coef\n            position_y = sH - abs(position[1]*self.controller.dpi_coef) if position[1]*self.controller.dpi_coef < 0 else position[1]*self.controller.dpi_coef\n\n            #position_x = 25\n            #position_y = 25\n\n            size_w = 300*self.controller.dpi_coef\n            size_h = 100*self.controller.dpi_coef\n\n            coef_sH = size_h\n            coef_sW = size_w\n\n            glBindTexture(GL_TEXTURE_2D, self.popup_widget)\n            glColor4f(1., 1., 1.0, .8)\n            glBegin(GL_QUADS)\n            glTexCoord2f(0, 0)\n            glVertex3f(position_x, position_y, 0)\n            glTexCoord2f(0, 1)\n            glVertex3f(position_x, (position_y + coef_sH), 0)\n            glTexCoord2f(1, 1)\n            glVertex3f((position_x + coef_sW), (position_y + coef_sH), 0)\n            glTexCoord2f(1, 0)\n            glVertex3f((position_x + coef_sW), position_y, 0)\n            glEnd()\n\n            glDisable(GL_TEXTURE_2D)\n\n            glColor4f(1., 1., 1., 1.)\n            font = self.controller.view.font\n            if self.controller.app_config.system_platform in [\'Darwin\']:\n                font.setPointSize(19)\n            else:\n                font.setPointSize(17 * self.controller.dpi_coef - self.controller.dpi_scale)\n            self.renderText(position_x + 8, sH - position_y - size_h + 30, self.tr(""PRINT INFO""), font)\n\n            if self.controller.app_config.system_platform in [\'Darwin\']:\n                font.setPointSize(11)\n            else:\n                font.setPointSize(9 * self.controller.dpi_coef - self.controller.dpi_scale)\n\n            #header = \'{:>20}{:>10}{:>14}\'.format(\' \', \'time:\', \'filament:\')\n            #print(header)\n            #text = \'{:20}{:>10}{:>12}\'.format(messages[\'info_text\'], messages[\'printing_time\'], messages[\'filament_lenght\'])\n            #print(text)\n            glColor3f(.5,.5,.5)\n            #self.renderText(position_x + 8, sH - position_y - size_h + 63, header, font)\n            self.renderText(position_x + 108*self.controller.dpi_coef, sH - position_y - size_h + 63*self.controller.dpi_coef, self.tr(""estimate time:""), font)\n            self.renderText(position_x + 208*self.controller.dpi_coef, sH - position_y - size_h + 63*self.controller.dpi_coef, self.tr(""filament:""), font)\n            glColor3f(1., 1., 1.)\n            #self.renderText(position_x + 8, sH - position_y - size_h + 65 + 15, text, font)\n            self.renderText(position_x + 10*self.controller.dpi_coef, sH - position_y - size_h + 65*self.controller.dpi_coef + 15, self.tr(""total info:""), font)\n            self.renderText(position_x + 108*self.controller.dpi_coef, sH - position_y - size_h + 65*self.controller.dpi_coef + 15, messages[\'printing_time\'], font)\n            self.renderText(position_x + 208*self.controller.dpi_coef, sH - position_y - size_h + 65*self.controller.dpi_coef + 15, messages[\'filament_lenght\'], font)\n\n\n            glEnable(GL_DEPTH_TEST)\n            glDisable(GL_BLEND)\n\n            glPopMatrix()\n\n            glMatrixMode(GL_PROJECTION)\n            glPopMatrix()\n\n            glMatrixMode(GL_MODELVIEW)\n\n    def draw_layer(self, layer, color, printer, color_change=0):\n        printing_space = printer[\'printing_space\']\n        layer_data = self.controller.gcode.data[layer]\n\n        line_width = .01\n        left = True\n\n        glPushMatrix()\n        #TODO: Better solution\n        glTranslatef(printing_space[0]*-0.5*.1, printing_space[1]*-0.5*.1, 0.0)\n\n        glDisable(GL_LIGHTING)\n        glDisable(GL_DEPTH_TEST)\n\n        glLineWidth(2.5)\n\n        glEnable(GL_LINE_SMOOTH)\n        glHint(GL_LINE_SMOOTH_HINT, GL_NICEST)\n\n\n        glBegin(GL_LINES)\n        #for layer_data in layer_datas:\n        #( brim, perimetry,  infill, support, colorchange)\n        for p in layer_data:\n            if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n                if p[5] == 0:\n                    c = self.controller.get_extruder_color(1)\n                    color = [c.red(), c.green(), c.blue()]\n                elif p[5] == 1:\n                    c = self.controller.get_extruder_color(2)\n                    color = [c.red(), c.green(), c.blue()]\n                elif p[5] == 2:\n                    c = self.controller.get_extruder_color(3)\n                    color = [c.red(), c.green(), c.blue()]\n                elif p[5] == 3:\n                    c = self.controller.get_extruder_color(4)\n                    color = [c.red(), c.green(), c.blue()]\n            else:\n                if color_change:\n                    color = [255, 255, 255]\n                elif p[2] == 5.0:\n                    color = [255, 255, 255]\n                elif p[2] == 4.0:\n                    color = [88, 117, 69]\n                elif p[2] == 2.0:\n                    color = [ 255,158, 60]\n                elif p[2] == 3.0:\n                    color = [247, 108, 49]\n\n            if p[2] >= 1.0:\n                glColor3ub(color[0], color[1], color[2])\n                glVertex3f(p[0][0] * .1, p[0][1] * .1, p[0][2] * .1)\n                glVertex3f(p[1][0] * .1, p[1][1] * .1, p[1][2] * .1)\n            #elif p[2] == \'M\':\n            #    glColor3f(0.0, 0.0, 1.0)\n            #    glVertex3f(p[0][0] * .1, p[0][1] * .1, p[0][2] * .1)\n            #    glVertex3f(p[1][0] * .1, p[1][1] * .1, p[1][2] * .1)\n        glEnd()\n        glPopMatrix()\n\n        #glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)\n        \'\'\'\n        glBegin(GL_TRIANGLE_STRIP)\n        #glBegin(GL_TRIANGLES)\n        # for layer_data in layer_datas:\n\n        last_type = \'E\'\n        for p in layer_data:\n            a = numpy.array(p[0])\n            b = numpy.array(p[1])\n            a *= .1\n            b *= .1\n            ab_leng = numpy.linalg.norm(b-a)\n\n            dx = b[0] - a[0] #x2-x1\n            dy = b[1] - a[1] #y2-y1\n            n1 = numpy.array([-dy, dx, 0.0])\n            n1 /= numpy.linalg.norm(n1)\n            n2 = numpy.array([dy, -dx, 0.0])\n            n2 /= numpy.linalg.norm(n2)\n\n            if not last_type == p[2]:\n                glEnd()\n                glBegin(GL_TRIANGLE_STRIP)\n                last_type = p[2]\n\n            if \'M\' == p[2]:\n                continue\n\n            if \'E-sk\' == p[2]:\n                glColor3ub(255, 255, 255)\n            elif \'E-su\' == p[2]:\n                glColor3ub(88, 117, 69)\n            elif \'E-i\' == p[2]:\n                glColor3ub(255, 158, 60)\n            elif \'E-p\' == p[2]:\n                glColor3ub(247, 108, 49)\n\n            a00 = a + n2 * ((p[4]*.02404)/ab_leng)\n            a01 = a + n1 * ((p[4]*.02404)/ab_leng)\n\n            b00 = b + n2 * ((p[4]*.02404)/ab_leng)\n            b01 = b + n1 * ((p[4]*.02404)/ab_leng)\n\n            glVertex3f(a00[0], a00[1], p[0][2]*.1)\n            glVertex3f(a01[0], a01[1], p[0][2]*.1)\n\n            glVertex3f(b00[0], b00[1], p[1][2]*.1)\n            glVertex3f(b01[0], b01[1], p[1][2]*.1)\n        glEnd()\n\n        #glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)\n\n        glEnable(GL_DEPTH_TEST)\n        glEnable(GL_LIGHTING)\n        glPopMatrix()\n        \'\'\'\n\n\n    def draw_tools_helper(self, model, settings, picking=False):\n        if picking:\n            rotateColors = [model.rotateColorXId, model.rotateColorYId, model.rotateColorZId]\n            scaleColors = [model.scaleColorXId, model.scaleColorYId, model.scaleColorZId, model.scaleColorXYZId]\n        else:\n            rotateColors = [[180,180,180],[180,180,180],[180,180,180]]\n            scaleColors = [model.scaleColorXId, model.scaleColorYId, model.scaleColorZId, model.scaleColorXYZId]\n\n        if model.is_multipart_model:\n            pos = model.multipart_parent.pos + model.pos\n            model = model.multipart_parent\n            #max_bs =\n        else:\n            pos = model.pos\n            #max_bs = model.max_bs\n\n        if self.rotateTool.is_pressed():\n            self.draw_rotation_circle(model, rotateColors, pos, model.max_bs, picking)\n        if self.scaleTool.is_pressed():\n            self.draw_scale_rect(model, scaleColors, pos, model.boundingSphereSize, picking)\n\n\n    def draw_scale_rect(self, model, colors, position, radius, picking=False):\n        if not picking:\n                colors[3] = [255, 255, 255]\n\n        scale_axis = []\n\n        if isinstance(model, MultiModel):\n            for m in model.models:\n                scale_axis.append(m.scaleAxis)\n        else:\n            scale_axis.append(model.scaleAxis)\n\n\n        offset=0.5\n        size_of_selector = 0.2\n\n        min = deepcopy(model.min)\n        max = deepcopy(model.max)\n\n        min -= offset\n        max += offset\n\n        glPushMatrix()\n        glTranslatef(position[0], position[1], 0.0)\n        glDisable( GL_LIGHTING )\n        glDisable(GL_DEPTH_TEST)\n\n\n        if picking:\n            glColor3ubv(colors[3])\n\n            glBegin(GL_TRIANGLES)\n            glVertex3f(max[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, max[1] + size_of_selector, 0.)\n\n            glVertex3f(max[0] + size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            glEnd()\n\n            glBegin(GL_TRIANGLES)\n            glVertex3f(min[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, min[1] + size_of_selector, 0.)\n\n            glVertex3f(min[0] + size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            glEnd()\n\n            glBegin(GL_TRIANGLES)\n            glVertex3f(max[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, min[1] + size_of_selector, 0.)\n\n            glVertex3f(max[0] + size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, min[1] + size_of_selector, 0.)\n            glEnd()\n\n            glBegin(GL_TRIANGLES)\n            glVertex3f(min[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, max[1] + size_of_selector, 0.)\n\n            glVertex3f(min[0] + size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glEnd()\n\n\n        else:\n            glColor3ubv(colors[3])\n            #Outer lines\n\n            glBegin(GL_LINE_LOOP)\n            glVertex3f(min[0], min[1], 0.)\n            glVertex3f(min[0], max[1], 0.)\n            glVertex3f(max[0], max[1], 0.)\n            glVertex3f(max[0], min[1], 0.)\n            glEnd()\n\n            if \'XYZ\' in scale_axis:\n                glColor3ub(255, 97, 0)\n            else:\n                glColor3f(1.,1.,1.)\n            glBegin(GL_TRIANGLES)\n            glVertex3f(max[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, max[1] + size_of_selector, 0.)\n\n            glVertex3f(max[0] + size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            #glEnd()\n\n            #glBegin(GL_TRIANGLES)\n            glVertex3f(min[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, min[1] + size_of_selector, 0.)\n\n            glVertex3f(min[0] + size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            #glEnd()\n\n            #glBegin(GL_TRIANGLES)\n            glVertex3f(max[0] - size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, min[1] + size_of_selector, 0.)\n\n            glVertex3f(max[0] + size_of_selector, min[1] + size_of_selector, 0.)\n            glVertex3f(max[0] + size_of_selector, min[1] - size_of_selector, 0.)\n            glVertex3f(max[0] - size_of_selector, min[1] + size_of_selector, 0.)\n            #glEnd()\n\n            #glBegin(GL_TRIANGLES)\n            glVertex3f(min[0] - size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, max[1] + size_of_selector, 0.)\n\n            glVertex3f(min[0] + size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(min[0] - size_of_selector, max[1] + size_of_selector, 0.)\n            glVertex3f(min[0] + size_of_selector, max[1] - size_of_selector, 0.)\n            glEnd()\n\n\n\n            #self.renderText(0., 0., 0., ""%s"" % str(model.size_origin))\n\n\n        glEnable(GL_DEPTH_TEST)\n        glEnable(GL_LIGHTING)\n        glPopMatrix()\n\n\n    def draw_rotation_circle(self, model, colors, position, radius, picking=False):\n        actual_angle = numpy.rad2deg(model.rot[2])\n        if actual_angle >= 360.:\n            n, actual_angle = divmod(actual_angle, 360)\n        elif actual_angle <= 0.:\n            n, actual_angle = divmod(actual_angle, -360)\n\n        if not picking:\n                colors[2] = [255, 255, 255]\n\n        segments = 64\n        if picking:\n            width = 0.45\n        else:\n            width = 0.15\n\n        if radius < 2.5:\n            radius = 2.5\n\n        r0 = radius * 0.35\n        r1 = radius * 0.7\n        r2 = radius\n        r3 = radius+0.05\n        r4 = radius+0.15\n        r5 = radius+0.25\n        r6 = radius+0.4\n        r7 = radius+1.0\n\n        if picking:\n            list_of_segments_6 = numpy.arange(0., 360., 1.)\n            circle7 = numpy.array([[numpy.cos(numpy.radians(i)) * r7, numpy.sin(numpy.radians(i)) * r7] for i in list_of_segments_6])\n        else:\n            #calculete points for circle 0 and 1\n            list_of_segments_0_1 = numpy.arange(0, 360., 360./8.)\n            circle0 = numpy.array([[numpy.cos(numpy.radians(i)) * r0, numpy.sin(numpy.radians(i)) * r0] for i in list_of_segments_0_1])\n            circle1 = numpy.array([[numpy.cos(numpy.radians(i)) * r1, numpy.sin(numpy.radians(i)) * r1] for i in list_of_segments_0_1])\n\n            # calculete points for circle 2\n            list_of_segments_2 = numpy.arange(0, 360., 360. / segments)\n            circle2 = numpy.array([[numpy.cos(numpy.radians(i)) * r2, numpy.sin(numpy.radians(i)) * r2] for i in list_of_segments_2])\n\n            # calculete points for circle 3, 4 and 5\n            list_of_segments_3_4_5 = numpy.arange(0, 360., 360. / 72.)\n            circle3 = numpy.array([[numpy.cos(numpy.radians(i)) * r3, numpy.sin(numpy.radians(i)) * r3] for i in list_of_segments_3_4_5])\n            circle4 = numpy.array([[numpy.cos(numpy.radians(i)) * r4, numpy.sin(numpy.radians(i)) * r4] for i in list_of_segments_3_4_5])\n            circle5 = numpy.array([[numpy.cos(numpy.radians(i)) * r5, numpy.sin(numpy.radians(i)) * r5] for i in list_of_segments_3_4_5])\n\n        # calculete points for circle 6\n        list_of_segments_6 = numpy.arange(0., 360., 1.)\n        circle6 = numpy.array([[numpy.cos(numpy.radians(i)) * r6, numpy.sin(numpy.radians(i)) * r6] for i in list_of_segments_6])\n        circle7 = numpy.array([[numpy.cos(numpy.radians(i)) * r7, numpy.sin(numpy.radians(i)) * r7] for i in list_of_segments_6])\n\n        glPushMatrix()\n        glTranslatef(position[0], position[1], 0.0)\n        glDisable( GL_LIGHTING )\n        glDisable(GL_DEPTH_TEST)\n\n\n        a = numpy.array([circle6[int(actual_angle)][0].copy(), circle6[int(actual_angle)][1].copy() * -1., 0.0])\n        c = numpy.array([circle7[int(actual_angle)][0].copy(), circle7[int(actual_angle)][1].copy() * -1., 0.0])\n        v_ac = c - a\n        v_ac_l = numpy.linalg.norm(v_ac)\n        v_ac /= v_ac_l\n        c -= v_ac *.1\n        b = numpy.cross(v_ac, np.array([0., 0., 1.]))\n        b /= numpy.linalg.norm(b)\n        b *= .25\n        b += a + v_ac * .25\n        d = numpy.cross(v_ac, np.array([0., 0., -1.]))\n        d /= numpy.linalg.norm(d)\n        d *= .25\n        d += a + v_ac * .25\n\n        if picking:\n            glColor3ubv(colors[2])\n            glLineWidth(7.5)\n            glBegin(GL_LINES)\n            glVertex3f(0., 0., 0.)\n            glVertex3f(circle7[int(actual_angle)][0], circle7[int(actual_angle)][1] * -1., 0.)\n            glEnd()\n\n            glEnable(GL_TEXTURE_2D)\n            glEnable(GL_BLEND)\n\n            glBindTexture(GL_TEXTURE_2D, self.catching_point)\n            glColor3ubv(colors[2])\n            glBegin(GL_QUADS)\n            glTexCoord2f(0., 0.)\n            glVertex3f(a[0], a[1], 0.0)\n            glTexCoord2f(0., 1.)\n            glVertex3f(b[0], b[1], 0.0)\n            glTexCoord2f(1., 1.)\n            glVertex3f(c[0], c[1], 0.0)\n            glTexCoord2f(1., 0.)\n            glVertex3f(d[0], d[1], 0.0)\n            glEnd()\n\n        else:\n            glLineWidth(2.5)\n            glColor3ubv(colors[2])\n            #inner lines\n            glBegin(GL_LINES)\n            for i0, i1 in zip(circle0, circle1):\n                glVertex3f(i0[0], i0[1], 0.)\n                glVertex3f(i1[0], i1[1], 0.)\n            glEnd()\n\n            #outer lines\n            bigger_index = list(range(0, 72, 3))\n            glBegin(GL_LINES)\n            for n, (i0, i1, i2) in enumerate(zip(circle3, circle4, circle5)):\n                glVertex3f(i0[0], i0[1], 0.)\n                if n in bigger_index:\n                    glVertex3f(i2[0], i2[1], 0.)\n                else:\n                    glVertex3f(i1[0], i1[1], 0.)\n            glEnd()\n\n            #main circle\n            glBegin(GL_LINE_LOOP)\n            for i in circle2:\n                glVertex3f(i[0], i[1], 0.)\n            glEnd()\n\n            #print(""sceneRender: "" + str(actual_angle))\n            if model.rotationAxis == ""Z"":\n                glLineWidth(5)\n                glColor3ub(255, 97, 0)\n            else:\n                glLineWidth(2.5)\n                glColor3ub(255, 255, 255)\n            glBegin(GL_LINES)\n            glVertex3f(0., 0., 0.)\n            glVertex3f(circle7[int(actual_angle)][0] - v_ac[0] *.3, (circle7[int(actual_angle)][1]*-1.) - v_ac[1] *.3, 0.)\n            glEnd()\n\n\n            glLineWidth(2.5)\n            glBegin(GL_LINE_LOOP)\n            glVertex3f(0., 0., 0.)\n            glVertex3f(circle6[0][0], circle6[0][1], 0.)\n            glColor3ub(255, 97, 0)\n            for i in circle6[1:int(actual_angle)+1]:\n                glVertex3f(i[0], i[1]*-1., 0.)\n                #glVertex3f(self.hitPoint[0], self.hitPoint[1], self.hitPoint[2])\n            glColor3ub(255, 255, 255)\n            glVertex3f(0., 0., 0.)\n            glEnd()\n\n            glEnable(GL_TEXTURE_2D)\n            glEnable(GL_BLEND)\n\n            glBindTexture(GL_TEXTURE_2D, self.catching_point)\n            color = [255, 255, 255]\n            if isinstance(model, MultiModel):\n                for m in model.models:\n                    if m.rotationAxis == ""Z"":\n                        color = [255, 97, 0]\n            else:\n                if model.rotationAxis == ""Z"":\n                    color = [255, 97, 0]\n                else:\n                    color = [255, 255, 255]\n            glColor3ub(color[0], color[1], color[2])\n            glBegin(GL_QUADS)\n            glTexCoord2f(0., 0.)\n            glVertex3f(a[0], a[1], 0.0)\n            glTexCoord2f(0., 1.)\n            glVertex3f(b[0], b[1], 0.0)\n            glTexCoord2f(1., 1.)\n            glVertex3f(c[0], c[1], 0.0)\n            glTexCoord2f(1., 0.)\n            glVertex3f(d[0], d[1], 0.0)\n            glEnd()\n\n            self.renderText(circle7[int(actual_angle)][0], circle7[int(actual_angle)][1]*-1., 0., ""%.1f"" % actual_angle )\n\n\n        glEnable(GL_DEPTH_TEST)\n        glEnable(GL_LIGHTING)\n        glPopMatrix()\n\n\n    def draw_debug(self):\n        glPushMatrix()\n        glDisable(GL_LIGHTING)\n        glColor3f(1.,.0,.0)\n        glBegin(GL_LINES)\n        glVertex3f(self.rayStart[0], self.rayStart[1], self.rayStart[2])\n        glVertex3f(self.rayDir[0]+self.rayStart[0], self.rayDir[1]+self.rayStart[1], self.rayDir[2]+self.rayStart[2])\n        \'\'\'\n        glColor3f(0.,1.0,.0)\n        glVertex3f(self.rayStart[0], self.rayStart[1], self.rayStart[2])\n        glVertex3f(self.rayUp[0], self.rayUp[1], self.rayUp[2])\n        glColor3f(0.,.0,.1)\n        glVertex3f(self.rayStart[0], self.rayStart[1], self.rayStart[2])\n        glVertex3f(self.rayRight[0], self.rayRight[1], self.rayRight[2])\n        \'\'\'\n        glEnd()\n\n        glBegin(GL_LINE_LOOP)\n        glVertex3f(self.v0[0], self.v0[1], self.v0[2])\n        glVertex3f(self.v1[0], self.v1[1], self.v1[2])\n        glVertex3f(self.v2[0], self.v2[1], self.v2[2])\n        glEnd()\n\n        glEnable(GL_LIGHTING)\n        glPopMatrix()\n\n\n    def resizeGL(self, width, height):\n        self.w = width\n        self.h = height\n        glViewport(0, 0, width, height)\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        gluPerspective(45., float(width*1./height*1.), 1., 75.)\n        glMatrixMode(GL_MODELVIEW)\n\n    def get_cursor_position(self, event):\n        matModelView = glGetDoublev(GL_MODELVIEW_MATRIX )\n        matProjection = glGetDoublev(GL_PROJECTION_MATRIX)\n        viewport = glGetIntegerv( GL_VIEWPORT )\n\n        winX = event.x() * 1.0\n        winY = viewport[3] - (event.y() *1.0)\n\n        rayStart = gluUnProject(winX, winY, -1.0, matModelView, matProjection, viewport)\n        rayEnd = gluUnProject(winX, winY, 1.0, matModelView, matProjection, viewport)\n\n        return (rayStart, rayEnd)\n\n    def get_camera_direction(self, event=None):\n        matModelView = glGetDoublev(GL_MODELVIEW_MATRIX )\n        matProjection = glGetDoublev(GL_PROJECTION_MATRIX)\n        viewport = glGetIntegerv( GL_VIEWPORT )\n\n        winX = (viewport[2]*.5)\n        winY = (viewport[3]*.5)\n\n        rayStart = numpy.array(gluUnProject(winX, winY, 0.0, matModelView, matProjection, viewport))\n        rayEnd = numpy.array(gluUnProject(winX, winY, 1.0, matModelView, matProjection, viewport))\n\n        rayUp = numpy.array(gluUnProject(winX, winY + 10., 0.0, matModelView, matProjection, viewport))\n        rayUp = rayUp - rayStart\n        rayUp /= numpy.linalg.norm(rayUp)\n        self.rayUp = rayUp\n\n        rayRight = numpy.array(gluUnProject(winX + 10., winY, 0.0, matModelView, matProjection, viewport))\n        rayRight = rayRight - rayStart\n        rayRight /= numpy.linalg.norm(rayRight)\n        self.rayRight = rayRight\n        \'\'\'\n        self.rayStart = rayStart\n        self.rayDir = (rayEnd - rayStart)/(numpy.linalg.norm(rayEnd - rayStart))\n        self.rayUp = rayUp\n        self.rayRight = rayRight\n        \'\'\'\n\n        rayDir = (rayEnd - rayStart)/(numpy.linalg.norm(rayEnd - rayStart))\n\n        return rayStart, rayDir, rayUp, rayRight\n\n\n\n    def make_printing_bed(self, printer_data):\n        #print(""Printer data: "" + str(printer_data))\n        #Model = ModelTypeStl.load(printer_data[\'model\'])\n        Model = ModelTypeObj.load(self.controller.app_config.local_path + printer_data[\'model\'])\n        bed_texture = printer_data[\'texture\']\n        bed_texture_from_below = printer_data[\'texture_from_below\']\n        printing_space = printer_data[\'printing_space\']\n\n        image_hotbed = self.texture_from_png(self.controller.app_config.local_path + bed_texture)\n        image_hotbed_from_below = self.texture_from_png(self.controller.app_config.local_path + bed_texture_from_below)\n\n\n        genList_top = glGenLists(1)\n        glNewList(genList_top, GL_COMPILE)\n\n        glLineWidth(2)\n        glPushMatrix()\n        glTranslatef(printer_data[\'model_offset\'][0], printer_data[\'model_offset\'][1], printer_data[\'model_offset\'][2])\n\n        glDisable(GL_BLEND)\n        glEnable(GL_TEXTURE_2D)\n        glBindTexture(GL_TEXTURE_2D, image_hotbed)\n\n        #glEnable(GL_LIGHTING)\n\n        #glShadeModel(GL_SMOOTH)\n        glCullFace(GL_FRONT_AND_BACK)\n\n        #Obj version\n        #glColor4f(.4, .4, .4, .75)\n        glColor4f(1., 1., 1., 1.)\n        glBegin(GL_TRIANGLES)\n        for i in range(0, len(Model.v0)):\n            #print(str(Model.v0[i]))\n            glTexCoord2f(Model.t0[i][0], Model.t0[i][1])\n            glNormal3f(Model.n0[i][0], Model.n0[i][1], Model.n0[i][2])\n            glVertex3f(Model.v0[i][0]*.1, Model.v0[i][1]*.1, Model.v0[i][2]*.1)\n\n            glTexCoord2f(Model.t1[i][0], Model.t1[i][1])\n            glNormal3f(Model.n1[i][0], Model.n1[i][1], Model.n1[i][2])\n            glVertex3f(Model.v1[i][0]*.1, Model.v1[i][1]*.1, Model.v1[i][2]*.1)\n\n            glTexCoord2f(Model.t2[i][0], Model.t2[i][1])\n            glNormal3f(Model.n2[i][0], Model.n2[i][1], Model.n2[i][2])\n            glVertex3f(Model.v2[i][0]*.1, Model.v2[i][1]*.1, Model.v2[i][2]*.1)\n        glEnd()\n\n        glPopMatrix()\n\n        #glEnable(GL_TEXTURE_2D)\n        glDisable(GL_TEXTURE_2D)\n        glDisable(GL_LIGHTING)\n        glEndList()\n\n\n        genList_button = glGenLists(1)\n        glNewList(genList_button, GL_COMPILE)\n\n        glPushMatrix()\n        glTranslatef(printer_data[\'model_offset\'][0], printer_data[\'model_offset\'][1], printer_data[\'model_offset\'][2])\n\n        glEnable(GL_TEXTURE_2D)\n        glBindTexture(GL_TEXTURE_2D, image_hotbed_from_below)\n\n        #button view\n        glColor3f(1, 1, 1)\n        glBegin(GL_TRIANGLES)\n        glTexCoord2f(0., 0.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*-.05, printing_space[1]*-.05, 0.)\n\n        glTexCoord2f(1., 0.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*.05, printing_space[1]*-.05, 0.)\n\n        glTexCoord2f(0., 1.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*-.05, printing_space[1]*.05, 0.)\n\n        glTexCoord2f(0., 1.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*-.05, printing_space[1]*.05, 0.)\n\n        glTexCoord2f(1., 1.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*.05, printing_space[1]*.05, 0.)\n\n        glTexCoord2f(1., 0.)\n        glNormal3f(0., 0., 1.)\n        glVertex3f(printing_space[0]*.05, printing_space[1]*-.05, 0.)\n        glEnd()\n\n        glPopMatrix()\n\n        glEndList()\n\n\n        return genList_top, genList_button\n\n\n    def make_printing_space(self, printer_data):\n        printing_space = printer_data[\'printing_space\']\n\n        genList = glGenLists(1)\n        glNewList(genList, GL_COMPILE)\n\n        glLineWidth(.75)\n        glEnable(GL_BLEND)\n        glDisable(GL_TEXTURE_2D)\n        glDisable(GL_LIGHTING)\n\n        glEnable(GL_DEPTH_TEST)\n\n        glBegin(GL_LINES)\n        glColor3f(1, 1, 1)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * 0.5 * .1, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * 0.5 * .1, printing_space[2] * .1)\n\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * 0.5 * .1, 0)\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * 0.5 * .1, printing_space[2] * .1)\n\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * -0.5 * .1, 0)\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * -0.5 * .1, printing_space[2] * .1)\n\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, printing_space[2] * .1)\n        glEnd()\n\n        glBegin(GL_LINE_LOOP)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * 0.5 * .1, printing_space[2] * .1)\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * 0.5 * .1, printing_space[2] * .1)\n        glVertex3d(printing_space[0] * 0.5 * .1, printing_space[1] * -0.5 * .1, printing_space[2] * .1)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, printing_space[2] * .1)\n        glEnd()\n        glEndList()\n\n\n\n        return genList\n\n    def draw_axis(self, printing_space):\n        glLineWidth(7.5)\n        #glDisable(GL_DEPTH_TEST)\n        glBegin(GL_LINES)\n        glColor3f(1, 0, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 0)\n        glVertex3d((printing_space[0] * -0.5 * .1) + 1, printing_space[1] * -0.5 * .1, 0)\n\n        glColor3f(0, 1, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, (printing_space[1] * -0.5 * .1) + 1, 0)\n\n        glColor3f(0, 0, 1)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 0)\n        glVertex3d(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 1)\n        glEnd()\n\n        glColor3f(1, 0, 0)\n        self.renderText((printing_space[0] * -0.5 * .1) + 1.1, printing_space[1] * -0.5 * .1, 0, ""X"")\n        glColor3f(0, 1, 0)\n        self.renderText(printing_space[0] * -0.5 * .1, (printing_space[1] * -0.5 * .1) + 1.1, 0, ""Y"")\n        glColor3f(0, 0, 1)\n        self.renderText(printing_space[0] * -0.5 * .1, printing_space[1] * -0.5 * .1, 1.1, ""Z"")\n\n        #glEnable(GL_DEPTH_TEST)\n\n\n    def draw_background_texture(self):\n        glMatrixMode(GL_PROJECTION)\n        glPushMatrix()\n        glLoadIdentity()\n        viewport = glGetIntegerv( GL_VIEWPORT )\n        glOrtho(0.0, viewport[2], 0.0, viewport[3], 0.0, 1.0)\n        glMatrixMode(GL_MODELVIEW)\n        glPushMatrix()\n\n        glLoadIdentity()\n        glDisable(GL_LIGHTING)\n        glDisable(GL_BLEND)\n        glDisable(GL_DEPTH_TEST)\n\n        glColor3f(1,1,1)\n        glEnable(GL_TEXTURE_2D)\n        glBindTexture(GL_TEXTURE_2D, self.image_background)\n\n        glBegin(GL_QUADS)\n        glTexCoord2f(0, 0)\n        glVertex3f(0, 0, 0)\n\n        glTexCoord2f(0, 1)\n        glVertex3f(0, viewport[3], 0)\n\n        glTexCoord2f(1, 1)\n        glVertex3f(viewport[2], viewport[3], 0)\n\n        glTexCoord2f(1, 0)\n        glVertex3f(viewport[2], 0, 0)\n        glEnd()\n\n        glEnable(GL_DEPTH_TEST)\n\n        glDisable(GL_TEXTURE_2D)\n        glPopMatrix()\n\n        glMatrixMode(GL_PROJECTION)\n        glPopMatrix()\n\n        glMatrixMode(GL_MODELVIEW)\n\n    def draw_tools(self, picking=False):\n        glMatrixMode(GL_PROJECTION)\n        glPushMatrix()\n        glLoadIdentity()\n        viewport = glGetIntegerv( GL_VIEWPORT )\n        glOrtho(0.0, viewport[2], 0.0, viewport[3], -1.0, 1.0)\n        glMatrixMode(GL_MODELVIEW)\n        glPushMatrix()\n\n        sW = viewport[2] * 1.0\n        sH = viewport[3] * 1.0\n\n        glLoadIdentity()\n        glDisable(GL_LIGHTING)\n        glDisable(GL_DEPTH_TEST)\n\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)\n        glColor3f(1,1,1)\n\n        size = 45.\n\n        coef_sH = 50\n        coef_sW = 50\n\n        for tool in self.tools:\n            position_x = sW - abs(tool.position[0]) if tool.position[0] < 0 else tool.position[0]\n            position_y = sH - abs(tool.position[1]) if tool.position[1] < 0 else tool.position[1]\n\n            coef_sW = tool.size[0]\n            coef_sH = tool.size[1]\n\n            if picking:\n                glColor3ub(tool.color_id[0], tool.color_id[1], tool.color_id[2])\n                glEnable(GL_TEXTURE_2D)\n                glBindTexture(GL_TEXTURE_2D, tool.texture_background)\n            else:\n                glColor3f(1,1,1)\n                glEnable(GL_TEXTURE_2D)\n                if tool.pressed:\n                    glBindTexture(GL_TEXTURE_2D, tool.texture_on)\n                elif tool.mouse_over:\n                    glColor3f(1, 1, 1)\n                    glBindTexture(GL_TEXTURE_2D, tool.texture_hover)\n                else:\n                    glBindTexture(GL_TEXTURE_2D, tool.texture_off)\n            glBegin(GL_QUADS)\n            glTexCoord2f(0, 0)\n            glVertex3f(position_x, position_y, 0)\n            glTexCoord2f(0, 1.)\n            glVertex3f(position_x, (position_y + coef_sH), 0)\n            glTexCoord2f(1., 1.)\n            glVertex3f((position_x + coef_sW), (position_y + coef_sH), 0)\n            glTexCoord2f(1., 0)\n            glVertex3f((position_x + coef_sW), position_y, 0)\n            glEnd()\n\n\n        glEnable(GL_DEPTH_TEST)\n\n        glDisable(GL_TEXTURE_2D)\n        glPopMatrix()\n\n        glMatrixMode(GL_PROJECTION)\n        glPopMatrix()\n\n        glMatrixMode(GL_MODELVIEW)\n\n\n    def normalize_angle(self, angle):\n        while angle < 0:\n            angle += 360 * 16\n        while angle > 360 * 16:\n            angle -= 360 * 16\n        return angle\n\n    def normalize_angle_x(self, angle):\n        if angle < -90*16:\n            angle = -90*16\n        if angle > 90*16:\n            angle = 90*16\n        return angle\n\n\ndef _gl_vector(array, *args):\n    \'\'\'\n    Convert an array and an optional set of args into a flat vector of GLfloat\n    \'\'\'\n    array = numpy.array(array)\n    if len(args) > 0:\n        array = numpy.append(array, args)\n    vector = (GLfloat * len(array))(*array)\n    return vector'"
slicer.py,0,"b'# -*- coding: utf-8 -*-\n\n__author__ = \'Tibor Vavra\'\n\nimport io\nimport logging\nimport os\nimport configparser\nfrom abc import ABCMeta, abstractmethod\n\n\nimport platform\nimport subprocess\nfrom copy import deepcopy\n\nfrom io import StringIO\n\nimport signal\nfrom PyQt4.QtCore import QObject, QThread, pyqtSignal\n\nfrom gcode import GCode\n\n\nclass SlicerEngineAbstract():\n    \'\'\'\n    SlicerEngineAbstract is abstract class patern for others SlicerEngines\n    \'\'\'\n    __metaclass__ = ABCMeta\n\n    @abstractmethod\n    def slice(self):\n        pass\n\n    @abstractmethod\n    def set_data(self, data):\n        pass\n\n    @abstractmethod\n    def get_version(self):\n        pass\n\n\nclass Slic3rEngineRunner(QObject):\n    \'\'\'\n    This is just connector to console version of Slic3r software\n    first version\n    \'\'\'\n    step_increased = pyqtSignal(int)\n    filament_info = pyqtSignal(str)\n    finished = pyqtSignal()\n    send_message = pyqtSignal(str)\n    send_gcodedata = pyqtSignal(GCode)\n\n    #support parameters for soluble materials, list of parameters which will be used from soluble materials\n    support_parameters = [""support_material_angle"",\n                            ""support_material_buildplate_only"",\n                            ""support_material_contact_distance"",\n                            ""support_material_enforce_layers"",\n                            ""support_material_extruder"",\n                            ""support_material_extrusion_width"",\n                            ""support_material_interface_extruder"",\n                            ""support_material_interface_layers"",\n                            ""support_material_interface_spacing"",\n                            ""support_material_interface_speed"",\n                            ""support_material_pattern"",\n                            ""support_material_spacing"",\n                            ""support_material_threshold"",\n                            ""support_material_with_sheath"",\n                            ""support_material_xy_spacing"",\n                            ""support_material_synchronize_layers""]\n\n    multimaterial_spec_parameters = [""bridge_fan_speed"",\n                        ""cooling"",\n                        ""deretract_speed"",\n                        ""disable_fan_first_layers"",\n                        ""extrusion_multiplier"",\n                        ""fan_always_on"",\n                        ""fan_below_layer_time"",\n                        ""filament_density"",\n                        ""filament_diameter"",\n                        ""filament_max_volumetric_speed"",\n                        ""filament_type"",\n                        ""filament_soluble"",\n                        ""first_layer_bed_temperature"",\n                        ""first_layer_temperature"",\n                        ""max_fan_speed"",\n                        ""max_layer_height"",\n                        ""min_fan_speed"",\n                        ""min_layer_height"",\n                        ""min_print_speed"",\n                        ""nozzle_diameter"",\n                        ""retract_before_travel"",\n                        ""retract_before_wipe"",\n                        ""retract_layer_change"",\n                        ""retract_length"",\n                        ""retract_length_toolchange"",\n                        ""retract_lift"",\n                        ""retract_lift_above"",\n                        ""retract_lift_below"",\n                        ""retract_restart_extra"",\n                        ""retract_restart_extra_toolchange"",\n                        ""retract_speed"",\n                        ""slowdown_below_layer_time"",\n                        ""temperature"",\n                        ""wipe""]\n\n\n\n    def __init__(self, controller):\n        super(Slic3rEngineRunner, self).__init__()\n        self.is_running = True\n        self.controller = controller\n\n        self.gcode = GCode(self.controller.app_config.tmp_place + \'out.gcode\', self.controller, None, None)\n\n        system_platform = platform.system()\n        if system_platform in [\'Linux\']:\n            self.slicer_place = [self.controller.app_config.local_path + ""tools/Slic3r-Lite/bin/slic3r""]\n        elif system_platform in [\'Darwin\']:\n            self.slicer_place = [self.controller.app_config.local_path + ""tools/Slic3r-Lite/Slic3r.app/Contents/MacOS/Slic3r""]\n        elif system_platform in [\'Windows\']:\n            self.slicer_place = [\'tools\\\\Slic3r-Lite\\\\slic3r-noconsole.exe\']\n        else:\n            self.slicer_place = [\'slic3r\']\n\n        #print(self.slicer_place)\n\n        self.step_max = 9\n        self.step = 0\n\n\n    def translate_dictionary(self, old, update):\n        #config file parameter name, internal parameter name, data conversion function\n        translation_table = [\n            [\'fill_density\', \'infill\', self.percent_transform],\n            [\'brim_width\', \'brim\', self.brim_transform],\n            #[\'support_material\', \'support\', self.boolean_transform]\n            [\'support_material\', \'support_on_off\', self.support1_transform],\n            [\'support_material_buildplate_only\', \'support_build_plate\', self.support2_transform],\n            [\'overhangs\', \'overhangs\', self.support3_transform],\n            [\'support_material_extruder\', \'support_material_extruder\', self.support4_transform],\n            [\'support_material_interface_extruder\', \'support_material_interface_extruder\', self.str_transform],\n            #[\'support_material_with_sheath\', \'support_material_with_sheath\', self.support5_transform],\n\n            [\'wipe_tower\', \'is_wipe_tower\', self.str_transform],\n            [\'wipe_tower_per_color_wipe\', \'wipe_size_y\', self.str_transform],\n            [\'wipe_tower_width\', \'wipe_size_x\', self.str_transform],\n            [\'wipe_tower_x\', \'wipe_pos_x\', self.str_transform],\n            [\'wipe_tower_y\', \'wipe_pos_y\', self.str_transform],\n\n            [\'single_extruder_multi_material\', \'is_multimat\', self.str_transform]\n        ]\n        for i in translation_table:\n            old[i[0]] = i[2](update[i[1]])\n        return old\n\n    def percent_transform(self, in_value):\n        return ""%s"" % str(in_value) + \'%\'\n\n    def brim_transform(self, in_value):\n        return ""%s"" % str(int(in_value)*10)\n\n    def support1_transform(self, in_value):\n        print(""Support transform 1: "" + str(in_value))\n        if in_value == 0:   #None\n            return ""0""\n        elif in_value >= 1: #Build plate only\n            return ""1""\n        return ""0""\n\n    def support2_transform(self, in_value):\n        print(""Support transform 2: "" + str(in_value))\n        if in_value == 0:   #None\n            return ""0""\n        elif in_value == 1: #Build plate only\n            return ""1""\n        elif in_value == 2: #Everywhere\n            return ""0""\n        elif in_value == 3: #Build plate only with interface\n            return ""1""\n        elif in_value == 4: #Everywhere with interface\n            return ""0""\n        else:\n            return ""0""\n        return ""0""\n\n    def support3_transform(self, in_value):\n        print(""Support transform 3: "" + str(in_value))\n        if in_value == 0:   #None\n            return ""0""\n        elif in_value >= 1: #other support options\n            return ""1""\n        else:\n            return ""1""\n        return ""0""\n\n    def support4_transform(self, in_value):\n        print(""Support transform 4: "" + str(in_value))\n        #support material extruder\n        [a, b] = in_value\n        if b == 0:   #None\n            return ""0""\n        elif b == 1: #Build plate only\n            return self.str_transform(a)\n        elif b == 2: #Everywhere\n            return self.str_transform(a)\n        elif b > 2: #Build plate only\n            return ""0""\n        return ""0""\n\n    def support5_transform(self, in_value):\n        print(""Support transform 4: "" + str(in_value))\n        #support material extruder\n        [a, b] = in_value\n        if b == 0:   #None\n            return ""0""\n        elif b == 1: #Build plate only\n            return self.str_transform(a)\n        elif b == 2: #Everywhere\n            return self.str_transform(a)\n        elif b > 2: #Build plate only\n            return ""0""\n        return ""0""\n\n    def str_transform(self, in_value):\n        return ""%s"" % str(in_value)\n\n    def list_to_str(self, lst):\n        return \',\'.join(str(e) for e in lst)\n\n\n    def save_configuration(self, filename):\n        actual_printing_data = self.controller.get_actual_printing_data()\n        for i in actual_printing_data:\n            if i in [\'brim\', \'support_on_off\'] and actual_printing_data[i]==True:\n                self.step_max+=1\n\n        #material_printing_data = self.controller.get_printing_parameters_for_material_quality(actual_printing_data[\'material\'], actual_printing_data[\'quality\'])\n        material_printing_data = self.controller.printing_parameters.get_actual_settings(self.controller.get_actual_printer(), self.controller.settings[\'printer_type\'], actual_printing_data[\'material\'], actual_printing_data[\'quality\'], self)\n        #print(""All settings: "" + str(material_printing_data))\n        new_parameters = self.translate_dictionary(material_printing_data, actual_printing_data)\n        new_config = configparser.RawConfigParser()\n        new_config.add_section(\'settings\')\n        #new_config.set(\'settings\', i, new_parameters)\n        for i in new_parameters:\n            if type(new_parameters[i]) == list:\n                new_config.set(\'settings\', i, self.list_to_str(new_parameters[i]))\n            else:\n                new_config.set(\'settings\', i, new_parameters[i])\n\n        #write ini file\n        with open(filename, \'w\') as ini_file:\n            fake_file = io.StringIO()\n            new_config.write(fake_file)\n            ini_file.write(fake_file.getvalue()[11:])\n\n        print(""saved"")\n\n\n    def slice(self):\n        self.save_configuration(self.controller.app_config.tmp_place + \'prusacontrol.ini\')\n        self.process = subprocess.Popen(\n                    self.slicer_place + [self.controller.app_config.tmp_place + \'tmp.prusa\', \'--load\',\n                                         self.controller.app_config.tmp_place + \'prusacontrol.ini\', \'--output\',\n                                         self.controller.app_config.tmp_place + \'out.gcode\', \'--dont-arrange\'],\n                    stdout=subprocess.PIPE)\n\n        #if self.controller.is_multimaterial() and not self.controller.is_single_material_mode():\n        #    self.process = subprocess.Popen(\n        #        self.slicer_place + [self.controller.app_config.tmp_place + \'tmp.prusa\', \'--load\',\n        #                             self.controller.app_config.tmp_place + \'prusacontrol.ini\', \'--output\',\n        #                             self.controller.app_config.tmp_place + \'out.gcode\', \'--dont-arrange\'],\n        #        stdout=subprocess.PIPE)\n        #else:\n        #    self.process = subprocess.Popen(self.slicer_place + [self.controller.app_config.tmp_place + \'tmp.stl\', \'--load\',\n        #                            self.controller.app_config.tmp_place + \'prusacontrol.ini\', \'--output\',\n        #                            self.controller.app_config.tmp_place + \'out.gcode\', \'--dont-arrange\'],\n        #                           stdout=subprocess.PIPE)\n        self.check_progress()\n\n    def kill(self):\n        self.process.kill()\n\n    def check_progress(self):\n        #self.gcode.set_running_variable(self.is_running)\n        self.step = 16\n        step_coef = 40./(len(self.controller.scene.get_models(False))*7.)\n        while self.is_running is True:\n            self.step+=(1.*step_coef)\n            if self.process.returncode == -signal.SIGSEGV:\n                self.send_message.emit(""Slic3r engine crash"")\n                break\n            line = str(self.process.stdout.readline(), \'utf-8\')\n            parsed_line = line.rsplit()\n            print(parsed_line)\n            if not line:\n                continue\n            if \'Done.\' in parsed_line[0]:\n                self.step_increased.emit(75)\n                self.send_message.emit(""Generating G-code preview"")\n\n                if self.gcode.read_in_realtime(True, self.set_gcode_progressbar):\n                    self.send_gcodedata.emit(self.gcode)\n                else:\n                    self.send_message.emit("""")\n                    return\n                self.send_message.emit("""")\n            elif \'Filament\' in parsed_line[0] and \'required:\' in parsed_line[1]:\n                filament_str = str(parsed_line[2] + \' \' + parsed_line[3])\n                self.filament_info.emit(filament_str)\n                self.finished.emit()\n                #self.step_increased.emit(100)\n                break\n            else:\n                text = line.rsplit()[1:]\n                if text[0] == \'Exporting\':\n                    text = text[:2]\n                self.send_message.emit("" "".join(text))\n            self.step_increased.emit(int(self.step))\n\n    def set_gcode_progressbar(self, value):\n        start = 75\n        final = int(((value+0.001)/100.)*25.)\n        self.step_increased.emit(start+final)\n\n\n    def end(self):\n        self.end_callback()\n\n    def get_version(self):\n        version_process = subprocess.Popen(self.slicer_place + [""--version""], stdout=subprocess.PIPE)\n        version_info = str(version_process.stdout.readline(), \'utf-8\')\n        return version_info\n\nclass CuraEngine(SlicerEngineAbstract):\n    \'\'\'\n    This is just connector to console version of Slic3r software\n    first version\n    \'\'\'\n    pass\n\nclass OwnSlicerEngine(SlicerEngineAbstract):\n    \'\'\'\n    PrusaResearch slicer engine, designed for their printers\n    Future\n    \'\'\'\n    pass\n\n\nclass SlicerEngineManager(QObject):\n    \'\'\'\n    SlicerEngineManager is class designed for managing slicers engine and prepare parameters\n    \'\'\'\n    cancel_signal = pyqtSignal()\n\n    def __init__(self, controller):\n        super(SlicerEngineManager, self).__init__()\n        self.controller = controller\n        self.slice_thread = None\n        self.slice_engine = Slic3rEngineRunner(self.controller)\n\n\n    def slice(self):\n        self.slice_thread = QThread()\n        #TODO:Make it universal(for other slice engines)\n        self.slice_engine = Slic3rEngineRunner(self.controller)\n        self.slice_engine.moveToThread(self.slice_thread)\n        self.slice_thread.started.connect(self.slice_engine.slice)\n        self.slice_engine.finished.connect(self.thread_ended)\n        self.slice_engine.filament_info.connect(self.controller.set_print_info_text)\n        self.slice_engine.step_increased.connect(self.controller.set_progress_bar)\n        self.slice_engine.send_message.connect(self.controller.slicing_message)\n        self.slice_engine.send_gcodedata.connect(self.controller.set_gcode_instance)\n\n        self.cancel_signal.connect(self.slice_engine.gcode.gcode_parser.cancel_parsing)\n\n        self.slice_thread.start()\n\n    def cancel(self):\n        logging.debug(""Thread canceling"")\n        if self.slice_engine and self.slice_thread:\n            self.slice_engine.is_running = False\n            self.cancel_signal.emit()\n            self.slice_engine.kill()\n            self.slice_thread.quit()\n            self.slice_thread.wait()\n            self.controller.status = \'canceled\'\n            self.controller.set_generate_button()\n            self.controller.set_progress_bar(0.0)\n\n    def thread_ended(self):\n        self.slice_thread.quit()\n        #TODO: add function to read gcode\n        self.controller.scene_was_sliced()\n\n\n    def get_version(self):\n        return self.slice_engine.get_version()\n\n'"
