file_path,api_count,code
perlin2d.py,11,"b""import numpy as np\n\ndef generate_perlin_noise_2d(shape, res):\n    def f(t):\n        return 6*t**5 - 15*t**4 + 10*t**3\n    \n    delta = (res[0] / shape[0], res[1] / shape[1])\n    d = (shape[0] // res[0], shape[1] // res[1])\n    grid = np.mgrid[0:res[0]:delta[0],0:res[1]:delta[1]].transpose(1, 2, 0) % 1\n    # Gradients\n    angles = 2*np.pi*np.random.rand(res[0]+1, res[1]+1)\n    gradients = np.dstack((np.cos(angles), np.sin(angles)))\n    g00 = gradients[0:-1,0:-1].repeat(d[0], 0).repeat(d[1], 1)\n    g10 = gradients[1:  ,0:-1].repeat(d[0], 0).repeat(d[1], 1)\n    g01 = gradients[0:-1,1:  ].repeat(d[0], 0).repeat(d[1], 1)\n    g11 = gradients[1:  ,1:  ].repeat(d[0], 0).repeat(d[1], 1)\n    # Ramps\n    n00 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]  )) * g00, 2)\n    n10 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]  )) * g10, 2)\n    n01 = np.sum(np.dstack((grid[:,:,0]  , grid[:,:,1]-1)) * g01, 2)\n    n11 = np.sum(np.dstack((grid[:,:,0]-1, grid[:,:,1]-1)) * g11, 2)\n    # Interpolation\n    t = f(grid)\n    n0 = n00*(1-t[:,:,0]) + t[:,:,0]*n10\n    n1 = n01*(1-t[:,:,0]) + t[:,:,0]*n11\n    return np.sqrt(2)*((1-t[:,:,1])*n0 + t[:,:,1]*n1)\n        \ndef generate_fractal_noise_2d(shape, res, octaves=1, persistence=0.5):\n    noise = np.zeros(shape)\n    frequency = 1\n    amplitude = 1\n    for _ in range(octaves):\n        noise += amplitude * generate_perlin_noise_2d(shape, (frequency*res[0], frequency*res[1]))\n        frequency *= 2\n        amplitude *= persistence\n    return noise\n    \nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n    \n    np.random.seed(0)\n    noise = generate_perlin_noise_2d((256, 256), (8, 8))\n    plt.imshow(noise, cmap='gray', interpolation='lanczos')\n    plt.colorbar()\n    \n    np.random.seed(0)\n    noise = generate_fractal_noise_2d((256, 256), (8, 8), 5)\n    plt.figure()\n    plt.imshow(noise, cmap='gray', interpolation='lanczos')\n    plt.colorbar()\n    plt.show()\n"""
perlin3d.py,14,"b""import numpy as np\n    \ndef generate_perlin_noise_3d(shape, res):\n    def f(t):\n        return 6*t**5 - 15*t**4 + 10*t**3\n    \n    delta = (res[0] / shape[0], res[1] / shape[1], res[2] / shape[2])\n    d = (shape[0] // res[0], shape[1] // res[1], shape[2] // res[2])\n    grid = np.mgrid[0:res[0]:delta[0],0:res[1]:delta[1],0:res[2]:delta[2]]\n    grid = grid.transpose(1, 2, 3, 0) % 1\n    # Gradients\n    theta = 2*np.pi*np.random.rand(res[0]+1, res[1]+1, res[2]+1)\n    phi = 2*np.pi*np.random.rand(res[0]+1, res[1]+1, res[2]+1)\n    gradients = np.stack((np.sin(phi)*np.cos(theta), np.sin(phi)*np.sin(theta), np.cos(phi)), axis=3)\n    g000 = gradients[0:-1,0:-1,0:-1].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g100 = gradients[1:  ,0:-1,0:-1].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g010 = gradients[0:-1,1:  ,0:-1].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g110 = gradients[1:  ,1:  ,0:-1].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g001 = gradients[0:-1,0:-1,1:  ].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g101 = gradients[1:  ,0:-1,1:  ].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g011 = gradients[0:-1,1:  ,1:  ].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    g111 = gradients[1:  ,1:  ,1:  ].repeat(d[0], 0).repeat(d[1], 1).repeat(d[2], 2)\n    # Ramps\n    n000 = np.sum(np.stack((grid[:,:,:,0]  , grid[:,:,:,1]  , grid[:,:,:,2]  ), axis=3) * g000, 3)\n    n100 = np.sum(np.stack((grid[:,:,:,0]-1, grid[:,:,:,1]  , grid[:,:,:,2]  ), axis=3) * g100, 3)\n    n010 = np.sum(np.stack((grid[:,:,:,0]  , grid[:,:,:,1]-1, grid[:,:,:,2]  ), axis=3) * g010, 3)\n    n110 = np.sum(np.stack((grid[:,:,:,0]-1, grid[:,:,:,1]-1, grid[:,:,:,2]  ), axis=3) * g110, 3)\n    n001 = np.sum(np.stack((grid[:,:,:,0]  , grid[:,:,:,1]  , grid[:,:,:,2]-1), axis=3) * g001, 3)\n    n101 = np.sum(np.stack((grid[:,:,:,0]-1, grid[:,:,:,1]  , grid[:,:,:,2]-1), axis=3) * g101, 3)\n    n011 = np.sum(np.stack((grid[:,:,:,0]  , grid[:,:,:,1]-1, grid[:,:,:,2]-1), axis=3) * g011, 3)\n    n111 = np.sum(np.stack((grid[:,:,:,0]-1, grid[:,:,:,1]-1, grid[:,:,:,2]-1), axis=3) * g111, 3)\n    # Interpolation\n    t = f(grid)\n    n00 = n000*(1-t[:,:,:,0]) + t[:,:,:,0]*n100\n    n10 = n010*(1-t[:,:,:,0]) + t[:,:,:,0]*n110\n    n01 = n001*(1-t[:,:,:,0]) + t[:,:,:,0]*n101\n    n11 = n011*(1-t[:,:,:,0]) + t[:,:,:,0]*n111\n    n0 = (1-t[:,:,:,1])*n00 + t[:,:,:,1]*n10\n    n1 = (1-t[:,:,:,1])*n01 + t[:,:,:,1]*n11\n    return ((1-t[:,:,:,2])*n0 + t[:,:,:,2]*n1)\n    \ndef generate_fractal_noise_3d(shape, res, octaves=1, persistence=0.5):\n    noise = np.zeros(shape)\n    frequency = 1\n    amplitude = 1\n    for _ in range(octaves):\n        noise += amplitude * generate_perlin_noise_3d(shape, (frequency*res[0], frequency*res[1], frequency*res[2]))\n        frequency *= 2\n        amplitude *= persistence\n    return noise\n    \nif __name__ == '__main__':\n    import matplotlib.pyplot as plt\n    import matplotlib.animation as animation\n    \n    np.random.seed(0)\n    noise = generate_fractal_noise_3d((32, 256, 256), (1, 4, 4), 4)\n    \n    fig = plt.figure()\n    images = [[plt.imshow(layer, cmap='gray', interpolation='lanczos', animated=True)] for layer in noise]\n    animation = animation.ArtistAnimation(fig, images, interval=50, blit=True)\n    plt.show()\n"""
