file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# Always prefer setuptools over distutils\nfrom setuptools import setup, find_packages\nfrom os import path\nimport io\n\nhere = path.abspath(path.dirname(__file__))\n\nNAME = ""windrose""\nwith io.open(path.join(here, NAME, ""version.py""), ""rt"", encoding=""UTF-8"") as f:\n    exec(f.read())\n\nwith io.open(path.join(here, ""README.md""), ""rt"", encoding=""UTF-8"") as f:\n    long_description = f.read()\n\nsetup(\n    name=NAME,\n    # Versions should comply with PEP440.  For a discussion on single-sourcing\n    # the version across setup.py and the project code, see\n    # https://packaging.python.org/en/latest/development.html#single-sourcing-the-version\n    # version=\'0.0.2\',\n    version=__version__,\n    description=(\n        ""Python Matplotlib, Numpy library to manage wind data, ""\n        ""draw windrose (also known as a polar rose plot)""\n    ),\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    # The project\'s main homepage.\n    url=__url__,\n    # Author details\n    author=__author__,\n    author_email=__email__,\n    # Choose your license\n    license=__license__,\n    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        ""Development Status :: 3 - Alpha"",\n        # Indicate who your project is intended for\n        ""Environment :: Console"",\n        # \'Topic :: Software Development :: Build Tools\',\n        ""Intended Audience :: Developers"",\n        ""Operating System :: OS Independent"",\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        ""Programming Language :: Cython"",\n        ""Programming Language :: Python"",\n        # \'Programming Language :: Python :: 2\',\n        # \'Programming Language :: Python :: 2.6\',\n        ""Programming Language :: Python :: 2.7"",\n        # \'Programming Language :: Python :: 3\',\n        # \'Programming Language :: Python :: 3.2\',\n        # \'Programming Language :: Python :: 3.3\',\n        ""Programming Language :: Python :: 3.4"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        # Pick your license as you wish (should match ""license"" above)\n        # \'License :: CEA CNRS Inria Logiciel Libre License B (CeCILL-B)\',\n        ""License :: OSI Approved :: BSD License"",\n    ],\n    # What does your project relate to?\n    keywords=""python plot matplotlib numpy wind wind rose compass"",\n    # You can just specify the packages manually here if your project is\n    # simple. Or you can use find_packages().\n    packages=find_packages(exclude=[""contrib"", ""docs"", ""tests*""]),\n    # List run-time dependencies here.  These will be installed by pip when your\n    # project is installed. For an analysis of ""install_requires"" vs pip\'s\n    # requirements files see:\n    # https://packaging.python.org/en/latest/technical.html#install-requires-vs-requirements-files\n    install_requires=[""matplotlib"", ""numpy""],\n    # List additional groups of dependencies here (e.g. development dependencies).\n    # You can install these using the following syntax, for example:\n    # $ pip install -e .[dev,test]\n    extras_require={\n        ""dev"": [""check-manifest"", ""pytest""],\n        ""test"": [""coverage"", ""pytest""],\n        ""advanced"": [""pandas"", ""scipy""],\n    },\n    # If there are data files included in your packages that need to be\n    # installed, specify them here.  If using Python 2.6 or less, then these\n    # have to be included in MANIFEST.in as well.\n    package_data={""samples"": [""samples/*.py"", ""samples/*.csv""]},\n    # Although \'package_data\' is the preferred approach, in some case you may\n    # need to place data files outside of your packages.\n    # see http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files\n    # In this case, \'data_file\' will be installed into \'<sys.prefix>/my_data\'\n    # data_files=[(\'my_data\', [\'data/data_file\'])],\n    # To provide executable scripts, use entry points in preference to the\n    # ""scripts"" keyword. Entry points provide cross-platform support and allow\n    # pip to create the appropriate form of executable for the target platform.\n    entry_points={""console_scripts"": [""sample=sample:main""]},\n)\n'"
docs/conf.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# windrose documentation build configuration file, created by\n# sphinx-quickstart on Tue May  1 16:51:19 2018.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(""../windrose""))\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [""sphinx.ext.autodoc"", ""sphinx.ext.intersphinx"", ""sphinx.ext.napoleon""]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [""_templates""]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\nsource_suffix = "".rst""\n\n# The master toctree document.\nmaster_doc = ""index""\n\n# General information about the project.\nproject = ""windrose""\ncopyright = ""2018, Lionel Roubeyrie & Sebastien Celles""\nauthor = ""Lionel Roubeyrie & Sebastien Celles""\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = """"\n# The full version, including alpha/beta/rc tags.\nrelease = """"\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [""_build"", ""Thumbs.db"", "".DS_Store""]\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = ""sphinx""\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\n# html_theme = \'alabaster\'\nhtml_theme = ""sphinx_rtd_theme""\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [""_static""]\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# This is required for the alabaster theme\n# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars\nhtml_sidebars = {\n    ""**"": [\n        ""about.html"",\n        ""navigation.html"",\n        ""relations.html"",  # needs \'show_related\': True theme option to display\n        ""searchbox.html"",\n        ""donate.html"",\n    ]\n}\n\n\n# -- Options for HTMLHelp output ------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = ""windrosedoc""\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        ""windrose.tex"",\n        ""windrose Documentation"",\n        ""Lionel Roubeyrie \\\\& Sebastien Celles"",\n        ""manual"",\n    )\n]\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, ""windrose"", ""windrose Documentation"", [author], 1)]\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        ""windrose"",\n        ""windrose Documentation"",\n        author,\n        ""windrose"",\n        ""One line description of project."",\n        ""Miscellaneous"",\n    )\n]\n\n\ninterpshinx_mapping = {""matplotlib"": (""http://matplotlib.org"", None)}\n'"
samples/example_animate.py,2,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nThis sample need to be improve to provide\na clean API to output animation\n\nMonthly\npython samples/example_animate.py --by M --exit_at 5 --rmax 1000\n\nDaily\npython samples/example_animate.py --by D --exit_at 5 --rmax 60\n\n""""""\n\nimport click\n\nimport time\nimport logging\nimport traceback\n\nimport matplotlib\n\n# matplotlib.use(""Agg"")\nimport matplotlib.pyplot as plt\nimport matplotlib.animation\nimport matplotlib.cm as cm\n\nimport pandas as pd\nimport numpy as np\n\nimport datetime\n\nfrom windrose import WindroseAxes, FIGSIZE_DEFAULT, DPI_DEFAULT\n\nlogging.Formatter.converter = time.gmtime\nlogging.basicConfig(format=""%(asctime)s %(levelname)s %(message)s"", level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\npd.set_option(""max_rows"", 10)\n\nS_FIGSIZE_DEFAULT = "","".join(map(str, FIGSIZE_DEFAULT))\n\n\ndef get_by_func(by=None, by_func=None):\n    if by is None and by_func is None:\n        by = ""MS""\n\n    if by in [""year"", ""yearly"", ""Y""]:\n        return lambda dt: dt.year\n    elif by in [""month"", ""monthly"", ""MS""]:  # MS: month start\n        return lambda dt: (dt.year, dt.month)\n    elif by in [""day"", ""daily"", ""D""]:\n        return lambda dt: (dt.year, dt.month, dt.day)\n    elif by is None and by_func is not None:\n        return by_func\n    else:\n        raise NotImplementedError(""\'%s\' is not an allowed \'by\' parameter"" % by)\n\n\ndef generate(df_all, func, copy=True):\n    if copy:\n        df_all = df_all.copy()\n    df_all[""by""] = df_all.index.map(func)\n    df = df_all.reset_index().set_index([""by"", df_all.index.name])\n    for by_val in df.index.levels[0]:\n        yield df.loc[by_val]\n\n\ndef count(df_all, func):\n    return len(np.unique(df_all.index.map(func)))\n\n\n@click.command()\n@click.option(\n    ""--filename"", default=""samples/sample_wind_poitiers.csv"", help=""Input filename""\n)\n@click.option(""--exit_at"", default=0, help=""premature exit (int) - must be > 1"")\n@click.option(""--by"", default=""month"", help=""Animate by (year, month, day...)"")\n@click.option(""--rmax"", default=1000, help=""rmax"")\n@click.option(\n    ""--filename_out"", default=""windrose_animation.mp4"", help=""Output filename""\n)\n@click.option(""--dpi"", default=DPI_DEFAULT, help=""Dot per inch for plot generation"")\n@click.option(\n    ""--figsize"",\n    default=S_FIGSIZE_DEFAULT,\n    help=""Figure size x,y - default=%s"" % S_FIGSIZE_DEFAULT,\n)\n@click.option(\n    ""--fps"", default=7, help=""Number of frame per seconds for video generation""\n)\n@click.option(""--bins_min"", default=0.01, help=""Bins minimum value"")\n@click.option(""--bins_max"", default=20, help=""Bins maximum value"")\n@click.option(""--bins_step"", default=2, help=""Bins step value"")\n@click.option(""--fontname"", default=""Courier New"", help=""Font name"")\ndef main(\n    filename,\n    exit_at,\n    by,\n    rmax,\n    dpi,\n    figsize,\n    fps,\n    bins_min,\n    bins_max,\n    bins_step,\n    fontname,\n    filename_out,\n):\n    # convert figsize (string like ""8,9"" to a list of float [8.0, 9.0]\n    figsize = figsize.split("","")\n    figsize = map(float, figsize)\n\n    by_func = get_by_func(by)\n\n    # Read CSV file to a Pandas DataFrame\n    df_all = pd.read_csv(filename)\n    df_all[""Timestamp""] = pd.to_datetime(df_all[""Timestamp""])\n    df_all = df_all.set_index(""Timestamp"")\n\n    df_all.index = df_all.index.tz_localize(""UTC"").tz_convert(""UTC"")\n\n    dt_start = df_all.index[0]\n    dt_end = df_all.index[-1]\n\n    td = dt_end - dt_start\n    Nslides = count(df_all, by_func)\n    msg = """"""Starting\nFirst dt: %s\nLast  dt: %s\n      td: %s\n  Slides: %d"""""" % (\n        dt_start,\n        dt_end,\n        td,\n        Nslides,\n    )\n    logger.info(msg)\n\n    # Define bins\n    bins = np.arange(bins_min, bins_max, bins_step)\n\n    # Create figure\n    fig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""w"", edgecolor=""w"")\n\n    # Create a video writer (ffmpeg can create MPEG files)\n    FFMpegWriter = matplotlib.animation.writers[""ffmpeg""]\n    metadata = dict(\n        title=""windrose"",\n        artist=""windrose"",\n        comment=""""""Made with windrose\nhttp://www.github.com/scls19fr/windrose"""""",\n    )\n    writer = FFMpegWriter(fps=fps, metadata=metadata)\n\n    dt_start_process = datetime.datetime.now()\n\n    with writer.saving(fig, filename_out, 100):\n        try:\n            for i, df in enumerate(generate(df_all, by_func)):\n                dt1 = df.index[0]\n                dt2 = df.index[-1]\n                td = dt2 - dt1\n                msg = """"""  Slide %s/%s\n    From %s\n      to %s\n      td %s"""""" % (\n                    i + 1,\n                    Nslides,\n                    dt1,\n                    dt2,\n                    td,\n                )\n                logger.info(msg)\n                remaining = Nslides - (i + 1)\n                now = datetime.datetime.now()\n                td_remaining = (now - dt_start_process) / (i + 1) * remaining\n                logger.info(\n                    """"""    Expected\n    time: %s\n  end at: %s\n""""""\n                    % (td_remaining, now + td_remaining)\n                )\n\n                title = ""  From %s\\n    to %s"" % (dt1, dt2)\n\n                try:\n                    ax = WindroseAxes.from_ax(\n                        fig=fig, rmax=rmax\n                    )  # scatter, bar, box, contour, contourf\n\n                    direction = df[""direction""].values\n                    var = df[""speed""].values\n\n                    # ax.scatter(direction, var, alpha=0.2)\n                    # ax.set_xlim([-bins[-1], bins[-1]])\n                    # ax.set_ylim([-bins[-1], bins[-1]])\n\n                    # ax.bar(direction, var, bins=bins, normed=True, opening=0.8, edgecolor=\'white\')\n\n                    # ax.box(direction, var, bins=bins)\n\n                    # ax.contour(direction, var, cmap=cm.hot, lw=3, bins=bins)\n\n                    ax.contourf(direction, var, bins=bins, cmap=cm.hot)\n                    ax.contour(direction, var, bins=bins, colors=""black"", lw=3)\n\n                    ax.set_legend()\n\n                    # ax = WindAxes.from_ax(fig=fig)  # pdf: probability density function\n                    # ax.pdf(var, bins=bins)\n                    # ax.set_xlim([0, bins[-1]])\n                    # ax.set_ylim([0, 0.4])\n\n                    ax.set_title(title, fontname=fontname)\n\n                    writer.grab_frame()\n                except KeyboardInterrupt:\n                    break\n                except Exception:\n                    logger.error(traceback.format_exc())\n\n                fig.clf()\n                if i > exit_at - 1 and exit_at != 0:  # exit_at must be > 1\n                    break\n        except KeyboardInterrupt:\n            return\n        except Exception:\n            logger.error(traceback.format_exc())\n\n        N = i + 1\n        logger.info(""Number of slides: %d"" % N)\n\n    # plt.show()\n\n    logger.info(""Save file to \'%s\'"" % filename_out)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_by.py,5,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\n""""""\nsample using ""by"" keyword\n""""""\n\nimport click\n\n# import matplotlib\n# matplotlib.use(""Agg"")\n# import matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\n\nimport numpy as np\nimport pandas as pd\n\nfrom windrose import WindroseAxes, FIGSIZE_DEFAULT, DPI_DEFAULT\n\n\nclass AxCollection(object):\n    def __init__(self, fig=None, *args, **kwargs):\n        if fig is None:\n            self.fig = plt.figure(\n                figsize=FIGSIZE_DEFAULT, dpi=DPI_DEFAULT, facecolor=""w"", edgecolor=""w""\n            )\n        else:\n            self.fig = fig\n\n    def animate(self):\n        pass\n\n    def show(self):\n        pass\n\n\nclass Layout(object):\n    """"""\n    Inspired from PdfPages\n        https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/backends/backend_pdf.py - PdfPages\n        http://matplotlib.org/api/backend_pdf_api.html\n        http://matplotlib.org/examples/pylab_examples/multipage_pdf.html\n\n    Inspired also from FFMpegWriter\n        http://matplotlib.org/examples/animation/moviewriter.html\n        https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/animation.py\n        MovieWriter\n    """"""\n\n    def __init__(self, ncols=4, nrows=6, nsheets=1):\n        self.ncols = ncols\n        self.nrows = nrows\n        self.nsheets = nsheets\n\n        self._resize()\n        self._i = 0\n\n    @property\n    def fig(self):\n        return self._array_fig\n\n    def _resize(self):\n        # self._array_ax = np.empty((self.nsheets, self.nrows, self.ncols), dtype=object)\n        self._array_ax = np.empty(self.nsheets, dtype=object)\n        # self._array_ax.fill(None)\n\n        self._array_fig = np.empty(self.nsheets, dtype=object)\n        # self._array_fig.fill(None)\n\n        for i in range(self.nsheets):\n            fig, axs = plt.subplots(nrows=self.nrows, ncols=self.ncols)\n            # print(fig, axs)\n            self._array_fig[i] = fig\n            self._array_ax[i] = axs\n\n    def __repr__(self):\n        s = """"""<Layout\n  cols: %s\n  rows: %s\n  sheets: %s\n>"""""" % (\n            self.ncols,\n            self.nrows,\n            self.nsheets,\n        )\n        return s\n\n    def __enter__(self, *args, **kwargs):\n        print(""enter %s %s"" % (args, kwargs))\n        return self\n\n    def __exit__(self, type, value, traceback):\n        # print(""exit %s %s"" % (args, kwargs))\n        print(""exit %s %s %s"" % (type, value, traceback))\n        # print(""exit"")\n        self.close()\n\n    def close(self):\n        print(""close"")\n\n    def saveax(self):\n        print(""saveax"")\n        self._i += 1\n\n\nclass NormalLayout(Layout):\n    def __init__(self):\n        super(NormalLayout, self).__init__()\n\n\nS_FIGSIZE_DEFAULT = "","".join(map(str, FIGSIZE_DEFAULT))\n\n\ndef by_func_yearly(dt):\n    return dt.year\n\n\ndef by_func_monthly(dt):\n    return dt.year, dt.month\n\n\ndef by_func_daily(dt):\n    return dt.year, dt.month, dt.day\n\n\n@click.command()\n@click.option(\n    ""--filename"", default=""samples/sample_wind_poitiers.csv"", help=""Input filename""\n)\n@click.option(\n    ""--filename_out"", default=""windrose_animation.mp4"", help=""Output filename""\n)\n@click.option(""--dpi"", default=DPI_DEFAULT, help=""Dot per inch for plot generation"")\n@click.option(\n    ""--figsize"",\n    default=S_FIGSIZE_DEFAULT,\n    help=""Figure size x,y - default=%s"" % S_FIGSIZE_DEFAULT,\n)\n@click.option(\n    ""--fps"", default=7, help=""Number of frame per seconds for video generation""\n)\n@click.option(""--bins_min"", default=0.01, help=""Bins minimum value"")\n@click.option(""--bins_max"", default=20, help=""Bins maximum value"")\n@click.option(""--bins_step"", default=2, help=""Bins step value"")\ndef main(filename, dpi, figsize, fps, bins_min, bins_max, bins_step, filename_out):\n    # convert figsize (string like ""8,9"" to a list of float [8.0, 9.0]\n    figsize = figsize.split("","")\n    figsize = map(float, figsize)\n\n    # Read CSV file to a Pandas DataFrame\n    df_all = pd.read_csv(filename)\n    df_all[""Timestamp""] = pd.to_datetime(df_all[""Timestamp""])\n    df_all = df_all.set_index(""Timestamp"")\n    df_all.index = df_all.index.tz_localize(""UTC"").tz_convert(""UTC"")\n    # df_all = df_all.iloc[-10000:,:]\n    df_all = df_all.ix[""2011-07-01"":""2011-12-31""]\n\n    # Get Numpy arrays from DataFrame\n    direction_all = df_all[""direction""].values\n    var_all = df_all[""speed""].values\n    index_all = df_all.index.to_datetime()  # Fixed: .values -> to_datetime()\n    by_all = df_all.index.map(by_func_monthly)\n    by_unique = np.unique(by_all)\n    print(by_unique)\n\n    (ncols, nrows, nsheets) = (4, 3, 2)  # noqa\n    # layout = Layout(4, 3, 2) # ncols, nrows, nsheets\n    # layout = Layout(ncols, nrows, nsheets)\n\n    # layout = Layout(4, 6, 1)\n    # layout.save(ax)\n    # layout.to_pdf(""filename.pdf"")\n    # layout.to_video(""filename.mp4"")\n\n    # fig, ax = plt.subplots(nrows=2, ncols=3)\n\n    # with Layout(4, 6, 1) as layout:\n    #     print(layout)\n    #     #layout.save(ax)\n\n    def tuple_position(i, ncols, nrows):\n        i_sheet, sheet_pos = divmod(i, ncols * nrows)\n        i_row, i_col = divmod(sheet_pos, ncols)\n        return i_sheet, i_row, i_col\n\n    def position_from_tuple(t, ncols, nrows):\n        i_sheet, i_row, i_col = t\n        return i_sheet * ncols * nrows + i_row * ncols + i_col\n\n    assert tuple_position(0, ncols, nrows) == (0, 0, 0)\n    assert tuple_position(1, ncols, nrows) == (0, 0, 1)\n    assert tuple_position(2, ncols, nrows) == (0, 0, 2)\n    assert tuple_position(3, ncols, nrows) == (0, 0, 3)\n    assert tuple_position(4, ncols, nrows) == (0, 1, 0)\n    assert tuple_position(5, ncols, nrows) == (0, 1, 1)\n    assert tuple_position(6, ncols, nrows) == (0, 1, 2)\n    assert tuple_position(7, ncols, nrows) == (0, 1, 3)\n    assert tuple_position(8, ncols, nrows) == (0, 2, 0)\n    assert tuple_position(9, ncols, nrows) == (0, 2, 1)\n    assert tuple_position(10, ncols, nrows) == (0, 2, 2)\n    assert tuple_position(11, ncols, nrows) == (0, 2, 3)\n    assert tuple_position(12, ncols, nrows) == (1, 0, 0)\n    assert tuple_position(13, ncols, nrows) == (1, 0, 1)\n    assert tuple_position(14, ncols, nrows) == (1, 0, 2)\n    assert tuple_position(15, ncols, nrows) == (1, 0, 3)\n    assert tuple_position(16, ncols, nrows) == (1, 1, 0)\n    assert tuple_position(17, ncols, nrows) == (1, 1, 1)\n\n    assert position_from_tuple((0, 0, 0), ncols, nrows) == 0\n    assert position_from_tuple((1, 0, 0), ncols, nrows) == ncols * nrows\n    assert position_from_tuple((2, 0, 0), ncols, nrows) == 2 * ncols * nrows\n    assert position_from_tuple((1, 0, 1), ncols, nrows) == ncols * nrows + 1\n    assert position_from_tuple((1, 1, 1), ncols, nrows) == ncols * nrows + ncols + 1\n    assert position_from_tuple((1, 2, 3), ncols, nrows) == ncols * nrows + 2 * ncols + 3\n\n    for i in range(20):\n        t = tuple_position(i, ncols, nrows)\n        assert position_from_tuple(t, ncols, nrows) == i\n\n    # layout = NormalLayout()\n\n    # with layout.append() as ax:\n    #     pass\n    # layout.show()\n\n    # Define bins\n    bins = np.arange(bins_min, bins_max, bins_step)\n\n    for by_value in by_unique:\n        # by_value = (2011, 5)\n\n        # mask = (by == by_value).all(axis=1)\n        # ToFix: see http://stackoverflow.com/questions/32005403/boolean-indexing-with-numpy-array-and-tuples\n\n        mask = (pd.Series(by_all) == by_value).values\n\n        # print(mask)\n\n        index = index_all[mask]\n        var = var_all[mask]\n        direction = direction_all[mask]\n\n        # Create figure\n        # fig = plt.figure(figsize=figsize, dpi=dpi, facecolor=\'w\', edgecolor=\'w\')\n\n        # Same as above, but with contours over each filled region...\n        ax = WindroseAxes.from_ax()\n        ax.contourf(direction, var, bins=bins, cmap=cm.hot)\n        ax.contour(direction, var, bins=bins, colors=""black"")\n        fontname = ""Courier""\n        # title = by_value\n        dt1 = index[0]\n        dt2 = index[-1]\n        # dt1 = df.index[mask][0]\n        # dt2 = df.index[mask][-1]\n        # td = dt2 - dt1\n        title = ""From %s\\n  to %s"" % (dt1, dt2)\n\n        ax.set_title(title, fontname=fontname)\n        ax.set_legend()\n\n        plt.show()\n\n    # time.sleep(10)\n\n    # print(""Save file to \'%s\'"" % filename_out)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_np_mpl_oo.py,4,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom windrose import WindroseAxes\nfrom windrose import WindAxes\n\nfrom matplotlib import pyplot as plt\nimport matplotlib.cm as cm\nimport numpy as np\n\n\ndef main():\n    # Create wind speed and direction variables\n    N = 500\n    ws = np.random.random(N) * 6\n    wd = np.random.random(N) * 360\n\n    ax = WindroseAxes.from_ax()\n    ax.scatter(wd, ws, alpha=0.2)\n    ax.set_legend()\n\n    # windrose like a stacked histogram with normed (displayed in percent) results\n    ax = WindroseAxes.from_ax()\n    ax.bar(wd, ws, normed=True, opening=0.8, edgecolor=""white"")\n    ax.set_legend()\n\n    # Another stacked histogram representation, not normed, with bins limits\n    ax = WindroseAxes.from_ax()\n    bins = np.arange(0, 8, 1)\n    ax.box(wd, ws, bins=bins)\n    ax.set_legend()\n\n    # A windrose in filled representation, with a controled colormap\n    ax = WindroseAxes.from_ax()\n    ax.contourf(wd, ws, bins=bins, cmap=cm.hot)\n    ax.set_legend()\n\n    # Same as above, but with contours over each filled region...\n    ax = WindroseAxes.from_ax()\n    ax.contourf(wd, ws, bins=bins, cmap=cm.hot)\n    ax.contour(wd, ws, bins=bins, colors=""black"")\n    ax.set_legend()\n\n    # ...or without filled regions\n    ax = WindroseAxes.from_ax()\n    ax.contour(wd, ws, bins=bins, cmap=cm.hot, lw=3)\n    ax.set_legend()\n\n    # print ax._info\n    # plt.show()\n\n    ax = WindAxes.from_ax()\n    bins = np.arange(0, 6 + 1, 0.5)\n    bins = bins[1:]\n    ax.pdf(ws, bins=bins)\n    plt.show()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_pandas.py,5,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport pandas as pd\n\nfrom windrose import plot_windrose\nfrom matplotlib import pyplot as plt\nimport matplotlib.cm as cm\nimport numpy as np\n\n\ndef main():\n    df = pd.read_csv(""samples/sample_wind_poitiers.csv"", parse_dates=[""Timestamp""])\n    # df[\'Timestamp\'] = pd.to_timestamp()\n    df = df.set_index(""Timestamp"")\n\n    # N = 500\n    # ws = np.random.random(N) * 6\n    # wd = np.random.random(N) * 360\n    # df = pd.DataFrame({\'speed\': ws, \'direction\': wd})\n\n    print(df)\n    print(df.dtypes)\n\n    bins = np.arange(0.01, 8, 1)\n    # bins = np.arange(0, 8, 1)[1:]\n    plot_windrose(df, kind=""contour"", bins=bins, cmap=cm.hot, lw=3, rmax=20000)\n    plt.show()\n\n    bins = np.arange(0, 30 + 1, 1)\n    bins = bins[1:]\n\n    ax, params = plot_windrose(df, kind=""pdf"", bins=bins)\n    print(""Weibull params:"")\n    print(params)\n    # plt.savefig(""screenshots/pdf.png"")\n    plt.show()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_pdf_by.py,2,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\n""""""\nExample to create a PDF\nMonthly windrose axe\nOne figure per year\n""""""\n\n\nimport click\n\nimport datetime\n\n# import time\n\nfrom math import pi\n\n# import matplotlib\nimport matplotlib.pyplot as plt\n\n# import matplotlib.animation\nfrom matplotlib.backends.backend_pdf import PdfPages\n\n# import matplotlib.cm as cm\n\nimport numpy as np\nfrom numpy import sin, cos\nimport pandas as pd\n\nfrom windrose import WindroseAxes, WindAxes, plot_windrose, clean  # noqa\nfrom windrose import wrscatter, wrcontour, wrcontourf  # noqa\n\nFIGSIZE_DEFAULT = (16, 12)\nS_FIGSIZE_DEFAULT = "","".join(map(str, FIGSIZE_DEFAULT))\n\nDPI_DEFAULT = 40\n\n\ndef by_func_yearly(dt):\n    return dt.year\n\n\ndef by_func_monthly(dt):\n    return dt.year, dt.month\n\n\ndef by_func_daily(dt):\n    return dt.year, dt.month, dt.day\n\n\n@click.command()\n@click.option(\n    ""--filename"", default=""samples/sample_wind_poitiers.csv"", help=""Input filename""\n)\n@click.option(""--filename_out"", default=""windrose.pdf"", help=""Output filename"")\n@click.option(""--dpi"", default=DPI_DEFAULT, help=""Dot per inch for plot generation"")\n@click.option(\n    ""--figsize"",\n    default=S_FIGSIZE_DEFAULT,\n    help=""Figure size x,y - default=%s"" % S_FIGSIZE_DEFAULT,\n)\n@click.option(""--bins_min"", default=0.01, help=""Bins minimum value"")\n@click.option(""--bins_max"", default=20, help=""Bins maximum value"")\n@click.option(""--bins_step"", default=2, help=""Bins step value"")\n@click.option(""--fontname"", default=""Courier New"", help=""Font name"")\n@click.option(""--show/--no-show"", default=False, help=""Show figure"")\n@click.option(""--dt_from"", default="""", help=""Datetime from"")\n@click.option(""--dt_to"", default="""", help=""Datetime to"")\n@click.option(""--offset"", default=0, help=""Axe figure offset"")\n@click.option(""--ncols"", default=4, help=""Number of columns per figure"")\n@click.option(""--nrows"", default=3, help=""Number of rows per figure"")\ndef main(\n    filename,\n    dt_from,\n    dt_to,\n    dpi,\n    figsize,\n    bins_min,\n    bins_max,\n    bins_step,\n    ncols,\n    nrows,\n    fontname,\n    show,\n    filename_out,\n    offset,\n):\n\n    # convert figsize (string like ""8,9"" to a list of float [8.0, 9.0]\n    figsize = figsize.split("","")\n    figsize = tuple(map(float, figsize))\n    width, height = figsize\n\n    # Read CSV file to a Pandas DataFrame\n    df_all = pd.read_csv(filename)\n    df_all[""Timestamp""] = pd.to_datetime(df_all[""Timestamp""])\n    df_all = df_all.set_index(""Timestamp"")\n    df_all.index = df_all.index.tz_localize(""UTC"").tz_convert(""UTC"")\n    # df_all = df_all.iloc[-10000:,:]\n    # df_all = df_all[\'2011-07-01\':\'2012-12-31\']\n    if dt_from == """":\n        dt_from = df_all.index[0]\n    if dt_to == """":\n        dt_to = df_all.index[-1]\n    df_all = df_all[dt_from:dt_to]\n\n    # Get Numpy arrays from DataFrame\n    direction_all = df_all[""direction""].values\n    var_all = df_all[""speed""].values\n    # index_all = df_all.index.to_datetime()  # Fixed: .values -> to_datetime()\n    by_all = df_all.index.map(by_func_monthly)\n    by_unique = np.unique(by_all)\n    print(by_unique)\n\n    # Define bins\n    # bins = np.arange(bins_min, bins_max, bins_step)\n\n    with PdfPages(filename_out) as pdf:\n\n        for i, by_value in enumerate(by_unique):\n            print(""processing: %s"" % str(by_value))\n\n            if (i + offset) % (ncols * nrows) == 0 or i == 0:\n                # Create figure and axes\n                fig, axs = plt.subplots(\n                    nrows=nrows,\n                    ncols=ncols,\n                    figsize=figsize,\n                    dpi=dpi,\n                    facecolor=""w"",\n                    edgecolor=""w"",\n                )\n                print(""%r\\n%r\\n%r"" % (fig, fig.axes, axs))\n\n            i_sheet, sheet_pos = divmod(i + offset, ncols * nrows)\n            i_row, i_col = divmod(sheet_pos, ncols)\n\n            # ax = axs[i_row][i_col]\n            ax = fig.axes[sheet_pos]\n\n            mask = (pd.Series(by_all) == by_value).values\n\n            # index = index_all[mask]\n            var = var_all[mask]\n            direction = direction_all[mask]\n\n            # df = pd.DataFrame([var, direction], index=[\'Speed\', \'Direction\'], columns=index).transpose()\n            # df.index.name = \'DateTime\'\n            # print(df)\n\n            Vx = var * sin(pi / 180 * direction)\n            Vy = var * cos(pi / 180 * direction)\n            ax.scatter(Vx, Vy, alpha=0.1)\n            v = 40\n            ax.set_xlim(-v, v)\n            ax.set_ylim(-v, v)\n\n            # rect = [0.1, 0.1, 0.8, 0.8]\n            # ax = WindroseAxes(fig, rect, facecolor=\'w\')\n            # wrscatter(direction, var, ax=ax) # ToFix!!!! TypeError: Input must be a 2D array.\n\n            # print(direction)\n            # print(var)\n            # print(ax)\n            # wrcontour(direction, var, ax=ax) # ToFix!!!! TypeError: Input must be a 2D array.\n\n            # Same as above, but with contours over each filled region...\n            # ToFix!!!! TypeError: Input must be a 2D array.\n            # ax = WindroseAxes.from_ax(ax)\n            # rect = [0.1, 0.1, 0.8, 0.8]\n            # #axs[i_row][i_col] = WindroseAxes(fig, rect, facecolor=\'w\')\n            # #axs[i_row][i_col] = WindroseAxes.from_ax(fig=fig)\n            # ax = WindroseAxes(fig, rect, facecolor=\'w\')\n            # fig.axes[i + offset] = ax\n            # ax.contourf(direction, var, bins=bins, cmap=cm.hot)\n            # ax.contour(direction, var, bins=bins, colors=\'black\')\n\n            # dt1 = index[0]\n            # dt2 = index[-1]\n            # dt1 = df.index[mask][0]\n            # dt2 = df.index[mask][-1]\n            # td = dt2 - dt1\n\n            # title = by_value\n            # title = ""From %s\\n  to %s"" % (dt1, dt2)\n            # title = ""%04d-%02d"" % (by_value[0], by_value[1])\n            dt = datetime.date(by_value[0], by_value[1], 1)\n            fmt = ""%B""  # ""%Y %B""  # Month\n            title = dt.strftime(fmt)\n            ax.set_title(title, fontname=fontname)\n\n            # ax.set_legend()\n\n            fig_title = dt.strftime(""%Y"")  # Year\n            fig.suptitle(fig_title)\n\n            remaining = (i + offset + 1) % (ncols * nrows)\n            if remaining == 0:\n                save_figure(fig, pdf, show, fig_title)\n\n        if remaining != 0:\n            save_figure(fig, pdf, show, fig_title)\n\n        # time.sleep(10)\n\n        print(""Save file to \'%s\'"" % filename_out)\n\n        print(""remaining: %d"" % remaining)\n\n\ndef save_figure(fig, pdf, show, fig_title):\n    filename = ""windrose_%s.png"" % fig_title\n    print(""save_figure: %s"" % filename)\n    if show:\n        plt.show()\n    fig.savefig(filename)  # Save to image\n    pdf.savefig(fig)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_statistical_input.py,3,"b'import click\nfrom windrose import WindroseAxes\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport os\n\n\nFILENAME_DEFAULT = os.path.join(\n    os.path.dirname(os.path.abspath(__file__)),\n    ""amalia_directionally_averaged_speeds.txt"",\n)\n\n\n@click.command()\n@click.option(""--filename"", default=FILENAME_DEFAULT, help=""Input filename"")\ndef main(filename):\n    fig = plt.figure(figsize=(12, 8), dpi=80, facecolor=""w"", edgecolor=""w"")\n    ax = WindroseAxes(fig, [0.1, 0.1, 0.8, 0.8], facecolor=""w"")\n    fig.add_axes(ax)\n    windRose = np.loadtxt(filename)\n    indexes = np.where(windRose[:, 1] > 0.1)\n    windDirections = windRose[indexes[0], 0]\n    windSpeeds = windRose[indexes[0], 1]\n    # windSpeeds = windRose[indexes[0], 1] * 2 / np.sqrt(np.pi)  # convert from mean wind speed to weibull scale factor\n    windFrequencies = windRose[indexes[0], 2]\n    # size = len(windDirections)\n    ax.box(\n        windDirections,\n        windSpeeds,\n        frequency=windFrequencies,\n        mean_values=1,\n        bins=[15, 18, 20, 23, 25],\n        nsector=72,\n    )\n    # ax.box(windDirections, [[windSpeeds[i], 2] for i in range(len(windSpeeds))], frequency=windFrequencies, weibull_factors=1, bins=[15, 18, 20, 23, 25], nsector=72)\n    ax.set_yticklabels([])\n    plt.show()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
samples/example_subplots.py,1,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport click\n\nimport datetime\nimport pandas as pd\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib.cm as cm\n\nimport windrose  # noqa\n\npd.set_option(""max_rows"", 10)\n\n\ndef get_by_func(by=None, by_func=None):\n    if by is None and by_func is None:\n        by = ""MS""\n\n    if by in [""year"", ""yearly"", ""Y""]:\n        return lambda dt: dt.year\n    elif by in [""month"", ""monthly"", ""MS""]:  # MS: month start\n        return lambda dt: (dt.year, dt.month)\n    elif by in [""day"", ""daily"", ""D""]:\n        return lambda dt: (dt.year, dt.month, dt.day)\n    elif by is None and by_func is not None:\n        return by_func\n    else:\n        raise NotImplementedError(""\'%s\' is not an allowed \'by\' parameter"" % by)\n\n\ndef tuple_position(i, nrows, ncols):\n    i_sheet, sheet_pos = divmod(i, ncols * nrows)\n    i_row, i_col = divmod(sheet_pos, ncols)\n    return i_sheet, i_row, i_col\n\n\n@click.command()\n@click.option(\n    ""--filename"", default=""samples/sample_wind_poitiers.csv"", help=""Input filename""\n)\n@click.option(""--year"", default=2014, help=""Year"")\ndef main(filename, year):\n    df_all = pd.read_csv(filename, parse_dates=[""Timestamp""])\n    df_all = df_all.set_index(""Timestamp"")\n\n    f_year = get_by_func(""year"")\n    df_all[""by_page""] = df_all.index.map(f_year)\n    f_month = get_by_func(""month"")\n    df_all[""by""] = df_all.index.map(f_month)\n\n    df_all = df_all.reset_index().set_index([""by_page"", ""by"", ""Timestamp""])\n\n    print(df_all)\n\n    nrows, ncols = 3, 4\n    fig = plt.figure()\n    bins = np.arange(0.01, 8, 1)\n\n    fig.suptitle(""Wind speed - %d"" % year)\n    for month in range(1, 13):\n        ax = fig.add_subplot(nrows, ncols, month, projection=""windrose"")\n        title = datetime.datetime(year, month, 1).strftime(""%b"")\n        ax.set_title(title)\n        try:\n            df = df_all.loc[year].loc[(year, month)]\n        except KeyError:\n            continue\n        direction = df[""direction""].values\n        var = df[""speed""].values\n        # ax.contour(direction, var, bins=bins, colors=\'black\', lw=3)\n        ax.contourf(direction, var, bins=bins, cmap=cm.hot)\n        ax.contour(direction, var, bins=bins, colors=""black"")\n\n    plt.show()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
tests/__init__.py,0,b''
tests/test_windrose.py,9,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# Run all unit tests (from project root directory)\n# $ pytest -vv tests\n\n# Run a test (from project root directory)\n# $ pytest -vv tests/test_windrose.py::test_windrose_np_plot_and_pd_plot\n\nimport matplotlib\n\nmatplotlib.use(""Agg"")  # noqa\n\n# import matplotlib as mpl\nfrom matplotlib import pyplot as plt\nfrom matplotlib import cm as cm\n\nfrom windrose import WindroseAxes\nfrom windrose import WindAxes\nfrom windrose import WindAxesFactory\n\n# from windrose import FIGSIZE_DEFAULT, DPI_DEFAULT\nfrom windrose import wrbar, wrbox, wrcontour, wrcontourf, wrpdf, wrscatter\nfrom windrose import plot_windrose\n\nimport numpy as np\nimport pandas as pd\n\n\n# Create wind speed and direction variables\nN = 500\nws = np.random.random(N) * 6\nwd = np.random.random(N) * 360\n\ndf = pd.DataFrame({""speed"": ws, ""direction"": wd})\n\n\ndef test_windrose_np_mpl_oo():\n    bins = np.arange(0, 8, 1)\n\n    # windrose with scatter plot\n    ax = WindroseAxes.from_ax()\n    ax.scatter(wd, ws, alpha=0.2)\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/scatter.png"")\n\n    # windrose like a stacked histogram with normed (displayed in percent) results\n    ax = WindroseAxes.from_ax()\n    ax.bar(wd, ws, normed=True, opening=0.8, edgecolor=""white"")\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/bar.png"")\n\n    # Another stacked histogram representation, not normed, with bins limits\n    ax = WindroseAxes.from_ax()\n    ax.box(wd, ws, bins=bins)\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/box.png"")\n\n    # A windrose in filled representation, with a controled colormap\n    ax = WindroseAxes.from_ax()\n    ax.contourf(wd, ws, bins=bins, cmap=cm.hot)\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/contourf.png"")\n\n    # Same as above, but with contours over each filled region...\n    ax = WindroseAxes.from_ax()\n    ax.contourf(wd, ws, bins=bins, cmap=cm.hot)\n    ax.contour(wd, ws, bins=bins, colors=""black"")\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/contourf-contour.png"")\n\n    # ...or without filled regions\n    ax = WindroseAxes.from_ax()\n    ax.contour(wd, ws, bins=bins, cmap=cm.hot, lw=3)\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/contour.png"")\n\n    # print ax._info\n    # plt.show()\n\n    ax = WindAxes.from_ax()\n    bins = bins[1:]\n    ax.pdf(ws, bins=bins)\n    plt.savefig(""tests/output/oo/pdf.png"")\n\n\ndef test_windrose_np_mpl_func():\n    bins = np.arange(0, 8, 1)\n\n    wrscatter(wd, ws, alpha=0.2)\n    plt.savefig(""tests/output/func/scatter.png"")\n\n    wrbar(wd, ws, normed=True, opening=0.8, edgecolor=""white"")\n    plt.savefig(""tests/output/func/bar.png"")\n\n    wrbox(wd, ws, bins=bins)\n    plt.savefig(""tests/output/func/box.png"")\n\n    wrcontourf(wd, ws, bins=bins, cmap=cm.hot)\n    plt.savefig(""tests/output/func/contourf.png"")\n\n    # ax = wrcontourf(wd, ws, bins=bin, cmap=cm.hot)\n    # wrcontour(wd, ws, bins=np.arange(0, 8, 1), colors=\'black\')\n    # plt.savefig(\'tests/output/func/wrcontourf-contour.png\')\n\n    wrcontour(wd, ws, bins=bins, cmap=cm.hot, lw=3)\n    plt.savefig(""tests/output/func/contour.png"")\n\n    wrpdf(ws, bins=bins)\n    plt.savefig(""tests/output/func/pdf.png"")\n\n\ndef test_windrose_pandas():\n    bins = np.arange(0.01, 8, 1)\n\n    kind = ""scatter""\n    plot_windrose(df, kind=kind, alpha=0.2)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    kind = ""bar""\n    plot_windrose(df, kind=kind, normed=True, opening=0.8, edgecolor=""white"")\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    kind = ""box""\n    plot_windrose(df, kind=kind, bins=bins)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    kind = ""contourf""\n    plot_windrose(df, kind=kind, bins=bins, cmap=cm.hot)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    kind = ""contour""\n    plot_windrose(df, kind=kind, bins=bins, cmap=cm.hot, lw=3)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    kind = ""pdf""\n    plot_windrose(df, kind=kind, bins=bins)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n\ndef test_windaxesfactory():\n    ax = WindAxesFactory.create(""WindroseAxes"")\n    ax.bar(wd, ws, normed=True, opening=0.8, edgecolor=""white"")\n    ax.set_legend()\n    plt.savefig(""tests/output/oo/bar_from_factory.png"")\n\n    ax = WindAxesFactory.create(""WindAxes"")\n    bins = np.arange(0, 8, 1)\n    bins = bins[1:]\n    ax.pdf(ws, bins=bins)\n    plt.savefig(""tests/output/oo/pdf_from_factory.png"")\n\n\ndef test_windrose_np_plot_and_pd_plot():\n    # bins = np.arange(0.01, 8, 1)\n    kind = ""scatter""\n\n    plot_windrose(df, kind=kind, alpha=0.2)\n    plt.savefig(""tests/output/df/%s.png"" % kind)\n\n    plot_windrose(wd, ws, kind=kind, alpha=0.2)\n    plt.savefig(""tests/output/func/%s.png"" % kind)\n\n\ndef test_windrose_pd_not_default_names():\n    # bins = np.arange(0.01, 8, 1)\n    kind = ""scatter""\n    df_not_default_names = pd.DataFrame({""wind_speed"": ws, ""wind_direction"": wd})\n    plot_windrose(\n        df_not_default_names,\n        kind=kind,\n        alpha=0.2,\n        var_name=""wind_speed"",\n        direction_name=""wind_direction"",\n    )\n\n\n# def test_plot_by():\n#     #df = pd.read_csv(""samples/sample_wind_poitiers.csv"", parse_dates=[\'Timestamp\'])\n#     #df[\'Timestamp\'] = pd.to_timestamp()\n#     #df = df.set_index(\'Timestamp\')\n#     #by = \'year_month\'\n#     #df[by] = df.index.map(lambda dt: (dt.year, dt.month))\n#     #df = df.reset_index()\n#     #df = df.set_index([by, \'Timestamp\'])\n#     #print(df)\n'"
windrose/__init__.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import absolute_import, division, print_function  # noqa\n\nfrom .windrose import WindAxesFactory  # noqa\nfrom .windrose import WindroseAxes  # noqa\nfrom .windrose import WindAxes  # noqa\nfrom .windrose import wrcontour  # noqa\nfrom .windrose import wrcontourf  # noqa\nfrom .windrose import wrbox  # noqa\nfrom .windrose import wrbar  # noqa\nfrom .windrose import wrpdf  # noqa\nfrom .windrose import wrscatter  # noqa\nfrom .windrose import clean  # noqa\nfrom .windrose import clean_df  # noqa\nfrom .windrose import plot_windrose_np  # noqa\nfrom .windrose import plot_windrose_df  # noqa\nfrom .windrose import plot_windrose  # noqa\nfrom .windrose import FIGSIZE_DEFAULT # noqa\nfrom .windrose import DPI_DEFAULT  # noqa\nfrom .windrose import D_KIND_PLOT  # noqa\n\nfrom matplotlib.projections import register_projection\n\nregister_projection(WindroseAxes)\n'"
windrose/version.py,0,"b'__author__ = ""Lionel Roubeyrie""\n__credits__ = [""Sebastien Celles""]\n__email__ = ""s.celles@gmail.com""\n__version__ = ""1.6.7""\n__license__ = ""CeCILL-B OR BSD-3-Clause""\n__url__ = ""https://github.com/python-windrose/windrose""\n__maintainer__ = ""Sebastien Celles""\n'"
windrose/windrose.py,29,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n# from __future__ import absolute_import, division, print_function\n\nimport locale\nimport matplotlib as mpl\nfrom matplotlib import docstring\nimport numpy as np\nimport random\nfrom matplotlib.projections.polar import PolarAxes\nfrom numpy.lib.twodim_base import histogram2d\nimport matplotlib.pyplot as plt\n\nZBASE = -1000  # The starting zorder for all drawing, negative to have the grid on\nVAR_DEFAULT = ""speed""\nDIR_DEFAULT = ""direction""\nFIGSIZE_DEFAULT = (8, 8)\nDPI_DEFAULT = 80\nCALM_CIRCLE_COLOR = ""red""\nCALM_CIRCLE_ALPHA = 0.4\n\n\nclass WindAxesFactory(object):\n    """"""\n\n    Factory class to create WindroseAxes or WindAxes\n\n    """"""\n\n    @staticmethod\n    def create(typ, ax=None, *args, **kwargs):\n        """"""\n\n        Create\n\n        Mandatory:\n\n        Parameters\n        ----------\n        typ : string, \'windroseaxes\' or \'windaxes\'\n            Type of axes to create\n                * windroseaxes : a WindroseAxes axe\n                * windaxe : a WindAxes axe\n\n        ax : matplotlib.Axes, optional\n            A matplotlib axe\n\n        """"""\n        typ = typ.lower()\n        d = {""windroseaxes"": WindroseAxes, ""windaxes"": WindAxes}\n        if typ in d.keys():\n            cls = d[typ]\n            if isinstance(ax, cls):\n                return ax\n            else:\n                ax = cls.from_ax(ax, *args, **kwargs)\n                return ax\n        else:\n            raise NotImplementedError(""typ=%r but it might be in %s"" % (typ, d.keys()))\n\n\nclass WindroseAxes(PolarAxes):\n    """"""\n\n    Create a windrose axes\n\n    """"""\n\n    name = ""windrose""\n\n    def __init__(self, *args, **kwargs):\n        """"""\n        See Axes base class for args and kwargs documentation\n        """"""\n\n        # Uncomment to have the possibility to change the resolution directly\n        # when the instance is created\n        # self.RESOLUTION = kwargs.pop(\'resolution\', 100)\n        self.rmax = kwargs.pop(""rmax"", None)\n        self.theta_labels = kwargs.pop(""theta_labels"") or [""E"", ""N-E"", ""N"", ""N-W"", ""W"", ""S-W"", ""S"", ""S-E""]\n        PolarAxes.__init__(self, *args, **kwargs)\n        self.set_aspect(""equal"", adjustable=""box"", anchor=""C"")\n        self.radii_angle = 67.5\n        self.cla()\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, rmax=None, theta_labels=None, *args, **kwargs):\n        """"""\n        Return a WindroseAxes object for the figure `fig`.\n        """"""\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(\n                    figsize=FIGSIZE_DEFAULT,\n                    dpi=DPI_DEFAULT,\n                    facecolor=""w"",\n                    edgecolor=""w"",\n                )\n            rect = [0.1, 0.1, 0.8, 0.8]\n            ax = WindroseAxes(fig, rect, facecolor=""w"", rmax=rmax, theta_labels=theta_labels, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def cla(self):\n        """"""\n        Clear the current axes\n        """"""\n        PolarAxes.cla(self)\n\n        self.theta_angles = np.arange(0, 360, 45)\n        self.set_thetagrids(angles=self.theta_angles, labels=self.theta_labels)\n\n        self._info = {""dir"": list(), ""bins"": list(), ""table"": list()}\n\n        self.patches_list = list()\n\n        self.calm_count = None\n\n    def _colors(self, cmap, n):\n        """"""\n        Returns a list of n colors based on the colormap cmap\n\n        """"""\n        return [cmap(i) for i in np.linspace(0.0, 1.0, n)]\n\n    def set_radii_angle(self, **kwargs):\n        """"""\n        Set the radii labels angle\n        """"""\n\n        kwargs.pop(""labels"", None)\n        angle = kwargs.pop(""angle"", None)\n        if angle is None:\n            angle = self.radii_angle\n        self.radii_angle = angle\n        N = 5\n        rmax = self.get_rmax()\n        radii = np.linspace(0, rmax, N + 1)\n        if rmax % N == 0:\n            fmt = ""%d""\n        else:\n            fmt = ""%.1f""\n        radii_labels = [fmt % r for r in radii]\n        # radii_labels[0] = """"  # Removing label 0\n        self.set_rgrids(\n            radii=radii[1:], labels=radii_labels[1:], angle=self.radii_angle, **kwargs\n        )\n\n    def _update(self):\n        if not self.rmax:\n            self.rmax = np.max(np.sum(self._info[""table""], axis=0))\n        calm_count = self.calm_count or 0\n        self.set_rmax(rmax=self.rmax + calm_count)\n        self.set_radii_angle(angle=self.radii_angle)\n\n    def legend(self, loc=""lower left"", decimal_places=1, units=None, **kwargs):\n        """"""\n        Sets the legend location and her properties.\n\n        Parameters\n        ----------\n        loc : int, string or pair of floats, default: \'lower left\'\n            see :obj:`matplotlib.pyplot.legend`.\n\n        decimal_places : int, default 1\n            The decimal places of the formated legend\n\n        units: str, default None\n\n        Other Parameters\n        ----------------\n        isaxes : boolean, default True\n            whether this is an axes legend\n        prop : FontProperties(size=\'smaller\')\n            the font property\n        borderpad : float\n            the fractional whitespace inside the legend border\n        shadow : boolean\n            if True, draw a shadow behind legend\n        labelspacing : float, 0.005\n            the vertical space between the legend entries\n        handlelenght : float, 0.05\n            the length of the legend lines\n        handletextsep : float, 0.02\n            the space between the legend line and legend text\n        borderaxespad : float, 0.02\n            the border between the axes and legend edge\n        kwarg\n            Every other kwarg argument supported by\n            :obj:`matplotlib.pyplot.legend`\n        """"""\n\n        def get_handles():\n            handles = list()\n            for p in self.patches_list:\n                if isinstance(p, mpl.patches.Polygon) or isinstance(\n                    p, mpl.patches.Rectangle\n                ):\n                    color = p.get_facecolor()\n                elif isinstance(p, mpl.lines.Line2D):\n                    color = p.get_color()\n                else:\n                    raise AttributeError(""Can\'t handle patches"")\n                handles.append(\n                    mpl.patches.Rectangle(\n                        (0, 0), 0.2, 0.2, facecolor=color, edgecolor=""black""\n                    )\n                )\n            return handles\n\n        def get_labels(decimal_places=1, units=None):\n            _decimal_places = str(decimal_places)\n\n            fmt = ""[%."" + _decimal_places + ""f "" + "": %0."" + _decimal_places + ""f""\n\n            labels = np.copy(self._info[""bins""])\n            if locale.getlocale()[0] in [""fr_FR""]:\n                fmt += ""[""\n            else:\n                fmt += "")""\n\n            if units:\n                fmt += \' \' + units\n\n            labels = [fmt % (labels[i], labels[i + 1]) for i in range(len(labels) - 1)]\n            return labels\n\n        kwargs.pop(""labels"", None)\n        kwargs.pop(""handles"", None)\n\n        # decimal_places = kwargs.pop(\'decimal_places\', 1)\n\n        handles = get_handles()\n        labels = get_labels(decimal_places, units)\n        self.legend_ = mpl.legend.Legend(self, handles, labels, loc, **kwargs)\n        return self.legend_\n\n    def set_legend(self, **pyplot_arguments):\n        if ""borderaxespad"" not in pyplot_arguments:\n            pyplot_arguments[""borderaxespad""] = -0.10\n        legend = self.legend(**pyplot_arguments)\n        plt.setp(legend.get_texts(), fontsize=8)\n        return legend\n\n    def _init_plot(self, direction, var, **kwargs):\n        """"""\n        Internal method used by all plotting commands\n\n        Parameters\n        ----------\n        direction : 1D array,\n            directions the wind blows from, North centred\n        var : 1D array,\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        normed : boolean, default False\n        blowto : boolean, default False\n        colors : str or list of str, default None\n            The colors of the plot.\n        cmap : color map, default `jet`\n            A :obj:`matplotlib.cm` colormap for the plot.\n            Warning! It overrides `colors`.\n        weibull_factors :\n        mean_values :\n        frequency :\n        kwarg\n            Any argument accepted by :obj:`matplotlib.pyplot.plot`.\n        """"""\n\n        # if weibull factors are entered overwrite direction and var\n        if ""weibull_factors"" in kwargs or ""mean_values"" in kwargs:\n            if ""weibull_factors"" in kwargs and ""mean_values"" in kwargs:\n                raise TypeError(""cannot specify both weibull_factors and mean_values"")\n            statistic_type = ""unset""\n            if ""weibull_factors"" in kwargs:\n                statistic_type = ""weibull""\n                val = kwargs.pop(""weibull_factors"")\n            elif ""mean_values"" in kwargs:\n                statistic_type = ""mean""\n                val = kwargs.pop(""mean_values"")\n            if val:\n                if ""frequency"" not in kwargs:\n                    raise TypeError(\n                        ""specify \'frequency\' argument for statistical input""\n                    )\n                windFrequencies = kwargs.pop(""frequency"")\n                if len(windFrequencies) != len(direction) or len(direction) != len(var):\n                    if len(windFrequencies) != len(direction):\n                        raise TypeError(""len(frequency) != len(direction)"")\n                    elif len(direction) != len(var):\n                        raise TypeError(""len(frequency) != len(direction)"")\n                windSpeeds = []\n                windDirections = []\n                for dbin in range(len(direction)):\n                    for _ in range(int(windFrequencies[dbin] * 10000)):\n                        if statistic_type == ""weibull"":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin][0], var[dbin][1])\n                            )\n                        elif statistic_type == ""mean"":\n                            windSpeeds.append(\n                                random.weibullvariate(var[dbin] * 2 / np.sqrt(np.pi), 2)\n                            )\n                        windDirections.append(direction[dbin])\n                var, direction = windSpeeds, windDirections\n\n        # self.cla()\n        kwargs.pop(""zorder"", None)\n\n        # Init of the bins array if not set\n        bins = kwargs.pop(""bins"", None)\n        if bins is None:\n            bins = np.linspace(np.min(var), np.max(var), 6)\n        if isinstance(bins, int):\n            bins = np.linspace(np.min(var), np.max(var), bins)\n        bins = np.asarray(bins)\n        nbins = len(bins)\n\n        # Number of sectors\n        nsector = kwargs.pop(""nsector"", None)\n        if nsector is None:\n            nsector = 16\n\n        # Sets the colors table based on the colormap or the ""colors"" argument\n        colors = kwargs.pop(""colors"", None)\n        cmap = kwargs.pop(""cmap"", None)\n        if colors is not None:\n            if isinstance(colors, str):\n                colors = [colors] * nbins\n            if isinstance(colors, (tuple, list)):\n                if len(colors) != nbins:\n                    raise ValueError(""colors and bins must have same length"")\n        else:\n            if cmap is None:\n                cmap = mpl.cm.jet\n            colors = self._colors(cmap, nbins)\n\n        # Building the angles list\n        angles = np.arange(0, -2 * np.pi, -2 * np.pi / nsector) + np.pi / 2\n\n        normed = kwargs.pop(""normed"", False)\n        blowto = kwargs.pop(""blowto"", False)\n\n        # Calm condition\n        calm_limit = kwargs.pop(""calm_limit"", None)\n        if calm_limit is not None:\n            mask = var > calm_limit\n            self.calm_count = len(var) - np.count_nonzero(mask)\n            if normed:\n                self.calm_count = self.calm_count * 100 / len(var)\n            var = var[mask]\n            direction = direction[mask]\n\n        # Set the global information dictionnary\n        self._info[""dir""], self._info[""bins""], self._info[""table""] = histogram(\n            direction, var, bins, nsector, normed, blowto\n        )\n\n        return bins, nbins, nsector, colors, angles, kwargs\n\n    def _calm_circle(self):\n        """"""\n        Draw the calm centered circle\n        and return the initial offset for plots methods\n        """"""\n        if self.calm_count and self.calm_count > 0:\n            circle = mpl.patches.Circle(\n                (0., 0.),\n                self.calm_count,\n                transform=self.transData._b,\n                color=CALM_CIRCLE_COLOR,\n                alpha=CALM_CIRCLE_ALPHA,\n            )\n            self.add_artist(circle)\n        return self.calm_count or 0\n\n    def contour(self, direction, var, **kwargs):\n        """"""\n        Plot a windrose in linear mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n\n        Other Parameters\n        ----------------\n        sector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360/16=22.5\xc2\xb0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(var), max(var), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color (\'k\' or \'black\'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n\n        """"""\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi / nsector))\n        vals = np.hstack(\n            (\n                self._info[""table""],\n                np.reshape(\n                    self._info[""table""][:, 0], (self._info[""table""].shape[0], 1)\n                ),\n            )\n        )\n\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.plot(angles, val, color=colors[i], zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def contourf(self, direction, var, **kwargs):\n        """"""\n        Plot a windrose in filled mode. For each var bins, a line will be\n        draw on the axes, a segment between each sector (center to center).\n        Each line can be formated (color, width, ...) like with standard plot\n        pylab command.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360/16=22.5\xc2\xb0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6,\n            then bins=linspace(min(`var`), max(`var`), 6)\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color (\'k\' or \'black\'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n\n        others kwargs\n            Any supported argument of :obj:`matplotlib.pyplot.plot`\n        """"""\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(""facecolor"", None)\n        kwargs.pop(""edgecolor"", None)\n\n        # closing lines\n        angles = np.hstack((angles, angles[-1] - 2 * np.pi / nsector))\n        vals = np.hstack(\n            (\n                self._info[""table""],\n                np.reshape(\n                    self._info[""table""][:, 0], (self._info[""table""].shape[0], 1)\n                ),\n            )\n        )\n        offset = self._calm_circle()\n        for i in range(nbins):\n            val = vals[i, :] + offset\n            offset += vals[i, :]\n            zorder = ZBASE + nbins - i\n            patch = self.fill(np.append(angles, 0), np.append(val, 0),\n                              facecolor=colors[i], edgecolor=colors[i],\n                              zorder=zorder, **kwargs)\n            self.patches_list.extend(patch)\n        self._update()\n\n    def bar(self, direction, var, **kwargs):\n        """"""\n        Plot a windrose in bar mode. For each var bins and for each sector,\n        a colored bar will be draw on the axes.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds.\n\n        Other Parameters\n        ----------------\n        nsector : integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360/16=22.5\xc2\xb0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional.\n            if True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color (\'k\' or \'black\'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted\n            in different colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional.\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge box will be plotted.\n            Default : no edgecolor\n        opening : float, optional\n            between 0.0 and 1.0, to control the space between each sector (1.0\n            for no space)\n\n        """"""\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(""facecolor"", None)\n        edgecolor = kwargs.pop(""edgecolor"", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(""edgecolor must be a string color"")\n        opening = kwargs.pop(""opening"", None)\n        if opening is None:\n            opening = 0.8\n        dtheta = 2 * np.pi / nsector\n        opening = dtheta * opening\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[""table""][i - 1, j]\n                val = self._info[""table""][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening / 2, offset),\n                    opening,\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n    def box(self, direction, var, **kwargs):\n        """"""\n        Plot a windrose in proportional box mode. For each var bins and for\n        each sector, a colored box will be draw on the axes.\n\n        Parameters\n        ----------\n        direction : 1D array\n            directions the wind blows from, North centred\n        var : 1D array\n            values of the variable to compute. Typically the wind speeds\n\n        Other Parameters\n        ----------------\n        nsector: integer, optional\n            number of sectors used to compute the windrose table. If not set,\n            nsectors=16, then each sector will be 360/16=22.5\xc2\xb0, and the\n            resulting computed table will be aligned with the cardinals points.\n        bins : 1D array or integer, optional\n            number of bins, or a sequence of bins variable. If not set, bins=6\n            between min(`var`) and max(`var`).\n        blowto : bool, optional\n            If True, the windrose will be pi rotated, to show where the wind\n            blow to (usefull for pollutant rose).\n        colors : string or tuple, optional\n            one string color (\'k\' or \'black\'), in this case all bins will be\n            plotted in this color; a tuple of matplotlib color args (string,\n            float, rgb, etc), different levels will be plotted in different\n            colors in the order specified.\n        cmap : a cm Colormap instance from :obj:`matplotlib.cm`, optional\n            if cmap == None and colors == None, a default Colormap is used.\n        edgecolor : string, optional\n            The string color each edge bar will be plotted.  Default : no\n            edgecolor\n\n        """"""\n\n        bins, nbins, nsector, colors, angles, kwargs = self._init_plot(\n            direction, var, **kwargs\n        )\n        kwargs.pop(""facecolor"", None)\n        edgecolor = kwargs.pop(""edgecolor"", None)\n        if edgecolor is not None:\n            if not isinstance(edgecolor, str):\n                raise ValueError(""edgecolor must be a string color"")\n        opening = np.linspace(0.0, np.pi / 16, nbins)\n\n        offs = self._calm_circle()\n\n        for j in range(nsector):\n            offset = offs\n            for i in range(nbins):\n                if i > 0:\n                    offset += self._info[""table""][i - 1, j]\n                val = self._info[""table""][i, j]\n                zorder = ZBASE + nbins - i\n                patch = mpl.patches.Rectangle(\n                    (angles[j] - opening[i] / 2, offset),\n                    opening[i],\n                    val,\n                    facecolor=colors[i],\n                    edgecolor=edgecolor,\n                    zorder=zorder,\n                    **kwargs\n                )\n                self.add_patch(patch)\n                if j == 0:\n                    self.patches_list.append(patch)\n        self._update()\n\n\nclass WindAxes(mpl.axes.Subplot):\n    def __init__(self, *args, **kwargs):\n        """"""\n        See Axes base class for args and kwargs documentation\n        """"""\n        super(WindAxes, self).__init__(*args, **kwargs)\n\n    @staticmethod\n    def from_ax(ax=None, fig=None, *args, **kwargs):\n        if ax is None:\n            if fig is None:\n                fig = plt.figure(figsize=FIGSIZE_DEFAULT, dpi=DPI_DEFAULT)\n            ax = WindAxes(fig, 1, 1, 1, *args, **kwargs)\n            fig.add_axes(ax)\n            return ax\n        else:\n            return ax\n\n    def pdf(\n        self,\n        var,\n        bins=None,\n        Nx=100,\n        bar_color=""b"",\n        plot_color=""g"",\n        Nbins=10,\n        *args,\n        **kwargs\n    ):\n        """"""\n        Draw probability density function and return Weibull distribution\n        parameters\n        """"""\n        import scipy.stats\n\n        if bins is None:\n            bins = np.linspace(0, np.max(var), Nbins)\n        hist, bins = np.histogram(var, bins=bins, normed=True)\n        width = 0.7 * (bins[1] - bins[0])\n        center = (bins[:-1] + bins[1:]) / 2\n        self.bar(center, hist, align=""center"", width=width, color=bar_color)\n        params = scipy.stats.exponweib.fit(var, floc=0, f0=1)\n        x = np.linspace(0, bins[-1], Nx)\n        self.plot(x, scipy.stats.exponweib.pdf(x, *params), color=plot_color)\n        return (self, params)\n\n\ndef histogram(direction, var, bins, nsector, normed=False, blowto=False):\n    """"""\n    Returns an array where, for each sector of wind\n    (centred on the north), we have the number of time the wind comes with a\n    particular var (speed, polluant concentration, ...).\n\n    Parameters\n    ----------\n    direction : 1D array\n        directions the wind blows from, North centred\n    var : 1D array\n        values of the variable to compute. Typically the wind speeds\n    bins : list\n        list of var category against we\'re going to compute the table\n    nsector : integer\n        number of sectors\n\n    Other Parameters\n    ----------------\n    normed : boolean, default False\n        The resulting table is normed in percent or not.\n    blowto : boolean, default False\n        Normaly a windrose is computed with directions as wind blows from. If\n        true, the table will be reversed (usefull for pollutantrose)\n    """"""\n\n    if len(var) != len(direction):\n        raise ValueError(""var and direction must have same length"")\n\n    angle = 360. / nsector\n\n    dir_bins = np.arange(-angle / 2, 360. + angle, angle, dtype=np.float)\n    dir_edges = dir_bins.tolist()\n    dir_edges.pop(-1)\n    dir_edges[0] = dir_edges.pop(-1)\n    dir_bins[0] = 0.\n\n    var_bins = bins.tolist()\n    var_bins.append(np.inf)\n\n    if blowto:\n        direction = direction + 180.\n        direction[direction >= 360.] = direction[direction >= 360.] - 360\n\n    table = histogram2d(x=var, y=direction, bins=[var_bins, dir_bins], normed=False)[0]\n    # add the last value to the first to have the table of North winds\n    table[:, 0] = table[:, 0] + table[:, -1]\n    # and remove the last col\n    table = table[:, :-1]\n    if normed:\n        table = table * 100 / table.sum()\n\n    return dir_edges, var_bins, table\n\n\n@docstring.copy(WindroseAxes.contour)\ndef wrcontour(direction, var, ax=None, rmax=None, **kwargs):\n    """"""\n    Draw contour probability density function and return Weibull\n    distribution parameters.\n    """"""\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contour(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.contourf)\ndef wrcontourf(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.contourf(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.box)\ndef wrbox(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.box(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindroseAxes.bar)\ndef wrbar(direction, var, ax=None, rmax=None, **kwargs):\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    ax.bar(direction, var, **kwargs)\n    ax.set_legend()\n    return ax\n\n\n@docstring.copy(WindAxes.pdf)\ndef wrpdf(\n    var,\n    bins=None,\n    Nx=100,\n    bar_color=""b"",\n    plot_color=""g"",\n    Nbins=10,\n    ax=None,\n    rmax=None,\n    *args,\n    **kwargs\n):\n    """"""\n    Draw probability density function and return Weitbull distribution\n    parameters\n    """"""\n    ax = WindAxes.from_ax(ax)\n    ax, params = ax.pdf(var, bins, Nx, bar_color, plot_color, Nbins, *args, **kwargs)\n    return (ax, params)\n\n\ndef wrscatter(direction, var, ax=None, rmax=None, *args, **kwargs):\n    """"""\n    Draw scatter plot\n    """"""\n    ax = WindroseAxes.from_ax(ax, rmax=rmax)\n    direction = -np.array(direction) + np.radians(90)\n    ax.scatter(direction, var, *args, **kwargs)\n    return ax\n\n\n# def clean(direction, var):\n#     \'\'\'\n#     Remove masked values in the two arrays, where if a direction data is masked,\n#     the var data will also be removed in the cleaning process (and vice-versa)\n#     \'\'\'\n#     dirmask = direction.mask==False\n#     varmask = direction.mask==False\n#     mask = dirmask*varmask\n#     return direction[mask], var[mask]\n\n\ndef clean_df(df, var=VAR_DEFAULT, direction=DIR_DEFAULT):\n    """"""\n    Remove nan and var=0 values in the DataFrame\n    if a var (wind speed) is nan or equal to 0, this row is\n    removed from DataFrame\n    if a direction is nan, this row is also removed from DataFrame\n    """"""\n    return df[df[var].notnull() & df[var] != 0 & df[direction].notnull()]\n\n\ndef clean(direction, var, index=False):\n    """"""\n    Remove nan and var=0 values in the two arrays\n    if a var (wind speed) is nan or equal to 0, this data is\n    removed from var array but also from dir array\n    if a direction is nan, data is also removed from both array\n    """"""\n    dirmask = np.isfinite(direction)\n    varmask = var != 0 & np.isfinite(var)\n    mask = dirmask * varmask\n    if index is None:\n        index = np.arange(mask.sum())\n        return direction[mask], var[mask], index\n    elif not index:\n        return direction[mask], var[mask]\n    else:\n        index = index[mask]\n        return direction[mask], var[mask], index\n\n\nD_KIND_PLOT = {\n    ""contour"": wrcontour,\n    ""contourf"": wrcontourf,\n    ""box"": wrbox,\n    ""bar"": wrbar,\n    ""pdf"": wrpdf,\n    ""scatter"": wrscatter,\n}\n\n\ndef plot_windrose(\n    direction_or_df,\n    var=None,\n    kind=""contour"",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    if var is None:\n        # Assuming direction_or_df is a DataFrame\n        df = direction_or_df\n        var = df[var_name].values\n        direction = df[direction_name].values\n    else:\n        direction = direction_or_df\n    return plot_windrose_np(direction, var, kind=kind, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_df(\n    df,\n    kind=""contour"",\n    var_name=VAR_DEFAULT,\n    direction_name=DIR_DEFAULT,\n    by=None,\n    rmax=None,\n    **kwargs\n):\n    var = df[var_name].values\n    direction = df[direction_name].values\n    return plot_windrose_np(direction, var, by=by, rmax=rmax, **kwargs)\n\n\ndef plot_windrose_np(\n    direction, var, kind=""contour"", clean_flag=True, by=None, rmax=None, **kwargs\n):\n    if kind in D_KIND_PLOT.keys():\n        f_plot = D_KIND_PLOT[kind]\n    else:\n        raise Exception(""kind=%r but it must be in %r"" % (kind, D_KIND_PLOT.keys()))\n    # if f_clean is not None:\n    #     df = f_clean(df)\n    # var = df[var_name].values\n    # direction = df[direction_name].values\n    if clean_flag:\n        var, direction = clean(var, direction)\n    if by is None:\n        ax = f_plot(direction=direction, var=var, rmax=rmax, **kwargs)\n        if kind not in [""pdf""]:\n            ax.set_legend()\n        return ax\n    else:\n        raise NotImplementedError(\n            ""\'by\' keyword not supported for now ""\n            ""https://github.com/scls19fr/windrose/issues/10""\n        )\n'"
