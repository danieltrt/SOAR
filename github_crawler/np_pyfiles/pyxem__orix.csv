file_path,api_count,code
setup.py,0,"b'from setuptools import setup, find_packages\nfrom orix import __name__, __version__, __author__, __author_email__, __description__\n\n\nsetup(\n    name=__name__,\n    version=str(__version__),\n    license=""GPLv3"",\n    author=__author__,\n    author_email=__author_email__,\n    description=__description__,\n    long_description=open(""README.rst"").read(),\n    classifiers=[\n        ""Programming Language :: Python :: 3"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n        ""Development Status :: 4 - Beta"",\n        ""Intended Audience :: Science/Research"",\n        ""License :: OSI Approved :: GNU General Public License v3 (GPLv3)"",\n        ""Natural Language :: English"",\n        ""Operating System :: OS Independent"",\n        ""Topic :: Scientific/Engineering"",\n        ""Topic :: Scientific/Engineering :: Physics"",\n    ],\n    packages=find_packages(exclude=[""orix/tests""]),\n    # fmt: off\n    install_requires=[\n        ""numpy"",\n        ""scipy"",\n        ""matplotlib"",\n        ""tqdm"",\n        ""h5py"",\n    ],\n    # fmt: on\n    package_data={"""": [""LICENSE"", ""readme.rst""], ""orix"": [""*.py""],},\n)\n'"
orix/__init__.py,0,"b'__name__ = ""orix""\n__version__ = ""0.3.0dev""\n__author__ = ""Ben Martineau, Phillip Crout""\n__author_email__ = ""pyxem.team@gmail.com""\n__description__ = (\n    ""Orientation, rotation, quaternion, and crystal symmetry handling in Python.""\n)\n__credits__ = [\n    ""Ben Martineau"",\n    ""Phillip Crout"",\n    ""Duncan Johnstone"",\n    ""H\xc3\xa5kon Wiik \xc3\x85nes"",\n    ""Simon H\xc3\xb8g\xc3\xa5s"",\n]\n'"
orix/objects.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom orix.quaternion.orientation import Orientation, Misorientation  # pragma: no cover\nfrom orix.vector.neo_euler import (\n    NeoEuler,\n    Homochoric,\n    Rodrigues,\n    AxAngle,\n)  # pragma: no cover\n'"
orix/symmetry.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom orix.quaternion.symmetry import *  # pragma: no cover\nfrom orix.quaternion.orientation_region import OrientationRegion  # pragma: no cover\n'"
orix/base/__init__.py,15,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\n\n\ndef check(obj, cls):\n    if not isinstance(obj, cls):\n        try:\n            obj = cls(obj)\n        except BaseException:\n            raise ValueError(\n                ""Could not turn {} (type {}) into {}"".format(\n                    obj, obj.__class__.__name__, cls.__name__\n                )\n            )\n    return obj\n\n\nclass DimensionError(Exception):\n    def __init__(self, this, data):\n        class_name = this.__class__.__name__\n        required_dimension = this.dim\n        received_dimension = data.shape[-1]\n        super().__init__(\n            ""{} requires data of dimension {} ""\n            ""but received dimension {}."".format(\n                class_name, required_dimension, received_dimension\n            )\n        )\n\n\nclass Object3d:\n    """"""Base class for 3d objects.\n\n    """"""\n\n    dim = None\n    """"""int : The number of dimensions for this object.""""""\n\n    _data = None\n    """"""np.ndarray : Array holding this object\'s numerical data.""""""\n\n    __array_ufunc__ = None\n\n    def __init__(self, data=None):\n        if isinstance(data, Object3d):\n            self._data = data.data\n        else:\n            data = np.atleast_2d(data)\n            if data.shape[-1] != self.dim:\n                raise DimensionError(self, data)\n            self._data = data\n        self.__finalize__(data)\n\n    def __finalize__(self, data):\n        pass\n\n    @property\n    def data(self):\n        return self._data[..., : self.dim]\n\n    @data.setter\n    def data(self, data):\n        self._data[..., : self.dim] = data\n\n    def __repr__(self):\n        name = self.__class__.__name__\n        shape = str(self.shape)\n        data = np.array_str(self.data, precision=4, suppress_small=True)\n        return ""\\n"".join([name + "" "" + shape, data])\n\n    def __getitem__(self, key):\n        data = np.atleast_2d(self.data[key])\n        obj = self.__class__(data)\n        return obj\n\n    def __setitem__(self, key, value):\n        self.data[key] = value.data\n\n    @classmethod\n    def empty(cls):\n        """"""An empty object with the appropriate dimensions.""""""\n        return cls(np.zeros((0, cls.dim)))\n\n    @property\n    def shape(self):\n        """"""tuple : Shape of the object.""""""\n        return self.data.shape[:-1]\n\n    @property\n    def data_dim(self):\n        """"""int : The dimensions of the data.\n\n        For example, if `data` has shape (4, 4, 3), `data_dim` is 3.\n\n        """"""\n        return len(self.shape)\n\n    @property\n    def size(self):\n        """"""int : Total number of entries in this object.""""""\n        return np.prod(self.shape)\n\n    @classmethod\n    def stack(cls, sequence):\n        sequence = [s._data for s in sequence]\n        stack = np.stack(sequence, axis=-2)\n        obj = cls(stack[..., : cls.dim])\n        obj._data = stack\n        return obj\n\n    def flatten(self):\n        """"""Object3d : A new object with the same data in a single column.""""""\n        obj = self.__class__(self.data.T.reshape(self.dim, -1).T)\n        real_dim = self._data.shape[-1]\n        obj._data = self._data.T.reshape(real_dim, -1).T\n        return obj\n\n    def unique(self, return_index=False, return_inverse=False):\n        """"""Returns a new object containing only this object\'s unique entries.\n\n        Unless overridden, this method returns the numerically unique entries.\n        Also removes zero entries which are assumed to be degenerate.\n\n        Parameters\n        ----------\n        return_index : bool, optional\n            If True, will also return the indices of the (flattened) data where\n            the unique entries were found.\n        return_inverse : bool, optional\n            If True, will also return the indices to reconstruct the (flattened)\n            data from the unique data.\n\n        Returns\n        -------\n        dat : Object3d\n            The numerically unique entries.\n        idx : numpy.ndarray, optional\n            The indices of the unique data in the (flattened) array.\n        inv : numpy.ndarray, optional\n            The indices of the (flattened) data in the unique array.\n\n        """"""\n        data = self.flatten()._data.round(9)\n        data = data[~np.all(np.isclose(data, 0), axis=1)]  # Remove zeros\n        _, idx, inv = np.unique(\n            data.round(4), axis=0, return_index=True, return_inverse=True\n        )\n        obj = self.__class__(data[np.sort(idx), : self.dim])\n        obj._data = data[np.sort(idx)]\n        if return_index and return_inverse:\n            return obj, idx, inv\n        elif return_index and not return_inverse:\n            return obj, idx\n        elif return_inverse and not return_index:\n            return obj, inv\n        else:\n            return obj\n\n    @property\n    def norm(self):\n        from orix.scalar import Scalar\n\n        return Scalar(np.sqrt(np.sum(np.square(self.data), axis=-1)))\n\n    @property\n    def unit(self):\n        with np.errstate(divide=""ignore"", invalid=""ignore""):\n            obj = self.__class__(\n                np.nan_to_num(self.data / self.norm.data[..., np.newaxis])\n            )\n            return obj\n\n    def squeeze(self):\n        obj = self.__class__(self)\n        obj._data = np.atleast_2d(np.squeeze(self._data))\n        return obj\n\n    def reshape(self, *shape):\n        """"""Returns a new object containing the same data with a new shape.""""""\n        obj = self.__class__(self.data.reshape(*shape, self.dim))\n        obj._data = self._data.reshape(*shape, -1)\n        return obj\n\n    def get_plot_data(self):\n        return self\n'"
orix/crystal_map/__init__.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""\nCrystallographic map of rotations, crystal phases and key properties associated with\nevery spatial coordinate in a 1D, 2D or 3D space.\n\nAll map properties with a value in each data point are stored as 1D arrays.\n\nSubmodules\n==========\n\n.. autosummary::\n    :toctree: _autosummary\n\n    crystal_map\n    crystal_map_properties\n    phase_list\n""""""\n\nfrom orix.crystal_map.crystal_map import CrystalMap\nfrom orix.crystal_map.phase_list import Phase, PhaseList\nfrom orix.crystal_map.crystal_map_properties import CrystalMapProperties\n'"
orix/crystal_map/crystal_map.py,34,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport copy\n\nimport numpy as np\n\nfrom orix.quaternion.rotation import Rotation\nfrom orix.quaternion.orientation import Orientation\nfrom orix.crystal_map.phase_list import PhaseList, Phase\nfrom orix.crystal_map.crystal_map_properties import CrystalMapProperties\n\n\nclass CrystalMap:\n    """"""Crystallographic map of rotations, crystal phases and key\n    properties associated with every spatial coordinate in a 1D, 2D or 3D\n    space.\n\n    All properties are stored as 1D arrays, and reshaped when necessary.\n\n    Attributes\n    ----------\n    all_indexed : bool\n        Whether all points in data are indexed.\n    dz, dy, dx : float\n        Step sizes in z, y and x directions.\n    id : numpy.ndarray\n        ID of points in the data.\n    is_indexed : numpy.ndarray\n        Whether points in data are indexed.\n    ndim : int\n        Number of data dimensions of points in data.\n    orientations : orix.quaternion.orientation.Orientation\n        Orientations in data.\n    phase_id : numpy.ndarray\n        Phase IDs of points in data.\n    phases : orix.crystal_map.PhaseList\n        List of phases with their IDs, names, crystal symmetry objects and\n        colors (possibly more than are in the data).\n    phases_in_data : orix.crystal_map.PhaseList\n        List of phases in data with their IDs, names, crystal symmetry\n        objects and colors.\n    prop : orix.crystal_map.CrystalMapProperties\n        Dictionary with properties, like quality metrics, in each data\n        point.\n    rotations : orix.quaternion.rotation.Rotation\n        Rotations in data.\n    rotations_per_point : int\n        Number of rotations per data point in data.\n    rotations_shape : tuple\n        Shape of rotation object.\n    scan_unit : str\n        Length unit of data, default is ""px"".\n    shape : tuple\n        Shape of points in data.\n    size : int\n        Total number of points in data.\n    z, y, x : float\n        Coordinates of points in data.\n\n    Methods\n    -------\n    deepcopy()\n        Return a deep copy using :func:`~copy.deepcopy` function.\n    get_map_data(item, decimals=3, fill_value=None)\n        Return an array of a class instance attribute, with values equal\n        to ``False`` in ``self.is_in_data`` set to`fill_value`, of map\n        data shape.\n\n    """"""\n\n    def __init__(\n        self,\n        rotations,\n        phase_id=None,\n        x=None,\n        y=None,\n        z=None,\n        phase_name=None,\n        symmetry=None,\n        prop=None,\n    ):\n        """"""\n        Parameters\n        ----------\n        rotations : orix.quaternion.rotation.Rotation\n            Rotation of each data point. Must be passed with all spatial\n            dimensions in the first array axis (flattened). May contain\n            multiple rotations per point, included in the second array\n            axes. Crystal map data size is set equal to the first array\n            axis\' size.\n        phase_id : numpy.ndarray, optional\n            Phase ID of each pixel. IDs equal to -1 are considered not\n            indexed. If ``None`` is passed (default), all points are\n            considered to belong to one phase with ID 0.\n        x : numpy.ndarray, optional\n            Map x coordinate of each data point. If ``None`` is passed,\n            the map is assumed to be 1D, and it is set to an array of\n            increasing integers from 0 to the length of the `phase_id`\n            array.\n        y : numpy.ndarray, optional\n            Map y coordinate of each data point. If ``None`` is passed,\n            the map is assumed to be 1D, and it is set to ``None``.\n        z : numpy.ndarray, optional\n            Map z coordinate of each data point. If ``None`` is passed,\n            the map is assumed to be 2D or 1D, and it is set to ``None``.\n        phase_name : str or list of str, optional\n            Name of phase(s).\n        symmetry : str, int, orix.quaternion.symmetry.Symmetry or list\\\n                of str, int or orix.quaternion.symmetry.Symmetry, optional\n            Point group of crystal symmetries of phases in the map.\n        prop : dict of numpy.ndarray, optional\n            Dictionary of properties of each data point.\n\n        """"""\n        # Set rotations\n        if not isinstance(rotations, Rotation):\n            raise ValueError(\n                f""rotations must be of type {Rotation}, not {type(rotations)}.""\n            )\n        self._rotations = rotations\n\n        # Set data size\n        data_size = rotations.shape[0]\n\n        # Set phase IDs\n        if phase_id is None:  # Assume single phase data\n            phase_id = np.zeros(data_size)\n        phase_id = phase_id.astype(int)\n        self._phase_id = phase_id\n\n        # Set data point IDs\n        point_id = np.arange(data_size)\n        self._id = point_id\n\n        # Set spatial coordinates\n        if x is None and y is None and z is None:\n            x = np.arange(data_size)\n        self._x = x\n        self._y = y\n        self._z = z\n\n        # Create phase list\n        unique_phase_ids = np.unique(phase_id)  # Sorted in ascending order\n        include_not_indexed = False\n        if unique_phase_ids[0] == -1:\n            include_not_indexed = True\n            unique_phase_ids = unique_phase_ids[1:]\n        self.phases = PhaseList(\n            names=phase_name, symmetries=symmetry, phase_ids=unique_phase_ids,\n        )  # Also sorted in ascending order\n\n        # Set whether measurements are indexed\n        is_indexed = np.ones(data_size, dtype=bool)\n        is_indexed[np.where(phase_id == -1)] = False\n\n        # Add ""not_indexed"" to phase list and ensure not indexed points have correct\n        # phase ID\n        if include_not_indexed:\n            self.phases.add_not_indexed()\n            self._phase_id[~is_indexed] = -1\n\n        # Set array with True for points in data\n        self.is_in_data = np.ones(data_size, dtype=bool)\n\n        # Set scan unit\n        self.scan_unit = ""px""\n\n        # Set properties\n        if prop is None:\n            prop = {}\n        self._prop = CrystalMapProperties(prop, id=point_id)\n\n        # Set original data shape (needed if data shape changes in __getitem__())\n        self._original_shape = self._data_shape_from_coordinates()\n\n    @property\n    def id(self):\n        """"""ID of points in data.""""""\n        return self._id[self.is_in_data]\n\n    @property\n    def size(self):\n        """"""Total number of points in data.""""""\n        return np.sum(self.is_in_data)\n\n    @property\n    def shape(self):\n        """"""Shape of points in data.""""""\n        return self._data_shape_from_coordinates()\n\n    @property\n    def ndim(self):\n        """"""Number of data dimensions of points in data.""""""\n        return len(self.shape)\n\n    @property\n    def x(self):\n        """"""X coordinates of points in data.""""""\n        if self._x is None or len(np.unique(self._x)) == 1:\n            return None\n        else:\n            return self._x[self.is_in_data]\n\n    @property\n    def y(self):\n        """"""Y coordinates of points in data.""""""\n        if self._y is None or len(np.unique(self._y)) == 1:\n            return None\n        else:\n            return self._y[self.is_in_data]\n\n    @property\n    def z(self):\n        """"""Z coordinates of points in data.""""""\n        if self._z is None or len(np.unique(self._z)) == 1:\n            return None\n        else:\n            return self._z[self.is_in_data]\n\n    @property\n    def dx(self):\n        return self._step_size_from_coordinates(self._x)\n\n    @property\n    def dy(self):\n        return self._step_size_from_coordinates(self._y)\n\n    @property\n    def dz(self):\n        return self._step_size_from_coordinates(self._z)\n\n    @property\n    def phase_id(self):\n        """"""Phase IDs of points in data.""""""\n        return self._phase_id[self.is_in_data]\n\n    @phase_id.setter\n    def phase_id(self, value):\n        """"""Set phase ID of points in data by passing an int to `value`.""""""\n        self._phase_id[self.is_in_data] = value\n        if value == -1 and ""not_indexed"" not in self.phases.names:\n            self.phases.add_not_indexed()\n\n    @property\n    def phases_in_data(self):\n        """"""List of phases in data.\n\n        Needed because it can be useful to have phases not in data but in\n        `self.phases`.\n\n        """"""\n        unique_ids = np.unique(self.phase_id)\n        phase_list = self.phases[np.intersect1d(unique_ids, self.phases.phase_ids)]\n        if isinstance(phase_list, Phase):  # One phase in data\n            # Get phase ID so it carries over to the new `PhaseList` object\n            phase = phase_list  # Since it\'s actually a single phase\n            phase_id = self.phases.id_from_name(phase.name)\n            return PhaseList(phases=phase, phase_ids=phase_id)\n        else:  # Multiple phases in data\n            return phase_list\n\n    @property\n    def rotations(self):\n        """"""Rotations in data.""""""\n        return self._rotations[self.is_in_data]\n\n    @property\n    def rotations_per_point(self):\n        """"""Number of rotations per data point in data.""""""\n        return self.rotations.size // self.is_indexed.size\n\n    @property\n    def rotations_shape(self):\n        """"""Shape of rotation object.\n\n        Map shape and possible multiple rotations per point are accounted\n        for. 1-dimensions are squeezed out.\n\n        """"""\n        return tuple(i for i in self.shape + (self.rotations_per_point,) if i != 1)\n\n    @property\n    def orientations(self):\n        """"""Rotations, respecting symmetry, in data.""""""\n        # TODO: Consider whether orientations should be calculated upon loading...\n        # TODO: ... since computing orientations are slow (should benefit from dask!)\n        phases = self.phases_in_data\n        if phases.size == 1:\n            # Extract top matching rotations per point, if more than one\n            if self.rotations_per_point > 1:\n                rotations = self.rotations[:, 0]\n            else:\n                rotations = self.rotations\n            return Orientation(rotations).set_symmetry(phases[:].symmetry)\n        else:\n            raise ValueError(\n                f""Data has the phases {phases.names}, however, you are executing a ""\n                ""command that only permits one phase.""\n            )\n\n    @property\n    def is_indexed(self):\n        """"""Whether points in data are indexed.""""""\n        return self.phase_id != -1\n\n    @property\n    def all_indexed(self):\n        """"""Whether all points in data are indexed.""""""\n        return np.count_nonzero(self.is_indexed) == self.is_indexed.size\n\n    @property\n    def prop(self):\n        """""":class:`~orix.crystal_map.CrystalMapProperties` dictionary with\n        data properties in each data point.\n\n        """"""\n        self._prop.is_in_data = self.is_in_data\n        self._prop.id = self.id\n        return self._prop\n\n    @property\n    def _coordinates(self):\n        """"""Dictionary of coordinates of points in data.""""""\n        # TODO: Make this ""dynamic""/dependable when enabling specimen reference frame\n        return {""z"": self.z, ""y"": self.y, ""x"": self.x}\n\n    @property\n    def _step_sizes(self):\n        """"""Dictionary of step sizes of dimensions in data.""""""\n        # TODO: Make this ""dynamic""/dependable when enabling specimen reference frame\n        return {""z"": self.dz, ""y"": self.dy, ""x"": self.dx}\n\n    @property\n    def _coordinate_axes(self):\n        """"""Dictionary of which data axis corresponds to which cartesian\n        coordinate.\n\n        """"""\n        present_coordinates = [k for k, v in self._coordinates.items() if v is not None]\n        return {i: coord for i, coord in zip(range(self.ndim), present_coordinates)}\n\n    def __getattr__(self, item):\n        """"""Get an attribute in the `prop` dictionary directly from the\n        CrystalMap object.\n\n        Called when the default attribute access fails with an\n        AttributeError.\n\n        """"""\n        if item in self.__getattribute__(""_prop""):\n            return self.prop[item]  # Calls CrystalMapProperties.__getitem__()\n        else:\n            return object.__getattribute__(self, item)\n\n    def __setattr__(self, name, value):\n        """"""Set a class instance attribute.""""""\n        if hasattr(self, ""_prop"") and name in self._prop:\n            self.prop[name] = value  # Calls CrystalMapProperties.__setitem__()\n        else:\n            return object.__setattr__(self, name, value)\n\n    def __getitem__(self, key):\n        """"""Get a masked copy of the CrystalMap object.\n\n        Parameters\n        ----------\n        key : str, slice, tuple, int or boolean numpy.ndarray\n            If ``str``, it must be a valid phase or ""not_indexed"" or\n            ""indexed"". If ``slice`` or ``tuple``, it must be within the\n            map shape. If ``int``, it must be a valid ``self.id``. If\n            boolean array, it must be of map shape.\n\n        Examples\n        --------\n        A CrystalMap object can be indexed in multiple ways...\n\n        >>> cm\n        Phase   Orientations       Name  Symmetry       Color\n            1   5657 (48.4%)  austenite       432    tab:blue\n            2   6043 (51.6%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm.shape\n        (100, 117)\n\n        ... by slicing with slices, integers, or both\n\n        >>> cm2 = cm[20:40, 50:60]\n        >>> cm2\n        Phase   Orientations       Name  Symmetry       Color\n            1    148 (74.0%)  austenite       432    tab:blue\n            2     52 (26.0%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm2.shape\n        (20, 10)\n        >>> cm2 = cm[20:40, 3]\n        >>> cm2\n        Phase   Orientations       Name  Symmetry       Color\n            1     16 (80.0%)  austenite       432    tab:blue\n            2      4 (20.0%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm2.shape\n        (20, 3)\n\n        Note that 1-dimensions are NOT removed\n\n        >>> cm2 = cm[10, 10]\n        >>> cm2\n        Phase   Orientations     Name  Symmetry       Color\n            2     1 (100.0%)  ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm.shape\n        (1, 1)\n\n        ... by phase name(s)\n\n        >>> cm2 = cm[""austenite""]\n        Phase   Orientations       Name  Symmetry     Color\n            1  5657 (100.0%)  austenite       432  tab:blue\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm2.shape\n        (100, 117)\n        >>> cm[""austenite"", ""ferrite""]\n        Phase   Orientations       Name  Symmetry       Color\n            1   5657 (48.4%)  austenite       432    tab:blue\n            2   6043 (51.6%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n\n        ... by ""indexed"" and ""not_indexed""\n\n        >>> cm[""indexed""]\n        Phase   Orientations       Name  Symmetry       Color\n            1   5657 (48.4%)  austenite       432    tab:blue\n            2   6043 (51.6%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm[""not_indexed""]\n        No data.\n\n        ... or by boolean arrays ((chained) conditional(s))\n\n        >>> cm[cm.dp > 0.81]\n        Phase   Orientations       Name  Symmetry       Color\n            1   4092 (44.8%)  austenite       432    tab:blue\n            2   5035 (55.2%)    ferrite       432  tab:orange\n        Properties: iq, dp\n        Scan unit: um\n        >>> cm[(cm.iq > np.mean(cm.iq)) & (cm.phase_id == 1)]\n        Phase   Orientations       Name  Symmetry     Color\n            1  1890 (100.0%)  austenite       432  tab:blue\n        Properties: iq, dp\n        Scan unit: um\n\n        """"""\n        # Initiate a mask to be added to the returned copy of the CrystalMap object, to\n        # ensure that only the unmasked values are in the data of the copy (True in\n        # `is_in_data`). First, no points are in the data, but are added if they satisfy\n        # the condition in the input key.\n        is_in_data = np.zeros(self.size, dtype=bool)\n\n        # The original object might already have set some points to not be in the data.\n        # If so, `is_in_data` is used to update the original `is_in_data`. Since\n        # `new_is_in_data` is not initiated for all key types, we declare it here and\n        # check for it later.\n        new_is_in_data = None\n\n        # Override mask values\n        if isinstance(key, str) or (isinstance(key, tuple) and isinstance(key[0], str)):\n            # From phase string(s)\n            if not isinstance(key, tuple):  # Make single string iterable\n                key = (key,)\n            for k in key:\n                for phase_id, phase in self.phases:\n                    if k == phase.name:\n                        is_in_data[self.phase_id == phase_id] = True\n                    elif k.lower() == ""indexed"":\n                        # Add all indexed phases to data\n                        is_in_data[self.phase_id != -1] = True\n        elif isinstance(key, np.ndarray) and key.dtype == np.bool_:\n            # From boolean numpy array\n            is_in_data = key\n        elif (\n            isinstance(key, slice)\n            or isinstance(key, int)\n            or (\n                isinstance(key, tuple)\n                and any([(isinstance(i, slice) or isinstance(i, int)) for i in key])\n            )\n        ):\n            # From slice(s) or int\n            if isinstance(key, slice) or isinstance(key, int):\n                key = (key,)\n\n            slices = [slice(None, None, None)] * self.ndim\n            for i, k in enumerate(key):\n                slices[i] = k\n\n            new_is_in_data = np.zeros(self._original_shape, dtype=bool)  # > 1D\n            new_is_in_data[tuple(slices)] = True\n            # Note that although all points within slice(s) was sought, points within\n            # the slice(s) which are already removed from the data are still kept out by\n            # this boolean multiplication\n            new_is_in_data = new_is_in_data.flatten() * self.is_in_data\n\n        # Insert the mask into a mask with the full map shape, if not done already\n        if new_is_in_data is None:\n            new_is_in_data = np.zeros_like(self.is_in_data, dtype=bool)  # 1D\n            new_is_in_data[self.id] = is_in_data\n\n        # Return a copy with all attributes shallow except for the mask\n        new_map = copy.copy(self)\n        new_map.is_in_data = new_is_in_data\n\n        return new_map\n\n    def __repr__(self):\n        """"""Print a nice representation of the data.""""""\n        if self.size == 0:\n            return ""No data.""\n\n        phases = self.phases_in_data\n        phase_ids = self.phase_id\n\n        # Ensure attributes set to None are treated OK\n        names = [""None"" if not name else name for name in phases.names]\n        symmetry_names = [""None"" if not sym else sym.name for sym in phases.symmetries]\n\n        # Determine column widths\n        unique_phases = np.unique(phase_ids)\n        p_sizes = [np.where(phase_ids == i)[0].size for i in unique_phases]\n        id_len = 5\n        ori_len = max(max([len(str(p_size)) for p_size in p_sizes]) + 9, 13)\n        name_len = max(max([len(n) for n in names]), 5)\n        sym_len = max(max([len(sn) for sn in symmetry_names]), 8)\n        col_len = max(max([len(i) for i in phases.colors]), 6)\n\n        # Column alignment\n        align = "">""  # left "">"" or right ""<""\n\n        # Header (note the two-space spacing)\n        representation = (\n            ""{:{align}{width}}  "".format(""Phase"", width=id_len, align=align)\n            + ""{:{align}{width}}  "".format(""Orientations"", width=ori_len, align=align)\n            + ""{:{align}{width}}  "".format(""Name"", width=name_len, align=align)\n            + ""{:{align}{width}}  "".format(""Symmetry"", width=sym_len, align=align)\n            + ""{:{align}{width}}\\n"".format(""Color"", width=col_len, align=align)\n        )\n\n        # Overview of data for each phase\n        for i, phase_id in enumerate(unique_phases.astype(int)):\n            p_size = np.where(phase_ids == phase_id)[0].size\n            p_fraction = 100 * p_size / self.size\n            ori_str = f""{p_size} ({p_fraction:.1f}%)""\n            representation += (\n                f""{phase_id:{align}{id_len}}  ""\n                + f""{ori_str:{align}{ori_len}}  ""\n                + f""{names[i]:{align}{name_len}}  ""\n                + f""{symmetry_names[i]:{align}{sym_len}}  ""\n                + f""{phases.colors[i]:{align}{col_len}}\\n""\n            )\n\n        # Properties and spatial coordinates\n        props = []\n        for k in self.prop.keys():\n            props.append(k)\n        representation += ""Properties: "" + "", "".join(props) + ""\\n""\n\n        # Scan unit\n        representation += f""Scan unit: {self.scan_unit}""\n\n        return representation\n\n    def get_map_data(self, item, decimals=3, fill_value=None):\n        """"""Return an array of a class instance attribute, with values\n        equal to ``False`` in ``self.is_in_data`` set to `fill_value`, of\n        map data shape.\n\n        If `item` is ""orientations""/""rotations"" and there are multiple\n        rotations per point, only the first rotation is used.\n\n        Parameters\n        ----------\n        item : str or numpy.ndarray\n            Name of the class instance attribute or a numpy.ndarray.\n        decimals : int, optional\n            How many decimals to round data point values to (default is\n            3).\n        fill_value : None, optional\n            Value to fill points not in the data with. If ``None``\n            (default), np.nan is used.\n\n        Returns\n        -------\n        output_array : numpy.ndarray\n            Array of the class instance attribute with points not in data\n            set to `fill_value`, of float data type.\n\n        """"""\n        # TODO: Consider an `axes` argument along which to get map data if > 2D\n\n        # Get full map shape\n        map_shape = self._original_shape\n\n        # Declare array of correct shape, accounting for RGB\n        # TODO: Better account for `item.shape`, e.g. quaternions (item.shape[-1]\xc2\xa0== 4)\n        # TODO: ... in a more general way than here (not more if/else)!\n        array = np.zeros(np.prod(map_shape))\n        if isinstance(item, np.ndarray):\n            if item.shape[-1] == 3:  # Assume RGB\n                map_shape += (3,)\n                array = np.column_stack((array,) * 3)\n        elif item in [""orientations"", ""rotations""]:  # Definitely RGB\n            map_shape += (3,)\n            array = np.column_stack((array,) * 3)\n\n        # Enter non-masked values into array\n        if isinstance(item, np.ndarray):\n            array[self.is_in_data] = item\n        elif item in [""orientations"", ""rotations""]:\n            if item == ""rotations"":\n                # Use only the top matching rotation per point\n                if self.rotations_per_point > 1:\n                    rotations = self.rotations[:, 0]\n                else:\n                    rotations = self.rotations\n                array[self.is_in_data] = rotations.to_euler()\n            else:  # item == ""orientations""\n                # Fill in orientations per phase\n                # TODO: Consider whether orientations should be calculated upon loading\n                for i, phase in self.phases_in_data:\n                    phase_mask = (self._phase_id == i) * self.is_in_data\n                    phase_mask_in_data = self.phase_id == i\n                    array[phase_mask] = self[phase_mask_in_data].orientations.to_euler()\n        else:  # String\n            data = self.__getattr__(item)\n            if data is None:\n                raise ValueError(f""{item} is {data}."")\n            else:\n                array[self.is_in_data] = data\n\n        # Round values\n        rounded_array = np.round(array, decimals=decimals)\n\n        # Slice and reshape array\n        slices = self._data_slices_from_coordinates()\n        reshaped_array = rounded_array.reshape(map_shape)\n        output_array = reshaped_array[slices]\n\n        # Reshape and slice mask with points *not* in data\n        if array.shape[-1] == 3:  # RGB\n            not_in_data = np.dstack((~self.is_in_data,) * 3)\n        else:  # Scalar\n            not_in_data = ~self.is_in_data\n        not_in_data = not_in_data.reshape(map_shape)[slices]\n\n        output_array[not_in_data] = fill_value\n\n        return output_array\n\n    def deepcopy(self):\n        """"""Return a deep copy using :func:`copy.deepcopy` function.""""""\n        return copy.deepcopy(self)\n\n    @staticmethod\n    def _step_size_from_coordinates(coordinates):\n        """"""Return step size in input `coordinates` array.\n\n        Parameters\n        ----------\n        coordinates : numpy.ndarray\n            Linear coordinate array.\n\n        Returns\n        -------\n        step_size : float\n            Step size in `coordinates` array.\n\n        """"""\n        unique_sorted = np.sort(np.unique(coordinates))\n        step_size = 0\n        if unique_sorted.size != 1:\n            step_size = unique_sorted[1] - unique_sorted[0]\n        return step_size\n\n    def _data_slices_from_coordinates(self):\n        """"""Return a tuple of slices defining the current data extent in\n        all directions.\n\n        Returns\n        -------\n        slices : tuple of slices\n            Data slice in each existing dimension, in (z, y, x) order.\n\n        """"""\n        slices = []\n\n        # Loop over dimension coordinates and step sizes\n        for coordinates, step in zip(\n            self._coordinates.values(), self._step_sizes.values()\n        ):\n            if coordinates is not None:\n                c_min, c_max = np.min(coordinates), np.max(coordinates)\n                i_min = int(np.around(c_min / step))\n                i_max = int(np.around((c_max / step) + 1))\n                slices.append(slice(i_min, i_max))\n\n        return tuple(slices)\n\n    def _data_shape_from_coordinates(self):\n        """"""Return data shape based upon coordinate arrays.\n\n        Returns\n        -------\n        data_shape : tuple of ints\n            Shape of data in all existing dimensions, in (z, y, x) order.\n\n        """"""\n        data_shape = []\n        for dim_slice in self._data_slices_from_coordinates():\n            data_shape.append(dim_slice.stop - dim_slice.start)\n        return tuple(data_shape)\n'"
orix/crystal_map/crystal_map_properties.py,2,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\n\n\nclass CrystalMapProperties(dict):\n    """"""A class to store properties with in a CrystalMap instance.\n\n    This class is a thin wrapper around :class:`dict`. It overrides setting\n    and getting property arrays in the `dict` to handle a data mask\n    correctly, i.e. whether data points are considered to be in the data.\n\n    Attributes\n    ----------\n    id : numpy.ndarray\n        1D integer array with the id of each point in the data.\n    is_in_data : numpy.ndarray\n        1D boolean array with True for points in the data, of the same size\n        as the data.\n\n    """"""\n\n    def __init__(self, dictionary, id, is_in_data=None):\n        """"""Create a `CrystalMapProperties` object.\n\n        Parameters\n        ----------\n        dictionary : dict\n            Dictionary of properties with `key` equal to the property name\n            and `value` as the numpy array.\n        id : numpy.ndarray\n            1D integer array with the id of each point in the entire data,\n            i.e. not just points in the data.\n        is_in_data : numpy.ndarray, optional\n            1D boolean array with True for points in the data. If ``None``\n            is passed (default), all points are considered to be in the\n            data.\n\n        """"""\n        super().__init__(**dictionary)\n        self.id = id\n        if is_in_data is None:\n            self.is_in_data = np.ones(id.size, dtype=bool)\n        else:\n            self.is_in_data = is_in_data\n\n    def __setitem__(self, key, value):\n        """"""Add a 1D array to or update an existing array in the\n        dictionary. If `key` is the name of an existing array, only the\n        points in the data (where `self.is_in_data` is True) are set.\n\n        """"""\n        # Get array values if `key` already present, or zeros\n        array = self.setdefault(key, np.zeros(self.is_in_data.size))\n\n        # Determine array data type from input\n        if hasattr(value, ""__iter__""):\n            value_type = type(value[0])\n        else:\n            value_type = type(value)\n        array = array.astype(value_type)\n\n        array[self.is_in_data] = value\n        super().__setitem__(key, array)\n\n    def __getitem__(self, item):\n        """"""Return a dictionary entry, ensuring that only points in the data\n        are returned.\n\n        """"""\n        array = super().__getitem__(item)\n        return array[self.is_in_data]\n'"
orix/crystal_map/phase_list.py,5,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom collections import OrderedDict\nimport copy\nfrom itertools import islice\nfrom numbers import Number\n\nimport matplotlib.colors as mcolors\nimport numpy as np\n\nfrom orix.quaternion.symmetry import _groups, Symmetry\n\n# All named Matplotlib colors (tableau and xkcd already lower case hex)\nALL_COLORS = mcolors.TABLEAU_COLORS\nfor k, v in {**mcolors.BASE_COLORS, **mcolors.CSS4_COLORS}.items():\n    ALL_COLORS[k] = mcolors.to_hex(v)\nALL_COLORS.update(mcolors.XKCD_COLORS)\n\n# Point group alias mapping\n# Why is this needed? Well, e.g. in EDAX TSL OIM Analysis 7.2, point group 432 is\n# entered as 43...\nPOINT_GROUP_ALIASES = {\n    ""432"": ""43"",\n}\n\n\nclass Phase:\n    """"""Name, crystal symmetry, and color of a phase in a crystallographic\n    map.\n\n    Attributes\n    ----------\n    color : str\n        Name of phase color in Matplotlib\'s list of named colors.\n    color_rgb : tuple\n        RGB values of phase color, obtained from the color name.\n    name : str\n        Phase name.\n    symmetry : orix.quaternion.symmetry.Symmetry\n        Crystal symmetries of the phase.\n\n    Methods\n    -------\n    deepcopy()\n        Return a deep copy using :py:func:`~copy.deepcopy` function.\n\n    """"""\n\n    def __init__(self, name=None, symmetry=None, color=None):\n        """"""\n        Parameters\n        ----------\n        name : str, optional\n            Phase name. If ``None`` is passed (default), name is set to\n            ``None``.\n        symmetry : str or orix.quaternion.symmetry.Symmetry, optional\n            Point group of phase\'s crystal symmetry. If ``None`` is passed\n            (default), it set to ``None``.\n        color : str, optional\n            Phase color. If ``None`` is passed (default), it is set to\n            \'tab:blue\' (first among the default Matplotlib colors).\n\n        """"""\n        self.name = name\n        self.symmetry = symmetry\n        if color is None:\n            self.color = ""tab:blue""\n        else:\n            self.color = color\n\n    @property\n    def name(self):\n        """"""Phase name.""""""\n        return self._name\n\n    @name.setter\n    def name(self, value):\n        """"""Set phase name as string.""""""\n        self._name = str(value)\n\n    @property\n    def color(self):\n        """"""Name of phase color.""""""\n        return self._color\n\n    @color.setter\n    def color(self, value):\n        """"""Set phase color from something considered a valid color by\n        :func:`matplotlib.colors.is_color_like`.\n\n        """"""\n        value_hex = mcolors.to_hex(value)\n        for name, color_hex in ALL_COLORS.items():\n            if color_hex == value_hex:\n                self._color = name\n                break\n\n    @property\n    def color_rgb(self):\n        """"""Phase color as RGB tuple.""""""\n        return mcolors.to_rgb(self.color)\n\n    @property\n    def symmetry(self):\n        """"""Crystal symmetry of phase.""""""\n        return self._symmetry\n\n    @symmetry.setter\n    def symmetry(self, value):\n        """"""Set crystal symmetry of phase.""""""\n        if isinstance(value, Number):\n            value = str(value)\n        if isinstance(value, str):\n            for correct, alias in POINT_GROUP_ALIASES.items():\n                if value == alias:\n                    value = correct\n                    break\n            for symmetry in _groups:\n                if value.replace(""-"", """") == symmetry.name.replace(""-"", """"):\n                    value = symmetry\n                    break\n        if not isinstance(value, Symmetry) and value is not None:\n            raise ValueError(\n                f""{value} must be of type {Symmetry}, the name of a valid point""\n                "" group as a string, or None.""\n            )\n        else:\n            self._symmetry = value\n\n    def __repr__(self):\n        if self.symmetry:\n            symmetry_name = self.symmetry.name\n        else:\n            symmetry_name = self.symmetry  # Which should be None\n        return (\n            f""<name: {self.name}. symmetry: {symmetry_name}. color: "" f""{self.color}>""\n        )\n\n    def deepcopy(self):\n        """"""Return a deep copy using :py:func:`~copy.deepcopy` function.""""""\n        return copy.deepcopy(self)\n\n\nclass PhaseList:\n    """"""A list of phases in a crystallographic map.\n\n    Each phase in the list must have a unique phase id and name.\n\n    Attributes\n    ----------\n    colors : list of tuple\n        List of tuples with three entries, RGB, defining phase colors.\n    names : list of str\n        List of phase names.\n    phase_ids : list of int\n        List of unique phase indices in a crystallographic map as imported.\n    size : int\n        Number of phases in list.\n    symmetries : list of orix.quaternion.symmetry.Symmetry\n        List of phase crystal symmetries.\n\n    Methods\n    -------\n    add_not_indexed()\n        Add a dummy phase to assign to not indexed data points.\n    deepcopy()\n        Return a deep copy using :py:func:`~copy.deepcopy` function.\n    id_from_name(name):\n        Get phase ID from phase name.\n    sort_by_id()\n        Sort list according to phase ID.\n\n    """"""\n\n    def __init__(\n        self, phases=None, names=None, symmetries=None, colors=None, phase_ids=None\n    ):\n        """"""\n        Parameters\n        ----------\n        phases : orix.crystal_map.Phase, a list of orix.crystal_map.Phase\\\n                or a dictionary of orix.crystal_map.Phase, optional\n            A list or dict of phases or a single phase. The other arguments\n            are ignored if this is passed.\n        names : str or list of str, optional\n            Phase names.\n        symmetries : str, int, orix.quaternion.symmetry.Symmetry or list\\\n                of str, int or orix.quaternion.symmetry.Symmetry, optional\n            Point group symmetries.\n        colors : str or list of str, optional\n            Phase colors.\n        phase_ids : int, list of int or numpy.ndarray of int, optional\n            Phase IDs.\n\n        """"""\n        d = {}\n        if isinstance(phases, list):\n            try:\n                if isinstance(next(iter(phases)), Phase):\n                    if phase_ids is None:\n                        phase_ids = np.arange(len(phases))\n                    d = dict(zip(phase_ids, phases))\n            except StopIteration:\n                pass\n        elif isinstance(phases, dict):\n            try:\n                if isinstance(next(iter(phases.values())), Phase):\n                    d = phases\n            except StopIteration:\n                pass\n        elif isinstance(phases, Phase):\n            if phase_ids is None:\n                phase_ids = 0\n            d = {phase_ids: phases}\n        else:\n            # Ensure possible single strings have iterables of length 1\n            if isinstance(names, str):\n                names = list((names,))\n            if isinstance(symmetries, str) or isinstance(symmetries, Symmetry):\n                symmetries = list((symmetries,))\n            if isinstance(colors, str) or isinstance(colors, tuple):\n                colors = list((colors,))\n            if isinstance(phase_ids, int):\n                phase_ids = [\n                    phase_ids,\n                ]\n\n            # Get the maximum number of entries in the input lists (also\n            # handling the case where some lists are None)\n            max_entries = max(\n                [len(i) if i is not None else 0 for i in [names, symmetries, phase_ids]]\n            )\n\n            if phase_ids is None:\n                phase_ids = list(np.arange(max_entries))\n\n            # Get first 2 * n entries in color list (for good measure)\n            all_colors = list(islice(ALL_COLORS.keys(), 2 * max_entries))[::-1]\n\n            # Create phase dictionary\n            d = {}\n            phase_id_iter = 0\n            used_colors = []\n            for i in range(max_entries):\n                # Get name or None\n                try:\n                    name = names[i]\n                except (IndexError, TypeError):\n                    name = None\n\n                # Get symmetry or None\n                try:\n                    symmetry = symmetries[i]\n                except (IndexError, TypeError):\n                    symmetry = None\n\n                # Get a color (always)\n                try:\n                    if colors[i] is not None:\n                        color = colors[i]\n                    else:\n                        color = all_colors.pop()\n                except (IndexError, TypeError):\n                    color = all_colors.pop()\n                while color in used_colors:\n                    color = all_colors.pop()\n\n                # Get a phase_id (always)\n                try:\n                    phase_id = phase_ids[i]\n                except IndexError:\n                    phase_id = max(phase_ids) + phase_id_iter + 1\n                    phase_id_iter += 1\n\n                d[phase_id] = Phase(name=name, symmetry=symmetry, color=color)\n\n                # To ensure color aliases are added to `used_colors`\n                used_colors.append(d[phase_id].color)\n\n        # Finally create dictionary of phases\n        self._dict = OrderedDict(sorted(d.items()))\n\n    @property\n    def names(self):\n        """"""List of phase names in the list.""""""\n        return [phase.name for _, phase in self]\n\n    @property\n    def symmetries(self):\n        """"""List of crystal symmetries of phases in the list.""""""\n        return [phase.symmetry for _, phase in self]\n\n    @property\n    def colors(self):\n        """"""List of phase color names in the list.""""""\n        return [phase.color for _, phase in self]\n\n    @property\n    def colors_rgb(self):\n        """"""List of phase color RGB values in the list.""""""\n        return [phase.color_rgb for _, phase in self]\n\n    @property\n    def size(self):\n        """"""Number of phases in the list.""""""\n        return len(self._dict.items())\n\n    @property\n    def phase_ids(self):\n        """"""Unique phase IDs in the list of phases.""""""\n        return list(self._dict.keys())\n\n    def __getitem__(self, key):\n        """"""Return a PhaseList or a Phase object, depending on the number\n        of phases in the list matches the `key`.\n\n        Examples\n        --------\n        A PhaseList object can be indexed in multiple ways.\n\n        >>> pl = PhaseList(names=[\'a\', \'b\'], symmetries=[\'1\', \'3\'])\n        >>> pl\n        Id  Name  Symmetry  Color\n        0   a     1         tab:blue\n        1   b     3         tab:orange\n\n        Return a Phase object if only one phase matches the key\n\n        >>> pl[0]  # Index with a single phase id\n        <name: a. symmetry: 1. color: tab:blue>\n        >>> pl[\'b\']  # Index with a phase name\n        <name: b. symmetry: 3. color: tab:orange>\n        >>> pl[:1]\n        <name: b. symmetry: 3. color: tab:orange>\n\n        Return a PhaseList object\n\n        >>> pl[0:]  # Index with slices\n        Id  Name  Symmetry  Color\n        0   a     1         tab:blue\n        1   b     3         tab:orange\n        >>> pl[\'a\', \'b\']  # Index with a tuple of phase names\n        Id  Name  Symmetry  Color\n        0   a     1         tab:blue\n        1   b     3         tab:orange\n        >>> pl[0, 1]  # Index with a tuple of phase phase_ids\n        Id  Name  Symmetry  Color\n        0   a     1         tab:blue\n        1   b     3         tab:orange\n        >>> pl[[0, 1]]  # Index with a list of phase_ids\n        Id  Name  Symmetry  Color\n        0   a     1         tab:blue\n        1   b     3         tab:orange\n\n        """"""\n        # Make key iterable if it isn\'t already\n        if (\n            not isinstance(key, tuple)\n            and not isinstance(key, slice)\n            and not isinstance(key, list)\n            and not isinstance(key, np.ndarray)\n        ):\n            key_iter = (key,)\n        else:\n            key_iter = key\n\n        d = {}\n        if isinstance(key_iter, str) or (\n            isinstance(key_iter, tuple)\n            and isinstance(key_iter[0], str)\n            or (isinstance(key_iter, list) and isinstance(key_iter[0], str))\n        ):\n            for key_name in list(set(key_iter)):  # Use set to remove duplicates\n                for i, phase in self._dict.items():\n                    if key_name == phase.name:\n                        d[i] = phase\n        elif (\n            isinstance(key_iter, int)\n            or isinstance(key_iter, tuple)\n            or isinstance(key_iter, list)\n            or isinstance(key_iter, np.ndarray)\n        ):\n            for i in list(set(key_iter)):  # Use set to remove duplicates\n                d[i] = self._dict[i]\n        elif isinstance(key_iter, slice):\n            # Dicts cannot be sliced, hence this work-around\n            id_arr = np.arange(max(self.phase_ids) + 1)\n            sliced_arr = id_arr[key_iter]\n            ids_in_slice = [i for i in sliced_arr if i in self.phase_ids]\n            d = {i: self._dict[i] for i in ids_in_slice}\n\n        # Raise KeyError if key is missing (not in the container), per Python docs:\n        # https://docs.python.org/3/reference/datamodel.html#object.__getitem__\n        if d == {}:\n            raise KeyError(f""{key} was not found in the phase list."")\n\n        # Ensure integer phase IDs\n        d = {int(i): p for i, p in d.items()}\n\n        # Return a Phase object if only one phase matches the key\n        if len(d) == 1:\n            return [i for i in d.values()][0]\n        else:\n            return PhaseList(d)\n\n    def __setitem__(self, key, value):\n        """"""Add a phase to the list with a name and symmetry.""""""\n        if key not in self.names:\n            # Make sure the new phase gets a new color\n            color_new = None\n            for color_name in ALL_COLORS.keys():\n                if color_name not in self.colors:\n                    color_new = color_name\n                    break\n\n            # Create new ID\n            if self.phase_ids:\n                new_phase_id = max(self.phase_ids) + 1\n            else:  # `self.phase_ids` is an empty list\n                new_phase_id = 0\n\n            self._dict[new_phase_id] = Phase(name=key, symmetry=value, color=color_new)\n        else:\n            raise ValueError(f""{key} is already in the phase list {self.names}."")\n\n    def __delitem__(self, key):\n        """"""Delete a phase from the phase list.\n\n        Parameters\n        ----------\n        key : int or str\n            ID or name of a phase in the phase list.\n\n        """"""\n        if isinstance(key, int):\n            self._dict.pop(key)\n        elif isinstance(key, str):\n            matching_phase_id = None\n            for phase_id, phase in self._dict.items():\n                if key == phase.name:\n                    matching_phase_id = phase_id\n                    break\n            if matching_phase_id is None:\n                raise KeyError(f""{key} is not among the phase names {self.names}."")\n            else:\n                self._dict.pop(matching_phase_id)\n        else:\n            raise TypeError(f""{key} is an invalid phase."")\n\n    def __iter__(self):\n        """"""Return a tuple with phase ID and Phase object, in that order.\n\n        """"""\n        for phase_id, phase in self._dict.items():\n            yield phase_id, phase\n\n    def __repr__(self):\n        if self.size == 0:\n            return ""No phases.""\n\n        # Ensure attributes set to None are treated OK\n        names = [""None"" if not i else i for i in self.names]\n        symmetry_names = [""None"" if not i else i.name for i in self.symmetries]\n\n        # Determine column widths (allowing PhaseList to be empty)\n        id_len = 2\n        name_len = 4\n        if names:\n            name_len = max(max([len(i) for i in names]), name_len)\n        sym_len = 8\n        if symmetry_names:\n            sym_len = max(max([len(i) for i in symmetry_names]), sym_len)\n        col_len = 5\n        if self.colors:\n            col_len = max(max([len(i) for i in self.colors]), col_len)\n\n        # Column alignment\n        align = "">""  # right: "">"", left: ""<""\n\n        # Header\n        representation = (\n            ""{:{align}{width}}  "".format(""Id"", width=id_len, align=align)\n            + ""{:{align}{width}}  "".format(""Name"", width=name_len, align=align)\n            + ""{:{align}{width}}  "".format(""Symmetry"", width=sym_len, align=align)\n            + ""{:{align}{width}}"".format(""Color"", width=col_len, align=align)\n        )\n\n        # Overview of each phase\n        for i, phase_id in enumerate(self.phase_ids):\n            representation += (\n                f""\\n{phase_id:{align}{id_len}}  ""\n                + f""{names[i]:{align}{name_len}}  ""\n                + f""{symmetry_names[i]:{align}{sym_len}}  ""\n                + f""{self.colors[i]:{align}{col_len}}""\n            )\n\n        return representation\n\n    def deepcopy(self):\n        """"""Return a deep copy using :func:`copy.deepcopy` function.""""""\n        return copy.deepcopy(self)\n\n    def add_not_indexed(self):\n        """"""Add a dummy phase to assign to not indexed data points.\n\n        The phase, named ""not_indexed"", has a ""symmetry"" equal to None, and\n        a white color when plotted.\n\n        """"""\n        self._dict[-1] = Phase(name=""not_indexed"", symmetry=None, color=""white"")\n        self.sort_by_id()\n\n    def sort_by_id(self):\n        """"""Sort list according to phase ID.""""""\n        self._dict = OrderedDict(sorted(self._dict.items()))\n\n    def id_from_name(self, name):\n        """"""Get phase ID from phase name.\n\n        Parameters\n        ----------\n        name : str\n            Phase name.\n\n        """"""\n        for phase_id, phase in self:\n            if name == phase.name:\n                return phase_id\n        raise KeyError(f""{name} is not among the phase names {self.names}."")\n'"
orix/io/__init__.py,3,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Load and save utilities.\n\n.. warning::\n\n   These functions are far from complete or universally useful. Use at your\n   own risk.\n\n""""""\n\nimport numpy as np\n\nfrom orix.io.emsoft_h5ebsd import load_emsoft\nfrom orix.io.ang import load_ang\n\n\ndef loadang(file_string: str):\n    """"""Load ``.ang`` files.\n\n    Parameters\n    ----------\n    file_string : str\n        Path to the ``.ang`` file. This file is assumed to list the Euler\n        angles in the Bunge convention in the first three columns.\n\n    Returns\n    -------\n    Rotation\n\n    """"""\n    from orix.quaternion.rotation import Rotation\n\n    data = np.loadtxt(file_string)\n    euler = data[:, :3]\n    rotation = Rotation.from_euler(euler)\n    return rotation\n\n\ndef loadctf(file_string: str):\n    """"""Load ``.ang`` files.\n\n    Parameters\n    ----------\n    file_string : str\n        Path to the ``.ctf`` file. This file is assumed to list the Euler\n        angles in the Bunge convention in the columns 5, 6, and 7.\n\n    Returns\n    -------\n    Rotation\n\n    """"""\n\n    from orix.quaternion.rotation import Rotation\n\n    data = np.loadtxt(file_string, skiprows=17)[:, 5:8]\n    euler = np.radians(data)\n    rotation = Rotation.from_euler(euler)\n    return rotation\n'"
orix/io/ang.py,3,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport re\nimport warnings\n\nimport numpy as np\n\nfrom orix.quaternion.rotation import Rotation\nfrom orix.crystal_map import CrystalMap\n\n# MTEX has this format sorted out, check out their readers when fixing issues and\n# adapting to other versions of this file format in the future:\n# https://github.com/mtex-toolbox/mtex/blob/develop/interfaces/loadEBSD_ang.m\n# https://github.com/mtex-toolbox/mtex/blob/develop/interfaces/loadEBSD_ACOM.m\n\n\ndef load_ang(filename):\n    """"""Return a :class:`orix.crystal_map.CrystalMap` object from EDAX\n    TSL\'s .ang file format. The map in the input file is assumed to be 2D.\n\n    Many vendors produce an .ang file. Supported vendors are:\n        * EDAX TSL\n        * NanoMegas ASTAR Index\n        * EMsoft (from program `EMdpmerge`)\n\n    All points satisfying the following criteria are classified as not\n    indexed:\n        * EDAX TSL: confidence index == -1\n\n    Parameters\n    ----------\n    filename : str\n        Path and file name.\n\n    """"""\n    # Get file header\n    with open(filename) as f:\n        header = _get_header(f)\n\n    # Get phase names and crystal symmetries from header (potentially empty)\n    phase_names, symmetries = _get_phases_from_header(header)\n\n    # Read all file data\n    file_data = np.loadtxt(filename)\n\n    # Get vendor and column names\n    n_rows, n_cols = file_data.shape\n    vendor, column_names = _get_vendor_columns(header, n_cols)\n\n    # Data needed to create a CrystalMap object\n    data = {\n        ""euler1"": None,\n        ""euler2"": None,\n        ""euler3"": None,\n        ""x"": None,\n        ""y"": None,\n        ""phase_id"": None,\n        ""prop"": {},\n    }\n    for column, name in enumerate(column_names):\n        if name in data.keys():\n            data[name] = file_data[:, column]\n        else:\n            data[""prop""][name] = file_data[:, column]\n\n    # Set which data points are not indexed\n    if vendor == ""tsl"":\n        data[""phase_id""][np.where(data[""prop""][""ci""] == -1)] = -1\n    # TODO: Add not-indexed convention for INDEX ASTAR\n\n    # Create rotations\n    rotations = Rotation.from_euler(\n        np.column_stack((data[""euler1""], data[""euler2""], data[""euler3""]))\n    )\n\n    return CrystalMap(\n        rotations=rotations,\n        phase_id=data[""phase_id""],\n        x=data[""x""],\n        y=data[""y""],\n        phase_name=phase_names,\n        symmetry=symmetries,\n        prop=data[""prop""],\n    )\n\n\ndef _get_header(file):\n    """"""Return the first lines starting with \'#\' in an .ang file.\n\n    Parameters\n    ----------\n    file : _io.TextIO\n        File object.\n\n    Returns\n    -------\n    header : list\n        List with header lines as individual elements.\n\n    """"""\n    header = []\n    line = file.readline()\n    while line.startswith(""#""):\n        header.append(line.rstrip())\n        line = file.readline()\n    return header\n\n\ndef _get_vendor_columns(header, n_cols_file):\n    """"""Return the .ang file column names and vendor, determined from the\n    header.\n\n    Parameters\n    ----------\n    header : list\n        List with header lines as individual elements.\n    n_cols_file : int\n        Number of file columns.\n\n    Returns\n    -------\n    vendor : str\n        Determined vendor (""tsl"", ""astar"", or ""emsoft"").\n    column_names : list of str\n        List of column names.\n\n    """"""\n    # Assume EDAX TSL by default\n    vendor = ""tsl""\n\n    # Determine vendor by searching for the vendor footprint in the header\n    vendor_footprint = {\n        ""emsoft"": ""EMsoft"",\n        ""astar"": ""ACOM"",\n    }\n    for name, footprint in vendor_footprint.items():\n        for line in header:\n            if footprint in line:\n                vendor = name\n                break\n\n    # Vendor column names\n    column_names = {\n        ""unknown"": [\n            ""euler1"",\n            ""euler2"",\n            ""euler3"",\n            ""x"",\n            ""y"",\n            ""unknown1"",\n            ""unknown2"",\n            ""phase_id"",\n        ],\n        ""tsl"": [\n            ""euler1"",\n            ""euler2"",\n            ""euler3"",\n            ""x"",\n            ""y"",\n            ""iq"",  # Image quality from Hough transform\n            ""ci"",  # Confidence index\n            ""phase_id"",\n            ""unknown1"",\n            ""fit"",  # Pattern fit\n            ""unknown2"",\n            ""unknown3"",\n            ""unknown4"",\n            ""unknown5"",\n        ],\n        ""emsoft"": [\n            ""euler1"",\n            ""euler2"",\n            ""euler3"",\n            ""x"",\n            ""y"",\n            ""iq"",  # Image quality from Krieger Lassen\'s method\n            ""dp"",  # Dot product\n            ""phase_id"",\n        ],\n        ""astar"": [\n            ""euler1"",\n            ""euler2"",\n            ""euler3"",\n            ""x"",\n            ""y"",\n            ""ind"",  # Correlation index\n            ""rel"",  # Reliability\n            ""phase_id"",\n            ""relx100"",  # Reliability x 100\n        ],\n    }\n\n    n_cols_expected = len(column_names[vendor])\n    if n_cols_file != n_cols_expected:\n        warnings.warn(\n            f""Number of columns, {n_cols_file}, in the file is not equal to ""\n            f""the expected number of columns, {n_cols_expected}, for the \\n""\n            f""assumed vendor \'{vendor}\'. Will therefore assume the following ""\n            ""columns: euler1, euler2, euler3, x, y, unknown1, unknown2, ""\n            ""phase_id, unknown3, unknown4, etc.""\n        )\n        vendor = ""unknown""\n        n_cols_unknown = len(column_names[""unknown""])\n        if n_cols_file > n_cols_unknown:\n            # Add potential extra columns to properties\n            for i in range(n_cols_file - n_cols_unknown):\n                column_names[""unknown""].append(""unknown"" + str(i + 3))\n\n    return vendor, column_names[vendor]\n\n\ndef _get_phases_from_header(header):\n    """"""Return phase names and symmetries detected in an .ang file\n    header.\n\n    Parameters\n    ----------\n    header : list\n        List with header lines as individual elements.\n\n    Returns\n    -------\n    phase_names : list of str\n        List of names of detected phases.\n    phase_symmetries : list of str\n        List of symmetries of detected phase.\n\n    Notes\n    -----\n    Regular expressions are used to collect phase name, formula and\n    symmetry. This function have been tested with files from the following\n    vendor\'s formats: EDAX TSL OIM Data Collection v7, ASTAR Index, and\n    EMsoft v4.\n\n    """"""\n    regexps = {\n        ""name"": ""# MaterialName([ \\t]+)([A-z0-9 ]+)"",\n        ""formula"": ""# Formula([ \\t]+)([A-z0-9 ]+)"",\n        ""symmetry"": ""# Symmetry([ \\t]+)([A-z0-9 ]+)"",\n    }\n    phases = {""name"": [], ""formula"": [], ""symmetry"": []}\n    for line in header:\n        for key, exp in regexps.items():\n            match = re.search(exp, line)\n            if match:\n                phases[key].append(match.group(2))\n\n    # Check if formula is empty (sometimes the case for ASTAR Index)\n    phase_names = phases[""formula""]\n    if len(phase_names) == 0 or any([i != """" for i in phase_names]):\n        phase_names = phases[""name""]\n\n    return phase_names, phases[""symmetry""]\n'"
orix/io/emsoft_h5ebsd.py,1,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport re\n\nimport h5py\nimport numpy as np\n\nfrom orix.quaternion.rotation import Rotation\nfrom orix.crystal_map import CrystalMap\n\n\ndef load_emsoft(filename, refined=False, **kwargs):\n    """"""Return a CrystalMap object from EMsoft\'s dictionary indexing dot\n    product files.\n\n    Parameters\n    ----------\n    filename : str\n        Path and file name.\n    refined : bool, optional\n        Whether to return refined orientations (default is ``False``).\n    kwargs :\n        Keyword arguments passed to :func:`h5py.File`.\n    """"""\n\n    mode = kwargs.pop(""mode"", ""r"")\n    f = h5py.File(filename, mode=mode, **kwargs)\n\n    # Get groups for convenience\n    ebsd_group = f[""Scan 1/EBSD""]\n    data_group = ebsd_group[""Data""]\n    header_group = ebsd_group[""Header""]\n    phase_group = header_group[""Phase/1""]\n\n    # Get map shape and step sizes\n    ny = header_group[""nRows""][:][0]\n    nx = header_group[""nColumns""][:][0]\n    step_y = header_group[""Step Y""][:][0]\n    map_size = ny * nx\n\n    # Get map coordinates (""Y Position"" data set is not correct in EMsoft as of 2020-04,\n    # see: https://github.com/EMsoft-org/EMsoft/blob/7762e1961508fe3e71d4702620764ceb98a78b9e/Source/EMsoftHDFLib/EMh5ebsd.f90#L1093)\n    x = data_group[""X Position""][:]\n    # y = data_group[""Y Position""][:]\n    y = np.sort(np.tile(np.arange(ny) * step_y, nx))\n\n    # Get number of top matches kept per data point\n    n_top_matches = f[""NMLparameters/EBSDIndexingNameListType/nnk""][:][0]\n\n    # Get phase IDs\n    phase_id = data_group[""Phase""][:]\n\n    # Get phase name and crystal symmetry\n    phase_name = re.search(\n        r""([A-z0-9]+)"", phase_group[""MaterialName""][:][0].decode()\n    ).group(1)\n    symmetry = re.search(\n        r""\\[([A-z0-9]+)\\]"", phase_group[""Point Group""][:][0].decode()\n    ).group(1)\n\n    # Get rotations\n    if refined:\n        euler = data_group[""RefinedEulerAngles""][:]\n    else:  # Get n top matches for each pixel\n        top_match_idx = data_group[""TopMatchIndices""][:][:map_size]\n        dictionary_size = data_group[""FZcnt""][:][0]\n        dictionary_euler = data_group[""DictionaryEulerAngles""][:][:dictionary_size]\n        euler = dictionary_euler[top_match_idx, :]\n    rotations = Rotation.from_euler(euler)\n\n    properties = _get_properties(\n        data_group=data_group, n_top_matches=n_top_matches, map_size=map_size,\n    )\n\n    return CrystalMap(\n        rotations=rotations,\n        phase_id=phase_id,\n        x=x,\n        y=y,\n        phase_name=phase_name,\n        symmetry=symmetry,\n        prop=properties,\n    )\n\n\ndef _get_properties(data_group, n_top_matches, map_size):\n    """"""Return a dictionary of properties within an EMsoft h5ebsd file, with\n    property names as the dictionary key and arrays as the values.\n\n    Parameters\n    ----------\n    data_group : h5py.Group\n        HDF5 group with the property data sets.\n    n_top_matches : int\n        Number of rotations per point.\n    map_size : int\n        Data size.\n\n    Returns\n    -------\n    properties : dict\n        Property dictionary.\n    """"""\n    expected_properties = [\n        ""AvDotProductMap"",\n        ""CI"",\n        ""CIMap"",\n        ""IQ"",\n        ""IQMap"",\n        ""ISM"",\n        ""ISMap"",\n        ""KAM"",\n        ""OSM"",\n        ""RefinedDotProducts"",\n        ""TopDotProductList"",\n        ""TopMatchIndices"",\n    ]\n\n    # Get properties\n    properties = {}\n    for property_name in expected_properties:\n        if property_name in data_group.keys():\n            prop = data_group[property_name][:]\n            if prop.shape[-1] == n_top_matches:\n                prop = prop[:map_size].reshape((map_size,) + (n_top_matches,))\n            else:\n                prop = prop.reshape(map_size)\n            properties[property_name] = prop\n\n    return properties\n'"
orix/plot/__init__.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom orix.plot.rotation_plot import RodriguesPlot\nfrom orix.plot.crystal_map_plot import CrystalMapPlot\n'"
orix/plot/crystal_map_plot.py,12,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport warnings\n\nimport matplotlib.font_manager as fm\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\nfrom matplotlib.axes import Axes\nfrom matplotlib.projections import register_projection\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar\nimport numpy as np\n\nfrom orix.scalar import Scalar\nfrom orix.vector import Vector3d\n\n\nclass CrystalMapPlot(Axes):\n    """"""A base class for 2D plotting of CrystalMap objects.\n\n    Attributes\n    ----------\n    name : str\n        Matplotlib projection name.\n\n    Methods\n    -------\n    plot_map(\n        crystal_map, value=None, scalebar=True, scalebar_properties=None,\n        legend=True, legend_properties=None, **kwargs)\n        Plot a 2D map with any CrystalMap attribute as map values.\n    add_scalebar(crystal_map, **kwargs)\n        Add a scalebar to the axes object via `AnchoredSizeBar`.\n    add_overlay(crystal_map, item)\n        Use a crystal map property as gray scale values of a phase map.\n    add_colorbar(label=None, **kwargs)\n        Add an opinionated colorbar to the figure.\n    remove_padding()\n        Remove all white padding outside of the figure.\n\n    """"""\n\n    name = ""plot_map""\n    _data_axes = None\n    _data_slices = None\n    _data_shape = None\n\n    def plot_map(\n        self,\n        crystal_map,\n        value=None,\n        scalebar=True,\n        scalebar_properties=None,\n        legend=True,\n        legend_properties=None,\n        axes=None,\n        depth=None,\n        **kwargs,\n    ):\n        """"""Plot a 2D map with any CrystalMap attribute as map values.\n\n        Wraps :meth:`matplotlib.axes.Axes.imshow`, see that method for\n        relevant keyword arguments.\n\n        Parameters\n        ----------\n        crystal_map : orix.crystal_map.CrystalMap\n            Crystal map object to obtain data to plot from.\n        value : numpy.ndarray, optional\n            Attribute array to plot. If value is ``None`` (default), a\n            phase map is plotted.\n        scalebar : bool, optional\n            Whether to add a scalebar (default is ``True``) along the\n            horizontal map dimension.\n        scalebar_properties : dict\n            Dictionary of keyword arguments passed to\n            :func:`mpl_toolkits.axes_grid1.anchored_artists.AnchoredSizeBar`.\n        legend : bool, optional\n            Whether to add a legend to the plot. This is only implemented for\n            a phase plot (in which case default is ``True``).\n        legend_properties : dict\n            Dictionary of keyword arguments passed to\n            :meth:`matplotlib.axes.legend`.\n        axes : tuple of ints, optional\n            Which data axes to plot if data has more than two dimensions.\n            The index of data to plot in the final dimension is determined\n            by `depth`. If ``None`` (default), data along the two last\n            axes is plotted.\n        depth : int, optional\n            Which layer along the third axis to plot if data has more than\n            two dimensions. If ``None`` (default), data in the first index\n            (layer) is plotted.\n        kwargs :\n            Keyword arguments passed to\n            :meth:`matplotlib.axes.Axes.imshow`.\n\n        Returns\n        -------\n        im : matplotlib.image.AxesImage\n            Image object, to be used further to get data from etc.\n\n        See Also\n        --------\n        matplotlib.axes.Axes.imshow\n        orix.plot.CrystalMapPlot.add_scalebar\n        orix.plot.CrystalMapPlot.add_overlay\n        orix.plot.CrystalMapPlot.add_colorbar\n\n        Examples\n        --------\n        >>> import matplotlib.pyplot as plt\n        >>> import numpy as np\n        >>> from orix import plot\n        >>> from orix.io import load_ang\n\n        Import a crystal map\n\n        >>> cm = load_ang(""/some/directory/data.ang"")\n\n        Plot a phase map\n\n        >>> fig = plt.figure()  # Get figure\n        >>> ax = fig.add_subplot(projection=""plot_map"")  # Get axes\n        >>> im = ax.plot_map(cm)  # Get image\n\n        Add an overlay\n\n        >>> ax.add_overlay(cm, cm.iq)\n\n        Plot an arbitrary map property, also changing scalebar location\n\n        >>> ax = plt.subplot(projection=""plot_map"")\n        >>> ax.plot_map(\n        ...     cm, cm.dp, cmap=""cividis"", scalebar_properties={""loc"": 4})\n\n        Add a colorbar\n\n        >>> cbar = ax.add_colorbar(""Dot product"")  # Get colorbar\n\n        Plot orientation angle in degrees of one phase\n\n        >>> cm2 = cm[""austenite""]\n        >>> austenite_angles = cm2.orientations.angle.data * 180 / np.pi\n        >>> fig = plt.figure()\n        >>> ax = fig.add_subplot(projection=""plot_map"")\n        >>> im = ax.plot_map(cm2, austenite_angles)\n        >>> ax.add_colorbar(""Orientation angle [$^{\\circ}$]"")\n\n        Remove all figure and axes padding\n\n        >>> ax.remove_padding()\n\n        Write annotated figure to file\n\n        >>> fig.savefig(\n        ...     ""/some/directory/image.png"",\n        ...     pad_inches=0,\n        ...     bbox_inches=""tight""\n        ...)\n\n        Write un-annotated image to file\n\n        >>> plt.imsave(""/some/directory/image2.png"", im.get_array())\n\n        """"""\n        self._get_plot_shape(crystal_map=crystal_map, axes=axes, depth=depth)\n\n        patches = None\n        if value is None:  # Phase map\n            # Color each map pixel with corresponding phase color RGB tuple\n            phase_id = crystal_map.get_map_data(""phase_id"")\n            phase_id = phase_id[self._data_slices]\n            unique_phase_ids = np.unique(phase_id[~np.isnan(phase_id)])\n            data = np.ones(phase_id.shape + (3,))\n            for i, color in zip(\n                unique_phase_ids, crystal_map.phases_in_data.colors_rgb\n            ):\n                mask = phase_id == int(i)\n                data[mask] = data[mask] * color\n\n            # Add legend patches to plot\n            patches = []\n            for _, p in crystal_map.phases_in_data:\n                patches.append(mpatches.Patch(color=p.color_rgb, label=p.name))\n        else:  # Create masked array of correct shape\n            if isinstance(value, Scalar) or isinstance(value, Vector3d):\n                value = value.data\n            data = crystal_map.get_map_data(value)\n            data = data[self._data_slices]\n\n        # Squeeze 1-dimensions\n        data = np.squeeze(data)\n\n        # Legend\n        if legend and isinstance(patches, list):\n            if legend_properties is None:\n                legend_properties = {}\n            self._add_legend(patches, **legend_properties)\n\n        # Scalebar\n        if scalebar:\n            if scalebar_properties is None:\n                scalebar_properties = {}\n            _ = self.add_scalebar(crystal_map, **scalebar_properties)\n\n        im = self.imshow(X=data, **kwargs)\n        im = self._override_status_bar(im, crystal_map)\n\n        return im\n\n    def add_scalebar(self, crystal_map, **kwargs):\n        """"""Add a scalebar to the axes object via `AnchoredSizeBar`.\n\n        To find an appropriate scalebar width, this snippet from MTEX\n        [Bachmann2010]_ written by Eric Payton and Philippe Pinard is used:\n        https://github.com/mtex-toolbox/mtex/blob/b8fc167d06d453a2b3e212b1ac383acbf85a5a27/plotting/scaleBar.m,\n\n        Parameters\n        ----------\n        crystal_map : orix.crystal_map.CrystalMap\n            Crystal map object to obtain necessary data from.\n        **kwargs : dict\n            Keyword arguments passed to\n            :func:`mpl_toolkits.axes_grid1.anchored_artists.AnchoredSizeBar`.\n            `alpha` can also be passed, to set the scalebar transparency.\n\n        Returns\n        -------\n        bar : mpl_toolkits.axes_grid1.anchored_artists.AnchoredSizeBar\n            Scalebar.\n\n        Examples\n        --------\n        >>> cm\n        Phase  Orientations   Name       Symmetry  Color\n        1      5657 (48.4%)   austenite  432       tab:blue\n        2      6043 (51.6%)   ferrite    432       tab:orange\n        Properties: iq, dp\n        Scan unit: um\n\n        Create a phase map without a scale bar and add it afterwards\n\n        >>> fig = plt.figure()\n        >>> ax = fig.add_subplot(projection=""plot_map"")\n        >>> im = ax.plot_map(cm, scalebar=False)\n        >>> sbar = ax.add_scalebar(cm, loc=4, frameon=False)\n\n        """"""\n        last_axis = crystal_map.ndim - 1\n        horizontal = crystal_map._coordinate_axes[last_axis]  # Get whether z, y or x\n\n        map_width = crystal_map.shape[last_axis]\n        step_size = crystal_map._step_sizes[horizontal]\n        scan_unit = crystal_map.scan_unit\n\n        # Initial scalebar width should be approximately 1/10 of map width\n        scalebar_width = 0.1 * map_width * step_size\n\n        # Ensure a suitable number is used, e.g. going from 1000 nm to 1 um\n        scalebar_width, scan_unit, factor = convert_unit(scalebar_width, scan_unit)\n\n        # This snippet for finding a suitable scalebar width is taken from MTEX:\n        # https://github.com/mtex-toolbox/mtex/blob/b8fc167d06d453a2b3e212b1ac383acbf85a5a27/plotting/scaleBar.m,\n        # written by Eric Payton and Philippe Pinard. We want a round, not too high\n        # number without decimals\n        good_values = np.array(\n            [1, 2, 5, 10, 15, 20, 25, 50, 75, 100, 125, 150, 200, 500, 750], dtype=int,\n        )\n        # Find good data closest to initial scalebar width\n        difference = abs(scalebar_width - good_values)\n        good_value_idx = np.where(difference == difference.min())[0][0]\n        scalebar_width = good_values[good_value_idx]\n\n        # Scale width by factor from above conversion (usually factor = 1.0)\n        scalebar_width = scalebar_width * factor\n        scalebar_width_px = scalebar_width / step_size\n\n        # Allow for a potential decimal in scalebar number if something didn\'t go as\n        # planned\n        if scalebar_width.is_integer():\n            scalebar_width = int(scalebar_width)\n        else:\n            warnings.warn(f""Scalebar width {scalebar_width} is not an integer."")\n\n        if scan_unit == ""um"":\n            scan_unit = ""\\u03BC"" + ""m""\n\n        # Set up arguments to AnchoredSizeBar() if not already present in kwargs\n        d = {\n            ""loc"": 3,\n            ""pad"": 0.2,\n            ""sep"": 3,\n            ""frameon"": True,\n            ""borderpad"": 0.5,\n            ""size_vertical"": scalebar_width_px / 12,\n            ""fontproperties"": fm.FontProperties(size=11),\n        }\n        [kwargs.setdefault(k, v) for k, v in d.items()]\n\n        alpha = kwargs.pop(""alpha"", 0.6)\n\n        # Create scalebar\n        bar = AnchoredSizeBar(\n            transform=self.axes.transData,\n            size=scalebar_width_px,\n            label=str(scalebar_width) + "" "" + scan_unit,\n            **kwargs,\n        )\n        bar.patch.set_alpha(alpha)\n\n        self.axes.add_artist(bar)\n\n        return bar\n\n    def add_overlay(self, crystal_map, item):\n        """"""Use a crystal map property as gray scale values of a phase map.\n\n        The property\'s range is adjusted to [0, 1] for maximum contrast.\n\n        Parameters\n        ----------\n        crystal_map : orix.crystal_map.CrystalMap\n            Crystal map object to obtain necessary data from.\n        item : str\n            Name of map property to scale phase array with. The property\n            range is adjusted for maximum contrast.\n\n        Examples\n        --------\n        >>> cm\n        Phase  Orientations   Name       Symmetry  Color\n        1      5657 (48.4%)   austenite  432       tab:blue\n        2      6043 (51.6%)   ferrite    432       tab:orange\n        Properties: iq, dp\n        Scan unit: um\n\n        Plot a phase map with a map property as overlay\n\n        >>> fig = plt.figure()\n        >>> ax = fig.add_subplot(projection=""plot_map"")\n        >>> im = ax.plot_map(cm)\n        >>> ax.add_overlay(cm, cm.dp)\n\n        """"""\n        image = self.images[0]\n        image_data = image.get_array()\n\n        if image_data.ndim < 3:\n            # Adding overlay to a scalar plot (should this be allowed?)\n            image_data = image.to_rgba(image_data)[:, :, :3]  # No alpha\n\n        # Scale prop to [0, 1] to maximize image contrast\n        overlay = crystal_map.get_map_data(item)\n        overlay_min = np.nanmin(overlay)\n        rescaled_overlay = (overlay - overlay_min) / (np.nanmax(overlay) - overlay_min)\n\n        n_channels = 3\n        for i in range(n_channels):\n            image_data[:, :, i] *= rescaled_overlay\n\n        image.set_data(image_data)\n\n    def add_colorbar(self, label=None, **kwargs):\n        """"""Add an opinionated colorbar to the figure.\n\n        Parameters\n        ----------\n        label : str, optional\n            Colorbar title, default is ``None``.\n        kwargs :\n            Keyword arguments passed to\n            :meth:`mpl_toolkits.axes_grid1.make_axes_locatable.append_axes`.\n\n        Returns\n        -------\n        cbar : matplotlib.colorbar\n            Colorbar.\n\n        Examples\n        --------\n        >>> cm\n        Phase  Orientations   Name       Symmetry  Color\n        1      5657 (48.4%)   austenite  432       tab:blue\n        2      6043 (51.6%)   ferrite    432       tab:orange\n        Properties: iq, dp\n        Scan unit: um\n\n        Plot a map property and add a colorbar\n\n        >>> fig = plt.figure()\n        >>> ax = fig.add_subplot(projection=""plot_map"")\n        >>> im = ax.plot_map(cm, cm.dp, cmap=""inferno"")\n        >>> cbar = ax.add_colorbar(""Dot product"")\n\n        If the default options are not satisfactory, the colorbar can be\n        updated\n\n        >>> cbar.ax.set_ylabel(ylabel=""dp"", rotation=90)\n\n        """"""\n        # Keyword arguments\n        d = {""position"": ""right"", ""size"": ""5%"", ""pad"": 0.1}\n        [kwargs.setdefault(k, v) for k, v in d.items()]\n\n        # Add colorbar\n        divider = make_axes_locatable(self)\n        cax = divider.append_axes(**kwargs)\n        cbar = self.figure.colorbar(self.images[0], cax=cax)\n\n        # Set label with padding\n        cbar.ax.get_yaxis().labelpad = 15\n        cbar.ax.set_ylabel(label, rotation=270)\n\n        return cbar\n\n    def remove_padding(self):\n        """"""Remove all white padding outside of the figure.\n\n        Examples\n        --------\n        >>> cm\n        Phase  Orientations   Name       Symmetry  Color\n        1      5657 (48.4%)   austenite  432       tab:blue\n        2      6043 (51.6%)   ferrite    432       tab:orange\n        Properties: iq, dp\n        Scan unit: um\n\n        Remove all figure and axes padding of a phase map\n\n        >>> fig = plt.figure()\n        >>> ax = fig.add_subplot(projection=""plot_map"")\n        >>> ax.plot_map(cm)\n        >>> ax.remove_padding()\n\n        """"""\n        self.set_axis_off()\n        self.margins(0, 0)\n\n        # Tune subplot layout\n        colorbar = self.images[0].colorbar\n        if colorbar is not None:\n            right = self.figure.subplotpars.right\n        else:\n            right = 1\n        self.figure.subplots_adjust(top=1, bottom=0, right=right, left=0)\n\n    def _get_plot_shape(self, crystal_map, axes=None, depth=None):\n        """"""Set `CrystalMapPlot` attributes describing which data axes to\n        plot.\n\n        Parameters\n        ----------\n        crystal_map : orix.crystal_map.CrystalMap\n            Map to determine plotting axes and slices from.\n        axes : list of ints, optional\n            Data axes to plot. If ``None``, the last two data axes are\n            plotted (default).\n        depth : int, optional\n            Which data layer to plot along the final axis not in `axes` if\n            data is 3D. If ``None``, this is set to zero, i.e. the first\n            layer (default).\n\n        """"""\n        ndim = crystal_map.ndim\n\n        # Get data axes to plot\n        if axes is None:\n            axes = [ndim - 2, ndim - 1]\n        axes = list(axes)\n        axes.sort()\n        self._data_axes = axes[:2]  # Can only plot two axes!\n\n        if depth is None:  # Plot first layer\n            depth = 0\n\n        # Get data slices to plot\n        slices = []\n        data_shape = []\n        for data_axis, axis_size in zip(\n            crystal_map._coordinate_axes.keys(), crystal_map._original_shape\n        ):\n            data_slice = slice(depth, depth + 1, None)\n            for plot_axis in self._data_axes:\n                if data_axis == plot_axis:\n                    data_slice = slice(None, None, None)\n                    data_shape.append(axis_size)\n            slices.append(data_slice)\n        self._data_slices = tuple(slices)\n        self._data_shape = tuple(data_shape)\n\n    def _add_legend(self, patches, **kwargs):\n        """"""Add a legend to the axes object.\n\n        Parameters\n        ----------\n        patches : list of matplotlib.patches.Patch\n            Patches with color code and name.\n        **kwargs :\n            Keyword arguments passed to :meth:`matplotlib.axes.legend`.\n\n        """"""\n        d = {\n            ""borderpad"": 0.3,\n            ""handlelength"": 0.75,\n            ""handletextpad"": 0.3,\n            ""framealpha"": 0.6,\n            ""prop"": fm.FontProperties(size=11),\n        }\n        [kwargs.setdefault(k, v) for k, v in d.items()]\n        self.legend(handles=patches, **kwargs)\n\n    def _override_status_bar(self, image, crystal_map):\n        """"""Display coordinates, a property value (if scalar values are\n        plotted), and Euler angles (in radians) per data point in the\n        status bar.\n\n        This is done by overriding\n        :meth:`matplotlib.images.AxesImage.get_cursor_data`,\n        :meth:`matplotlib.images.AxesImage.format_cursor_data` and\n        :meth:`matplotlib.axes.Axes.format_coord`.\n\n        Parameters\n        ----------\n        image : matplotlib.images.AxesImage\n            Image object.\n        crystal_map : orix.crystal_map.CrystalMap\n            Crystal map object to obtain necessary data from.\n\n        Returns\n        -------\n        image : matplotlib.images.AxesImage\n            Image object where the above mentioned methods are overridden.\n\n        """"""\n        # Get data shape to plot\n        n_rows, n_cols = self._data_shape\n\n        # Get rotations, ensuring correct masking\n        # TODO: Show orientations in Euler angles (computationally intensive...)\n        r = crystal_map.get_map_data(""rotations"", decimals=3)\n        r = r[self._data_slices].squeeze()\n\n        # Get image data, overwriting potentially masked regions set to 0.0\n        image_data = image.get_array()  # numpy.masked.MaskedArray\n        image_data[image_data.mask] = np.nan\n\n        def status_bar_data(event):\n            col = int(event.xdata + 0.5)\n            row = int(event.ydata + 0.5)\n            return row, col, r[row, col], image_data[row, col]\n\n        # Set width of status bar fields\n        x_width = len(str(n_cols - 1))\n        y_width = len(str(n_rows - 1))\n        scalar_width = len(str(np.nanmax(image_data)))\n\n        # Override\n        image.get_cursor_data = status_bar_data\n        self.axes.format_coord = lambda x, y: """"\n\n        def format_status_bar_data_rgb(data):\n            """"""Status bar format for RGB plots.""""""\n            return (\n                f""(y,x):({data[0]:{y_width}},{data[1]:{x_width}})""\n                f"" rot:({data[2][0]:5},{data[2][1]:5},{data[2][2]:5})""\n            )\n\n        def format_status_bar_data_scalar(data):\n            """"""Status bar format for scalar plots.""""""\n            return (\n                f""(y,x):({data[0]:{y_width}},{data[1]:{x_width}})""\n                f"" val:{data[3]:{scalar_width}}""\n                f"" rot:({data[2][0]:5},{data[2][1]:5},{data[2][2]:5})""\n            )\n\n        # Pick status bar format and override this as well\n        if image_data.ndim > 2 and image_data.shape[-1] == 3:\n            image.format_cursor_data = format_status_bar_data_rgb\n        else:\n            image.format_cursor_data = format_status_bar_data_scalar\n\n        return image\n\n\nregister_projection(CrystalMapPlot)\n\n\ndef convert_unit(value, unit):\n    """"""Return the data with a suitable, not too large, unit.\n\n    This algorithm is taken directly from MTEX [Bachmann2010]_\n    https://github.com/mtex-toolbox/mtex/blob/a74545383160610796b9525eedf50a241800ffae/plotting/plotting_tools/switchUnit.m,\n    written by Ralf Hielscher.\n\n    Parameters\n    ----------\n    value : float\n        The data to convert.\n    unit : str\n        The data unit, e.g. um. If `px` is passed, `um` is assumed.\n\n    Returns\n    -------\n    new_value : float\n        The input data converted to the suitable unit.\n    new_unit : str\n        A (possibly) more suitable unit than the input.\n    factor : float\n        Factor to multiple `new_value` with to get the input data.\n\n    Examples\n    --------\n    >>> convert_unit(17.55 * 1e3, \'nm\')\n    17.55 um 999.9999999999999\n    >>> convert_unit(17.55 * 1e-3, \'mm\')\n    17.55 um 0.001\n\n    """"""\n    unit_is_px = False\n    if unit == ""px"":\n        unit = ""um""\n        unit_is_px = True\n\n    # Create lookup-table with units and power\n    lookup_table = []\n    letters = ""yzafpnum kMGTPEZY""\n    new_unit_idx = None\n    for i, letter in enumerate(letters):\n        # Ensure \'m\' is entered correctly\n        current_unit = (letter + ""m"").strip("" "")\n        lookup_table.append((current_unit, 10 ** (3 * i - 24)))\n        if unit == current_unit:\n            new_unit_idx = i\n\n    # Find the lookup-table index of the most suitable unit\n    value_in_metres = value * lookup_table[new_unit_idx][1]\n    power_of_value = np.floor(np.log10(value_in_metres))\n    suitable_unit_idx = int(np.floor(power_of_value / 3) + 8)\n\n    # Calculate new data, unit and the conversion factor\n    new_value = value_in_metres / lookup_table[suitable_unit_idx][1]\n    new_unit = lookup_table[suitable_unit_idx][0]\n    factor = lookup_table[suitable_unit_idx][1] / lookup_table[new_unit_idx][1]\n\n    if unit_is_px:\n        new_unit = ""px""\n\n    return new_value, new_unit, factor\n'"
orix/plot/rotation_plot.py,0,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom matplotlib import projections\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom orix.vector.neo_euler import Rodrigues, AxAngle\n\n\nclass RotationPlot(Axes3D):\n\n    name = None\n    transformation_class = None\n\n    def transform(self, xs):\n        from orix.quaternion.rotation import Rotation\n\n        if isinstance(xs, Rotation):\n            transformed = self.transformation_class.from_rotation(xs.get_plot_data())\n        else:\n            transformed = self.transformation_class(xs)\n        x, y, z = transformed.xyz\n        return x, y, z\n\n    def scatter(self, xs, **kwargs):\n        x, y, z = self.transform(xs)\n        return super().scatter(x, y, z, **kwargs)\n\n    def plot(self, xs, **kwargs):\n        x, y, z = self.transform(xs)\n        return super().plot(x, y, z, **kwargs)\n\n    def plot_wireframe(self, xs, **kwargs):\n        x, y, z = self.transform(xs)\n        return super().plot_wireframe(x, y, z, **kwargs)\n\n\nclass RodriguesPlot(RotationPlot):\n    """"""Plot rotations in a Rodrigues-Frank projection.""""""\n\n    name = ""rodrigues""\n    transformation_class = Rodrigues\n\n\nclass AxAnglePlot(RotationPlot):\n    """"""Plot rotations in an Axes-Angle projection.""""""\n\n    name = ""axangle""\n    transformation_class = AxAngle\n\n\nprojections.register_projection(RodriguesPlot)\nprojections.register_projection(AxAnglePlot)\n'"
orix/quaternion/__init__.py,13,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Four-dimensional objects.\n\nIn a simplified sense, quaternions are an extension of the concept of complex\nnumbers, represented by :math:`a + bi + cj + dk` where :math:`i`, :math:`j`, and\n:math:`k` are quaternion units and :math:`i^2 = j^2 = k^2 = ijk = -1`. For\nfurther reference see\n`the Wikipedia article <https://en.wikipedia.org/wiki/Quaternion>`_\n\nUnit quaternions are efficient objects for representing rotations, and hence\norientations.\n\nSubmodules\n==========\n\n.. autosummary::\n    :toctree: _autosummary\n\n    rotation\n    symmetry\n    orientation\n    orientation_region\n\nMembers\n=======\n\n""""""\nimport numpy as np\nfrom orix.base import check, Object3d\nfrom orix.scalar import Scalar\nfrom orix.vector import Vector3d\n\n\ndef check_quaternion(obj):\n    return check(obj, Quaternion)\n\n\nclass Quaternion(Object3d):\n    """"""Basic quaternion object.\n\n    Quaternions support the following mathematical operations:\n\n    - Unary negation.\n    - Inversion.\n    - Multiplication with other quaternions and vectors.\n\n    Attributes\n    ----------\n    data : numpy.ndarray\n        The numpy array containing the quaternion data.\n    a, b, c, d : Scalar\n        The individual elements of each vector.\n    conj : Quaternion\n        The conjugate of this quaternion: :math:`q^* = a - bi - cj - dk`\n\n\n    """"""\n\n    dim = 4\n\n    @property\n    def a(self):\n        return Scalar(self.data[..., 0])\n\n    @a.setter\n    def a(self, value):\n        self.data[..., 0] = value\n\n    @property\n    def b(self):\n        return Scalar(self.data[..., 1])\n\n    @b.setter\n    def b(self, value):\n        self.data[..., 1] = value\n\n    @property\n    def c(self):\n        return Scalar(self.data[..., 2])\n\n    @c.setter\n    def c(self, value):\n        self.data[..., 2] = value\n\n    @property\n    def d(self):\n        return Scalar(self.data[..., 3])\n\n    @d.setter\n    def d(self, value):\n        self.data[..., 3] = value\n\n    @property\n    def conj(self):\n        a = self.a.data\n        b, c, d = -self.b.data, -self.c.data, -self.d.data\n        q = np.stack((a, b, c, d), axis=-1)\n        return Quaternion(q)\n\n    def __neg__(self):\n        return self.__class__(-self.data)\n\n    def __invert__(self):\n        return self.__class__(self.conj.data / (self.norm.data ** 2)[..., np.newaxis])\n\n    def __mul__(self, other):\n        if isinstance(other, Quaternion):\n            sa, oa = self.a.data, other.a.data\n            sb, ob = self.b.data, other.b.data\n            sc, oc = self.c.data, other.c.data\n            sd, od = self.d.data, other.d.data\n            a = sa * oa - sb * ob - sc * oc - sd * od\n            b = sb * oa + sa * ob - sd * oc + sc * od\n            c = sc * oa + sd * ob + sa * oc - sb * od\n            d = sd * oa - sc * ob + sb * oc + sa * od\n            q = np.stack((a, b, c, d), axis=-1)\n            return other.__class__(q)\n        elif isinstance(other, Vector3d):\n            a, b, c, d = self.a.data, self.b.data, self.c.data, self.d.data\n            x, y, z = other.x.data, other.y.data, other.z.data\n            x_new = (a ** 2 + b ** 2 - c ** 2 - d ** 2) * x + 2 * (\n                (a * c + b * d) * z + (b * c - a * d) * y\n            )\n            y_new = (a ** 2 - b ** 2 + c ** 2 - d ** 2) * y + 2 * (\n                (a * d + b * c) * x + (c * d - a * b) * z\n            )\n            z_new = (a ** 2 - b ** 2 - c ** 2 + d ** 2) * z + 2 * (\n                (a * b + c * d) * y + (b * d - a * c) * x\n            )\n            return other.__class__(np.stack((x_new, y_new, z_new), axis=-1))\n        return NotImplemented\n\n    def outer(self, other):\n        """"""Compute the outer product of this quaternion and the other object.""""""\n\n        def e(x, y):\n            return np.multiply.outer(x, y)\n\n        if isinstance(other, Quaternion):\n            q = np.zeros(self.shape + other.shape + (4,), dtype=float)\n            sa, oa = self.data[..., 0], other.data[..., 0]\n            sb, ob = self.data[..., 1], other.data[..., 1]\n            sc, oc = self.data[..., 2], other.data[..., 2]\n            sd, od = self.data[..., 3], other.data[..., 3]\n            q[..., 0] = e(sa, oa) - e(sb, ob) - e(sc, oc) - e(sd, od)\n            q[..., 1] = e(sb, oa) + e(sa, ob) - e(sd, oc) + e(sc, od)\n            q[..., 2] = e(sc, oa) + e(sd, ob) + e(sa, oc) - e(sb, od)\n            q[..., 3] = e(sd, oa) - e(sc, ob) + e(sb, oc) + e(sa, od)\n            return other.__class__(q)\n        elif isinstance(other, Vector3d):\n            a, b, c, d = self.a.data, self.b.data, self.c.data, self.d.data\n            x, y, z = other.x.data, other.y.data, other.z.data\n            x_new = e(a ** 2 + b ** 2 - c ** 2 - d ** 2, x) + 2 * (\n                e(a * c + b * d, z) + e(b * c - a * d, y)\n            )\n            y_new = e(a ** 2 - b ** 2 + c ** 2 - d ** 2, y) + 2 * (\n                e(a * d + b * c, x) + e(c * d - a * b, z)\n            )\n            z_new = e(a ** 2 - b ** 2 - c ** 2 + d ** 2, z) + 2 * (\n                e(a * b + c * d, y) + e(b * d - a * c, x)\n            )\n            v = np.stack((x_new, y_new, z_new), axis=-1)\n            return other.__class__(v)\n        raise NotImplementedError(\n            ""This operation is currently not avaliable in orix, please use outer with other of type: Quaternion or Vector3d""\n        )\n\n    def dot(self, other):\n        """"""Scalar : the dot product of this quaternion and the other.""""""\n        return Scalar(np.sum(self.data * other.data, axis=-1))\n\n    def dot_outer(self, other):\n        """"""Scalar : the outer dot product of this quaternion and the other.""""""\n        dots = np.tensordot(self.data, other.data, axes=(-1, -1))\n        return Scalar(dots)\n\n    @classmethod\n    def triple_cross(cls, q1, q2, q3):\n        """"""Pointwise cross product of three quaternions.\n\n        Parameters\n        ----------\n        q1, q2, q3 : Quaternion\n            Three quaternions for which to find the ""triple cross"".\n\n        Returns\n        -------\n        q : Quaternion\n\n        """"""\n        q1a, q1b, q1c, q1d = q1.a.data, q1.b.data, q1.c.data, q1.d.data\n        q2a, q2b, q2c, q2d = q2.a.data, q2.b.data, q2.c.data, q2.d.data\n        q3a, q3b, q3c, q3d = q3.a.data, q3.b.data, q3.c.data, q3.d.data\n        a = (\n            +q1b * q2c * q3d\n            - q1b * q3c * q2d\n            - q2b * q1c * q3d\n            + q2b * q3c * q1d\n            + q3b * q1c * q2d\n            - q3b * q2c * q1d\n        )\n        b = (\n            +q1a * q3c * q2d\n            - q1a * q2c * q3d\n            + q2a * q1c * q3d\n            - q2a * q3c * q1d\n            - q3a * q1c * q2d\n            + q3a * q2c * q1d\n        )\n        c = (\n            +q1a * q2b * q3d\n            - q1a * q3b * q2d\n            - q2a * q1b * q3d\n            + q2a * q3b * q1d\n            + q3a * q1b * q2d\n            - q3a * q2b * q1d\n        )\n        d = (\n            +q1a * q3b * q2c\n            - q1a * q2b * q3c\n            + q2a * q1b * q3c\n            - q2a * q3b * q1c\n            - q3a * q1b * q2c\n            + q3a * q2b * q1c\n        )\n        q = cls(np.vstack((a, b, c, d)).T)\n        return q\n\n    @property\n    def antipodal(self):\n        return self.__class__(np.stack([self.data, -self.data], axis=0))\n\n    def mean(self):\n        """"""\n        Calculates the mean quarternion with unitary weights\n\n        Notes\n        -----\n        The method used here corresponds to the Equation (13) of http://www.acsu.buffalo.edu/~johnc/ave_quat07.pdf\n        """"""\n        q = self.flatten().data.T\n        qq = q.dot(q.T)\n        w, v = np.linalg.eig(qq)\n        w_max = np.argmax(w)\n        return self.__class__(v[:, w_max])\n'"
orix/quaternion/orientation.py,12,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Rotations respecting symmetry.\n\nAn orientation is simply a rotation with respect to some reference frame. In\nthis respect, an orientation is in fact a *misorientation* - a change of\norientation - with respect to a reference of the identity rotation.\n\nIn orix, orientations and misorientations are distinguished from rotations\nonly by the inclusion of a notion of symmetry. Consider the following example:\n\n.. image:: /_static/img/orientation.png\n   :width: 200px\n   :alt: Two objects with two different rotations each. The square, with\n         fourfold symmetry, has the same orientation in both cases.\n   :align: center\n\nBoth objects have undergone the same *rotations* with respect to the reference.\nHowever, because the square has fourfold symmetry, it is indistinguishable\nin both cases, and hence has the same orientation.\n\n""""""\n\nfrom itertools import product as iproduct\nfrom itertools import combinations_with_replacement as icombinations\nimport numpy as np\nimport warnings\nfrom tqdm import tqdm\n\n\nfrom orix.quaternion.rotation import Rotation\nfrom orix.quaternion.symmetry import C1\nfrom orix.quaternion.orientation_region import OrientationRegion\n\n\ndef _distance(misorientation, verbose, split_size=100):\n    """""" private function to find the symmetry reduced distance between all\n    pairs of (mis)orientations\n\n    Parameters\n    ----------\n    misorientation : orix.Misorientation object\n        The misorientation to be considered.\n    verbose : bool\n        Output progress bar while computing.\n    split_size : int\n        Size of block to compute at a time.\n\n    Returns\n    -------\n    distance : np.array\n        2D matrix containing the angular distance between every\n        orientation, considering symmetries.\n    """"""\n    num_orientations = misorientation.shape[0]\n    S_1, S_2 = misorientation._symmetry\n    distance = np.full(misorientation.shape + misorientation.shape, np.infty)\n    split_size = split_size // S_1.shape[0]\n    outer_range = range(0, num_orientations, split_size)\n    if verbose:\n        outer_range = tqdm(outer_range, total=np.ceil(num_orientations / split_size))\n\n    S_1_outer_S_1 = S_1.outer(S_1)\n\n    # Calculate the upper half of the distance matrix block by block\n    for start_index_b in outer_range:\n        # we use slice object for compactness\n        index_slice_b = slice(\n            start_index_b, min(num_orientations, start_index_b + split_size)\n        )\n        o_sub_b = misorientation[index_slice_b]\n        for start_index_a in range(0, start_index_b + split_size, split_size):\n            index_slice_a = slice(\n                start_index_a, min(num_orientations, start_index_a + split_size)\n            )\n            o_sub_a = misorientation[index_slice_a]\n            axis = (len(o_sub_a.shape), len(o_sub_a.shape) + 1)\n            mis2orientation = (~o_sub_a).outer(S_1_outer_S_1).outer(o_sub_b)\n            # This works through all the identity rotations\n            for s_2_1, s_2_2 in icombinations(S_2, 2):\n                m = s_2_1 * mis2orientation * s_2_2\n                angle = m.angle.data.min(axis=axis)\n                distance[index_slice_a, index_slice_b] = np.minimum(\n                    distance[index_slice_a, index_slice_b], angle\n                )\n    # Symmetrize the matrix for convenience\n    i_lower = np.tril_indices(distance.shape[0], -1)\n    distance[i_lower] = distance.T[i_lower]\n    return distance\n\n\nclass Misorientation(Rotation):\n    """"""Misorientation object.\n\n    Misorientations represent transformations from one orientation,\n    :math:`o_1` to another, :math:`o_2`: :math:`o_2 \\\\cdot o_1^{-1}`.\n\n    They have symmetries associated with each of the starting orientations.\n\n    """"""\n\n    _symmetry = (C1, C1)\n\n    def __getitem__(self, key):\n        m = super(Misorientation, self).__getitem__(key)\n        m._symmetry = self._symmetry\n        return m\n\n    @property\n    def symmetry(self):\n        """"""tuple of Symmetry""""""\n        return self._symmetry\n\n    @property\n    def equivalent(self):\n        """"""Equivalent misorientations\n\n        Returns\n        -------\n        Misorientation\n\n        """"""\n        Gl, Gr = self._symmetry\n        if Gl._tuples == Gr._tuples:  # Grain exchange case\n            orientations = Orientation.stack([self, ~self]).flatten()\n        else:\n            orientations = Orientation(self)\n        equivalent = Gr.outer(orientations.outer(Gl))\n        return self.__class__(equivalent).flatten()\n\n    def set_symmetry(self, Gl, Gr, verbose=False):\n        """"""Assign symmetries to this misorientation.\n\n        Computes equivalent transformations which have the smallest angle of\n        rotation and assigns these in-place.\n\n        Parameters\n        ----------\n        Gl, Gr : Symmetry\n\n        Returns\n        -------\n        Misorientation\n            A new misorientation object with the assigned symmetry.\n\n        Examples\n        --------\n        >>> from orix.quaternion.symmetry import C4, C2\n        >>> data = np.array([[0.5, 0.5, 0.5, 0.5], [0, 1, 0, 0]])\n        >>> m = Misorientation(data).set_symmetry(C4, C2)\n        >>> m\n        Misorientation (2,) 4, 2\n        [[-0.7071  0.     -0.7071  0.    ]\n         [ 0.      0.7071 -0.7071  0.    ]]\n\n        """"""\n        symmetry_pairs = iproduct(Gl, Gr)\n        if verbose:\n            symmetry_pairs = tqdm(symmetry_pairs, total=Gl.size * Gr.size)\n\n        orientation_region = OrientationRegion.from_symmetry(Gl, Gr)\n        o_inside = self.__class__.identity(self.shape)\n        outside = np.ones(self.shape, dtype=bool)\n        for gl, gr in symmetry_pairs:\n            o_transformed = gl * self[outside] * gr\n            o_inside[outside] = o_transformed\n            outside = ~(o_inside < orientation_region)\n            if not np.any(outside):\n                break\n        o_inside._symmetry = (Gl, Gr)\n        return o_inside\n\n    def distance(self, verbose=False, split_size=100):\n        """"""Symmetry reduced distance\n\n        Compute the shortest distance between all orientations considering\n        symmetries.\n\n        Parameters\n        ---------\n        verbose : bool\n            Output progress bar while computing.\n        split_size : int\n            Size of block to compute at a time.\n\n        Returns\n        -------\n        distance : np.array\n            2D matrix containing the angular distance between every\n            orientation, considering symmetries.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from orix.quaternion.symmetry import C4, C2\n        >>> from orix.quaternion.orientation import Misorientation\n        >>> data = np.array([[0.5, 0.5, 0.5, 0.5], [0, 1, 0, 0]])\n        >>> m = Misorientation(data).set_symmetry(C4, C2)\n        >>> m.distance()\n        array([[3.14159265, 1.57079633],\n               [1.57079633, 0.        ]])\n        """"""\n        distance = _distance(self, verbose, split_size)\n        return distance.reshape(self.shape + self.shape)\n\n    def __repr__(self):\n        cls = self.__class__.__name__\n        shape = str(self.shape)\n        s1, s2 = self._symmetry[0].name, self._symmetry[1].name\n        s2 = """" if s2 == ""1"" else s2\n        symm = s1 + (s2 and "", "") + s2\n        data = np.array_str(self.data, precision=4, suppress_small=True)\n        rep = ""{} {} {}\\n{}"".format(cls, shape, symm, data)\n        return rep\n\n\nclass Orientation(Misorientation):\n    """"""Orientation object.\n\n    Orientations represent misorientations away from a reference of identity\n    and have only one associated symmetry.\n\n    Orientations support binary subtraction, producing a misorientation. That\n    is, to compute the misorientation from :math:`o_1` to :math:`o_2`,\n    call :code:`o_2 - o_1`.\n\n    """"""\n\n    @property\n    def symmetry(self):\n        """"""Symmetry""""""\n        return self._symmetry[1]\n\n    def set_symmetry(self, symmetry):\n        """"""Assign a symmetry to this orientation.\n\n        Computes equivalent transformations which have the smallest angle of\n        rotation and assigns these in-place.\n\n        Parameters\n        ----------\n        symmetry : Symmetry\n\n        Returns\n        -------\n        Orientation\n            The instance itself, with equivalent values.\n\n        Examples\n        --------\n        >>> from orix.quaternion.symmetry import C4\n        >>> data = np.array([[0.5, 0.5, 0.5, 0.5], [0, 1, 0, 0]])\n        >>> o = Orientation(data).set_symmetry((C4))\n        >>> o\n        Orientation (2,) 4\n        [[-0.7071  0.     -0.7071  0.    ]\n         [ 0.     -0.7071 -0.7071  0.    ]]\n\n        """"""\n        return super(Orientation, self).set_symmetry(C1, symmetry)\n\n    def __sub__(self, other):\n        if isinstance(other, Orientation):\n            misorientation = Misorientation(self * ~other)\n            m_inside = misorientation.set_symmetry(\n                self.symmetry, other.symmetry\n            ).squeeze()\n            return m_inside\n        return NotImplemented\n'"
orix/quaternion/orientation_region.py,23,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""An orientation region is some subset of the complete space of orientations.\n\nThe complete orientation space represents every possible orientation of an\nobject. The whole space is not always needed, for example if the orientation\nof an object is constrained or (most commonly) if the object is symmetrical. In\nthis case, the space can be segmented using sets of Rotations representing\nboundaries in the space. This is clearest in the Rodrigues parametrisation,\nwhere the boundaries are planes, such as the example here: the asymmetric\ndomain of an adjusted 432 symmetry.\n\n.. image:: /_static/img/orientation-region-Oq.png\n   :width: 300px\n   :alt: Boundaries of an orientation region in Rodrigues space.\n   :align: center\n\nRotations or orientations can be inside or outside of an orientation region.\n\n""""""\n\nimport itertools\nimport numpy as np\n\nfrom orix.quaternion import Quaternion\nfrom orix.quaternion.rotation import Rotation\nfrom orix.quaternion.symmetry import C1, get_distinguished_points\nfrom orix.vector.neo_euler import Rodrigues, AxAngle\n\nEPSILON = 1e-9  # small number to avoid round off problems\n\n\ndef _get_large_cell_normals(s1, s2):\n    dp = get_distinguished_points(s1, s2)\n    normals = Rodrigues.zero(dp.shape + (2,))\n    planes1 = dp.axis * np.tan(dp.angle.data / 4)\n    planes2 = -dp.axis * np.tan(dp.angle.data / 4) ** -1\n    planes2.data[np.isnan(planes2.data)] = 0\n    normals[:, 0] = planes1\n    normals[:, 1] = planes2\n    normals: Rotation = Rotation.from_neo_euler(normals).flatten().unique(\n        antipodal=False\n    )\n    if not normals.size:\n        return normals\n    _, inv = normals.axis.unique(return_inverse=True)\n    axes_unique = []\n    angles_unique = []\n    for i in np.unique(inv):\n        n = normals[inv == i]\n        axes_unique.append(n.axis.data[0])\n        angles_unique.append(n.angle.data.max())\n    normals = Rotation.from_neo_euler(\n        AxAngle.from_axes_angles(np.array(axes_unique), angles_unique)\n    )\n    return normals\n\n\ndef get_proper_groups(Gl, Gr):\n    """"""Return the appropriate groups for the asymmetric domain calculation.\n\n    Parameters\n    ----------\n    Gl, Gr : Symmetry\n\n    Returns\n    -------\n    Gl, Gr : Symmetry\n        The proper subgroup(s) or proper inversion subgroup(s) as appropriate.\n\n    Raises\n    ------\n    NotImplementedError\n        If both groups are improper and neither contain an inversion, special\n        consideration is needed which is not yet implemented in orix.\n\n    """"""\n    if Gl.is_proper and Gr.is_proper:\n        return Gl, Gr\n    elif Gl.is_proper and not Gr.is_proper:\n        return Gl, Gr.proper_subgroup\n    elif not Gl.is_proper and Gr.is_proper:\n        return Gl.proper_subgroup, Gr\n    else:\n        if Gl.contains_inversion and Gr.contains_inversion:\n            return Gl.proper_subgroup, Gr.proper_subgroup\n        elif Gl.contains_inversion and not Gr.contains_inversion:\n            return Gl.proper_subgroup, Gr.laue_proper_subgroup\n        elif not Gl.contains_inversion and Gr.contains_inversion:\n            return Gl.laue_proper_subgroup, Gr.proper_subgroup\n        else:\n            raise NotImplementedError(\n                ""Both groups are improper, "" ""and do not contain inversion.""\n            )\n\n\nclass OrientationRegion(Rotation):\n    """"""A set of :obj:`Rotation`s which are the normals of an orientation region.\n    """"""\n\n    @classmethod\n    def from_symmetry(cls, s1, s2=C1):\n        """"""The set of unique (mis)orientations of a symmetrical object.\n\n        Parameters\n        ----------\n        s1, s2 : Symmetry\n\n        """"""\n        s1, s2 = get_proper_groups(s1, s2)\n        large_cell_normals = _get_large_cell_normals(s1, s2)\n        disjoint = s1 & s2\n        fundamental_sector = disjoint.fundamental_sector()\n        fundamental_sector_normals = Rotation.from_neo_euler(\n            AxAngle.from_axes_angles(fundamental_sector, np.pi)\n        )\n        normals = Rotation(\n            np.concatenate([large_cell_normals.data, fundamental_sector_normals.data])\n        )\n        orientation_region = cls(normals)\n        vertices = orientation_region.vertices()\n        if vertices.size:\n            orientation_region = orientation_region[\n                np.any(\n                    np.isclose(orientation_region.dot_outer(vertices).data, 0), axis=1\n                )\n            ]\n        return orientation_region\n\n    def vertices(self):\n        """"""The vertices of the asymmetric domain.\n\n        Returns\n        -------\n        Rotation\n\n        """"""\n        normal_combinations = list(itertools.combinations(self, 3))\n        if len(normal_combinations) < 1:\n            return Rotation.empty()\n        c1, c2, c3 = zip(*normal_combinations)\n        c1, c2, c3 = (\n            Rotation.stack(c1).flatten(),\n            Rotation.stack(c2).flatten(),\n            Rotation.stack(c3).flatten(),\n        )\n        v = Rotation.triple_cross(c1, c2, c3)\n        v = v[~np.any(np.isnan(v.data), axis=-1)]\n        v = v[v < self].unique()\n        surface = np.any(np.isclose(v.dot_outer(self).data, 0), axis=1)\n        return v[surface]\n\n    def faces(self):\n        normals = Rotation(self)\n        vertices = self.vertices()\n        faces = []\n        for n in normals:\n            faces.append(vertices[np.isclose(vertices.dot(n).data, 0)])\n        faces = [f for f in faces if f.size > 2]\n        return faces\n\n    def __gt__(self, other):\n        """"""\n        overidden greater than method. Applying this to an Orientation\n        will return only orientations those that lie within the OrientationRegion\n        """"""\n\n        c = Quaternion(self).dot_outer(Quaternion(other)).data\n        inside = np.logical_or(\n            np.all(np.greater_equal(c, -EPSILON), axis=0),\n            np.all(np.less_equal(c, +EPSILON), axis=0),\n        )\n        return inside\n\n    def get_plot_data(self):\n        from orix.vector import Vector3d\n\n        theta = np.linspace(0, 2 * np.pi - EPSILON, 361)\n        rho = np.linspace(0, np.pi - EPSILON, 181)\n        theta, rho = np.meshgrid(theta, rho)\n        g = Vector3d.from_polar(rho, theta)\n        n = Rodrigues.from_rotation(self).norm.data[:, np.newaxis, np.newaxis]\n        if n.size == 0:\n            return Rotation.from_neo_euler(AxAngle.from_axes_angles(g, np.pi))\n        d = (-self.axis).dot_outer(g.unit).data\n        x = n * d\n        x = 2 * np.arctan(x ** -1)\n        x[x < 0] = np.pi\n        x = np.min(x, axis=0)\n        r = Rotation.from_neo_euler(AxAngle.from_axes_angles(g.unit, x))\n        return r\n'"
orix/quaternion/rotation.py,76,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Point transformations of objects.\n\nRotations are transformations of three-dimensional space leaving the\norigin in place. Rotations can be parametrized numerous ways, but in orix are\nhandled as unit quaternions. Rotations can act on vectors, or other rotations,\nbut not scalars. They are often most easily visualised as being a turn of a\ncertain angle about a certain axis.\n\n.. image:: /_static/img/rotation.png\n   :width: 200px\n   :alt: Rotation of an object illustrated with an axis and rotation angle.\n   :align: center\n\nRotations can also be *improper*. An improper rotation in orix operates on\nvectors as a rotation by the unit quaternion, followed by inversion. Hence,\na mirroring through the x-y plane can be considered an improper rotation of\n180\xc2\xb0 about the z-axis, illustrated in the figure below.\n\n.. image:: /_static/img/inversion.png\n   :width: 200px\n   :alt: 180\xc2\xb0 rotation followed by inversion, leading to a mirror operation.\n   :align: center\n\n\n""""""\nimport numpy as np\nfrom scipy.special import hyp0f1\n\nfrom orix.quaternion import Quaternion\nfrom orix.vector import Vector3d\nfrom orix.scalar import Scalar\n\n\nclass Rotation(Quaternion):\n    """"""Rotation object.\n\n    Rotations support the following mathematical operations:\n\n    - Unary negation.\n    - Inversion.\n    - Multiplication with other rotations and vectors.\n\n    Rotations inherit all methods from :class:`Quaternion` although behaviour is\n    different in some cases.\n\n    Rotations can be converted to other parametrizations, notably the neo-Euler\n    representations. See :class:`NeoEuler`.\n\n    """"""\n\n    def __init__(self, data):\n        super(Rotation, self).__init__(data)\n        self._data = np.concatenate((self.data, np.zeros(self.shape + (1,))), axis=-1)\n        if isinstance(data, Rotation):\n            self.improper = data.improper\n        with np.errstate(divide=""ignore"", invalid=""ignore""):\n            self.data = self.data / self.norm.data[..., np.newaxis]\n\n    def __mul__(self, other):\n        if isinstance(other, Rotation):\n            q = Quaternion(self) * Quaternion(other)\n            r = other.__class__(q)\n            i = np.logical_xor(self.improper, other.improper)\n            r.improper = i\n            return r\n        if isinstance(other, Quaternion):\n            q = Quaternion(self) * other\n            return q\n        if isinstance(other, Vector3d):\n            v = Quaternion(self) * other\n            improper = (self.improper * np.ones(other.shape)).astype(bool)\n            v[improper] = -v[improper]\n            return v\n        if isinstance(other, int) or isinstance(other, list):  # has to plus/minus 1\n            other = np.atleast_1d(other).astype(int)\n        if isinstance(other, np.ndarray):\n            assert np.all(\n                abs(other) == 1\n            ), ""Rotations can only be multiplied by 1 or -1""\n            r = Rotation(self.data)\n            r.improper = np.logical_xor(self.improper, other == -1)\n            return r\n        return NotImplemented\n\n    def __neg__(self):\n        r = self.__class__(self.data)\n        r.improper = np.logical_not(self.improper)\n        return r\n\n    def __getitem__(self, key):\n        r = super(Rotation, self).__getitem__(key)\n        r.improper = self.improper[key]\n        return r\n\n    def __invert__(self):\n        r = super(Rotation, self).__invert__()\n        r.improper = self.improper\n        return r\n\n    def unique(self, return_index=False, return_inverse=False, antipodal=True):\n        """"""Returns a new object containing only this object\'s unique entries.\n\n        Two rotations are not unique if:\n\n            - they have the same propriety AND\n                - they have the same numerical value OR\n                - the numerical value of one is the negative of the other\n\n        Parameters\n        ----------\n        return_index : bool, optional\n            If True, will also return the indices of the (flattened) data where\n            the unique entries were found.\n        return_inverse : bool, optional\n            If True, will also return the indices to reconstruct the (flattened)\n            data from the unique data.\n        antipodal : bool, optional\n            If False, rotations representing the same transformation\n            whose values are numerically different (negative) will *not* be\n            considered unique.\n\n        """"""\n        if len(self.data) == 0:\n            return self.__class__(self.data)\n        rotation = self.flatten()\n        if antipodal:\n            abcd = rotation._differentiators()\n        else:\n            abcd = np.stack(\n                [\n                    rotation.a.data,\n                    rotation.b.data,\n                    rotation.c.data,\n                    rotation.d.data,\n                    rotation.improper,\n                ],\n                axis=-1,\n            ).round(6)\n        _, idx, inv = np.unique(abcd, axis=0, return_index=True, return_inverse=True)\n        idx_sort = np.sort(idx)\n        dat = rotation[idx_sort]\n        dat.improper = rotation.improper[idx_sort]\n        if return_index and return_inverse:\n            return dat, idx_sort, inv\n        elif return_index and not return_inverse:\n            return dat, idx_sort\n        elif return_inverse and not return_index:\n            return dat, inv\n        else:\n            return dat\n\n    def _differentiators(self):\n        a = self.a.data\n        b = self.b.data\n        c = self.c.data\n        d = self.d.data\n        i = self.improper\n        abcd = np.stack(\n            (\n                a ** 2,\n                b ** 2,\n                c ** 2,\n                d ** 2,\n                a * b,\n                a * c,\n                a * d,\n                b * c,\n                b * d,\n                c * d,\n                i,\n            ),\n            axis=-1,\n        ).round(6)\n        return abcd\n\n    def angle_with(self, other):\n        """"""The angle of rotation transforming this rotation to the other.\n\n        Returns\n        -------\n        Scalar\n\n        """"""\n        other = Rotation(other)\n        angles = Scalar(\n            np.nan_to_num(np.arccos(2 * self.unit.dot(other.unit).data ** 2 - 1))\n        )\n        return angles\n\n    def outer(self, other):\n        """"""Compute the outer product of this rotation and the other object.""""""\n        r = super(Rotation, self).outer(other)\n        if isinstance(r, Rotation):\n            r.improper = np.logical_xor.outer(self.improper, other.improper)\n        if isinstance(r, Vector3d):\n            r[self.improper] = -r[self.improper]\n        return r\n\n    def flatten(self):\n        """"""A new object with the same data in a single column.""""""\n        r = super(Rotation, self).flatten()\n        r.improper = self.improper.T.flatten().T\n        return r\n\n    @property\n    def improper(self):\n        """"""ndarray : True for improper rotations and False otherwise.""""""\n        return self._data[..., -1].astype(bool)\n\n    @improper.setter\n    def improper(self, value):\n        self._data[..., -1] = value\n\n    def dot_outer(self, other):\n        """"""Scalar : the outer dot product of this rotation and the other.""""""\n        cosines = np.abs(super(Rotation, self).dot_outer(other).data)\n        if isinstance(other, Rotation):\n            improper = self.improper.reshape(self.shape + (1,) * len(other.shape))\n            i = np.logical_xor(improper, other.improper)\n            cosines = np.minimum(~i, cosines)\n        else:\n            cosines[self.improper] = 0\n        return Scalar(cosines)\n\n    @classmethod\n    def from_neo_euler(cls, neo_euler):\n        """"""Creates a rotation from a neo-euler (vector) representation.\n\n        Parameters\n        ----------\n        neo_euler : NeoEuler\n            Vector parametrization of a rotation.\n\n        """"""\n        s = np.sin(neo_euler.angle.data / 2)\n        a = np.cos(neo_euler.angle.data / 2)\n        b = s * neo_euler.axis.x.data\n        c = s * neo_euler.axis.y.data\n        d = s * neo_euler.axis.z.data\n        r = cls(np.stack([a, b, c, d], axis=-1))\n        return r\n\n    def to_euler(self, convention=""bunge""):  # TODO: other conventions\n        """"""Rotations as Euler angles.\n\n        Parameters\n        ----------\n        convention : \'bunge\'\n            The Euler angle convention used. Only \'bunge\'\n            is supported as present\n\n        Returns\n        -------\n        ndarray\n            Array of Euler angles in radians.\n\n        """"""\n        if convention != ""bunge"":\n            raise ValueError(""The convention you have specified is not supported"")\n        # A.14 from Modelling Simul. Mater. Sci. Eng. 23 (2015) 083501\n        n = self.data.shape[:-1]\n        e = np.zeros(n + (3,))\n\n        # move into pure numpy\n        a, b, c, d = self.a.data, self.b.data, self.c.data, self.d.data\n\n        q_zero_three = a ** 2 + d ** 2\n        q_one_two = b ** 2 + c ** 2\n        chi = np.sqrt(q_zero_three * q_one_two)\n\n        # P = 1\n\n        if np.sum(q_one_two == 0) > 0:  # checks that this occurs somewhere in data\n            alpha = np.arctan2(-2 * a * d, a ** 2 - d ** 2)\n            cond = [q_one_two == 0]\n            e[..., 0] = np.where(cond, alpha, e[..., 0])\n            e[..., 1] = np.where(cond, 0, e[..., 1])\n            e[..., 2] = np.where(cond, 0, e[..., 2])\n\n        if np.sum(q_zero_three == 0) > 0:\n            alpha = np.arctan2(2 * b * c, b ** 2 - c ** 2)\n            cond = [q_zero_three == 0]\n            e[..., 0] = np.where(cond, alpha, e[..., 0])\n            e[..., 1] = np.where(cond, np.pi, e[..., 1])\n            e[..., 2] = np.where(cond, 0, e[..., 2])\n\n        if np.sum(chi != 0) > 0:\n            alpha = np.arctan2(\n                np.divide(b * d - a * c, chi), np.divide(-a * b - c * d, chi)\n            )\n            beta = np.arctan2(2 * chi, q_zero_three - q_one_two)\n            gamma = np.arctan2(\n                np.divide(a * c + b * d, chi), np.divide(c * d - a * b, chi)\n            )\n\n            e[..., 0] = np.where(chi != 0, alpha, e[..., 0])\n            e[..., 1] = np.where(chi != 0, beta, e[..., 1])\n            e[..., 2] = np.where(chi != 0, gamma, e[..., 2])\n\n        return e\n\n    @classmethod\n    def from_euler(cls, euler, convention=""bunge"", direction=""crystal2lab""):\n        """"""Creates a rotation from an array of Euler angles.\n\n        Parameters\n        ----------\n        euler : array-like\n            Euler angles in the Bunge convention.\n        convention : str\n            Only \'bunge\' is currently suppported for new data\n        direction : str\n            \'lab2crystal\' or \'crystal2lab\'\n        """"""\n        if convention not in  [""bunge"",""Krakow_Hielscher""]:\n            raise ValuerError(""The chosen convention is not one of the allowed options"")\n        if direction not in [""lab2crystal"", ""crystal2lab""]:\n            raise ValueError(""The chosen direction is not one of the allowed options"")\n\n        if convention == ""Krakow_Hielscher"":\n            # To be applied to the data found at:\n            # https://www.repository.cam.ac.uk/handle/1810/263510\n            euler = np.array(euler)\n            n = euler.shape[:-1]\n            alpha, beta, gamma = euler[..., 0], euler[..., 1], euler[..., 2]\n            alpha -= np.pi / 2\n            gamma -= 3 * np.pi / 2\n            zero = np.zeros(n)\n            qalpha = Quaternion(\n                np.stack((np.cos(alpha / 2), zero, zero, np.sin(alpha / 2)), axis=-1)\n            )\n            qbeta = Quaternion(\n                np.stack((np.cos(beta / 2), zero, np.sin(beta / 2), zero), axis=-1)\n            )\n            qgamma = Quaternion(\n                np.stack((np.cos(gamma / 2), zero, zero, np.sin(gamma / 2)), axis=-1)\n            )\n            data = qalpha * qbeta * qgamma\n\n            rot = cls(data.data)\n            rot.improper = zero\n            return rot\n\n        elif convention == ""bunge"":\n            euler = np.array(euler)\n            n = euler.shape[:-1]\n\n            # Uses A.5 & A.6 from Modelling Simul. Mater. Sci. Eng. 23 (2015) 083501\n\n            alpha = euler[..., 0]  # psi1\n            beta = euler[..., 1]  # Psi\n            gamma = euler[..., 2]  # psi3\n\n            sigma = 0.5 * np.add(alpha, gamma)\n            delta = 0.5 * np.subtract(alpha, gamma)\n            c = np.cos(beta / 2)\n            s = np.sin(beta / 2)\n\n            # Using P = 1 from A.6\n            q = np.zeros(n + (4,))\n            q[..., 0] = c * np.cos(sigma)\n            q[..., 1] = -s * np.cos(delta)\n            q[..., 2] = -s * np.sin(delta)\n            q[..., 3] = -c * np.sin(sigma)\n\n            for i in [1, 2, 3, 0]:  # flip the zero element last\n                q[..., i] = np.where(q[..., 0] < 0, -q[..., i], q[..., i])\n\n            data = Quaternion(q)\n\n            if direction == ""lab2crystal"":\n                data = ~data\n\n            rot = cls(data.data)\n            rot.improper = np.zeros((n))\n            return rot\n\n    @classmethod\n    def identity(cls, shape=(1,)):\n        """"""Create identity rotations.\n\n        Parameters\n        ----------\n        shape : tuple\n            The shape out of which to construct identity quaternions\n\n        """"""\n        data = np.zeros(shape + (4,))\n        data[..., 0] = 1\n        return cls(data)\n\n    @property\n    def axis(self):\n        """"""Vector3d : the axis of rotation.""""""\n        axis = Vector3d(np.stack((self.b.data, self.c.data, self.d.data), axis=-1))\n        axis[self.a.data < -1e-6] = -axis[self.a.data < -1e-6]\n        axis[axis.norm.data == 0] = Vector3d.zvector() * np.sign(\n            self.a[axis.norm.data == 0].data\n        )\n        axis.data = axis.data / axis.norm.data[..., np.newaxis]\n        return axis\n\n    @property\n    def angle(self):\n        """"""Scalar : the angle of rotation.""""""\n        return Scalar(2 * np.nan_to_num(np.arccos(np.abs(self.a.data))))\n\n    @classmethod\n    def random(cls, shape=(1,)):\n        """"""Uniformly distributed rotations.\n\n        Parameters\n        ----------\n        shape : int or tuple of int, optional\n            The shape of the required object.\n\n        """"""\n        shape = (shape,) if isinstance(shape, int) else shape\n        n = int(np.prod(shape))\n        rotations = []\n        while len(rotations) < n:\n            r = np.random.uniform(-1, 1, (3 * n, cls.dim))\n            r2 = np.sum(np.square(r), axis=1)\n            r = r[np.logical_and(1e-9 ** 2 < r2, r2 <= 1)]\n            rotations += list(r)\n        return cls(np.array(rotations[:n])).reshape(*shape)\n\n    @classmethod\n    def random_vonmises(cls, shape=(1,), alpha=1.0, reference=(1, 0, 0, 0), eps=1e-6):\n        """"""Random rotations with a simplified Von Mises-Fisher distribution.\n\n        Parameters\n        ----------\n        shape : int or tuple of int, optional\n            The shape of the required object.\n        alpha : float\n            Parameter for the VM-F distribution. Lower values lead to ""looser""\n            distributions.\n        reference : Rotation\n            The center of the distribution.\n        eps : float\n            A small fixed variable.\n\n        """"""\n        shape = (shape,) if isinstance(shape, int) else shape\n        reference = Rotation(reference)\n        n = int(np.prod(shape))\n        sample_size = int(alpha) * n\n        rotations = []\n        f_max = von_mises(reference, alpha, reference)\n        while len(rotations) < n:\n            rotation = cls.random(sample_size)\n            f = von_mises(rotation, alpha, reference)\n            x = np.random.rand(sample_size)\n            rotation = rotation[x * f_max < f]\n            rotations += list(rotation)\n        return cls.stack(rotations[:n]).reshape(*shape)\n\n    @property\n    def antipodal(self):\n        """"""Rotation : this and antipodally equivalent rotations.""""""\n        r = self.__class__(np.stack([self.data, -self.data], axis=0))\n        r.improper = self.improper\n        return r\n\n\ndef von_mises(x, alpha, reference=Rotation((1, 0, 0, 0))):\n    """"""A vastly simplified Von Mises-Fisher distribution calculation.\n\n    Parameters\n    ----------\n    x : Rotation\n    alpha : float\n        Lower values of alpha lead to ""looser"" distributions.\n    reference : Rotation\n\n    Notes\n    -----\n    This simplified version of the distribution is calculated using\n\n    .. math:: \\\\frac{\\\\exp\\\\left(2\\\\alpha\\\\cos\\\\left(\\\\omega\\\\right)\\\\right)}{_0F_1\\\\left(\\\\frac{N}{2}, \\\\alpha^2\\\\right)}\n\n    where :math:`\\omega` is the angle between orientations and :math:`N` is the\n    number of relevant dimensions, in this case 3.\n\n    Returns\n    -------\n    ndarray\n\n    """"""\n    angle = x.angle_with(reference)\n    return np.exp(2 * alpha * np.cos(angle.data)) / hyp0f1(1.5, alpha ** 2)\n'"
orix/quaternion/symmetry.py,7,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Collections of transformations representing a symmetry group.\n\nAn object\'s symmetry can be characterized by the transformations relating\nsymmetrically-equivalent views on that object. Consider the following shape.\n\n.. image:: /_static/img/triad-object.png\n   :width: 200px\n   :alt: Image of an object with three-fold symmetry.\n   :align: center\n\nThis obviously has three-fold symmetry. If we rotated it by\n:math:`\\\\frac{2}{3}\\\\pi` or :math:`\\\\frac{4}{3}\\\\pi`, the image would be unchanged.\nThese angles, as well as :math:`0`, or the identity, expressed as quaternions,\nform a group. Applying any operation in the group to any other results in\nanother member of the group.\n\nSymmetries can consist of rotations or inversions, expressed as\nimproper rotations. A mirror symmetry is equivalent to a 2-fold rotation\ncombined with inversion.\n\n""""""\nimport numpy as np\n\nfrom orix.quaternion.rotation import Rotation\nfrom orix.vector import Vector3d\n\n\nclass Symmetry(Rotation):\n    """"""The set of rotations comprising a point group.\n\n    """"""\n\n    name = """"\n\n    def __repr__(self):\n        cls = self.__class__.__name__\n        shape = str(self.shape)\n        data = np.array_str(self.data, precision=4, suppress_small=True)\n        rep = ""{} {}{pad}{}\\n{}"".format(\n            cls, shape, self.name, data, pad=self.name and "" ""\n        )\n        return rep\n\n    def __and__(self, other):\n        return Symmetry.from_generators(\n            *[g for g in self.subgroups if g in other.subgroups]\n        )\n\n    @property\n    def order(self):\n        """"""int : The number of elements of the group.""""""\n        return self.size\n\n    @property\n    def is_proper(self):\n        """"""bool : True if this group contains only proper rotations.""""""\n        return np.all(np.equal(self.improper, 0))\n\n    @property\n    def subgroups(self):\n        """"""list of Symmetry : the groups that are subgroups of this group.""""""\n        return [g for g in _groups if g._tuples <= self._tuples]\n\n    @property\n    def proper_subgroups(self):\n        """"""list of Symmetry : the proper groups that are subgroups of this group.""""""\n        return [g for g in self.subgroups if g.is_proper]\n\n    @property\n    def proper_subgroup(self):\n        """"""Symmetry : the largest proper group of this subgroup.""""""\n        subgroups = self.proper_subgroups\n        subgroups_sorted = sorted(subgroups, key=lambda g: g.order)\n        return subgroups_sorted[-1]\n\n    @property\n    def laue(self):\n        """"""Symmetry : this group plus inversion""""""\n        laue_group = Symmetry.from_generators(self, Ci)\n        return laue_group\n\n    @property\n    def laue_proper_subgroup(self):\n        """"""Symmetry : the proper subgroup of this group plus inversion.""""""\n        return self.laue.proper_subgroup\n\n    @property\n    def contains_inversion(self):\n        """"""bool : True if this group contains inversion.""""""\n        return Ci._tuples <= self._tuples\n\n    @property\n    def _tuples(self):\n        """"""set of tuple : the differentiators of this group.""""""\n        s = Rotation(self.flatten())\n        tuples = set([tuple(d) for d in s._differentiators()])\n        return tuples\n\n    @classmethod\n    def from_generators(cls, *generators):\n        """"""Create a Symmetry from a minimum list of generating transformations.\n\n        Parameters\n        ----------\n        generators : Rotation\n            An arbitrary list of constituent transformations.\n\n        Returns\n        -------\n        Symmetry\n\n        Examples\n        --------\n        Combining a 180\xc2\xb0 rotation about [1, -1, 0] with a 4-fold rotoinversion\n        axis along [0, 0, 1]\n\n        >>> myC2 = Symmetry([(1, 0, 0, 0), (0, 0.75**0.5, -0.75**0.5, 0)])\n        >>> myS4 = Symmetry([(1, 0, 0, 0), (0.5**0.5, 0, 0, 0.5**0.5)])\n        >>> myS4.improper = [0, 1]\n        >>> mySymmetry = Symmetry.from_generators(myC2, myS4)\n        >>> mySymmetry\n        Symmetry (8,)\n        [[ 1.      0.      0.      0.    ]\n         [ 0.      0.7071 -0.7071  0.    ]\n         [ 0.7071  0.      0.      0.7071]\n         [ 0.      0.     -1.      0.    ]\n         [ 0.      1.      0.      0.    ]\n         [-0.7071  0.      0.      0.7071]\n         [ 0.      0.      0.      1.    ]\n         [ 0.     -0.7071 -0.7071  0.    ]]\n        """"""\n        generator = cls((1, 0, 0, 0))\n        for g in generators:\n            generator = generator.outer(Symmetry(g)).unique()\n        size = 1\n        size_new = generator.size\n        while size_new != size and size_new < 48:\n            size = size_new\n            generator = generator.outer(generator).unique()\n            size_new = generator.size\n        return generator\n\n    def get_axis_orders(self):\n        s = self[self.angle > 0]\n        if s.size == 0:\n            return {}\n        return {\n            Vector3d(a): b + 1\n            for a, b in zip(*np.unique(s.axis.data, axis=0, return_counts=True))\n        }\n\n    def get_highest_order_axis(self):\n        axis_orders = self.get_axis_orders()\n        if len(axis_orders) == 0:\n            return Vector3d.zvector(), np.infty\n        highest_order = max(axis_orders.values())\n        axes = Vector3d.stack(\n            [ao for ao in axis_orders if axis_orders[ao] == highest_order]\n        ).flatten()\n        return axes, highest_order\n\n    @property\n    def diads(self):\n        axis_orders = self.get_axis_orders()\n        diads = [ao for ao in axis_orders if axis_orders[ao] == 2]\n        if len(diads) == 0:\n            return Vector3d.empty()\n        return Vector3d.stack(diads).flatten()\n\n    def fundamental_sector(self):\n        from orix.vector.neo_euler import AxAngle\n        from orix.vector.spherical_region import SphericalRegion\n\n        symmetry = self.antipodal\n        symmetry = symmetry[symmetry.angle > 0]\n        axes, order = symmetry.get_highest_order_axis()\n        if order > 6:\n            return Vector3d.empty()\n        axis = Vector3d.zvector().get_nearest(axes, inclusive=True)\n        r = Rotation.from_neo_euler(AxAngle.from_axes_angles(axis, 2 * np.pi / order))\n\n        diads = symmetry.diads\n        nearest_diad = axis.get_nearest(diads)\n        if nearest_diad.size == 0:\n            nearest_diad = axis.perpendicular\n\n        n1 = axis.cross(nearest_diad).unit\n        n2 = -(r * n1)\n        next_diad = r * nearest_diad\n        n = Vector3d.stack((n1, n2)).flatten()\n        sr = SphericalRegion(n.unique())\n        inside = symmetry[symmetry.axis < sr]\n        if inside.size == 0:\n            return sr\n        axes, order = inside.get_highest_order_axis()\n        axis = axis.get_nearest(axes)\n        r = Rotation.from_neo_euler(AxAngle.from_axes_angles(axis, 2 * np.pi / order))\n        nearest_diad = next_diad\n        n1 = axis.cross(nearest_diad).unit\n        n2 = -(r * n1)\n        n = Vector3d(np.concatenate((n.data, n1.data, n2.data)))\n        sr = SphericalRegion(n.unique())\n        return sr\n\n\n# Triclinic\nC1 = Symmetry((1, 0, 0, 0))\nC1.name = ""1""\nCi = Symmetry([(1, 0, 0, 0), (1, 0, 0, 0)])\nCi.improper = [0, 1]\nCi.name = ""-1""\n\n# Special generators\n_mirror_xy = Symmetry([(1, 0, 0, 0), (0, 0.75 ** 0.5, -(0.75 ** 0.5), 0)])\n_mirror_xy.improper = [0, 1]\n_cubic = Symmetry([(1, 0, 0, 0), (0.5, 0.5, 0.5, 0.5)])\n\n# 2-fold rotations\nC2x = Symmetry([(1, 0, 0, 0), (0, 1, 0, 0)])\nC2x.name = ""211""\nC2y = Symmetry([(1, 0, 0, 0), (0, 0, 1, 0)])\nC2y.name = ""121""\nC2z = Symmetry([(1, 0, 0, 0), (0, 0, 0, 1)])\nC2z.name = ""112""\nC2 = Symmetry(C2z)\nC2.name = ""2""\n\n# Mirrors\nCsx = Symmetry([(1, 0, 0, 0), (0, 1, 0, 0)])\nCsx.improper = [0, 1]\nCsx.name = ""m11""\nCsy = Symmetry([(1, 0, 0, 0), (0, 0, 1, 0)])\nCsy.improper = [0, 1]\nCsy.name = ""1m1""\nCsz = Symmetry([(1, 0, 0, 0), (0, 0, 0, 1)])\nCsz.improper = [0, 1]\nCsz.name = ""11m""\nCs = Symmetry(Csz)\nCs.name = ""m""\n\n# Monoclinic\nC2h = Symmetry.from_generators(C2, Cs)\nC2h.name = ""2/m""\n\n# Orthorhombic\nD2 = Symmetry.from_generators(C2z, C2x, C2y)\nD2.name = ""222""\nC2v = Symmetry.from_generators(C2x, Csz)\nC2v.name = ""mm2""\nD2h = Symmetry.from_generators(Csz, Csx, Csy)\nD2h.name = ""mmm""\n\n# 4-fold rotations\nC4x = Symmetry(\n    [\n        (1, 0, 0, 0),\n        (0.5 ** 0.5, 0.5 ** 0.5, 0, 0),\n        (0, 1, 0, 0),\n        (-(0.5 ** 0.5), 0.5 ** 0.5, 0, 0),\n    ]\n)\nC4y = Symmetry(\n    [\n        (1, 0, 0, 0),\n        (0.5 ** 0.5, 0, 0.5 ** 0.5, 0),\n        (0, 0, 1, 0),\n        (-(0.5 ** 0.5), 0, 0.5 ** 0.5, 0),\n    ]\n)\nC4z = Symmetry(\n    [\n        (1, 0, 0, 0),\n        (0.5 ** 0.5, 0, 0, 0.5 ** 0.5),\n        (0, 0, 0, 1),\n        (-(0.5 ** 0.5), 0, 0, 0.5 ** 0.5),\n    ]\n)\nC4 = Symmetry(C4z)\nC4.name = ""4""\n\n# Tetragonal\nS4 = Symmetry.from_generators(C2, Ci)\nS4.name = ""-4""\nC4h = Symmetry.from_generators(C4, Cs)\nC4h.name = ""4/m""\nD4 = Symmetry.from_generators(C4, C2x, C2y)\nD4.name = ""422""\nC4v = Symmetry.from_generators(C4, Csx)\nC4v.name = ""4mm""\nD2d = Symmetry.from_generators(D2, _mirror_xy)\nD2d.name = ""-42m""\nD4h = Symmetry.from_generators(C4h, Csx, Csy)\nD4h.name = ""4/mmm""\n\n# 3-fold rotations\nC3x = Symmetry([(1, 0, 0, 0), (0.5, 0.75 ** 0.5, 0, 0), (-0.5, 0.75 ** 0.5, 0, 0)])\nC3y = Symmetry([(1, 0, 0, 0), (0.5, 0, 0.75 ** 0.5, 0), (-0.5, 0, 0.75 ** 0.5, 0)])\nC3z = Symmetry([(1, 0, 0, 0), (0.5, 0, 0, 0.75 ** 0.5), (-0.5, 0, 0, 0.75 ** 0.5)])\nC3 = Symmetry(C3z)\nC3.name = ""3""\n\n# Trigonal\nS6 = Symmetry.from_generators(C3, Ci)\nS6.name = ""-3""\nD3x = Symmetry.from_generators(C3, C2x)\nD3x.name = ""321""\nD3y = Symmetry.from_generators(C3, C2y)\nD3y.name = ""312""\nD3 = Symmetry(D3x)\nD3.name = ""32""\nC3v = Symmetry.from_generators(C3, Csx)\nC3v.name = ""3m""\nD3d = Symmetry.from_generators(S6, Csx)\nD3d.name = ""-3m""\n\n# Hexagonal\nC6 = Symmetry.from_generators(C3, C2)\nC6.name = ""6""\nC3h = Symmetry.from_generators(C3, Cs)\nC3h.name = ""-6""\nC6h = Symmetry.from_generators(C6, Cs)\nC6h.name = ""6/m""\nD6 = Symmetry.from_generators(C6, C2x, C2y)\nD6.name = ""622""\nC6v = Symmetry.from_generators(C6, Csx)\nC6v.name = ""6mm""\nD3h = Symmetry.from_generators(C3, C2y, Csz)\nD3h.name = ""-6m2""\nD6h = Symmetry.from_generators(D6, Csz)\nD6h.name = ""6/mmm""\n\n# Cubic\nT = Symmetry.from_generators(C2, _cubic)\nT.name = ""23""\nTh = Symmetry.from_generators(T, Ci)\nTh.name = ""m-3""\nO = Symmetry.from_generators(C4, _cubic, C2x)\nO.name = ""432""\nTd = Symmetry.from_generators(T, _mirror_xy)\nTd.name = ""-43m""\nOh = Symmetry.from_generators(O, Ci)\nOh.name = ""m-3m""\n\n_groups = [\n    C1,\n    Ci,  # triclinic\n    C2x,\n    C2y,\n    C2z,\n    Csx,\n    Csy,\n    Csz,\n    C2h,  # monoclinic\n    D2,\n    C2v,\n    D2h,  # orthorhombic\n    C4,\n    S4,\n    C4h,\n    D4,\n    C4v,\n    D2d,\n    D4h,  # tetragonal\n    C3,\n    S6,\n    D3x,\n    D3y,\n    D3,\n    C3v,\n    D3d,  # trigonal\n    C6,\n    C3h,\n    C6h,\n    D6,\n    C6v,\n    D3h,\n    D6h,  # hexagonal\n    T,\n    Th,\n    O,\n    Td,\n    Oh,  # cubic\n]\n_proper_groups = [C1, C2, C2x, C2y, C2z, D2, C4, D4, C3, D3x, D3y, D3, C6, D6, T, O]\n\n\ndef get_distinguished_points(s1, s2=C1):\n    """"""Points symmetrically equivalent to identity with respect to `s1` and `s2`\n\n    Parameters\n    ----------\n    s1, s2 : Symmetry\n\n    Returns\n    -------\n    Rotation\n\n    """"""\n    distinguished_points = s1.outer(s2).antipodal.unique(antipodal=False)\n    return distinguished_points[distinguished_points.angle > 0]\n'"
orix/scalar/__init__.py,26,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Dimensionless quantities.\n\nAs well as themselves representing physical quantities, Scalars\nmay represent elements of higher-dimensional quantities, such as the x-component\nof a vector or the rotation angle of a quaternion.\n\n""""""\nimport numpy as np\nfrom orix.base import Object3d, DimensionError\n\n\nclass Scalar(Object3d):\n    """"""Scalar base class.\n\n    Scalars currently support the following mathematical operations:\n\n        - Unary negation.\n        - Addition to other scalars, numerical types, and array_like objects.\n        - Subtraction to the above.\n        - Multiplication to the above.\n        - Element-wise boolean comparisons (``==``, ``<`` etc).\n        - Unary exponentiation.\n\n    """"""\n\n    dim = 0\n\n    def __init__(self, data):\n        if isinstance(data, Object3d):\n            self._data = data._data\n        else:\n            data = np.atleast_1d(data)\n            self._data = data\n\n    @property\n    def data(self):\n        return self._data\n\n    def __neg__(self):\n        return self.__class__(-self.data)\n\n    def __add__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(self.data + other.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data + other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data + other)\n        return NotImplemented\n\n    def __radd__(self, other):\n        if isinstance(other, (int, float)):\n            return self.__class__(other + self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other + self.data)\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(self.data - other.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data - other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data - other)\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, (int, float)):\n            return self.__class__(other - self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other - self.data)\n        return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(self.data * other.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data * other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data * other)\n        return NotImplemented\n\n    def __rmul__(self, other):\n        if isinstance(other, (int, float)):\n            return self.__class__(other * self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other * self.data)\n        return NotImplemented\n\n    def __eq__(self, other):\n        if isinstance(other, Scalar):\n            return self.data == other.data\n        elif isinstance(other, (int, float)):\n            return self.data == other\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.data == other\n        return NotImplemented\n\n    def __gt__(self, other):\n        if isinstance(other, Scalar):\n            return self.data > other.data\n        elif isinstance(other, (int, float)):\n            return self.data > other\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.data > other\n        return NotImplemented\n\n    def __lt__(self, other):\n        if isinstance(other, Scalar):\n            return self.data < other.data\n        elif isinstance(other, (int, float)):\n            return self.data < other\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.data < other\n        return NotImplemented\n\n    def __ge__(self, other):\n        if isinstance(other, Scalar):\n            return self.data >= other.data\n        elif isinstance(other, (int, float)):\n            return self.data >= other\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.data >= other\n        return NotImplemented\n\n    def __le__(self, other):\n        if isinstance(other, Scalar):\n            return self.data <= other.data\n        elif isinstance(other, (int, float)):\n            return self.data <= other\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.data <= other\n        return NotImplemented\n\n    def __pow__(self, power, modulo=None):\n        if isinstance(power, (int, float)):\n            return self.__class__(self.data ** power)\n        elif isinstance(power, (list, tuple)):\n            power = np.array(power)\n        if isinstance(power, np.ndarray):\n            return self.__class__(self.data ** power)\n        return NotImplemented\n\n    @classmethod\n    def stack(cls, sequence):\n        sequence = [s.data for s in sequence]\n        stack = np.stack(sequence, axis=-1)\n        return cls(stack)\n\n    @property\n    def shape(self):\n        """"""Tuple of the shape of the Scalar.\n\n        Returns\n        -------\n        tuple\n\n        """"""\n        return self.data.shape\n\n    def reshape(self, *args):\n        """"""Returns a new Scalar containing the same data with a new shape.""""""\n        return self.__class__(self.data.reshape(*args))\n\n    def flatten(self):\n        """"""Scalar : A new object with the same data in a single column.""""""\n        return self.__class__(self.data.T.flatten())\n'"
orix/tests/__init__.py,0,b''
orix/tests/conftest.py,75,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport gc\nimport os\nfrom tempfile import TemporaryDirectory\n\nfrom h5py import File\nimport numpy as np\nimport pytest\n\nfrom orix.crystal_map import CrystalMap\nfrom orix.crystal_map.phase_list import PhaseList\nfrom orix.quaternion.rotation import Rotation\n\n\n@pytest.fixture\ndef rotations():\n    return Rotation([(2, 4, 6, 8), (-1, -2, -3, -4)])\n\n\n# TODO: Exchange for a multiphase header (change `phase_id` accordingly)\nANGFILE_TSL_HEADER = (\n    ""# TEM_PIXperUM          1.000000\\n""\n    ""# x-star                0.413900\\n""\n    ""# y-star                0.729100\\n""\n    ""# z-star                0.514900\\n""\n    ""# WorkingDistance       27.100000\\n""\n    ""#\\n""\n    ""# Phase 1\\n""\n    ""# MaterialName      Aluminum\\n""\n    ""# Formula       Al\\n""\n    ""# Info      \\n""\n    ""# Symmetry              43\\n""\n    ""# LatticeConstants      4.040 4.040 4.040  90.000  90.000  90.000\\n""\n    ""# NumberFamilies        69\\n""\n    ""# hklFamilies        1 -1 -1 1 8.469246 1\\n""\n    ""# ElasticConstants  -1.000000 -1.000000 -1.000000 -1.000000 -1.000000 -1.000000\\n""\n    ""# Categories0 0 0 0 0 \\n""\n    ""#\\n""\n    ""# GRID: SqrGrid\\n""\n    ""# XSTEP: 0.100000\\n""\n    ""# YSTEP: 0.100000\\n""\n    ""# NCOLS_ODD: 42\\n""\n    ""# NCOLS_EVEN: 42\\n""\n    ""# NROWS: 13\\n""\n    ""#\\n""\n    ""# OPERATOR:     sem\\n""\n    ""#\\n""\n    ""# SAMPLEID:     \\n""\n    ""#\\n""\n    ""# SCANID:   \\n""\n    ""#\\n""\n)\n\nANGFILE_ASTAR_HEADER = (\n    ""# File created from ACOM RES results\\n""\n    ""# ni-dislocations.res\\n""\n    ""#     \\n""\n    ""#     \\n""\n    ""# MaterialName      Nickel\\n""\n    ""# Formula\\n""\n    ""# Symmetry          43\\n""\n    ""# LatticeConstants  3.520  3.520  3.520  90.000  90.000  90.000\\n""\n    ""# NumberFamilies    4\\n""\n    ""# hklFamilies       1  1  1 1 0.000000\\n""\n    ""# hklFamilies       2  0  0 1 0.000000\\n""\n    ""# hklFamilies       2  2  0 1 0.000000\\n""\n    ""# hklFamilies       3  1  1 1 0.000000\\n""\n    ""#\\n""\n    ""# GRID: SqrGrid#\\n""\n)\n\nANGFILE_EMSOFT_HEADER = (\n    ""# TEM_PIXperUM          1.000000\\n""\n    ""# x-star                 0.446667\\n""\n    ""# y-star                 0.586875\\n""\n    ""# z-star                 0.713450\\n""\n    ""# WorkingDistance        0.000000\\n""\n    ""#\\n""\n    ""# Phase 1\\n""\n    ""# MaterialName    austenite\\n""\n    ""# Formula       austenite\\n""\n    ""# Info          patterns indexed using EMsoft::EMEBSDDI\\n""\n    ""# Symmetry              43\\n""\n    ""# LatticeConstants      3.595 3.595 3.595   90.000 90.000 90.000\\n""\n    ""# NumberFamilies        0\\n""\n    ""# Phase 2\\n""\n    ""# MaterialName    ferrite/ferrite\\n""\n    ""# Formula       ferrite/ferrite\\n""\n    ""# Info          patterns indexed using EMsoft::EMEBSDDI\\n""\n    ""# Symmetry              43\\n""\n    ""# LatticeConstants      2.867 2.867 2.867   90.000 90.000 90.000\\n""\n    ""# NumberFamilies        0\\n""\n    ""# GRID: SqrGrid\\n""\n    ""# XSTEP:  1.500000\\n""\n    ""# YSTEP:  1.500000\\n""\n    ""# NCOLS_ODD:   13\\n""\n    ""# NCOLS_EVEN:   13\\n""\n    ""# NROWS:   42\\n""\n    ""#\\n""\n    ""# OPERATOR:   H\xc3\xa5kon Wiik \xc3\x85nes\\n""\n    ""#\\n""\n    ""# SAMPLEID:\\n""\n    ""#\\n""\n    ""# SCANID:\\n""\n    ""#\\n""\n)\n\n\n@pytest.fixture()\ndef temp_ang_file():\n    with TemporaryDirectory() as tempdir:\n        f = open(os.path.join(tempdir, ""temp_ang_file.ang""), mode=""w+"")\n        yield f\n        gc.collect()  # Garbage collection so that file can be used by multiple tests\n\n\n@pytest.fixture(\n    params=[\n        # Tuple with default values for five parameters: map_shape, step_sizes,\n        # phase_id, n_unknown_columns, and rotations (see docstring below)\n        (\n            (7, 13),  # map_shape\n            (0.1, 0.1),  # step_sizes\n            np.random.choice([0], 7 * 13),  # phase_id\n            5,  # Number of unknown columns (one between ci and fit, the rest after fit)\n            np.array(\n                [[4.48549, 0.95242, 0.79150], [1.34390, 0.27611, 0.82589],]\n            ),  # rotations as rows of Euler angle triplets\n        )\n    ]\n)\ndef angfile_tsl(tmpdir, request):\n    """"""Create a dummy EDAX TSL .ang file from input.\n\n    10% of map points are set to non-indexed (confidence index equal to\n    -1).\n\n    Parameters expected in `request`\n    --------------------------------\n    map_shape : tuple of ints\n        Map shape to create.\n    step_sizes : tuple of floats\n        Step sizes in x and y coordinates in microns.\n    phase_id : np.ndarray\n        Array of map size with phase IDs in header.\n    n_unknown_columns : int\n        Number of columns with unknown values.\n    rotations : np.ndarray\n        A sample, smaller than the map size, of example rotations as\n        rows of Euler angle triplets.\n\n    """"""\n    f = tmpdir.join(""angfile_tsl.ang"")\n\n    # Unpack parameters\n    (ny, nx), (dy, dx), phase_id, n_unknown_columns, example_rotations = request.param\n\n    # File columns\n    map_size = ny * nx\n    x = np.tile(np.arange(nx) * dx, ny)\n    y = np.sort(np.tile(np.arange(ny) * dy, nx))\n    ci = np.random.random(map_size)  # [0, 1]\n    iq = np.random.uniform(low=1e3, high=1e6, size=map_size)\n    un = np.zeros(map_size, dtype=int)\n    fit = np.random.uniform(low=0, high=3, size=map_size)\n    # Rotations\n    rot_idx = np.random.choice(np.arange(len(example_rotations)), map_size)\n    rot = example_rotations[rot_idx]\n\n    # Insert 10% non-indexed points\n    non_indexed_points = np.random.choice(\n        np.arange(map_size), replace=False, size=int(map_size * 0.1)\n    )\n    rot[non_indexed_points] = 4 * np.pi\n    ci[non_indexed_points] = -1\n    fit[non_indexed_points] = 180.0\n\n    np.savetxt(\n        fname=f,\n        X=np.column_stack(\n            (rot[:, 0], rot[:, 1], rot[:, 2], x, y, iq, ci, phase_id, un, fit)\n            + (un,) * (n_unknown_columns - 1)\n        ),\n        fmt=(\n            ""%9.5f%10.5f%10.5f%13.5f%13.5f%9.1f%7.3f%3i%7i%8.3f""\n            + ""%10.5f"" * (n_unknown_columns - 1)\n            + "" ""\n        ),\n        header=ANGFILE_TSL_HEADER,\n        comments="""",\n    )\n\n    return f\n\n\n@pytest.fixture(\n    params=[\n        # Tuple with default values for four parameters: map_shape, step_sizes,\n        # phase_id, and rotations (see docstring below)\n        (\n            (7, 5),  # map_shape\n            (2.86, 2.86),  # step_sizes\n            np.ones(7 * 5, dtype=int),  # phase_id\n            np.array(\n                [[6.148271, 0.792205, 1.324879], [6.155951, 0.793078, 1.325229],]\n            ),  # rotations as rows of Euler angle triplets\n        )\n    ]\n)\ndef angfile_astar(tmpdir, request):\n    """"""Create a dummy NanoMegas ASTAR Index .ang file from input.\n\n    Parameters expected in `request`\n    --------------------------------\n    map_shape : tuple of ints\n        Map shape to create.\n    step_sizes : tuple of floats\n        Step sizes in x and y coordinates in nanometres.\n    phase_id : np.ndarray\n        Array of map size with phase IDs in header.\n    rotations : np.ndarray\n        A sample, smaller than the map size, of example rotations as\n        rows of Euler angle triplets.\n\n    """"""\n    f = tmpdir.join(""angfile_astar.ang"")\n\n    # Unpack parameters\n    (ny, nx), (dy, dx), phase_id, example_rotations = request.param\n\n    # File columns\n    map_size = ny * nx\n    x = np.tile(np.arange(nx) * dx, ny)\n    y = np.sort(np.tile(np.arange(ny) * dy, nx))\n    ind = np.random.uniform(low=0, high=100, size=map_size)\n    rel = np.round(np.random.random(map_size), decimals=2)  # [0, 1]\n    relx100 = (rel * 100).astype(int)\n\n    # Rotations\n    n_rotations = len(example_rotations)\n    if n_rotations == map_size:\n        rot = example_rotations\n    else:\n        # Sample as many rotations from `rotations` as `map_size`\n        rot_idx = np.random.choice(np.arange(len(example_rotations)), map_size)\n        rot = example_rotations[rot_idx]\n\n    np.savetxt(\n        fname=f,\n        X=np.column_stack(\n            (rot[:, 0], rot[:, 1], rot[:, 2], x, y, ind, rel, phase_id, relx100)\n        ),\n        fmt=""%8.6f%9.6f%9.6f%10.3f%10.3f%7.1f%7.3f%3i%8i"",\n        header=ANGFILE_ASTAR_HEADER,\n        comments="""",\n    )\n\n    return f\n\n\n@pytest.fixture(\n    params=[\n        # Tuple with default values for four parameters: map_shape, step_sizes,\n        # phase_id, and rotations (see docstring below)\n        (\n            (9, 7),  # map_shape\n            (1.5, 1.5),  # step_sizes\n            np.random.choice([1, 2], 9 * 7),  # phase_id\n            np.array(\n                [[6.148271, 0.792205, 1.324879], [6.155951, 0.793078, 1.325229],]\n            ),  # rotations as rows of Euler angle triplets\n        )\n    ]\n)\ndef angfile_emsoft(tmpdir, request):\n    """"""Create a dummy EMsoft .ang file from input.\n\n    Parameters expected in `request`\n    --------------------------------\n    map_shape : tuple of ints\n        Map shape to create.\n    step_sizes : tuple of floats\n        Step sizes in x and y coordinates in nanometres.\n    phase_id : np.ndarray\n        Array of map size with phase IDs in header.\n    rotations : np.ndarray\n        A sample, smaller than the map size, of example rotations as\n        rows of Euler angle triplets.\n\n    """"""\n    f = tmpdir.join(""angfile_emsoft.ang"")\n\n    # Unpack parameters\n    (ny, nx), (dy, dx), phase_id, example_rotations = request.param\n\n    # File columns\n    map_size = ny * nx\n    x = np.tile(np.arange(nx) * dx, ny)\n    y = np.sort(np.tile(np.arange(ny) * dy, nx))\n    iq = np.round(np.random.uniform(low=0, high=100, size=map_size), decimals=1)\n    dp = np.round(np.random.random(map_size), decimals=3)  # [0, 1]\n\n    # Rotations\n    rot_idx = np.random.choice(np.arange(len(example_rotations)), map_size)\n    rot = example_rotations[rot_idx]\n\n    np.savetxt(\n        fname=f,\n        X=np.column_stack((rot[:, 0], rot[:, 1], rot[:, 2], x, y, iq, dp, phase_id)),\n        fmt=""%.5f %.5f %.5f %.5f %.5f %.1f %.3f %i"",\n        header=ANGFILE_EMSOFT_HEADER,\n        comments="""",\n    )\n\n    return f\n\n\n@pytest.fixture(\n    params=[\n        # Tuple with default values for parameters: map_shape, step_sizes,\n        # rotations, n_top_matches, and refined (see docstring below)\n        (\n            (13, 3),  # map_shape\n            (1.5, 1.5),  # step_sizes\n            np.array(\n                [[6.148271, 0.792205, 1.324879], [6.155951, 0.793078, 1.325229],]\n            ),  # rotations as rows of Euler angle triplets\n            50,  # n_top_matches\n            True,  # refined\n        )\n    ]\n)\ndef temp_emsoft_h5ebsd_file(tmpdir, request):\n    """"""Create a dummy EMsoft h5ebsd .h5 file from input.\n\n    Parameters expected in `request`\n    --------------------------------\n    map_shape : tuple of ints\n        Map shape to create.\n    step_sizes : tuple of floats\n        Step sizes in x and y coordinates in nanometres.\n    rotations : np.ndarray\n        A sample, smaller than the map size, of example rotations as\n        rows of Euler angle triplets.\n    n_top_matches : int\n        Number of top matching orientations per data point kept.\n    refined : bool\n        Whether refined Euler angles and dot products are read.\n\n    """"""\n    f = File(tmpdir.join(""emsoft_h5ebsd_file.h5""), mode=""w"")\n\n    # Unpack parameters\n    map_shape, (dy, dx), example_rotations, n_top_matches, refined = request.param\n    ny, nx = map_shape\n    map_size = ny * nx\n\n    # Create groups used in reader\n    ebsd_group = f.create_group(""Scan 1/EBSD"")\n    data_group = ebsd_group.create_group(""Data"")\n    header_group = ebsd_group.create_group(""Header"")\n    phase_group = header_group.create_group(""Phase/1"")  # Always single phase\n\n    # Create `header_group` datasets used in reader\n    for name, data, dtype in zip(\n        [""nRows"", ""nColumns"", ""Step Y"", ""Step X""],\n        [ny, nx, dy, dx],\n        [np.int32, np.int32, np.float32, np.float32],\n    ):\n        header_group.create_dataset(name, data=np.array([data], dtype=dtype))\n\n    # Create `data_group` datasets, mostly quality metrics\n    data_group.create_dataset(""X Position"", data=np.tile(np.arange(nx) * dx, ny))\n    # Note that ""Y Position"" is wrongly written to their h5ebsd file by EMsoft\n    data_group.create_dataset(\n        ""Y Position"",\n        data=np.tile(np.arange(nx) * dx, ny),  # Wrong\n        #        data=np.sort(np.tile(np.arange(ny) * dy, nx)),  # Correct\n    )\n    for name, shape, dtype in [\n        (""AvDotProductMap"", map_shape, np.int32),\n        (""CI"", map_size, np.float32),\n        (""CIMap"", map_shape, np.int32),\n        (""IQ"", map_size, np.float32),\n        (""IQMap"", map_shape, np.int32),\n        (""ISM"", map_size, np.float32),\n        (""ISMap"", map_shape, np.int32),\n        (""KAM"", map_shape, np.float32),\n        (""OSM"", map_shape, np.float32),\n        (""Phase"", map_size, np.uint8),\n    ]:\n        data_group.create_dataset(name, data=np.zeros(shape, dtype=dtype))\n\n    # `data_group` with rotations\n    # Sample as many rotations from `rotations` as `map_size`\n    rot_idx = np.random.choice(np.arange(len(example_rotations)), map_size)\n    rot = example_rotations[rot_idx]\n    n_sampled_oris = 333227  # Cubic space group with Ncubochoric = 100\n    data_group.create_dataset(""FZcnt"", data=np.array([n_sampled_oris], dtype=np.int32))\n    data_group.create_dataset(\n        ""TopMatchIndices"",\n        data=np.vstack(\n            (np.random.choice(np.arange(n_sampled_oris), n_top_matches),) * map_size\n        ),\n        dtype=np.int32,\n    )\n    data_group.create_dataset(\n        ""TopDotProductList"",\n        data=np.vstack((np.random.random(size=n_top_matches),) * map_size),\n        dtype=np.float32,\n    )\n    data_group.create_dataset(\n        ""DictionaryEulerAngles"",\n        data=np.column_stack(\n            (np.random.uniform(low=0, high=2 * np.pi, size=n_sampled_oris),) * 3\n        ),\n        dtype=np.float32,\n    )\n\n    if refined:\n        data_group.create_dataset(""RefinedEulerAngles"", data=rot.astype(np.float32))\n        data_group.create_dataset(\n            ""RefinedDotProducts"", data=np.zeros(map_size, dtype=np.float32)\n        )\n\n    # Number of top matches kept\n    f.create_dataset(\n        ""NMLparameters/EBSDIndexingNameListType/nnk"",\n        data=np.array([n_top_matches], dtype=np.int32),\n    )\n\n    # `phase_group`\n    for name, data in [\n        (""Point Group"", ""Cubic (Oh) [m3m]""),\n        (""MaterialName"", ""austenite/austenite""),\n    ]:\n        phase_group.create_dataset(name, data=np.array([data], dtype=np.dtype(""S"")))\n\n    yield f\n    gc.collect()\n\n\n@pytest.fixture\ndef phase_list():\n    names = [""a"", ""b"", ""c""]\n    symmetry_names = [""m-3m"", ""432"", ""3""]\n    colors = [""r"", ""g"", ""b""]\n\n    return PhaseList(names=names, symmetries=symmetry_names, colors=colors)\n\n\n@pytest.fixture(\n    params=[\n        # Tuple with default values for parameters: map_shape, step_sizes, and\n        # n_rotations_per_point\n        (\n            (1, 4, 3),  # map_shape\n            (0, 1.5, 1.5),  # step_sizes\n            1,  # rotations_per_point\n        ),\n    ],\n)\ndef crystal_map_input(request, rotations):\n    # Unpack parameters\n    (nz, ny, nx), (dz, dy, dx), rotations_per_point = request.param\n    map_size = nz * ny * nx\n\n    d = {""x"": None, ""y"": None, ""z"": None, ""rotations"": None}\n    if nx > 1:\n        d[""x""] = np.tile(np.arange(nx) * dx, ny * nz)\n    if ny > 1:\n        d[""y""] = np.tile(np.sort(np.tile(np.arange(ny) * dy, nx)), nz)\n    if nz > 1:\n        d[""z""] = np.array([np.ones(ny * nx) * i * dz for i in range(nz)]).flatten()\n\n    rot_idx = np.random.choice(\n        np.arange(rotations.size), map_size * rotations_per_point\n    )\n\n    data_shape = (map_size,)\n    if rotations_per_point > 1:\n        data_shape += (rotations_per_point,)\n\n    d[""rotations""] = rotations[rot_idx].reshape(*data_shape)\n\n    return d\n\n\n@pytest.fixture\ndef crystal_map(crystal_map_input):\n    return CrystalMap(**crystal_map_input)\n'"
orix/tests/test_axangle.py,17,"b'import pytest\nimport numpy as np\nimport itertools\n\nfrom orix.vector.neo_euler import AxAngle\nfrom orix.vector import Vector3d\nfrom orix.quaternion.rotation import Rotation\n\n\naxes = [\n    (1, 0, 0),\n    (1, 1, 0),\n    (2, -1, 0),\n    (0, 2, 1),\n    (-1, -1, -1),\n]\n\nangles = [\n    -2 * np.pi,\n    -5 * np.pi / 6,\n    -np.pi / 3,\n    0,\n    np.pi / 12,\n    np.pi / 3,\n    3 * np.pi / 4,\n    2 * np.pi,\n    np.pi / 7,\n]\n\naxangles = [np.array(angle) * Vector3d(axis).unit for axis in axes for angle in angles]\naxangles += [\n    np.array(angle) * Vector3d(axis).unit\n    for axis in itertools.combinations_with_replacement(axes, 2)\n    for angle in itertools.combinations_with_replacement(angles, 2)\n]\n\n\n@pytest.fixture(params=axangles[:100])\ndef axangle(request):\n    return AxAngle(request.param.data)\n\n\ndef test_angle(axangle):\n    assert np.allclose(axangle.angle.data, axangle.norm.data)\n\n\ndef test_axis(axangle):\n    assert axangle.axis.shape == axangle.shape\n\n\n@pytest.mark.parametrize(\n    ""axis, angle, expected_axis"",\n    [\n        ((2, 1, 1), np.pi / 4, (0.816496, 0.408248, 0.408248)),\n        (Vector3d((2, 0, 0)), -2 * np.pi, (-1, 0, 0)),\n    ],\n)\ndef test_from_axes_angles(axis, angle, expected_axis):\n    ax = AxAngle.from_axes_angles(axis, angle)\n    assert np.allclose(ax.axis.data, expected_axis)\n    assert np.allclose(ax.angle.data, abs(angle))\n\n\n@pytest.mark.parametrize(\n    ""rotation, expected"",\n    [(Rotation([1, 0, 0, 0]), [0, 0, 0]), (Rotation([0, 1, 0, 0]), [np.pi, 0, 0])],\n)\ndef test_from_rotation(rotation, expected):\n    axangle = AxAngle.from_rotation(rotation)\n    assert np.allclose(axangle.data, expected)\n'"
orix/tests/test_crystal_map.py,64,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\nimport pytest\n\nfrom orix.crystal_map import CrystalMap\nfrom orix.crystal_map.phase_list import Phase, PhaseList\nfrom orix.quaternion.orientation import Orientation\nfrom orix.quaternion.rotation import Rotation\nfrom orix.quaternion.symmetry import C2, C3, C4, O\n\n# Note that many parts of the CrystalMap() class are tested while testing IO and the\n# Phase() and PhaseList() classes\n\n\nclass TestCrystalMapInit:\n    def test_minimal_init(self, rotations):\n        map_size = 2\n\n        assert isinstance(rotations, Rotation)\n\n        cm = CrystalMap(rotations=rotations)\n\n        assert np.allclose(cm.x, np.arange(map_size))\n        assert cm.size == map_size\n        assert cm.shape == (map_size,)\n        assert cm.ndim\n        assert np.allclose(cm.id, np.arange(map_size))\n        assert isinstance(cm.rotations, Rotation)\n        assert np.allclose(cm.rotations.data, rotations.data)\n\n    @pytest.mark.parametrize(""rotation_format"", [""array"", ""list""])\n    def test_init_with_invalid_rotations(self, rotations, rotation_format):\n        with pytest.raises(ValueError):\n            if rotation_format == ""array"":\n                _ = CrystalMap(rotations=rotations.data)\n            else:  # rotation_format == ""list""\n                _ = CrystalMap(rotations=list(rotations.data))\n\n    @pytest.mark.parametrize(\n        (\n            ""crystal_map_input, expected_shape, expected_size, expected_step_sizes, ""\n            ""expected_rotations_per_point""\n        ),\n        [\n            (\n                ((1, 5, 5), (0, 1.5, 1.5), 3),\n                (5, 5),\n                25,\n                {""z"": 0, ""y"": 1.5, ""x"": 1.5},\n                3,\n            ),\n            (((1, 1, 10), (0, 0.1, 0.1), 1), (10,), 10, {""z"": 0, ""y"": 0, ""x"": 0.1}, 1),\n            (((1, 10, 1), (0, 1e-3, 0), 2), (10,), 10, {""z"": 0, ""y"": 1e-3, ""x"": 0}, 2,),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_init_with_different_coordinate_arrays(\n        self,\n        crystal_map_input,\n        expected_shape,\n        expected_size,\n        expected_step_sizes,\n        expected_rotations_per_point,\n    ):\n        cm = CrystalMap(**crystal_map_input)\n        coordinate_arrays = [\n            crystal_map_input[""z""],\n            crystal_map_input[""y""],\n            crystal_map_input[""x""],\n        ]\n\n        assert cm.shape == expected_shape\n        assert cm.size == expected_size\n        assert cm._step_sizes == expected_step_sizes\n        assert cm.rotations_per_point == expected_rotations_per_point\n\n        for actual_coords, expected_coords, expected_step_size in zip(\n            cm._coordinates.values(), coordinate_arrays, expected_step_sizes.values()\n        ):\n            print(actual_coords, expected_coords)\n            if expected_coords is None:\n                assert actual_coords is None\n            else:\n                assert np.allclose(actual_coords, expected_coords)\n\n    def test_init_map_with_props(self, crystal_map_input):\n        x = crystal_map_input[""x""]\n        props = {""iq"": np.arange(x.size)}\n        cm = CrystalMap(prop=props, **crystal_map_input)\n\n        assert cm.prop == props\n        assert np.allclose(cm.prop.id, cm.id)\n        assert np.allclose(cm.prop.is_in_data, cm.is_in_data)\n\n    @pytest.mark.parametrize(""unique_phase_ids"", [[0, 1], [1, -1]])\n    def test_init_with_phase_id(self, crystal_map_input, unique_phase_ids):\n        x = crystal_map_input[""x""]\n\n        # Create phase ID array, ensuring all are present\n        phase_id = np.random.choice(unique_phase_ids, x.size)\n        for i, unique_id in enumerate(unique_phase_ids):\n            phase_id[i] = unique_id\n\n        cm = CrystalMap(phase_id=phase_id, **crystal_map_input)\n\n        assert np.allclose(cm.phase_id, phase_id)\n        # Test all_indexed\n        if -1 in unique_phase_ids:\n            assert not cm.all_indexed\n            assert -1 in cm.phases.phase_ids\n        else:\n            assert cm.all_indexed\n            assert -1 not in cm.phases.phase_ids\n\n    def test_init_with_symmetry_list(self, crystal_map_input):\n        symmetries = [C2, C3]\n        cm = CrystalMap(symmetry=symmetries, **crystal_map_input)\n        assert cm.phases.symmetries == symmetries\n\n    def test_init_with_single_symmetry(self, crystal_map_input):\n        symmetry = O\n        cm = CrystalMap(symmetry=symmetry, **crystal_map_input)\n        assert cm.phases.symmetries[0] == symmetry\n\n\nclass TestCrystalMapGetItem:\n    @pytest.mark.parametrize(\n        ""crystal_map_input, slice_tuple, expected_shape"",\n        [\n            (((5, 5, 5), (1, 1, 1), 1), slice(None, None, None), (5, 5, 5)),\n            (\n                ((5, 5, 5), (1, 1, 1), 1),\n                (slice(1, 2, None), slice(None, None, None)),\n                (1, 5, 5),\n            ),\n            (\n                ((2, 5, 5), (1, 1, 1), 1),\n                (slice(0, 2, None), slice(None, None, None), slice(1, 4, None)),\n                (2, 5, 3),\n            ),\n            (\n                ((3, 10, 10), (1, 0.5, 0.1), 2),\n                (1, slice(5, 10, None), slice(None, None, None)),\n                (1, 5, 10),\n            ),\n            (\n                ((3, 10, 10), (1, 0.5, 0.1), 2),\n                (slice(None, 10, None), slice(2, 4, None), slice(None, 3, None)),\n                (3, 2, 3),\n            ),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_by_slice(self, crystal_map_input, slice_tuple, expected_shape):\n        cm = CrystalMap(**crystal_map_input)\n\n        cm2 = cm[slice_tuple]\n        assert cm2.shape == expected_shape\n\n    def test_get_by_phase_name(self, crystal_map_input, phase_list):\n        x = crystal_map_input[""x""]\n\n        # Create phase ID array, ensuring all are present\n        phase_ids = np.random.choice(phase_list.phase_ids, x.size)\n        for i, unique_id in enumerate(phase_list.phase_ids):\n            phase_ids[i] = unique_id\n\n        # Get number of points with each phase ID\n        n_points_per_phase = {}\n        for phase_i, phase in phase_list:\n            n_points_per_phase[phase.name] = len(np.where(phase_ids == phase_i)[0])\n\n        cm = CrystalMap(phase_id=phase_ids, **crystal_map_input)\n        cm.phases = phase_list\n\n        for (_, phase), (expected_phase_name, n_points) in zip(\n            phase_list, n_points_per_phase.items()\n        ):\n            cm2 = cm[phase.name]\n\n            assert cm2.size == n_points\n            assert cm2.phases_in_data.names == [expected_phase_name]\n\n    def test_get_by_indexed_not_indexed(self, crystal_map):\n        cm = crystal_map\n\n        # Set some points to not_indexed\n        cm[2:4].phase_id = -1\n\n        indexed = cm[""indexed""]\n        not_indexed = cm[""not_indexed""]\n\n        assert indexed.size + not_indexed.size == cm.size\n        assert np.allclose(np.unique(not_indexed.phase_id), np.array([-1]))\n        assert np.allclose(np.unique(indexed.phase_id), np.array([0]))\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((1, 4, 3), (1, 1, 1), 1)],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_by_condition(self, crystal_map_input):\n        cm = CrystalMap(**crystal_map_input)\n\n        cm.prop[""dp""] = np.arange(cm.size)\n\n        n_points = 2\n        assert cm.shape == (4, 3)  # Test code assumption\n        cm[0, :n_points].dp = -1\n        cm2 = cm[cm.dp < 0]\n\n        assert cm2.size == n_points\n        assert np.sum(cm2.dp) == -n_points\n\n    def test_get_by_multiple_conditions(self, crystal_map, phase_list):\n        cm = crystal_map\n\n        assert phase_list.phase_ids == [0, 1, 2]  # Test code assumption\n\n        cm.phases = phase_list\n        cm.prop[""dp""] = np.arange(cm.size)\n        a_phase_id = phase_list.phase_ids[0]\n        cm[cm.dp > 3].phase_id = a_phase_id\n\n        condition1 = cm.dp > 3\n        condition2 = cm.phase_id == a_phase_id\n        cm2 = cm[condition1 & condition2]\n        assert cm2.size == np.sum(condition1 * condition2)\n        assert np.allclose(cm2.is_in_data, condition1 * condition2)\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, integer_slices, expected_id, raises"",\n        [\n            (((3, 4, 4), (1, 1, 1), 1), (0, 0, 2), 2, False),\n            (((3, 4, 4), (1, 1, 1), 3), (0, 2, 0), 8, False),\n            (((3, 4, 4), (1, 1, 1), 3), (2, 0, 0), 32, False),\n            (((1, 4, 1), (0, 1, 0), 2), 1, 1, False),\n            (((3, 4, 4), (1, 1, 1), 3), (1000, 0, 0), None, True),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_by_integer(\n        self, crystal_map_input, integer_slices, expected_id, raises\n    ):\n        # This also tests `phase_id`\n        cm = CrystalMap(**crystal_map_input)\n        if raises:\n            with pytest.raises(IndexError, match=f"".* is out of bounds for""):\n                _ = cm[integer_slices]\n        else:\n            point = cm[integer_slices]\n            expected_point = cm[cm.id == expected_id]\n\n            assert np.allclose(point.rotations.data, expected_point.rotations.data)\n            assert point._coordinates == expected_point._coordinates\n\n\nclass TestCrystalMapSetAttributes:\n    def test_set_scan_unit(self, crystal_map):\n        cm = crystal_map\n        assert cm.scan_unit == ""px""\n\n        micron = ""um""\n        cm.scan_unit = micron\n        assert cm.scan_unit == micron\n\n    @pytest.mark.parametrize(""set_phase_id"", [1, -1])\n    def test_set_phase_ids(self, crystal_map, set_phase_id):\n        cm = crystal_map\n\n        phase_ids = cm.phase_id\n        condition = cm.x > 1.5\n        cm[condition].phase_id = set_phase_id\n        phase_ids[condition] = set_phase_id\n\n        assert np.allclose(cm.phase_id, phase_ids)\n\n        if set_phase_id == -1:\n            assert ""not_indexed"" in cm.phases.names\n\n    def test_set_phase_ids_raises(self, crystal_map):\n        with pytest.raises(ValueError, match=""NumPy boolean array indexing assignment""):\n            crystal_map[1, 1].phase_id = -1 * np.ones(10)\n\n    @pytest.mark.parametrize(""set_phase_id, index_error"", [(-1, False), (1, True)])\n    def test_set_phase_id_with_unknown_id(self, crystal_map, set_phase_id, index_error):\n        cm = crystal_map\n\n        condition = cm.x > 1.5\n        phase_ids = cm.phases.phase_ids  # Get before adding a new phase\n\n        if index_error:\n            with pytest.raises(IndexError, match=""list index out of range""):\n                # `set_phase_id` ID is not in `self.phases.phase_ids`\n                cm[condition].phase_id = set_phase_id\n                _ = cm.__repr__()\n\n            # Add unknown ID to phase list to fix `self.__repr__()`\n            cm.phases[""a""] = 432  # Add phase with ID 1\n        else:\n            cm[condition].phase_id = set_phase_id\n\n        _ = cm.__repr__()\n\n        new_phase_ids = phase_ids + [set_phase_id]\n        new_phase_ids.sort()\n        assert cm.phases.phase_ids == new_phase_ids\n\n    def test_phases_in_data(self, crystal_map, phase_list):\n        cm = crystal_map\n        cm.phases = phase_list\n\n        assert cm.phases_in_data.names != cm.phases.names\n\n        ids_not_in_data = np.setdiff1d(\n            np.array(cm.phases.phase_ids), np.array(cm.phases_in_data.phase_ids)\n        )\n        condition1 = cm.x > 1.5\n        condition2 = cm.y > 1.5\n        for new_id, condition in zip(ids_not_in_data, [condition1, condition2]):\n            cm[condition].phase_id = new_id\n\n        assert cm.phases_in_data.names == cm.phases.names\n\n\nclass TestCrystalMapOrientations:\n    def test_orientations(self, crystal_map_input, phase_list):\n        x = crystal_map_input[""x""]\n\n        # Create phase ID array, ensuring all are present\n        phase_ids = np.random.choice(phase_list.phase_ids, x.size)\n        for i, unique_id in enumerate(phase_list.phase_ids):\n            phase_ids[i] = unique_id\n\n        cm = CrystalMap(phase_id=phase_ids, **crystal_map_input)\n\n        # Set phases and make sure all are in data\n        cm.phases = phase_list\n        assert cm.phases_in_data.names == cm.phases.names\n\n        # Ensure all points have a valid orientation\n        orientations_size = 0\n        for phase_id in phase_list.phase_ids:\n            o = cm[cm.phase_id == phase_id].orientations\n            assert isinstance(o, Orientation)\n            orientations_size += o.size\n\n        assert orientations_size == cm.size\n\n    @pytest.mark.parametrize(\n        ""symmetry, rotation, expected_orientation"",\n        [\n            (C2, [(0.6088, 0, 0, 0.7934)], [(-0.7934, 0, 0, 0.6088)]),\n            (C3, [(0.6088, 0, 0, 0.7934)], [(-0.9914, 0, 0, 0.1305)]),\n            (C4, [(0.6088, 0, 0, 0.7934)], [(-0.9914, 0, 0, -0.1305)]),\n            (O, [(0.6088, 0, 0, 0.7934)], [(-0.9914, 0, 0, -0.1305)]),\n        ],\n    )\n    def test_orientations_symmetry(self, symmetry, rotation, expected_orientation):\n        r = Rotation(rotation)\n        cm = CrystalMap(rotations=r, phase_id=np.array([0]))\n        cm.phases = PhaseList(Phase(""a"", symmetry=symmetry))\n\n        o = cm.orientations\n\n        assert np.allclose(\n            o.data, Orientation(r).set_symmetry(symmetry).data, atol=1e-3\n        )\n        assert np.allclose(o.data, expected_orientation, atol=1e-3)\n\n    def test_orientations_none_symmetry_raises(self, crystal_map_input):\n        cm = CrystalMap(**crystal_map_input)\n\n        assert cm.phases.symmetries == [None]\n\n        with pytest.raises(TypeError, match=""\'NoneType\' object is not iterable""):\n            _ = cm.orientations\n\n    def test_orientations_multiple_phases_raises(self, crystal_map, phase_list):\n        cm = crystal_map\n\n        cm.phases = phase_list\n        cm[cm.x > 1.5].phase_id = 2\n\n        with pytest.raises(ValueError, match=""Data has the phases ""):\n            _ = cm.orientations\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, rotations_per_point"",\n        [(((1, 5, 5), (0, 1.5, 1.5), 3), 3)],\n        indirect=[""crystal_map_input""],\n    )\n    def test_multiple_orientations_per_point(\n        self, crystal_map_input, rotations_per_point\n    ):\n        cm = CrystalMap(**crystal_map_input)\n\n        assert cm.phases.phase_ids == [0]  # Test code assumption\n        cm.phases[0].symmetry = ""m-3m""\n\n        assert cm.rotations_per_point == rotations_per_point\n        assert cm.orientations.size == cm.size\n\n\nclass TestCrystalMapProp:\n    def test_add_new_crystal_map_property(self, crystal_map):\n        cm = crystal_map\n\n        prop_name = ""iq""\n        prop_values = np.arange(cm.size)\n        cm.prop[prop_name] = prop_values\n\n        assert np.allclose(cm.prop.get(prop_name), prop_values)\n        assert np.allclose(cm.prop[prop_name], prop_values)\n\n    def test_overwrite_crystal_map_property_values(self, crystal_map):\n        cm = crystal_map\n\n        prop_name = ""iq""\n        prop_values = np.arange(cm.size)\n        cm.prop[prop_name] = prop_values\n\n        assert np.allclose(cm.prop[prop_name], prop_values)\n\n        new_prop_value = -1\n        cm.__setattr__(prop_name, new_prop_value)\n\n        assert np.allclose(cm.prop[prop_name], np.ones(cm.size) * new_prop_value)\n\n\nclass TestCrystalMapMasking:\n    def test_getitem_with_masking(self, crystal_map_input):\n        x = crystal_map_input[""x""]\n        props = {""iq"": np.arange(x.size)}\n        cm = CrystalMap(prop=props, **crystal_map_input)\n\n        cm2 = cm[cm.iq > 1]\n\n        assert np.allclose(cm2.prop.id, cm2.id)\n        assert np.allclose(cm2.prop.is_in_data, cm2.is_in_data)\n\n\nclass TestCrystalMapGetMapData:\n    @pytest.mark.parametrize(\n        ""crystal_map_input, to_get, expected_array"",\n        [\n            (\n                ((1, 4, 4), (0, 0.5, 1), 2),\n                ""x"",\n                np.array([0, 1, 2, 3] * 4).reshape((4, 4)),\n            ),\n            (\n                ((1, 4, 4), (0, 0.5, 1), 2),\n                ""y"",\n                np.array([[i * 0.5] * 4 for i in range(4)]),  # [0, 0, 0, 0, 0.5, ...]\n            ),\n            (\n                ((2, 4, 4), (0.28, 0.5, 1), 2),\n                ""z"",\n                np.stack((np.zeros((4, 4)), np.ones((4, 4)) * 0.28), axis=0),\n            ),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_coordinate_array(self, crystal_map_input, to_get, expected_array):\n        cm = CrystalMap(**crystal_map_input)\n\n        # Get via string\n        data_via_string = cm.get_map_data(to_get)\n        assert np.allclose(data_via_string, expected_array)\n\n        # Get via numpy array\n        if to_get == ""x"":\n            data_via_array = cm.get_map_data(cm.x)\n        elif to_get == ""y"":\n            data_via_array = cm.get_map_data(cm.y)\n        else:  # to_get == ""z""\n            data_via_array = cm.get_map_data(cm.z)\n        assert np.allclose(data_via_array, expected_array)\n\n        # Make sure they are the same\n        assert np.allclose(data_via_array, data_via_string)\n\n    def test_get_property_array(self, crystal_map):\n        cm = crystal_map\n\n        expected_array = np.arange(cm.size)\n        prop_name = ""iq""\n        cm.prop[prop_name] = expected_array\n\n        iq = cm.get_map_data(prop_name)\n\n        assert np.allclose(iq, expected_array.reshape(cm.shape))\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((1, 3, 2), (0, 1, 1), 3), ((3, 1, 2), (1, 1, 1), 1)],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_orientations_array(self, crystal_map_input, phase_list):\n        cm = CrystalMap(**crystal_map_input)\n\n        cm[:2, 0].phase_id = 1\n        # Test code assumption\n        id1 = 0\n        id2 = 1\n        assert np.allclose(np.unique(cm.phase_id), np.array([id1, id2]))\n        cm.phases = phase_list\n\n        # Get all with string\n        o = cm.get_map_data(""orientations"")\n\n        # Get per phase with string\n        cm1 = cm[cm.phase_id == id1]\n        cm2 = cm[cm.phase_id == id2]\n        o1 = cm1.get_map_data(""orientations"")\n        o2 = cm2.get_map_data(""orientations"")\n\n        expected_o1 = cm1.orientations.to_euler()\n        expected_shape = expected_o1.shape\n        assert np.allclose(\n            o1[~np.isnan(o1)].reshape(expected_shape), expected_o1, atol=1e-3\n        )\n\n        expected_o2 = cm2.orientations.to_euler()\n        expected_shape = expected_o2.shape\n        assert np.allclose(\n            o2[~np.isnan(o2)].reshape(expected_shape), expected_o2, atol=1e-3\n        )\n\n        # Do calculations ""manually""\n        data_shape = (cm.size, 3)\n        array = np.zeros(data_shape)\n\n        if cm.rotations_per_point > 1:\n            rotations = cm.rotations[:, 0]\n        else:\n            rotations = cm.rotations\n\n        for i, phase in cm.phases_in_data:\n            phase_mask = cm._phase_id == i\n            phase_mask_in_data = cm.phase_id == i\n            array[phase_mask] = (\n                Orientation(rotations[phase_mask_in_data])\n                .set_symmetry(phase.symmetry)\n                .to_euler()\n            )\n\n        assert np.allclose(o, array.reshape(o.shape), atol=1e-3)\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((1, 2, 2), (0, 1, 1), 2), ((3, 2, 2), (1, 1, 1), 1),],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_rotations_array(self, crystal_map_input):\n        cm = CrystalMap(**crystal_map_input)\n\n        # Get with string\n        r = cm.get_map_data(""rotations"")\n\n        new_shape = cm.rotations_shape + (3,)\n        expected_array = cm.rotations.to_euler().reshape(*new_shape)\n        assert np.allclose(r, expected_array, atol=1e-3)\n\n        # Get with array (RGB)\n        new_shape2 = (cm.size, 3)\n        r2 = cm.get_map_data(r.reshape(*new_shape2))\n        assert np.allclose(r2, expected_array, atol=1e-3)\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((3, 9, 3), (1, 1.5, 1.5), 2), ((2, 10, 5), (1, 0.1, 0.1), 3),],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_phase_id_array_from_3d_data(self, crystal_map_input):\n        cm = CrystalMap(**crystal_map_input)\n        _ = cm.get_map_data(cm.phase_id)\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, to_get"",\n        [\n            (((1, 4, 3), (1, 1, 1), 1), ""z""),\n            (((4, 1, 3), (1, 1, 1), 1), ""y""),\n            (((4, 3, 1), (1, 1, 1), 1), ""x""),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_get_unknown_string_raises(self, crystal_map_input, to_get):\n        cm = CrystalMap(**crystal_map_input)\n        with pytest.raises(ValueError, match=f""{to_get} is None.""):\n            _ = cm.get_map_data(to_get)\n\n\nclass TestCrystalMapRepresentation:\n    def test_representation(self, crystal_map, phase_list):\n        cm = crystal_map\n        cm.phases = phase_list\n        cm.scan_unit = ""nm""\n\n        # Test code assumptions\n        assert phase_list.phase_ids == [0, 1, 2]\n        assert cm.shape == (4, 3)\n\n        cm[0, 1].phase_id = phase_list.phase_ids[1]\n        cm[1, 1].phase_id = phase_list.phase_ids[2]\n\n        cm.prop[""iq""] = np.arange(cm.size)\n\n        assert cm[cm.phase_id == -1].__repr__() == ""No data.""\n\n        print(cm.__repr__())\n\n        assert cm.__repr__() == (\n            ""Phase   Orientations   Name  Symmetry   Color\\n""\n            ""    0     10 (83.3%)      a      m-3m       r\\n""\n            ""    1       1 (8.3%)      b       432       g\\n""\n            ""    2       1 (8.3%)      c         3       b\\n""\n            ""Properties: iq\\n""\n            ""Scan unit: nm""\n        )\n\n\nclass TestCrystalMapCopying:\n    def test_shallowcopy_crystal_map(self, crystal_map_input):\n        map_size = crystal_map_input[""x""].size\n        phase_ids = np.arange(map_size)\n\n        cm = CrystalMap(phase_id=phase_ids, **crystal_map_input)\n\n        cm2 = cm[:]  # Everything except `is_in_data` is shallow copied\n        cm3 = cm  # These are the same objects (of course)\n\n        assert np.may_share_memory(cm2._phase_id, cm._phase_id)\n        assert np.may_share_memory(cm2._rotations.data, cm._rotations.data)\n\n        cm[3, 0].phase_id = -2\n        assert np.allclose(cm2.phase_id, cm.phase_id)\n        assert np.allclose(cm3.phase_id, cm.phase_id)\n\n        # The user is strictly speaking only supposed to change this via __getitem__()\n        cm.is_in_data[2] = False\n        assert cm2.size != cm.size\n        assert cm3.size == cm.size\n        assert np.allclose(cm2.is_in_data, cm.is_in_data) is False\n        assert np.may_share_memory(cm3.is_in_data, cm.is_in_data)\n\n    def test_deepcopy_crystal_map(self, crystal_map_input):\n        map_size = crystal_map_input[""x""].size\n        phase_ids = np.arange(map_size)\n\n        cm = CrystalMap(phase_id=phase_ids, **crystal_map_input)\n\n        cm2 = cm.deepcopy()\n\n        cm[3, 0].phase_id = -2\n        assert np.allclose(cm2.phase_id, cm.phase_id) is False\n        assert np.may_share_memory(cm2._phase_id, cm._phase_id) is False\n\n\nclass TestCrystalMapShape:\n    @pytest.mark.parametrize(\n        ""crystal_map_input, expected_slices"",\n        [\n            (((1, 10, 30), (0, 0.1, 0.1), 2), (slice(0, 10, None), slice(0, 30, None))),\n            (\n                ((2, 13, 27), (0.3, 0.7, 0.9), 3),\n                (slice(0, 2, None), slice(0, 13, None), slice(0, 27, None)),\n            ),\n            (((1, 4, 3), (0, 1.5, 1.5), 1), (slice(0, 4, None), slice(0, 3, None))),\n            # Testing rounding 15 / 2 = 7.5 and 45 / 2 = 22.5\n            (((1, 15, 45), (0, 2, 2), 1), (slice(0, 15, None), slice(0, 45, None))),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_data_slices_from_coordinates(self, crystal_map_input, expected_slices):\n        cm = CrystalMap(**crystal_map_input)\n        assert cm._data_slices_from_coordinates() == expected_slices\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, slices, expected_size, expected_shape, expected_slices"",\n        [\n            # Slice 3D data with an index in all axes\n            (\n                ((2, 3, 4), (1, 1, 1), 1),\n                (1, 2, 3),\n                1,\n                (1, 1, 1),\n                (slice(1, 2, None), slice(2, 3, None), slice(3, 4, None)),\n            ),\n            # Slice 3D data with indices in only two axes\n            (\n                ((2, 3, 4), (0.1, 0.1, 0.1), 1),\n                (1, 2),\n                4,\n                (1, 1, 4),\n                (slice(1, 2, None), slice(2, 3, None), slice(0, 4, None)),\n            ),\n            # Slice 3D data with indices in only two axes (same as above, to make sure\n            # slice determination is unaffected by step size)\n            (\n                ((2, 3, 4), (1, 1, 1), 1),\n                (1, 2),\n                4,\n                (1, 1, 4),\n                (slice(1, 2, None), slice(2, 3, None), slice(0, 4, None)),\n            ),\n            # Slice 3D data with an index in only one axis\n            (\n                ((2, 3, 4), (0.1, 0.1, 0.1), 1),\n                (1,),\n                12,\n                (1, 3, 4),\n                (slice(1, 2, None), slice(0, 3, None), slice(0, 4, None)),\n            ),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_data_slice_from_coordinates_masked(\n        self, crystal_map_input, slices, expected_size, expected_shape, expected_slices\n    ):\n        cm = CrystalMap(**crystal_map_input)\n\n        # Mask data\n        cm2 = cm[slices]\n\n        assert cm2.size == expected_size\n        assert cm2.shape == expected_shape\n        assert cm2._data_slices_from_coordinates() == expected_slices\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, expected_shape"",\n        [\n            (((1, 10, 30), (0, 0.1, 0.1), 2), (10, 30)),\n            (((2, 13, 27), (0.3, 0.7, 0.9), 3), (2, 13, 27)),\n            (((1, 4, 3), (0, 1.5, 1.5), 1), (4, 3)),\n            (((1, 15, 45), (0, 2, 2), 2), (15, 45)),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_shape_from_coordinates(self, crystal_map_input, expected_shape):\n        cm = CrystalMap(**crystal_map_input)\n        assert cm.shape == expected_shape\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, expected_shape"",\n        [\n            (((1, 10, 30), (0, 0.1, 0.1), 2), (10, 30, 2)),\n            (((2, 13, 27), (0.3, 0.7, 0.9), 3), (2, 13, 27, 3)),\n            (((1, 4, 3), (0, 1.5, 1.5), 5), (4, 3, 5)),\n            (((1, 15, 45), (0, 2, 2), 2), (15, 45, 2)),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_rotation_shape(self, crystal_map_input, expected_shape):\n        cm = CrystalMap(**crystal_map_input)\n        assert cm.rotations_shape == expected_shape\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, expected_coordinate_axes"",\n        [\n            (((1, 10, 30), (0, 0.1, 0.1), 1), {0: ""y"", 1: ""x""}),\n            (((2, 13, 27), (0.3, 0.7, 0.9), 1), {0: ""z"", 1: ""y"", 2: ""x""}),\n            (((1, 13, 27), (0, 1.5, 1.5), 1), {0: ""y"", 1: ""x""}),\n            (((2, 13, 1), (1, 2, 1), 2), {0: ""z"", 1: ""y""}),\n            (((2, 1, 13), (1, 0, 2), 1), {0: ""z"", 1: ""x""}),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_coordinate_axes(self, crystal_map_input, expected_coordinate_axes):\n        cm = CrystalMap(**crystal_map_input)\n        assert cm._coordinate_axes == expected_coordinate_axes\n'"
orix/tests/test_crystal_map_plot.py,29,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport copy\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport pytest\n\nfrom orix import plot  # Needed for projection=""plot_map""? Might be imported via below\nfrom orix.plot import CrystalMapPlot\nfrom orix.plot.crystal_map_plot import convert_unit\nfrom orix.crystal_map import CrystalMap\nfrom orix.crystal_map.phase_list import PhaseList\n\nplt.rcParams[""backend""] = ""TkAgg""\n\n# Warning raised when plot width is too small (this too is tested)\nSCALEBAR_WARNING = ""Scalebar width .* is not an integer.""\n\n# Can be easily changed in the future\nPLOT_MAP = ""plot_map""\n\n\nclass TestCrystalMapPlot:\n    @pytest.mark.parametrize(\n        ""crystal_map_input, expected_data_shape"",\n        [\n            (((1, 10, 20), (0, 1.5, 1.5), 1), (10, 20, 3)),\n            (((1, 4, 3), (0, 0.1, 0.1), 1), (4, 3, 3)),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_plot_phase(self, crystal_map_input, phase_list, expected_data_shape):\n        cm = CrystalMap(**crystal_map_input)\n\n        assert np.unique(cm.phase_id) == np.array([0])  # Test code assumption\n        assert phase_list.phase_ids == [0, 1, 2]\n        cm.phases = phase_list\n        cm[0, 0].phase_id = 0\n        cm[1, 1].phase_id = 2\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(cm)\n\n        # Expected image data\n        phase_id = cm.get_map_data(""phase_id"")\n        unique_phase_ids = np.unique(phase_id[~np.isnan(phase_id)])\n        expected_data = np.ones(phase_id.shape + (3,))\n        for i, color in zip(unique_phase_ids, cm.phases_in_data.colors_rgb):\n            mask = phase_id == int(i)\n            expected_data[mask] = expected_data[mask] * color\n\n        image_data = im.get_array()\n        assert np.allclose(image_data.shape, expected_data_shape)\n        assert np.allclose(image_data, expected_data)\n\n        plt.close(""all"")\n\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_plot_property(self, crystal_map):\n        cm = crystal_map\n\n        prop_name = ""iq""\n        prop_data = np.arange(cm.size)\n        cm.prop[prop_name] = prop_data\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(cm, cm.iq)\n\n        assert np.allclose(im.get_array(), prop_data.reshape(cm.shape))\n\n        plt.close(""all"")\n\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_plot_scalar(self, crystal_map):\n        cm = crystal_map\n\n        angles = cm.rotations.angle.data\n\n        fig1 = plt.figure()\n        ax1 = fig1.add_subplot(projection=PLOT_MAP)\n        # Test use of `vmax` as well\n        im1 = ax1.plot_map(cm, angles, vmax=angles.max() - 10)\n\n        assert np.allclose(im1.get_array(), angles.reshape(cm.shape), atol=1e-3)\n\n        fig2 = plt.figure()\n        ax2 = fig2.add_subplot(projection=PLOT_MAP)\n        im2 = ax2.plot_map(cm, cm.rotations.angle)\n\n        assert np.allclose(im2.get_array(), angles.reshape(cm.shape), atol=1e-3)\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((2, 9, 3), (1, 1.5, 1.5), 1), ((2, 10, 5), (1, 0.1, 0.1), 1)],\n        indirect=[""crystal_map_input""],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_plot_masked_phase(self, crystal_map_input, phase_list):\n        cm = CrystalMap(**crystal_map_input)\n\n        # Test code assumptions\n        assert np.unique(cm.phase_id) == np.array([0])\n        assert phase_list.phase_ids == [0, 1, 2]\n        assert cm.ndim == 3\n\n        cm.phases = phase_list\n\n        cm[0, :2, :1].phase_id = 1\n        cm[1, 2:4, :1].phase_id = 2\n        assert np.allclose(np.unique(cm.phase_id), np.array([0, 1, 2]))\n\n        # One phase plot per masked map\n        for i, phase in phase_list:\n            fig = plt.figure()\n            ax = fig.add_subplot(projection=PLOT_MAP)\n            _ = ax.plot_map(cm[cm.phase_id == i])\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input"",\n        [((2, 9, 6), (1, 1.5, 1.5), 2), ((2, 10, 5), (1, 0.1, 0.1), 1)],\n        indirect=[""crystal_map_input""],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_plot_masked_scalar(self, crystal_map_input):\n        cm = CrystalMap(**crystal_map_input)\n\n        cm.prop[""test""] = np.zeros(cm.size)\n        cm[1, 5, 4].test = 1\n\n        fig1 = plt.figure()\n        ax1 = fig1.add_subplot(projection=PLOT_MAP)\n        im1 = ax1.plot_map(cm, cm.test)\n\n        fig2 = plt.figure()\n        ax2 = fig2.add_subplot(projection=PLOT_MAP)\n        im2 = ax2.plot_map(cm, cm.test, depth=1)\n\n        expected_data_im1 = np.zeros(ax1._data_shape)\n        expected_data_im2 = np.zeros(ax2._data_shape)\n        expected_data_im2[5, 4] = 1\n\n        im1_data = im1.get_array()\n        im2_data = im2.get_array()\n        assert np.allclose(im1_data, expected_data_im1)\n        assert np.allclose(im2_data, expected_data_im2)\n\n        plt.close(""all"")\n\n\nclass TestCrystalMapPlotUtilities:\n    def test_init_projection(self):\n        # Option 1\n        fig = plt.figure()\n        ax1 = fig.add_subplot(projection=PLOT_MAP)\n        assert isinstance(ax1, CrystalMapPlot)\n\n        # Option 2 (`label` to suppress warning of non-unique figure objects)\n        ax2 = plt.subplot(projection=PLOT_MAP, label=""unique"")\n        assert isinstance(ax2, CrystalMapPlot)\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, idx_to_change, axes, depth, expected_plot_shape"",\n        [\n            (((2, 10, 20), (1, 1.5, 1.5), 1), (1, 5, 4), (1, 2), 1, (10, 20)),\n            (((4, 4, 3), (0.1, 0.1, 0.1), 1), (0, 0, 2), (0, 1), 2, (4, 4)),\n            (((10, 10, 10), (1, 1, 1), 2), (-1, 8, -1), (0, 2), 8, (10, 10)),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_get_plot_shape(\n        self, crystal_map_input, idx_to_change, axes, depth, expected_plot_shape\n    ):\n        cm = CrystalMap(**crystal_map_input)\n\n        cm.prop[""test""] = np.zeros(cm.size)\n        cm[idx_to_change].test = 1\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(cm, cm.test, axes=axes, depth=depth)\n\n        assert ax._data_shape == expected_plot_shape\n        assert np.allclose(np.unique(im.get_array()), np.array([0, 1]))\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(""to_plot"", [""scalar"", ""rgb""])\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_add_overlay(self, crystal_map, to_plot):\n        cm = crystal_map\n\n        assert np.allclose(cm.phase_id, np.zeros(cm.size))  # Assumption\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        if to_plot == ""scalar"":\n            im = ax.plot_map(cm, cm.y)\n            im_data = im.get_array()\n            assert im_data.ndim == 2\n            im_data = im.to_rgba(im_data)[:, :, :3]\n        else:  # rgb\n            im = ax.plot_map(cm)\n            im_data = copy.deepcopy(im.get_array())\n\n        to_overlay = cm.id\n        ax.add_overlay(cm, to_overlay)\n        im_data2 = ax.images[0].get_array()\n\n        assert np.allclose(im_data, im_data2) is False\n\n        overlay = cm.get_map_data(to_overlay)\n        overlay_min = np.nanmin(overlay)\n        rescaled_overlay = (overlay - overlay_min) / (np.nanmax(overlay) - overlay_min)\n\n        for i in range(3):\n            im_data[:, :, i] *= rescaled_overlay\n\n        assert np.allclose(im_data, im_data2)\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""phase_names, phase_colors, legend_properties"",\n        [\n            ([""a"", ""b""], [""r"", ""b""], {}),\n            (\n                [""austenite"", ""ferrite""],\n                [""xkcd:violet"", ""lime""],\n                {""borderpad"": 1, ""framealpha"": 1},\n            ),\n            (\n                [""al"", ""au""],\n                [""tab:orange"", ""tab:green""],\n                {""handlelength"": 0.5, ""handletextpad"": 0.5},\n            ),\n        ],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_phase_legend(\n        self, crystal_map, phase_names, phase_colors, legend_properties\n    ):\n        cm = crystal_map\n        cm[0, 0].phase_id = 1\n        cm.phases = PhaseList(names=phase_names, symmetries=[3, 3], colors=phase_colors)\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        _ = ax.plot_map(cm, legend_properties=legend_properties)\n\n        legend = ax.legend_\n\n        assert legend._fontsize == 11.0\n        assert [i._text for i in legend.texts] == phase_names\n\n        frame_alpha = legend_properties.pop(""framealpha"", 0.6)\n        assert legend.get_frame().get_alpha() == frame_alpha\n\n        for k, v in legend_properties.items():\n            assert legend.__getattribute__(k) == v\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(""with_colorbar"", [True, False])\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_remove_padding(self, crystal_map, with_colorbar):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        _ = ax.plot_map(crystal_map)\n\n        if with_colorbar:\n            _ = ax.add_colorbar(position=""right"")\n\n        # Before\n        margin_before = 0.05\n        assert ax._xmargin == margin_before\n        assert ax._ymargin == margin_before\n\n        expected_subplot_params = (0.88, 0.11, 0.9, 0.125)  # top, bottom, right, left\n        subplot_params = fig.subplotpars\n        assert (\n            subplot_params.top,\n            subplot_params.bottom,\n            subplot_params.right,\n            subplot_params.left,\n        ) == expected_subplot_params\n\n        ax.remove_padding()\n\n        # After\n        margin_after = 0\n        expected_subplot_params = (1, 0, 1, 0)\n        assert ax._xmargin == margin_after\n        assert ax._ymargin == margin_after\n\n        if with_colorbar:\n            expected_subplot_params = (1, 0, 0.9, 0)\n        subplot_params = fig.subplotpars\n        assert (\n            subplot_params.top,\n            subplot_params.bottom,\n            subplot_params.right,\n            subplot_params.left,\n        ) == expected_subplot_params\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(""cmap"", [""viridis"", ""cividis"", ""inferno""])\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_set_colormap(self, crystal_map, cmap):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(crystal_map, cmap=cmap)\n\n        assert im.cmap.name == cmap\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""cmap, label, position"",\n        [(""viridis"", ""a"", ""right""), (""cividis"", ""b"", ""left""), (""inferno"", ""c"", ""top""),],\n    )\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_add_colorbar(self, crystal_map, cmap, label, position):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(crystal_map, cmap=cmap)\n\n        assert im.cmap.name == cmap\n\n        cbar = ax.add_colorbar(label=label, position=position)\n\n        assert cbar.cmap.name == cmap\n        assert cbar.ax.get_ylabel() == label\n\n        new_label = label + ""z""\n        cbar.ax.set_ylabel(ylabel=new_label)\n        assert cbar.ax.get_ylabel() == new_label\n\n        assert cbar.ax.yaxis.labelpad == 15\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""value, unit, expected_value, expected_unit, expected_factor"",\n        [\n            (3.141592 * 1e3, ""nm"", 3.141592, ""um"", 1e3),\n            (10.55 * 1e-3, ""mm"", 10.55, ""um"", 1e-3),\n            (23.7 * 1e3, ""px"", 23.7, ""px"", 1e3),\n        ],\n    )\n    def test_convert_unit(\n        self, value, unit, expected_value, expected_unit, expected_factor\n    ):\n        new_value, new_unit, factor = convert_unit(value, unit)\n        assert np.allclose(new_value, expected_value, atol=1e-6)\n        assert new_unit == expected_unit\n        assert np.allclose(factor, expected_factor)\n\n\nclass TestStatusBar:\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_status_bar_call_directly(self, crystal_map):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        im = ax.plot_map(crystal_map)\n\n        _ = ax._override_status_bar(im, crystal_map)\n\n        plt.close(""all"")\n\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_status_bar_silence_default_format_coord(self, crystal_map):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        _ = ax.plot_map(crystal_map)\n\n        assert ax.format_coord(0, 0) == """"\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(""to_plot"", [""rgb"", ""scalar""])\n    @pytest.mark.filterwarnings(f""ignore: {SCALEBAR_WARNING}"")\n    def test_status_bar(self, crystal_map, to_plot):\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n\n        f = plt.gcf()\n        f.canvas.draw()\n        f.canvas.flush_events()\n\n        if to_plot == ""rgb"":\n            im = ax.plot_map(crystal_map)\n        else:  # scalar\n            im = ax.plot_map(crystal_map, crystal_map.id)\n\n        # Get figure canvas (x, y) from transformation from data (x, y)\n        data_idx = (2, 2)\n        x, y = ax.transData.transform(data_idx)\n\n        # Mock a mouse event\n        plt.matplotlib.backends.backend_agg.FigureCanvasBase.motion_notify_event(\n            f.canvas, x, y\n        )\n        cursor_event = plt.matplotlib.backend_bases.MouseEvent(\n            ""motion_notify_event"", f.canvas, x, y\n        )\n\n        # Call our custom cursor data function\n        cursor_data = im.get_cursor_data(cursor_event)\n\n        # Check status bar data formatting\n        data_format = im.format_cursor_data(cursor_data)\n        expected_format = f""(y,x):({data_idx[0]},{data_idx[1]})""\n\n        # Get crystal map data\n        point = crystal_map[data_idx]\n        r = point.rotations.to_euler()\n\n        # Expected indices, rotation and value\n        assert cursor_data[:2] == data_idx\n        assert np.allclose(cursor_data[2], r, atol=1e-3)\n        if to_plot == ""rgb"":\n            assert np.allclose(cursor_data[3], point.phases_in_data.colors_rgb)\n        else:  # scalar\n            assert np.allclose(cursor_data[3], point.id)\n            expected_format += "" val: {:.1f}"".format(point.id[0])\n\n        expected_format += "" rot:({:.3f},{:.3f},{:.3f})"".format(\n            r[0, 0], r[0, 1], r[0, 2]\n        )\n        assert data_format == expected_format\n\n        plt.close(""all"")\n\n\nclass TestScalebar:\n    @pytest.mark.parametrize(\n        ""crystal_map_input, scalebar_properties, artist_attribute"",\n        [\n            (((1, 10, 30), (0, 1, 1), 1), {}, {}),  # Default\n            (\n                ((1, 10, 30), (0, 1, 1), 1),\n                {\n                    ""loc"": 4,\n                    ""frameon"": False,\n                    ""sep"": 6,\n                    ""size_vertical"": 0.2,\n                    ""alpha"": 0.8,\n                },\n                {\n                    ""loc"": ""loc"",\n                    ""frameon"": ""_drawFrame"",\n                    ""sep"": [""_box"", ""sep""],\n                    ""size_vertical"": [""size_bar"", ""_children"", 0, ""_height""],\n                    ""alpha"": [""patch"", ""_alpha""],\n                },\n            ),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_scalebar_properties(\n        self, crystal_map_input, scalebar_properties, artist_attribute\n    ):\n        cm = CrystalMap(**crystal_map_input)\n        cm.scan_unit = ""um""\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        _ = ax.plot_map(cm, scalebar=False)\n        sbar = ax.add_scalebar(cm, **scalebar_properties)\n\n        if ""alpha"" not in scalebar_properties.keys():  # Check default\n            assert sbar.patch._alpha == 0.6\n\n        for (k, v), attr_loc in zip(\n            scalebar_properties.items(), artist_attribute.values()\n        ):\n            if isinstance(attr_loc, list):\n                sbar_attr = sbar.__getattribute__(attr_loc[0])\n                for i in attr_loc[1:]:\n                    if isinstance(i, int):\n                        sbar_attr = sbar_attr[i]\n                    else:\n                        sbar_attr = sbar_attr.__getattribute__(i)\n            else:\n                sbar_attr = sbar.__getattribute__(attr_loc)\n            assert sbar_attr == v\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        (\n            ""crystal_map_input, unit, expected_coordinate_axes, expected_width_px, ""\n            ""expected_width_unit, expected_unit""\n        ),\n        [\n            (((10, 20, 1), (1, 1, 0), 1), ""px"", {0: ""z"", 1: ""y""}, 2, 2, ""px""),\n            (((1, 10, 30), (0, 1, 1), 1), ""px"", {0: ""y"", 1: ""x""}, 2, 2, ""px""),\n            (((1, 10, 40), (0, 1, 1), 1), ""px"", {0: ""y"", 1: ""x""}, 5, 5, ""px""),\n            (((20, 1, 10), (1, 1, 1), 1), ""um"", {0: ""z"", 1: ""x""}, 1, 1, ""um""),\n            (\n                ((1, 100, 117), (0, 1.5, 1.5), 1),\n                ""nm"",\n                {0: ""y"", 1: ""x""},\n                13.33,\n                20,\n                ""nm"",\n            ),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_scalebar_axis(\n        self,\n        crystal_map_input,\n        unit,\n        expected_coordinate_axes,\n        expected_width_px,\n        expected_width_unit,\n        expected_unit,\n    ):\n        cm = CrystalMap(**crystal_map_input)\n        cm.scan_unit = unit\n\n        assert cm._coordinate_axes == expected_coordinate_axes\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n        _ = ax.plot_map(cm, scalebar=False)\n        sbar = ax.add_scalebar(cm)\n\n        # Scalebar width (_width attribute of Rectangle artist)\n        assert np.allclose(\n            sbar.size_bar._children[0]._width, expected_width_px, atol=1e-2\n        )\n\n        # Scalebar text\n        if expected_unit == ""um"":\n            expected_unit = ""\\u03BC"" + ""m""\n        assert (\n            sbar.txt_label._children[0]._text\n            == f""{expected_width_unit} {expected_unit}""\n        )\n\n        plt.close(""all"")\n\n    @pytest.mark.parametrize(\n        ""crystal_map_input, warns"",\n        [\n            (((1, 10, 20), (0, 1.5, 1.5), 1), False),\n            (((1, 4, 3), (0, 0.1, 0.1), 1), True),\n        ],\n        indirect=[""crystal_map_input""],\n    )\n    def test_scalebar_warns(self, crystal_map_input, warns):\n        cm = CrystalMap(**crystal_map_input)\n\n        fig = plt.figure()\n        ax = fig.add_subplot(projection=PLOT_MAP)\n\n        if warns:\n            with pytest.warns(UserWarning, match=SCALEBAR_WARNING):\n                _ = ax.plot_map(cm)\n        else:\n            _ = ax.plot_map(cm)\n\n        plt.close(""all"")\n'"
orix/tests/test_crystal_map_properties.py,20,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\nimport pytest\n\nfrom orix.crystal_map.crystal_map_properties import CrystalMapProperties\n\n\nclass TestCrystalMapProperties:\n    @pytest.mark.parametrize(\n        ""dictionary, id, is_in_data"",\n        [\n            ({}, np.arange(10), np.ones(10, dtype=bool)),\n            ({""iq"": np.arange(10), ""dp"": np.zeros(10)}, np.arange(10), None,),\n            ({}, np.arange(5), np.array([1, 1, 0, 1, 1], dtype=bool)),\n        ],\n    )\n    def test_init_properties(self, dictionary, id, is_in_data):\n        props = CrystalMapProperties(\n            dictionary=dictionary, id=id, is_in_data=is_in_data\n        )\n\n        assert props == dictionary\n        assert np.allclose(props.id, id)\n        if is_in_data is None:\n            is_in_data = np.ones(id.size, dtype=bool)\n        assert np.allclose(props.is_in_data, is_in_data)\n\n    def test_set_item(self):\n        map_size = 10\n        is_in_data = np.ones(map_size, dtype=bool)\n        is_in_data[5] = False\n        d = {""iq"": np.arange(map_size)}\n        props = CrystalMapProperties(d, id=np.arange(map_size), is_in_data=is_in_data)\n\n        # Set array with an array\n        n_in_data = map_size - len(np.where(~is_in_data)[0])\n        props[""iq""] = np.arange(n_in_data) + 1\n        expected_array = np.array([1, 2, 3, 4, 5, 5, 6, 7, 8, 9])\n        assert np.allclose(props.get(""iq""), expected_array)\n\n        # Set array with one value\n        props[""iq""] = 2\n        expected_array2 = np.ones(map_size) * 2\n        expected_array2[5] = expected_array[5]\n        assert np.allclose(props.get(""iq""), expected_array2)\n\n    def test_set_item_error(self):\n        map_size = 10\n        is_in_data = np.ones(map_size, dtype=bool)\n        id_to_change = 3\n        is_in_data[id_to_change] = False\n\n        d = {""iq"": np.arange(map_size)}\n        props = CrystalMapProperties(d, id=np.arange(map_size), is_in_data=is_in_data)\n\n        # Set array with an array\n        with pytest.raises(ValueError, match=""NumPy boolean array indexing assignment""):\n            props[""iq""] = np.arange(map_size) + 1\n\n        # Set new 2D array\n        props.is_in_data[id_to_change] = True\n        with pytest.raises(TypeError, match=""NumPy boolean array indexing assignment""):\n            new_shape = (10 // 2, 10 // 5)\n            props[""dp""] = np.arange(map_size).reshape(new_shape)\n'"
orix/tests/test_io.py,68,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport os\n\nimport pytest\nimport numpy as np\n\nfrom orix import io\nfrom orix.io import load_ang, load_emsoft\nfrom orix.io.ang import _get_header, _get_phases_from_header, _get_vendor_columns\n\nfrom orix.tests.conftest import (\n    ANGFILE_TSL_HEADER,\n    ANGFILE_ASTAR_HEADER,\n    ANGFILE_EMSOFT_HEADER,\n)\n\n\n@pytest.mark.parametrize(\n    ""angfile_astar, expected_data"",\n    [\n        (\n            (\n                (2, 5),\n                (1, 1),\n                np.ones(2 * 5, dtype=int),\n                np.array(\n                    [\n                        [4.485496, 0.952426, 0.791507],\n                        [1.343904, 0.276111, 0.825890],\n                        [1.343904, 0.276111, 0.825890],\n                        [1.343904, 0.276111, 0.825890],\n                        [4.555309, 2.895152, 3.972020],\n                        [1.361357, 0.276111, 0.825890],\n                        [4.485496, 0.220784, 0.810182],\n                        [0.959931, 2.369110, 4.058938],\n                        [0.959931, 2.369110, 4.058938],\n                        [4.485496, 0.220784, 0.810182],\n                    ],\n                ),\n            ),\n            np.array(\n                [\n                    [0.77861956, -0.12501022, 0.44104243, 0.42849224],\n                    [0.46256046, -0.13302712, -0.03524667, -0.87584204],\n                    [0.46256046, -0.13302712, -0.03524667, -0.87584204],\n                    [0.46256046, -0.13302712, -0.03524667, -0.87584204],\n                    [0.05331986, 0.95051048, 0.28534763, -0.11074093],\n                    [0.45489991, -0.13271448, -0.03640618, -0.87984517],\n                    [0.8752001, -0.02905178, 0.10626836, 0.47104969],\n                    [0.3039118, 0.01972273, -0.92612154, 0.22259272],\n                    [0.3039118, 0.01972273, -0.92612154, 0.22259272],\n                    [0.8752001, -0.02905178, 0.10626836, 0.47104969],\n                ]\n            ),\n        ),\n    ],\n    indirect=[""angfile_astar""],\n)\ndef test_loadang(angfile_astar, expected_data):\n    loaded_data = io.loadang(angfile_astar)\n    assert np.allclose(loaded_data.data, expected_data)\n\n\ndef test_loadctf():\n    """""" Crude test of the ctf loader """"""\n    z = np.random.rand(100, 8)\n    fname = ""temp.ctf""\n    np.savetxt(fname, z)\n\n    _ = io.loadctf(fname)\n    os.remove(fname)\n\n\nclass TestAngReader:\n    @pytest.mark.parametrize(\n        ""angfile_tsl, map_shape, step_sizes, phase_id, n_unknown_columns, example_rot"",\n        [\n            (\n                # Read by angfile_tsl() via request.param (passed via `indirect` below)\n                (\n                    (5, 3),  # map_shape\n                    (0.1, 0.1),  # step_sizes\n                    np.zeros(5 * 3, dtype=int),  # phase_id\n                    5,  # n_unknown_columns\n                    np.array(\n                        [[1.59942, 2.37748, 4.53419], [1.59331, 2.37417, 4.53628],]\n                    ),  # rotations as rows of Euler angle triplets\n                ),\n                (5, 3),\n                (0.1, 0.1),\n                np.zeros(5 * 3, dtype=int),\n                5,\n                np.array(\n                    [[1.59942, 2.37748, -1.74690], [1.59331, 2.37417, -1.74899],]\n                ),  # rotations as rows of Euler angle triplets\n            ),\n            (\n                (\n                    (8, 4),  # map_shape\n                    (1.5, 1.5),  # step_sizes\n                    np.zeros(8 * 4, dtype=int),  # phase_id\n                    5,  # n_unknown_columns\n                    np.array(\n                        [[5.81107, 2.34188, 4.47345], [6.16205, 0.79936, 1.31702],]\n                    ),  # rotations as rows of Euler angle triplets\n                ),\n                (8, 4),\n                (1.5, 1.5),\n                np.zeros(8 * 4, dtype=int),\n                5,\n                np.array(\n                    [[-0.12113, 2.34188, 1.31702], [-0.47211, 0.79936, -1.80973],]\n                ),  # rotations as rows of Euler angle triplets\n            ),\n        ],\n        indirect=[""angfile_tsl""],\n    )\n    def test_load_ang_tsl(\n        self,\n        angfile_tsl,\n        map_shape,\n        step_sizes,\n        phase_id,\n        n_unknown_columns,\n        example_rot,\n    ):\n        cm = load_ang(angfile_tsl)\n\n        # Fraction of non-indexed points\n        non_indexed_fraction = int(np.prod(map_shape) * 0.1)\n        assert non_indexed_fraction == np.sum(~cm.is_indexed)\n\n        # Properties\n        assert list(cm.prop.keys()) == [\n            ""iq"",\n            ""ci"",\n            ""unknown1"",\n            ""fit"",\n            ""unknown2"",\n            ""unknown3"",\n            ""unknown4"",\n            ""unknown5"",\n        ]\n\n        # Coordinates\n        ny, nx = map_shape\n        dy, dx = step_sizes\n        assert np.allclose(cm.x, np.tile(np.arange(nx) * dx, ny))\n        assert np.allclose(cm.y, np.sort(np.tile(np.arange(ny) * dy, nx)))\n\n        # Map shape and size\n        assert cm.shape == map_shape\n        assert cm.size == np.prod(map_shape)\n\n        # Attributes are within expected ranges or have a certain value\n        assert cm.prop[""ci""].max() <= 1\n        assert cm[""indexed""].fit.max() <= 3\n        assert all(cm[""not_indexed""].fit == 180)\n        assert all(cm[""not_indexed""].ci == -1)\n\n        # Phase IDs (accounting for non-indexed points)\n        phase_id[cm[""not_indexed""].id] = -1\n        assert np.allclose(cm.phase_id, phase_id)\n\n        # Rotations\n        rot_unique = np.unique(cm[""indexed""].rotations.to_euler(), axis=0)\n        assert np.allclose(\n            np.sort(rot_unique, axis=0), np.sort(example_rot, axis=0), atol=1e-5)\n        assert np.allclose(\n            cm[""not_indexed""].rotations.to_euler()[0],\n            np.array([np.pi, 0, np.pi]),\n            atol=1e-5,\n        )\n\n        # Phases\n        assert cm.phases.size == 2  # Including non-indexed\n        assert cm.phases.phase_ids == [-1, 0]\n        phase = cm.phases[0]\n        assert phase.name == ""Aluminum""\n        assert phase.symmetry.name == ""432""\n\n    @pytest.mark.parametrize(\n        ""angfile_astar, map_shape, step_sizes, phase_id, example_rot"",\n        [\n            (\n                # Read by angfile_astar() via request.param (passed via `indirect`\n                # below)\n                (\n                    (9, 3),  # map_shape\n                    (4.5, 4.5),  # step_sizes\n                    np.ones(9 * 3, dtype=int),  # phase_id\n                    np.array(\n                        [\n                            [1.895079, 0.739496, 1.413542],\n                            [1.897871, 0.742638, 1.413717],\n                        ]\n                    ),\n                ),\n                (9, 3),\n                (4.5, 4.5),\n                np.ones(9 * 3, dtype=int),\n                np.array(\n                    [[1.895079, 0.739496, 1.413542], [1.897871, 0.742638, 1.413717],]\n                ),\n            ),\n            (\n                (\n                    (11, 13),  # map_shape\n                    (10, 10),  # step_sizes\n                    np.ones(11 * 13, dtype=int),  # phase_id\n                    np.array(\n                        [\n                            [1.621760, 2.368935, 4.559324],\n                            [1.604481, 2.367539, 4.541870],\n                        ]\n                    ),\n                ),\n                (11, 13),\n                (10, 10),\n                np.ones(11 * 13, dtype=int),\n                np.array(\n                    [[1.621760, 2.368935, -1.723861], [1.604481, 2.367539, -1.741315],]\n                ),\n            ),\n        ],\n        indirect=[""angfile_astar""],\n    )\n    def test_load_ang_astar(\n        self, angfile_astar, map_shape, step_sizes, phase_id, example_rot,\n    ):\n        cm = load_ang(angfile_astar)\n\n        # Properties\n        assert list(cm.prop.keys()) == [""ind"", ""rel"", ""relx100""]\n\n        # Coordinates\n        ny, nx = map_shape\n        dy, dx = step_sizes\n        assert np.allclose(cm.x, np.tile(np.arange(nx) * dx, ny))\n        assert np.allclose(cm.y, np.sort(np.tile(np.arange(ny) * dy, nx)))\n\n        # Map shape and size\n        assert cm.shape == map_shape\n        assert cm.size == np.prod(map_shape)\n\n        # Attributes are within expected ranges or have a certain value\n        assert cm.prop[""ind""].max() <= 100\n        assert cm.prop[""rel""].max() <= 1\n        assert cm.prop[""relx100""].max() <= 100\n        relx100 = (cm.prop[""rel""] * 100).astype(int)\n        assert np.allclose(cm.prop[""relx100""], relx100)\n\n        # Phase IDs\n        assert np.allclose(cm.phase_id, phase_id)\n\n        # Rotations\n        rot_unique = np.unique(cm.rotations.to_euler(), axis=0)\n        assert np.allclose(\n            np.sort(rot_unique, axis=0), np.sort(example_rot, axis=0), atol=1e-6)\n\n        # Phases\n        assert cm.phases.size == 1\n        assert cm.phases.phase_ids == [1]\n        phase = cm.phases[1]\n        assert phase.name == ""Nickel""\n        assert phase.symmetry.name == ""432""\n\n    @pytest.mark.parametrize(\n        ""angfile_emsoft, map_shape, step_sizes, phase_id, example_rot"",\n        [\n            (\n                # Read by angfile_emsoft() via request.param (passed via `indirect`\n                # below)\n                (\n                    (10, 11),  # map_shape\n                    (4.5, 4.5),  # step_sizes\n                    np.concatenate(\n                        (\n                            np.ones(int(np.ceil((10 * 11) / 2))),\n                            np.ones(int(np.floor((10 * 11) / 2))) * 2,\n                        )\n                    ),  # phase_id\n                    np.array(\n                        [\n                            [1.895079, 0.739496, 1.413542],\n                            [1.897871, 0.742638, 1.413717],\n                        ]\n                    ),\n                ),\n                (10, 11),\n                (4.5, 4.5),\n                np.concatenate(\n                    (\n                        np.ones(int(np.ceil((10 * 11) / 2))),\n                        np.ones(int(np.floor((10 * 11) / 2))) * 2,\n                    )\n                ),\n                np.array(\n                    [[1.895079, 0.739496, 1.413542], [1.897871, 0.742638, 1.413717],]\n                ),\n            ),\n            (\n                (\n                    (3, 6),  # map_shape\n                    (10, 10),  # step_sizes\n                    np.concatenate(\n                        (\n                            np.ones(int(np.ceil((3 * 6) / 2))),\n                            np.ones(int(np.floor((3 * 6) / 2))) * 2,\n                        )\n                    ),  # phase_id\n                    np.array(\n                        [\n                            [1.62176, 2.36894, -1.72386],\n                            [1.60448, 2.36754, -1.72386],\n                        ]\n                    ),\n                ),\n                (3, 6),\n                (10, 10),\n                np.concatenate(\n                    (\n                        np.ones(int(np.ceil((3 * 6) / 2))),\n                        np.ones(int(np.floor((3 * 6) / 2))) * 2,\n                    )\n                ),\n                np.array(\n                    [[1.62176, 2.36894, -1.72386], [1.60448, 2.36754, -1.72386],]\n                ),\n            ),\n        ],\n        indirect=[""angfile_emsoft""],\n    )\n    def test_load_ang_emsoft(\n        self, angfile_emsoft, map_shape, step_sizes, phase_id, example_rot,\n    ):\n        cm = load_ang(angfile_emsoft)\n\n        # Properties\n        assert list(cm.prop.keys()) == [""iq"", ""dp""]\n\n        # Coordinates\n        ny, nx = map_shape\n        dy, dx = step_sizes\n        assert np.allclose(cm.x, np.tile(np.arange(nx) * dx, ny))\n        assert np.allclose(cm.y, np.sort(np.tile(np.arange(ny) * dy, nx)))\n\n        # Map shape and size\n        assert cm.shape == map_shape\n        assert cm.size == np.prod(map_shape)\n\n        # Attributes are within expected ranges or have a certain value\n        assert cm.prop[""iq""].max() <= 100\n        assert cm.prop[""dp""].max() <= 1\n\n        # Phase IDs\n        assert np.allclose(cm.phase_id, phase_id)\n\n        # Rotations\n        rot_unique = np.unique(cm.rotations.to_euler(), axis=0)\n        assert np.allclose(\n            np.sort(rot_unique, axis=0), np.sort(example_rot, axis=0), atol=1e-5)\n\n        # Phases (change if file header is changed!)\n        phases_in_data = cm[""indexed""].phases_in_data\n        assert phases_in_data.size == 2\n        assert phases_in_data.phase_ids == [1, 2]\n        assert phases_in_data.names == [""austenite"", ""ferrite""]\n        assert [i.name for i in phases_in_data.symmetries] == [""432"",] * 2\n\n    def test_get_header(self, temp_ang_file):\n        temp_ang_file.write(ANGFILE_ASTAR_HEADER)\n        temp_ang_file.close()\n        assert _get_header(open(temp_ang_file.name)) == [\n            ""# File created from ACOM RES results"",\n            ""# ni-dislocations.res"",\n            ""#     "".rstrip(),\n            ""#     "".rstrip(),\n            ""# MaterialName      Nickel"",\n            ""# Formula"",\n            ""# Symmetry          43"",\n            ""# LatticeConstants  3.520  3.520  3.520  90.000  90.000  90.000"",\n            ""# NumberFamilies    4"",\n            ""# hklFamilies       1  1  1 1 0.000000"",\n            ""# hklFamilies       2  0  0 1 0.000000"",\n            ""# hklFamilies       2  2  0 1 0.000000"",\n            ""# hklFamilies       3  1  1 1 0.000000"",\n            ""#"",\n            ""# GRID: SqrGrid#"",\n        ]\n\n    @pytest.mark.parametrize(\n        ""expected_vendor, expected_columns, vendor_header"",\n        [\n            (\n                ""tsl"",\n                [\n                    ""iq"",\n                    ""ci"",\n                    ""phase_id"",\n                    ""unknown1"",\n                    ""fit"",\n                    ""unknown2"",\n                    ""unknown3"",\n                    ""unknown4"",\n                    ""unknown5"",\n                ],\n                ANGFILE_TSL_HEADER,\n            ),\n            (""astar"", [""ind"", ""rel"", ""phase_id"", ""relx100""], ANGFILE_ASTAR_HEADER),\n            (""emsoft"", [""iq"", ""dp"", ""phase_id""], ANGFILE_EMSOFT_HEADER),\n        ],\n    )\n    def test_get_vendor_columns(\n        self, expected_vendor, expected_columns, vendor_header, temp_ang_file\n    ):\n        expected_columns = [""euler1"", ""euler2"", ""euler3"", ""x"", ""y""] + expected_columns\n        n_cols_file = len(expected_columns)\n\n        temp_ang_file.write(vendor_header)\n        temp_ang_file.close()\n        header = _get_header(open(temp_ang_file.name))\n        vendor, column_names = _get_vendor_columns(header, n_cols_file)\n\n        assert vendor == expected_vendor\n        assert column_names == expected_columns\n\n    @pytest.mark.parametrize(""n_cols_file"", [15, 20])\n    def test_get_vendor_columns_unknown(self, temp_ang_file, n_cols_file):\n        temp_ang_file.write(""Look at me!\\nI\'m Mr. .ang file!\\n"")\n        temp_ang_file.close()\n        header = _get_header(open(temp_ang_file.name))\n        with pytest.warns(UserWarning, match=f""Number of columns, {n_cols_file}, ""):\n            vendor, column_names = _get_vendor_columns(header, n_cols_file)\n            assert vendor == ""unknown""\n            expected_columns = [\n                ""euler1"",\n                ""euler2"",\n                ""euler3"",\n                ""x"",\n                ""y"",\n                ""unknown1"",\n                ""unknown2"",\n                ""phase_id"",\n            ] + [""unknown"" + str(i + 3) for i in range(n_cols_file - 8)]\n            assert column_names == expected_columns\n\n    @pytest.mark.parametrize(\n        ""header_phase_part, expected_names, expected_symmetries"",\n        [\n            (\n                [\n                    [\n                        ""# MaterialName      Nickel"",\n                        ""# Formula"",\n                        ""# Symmetry          43"",\n                        ""# LatticeConstants  3.520  3.520  3.520  90.000  90.000  90.000"",\n                    ],\n                    [\n                        ""# MaterialName      Aluminium"",\n                        ""# Formula  Al"",\n                        ""# Symmetry          m3m"",\n                        ""# LatticeConstants  3.520  3.520  3.520  90.000  90.000  90.000"",\n                    ],\n                ],\n                [""Nickel"", ""Aluminium""],\n                [""43"", ""m3m""],\n            ),\n        ],\n    )\n    def test_get_phases_from_header(\n        self, header_phase_part, expected_names, expected_symmetries\n    ):\n        # Create header from parts\n        header = [\n            ""# File created from ACOM RES results"",\n            ""# ni-dislocations.res"",\n            ""#     "",\n            ""#     "",\n        ]\n        hkl_families = [\n            ""# NumberFamilies    4"",\n            ""# hklFamilies       1  1  1 1 0.000000"",\n            ""# hklFamilies       2  0  0 1 0.000000"",\n            ""# hklFamilies       2  2  0 1 0.000000"",\n            ""# hklFamilies       3  1  1 1 0.000000"",\n        ]\n        for phase in header_phase_part:\n            header += phase + hkl_families\n        header += [\n            ""#"",\n            ""# GRID: SqrGrid#"",\n        ]\n        names, symmetries = _get_phases_from_header(header)\n\n        assert names == expected_names\n        assert symmetries == expected_symmetries\n\n\nclass TestEMsoftReader:\n    @pytest.mark.parametrize(\n        (\n            ""temp_emsoft_h5ebsd_file, map_shape, step_sizes, example_rot, ""\n            ""n_top_matches, refined""\n        ),\n        [\n            (\n                (\n                    (7, 3),  # map_shape\n                    (1.5, 1.5),  # step_sizes\n                    np.array(\n                        [\n                            [6.148271, 0.792205, 1.324879],\n                            [6.155951, 0.793078, 1.325229],\n                        ]\n                    ),  # rotations as rows of Euler angle triplets\n                    50,  # n_top_matches\n                    True,  # refined\n                ),\n                (7, 3),\n                (1.5, 1.5),\n                np.array(\n                    [[6.148271, 0.792205, 1.324879], [6.155951, 0.793078, 1.325229],]\n                ),\n                50,\n                True,\n            ),\n            (\n                (\n                    (5, 17),\n                    (0.5, 0.5),\n                    np.array(\n                        [\n                            [6.148271, 0.792205, 1.324879],\n                            [6.155951, 0.793078, 1.325229],\n                        ]\n                    ),\n                    20,\n                    False,\n                ),\n                (5, 17),\n                (0.5, 0.5),\n                np.array(\n                    [[6.148271, 0.792205, 1.324879], [6.155951, 0.793078, 1.325229],]\n                ),\n                20,\n                False,\n            ),\n        ],\n        indirect=[""temp_emsoft_h5ebsd_file""],\n    )\n    def test_load_emsoft(\n        self,\n        temp_emsoft_h5ebsd_file,\n        map_shape,\n        step_sizes,\n        example_rot,\n        n_top_matches,\n        refined,\n    ):\n        cm = load_emsoft(temp_emsoft_h5ebsd_file.id, refined=refined)\n\n        assert cm.shape == map_shape\n        assert (cm.dy, cm.dx) == step_sizes\n        if refined:\n            n_top_matches = 1\n        assert cm.rotations_per_point == n_top_matches\n\n        # Properties\n        expected_props = [\n            ""AvDotProductMap"",\n            ""CI"",\n            ""CIMap"",\n            ""IQ"",\n            ""IQMap"",\n            ""ISM"",\n            ""ISMap"",\n            ""KAM"",\n            ""OSM"",\n            ""TopDotProductList"",\n            ""TopMatchIndices"",\n        ]\n        if refined:\n            expected_props += [""RefinedDotProducts""]\n        actual_props = list(cm.prop.keys())\n        actual_props.sort()\n        expected_props.sort()\n        assert actual_props == expected_props\n'"
orix/tests/test_neoeuler.py,3,"b'import pytest\nimport numpy as np\n\nfrom orix.vector.neo_euler import Rodrigues, Homochoric\nfrom orix.quaternion.rotation import Rotation\n\n\n"""""" Rodrigues """"""\n\n\n@pytest.mark.parametrize(\n    ""rotation, expected"",\n    [\n        (Rotation([1, 0, 0, 0]), [0, 0, 0]),\n        (Rotation([0.9239, 0.2209, 0.2209, 0.2209]), [0.2391, 0.2391, 0.2391]),\n    ],\n)\ndef test_from_rotation(rotation, expected):\n    rodrigues = Rodrigues.from_rotation(rotation)\n    assert np.allclose(rodrigues.data, expected, atol=1e-4)\n\n\n@pytest.mark.parametrize(\n    ""rodrigues, expected"", [(Rodrigues([0.2391, 0.2391, 0.2391]), np.pi / 4),]\n)\ndef test_angle(rodrigues, expected):\n    angle = rodrigues.angle\n    assert np.allclose(angle.data, expected, atol=1e-3)\n\n\n"""""" Homochoric""""""\n\n\n@pytest.mark.parametrize(\n    ""rotation"", [Rotation([1, 0, 0, 0]), Rotation([0.9239, 0.2209, 0.2209, 0.2209])]\n)\ndef test_Homochoric_from_rotation(rotation):\n    h = Homochoric.from_rotation(rotation)\n    return None\n\n\n@pytest.mark.parametrize(\n    ""rotation"", [Rotation([1, 0, 0, 0]), Rotation([0.9239, 0.2209, 0.2209, 0.2209])]\n)\n@pytest.mark.xfail(strict=True, reason=AttributeError)\ndef test_Homochoric_angle(rotation):\n    h = Homochoric.from_rotation(rotation)\n    h.angle\n'"
orix/tests/test_object3d.py,15,"b'import pytest\nimport numpy as np\n\nfrom orix.base import DimensionError, Object3d, check\n\n\n@pytest.mark.xfail(strict=True, reason=ValueError)\ndef test_check_failing():\n    check(np.asarray([1, 1, 1, 1]), Object3d)\n\n\n@pytest.fixture(\n    params=[\n        (2,),\n        (2, 2),\n        (4, 2),\n        (2, 3, 2),\n        (100, 100, 2),\n        (3,),\n        (3, 3),\n        (4, 3),\n        (2, 3, 3),\n        (100, 100, 3),\n        (4,),\n        (3, 4),\n        (3, 4),\n        (2, 3, 4),\n        (100, 100, 4),\n    ]\n)\ndef data(request):\n    np.random.seed(4)\n    dat = np.random.rand(*request.param) * 2 - 1\n    return dat\n\n\n# Create an abstract subclass to test methods\n@pytest.fixture(params=[2, 3, 4])\ndef test_object3d(request):\n    class TestObject3d(Object3d):\n        dim = request.param\n\n    return TestObject3d\n\n\n@pytest.fixture(\n    params=[\n        (1,),\n        (2,),\n        (3,),\n        (4,),\n        (8,),\n        (100,),\n        (1, 1,),\n        (2, 1),\n        (1, 2),\n        (2, 2,),\n        (5, 5,),\n        (100, 100,),\n        (1, 1, 1),\n        (2, 1, 1),\n        (1, 2, 1),\n        (1, 4, 3),\n        (6, 4, 3),\n        (50, 40, 30),\n    ]\n)\ndef object3d(request, test_object3d):\n    shape = request.param + (test_object3d.dim,)\n    np.random.seed(4)\n    dat = np.random.rand(*shape) * 2 - 1\n    return test_object3d(dat)\n\n\n@pytest.mark.parametrize(\n    ""test_object3d, data"",\n    [\n        (2, (2,)),\n        (2, (3, 2,)),\n        (2, (4, 3, 2,)),\n        (2, (5, 4, 3, 2,)),\n        pytest.param(2, (3,), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(2, (2, 1), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(2, (3, 3), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(2, (3, 3, 3), marks=pytest.mark.xfail(raises=DimensionError)),\n        (3, (3,)),\n        (3, (4, 3,)),\n        (3, (5, 4, 3,)),\n        (3, (2, 5, 4, 3,)),\n        pytest.param(3, (2,), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(3, (3, 1,), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(3, (2, 2,), marks=pytest.mark.xfail(raises=DimensionError)),\n        pytest.param(3, (2, 2, 4), marks=pytest.mark.xfail(raises=DimensionError)),\n    ],\n    indirect=[""test_object3d"", ""data""],\n)\ndef test_init(test_object3d, data):\n    obj = test_object3d(data)\n    assert np.allclose(obj.data, data)\n\n\n@pytest.mark.parametrize(\n    ""test_object3d, data, key"",\n    [\n        (2, (5, 5, 2), (slice(0), slice(0))),\n        (2, (5, 5, 2), slice(1)),\n        (2, (5, 2), slice(1)),\n        (2, (5, 5, 2), 3),\n        (2, (5, 5, 2), slice(0, 3)),\n        (2, (5, 5, 2), (None, slice(1, 5))),\n        pytest.param(\n            2,\n            (5, 2),\n            (slice(1), slice(1), slice(1),),\n            marks=pytest.mark.xfail(raises=IndexError),\n        ),\n        pytest.param(2, (5, 2), slice(7, 8)),\n        pytest.param(\n            3,\n            (4, 4, 3),\n            (6, 6),\n            marks=pytest.mark.xfail(raises=IndexError, strict=True),\n        ),\n    ],\n    indirect=[""test_object3d"", ""data""],\n)\ndef test_slice(test_object3d, data, key):\n    obj = test_object3d(data)\n    obj_subset = obj[key]\n    print(key)\n    assert isinstance(obj_subset, test_object3d)\n    assert np.allclose(obj_subset.data, data[key])\n\n\ndef test_shape(object3d):\n    assert object3d.shape == object3d.data.shape[:-1]\n\n\ndef test_data_dim(object3d):\n    assert object3d.data_dim == len(object3d.data.shape[:-1])\n\n\ndef test_size(object3d):\n    assert object3d.size == object3d.data.size / object3d.dim\n\n\n@pytest.mark.parametrize(""n"", [2, 3, 4, 5, 6])\ndef test_stack(object3d, n):\n    stack = object3d.stack([object3d] * n)\n    assert isinstance(stack, object3d.__class__)\n    assert stack.shape[-1] == n\n\n\ndef test_flatten(object3d):\n    flat = object3d.flatten()\n    assert isinstance(flat, object3d.__class__)\n    assert flat.data_dim == 1\n    assert flat.shape[0] == object3d.size\n\n\n@pytest.mark.parametrize(""test_object3d"", [1,], indirect=[""test_object3d""])\ndef test_unique(test_object3d):\n    object = test_object3d([[1], [1], [2], [3], [3]])\n    unique = object.unique()\n    assert np.allclose(unique.data.flatten(), [1, 2, 3])\n    unique, idx = object.unique(return_index=True)\n    assert np.allclose(unique.data.flatten(), [1, 2, 3])\n    assert np.allclose(idx, [0, 2, 3])\n    unique, inv = object.unique(return_inverse=True)\n    assert np.allclose(unique.data.flatten(), [1, 2, 3])\n    assert np.allclose(inv, [0, 0, 1, 2, 2])\n    unique, idx, inv = object.unique(True, True)\n    assert np.allclose(unique.data.flatten(), [1, 2, 3])\n    assert np.allclose(idx, [0, 2, 3])\n    assert np.allclose(inv, [0, 0, 1, 2, 2])\n'"
orix/tests/test_orientation.py,6,"b'import numpy as np\nimport pytest\n\nfrom orix.quaternion.orientation import Orientation, Misorientation\nfrom orix.quaternion.symmetry import C1, C2, C3, C4, D2, D3, D6, T, O\nfrom orix.vector import Vector3d\n\n\n@pytest.fixture\ndef vector(request):\n    return Vector3d(request.param)\n\n\n@pytest.fixture(params=[(0.5, 0.5, 0.5, 0.5), (0.5 ** 0.5, 0, 0, 0.5 ** 0.5)])\ndef orientation(request):\n    return Orientation(request.param)\n\n\n@pytest.mark.parametrize(\n    ""orientation, symmetry, expected"",\n    [\n        ([(1, 0, 0, 0)], C1, [(1, 0, 0, 0)]),\n        ([(1, 0, 0, 0)], C4, [(1, 0, 0, 0)]),\n        ([(1, 0, 0, 0)], D3, [(1, 0, 0, 0)]),\n        ([(1, 0, 0, 0)], T, [(1, 0, 0, 0)]),\n        ([(1, 0, 0, 0)], O, [(1, 0, 0, 0)]),\n        # 7pi/12 -C2-> # 7pi/12\n        ([(0.6088, 0, 0, 0.7934)], C2, [(-0.7934, 0, 0, 0.6088)]),\n        # 7pi/12 -C3-> # 7pi/12\n        ([(0.6088, 0, 0, 0.7934)], C3, [(-0.9914, 0, 0, 0.1305)]),\n        # 7pi/12 -C4-> # pi/12\n        ([(0.6088, 0, 0, 0.7934)], C4, [(-0.9914, 0, 0, -0.1305)]),\n        # 7pi/12 -O-> # pi/12\n        ([(0.6088, 0, 0, 0.7934)], O, [(-0.9914, 0, 0, -0.1305)]),\n    ],\n    indirect=[""orientation""],\n)\ndef test_set_symmetry(orientation, symmetry, expected):\n    o = orientation.set_symmetry(symmetry)\n    assert np.allclose(o.data, expected, atol=1e-3)\n\n\n@pytest.mark.parametrize(\n    ""symmetry, vector"",\n    [(C1, (1, 2, 3)), (C2, (1, -1, 3)), (C3, (1, 1, 1)), (O, (0, 1, 0))],\n    indirect=[""vector""],\n)\ndef test_orientation_persistence(symmetry, vector):\n    v = symmetry.outer(vector).flatten()\n    o = Orientation.random()\n    oc = o.set_symmetry(symmetry)\n    v1 = o * v\n    v1 = Vector3d(v1.data.round(4))\n    v2 = oc * v\n    v2 = Vector3d(v2.data.round(4))\n    assert v1._tuples == v2._tuples\n\n@pytest.mark.parametrize(\n    ""orientation, symmetry, expected"",\n    [\n        ((1, 0, 0, 0), C1, [0]),\n        ([(1, 0, 0, 0), (0.7071, 0.7071, 0, 0)], C1, [[0, np.pi / 2], [np.pi / 2, 0]]),\n        ([(1, 0, 0, 0), (0.7071, 0.7071, 0, 0)], C4, [[0, np.pi / 2], [np.pi / 2, 0]]),\n        ([(1, 0, 0, 0), (0.7071, 0, 0, 0.7071)], C4, [[0, 0], [0, 0]]),\n        (\n            [\n                [(1, 0, 0, 0), (0.7071, 0, 0, 0.7071)],\n                [(0, 0, 0, 1), (0.9239, 0, 0, 0.3827)],\n            ],\n            C4,\n            [\n                [[[0, 0], [0, np.pi / 4]], [[0, 0], [0, np.pi / 4]]],\n                [[[0, 0], [0, np.pi / 4]], [[np.pi / 4, np.pi / 4], [np.pi / 4, 0]]],\n            ],\n        ),\n    ],\n    indirect=[""orientation""],\n)\ndef test_distance(orientation, symmetry, expected):\n    o = orientation.set_symmetry(symmetry)\n    distance = o.distance(verbose=True)\n    assert np.allclose(distance, expected, atol=1e-3)\n\n\n@pytest.mark.parametrize(""symmetry"", [C1, C2, C4, D2, D6, T, O])\ndef test_getitem(orientation, symmetry):\n    o = orientation.set_symmetry(symmetry)\n    assert o[0].symmetry._tuples == symmetry._tuples\n\n\n@pytest.mark.parametrize(""Gl"", [C4, C2])\ndef test_equivalent(Gl):\n    """""" Tests that the property Misorientation.equivalent runs without error\n\n    Cases\n    -----\n    Gl == C4 ~ ""grain exchange""\n    Gl == C2 ~ ""no grain exchange""\n    """"""\n    m = Misorientation([1, 1, 1, 1])  # any will do\n    m_new = m.set_symmetry(Gl, C4, verbose=True)\n    m_new.symmetry\n    _m = m_new.equivalent\n\n\ndef test_repr():\n    m = Misorientation([1, 1, 1, 1])  # any will do\n    print(m)  # hits __repr__\n    return None\n\n\ndef test_sub():\n    m = Orientation([1, 1, 1, 1])  # any will do\n    m.set_symmetry(C4)  # only one as it a O\n    _ = m - m  # this should give a set of zeroes\n    return None\n\n\n@pytest.mark.xfail(strict=True, reason=TypeError)\ndef test_sub_orientation_and_other():\n    m = Orientation([1, 1, 1, 1])  # any will do\n    _ = m - 3\n'"
orix/tests/test_orientation_region.py,2,"b'import pytest\nimport numpy\n\nfrom orix.quaternion.symmetry import *\nfrom orix.quaternion.orientation import Orientation\nfrom orix.quaternion.orientation_region import (\n    _get_large_cell_normals,\n    get_proper_groups,\n    OrientationRegion,\n)\nfrom orix.quaternion.symmetry import get_distinguished_points\n\n\n@pytest.mark.parametrize(\n    ""s1, s2, expected"",\n    [\n        (C2, C1, [[0, 0, 0, 1], [0, 0, 0, -1]]),\n        (\n            C3,\n            C1,\n            [\n                [0.5, 0, 0, 0.866],\n                [-0.5, 0, 0, -0.866],\n                [-0.5, 0, 0, 0.866],\n                [0.5, 0, 0, -0.866],\n            ],\n        ),\n        (\n            D3,\n            C3,\n            [\n                [0.5, 0.0, 0.0, 0.866],\n                [-0.5, 0.0, 0.0, -0.866],\n                [-0.5, 0.0, 0.0, 0.866],\n                [0.5, -0.0, -0.0, -0.866],\n                [0.0, 1.0, 0.0, 0.0],\n                [-0.0, -1.0, -0.0, -0.0],\n                [0.0, 0.5, 0.866, 0.0],\n                [-0.0, -0.5, -0.866, 0.0],\n                [0.0, -0.5, 0.866, 0.0],\n                [0.0, 0.5, -0.866, 0.0],\n            ],\n        ),\n    ],\n)\ndef test_get_distinguished_points(s1, s2, expected):\n    dp = get_distinguished_points(s1, s2)\n    assert np.allclose(dp.data, expected, atol=1e-3)\n\n\n@pytest.mark.parametrize(\n    ""s1, s2, expected"",\n    [\n        (C2, C1, [[0.5 ** 0.5, 0, 0, -(0.5 ** 0.5)], [0.5 ** 0.5, 0, 0, 0.5 ** 0.5]]),\n        (C6, C1, [[0.258819, 0, 0, -0.965926,], [0.258819, 0, 0, 0.965926,]]),\n        (C3, C3, [[0.5, 0, 0, -0.866], [0.5, 0, 0, 0.866]]),\n        (\n            D2,\n            C1,\n            [\n                [0.5 ** 0.5, -(0.5 ** 0.5), 0, 0,],\n                [0.5 ** 0.5, 0, -(0.5 ** 0.5), 0,],\n                [0.5 ** 0.5, 0, 0, -(0.5 ** 0.5),],\n                [0.5 ** 0.5, 0, 0, 0.5 ** 0.5,],\n                [0.5 ** 0.5, 0, 0.5 ** 0.5, 0,],\n                [0.5 ** 0.5, 0.5 ** 0.5, 0, 0,],\n            ],\n        ),\n        (\n            D3,\n            C1,\n            [\n                [0.707107, -0.707107, 0, 0,],\n                [0.707107, -0.353553, -0.612372, 0,],\n                [0.707107, -0.353553, 0.612372, 0,],\n                [0.5, 0, 0, -0.866025,],\n                [0.5, 0, 0, 0.866025,],\n                [0.707107, 0.353553, -0.612372, 0,],\n                [0.707107, 0.353553, 0.612372, 0,],\n                [0.707107, 0.707107, 0, 0,],\n            ],\n        ),\n        (\n            D6,\n            C1,\n            [\n                [0.707107, -0.707107, 0, 0,],\n                [0.707107, -0.612372, -0.353553, 0,],\n                [0.707107, -0.612372, 0.353553, 0,],\n                [0.707107, -0.353553, -0.612372, 0,],\n                [0.707107, -0.353553, 0.612372, 0,],\n                [0.707107, 0, -0.707107, 0,],\n                [0.258819, 0, 0, -0.965926,],\n                [0.258819, 0, 0, 0.965926,],\n                [0.707107, 0, 0.707107, 0,],\n                [0.707107, 0.353553, -0.612372, 0,],\n                [0.707107, 0.353553, 0.612372, 0,],\n                [0.707107, 0.612372, -0.353553, 0,],\n                [0.707107, 0.612372, 0.353553, 0,],\n                [0.707107, 0.707107, 0, 0,],\n            ],\n        ),\n    ],\n)\ndef test_get_large_cell_normals(s1, s2, expected):\n    n = _get_large_cell_normals(s1, s2)\n    print(n)\n    assert np.allclose(n.data, expected, atol=1e-3)\n\n\ndef test_coverage_on_faces():\n    o = OrientationRegion(Orientation([1, 1, 1, 1]))\n    f = o.faces()\n    return None\n\n\n@pytest.mark.parametrize(\n    ""Gl,Gr"",\n    [\n        (C1, Ci),\n        (Ci, C1),\n        (C1, Csz),\n        (Csz, C1),\n        (Ci, Csz),\n        (Csz, Ci),\n        (C1, C1),\n        (Ci, Ci),\n    ],\n)\ndef test_get_proper_point_groups(Gl, Gr):\n    get_proper_groups(Gl, Gr)\n    return None\n\n\n@pytest.mark.xfail(raises=NotImplementedError, strict=True)\ndef test_get_proper_point_group_not_implemented():\n    """""" Double inversion case not yet implemented """"""\n    get_proper_groups(Csz, Csz)\n'"
orix/tests/test_phase_list.py,4,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2020 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nimport numpy as np\nimport pytest\n\nfrom orix.crystal_map.phase_list import Phase, PhaseList\nfrom orix.quaternion.symmetry import Symmetry, O\n\n\nclass TestPhase:\n    @pytest.mark.parametrize(\n        ""name, symmetry, color, color_alias, color_rgb"",\n        [\n            (None, ""m-3m"", None, ""tab:blue"", (0.121568, 0.466666, 0.705882)),\n            (None, ""1"", ""blue"", ""b"", (0, 0, 1)),\n            (""al"", ""43"", ""xkcd:salmon"", ""xkcd:salmon"", (1, 0.474509, 0.423529)),\n            (""My awes0me phase!"", O, ""C1"", ""tab:orange"", (1, 0.498039, 0.054901)),\n        ],\n    )\n    def test_init_phase(self, name, symmetry, color, color_alias, color_rgb):\n        p = Phase(name, symmetry, color)\n\n        assert p.name == str(name)\n\n        if symmetry == ""43"":\n            symmetry = ""432""\n        if isinstance(symmetry, Symmetry):\n            symmetry = symmetry.name\n        assert p.symmetry.name == symmetry\n\n        assert p.color == color_alias\n        assert np.allclose(p.color_rgb, color_rgb, atol=1e-6)\n\n    @pytest.mark.parametrize(""name"", [None, ""al"", 1, np.arange(2)])\n    def test_set_phase_name(self, name):\n        p = Phase(name=name)\n        assert p.name == str(name)\n\n    @pytest.mark.parametrize(\n        ""color, color_alias, color_rgb, fails"",\n        [\n            (""some-color"", None, None, True),\n            (""c1"", None, None, True),\n            (""C1"", ""tab:orange"", (1, 0.498039, 0.054901), False),\n        ],\n    )\n    def test_set_phase_color(self, color, color_alias, color_rgb, fails):\n        p = Phase()\n        if fails:\n            with pytest.raises(ValueError, match=""Invalid RGBA argument: ""):\n                p.color = color\n        else:\n            p.color = color\n            assert p.color == color_alias\n            assert np.allclose(p.color_rgb, color_rgb, atol=1e-6)\n\n    @pytest.mark.parametrize(\n        ""symmetry, symmetry_name, fails"",\n        [\n            (43, ""432"", False),\n            (""4321"", None, True),\n            (""m3m"", ""m-3m"", False),\n            (""43"", ""432"", False),\n        ],\n    )\n    def test_set_phase_symmetry(self, symmetry, symmetry_name, fails):\n        p = Phase()\n        if fails:\n            with pytest.raises(ValueError, match=f""{symmetry} must be of type""):\n                p.symmetry = symmetry\n        else:\n            p.symmetry = symmetry\n            assert p.symmetry.name == symmetry_name\n\n    @pytest.mark.parametrize(""name, symmetry"", [(""al"", None), (None, ""m-3m"")])\n    def test_phase_repr_str(self, name, symmetry):\n        p = Phase(name=name, symmetry=symmetry, color=""C0"")\n        representation = (\n            ""<name: ""\n            + str(name)\n            + "". symmetry: ""\n            + str(symmetry)\n            + "". color: tab:blue>""\n        )\n        assert p.__repr__() == representation\n        assert p.__str__() == representation\n\n    def test_deepcopy_phase(self):\n        p = Phase(""al"", ""m-3m"", ""C1"")\n        p2 = p.deepcopy()\n\n        assert p.__repr__() == ""<name: al. symmetry: m-3m. color: tab:orange>""\n        p.name = ""austenite""\n        p.symmetry = 43\n        p.color = ""C2""\n\n        assert p.__repr__() == ""<name: austenite. symmetry: 432. color: tab:green>""\n        assert p2.__repr__() == ""<name: al. symmetry: m-3m. color: tab:orange>""\n\n    def test_shallowcopy_phase(self):\n        p = Phase(""al"", ""m-3m"", ""C1"")\n        p2 = p\n\n        p2.name = ""austenite""\n        p2.symmetry = 43\n        p2.color = ""C2""\n\n        assert p.__repr__() == p2.__repr__()\n\n\nclass TestPhaseList:\n    @pytest.mark.parametrize(""empty_input"", [(), [], {}])\n    def test_init_empty_phaselist(self, empty_input):\n        pl = PhaseList(empty_input)\n        assert pl.__repr__() == ""No phases.""\n        pl[""al""] = ""m-3m""\n        assert pl.__repr__() == (\n            ""Id  Name  Symmetry     Color\\n 0    al      m-3m  tab:blue""\n        )\n\n    def test_init_set_to_nones(self):\n        phase_ids = [1, 2]\n        pl = PhaseList(phase_ids=phase_ids)\n\n        assert pl.phase_ids == phase_ids\n        assert pl.names == [""None"",] * 2\n        assert pl.symmetries == [None,] * 2\n        assert pl.colors == [""tab:blue"", ""tab:orange""]\n\n    @pytest.mark.parametrize(""phase_collection"", [""dict"", ""list""])\n    def test_init_phaselist_from_phases(self, phase_collection):\n        p1 = Phase(""austenite"", 432, None)\n        p2 = Phase(""ferrite"", ""432"", ""C1"")\n        if phase_collection == ""dict"":\n            phases = {1: p1, 2: p2}\n        else:  # phase_collection == ""list"":\n            phases = [p1, p2]\n\n        pl = PhaseList(phases)\n\n        assert pl.names == [p.name for p in [p1, p2]]\n        assert pl.symmetries == [p.symmetry for p in [p1, p2]]\n        assert pl.colors == [p.color for p in [p1, p2]]\n        assert pl.colors_rgb == [p.color_rgb for p in [p1, p2]]\n\n    def test_init_phaselist_from_phase(self):\n        p = Phase(""austenite"", ""432"", ""C2"")\n        pl = PhaseList(p)\n\n        assert pl.names == [p.name]\n        assert pl.symmetries == [p.symmetry]\n        assert pl.colors == [p.color]\n        assert pl.colors_rgb == [p.color_rgb]\n\n    @pytest.mark.parametrize(\n        (\n            ""names, symmetries, colors, phase_ids, expected_names, ""\n            ""expected_symmetries, expected_colors, expected_phase_ids""\n        ),\n        [\n            (\n                [""al"", ""ni""],\n                [43,],\n                [None, ""C1""],\n                [1,],\n                [""al"", ""ni""],\n                [""432"", None],\n                [""tab:blue"", ""tab:orange""],\n                [1, 2],\n            ),\n            (\n                [""al"", None],\n                [432, ""m3m""],\n                (1, 0, 0),\n                [100,],\n                [""al"", ""None""],\n                [""432"", ""m-3m""],\n                [""r"", ""tab:blue""],\n                [100, 101],\n            ),\n            (\n                [None,],\n                [None, None],\n                [""green"", ""black""],\n                1,\n                [""None"", ""None""],\n                [None, None],\n                [""g"", ""k""],\n                [1, 2],\n            ),\n            (\n                [""al"", ""Ni""],\n                [""m-3m"", 3, None],\n                [""C0"", None, ""C0""],\n                None,\n                [""al"", ""Ni"", ""None""],\n                [""m-3m"", ""3"", None],\n                [""tab:blue"", ""tab:orange"", ""tab:blue""],\n                [0, 1, 2],\n            ),\n        ],\n    )\n    def test_init_phaselist_from_strings(\n        self,\n        names,\n        symmetries,\n        colors,\n        phase_ids,\n        expected_names,\n        expected_symmetries,\n        expected_colors,\n        expected_phase_ids,\n    ):\n        pl = PhaseList(\n            names=names, symmetries=symmetries, colors=colors, phase_ids=phase_ids,\n        )\n\n        actual_symmetry_names = []\n        for _, p in pl:\n            if p.symmetry is None:\n                actual_symmetry_names.append(None)\n            else:\n                actual_symmetry_names.append(p.symmetry.name)\n\n        assert pl.names == expected_names\n        assert actual_symmetry_names == expected_symmetries\n        assert pl.colors == expected_colors\n        assert pl.phase_ids == expected_phase_ids\n\n    def test_get_phaselist_colors_rgb(self):\n        pl = PhaseList(names=[""a"", ""b"", ""c""], colors=[""r"", ""g"", (0, 0, 1)])\n\n        assert pl.colors == [""r"", ""g"", ""b""]\n        assert np.allclose(pl.colors_rgb, [(1.0, 0.0, 0.0), [0, 0.5, 0], (0, 0, 1)])\n\n    @pytest.mark.parametrize(""n_names"", [1, 3])\n    def test_get_phaselist_size(self, n_names):\n        phase_names_pool = ""abcd""\n        phase_names = [phase_names_pool[i] for i in range(n_names)]\n\n        pl = PhaseList(names=phase_names)\n\n        assert pl.size == n_names\n\n    @pytest.mark.parametrize(\n        ""n_names, phase_ids, expected_names, expected_phase_ids"",\n        [\n            (2, [0, 2], [""a"", ""b""], [0, 2]),\n            (3, [1, 100, 2], [""a"", ""c"", ""b""], [1, 2, 100]),\n            (3, 100, [""a"", ""b"", ""c""], [100, 101, 102]),\n        ],\n    )\n    def test_get_phaselist_ids(\n        self, n_names, phase_ids, expected_names, expected_phase_ids\n    ):\n        phase_names_pool = ""abc""\n        phase_names = [phase_names_pool[i] for i in range(n_names)]\n\n        pl = PhaseList(names=phase_names, phase_ids=phase_ids)\n\n        assert pl.names == expected_names\n        assert pl.phase_ids == expected_phase_ids\n\n    @pytest.mark.parametrize(\n        ""key_getter, name, symmetry, color"",\n        [\n            (0, ""a"", ""m-3m"", ""r""),\n            (""b"", ""b"", ""432"", ""g""),\n            (slice(2, None, None), ""c"", ""3"", ""b""),  # equivalent to pl[2:]\n        ],\n    )\n    def test_get_phase_from_phaselist(\n        self, phase_list, key_getter, name, symmetry, color\n    ):\n        p = phase_list[key_getter]\n\n        assert p.__repr__() == (\n            ""<name: "" + name + "". symmetry: "" + symmetry + "". color: "" + color + "">""\n        )\n\n    @pytest.mark.parametrize(\n        ""key_getter, names, symmetries, colors"",\n        [\n            (\n                slice(0, None, None),\n                [""a"", ""b"", ""c""],\n                [""m-3m"", ""432"", ""3""],\n                [""r"", ""g"", ""b""],\n            ),\n            ((""a"", ""b""), [""a"", ""b""], [""m-3m"", ""432""], [""r"", ""g""]),\n            ([""a"", ""b""], [""a"", ""b""], [""m-3m"", ""432""], [""r"", ""g""]),\n            ((0, 2), [""a"", ""c""], [""m-3m"", ""3""], [""r"", ""b""]),\n            ([0, 2], [""a"", ""c""], [""m-3m"", ""3""], [""r"", ""b""]),\n        ],\n    )\n    def test_get_phases_from_phaselist(\n        self, phase_list, key_getter, names, symmetries, colors\n    ):\n        phases = phase_list[key_getter]\n\n        assert phases.names == names\n        assert [p.name for p in phases.symmetries] == symmetries\n        assert phases.colors == colors\n\n    @pytest.mark.parametrize(""key_getter"", [""d"", 3, slice(3, None, None)])\n    def test_get_from_phaselist_error(self, phase_list, key_getter):\n        with pytest.raises(KeyError):\n            _ = phase_list[key_getter]\n\n    @pytest.mark.parametrize(\n        ""key, value, already_there"",\n        [(""d"", ""m-3m"", False), (""d"", 432, False), (""c"", 432, True),],\n    )\n    def test_set_phase_in_phaselist(self, phase_list, key, value, already_there):\n        if already_there:\n            with pytest.raises(ValueError, match=f""{key} is already in the phase ""):\n                phase_list[key] = value\n        else:\n            expected_names = phase_list.names + [key]\n            expected_symmetry_names = [s.name for s in phase_list.symmetries] + [\n                str(value)\n            ]\n\n            phase_list[key] = value\n\n            assert phase_list.names == expected_names\n            assert [s.name for s in phase_list.symmetries] == expected_symmetry_names\n\n    def test_set_phase_in_empty_phaselist(self):\n        pl = PhaseList()\n\n        names = [0, 0]  # Use as names\n        symmetries = [432, ""m-3m""]\n        for n, s in zip(names, symmetries):\n            pl[n] = str(s)\n\n        assert pl.phase_ids == [0, 1]\n        assert pl.names == [str(n) for n in names]\n        assert [s.name for s in pl.symmetries] == [str(s) for s in symmetries]\n\n    @pytest.mark.parametrize(\n        ""key_del, invalid_phase, error_type, error_msg"",\n        [\n            (0, False, None, None),\n            (""a"", False, None, None),\n            (3, True, KeyError, ""3""),\n            (""d"", True, KeyError, ""d is not among the phase names""),\n            ([0, 1], True, TypeError, "".* is an invalid phase.""),\n        ],\n    )\n    def test_del_phase_in_phaselist(\n        self, phase_list, key_del, invalid_phase, error_type, error_msg\n    ):\n        if invalid_phase:\n            with pytest.raises(error_type, match=error_msg):\n                del phase_list[key_del]\n        else:\n            phase_ids = phase_list.phase_ids\n            names = phase_list.names\n\n            del phase_list[key_del]\n\n            if isinstance(key_del, int):\n                phase_ids.remove(key_del)\n                assert phase_list.phase_ids == phase_ids\n            elif isinstance(key_del, str):\n                names.remove(key_del)\n                assert phase_list.names == names\n\n    def test_iterate_phaselist(self):\n        names = [""al"", ""ni"", ""sigma""]\n        symmetries = [3, 432, ""m-3m""]\n        colors = [""g"", ""b"", ""r""]\n\n        pl = PhaseList(names=names, symmetries=symmetries, colors=colors)\n\n        for i, ((phase_id, phase), n, s, c) in enumerate(\n            zip(pl, names, symmetries, colors)\n        ):\n            assert phase_id == i\n            assert phase.name == n\n            assert phase.symmetry.name == str(s)\n            assert phase.color == c\n\n    def test_deepcopy_phaselist(self, phase_list):\n        names = phase_list.names\n        symmetries = [s.name for s in phase_list.symmetries]\n        colors = phase_list.colors\n\n        pl2 = phase_list.deepcopy()\n        assert pl2.names == names\n\n        phase_list[""d""] = ""m-3m""\n        phase_list[""d""].color = ""g""\n\n        assert phase_list.names == names + [""d""]\n        assert [s.name for s in phase_list.symmetries] == symmetries + [""m-3m""]\n        assert phase_list.colors == colors + [""g""]\n\n        assert pl2.names == names\n        assert [s.name for s in pl2.symmetries] == symmetries\n        assert pl2.colors == colors\n\n    def test_shallowcopy_phaselist(self, phase_list):\n        pl2 = phase_list\n\n        phase_list[""d""] = ""m-3m""\n\n        assert pl2.names == phase_list.names\n        assert [s2.name for s2 in pl2.symmetries] == [\n            s.name for s in phase_list.symmetries\n        ]\n        assert pl2.colors == phase_list.colors\n\n    def test_make_not_indexed(self):\n        phase_names = [""a"", ""b"", ""c""]\n        phase_colors = [""r"", ""g"", ""b""]\n        pl = PhaseList(names=phase_names, colors=phase_colors, phase_ids=[-1, 0, 1])\n\n        assert pl.names == phase_names\n        assert pl.colors == phase_colors\n\n        pl.add_not_indexed()\n\n        phase_names[0] = ""not_indexed""\n        phase_colors[0] = ""w""\n        assert pl.names == phase_names\n        assert pl.colors == phase_colors\n\n    def test_phase_id_from_name(self, phase_list):\n        for phase_id, phase in phase_list:\n            assert phase_id == phase_list.id_from_name(phase.name)\n\n        with pytest.raises(KeyError, match=""d is not among the phase names ""):\n            _ = phase_list.id_from_name(""d"")\n'"
orix/tests/test_quaternion.py,26,"b'import numpy as np\nimport pytest\nfrom orix.base import DimensionError\nfrom orix.quaternion import Quaternion, check_quaternion\nfrom orix.vector import Vector3d\n\nvalues = [\n    (0.707, 0.0, 0.0, 0.707),\n    (0.5, -0.5, -0.5, 0.5),\n    (0.0, 0.0, 0.0, 1.0),\n    (1.0, 1.0, 1.0, 1.0),\n    ((0.5, -0.5, -0.5, 0.5), (0.0, 0.0, 0.0, 1.0),),\n    Quaternion(\n        [\n            [(0.0, 0.0, 0.0, 1.0), (0.707, 0.0, 0.0, 0.707),],\n            [(1.0, 1.0, 1.0, 1.0), (0.707, 0.0, 0.0, 0.707),],\n        ]\n    ),\n    np.array((4, 3, 2, 1)),\n]\n\n\n@pytest.fixture(params=values)\ndef quaternion(request):\n    return Quaternion(request.param)\n\n\n@pytest.fixture\ndef identity():\n    return Quaternion((1, 0, 0, 0))\n\n\nsingles = [\n    (0.881, 0.665, 0.123, 0.517),\n    (0.111, 0.222, 0.333, 0.444),\n    ((1, 0, 0.5, 0), (3, 1, -1, -2),),\n    [\n        [[0.343, 0.343, 0, -0.333], [-7, -8, -9, -10],],\n        [[0.00001, -0.0001, 0.001, -0.01], [0, 0, 0, 0]],\n    ],\n]\n\n\n@pytest.fixture(params=singles)\ndef something(request):\n    return Quaternion(request.param)\n\n\n@pytest.mark.parametrize(""input_length"", [1, 2, 3, 5, 6, 8,])\ndef test_init(input_length):\n    with pytest.raises(DimensionError):\n        Quaternion(tuple(range(input_length)))\n\n\ndef test_neg(quaternion):\n    assert np.all((-quaternion).data == -(quaternion.data))\n\n\ndef test_norm(quaternion):\n    assert np.all(quaternion.norm.data == (quaternion.data ** 2).sum(axis=-1) ** 0.5)\n\n\ndef test_unit(quaternion):\n    assert np.allclose(quaternion.unit.norm.data, 1)\n\n\ndef test_conj(quaternion):\n    assert np.all(quaternion.data[..., 0] == quaternion.conj.data[..., 0])\n    assert np.all(quaternion.data[..., 1:] == -quaternion.conj.data[..., 1:])\n\n\ndef test_mul(quaternion, something):\n    sa, sb, sc, sd = (\n        something.a.data,\n        something.b.data,\n        something.c.data,\n        something.d.data,\n    )\n    qa, qb, qc, qd = (\n        quaternion.a.data,\n        quaternion.b.data,\n        quaternion.c.data,\n        quaternion.d.data,\n    )\n    q1 = quaternion * something\n    assert isinstance(q1, Quaternion)\n    assert np.allclose(q1.a.data, sa * qa - sb * qb - sc * qc - sd * qd)\n    assert np.allclose(q1.b.data, qa * sb + qb * sa + qc * sd - qd * sc)\n    assert np.allclose(q1.c.data, qa * sc - qb * sd + qc * sa + qd * sb)\n    assert np.allclose(q1.d.data, qa * sd + qb * sc - qc * sb + qd * sa)\n\n\ndef test_mul_identity(quaternion, identity):\n    assert np.all((quaternion * identity).data == quaternion.data)\n\n\ndef test_no_multiplicative_inverse(quaternion, something):\n    q1 = quaternion * something\n    q2 = something * quaternion\n    assert np.all(q1 != q2)\n\n\ndef test_inverse(quaternion):\n    assert np.allclose((quaternion * ~quaternion).data, (~quaternion * quaternion).data)\n    assert np.allclose((quaternion * ~quaternion).a.data, 1)\n    assert np.allclose((quaternion * ~quaternion).data[..., 1:], 0)\n\n\ndef test_dot(quaternion, something):\n    assert np.all(\n        quaternion.dot(quaternion).data == np.sum(quaternion.data ** 2, axis=-1)\n    )\n    assert np.all(quaternion.dot(something).data == something.dot(quaternion).data)\n\n\ndef test_dot_outer(quaternion, something):\n    d = quaternion.dot_outer(something)\n    assert d.shape == quaternion.shape + something.shape\n    for i in np.ndindex(quaternion.shape):\n        for j in np.ndindex(something.shape):\n            assert np.allclose(d[i + j].data, quaternion[i].dot(something[j]).data)\n\n\n@pytest.mark.parametrize(\n    ""quaternion, vector, expected"",\n    [\n        ((0.5, 0.5, 0.5, 0.5), (1, 0, 0), (0, 1, 0)),\n        ((np.sqrt(2) / 2, 0, 0, np.sqrt(2) / 2), (0, 1, 0), (-1, 0, 0)),\n        ((0, 1, 0, 0), (0, 1, 0), (0, -1, 0)),\n        (\n            (0, np.sqrt(3) / 3, np.sqrt(3) / 3, -np.sqrt(3) / 3),\n            (1, 1, 0),\n            (1 / 3, 1 / 3, -4 / 3),\n        ),\n    ],\n)\ndef test_multiply_vector(quaternion, vector, expected):\n    q = Quaternion(quaternion)\n    v = Vector3d(vector)\n    v_new = q * v\n    assert np.allclose(v_new.data, expected)\n\n\ndef test_check_quat():\n    """""" check is an oddly named function""""""\n    quat = Quaternion([2, 2, 2, 2])\n    assert np.allclose(quat.data, check_quaternion(quat).data)\n\n\ndef test_abcd():\n    quat = Quaternion([2, 2, 2, 2])\n    quat.a = 1\n    quat.b = 1\n    quat.c = 1\n    quat.d = 1\n    assert np.allclose(quat.data, 1)\n\n\ndef test_mean(quaternion):\n    _ = quaternion.mean()\n    return None\n\n\ndef test_antipodal(quaternion):\n    _ = quaternion.antipodal\n    return None\n\n\n@pytest.mark.xfail(strict=True, reason=""NotImplemented"")\ndef test_edgecase_outer(quaternion):\n    threetwoq = quaternion.outer([3, 2])\n\n\n@pytest.mark.xfail(strict=True, reason=""NotImplemented"")\ndef test_failing_mul(quaternion):\n    quaternion * ""cant-mult-by-this""\n'"
orix/tests/test_rotation.py,49,"b'from math import cos, sin, tan, pi\nimport numpy as np\nimport pytest\n\nfrom orix.quaternion import Quaternion\nfrom orix.quaternion.rotation import Rotation\nfrom orix.vector import Vector3d\n\nrotations = [\n    (0.707, 0.0, 0.0, 0.707),\n    (0.5, -0.5, -0.5, 0.5),\n    (0.0, 0.0, 0.0, 1.0),\n    (1.0, 1.0, 1.0, 1.0),\n    ((0.5, -0.5, -0.5, 0.5), (0.0, 0.0, 0.0, 1.0),),\n    Rotation([(2, 4, 6, 8), (-1, -2, -3, -4)]),\n    np.array((4, 3, 2, 1)),\n]\n\nquaternions = [\n    (0.881, 0.665, 0.123, 0.517),\n    (0.111, 0.222, 0.333, 0.444),\n    ((1, 0, 0.5, 0), (3, 1, -1, -2),),\n    [\n        [[0.343, 0.343, 0, -0.333], [-7, -8, -9, -10],],\n        [[0.00001, -0.0001, 0.001, -0.01], [0, 0, 0, 0]],\n    ],\n]\n\nvectors = [(1, 0, 0), (1, 1, 0), (0.7, 0.8, 0.9), [[1, 1, 1], [0.4, 0.5, -0.6],]]\n\n\n@pytest.fixture(params=rotations)\ndef rotation(request):\n    return Rotation(request.param)\n\n\nrotation_2 = rotation\n\n\n@pytest.fixture(params=quaternions)\ndef quaternion(request):\n    return Quaternion(request.param)\n\n\n@pytest.fixture(params=vectors)\ndef vector(request):\n    return Vector3d(request.param)\n\n\ndef test_init(rotation):\n    assert np.allclose(rotation.norm.data, 1)\n    assert rotation.improper.shape == rotation.shape\n    assert np.all(rotation.improper == False)\n\n\ndef test_slice(rotation):\n    r = rotation[0]\n    assert np.allclose(r.data, rotation.data[0])\n    assert r.improper.shape == r.shape\n\n\ndef test_unit(rotation):\n    assert isinstance(rotation.unit, Rotation)\n    assert np.allclose(rotation.unit.norm.data, 1)\n\n\n@pytest.mark.parametrize(\n    ""rotation, quaternion, expected"",\n    [\n        ([0.5, 0.5, 0.5, 0.5], [1, 0, 0, 0], [0.5, 0.5, 0.5, 0.5]),\n        (\n            [0.5, -0.5, -0.5, 0.5],\n            [0, cos(pi / 4), sin(pi / 4), 0],\n            [cos(pi / 4), 0, sin(pi / 4), 0],\n        ),\n        (\n            [0.794743, 0.50765, -0.33156, 0.0272659],\n            [0.545394, 0.358915, 0.569472, 0.499427],\n            [0.426441, 0.380997, 0.0280051, 0.819881],\n        ),\n    ],\n    indirect=[""rotation"", ""quaternion""],\n)\ndef test_mul_quaternion(rotation, quaternion, expected):\n    r = rotation * quaternion\n    assert isinstance(r, Quaternion)\n    assert np.allclose(r.data, expected)\n    rotation.improper = 1\n    ri = rotation * quaternion\n    assert np.allclose(r.data, ri.data)\n\n\n@pytest.mark.parametrize(\n    ""r1, i1, r2, i2, expected, expected_i"",\n    [\n        ([0.5, 0.5, 0.5, 0.5], 0, [0.5, 0.5, 0.5, 0.5], 0, [-0.5, 0.5, 0.5, 0.5], 0),\n        ([0.5, 0.5, 0.5, 0.5], 1, [0.5, 0.5, 0.5, 0.5], 0, [-0.5, 0.5, 0.5, 0.5], 1),\n        (\n            [0.285883, 0.726947, 0.611896, -0.124108],\n            0,\n            [-0.247817, -0.574353, 0.594154, 0.505654],\n            1,\n            [0.0458731, 0.0387992, -0.278082, 0.958677],\n            1,\n        ),\n        (\n            [tan(pi / 6), 0, -tan(pi / 6), tan(pi / 6)],\n            1,\n            [0.5, -0.5, -0.5, 0.5],\n            1,\n            [-0.288675, -0.288675, -0.866025, 0.288675],\n            0,\n        ),\n    ],\n)\ndef test_mul_rotation(r1, i1, r2, i2, expected, expected_i):\n    r1 = Rotation(r1)\n    r1.improper = i1\n    r2 = Rotation(r2)\n    r2.improper = i2\n    r = r1 * r2\n    assert isinstance(r, Rotation)\n    assert np.allclose(r.data, expected)\n    assert np.all(r.improper == expected_i)\n\n\n@pytest.mark.parametrize(\n    ""rotation, i, vector, expected"",\n    [\n        ([0.5, 0.5, 0.5, 0.5], 0, [1, 1, 0], [0, 1, 1]),\n        ([0.5, 0.5, 0.5, 0.5], 1, [1, 1, 0], [0, -1, -1]),\n        (\n            [-0.172767, -0.346157, 0.664402, -0.63945],\n            0,\n            [0.237425, -0.813408, 0.531034],\n            [0.500697, -0.524764, 0.688422],\n        ),\n        (\n            [-0.172767, -0.346157, 0.664402, -0.63945],\n            1,\n            [0.237425, -0.813408, 0.531034],\n            [-0.500697, 0.524764, -0.688422],\n        ),\n    ],\n    indirect=[""rotation"", ""vector""],\n)\ndef test_mul_vector(rotation, i, vector, expected):\n    rotation.improper = i\n    v = rotation * vector\n    assert isinstance(v, Vector3d)\n    assert np.allclose(v.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""rotation, i, number, expected_i"",\n    [\n        ([0.5, 0.5, 0.5, 0.5], 0, 1, 0),\n        ([0.5, 0.5, 0.5, 0.5], 1, 1, 1),\n        ([0.5, 0.5, 0.5, 0.5], 1, -1, 0),\n        ([[0, 1, 0, 0], [0, 0, 1, 0]], [0, 1], [-1, 1], [1, 1]),\n        ([[0, 1, 0, 0], [0, 0, 1, 0]], [1, 0], [-1, 1], [0, 0]),\n        pytest.param([0.5, 0.5, 0.5, 0.5], 1, 2, 0, marks=pytest.mark.xfail),\n        pytest.param(\n            [0.545394, 0.358915, 0.569472, 0.499427], 0, -2, 0, marks=pytest.mark.xfail\n        ),\n    ],\n    indirect=[""rotation""],\n)\ndef test_mul_number(rotation, i, number, expected_i):\n    rotation.improper = i\n    r = rotation * number\n    assert np.allclose(rotation.data, r.data)\n    assert np.allclose(r.improper, expected_i)\n\n\n@pytest.mark.xfail(strict=True, reason=TypeError)\ndef test_mul_failing(rotation):\n    _ = rotation * ""cant-mult-by-this""\n\n\n@pytest.mark.parametrize(\n    ""rotation, i, expected_i"",\n    [([0.5, 0.5, 0.5, 0.5], 0, 1), ([0.5, 0.5, 0.5, 0.5], 1, 0),],\n    indirect=[""rotation""],\n)\ndef test_neg(rotation, i, expected_i):\n    rotation.improper = i\n    r = -rotation\n    assert np.allclose(r.improper, expected_i)\n\n\n"""""" these tests address .to_euler() and .from_euler()""""""\n\n\n@pytest.fixture()\ndef e():\n    e = np.random.rand(10, 3)\n    return e\n\n\ndef test_to_from_euler(e):\n    """""" Checks that going euler2quat2euler gives no change """"""\n    r = Rotation.from_euler(e)\n    e2 = r.to_euler()\n    assert np.allclose(e.data, e2.data)\n\n\ndef test_direction_kwarg(e):\n    r = Rotation.from_euler(e, direction=""lab2crystal"")\n\n\ndef test_Krakow_Hielscher(e):\n    r = Rotation.from_euler(e, convention=""Krakow_Hielscher"")\n\n\n@pytest.mark.xfail()\ndef test_direction_kwarg_dumb(e):\n    r = Rotation.from_euler(e, direction=""dumb_direction"")\n\n\n@pytest.mark.xfail()\ndef test_unsupported_conv_to(e):\n    r = Rotation.from_euler(e)\n    r.to_euler(convention=""unsupported"")\n\n\n@pytest.mark.xfail()\ndef test_unsupported_conv_from(e):\n    r = Rotation.from_euler(e, convention=""unsupported"")\n\n\ndef test_edge_cases_to_euler():\n    x = np.sqrt(1 / 2)\n    q = Rotation(np.asarray([x, 0, 0, x]))\n    e = q.to_euler()\n    q = Rotation(np.asarray([0, x, 0, 0]))\n    e = q.to_euler()\n\n\n@pytest.mark.parametrize(\n    ""rotation, improper, expected, improper_expected"",\n    [\n        (\n            np.array([[0.5, 0.5, 0.5, 0.5], [1, 0, 0, 1],]),\n            [0, 0],\n            np.array([[0.5, 0.5, 0.5, 0.5], [0.707106, 0, 0, 0.707106],]),\n            [0, 0],\n        ),\n        (\n            np.array([[0.5, 0.5, 0.5, 0.5], [1, 0, 0, 1],]),\n            [0, 1],\n            np.array([[0.5, 0.5, 0.5, 0.5], [0.707106, 0, 0, 0.707106],]),\n            [0, 1],\n        ),\n        (\n            np.array([[0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5],]),\n            [0, 0],\n            np.array([[0.5, 0.5, 0.5, 0.5],]),\n            [0],\n        ),\n        (\n            np.array([[0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5],]),\n            [0, 1],\n            np.array([[0.5, 0.5, 0.5, 0.5], [0.5, 0.5, 0.5, 0.5],]),\n            [0, 1],\n        ),\n    ],\n    indirect=[""rotation""],\n)\ndef test_unique(rotation, improper, expected, improper_expected):\n    rotation.improper = improper\n    u = rotation.unique()\n    assert np.allclose(u.data, expected, atol=1e-6)\n    assert np.allclose(u.improper, improper_expected)\n\n\ndef test_kwargs_unique(rotation):\n    """""" return_index and return_inverse edge cases""""""\n    rotation.unique(return_index=True, return_inverse=True)\n    rotation.unique(return_index=True, return_inverse=False)\n    rotation.unique(return_index=False, return_inverse=True)\n\n\n@pytest.mark.parametrize(\n    ""rotation, improper, expected, improper_expected"",\n    [\n        (\n            np.array(\n                [\n                    [0.231386, 0.270835, 0.779474, 0.515294],\n                    [-0.515294, -0.779474, 0.270835, 0.231386],\n                ]\n            ),\n            [0, 1],\n            np.array(\n                [\n                    [0.231386, -0.270835, -0.779474, -0.515294],\n                    [-0.515294, 0.779474, -0.270835, -0.231386],\n                ]\n            ),\n            [0, 1],\n        ),\n    ],\n    indirect=[""rotation""],\n)\ndef test_inv(rotation, improper, expected, improper_expected):\n    rotation.improper = improper\n    r = ~rotation\n    assert np.allclose(r.data, expected, atol=1e-6)\n    assert np.allclose(r.improper, improper_expected)\n\n\n@pytest.mark.parametrize(\n    ""rotation, improper, rotation_2, improper_2, expected"",\n    [\n        (\n            np.array(\n                [\n                    [-0.192665, -0.7385, 0.605678, -0.22506],\n                    [0.194855, -0.0613995, 0.814759, -0.542614],\n                    [-0.440859, -0.61701, -0.305151, 0.576042],\n                ]\n            ),\n            [0, 0, 0],\n            np.array(\n                [\n                    [0.311833, -0.670051, -0.635546, -0.22332],\n                    [-0.0608553, -0.380776, -0.662, 0.642699],\n                ]\n            ),\n            [0, 1],\n            np.array([[0.1001, 0], [0.2947, 0], [0.3412, 0],]),\n        ),\n        (\n            np.array(\n                [\n                    [\n                        [0.75175, 0.250266, -0.352737, 0.49781],\n                        [0.242073, -0.698966, 0.315235, -0.594537],\n                        [0.46822, 0.43453, -0.653468, 0.40612],\n                        [0.472186, -0.414235, -0.552524, -0.547875],\n                        [0.767081, -0.320688, 0.0707849, 0.551122],\n                    ],\n                    [\n                        [-0.507603, -0.63199, -0.441212, 0.385045],\n                        [0.775813, 0.122649, -0.616902, -0.0500386],\n                        [0.243256, 0.243706, 0.919676, 0.18876],\n                        [0.472742, 0.453436, 0.677063, -0.335405],\n                        [0.0951788, -0.0223328, 0.924478, -0.368487],\n                    ],\n                ]\n            ),\n            np.array([[1, 0, 0, 1, 0], [1, 1, 0, 1, 1]]),\n            np.array(\n                [\n                    [0.733623, -0.289254, -0.51314, -0.338846],\n                    [0.654535, 0.491901, 0.544886, -0.180876],\n                    [0.529135, 0.166796, -0.329274, 0.764051],\n                ]\n            ),\n            [0, 0, 1],\n            np.array(\n                [\n                    [\n                        [0, 0, 0.9360],\n                        [0.4195, 0.0939, 0],\n                        [0.4155, 0.0907, 0],\n                        [0, 0, 0.0559],\n                        [0.4324, 0.2832, 0],\n                    ],\n                    [\n                        [0, 0, 0.0655],\n                        [0, 0, 0.5959],\n                        [0.4279, 0.7461, 0],\n                        [0, 0, 0.1534],\n                        [0, 0, 0.5393],\n                    ],\n                ]\n            ),\n        ),\n    ],\n    indirect=[""rotation"", ""rotation_2""],\n)\ndef test_dot_outer_rot(rotation, improper, rotation_2, improper_2, expected):\n    rotation.improper = improper\n    rotation_2.improper = improper_2\n    cosines = rotation.dot_outer(rotation_2)\n    assert cosines.shape == rotation.shape + rotation_2.shape\n    assert np.allclose(cosines.data, expected, atol=1e-4)\n\n\n@pytest.mark.parametrize(\n    ""rotation, improper, quaternion, expected"",\n    [\n        (\n            np.array(\n                [\n                    [0.915014, 0.033423, -0.292416, 0.275909],\n                    [0.117797, -0.260041, -0.54774, 0.786437],\n                    [0.301376, 0.818476, 0.482242, 0.0819321],\n                ]\n            ),\n            [0, 0, 1],\n            np.array(\n                [\n                    [0.15331, -0.0110295, -0.17113, 0.973185],\n                    [0.969802, 0.089686, 0.186519, -0.12904],\n                ]\n            ),\n            np.array([[0.4585, 0.8002], [0.8800, 0.1127], [0, 0],]),\n        ),\n    ],\n    indirect=[""rotation"", ""quaternion""],\n)\ndef test_dot_outer_quat(rotation, improper, quaternion, expected):\n    rotation.improper = improper\n    cosines = rotation.dot_outer(quaternion)\n    assert cosines.shape == rotation.shape + quaternion.shape\n    assert np.allclose(cosines.data, expected, atol=1e-4)\n\n\n@pytest.mark.parametrize(\n    ""rotation, expected"",\n    [\n        ([1, 0, 0, 0], [0, 0, 1]),\n        ([-1, 0, 0, 0], [0, 0, -1]),\n        ([0, 0.5 ** 0.5, 0.5 ** 0.5, 0], [0.5 ** 0.5, 0.5 ** 0.5, 0]),\n        ([[1, 0, 0, 0], [-1, 0, 0, 0],], [[0, 0, 1], [0, 0, -1]]),\n    ],\n    indirect=[""rotation""],\n)\ndef test_axis(rotation, expected):\n    ax = rotation.axis\n    assert np.allclose(ax.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""rotation, improper"",\n    [([(1, 0, 0, 0), (1, 0, 0, 0)], [0, 1]), ([(0.5 ** 0.5, 0, 0, 0.5 ** 0.5)], [1]),],\n)\ndef test_antipodal(rotation, improper):\n    rotation = Rotation(rotation)\n    rotation.improper = improper\n    a = rotation.antipodal\n    assert np.allclose(a[0].data, rotation.data)\n    assert np.allclose(a[1].data, -rotation.data)\n    assert np.allclose(a[0].improper, rotation.improper)\n    assert np.allclose(a[1].improper, rotation.improper)\n\n\n@pytest.mark.parametrize(""shape, reference"", [((1,), (1, 0, 0, 0))])\ndef test_random_vonmises(shape, reference):\n    r = Rotation.random_vonmises(shape, 1.0, reference)\n    assert r.shape == shape\n    assert isinstance(r, Rotation)\n'"
orix/tests/test_rotation_plot.py,1,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\nfrom orix.plot.rotation_plot import RodriguesPlot, AxAnglePlot\nfrom orix.quaternion.orientation import Misorientation\nfrom orix.quaternion.symmetry import D6, C1\nfrom orix.quaternion.orientation_region import OrientationRegion\n\n\ndef test_init_RodriguesPlot():\n    fig = plt.figure(figsize=(3, 3))\n    _ = RodriguesPlot(fig)\n    return None\n\n\ndef test_init_AxAnglePlot():\n    fig = plt.figure(figsize=(3, 3))\n    _ = AxAnglePlot(fig)\n    return None\n\n\ndef test_RotationPlot_methods():\n    """""" This code is lifted from demo-3-v0.1 """"""\n    misori = Misorientation([1, 1, 1, 1])  # any will do\n    fig = plt.figure(figsize=(6, 3))\n    gridspec = plt.GridSpec(1, 1, left=0, right=1, bottom=0, top=1, hspace=0.05)\n    ax_misori = fig.add_subplot(\n        gridspec[0], projection=""axangle"", proj_type=""ortho"", aspect=""equal""\n    )\n    ax_misori.scatter(misori)\n    ax_misori.plot(misori)\n    ax_misori.plot_wireframe(OrientationRegion.from_symmetry(D6, D6))\n    plt.close(""all"")\n\n    # clear the edge case\n    ax_misori.transform(np.asarray([1, 1, 1]))\n    return None\n\n\ndef test_full_region_plot():\n    empty = OrientationRegion.from_symmetry(C1, C1)\n    _ = empty.get_plot_data()\n'"
orix/tests/test_scalar.py,26,"b'import pytest\nimport numpy as np\n\nfrom orix.scalar import Scalar\nfrom orix.vector import Vector3d\n\n\n@pytest.fixture(params=[(1,)])\ndef scalar(request):\n    return Scalar(request.param)\n\n\n@pytest.mark.parametrize(\n    ""data, expected"",\n    [\n        ((5, 3), (5, 3)),\n        ([[1], [2]], [[1], [2]]),\n        (np.array([1, 2, 3, 4, 5]), [1, 2, 3, 4, 5]),\n        (Scalar([-1, 1]), [-1, 1]),\n    ],\n)\ndef test_init(data, expected):\n    scalar = Scalar(data)\n    assert np.allclose(scalar.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, expected"", [(1, -1), ((1, -1), (-1, 1))], indirect=[""scalar""]\n)\ndef test_neg(scalar, expected):\n    neg = -scalar\n    assert np.allclose(neg.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 2),\n        ((1, 2), (2, -1), (3, 1)),\n        ([[0, -1], [4, 2]], 0.5, [[0.5, -0.5], [4.5, 2.5]]),\n        ((4,), np.array([[-1, -1], [-1, -1]]), [[3, 3], [3, 3]]),\n        ((-1,), Scalar((1,)), [0]),\n        pytest.param(0.5, ""frederick"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_add(scalar, other, expected):\n    sum = scalar + other\n    assert np.allclose(sum.data, expected)\n    sum2 = other + scalar\n    assert np.allclose(sum.data, sum2.data)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 0),\n        ((1, 2), (2, -1), (-1, 3)),\n        ([[0, -1], [4, 2]], 0.5, [[-0.5, -1.5], [3.5, 1.5]]),\n        ((4,), np.array([[-1, -2], [1, -1]]), [[5, 6], [3, 5]]),\n        ((-1,), Scalar((1,)), [-2]),\n        pytest.param(0.5, ""frederick"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_sub(scalar, other, expected):\n    sub = scalar - other\n    assert np.allclose(sub.data, expected)\n    sub2 = other - scalar\n    assert np.allclose(sub.data, -sub2.data)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 1),\n        ((1, 2), (2, -1), (2, -2)),\n        ([[0, -1], [4, 2]], 0.5, [[0, -0.5], [2, 1]]),\n        ((4,), np.array([[-1, -2], [1, -1]]), [[-4, -8], [4, -4]]),\n        ((-1,), Scalar((1,)), [-1]),\n        pytest.param(0.5, ""frederick"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_mul(scalar, other, expected):\n    mul = scalar * other\n    assert np.allclose(mul.data, expected)\n    mul2 = other * scalar\n    assert np.allclose(mul.data, mul2.data)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        pytest.param(1, 1, 0, marks=pytest.mark.xfail),\n        ((2, 2), (2, -1), (1, 0)),\n        ([[0.5, -1], [4, 2]], 0.5, [[1, 0], [0, 0]]),\n        ((4,), np.array([[-1, -2], [4, -1]]), [[0, 0], [1, 0]]),\n        ([5], Scalar([5]), 1),\n        ([5], Scalar([6]), 0),\n        pytest.param([3], ""larry"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_equality(scalar, other, expected):\n    eq = scalar == other\n    assert np.allclose(eq, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        pytest.param(1, 1, 0, marks=pytest.mark.xfail),\n        ((1, 2), (2, -1), (0, 1)),\n        ([[0, -1], [4, 2]], 0.5, [[0, 0], [1, 1]]),\n        ((4,), np.array([[-1, -2], [1, -1]]), [[1, 1], [1, 1]]),\n        ([5], Scalar([6]), 0),\n        pytest.param([3], ""larry"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_inequality(scalar, other, expected):\n    gt = scalar > other\n    assert np.allclose(gt, expected)\n    lt = scalar < other\n    assert np.allclose(gt, ~lt)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 1),\n        ((1, 2), (2, -1), (0, 1)),\n        ([[0, -1], [4, 2]], 0.5, [[0, 0], [1, 1]]),\n        ((1,), np.array([[-1, -2], [1, -1]]), [[1, 1], [1, 1]]),\n        ([5], Scalar([5]), 1),\n        ([5], Scalar([6]), 0),\n        pytest.param([3], ""larry"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_ge(scalar, other, expected):\n    gt = scalar >= other\n    assert np.allclose(gt, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 1),\n        ((1, 2), (2, -1), (1, 0)),\n        ([[0, -1], [4, 2]], 0.5, [[1, 1], [0, 0]]),\n        ((1,), np.array([[-1, -2], [1, -1]]), [[0, 0], [1, 0]]),\n        ([5], Scalar([5]), 1),\n        ([5], Scalar([6]), 1),\n        pytest.param([3], ""larry"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_le(scalar, other, expected):\n    le = scalar <= other\n    assert np.allclose(le, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, other, expected"",\n    [\n        (1, 1, 1),\n        ((1.0, 2.0), (2, -1), (1, 0.5)),\n        ([[0, -1], [4, 2]], 2, [[0, 1], [16, 4]]),\n        ((4.0,), np.array([[-1, -2], [1, -1]]), [[0.25, 0.0625], [4, 0.25]]),\n        pytest.param([3], ""larry"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_pow(scalar, other, expected):\n    pow = scalar ** other\n    assert np.allclose(pow.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""scalar, expected"",\n    [((1, 1, 1), (3,)), ([[0, -1], [4, 2]], (2, 2)), ([[5, 1, 0]], (1, 3)),],\n    indirect=[""scalar""],\n)\ndef test_shape(scalar, expected):\n    shape = scalar.shape\n    assert shape == expected\n\n\n@pytest.mark.parametrize(\n    ""scalar, shape, expected"",\n    [\n        ((1, 1, 1), (3, 1), np.array([[1], [1], [1]])),\n        ([[0, -1], [4, 2]], (4,), [0, -1, 4, 2]),\n        pytest.param([[0, -1], [4, 2]], (3,), [0, -1, 4], marks=pytest.mark.xfail),\n    ],\n    indirect=[""scalar""],\n)\ndef test_reshape(scalar, shape, expected):\n    s = scalar.reshape(*shape)\n    assert s.shape == shape\n    assert np.allclose(s.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""data, expected"",\n    [\n        (\n            [Scalar([[1, 2], [3, 4]]), Scalar([[5, 6], [7, 8]])],\n            [[[1, 5], [2, 6]], [[3, 7], [4, 8]]],\n        ),\n    ],\n)\ndef test_stack(data, expected):\n    stack = Scalar.stack(data)\n    assert isinstance(stack, Scalar)\n    assert stack.shape[-1] == len(data)\n    assert np.allclose(stack.data, expected)\n\n\ndef test_flatten(scalar):\n    scalar.flatten()\n    return None\n\n\n@pytest.mark.xfail(strict=True, reason=TypeError)\nclass TestSpareNotImplemented:\n    def test_radd_notimplemented(self, scalar):\n        ""cantadd"" + scalar\n\n    def test_rsub_notimplemented(self, scalar):\n        ""cantsub"" - scalar\n\n    def test_rmul_notimplemented(self, scalar):\n        ""cantmul"" * scalar\n\n    def test_lt_notimplemented(self, scalar):\n        scalar < ""cantlt""\n'"
orix/tests/test_spherical_region.py,2,"b'import pytest\nimport numpy as np\n\nfrom orix.vector import Vector3d\nfrom orix.vector.spherical_region import SphericalRegion\n\n\n@pytest.fixture(params=[(0, 0, 1)])\ndef spherical_region(request):\n    return SphericalRegion(request.param)\n\n\n@pytest.fixture(params=[(0, 0, 1)])\ndef vector(request):\n    return Vector3d(request.param)\n\n\n@pytest.mark.parametrize(\n    ""spherical_region, vector, expected"",\n    [\n        ([0, 0, 1], [[0, 0, 0.5], [0, 0, -0.5], [0, 1, 0]], [True, False, False]),\n        ([[0, 0, 1], [0, 1, 0]], [[0, 1, 1], [0, 0, 1]], [True, False]),\n    ],\n    indirect=[""spherical_region"", ""vector""],\n)\ndef test_gt(spherical_region, vector, expected):\n    inside = vector < spherical_region\n    assert np.all(np.equal(inside, expected))\n\n\n@pytest.mark.parametrize(\n    ""spherical_region, vector, expected"",\n    [\n        ([0, 0, 1], [[0, 0, 0.5], [0, 0, -0.5], [0, 1, 0]], [True, False, True]),\n        ([[0, 0, 1], [0, 1, 0]], [[0, 1, 1], [0, 0, 1]], [True, True]),\n    ],\n    indirect=[""spherical_region"", ""vector""],\n)\ndef test_ge(spherical_region, vector, expected):\n    inside = vector <= spherical_region\n    assert np.all(np.equal(inside, expected))\n'"
orix/tests/test_symmetry.py,2,"b'import pytest\n\nfrom orix.quaternion.symmetry import *\nfrom orix.vector import Vector3d\n\n\n@pytest.fixture(params=[(1, 2, 3)])\ndef vector(request):\n    return Vector3d(request.param)\n\n\n@pytest.mark.parametrize(\n    ""symmetry, vector, expected"",\n    [\n        (Ci, (1, 2, 3), [(1, 2, 3), (-1, -2, -3)]),\n        (Csx, (1, 2, 3), [(1, 2, 3), (-1, 2, 3)]),\n        (Csy, (1, 2, 3), [(1, 2, 3), (1, -2, 3)]),\n        (Csz, (1, 2, 3), [(1, 2, 3), (1, 2, -3)]),\n        (C2, (1, 2, 3), [(1, 2, 3), (-1, -2, 3)]),\n        (C2v, (1, 2, 3), [(1, 2, 3), (1, -2, 3), (1, -2, -3), (1, 2, -3),]),\n        (\n            C4v,\n            (1, 2, 3),\n            [\n                (1, 2, 3),\n                (-2, 1, 3),\n                (-1, -2, 3),\n                (2, -1, 3),\n                (-1, 2, 3),\n                (2, 1, 3),\n                (-2, -1, 3),\n                (1, -2, 3),\n            ],\n        ),\n        (\n            D4,\n            (1, 2, 3),\n            [\n                (1, 2, 3),\n                (-2, 1, 3),\n                (-1, -2, 3),\n                (2, -1, 3),\n                (-1, 2, -3),\n                (2, 1, -3),\n                (-2, -1, -3),\n                (1, -2, -3),\n            ],\n        ),\n        (\n            C6,\n            (1, 2, 3),\n            [\n                (1, 2, 3),\n                (-1.232, 1.866, 3),\n                (-2.232, -0.134, 3),\n                (-1, -2, 3),\n                (1.232, -1.866, 3),\n                (2.232, 0.134, 3),\n            ],\n        ),\n        (\n            Td,\n            (1, 2, 3),\n            [\n                (1, 2, 3),\n                (3, 1, 2),\n                (2, 3, 1),\n                (-2, -1, 3),\n                (3, -2, -1),\n                (-1, 3, -2),\n                (2, -1, -3),\n                (-3, 2, -1),\n                (-1, -3, 2),\n                (1, -2, -3),\n                (-3, 1, -2),\n                (-2, -3, 1),\n                (-1, -2, 3),\n                (3, -1, -2),\n                (-2, 3, -1),\n                (2, 1, 3),\n                (3, 2, 1),\n                (1, 3, 2),\n                (-2, 1, -3),\n                (-3, -2, 1),\n                (1, -3, -2),\n                (-1, 2, -3),\n                (-3, -1, 2),\n                (2, -3, -1),\n            ],\n        ),\n        (\n            Oh,\n            (1, 2, 3),\n            [\n                (1, 2, 3),\n                (3, 1, 2),\n                (2, 3, 1),\n                (2, 1, -3),\n                (-3, 2, 1),\n                (1, -3, 2),\n                (-2, 1, 3),\n                (3, -2, 1),\n                (1, 3, -2),\n                (1, -2, -3),\n                (-3, 1, -2),\n                (-2, -3, 1),\n                (-1, -2, 3),\n                (3, -1, -2),\n                (-2, 3, -1),\n                (-2, -1, -3),\n                (-3, -2, -1),\n                (-1, -3, -2),\n                (2, -1, 3),\n                (3, 2, -1),\n                (-1, 3, 2),\n                (-1, 2, -3),\n                (-3, -1, 2),\n                (2, -3, -1),\n                (-1, -2, -3),\n                (-3, -1, -2),\n                (-2, -3, -1),\n                (-2, -1, 3),\n                (3, -2, -1),\n                (-1, 3, -2),\n                (2, -1, -3),\n                (-3, 2, -1),\n                (-1, -3, 2),\n                (-1, 2, 3),\n                (3, -1, 2),\n                (2, 3, -1),\n                (1, 2, -3),\n                (-3, 1, 2),\n                (2, -3, 1),\n                (2, 1, 3),\n                (3, 2, 1),\n                (1, 3, 2),\n                (-2, 1, -3),\n                (-3, -2, 1),\n                (1, -3, -2),\n                (1, -2, 3),\n                (3, 1, -2),\n                (-2, 3, 1),\n            ],\n        ),\n    ],\n    indirect=[""vector""],\n)\ndef test_symmetry(symmetry, vector, expected):\n    vector_calculated = [\n        tuple(v.round(3)) for v in symmetry.outer(vector).unique().data\n    ]\n    print(""Expected\\n"", expected)\n    print(""Calculated\\n"", vector_calculated)\n    print(symmetry.improper)\n    assert set(vector_calculated) == set(expected)\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [(C2h, 4), (C6, 6), (D6h, 24), (T, 12), (Td, 24), (Oh, 48), (O, 24)],\n)\ndef test_order(symmetry, expected):\n    assert symmetry.order == expected\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"", [(D2d, False), (C4, True), (C6v, False), (O, True),]\n)\ndef test_is_proper(symmetry, expected):\n    assert symmetry.is_proper == expected\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [\n        (C1, [C1]),\n        (D2, [C1, C2x, C2y, C2z, D2]),\n        (C6v, [C1, Csx, Csy, C2z, C3, C3v, C6, C6v]),\n    ],\n)\ndef test_subgroups(symmetry, expected):\n    print(len(symmetry.subgroups))\n    assert set(symmetry.subgroups) == set(expected)\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [(C1, [C1]), (D2, [C1, C2x, C2y, C2z, D2]), (C6v, [C1, C2z, C3, C6]),],\n)\ndef test_proper_subgroups(symmetry, expected):\n    assert set(symmetry.proper_subgroups) == set(expected)\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [\n        (C1, C1),\n        (Ci, C1),\n        (C2, C2),\n        (Cs, C1),\n        (C2h, C2),\n        (D2, D2),\n        (C2v, C2x),\n        (C4, C4),\n        (C4h, C4),\n        (C3h, C3),\n        (C6v, C6),\n        (D3h, D3y),\n        (T, T),\n        (Td, T),\n        (Oh, O),\n    ],\n)\ndef test_proper_subgroup(symmetry, expected):\n    assert symmetry.proper_subgroup._tuples == expected._tuples\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [\n        (C1, Ci),\n        (Ci, Ci),\n        (C2, C2h),\n        (C2h, C2h),\n        (C4, C4h),\n        (C4h, C4h),\n        (D4, D4h),\n        (D4h, D4h),\n        (C6v, D6h),\n        (D6h, D6h),\n        (T, Th),\n        (Td, Oh),\n    ],\n)\ndef test_laue(symmetry, expected):\n    assert symmetry.laue._tuples == expected._tuples\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"", [(Cs, C2), (C4v, D4), (Th, T), (Td, O), (O, O), (Oh, O),]\n)\ndef test_proper_inversion_subgroup(symmetry, expected):\n    print(""Expected\\n"", expected)\n    print(""Calculated\\n"", symmetry.laue_proper_subgroup)\n    assert symmetry.laue_proper_subgroup._tuples == expected._tuples\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [\n        (C1, False),\n        (Ci, True),\n        (Cs, False),\n        (C2, False),\n        (C2h, True),\n        (D4, False),\n        (D2d, False),\n        (D3d, True),\n        (C6, False),\n        (C3h, False),\n        (Td, False),\n        (Oh, True),\n    ],\n)\ndef test_contains_inversion(symmetry, expected):\n    assert symmetry.contains_inversion == expected\n\n\n@pytest.mark.parametrize(\n    ""symmetry, other, expected"",\n    [(D2, C1, [C1]), (C1, C1, [C1]), (D2, C2, [C1, C2z]), (C4, S4, [C1, C2z]),],\n)\ndef test_and(symmetry, other, expected):\n    overlap = symmetry & other\n    expected = Symmetry.from_generators(*expected)\n    assert overlap._tuples == expected._tuples\n\n\n@pytest.mark.parametrize(\n    ""symmetry, other, expected"", [(C1, C1, True), (C1, C2, False),]\n)\ndef test_eq(symmetry, other, expected):\n    assert (symmetry == other) == expected\n\n\n@pytest.mark.parametrize(\n    ""symmetry, expected"",\n    [\n        (C1, np.zeros((0, 3))),\n        (C2, [0, 1, 0]),\n        (D2, [[0, 1, 0], [0, 0, 1]]),\n        (C4, [[0, 1, 0], [1, 0, 0]]),\n        (\n            T,\n            [\n                [0.5 ** 0.5, -(0.5 ** 0.5), 0],\n                [0, -(0.5 ** 0.5), 0.5 ** 0.5],\n                [0, 0.5 ** 0.5, 0.5 ** 0.5],\n                [0.5 ** 0.5, 0.5 ** 0.5, 0],\n            ],\n        ),\n    ],\n)\ndef test_fundamental_sector(symmetry, expected):\n    fs = symmetry.fundamental_sector()\n    assert np.allclose(fs.data, expected)\n\n\ndef test_no_symm_fundemental_sector():\n    nosym = Symmetry.from_generators(Rotation([1, 0, 0, 0]))\n    nosym.fundamental_sector()\n'"
orix/tests/test_symmetry_data.py,0,"b'data = [\n    (""1"", [[1, 0, 0, 0],], [0,]),\n    (""-1"", [[1, 0, 0, 0], [1, 0, 0, 0],], [0, 1,]),\n    (""2"", [[1, 0, 0, 0], [0, 0, 1, 0],], [0, 0,]),\n    (""m"", [[1, 0, 0, 0], [0, 0, 1, 0],], [0, 1,]),\n    (""2/m"", [[1, 0, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 1, 0],], [0, 0, 1, 1,]),\n    (""222"", [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, -1, 0],], [0, 0, 0, 0,]),\n    (""mm2"", [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, -1, 0],], [0, 1, 0, 1,]),\n    (\n        ""mmm"",\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [0, 0, -1, 0],\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0, 0, 0, 1],\n            [0, 0, -1, 0],\n        ],\n        [0, 0, 0, 0, 1, 1, 1, 1,],\n    ),\n    (""3"", [[1, 0, 0, 0], [0.5, 0, 0, 0.866], [-0.5, 0, 0, 0.866],], [0, 0, 0,]),\n    (\n        ""-3"",\n        [\n            [1, 0, 0, 0],\n            [0.5, 0, 0, 0.866],\n            [-0.5, 0, 0, 0.866],\n            [1, 0, 0, 0],\n            [0.5, 0, 0, 0.866],\n            [-0.5, 0, 0, 0.866],\n        ],\n        [0, 0, 0, 1, 1, 1,],\n    ),\n    (\n        ""32"",\n        [\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n        ],\n        [0, 0, 0, 0, 0, 0,],\n    ),\n    (\n        ""3m"",\n        [\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n        ],\n        [0, 1, 0, 1, 0, 1,],\n    ),\n    (\n        ""-3m"",\n        [\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n        ],\n        [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,],\n    ),\n    (\n        ""-42m"",\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0.7071, 0, 0, 0.7071],\n            [0, 0.7071, -0.7071, 0],\n            [0, 0, 0, 1],\n            [0, 0, -1, 0],\n            [-0.7071, 0, 0, 0.7071],\n            [0, -0.7071, -0.7071, 0],\n        ],\n        [0, 0, 1, 1, 0, 0, 1, 1,],\n    ),\n    (\n        ""4/mmm"",\n        [\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0.7071, 0, 0, 0.7071],\n            [0, 0.7071, -0.7071, 0],\n            [0, 0, 0, 1],\n            [0, 0, -1, 0],\n            [-0.7071, 0, 0, 0.7071],\n            [0, -0.7071, -0.7071, 0],\n            [1, 0, 0, 0],\n            [0, 1, 0, 0],\n            [0.7071, 0, 0, 0.7071],\n            [0, 0.7071, -0.7071, 0],\n            [0, 0, 0, 1],\n            [0, 0, -1, 0],\n            [-0.7071, 0, 0, 0.7071],\n            [0, -0.7071, -0.7071, 0],\n        ],\n        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,],\n    ),\n    (\n        ""622"",\n        [\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.866, 0, 0, 0.5],\n            [0, 0.5, -0.866, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1],\n            [0, -0.5, -0.866, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n            [-0.866, 0, 0, 0.5],\n            [0, -1, 0, 0],\n        ],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,],\n    ),\n    (\n        ""-62m"",\n        [\n            [1, 0, 0, 0],\n            [0, 0.866, -0.5, 0],\n            [0.866, 0, 0, 0.5],\n            [0, 0.5, -0.866, 0],\n            [0.5, 0, 0, 0.866],\n            [0, 0, -1, 0],\n            [0, 0, 0, 1],\n            [0, -0.5, -0.866, 0],\n            [-0.5, 0, 0, 0.866],\n            [0, -0.866, -0.5, 0],\n            [-0.866, 0, 0, 0.5],\n            [0, -1, 0, 0],\n        ],\n        [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1,],\n    ),\n    (\n        ""23"",\n        [\n            [1, 0, 0, 0],\n            [0.5, 0.5, 0.5, 0.5],\n            [-0.5, 0.5, 0.5, 0.5],\n            [0, 1, 0, 0],\n            [-0.5, 0.5, 0.5, -0.5],\n            [-0.5, -0.5, 0.5, -0.5],\n            [0, 0, 0, 1],\n            [-0.5, 0.5, -0.5, 0.5],\n            [-0.5, 0.5, -0.5, -0.5],\n            [0, 0, -1, 0],\n            [0.5, 0.5, -0.5, -0.5],\n            [0.5, 0.5, 0.5, -0.5],\n        ],\n        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,],\n    ),\n]\n'"
orix/tests/test_vector3d.py,36,"b'from math import pi\nimport numpy as np\nimport pytest\n\nfrom orix.vector import Vector3d, check_vector\nfrom orix.scalar import Scalar\n\nvectors = [\n    (1, 0, 0),\n    (0, 0, 1),\n    ((0.5, 0.5, 0.5), (-1, 0, 0),),\n    [[[-0.707, 0.707, 1], [2, 2, 2]], [[0.1, -0.3, 0.2], [-5, -6, -7]],],\n    np.random.rand(3),\n]\n\nsingles = [\n    (1, -1, 1),\n    (-5, -5, -6),\n    [[9, 9, 9], [0.001, 0.0001, 0.00001],],\n    np.array(\n        [[[0.5, 0.25, 0.125], [-0.125, 0.25, 0.5]], [[1, 2, 4], [1, -0.3333, 0.1667]],]\n    ),\n]\n\nnumbers = [-12, 0.5, -0.333333333, 4]\n\n\n@pytest.fixture(params=vectors)\ndef vector(request):\n    return Vector3d(request.param)\n\n\n@pytest.fixture(params=singles)\ndef something(request):\n    return Vector3d(request.param)\n\n\n@pytest.fixture(params=numbers)\ndef number(request):\n    return request.param\n\n\ndef test_check_vector():\n    vector3 = Vector3d([2, 2, 2])\n    assert np.allclose(vector3.data, check_vector(vector3).data)\n\n\ndef test_neg(vector):\n    assert np.all((-vector).data == -(vector.data))\n\n\n@pytest.mark.parametrize(\n    ""vector, other, expected"",\n    [\n        ([1, 2, 3], Vector3d([[1, 2, 3], [-3, -2, -1]]), [[2, 4, 6], [-2, 0, 2]]),\n        ([1, 2, 3], Scalar([4]), [5, 6, 7]),\n        ([1, 2, 3], 0.5, [1.5, 2.5, 3.5]),\n        ([1, 2, 3], [-1, 2], [[0, 1, 2], [3, 4, 5]]),\n        ([1, 2, 3], np.array([-1, 1]), [[0, 1, 2], [2, 3, 4]]),\n        pytest.param([1, 2, 3], ""dracula"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""vector""],\n)\ndef test_add(vector, other, expected):\n    s1 = vector + other\n    s2 = other + vector\n    assert np.allclose(s1.data, expected)\n    assert np.allclose(s1.data, s2.data)\n\n\n@pytest.mark.parametrize(\n    ""vector, other, expected"",\n    [\n        ([1, 2, 3], Vector3d([[1, 2, 3], [-3, -2, -1]]), [[0, 0, 0], [4, 4, 4]]),\n        ([1, 2, 3], Scalar([4]), [-3, -2, -1]),\n        ([1, 2, 3], 0.5, [0.5, 1.5, 2.5]),\n        ([1, 2, 3], [-1, 2], [[2, 3, 4], [-1, 0, 1]]),\n        ([1, 2, 3], np.array([-1, 1]), [[2, 3, 4], [0, 1, 2]]),\n        pytest.param([1, 2, 3], ""dracula"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""vector""],\n)\ndef test_sub(vector, other, expected):\n    s1 = vector - other\n    s2 = other - vector\n    assert np.allclose(s1.data, expected)\n    assert np.allclose(-s1.data, s2.data)\n\n\n@pytest.mark.parametrize(\n    ""vector, other, expected"",\n    [\n        pytest.param(\n            [1, 2, 3],\n            Vector3d([[1, 2, 3], [-3, -2, -1]]),\n            [[0, 0, 0], [4, 4, 4]],\n            marks=pytest.mark.xfail(raises=ValueError),\n        ),\n        ([1, 2, 3], Scalar([4]), [4, 8, 12]),\n        ([1, 2, 3], 0.5, [0.5, 1.0, 1.5]),\n        ([1, 2, 3], [-1, 2], [[-1, -2, -3], [2, 4, 6]]),\n        ([1, 2, 3], np.array([-1, 1]), [[-1, -2, -3], [1, 2, 3]]),\n        pytest.param([1, 2, 3], ""dracula"", None, marks=pytest.mark.xfail),\n    ],\n    indirect=[""vector""],\n)\ndef test_mul(vector, other, expected):\n    s1 = vector * other\n    s2 = other * vector\n    assert np.allclose(s1.data, expected)\n    assert np.allclose(s1.data, s2.data)\n\n\ndef test_dot(vector, something):\n    assert np.allclose(vector.dot(vector).data, (vector.data ** 2).sum(axis=-1))\n    assert np.allclose(vector.dot(something).data, something.dot(vector).data)\n\n\ndef test_dot_error(vector, number):\n    with pytest.raises(ValueError):\n        vector.dot(number)\n\n\ndef test_dot_outer(vector, something):\n    d = vector.dot_outer(something).data\n    assert d.shape == vector.shape + something.shape\n    for i in np.ndindex(vector.shape):\n        for j in np.ndindex(something.shape):\n            assert np.allclose(d[i + j], vector[i].dot(something[j]).data)\n\n\ndef test_cross(vector, something):\n    assert isinstance(vector.cross(something), Vector3d)\n\n\ndef test_cross_error(vector, number):\n    with pytest.raises(AttributeError):\n        vector.cross(number)\n\n\n@pytest.mark.parametrize(\n    ""theta, phi, r, expected"",\n    [\n        (np.pi / 4, np.pi / 4, 1, Vector3d((0.5, 0.5, 0.707107))),\n        (2 * np.pi / 3, 7 * np.pi / 6, 1, Vector3d((-0.75, -0.433013, -0.5))),\n    ],\n)\ndef test_polar(theta, phi, r, expected):\n    assert np.allclose(\n        Vector3d.from_polar(theta, phi, r).data, expected.data, atol=1e-5\n    )\n\n\n@pytest.mark.parametrize(""shape"", [(1,), (2, 2), (5, 4, 3),])\ndef test_zero(shape):\n    v = Vector3d.zero(shape)\n    assert v.shape == shape\n    assert v.data.shape[-1] == v.dim\n\n\ndef test_angle_with(vector, something):\n    a = vector.angle_with(vector).data\n    assert np.allclose(a, 0)\n    a = vector.angle_with(something).data\n    assert np.all(a >= 0)\n    assert np.all(a <= np.pi)\n\n\ndef test_mul_array(vector):\n    array = np.random.rand(*vector.shape)\n    m1 = vector * array\n    m2 = array * vector\n    assert isinstance(m1, Vector3d)\n    assert isinstance(m2, Vector3d)\n    assert np.all(m1.data == m2.data)\n\n\n@pytest.mark.parametrize(\n    ""vector, x, y, z"",\n    [([1, 2, 3], 1, 2, 3), ([[0, 2, 3], [2, 2, 3]], [0, 2], [2, 2], [3, 3]),],\n    indirect=[""vector""],\n)\ndef test_xyz(vector, x, y, z):\n    vx, vy, vz = vector.xyz\n    assert np.allclose(vx, x)\n    assert np.allclose(vy, y)\n    assert np.allclose(vz, z)\n\n\n@pytest.mark.parametrize(\n    ""vector, rotation, expected"",\n    [\n        ((1, 0, 0), pi / 2, (0, 1, 0)),\n        ((1, 1, 0), pi / 2, (-1, 1, 0)),\n        (\n            (1, 1, 0),\n            [pi / 2, pi, 3 * pi / 2, 2 * pi],\n            [(-1, 1, 0), (-1, -1, 0), (1, -1, 0), (1, 1, 0)],\n        ),\n        ((1, 1, 1), -pi / 2, (1, -1, 1)),\n    ],\n    indirect=[""vector""],\n)\ndef test_rotate(vector, rotation, expected):\n    r = Vector3d(vector).rotate(Vector3d.zvector(), rotation)\n    assert isinstance(r, Vector3d)\n    assert np.allclose(r.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""vector, data, expected"",\n    [\n        ([1, 2, 3], 3, [3, 2, 3]),\n        ([[0, 2, 3], [2, 2, 3]], 1, [[1, 2, 3], [1, 2, 3]]),\n        ([[0, 2, 3], [2, 2, 3]], [-1, 1], [[-1, 2, 3], [1, 2, 3]]),\n    ],\n    indirect=[""vector""],\n)\ndef test_assign_x(vector, data, expected):\n    vector.x = data\n    assert np.allclose(vector.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""vector, data, expected"",\n    [\n        ([1, 2, 3], 3, [1, 3, 3]),\n        ([[0, 2, 3], [2, 2, 3]], 1, [[0, 1, 3], [2, 1, 3]]),\n        ([[0, 2, 3], [2, 2, 3]], [-1, 1], [[0, -1, 3], [2, 1, 3]]),\n    ],\n    indirect=[""vector""],\n)\ndef test_assign_y(vector, data, expected):\n    vector.y = data\n    assert np.allclose(vector.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""vector, data, expected"",\n    [\n        ([1, 2, 3], 1, [1, 2, 1]),\n        ([[0, 2, 3], [2, 2, 3]], 1, [[0, 2, 1], [2, 2, 1]]),\n        ([[0, 2, 3], [2, 2, 3]], [-1, 1], [[0, 2, -1], [2, 2, 1]]),\n    ],\n    indirect=[""vector""],\n)\ndef test_assign_z(vector, data, expected):\n    vector.z = data\n    assert np.allclose(vector.data, expected)\n\n\n@pytest.mark.parametrize(\n    ""vector"", [[(1, 0, 0)], [(0.5, 0.5, 1.25), (-1, -1, -1)],], indirect=[""vector""]\n)\ndef test_perpendicular(vector: Vector3d):\n    assert np.allclose(vector.dot(vector.perpendicular).data, 0)\n\n\ndef test_mean_xyz():\n    x = Vector3d.xvector()\n    y = Vector3d.yvector()\n    z = Vector3d.zvector()\n    t = Vector3d([3 * x.data, 3 * y.data, 3 * z.data])\n    np.allclose(t.mean().data, 1)\n\n\n@pytest.mark.xfail(strict=True, reason=ValueError)\ndef test_zero_perpendicular():\n    t = Vector3d(np.asarray([0, 0, 0]))\n    tperp = t.perpendicular()\n\n\n@pytest.mark.xfail(strict=True, reason=TypeError)\nclass TestSpareNotImplemented:\n    def test_radd_notimplemented(self, vector):\n        ""cantadd"" + vector\n\n    def test_rsub_notimplemented(self, vector):\n        ""cantsub"" - vector\n\n    def test_rmul_notimplemented(self, vector):\n        ""cantmul"" * vector\n'"
orix/vector/__init__.py,43,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Three-dimensional quantities.\n\nVectors can represent positions in three-dimensional space and are also\ncommonly associated with motion, possessing both a magnitude and a direction.\nIn orix they are often encountered as derived objects such as the rotation\naxis of a quaternion or the normal to the bounding planes of a spherical\nregion.\n\nSubmodules\n==========\n\n.. autosummary::\n    :toctree: _autosummary\n\n    neo_euler\n    spherical_region\n\nMembers\n=======\n\n""""""\nimport numpy as np\nfrom orix.base import check, Object3d\nfrom orix.scalar import Scalar\n\n\ndef check_vector(obj):\n    return check(obj, Vector3d)\n\n\nclass Vector3d(Object3d):\n    """"""Vector base class.\n\n    Vectors support the following mathematical operations:\n\n    - Unary negation.\n    - Addition to other vectors, scalars, numbers, and compatible\n      array-like objects.\n    - Subtraction to and from the above.\n    - Multiplication to scalars, numbers, and compatible array-like objects.\n\n    Examples\n    --------\n    >>> v = Vector3d((1, 2, 3))\n    >>> w = Vector3d(np.array([[1, 0, 0], [0, 1, 1]]))\n\n    >>> w.x\n    Scalar (2,)\n    [1 0]\n\n    >>> v.unit\n    Vector3d (1,)\n    [[ 0.2673  0.5345  0.8018]]\n\n    >>> -v\n    Vector3d (1,)\n    [[-1 -2 -3]]\n\n    >>> v + w\n    Vector3d (2,)\n    [[2 2 3]\n     [1 3 4]]\n\n    >>> w - (2, -3)\n    Vector3d (2,)\n    [[-1 -2 -2]\n     [ 3  4  4]]\n\n    >>> 3 * v\n    Vector3d (1,)\n    [[3 6 9]]\n    """"""\n\n    dim = 3\n\n    def __neg__(self):\n        return self.__class__(-self.data)\n\n    def __add__(self, other):\n        if isinstance(other, Vector3d):\n            return self.__class__(self.data + other.data)\n        elif isinstance(other, Scalar):\n            return self.__class__(self.data + other.data[..., np.newaxis])\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data + other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data + other[..., np.newaxis])\n        return NotImplemented\n\n    def __radd__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(other.data[..., np.newaxis] + self.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(other + self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other[..., np.newaxis] + self.data)\n        return NotImplemented\n\n    def __sub__(self, other):\n        if isinstance(other, Vector3d):\n            return self.__class__(self.data - other.data)\n        elif isinstance(other, Scalar):\n            return self.__class__(self.data - other.data[..., np.newaxis])\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data - other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data - other[..., np.newaxis])\n        return NotImplemented\n\n    def __rsub__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(other.data[..., np.newaxis] - self.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(other - self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other[..., np.newaxis] - self.data)\n        return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, Vector3d):\n            raise ValueError(\n                ""Multiplying one vector with another is ambiguous. ""\n                ""Try `.dot` or `.cross` instead.""\n            )\n        elif isinstance(other, Scalar):\n            return self.__class__(self.data * other.data[..., np.newaxis])\n        elif isinstance(other, (int, float)):\n            return self.__class__(self.data * other)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(self.data * other[..., np.newaxis])\n        return NotImplemented\n\n    def __rmul__(self, other):\n        if isinstance(other, Scalar):\n            return self.__class__(other.data[..., np.newaxis] * self.data)\n        elif isinstance(other, (int, float)):\n            return self.__class__(other * self.data)\n        elif isinstance(other, (list, tuple)):\n            other = np.array(other)\n        if isinstance(other, np.ndarray):\n            return self.__class__(other[..., np.newaxis] * self.data)\n        return NotImplemented\n\n    def dot(self, other):\n        """"""The dot product of a vector with another vector.\n\n        Vectors must have compatible shape.\n\n        Returns\n        -------\n        Scalar\n\n        Examples\n        --------\n        >>> v = Vector3d((0, 0, 1.0))\n        >>> w = Vector3d(((0, 0, 0.5), (0.4, 0.6, 0)))\n        >>> v.dot(w)\n        Scalar (2,)\n        [ 0.5  0. ]\n        >>> w.dot(v)\n        Scalar (2,)\n        [ 0.5  0. ]\n        """"""\n        if not isinstance(other, Vector3d):\n            raise ValueError(""{} is not a vector!"".format(other))\n        return Scalar(np.sum(self.data * other.data, axis=-1))\n\n    def dot_outer(self, other):\n        """"""The outer dot product of a vector with another vector.\n\n        The dot product for every combination of vectors in `self` and `other`\n        is computed.\n\n        Returns\n        -------\n        Scalar\n\n        Examples\n        --------\n        >>> v = Vector3d(((0.0, 0.0, 1.0), (1.0, 0.0, 0.0)))  # shape = (2, )\n        >>> w = Vector3d(((0.0, 0.0, 0.5), (0.4, 0.6, 0.0), (0.5, 0.5, 0.5)))  # shape = (3, )\n        >>> v.dot_outer(w)\n        Scalar (2, 3)\n        [[ 0.5  0.   0.5]\n         [ 0.   0.4  0.5]]\n        >>> w.dot_outer(v)  # shape = (3, 2)\n        Scalar (3, 2)\n        [[ 0.5  0. ]\n         [ 0.   0.4]\n         [ 0.5  0.5]]\n\n        """"""\n        dots = np.tensordot(self.data, other.data, axes=(-1, -1))\n        return Scalar(dots)\n\n    def cross(self, other):\n        """"""The cross product of a vector with another vector.\n\n        Vectors must have compatible shape for broadcasting to work.\n\n        Returns\n        -------\n        Vector3d\n            The class of \'other\' is preserved.\n\n        Examples\n        --------\n        >>> v = Vector3d(((1, 0, 0), (-1, 0, 0)))\n        >>> w = Vector3d((0, 1, 0))\n        >>> v.cross(w)\n        Vector3d (2,)\n        [[ 0  0  1]\n         [ 0  0 -1]]\n\n        """"""\n        return other.__class__(np.cross(self.data, other.data))\n\n    @classmethod\n    def from_polar(cls, theta, phi, r=1):\n        """"""Creates a Vector3d object from polar data.\n        Parameters\n        ----------\n        theta : array_like\n            The polar angle, in radians.\n        phi : array_like\n            The azimuthal angle, in radians.\n        r : array_like\n            The radial distance. Defaults to 1 to produce unit vectors.\n        Returns\n        -------\n        Vector3d\n        """"""\n        theta = np.atleast_1d(theta)\n        phi = np.atleast_1d(phi)\n        z = np.cos(theta)\n        y = np.sin(phi) * np.sin(theta)\n        x = np.cos(phi) * np.sin(theta)\n        return r * cls(np.stack((x, y, z), axis=-1))\n\n    @classmethod\n    def zero(cls, shape=(1,)):\n        """"""Returns zero vectors in the specified shape.\n\n        Parameters\n        ----------\n        shape : tuple\n\n        Returns\n        -------\n        Vector3d\n\n        """"""\n        return cls(np.zeros(shape + (cls.dim,)))\n\n    @classmethod\n    def xvector(cls):\n        """"""Vector3d : a single unit vector parallel to the x-direction.""""""\n        return cls((1, 0, 0))\n\n    @classmethod\n    def yvector(cls):\n        """"""Vector3d : a single unit vector parallel to the y-direction.""""""\n        return cls((0, 1, 0))\n\n    @classmethod\n    def zvector(cls):\n        """"""Vector3d : a single unit vector parallel to the z-direction.""""""\n        return cls((0, 0, 1))\n\n    @property\n    def x(self):\n        """"""Scalar : This vector\'s x data.""""""\n        return Scalar(self.data[..., 0])\n\n    @x.setter\n    def x(self, value):\n        self.data[..., 0] = value\n\n    @property\n    def y(self):\n        """"""Scalar : This vector\'s y data.""""""\n        return Scalar(self.data[..., 1])\n\n    @y.setter\n    def y(self, value):\n        self.data[..., 1] = value\n\n    @property\n    def z(self):\n        """"""Scalar : This vector\'s z data.""""""\n        return Scalar(self.data[..., 2])\n\n    @z.setter\n    def z(self, value):\n        self.data[..., 2] = value\n\n    @property\n    def xyz(self):\n        """"""tuple of ndarray : This vector\'s components, useful for plotting.""""""\n        return self.x.data, self.y.data, self.z.data\n\n    def angle_with(self, other):\n        """"""Calculate the angles between vectors in \'self\' and \'other\'\n\n        Vectors must have compatible shapes for broadcasting to work.\n\n        Returns\n        -------\n        Scalar\n            The angle between the vectors, in radians.\n\n        """"""\n        cosines = np.round(self.dot(other).data / self.norm.data / other.norm.data, 9)\n        return Scalar(np.arccos(cosines))\n\n    def rotate(self, axis=None, angle=0):\n        """"""Convenience function for rotating this vector.\n\n        Shapes of \'axis\' and \'angle\' must be compatible with shape of this\n        vector for broadcasting.\n\n        Parameters\n        ----------\n        axis : Vector3d or array_like, optional\n            The axis of rotation. Defaults to the z-vector.\n        angle : array_like, optional\n            The angle of rotation, in radians.\n\n        Returns\n        -------\n        Vector3d\n            A new vector with entries rotated.\n\n        Examples\n        --------\n        >>> from math import pi\n        >>> v = Vector3d((0, 1, 0))\n        >>> axis = Vector3d((0, 0, 1))\n        >>> angles = [0, pi/4, pi/2, 3*pi/4, pi]\n        >>> v.rotate(axis=axis, angle=angles)\n\n\n        """"""\n        from orix.quaternion.rotation import Rotation\n        from orix.vector.neo_euler import AxAngle\n\n        axis = Vector3d.zvector() if axis is None else axis\n        angle = 0 if angle is None else angle\n        q = Rotation.from_neo_euler(AxAngle.from_axes_angles(axis, angle))\n        return q * self\n\n    @property\n    def perpendicular(self):\n        if np.any(self.x.data == 0) and np.any(self.y.data == 0):\n            if np.any(self.z.data == 0):\n                raise ValueError(""Contains zero vectors!"")\n            return Vector3d.xvector()\n        x = -self.y.data\n        y = self.x.data\n        z = np.zeros_like(x)\n        return Vector3d(np.stack((x, y, z), axis=-1))\n\n    def get_nearest(self, x, inclusive=False, tiebreak=None):\n        """"""The vector among x with the smallest angle to this one.\n\n        Parameters\n        ----------\n        x : Vector3d\n        inclusive : bool\n            if False (default) vectors exactly parallel to this will not be\n            considered.\n        tiebreak : Vector3d\n            If multiple vectors are equally close to this one, `tiebreak` will\n            be used as a secondary comparison. By default equal to (0, 0, 1).\n\n        Returns\n        -------\n        Vector3d\n\n        """"""\n        assert self.size == 1, ""`get_nearest` only works for single vectors.""\n        tiebreak = Vector3d.zvector() if tiebreak is None else tiebreak\n        eps = 1e-9 if inclusive else 0.0\n        cosines = x.dot(self).data\n        mask = np.logical_and(-1 - eps < cosines, cosines < 1 + eps)\n        x = x[mask]\n        if x.size == 0:\n            return Vector3d.empty()\n        cosines = cosines[mask]\n        verticality = x.dot(tiebreak).data\n        order = np.lexsort((cosines, verticality))\n        return x[order[-1]]\n\n    @property\n    def _tuples(self):\n        """"""set of tuple : the set of comparable vectors.""""""\n        s = self.flatten()\n        tuples = set([tuple(d) for d in s.data])\n        return tuples\n\n    def mean(self):\n        axis = tuple(range(self.data_dim))\n        return self.__class__(self.data.mean(axis=axis))\n'"
orix/vector/neo_euler.py,8,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Neo-Eulerian vectors parametrize rotations as vectors.\n\nThe rotation is specified by an axis of rotation and an angle. Different\nneo-Eulerian vectors have different scaling functions applied to the angle\nof rotation for different properties of the space. For example, the axis-angle\nrepresentation does not scale the angle of rotation, making it easy for direct\ninterpretation, whereas the Rodrigues representation applies a scaled tangent\nfunction, such that any straight lines in Rodrigues space represent rotations\nabout a fixed axis.\n\n""""""\nimport abc\n\nimport numpy as np\nfrom orix.scalar import Scalar\nfrom orix.vector import Vector3d\n\n\nclass NeoEuler(Vector3d, abc.ABC):\n    """"""Base class for neo-Eulerian vectors.\n\n    """"""\n\n    @classmethod\n    @abc.abstractmethod\n    def from_rotation(cls, rotation):  # pragma: no cover\n        """"""NeoEuler : Create a new vector from the given rotation.""""""\n        pass\n\n    @property\n    @abc.abstractmethod\n    def angle(self):  # pragma: no cover\n        """"""Scalar : the angle of rotation.""""""\n        pass\n\n    @property\n    def axis(self):\n        """"""Vector3d : the axis of rotation.""""""\n        return Vector3d(self.unit)\n\n\nclass Homochoric(NeoEuler):\n    """"""Equal-volume mapping of the unit quaternion hemisphere.\n\n    The homochoric vector representing a rotation with rotation angle\n    :math:`\\\\theta` has magnitude\n    :math:`\\\\left[\\\\frac{3}{4}(\\\\theta - \\\\sin\\\\theta)\\\\right]^{\\\\frac{1}{3}}`.\n\n    Notes\n    -----\n    The homochoric transformation has no analytical inverse.\n\n    """"""\n\n    @classmethod\n    def from_rotation(cls, rotation):\n        theta = rotation.angle.data\n        n = rotation.axis\n        magnitude = (0.75 * (theta - np.sin(theta))) ** (1 / 3)\n        return cls(n * magnitude)\n\n    @property\n    def angle(self):\n        raise AttributeError(\n            ""The angle of a homochoric vector cannot be determined analytically.""\n        )\n\n\nclass Rodrigues(NeoEuler):\n    """"""In Rodrigues space, straight lines map to rotations about a fixed axis.\n\n    The Rodrigues vector representing a rotation with rotation angle\n    :math:`\\\\theta` has magnitude :math:`\\\\tan\\\\frac{\\\\theta}{2}`.\n\n    """"""\n\n    @classmethod\n    def from_rotation(cls, rotation):\n        a = np.float64(rotation.a.data)\n        with np.errstate(divide=""ignore"", invalid=""ignore""):\n            data = np.stack(\n                (rotation.b.data / a, rotation.c.data / a, rotation.d.data / a), axis=-1\n            )\n        data[np.isnan(data)] = 0\n        r = cls(data)\n        return r\n\n    @property\n    def angle(self):\n        return Scalar(np.arctan(self.norm.data) * 2)\n\n\nclass AxAngle(NeoEuler):\n    """"""The simplest neo-Eulerian representation.\n\n    The Axis-Angle vector representing a rotation with rotation angle\n    :math:`\\\\theta` has magnitude :math:`\\\\theta`\n\n    """"""\n\n    @classmethod\n    def from_rotation(cls, rotation):\n        return cls((rotation.axis * rotation.angle).data)\n\n    @property\n    def angle(self):\n        return Scalar(self.norm.data)\n\n    @classmethod\n    def from_axes_angles(cls, axes, angles):\n        """"""Create new AxAngle object explicitly from the given axes and angles.\n\n        Parameters\n        ----------\n        axes : Vector3d or array_like\n            The axis of rotation.\n        angles : array_like\n            The angle of rotation, in radians.\n\n        Returns\n        -------\n        AxAngle\n\n        """"""\n        axes = Vector3d(axes).unit\n        angles = np.array(angles)\n        axangle_data = angles[..., np.newaxis] * axes.data\n        return cls(axangle_data)\n'"
orix/vector/spherical_region.py,2,"b'# -*- coding: utf-8 -*-\n# Copyright 2018-2019 The pyXem developers\n#\n# This file is part of orix.\n#\n# orix is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# orix is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with orix.  If not, see <http://www.gnu.org/licenses/>.\n\n""""""Vectors describing a segment of a sphere.\n\nEach entry represents a plane normal in 3-d. Vectors can lie in, on, or outside\nthe spherical region.\n\n.. image:: /_static/img/spherical-region-D3.png\n   :width: 200px\n   :alt: Representation of the planes comprising a spherical region.\n   :align: center\n\nExamples\n--------\n\n>>> sr = SphericalRegion([0, 0, 1])  # Region above the x-y plane\n>>> v = Vector3d([(0, 0, 1), (0, 0, -1), (1, 0, 0)])\n>>> v < sr\narray([ True, False, False], dtype=bool)\n>>> v <= sr\narray([ True, False,  True], dtype=bool)\n\n""""""\nimport numpy as np\n\nfrom orix.vector import Vector3d\n\n\nclass SphericalRegion(Vector3d):\n    """"""A set of vectors representing normals segmenting a sphere.\n\n    """"""\n\n    def __gt__(self, x):\n        """"""Returns True where x is strictly inside the region.\n\n        Parameters\n        ----------\n        x : Vector3d\n\n        Returns\n        -------\n        ndarray\n\n        """"""\n        return np.all(self.dot_outer(x) > 1e-9, axis=0)\n\n    def __ge__(self, x):\n        """"""Returns True if x is inside the region or one of the bounding planes.\n\n        Parameters\n        ----------\n        x : Vector3d\n\n        Returns\n        -------\n        ndarray\n\n        """"""\n        return np.all(self.dot_outer(x) > -1e-9, axis=0)\n'"
