file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\nfrom setuptools import setup, find_packages\nimport versioneer\nimport sys\n\nlong_description = \'\'\n\nif \'upload\' in sys.argv:\n    with open(\'README.rst\') as f:\n        long_description = f.read()\n\ninstall_reqs = [\n    \'matplotlib>=1.4.0\',\n    \'numpy>=1.9.1\',\n    \'pandas>=0.18.0\',\n    \'scipy>=0.14.0\',\n    \'seaborn>=0.6.0\',\n    \'statsmodels>=0.6.1\',\n    \'IPython>=3.2.3\',\n    \'empyrical>=0.5.0\',\n]\n\nextra_reqs = {\n    \'test\': [\n        ""nose>=1.3.7"",\n        ""parameterized>=0.5.0"",\n        ""tox>=2.3.1"",\n        ""flake8>=3.7.9"",\n    ],\n}\n\nif __name__ == ""__main__"":\n    setup(\n        name=\'alphalens\',\n        version=versioneer.get_version(),\n        cmdclass=versioneer.get_cmdclass(),\n        description=\'Performance analysis of predictive (alpha) stock factors\',\n        author=\'Quantopian Inc.\',\n        author_email=\'opensource@quantopian.com\',\n        packages=find_packages(include=\'alphalens.*\'),\n        package_data={\n            \'alphalens\': [\'examples/*\'],\n        },\n        long_description=long_description,\n        classifiers=[\n            \'Development Status :: 5 - Production/Stable\',\n            \'Intended Audience :: Developers\',\n            \'License :: OSI Approved :: Apache Software License\',\n            \'Natural Language :: English\',\n            \'Operating System :: OS Independent\',\n            \'Programming Language :: Python :: 2.7\',\n            \'Programming Language :: Python :: 3.4\',\n            \'Programming Language :: Python :: 3.5\',\n            \'Programming Language :: Python\',\n            \'Topic :: Utilities\',\n            \'Topic :: Office/Business :: Financial\',\n            \'Topic :: Scientific/Engineering :: Information Analysis\',\n        ],\n        url=\'https://github.com/quantopian/alphalens\',\n        install_requires=install_reqs,\n        extras_require=extra_reqs,\n    )\n'"
versioneer.py,0,"b'\n# Version: 0.18\n\n""""""The Versioneer - like a rocketeer, but for versions.\n\nThe Versioneer\n==============\n\n* like a rocketeer, but for versions!\n* https://github.com/warner/python-versioneer\n* Brian Warner\n* License: Public Domain\n* Compatible With: python2.6, 2.7, 3.2, 3.3, 3.4, 3.5, 3.6, and pypy\n* [![Latest Version]\n(https://pypip.in/version/versioneer/badge.svg?style=flat)\n](https://pypi.python.org/pypi/versioneer/)\n* [![Build Status]\n(https://travis-ci.org/warner/python-versioneer.png?branch=master)\n](https://travis-ci.org/warner/python-versioneer)\n\nThis is a tool for managing a recorded version number in distutils-based\npython projects. The goal is to remove the tedious and error-prone ""update\nthe embedded version string"" step from your release process. Making a new\nrelease should be as easy as recording a new tag in your version-control\nsystem, and maybe making new tarballs.\n\n\n## Quick Install\n\n* `pip install versioneer` to somewhere to your $PATH\n* add a `[versioneer]` section to your setup.cfg (see below)\n* run `versioneer install` in your source tree, commit the results\n\n## Version Identifiers\n\nSource trees come from a variety of places:\n\n* a version-control system checkout (mostly used by developers)\n* a nightly tarball, produced by build automation\n* a snapshot tarball, produced by a web-based VCS browser, like github\'s\n  ""tarball from tag"" feature\n* a release tarball, produced by ""setup.py sdist"", distributed through PyPI\n\nWithin each source tree, the version identifier (either a string or a number,\nthis tool is format-agnostic) can come from a variety of places:\n\n* ask the VCS tool itself, e.g. ""git describe"" (for checkouts), which knows\n  about recent ""tags"" and an absolute revision-id\n* the name of the directory into which the tarball was unpacked\n* an expanded VCS keyword ($Id$, etc)\n* a `_version.py` created by some earlier build step\n\nFor released software, the version identifier is closely related to a VCS\ntag. Some projects use tag names that include more than just the version\nstring (e.g. ""myproject-1.2"" instead of just ""1.2""), in which case the tool\nneeds to strip the tag prefix to extract the version identifier. For\nunreleased software (between tags), the version identifier should provide\nenough information to help developers recreate the same tree, while also\ngiving them an idea of roughly how old the tree is (after version 1.2, before\nversion 1.3). Many VCS systems can report a description that captures this,\nfor example `git describe --tags --dirty --always` reports things like\n""0.7-1-g574ab98-dirty"" to indicate that the checkout is one revision past the\n0.7 tag, has a unique revision id of ""574ab98"", and is ""dirty"" (it has\nuncommitted changes.\n\nThe version identifier is used for multiple purposes:\n\n* to allow the module to self-identify its version: `myproject.__version__`\n* to choose a name and prefix for a \'setup.py sdist\' tarball\n\n## Theory of Operation\n\nVersioneer works by adding a special `_version.py` file into your source\ntree, where your `__init__.py` can import it. This `_version.py` knows how to\ndynamically ask the VCS tool for version information at import time.\n\n`_version.py` also contains `$Revision$` markers, and the installation\nprocess marks `_version.py` to have this marker rewritten with a tag name\nduring the `git archive` command. As a result, generated tarballs will\ncontain enough information to get the proper version.\n\nTo allow `setup.py` to compute a version too, a `versioneer.py` is added to\nthe top level of your source tree, next to `setup.py` and the `setup.cfg`\nthat configures it. This overrides several distutils/setuptools commands to\ncompute the version when invoked, and changes `setup.py build` and `setup.py\nsdist` to replace `_version.py` with a small static file that contains just\nthe generated version data.\n\n## Installation\n\nSee [INSTALL.md](./INSTALL.md) for detailed installation instructions.\n\n## Version-String Flavors\n\nCode which uses Versioneer can learn about its version string at runtime by\nimporting `_version` from your main `__init__.py` file and running the\n`get_versions()` function. From the ""outside"" (e.g. in `setup.py`), you can\nimport the top-level `versioneer.py` and run `get_versions()`.\n\nBoth functions return a dictionary with different flavors of version\ninformation:\n\n* `[\'version\']`: A condensed version string, rendered using the selected\n  style. This is the most commonly used value for the project\'s version\n  string. The default ""pep440"" style yields strings like `0.11`,\n  `0.11+2.g1076c97`, or `0.11+2.g1076c97.dirty`. See the ""Styles"" section\n  below for alternative styles.\n\n* `[\'full-revisionid\']`: detailed revision identifier. For Git, this is the\n  full SHA1 commit id, e.g. ""1076c978a8d3cfc70f408fe5974aa6c092c949ac"".\n\n* `[\'date\']`: Date and time of the latest `HEAD` commit. For Git, it is the\n  commit date in ISO 8601 format. This will be None if the date is not\n  available.\n\n* `[\'dirty\']`: a boolean, True if the tree has uncommitted changes. Note that\n  this is only accurate if run in a VCS checkout, otherwise it is likely to\n  be False or None\n\n* `[\'error\']`: if the version string could not be computed, this will be set\n  to a string describing the problem, otherwise it will be None. It may be\n  useful to throw an exception in setup.py if this is set, to avoid e.g.\n  creating tarballs with a version string of ""unknown"".\n\nSome variants are more useful than others. Including `full-revisionid` in a\nbug report should allow developers to reconstruct the exact code being tested\n(or indicate the presence of local changes that should be shared with the\ndevelopers). `version` is suitable for display in an ""about"" box or a CLI\n`--version` output: it can be easily compared against release notes and lists\nof bugs fixed in various releases.\n\nThe installer adds the following text to your `__init__.py` to place a basic\nversion in `YOURPROJECT.__version__`:\n\n    from ._version import get_versions\n    __version__ = get_versions()[\'version\']\n    del get_versions\n\n## Styles\n\nThe setup.cfg `style=` configuration controls how the VCS information is\nrendered into a version string.\n\nThe default style, ""pep440"", produces a PEP440-compliant string, equal to the\nun-prefixed tag name for actual releases, and containing an additional ""local\nversion"" section with more detail for in-between builds. For Git, this is\nTAG[+DISTANCE.gHEX[.dirty]] , using information from `git describe --tags\n--dirty --always`. For example ""0.11+2.g1076c97.dirty"" indicates that the\ntree is like the ""1076c97"" commit but has uncommitted changes ("".dirty""), and\nthat this commit is two revisions (""+2"") beyond the ""0.11"" tag. For released\nsoftware (exactly equal to a known tag), the identifier will only contain the\nstripped tag, e.g. ""0.11"".\n\nOther styles are available. See [details.md](details.md) in the Versioneer\nsource tree for descriptions.\n\n## Debugging\n\nVersioneer tries to avoid fatal errors: if something goes wrong, it will tend\nto return a version of ""0+unknown"". To investigate the problem, run `setup.py\nversion`, which will run the version-lookup code in a verbose mode, and will\ndisplay the full contents of `get_versions()` (including the `error` string,\nwhich may help identify what went wrong).\n\n## Known Limitations\n\nSome situations are known to cause problems for Versioneer. This details the\nmost significant ones. More can be found on Github\n[issues page](https://github.com/warner/python-versioneer/issues).\n\n### Subprojects\n\nVersioneer has limited support for source trees in which `setup.py` is not in\nthe root directory (e.g. `setup.py` and `.git/` are *not* siblings). The are\ntwo common reasons why `setup.py` might not be in the root:\n\n* Source trees which contain multiple subprojects, such as\n  [Buildbot](https://github.com/buildbot/buildbot), which contains both\n  ""master"" and ""slave"" subprojects, each with their own `setup.py`,\n  `setup.cfg`, and `tox.ini`. Projects like these produce multiple PyPI\n  distributions (and upload multiple independently-installable tarballs).\n* Source trees whose main purpose is to contain a C library, but which also\n  provide bindings to Python (and perhaps other langauges) in subdirectories.\n\nVersioneer will look for `.git` in parent directories, and most operations\nshould get the right version string. However `pip` and `setuptools` have bugs\nand implementation details which frequently cause `pip install .` from a\nsubproject directory to fail to find a correct version string (so it usually\ndefaults to `0+unknown`).\n\n`pip install --editable .` should work correctly. `setup.py install` might\nwork too.\n\nPip-8.1.1 is known to have this problem, but hopefully it will get fixed in\nsome later version.\n\n[Bug #38](https://github.com/warner/python-versioneer/issues/38) is tracking\nthis issue. The discussion in\n[PR #61](https://github.com/warner/python-versioneer/pull/61) describes the\nissue from the Versioneer side in more detail.\n[pip PR#3176](https://github.com/pypa/pip/pull/3176) and\n[pip PR#3615](https://github.com/pypa/pip/pull/3615) contain work to improve\npip to let Versioneer work correctly.\n\nVersioneer-0.16 and earlier only looked for a `.git` directory next to the\n`setup.cfg`, so subprojects were completely unsupported with those releases.\n\n### Editable installs with setuptools <= 18.5\n\n`setup.py develop` and `pip install --editable .` allow you to install a\nproject into a virtualenv once, then continue editing the source code (and\ntest) without re-installing after every change.\n\n""Entry-point scripts"" (`setup(entry_points={""console_scripts"": ..})`) are a\nconvenient way to specify executable scripts that should be installed along\nwith the python package.\n\nThese both work as expected when using modern setuptools. When using\nsetuptools-18.5 or earlier, however, certain operations will cause\n`pkg_resources.DistributionNotFound` errors when running the entrypoint\nscript, which must be resolved by re-installing the package. This happens\nwhen the install happens with one version, then the egg_info data is\nregenerated while a different version is checked out. Many setup.py commands\ncause egg_info to be rebuilt (including `sdist`, `wheel`, and installing into\na different virtualenv), so this can be surprising.\n\n[Bug #83](https://github.com/warner/python-versioneer/issues/83) describes\nthis one, but upgrading to a newer version of setuptools should probably\nresolve it.\n\n### Unicode version strings\n\nWhile Versioneer works (and is continually tested) with both Python 2 and\nPython 3, it is not entirely consistent with bytes-vs-unicode distinctions.\nNewer releases probably generate unicode version strings on py2. It\'s not\nclear that this is wrong, but it may be surprising for applications when then\nwrite these strings to a network connection or include them in bytes-oriented\nAPIs like cryptographic checksums.\n\n[Bug #71](https://github.com/warner/python-versioneer/issues/71) investigates\nthis question.\n\n\n## Updating Versioneer\n\nTo upgrade your project to a new release of Versioneer, do the following:\n\n* install the new Versioneer (`pip install -U versioneer` or equivalent)\n* edit `setup.cfg`, if necessary, to include any new configuration settings\n  indicated by the release notes. See [UPGRADING](./UPGRADING.md) for details.\n* re-run `versioneer install` in your source tree, to replace\n  `SRC/_version.py`\n* commit any changed files\n\n## Future Directions\n\nThis tool is designed to make it easily extended to other version-control\nsystems: all VCS-specific components are in separate directories like\nsrc/git/ . The top-level `versioneer.py` script is assembled from these\ncomponents by running make-versioneer.py . In the future, make-versioneer.py\nwill take a VCS name as an argument, and will construct a version of\n`versioneer.py` that is specific to the given VCS. It might also take the\nconfiguration arguments that are currently provided manually during\ninstallation by editing setup.py . Alternatively, it might go the other\ndirection and include code from all supported VCS systems, reducing the\nnumber of intermediate scripts.\n\n\n## License\n\nTo make Versioneer easier to embed, all its code is dedicated to the public\ndomain. The `_version.py` that it creates is also in the public domain.\nSpecifically, both are released under the Creative Commons ""Public Domain\nDedication"" license (CC0-1.0), as described in\nhttps://creativecommons.org/publicdomain/zero/1.0/ .\n\n""""""\n\nfrom __future__ import print_function\ntry:\n    import configparser\nexcept ImportError:\n    import ConfigParser as configparser\nimport errno\nimport json\nimport os\nimport re\nimport subprocess\nimport sys\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_root():\n    """"""Get the project root directory.\n\n    We require that all commands are run from the project root, i.e. the\n    directory that contains setup.py, setup.cfg, and versioneer.py .\n    """"""\n    root = os.path.realpath(os.path.abspath(os.getcwd()))\n    setup_py = os.path.join(root, ""setup.py"")\n    versioneer_py = os.path.join(root, ""versioneer.py"")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        # allow \'python path/to/setup.py COMMAND\'\n        root = os.path.dirname(os.path.realpath(os.path.abspath(sys.argv[0])))\n        setup_py = os.path.join(root, ""setup.py"")\n        versioneer_py = os.path.join(root, ""versioneer.py"")\n    if not (os.path.exists(setup_py) or os.path.exists(versioneer_py)):\n        err = (""Versioneer was unable to run the project root directory. ""\n               ""Versioneer requires setup.py to be executed from ""\n               ""its immediate directory (like \'python setup.py COMMAND\'), ""\n               ""or in a way that lets it use sys.argv[0] to find the root ""\n               ""(like \'python path/to/setup.py COMMAND\')."")\n        raise VersioneerBadRootError(err)\n    try:\n        # Certain runtime workflows (setup.py install/develop in a setuptools\n        # tree) execute all dependencies in a single python process, so\n        # ""versioneer"" may be imported multiple times, and python\'s shared\n        # module-import table will cache the first one. So we can\'t use\n        # os.path.dirname(__file__), as that will find whichever\n        # versioneer.py was first imported, even in later projects.\n        me = os.path.realpath(os.path.abspath(__file__))\n        me_dir = os.path.normcase(os.path.splitext(me)[0])\n        vsr_dir = os.path.normcase(os.path.splitext(versioneer_py)[0])\n        if me_dir != vsr_dir:\n            print(""Warning: build in %s is using versioneer.py from %s""\n                  % (os.path.dirname(me), versioneer_py))\n    except NameError:\n        pass\n    return root\n\n\ndef get_config_from_root(root):\n    """"""Read the project setup.cfg file to determine Versioneer config.""""""\n    # This might raise EnvironmentError (if setup.cfg is missing), or\n    # configparser.NoSectionError (if it lacks a [versioneer] section), or\n    # configparser.NoOptionError (if it lacks ""VCS=""). See the docstring at\n    # the top of versioneer.py for instructions on writing your setup.cfg .\n    setup_cfg = os.path.join(root, ""setup.cfg"")\n    parser = configparser.SafeConfigParser()\n    with open(setup_cfg, ""r"") as f:\n        parser.readfp(f)\n    VCS = parser.get(""versioneer"", ""VCS"")  # mandatory\n\n    def get(parser, name):\n        if parser.has_option(""versioneer"", name):\n            return parser.get(""versioneer"", name)\n        return None\n    cfg = VersioneerConfig()\n    cfg.VCS = VCS\n    cfg.style = get(parser, ""style"") or """"\n    cfg.versionfile_source = get(parser, ""versionfile_source"")\n    cfg.versionfile_build = get(parser, ""versionfile_build"")\n    cfg.tag_prefix = get(parser, ""tag_prefix"")\n    if cfg.tag_prefix in (""\'\'"", \'""""\'):\n        cfg.tag_prefix = """"\n    cfg.parentdir_prefix = get(parser, ""parentdir_prefix"")\n    cfg.verbose = get(parser, ""verbose"")\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\n# these dictionaries contain VCS-specific tools\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen([c] + args, cwd=cwd, env=env,\n                                 stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %s"" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %s"" % (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %s (error)"" % dispcmd)\n            print(""stdout was %s"" % stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\nLONG_VERSION_PY[\'git\'] = \'\'\'\n# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.18 (https://github.com/warner/python-versioneer)\n\n""""""Git implementation of _version.py.""""""\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\n\n\ndef get_keywords():\n    """"""Get the keywords needed to look up the version information.""""""\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = ""%(DOLLAR)sFormat:%%d%(DOLLAR)s""\n    git_full = ""%(DOLLAR)sFormat:%%H%(DOLLAR)s""\n    git_date = ""%(DOLLAR)sFormat:%%ci%(DOLLAR)s""\n    keywords = {""refnames"": git_refnames, ""full"": git_full, ""date"": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_config():\n    """"""Create, populate and return the VersioneerConfig() object.""""""\n    # these strings are filled in when \'setup.py versioneer\' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = ""git""\n    cfg.style = ""%(STYLE)s""\n    cfg.tag_prefix = ""%(TAG_PREFIX)s""\n    cfg.parentdir_prefix = ""%(PARENTDIR_PREFIX)s""\n    cfg.versionfile_source = ""%(VERSIONFILE_SOURCE)s""\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen([c] + args, cwd=cwd, env=env,\n                                 stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %%s"" %% dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %%s"" %% (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %%s (error)"" %% dispcmd)\n            print(""stdout was %%s"" %% stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {""version"": dirname[len(parentdir_prefix):],\n                    ""full-revisionid"": None,\n                    ""dirty"": False, ""error"": None, ""date"": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(""Tried directories %%s but none started with prefix %%s"" %%\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %%d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r\'\\d\', r)])\n        if verbose:\n            print(""discarding \'%%s\', no digits"" %% "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %%s"" %% "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(""picking %%s"" %% r)\n            return {""version"": r,\n                    ""full-revisionid"": keywords[""full""].strip(),\n                    ""dirty"": False, ""error"": None,\n                    ""date"": date}\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {""version"": ""0+unknown"",\n            ""full-revisionid"": keywords[""full""].strip(),\n            ""dirty"": False, ""error"": ""no suitable tags"", ""date"": None}\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root,\n                          hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %%s not under git control"" %% root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(GITS, [""describe"", ""--tags"", ""--dirty"",\n                                          ""--always"", ""--long"",\n                                          ""--match"", ""%%s*"" %% tag_prefix],\n                                   cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\'^(.+)-(\\d+)-g([0-9a-f]+)$\', git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = (""unable to parse git-describe output: \'%%s\'""\n                               %% describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%%s\' doesn\'t start with prefix \'%%s\'""\n                print(fmt %% (full_tag, tag_prefix))\n            pieces[""error""] = (""tag \'%%s\' doesn\'t start with prefix \'%%s\'""\n                               %% (full_tag, tag_prefix))\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""],\n                                    cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%%ci"", ""HEAD""],\n                       cwd=root)[0].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%%d.g%%s"" %% (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%%d.g%%s"" %% (pieces[""distance""],\n                                          pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%%d"" %% pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%%d"" %% pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%%d"" %% pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%%s"" %% pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%%d"" %% pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%%s"" %% pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%%d"" %% pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%%d"" %% pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%%d-g%%s"" %% (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%%d-g%%s"" %% (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {""version"": ""unknown"",\n                ""full-revisionid"": pieces.get(""long""),\n                ""dirty"": None,\n                ""error"": pieces[""error""],\n                ""date"": None}\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%%s\'"" %% style)\n\n    return {""version"": rendered, ""full-revisionid"": pieces[""long""],\n            ""dirty"": pieces[""dirty""], ""error"": None,\n            ""date"": pieces.get(""date"")}\n\n\ndef get_versions():\n    """"""Get version information or return default if unable to do so.""""""\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don\'t do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,\n                                          verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for i in cfg.versionfile_source.split(\'/\'):\n            root = os.path.dirname(root)\n    except NameError:\n        return {""version"": ""0+unknown"", ""full-revisionid"": None,\n                ""dirty"": None,\n                ""error"": ""unable to find root of source tree"",\n                ""date"": None}\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {""version"": ""0+unknown"", ""full-revisionid"": None,\n            ""dirty"": None,\n            ""error"": ""unable to compute version"", ""date"": None}\n\'\'\'\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r\'\\d\', r)])\n        if verbose:\n            print(""discarding \'%s\', no digits"" % "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %s"" % "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(""picking %s"" % r)\n            return {""version"": r,\n                    ""full-revisionid"": keywords[""full""].strip(),\n                    ""dirty"": False, ""error"": None,\n                    ""date"": date}\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {""version"": ""0+unknown"",\n            ""full-revisionid"": keywords[""full""].strip(),\n            ""dirty"": False, ""error"": ""no suitable tags"", ""date"": None}\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root,\n                          hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %s not under git control"" % root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(GITS, [""describe"", ""--tags"", ""--dirty"",\n                                          ""--always"", ""--long"",\n                                          ""--match"", ""%s*"" % tag_prefix],\n                                   cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\'^(.+)-(\\d+)-g([0-9a-f]+)$\', git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = (""unable to parse git-describe output: \'%s\'""\n                               % describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                print(fmt % (full_tag, tag_prefix))\n            pieces[""error""] = (""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                               % (full_tag, tag_prefix))\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""],\n                                    cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%ci"", ""HEAD""],\n                       cwd=root)[0].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef do_vcs_install(manifest_in, versionfile_source, ipy):\n    """"""Git-specific installation logic for Versioneer.\n\n    For Git, this means creating/changing .gitattributes to mark _version.py\n    for export-subst keyword substitution.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n    files = [manifest_in, versionfile_source]\n    if ipy:\n        files.append(ipy)\n    try:\n        me = __file__\n        if me.endswith("".pyc"") or me.endswith("".pyo""):\n            me = os.path.splitext(me)[0] + "".py""\n        versioneer_file = os.path.relpath(me)\n    except NameError:\n        versioneer_file = ""versioneer.py""\n    files.append(versioneer_file)\n    present = False\n    try:\n        f = open("".gitattributes"", ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(versionfile_source):\n                if ""export-subst"" in line.strip().split()[1:]:\n                    present = True\n        f.close()\n    except EnvironmentError:\n        pass\n    if not present:\n        f = open("".gitattributes"", ""a+"")\n        f.write(""%s export-subst\\n"" % versionfile_source)\n        f.close()\n        files.append("".gitattributes"")\n    run_command(GITS, [""add"", ""--""] + files)\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {""version"": dirname[len(parentdir_prefix):],\n                    ""full-revisionid"": None,\n                    ""dirty"": False, ""error"": None, ""date"": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(""Tried directories %s but none started with prefix %s"" %\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\nSHORT_VERSION_PY = """"""\n# This file was generated by \'versioneer.py\' (0.18) from\n# revision-control system data, or from the parent directory name of an\n# unpacked source archive. Distribution tarballs contain a pre-generated copy\n# of this file.\n\nimport json\n\nversion_json = \'\'\'\n%s\n\'\'\'  # END VERSION_JSON\n\n\ndef get_versions():\n    return json.loads(version_json)\n""""""\n\n\ndef versions_from_file(filename):\n    """"""Try to determine the version from _version.py if present.""""""\n    try:\n        with open(filename) as f:\n            contents = f.read()\n    except EnvironmentError:\n        raise NotThisMethod(""unable to read _version.py"")\n    mo = re.search(r""version_json = \'\'\'\\n(.*)\'\'\'  # END VERSION_JSON"",\n                   contents, re.M | re.S)\n    if not mo:\n        mo = re.search(r""version_json = \'\'\'\\r\\n(.*)\'\'\'  # END VERSION_JSON"",\n                       contents, re.M | re.S)\n    if not mo:\n        raise NotThisMethod(""no version_json in _version.py"")\n    return json.loads(mo.group(1))\n\n\ndef write_to_version_file(filename, versions):\n    """"""Write the given version number to the given _version.py file.""""""\n    os.unlink(filename)\n    contents = json.dumps(versions, sort_keys=True,\n                          indent=1, separators=("","", "": ""))\n    with open(filename, ""w"") as f:\n        f.write(SHORT_VERSION_PY % contents)\n\n    print(""set %s to \'%s\'"" % (filename, versions[""version""]))\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%d.g%s"" % (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%d.g%s"" % (pieces[""distance""],\n                                          pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%d"" % pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%d"" % pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%s"" % pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%s"" % pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {""version"": ""unknown"",\n                ""full-revisionid"": pieces.get(""long""),\n                ""dirty"": None,\n                ""error"": pieces[""error""],\n                ""date"": None}\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%s\'"" % style)\n\n    return {""version"": rendered, ""full-revisionid"": pieces[""long""],\n            ""dirty"": pieces[""dirty""], ""error"": None,\n            ""date"": pieces.get(""date"")}\n\n\nclass VersioneerBadRootError(Exception):\n    """"""The project root directory is unknown or missing key files.""""""\n\n\ndef get_versions(verbose=False):\n    """"""Get the project version from whatever source is available.\n\n    Returns dict with two keys: \'version\' and \'full\'.\n    """"""\n    if ""versioneer"" in sys.modules:\n        # see the discussion in cmdclass.py:get_cmdclass()\n        del sys.modules[""versioneer""]\n\n    root = get_root()\n    cfg = get_config_from_root(root)\n\n    assert cfg.VCS is not None, ""please set [versioneer]VCS= in setup.cfg""\n    handlers = HANDLERS.get(cfg.VCS)\n    assert handlers, ""unrecognized VCS \'%s\'"" % cfg.VCS\n    verbose = verbose or cfg.verbose\n    assert cfg.versionfile_source is not None, \\\n        ""please set versioneer.versionfile_source""\n    assert cfg.tag_prefix is not None, ""please set versioneer.tag_prefix""\n\n    versionfile_abs = os.path.join(root, cfg.versionfile_source)\n\n    # extract version from first of: _version.py, VCS command (e.g. \'git\n    # describe\'), parentdir. This is meant to work for developers using a\n    # source checkout, for users of a tarball created by \'setup.py sdist\',\n    # and for users of a tarball/zipball created by \'git archive\' or github\'s\n    # download-from-tag feature or the equivalent in other VCSes.\n\n    get_keywords_f = handlers.get(""get_keywords"")\n    from_keywords_f = handlers.get(""keywords"")\n    if get_keywords_f and from_keywords_f:\n        try:\n            keywords = get_keywords_f(versionfile_abs)\n            ver = from_keywords_f(keywords, cfg.tag_prefix, verbose)\n            if verbose:\n                print(""got version from expanded keyword %s"" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        ver = versions_from_file(versionfile_abs)\n        if verbose:\n            print(""got version from file %s %s"" % (versionfile_abs, ver))\n        return ver\n    except NotThisMethod:\n        pass\n\n    from_vcs_f = handlers.get(""pieces_from_vcs"")\n    if from_vcs_f:\n        try:\n            pieces = from_vcs_f(cfg.tag_prefix, root, verbose)\n            ver = render(pieces, cfg.style)\n            if verbose:\n                print(""got version from VCS %s"" % ver)\n            return ver\n        except NotThisMethod:\n            pass\n\n    try:\n        if cfg.parentdir_prefix:\n            ver = versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n            if verbose:\n                print(""got version from parentdir %s"" % ver)\n            return ver\n    except NotThisMethod:\n        pass\n\n    if verbose:\n        print(""unable to compute version"")\n\n    return {""version"": ""0+unknown"", ""full-revisionid"": None,\n            ""dirty"": None, ""error"": ""unable to compute version"",\n            ""date"": None}\n\n\ndef get_version():\n    """"""Get the short version string for this project.""""""\n    return get_versions()[""version""]\n\n\ndef get_cmdclass():\n    """"""Get the custom setuptools/distutils subclasses used by Versioneer.""""""\n    if ""versioneer"" in sys.modules:\n        del sys.modules[""versioneer""]\n        # this fixes the ""python setup.py develop"" case (also \'install\' and\n        # \'easy_install .\'), in which subdependencies of the main project are\n        # built (using setup.py bdist_egg) in the same python process. Assume\n        # a main project A and a dependency B, which use different versions\n        # of Versioneer. A\'s setup.py imports A\'s Versioneer, leaving it in\n        # sys.modules by the time B\'s setup.py is executed, causing B to run\n        # with the wrong versioneer. Setuptools wraps the sub-dep builds in a\n        # sandbox that restores sys.modules to it\'s pre-build state, so the\n        # parent is protected against the child\'s ""import versioneer"". By\n        # removing ourselves from sys.modules here, before the child build\n        # happens, we protect the child from the parent\'s versioneer too.\n        # Also see https://github.com/warner/python-versioneer/issues/52\n\n    cmds = {}\n\n    # we add ""version"" to both distutils and setuptools\n    from distutils.core import Command\n\n    class cmd_version(Command):\n        description = ""report generated version string""\n        user_options = []\n        boolean_options = []\n\n        def initialize_options(self):\n            pass\n\n        def finalize_options(self):\n            pass\n\n        def run(self):\n            vers = get_versions(verbose=True)\n            print(""Version: %s"" % vers[""version""])\n            print("" full-revisionid: %s"" % vers.get(""full-revisionid""))\n            print("" dirty: %s"" % vers.get(""dirty""))\n            print("" date: %s"" % vers.get(""date""))\n            if vers[""error""]:\n                print("" error: %s"" % vers[""error""])\n    cmds[""version""] = cmd_version\n\n    # we override ""build_py"" in both distutils and setuptools\n    #\n    # most invocation pathways end up running build_py:\n    #  distutils/build -> build_py\n    #  distutils/install -> distutils/build ->..\n    #  setuptools/bdist_wheel -> distutils/install ->..\n    #  setuptools/bdist_egg -> distutils/install_lib -> build_py\n    #  setuptools/install -> bdist_egg ->..\n    #  setuptools/develop -> ?\n    #  pip install:\n    #   copies source tree to a tempdir before running egg_info/etc\n    #   if .git isn\'t copied too, \'git describe\' will fail\n    #   then does setup.py bdist_wheel, or sometimes setup.py install\n    #  setup.py egg_info -> ?\n\n    # we override different ""build_py"" commands for both environments\n    if ""setuptools"" in sys.modules:\n        from setuptools.command.build_py import build_py as _build_py\n    else:\n        from distutils.command.build_py import build_py as _build_py\n\n    class cmd_build_py(_build_py):\n        def run(self):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            versions = get_versions()\n            _build_py.run(self)\n            # now locate _version.py in the new build/ directory and replace\n            # it with an updated value\n            if cfg.versionfile_build:\n                target_versionfile = os.path.join(self.build_lib,\n                                                  cfg.versionfile_build)\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n    cmds[""build_py""] = cmd_build_py\n\n    if ""cx_Freeze"" in sys.modules:  # cx_freeze enabled?\n        from cx_Freeze.dist import build_exe as _build_exe\n        # nczeczulin reports that py2exe won\'t like the pep440-style string\n        # as FILEVERSION, but it can be used for PRODUCTVERSION, e.g.\n        # setup(console=[{\n        #   ""version"": versioneer.get_version().split(""+"", 1)[0], # FILEVERSION\n        #   ""product_version"": versioneer.get_version(),\n        #   ...\n\n        class cmd_build_exe(_build_exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _build_exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, ""w"") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(LONG %\n                            {""DOLLAR"": ""$"",\n                             ""STYLE"": cfg.style,\n                             ""TAG_PREFIX"": cfg.tag_prefix,\n                             ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                             ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n                             })\n        cmds[""build_exe""] = cmd_build_exe\n        del cmds[""build_py""]\n\n    if \'py2exe\' in sys.modules:  # py2exe enabled?\n        try:\n            from py2exe.distutils_buildexe import py2exe as _py2exe  # py3\n        except ImportError:\n            from py2exe.build_exe import py2exe as _py2exe  # py2\n\n        class cmd_py2exe(_py2exe):\n            def run(self):\n                root = get_root()\n                cfg = get_config_from_root(root)\n                versions = get_versions()\n                target_versionfile = cfg.versionfile_source\n                print(""UPDATING %s"" % target_versionfile)\n                write_to_version_file(target_versionfile, versions)\n\n                _py2exe.run(self)\n                os.unlink(target_versionfile)\n                with open(cfg.versionfile_source, ""w"") as f:\n                    LONG = LONG_VERSION_PY[cfg.VCS]\n                    f.write(LONG %\n                            {""DOLLAR"": ""$"",\n                             ""STYLE"": cfg.style,\n                             ""TAG_PREFIX"": cfg.tag_prefix,\n                             ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                             ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n                             })\n        cmds[""py2exe""] = cmd_py2exe\n\n    # we override different ""sdist"" commands for both environments\n    if ""setuptools"" in sys.modules:\n        from setuptools.command.sdist import sdist as _sdist\n    else:\n        from distutils.command.sdist import sdist as _sdist\n\n    class cmd_sdist(_sdist):\n        def run(self):\n            versions = get_versions()\n            self._versioneer_generated_versions = versions\n            # unless we update this, the command will keep using the old\n            # version\n            self.distribution.metadata.version = versions[""version""]\n            return _sdist.run(self)\n\n        def make_release_tree(self, base_dir, files):\n            root = get_root()\n            cfg = get_config_from_root(root)\n            _sdist.make_release_tree(self, base_dir, files)\n            # now locate _version.py in the new base_dir directory\n            # (remembering that it may be a hardlink) and replace it with an\n            # updated value\n            target_versionfile = os.path.join(base_dir, cfg.versionfile_source)\n            print(""UPDATING %s"" % target_versionfile)\n            write_to_version_file(target_versionfile,\n                                  self._versioneer_generated_versions)\n    cmds[""sdist""] = cmd_sdist\n\n    return cmds\n\n\nCONFIG_ERROR = """"""\nsetup.cfg is missing the necessary Versioneer configuration. You need\na section like:\n\n [versioneer]\n VCS = git\n style = pep440\n versionfile_source = src/myproject/_version.py\n versionfile_build = myproject/_version.py\n tag_prefix =\n parentdir_prefix = myproject-\n\nYou will also need to edit your setup.py to use the results:\n\n import versioneer\n setup(version=versioneer.get_version(),\n       cmdclass=versioneer.get_cmdclass(), ...)\n\nPlease read the docstring in ./versioneer.py for configuration instructions,\nedit setup.cfg, and re-run the installer or \'python versioneer.py setup\'.\n""""""\n\nSAMPLE_CONFIG = """"""\n# See the docstring in versioneer.py for instructions. Note that you must\n# re-run \'versioneer.py setup\' after changing this section, and commit the\n# resulting files.\n\n[versioneer]\n#VCS = git\n#style = pep440\n#versionfile_source =\n#versionfile_build =\n#tag_prefix =\n#parentdir_prefix =\n\n""""""\n\nINIT_PY_SNIPPET = """"""\nfrom ._version import get_versions\n__version__ = get_versions()[\'version\']\ndel get_versions\n""""""\n\n\ndef do_setup():\n    """"""Main VCS-independent setup function for installing Versioneer.""""""\n    root = get_root()\n    try:\n        cfg = get_config_from_root(root)\n    except (EnvironmentError, configparser.NoSectionError,\n            configparser.NoOptionError) as e:\n        if isinstance(e, (EnvironmentError, configparser.NoSectionError)):\n            print(""Adding sample versioneer config to setup.cfg"",\n                  file=sys.stderr)\n            with open(os.path.join(root, ""setup.cfg""), ""a"") as f:\n                f.write(SAMPLE_CONFIG)\n        print(CONFIG_ERROR, file=sys.stderr)\n        return 1\n\n    print("" creating %s"" % cfg.versionfile_source)\n    with open(cfg.versionfile_source, ""w"") as f:\n        LONG = LONG_VERSION_PY[cfg.VCS]\n        f.write(LONG % {""DOLLAR"": ""$"",\n                        ""STYLE"": cfg.style,\n                        ""TAG_PREFIX"": cfg.tag_prefix,\n                        ""PARENTDIR_PREFIX"": cfg.parentdir_prefix,\n                        ""VERSIONFILE_SOURCE"": cfg.versionfile_source,\n                        })\n\n    ipy = os.path.join(os.path.dirname(cfg.versionfile_source),\n                       ""__init__.py"")\n    if os.path.exists(ipy):\n        try:\n            with open(ipy, ""r"") as f:\n                old = f.read()\n        except EnvironmentError:\n            old = """"\n        if INIT_PY_SNIPPET not in old:\n            print("" appending to %s"" % ipy)\n            with open(ipy, ""a"") as f:\n                f.write(INIT_PY_SNIPPET)\n        else:\n            print("" %s unmodified"" % ipy)\n    else:\n        print("" %s doesn\'t exist, ok"" % ipy)\n        ipy = None\n\n    # Make sure both the top-level ""versioneer.py"" and versionfile_source\n    # (PKG/_version.py, used by runtime code) are in MANIFEST.in, so\n    # they\'ll be copied into source distributions. Pip won\'t be able to\n    # install the package without this.\n    manifest_in = os.path.join(root, ""MANIFEST.in"")\n    simple_includes = set()\n    try:\n        with open(manifest_in, ""r"") as f:\n            for line in f:\n                if line.startswith(""include ""):\n                    for include in line.split()[1:]:\n                        simple_includes.add(include)\n    except EnvironmentError:\n        pass\n    # That doesn\'t cover everything MANIFEST.in can do\n    # (http://docs.python.org/2/distutils/sourcedist.html#commands), so\n    # it might give some false negatives. Appending redundant \'include\'\n    # lines is safe, though.\n    if ""versioneer.py"" not in simple_includes:\n        print("" appending \'versioneer.py\' to MANIFEST.in"")\n        with open(manifest_in, ""a"") as f:\n            f.write(""include versioneer.py\\n"")\n    else:\n        print("" \'versioneer.py\' already in MANIFEST.in"")\n    if cfg.versionfile_source not in simple_includes:\n        print("" appending versionfile_source (\'%s\') to MANIFEST.in"" %\n              cfg.versionfile_source)\n        with open(manifest_in, ""a"") as f:\n            f.write(""include %s\\n"" % cfg.versionfile_source)\n    else:\n        print("" versionfile_source already in MANIFEST.in"")\n\n    # Make VCS-specific changes. For git, this means creating/changing\n    # .gitattributes to mark _version.py for export-subst keyword\n    # substitution.\n    do_vcs_install(manifest_in, cfg.versionfile_source, ipy)\n    return 0\n\n\ndef scan_setup_py():\n    """"""Validate the contents of setup.py against Versioneer\'s expectations.""""""\n    found = set()\n    setters = False\n    errors = 0\n    with open(""setup.py"", ""r"") as f:\n        for line in f.readlines():\n            if ""import versioneer"" in line:\n                found.add(""import"")\n            if ""versioneer.get_cmdclass()"" in line:\n                found.add(""cmdclass"")\n            if ""versioneer.get_version()"" in line:\n                found.add(""get_version"")\n            if ""versioneer.VCS"" in line:\n                setters = True\n            if ""versioneer.versionfile_source"" in line:\n                setters = True\n    if len(found) != 3:\n        print("""")\n        print(""Your setup.py appears to be missing some important items"")\n        print(""(but I might be wrong). Please make sure it has something"")\n        print(""roughly like the following:"")\n        print("""")\n        print("" import versioneer"")\n        print("" setup( version=versioneer.get_version(),"")\n        print(""        cmdclass=versioneer.get_cmdclass(),  ...)"")\n        print("""")\n        errors += 1\n    if setters:\n        print(""You should remove lines like \'versioneer.VCS = \' and"")\n        print(""\'versioneer.versionfile_source = \' . This configuration"")\n        print(""now lives in setup.cfg, and should be removed from setup.py"")\n        print("""")\n        errors += 1\n    return errors\n\n\nif __name__ == ""__main__"":\n    cmd = sys.argv[1]\n    if cmd == ""setup"":\n        errors = do_setup()\n        errors += scan_setup_py()\n        if errors:\n            sys.exit(1)\n'"
alphalens/__init__.py,0,"b""from . import performance\nfrom . import plotting\nfrom . import tears\nfrom . import utils\n\nfrom ._version import get_versions\n\n\n__version__ = get_versions()['version']\ndel get_versions\n\n__all__ = ['performance', 'plotting', 'tears', 'utils']\n"""
alphalens/_version.py,0,"b'\n# This file helps to compute a version number in source trees obtained from\n# git-archive tarball (such as those provided by githubs download-from-tag\n# feature). Distribution tarballs (built by setup.py sdist) and build\n# directories (produced by setup.py build) will contain a much shorter file\n# that just contains the computed version number.\n\n# This file is released into the public domain. Generated by\n# versioneer-0.18 (https://github.com/warner/python-versioneer)\n\n""""""Git implementation of _version.py.""""""\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\n\n\ndef get_keywords():\n    """"""Get the keywords needed to look up the version information.""""""\n    # these strings will be replaced by git during git-archive.\n    # setup.py/versioneer.py will grep for the variable names, so they must\n    # each be defined on a line of their own. _version.py will just call\n    # get_keywords().\n    git_refnames = ""$Format:%d$""\n    git_full = ""$Format:%H$""\n    git_date = ""$Format:%ci$""\n    keywords = {""refnames"": git_refnames, ""full"": git_full, ""date"": git_date}\n    return keywords\n\n\nclass VersioneerConfig:\n    """"""Container for Versioneer configuration parameters.""""""\n\n\ndef get_config():\n    """"""Create, populate and return the VersioneerConfig() object.""""""\n    # these strings are filled in when \'setup.py versioneer\' creates\n    # _version.py\n    cfg = VersioneerConfig()\n    cfg.VCS = ""git""\n    cfg.style = ""pep440""\n    cfg.tag_prefix = ""v""\n    cfg.parentdir_prefix = ""alphalens-""\n    cfg.versionfile_source = ""alphalens/_version.py""\n    cfg.verbose = False\n    return cfg\n\n\nclass NotThisMethod(Exception):\n    """"""Exception raised if a method is not valid for the current scenario.""""""\n\n\nLONG_VERSION_PY = {}\nHANDLERS = {}\n\n\ndef register_vcs_handler(vcs, method):  # decorator\n    """"""Decorator to mark a method as the handler for a particular VCS.""""""\n    def decorate(f):\n        """"""Store f in HANDLERS[vcs][method].""""""\n        if vcs not in HANDLERS:\n            HANDLERS[vcs] = {}\n        HANDLERS[vcs][method] = f\n        return f\n    return decorate\n\n\ndef run_command(commands, args, cwd=None, verbose=False, hide_stderr=False,\n                env=None):\n    """"""Call the given command(s).""""""\n    assert isinstance(commands, list)\n    p = None\n    for c in commands:\n        try:\n            dispcmd = str([c] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            p = subprocess.Popen([c] + args, cwd=cwd, env=env,\n                                 stdout=subprocess.PIPE,\n                                 stderr=(subprocess.PIPE if hide_stderr\n                                         else None))\n            break\n        except EnvironmentError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(""unable to run %s"" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(""unable to find command, tried %s"" % (commands,))\n        return None, None\n    stdout = p.communicate()[0].strip()\n    if sys.version_info[0] >= 3:\n        stdout = stdout.decode()\n    if p.returncode != 0:\n        if verbose:\n            print(""unable to run %s (error)"" % dispcmd)\n            print(""stdout was %s"" % stdout)\n        return None, p.returncode\n    return stdout, p.returncode\n\n\ndef versions_from_parentdir(parentdir_prefix, root, verbose):\n    """"""Try to determine the version from the parent directory name.\n\n    Source tarballs conventionally unpack into a directory that includes both\n    the project name and a version string. We will also support searching up\n    two directory levels for an appropriately named parent directory\n    """"""\n    rootdirs = []\n\n    for i in range(3):\n        dirname = os.path.basename(root)\n        if dirname.startswith(parentdir_prefix):\n            return {""version"": dirname[len(parentdir_prefix):],\n                    ""full-revisionid"": None,\n                    ""dirty"": False, ""error"": None, ""date"": None}\n        else:\n            rootdirs.append(root)\n            root = os.path.dirname(root)  # up a level\n\n    if verbose:\n        print(""Tried directories %s but none started with prefix %s"" %\n              (str(rootdirs), parentdir_prefix))\n    raise NotThisMethod(""rootdir doesn\'t start with parentdir_prefix"")\n\n\n@register_vcs_handler(""git"", ""get_keywords"")\ndef git_get_keywords(versionfile_abs):\n    """"""Extract version information from the given file.""""""\n    # the code embedded in _version.py can just fetch the value of these\n    # keywords. When used from setup.py, we don\'t want to import _version.py,\n    # so we do it with a regexp instead. This function is not used from\n    # _version.py.\n    keywords = {}\n    try:\n        f = open(versionfile_abs, ""r"")\n        for line in f.readlines():\n            if line.strip().startswith(""git_refnames =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""refnames""] = mo.group(1)\n            if line.strip().startswith(""git_full =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""full""] = mo.group(1)\n            if line.strip().startswith(""git_date =""):\n                mo = re.search(r\'=\\s*""(.*)""\', line)\n                if mo:\n                    keywords[""date""] = mo.group(1)\n        f.close()\n    except EnvironmentError:\n        pass\n    return keywords\n\n\n@register_vcs_handler(""git"", ""keywords"")\ndef git_versions_from_keywords(keywords, tag_prefix, verbose):\n    """"""Get version information from git keywords.""""""\n    if not keywords:\n        raise NotThisMethod(""no keywords at all, weird"")\n    date = keywords.get(""date"")\n    if date is not None:\n        # git-2.2.0 added ""%cI"", which expands to an ISO-8601 -compliant\n        # datestamp. However we prefer ""%ci"" (which expands to an ""ISO-8601\n        # -like"" string, which we must then edit to make compliant), because\n        # it\'s been around since git-1.5.3, and it\'s too difficult to\n        # discover which version we\'re using, or to work around using an\n        # older one.\n        date = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n    refnames = keywords[""refnames""].strip()\n    if refnames.startswith(""$Format""):\n        if verbose:\n            print(""keywords are unexpanded, not using"")\n        raise NotThisMethod(""unexpanded keywords, not a git-archive tarball"")\n    refs = set([r.strip() for r in refnames.strip(""()"").split("","")])\n    # starting in git-1.8.3, tags are listed as ""tag: foo-1.0"" instead of\n    # just ""foo-1.0"". If we see a ""tag: "" prefix, prefer those.\n    TAG = ""tag: ""\n    tags = set([r[len(TAG):] for r in refs if r.startswith(TAG)])\n    if not tags:\n        # Either we\'re using git < 1.8.3, or there really are no tags. We use\n        # a heuristic: assume all version tags have a digit. The old git %d\n        # expansion behaves like git log --decorate=short and strips out the\n        # refs/heads/ and refs/tags/ prefixes that would let us distinguish\n        # between branches and tags. By ignoring refnames without digits, we\n        # filter out many common branch names like ""release"" and\n        # ""stabilization"", as well as ""HEAD"" and ""master"".\n        tags = set([r for r in refs if re.search(r\'\\d\', r)])\n        if verbose:\n            print(""discarding \'%s\', no digits"" % "","".join(refs - tags))\n    if verbose:\n        print(""likely tags: %s"" % "","".join(sorted(tags)))\n    for ref in sorted(tags):\n        # sorting will prefer e.g. ""2.0"" over ""2.0rc1""\n        if ref.startswith(tag_prefix):\n            r = ref[len(tag_prefix):]\n            if verbose:\n                print(""picking %s"" % r)\n            return {""version"": r,\n                    ""full-revisionid"": keywords[""full""].strip(),\n                    ""dirty"": False, ""error"": None,\n                    ""date"": date}\n    # no suitable tags, so version is ""0+unknown"", but full hex is still there\n    if verbose:\n        print(""no suitable tags, using unknown + full revision id"")\n    return {""version"": ""0+unknown"",\n            ""full-revisionid"": keywords[""full""].strip(),\n            ""dirty"": False, ""error"": ""no suitable tags"", ""date"": None}\n\n\n@register_vcs_handler(""git"", ""pieces_from_vcs"")\ndef git_pieces_from_vcs(tag_prefix, root, verbose, run_command=run_command):\n    """"""Get version from \'git describe\' in the root of the source tree.\n\n    This only gets called if the git-archive \'subst\' keywords were *not*\n    expanded, and _version.py hasn\'t already been rewritten with a short\n    version string, meaning we\'re inside a checked out source tree.\n    """"""\n    GITS = [""git""]\n    if sys.platform == ""win32"":\n        GITS = [""git.cmd"", ""git.exe""]\n\n    out, rc = run_command(GITS, [""rev-parse"", ""--git-dir""], cwd=root,\n                          hide_stderr=True)\n    if rc != 0:\n        if verbose:\n            print(""Directory %s not under git control"" % root)\n        raise NotThisMethod(""\'git rev-parse --git-dir\' returned error"")\n\n    # if there is a tag matching tag_prefix, this yields TAG-NUM-gHEX[-dirty]\n    # if there isn\'t one, this yields HEX[-dirty] (no NUM)\n    describe_out, rc = run_command(GITS, [""describe"", ""--tags"", ""--dirty"",\n                                          ""--always"", ""--long"",\n                                          ""--match"", ""%s*"" % tag_prefix],\n                                   cwd=root)\n    # --long was added in git-1.5.5\n    if describe_out is None:\n        raise NotThisMethod(""\'git describe\' failed"")\n    describe_out = describe_out.strip()\n    full_out, rc = run_command(GITS, [""rev-parse"", ""HEAD""], cwd=root)\n    if full_out is None:\n        raise NotThisMethod(""\'git rev-parse\' failed"")\n    full_out = full_out.strip()\n\n    pieces = {}\n    pieces[""long""] = full_out\n    pieces[""short""] = full_out[:7]  # maybe improved later\n    pieces[""error""] = None\n\n    # parse describe_out. It will be like TAG-NUM-gHEX[-dirty] or HEX[-dirty]\n    # TAG might have hyphens.\n    git_describe = describe_out\n\n    # look for -dirty suffix\n    dirty = git_describe.endswith(""-dirty"")\n    pieces[""dirty""] = dirty\n    if dirty:\n        git_describe = git_describe[:git_describe.rindex(""-dirty"")]\n\n    # now we have TAG-NUM-gHEX or HEX\n\n    if ""-"" in git_describe:\n        # TAG-NUM-gHEX\n        mo = re.search(r\'^(.+)-(\\d+)-g([0-9a-f]+)$\', git_describe)\n        if not mo:\n            # unparseable. Maybe git-describe is misbehaving?\n            pieces[""error""] = (""unable to parse git-describe output: \'%s\'""\n                               % describe_out)\n            return pieces\n\n        # tag\n        full_tag = mo.group(1)\n        if not full_tag.startswith(tag_prefix):\n            if verbose:\n                fmt = ""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                print(fmt % (full_tag, tag_prefix))\n            pieces[""error""] = (""tag \'%s\' doesn\'t start with prefix \'%s\'""\n                               % (full_tag, tag_prefix))\n            return pieces\n        pieces[""closest-tag""] = full_tag[len(tag_prefix):]\n\n        # distance: number of commits since tag\n        pieces[""distance""] = int(mo.group(2))\n\n        # commit: short hex revision ID\n        pieces[""short""] = mo.group(3)\n\n    else:\n        # HEX: no tags\n        pieces[""closest-tag""] = None\n        count_out, rc = run_command(GITS, [""rev-list"", ""HEAD"", ""--count""],\n                                    cwd=root)\n        pieces[""distance""] = int(count_out)  # total number of commits\n\n    # commit date: see ISO-8601 comment in git_versions_from_keywords()\n    date = run_command(GITS, [""show"", ""-s"", ""--format=%ci"", ""HEAD""],\n                       cwd=root)[0].strip()\n    pieces[""date""] = date.strip().replace("" "", ""T"", 1).replace("" "", """", 1)\n\n    return pieces\n\n\ndef plus_or_dot(pieces):\n    """"""Return a + if we don\'t already have one, else return a .""""""\n    if ""+"" in pieces.get(""closest-tag"", """"):\n        return "".""\n    return ""+""\n\n\ndef render_pep440(pieces):\n    """"""Build up version string, with post-release ""local version identifier"".\n\n    Our goal: TAG[+DISTANCE.gHEX[.dirty]] . Note that if you\n    get a tagged build and then dirty it, you\'ll get TAG+0.gHEX.dirty\n\n    Exceptions:\n    1: no tags. git_describe was just HEX. 0+untagged.DISTANCE.gHEX[.dirty]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += plus_or_dot(pieces)\n            rendered += ""%d.g%s"" % (pieces[""distance""], pieces[""short""])\n            if pieces[""dirty""]:\n                rendered += "".dirty""\n    else:\n        # exception #1\n        rendered = ""0+untagged.%d.g%s"" % (pieces[""distance""],\n                                          pieces[""short""])\n        if pieces[""dirty""]:\n            rendered += "".dirty""\n    return rendered\n\n\ndef render_pep440_pre(pieces):\n    """"""TAG[.post.devDISTANCE] -- No -dirty.\n\n    Exceptions:\n    1: no tags. 0.post.devDISTANCE\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += "".post.dev%d"" % pieces[""distance""]\n    else:\n        # exception #1\n        rendered = ""0.post.dev%d"" % pieces[""distance""]\n    return rendered\n\n\ndef render_pep440_post(pieces):\n    """"""TAG[.postDISTANCE[.dev0]+gHEX] .\n\n    The "".dev0"" means dirty. Note that .dev0 sorts backwards\n    (a dirty tree will appear ""older"" than the corresponding clean one),\n    but you shouldn\'t be releasing software with -dirty anyways.\n\n    Exceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n            rendered += plus_or_dot(pieces)\n            rendered += ""g%s"" % pieces[""short""]\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n        rendered += ""+g%s"" % pieces[""short""]\n    return rendered\n\n\ndef render_pep440_old(pieces):\n    """"""TAG[.postDISTANCE[.dev0]] .\n\n    The "".dev0"" means dirty.\n\n    Eexceptions:\n    1: no tags. 0.postDISTANCE[.dev0]\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""] or pieces[""dirty""]:\n            rendered += "".post%d"" % pieces[""distance""]\n            if pieces[""dirty""]:\n                rendered += "".dev0""\n    else:\n        # exception #1\n        rendered = ""0.post%d"" % pieces[""distance""]\n        if pieces[""dirty""]:\n            rendered += "".dev0""\n    return rendered\n\n\ndef render_git_describe(pieces):\n    """"""TAG[-DISTANCE-gHEX][-dirty].\n\n    Like \'git describe --tags --dirty --always\'.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        if pieces[""distance""]:\n            rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render_git_describe_long(pieces):\n    """"""TAG-DISTANCE-gHEX[-dirty].\n\n    Like \'git describe --tags --dirty --always -long\'.\n    The distance/hash is unconditional.\n\n    Exceptions:\n    1: no tags. HEX[-dirty]  (note: no \'g\' prefix)\n    """"""\n    if pieces[""closest-tag""]:\n        rendered = pieces[""closest-tag""]\n        rendered += ""-%d-g%s"" % (pieces[""distance""], pieces[""short""])\n    else:\n        # exception #1\n        rendered = pieces[""short""]\n    if pieces[""dirty""]:\n        rendered += ""-dirty""\n    return rendered\n\n\ndef render(pieces, style):\n    """"""Render the given version pieces into the requested style.""""""\n    if pieces[""error""]:\n        return {""version"": ""unknown"",\n                ""full-revisionid"": pieces.get(""long""),\n                ""dirty"": None,\n                ""error"": pieces[""error""],\n                ""date"": None}\n\n    if not style or style == ""default"":\n        style = ""pep440""  # the default\n\n    if style == ""pep440"":\n        rendered = render_pep440(pieces)\n    elif style == ""pep440-pre"":\n        rendered = render_pep440_pre(pieces)\n    elif style == ""pep440-post"":\n        rendered = render_pep440_post(pieces)\n    elif style == ""pep440-old"":\n        rendered = render_pep440_old(pieces)\n    elif style == ""git-describe"":\n        rendered = render_git_describe(pieces)\n    elif style == ""git-describe-long"":\n        rendered = render_git_describe_long(pieces)\n    else:\n        raise ValueError(""unknown style \'%s\'"" % style)\n\n    return {""version"": rendered, ""full-revisionid"": pieces[""long""],\n            ""dirty"": pieces[""dirty""], ""error"": None,\n            ""date"": pieces.get(""date"")}\n\n\ndef get_versions():\n    """"""Get version information or return default if unable to do so.""""""\n    # I am in _version.py, which lives at ROOT/VERSIONFILE_SOURCE. If we have\n    # __file__, we can work backwards from there to the root. Some\n    # py2exe/bbfreeze/non-CPython implementations don\'t do __file__, in which\n    # case we can only use expanded keywords.\n\n    cfg = get_config()\n    verbose = cfg.verbose\n\n    try:\n        return git_versions_from_keywords(get_keywords(), cfg.tag_prefix,\n                                          verbose)\n    except NotThisMethod:\n        pass\n\n    try:\n        root = os.path.realpath(__file__)\n        # versionfile_source is the relative path from the top of the source\n        # tree (where the .git directory might live) to this file. Invert\n        # this to find the root from __file__.\n        for i in cfg.versionfile_source.split(\'/\'):\n            root = os.path.dirname(root)\n    except NameError:\n        return {""version"": ""0+unknown"", ""full-revisionid"": None,\n                ""dirty"": None,\n                ""error"": ""unable to find root of source tree"",\n                ""date"": None}\n\n    try:\n        pieces = git_pieces_from_vcs(cfg.tag_prefix, root, verbose)\n        return render(pieces, cfg.style)\n    except NotThisMethod:\n        pass\n\n    try:\n        if cfg.parentdir_prefix:\n            return versions_from_parentdir(cfg.parentdir_prefix, root, verbose)\n    except NotThisMethod:\n        pass\n\n    return {""version"": ""0+unknown"", ""full-revisionid"": None,\n            ""dirty"": None,\n            ""error"": ""unable to compute version"", ""date"": None}\n'"
alphalens/performance.py,5,"b'#\n# Copyright 2017 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pandas as pd\nimport numpy as np\nimport warnings\n\nimport empyrical as ep\nfrom pandas.tseries.offsets import BDay\nfrom scipy import stats\nfrom statsmodels.regression.linear_model import OLS\nfrom statsmodels.tools.tools import add_constant\nfrom . import utils\n\n\ndef factor_information_coefficient(factor_data,\n                                   group_adjust=False,\n                                   by_group=False):\n    """"""\n    Computes the Spearman Rank Correlation based Information Coefficient (IC)\n    between factor values and N period forward returns for each period in\n    the factor index.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    group_adjust : bool\n        Demean forward returns by group before computing IC.\n    by_group : bool\n        If True, compute period wise IC separately for each group.\n\n    Returns\n    -------\n    ic : pd.DataFrame\n        Spearman Rank correlation between factor and\n        provided forward returns.\n    """"""\n\n    def src_ic(group):\n        f = group[\'factor\']\n        _ic = group[utils.get_forward_returns_columns(factor_data.columns)] \\\n            .apply(lambda x: stats.spearmanr(x, f)[0])\n        return _ic\n\n    factor_data = factor_data.copy()\n\n    grouper = [factor_data.index.get_level_values(\'date\')]\n\n    if group_adjust:\n        factor_data = utils.demean_forward_returns(factor_data,\n                                                   grouper + [\'group\'])\n    if by_group:\n        grouper.append(\'group\')\n\n    ic = factor_data.groupby(grouper).apply(src_ic)\n\n    return ic\n\n\ndef mean_information_coefficient(factor_data,\n                                 group_adjust=False,\n                                 by_group=False,\n                                 by_time=None):\n    """"""\n    Get the mean information coefficient of specified groups.\n    Answers questions like:\n    What is the mean IC for each month?\n    What is the mean IC for each group for our whole timerange?\n    What is the mean IC for for each group, each week?\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    group_adjust : bool\n        Demean forward returns by group before computing IC.\n    by_group : bool\n        If True, take the mean IC for each group.\n    by_time : str (pd time_rule), optional\n        Time window to use when taking mean IC.\n        See http://pandas.pydata.org/pandas-docs/stable/timeseries.html\n        for available options.\n\n    Returns\n    -------\n    ic : pd.DataFrame\n        Mean Spearman Rank correlation between factor and provided\n        forward price movement windows.\n    """"""\n\n    ic = factor_information_coefficient(factor_data, group_adjust, by_group)\n\n    grouper = []\n    if by_time is not None:\n        grouper.append(pd.Grouper(freq=by_time))\n    if by_group:\n        grouper.append(\'group\')\n\n    if len(grouper) == 0:\n        ic = ic.mean()\n\n    else:\n        ic = (ic.reset_index().set_index(\'date\').groupby(grouper).mean())\n\n    return ic\n\n\ndef factor_weights(factor_data,\n                   demeaned=True,\n                   group_adjust=False,\n                   equal_weight=False):\n    """"""\n    Computes asset weights by factor values and dividing by the sum of their\n    absolute value (achieving gross leverage of 1). Positive factor values will\n    results in positive weights and negative values in negative weights.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    demeaned : bool\n        Should this computation happen on a long short portfolio? if True,\n        weights are computed by demeaning factor values and dividing by the sum\n        of their absolute value (achieving gross leverage of 1). The sum of\n        positive weights will be the same as the negative weights (absolute\n        value), suitable for a dollar neutral long-short portfolio\n    group_adjust : bool\n        Should this computation happen on a group neutral portfolio? If True,\n        compute group neutral weights: each group will weight the same and\n        if \'demeaned\' is enabled the factor values demeaning will occur on the\n        group level.\n    equal_weight : bool, optional\n        if True the assets will be equal-weighted instead of factor-weighted\n        If demeaned is True then the factor universe will be split in two\n        equal sized groups, top assets with positive weights and bottom assets\n        with negative weights\n\n    Returns\n    -------\n    returns : pd.Series\n        Assets weighted by factor value.\n    """"""\n\n    def to_weights(group, _demeaned, _equal_weight):\n\n        if _equal_weight:\n            group = group.copy()\n\n            if _demeaned:\n                # top assets positive weights, bottom ones negative\n                group = group - group.median()\n\n            negative_mask = group < 0\n            group[negative_mask] = -1.0\n            positive_mask = group > 0\n            group[positive_mask] = 1.0\n\n            if _demeaned:\n                # positive weights must equal negative weights\n                if negative_mask.any():\n                    group[negative_mask] /= negative_mask.sum()\n                if positive_mask.any():\n                    group[positive_mask] /= positive_mask.sum()\n\n        elif _demeaned:\n            group = group - group.mean()\n\n        return group / group.abs().sum()\n\n    grouper = [factor_data.index.get_level_values(\'date\')]\n    if group_adjust:\n        grouper.append(\'group\')\n\n    weights = factor_data.groupby(grouper)[\'factor\'] \\\n        .apply(to_weights, demeaned, equal_weight)\n\n    if group_adjust:\n        weights = weights.groupby(level=\'date\').apply(to_weights, False, False)\n\n    return weights\n\n\ndef factor_returns(factor_data,\n                   demeaned=True,\n                   group_adjust=False,\n                   equal_weight=False,\n                   by_asset=False):\n    """"""\n    Computes period wise returns for portfolio weighted by factor\n    values.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    demeaned : bool\n        Control how to build factor weights\n        -- see performance.factor_weights for a full explanation\n    group_adjust : bool\n        Control how to build factor weights\n        -- see performance.factor_weights for a full explanation\n    equal_weight : bool, optional\n        Control how to build factor weights\n        -- see performance.factor_weights for a full explanation\n    by_asset: bool, optional\n        If True, returns are reported separately for each esset.\n\n    Returns\n    -------\n    returns : pd.DataFrame\n        Period wise factor returns\n    """"""\n\n    weights = \\\n        factor_weights(factor_data, demeaned, group_adjust, equal_weight)\n\n    weighted_returns = \\\n        factor_data[utils.get_forward_returns_columns(factor_data.columns)] \\\n        .multiply(weights, axis=0)\n\n    if by_asset:\n        returns = weighted_returns\n    else:\n        returns = weighted_returns.groupby(level=\'date\').sum()\n\n    return returns\n\n\ndef factor_alpha_beta(factor_data,\n                      returns=None,\n                      demeaned=True,\n                      group_adjust=False,\n                      equal_weight=False):\n    """"""\n    Compute the alpha (excess returns), alpha t-stat (alpha significance),\n    and beta (market exposure) of a factor. A regression is run with\n    the period wise factor universe mean return as the independent variable\n    and mean period wise return from a portfolio weighted by factor values\n    as the dependent variable.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    returns : pd.DataFrame, optional\n        Period wise factor returns. If this is None then it will be computed\n        with \'factor_returns\' function and the passed flags: \'demeaned\',\n        \'group_adjust\', \'equal_weight\'\n    demeaned : bool\n        Control how to build factor returns used for alpha/beta computation\n        -- see performance.factor_return for a full explanation\n    group_adjust : bool\n        Control how to build factor returns used for alpha/beta computation\n        -- see performance.factor_return for a full explanation\n    equal_weight : bool, optional\n        Control how to build factor returns used for alpha/beta computation\n        -- see performance.factor_return for a full explanation\n\n    Returns\n    -------\n    alpha_beta : pd.Series\n        A list containing the alpha, beta, a t-stat(alpha)\n        for the given factor and forward returns.\n    """"""\n\n    if returns is None:\n        returns = \\\n            factor_returns(factor_data, demeaned, group_adjust, equal_weight)\n\n    universe_ret = factor_data.groupby(level=\'date\')[\n        utils.get_forward_returns_columns(factor_data.columns)] \\\n        .mean().loc[returns.index]\n\n    if isinstance(returns, pd.Series):\n        returns.name = universe_ret.columns.values[0]\n        returns = pd.DataFrame(returns)\n\n    alpha_beta = pd.DataFrame()\n    for period in returns.columns.values:\n        x = universe_ret[period].values\n        y = returns[period].values\n        x = add_constant(x)\n\n        reg_fit = OLS(y, x).fit()\n        try:\n            alpha, beta = reg_fit.params\n        except ValueError:\n            alpha_beta.loc[\'Ann. alpha\', period] = np.nan\n            alpha_beta.loc[\'beta\', period] = np.nan\n        else:\n            freq_adjust = pd.Timedelta(\'252Days\') / pd.Timedelta(period)\n\n            alpha_beta.loc[\'Ann. alpha\', period] = \\\n                (1 + alpha) ** freq_adjust - 1\n            alpha_beta.loc[\'beta\', period] = beta\n\n    return alpha_beta\n\n\ndef cumulative_returns(returns):\n    """"""\n    Computes cumulative returns from simple daily returns.\n\n    Parameters\n    ----------\n    returns: pd.Series\n        pd.Series containing daily factor returns (i.e. \'1D\' returns).\n\n    Returns\n    -------\n    Cumulative returns series : pd.Series\n        Example:\n            2015-01-05   1.001310\n            2015-01-06   1.000805\n            2015-01-07   1.001092\n            2015-01-08   0.999200\n    """"""\n\n    return ep.cum_returns(returns, starting_value=1)\n\n\ndef positions(weights, period, freq=None):\n    """"""\n    Builds net position values time series, the portfolio percentage invested\n    in each position.\n\n    Parameters\n    ----------\n    weights: pd.Series\n        pd.Series containing factor weights, the index contains timestamps at\n        which the trades are computed and the values correspond to assets\n        weights\n        - see factor_weights for more details\n    period: pandas.Timedelta or string\n        Assets holding period (1 day, 2 mins, 3 hours etc). It can be a\n        Timedelta or a string in the format accepted by Timedelta constructor\n        (\'1 days\', \'1D\', \'30m\', \'3h\', \'1D1h\', etc)\n    freq : pandas DateOffset, optional\n        Used to specify a particular trading calendar. If not present\n        weights.index.freq will be used\n\n    Returns\n    -------\n    pd.DataFrame\n        Assets positions series, datetime on index, assets on columns.\n        Example:\n            index                 \'AAPL\'         \'MSFT\'          cash\n            2004-01-09 10:30:00   13939.3800     -14012.9930     711.5585\n            2004-01-09 15:30:00       0.00       -16012.9930     411.5585\n            2004-01-12 10:30:00   14492.6300     -14624.8700       0.0\n            2004-01-12 15:30:00   14874.5400     -15841.2500       0.0\n            2004-01-13 10:30:00   -13853.2800    13653.6400      -43.6375\n    """"""\n\n    weights = weights.unstack()\n\n    if not isinstance(period, pd.Timedelta):\n        period = pd.Timedelta(period)\n\n    if freq is None:\n        freq = weights.index.freq\n\n    if freq is None:\n        freq = BDay()\n        warnings.warn(""\'freq\' not set, using business day calendar"",\n                      UserWarning)\n\n    #\n    # weights index contains factor computation timestamps, then add returns\n    # timestamps too (factor timestamps + period) and save them to \'full_idx\'\n    # \'full_idx\' index will contain an entry for each point in time the weights\n    # change and hence they have to be re-computed\n    #\n    trades_idx = weights.index.copy()\n    returns_idx = utils.add_custom_calendar_timedelta(trades_idx, period, freq)\n    weights_idx = trades_idx.union(returns_idx)\n\n    #\n    # Compute portfolio weights for each point in time contained in the index\n    #\n    portfolio_weights = pd.DataFrame(index=weights_idx,\n                                     columns=weights.columns)\n    active_weights = []\n\n    for curr_time in weights_idx:\n\n        #\n        # fetch new weights that become available at curr_time and store them\n        # in active weights\n        #\n        if curr_time in weights.index:\n            assets_weights = weights.loc[curr_time]\n            expire_ts = utils.add_custom_calendar_timedelta(curr_time,\n                                                            period, freq)\n            active_weights.append((expire_ts, assets_weights))\n\n        #\n        # remove expired entry in active_weights (older than \'period\')\n        #\n        if active_weights:\n            expire_ts, assets_weights = active_weights[0]\n            if expire_ts <= curr_time:\n                active_weights.pop(0)\n\n        if not active_weights:\n            continue\n        #\n        # Compute total weights for curr_time and store them\n        #\n        tot_weights = [w for (ts, w) in active_weights]\n        tot_weights = pd.concat(tot_weights, axis=1)\n        tot_weights = tot_weights.sum(axis=1)\n        tot_weights /= tot_weights.abs().sum()\n\n        portfolio_weights.loc[curr_time] = tot_weights\n\n    return portfolio_weights.fillna(0)\n\n\ndef mean_return_by_quantile(factor_data,\n                            by_date=False,\n                            by_group=False,\n                            demeaned=True,\n                            group_adjust=False):\n    """"""\n    Computes mean returns for factor quantiles across\n    provided forward returns columns.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    by_date : bool\n        If True, compute quantile bucket returns separately for each date.\n    by_group : bool\n        If True, compute quantile bucket returns separately for each group.\n    demeaned : bool\n        Compute demeaned mean returns (long short portfolio)\n    group_adjust : bool\n        Returns demeaning will occur on the group level.\n\n    Returns\n    -------\n    mean_ret : pd.DataFrame\n        Mean period wise returns by specified factor quantile.\n    std_error_ret : pd.DataFrame\n        Standard error of returns by specified quantile.\n    """"""\n\n    if group_adjust:\n        grouper = [factor_data.index.get_level_values(\'date\')] + [\'group\']\n        factor_data = utils.demean_forward_returns(factor_data, grouper)\n    elif demeaned:\n        factor_data = utils.demean_forward_returns(factor_data)\n    else:\n        factor_data = factor_data.copy()\n\n    grouper = [\'factor_quantile\', factor_data.index.get_level_values(\'date\')]\n\n    if by_group:\n        grouper.append(\'group\')\n\n    group_stats = factor_data.groupby(grouper)[\n        utils.get_forward_returns_columns(factor_data.columns)] \\\n        .agg([\'mean\', \'std\', \'count\'])\n\n    mean_ret = group_stats.T.xs(\'mean\', level=1).T\n\n    if not by_date:\n        grouper = [mean_ret.index.get_level_values(\'factor_quantile\')]\n        if by_group:\n            grouper.append(mean_ret.index.get_level_values(\'group\'))\n        group_stats = mean_ret.groupby(grouper)\\\n            .agg([\'mean\', \'std\', \'count\'])\n        mean_ret = group_stats.T.xs(\'mean\', level=1).T\n\n    std_error_ret = group_stats.T.xs(\'std\', level=1).T \\\n        / np.sqrt(group_stats.T.xs(\'count\', level=1).T)\n\n    return mean_ret, std_error_ret\n\n\ndef compute_mean_returns_spread(mean_returns,\n                                upper_quant,\n                                lower_quant,\n                                std_err=None):\n    """"""\n    Computes the difference between the mean returns of\n    two quantiles. Optionally, computes the standard error\n    of this difference.\n\n    Parameters\n    ----------\n    mean_returns : pd.DataFrame\n        DataFrame of mean period wise returns by quantile.\n        MultiIndex containing date and quantile.\n        See mean_return_by_quantile.\n    upper_quant : int\n        Quantile of mean return from which we\n        wish to subtract lower quantile mean return.\n    lower_quant : int\n        Quantile of mean return we wish to subtract\n        from upper quantile mean return.\n    std_err : pd.DataFrame, optional\n        Period wise standard error in mean return by quantile.\n        Takes the same form as mean_returns.\n\n    Returns\n    -------\n    mean_return_difference : pd.Series\n        Period wise difference in quantile returns.\n    joint_std_err : pd.Series\n        Period wise standard error of the difference in quantile returns.\n        if std_err is None, this will be None\n    """"""\n\n    mean_return_difference = mean_returns.xs(upper_quant,\n                                             level=\'factor_quantile\') \\\n        - mean_returns.xs(lower_quant, level=\'factor_quantile\')\n\n    if std_err is None:\n        joint_std_err = None\n    else:\n        std1 = std_err.xs(upper_quant, level=\'factor_quantile\')\n        std2 = std_err.xs(lower_quant, level=\'factor_quantile\')\n        joint_std_err = np.sqrt(std1**2 + std2**2)\n\n    return mean_return_difference, joint_std_err\n\n\ndef quantile_turnover(quantile_factor, quantile, period=1):\n    """"""\n    Computes the proportion of names in a factor quantile that were\n    not in that quantile in the previous period.\n\n    Parameters\n    ----------\n    quantile_factor : pd.Series\n        DataFrame with date, asset and factor quantile.\n    quantile : int\n        Quantile on which to perform turnover analysis.\n    period: int, optional\n        Number of days over which to calculate the turnover.\n\n    Returns\n    -------\n    quant_turnover : pd.Series\n        Period by period turnover for that quantile.\n    """"""\n\n    quant_names = quantile_factor[quantile_factor == quantile]\n    quant_name_sets = quant_names.groupby(level=[\'date\']).apply(\n        lambda x: set(x.index.get_level_values(\'asset\')))\n\n    name_shifted = quant_name_sets.shift(period)\n\n    new_names = (quant_name_sets - name_shifted).dropna()\n    quant_turnover = new_names.apply(\n        lambda x: len(x)) / quant_name_sets.apply(lambda x: len(x))\n    quant_turnover.name = quantile\n    return quant_turnover\n\n\ndef factor_rank_autocorrelation(factor_data, period=1):\n    """"""\n    Computes autocorrelation of mean factor ranks in specified time spans.\n    We must compare period to period factor ranks rather than factor values\n    to account for systematic shifts in the factor values of all names or names\n    within a group. This metric is useful for measuring the turnover of a\n    factor. If the value of a factor for each name changes randomly from period\n    to period, we\'d expect an autocorrelation of 0.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    period: int, optional\n        Number of days over which to calculate the turnover.\n\n    Returns\n    -------\n    autocorr : pd.Series\n        Rolling 1 period (defined by time_rule) autocorrelation of\n        factor values.\n    """"""\n    grouper = [factor_data.index.get_level_values(\'date\')]\n\n    ranks = factor_data.groupby(grouper)[\'factor\'].rank()\n\n    asset_factor_rank = ranks.reset_index().pivot(index=\'date\',\n                                                  columns=\'asset\',\n                                                  values=\'factor\')\n\n    asset_shifted = asset_factor_rank.shift(period)\n\n    autocorr = asset_factor_rank.corrwith(asset_shifted, axis=1)\n    autocorr.name = period\n    return autocorr\n\n\ndef common_start_returns(factor,\n                         returns,\n                         before,\n                         after,\n                         cumulative=False,\n                         mean_by_date=False,\n                         demean_by=None):\n    """"""\n    A date and equity pair is extracted from each index row in the factor\n    dataframe and for each of these pairs a return series is built starting\n    from \'before\' the date and ending \'after\' the date specified in the pair.\n    All those returns series are then aligned to a common index (-before to\n    after) and returned as a single DataFrame\n\n    Parameters\n    ----------\n    factor : pd.DataFrame\n        DataFrame with at least date and equity as index, the columns are\n        irrelevant\n    returns : pd.DataFrame\n        A wide form Pandas DataFrame indexed by date with assets in the\n        columns. Returns data should span the factor analysis time period\n        plus/minus an additional buffer window corresponding to after/before\n        period parameters.\n    before:\n        How many returns to load before factor date\n    after:\n        How many returns to load after factor date\n    cumulative: bool, optional\n        Whether or not the given returns are cumulative. If False the given\n        returns are assumed to be daily.\n    mean_by_date: bool, optional\n        If True, compute mean returns for each date and return that\n        instead of a return series for each asset\n    demean_by: pd.DataFrame, optional\n        DataFrame with at least date and equity as index, the columns are\n        irrelevant. For each date a list of equities is extracted from\n        \'demean_by\' index and used as universe to compute demeaned mean\n        returns (long short portfolio)\n\n    Returns\n    -------\n    aligned_returns : pd.DataFrame\n        Dataframe containing returns series for each factor aligned to the same\n        index: -before to after\n    """"""\n    if not cumulative:\n        returns = returns.apply(cumulative_returns, axis=0)\n\n    all_returns = []\n\n    for timestamp, df in factor.groupby(level=\'date\'):\n\n        equities = df.index.get_level_values(\'asset\')\n\n        try:\n            day_zero_index = returns.index.get_loc(timestamp)\n        except KeyError:\n            continue\n\n        starting_index = max(day_zero_index - before, 0)\n        ending_index = min(day_zero_index + after + 1,\n                           len(returns.index))\n\n        equities_slice = set(equities)\n        if demean_by is not None:\n            demean_equities = demean_by.loc[timestamp] \\\n                .index.get_level_values(\'asset\')\n            equities_slice |= set(demean_equities)\n\n        series = returns.loc[returns.index[starting_index:ending_index],\n                             equities_slice]\n        series.index = range(starting_index - day_zero_index,\n                             ending_index - day_zero_index)\n\n        if demean_by is not None:\n            mean = series.loc[:, demean_equities].mean(axis=1)\n            series = series.loc[:, equities]\n            series = series.sub(mean, axis=0)\n\n        if mean_by_date:\n            series = series.mean(axis=1)\n\n        all_returns.append(series)\n\n    return pd.concat(all_returns, axis=1)\n\n\ndef average_cumulative_return_by_quantile(factor_data,\n                                          returns,\n                                          periods_before=10,\n                                          periods_after=15,\n                                          demeaned=True,\n                                          group_adjust=False,\n                                          by_group=False):\n    """"""\n    Plots average cumulative returns by factor quantiles in the period range\n    defined by -periods_before to periods_after\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    returns : pd.DataFrame\n        A wide form Pandas DataFrame indexed by date with assets in the\n        columns. Returns data should span the factor analysis time period\n        plus/minus an additional buffer window corresponding to periods_after/\n        periods_before parameters.\n    periods_before : int, optional\n        How many periods before factor to plot\n    periods_after  : int, optional\n        How many periods after factor to plot\n    demeaned : bool, optional\n        Compute demeaned mean returns (long short portfolio)\n    group_adjust : bool\n        Returns demeaning will occur on the group level (group\n        neutral portfolio)\n    by_group : bool\n        If True, compute cumulative returns separately for each group\n\n    Returns\n    -------\n    cumulative returns and std deviation : pd.DataFrame\n        A MultiIndex DataFrame indexed by quantile (level 0) and mean/std\n        (level 1) and the values on the columns in range from\n        -periods_before to periods_after\n        If by_group=True the index will have an additional \'group\' level\n        ::\n            ---------------------------------------------------\n                        |       | -2  | -1  |  0  |  1  | ...\n            ---------------------------------------------------\n              quantile  |       |     |     |     |     |\n            ---------------------------------------------------\n                        | mean  |  x  |  x  |  x  |  x  |\n                 1      ---------------------------------------\n                        | std   |  x  |  x  |  x  |  x  |\n            ---------------------------------------------------\n                        | mean  |  x  |  x  |  x  |  x  |\n                 2      ---------------------------------------\n                        | std   |  x  |  x  |  x  |  x  |\n            ---------------------------------------------------\n                ...     |                 ...\n            ---------------------------------------------------\n    """"""\n\n    def cumulative_return_around_event(q_fact, demean_by):\n        return common_start_returns(\n            q_fact,\n            returns,\n            periods_before,\n            periods_after,\n            cumulative=True,\n            mean_by_date=True,\n            demean_by=demean_by,\n        )\n\n    def average_cumulative_return(q_fact, demean_by):\n        q_returns = cumulative_return_around_event(q_fact, demean_by)\n        q_returns.replace([np.inf, -np.inf], np.nan, inplace=True)\n\n        return pd.DataFrame({\'mean\': q_returns.mean(skipna=True, axis=1),\n                             \'std\': q_returns.std(skipna=True, axis=1)}).T\n\n    if by_group:\n        #\n        # Compute quantile cumulative returns separately for each group\n        # Deman those returns accordingly to \'group_adjust\' and \'demeaned\'\n        #\n        returns_bygroup = []\n\n        for group, g_data in factor_data.groupby(\'group\'):\n            g_fq = g_data[\'factor_quantile\']\n            if group_adjust:\n                demean_by = g_fq  # demeans at group level\n            elif demeaned:\n                demean_by = factor_data[\'factor_quantile\']  # demean by all\n            else:\n                demean_by = None\n            #\n            # Align cumulative return from different dates to the same index\n            # then compute mean and std\n            #\n            avgcumret = g_fq.groupby(g_fq).apply(average_cumulative_return,\n                                                 demean_by)\n            if len(avgcumret) == 0:\n                continue\n\n            avgcumret[\'group\'] = group\n            avgcumret.set_index(\'group\', append=True, inplace=True)\n            returns_bygroup.append(avgcumret)\n\n        return pd.concat(returns_bygroup, axis=0)\n\n    else:\n        #\n        # Compute quantile cumulative returns for the full factor_data\n        # Align cumulative return from different dates to the same index\n        # then compute mean and std\n        # Deman those returns accordingly to \'group_adjust\' and \'demeaned\'\n        #\n        if group_adjust:\n            all_returns = []\n            for group, g_data in factor_data.groupby(\'group\'):\n                g_fq = g_data[\'factor_quantile\']\n                avgcumret = g_fq.groupby(g_fq).apply(\n                    cumulative_return_around_event, g_fq\n                )\n                all_returns.append(avgcumret)\n            q_returns = pd.concat(all_returns, axis=1)\n            q_returns = pd.DataFrame({\'mean\': q_returns.mean(axis=1),\n                                      \'std\': q_returns.std(axis=1)})\n            return q_returns.unstack(level=1).stack(level=0)\n        elif demeaned:\n            fq = factor_data[\'factor_quantile\']\n            return fq.groupby(fq).apply(average_cumulative_return, fq)\n        else:\n            fq = factor_data[\'factor_quantile\']\n            return fq.groupby(fq).apply(average_cumulative_return, None)\n\n\ndef factor_cumulative_returns(factor_data,\n                              period,\n                              long_short=True,\n                              group_neutral=False,\n                              equal_weight=False,\n                              quantiles=None,\n                              groups=None):\n    """"""\n    Simulate a portfolio using the factor in input and returns the cumulative\n    returns of the simulated portfolio\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to,\n        and (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    period : string\n        \'factor_data\' column name corresponding to the \'period\' returns to be\n        used in the computation of porfolio returns\n    long_short : bool, optional\n        if True then simulates a dollar neutral long-short portfolio\n        - see performance.create_pyfolio_input for more details\n    group_neutral : bool, optional\n        If True then simulates a group neutral portfolio\n        - see performance.create_pyfolio_input for more details\n    equal_weight : bool, optional\n        Control the assets weights:\n        - see performance.create_pyfolio_input for more details\n    quantiles: sequence[int], optional\n        Use only specific quantiles in the computation. By default all\n        quantiles are used\n    groups: sequence[string], optional\n        Use only specific groups in the computation. By default all groups\n        are used\n\n    Returns\n    -------\n    Cumulative returns series : pd.Series\n        Example:\n            2015-07-16 09:30:00  -0.012143\n            2015-07-16 12:30:00   0.012546\n            2015-07-17 09:30:00   0.045350\n            2015-07-17 12:30:00   0.065897\n            2015-07-20 09:30:00   0.030957\n    """"""\n    fwd_ret_cols = utils.get_forward_returns_columns(factor_data.columns)\n\n    if period not in fwd_ret_cols:\n        raise ValueError(""Period \'%s\' not found"" % period)\n\n    todrop = list(fwd_ret_cols)\n    todrop.remove(period)\n    portfolio_data = factor_data.drop(todrop, axis=1)\n\n    if quantiles is not None:\n        portfolio_data = portfolio_data[portfolio_data[\'factor_quantile\'].isin(\n            quantiles)]\n\n    if groups is not None:\n        portfolio_data = portfolio_data[portfolio_data[\'group\'].isin(groups)]\n\n    returns = \\\n        factor_returns(portfolio_data, long_short, group_neutral, equal_weight)\n\n    return cumulative_returns(returns[period], period)\n\n\ndef factor_positions(factor_data,\n                     period,\n                     long_short=True,\n                     group_neutral=False,\n                     equal_weight=False,\n                     quantiles=None,\n                     groups=None):\n    """"""\n    Simulate a portfolio using the factor in input and returns the assets\n    positions as percentage of the total portfolio.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to,\n        and (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    period : string\n        \'factor_data\' column name corresponding to the \'period\' returns to be\n        used in the computation of porfolio returns\n    long_short : bool, optional\n        if True then simulates a dollar neutral long-short portfolio\n        - see performance.create_pyfolio_input for more details\n    group_neutral : bool, optional\n        If True then simulates a group neutral portfolio\n        - see performance.create_pyfolio_input for more details\n    equal_weight : bool, optional\n        Control the assets weights:\n        - see performance.create_pyfolio_input for more details.\n    quantiles: sequence[int], optional\n        Use only specific quantiles in the computation. By default all\n        quantiles are used\n    groups: sequence[string], optional\n        Use only specific groups in the computation. By default all groups\n        are used\n\n    Returns\n    -------\n    assets positions : pd.DataFrame\n        Assets positions series, datetime on index, assets on columns.\n        Example:\n            index                 \'AAPL\'         \'MSFT\'          cash\n            2004-01-09 10:30:00   13939.3800     -14012.9930     711.5585\n            2004-01-09 15:30:00       0.00       -16012.9930     411.5585\n            2004-01-12 10:30:00   14492.6300     -14624.8700       0.0\n            2004-01-12 15:30:00   14874.5400     -15841.2500       0.0\n            2004-01-13 10:30:00   -13853.2800    13653.6400      -43.6375\n    """"""\n    fwd_ret_cols = utils.get_forward_returns_columns(factor_data.columns)\n\n    if period not in fwd_ret_cols:\n        raise ValueError(""Period \'%s\' not found"" % period)\n\n    todrop = list(fwd_ret_cols)\n    todrop.remove(period)\n    portfolio_data = factor_data.drop(todrop, axis=1)\n\n    if quantiles is not None:\n        portfolio_data = portfolio_data[portfolio_data[\'factor_quantile\'].isin(\n            quantiles)]\n\n    if groups is not None:\n        portfolio_data = portfolio_data[portfolio_data[\'group\'].isin(groups)]\n\n    weights = \\\n        factor_weights(portfolio_data, long_short, group_neutral, equal_weight)\n\n    return positions(weights, period)\n\n\ndef create_pyfolio_input(factor_data,\n                         period,\n                         capital=None,\n                         long_short=True,\n                         group_neutral=False,\n                         equal_weight=False,\n                         quantiles=None,\n                         groups=None,\n                         benchmark_period=\'1D\'):\n    """"""\n    Simulate a portfolio using the input factor and returns the portfolio\n    performance data properly formatted for Pyfolio analysis.\n\n    For more details on how this portfolio is built see:\n    - performance.cumulative_returns (how the portfolio returns are computed)\n    - performance.factor_weights (how assets weights are computed)\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to,\n        and (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    period : string\n        \'factor_data\' column name corresponding to the \'period\' returns to be\n        used in the computation of porfolio returns\n    capital : float, optional\n        If set, then compute \'positions\' in dollar amount instead of percentage\n    long_short : bool, optional\n        if True enforce a dollar neutral long-short portfolio: asset weights\n        will be computed by demeaning factor values and dividing by the sum of\n        their absolute value (achieving gross leverage of 1) which will cause\n        the portfolio to hold both long and short positions and the total\n        weights of both long and short positions will be equal.\n        If False the portfolio weights will be computed dividing the factor\n        values and  by the sum of their absolute value (achieving gross\n        leverage of 1). Positive factor values will generate long positions and\n        negative factor values will produce short positions so that a factor\n        with only posive values will result in a long only portfolio.\n    group_neutral : bool, optional\n        If True simulates a group neutral portfolio: the portfolio weights\n        will be computed so that each group will weigh the same.\n        if \'long_short\' is enabled the factor values demeaning will occur on\n        the group level resulting in a dollar neutral, group neutral,\n        long-short portfolio.\n        If False group information will not be used in weights computation.\n    equal_weight : bool, optional\n        if True the assets will be equal-weighted. If long_short is True then\n        the factor universe will be split in two equal sized groups with the\n        top assets in long positions and bottom assets in short positions.\n        if False the assets will be factor-weighed, see \'long_short\' argument\n    quantiles: sequence[int], optional\n        Use only specific quantiles in the computation. By default all\n        quantiles are used\n    groups: sequence[string], optional\n        Use only specific groups in the computation. By default all groups\n        are used\n    benchmark_period : string, optional\n        By default benchmark returns are computed as the factor universe mean\n        daily returns but \'benchmark_period\' allows to choose a \'factor_data\'\n        column corresponding to the returns to be used in the computation of\n        benchmark returns. More generally benchmark returns are computed as the\n        factor universe returns traded at \'benchmark_period\' frequency, equal\n        weighting and long only\n\n\n    Returns\n    -------\n     returns : pd.Series\n        Daily returns of the strategy, noncumulative.\n         - Time series with decimal returns.\n         - Example:\n            2015-07-16    -0.012143\n            2015-07-17    0.045350\n            2015-07-20    0.030957\n            2015-07-21    0.004902\n\n     positions : pd.DataFrame\n        Time series of dollar amount (or percentage when \'capital\' is not\n        provided) invested in each position and cash.\n         - Days where stocks are not held can be represented by 0.\n         - Non-working capital is labelled \'cash\'\n         - Example:\n            index         \'AAPL\'         \'MSFT\'          cash\n            2004-01-09    13939.3800     -14012.9930     711.5585\n            2004-01-12    14492.6300     -14624.8700     27.1821\n            2004-01-13    -13853.2800    13653.6400      -43.6375\n\n\n     benchmark : pd.Series\n        Benchmark returns computed as the factor universe mean daily returns.\n\n    """"""\n\n    #\n    # Build returns:\n    # we don\'t know the frequency at which the factor returns are computed but\n    # pyfolio wants daily returns. So we compute the cumulative returns of the\n    # factor, then resample it at 1 day frequency and finally compute daily\n    # returns\n    #\n    cumrets = factor_cumulative_returns(factor_data,\n                                        period,\n                                        long_short,\n                                        group_neutral,\n                                        equal_weight,\n                                        quantiles,\n                                        groups)\n    cumrets = cumrets.resample(\'1D\').last().fillna(method=\'ffill\')\n    returns = cumrets.pct_change().fillna(0)\n\n    #\n    # Build positions. As pyfolio asks for daily position we have to resample\n    # the positions returned by \'factor_positions\' at 1 day frequency and\n    # recompute the weights so that the sum of daily weights is 1.0\n    #\n    positions = factor_positions(factor_data,\n                                 period,\n                                 long_short,\n                                 group_neutral,\n                                 equal_weight,\n                                 quantiles,\n                                 groups)\n    positions = positions.resample(\'1D\').sum().fillna(method=\'ffill\')\n    positions = positions.div(positions.abs().sum(axis=1), axis=0).fillna(0)\n    positions[\'cash\'] = 1. - positions.sum(axis=1)\n\n    # transform percentage positions to dollar positions\n    if capital is not None:\n        positions = positions.mul(\n            cumrets.reindex(positions.index) * capital, axis=0)\n\n    #\n    #\n    #\n    # Build benchmark returns as the factor universe mean returns traded at\n    # \'benchmark_period\' frequency\n    #\n    fwd_ret_cols = utils.get_forward_returns_columns(factor_data.columns)\n    if benchmark_period in fwd_ret_cols:\n        benchmark_data = factor_data.copy()\n        # make sure no negative positions\n        benchmark_data[\'factor\'] = benchmark_data[\'factor\'].abs()\n        benchmark_rets = factor_cumulative_returns(benchmark_data,\n                                                   benchmark_period,\n                                                   long_short=False,\n                                                   group_neutral=False,\n                                                   equal_weight=True)\n        benchmark_rets = benchmark_rets.resample(\n            \'1D\').last().fillna(method=\'ffill\')\n        benchmark_rets = benchmark_rets.pct_change().fillna(0)\n        benchmark_rets.name = \'benchmark\'\n    else:\n        benchmark_rets = None\n\n    return returns, positions, benchmark_rets\n'"
alphalens/plotting.py,10,"b'#\n# Copyright 2017 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport numpy as np\nimport pandas as pd\nfrom scipy import stats\nimport statsmodels.api as sm\n\nimport seaborn as sns\nimport matplotlib.cm as cm\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import ScalarFormatter\n\nfrom functools import wraps\n\nfrom . import utils\nfrom . import performance as perf\n\nDECIMAL_TO_BPS = 10000\n\n\ndef customize(func):\n    """"""\n    Decorator to set plotting context and axes style during function call.\n    """"""\n    @wraps(func)\n    def call_w_context(*args, **kwargs):\n        set_context = kwargs.pop(\'set_context\', True)\n        if set_context:\n            color_palette = sns.color_palette(\'colorblind\')\n            with plotting_context(), axes_style(), color_palette:\n                sns.despine(left=True)\n                return func(*args, **kwargs)\n        else:\n            return func(*args, **kwargs)\n    return call_w_context\n\n\ndef plotting_context(context=\'notebook\', font_scale=1.5, rc=None):\n    """"""\n    Create alphalens default plotting style context.\n\n    Under the hood, calls and returns seaborn.plotting_context() with\n    some custom settings. Usually you would use in a with-context.\n\n    Parameters\n    ----------\n    context : str, optional\n        Name of seaborn context.\n    font_scale : float, optional\n        Scale font by factor font_scale.\n    rc : dict, optional\n        Config flags.\n        By default, {\'lines.linewidth\': 1.5}\n        is being used and will be added to any\n        rc passed in, unless explicitly overriden.\n\n    Returns\n    -------\n    seaborn plotting context\n\n    Example\n    -------\n    with alphalens.plotting.plotting_context(font_scale=2):\n        alphalens.create_full_tear_sheet(..., set_context=False)\n\n    See also\n    --------\n    For more information, see seaborn.plotting_context().\n    """"""\n    if rc is None:\n        rc = {}\n\n    rc_default = {\'lines.linewidth\': 1.5}\n\n    # Add defaults if they do not exist\n    for name, val in rc_default.items():\n        rc.setdefault(name, val)\n\n    return sns.plotting_context(context=context, font_scale=font_scale, rc=rc)\n\n\ndef axes_style(style=\'darkgrid\', rc=None):\n    """"""Create alphalens default axes style context.\n\n    Under the hood, calls and returns seaborn.axes_style() with\n    some custom settings. Usually you would use in a with-context.\n\n    Parameters\n    ----------\n    style : str, optional\n        Name of seaborn style.\n    rc : dict, optional\n        Config flags.\n\n    Returns\n    -------\n    seaborn plotting context\n\n    Example\n    -------\n    with alphalens.plotting.axes_style(style=\'whitegrid\'):\n        alphalens.create_full_tear_sheet(..., set_context=False)\n\n    See also\n    --------\n    For more information, see seaborn.plotting_context().\n\n    """"""\n    if rc is None:\n        rc = {}\n\n    rc_default = {}\n\n    # Add defaults if they do not exist\n    for name, val in rc_default.items():\n        rc.setdefault(name, val)\n\n    return sns.axes_style(style=style, rc=rc)\n\n\ndef plot_returns_table(alpha_beta,\n                       mean_ret_quantile,\n                       mean_ret_spread_quantile):\n    returns_table = pd.DataFrame()\n    returns_table = returns_table.append(alpha_beta)\n    returns_table.loc[""Mean Period Wise Return Top Quantile (bps)""] = \\\n        mean_ret_quantile.iloc[-1] * DECIMAL_TO_BPS\n    returns_table.loc[""Mean Period Wise Return Bottom Quantile (bps)""] = \\\n        mean_ret_quantile.iloc[0] * DECIMAL_TO_BPS\n    returns_table.loc[""Mean Period Wise Spread (bps)""] = \\\n        mean_ret_spread_quantile.mean() * DECIMAL_TO_BPS\n\n    print(""Returns Analysis"")\n    utils.print_table(returns_table.apply(lambda x: x.round(3)))\n\n\ndef plot_turnover_table(autocorrelation_data, quantile_turnover):\n    turnover_table = pd.DataFrame()\n    for period in sorted(quantile_turnover.keys()):\n        for quantile, p_data in quantile_turnover[period].iteritems():\n            turnover_table.loc[""Quantile {} Mean Turnover "".format(quantile),\n                               ""{}D"".format(period)] = p_data.mean()\n    auto_corr = pd.DataFrame()\n    for period, p_data in autocorrelation_data.iteritems():\n        auto_corr.loc[""Mean Factor Rank Autocorrelation"",\n                      ""{}D"".format(period)] = p_data.mean()\n\n    print(""Turnover Analysis"")\n    utils.print_table(turnover_table.apply(lambda x: x.round(3)))\n    utils.print_table(auto_corr.apply(lambda x: x.round(3)))\n\n\ndef plot_information_table(ic_data):\n    ic_summary_table = pd.DataFrame()\n    ic_summary_table[""IC Mean""] = ic_data.mean()\n    ic_summary_table[""IC Std.""] = ic_data.std()\n    ic_summary_table[""Risk-Adjusted IC""] = \\\n        ic_data.mean() / ic_data.std()\n    t_stat, p_value = stats.ttest_1samp(ic_data, 0)\n    ic_summary_table[""t-stat(IC)""] = t_stat\n    ic_summary_table[""p-value(IC)""] = p_value\n    ic_summary_table[""IC Skew""] = stats.skew(ic_data)\n    ic_summary_table[""IC Kurtosis""] = stats.kurtosis(ic_data)\n\n    print(""Information Analysis"")\n    utils.print_table(ic_summary_table.apply(lambda x: x.round(3)).T)\n\n\ndef plot_quantile_statistics_table(factor_data):\n    quantile_stats = factor_data.groupby(\'factor_quantile\') \\\n        .agg([\'min\', \'max\', \'mean\', \'std\', \'count\'])[\'factor\']\n    quantile_stats[\'count %\'] = quantile_stats[\'count\'] \\\n        / quantile_stats[\'count\'].sum() * 100.\n\n    print(""Quantiles Statistics"")\n    utils.print_table(quantile_stats)\n\n\ndef plot_ic_ts(ic, ax=None):\n    """"""\n    Plots Spearman Rank Information Coefficient and IC moving\n    average for a given factor.\n\n    Parameters\n    ----------\n    ic : pd.DataFrame\n        DataFrame indexed by date, with IC for each forward return.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n    ic = ic.copy()\n\n    num_plots = len(ic.columns)\n    if ax is None:\n        f, ax = plt.subplots(num_plots, 1, figsize=(18, num_plots * 7))\n        ax = np.asarray([ax]).flatten()\n\n    ymin, ymax = (None, None)\n    for a, (period_num, ic) in zip(ax, ic.iteritems()):\n        ic.plot(alpha=0.7, ax=a, lw=0.7, color=\'steelblue\')\n        ic.rolling(window=22).mean().plot(\n            ax=a,\n            color=\'forestgreen\',\n            lw=2,\n            alpha=0.8\n        )\n\n        a.set(ylabel=\'IC\', xlabel="""")\n        a.set_title(\n            ""{} Period Forward Return Information Coefficient (IC)""\n            .format(period_num))\n        a.axhline(0.0, linestyle=\'-\', color=\'black\', lw=1, alpha=0.8)\n        a.legend([\'IC\', \'1 month moving avg\'], loc=\'upper right\')\n        a.text(.05, .95, ""Mean %.3f \\n Std. %.3f"" % (ic.mean(), ic.std()),\n               fontsize=16,\n               bbox={\'facecolor\': \'white\', \'alpha\': 1, \'pad\': 5},\n               transform=a.transAxes,\n               verticalalignment=\'top\')\n\n        curr_ymin, curr_ymax = a.get_ylim()\n        ymin = curr_ymin if ymin is None else min(ymin, curr_ymin)\n        ymax = curr_ymax if ymax is None else max(ymax, curr_ymax)\n\n    for a in ax:\n        a.set_ylim([ymin, ymax])\n\n    return ax\n\n\ndef plot_ic_hist(ic, ax=None):\n    """"""\n    Plots Spearman Rank Information Coefficient histogram for a given factor.\n\n    Parameters\n    ----------\n    ic : pd.DataFrame\n        DataFrame indexed by date, with IC for each forward return.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    ic = ic.copy()\n\n    num_plots = len(ic.columns)\n\n    v_spaces = ((num_plots - 1) // 3) + 1\n\n    if ax is None:\n        f, ax = plt.subplots(v_spaces, 3, figsize=(18, v_spaces * 6))\n        ax = ax.flatten()\n\n    for a, (period_num, ic) in zip(ax, ic.iteritems()):\n        sns.distplot(ic.replace(np.nan, 0.), norm_hist=True, ax=a)\n        a.set(title=""%s Period IC"" % period_num, xlabel=\'IC\')\n        a.set_xlim([-1, 1])\n        a.text(.05, .95, ""Mean %.3f \\n Std. %.3f"" % (ic.mean(), ic.std()),\n               fontsize=16,\n               bbox={\'facecolor\': \'white\', \'alpha\': 1, \'pad\': 5},\n               transform=a.transAxes,\n               verticalalignment=\'top\')\n        a.axvline(ic.mean(), color=\'w\', linestyle=\'dashed\', linewidth=2)\n\n    if num_plots < len(ax):\n        ax[-1].set_visible(False)\n\n    return ax\n\n\ndef plot_ic_qq(ic, theoretical_dist=stats.norm, ax=None):\n    """"""\n    Plots Spearman Rank Information Coefficient ""Q-Q"" plot relative to\n    a theoretical distribution.\n\n    Parameters\n    ----------\n    ic : pd.DataFrame\n        DataFrame indexed by date, with IC for each forward return.\n    theoretical_dist : scipy.stats._continuous_distns\n        Continuous distribution generator. scipy.stats.norm and\n        scipy.stats.t are popular options.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    ic = ic.copy()\n\n    num_plots = len(ic.columns)\n\n    v_spaces = ((num_plots - 1) // 3) + 1\n\n    if ax is None:\n        f, ax = plt.subplots(v_spaces, 3, figsize=(18, v_spaces * 6))\n        ax = ax.flatten()\n\n    if isinstance(theoretical_dist, stats.norm.__class__):\n        dist_name = \'Normal\'\n    elif isinstance(theoretical_dist, stats.t.__class__):\n        dist_name = \'T\'\n    else:\n        dist_name = \'Theoretical\'\n\n    for a, (period_num, ic) in zip(ax, ic.iteritems()):\n        sm.qqplot(ic.replace(np.nan, 0.).values, theoretical_dist, fit=True,\n                  line=\'45\', ax=a)\n        a.set(title=""{} Period IC {} Dist. Q-Q"".format(\n              period_num, dist_name),\n              ylabel=\'Observed Quantile\',\n              xlabel=\'{} Distribution Quantile\'.format(dist_name))\n\n    return ax\n\n\ndef plot_quantile_returns_bar(mean_ret_by_q,\n                              by_group=False,\n                              ylim_percentiles=None,\n                              ax=None):\n    """"""\n    Plots mean period wise returns for factor quantiles.\n\n    Parameters\n    ----------\n    mean_ret_by_q : pd.DataFrame\n        DataFrame with quantile, (group) and mean period wise return values.\n    by_group : bool\n        Disaggregated figures by group.\n    ylim_percentiles : tuple of integers\n        Percentiles of observed data to use as y limits for plot.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    mean_ret_by_q = mean_ret_by_q.copy()\n\n    if ylim_percentiles is not None:\n        ymin = (np.nanpercentile(mean_ret_by_q.values,\n                                 ylim_percentiles[0]) * DECIMAL_TO_BPS)\n        ymax = (np.nanpercentile(mean_ret_by_q.values,\n                                 ylim_percentiles[1]) * DECIMAL_TO_BPS)\n    else:\n        ymin = None\n        ymax = None\n\n    if by_group:\n        num_group = len(\n            mean_ret_by_q.index.get_level_values(\'group\').unique())\n\n        if ax is None:\n            v_spaces = ((num_group - 1) // 2) + 1\n            f, ax = plt.subplots(v_spaces, 2, sharex=False,\n                                 sharey=True, figsize=(18, 6 * v_spaces))\n            ax = ax.flatten()\n\n        for a, (sc, cor) in zip(ax, mean_ret_by_q.groupby(level=\'group\')):\n            (cor.xs(sc, level=\'group\')\n                .multiply(DECIMAL_TO_BPS)\n                .plot(kind=\'bar\', title=sc, ax=a))\n\n            a.set(xlabel=\'\', ylabel=\'Mean Return (bps)\',\n                  ylim=(ymin, ymax))\n\n        if num_group < len(ax):\n            ax[-1].set_visible(False)\n\n        return ax\n\n    else:\n        if ax is None:\n            f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n        (mean_ret_by_q.multiply(DECIMAL_TO_BPS)\n            .plot(kind=\'bar\',\n                  title=""Mean Period Wise Return By Factor Quantile"", ax=ax))\n        ax.set(xlabel=\'\', ylabel=\'Mean Return (bps)\',\n               ylim=(ymin, ymax))\n\n        return ax\n\n\ndef plot_quantile_returns_violin(return_by_q,\n                                 ylim_percentiles=None,\n                                 ax=None):\n    """"""\n    Plots a violin box plot of period wise returns for factor quantiles.\n\n    Parameters\n    ----------\n    return_by_q : pd.DataFrame - MultiIndex\n        DataFrame with date and quantile as rows MultiIndex,\n        forward return windows as columns, returns as values.\n    ylim_percentiles : tuple of integers\n        Percentiles of observed data to use as y limits for plot.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    return_by_q = return_by_q.copy()\n\n    if ylim_percentiles is not None:\n        ymin = (np.nanpercentile(return_by_q.values,\n                                 ylim_percentiles[0]) * DECIMAL_TO_BPS)\n        ymax = (np.nanpercentile(return_by_q.values,\n                                 ylim_percentiles[1]) * DECIMAL_TO_BPS)\n    else:\n        ymin = None\n        ymax = None\n\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    unstacked_dr = (return_by_q\n                    .multiply(DECIMAL_TO_BPS))\n    unstacked_dr.columns = unstacked_dr.columns.set_names(\'forward_periods\')\n    unstacked_dr = unstacked_dr.stack()\n    unstacked_dr.name = \'return\'\n    unstacked_dr = unstacked_dr.reset_index()\n\n    sns.violinplot(data=unstacked_dr,\n                   x=\'factor_quantile\',\n                   hue=\'forward_periods\',\n                   y=\'return\',\n                   orient=\'v\',\n                   cut=0,\n                   inner=\'quartile\',\n                   ax=ax)\n    ax.set(xlabel=\'\', ylabel=\'Return (bps)\',\n           title=""Period Wise Return By Factor Quantile"",\n           ylim=(ymin, ymax))\n\n    ax.axhline(0.0, linestyle=\'-\', color=\'black\', lw=0.7, alpha=0.6)\n\n    return ax\n\n\ndef plot_mean_quantile_returns_spread_time_series(mean_returns_spread,\n                                                  std_err=None,\n                                                  bandwidth=1,\n                                                  ax=None):\n    """"""\n    Plots mean period wise returns for factor quantiles.\n\n    Parameters\n    ----------\n    mean_returns_spread : pd.Series\n        Series with difference between quantile mean returns by period.\n    std_err : pd.Series\n        Series with standard error of difference between quantile\n        mean returns each period.\n    bandwidth : float\n        Width of displayed error bands in standard deviations.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    if isinstance(mean_returns_spread, pd.DataFrame):\n        if ax is None:\n            ax = [None for a in mean_returns_spread.columns]\n\n        ymin, ymax = (None, None)\n        for (i, a), (name, fr_column) in zip(enumerate(ax),\n                                             mean_returns_spread.iteritems()):\n            stdn = None if std_err is None else std_err[name]\n            a = plot_mean_quantile_returns_spread_time_series(fr_column,\n                                                              std_err=stdn,\n                                                              ax=a)\n            ax[i] = a\n            curr_ymin, curr_ymax = a.get_ylim()\n            ymin = curr_ymin if ymin is None else min(ymin, curr_ymin)\n            ymax = curr_ymax if ymax is None else max(ymax, curr_ymax)\n\n        for a in ax:\n            a.set_ylim([ymin, ymax])\n\n        return ax\n\n    if mean_returns_spread.isnull().all():\n        return ax\n\n    periods = mean_returns_spread.name\n    title = (\'Top Minus Bottom Quantile Mean Return ({} Period Forward Return)\'\n             .format(periods if periods is not None else """"))\n\n    if ax is None:\n        f, ax = plt.subplots(figsize=(18, 6))\n\n    mean_returns_spread_bps = mean_returns_spread * DECIMAL_TO_BPS\n\n    mean_returns_spread_bps.plot(alpha=0.4, ax=ax, lw=0.7, color=\'forestgreen\')\n    mean_returns_spread_bps.rolling(window=22).mean().plot(\n        color=\'orangered\',\n        alpha=0.7,\n        ax=ax\n    )\n    ax.legend([\'mean returns spread\', \'1 month moving avg\'], loc=\'upper right\')\n\n    if std_err is not None:\n        std_err_bps = std_err * DECIMAL_TO_BPS\n        upper = mean_returns_spread_bps.values + (std_err_bps * bandwidth)\n        lower = mean_returns_spread_bps.values - (std_err_bps * bandwidth)\n        ax.fill_between(mean_returns_spread.index,\n                        lower,\n                        upper,\n                        alpha=0.3,\n                        color=\'steelblue\')\n\n    ylim = np.nanpercentile(abs(mean_returns_spread_bps.values), 95)\n    ax.set(ylabel=\'Difference In Quantile Mean Return (bps)\',\n           xlabel=\'\',\n           title=title,\n           ylim=(-ylim, ylim))\n    ax.axhline(0.0, linestyle=\'-\', color=\'black\', lw=1, alpha=0.8)\n\n    return ax\n\n\ndef plot_ic_by_group(ic_group, ax=None):\n    """"""\n    Plots Spearman Rank Information Coefficient for a given factor over\n    provided forward returns. Separates by group.\n\n    Parameters\n    ----------\n    ic_group : pd.DataFrame\n        group-wise mean period wise returns.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n    ic_group.plot(kind=\'bar\', ax=ax)\n\n    ax.set(title=""Information Coefficient By Group"", xlabel="""")\n    ax.set_xticklabels(ic_group.index, rotation=45)\n\n    return ax\n\n\ndef plot_factor_rank_auto_correlation(factor_autocorrelation,\n                                      period=1,\n                                      ax=None):\n    """"""\n    Plots factor rank autocorrelation over time.\n    See factor_rank_autocorrelation for more details.\n\n    Parameters\n    ----------\n    factor_autocorrelation : pd.Series\n        Rolling 1 period (defined by time_rule) autocorrelation\n        of factor values.\n    period: int, optional\n        Period over which the autocorrelation is calculated\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    factor_autocorrelation.plot(title=\'{}D Period Factor Rank Autocorrelation\'\n                                .format(period), ax=ax)\n    ax.set(ylabel=\'Autocorrelation Coefficient\', xlabel=\'\')\n    ax.axhline(0.0, linestyle=\'-\', color=\'black\', lw=1)\n    ax.text(.05, .95, ""Mean %.3f"" % factor_autocorrelation.mean(),\n            fontsize=16,\n            bbox={\'facecolor\': \'white\', \'alpha\': 1, \'pad\': 5},\n            transform=ax.transAxes,\n            verticalalignment=\'top\')\n\n    return ax\n\n\ndef plot_top_bottom_quantile_turnover(quantile_turnover, period=1, ax=None):\n    """"""\n    Plots period wise top and bottom quantile factor turnover.\n\n    Parameters\n    ----------\n    quantile_turnover: pd.Dataframe\n        Quantile turnover (each DataFrame column a quantile).\n    period: int, optional\n        Period over which to calculate the turnover.\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    max_quantile = quantile_turnover.columns.max()\n    min_quantile = quantile_turnover.columns.min()\n    turnover = pd.DataFrame()\n    turnover[\'top quantile turnover\'] = quantile_turnover[max_quantile]\n    turnover[\'bottom quantile turnover\'] = quantile_turnover[min_quantile]\n    turnover.plot(title=\'{}D Period Top and Bottom Quantile Turnover\'\n                  .format(period), ax=ax, alpha=0.6, lw=0.8)\n    ax.set(ylabel=\'Proportion Of Names New To Quantile\', xlabel="""")\n\n    return ax\n\n\ndef plot_monthly_ic_heatmap(mean_monthly_ic, ax=None):\n    """"""\n    Plots a heatmap of the information coefficient or returns by month.\n\n    Parameters\n    ----------\n    mean_monthly_ic : pd.DataFrame\n        The mean monthly IC for N periods forward.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n\n    mean_monthly_ic = mean_monthly_ic.copy()\n\n    num_plots = len(mean_monthly_ic.columns)\n\n    v_spaces = ((num_plots - 1) // 3) + 1\n\n    if ax is None:\n        f, ax = plt.subplots(v_spaces, 3, figsize=(18, v_spaces * 6))\n        ax = ax.flatten()\n\n    new_index_year = []\n    new_index_month = []\n    for date in mean_monthly_ic.index:\n        new_index_year.append(date.year)\n        new_index_month.append(date.month)\n\n    mean_monthly_ic.index = pd.MultiIndex.from_arrays(\n        [new_index_year, new_index_month],\n        names=[""year"", ""month""])\n\n    for a, (periods_num, ic) in zip(ax, mean_monthly_ic.iteritems()):\n\n        sns.heatmap(\n            ic.unstack(),\n            annot=True,\n            alpha=1.0,\n            center=0.0,\n            annot_kws={""size"": 7},\n            linewidths=0.01,\n            linecolor=\'white\',\n            cmap=cm.coolwarm_r,\n            cbar=False,\n            ax=a)\n        a.set(ylabel=\'\', xlabel=\'\')\n\n        a.set_title(""Monthly Mean {} Period IC"".format(periods_num))\n\n    if num_plots < len(ax):\n        ax[-1].set_visible(False)\n\n    return ax\n\n\ndef plot_cumulative_returns(factor_returns,\n                            period,\n                            freq=None,\n                            title=None,\n                            ax=None):\n    """"""\n    Plots the cumulative returns of the returns series passed in.\n\n    Parameters\n    ----------\n    factor_returns : pd.Series\n        Period wise returns of dollar neutral portfolio weighted by factor\n        value.\n    period : pandas.Timedelta or string\n        Length of period for which the returns are computed (e.g. 1 day)\n        if \'period\' is a string it must follow pandas.Timedelta constructor\n        format (e.g. \'1 days\', \'1D\', \'30m\', \'3h\', \'1D1h\', etc)\n    freq : pandas DateOffset\n        Used to specify a particular trading calendar e.g. BusinessDay or Day\n        Usually this is inferred from utils.infer_trading_calendar, which is\n        called by either get_clean_factor_and_forward_returns or\n        compute_forward_returns\n    title: string, optional\n        Custom title\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n        The axes that were plotted on.\n    """"""\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    factor_returns = perf.cumulative_returns(factor_returns)\n\n    factor_returns.plot(ax=ax, lw=3, color=\'forestgreen\', alpha=0.6)\n    ax.set(ylabel=\'Cumulative Returns\',\n           title=(""Portfolio Cumulative Return ({} Fwd Period)"".format(period)\n                  if title is None else title),\n           xlabel=\'\')\n    ax.axhline(1.0, linestyle=\'-\', color=\'black\', lw=1)\n\n    return ax\n\n\ndef plot_cumulative_returns_by_quantile(quantile_returns,\n                                        period,\n                                        freq=None,\n                                        ax=None):\n    """"""\n    Plots the cumulative returns of various factor quantiles.\n\n    Parameters\n    ----------\n    quantile_returns : pd.DataFrame\n        Returns by factor quantile\n    period : pandas.Timedelta or string\n        Length of period for which the returns are computed (e.g. 1 day)\n        if \'period\' is a string it must follow pandas.Timedelta constructor\n        format (e.g. \'1 days\', \'1D\', \'30m\', \'3h\', \'1D1h\', etc)\n    freq : pandas DateOffset\n        Used to specify a particular trading calendar e.g. BusinessDay or Day\n        Usually this is inferred from utils.infer_trading_calendar, which is\n        called by either get_clean_factor_and_forward_returns or\n        compute_forward_returns\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n    """"""\n\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    ret_wide = quantile_returns.unstack(\'factor_quantile\')\n\n    cum_ret = ret_wide.apply(perf.cumulative_returns)\n\n    cum_ret = cum_ret.loc[:, ::-1]  # we want negative quantiles as \'red\'\n\n    cum_ret.plot(lw=2, ax=ax, cmap=cm.coolwarm)\n    ax.legend()\n    ymin, ymax = cum_ret.min().min(), cum_ret.max().max()\n    ax.set(ylabel=\'Log Cumulative Returns\',\n           title=\'\'\'Cumulative Return by Quantile\n                    ({} Period Forward Return)\'\'\'.format(period),\n           xlabel=\'\',\n           yscale=\'symlog\',\n           yticks=np.linspace(ymin, ymax, 5),\n           ylim=(ymin, ymax))\n\n    ax.yaxis.set_major_formatter(ScalarFormatter())\n    ax.axhline(1.0, linestyle=\'-\', color=\'black\', lw=1)\n\n    return ax\n\n\ndef plot_quantile_average_cumulative_return(avg_cumulative_returns,\n                                            by_quantile=False,\n                                            std_bar=False,\n                                            title=None,\n                                            ax=None):\n    """"""\n    Plots sector-wise mean daily returns for factor quantiles\n    across provided forward price movement columns.\n\n    Parameters\n    ----------\n    avg_cumulative_returns: pd.Dataframe\n        The format is the one returned by\n        performance.average_cumulative_return_by_quantile\n    by_quantile : boolean, optional\n        Disaggregated figures by quantile (useful to clearly see std dev bars)\n    std_bar : boolean, optional\n        Plot standard deviation plot\n    title: string, optional\n        Custom title\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n    """"""\n\n    avg_cumulative_returns = avg_cumulative_returns.multiply(DECIMAL_TO_BPS)\n    quantiles = len(avg_cumulative_returns.index.levels[0].unique())\n    palette = [cm.coolwarm(i) for i in np.linspace(0, 1, quantiles)]\n    palette = palette[::-1]  # we want negative quantiles as \'red\'\n\n    if by_quantile:\n\n        if ax is None:\n            v_spaces = ((quantiles - 1) // 2) + 1\n            f, ax = plt.subplots(v_spaces, 2, sharex=False,\n                                 sharey=False, figsize=(18, 6 * v_spaces))\n            ax = ax.flatten()\n\n        for i, (quantile, q_ret) in enumerate(avg_cumulative_returns\n                                              .groupby(level=\'factor_quantile\')\n                                              ):\n\n            mean = q_ret.loc[(quantile, \'mean\')]\n            mean.name = \'Quantile \' + str(quantile)\n            mean.plot(ax=ax[i], color=palette[i])\n            ax[i].set_ylabel(\'Mean Return (bps)\')\n\n            if std_bar:\n                std = q_ret.loc[(quantile, \'std\')]\n                ax[i].errorbar(std.index, mean, yerr=std,\n                               fmt=\'none\', ecolor=palette[i], label=\'none\')\n\n            ax[i].axvline(x=0, color=\'k\', linestyle=\'--\')\n            ax[i].legend()\n            i += 1\n\n    else:\n\n        if ax is None:\n            f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n        for i, (quantile, q_ret) in enumerate(avg_cumulative_returns\n                                              .groupby(level=\'factor_quantile\')\n                                              ):\n\n            mean = q_ret.loc[(quantile, \'mean\')]\n            mean.name = \'Quantile \' + str(quantile)\n            mean.plot(ax=ax, color=palette[i])\n\n            if std_bar:\n                std = q_ret.loc[(quantile, \'std\')]\n                ax.errorbar(std.index, mean, yerr=std,\n                            fmt=\'none\', ecolor=palette[i], label=\'none\')\n            i += 1\n\n        ax.axvline(x=0, color=\'k\', linestyle=\'--\')\n        ax.legend()\n        ax.set(ylabel=\'Mean Return (bps)\',\n               title=(""Average Cumulative Returns by Quantile""\n                      if title is None else title),\n               xlabel=\'Periods\')\n\n    return ax\n\n\ndef plot_events_distribution(events, num_bars=50, ax=None):\n    """"""\n    Plots the distribution of events in time.\n\n    Parameters\n    ----------\n    events : pd.Series\n        A pd.Series whose index contains at least \'date\' level.\n    num_bars : integer, optional\n        Number of bars to plot\n    ax : matplotlib.Axes, optional\n        Axes upon which to plot.\n\n    Returns\n    -------\n    ax : matplotlib.Axes\n    """"""\n\n    if ax is None:\n        f, ax = plt.subplots(1, 1, figsize=(18, 6))\n\n    start = events.index.get_level_values(\'date\').min()\n    end = events.index.get_level_values(\'date\').max()\n    group_interval = (end - start) / num_bars\n    grouper = pd.Grouper(level=\'date\', freq=group_interval)\n    events.groupby(grouper).count().plot(kind=""bar"", grid=False, ax=ax)\n    ax.set(ylabel=\'Number of events\',\n           title=\'Distribution of events in time\',\n           xlabel=\'Date\')\n\n    return ax\n'"
alphalens/tears.py,0,"b'#\n# Copyright 2017 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport matplotlib.gridspec as gridspec\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport warnings\n\nfrom . import plotting\nfrom . import performance as perf\nfrom . import utils\n\n\nclass GridFigure(object):\n    """"""\n    It makes life easier with grid plots\n    """"""\n\n    def __init__(self, rows, cols):\n        self.rows = rows\n        self.cols = cols\n        self.fig = plt.figure(figsize=(14, rows * 7))\n        self.gs = gridspec.GridSpec(rows, cols, wspace=0.4, hspace=0.3)\n        self.curr_row = 0\n        self.curr_col = 0\n\n    def next_row(self):\n        if self.curr_col != 0:\n            self.curr_row += 1\n            self.curr_col = 0\n        subplt = plt.subplot(self.gs[self.curr_row, :])\n        self.curr_row += 1\n        return subplt\n\n    def next_cell(self):\n        if self.curr_col >= self.cols:\n            self.curr_row += 1\n            self.curr_col = 0\n        subplt = plt.subplot(self.gs[self.curr_row, self.curr_col])\n        self.curr_col += 1\n        return subplt\n\n    def close(self):\n        plt.close(self.fig)\n        self.fig = None\n        self.gs = None\n\n\n@plotting.customize\ndef create_summary_tear_sheet(\n    factor_data, long_short=True, group_neutral=False\n):\n    """"""\n    Creates a small summary tear sheet with returns, information, and turnover\n    analysis.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    long_short : bool\n        Should this computation happen on a long short portfolio? if so, then\n        mean quantile returns will be demeaned across the factor universe.\n    group_neutral : bool\n        Should this computation happen on a group neutral portfolio? if so,\n        returns demeaning will occur on the group level.\n    """"""\n\n    # Returns Analysis\n    mean_quant_ret, std_quantile = perf.mean_return_by_quantile(\n        factor_data,\n        by_group=False,\n        demeaned=long_short,\n        group_adjust=group_neutral,\n    )\n\n    mean_quant_rateret = mean_quant_ret.apply(\n        utils.rate_of_return, axis=0, base_period=mean_quant_ret.columns[0]\n    )\n\n    mean_quant_ret_bydate, std_quant_daily = perf.mean_return_by_quantile(\n        factor_data,\n        by_date=True,\n        by_group=False,\n        demeaned=long_short,\n        group_adjust=group_neutral,\n    )\n\n    mean_quant_rateret_bydate = mean_quant_ret_bydate.apply(\n        utils.rate_of_return,\n        axis=0,\n        base_period=mean_quant_ret_bydate.columns[0],\n    )\n\n    compstd_quant_daily = std_quant_daily.apply(\n        utils.std_conversion, axis=0, base_period=std_quant_daily.columns[0]\n    )\n\n    alpha_beta = perf.factor_alpha_beta(\n        factor_data, demeaned=long_short, group_adjust=group_neutral\n    )\n\n    mean_ret_spread_quant, std_spread_quant = perf.compute_mean_returns_spread(\n        mean_quant_rateret_bydate,\n        factor_data[""factor_quantile""].max(),\n        factor_data[""factor_quantile""].min(),\n        std_err=compstd_quant_daily,\n    )\n\n    periods = utils.get_forward_returns_columns(factor_data.columns)\n    periods = list(map(lambda p: pd.Timedelta(p).days, periods))\n\n    fr_cols = len(periods)\n    vertical_sections = 2 + fr_cols * 3\n    gf = GridFigure(rows=vertical_sections, cols=1)\n\n    plotting.plot_quantile_statistics_table(factor_data)\n\n    plotting.plot_returns_table(\n        alpha_beta, mean_quant_rateret, mean_ret_spread_quant\n    )\n\n    plotting.plot_quantile_returns_bar(\n        mean_quant_rateret,\n        by_group=False,\n        ylim_percentiles=None,\n        ax=gf.next_row(),\n    )\n\n    # Information Analysis\n    ic = perf.factor_information_coefficient(factor_data)\n    plotting.plot_information_table(ic)\n\n    # Turnover Analysis\n    quantile_factor = factor_data[""factor_quantile""]\n\n    quantile_turnover = {\n        p: pd.concat(\n            [\n                perf.quantile_turnover(quantile_factor, q, p)\n                for q in range(1, int(quantile_factor.max()) + 1)\n            ],\n            axis=1,\n        )\n        for p in periods\n    }\n\n    autocorrelation = pd.concat(\n        [\n            perf.factor_rank_autocorrelation(factor_data, period)\n            for period in periods\n        ],\n        axis=1,\n    )\n\n    plotting.plot_turnover_table(autocorrelation, quantile_turnover)\n\n    plt.show()\n    gf.close()\n\n\n@plotting.customize\ndef create_returns_tear_sheet(\n    factor_data, long_short=True, group_neutral=False, by_group=False\n):\n    """"""\n    Creates a tear sheet for returns analysis of a factor.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to,\n        and (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    long_short : bool\n        Should this computation happen on a long short portfolio? if so, then\n        mean quantile returns will be demeaned across the factor universe.\n        Additionally factor values will be demeaned across the factor universe\n        when factor weighting the portfolio for cumulative returns plots\n    group_neutral : bool\n        Should this computation happen on a group neutral portfolio? if so,\n        returns demeaning will occur on the group level.\n        Additionally each group will weight the same in cumulative returns\n        plots\n    by_group : bool\n        If True, display graphs separately for each group.\n    """"""\n\n    factor_returns = perf.factor_returns(\n        factor_data, long_short, group_neutral\n    )\n\n    mean_quant_ret, std_quantile = perf.mean_return_by_quantile(\n        factor_data,\n        by_group=False,\n        demeaned=long_short,\n        group_adjust=group_neutral,\n    )\n\n    mean_quant_rateret = mean_quant_ret.apply(\n        utils.rate_of_return, axis=0, base_period=mean_quant_ret.columns[0]\n    )\n\n    mean_quant_ret_bydate, std_quant_daily = perf.mean_return_by_quantile(\n        factor_data,\n        by_date=True,\n        by_group=False,\n        demeaned=long_short,\n        group_adjust=group_neutral,\n    )\n\n    mean_quant_rateret_bydate = mean_quant_ret_bydate.apply(\n        utils.rate_of_return,\n        axis=0,\n        base_period=mean_quant_ret_bydate.columns[0],\n    )\n\n    compstd_quant_daily = std_quant_daily.apply(\n        utils.std_conversion, axis=0, base_period=std_quant_daily.columns[0]\n    )\n\n    alpha_beta = perf.factor_alpha_beta(\n        factor_data, factor_returns, long_short, group_neutral\n    )\n\n    mean_ret_spread_quant, std_spread_quant = perf.compute_mean_returns_spread(\n        mean_quant_rateret_bydate,\n        factor_data[""factor_quantile""].max(),\n        factor_data[""factor_quantile""].min(),\n        std_err=compstd_quant_daily,\n    )\n\n    fr_cols = len(factor_returns.columns)\n    vertical_sections = 2 + fr_cols * 3\n    gf = GridFigure(rows=vertical_sections, cols=1)\n\n    plotting.plot_returns_table(\n        alpha_beta, mean_quant_rateret, mean_ret_spread_quant\n    )\n\n    plotting.plot_quantile_returns_bar(\n        mean_quant_rateret,\n        by_group=False,\n        ylim_percentiles=None,\n        ax=gf.next_row(),\n    )\n\n    plotting.plot_quantile_returns_violin(\n        mean_quant_rateret_bydate, ylim_percentiles=(1, 99), ax=gf.next_row()\n    )\n\n    trading_calendar = factor_data.index.levels[0].freq\n    if trading_calendar is None:\n        trading_calendar = pd.tseries.offsets.BDay()\n        warnings.warn(\n            ""\'freq\' not set in factor_data index: assuming business day"",\n            UserWarning,\n        )\n\n    # Compute cumulative returns from daily simple returns, if \'1D\'\n    # returns are provided.\n    if ""1D"" in factor_returns:\n        title = (\n            ""Factor Weighted ""\n            + (""Group Neutral "" if group_neutral else """")\n            + (""Long/Short "" if long_short else """")\n            + ""Portfolio Cumulative Return (1D Period)""\n        )\n\n        plotting.plot_cumulative_returns(\n            factor_returns[""1D""], period=""1D"", title=title, ax=gf.next_row()\n        )\n\n        plotting.plot_cumulative_returns_by_quantile(\n            mean_quant_ret_bydate[""1D""], period=""1D"", ax=gf.next_row()\n        )\n\n    ax_mean_quantile_returns_spread_ts = [\n        gf.next_row() for x in range(fr_cols)\n    ]\n    plotting.plot_mean_quantile_returns_spread_time_series(\n        mean_ret_spread_quant,\n        std_err=std_spread_quant,\n        bandwidth=0.5,\n        ax=ax_mean_quantile_returns_spread_ts,\n    )\n\n    plt.show()\n    gf.close()\n\n    if by_group:\n        (\n            mean_return_quantile_group,\n            mean_return_quantile_group_std_err,\n        ) = perf.mean_return_by_quantile(\n            factor_data,\n            by_date=False,\n            by_group=True,\n            demeaned=long_short,\n            group_adjust=group_neutral,\n        )\n\n        mean_quant_rateret_group = mean_return_quantile_group.apply(\n            utils.rate_of_return,\n            axis=0,\n            base_period=mean_return_quantile_group.columns[0],\n        )\n\n        num_groups = len(\n            mean_quant_rateret_group.index.get_level_values(""group"").unique()\n        )\n\n        vertical_sections = 1 + (((num_groups - 1) // 2) + 1)\n        gf = GridFigure(rows=vertical_sections, cols=2)\n\n        ax_quantile_returns_bar_by_group = [\n            gf.next_cell() for _ in range(num_groups)\n        ]\n        plotting.plot_quantile_returns_bar(\n            mean_quant_rateret_group,\n            by_group=True,\n            ylim_percentiles=(5, 95),\n            ax=ax_quantile_returns_bar_by_group,\n        )\n        plt.show()\n        gf.close()\n\n\n@plotting.customize\ndef create_information_tear_sheet(\n    factor_data, group_neutral=False, by_group=False\n):\n    """"""\n    Creates a tear sheet for information analysis of a factor.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    group_neutral : bool\n        Demean forward returns by group before computing IC.\n    by_group : bool\n        If True, display graphs separately for each group.\n    """"""\n\n    ic = perf.factor_information_coefficient(factor_data, group_neutral)\n\n    plotting.plot_information_table(ic)\n\n    columns_wide = 2\n    fr_cols = len(ic.columns)\n    rows_when_wide = ((fr_cols - 1) // columns_wide) + 1\n    vertical_sections = fr_cols + 3 * rows_when_wide + 2 * fr_cols\n    gf = GridFigure(rows=vertical_sections, cols=columns_wide)\n\n    ax_ic_ts = [gf.next_row() for _ in range(fr_cols)]\n    plotting.plot_ic_ts(ic, ax=ax_ic_ts)\n\n    ax_ic_hqq = [gf.next_cell() for _ in range(fr_cols * 2)]\n    plotting.plot_ic_hist(ic, ax=ax_ic_hqq[::2])\n    plotting.plot_ic_qq(ic, ax=ax_ic_hqq[1::2])\n\n    if not by_group:\n\n        mean_monthly_ic = perf.mean_information_coefficient(\n            factor_data,\n            group_adjust=group_neutral,\n            by_group=False,\n            by_time=""M"",\n        )\n        ax_monthly_ic_heatmap = [gf.next_cell() for x in range(fr_cols)]\n        plotting.plot_monthly_ic_heatmap(\n            mean_monthly_ic, ax=ax_monthly_ic_heatmap\n        )\n\n    if by_group:\n        mean_group_ic = perf.mean_information_coefficient(\n            factor_data, group_adjust=group_neutral, by_group=True\n        )\n\n        plotting.plot_ic_by_group(mean_group_ic, ax=gf.next_row())\n\n    plt.show()\n    gf.close()\n\n\n@plotting.customize\ndef create_turnover_tear_sheet(factor_data, turnover_periods=None):\n    """"""\n    Creates a tear sheet for analyzing the turnover properties of a factor.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    turnover_periods : sequence[string], optional\n        Periods to compute turnover analysis on. By default periods in\n        \'factor_data\' are used but custom periods can provided instead. This\n        can be useful when periods in \'factor_data\' are not multiples of the\n        frequency at which factor values are computed i.e. the periods\n        are 2h and 4h and the factor is computed daily and so values like\n        [\'1D\', \'2D\'] could be used instead\n    """"""\n\n    if turnover_periods is None:\n        input_periods = utils.get_forward_returns_columns(\n            factor_data.columns, require_exact_day_multiple=True,\n        ).get_values()\n        turnover_periods = utils.timedelta_strings_to_integers(input_periods)\n    else:\n        turnover_periods = utils.timedelta_strings_to_integers(\n            turnover_periods,\n        )\n\n    quantile_factor = factor_data[""factor_quantile""]\n\n    quantile_turnover = {\n        p: pd.concat(\n            [\n                perf.quantile_turnover(quantile_factor, q, p)\n                for q in quantile_factor.sort_values().unique().tolist()\n            ],\n            axis=1,\n        )\n        for p in turnover_periods\n    }\n\n    autocorrelation = pd.concat(\n        [\n            perf.factor_rank_autocorrelation(factor_data, period)\n            for period in turnover_periods\n        ],\n        axis=1,\n    )\n\n    plotting.plot_turnover_table(autocorrelation, quantile_turnover)\n\n    fr_cols = len(turnover_periods)\n    columns_wide = 1\n    rows_when_wide = ((fr_cols - 1) // 1) + 1\n    vertical_sections = fr_cols + 3 * rows_when_wide + 2 * fr_cols\n    gf = GridFigure(rows=vertical_sections, cols=columns_wide)\n\n    for period in turnover_periods:\n        if quantile_turnover[period].isnull().all().all():\n            continue\n        plotting.plot_top_bottom_quantile_turnover(\n            quantile_turnover[period], period=period, ax=gf.next_row()\n        )\n\n    for period in autocorrelation:\n        if autocorrelation[period].isnull().all():\n            continue\n        plotting.plot_factor_rank_auto_correlation(\n            autocorrelation[period], period=period, ax=gf.next_row()\n        )\n\n    plt.show()\n    gf.close()\n\n\n@plotting.customize\ndef create_full_tear_sheet(factor_data,\n                           long_short=True,\n                           group_neutral=False,\n                           by_group=False):\n    """"""\n    Creates a full tear sheet for analysis and evaluating single\n    return predicting (alpha) factor.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    long_short : bool\n        Should this computation happen on a long short portfolio?\n        - See tears.create_returns_tear_sheet for details on how this flag\n        affects returns analysis\n    group_neutral : bool\n        Should this computation happen on a group neutral portfolio?\n        - See tears.create_returns_tear_sheet for details on how this flag\n        affects returns analysis\n        - See tears.create_information_tear_sheet for details on how this\n        flag affects information analysis\n    by_group : bool\n        If True, display graphs separately for each group.\n    """"""\n\n    plotting.plot_quantile_statistics_table(factor_data)\n    create_returns_tear_sheet(\n        factor_data, long_short, group_neutral, by_group, set_context=False\n    )\n    create_information_tear_sheet(\n        factor_data, group_neutral, by_group, set_context=False\n    )\n    create_turnover_tear_sheet(factor_data, set_context=False)\n\n\n@plotting.customize\ndef create_event_returns_tear_sheet(factor_data,\n                                    returns,\n                                    avgretplot=(5, 15),\n                                    long_short=True,\n                                    group_neutral=False,\n                                    std_bar=True,\n                                    by_group=False):\n    """"""\n    Creates a tear sheet to view the average cumulative returns for a\n    factor within a window (pre and post event).\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex Series indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, the factor\n        quantile/bin that factor value belongs to and (optionally) the group\n        the asset belongs to.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    returns : pd.DataFrame\n        A DataFrame indexed by date with assets in the columns containing daily\n        returns.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    avgretplot: tuple (int, int) - (before, after)\n        If not None, plot quantile average cumulative returns\n    long_short : bool\n        Should this computation happen on a long short portfolio? if so then\n        factor returns will be demeaned across the factor universe\n    group_neutral : bool\n        Should this computation happen on a group neutral portfolio? if so,\n        returns demeaning will occur on the group level.\n    std_bar : boolean, optional\n        Show plots with standard deviation bars, one for each quantile\n    by_group : bool\n        If True, display graphs separately for each group.\n    """"""\n\n    before, after = avgretplot\n\n    avg_cumulative_returns = perf.average_cumulative_return_by_quantile(\n        factor_data,\n        returns,\n        periods_before=before,\n        periods_after=after,\n        demeaned=long_short,\n        group_adjust=group_neutral,\n    )\n\n    num_quantiles = int(factor_data[""factor_quantile""].max())\n\n    vertical_sections = 1\n    if std_bar:\n        vertical_sections += ((num_quantiles - 1) // 2) + 1\n    cols = 2 if num_quantiles != 1 else 1\n    gf = GridFigure(rows=vertical_sections, cols=cols)\n    plotting.plot_quantile_average_cumulative_return(\n        avg_cumulative_returns,\n        by_quantile=False,\n        std_bar=False,\n        ax=gf.next_row(),\n    )\n    if std_bar:\n        ax_avg_cumulative_returns_by_q = [\n            gf.next_cell() for _ in range(num_quantiles)\n        ]\n        plotting.plot_quantile_average_cumulative_return(\n            avg_cumulative_returns,\n            by_quantile=True,\n            std_bar=True,\n            ax=ax_avg_cumulative_returns_by_q,\n        )\n\n    plt.show()\n    gf.close()\n\n    if by_group:\n        groups = factor_data[""group""].unique()\n        num_groups = len(groups)\n        vertical_sections = ((num_groups - 1) // 2) + 1\n        gf = GridFigure(rows=vertical_sections, cols=2)\n\n        avg_cumret_by_group = perf.average_cumulative_return_by_quantile(\n            factor_data,\n            returns,\n            periods_before=before,\n            periods_after=after,\n            demeaned=long_short,\n            group_adjust=group_neutral,\n            by_group=True,\n        )\n\n        for group, avg_cumret in avg_cumret_by_group.groupby(level=""group""):\n            avg_cumret.index = avg_cumret.index.droplevel(""group"")\n            plotting.plot_quantile_average_cumulative_return(\n                avg_cumret,\n                by_quantile=False,\n                std_bar=False,\n                title=group,\n                ax=gf.next_cell(),\n            )\n\n        plt.show()\n        gf.close()\n\n\n@plotting.customize\ndef create_event_study_tear_sheet(factor_data,\n                                  returns,\n                                  avgretplot=(5, 15),\n                                  rate_of_ret=True,\n                                  n_bars=50):\n    """"""\n    Creates an event study tear sheet for analysis of a specific event.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single event, forward returns for each\n        period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n    returns : pd.DataFrame, required only if \'avgretplot\' is provided\n        A DataFrame indexed by date with assets in the columns containing daily\n        returns.\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n    avgretplot: tuple (int, int) - (before, after), optional\n        If not None, plot event style average cumulative returns within a\n        window (pre and post event).\n    rate_of_ret : bool, optional\n        Display rate of return instead of simple return in \'Mean Period Wise\n        Return By Factor Quantile\' and \'Period Wise Return By Factor Quantile\'\n        plots\n    n_bars : int, optional\n        Number of bars in event distribution plot\n    """"""\n\n    long_short = False\n\n    plotting.plot_quantile_statistics_table(factor_data)\n\n    gf = GridFigure(rows=1, cols=1)\n    plotting.plot_events_distribution(\n        events=factor_data[""factor""], num_bars=n_bars, ax=gf.next_row()\n    )\n    plt.show()\n    gf.close()\n\n    if returns is not None and avgretplot is not None:\n\n        create_event_returns_tear_sheet(\n            factor_data=factor_data,\n            returns=returns,\n            avgretplot=avgretplot,\n            long_short=long_short,\n            group_neutral=False,\n            std_bar=True,\n            by_group=False,\n        )\n\n    factor_returns = perf.factor_returns(\n        factor_data, demeaned=False, equal_weight=True\n    )\n\n    mean_quant_ret, std_quantile = perf.mean_return_by_quantile(\n        factor_data, by_group=False, demeaned=long_short\n    )\n    if rate_of_ret:\n        mean_quant_ret = mean_quant_ret.apply(\n            utils.rate_of_return, axis=0, base_period=mean_quant_ret.columns[0]\n        )\n\n    mean_quant_ret_bydate, std_quant_daily = perf.mean_return_by_quantile(\n        factor_data, by_date=True, by_group=False, demeaned=long_short\n    )\n    if rate_of_ret:\n        mean_quant_ret_bydate = mean_quant_ret_bydate.apply(\n            utils.rate_of_return,\n            axis=0,\n            base_period=mean_quant_ret_bydate.columns[0],\n        )\n\n    fr_cols = len(factor_returns.columns)\n    vertical_sections = 2 + fr_cols * 1\n    gf = GridFigure(rows=vertical_sections + 1, cols=1)\n\n    plotting.plot_quantile_returns_bar(\n        mean_quant_ret, by_group=False, ylim_percentiles=None, ax=gf.next_row()\n    )\n\n    plotting.plot_quantile_returns_violin(\n        mean_quant_ret_bydate, ylim_percentiles=(1, 99), ax=gf.next_row()\n    )\n\n    trading_calendar = factor_data.index.levels[0].freq\n    if trading_calendar is None:\n        trading_calendar = pd.tseries.offsets.BDay()\n        warnings.warn(\n            ""\'freq\' not set in factor_data index: assuming business day"",\n            UserWarning,\n        )\n\n    plt.show()\n    gf.close()\n'"
alphalens/utils.py,8,"b'#\n# Copyright 2018 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pandas as pd\nimport numpy as np\nimport re\nimport warnings\n\nfrom IPython.display import display\nfrom pandas.tseries.offsets import CustomBusinessDay, Day, BusinessDay\nfrom scipy.stats import mode\n\n\nclass NonMatchingTimezoneError(Exception):\n    pass\n\n\nclass MaxLossExceededError(Exception):\n    pass\n\n\ndef rethrow(exception, additional_message):\n    """"""\n    Re-raise the last exception that was active in the current scope\n    without losing the stacktrace but adding an additional message.\n    This is hacky because it has to be compatible with both python 2/3\n    """"""\n    e = exception\n    m = additional_message\n    if not e.args:\n        e.args = (m,)\n    else:\n        e.args = (e.args[0] + m,) + e.args[1:]\n    raise e\n\n\ndef non_unique_bin_edges_error(func):\n    """"""\n    Give user a more informative error in case it is not possible\n    to properly calculate quantiles on the input dataframe (factor)\n    """"""\n    message = """"""\n\n    An error occurred while computing bins/quantiles on the input provided.\n    This usually happens when the input contains too many identical\n    values and they span more than one quantile. The quantiles are choosen\n    to have the same number of records each, but the same value cannot span\n    multiple quantiles. Possible workarounds are:\n    1 - Decrease the number of quantiles\n    2 - Specify a custom quantiles range, e.g. [0, .50, .75, 1.] to get unequal\n        number of records per quantile\n    3 - Use \'bins\' option instead of \'quantiles\', \'bins\' chooses the\n        buckets to be evenly spaced according to the values themselves, while\n        \'quantiles\' forces the buckets to have the same number of records.\n    4 - for factors with discrete values use the \'bins\' option with custom\n        ranges and create a range for each discrete value\n    Please see utils.get_clean_factor_and_forward_returns documentation for\n    full documentation of \'bins\' and \'quantiles\' options.\n\n""""""\n\n    def dec(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except ValueError as e:\n            if \'Bin edges must be unique\' in str(e):\n                rethrow(e, message)\n            raise\n    return dec\n\n\n@non_unique_bin_edges_error\ndef quantize_factor(factor_data,\n                    quantiles=5,\n                    bins=None,\n                    by_group=False,\n                    no_raise=False,\n                    zero_aware=False):\n    """"""\n    Computes period wise factor quantiles.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n\n    quantiles : int or sequence[float]\n        Number of equal-sized quantile buckets to use in factor bucketing.\n        Alternately sequence of quantiles, allowing non-equal-sized buckets\n        e.g. [0, .10, .5, .90, 1.] or [.05, .5, .95]\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    bins : int or sequence[float]\n        Number of equal-width (valuewise) bins to use in factor bucketing.\n        Alternately sequence of bin edges allowing for non-uniform bin width\n        e.g. [-4, -2, -0.5, 0, 10]\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    by_group : bool, optional\n        If True, compute quantile buckets separately for each group.\n    no_raise: bool, optional\n        If True, no exceptions are thrown and the values for which the\n        exception would have been thrown are set to np.NaN\n    zero_aware : bool, optional\n        If True, compute quantile buckets separately for positive and negative\n        signal values. This is useful if your signal is centered and zero is\n        the separation between long and short signals, respectively.\n\n    Returns\n    -------\n    factor_quantile : pd.Series\n        Factor quantiles indexed by date and asset.\n    """"""\n    if not ((quantiles is not None and bins is None) or\n            (quantiles is None and bins is not None)):\n        raise ValueError(\'Either quantiles or bins should be provided\')\n\n    if zero_aware and not (isinstance(quantiles, int)\n                           or isinstance(bins, int)):\n        msg = (""zero_aware should only be True when quantiles or bins is an""\n               "" integer"")\n        raise ValueError(msg)\n\n    def quantile_calc(x, _quantiles, _bins, _zero_aware, _no_raise):\n        try:\n            if _quantiles is not None and _bins is None and not _zero_aware:\n                return pd.qcut(x, _quantiles, labels=False) + 1\n            elif _quantiles is not None and _bins is None and _zero_aware:\n                pos_quantiles = pd.qcut(x[x >= 0], _quantiles // 2,\n                                        labels=False) + _quantiles // 2 + 1\n                neg_quantiles = pd.qcut(x[x < 0], _quantiles // 2,\n                                        labels=False) + 1\n                return pd.concat([pos_quantiles, neg_quantiles]).sort_index()\n            elif _bins is not None and _quantiles is None and not _zero_aware:\n                return pd.cut(x, _bins, labels=False) + 1\n            elif _bins is not None and _quantiles is None and _zero_aware:\n                pos_bins = pd.cut(x[x >= 0], _bins // 2,\n                                  labels=False) + _bins // 2 + 1\n                neg_bins = pd.cut(x[x < 0], _bins // 2,\n                                  labels=False) + 1\n                return pd.concat([pos_bins, neg_bins]).sort_index()\n        except Exception as e:\n            if _no_raise:\n                return pd.Series(index=x.index)\n            raise e\n\n    grouper = [factor_data.index.get_level_values(\'date\')]\n    if by_group:\n        grouper.append(\'group\')\n\n    factor_quantile = factor_data.groupby(grouper)[\'factor\'] \\\n        .apply(quantile_calc, quantiles, bins, zero_aware, no_raise)\n    factor_quantile.name = \'factor_quantile\'\n\n    return factor_quantile.dropna()\n\n\ndef infer_trading_calendar(factor_idx, prices_idx):\n    """"""\n    Infer the trading calendar from factor and price information.\n\n    Parameters\n    ----------\n    factor_idx : pd.DatetimeIndex\n        The factor datetimes for which we are computing the forward returns\n    prices_idx : pd.DatetimeIndex\n        The prices datetimes associated withthe factor data\n\n    Returns\n    -------\n    calendar : pd.DateOffset\n    """"""\n    full_idx = factor_idx.union(prices_idx)\n\n    traded_weekdays = []\n    holidays = []\n\n    days_of_the_week = [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\']\n    for day, day_str in enumerate(days_of_the_week):\n\n        weekday_mask = (full_idx.dayofweek == day)\n\n        # drop days of the week that are not traded at all\n        if not weekday_mask.any():\n            continue\n        traded_weekdays.append(day_str)\n\n        # look for holidays\n        used_weekdays = full_idx[weekday_mask].normalize()\n        all_weekdays = pd.date_range(full_idx.min(), full_idx.max(),\n                                     freq=CustomBusinessDay(weekmask=day_str)\n                                     ).normalize()\n        _holidays = all_weekdays.difference(used_weekdays)\n        _holidays = [timestamp.date() for timestamp in _holidays]\n        holidays.extend(_holidays)\n\n    traded_weekdays = \' \'.join(traded_weekdays)\n    return CustomBusinessDay(weekmask=traded_weekdays, holidays=holidays)\n\n\ndef compute_forward_returns(factor,\n                            prices,\n                            periods=(1, 5, 10),\n                            filter_zscore=None,\n                            cumulative_returns=True):\n    """"""\n    Finds the N period forward returns (as percent change) for each asset\n    provided.\n\n    Parameters\n    ----------\n    factor : pd.Series - MultiIndex\n        A MultiIndex Series indexed by timestamp (level 0) and asset\n        (level 1), containing the values for a single alpha factor.\n\n        - See full explanation in utils.get_clean_factor_and_forward_returns\n\n    prices : pd.DataFrame\n        Pricing data to use in forward price calculation.\n        Assets as columns, dates as index. Pricing data must\n        span the factor analysis time period plus an additional buffer window\n        that is greater than the maximum number of expected periods\n        in the forward returns calculations.\n    periods : sequence[int]\n        periods to compute forward returns on.\n    filter_zscore : int or float, optional\n        Sets forward returns greater than X standard deviations\n        from the the mean to nan. Set it to \'None\' to avoid filtering.\n        Caution: this outlier filtering incorporates lookahead bias.\n    cumulative_returns : bool, optional\n        If True, forward returns columns will contain cumulative returns.\n        Setting this to False is useful if you want to analyze how predictive\n        a factor is for a single forward day.\n\n    Returns\n    -------\n    forward_returns : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by timestamp (level 0) and asset\n        (level 1), containing the forward returns for assets.\n        Forward returns column names follow the format accepted by\n        pd.Timedelta (e.g. \'1D\', \'30m\', \'3h15m\', \'1D1h\', etc).\n        \'date\' index freq property (forward_returns.index.levels[0].freq)\n        will be set to a trading calendar (pandas DateOffset) inferred\n        from the input data (see infer_trading_calendar for more details).\n    """"""\n\n    factor_dateindex = factor.index.levels[0]\n    if factor_dateindex.tz != prices.index.tz:\n        raise NonMatchingTimezoneError(""The timezone of \'factor\' is not the ""\n                                       ""same as the timezone of \'prices\'. See ""\n                                       ""the pandas methods tz_localize and ""\n                                       ""tz_convert."")\n\n    freq = infer_trading_calendar(factor_dateindex, prices.index)\n\n    factor_dateindex = factor_dateindex.intersection(prices.index)\n\n    if len(factor_dateindex) == 0:\n        raise ValueError(""Factor and prices indices don\'t match: make sure ""\n                         ""they have the same convention in terms of datetimes ""\n                         ""and symbol-names"")\n\n    # chop prices down to only the assets we care about (= unique assets in\n    # `factor`).  we could modify `prices` in place, but that might confuse\n    # the caller.\n    prices = prices.filter(items=factor.index.levels[1])\n\n    raw_values_dict = {}\n    column_list = []\n\n    for period in sorted(periods):\n        if cumulative_returns:\n            returns = prices.pct_change(period)\n        else:\n            returns = prices.pct_change()\n\n        forward_returns = \\\n            returns.shift(-period).reindex(factor_dateindex)\n\n        if filter_zscore is not None:\n            mask = abs(\n                forward_returns - forward_returns.mean()\n            ) > (filter_zscore * forward_returns.std())\n            forward_returns[mask] = np.nan\n\n        #\n        # Find the period length, which will be the column name. We\'ll test\n        # several entries in order to find out the most likely period length\n        # (in case the user passed inconsinstent data)\n        #\n        days_diffs = []\n        for i in range(30):\n            if i >= len(forward_returns.index):\n                break\n            p_idx = prices.index.get_loc(forward_returns.index[i])\n            if p_idx is None or p_idx < 0 or (\n                    p_idx + period) >= len(prices.index):\n                continue\n            start = prices.index[p_idx]\n            end = prices.index[p_idx + period]\n            period_len = diff_custom_calendar_timedeltas(start, end, freq)\n            days_diffs.append(period_len.components.days)\n\n        delta_days = period_len.components.days - mode(days_diffs).mode[0]\n        period_len -= pd.Timedelta(days=delta_days)\n        label = timedelta_to_string(period_len)\n\n        column_list.append(label)\n\n        raw_values_dict[label] = np.concatenate(forward_returns.values)\n\n    df = pd.DataFrame.from_dict(raw_values_dict)\n    df.set_index(\n        pd.MultiIndex.from_product(\n            [factor_dateindex, prices.columns],\n            names=[\'date\', \'asset\']\n        ),\n        inplace=True\n    )\n    df = df.reindex(factor.index)\n\n    # now set the columns correctly\n    df = df[column_list]\n\n    df.index.levels[0].freq = freq\n    df.index.set_names([\'date\', \'asset\'], inplace=True)\n\n    return df\n\n\ndef backshift_returns_series(series, N):\n    """"""Shift a multi-indexed series backwards by N observations in\n    the first level.\n\n    This can be used to convert backward-looking returns into a\n    forward-returns series.\n    """"""\n    ix = series.index\n    dates, sids = ix.levels\n    date_labels, sid_labels = map(np.array, ix.labels)\n\n    # Output date labels will contain the all but the last N dates.\n    new_dates = dates[:-N]\n\n    # Output data will remove the first M rows, where M is the index of the\n    # last record with one of the first N dates.\n    cutoff = date_labels.searchsorted(N)\n    new_date_labels = date_labels[cutoff:] - N\n    new_sid_labels = sid_labels[cutoff:]\n    new_values = series.values[cutoff:]\n\n    assert new_date_labels[0] == 0\n\n    new_index = pd.MultiIndex(\n        levels=[new_dates, sids],\n        labels=[new_date_labels, new_sid_labels],\n        sortorder=1,\n        names=ix.names,\n    )\n\n    return pd.Series(data=new_values, index=new_index)\n\n\ndef demean_forward_returns(factor_data, grouper=None):\n    """"""\n    Convert forward returns to returns relative to mean\n    period wise all-universe or group returns.\n    group-wise normalization incorporates the assumption of a\n    group neutral portfolio constraint and thus allows allows the\n    factor to be evaluated across groups.\n\n    For example, if AAPL 5 period return is 0.1% and mean 5 period\n    return for the Technology stocks in our universe was 0.5% in the\n    same period, the group adjusted 5 period return for AAPL in this\n    period is -0.4%.\n\n    Parameters\n    ----------\n    factor_data : pd.DataFrame - MultiIndex\n        Forward returns indexed by date and asset.\n        Separate column for each forward return window.\n    grouper : list\n        If True, demean according to group.\n\n    Returns\n    -------\n    adjusted_forward_returns : pd.DataFrame - MultiIndex\n        DataFrame of the same format as the input, but with each\n        security\'s returns normalized by group.\n    """"""\n\n    factor_data = factor_data.copy()\n\n    if not grouper:\n        grouper = factor_data.index.get_level_values(\'date\')\n\n    cols = get_forward_returns_columns(factor_data.columns)\n    factor_data[cols] = factor_data.groupby(grouper)[cols] \\\n        .transform(lambda x: x - x.mean())\n\n    return factor_data\n\n\ndef print_table(table, name=None, fmt=None):\n    """"""\n    Pretty print a pandas DataFrame.\n\n    Uses HTML output if running inside Jupyter Notebook, otherwise\n    formatted text output.\n\n    Parameters\n    ----------\n    table : pd.Series or pd.DataFrame\n        Table to pretty-print.\n    name : str, optional\n        Table name to display in upper left corner.\n    fmt : str, optional\n        Formatter to use for displaying table elements.\n        E.g. \'{0:.2f}%\' for displaying 100 as \'100.00%\'.\n        Restores original setting after displaying.\n    """"""\n    if isinstance(table, pd.Series):\n        table = pd.DataFrame(table)\n\n    if isinstance(table, pd.DataFrame):\n        table.columns.name = name\n\n    prev_option = pd.get_option(\'display.float_format\')\n    if fmt is not None:\n        pd.set_option(\'display.float_format\', lambda x: fmt.format(x))\n\n    display(table)\n\n    if fmt is not None:\n        pd.set_option(\'display.float_format\', prev_option)\n\n\ndef get_clean_factor(factor,\n                     forward_returns,\n                     groupby=None,\n                     binning_by_group=False,\n                     quantiles=5,\n                     bins=None,\n                     groupby_labels=None,\n                     max_loss=0.35,\n                     zero_aware=False):\n    """"""\n    Formats the factor data, forward return data, and group mappings into a\n    DataFrame that contains aligned MultiIndex indices of timestamp and asset.\n    The returned data will be formatted to be suitable for Alphalens functions.\n\n    It is safe to skip a call to this function and still make use of Alphalens\n    functionalities as long as the factor data conforms to the format returned\n    from get_clean_factor_and_forward_returns and documented here\n\n    Parameters\n    ----------\n    factor : pd.Series - MultiIndex\n        A MultiIndex Series indexed by timestamp (level 0) and asset\n        (level 1), containing the values for a single alpha factor.\n        ::\n            -----------------------------------\n                date    |    asset   |\n            -----------------------------------\n                        |   AAPL     |   0.5\n                        -----------------------\n                        |   BA       |  -1.1\n                        -----------------------\n            2014-01-01  |   CMG      |   1.7\n                        -----------------------\n                        |   DAL      |  -0.1\n                        -----------------------\n                        |   LULU     |   2.7\n                        -----------------------\n\n    forward_returns : pd.DataFrame - MultiIndex\n        A MultiIndex DataFrame indexed by timestamp (level 0) and asset\n        (level 1), containing the forward returns for assets.\n        Forward returns column names must follow the format accepted by\n        pd.Timedelta (e.g. \'1D\', \'30m\', \'3h15m\', \'1D1h\', etc).\n        \'date\' index freq property must be set to a trading calendar\n        (pandas DateOffset), see infer_trading_calendar for more details.\n        This information is currently used only in cumulative returns\n        computation\n        ::\n            ---------------------------------------\n                       |       | 1D  | 5D  | 10D\n            ---------------------------------------\n                date   | asset |     |     |\n            ---------------------------------------\n                       | AAPL  | 0.09|-0.01|-0.079\n                       ----------------------------\n                       | BA    | 0.02| 0.06| 0.020\n                       ----------------------------\n            2014-01-01 | CMG   | 0.03| 0.09| 0.036\n                       ----------------------------\n                       | DAL   |-0.02|-0.06|-0.029\n                       ----------------------------\n                       | LULU  |-0.03| 0.05|-0.009\n                       ----------------------------\n\n    groupby : pd.Series - MultiIndex or dict\n        Either A MultiIndex Series indexed by date and asset,\n        containing the period wise group codes for each asset, or\n        a dict of asset to group mappings. If a dict is passed,\n        it is assumed that group mappings are unchanged for the\n        entire time period of the passed factor data.\n    binning_by_group : bool\n        If True, compute quantile buckets separately for each group.\n        This is useful when the factor values range vary considerably\n        across gorups so that it is wise to make the binning group relative.\n        You should probably enable this if the factor is intended\n        to be analyzed for a group neutral portfolio\n    quantiles : int or sequence[float]\n        Number of equal-sized quantile buckets to use in factor bucketing.\n        Alternately sequence of quantiles, allowing non-equal-sized buckets\n        e.g. [0, .10, .5, .90, 1.] or [.05, .5, .95]\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    bins : int or sequence[float]\n        Number of equal-width (valuewise) bins to use in factor bucketing.\n        Alternately sequence of bin edges allowing for non-uniform bin width\n        e.g. [-4, -2, -0.5, 0, 10]\n        Chooses the buckets to be evenly spaced according to the values\n        themselves. Useful when the factor contains discrete values.\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    groupby_labels : dict\n        A dictionary keyed by group code with values corresponding\n        to the display name for each group.\n    max_loss : float, optional\n        Maximum percentage (0.00 to 1.00) of factor data dropping allowed,\n        computed comparing the number of items in the input factor index and\n        the number of items in the output DataFrame index.\n        Factor data can be partially dropped due to being flawed itself\n        (e.g. NaNs), not having provided enough price data to compute\n        forward returns for all factor values, or because it is not possible\n        to perform binning.\n        Set max_loss=0 to avoid Exceptions suppression.\n    zero_aware : bool, optional\n        If True, compute quantile buckets separately for positive and negative\n        signal values. This is useful if your signal is centered and zero is\n        the separation between long and short signals, respectively.\n        \'quantiles\' is None.\n\n    Returns\n    -------\n    merged_data : pd.DataFrame - MultiIndex\n        A MultiIndex Series indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n\n        - forward returns column names follow the format accepted by\n          pd.Timedelta (e.g. \'1D\', \'30m\', \'3h15m\', \'1D1h\', etc)\n\n        - \'date\' index freq property (merged_data.index.levels[0].freq) is the\n          same as that of the input forward returns data. This is currently\n          used only in cumulative returns computation\n        ::\n           -------------------------------------------------------------------\n                      |       | 1D  | 5D  | 10D  |factor|group|factor_quantile\n           -------------------------------------------------------------------\n               date   | asset |     |     |      |      |     |\n           -------------------------------------------------------------------\n                      | AAPL  | 0.09|-0.01|-0.079|  0.5 |  G1 |      3\n                      --------------------------------------------------------\n                      | BA    | 0.02| 0.06| 0.020| -1.1 |  G2 |      5\n                      --------------------------------------------------------\n           2014-01-01 | CMG   | 0.03| 0.09| 0.036|  1.7 |  G2 |      1\n                      --------------------------------------------------------\n                      | DAL   |-0.02|-0.06|-0.029| -0.1 |  G3 |      5\n                      --------------------------------------------------------\n                      | LULU  |-0.03| 0.05|-0.009|  2.7 |  G1 |      2\n                      --------------------------------------------------------\n    """"""\n\n    initial_amount = float(len(factor.index))\n\n    factor_copy = factor.copy()\n    factor_copy.index = factor_copy.index.rename([\'date\', \'asset\'])\n    factor_copy = factor_copy[np.isfinite(factor_copy)]\n\n    merged_data = forward_returns.copy()\n    merged_data[\'factor\'] = factor_copy\n\n    if groupby is not None:\n        if isinstance(groupby, dict):\n            diff = set(factor_copy.index.get_level_values(\n                \'asset\')) - set(groupby.keys())\n            if len(diff) > 0:\n                raise KeyError(\n                    ""Assets {} not in group mapping"".format(\n                        list(diff)))\n\n            ss = pd.Series(groupby)\n            groupby = pd.Series(index=factor_copy.index,\n                                data=ss[factor_copy.index.get_level_values(\n                                    \'asset\')].values)\n\n        if groupby_labels is not None:\n            diff = set(groupby.values) - set(groupby_labels.keys())\n            if len(diff) > 0:\n                raise KeyError(\n                    ""groups {} not in passed group names"".format(\n                        list(diff)))\n\n            sn = pd.Series(groupby_labels)\n            groupby = pd.Series(index=groupby.index,\n                                data=sn[groupby.values].values)\n\n        merged_data[\'group\'] = groupby.astype(\'category\')\n\n    merged_data = merged_data.dropna()\n\n    fwdret_amount = float(len(merged_data.index))\n\n    no_raise = False if max_loss == 0 else True\n    quantile_data = quantize_factor(\n        merged_data,\n        quantiles,\n        bins,\n        binning_by_group,\n        no_raise,\n        zero_aware\n    )\n\n    merged_data[\'factor_quantile\'] = quantile_data\n\n    merged_data = merged_data.dropna()\n\n    binning_amount = float(len(merged_data.index))\n\n    tot_loss = (initial_amount - binning_amount) / initial_amount\n    fwdret_loss = (initial_amount - fwdret_amount) / initial_amount\n    bin_loss = tot_loss - fwdret_loss\n\n    print(""Dropped %.1f%% entries from factor data: %.1f%% in forward ""\n          ""returns computation and %.1f%% in binning phase ""\n          ""(set max_loss=0 to see potentially suppressed Exceptions)."" %\n          (tot_loss * 100, fwdret_loss * 100, bin_loss * 100))\n\n    if tot_loss > max_loss:\n        message = (""max_loss (%.1f%%) exceeded %.1f%%, consider increasing it.""\n                   % (max_loss * 100, tot_loss * 100))\n        raise MaxLossExceededError(message)\n    else:\n        print(""max_loss is %.1f%%, not exceeded: OK!"" % (max_loss * 100))\n\n    return merged_data\n\n\ndef get_clean_factor_and_forward_returns(factor,\n                                         prices,\n                                         groupby=None,\n                                         binning_by_group=False,\n                                         quantiles=5,\n                                         bins=None,\n                                         periods=(1, 5, 10),\n                                         filter_zscore=20,\n                                         groupby_labels=None,\n                                         max_loss=0.35,\n                                         zero_aware=False,\n                                         cumulative_returns=True):\n    """"""\n    Formats the factor data, pricing data, and group mappings into a DataFrame\n    that contains aligned MultiIndex indices of timestamp and asset. The\n    returned data will be formatted to be suitable for Alphalens functions.\n\n    It is safe to skip a call to this function and still make use of Alphalens\n    functionalities as long as the factor data conforms to the format returned\n    from get_clean_factor_and_forward_returns and documented here\n\n    Parameters\n    ----------\n    factor : pd.Series - MultiIndex\n        A MultiIndex Series indexed by timestamp (level 0) and asset\n        (level 1), containing the values for a single alpha factor.\n        ::\n            -----------------------------------\n                date    |    asset   |\n            -----------------------------------\n                        |   AAPL     |   0.5\n                        -----------------------\n                        |   BA       |  -1.1\n                        -----------------------\n            2014-01-01  |   CMG      |   1.7\n                        -----------------------\n                        |   DAL      |  -0.1\n                        -----------------------\n                        |   LULU     |   2.7\n                        -----------------------\n\n    prices : pd.DataFrame\n        A wide form Pandas DataFrame indexed by timestamp with assets\n        in the columns.\n        Pricing data must span the factor analysis time period plus an\n        additional buffer window that is greater than the maximum number\n        of expected periods in the forward returns calculations.\n        It is important to pass the correct pricing data in depending on\n        what time of period your signal was generated so to avoid lookahead\n        bias, or  delayed calculations.\n        \'Prices\' must contain at least an entry for each timestamp/asset\n        combination in \'factor\'. This entry should reflect the buy price\n        for the assets and usually it is the next available price after the\n        factor is computed but it can also be a later price if the factor is\n        meant to be traded later (e.g. if the factor is computed at market\n        open but traded 1 hour after market open the price information should\n        be 1 hour after market open).\n        \'Prices\' must also contain entries for timestamps following each\n        timestamp/asset combination in \'factor\', as many more timestamps\n        as the maximum value in \'periods\'. The asset price after \'period\'\n        timestamps will be considered the sell price for that asset when\n        computing \'period\' forward returns.\n        ::\n            ----------------------------------------------------\n                        | AAPL |  BA  |  CMG  |  DAL  |  LULU  |\n            ----------------------------------------------------\n               Date     |      |      |       |       |        |\n            ----------------------------------------------------\n            2014-01-01  |605.12| 24.58|  11.72| 54.43 |  37.14 |\n            ----------------------------------------------------\n            2014-01-02  |604.35| 22.23|  12.21| 52.78 |  33.63 |\n            ----------------------------------------------------\n            2014-01-03  |607.94| 21.68|  14.36| 53.94 |  29.37 |\n            ----------------------------------------------------\n\n    groupby : pd.Series - MultiIndex or dict\n        Either A MultiIndex Series indexed by date and asset,\n        containing the period wise group codes for each asset, or\n        a dict of asset to group mappings. If a dict is passed,\n        it is assumed that group mappings are unchanged for the\n        entire time period of the passed factor data.\n    binning_by_group : bool\n        If True, compute quantile buckets separately for each group.\n        This is useful when the factor values range vary considerably\n        across gorups so that it is wise to make the binning group relative.\n        You should probably enable this if the factor is intended\n        to be analyzed for a group neutral portfolio\n    quantiles : int or sequence[float]\n        Number of equal-sized quantile buckets to use in factor bucketing.\n        Alternately sequence of quantiles, allowing non-equal-sized buckets\n        e.g. [0, .10, .5, .90, 1.] or [.05, .5, .95]\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    bins : int or sequence[float]\n        Number of equal-width (valuewise) bins to use in factor bucketing.\n        Alternately sequence of bin edges allowing for non-uniform bin width\n        e.g. [-4, -2, -0.5, 0, 10]\n        Chooses the buckets to be evenly spaced according to the values\n        themselves. Useful when the factor contains discrete values.\n        Only one of \'quantiles\' or \'bins\' can be not-None\n    periods : sequence[int]\n        periods to compute forward returns on.\n    filter_zscore : int or float, optional\n        Sets forward returns greater than X standard deviations\n        from the the mean to nan. Set it to \'None\' to avoid filtering.\n        Caution: this outlier filtering incorporates lookahead bias.\n    groupby_labels : dict\n        A dictionary keyed by group code with values corresponding\n        to the display name for each group.\n    max_loss : float, optional\n        Maximum percentage (0.00 to 1.00) of factor data dropping allowed,\n        computed comparing the number of items in the input factor index and\n        the number of items in the output DataFrame index.\n        Factor data can be partially dropped due to being flawed itself\n        (e.g. NaNs), not having provided enough price data to compute\n        forward returns for all factor values, or because it is not possible\n        to perform binning.\n        Set max_loss=0 to avoid Exceptions suppression.\n    zero_aware : bool, optional\n        If True, compute quantile buckets separately for positive and negative\n        signal values. This is useful if your signal is centered and zero is\n        the separation between long and short signals, respectively.\n    cumulative_returns : bool, optional\n        If True, forward returns columns will contain cumulative returns.\n        Setting this to False is useful if you want to analyze how predictive\n        a factor is for a single forward day.\n\n    Returns\n    -------\n    merged_data : pd.DataFrame - MultiIndex\n        A MultiIndex Series indexed by date (level 0) and asset (level 1),\n        containing the values for a single alpha factor, forward returns for\n        each period, the factor quantile/bin that factor value belongs to, and\n        (optionally) the group the asset belongs to.\n        - forward returns column names follow  the format accepted by\n          pd.Timedelta (e.g. \'1D\', \'30m\', \'3h15m\', \'1D1h\', etc)\n        - \'date\' index freq property (merged_data.index.levels[0].freq) will be\n          set to a trading calendar (pandas DateOffset) inferred from the input\n          data (see infer_trading_calendar for more details). This is currently\n          used only in cumulative returns computation\n        ::\n           -------------------------------------------------------------------\n                      |       | 1D  | 5D  | 10D  |factor|group|factor_quantile\n           -------------------------------------------------------------------\n               date   | asset |     |     |      |      |     |\n           -------------------------------------------------------------------\n                      | AAPL  | 0.09|-0.01|-0.079|  0.5 |  G1 |      3\n                      --------------------------------------------------------\n                      | BA    | 0.02| 0.06| 0.020| -1.1 |  G2 |      5\n                      --------------------------------------------------------\n           2014-01-01 | CMG   | 0.03| 0.09| 0.036|  1.7 |  G2 |      1\n                      --------------------------------------------------------\n                      | DAL   |-0.02|-0.06|-0.029| -0.1 |  G3 |      5\n                      --------------------------------------------------------\n                      | LULU  |-0.03| 0.05|-0.009|  2.7 |  G1 |      2\n                      --------------------------------------------------------\n\n    See Also\n    --------\n    utils.get_clean_factor\n        For use when forward returns are already available.\n    """"""\n    forward_returns = compute_forward_returns(\n        factor,\n        prices,\n        periods,\n        filter_zscore,\n        cumulative_returns,\n    )\n\n    factor_data = get_clean_factor(factor, forward_returns, groupby=groupby,\n                                   groupby_labels=groupby_labels,\n                                   quantiles=quantiles, bins=bins,\n                                   binning_by_group=binning_by_group,\n                                   max_loss=max_loss, zero_aware=zero_aware)\n\n    return factor_data\n\n\ndef rate_of_return(period_ret, base_period):\n    """"""\n    Convert returns to \'one_period_len\' rate of returns: that is the value the\n    returns would have every \'one_period_len\' if they had grown at a steady\n    rate\n\n    Parameters\n    ----------\n    period_ret: pd.DataFrame\n        DataFrame containing returns values with column headings representing\n        the return period.\n    base_period: string\n        The base period length used in the conversion\n        It must follow pandas.Timedelta constructor format (e.g. \'1 days\',\n        \'1D\', \'30m\', \'3h\', \'1D1h\', etc)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame in same format as input but with \'one_period_len\' rate of\n        returns values.\n    """"""\n    period_len = period_ret.name\n    conversion_factor = (pd.Timedelta(base_period) /\n                         pd.Timedelta(period_len))\n    return period_ret.add(1).pow(conversion_factor).sub(1)\n\n\ndef std_conversion(period_std, base_period):\n    """"""\n    one_period_len standard deviation (or standard error) approximation\n\n    Parameters\n    ----------\n    period_std: pd.DataFrame\n        DataFrame containing standard deviation or standard error values\n        with column headings representing the return period.\n    base_period: string\n        The base period length used in the conversion\n        It must follow pandas.Timedelta constructor format (e.g. \'1 days\',\n        \'1D\', \'30m\', \'3h\', \'1D1h\', etc)\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame in same format as input but with one-period\n        standard deviation/error values.\n    """"""\n    period_len = period_std.name\n    conversion_factor = (pd.Timedelta(period_len) /\n                         pd.Timedelta(base_period))\n    return period_std / np.sqrt(conversion_factor)\n\n\ndef get_forward_returns_columns(columns, require_exact_day_multiple=False):\n    """"""\n    Utility that detects and returns the columns that are forward returns\n    """"""\n\n    # If exact day multiples are required in the forward return periods,\n    # drop all other columns (e.g. drop 3D12h).\n    if require_exact_day_multiple:\n        pattern = re.compile(r""^(\\d+([D]))+$"", re.IGNORECASE)\n        valid_columns = [(pattern.match(col) is not None) for col in columns]\n\n        if sum(valid_columns) < len(valid_columns):\n            warnings.warn(\n                ""Skipping return periods that aren\'t exact multiples""\n                + "" of days.""\n            )\n    else:\n        pattern = re.compile(r""^(\\d+([Dhms]|ms|us|ns]))+$"", re.IGNORECASE)\n        valid_columns = [(pattern.match(col) is not None) for col in columns]\n\n    return columns[valid_columns]\n\n\ndef timedelta_to_string(timedelta):\n    """"""\n    Utility that converts a pandas.Timedelta to a string representation\n    compatible with pandas.Timedelta constructor format\n\n    Parameters\n    ----------\n    timedelta: pd.Timedelta\n\n    Returns\n    -------\n    string\n        string representation of \'timedelta\'\n    """"""\n    c = timedelta.components\n    format = \'\'\n    if c.days != 0:\n        format += \'%dD\' % c.days\n    if c.hours > 0:\n        format += \'%dh\' % c.hours\n    if c.minutes > 0:\n        format += \'%dm\' % c.minutes\n    if c.seconds > 0:\n        format += \'%ds\' % c.seconds\n    if c.milliseconds > 0:\n        format += \'%dms\' % c.milliseconds\n    if c.microseconds > 0:\n        format += \'%dus\' % c.microseconds\n    if c.nanoseconds > 0:\n        format += \'%dns\' % c.nanoseconds\n    return format\n\n\ndef timedelta_strings_to_integers(sequence):\n    """"""\n    Converts pandas string representations of timedeltas into integers of days.\n\n    Parameters\n    ----------\n    sequence : iterable\n        List or array of timedelta string representations, e.g. [\'1D\', \'5D\'].\n\n    Returns\n    -------\n    sequence : list\n        Integer days corresponding to the input sequence, e.g. [1, 5].\n    """"""\n    return list(map(lambda x: pd.Timedelta(x).days, sequence))\n\n\ndef add_custom_calendar_timedelta(input, timedelta, freq):\n    """"""\n    Add timedelta to \'input\' taking into consideration custom frequency, which\n    is used to deal with custom calendars, such as a trading calendar\n\n    Parameters\n    ----------\n    input : pd.DatetimeIndex or pd.Timestamp\n    timedelta : pd.Timedelta\n    freq : pd.DataOffset (CustomBusinessDay, Day or BusinessDay)\n\n    Returns\n    -------\n    pd.DatetimeIndex or pd.Timestamp\n        input + timedelta\n    """"""\n    if not isinstance(freq, (Day, BusinessDay, CustomBusinessDay)):\n        raise ValueError(""freq must be Day, BDay or CustomBusinessDay"")\n    days = timedelta.components.days\n    offset = timedelta - pd.Timedelta(days=days)\n    return input + freq * days + offset\n\n\ndef diff_custom_calendar_timedeltas(start, end, freq):\n    """"""\n    Compute the difference between two pd.Timedelta taking into consideration\n    custom frequency, which is used to deal with custom calendars, such as a\n    trading calendar\n\n    Parameters\n    ----------\n    start : pd.Timestamp\n    end : pd.Timestamp\n    freq : CustomBusinessDay (see infer_trading_calendar)\n    freq : pd.DataOffset (CustomBusinessDay, Day or BDay)\n\n    Returns\n    -------\n    pd.Timedelta\n        end - start\n    """"""\n    if not isinstance(freq, (Day, BusinessDay, CustomBusinessDay)):\n        raise ValueError(""freq must be Day, BusinessDay or CustomBusinessDay"")\n\n    weekmask = getattr(freq, \'weekmask\', None)\n    holidays = getattr(freq, \'holidays\', None)\n\n    if weekmask is None and holidays is None:\n        if isinstance(freq, Day):\n            weekmask = \'Mon Tue Wed Thu Fri Sat Sun\'\n            holidays = []\n        elif isinstance(freq, BusinessDay):\n            weekmask = \'Mon Tue Wed Thu Fri\'\n            holidays = []\n\n    if weekmask is not None and holidays is not None:\n        # we prefer this method as it is faster\n        actual_days = np.busday_count(np.array(start).astype(\'datetime64[D]\'),\n                                      np.array(end).astype(\'datetime64[D]\'),\n                                      weekmask, holidays)\n    else:\n        # default, it is slow\n        actual_days = pd.date_range(start, end, freq=freq).shape[0] - 1\n        if not freq.onOffset(start):\n            actual_days -= 1\n\n    timediff = end - start\n    delta_days = timediff.components.days - actual_days\n    return timediff - pd.Timedelta(days=delta_days)\n'"
alphalens/tests/__init__.py,0,b''
alphalens/tests/test_performance.py,0,"b'#\n# Copyright 2016 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import division\nfrom unittest import TestCase\nfrom parameterized import parameterized\nfrom numpy import nan\nfrom pandas import (\n    Series,\n    DataFrame,\n    date_range,\n    MultiIndex,\n    Int64Index,\n    Index,\n    DatetimeIndex,\n    Timedelta\n)\n\nfrom pandas.tseries.offsets import (BDay, Day, CDay)\n\nfrom pandas.util.testing import (assert_frame_equal,\n                                 assert_series_equal)\n\nfrom .. performance import (factor_information_coefficient,\n                            mean_information_coefficient,\n                            mean_return_by_quantile,\n                            quantile_turnover,\n                            factor_rank_autocorrelation,\n                            factor_returns, factor_alpha_beta,\n                            cumulative_returns, factor_weights,\n                            common_start_returns,\n                            average_cumulative_return_by_quantile)\n\nfrom .. utils import (get_forward_returns_columns,\n                      get_clean_factor_and_forward_returns)\n\n\nclass PerformanceTestCase(TestCase):\n    dr = date_range(start=\'2015-1-1\', end=\'2015-1-2\')\n    dr.name = \'date\'\n    tickers = [\'A\', \'B\', \'C\', \'D\']\n    factor = DataFrame(index=dr,\n                       columns=tickers,\n                       data=[[1, 2, 3, 4],\n                             [4, 3, 2, 1]]).stack()\n    factor.index = factor.index.set_names([\'date\', \'asset\'])\n    factor.name = \'factor\'\n    factor_data = DataFrame()\n    factor_data[\'factor\'] = factor\n    factor_data[\'group\'] = Series(index=factor.index,\n                                  data=[1, 1, 2, 2, 1, 1, 2, 2],\n                                  dtype=""category"")\n\n    @parameterized.expand([(factor_data, [4, 3, 2, 1, 1, 2, 3, 4],\n                            False, False,\n                            dr,\n                            [-1., -1.],\n                            ),\n                           (factor_data, [1, 2, 3, 4, 4, 3, 2, 1],\n                            False, False,\n                            dr,\n                            [1., 1.],\n                            ),\n                           (factor_data, [1, 2, 3, 4, 4, 3, 2, 1],\n                            False, True,\n                            MultiIndex.from_product(\n                                [dr, [1, 2]], names=[\'date\', \'group\']),\n                            [1., 1., 1., 1.],\n                            ),\n                           (factor_data, [1, 2, 3, 4, 4, 3, 2, 1],\n                            True, True,\n                            MultiIndex.from_product(\n                                [dr, [1, 2]], names=[\'date\', \'group\']),\n                            [1., 1., 1., 1.],\n                            )])\n    def test_information_coefficient(self,\n                                     factor_data,\n                                     forward_returns,\n                                     group_adjust,\n                                     by_group,\n                                     expected_ix,\n                                     expected_ic_val):\n\n        factor_data[\'1D\'] = Series(index=factor_data.index,\n                                   data=forward_returns)\n\n        ic = factor_information_coefficient(factor_data=factor_data,\n                                            group_adjust=group_adjust,\n                                            by_group=by_group)\n\n        expected_ic_df = DataFrame(index=expected_ix,\n                                   columns=Index([\'1D\'], dtype=\'object\'),\n                                   data=expected_ic_val)\n\n        assert_frame_equal(ic, expected_ic_df)\n\n    @parameterized.expand([(factor_data,\n                            [4, 3, 2, 1, 1, 2, 3, 4],\n                            False,\n                            False,\n                            \'D\',\n                            dr,\n                            [-1., -1.]),\n                           (factor_data,\n                            [1, 2, 3, 4, 4, 3, 2, 1],\n                            False,\n                            False,\n                            \'W\',\n                            DatetimeIndex([\'2015-01-04\'],\n                                          name=\'date\',\n                                          freq=\'W-SUN\'),\n                            [1.]),\n                           (factor_data,\n                            [1, 2, 3, 4, 4, 3, 2, 1],\n                            False,\n                            True,\n                            None,\n                            Int64Index([1, 2], name=\'group\'),\n                            [1., 1.]),\n                           (factor_data,\n                            [1, 2, 3, 4, 4, 3, 2, 1],\n                            False,\n                            True,\n                            \'W\',\n                            MultiIndex.from_product(\n                                [DatetimeIndex([\'2015-01-04\'],\n                                               name=\'date\',\n                                               freq=\'W-SUN\'),\n                                 [1, 2]], names=[\'date\', \'group\']),\n                            [1., 1.])])\n    def test_mean_information_coefficient(self,\n                                          factor_data,\n                                          forward_returns,\n                                          group_adjust,\n                                          by_group,\n                                          by_time,\n                                          expected_ix,\n                                          expected_ic_val):\n\n        factor_data[\'1D\'] = Series(index=factor_data.index,\n                                   data=forward_returns)\n\n        ic = mean_information_coefficient(factor_data,\n                                          group_adjust=group_adjust,\n                                          by_group=by_group,\n                                          by_time=by_time)\n\n        expected_ic_df = DataFrame(index=expected_ix,\n                                   columns=Index([\'1D\'], dtype=\'object\'),\n                                   data=expected_ic_val)\n\n        assert_frame_equal(ic, expected_ic_df)\n\n    @parameterized.expand([([1.1, 1.2, 1.1, 1.2, 1.1, 1.2],\n                            [[1, 2, 1, 2, 1, 2],\n                             [1, 2, 1, 2, 1, 2],\n                             [1, 2, 1, 2, 1, 2]],\n                            2, False,\n                            [0.1, 0.2]),\n                           ([1.1, 1.2, 1.1, 1.2, 1.1, 1.2],\n                            [[1, 2, 1, 2, 1, 2],\n                             [1, 2, 1, 2, 1, 2],\n                             [1, 2, 1, 2, 1, 2]],\n                            2, True,\n                            [0.1, 0.1, 0.2, 0.2]),\n                           ([1.1, 1.1, 1.1, 1.2, 1.2, 1.2],\n                            [[1, 2, 3, 1, 2, 3],\n                             [1, 2, 3, 1, 2, 3],\n                             [1, 2, 3, 1, 2, 3]],\n                            3, False,\n                            [0.15, 0.15, 0.15]),\n                           ([1.1, 1.1, 1.1, 1.2, 1.2, 1.2],\n                            [[1, 2, 3, 1, 2, 3],\n                             [1, 2, 3, 1, 2, 3],\n                             [1, 2, 3, 1, 2, 3]],\n                            3, True,\n                            [0.1, 0.2, 0.1, 0.2, 0.1, 0.2]),\n                           ([1.5, 1.5, 1.2, 1.0, 1.0, 1.0],\n                            [[1, 1, 2, 2, 2, 2],\n                             [2, 2, 1, 2, 2, 2],\n                             [2, 2, 1, 2, 2, 2]],\n                            2, False,\n                            [0.3, 0.15]),\n                           ([1.5, 1.5, 1.2, 1.0, 1.0, 1.0],\n                            [[1, 1, 3, 2, 2, 2],\n                             [3, 3, 1, 2, 2, 2],\n                             [3, 3, 1, 2, 2, 2]],\n                            3, False,\n                            [0.3, 0.0, 0.4]),\n                           ([1.6, 1.6, 1.0, 1.0, 1.0, 1.0],\n                            [[1, 1, 2, 2, 2, 2],\n                             [2, 2, 1, 1, 1, 1],\n                             [2, 2, 1, 1, 1, 1]],\n                            2, False,\n                            [0.2, 0.4]),\n                           ([1.6, 1.6, 1.0, 1.6, 1.6, 1.0],\n                            [[1, 1, 2, 1, 1, 2],\n                             [2, 2, 1, 2, 2, 1],\n                             [2, 2, 1, 2, 2, 1]],\n                            2, True,\n                            [0.2, 0.2, 0.4, 0.4])])\n    def test_mean_return_by_quantile(self,\n                                     daily_rets,\n                                     factor,\n                                     bins,\n                                     by_group,\n                                     expected_data):\n        """"""\n        Test mean_return_by_quantile\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 1, \'C\': 1, \'D\': 2, \'E\': 2, \'F\': 2}\n\n        price_data = [[daily_rets[0]**i, daily_rets[1]**i, daily_rets[2]**i,\n                       daily_rets[3]**i, daily_rets[4]**i, daily_rets[5]**i]\n                      for i in range(1, 5)]  # 4 days\n\n        start = \'2015-1-11\'\n        factor_end = \'2015-1-13\'\n        price_end = \'2015-1-14\'  # 1D fwd returns\n\n        price_index = date_range(start=start, end=price_end)\n        price_index.name = \'date\'\n        prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n        factor_index = date_range(start=start, end=factor_end)\n        factor_index.name = \'date\'\n        factor = DataFrame(index=factor_index, columns=tickers,\n                           data=factor).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=None,\n            bins=bins,\n            periods=(1,))\n\n        mean_quant_ret, std_quantile = \\\n            mean_return_by_quantile(factor_data,\n                                    by_date=False,\n                                    by_group=by_group,\n                                    demeaned=False,\n                                    group_adjust=False)\n\n        expected = DataFrame(index=mean_quant_ret.index.copy(),\n                             columns=mean_quant_ret.columns.copy(),\n                             data=expected_data)\n        expected.index.name = \'factor_quantile\'\n\n        assert_frame_equal(mean_quant_ret, expected)\n\n    @parameterized.expand([([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 4.0, 1,\n                            [nan, 1.0, 1.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 4.0, 1,\n                            [nan, 1.0, 1.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 4.0, 2,\n                            [nan, nan, 0.0, 1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 4.0, 2,\n                            [nan, nan, 0.0, 1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 4.0, 3,\n                            [nan, nan, nan, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 4.0, 3,\n                            [nan, nan, nan, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 3.0, 1,\n                            [nan, 0.0, 0.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 3.0, 1,\n                            [nan, 0.0, 0.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 3.0, 2,\n                            [nan, nan, 0.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 3.0, 2,\n                            [nan, nan, 0.0, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 3.0, 3,\n                            [nan, nan, nan, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 3.0, 3,\n                            [nan, nan, nan, 0.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0]],\n                            \'1B\', 2.0, 1,\n                            [nan, 1.0, 1.0, 1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0]],\n                            \'1D\', 2.0, 1,\n                            [nan, 1.0, 1.0, 1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0]],\n                            \'1B\', 3.0, 4,\n                            [nan, nan, nan, nan,\n                             0., 0., 0., 0.,\n                             0., 0., 0., 0.]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0]],\n                            \'1D\', 3.0, 4,\n                            [nan, nan, nan, nan,\n                             0., 0., 0., 0.,\n                             0., 0., 0., 0.]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 3.0, 10,\n                            [nan, nan, nan, nan, nan,\n                             nan, nan, nan, nan, nan,\n                             0., 1.]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 3.0, 2.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 3.0, 10,\n                            [nan, nan, nan, nan, nan,\n                             nan, nan, nan, nan, nan,\n                             0., 1.])\n                           ])\n    def test_quantile_turnover(self, quantile_values, freq, test_quantile,\n                               period, expected_vals):\n\n        dr = date_range(start=\'2015-1-1\', periods=len(quantile_values),\n                        freq=freq)\n        dr.name = \'date\'\n        tickers = [\'A\', \'B\', \'C\', \'D\']\n\n        quantized_test_factor = Series(DataFrame(index=dr,\n                                                 columns=tickers,\n                                                 data=quantile_values)\n                                       .stack())\n        quantized_test_factor.index = quantized_test_factor.index.set_names(\n            [\'date\', \'asset\'])\n\n        to = quantile_turnover(quantized_test_factor, test_quantile, period)\n\n        expected = Series(\n            index=quantized_test_factor.index.levels[0], data=expected_vals)\n        expected.name = test_quantile\n\n        assert_series_equal(to, expected)\n\n    @parameterized.expand([([[3, 4,  2,  1, nan],\n                             [3, 4, -2, -1, nan],\n                             [3, nan, nan, 1, 4]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            False, False, False,\n                            [0.30, 0.40, 0.20, 0.10,\n                             0.30, 0.40, -0.20, -0.10,\n                             0.375, 0.125, 0.50]),\n                           ([[3, 4,  2,  1, nan],\n                             [3, 4, -2, -1, nan],\n                             [3, nan, nan, 1, 4]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            True, False, False,\n                            [0.125, 0.375, -0.125, -0.375,\n                             0.20, 0.30, -0.30, -0.20,\n                             0.10, -0.50, 0.40]),\n                           ([[3, 4,  2, 1, nan],\n                             [-3, 4, -2, 1, nan],\n                             [2, 2,  2, 3, 1]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            False, True, False,\n                            [0.30, 0.40, 0.20, 0.10,\n                             -0.30, 0.40, -0.20, 0.10,\n                             0.20, 0.20, 0.20, 0.30, 0.10]),\n                           ([[3,   4,  2,  1, nan],\n                             [3,   4, -2, -1, nan],\n                             [3, nan, nan, 1, 4]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            True, True, False,\n                            [0.25,  0.25, -0.25, -0.25,\n                             0.25, 0.25, -0.25, -0.25,\n                             -0.50, nan, 0.50]),\n                           ([[3, 4,   2,  1, 5],\n                             [3, 4,  -2, -1, 5],\n                             [3, nan, nan, 1, nan]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            False, False, True,\n                            [0.20, 0.20, 0.20, 0.20, 0.20,\n                             0.20, 0.20, -0.20, -0.20, 0.20,\n                             0.50, 0.50]),\n                           ([[1, 4,   2,   3, nan],\n                             [1, 4,  -2,  -3, nan],\n                             [3, nan, nan, 2, 7]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            True, False, True,\n                            [-0.25, 0.25, -0.25, 0.25,\n                             0.25, 0.25, -0.25, -0.25,\n                             0., -0.50, 0.50]),\n                           ([[3, 4,   2,   1, nan],\n                             [-3, 4, -2,   1, nan],\n                             [3, nan, nan,  1,  4],\n                             [3, nan, nan, -1,  4],\n                             [3, nan, nan,  1, -4]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            False, True, True,\n                            [0.25, 0.25, 0.25, 0.25,\n                             -0.25, 0.25, -0.25, 0.25,\n                             0.25, 0.50, 0.25,\n                             0.25, -0.50, 0.25,\n                             0.25, 0.50, -0.25]),\n                           ([[1, 4,   2,   3, nan],\n                             [3, 4,  -2,  -1, nan],\n                             [3, nan, nan, 2, 7],\n                             [3, nan, nan, 2, -7]],\n                            [\'A\', \'B\', \'C\', \'D\', \'E\'],\n                            {\'A\': \'Group1\', \'B\': \'Group2\', \'C\': \'Group1\',\n                             \'D\': \'Group2\', \'E\': \'Group1\'},\n                            True, True, True,\n                            [-0.25, 0.25, 0.25, -0.25,\n                             0.25, 0.25, -0.25, -0.25,\n                             -0.50, nan, 0.50,\n                             0.50, nan, -0.50]),\n                           ])\n    def test_factor_weights(self,\n                            factor_vals,\n                            tickers,\n                            groups,\n                            demeaned,\n                            group_adjust,\n                            equal_weight,\n                            expected_vals):\n\n        index = date_range(\'1/12/2000\', periods=len(factor_vals))\n        factor = DataFrame(index=index,\n                           columns=tickers,\n                           data=factor_vals).stack()\n        factor.index = factor.index.set_names([\'date\', \'asset\'])\n        factor.name = \'factor\'\n\n        factor_data = DataFrame()\n        factor_data[\'factor\'] = factor\n        groups = Series(groups)\n        factor_data[\'group\'] = \\\n            Series(index=factor.index,\n                   data=groups[factor.index.get_level_values(\'asset\')].values)\n\n        weights = \\\n            factor_weights(factor_data, demeaned, group_adjust, equal_weight)\n\n        expected = Series(data=expected_vals,\n                          index=factor_data.index,\n                          name=\'factor\')\n\n        assert_series_equal(weights, expected)\n\n    @parameterized.expand([([1, 2, 3, 4, 4, 3, 2, 1],\n                            [4, 3, 2, 1, 1, 2, 3, 4],\n                            False,\n                            [-1.25000, -1.25000]),\n                           ([1, 1, 1, 1, 1, 1, 1, 1],\n                            [4, 3, 2, 1, 1, 2, 3, 4],\n                            False,\n                            [nan, nan]),\n                           ([1, 2, 3, 4, 4, 3, 2, 1],\n                            [4, 3, 2, 1, 1, 2, 3, 4],\n                            True,\n                            [-0.5, -0.5]),\n                           ([1, 2, 3, 4, 1, 2, 3, 4],\n                            [1, 4, 1, 2, 1, 2, 2, 1],\n                            True,\n                            [1.0, 0.0]),\n                           ([1, 1, 1, 1, 1, 1, 1, 1],\n                            [4, 3, 2, 1, 1, 2, 3, 4],\n                            True,\n                            [nan, nan])\n                           ])\n    def test_factor_returns(self,\n                            factor_vals,\n                            fwd_return_vals,\n                            group_adjust,\n                            expected_vals):\n\n        factor_data = self.factor_data.copy()\n        factor_data[\'1D\'] = fwd_return_vals\n        factor_data[\'factor\'] = factor_vals\n\n        factor_returns_s = factor_returns(factor_data=factor_data,\n                                          demeaned=True,\n                                          group_adjust=group_adjust)\n\n        expected = DataFrame(\n            index=self.dr,\n            data=expected_vals,\n            columns=get_forward_returns_columns(\n                factor_data.columns))\n\n        assert_frame_equal(factor_returns_s, expected)\n\n    @parameterized.expand([([1, 2, 3, 4, 1, 1, 1, 1],\n                            -1,\n                            5. / 6.)])\n    def test_factor_alpha_beta(self, fwd_return_vals, alpha, beta):\n\n        factor_data = self.factor_data.copy()\n        factor_data[\'1D\'] = fwd_return_vals\n\n        ab = factor_alpha_beta(factor_data=factor_data)\n\n        expected = DataFrame(columns=[\'1D\'],\n                             index=[\'Ann. alpha\', \'beta\'],\n                             data=[alpha, beta])\n\n        assert_frame_equal(ab, expected)\n\n    @parameterized.expand([\n        (\n            [1.0, 0.5, 1.0, 0.5, 0.5],\n            \'1D\',\n            \'1D\',\n            [2.0, 3.0, 6.0, 9.0, 13.50],\n        ),\n        (\n            [0.1, 0.1, 0.1, 0.1, 0.1],\n            \'1D\',\n            \'1D\',\n            [1.1, 1.21, 1.331, 1.4641, 1.61051],\n        ),\n        (\n            [-0.1, -0.1, -0.1, -0.1, -0.1],\n            \'1D\',\n            \'1D\',\n            [0.9, 0.81, 0.729, 0.6561, 0.59049],\n        ),\n        (\n            [1.0, 0.5, 1.0, 0.5, 0.5],\n            \'1B\',\n            \'1D\',\n            [2.0, 3.0, 6.0, 9.0, 13.50],\n        ),\n        (\n            [0.1, 0.1, 0.1, 0.1, 0.1],\n            \'1B\',\n            \'1D\',\n            [1.1, 1.21, 1.331, 1.4641, 1.61051],\n        ),\n        (\n            [-0.1, -0.1, -0.1, -0.1, -0.1],\n            \'1B\',\n            \'1D\',\n            [0.9, 0.81, 0.729, 0.6561, 0.59049],\n        ),\n        (\n            [1.0, 0.5, 1.0, 0.5, 0.5],\n            \'1CD\',\n            \'1D\',\n            [2.0, 3.0, 6.0, 9.0, 13.50],\n        ),\n        (\n            [0.1, 0.1, 0.1, 0.1, 0.1],\n            \'1CD\',\n            \'1D\',\n            [1.1, 1.21, 1.331, 1.4641, 1.61051],\n        ),\n        (\n            [-0.1, -0.1, -0.1, -0.1, -0.1],\n            \'1CD\',\n            \'1D\',\n            [0.9, 0.81, 0.729, 0.6561, 0.59049],\n        ),\n    ])\n    def test_cumulative_returns(self,\n                                returns,\n                                ret_freq,\n                                period_len,\n                                expected_vals):\n        if \'CD\' in ret_freq:\n            ret_freq_class = CDay(weekmask=\'Tue Wed Thu Fri Sun\')\n            ret_freq = ret_freq_class\n        elif \'B\' in ret_freq:\n            ret_freq_class = BDay()\n        else:\n            ret_freq_class = Day()\n\n        period_len = Timedelta(period_len)\n        index = date_range(\'1/1/1999\', periods=len(returns), freq=ret_freq)\n        returns = Series(returns, index=index)\n\n        cum_ret = cumulative_returns(returns)\n\n        expected = Series(expected_vals, index=cum_ret.index)\n\n        assert_series_equal(cum_ret, expected, check_less_precise=True)\n\n    @parameterized.expand([([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 1,\n                            [nan, 1.0, 1.0, 1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 1,\n                            [nan, 1.0, 1.0, 1.0]),\n                           ([[4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1B\', 1,\n                            [nan, -1.0, -1.0, -1.0]),\n                           ([[4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0]],\n                            \'1D\', 1,\n                            [nan, -1.0, -1.0, -1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0]],\n                            \'1B\', 3,\n                            [nan, nan, nan, 1.0, 1.0,\n                             1.0, 0.6, -0.6, -1.0, 1.0,\n                             -0.6, -1.0]),\n                           ([[1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0],\n                             [1.0, 2.0, 3.0, 4.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [2.0, 1.0, 4.0, 3.0],\n                             [4.0, 3.0, 2.0, 1.0]],\n                            \'1D\', 3,\n                            [nan, nan, nan, 1.0, 1.0,\n                             1.0, 0.6, -0.6, -1.0, 1.0,\n                             -0.6, -1.0])\n                           ])\n    def test_factor_rank_autocorrelation(self,\n                                         factor_values,\n                                         freq,\n                                         period,\n                                         expected_vals):\n\n        dr = date_range(start=\'2015-1-1\', periods=len(factor_values),\n                        freq=freq)\n        dr.name = \'date\'\n        tickers = [\'A\', \'B\', \'C\', \'D\']\n        factor = DataFrame(index=dr,\n                           columns=tickers,\n                           data=factor_values).stack()\n        factor.index = factor.index.set_names([\'date\', \'asset\'])\n\n        factor_df = DataFrame()\n        factor_df[\'factor\'] = factor\n\n        fa = factor_rank_autocorrelation(factor_df, period)\n        expected = Series(index=dr, data=expected_vals)\n        expected.name = period\n\n        assert_series_equal(fa, expected)\n\n    @parameterized.expand([\n        (\n            2, 3, False, False,\n            [[4.93048307, 8.68843922], [6.60404312, 12.22369139],\n             [8.92068367, 17.1794088], [12.1275523, 24.12861778],\n             [16.5694159, 33.8740100], [22.7273233, 47.53995233]],\n        ),\n        (\n            3, 2, False, True,\n            [[0.0, 5.63219176], [0.0, 7.96515233],\n             [0.0, 11.2420646], [0.0, 15.8458720],\n             [0.0, 22.3134160], [0.0, 31.3970961]],\n        ),\n        (\n            3, 5, True, False,\n            [[3.7228318, 2.6210478], [4.9304831, 3.6296796], [6.6040431, 5.0193734],  # noqa\n             [8.9206837, 6.9404046], [12.127552, 9.6023405], [16.569416, 13.297652],  # noqa\n             [22.727323, 18.434747], [31.272682, 25.584180], [34.358565, 25.497254]],  # noqa\n        ),\n        (\n            1, 4, True, True,\n            [[0., 0.], [0., 0.], [0., 0.],\n             [0., 0.], [0., 0.], [0., 0.]],\n        ),\n        (\n            6, 6, False, False,\n            [[2.02679565, 2.38468223], [2.38769454, 3.22602748],\n             [2.85413029, 4.36044469], [3.72283181, 6.16462715],\n             [4.93048307, 8.68843922], [6.60404312, 12.2236914],\n             [8.92068367, 17.1794088], [12.1275523, 24.1286178],\n             [16.5694159, 33.8740100], [22.7273233, 47.5399523],\n             [31.2726821, 66.7013483], [34.3585654, 70.1828776],\n             [37.9964585, 74.3294620]],\n        ),\n        (\n            6, 6, False, True,\n            [[0.0, 2.20770299], [0.0, 2.95942924], [0.0, 3.97022414],\n             [0.0, 5.63219176], [0.0, 7.96515233], [0.0, 11.2420646],\n             [0.0, 15.8458720], [0.0, 22.3134160], [0.0, 31.3970962],\n             [0.0, 44.1512888], [0.0, 62.0533954], [0.0, 65.8668371],\n             [0.0, 70.4306483]],\n        ),\n        (\n            6, 6, True, False,\n            [[2.0267957, 0.9562173], [2.3876945, 1.3511898], [2.8541303, 1.8856194],  # noqa\n             [3.7228318, 2.6210478], [4.9304831, 3.6296796], [6.6040431, 5.0193734],  # noqa\n             [8.9206837, 6.9404046], [12.127552, 9.6023405], [16.569416, 13.297652],  # noqa\n             [22.727323, 18.434747], [31.272682, 25.584180], [34.358565, 25.497254],  # noqa\n             [37.996459, 25.198051]],\n        ),\n        (\n            6, 6, True, True,\n            [[0., 0.], [0., 0.], [0., 0.], [0., 0.], [0., 0.],\n             [0., 0.], [0., 0.], [0., 0.], [0., 0.], [0., 0.],\n             [0., 0.], [0., 0.], [0., 0.]],\n        ),\n    ])\n    def test_common_start_returns(self,\n                                  before,\n                                  after,\n                                  mean_by_date,\n                                  demeaned,\n                                  expected_vals):\n        dr = date_range(start=\'2015-1-17\', end=\'2015-2-2\')\n        dr.name = \'date\'\n        tickers = [\'A\', \'B\', \'C\', \'D\']\n        r1, r2, r3, r4 = (1.20, 1.40, 0.90, 0.80)\n        data = [[r1**i, r2**i, r3**i, r4**i] for i in range(1, 18)]\n        returns = DataFrame(data=data, index=dr, columns=tickers)\n        dr2 = date_range(start=\'2015-1-21\', end=\'2015-1-29\')\n        factor = DataFrame(index=dr2, columns=tickers,\n                           data=[[3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1],\n                                 [3, 4, 2, 1]]).stack()\n        factor.index = factor.index.set_names([\'date\', \'asset\'])\n        factor.name = \'factor\'\n\n        cmrt = common_start_returns(\n            factor,\n            returns,\n            before,\n            after,\n            cumulative=True,\n            mean_by_date=mean_by_date,\n            demean_by=factor if demeaned else None,\n        )\n        cmrt = DataFrame({\'mean\': cmrt.mean(axis=1), \'std\': cmrt.std(axis=1)})\n        expected = DataFrame(index=range(-before, after + 1),\n                             columns=[\'mean\', \'std\'], data=expected_vals)\n        assert_frame_equal(cmrt, expected)\n\n    @parameterized.expand([\n        (\n            1, 2, False, 4,\n            [[0.00512695, 0.00256348, 0.00128174, 6.40869e-4],\n             [0.00579185, 0.00289592, 0.00144796, 7.23981e-4],\n             [1.00000000, 1.00000000, 1.00000000, 1.00000000],\n             [0.00000000, 0.00000000, 0.00000000, 0.00000000],\n             [7.15814531, 8.94768164, 11.1846020, 13.9807526],\n             [2.93784787, 3.67230984, 4.59038730, 5.73798413],\n             [39.4519043, 59.1778564, 88.7667847, 133.150177],\n             [28.3717330, 42.5575995, 63.8363992, 95.7545989]],\n        ),\n        (\n            1, 2, True, 4,\n            [[-11.898667, -17.279462, -25.236885, -37.032252],\n             [7.82587034, 11.5529583, 17.0996881, 25.3636472],\n             [-10.903794, -16.282025, -24.238167, -36.032893],\n             [7.82140124, 11.5507268, 17.0985737, 25.3630906],\n             [-4.7456488, -8.3343438, -14.053565, -23.052140],\n             [4.91184665, 7.91180853, 12.5481552, 19.6734224],\n             [27.5481102, 41.8958311, 63.5286176, 96.1172844],\n             [20.5510133, 31.0075980, 46.7385910, 70.3923129]],\n        ),\n        (\n            3, 0, False, 4,\n            [[7.0, 3.0, 1.0, 0.0],\n             [0.0, 0.0, 0.0, 0.0],\n             [0.0, 0.0, 0.0, 0.0],\n             [0.0, 0.0, 0.0, 0.0],\n             [-0.488, -0.36, -0.2, 0.0],\n             [0.0, 0.0, 0.0, 0.0],\n             [-0.703704, -0.55555555, -0.333333333, 0.0],\n             [0.0, 0.0, 0.0, 0.0]],\n        ),\n        (\n            0, 3, True, 4,\n            [[-17.279462, -25.236885, -37.032252, -54.550061],\n             [11.5529583, 17.0996881, 25.3636472, 37.6887906],\n             [-16.282025, -24.238167, -36.032893, -53.550382],\n             [11.5507268, 17.0985737, 25.3630906, 37.6885125],\n             [-8.3343438, -14.053565, -23.052140, -37.074441],\n             [7.91180853, 12.5481552, 19.6734224, 30.5748605],\n             [41.8958311, 63.5286176, 96.1172844, 145.174884],\n             [31.0075980, 46.7385910, 70.3923129, 105.944230]]),\n        (\n            3, 3, False, 2,\n            [[0.5102539, 0.50512695, 0.50256348, 0.50128174, 0.50064087, 0.50032043, 0.50016022],  # noqa\n             [0.0115837, 0.00579185, 0.00289592, 1.44796e-3, 7.23981e-4, 3.61990e-4, 1.80995e-4],  # noqa\n             [11.057696, 16.0138929, 23.3050248, 34.0627690, 49.9756934, 73.5654648, 108.600603],  # noqa\n             [7.2389454, 10.6247239, 15.6450367, 23.1025693, 34.1977045, 50.7264595, 75.3771641]],  # noqa\n        ),\n        (\n            3, 3, True, 2,\n            [[-5.273721, -7.754383, -11.40123, -16.78074, -24.73753, -36.53257, -54.05022],  # noqa\n             [3.6239580, 5.3146000, 7.8236356, 11.551843, 17.099131, 25.363369, 37.688652],  # noqa\n             [5.2737212, 7.7543830, 11.401231, 16.780744, 24.737526, 36.532572, 54.050221],  # noqa\n             [3.6239580, 5.3146000, 7.8236356, 11.551843, 17.099131, 25.363369, 37.688652]],  # noqa\n        ),\n    ])\n    def test_average_cumulative_return_by_quantile(self,\n                                                   before,\n                                                   after,\n                                                   demeaned,\n                                                   quantiles,\n                                                   expected_vals):\n        dr = date_range(start=\'2015-1-15\', end=\'2015-2-1\')\n        dr.name = \'date\'\n        tickers = [\'A\', \'B\', \'C\', \'D\']\n        r1, r2, r3, r4 = (1.25, 1.50, 1.00, 0.50)\n        data = [[r1**i, r2**i, r3**i, r4**i] for i in range(1, 19)]\n        returns = DataFrame(index=dr, columns=tickers, data=data)\n        dr2 = date_range(start=\'2015-1-21\', end=\'2015-1-26\')\n        dr2.name = \'date\'\n        factor = DataFrame(\n            index=dr2, columns=tickers, data=[\n                [3, 4, 2, 1],\n                [3, 4, 2, 1],\n                [3, 4, 2, 1],\n                [3, 4, 2, 1],\n                [3, 4, 2, 1],\n                [3, 4, 2, 1]]).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, returns, quantiles=quantiles, periods=range(\n                0, after + 1), filter_zscore=False)\n\n        avgrt = average_cumulative_return_by_quantile(\n            factor_data, returns, before, after, demeaned)\n        arrays = []\n        for q in range(1, quantiles + 1):\n            arrays.append((q, \'mean\'))\n            arrays.append((q, \'std\'))\n        index = MultiIndex.from_tuples(arrays, names=[\'factor_quantile\', None])\n        expected = DataFrame(\n            index=index, columns=range(-before, after + 1), data=expected_vals)\n        assert_frame_equal(avgrt, expected)\n\n    @parameterized.expand([\n        (\n            0, 2, False, 4,\n            [[0.0292969, 0.0146484, 7.32422e-3],\n             [0.0241851, 0.0120926, 6.04628e-3],\n             [1.0000000, 1.0000000, 1.00000000],\n             [0.0000000, 0.0000000, 0.00000000],\n             [3.5190582, 4.3988228, 5.49852848],\n             [1.0046375, 1.2557969, 1.56974616],\n             [10.283203, 15.424805, 23.1372070],\n             [5.2278892, 7.8418338, 11.7627508]],\n        ),\n        (\n            0, 3, True, 4,\n            [[-3.6785927, -5.1949205, -7.4034407, -10.641996],\n             [1.57386873, 2.28176590, 3.33616491, 4.90228915],\n             [-2.7078896, -4.2095690, -6.4107649, -9.6456583],\n             [1.55205002, 2.27087143, 3.33072273, 4.89956999],\n             [-0.1888313, -0.8107462, -1.9122365, -3.7724977],\n             [0.55371389, 1.02143924, 1.76795263, 2.94536298],\n             [6.57531357, 10.2152357, 15.7264421, 24.0601522],\n             [3.67596914, 5.57112656, 8.43221341, 12.7447568]],\n        ),\n        (\n            0, 3, False, 2,\n            [[0.51464844, 0.50732422, 0.50366211, 0.50183105],\n             [0.01209256, 0.00604628, 0.00302314, 0.00151157],\n             [6.90113068, 9.91181374, 14.3178678, 20.7894856],\n             [3.11499629, 4.54718783, 6.66416616, 9.80049950]],\n        ),\n        (\n            0, 3, True, 2,\n            [[-3.1932411, -4.7022448, -6.9071028, -10.143827],\n             [1.56295067, 2.27631715, 3.33344356, 4.90092953],\n             [3.19324112, 4.70224476, 6.90710282, 10.1438273],\n             [1.56295067, 2.27631715, 3.33344356, 4.90092953]],\n        ),\n    ])\n    def test_average_cumulative_return_by_quantile_2(self, before, after,\n                                                     demeaned, quantiles,\n                                                     expected_vals):\n        """"""\n        Test varying factor asset universe: at different dates there might be\n        different assets\n        """"""\n        dr = date_range(start=\'2015-1-15\', end=\'2015-1-25\')\n        dr.name = \'date\'\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n        r1, r2, r3, r4 = (1.25, 1.50, 1.00, 0.50)\n        data = [[r1**i, r2**i, r3**i, r4**i, r2**i, r3**i]\n                for i in range(1, 12)]\n        prices = DataFrame(index=dr, columns=tickers, data=data)\n        dr2 = date_range(start=\'2015-1-18\', end=\'2015-1-21\')\n        dr2.name = \'date\'\n        factor = DataFrame(index=dr2, columns=tickers,\n                           data=[[3, 4, 2, 1, nan, nan],\n                                 [3, 4, 2, 1, nan, nan],\n                                 [3, nan, nan, 1, 4, 2],\n                                 [3, nan, nan, 1, 4, 2]]).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices, quantiles=quantiles, periods=range(\n                0, after + 1), filter_zscore=False)\n\n        avgrt = average_cumulative_return_by_quantile(\n            factor_data, prices, before, after, demeaned)\n        arrays = []\n        for q in range(1, quantiles + 1):\n            arrays.append((q, \'mean\'))\n            arrays.append((q, \'std\'))\n        index = MultiIndex.from_tuples(arrays, names=[\'factor_quantile\', None])\n        expected = DataFrame(\n            index=index, columns=range(-before, after + 1), data=expected_vals)\n        assert_frame_equal(avgrt, expected)\n'"
alphalens/tests/test_tears.py,0,"b'#\n# Copyright 2017 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import division\nfrom unittest import TestCase\nfrom parameterized import parameterized\nfrom numpy import nan\nfrom pandas import (DataFrame, date_range, Timedelta, concat)\n\nfrom .. tears import (create_returns_tear_sheet,\n                      create_information_tear_sheet,\n                      create_turnover_tear_sheet,\n                      create_summary_tear_sheet,\n                      create_full_tear_sheet,\n                      create_event_returns_tear_sheet,\n                      create_event_study_tear_sheet)\n\nfrom .. utils import get_clean_factor_and_forward_returns\n\n\nclass TearsTestCase(TestCase):\n\n    tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n    factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n    price_data = [[1.25**i, 1.50**i, 1.00**i, 0.50**i, 1.50**i, 1.00**i]\n                  for i in range(1, 51)]\n\n    factor_data = [[3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, 4, 2, 1, nan, nan], [3, 4, 2, 1, nan, nan],\n                   [3, nan, nan, 1, 4, 2], [3, nan, nan, 1, 4, 2]]\n\n    event_data = [[1, nan, nan, nan, nan, nan],\n                  [4, nan, nan, 7, nan, nan],\n                  [nan, nan, nan, nan, nan, nan],\n                  [nan, 3, nan, 2, nan, nan],\n                  [1, nan, nan, nan, nan, nan],\n                  [nan, nan, 2, nan, nan, nan],\n                  [nan, nan, nan, 2, nan, nan],\n                  [nan, nan, nan, 1, nan, nan],\n                  [2, nan, nan, nan, nan, nan],\n                  [nan, nan, nan, nan, 5, nan],\n                  [nan, nan, nan, 2, nan, nan],\n                  [nan, nan, nan, nan, nan, nan],\n                  [2, nan, nan, nan, nan, nan],\n                  [nan, nan, nan, nan, nan, 5],\n                  [nan, nan, nan, 1, nan, nan],\n                  [nan, nan, nan, nan, 4, nan],\n                  [5, nan, nan, 4, nan, nan],\n                  [nan, nan, nan, 3, nan, nan],\n                  [nan, nan, nan, 4, nan, nan],\n                  [nan, nan, 2, nan, nan, nan],\n                  [5, nan, nan, nan, nan, nan],\n                  [nan, 1, nan, nan, nan, nan],\n                  [nan, nan, nan, nan, 4, nan],\n                  [0, nan, nan, nan, nan, nan],\n                  [nan, 5, nan, nan, nan, 4],\n                  [nan, nan, nan, nan, nan, nan],\n                  [nan, nan, 5, nan, nan, 3],\n                  [nan, nan, 1, 2, 3, nan],\n                  [nan, nan, nan, 5, nan, nan],\n                  [nan, nan, 1, nan, 3, nan]]\n\n    #\n    # business days calendar\n    #\n    bprice_index = date_range(start=\'2015-1-10\', end=\'2015-3-22\', freq=\'B\')\n    bprice_index.name = \'date\'\n    bprices = DataFrame(index=bprice_index, columns=tickers, data=price_data)\n\n    bfactor_index = date_range(start=\'2015-1-15\', end=\'2015-2-25\', freq=\'B\')\n    bfactor_index.name = \'date\'\n    bfactor = DataFrame(index=bfactor_index, columns=tickers,\n                        data=factor_data).stack()\n\n    #\n    # full calendar\n    #\n    price_index = date_range(start=\'2015-1-10\', end=\'2015-2-28\')\n    price_index.name = \'date\'\n    prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n    factor_index = date_range(start=\'2015-1-15\', end=\'2015-2-13\')\n    factor_index.name = \'date\'\n    factor = DataFrame(index=factor_index, columns=tickers,\n                       data=factor_data).stack()\n\n    #\n    # intraday factor\n    #\n    today_open = DataFrame(index=price_index+Timedelta(\'9h30m\'),\n                           columns=tickers, data=price_data)\n    today_open_1h = DataFrame(index=price_index+Timedelta(\'10h30m\'),\n                              columns=tickers, data=price_data)\n    today_open_1h += today_open_1h*0.001\n    today_open_3h = DataFrame(index=price_index+Timedelta(\'12h30m\'),\n                              columns=tickers, data=price_data)\n    today_open_3h -= today_open_3h*0.002\n    intraday_prices = concat([today_open, today_open_1h, today_open_3h]) \\\n        .sort_index()\n\n    intraday_factor = DataFrame(index=factor_index+Timedelta(\'9h30m\'),\n                                columns=tickers, data=factor_data).stack()\n\n    #\n    # event factor\n    #\n    bevent_factor = DataFrame(index=bfactor_index, columns=tickers,\n                              data=event_data).stack()\n\n    event_factor = DataFrame(index=factor_index, columns=tickers,\n                             data=event_data).stack()\n\n    all_prices = [prices, bprices]\n    all_factors = [factor, bfactor]\n    all_events = [event_factor, bevent_factor]\n\n    def __localize_prices_and_factor(self, prices, factor, tz):\n        if tz is not None:\n            factor = factor.unstack()\n            factor.index = factor.index.tz_localize(tz)\n            factor = factor.stack()\n            prices = prices.copy()\n            prices.index = prices.index.tz_localize(tz)\n        return prices, factor\n\n    @parameterized.expand([(2, (1, 5, 10), None),\n                           (3, (2, 4, 6), 20)])\n    def test_create_returns_tear_sheet(\n            self,\n            quantiles,\n            periods,\n            filter_zscore):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        factor_data = get_clean_factor_and_forward_returns(\n            self.factor,\n            self.prices,\n            quantiles=quantiles,\n            periods=periods,\n            filter_zscore=filter_zscore)\n\n        create_returns_tear_sheet(\n            factor_data, long_short=False, group_neutral=False, by_group=False)\n\n    @parameterized.expand([(1, (1, 5, 10), None),\n                           (4, (1, 2, 3, 7), 20)])\n    def test_create_information_tear_sheet(\n            self, quantiles, periods, filter_zscore):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        factor_data = get_clean_factor_and_forward_returns(\n            self.factor,\n            self.prices,\n            quantiles=quantiles,\n            periods=periods,\n            filter_zscore=filter_zscore)\n\n        create_information_tear_sheet(\n            factor_data, group_neutral=False, by_group=False)\n\n    @parameterized.expand([\n        (2, (2, 3, 6), None, 20),\n        (4, (1, 2, 3, 7), None, None),\n        (2, (2, 3, 6), [\'1D\', \'2D\'], 20),\n        (4, (1, 2, 3, 7), [\'1D\'], None),\n    ])\n    def test_create_turnover_tear_sheet(\n            self,\n            quantiles,\n            periods,\n            turnover_periods,\n            filter_zscore):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        factor_data = get_clean_factor_and_forward_returns(\n            self.factor,\n            self.prices,\n            quantiles=quantiles,\n            periods=periods,\n            filter_zscore=filter_zscore)\n\n        create_turnover_tear_sheet(factor_data, turnover_periods)\n\n    @parameterized.expand([(2, (1, 5, 10), None),\n                           (3, (1, 2, 3, 7), 20)])\n    def test_create_summary_tear_sheet(\n            self,\n            quantiles,\n            periods,\n            filter_zscore):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        factor_data = get_clean_factor_and_forward_returns(\n            self.factor,\n            self.prices,\n            quantiles=quantiles,\n            periods=periods,\n            filter_zscore=filter_zscore)\n\n        create_summary_tear_sheet(\n            factor_data, long_short=True, group_neutral=False)\n        create_summary_tear_sheet(\n            factor_data, long_short=False, group_neutral=False)\n\n    @parameterized.expand([\n        (2, (1, 5, 10), None, None),\n        (3, (2, 4, 6), 20, \'US/Eastern\'),\n        (4, (1, 8), 20, None),\n        (4, (1, 2, 3, 7), None, \'US/Eastern\'),\n    ])\n    def test_create_full_tear_sheet(\n            self,\n            quantiles,\n            periods,\n            filter_zscore,\n            tz):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        for factor, prices in zip(self.all_factors, self.all_prices):\n\n            prices, factor = self.__localize_prices_and_factor(prices,\n                                                               factor,\n                                                               tz)\n            factor_data = get_clean_factor_and_forward_returns(\n                factor,\n                prices,\n                groupby=self.factor_groups,\n                quantiles=quantiles,\n                periods=periods,\n                filter_zscore=filter_zscore)\n\n            create_full_tear_sheet(factor_data, long_short=False,\n                                   group_neutral=False, by_group=False)\n            create_full_tear_sheet(factor_data, long_short=True,\n                                   group_neutral=False, by_group=True)\n            create_full_tear_sheet(factor_data, long_short=True,\n                                   group_neutral=True, by_group=True)\n\n    @parameterized.expand([(2, (1, 5, 10), None, None),\n                           (3, (2, 4, 6), 20, None),\n                           (4, (3, 4), None, \'US/Eastern\'),\n                           (1, (2, 3, 6, 9), 20, \'US/Eastern\')])\n    def test_create_event_returns_tear_sheet(\n            self, quantiles, periods, filter_zscore, tz):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        for factor, prices in zip(self.all_factors, self.all_prices):\n\n            prices, factor = self.__localize_prices_and_factor(prices,\n                                                               factor,\n                                                               tz)\n            factor_data = get_clean_factor_and_forward_returns(\n                factor,\n                prices,\n                groupby=self.factor_groups,\n                quantiles=quantiles,\n                periods=periods,\n                filter_zscore=filter_zscore)\n\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=False, group_neutral=False, by_group=False)\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=True, group_neutral=False, by_group=False)\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=False, group_neutral=True, by_group=False)\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=False, group_neutral=False, by_group=True)\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=True, group_neutral=False, by_group=True)\n            create_event_returns_tear_sheet(factor_data, prices, avgretplot=(\n                5, 11), long_short=False, group_neutral=True, by_group=True)\n\n    @parameterized.expand([((6, 8), None, None),\n                           ((6, 8), None, None),\n                           ((6, 3), 20, None),\n                           ((6, 3), 20, \'US/Eastern\'),\n                           ((0, 3), None, None),\n                           ((3, 0), 20, \'US/Eastern\')])\n    def test_create_event_study_tear_sheet(\n            self, avgretplot, filter_zscore, tz):\n        """"""\n        Test no exceptions are thrown\n        """"""\n        for factor, prices in zip(self.all_events, self.all_prices):\n\n            prices, factor = self.__localize_prices_and_factor(prices,\n                                                               factor,\n                                                               tz)\n            factor_data = get_clean_factor_and_forward_returns(\n                factor, prices, bins=1, quantiles=None, periods=(\n                    1, 2), filter_zscore=filter_zscore)\n\n            create_event_study_tear_sheet(\n                factor_data, prices, avgretplot=avgretplot)\n'"
alphalens/tests/test_utils.py,0,"b'#\n# Copyright 2018 Quantopian, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the ""License"");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an ""AS IS"" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom __future__ import division\nfrom unittest import TestCase\nfrom parameterized import parameterized\nfrom numpy import (nan)\n\nfrom pandas import (\n    Series,\n    DataFrame,\n    date_range,\n    MultiIndex,\n    Timedelta,\n    Timestamp,\n    concat,\n)\nfrom pandas.util.testing import (assert_frame_equal,\n                                 assert_series_equal)\n\nfrom .. utils import (get_clean_factor_and_forward_returns,\n                      compute_forward_returns,\n                      quantize_factor)\n\n\nclass UtilsTestCase(TestCase):\n    dr = date_range(start=\'2015-1-1\', end=\'2015-1-2\')\n    dr.name = \'date\'\n    tickers = [\'A\', \'B\', \'C\', \'D\']\n\n    factor = DataFrame(index=dr,\n                       columns=tickers,\n                       data=[[1, 2, 3, 4],\n                             [4, 3, 2, 1]]).stack()\n    factor.index = factor.index.set_names([\'date\', \'asset\'])\n    factor.name = \'factor\'\n    factor_data = DataFrame()\n    factor_data[\'factor\'] = factor\n    factor_data[\'group\'] = Series(index=factor.index,\n                                  data=[1, 1, 2, 2, 1, 1, 2, 2],\n                                  dtype=""category"")\n\n    biased_factor = DataFrame(index=dr,\n                              columns=tickers.extend([\'E\', \'F\', \'G\', \'H\']),\n                              data=[[-1, 3, -2, 4, -5, 7, -6, 8],\n                                    [-4, 2, -3, 1, -8, 6, -7, 5]]).stack()\n    biased_factor.index = biased_factor.index.set_names([\'date\', \'asset\'])\n    biased_factor.name = \'factor\'\n    biased_factor_data = DataFrame()\n    biased_factor_data[\'factor\'] = biased_factor\n    biased_factor_data[\'group\'] = Series(index=biased_factor.index,\n                                         data=[1, 1, 2, 2, 1, 1, 2, 2,\n                                               1, 1, 2, 2, 1, 1, 2, 2],\n                                         dtype=""category"")\n\n    def test_compute_forward_returns(self):\n        dr = date_range(start=\'2015-1-1\', end=\'2015-1-3\')\n        prices = DataFrame(index=dr, columns=[\'A\', \'B\'],\n                           data=[[1, 1], [1, 2], [2, 1]])\n        factor = prices.stack()\n\n        fp = compute_forward_returns(factor, prices, periods=[1, 2])\n\n        ix = MultiIndex.from_product([dr, [\'A\', \'B\']],\n                                     names=[\'date\', \'asset\'])\n        expected = DataFrame(index=ix, columns=[\'1D\', \'2D\'])\n        expected[\'1D\'] = [0., 1., 1., -0.5, nan, nan]\n        expected[\'2D\'] = [1., 0., nan, nan, nan, nan]\n\n        assert_frame_equal(fp, expected)\n\n    def test_compute_forward_returns_index_out_of_bound(self):\n        dr = date_range(start=\'2014-12-29\', end=\'2015-1-3\')\n        prices = DataFrame(index=dr, columns=[\'A\', \'B\'],\n                           data=[[nan, nan], [nan, nan], [nan, nan],\n                                 [1, 1], [1, 2], [2, 1]])\n\n        dr = date_range(start=\'2015-1-1\', end=\'2015-1-3\')\n        factor = DataFrame(index=dr, columns=[\'A\', \'B\'],\n                           data=[[1, 1], [1, 2], [2, 1]])\n        factor = factor.stack()\n\n        fp = compute_forward_returns(factor, prices, periods=[1, 2])\n\n        ix = MultiIndex.from_product([dr, [\'A\', \'B\']],\n                                     names=[\'date\', \'asset\'])\n        expected = DataFrame(index=ix, columns=[\'1D\', \'2D\'])\n        expected[\'1D\'] = [0., 1., 1., -0.5, nan, nan]\n        expected[\'2D\'] = [1., 0., nan, nan, nan, nan]\n\n        assert_frame_equal(fp, expected)\n\n    def test_compute_forward_returns_non_cum(self):\n        dr = date_range(start=\'2015-1-1\', end=\'2015-1-3\')\n        prices = DataFrame(index=dr, columns=[\'A\', \'B\'],\n                           data=[[1, 1], [1, 2], [2, 1]])\n        factor = prices.stack()\n\n        fp = compute_forward_returns(factor, prices, periods=[1, 2],\n                                     cumulative_returns=False)\n\n        ix = MultiIndex.from_product([dr, [\'A\', \'B\']],\n                                     names=[\'date\', \'asset\'])\n        expected = DataFrame(index=ix, columns=[\'1D\', \'2D\'])\n        expected[\'1D\'] = [0., 1., 1., -0.5, nan, nan]\n        expected[\'2D\'] = [1., -0.5, nan, nan, nan, nan]\n\n        assert_frame_equal(fp, expected)\n\n    @parameterized.expand([(factor_data, 4, None, False, False,\n                            [1, 2, 3, 4, 4, 3, 2, 1]),\n                           (factor_data, 2, None, False, False,\n                            [1, 1, 2, 2, 2, 2, 1, 1]),\n                           (factor_data, 2, None, True, False,\n                            [1, 2, 1, 2, 2, 1, 2, 1]),\n                           (biased_factor_data, 4, None, False, True,\n                            [2, 3, 2, 3, 1, 4, 1, 4, 2, 3, 2, 3, 1, 4, 1, 4]),\n                           (biased_factor_data, 2, None, False, True,\n                            [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]),\n                           (biased_factor_data, 2, None, True, True,\n                            [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]),\n                           (biased_factor_data, None, 4, False, True,\n                            [2, 3, 2, 3, 1, 4, 1, 4, 2, 3, 2, 3, 1, 4, 1, 4]),\n                           (biased_factor_data, None, 2, False, True,\n                            [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]),\n                           (biased_factor_data, None, 2, True, True,\n                            [1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2]),\n                           (factor_data, [0, .25, .5, .75, 1.], None, False,\n                            False, [1, 2, 3, 4, 4, 3, 2, 1]),\n                           (factor_data, [0, .5, .75, 1.], None, False, False,\n                            [1, 1, 2, 3, 3, 2, 1, 1]),\n                           (factor_data, [0, .25, .5, 1.], None, False, False,\n                            [1, 2, 3, 3, 3, 3, 2, 1]),\n                           (factor_data, [0, .5, 1.], None, False, False,\n                            [1, 1, 2, 2, 2, 2, 1, 1]),\n                           (factor_data, [.25, .5, .75], None, False, False,\n                            [nan, 1, 2, nan, nan, 2, 1, nan]),\n                           (factor_data, [0, .5, 1.], None, True, False,\n                            [1, 2, 1, 2, 2, 1, 2, 1]),\n                           (factor_data, [.5, 1.], None, True, False,\n                            [nan, 1, nan, 1, 1, nan, 1, nan]),\n                           (factor_data, [0, 1.], None, True, False,\n                            [1, 1, 1, 1, 1, 1, 1, 1]),\n                           (factor_data, None, 4, False, False,\n                            [1, 2, 3, 4, 4, 3, 2, 1]),\n                           (factor_data, None, 2, False, False,\n                            [1, 1, 2, 2, 2, 2, 1, 1]),\n                           (factor_data, None, 3, False, False,\n                            [1, 1, 2, 3, 3, 2, 1, 1]),\n                           (factor_data, None, 8, False, False,\n                            [1, 3, 6, 8, 8, 6, 3, 1]),\n                           (factor_data, None, [0, 1, 2, 3, 5], False, False,\n                            [1, 2, 3, 4, 4, 3, 2, 1]),\n                           (factor_data, None, [1, 2, 3], False, False,\n                            [nan, 1, 2, nan, nan, 2, 1, nan]),\n                           (factor_data, None, [0, 2, 5], False, False,\n                            [1, 1, 2, 2, 2, 2, 1, 1]),\n                           (factor_data, None, [0.5, 2.5, 4.5], False, False,\n                            [1, 1, 2, 2, 2, 2, 1, 1]),\n                           (factor_data, None, [0.5, 2.5], True, False,\n                            [1, 1, nan, nan, nan, nan, 1, 1]),\n                           (factor_data, None, 2, True, False,\n                            [1, 2, 1, 2, 2, 1, 2, 1])])\n    def test_quantize_factor(self, factor, quantiles, bins, by_group,\n                             zero_aware, expected_vals):\n        quantized_factor = quantize_factor(factor,\n                                           quantiles=quantiles,\n                                           bins=bins,\n                                           by_group=by_group,\n                                           zero_aware=zero_aware)\n        expected = Series(index=factor.index,\n                          data=expected_vals,\n                          name=\'factor_quantile\').dropna()\n        assert_series_equal(quantized_factor, expected)\n\n    def test_get_clean_factor_and_forward_returns_1(self):\n        """"""\n        Test get_clean_factor_and_forward_returns with a daily factor\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 7)]  # 6 days = 3 + 3 fwd returns\n\n        factor_data = [[3, 4, 2, 1, nan, nan],\n                       [3, nan, nan, 1, 4, 2],\n                       [3, 4, 2, 1, nan, nan]]  # 3 days\n\n        start = \'2015-1-11\'\n        factor_end = \'2015-1-13\'\n        price_end = \'2015-1-16\'  # 3D fwd returns\n\n        price_index = date_range(start=start, end=price_end)\n        price_index.name = \'date\'\n        prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n        factor_index = date_range(start=start, end=factor_end)\n        factor_index.name = \'date\'\n        factor = DataFrame(index=factor_index, columns=tickers,\n                           data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1D\', \'2D\', \'3D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [-0.5, -0.75, -0.875, 4.0, 1, 4],\n                         [0.0,  0.00,  0.000, 2.0, 2, 2],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1]]\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n    def test_get_clean_factor_and_forward_returns_2(self):\n        """"""\n        Test get_clean_factor_and_forward_returns with a daily factor\n        on a business day calendar\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 7)]  # 6 days = 3 + 3 fwd returns\n\n        factor_data = [[3, 4, 2, 1, nan, nan],\n                       [3, nan, nan, 1, 4, 2],\n                       [3, 4, 2, 1, nan, nan]]  # 3 days\n\n        start = \'2017-1-12\'\n        factor_end = \'2017-1-16\'\n        price_end = \'2017-1-19\'  # 3D fwd returns\n\n        price_index = date_range(start=start, end=price_end, freq=\'B\')\n        price_index.name = \'date\'\n        prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n        factor_index = date_range(start=start, end=factor_end, freq=\'B\')\n        factor_index.name = \'date\'\n        factor = DataFrame(index=factor_index, columns=tickers,\n                           data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1D\', \'2D\', \'3D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [-0.5, -0.75, -0.875, 4.0, 1, 4],\n                         [0.0,  0.00,  0.000, 2.0, 2, 2],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1]]\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n    def test_get_clean_factor_and_forward_returns_3(self):\n        """"""\n        Test get_clean_factor_and_forward_returns with and intraday factor\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 5)]  # 4 days = 3 + 1 fwd returns\n\n        factor_data = [[3, 4, 2, 1, nan, nan],\n                       [3, nan, nan, 1, 4, 2],\n                       [3, 4, 2, 1, nan, nan]]  # 3 days\n\n        start = \'2017-1-12\'\n        factor_end = \'2017-1-16\'\n        price_end = \'2017-1-17\'  # 1D fwd returns\n\n        price_index = date_range(start=start, end=price_end, freq=\'B\')\n        price_index.name = \'date\'\n        today_open = DataFrame(index=price_index + Timedelta(\'9h30m\'),\n                               columns=tickers, data=price_data)\n        today_open_1h = DataFrame(index=price_index + Timedelta(\'10h30m\'),\n                                  columns=tickers, data=price_data)\n        today_open_1h += today_open_1h * 0.001\n        today_open_3h = DataFrame(index=price_index + Timedelta(\'12h30m\'),\n                                  columns=tickers, data=price_data)\n        today_open_3h -= today_open_3h * 0.002\n        prices = concat([today_open, today_open_1h, today_open_3h]) \\\n            .sort_index()\n\n        factor_index = date_range(start=start, end=factor_end, freq=\'B\')\n        factor_index.name = \'date\'\n        factor = DataFrame(index=factor_index + Timedelta(\'9h30m\'),\n                           columns=tickers, data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1h\', \'3h\', \'1D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.5, 4.0, 2, 4],\n                         [0.001, -0.002, 2.0, 2.0, 1, 2],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1],\n                         [0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1],\n                         [0.001, -0.002, -0.5, 4.0, 1, 4],\n                         [0.001, -0.002, 0.0, 2.0, 2, 2],\n                         [0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.5, 4.0, 2, 4],\n                         [0.001, -0.002, 2.0, 2.0, 1, 2],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1]]\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n    def test_get_clean_factor_and_forward_returns_4(self):\n        """"""\n        Test get_clean_factor_and_forward_returns on an event\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 9)]\n\n        factor_data = [[1, nan, nan, nan, nan, 6],\n                       [4, nan, nan, 7, nan, nan],\n                       [nan, nan, nan, nan, nan, nan],\n                       [nan, 3, nan, 2, nan, nan],\n                       [nan, nan, 1, nan, 3, nan]]\n\n        price_index = date_range(start=\'2017-1-12\', end=\'2017-1-23\', freq=\'B\')\n        price_index.name = \'date\'\n        prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n        factor_index = date_range(start=\'2017-1-12\', end=\'2017-1-18\', freq=\'B\')\n        factor_index.name = \'date\'\n        factor = DataFrame(index=factor_index, columns=tickers,\n                           data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1D\', \'2D\', \'3D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.1,  0.21,  0.331, 1.0, 1, 1],\n                         [0.0,   0.00,  0.000, 6.0, 2, 4],\n                         [0.1,  0.21,  0.331, 4.0, 1, 1],\n                         [-0.1, -0.19, -0.271, 7.0, 2, 4],\n                         [-0.5, -0.75, -0.875, 3.0, 2, 4],\n                         [-0.1, -0.19, -0.271, 2.0, 2, 1],\n                         [2.0,  8.00, 26.000, 1.0, 1, 1],\n                         [-0.5, -0.75, -0.875, 3.0, 1, 4]]\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n    def test_get_clean_factor_and_forward_returns_5(self):\n        """"""\n        Test get_clean_factor_and_forward_returns with and intraday factor\n        and holidays\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 20)]  # 19 days = 18 + 1 fwd returns\n\n        factor_data = [[3, 4, 2, 1, nan, nan],\n                       [3, nan, nan, 1, 4, 2],\n                       [3, 4, 2, 1, nan, nan]] * 6  # 18 days\n\n        start = \'2017-1-12\'\n        factor_end = \'2017-2-10\'\n        price_end = \'2017-2-13\'  # 1D (business day) fwd returns\n        holidays = [\'2017-1-13\', \'2017-1-18\', \'2017-1-30\', \'2017-2-7\']\n        holidays = [Timestamp(d) for d in holidays]\n\n        price_index = date_range(start=start, end=price_end, freq=\'B\')\n        price_index.name = \'date\'\n        price_index = price_index.drop(holidays)\n\n        today_open = DataFrame(index=price_index + Timedelta(\'9h30m\'),\n                               columns=tickers, data=price_data)\n        today_open_1h = DataFrame(index=price_index + Timedelta(\'10h30m\'),\n                                  columns=tickers, data=price_data)\n        today_open_1h += today_open_1h * 0.001\n        today_open_3h = DataFrame(index=price_index + Timedelta(\'12h30m\'),\n                                  columns=tickers, data=price_data)\n        today_open_3h -= today_open_3h * 0.002\n        prices = concat([today_open, today_open_1h, today_open_3h]) \\\n            .sort_index()\n\n        factor_index = date_range(start=start, end=factor_end, freq=\'B\')\n        factor_index.name = \'date\'\n        factor_index = factor_index.drop(holidays)\n        factor = DataFrame(index=factor_index + Timedelta(\'9h30m\'),\n                           columns=tickers, data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1h\', \'3h\', \'1D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.5, 4.0, 2, 4],\n                         [0.001, -0.002, 2.0, 2.0, 1, 2],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1],\n                         [0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1],\n                         [0.001, -0.002, -0.5, 4.0, 1, 4],\n                         [0.001, -0.002, 0.0, 2.0, 2, 2],\n                         [0.001, -0.002, 0.1, 3.0, 1, 3],\n                         [0.001, -0.002, -0.5, 4.0, 2, 4],\n                         [0.001, -0.002, 2.0, 2.0, 1, 2],\n                         [0.001, -0.002, -0.1, 1.0, 2, 1]] * 6  # 18  days\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n        inferred_holidays = factor_data.index.levels[0].freq.holidays\n        assert sorted(holidays) == sorted(inferred_holidays)\n\n    def test_get_clean_factor_and_forward_returns_6(self):\n        """"""\n        Test get_clean_factor_and_forward_returns with a daily factor\n        on a business day calendar and holidays\n        """"""\n        tickers = [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\']\n\n        factor_groups = {\'A\': 1, \'B\': 2, \'C\': 1, \'D\': 2, \'E\': 1, \'F\': 2}\n\n        price_data = [[1.10**i, 0.50**i, 3.00**i, 0.90**i, 0.50**i, 1.00**i]\n                      for i in range(1, 22)]  # 21 days = 18 + 3 fwd returns\n\n        factor_data = [[3, 4, 2, 1, nan, nan],\n                       [3, nan, nan, 1, 4, 2],\n                       [3, 4, 2, 1, nan, nan]] * 6  # 18 days\n\n        start = \'2017-1-12\'\n        factor_end = \'2017-2-10\'\n        price_end = \'2017-2-15\'  # 3D (business day) fwd returns\n        holidays = [\'2017-1-13\', \'2017-1-18\', \'2017-1-30\', \'2017-2-7\']\n        holidays = [Timestamp(d) for d in holidays]\n\n        price_index = date_range(start=start, end=price_end, freq=\'B\')\n        price_index.name = \'date\'\n        price_index = price_index.drop(holidays)\n        prices = DataFrame(index=price_index, columns=tickers, data=price_data)\n\n        factor_index = date_range(start=start, end=factor_end, freq=\'B\')\n        factor_index.name = \'date\'\n        factor_index = factor_index.drop(holidays)\n        factor = DataFrame(index=factor_index, columns=tickers,\n                           data=factor_data).stack()\n\n        factor_data = get_clean_factor_and_forward_returns(\n            factor, prices,\n            groupby=factor_groups,\n            quantiles=4,\n            periods=(1, 2, 3))\n\n        expected_idx = factor.index.rename([\'date\', \'asset\'])\n        expected_cols = [\'1D\', \'2D\', \'3D\',\n                         \'factor\', \'group\', \'factor_quantile\']\n        expected_data = [[0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1],\n                         [-0.5, -0.75, -0.875, 4.0, 1, 4],\n                         [0.0,  0.00,  0.000, 2.0, 2, 2],\n                         [0.1,  0.21,  0.331, 3.0, 1, 3],\n                         [-0.5, -0.75, -0.875, 4.0, 2, 4],\n                         [2.0,  8.00, 26.000, 2.0, 1, 2],\n                         [-0.1, -0.19, -0.271, 1.0, 2, 1]] * 6  # 18  days\n        expected = DataFrame(index=expected_idx,\n                             columns=expected_cols, data=expected_data)\n        expected[\'group\'] = expected[\'group\'].astype(\'category\')\n\n        assert_frame_equal(factor_data, expected)\n\n        inferred_holidays = factor_data.index.levels[0].freq.holidays\n        assert sorted(holidays) == sorted(inferred_holidays)\n'"
docs/source/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Alphalens documentation build configuration file, created by\n# sphinx-quickstart on Tue Jul  5 15:45:48 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\nfrom alphalens import __version__ as version\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'../..\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'numpydoc\'\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = u\'Alphalens\'\ncopyright = u\'2016, Quantopian, Inc.\'\nauthor = u\'Quantopian, Inc.\'\n\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only \'ja\' uses this config value\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'Alphalensdoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n\n# Latex figure (float) alignment\n#\'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'Alphalens.tex\', u\'Alphalens Documentation\',\n     u\'Quantopian, Inc.\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'alphalens\', u\'Alphalens Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'Alphalens\', u\'Alphalens Documentation\',\n     author, \'Alphalens\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n'"
