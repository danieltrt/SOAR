file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n""""""The setup script.""""""\n\nimport sys\nfrom setuptools import setup, find_packages\n\n\ndef get_version(filename):\n    """"""Extract the package version""""""\n    with open(filename) as in_fh:\n        for line in in_fh:\n            if line.startswith(""__version__""):\n                return line.split(""="")[1].strip()[1:-1]\n    raise ValueError(""Cannot extract version from %s"" % filename)\n\n\nwith open(""README.rst"") as readme_file:\n    readme = readme_file.read()\n\ntry:\n    with open(""HISTORY.rst"") as history_file:\n        history = history_file.read()\nexcept OSError:\n    history = """"\n\nrequirements = [""numpy""]\n\ndev_requirements = [\n    ""better-apidoc"",\n    ""coverage"",\n    ""flake8"",\n    ""gitpython"",\n    ""jupyter"",\n    ""matplotlib"",\n    ""nbsphinx"",\n    ""nbval"",\n    ""numba"",\n    ""pep8"",\n    ""pytest"",\n    ""pytest-cov"",\n    ""pytest-xdist"",\n    ""qutip"",\n    ""snakeviz"",\n    ""sphinx"",\n    ""sphinx-autobuild"",\n    ""sphinx-autodoc-typehints"",\n    ""sphinx_rtd_theme"",\n    ""sphinxcontrib-bibtex"",\n    ""twine"",\n    ""watermark"",\n    ""wheel"",\n]\n\nif sys.version_info >= (3, 6):\n    dev_requirements.extend([""black"", ""blackcellmagic""])\n\n\nversion = get_version(""./src/newtonprop/__init__.py"")\n\nsetup(\n    author=""Michael Goerz"",\n    author_email=""mail@michaelgoerz.net"",\n    classifiers=[\n        ""Development Status :: 2 - Pre-Alpha"",\n        ""Intended Audience :: Developers"",\n        ""License :: OSI Approved :: BSD License"",\n        ""Natural Language :: English"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n    ],\n    description=""Python reference implementation of the Newton propagator for quantum dynamics"",\n    python_requires="">=3.5"",\n    install_requires=requirements,\n    extras_require={""dev"": dev_requirements},\n    license=""BSD license"",\n    long_description=readme + ""\\n\\n"" + history,\n    include_package_data=True,\n    keywords=""newtonprop"",\n    name=""newtonprop"",\n    packages=find_packages(where=""src""),\n    package_dir={"""": ""src""},\n    url=""https://github.com/qucontrol/newtonprop"",\n    version=version,\n    zip_safe=False,\n)\n'"
docs/conf.py,0,"b'# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nimport os\nimport sys\nimport datetime\nimport git\n\nimport newtonprop\n\nfrom unittest import mock\nMOCK_MODULES = [\'numpy\', \'numpy.linalg\', \'scipy\', \'scipy.sparse\', \'matplotlib\',\n    \'matplotlib.pyplot\']\nsys.modules.update((mod_name, mock.Mock()) for mod_name in MOCK_MODULES)\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'_extensions\'))\n\n# -- Generate API documentation ------------------------------------------------\ndef run_apidoc(_):\n    """"""Generage API documentation""""""\n    import better_apidoc\n    better_apidoc.main([\n        \'better-apidoc\',\n        \'-t\',\n        os.path.join(\'.\', \'_templates\'),\n        \'--force\',\n        \'--no-toc\',\n        \'--separate\',\n        \'-o\',\n        os.path.join(\'.\', \'API\'),\n        os.path.join(\'..\', \'src\', \'newtonprop\'),\n    ])\n\n\n# -- General configuration -----------------------------------------------------\n\n# Report broken links as warnings\nnitpicky = True\nnitpick_ignore = [\n    (\'py:class\', \'callable\'),\n]\n\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.doctest\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.napoleon\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.autosummary\',\n    \'sphinx.ext.extlinks\',\n    \'sphinx.ext.ifconfig\',\n    \'sphinx.ext.todo\',\n    \'dollarmath\',\n    \'nbsphinx\',\n    \'sphinx.ext.inheritance_diagram\',\n    \'sphinx_autodoc_typehints\',\n    \'sphinxcontrib.bibtex\',\n]\n\nif os.getenv(\'SPELLCHECK\'):\n    extensions += \'sphinxcontrib.spelling\',\n    spelling_show_suggestions = True\n    spelling_lang = os.getenv(\'SPELLCHECK\')\n    spelling_word_list_filename = \'spelling_wordlist.txt\'\n    spelling_ignore_pypi_package_names = True\n\nintersphinx_mapping = {\n    \'python\': (\'https://docs.python.org/3.7\', None),\n    \'sympy\': (\'https://docs.sympy.org/latest/\', None),\n    \'scipy\': (\'https://docs.scipy.org/doc/scipy/reference/\', None),\n    \'numpy\': (\'https://docs.scipy.org/doc/numpy/\', None),\n    \'matplotlib\': (\'https://matplotlib.org/\', None),\n    \'qutip\': (\'http://qutip.org/docs/latest/\', None),\n}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\nsource_suffix = \'.rst\'\nmaster_doc = \'index\'\nproject = \'newtonprop\'\nyear = str(datetime.datetime.now().year)\nauthor = \'Michael Goerz\'\ncopyright = \'{0}, {1}\'.format(year, author)\nversion = newtonprop.__version__\nrootfolder = os.path.join(os.path.dirname(__file__), \'..\')\ntry:\n    last_commit = str(git.Repo(rootfolder).head.commit)[:7]\n    release = last_commit\nexcept (git.exc.InvalidGitRepositoryError, ValueError):\n    release = version\nnumfig = True\n\npygments_style = \'friendly\'\nextlinks = {\n    \'issue\': (\'https://github.com/qucontrol/newtonprop/issues/%s\', \'#\'),\n    \'pr\': (\'https://github.com/qucontrol/newtonprop/pull/%s\', \'PR #\'),\n}\n\n# autodoc settings\nautoclass_content = \'both\'\nautodoc_member_order = \'bysource\'\n\n\nhtml_last_updated_fmt = \'%b %d, %Y\'\nhtml_split_index = False\nhtml_sidebars = {\n   \'**\': [\'searchbox.html\', \'globaltoc.html\', \'sourcelink.html\'],\n}\nhtml_short_title = \'%s-%s\' % (project, version)\n\n\n# Mathjax settings\nmathjax_path = \'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js\'\nmathjax_config = {\n    \'extensions\': [\'tex2jax.js\'],\n    \'jax\': [\'input/TeX\', \'output/SVG\'],\n    \'TeX\': {\n        \'extensions\': [\n            ""AMSmath.js"", ""AMSsymbols.js"", ""noErrors.js"", ""noUndefined.js""],\n        \'Macros\': {\n            \'tr\': [\'{\\\\operatorname{tr}}\', 0],\n            \'diag\': [\'{\\\\operatorname{diag}}\', 0],\n            \'abs\': [\'{\\\\operatorname{abs}}\', 0],\n            \'pop\': [\'{\\\\operatorname{pop}}\', 0],\n            \'ee\': [\'{\\\\text{e}}\', 0],\n            \'ii\': [\'{\\\\text{i}}\', 0],\n            \'aux\': [\'{\\\\text{aux}}\', 0],\n            \'opt\': [\'{\\\\text{opt}}\', 0],\n            \'tgt\': [\'{\\\\text{tgt}}\', 0],\n            \'init\': [\'{\\\\text{init}}\', 0],\n            \'lab\': [\'{\\\\text{lab}}\', 0],\n            \'rwa\': [\'{\\\\text{rwa}}\', 0],\n            \'bra\': [\'{\\\\langle#1\\\\vert}\', 1],\n            \'ket\': [\'{\\\\vert#1\\\\rangle}\', 1],\n            \'Bra\': [\'{\\\\left\\\\langle#1\\\\right\\\\vert}\', 1],\n            \'Braket\': [\'{\\\\left\\\\langle #1\\\\vphantom{#2} \\\\mid #2\\\\vphantom{#1}\\\\right\\\\rangle}\', 2],\n            \'Ket\': [\'{\\\\left\\\\vert#1\\\\right\\\\rangle}\', 1],\n            \'mat\': [\'{\\\\mathbf{#1}}\', 1],\n            \'op\': [\'{\\\\hat{#1}}\', 1],\n            \'Op\': [\'{\\\\hat{#1}}\', 1],\n            \'dd\': [\'{\\\\,\\\\text{d}}\', 0],\n            \'daggered\': [\'{^{\\\\dagger}}\', 0],\n            \'transposed\': [\'{^{\\\\text{T}}}\', 0],\n            \'Liouville\': [\'{\\\\mathcal{L}}\', 0],\n            \'DynMap\': [\'{\\\\mathcal{E}}\', 0],\n            \'identity\': [\'{\\\\mathbf{1}}\', 0],\n            \'Norm\': [\'{\\\\lVert#1\\\\rVert}\', 1],\n            \'Abs\': [\'{\\\\left\\\\vert#1\\\\right\\\\vert}\', 1],\n            \'avg\': [\'{\\\\langle#1\\\\rangle}\', 1],\n            \'Avg\': [\'{\\\\left\\langle#1\\\\right\\\\rangle}\', 1],\n            \'AbsSq\': [\'{\\\\left\\\\vert#1\\\\right\\\\vert^2}\', 1],\n            \'Re\': [\'{\\\\operatorname{Re}}\', 0],\n            \'Im\': [\'{\\\\operatorname{Im}}\', 0],\n            \'Real\': [\'{\\\\mathbb{R}}\', 0],\n            \'Complex\': [\'{\\\\mathbb{C}}\', 0],\n            \'Integer\': [\'{\\\\mathbb{N}}\', 0],\n        }\n    }\n}\n\n\n# Napoleon settings\nnapoleon_google_docstring = True\nnapoleon_numpy_docstring = True\nnapoleon_include_private_with_doc = False\nnapoleon_include_special_with_doc = True\nnapoleon_use_admonition_for_examples = False\nnapoleon_use_admonition_for_notes = False\nnapoleon_use_admonition_for_references = False\nnapoleon_use_ivar = False\nnapoleon_use_param = True\nnapoleon_use_rtype = True\n\n# -- Monkeypatch for instance attribs (sphinx bug #2044) -----------------------\n\n\nfrom sphinx.ext.autodoc import (\n    ClassLevelDocumenter, InstanceAttributeDocumenter)\n\n\ndef iad_add_directive_header(self, sig):\n    ClassLevelDocumenter.add_directive_header(self, sig)\n\n\nInstanceAttributeDocumenter.add_directive_header = iad_add_directive_header\n\n# -- Options for HTML output ---------------------------------------------------\n\n# on_rtd is whether we are on readthedocs.org, this line of code grabbed from\n# docs.readthedocs.org\non_rtd = os.environ.get(\'READTHEDOCS\', None) == \'True\'\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nif not on_rtd:  # only import and set the theme if we\'re building docs locally\n    import sphinx_rtd_theme\n    html_theme = ""sphinx_rtd_theme""\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n#html_theme = \'sphinxdoc\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \'collapse_navigation\': True,\n    \'display_version\': True,\n    \'navigation_depth\': 4,\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = \'favicon.ico\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = False\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\nnbsphinx_prolog = r""""""\n{% set docname = env.doc2path(env.docname, base=\'docs\') %}\n\n.. only:: html\n\n    .. role:: raw-html(raw)\n        :format: html\n\n    :raw-html:`<a href=""http://nbviewer.jupyter.org/github/qucontrol/newtonprop/blob/{{ env.config.release }}/{{ docname }}"" target=""_blank""><img alt=""Render on nbviewer"" src=""https://img.shields.io/badge/render%20on-nbviewer-orange.svg"" style=""vertical-align:text-bottom""></a>&nbsp;<a href=""https://mybinder.org/v2/gh/qucontrol/newtonprop/{{ env.config.release }}?filepath={{ docname }}"" target=""_blank""><img alt=""Launch Binder"" src=""https://mybinder.org/badge_logo.svg"" style=""vertical-align:text-bottom""></a>`\n""""""\n# -----------------------------------------------------------------------------\ndef setup(app):\n    app.connect(\'builder-inited\', run_apidoc)\n'"
tests/test_newton.py,9,"b'""""""Tests for `newtonprop` package.""""""\nfrom pkg_resources import parse_version\n\nfrom math import pi\nimport numpy as np\nimport pytest\n\nimport newtonprop\n\nN = 10\n\n\ndef test_valid_version():\n    """"""Check that the package defines a valid __version__""""""\n    assert parse_version(newtonprop.__version__) >= parse_version(""0.1.0"")\n\n\n@pytest.fixture\ndef liouvillian():\n\n    two_pi = 2.0 * pi\n    w_c = two_pi * 0.01        # GHz\n    gamma = two_pi * 0.1       # GHZ\n    E0 = 0.1                   # GHZ\n\n    # Drift Hamiltonian\n    H0 = np.array(np.zeros(shape=(N, N), dtype=np.complex128))\n    for i in range(N):\n        H0[i, i] = i * w_c\n\n    # Control Hamiltonian\n    H1 = np.array(np.zeros(shape=(N, N), dtype=np.complex128))\n    for i in range(1, N):\n        H1[i-1, i] = np.sqrt(float(i))\n        H1[i, i-1] = H1[i-1, i]\n\n    # Total Hamiltonian\n    H = H0 + E0 * H1\n\n    # Dissipator\n    a = np.array(np.zeros(shape=(N, N), dtype=np.complex128))\n    for i in range(1, N):\n        a[i-1, i] = np.sqrt(i)\n\n    a_dag = a.conj().T\n\n    def L(rho):\n        Lrho = -1j * (H@rho - rho@H)\n        Lrho += gamma * (\n            a @ rho @ a_dag - 0.5 * (a_dag @ a @ rho + rho @ a_dag @ a))\n        return Lrho\n\n    return L\n\n\n@pytest.fixture\ndef rho0():\n    rho = np.matrix(np.zeros(shape=(N, N), dtype=np.complex128))\n    rho[:, :] = 1.0 / float(N)\n    return rho\n\n\ndef test_newton(liouvillian, rho0):\n    assert abs(1-np.trace(rho0)) < 1e-12\n    rho = newtonprop.propagator.step(liouvillian, rho0, dt=0.1, func=np.exp)\n    assert abs(1-np.trace(rho)) < 1e-12\n'"
docs/_extensions/dollarmath.py,0,"b'# This program is public domain\n# Author: Paul Kienzle\nr""""""\nAllow $math$ markup in text and docstrings, ignoring \\$.\n\nThe $math$ markup should be separated from the surrounding text by spaces.  To\nembed markup within a word, place backslash-space before and after.  For\nconvenience, the final $ can be followed by punctuation (period, comma or\nsemicolon).\n""""""\n\nimport re\n\n_dollar = re.compile(r""(?:^|(?<=\\s))[$]([^\\n]*?)(?<![\\\\])[$](?:$|(?=\\s|[.,;\\\\]))"")\n_notdollar = re.compile(r""\\\\[$]"")\n\ndef replace_dollar(content):\n    original = content\n    content = _dollar.sub(r"":math:`\\1`"",content)\n    content = _notdollar.sub(""$"", content)\n    #if \'$\' in content:\n    #    import sys\n    #    sys.stdout.write(""\\n========> not converted\\n"")\n    #    sys.stdout.write(content)\n    #    sys.stdout.write(""\\n"")\n    #elif \'$\' in original:\n    #    import sys\n    #    sys.stdout.write(""\\n========> converted\\n"")\n    #    sys.stdout.write(content)\n    #    sys.stdout.write(""\\n"")\n    return content\n\n\ndef rewrite_rst(app, docname, source):\n    # We specifically must not transform *.ipynb files, because this interacts\n    # badly with the npsphinx plugin, producing broken math. We thus restrict\n    # ourselfs to *.rst files (which include the autogenrated API)\n    if app.env.doc2path(docname).endswith(\'rst\'):\n        source[0] = replace_dollar(source[0])\n\n\ndef rewrite_autodoc(app, what, name, obj, options, lines):\n    lines[:] = [replace_dollar(L) for L in lines]\n\n\ndef setup(app):\n    app.connect(\'source-read\', rewrite_rst)\n    app.connect(\'autodoc-process-docstring\', rewrite_autodoc)\n\n\ndef test_dollar():\n    assert replace_dollar(u""no dollar"")==u""no dollar""\n    assert replace_dollar(u""$only$"")==u"":math:`only`""\n    assert replace_dollar(u""$first$ is good"")==u"":math:`first` is good""\n    assert replace_dollar(u""so is $last$"")==u""so is :math:`last`""\n    assert replace_dollar(u""and $mid$ too"")==u""and :math:`mid` too""\n    assert replace_dollar(u""$first$, $mid$, $last$"")==u"":math:`first`, :math:`mid`, :math:`last`""\n    assert replace_dollar(u""dollar\\$ escape"")==u""dollar$ escape""\n    assert replace_dollar(u""dollar \\$escape\\$ too"")==u""dollar $escape$ too""\n    assert replace_dollar(u""emb\\ $ed$\\ ed"")==u""emb\\ :math:`ed`\\ ed""\n    assert replace_dollar(u""$first$a"")==u""$first$a""\n    assert replace_dollar(u""a$last$"")==u""a$last$""\n    assert replace_dollar(u""a $mid$dle a"")==u""a $mid$dle a""\n\nif __name__ == ""__main__"":\n    test_dollar()\n'"
src/newtonprop/__init__.py,0,"b'""""""Pure Python reference implementation of the Newton propagator for quantum\ndynamics.""""""\n\n__version__ = \'0.1.0\'\n\nfrom .propagator import step as newton\nfrom .interface import NewtonPropagatorBase\n\n__all__ = [\'newton\', \'NewtonPropagatorBase\']\n'"
src/newtonprop/interface.py,1,"b'""""""Recommended interface for a stateful Newton propagator\n\nTypically, an efficient propagator will rely on low-level data structures.\nSince conversion between high- and low-level structures in every call of\n:func:`newtonprop.propagator.step` would be wasteful, it is better to use a\nstateful propagator that only does the conversion once, holds the required\nstate, and converts back only on demand.\n\nWhile a stateful propagator could be achieved through a wrapper function and\nclosures, a more straightforward implementation holds the necessary state in a\nclass. To encourage a consistent interface, you should subclass\n:class:`NewtonPropagatorBase` for this purpose.\n""""""\nfrom abc import ABCMeta, abstractmethod\n\nimport numpy as np\n\nfrom .propagator import _step, _exp, _expmi, _expi\n\n\n__all__ = [""NewtonPropagatorBase""]\n\n\nclass NewtonPropagatorBase(metaclass=ABCMeta):\n    """"""Abstract base class for a stateful interface for using the Newton\n    propagator\n\n    This must be sub-classed before it can be used.\n\n    Args:\n        data: data that underlies the abstract operator $A$. The propagator\n            will use this together with a time parameter `t` to construct the\n            argument `A` for :func:`newtonprop.propagator.step`.\n        func (callable or str): The scalar version of the operator-function\n            $f$.  Must take one complex argument and return a\n            complex value. If given as a string, the corresponding callable\n            will be looked up in :attr:`funcs`.\n        m_max (int): Maximal Krylov dimension. Initializes the corresponding\n            attribute.\n        maxrestart (int): Maximum number of Newton restarts. Initializes the\n            corresponding attribute.\n        tol (float): Desired precision of the result. Initializes the\n            corresponding attribute.\n\n    Subclasses will customize the behavior mostly by overriding a number of\n    private methods, outlined below. These methods may act on the following\n    (private) attributes:\n\n    .. py:attribute:: _data\n\n        Internal data that may be used to calculate $A$. Obtained from\n        `data` via :meth:`_convert_data_to_internal`.\n\n    .. py:attribute:: _v0\n\n        The state set by :meth:`set_initial_state`, in its original format\n\n    .. py:attribute:: _v\n\n        The current state, in an internal format. The internal format is\n        determined by :meth:`_convert_state_to_internal`.\n\n    **Private methods:**\n\n    .. automethod:: _check\n\n    .. automethod:: _convert_state_to_internal\n\n    .. automethod:: _convert_state_from_internal\n\n    .. automethod:: _convert_data_to_internal\n\n    .. automethod:: _inner\n\n    .. automethod:: _norm\n\n    .. automethod:: _zero\n\n    .. automethod:: _A\n\n    **Public methods, attributes, and properties:**\n\n    .. py:attribute:: func\n\n        The scalar version of the operator-function $f$, as a callable\n\n    .. py:attribute:: m_max\n\n        Maximal Krylov dimension (int)\n\n    .. py:attribute:: maxrestart\n\n        Maximum number of Newton restarts (int)\n\n    .. py:attribute:: tol\n\n        Desired precision of the result (float)\n    """"""\n\n    #: Registry of `func` names (class attribute)\n    #:\n    #: Cf. the `func` argument of :func:`newtonprop.propagator.step`. You may\n    #: extend this with your own function names.\n    funcs = {""exp"": _exp, ""expmi"": _expmi, ""expi"": _expi}\n\n    def __init__(self, data, func=""exp"", m_max=10, maxrestart=100, tol=1e-12):\n        if isinstance(func, str):\n            func = self.funcs[func]\n        self._data = self._convert_data_to_internal(data)\n        self.func = func\n        self._v0 = None\n        self._v = None\n        self.m_max = m_max\n        self.maxrestart = maxrestart\n        self.tol = tol\n\n    def set_initial_state(self, v):\n        """"""Set the initial state for the propagation.""""""\n        # Note: `self._v` does not need to be the same as the input `v`. In\n        # general, you want to convert `v` to a more efficient internal format\n        # and store that.\n        self._v0 = v\n        self._v = self._convert_state_to_internal(v)\n        self._check()\n\n    @property\n    def state(self):\n        """"""The current state (read-only)\n\n        After a call to :meth:`set_initial_state`, this is the state set by\n        that call. After a call to :meth:`step`, it is the result of that\n        propagation step.\n        """"""\n        res = self._convert_state_from_internal(self._v)\n        assert isinstance(res, self._v0.__class__)\n        return res\n\n    def step(self, t, dt):\n        r""""""Perform a single propagation step\n\n        Args:\n            t (float): time value at which to evaluate the abstract operator\n                $A(t)$\n            dt (float): length of the time step\n\n        Construct an abstract operator $A(t)$ based on the `data` the\n        propagator was initialized with, and calculate\n\n        .. math::\n\n            v_\\text{out} = f(A(t)\\,dt) \\, v_\\text{in}\n\n        where $v_\\text{in}$ is the current :attr:`state`, and $f$ is the\n        function specified by `func` during initialization.\n\n        The state $v_\\text{out}$ becomes $v_\\text{in}$ for the next call to\n        :meth:`step`. The time parameter `t` should generally be the midpoint\n        of the interval covered by $dt$.\n\n        The results of the propagation step may be read from :attr:`state`. The\n        :meth:`step` method does not return anything.\n        """"""\n        A = self._A(t)\n        self._v = _step(\n            A,\n            self._v,\n            dt,\n            self.func,\n            m_max=self.m_max,\n            maxrestart=self.maxrestart,\n            tol=self.tol,\n            inner=self._inner,\n            norm=self._norm,\n            zero=self._zero,\n        )\n\n    # subclasses should customize the behavior primarily by overriding the\n    # following private methods:\n\n    def _check(self):  # pragma: nocover\n        """"""Check completeness and consistency of attributes\n\n        After :meth:`set_initial_state`, check that all attributes are defined\n        and are consistent. If not, raise an :exc:`AttributeError`.\n        """"""\n        try:\n            N = np.prod(self._v.shape)\n            if self.m_max >= N:\n                raise ValueError(\n                    ""m_max must be smaller than the system dimension""\n                )\n        except AttributeError:\n            pass\n\n    def _convert_state_to_internal(self, v):  # pragma: nocover\n        """"""Convert the initial state `v` into a more efficient internal format.\n\n        This is used when setting :attr:`_v` from the `v` given in\n        :meth:`set_initial_state`. By default, the state is passed on\n        unchanged.\n        """"""\n        return v\n\n    def _convert_state_from_internal(self, v):  # pragma: nocover\n        """"""Convert `v` in internal format of :attr:`_v` to original format\n\n        If :attr:`_v` uses an internal format different from the `v` in\n        :meth:`set_initial_state`, this method must be overridden to convert\n        :attr:`_v` back to the original format. It is used by :attr:`state` for\n        this purpose. By default, the internal state is passed on unchanged.\n        """"""\n        return v\n\n    @staticmethod\n    def _convert_data_to_internal(data):  # pragma: nocover\n        """"""Convert `data` to :attr:`_data`\n\n        Optional conversion of the `data` passed to the initializer to a more\n        efficient internal format.  By default, the `data` is stored unchanged.\n        """"""\n        return data\n\n    @abstractmethod\n    def _inner(self, a, b):  # pragma: nocover\n        """"""Inner product between two states `a`, `b` in the format of\n        :attr:`_v`\n\n        Must return a complex number. This is an abstract method, and thus must\n        be implemented by any subclass of :class:`NewtonPropagatorBase`.\n\n        An example implementation is::\n\n            def _inner(self, a, b):\n                return numpy.vdot(a, b)\n        """"""\n        pass\n\n    @abstractmethod\n    def _norm(self, a):  # pragma: nocover\n        """"""Norm of a state `a` in the format of :attr:`_v`\n\n        Must return a complex number. This is an abstract method, and thus must\n        be implemented by any subclass of :class:`NewtonPropagatorBase`.\n\n        An example implementation is::\n\n            def _norm(self, a):\n                return numpy.linalg.norm(a)\n        """"""\n        pass\n\n    @abstractmethod\n    def _zero(self, a):  # pragma: nocover\n        """"""A new zero-state compatible with the format of :attr:`_v`\n\n        Must allocate and return a new state in the same internal format as\n        :attr:`_v`, but containing zeros, so that the state can set in-place.\n        This is an abstract method, and thus must be implemented by any\n        subclass of :class:`NewtonPropagatorBase`.\n\n        An example implementation is::\n\n            def _zero(self, a):\n                return numpy.zeros(shape=a.shape, dtype=a.dtype)\n        """"""\n        pass\n\n    @abstractmethod\n    def _A(self, t):  # pragma: nocover\n        """"""Callable ``A(v)`` encoding the abstract operator $A(t)$.\n\n        Must return a callable ``A(v)`` that takes a state `v` in the\n        internal format of :attr:`_v` and returns a state in the same format.\n        This is an abstract method, and thus must be implemented by any\n        subclass of :class:`NewtonPropagatorBase`.\n\n        Assuming ``self._data`` contains a nested list ``[L0, [L1, eps]]``\n        where ``L0`` and ``L1`` are numpy matrices containing a superoperator,\n        and ``eps`` is a callable with argument `t` for a time-dependent\n        control, an example implementation is::\n\n            def _A(self, t):\n                Lmatrix = (\n                    self._data[0] + self._data[1][0] + self._data[1][1](t))\n\n                def L(v):\n                    return Lmatrix @ v\n\n                return L\n\n        .. Note::\n\n            This method does not calculate ``A(v)`` directly, but returns a\n            callable that does. This is to take into account time-dependent\n            operators, which :func:`newtonprop.propagator.step` does not know\n            anything about.\n        """"""\n        pass\n'"
src/newtonprop/propagator.py,29,"b'""""""Newton Propagator""""""\nimport logging\nimport numpy as np\n\ntry:\n\n    from numba import jit\n    # the the user-supplied `A` is efficient (runs in compiled code), some\n    # parts of the Newton algorithm (especially _extend_leja) can become\n    # signficant. In this case, compiling those parts of the Newton propagation\n    # with number can get something like an extra factor 4 in speed.\n\nexcept ImportError:  # pragma: nocover\n\n    def jit(*args, **kwargs):\n\n        def _noop_decorator(func):\n            return func\n\n        return _noop_decorator\n\n\n__all__ = [""step""]\n\n\ndef _arnoldi(A, dt, v0, m_max, inner=np.vdot, norm=np.linalg.norm):\n    """"""Calculate the (extended) Hessenberg matrix of an operator A(t) and\n    return it together with the  m+1 (m <= m_max) Arnoldi vectors\n    (orthonormlized Krylov vectors).  Also return the combined Ritz values (all\n    eigenvalues of the Hessenberg matrices of size 1..m )\n\n    Args\n        A (callable): Function encoding the operator A. Calling `A(v0)`\n            must return the result of applying A to v0.\n        dt (float): Time step\n        v0: Initial state\n        m_max (int): Maximal Krylov dimension\n        inner (callable): Function that evaluates an inner product. Must take\n            two arguments of the type of `v0` and return a complex number. If\n            None, defaults to :func:`numpy.vdot`.\n        norm (callable): Function that calculates the norm of a state. Must\n            take one argument of the type of `v0` and return a real number. If\n            None, defaults to :func:`numpy.linalg.norm`.\n    """"""\n    m = m_max\n\n    # Hessenberg matrix (at maximum size)\n    Hess = np.matrix(\n        np.zeros(shape=(m_max + 1, m_max + 1), dtype=np.complex128)\n    )\n\n    # Eigenvalues of all Hess\n    Ritz = []\n\n    arnoldi_vecs = []\n\n    beta = norm(v0)\n    if abs(beta - 1.0) > 1.0e-10:\n        print(""beta = "", beta)\n        raise AssertionError(\n            ""v0 must have norm 1.0. Mismatch between `inner` and `norm`?""\n        )\n    v = v0 / beta\n    arnoldi_vecs.append(v)\n    for j in range(m):\n        v = A(v)  # v_{j+1}\n        for i, v_i in enumerate(arnoldi_vecs):\n            Hess[i, j] = dt * inner(v_i, v)\n            v = v - (Hess[i, j] / dt) * v_i\n        # At this point, we have finished the (j+1) x (j+1) Hessenberg matrix\n        Ritz.extend(np.linalg.eigvals(Hess[: j + 1, : j + 1]))\n        h_next = norm(v)\n        Hess[j + 1, j] = h_next * dt\n        if h_next <= 1.0e-14:  # abort early at convergence\n            m = j\n            break\n        v *= 1 / h_next  # normalize\n        arnoldi_vecs.append(v)\n    # At this point, arnoldi_vecs contains m+1 elements\n    Ritz = np.array(Ritz, dtype=np.complex128)\n    return arnoldi_vecs, Hess[: m + 1, : m + 1], Ritz, m\n\n\ndef _normalize_points(z):\n    """"""Given a set of complex points z, return the normalization radius""""""\n    r = 0.0\n    for z_i in z:\n        r_i = abs(z_i)\n        if r_i > r:\n            r = r_i\n    # we need to enlarge the radius a little bit to account for points that\n    # will be added in later iterations\n    r *= 1.2  # arbitary factor\n    assert r > 0.0, ""Radius is zero""\n    return r\n\n\n@jit(nopython=True)\ndef _expmi(x):\n    return np.exp(-1j * x)\n\n\n@jit(nopython=True)\ndef _expi(x):\n    return np.exp(1j * x)\n\n\n@jit(nopython=True)\ndef _exp(x):\n    return np.exp(x)\n\n\n@jit()\ndef _extend_newton_coeffs(func, old_a, new_leja, center, radius):\n    """"""Extend a set of Newton coefficients, by using a set of new_leja points\n    which are normalized with the given center and radius\n    """"""\n    n_old = len(old_a)\n    m = len(new_leja) - n_old\n    a = np.zeros(n_old + m, dtype=np.complex128)\n    a[:n_old] = old_a\n    n0 = n_old\n\n    if n_old == 0:\n        a[0] = func(new_leja[0])\n        n0 = 1\n\n    for k in range(n0, n_old + m):\n        d = 1.0\n        pn = 0.0\n        for n in range(1, k):  # 1..k-1\n            zd = new_leja[k] - new_leja[n - 1]\n            d *= zd / radius\n            pn += a[n] * d\n        zd = new_leja[k] - new_leja[k - 1]\n        d *= zd / radius\n        assert abs(d) > 1.0e-200, ""Divided differences too small""\n        a[k] = (func(new_leja[k]) - a[0] - pn) / d\n    return a\n\n\n@jit(nopython=True)\ndef _extend_leja(old_leja, new_points, n_use):\n    """"""Given a set of normalized (ordered) Leja points, extract `n_use` points\n    from the (normalized) new_points, and append them to the set of leja points\n    """"""\n    n_old = len(old_leja)\n    new_leja = np.zeros(n_old + n_use, dtype=np.complex128)\n    new_leja[:n_old] = old_leja[:]\n    i_add_start = 0\n    if n_old == 0:\n        # At the very beginning, start with the point that has largest absolute\n        # value\n        for i in range(len(new_points) - 1):  # 0 .. n_old - 2\n            if abs(new_points[i]) > abs(new_points[-1]):\n                temp = new_points[i]\n                new_points[i] = new_points[-1]\n                new_points[-1] = temp\n        new_leja[0] = new_points[-1]\n        i_add_start = 1\n    # find the best point for new_leja[n_old+n]\n    n_added = i_add_start\n    ex = 1.0 / (n_old + n_use)\n    for i_add in range(i_add_start, n_use):\n        p_max = 0.0\n        i_max = 0\n        # the new leja are defined with index  0 .. (n_old-1)+n\n        # the new candidates are defined with index 0 .. len(new_points)-1+n\n        for i in range(len(new_points) - i_add):  # trial points (candidates)\n            p = 1.0\n            for j in range(n_old + i_add):  # existing leja points\n                p *= np.abs(new_points[i] - new_leja[j]) ** ex\n            # at this point p is the divided difference denominator for the\n            # candidate with index i\n            if p > p_max:\n                p_max = p\n                i_max = i\n        # XXX if p_max below limit: abort\n        new_leja[n_old + i_add] = new_points[i_max]\n        n_added += 1\n        # remove the used point by moving in the last point\n        new_points[i_max] = new_points[len(new_points) - 1 - i_add]\n    return new_leja, n_added\n\n\ndef step(\n    A,\n    v,\n    dt,\n    func=\'exp\',\n    m_max=10,\n    maxrestart=100,\n    tol=1e-12,\n    inner=None,\n    norm=None,\n    zero=None,\n):\n    r""""""Evaluate $f(A\\,dt)\\,v$, for example $e^{-i\\,A\\,dt}\\,v$ for the\n    propagation of a quantum state.\n\n    Applies the result of an arbitrary abstract operator function $f(A\\,dt)$ to\n    an abstract state $v$, where $A$ is an abstract operator and $dt$ is a\n    scalar factor. The intended application is computing a single time step\n    $dt$ of the time evolution of a quantum state, where the form of the time\n    evolution operator/dynamical map is $e^{-i\\,A\\,dt}$. If $v$ is a Hilbert\n    space state, $A$ is the system Hamiltonian (constant over the duration\n    :math:`dt`). If $v$ is a density matrix, $A = i \\Liouville$ with the\n    Liouvillian super-operator $\\Liouville$.\n\n    The operator $f(A\\,dt)$ is never explicitly constructed, only its\n    application to $v$ is calculated. This distinguishes the Newton propagator\n    from functions like :func:`scipy.linalg.expm` for matrix exponentiation.\n    Internally, it uses an iterative restarted Krylov projection of $(A\\,dt)$,\n    where the Krylov dimension in each iteration is `m_max`. Consequently,\n    storage for only `m_max` Arnoldi-vectors of the same size as `v` is\n    required.\n\n    Args:\n        A (callable): Function encoding the abstract operator $A$. Calling\n            ``A(v)`` must return the result of applying $A$ to $v$.\n        v: Initial state $v$.\n        dt (float): scalar parameter (time step :math:`dt`)\n        func (callable or str): The scalar version of the operator-function\n            $f$.  Must take one complex argument and return a\n            complex value. Note that `func` will only ever be called with a\n            scalar argument, not with the argument $(A\\,dt)$.\n            If passed as a string, `func` may have the following values,\n            corresponding to ""standard"" functions:\n\n            * ``\'exp\'``: ``lambda x: np.exp(x)``\n            * ``\'expmi\'``: ``lambda x: np.exp(-1j * x)``\n            * ``\'expi\'``: ``lambda x: np.exp(1j * x)``\n\n        m_max (int): Maximal Krylov dimension\n        maxrestart (int): Maximal number of Newton restarts (iterations of the\n            algorithm)\n        tol (float): Desired precision of the result\n        inner (callable): Function that evaluates an inner product. Must take\n            two arguments of the type of `v0` and return a complex number. If\n            None, defaults to :func:`numpy.vdot`.\n        norm (callable): Function that calculates the norm of a state. Must\n            take one argument of the type of `v0` and return a real number. If\n            None, defaults to :func:`numpy.linalg.norm`. The norm must be\n            induced by the inner product specified by `inner`.\n        zero (callable): Function that takes `v` as input and allocates and\n            returns a new zero state of the same type and shape as `v`.\n            If None, defaults to\n            ``lambda v: numpy.zeros(shape=v.shape, dtype=v.dtype)``\n\n    Returns:\n        The result of the operator-function $f(A\\,dt)$ applied to $v$.\n        The return value will be of the same type as the input `v`.\n\n    .. Note::\n\n        The input `state` may be of any array-like type. It should have (but is\n        not strictly required to have) a `shape` attribute. It must support\n        being multiplied or divided by a scalar, e.g. ``state / 2.0`` or\n        ``2 * state``. Lastly, it must support in-place addition with another\n        state, ``state += state2``.  All other mathematical properties of\n        `state` can be defined via custom `inner`, `norm`, and `zero`\n        functions.\n\n        Mathematically, `state` must be an element a Hilbert space (a ""complete\n        inner product space""). This includes density matrices, which can be\n        interpreted as elements of a Hilbert space provided one chooses an\n        appropriate norm and inner product.\n\n    .. Warning::\n\n        The norm *must* be the one induced by the inner product,\n\n        .. math::\n\n            \\Norm{v} \\equiv \\sqrt{\\Braket{v}{v}}\n\n        The parameters `inner` and `norm` must fulfill this definition.\n        For density matrices, they should be the Hilbert-Schmidt product and\n        the Hilbert-Schmidt norm. The ""operator norm"" has no associated inner\n        product. If the operator norm is used, density matrices are not\n        elements of a Hilbert space, but of a C* algebra, which would not allow\n        for the evaluation of the propagator.\n\n        A mismatch between `norm` and `inner` leads to subtle errors that will\n        not be obvious (e.g., a substantial lack of precision)\n    """"""\n    if inner is None:\n        inner = np.vdot\n        if norm is None:\n            norm = np.linalg.norm\n    else:\n        if norm is None:\n            norm = lambda v: np.sqrt(np.abs(inner(v, v)))\n    if zero is None:\n        zero = lambda v: np.zeros(shape=v.shape, dtype=v.dtype)\n    funcs = {\n        \'exp\': _exp,\n        \'expmi\': _expmi,\n        \'expi\': _expi,\n    }\n    if isinstance(func, str):\n        func = funcs[func]\n\n    try:\n        N = np.prod(v.shape)\n        if m_max >= N:\n            raise ValueError(""m_max must be smaller than the system dimension"")\n    except AttributeError:\n        pass\n\n    return _step(A, v, dt, func, m_max, maxrestart, tol, inner, norm, zero)\n\n\ndef _step(A, v, dt, func, m_max, maxrestart, tol, inner, norm, zero):\n    logger = logging.getLogger(""newton"")\n\n    w = zero(v)  # result vector\n    Z = np.zeros(0, dtype=np.complex128)  # Leja points\n    a = np.zeros(0, dtype=np.complex128)  # Newton coeffs\n\n    beta = norm(v)\n    v = v / beta\n\n    for s in range(maxrestart):\n\n        arnoldi_vecs, Hess, Ritz, m = _arnoldi(\n            A, dt, v, m_max, inner=inner, norm=norm\n        )\n        if m < m_max:\n            logger.warn(\n                ""Arnoldi only returned order %d instead of the ""\n                ""requested %d"",\n                m,\n                m_max,\n            )\n        if m == 0 and s == 0:\n            # The input state appears to be an eigenstate\n            eig_val = beta * Hess[0, 0]\n            phase = func(eig_val)  # dt is absorbed in eig_val\n            w = phase * v\n            break\n\n        # normalize Ritz points\n        if s == 0:\n            radius = _normalize_points(Ritz)\n            center = 0.0\n        assert radius > 0.0, ""Radius is zero""\n\n        # get Leja points (i.e. Ritz points in the proper order)\n        n_s = len(Z)\n        Z, m = _extend_leja(Z, Ritz, m)  # Z now contains m new Leja points\n        assert m > 0, ""No new Leja points""\n        a = _extend_newton_coeffs(func, a, Z, center, radius)\n\n        R = np.matrix(np.zeros(shape=(m + 1, 1), dtype=np.complex128))\n        R[0, 0] = beta\n        P = a[n_s] * R\n        for k in range(1, m):  # 1..m-1\n            R = (np.dot(Hess, R) - Z[n_s + k - 1] * R) / radius\n            P += a[n_s + k] * R\n\n        wp = zero(v)\n        for i in range(m):  # 0 .. m-1\n            wp += P[i, 0] * arnoldi_vecs[i]\n\n        w += wp\n\n        # starting vector for next iteration\n        R = (np.dot(Hess, R) - Z[n_s + m - 1] * R) / radius\n        beta = np.linalg.norm(R)\n        R /= beta\n        # beta would be the norm of v, with the above normalization, v will now\n        # be normalized\n        v = zero(v)\n        for i in range(m + 1):  # 0 .. m\n            v += R[i, 0] * arnoldi_vecs[i]\n\n        if beta * abs(a[-1]) / (1 + norm(w)) < tol:\n            if logger.isEnabledFor(logging.DEBUG):  # pragma: nocover\n                logger.debug(""Converged at restart %s"", s)\n                logger.debug(""norm of wp     : %s"", norm(wp))\n                logger.debug(""norm of w      : %s"", norm(w))\n                logger.debug(""beta           : %s"", beta)\n                logger.debug(\n                    ""|R*a[-1]|/|w|  : %s"", np.linalg.norm(R) * a[-1] / norm(w)\n                )\n                logger.debug(""max Leja radius: %s"", np.max(np.abs(Z)))\n            break\n\n        try:\n            assert not np.isnan(np.sum(v)), ""v contains NaN""\n            assert not np.isnan(np.sum(w)), ""w contains NaN""\n        except (AttributeError, TypeError):\n            pass\n\n        if s == maxrestart - 1:  # pragma: nocover\n            logger.warn(""DID NOT REACH CONVERGENCE"")\n            logger.warn(""increase number of restarts"")\n\n    return w\n'"
