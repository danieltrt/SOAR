file_path,api_count,code
findNeighbours/section1.py,1,"b'import numpy as np\r\nimport cv2\r\nnp.set_printoptions(threshold=np.nan)\r\n## The readImage function takes a file path as argument and returns image in binary form.\r\ndef readImage(filePath):\r\n    #############  Add your Code here   ###############\r\n    img = cv2.imread(filePath, 0)\r\n    ret, binaryImage = cv2.threshold(img, 10, 255, cv2.THRESH_BINARY)\r\n    ###################################################\r\n    return binaryImage\r\n\r\n## The findNeighbours function takes a maze image and row and column coordinates of a cell as input arguments\r\n## and returns a stack consisting of all the neighbours of the cell as output.\r\n## Note :- Neighbour refers to all the adjacent cells one can traverse to from that cell provided only horizontal\r\n## and vertical traversal is allowed.\r\ndef findNeighbours(img,row,column):\r\n    neighbours = []\r\n    #############  Add your Code here   ###############\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i \r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    if img[top, col_new] != 0:\r\n        neighbours.append([row - 1, column])\r\n    if img[bottom, col_new] != 0:\r\n        neighbours.append([row + 1, column])\r\n    if img[row_new, left] != 0:\r\n        neighbours.append([row, column - 1])\r\n    if img[row_new, right] != 0:\r\n        neighbours.append([row, column + 1])\r\n    ###################################################\r\n    return neighbours\r\n\r\n##  colourCell function takes 4 arguments:-\r\n##            img - input image\r\n##            row - row coordinates of cell to be coloured\r\n##            column - column coordinates of cell to be coloured\r\n##            colourVal - the intensity of the colour.\r\n##  colourCell basically highlights the given cell by painting it with the given colourVal. Care should be taken that\r\n##  the function doesn\'t paint over the black walls and only paints the empty spaces. This function returns the image\r\n##  with the painted cell.\r\ndef colourCell(img, row, column, colorVal):   ## Add required arguments here.\r\n    \r\n    #############  Add your Code here   ###############\r\n    neighbours = findNeighbours(img, row, column)\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i\r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    for i in neighbours:\r\n        if i[0] == row + 1:\r\n            img[top + 1 : bottom + 2, left + 1 : right] = colorVal\r\n        if i[0] == row - 1:\r\n            img[top - 1 : bottom, left + 1 : right] = colorVal\r\n        if i[1] == column + 1:\r\n            img[top + 1 : bottom, left + 1 : right + 2] = colorVal\r\n        if i[1] == column - 1:\r\n            img[top + 1 : bottom, left - 1 : right] = colorVal\r\n    \r\n    ###################################################\r\n    return img\r\n\r\n##  Main function takes the filepath of image as input.\r\n##  You are not allowed to change any code in this function.\r\ndef main(filePath):\r\n    img = readImage(filePath)\r\n    coords = [(0,0),(9,9),(3,2),(4,7),(8,6)]\r\n    string = """"\r\n    for coordinate in coords:\r\n        img = colourCell(img, coordinate[0], coordinate[1], 150)\r\n        neighbours = findNeighbours(img, coordinate[0], coordinate[1])\r\n        print (neighbours)\r\n        string = string + str(neighbours) + ""\\n""\r\n        for k in neighbours:\r\n            img = colourCell(img, k[0], k[1], 230)\r\n    if __name__ == \'__main__\':\r\n        return img\r\n    else:\r\n        return string + ""\\t""\r\n## Specify filepath of image here. The main function is called in this section.\r\nif __name__ == \'__main__\':\r\n    filePath = \'maze00.jpg\'\r\n    img = main(filePath)\r\n    cv2.imshow(\'canvas\', img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n'"
mazeSolve-checkpoints/section3.py,0,"b'import numpy as np\r\nimport cv2\r\n\r\n## Reads image in HSV format. Accepts filepath as input argument and returns the HSV\r\n## equivalent of the image.\r\ndef readImageHSV(filePath):\r\n    #############  Add your Code here   ###############\r\n    img = cv2.imread(filePath)\r\n    hsvImg = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\r\n    ###################################################\r\n    return hsvImg\r\n\r\n## Reads image in binary format. Accepts filepath as input argument and returns the binary\r\n## equivalent of the image.\r\ndef readImageBinary(filePath):\r\n    #############  Add your Code here   ###############\r\n    img = cv2.imread(filePath, 0)\r\n    ret, binaryImage = cv2.threshold(img, 10, 255, cv2.THRESH_BINARY)\r\n    ###################################################\r\n    return binaryImage\r\n\r\n## The findNeighbours function takes a maze image and row and column coordinates of a cell as input arguments\r\n## and returns a stack consisting of all the neighbours of the cell as output.\r\n## Note :- Neighbour refers to all the adjacent cells one can traverse to from that cell provided only horizontal\r\n## and vertical traversal is allowed.\r\ndef findNeighbours(img,row,column):\r\n    neighbours = []\r\n    #############  Add your Code here   ###############\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i \r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    if img[top, col_new] != 0:\r\n        neighbours.append([row - 1, column])\r\n    if img[bottom, col_new] != 0:\r\n        neighbours.append([row + 1, column])\r\n    if img[row_new, left] != 0:\r\n        neighbours.append([row, column - 1])\r\n    if img[row_new, right] != 0:\r\n        neighbours.append([row, column + 1])\r\n    ###################################################\r\n    return neighbours\r\n\r\n##  colourCell basically highlights the given cell by painting it with the given colourVal. Care should be taken that\r\n##  the function doesn\'t paint over the black walls and only paints the empty spaces. This function returns the image\r\n##  with the painted cell.\r\n##  You can change the colourCell() functions used in the previous sections to suit your requirements.\r\n\r\ndef colourCell(img, row, column, flag):   ## Add required arguments here.\r\n    \r\n    #############  Add your Code here   ###############\r\n    neighbours = findNeighbours(img, row, column)\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i\r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    for i in neighbours:\r\n        if i[0] == row + 1:\r\n            img[top + 1 : bottom + 2, left + 1 : right] = 150\r\n        if i[0] == row - 1:\r\n            img[top - 1 : bottom, left + 1 : right] = 150\r\n        if i[1] == column + 1:\r\n            img[top + 1 : bottom, left + 1 : right + 2] = 150\r\n        if i[1] == column - 1:\r\n            img[top + 1 : bottom, left - 1 : right] = 150\r\n    if flag == 1:\r\n        img[top + 5 : bottom - 4, left + 5 : right - 4] = 0\r\n    ###################################################\r\n    return img\r\n\r\n##  Function that accepts some arguments from user and returns the graph of the maze image.\r\ndef buildGraph(img):  ## You can pass your own arguments in this space.\r\n    graph = {}\r\n    #############  Add your Code here   ###############\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i \r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    r = len(img) / cell\r\n    c = len(img) / cell\r\n    for i in range(r):\r\n        for j in range(c):\r\n            graph[(i, j)] = findNeighbours(img, i, j)\r\n    ###################################################\r\n    return graph\r\n\r\n#####################################    Add Utility Functions Here   ###################################\r\n##                                                                                                     ##\r\n##                   You are free to define any functions you want in this space.                      ##\r\n##                             The functions should be properly explained.                             ##\r\nclass Link():\r\n    value = 0\r\n    parent = 0\r\n    def __init__(self, a, b):\r\n        self.value = a\r\n        self.parent = b\r\n        \r\ndef next_num():                                     ##This is a sequence for assigning numbers to the cells in recursive function \r\n    del x[0]\r\n    return x[0]\r\n\r\ndef numberMaze(graph, initial, new, l):             ##This assigns numbers to the cells based on a certain algorithm that we have used\r\n    empty = 0                                       ##Starting from the first cell, the cells are assigned number 1 and everytime a branching occurs the next cells are assigned the next numbers, and if branhing does not occur the same number is continuosly assigned.\r\n    lar = 0                                         ##Them using class. we create links between these numbers, and to find shortest path between cells, we just traverse those certain numbers that we have assigned. suppose 1->3->5->8 are the links created, then to go from 1 to 8, we traverse all cells from 1 to 3 to 5 to the final cell in 8\r\n    for k in graph[initial]:\r\n        if new[tuple(k)] == -1:\r\n            empty += 1\r\n    if empty == 0:\r\n        return\r\n    elif empty == 1:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                new[tuple(graph[initial][i])] = new[initial] \r\n                numberMaze(graph, tuple(graph[initial][i]), new, l) \r\n    else:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                n = next_num()\r\n                new[tuple(graph[initial][i])] = n\r\n                l.append(Link(n, new[initial]))\r\n                numberMaze(graph, tuple(graph[initial][i]), new, l)\r\n\r\ndef shortestNumberedPath(l, initial, final, path):      ##This function is required to find the shortest path\r\n    if final == initial:                                ##It acquires the required sequence of links that had been developed using the algorith, explained above and returns it to the required function \r\n        return\r\n    else:\r\n        for i in l:\r\n            if i.value == final:\r\n                parent = i.parent\r\n                break\r\n        path.append(parent)\r\n        shortestNumberedPath(l, initial, parent, path)\r\n\r\ndef OptimumPath(markers, initial, final, filePath):         ##This function checks the length of all the possible paths and assigns the shortest path length and returns that path as the final shortest optimum path\r\n    shortest = range(5000)\r\n    img = readImageBinary(filePath)\r\n    graph = buildGraph(img)\r\n    if len(markers) == 0:\r\n        shortest = findPath(graph, initial, final, img)\r\n        optimumPath.append(shortest)\r\n        return\r\n    for k in markers:\r\n        path = findPath(graph, initial, k, img)\r\n        if len(path) < len(shortest):\r\n            shortest = path\r\n            marker = k\r\n    markers.remove(marker)\r\n    optimumPath.append(shortest)\r\n    OptimumPath(markers, marker, final, filePath)\r\n##                                                                                                     ##\r\n##                                                                                                     ##\r\n#########################################################################################################\r\n\r\n\r\n##  Finds shortest path between two coordinates in the maze. Returns a set of coordinates from initial point\r\n##  to final point.\r\ndef findPath(graph, initial, final, img): ## You can pass your own arguments in this space.\r\n    #############  Add your Code here   ###############\r\n    shortest = [initial]\r\n    visited = [initial]\r\n    count = 1\r\n    global path\r\n    path = []\r\n    global new\r\n    new = {}\r\n    global l\r\n    l = []\r\n    graph = buildGraph(img)\r\n    for k in graph.keys():\r\n        new[k] = -1\r\n    new[initial] = 1\r\n    global x\r\n    x = range(1, 1000)\r\n    numberMaze(graph, initial, new, l)\r\n    path.append(new[final])\r\n    shortestNumberedPath(l, new[initial], new[final], path)\r\n    path.reverse()\r\n    current = initial\r\n    while(True):\r\n        if current == final:\r\n            return shortest\r\n        for j in graph[current]:\r\n            if not tuple(j) in visited:\r\n                if new[tuple(j)] == new[current]:\r\n                    current = tuple(j)\r\n                    shortest.append(current)\r\n                    visited.append(current)\r\n                    break\r\n                else:\r\n                    if new[tuple(j)] == path[count]:\r\n                        count += 1\r\n                        shortest.append(tuple(j))\r\n                        current = tuple(j)\r\n                        visited.append(current)\r\n                        break\r\n    ###################################################\r\n                    \r\n\r\n## The findMarkers() function returns a list of coloured markers in form of a python dictionaries\r\n## For example if a blue marker is present at (3,6) and red marker is present at (1,5) then the\r\n## dictionary is returned as :-\r\n##          list_of_markers = { \'Blue\':(3,6), \'Red\':(1,5)}\r\n\r\ndef findMarkers(filepath):    ## You can pass your own arguments in this space.\r\n    list_of_markers = {}\r\n    #############  Add your Code here   ###############\r\n    i = 10\r\n    img = cv2.imread(filepath)\r\n    while i < len(img):\r\n        j = 10\r\n        while j < len(img[0]):\r\n            pixel = img[i, j]\r\n            if pixel[0] < 10 and pixel[1] < 10:\r\n                list_of_markers[\'Red\'] = ((i-10)/20, (j-10)/20)\r\n            if pixel[0] < 10 and pixel[2] < 10:\r\n                list_of_markers[\'Green\'] = ((i-10)/20, (j-10)/20)\r\n            if pixel[1] < 10 and pixel[2] < 10:\r\n                list_of_markers[\'Blue\'] = ((i-10)/20, (j-10)/20)\r\n            if pixel[0] > 240 and pixel[1] < 10 and pixel[2] > 240:\r\n                list_of_markers[\'Pink\'] = ((i-10)/20, (j-10)/20)\r\n            j += 20\r\n        i += 20\r\n    ###################################################\r\n    return list_of_markers\r\n\r\n## The findOptimumPath() function returns a python list which consists of all paths that need to be traversed\r\n## in order to start from the bottom left corner of the maze, collect all the markers by traversing to them and\r\n## then traverse to the top right corner of the maze.\r\n\r\ndef findOptimumPath(markers, initial, final, filePath):     ## You can pass your own arguments in this space.\r\n    path_array = []\r\n    #############  Add your Code here   ###############\r\n    global optimumPath\r\n    optimumPath = []\r\n    OptimumPath(markers, initial, final, filePath)\r\n    path_array = optimumPath\r\n    ###################################################\r\n    return path_array\r\n        \r\n## The colourPath() function highlights the whole path that needs to be traversed in the maze image and\r\n## returns the final image.\r\n\r\ndef colourPath(img, path, markers):      ## You can pass your own arguments in this space. \r\n    #############  Add your Code here   ###############\r\n    for i in path:\r\n        for j in i:\r\n            if j in markers:\r\n                flag = 1\r\n            else:\r\n                flag = 0\r\n            img = colourCell(img, j[0], j[1], flag)\r\n\r\n    ###################################################\r\n    return img\r\n\r\n\r\n## This is the main() function for the code, you are not allowed to change any statements in this part of\r\n## the code. You are only allowed to change the arguments supplied in the findMarkers(), findOptimumPath()\r\n## and colourPath() functions.\r\n\r\ndef main(filePath, flag = 0):\r\n    imgHSV = readImageHSV(filePath)                ## Acquire HSV equivalent of image.\r\n    listOfMarkers = findMarkers(filePath)              ## Acquire the list of markers with their coordinates. \r\n    test = str(listOfMarkers)\r\n    imgBinary = readImageBinary(filePath)          ## Acquire the binary equivalent of image.\r\n    initial_point = ((len(imgBinary)/20)-1,0)      ## Bottom Left Corner Cell\r\n    final_point = (0, (len(imgBinary[0])/20) - 1)  ## Top Right Corner Cell\r\n    pathArray = findOptimumPath(listOfMarkers.values(), initial_point, final_point, filePath) ## Acquire the list of paths for optimum traversal.\r\n    print pathArray\r\n    img = colourPath(imgBinary, pathArray, listOfMarkers.values())         ## Highlight the whole optimum path in the maze image\r\n    if __name__ == ""__main__"":                    \r\n        return img\r\n    else:\r\n        if flag == 0:\r\n            return pathArray\r\n        elif flag == 1:\r\n            return test + ""\\n""\r\n        else:\r\n            return img\r\n## Modify the filepath in this section to test your solution for different maze images.           \r\nif __name__ == ""__main__"":\r\n    filePath = ""maze00.jpg""                        ## Insert filepath of image here\r\n    img = main(filePath)                 \r\n    cv2.imshow(""canvas"", img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n\r\n'"
mazeSolve/section2.py,0,"b'import numpy as np\r\nimport cv2\r\n\r\nclass Link():\r\n    value = 0\r\n    parent = 0\r\n    def __init__(self, a, b):\r\n        self.value = a\r\n        self.parent = b\r\n## The readImage function takes a file path as argument and returns image in binary form.\r\n## You can copy the code you wrote for section1.py here.\r\ndef readImage(filePath):\r\n    #############  Add your Code here   ###############\r\n    img = cv2.imread(filePath, 0)\r\n    ret, binaryImage = cv2.threshold(img, 10, 255, cv2.THRESH_BINARY)\r\n    ###################################################\r\n    return binaryImage\r\n\r\n## The findNeighbours function takes a maze image and row and column coordinates of a cell as input arguments\r\n## and returns a stack consisting of all the neighbours of the cell as output.\r\n## Note :- Neighbour refers to all the adjacent cells one can traverse to from that cell provided only horizontal\r\n## and vertical traversal is allowed.\r\n## You can copy the code you wrote for section1.py here.\r\ndef findNeighbours(img,row,column):\r\n    neighbours = []\r\n    #############  Add your Code here   ###############\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i \r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    if img[top, col_new] != 0:\r\n        neighbours.append([row - 1, column])\r\n    if img[bottom, col_new] != 0:\r\n        neighbours.append([row + 1, column])\r\n    if img[row_new, left] != 0:\r\n        neighbours.append([row, column - 1])\r\n    if img[row_new, right] != 0:\r\n        neighbours.append([row, column + 1])\r\n    ###################################################\r\n    return neighbours\r\n\r\n##  colourCell function takes 4 arguments:-\r\n##            img - input image\r\n##            row - row coordinates of cell to be coloured\r\n##            column - column coordinates of cell to be coloured\r\n##            colourVal - the intensity of the colour.\r\n##  colourCell basically highlights the given cell by painting it with the given colourVal. Care should be taken that\r\n##  the function doesn\'t paint over the black walls and only paints the empty spaces. This function returns the image\r\n##  with the painted cell.\r\n##  You can copy the code you wrote for section1.py here.\r\ndef colourCell(img, row, column, flag):   ## Add required arguments here.\r\n    \r\n    #############  Add your Code here   ###############\r\n    neighbours = findNeighbours(img, row, column)\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i\r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    row_new = (2 * row + 1) * (cell / 2)\r\n    col_new = (2 * column + 1) * (cell / 2)\r\n    top = row_new - (cell / 2) + 1\r\n    bottom = row_new + (cell / 2) - 2\r\n    left = col_new - (cell / 2) + 1\r\n    right = col_new + (cell / 2) - 2\r\n    for i in neighbours:\r\n        if i[0] == row + 1:\r\n            img[top + 1 : bottom + 2, left + 1 : right] = 150\r\n        if i[0] == row - 1:\r\n            img[top - 1 : bottom, left + 1 : right] = 150\r\n        if i[1] == column + 1:\r\n            img[top + 1 : bottom, left + 1 : right + 2] = 150\r\n        if i[1] == column - 1:\r\n            img[top + 1 : bottom, left - 1 : right] = 150\r\n    if flag == 1:\r\n        img[top + 5 : bottom - 4, left + 5 : right - 4] = 0\r\n    ###################################################\r\n    return img\r\n\r\n##  Function that accepts some arguments from user and returns the graph of the maze image.\r\ndef buildGraph(img):  ## You can pass your own arguments in this space.\r\n    graph = {}\r\n    #############  Add your Code here   ###############\r\n    i = 0\r\n    while(True):\r\n        if img[i, i] != 0:\r\n            border = i \r\n            break\r\n        i += 1\r\n    i = border\r\n    cell = 0\r\n    while(True):\r\n        if img[i, i] == 0:\r\n            cell = i \r\n            break\r\n        i += 1\r\n    if img[cell - border * 2, cell] == 0 or img[cell, cell - border * 2] == 0:\r\n        cell = cell + border\r\n    r = len(img) / cell\r\n    c = len(img) / cell\r\n    for i in range(r):\r\n        for j in range(c):\r\n            graph[(i, j)] = findNeighbours(img, i, j)\r\n    ###################################################\r\n\r\n    return graph\r\n\r\ndef next_num():          ##This is a sequence for assigning numbers to the cells in recursive function \r\n    del x[0]\r\n    return x[0]\r\n\r\ndef numberMaze(graph, initial, new, l):         \r\n    empty = 0                                   ##This assigns numbers to the cells based on a certain algorithm that we have used\r\n                                                  ##Starting from the first cell, the cells are assigned number 1 and everytime a branching occurs the next cells are assigned the next numbers, and if branhing does not occur the same number is continuosly assigned.\r\n    lar = 0                                         ##Them using class. we create links between these numbers, and to find shortest path between cells, we just traverse those certain numbers that we have assigned. suppose 1->3->5->8 are the links created, then to go from 1 to 8, we traverse all cells from 1 to 3 to 5 to the final cell in 8\r\n    \r\n    for k in graph[initial]:\r\n        if new[tuple(k)] == -1:\r\n            empty += 1\r\n    if empty == 0:\r\n        return\r\n    elif empty == 1:\r\n        for i in range(len(graph[initial])):        \r\n            if new[tuple(graph[initial][i])] == -1:\r\n                new[tuple(graph[initial][i])] = new[initial] \r\n                numberMaze(graph, tuple(graph[initial][i]), new, l) \r\n    else:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                n = next_num()\r\n                new[tuple(graph[initial][i])] = n\r\n                l.append(Link(n, new[initial]))\r\n                numberMaze(graph, tuple(graph[initial][i]), new, l)\r\n\r\ndef shortestNumberedPath(l, initial, final, path):   ##This function is required to find the shortest path\r\n                                                        ##It acquires the required sequence of links that had been developed using the algorith, explained above and returns it to the required function \r\n    if final == initial:\r\n        return\r\n    else:\r\n        for i in l:\r\n            if i.value == final:\r\n                parent = i.parent\r\n                break\r\n        path.append(parent)\r\n        shortestNumberedPath(l, initial, parent, path)\r\n        \r\n##  Finds shortest path between two coordinates in the maze. Returns a set of coordinates from initial point\r\n##  to final point.\r\ndef findPath(graph, initial, final, img): ## You can pass your own arguments in this space.\r\n    #############  Add your Code here   ###############\r\n    shortest = [initial]\r\n    visited = [initial]\r\n    count = 1\r\n    global path\r\n    path = []\r\n    global new\r\n    new = {}\r\n    global l\r\n    l = []\r\n    breadth = len(img)/20          \r\n    length = len(img[0])/20          \r\n    if length == 10:\r\n        initial = (0,0)      \r\n        final = (9,9)           \r\n    else:\r\n        initial = (0,0)\r\n        final = (19,19)\r\n    graph = buildGraph(img)\r\n    for k in graph.keys():\r\n        new[k] = -1\r\n    new[initial] = 1\r\n    global x\r\n    x = range(1, 1000)\r\n    numberMaze(graph, initial, new, l)\r\n    path.append(new[final])\r\n    shortestNumberedPath(l, new[initial], new[final], path)\r\n    path.reverse()\r\n    current = initial\r\n    while(True):\r\n        if current == final:\r\n            return shortest\r\n        for j in graph[current]:\r\n            if not tuple(j) in visited:\r\n                if new[tuple(j)] == new[current]:\r\n                    current = tuple(j)\r\n                    shortest.append(current)\r\n                    visited.append(current)\r\n                    break\r\n                else:\r\n                    if new[tuple(j)] == path[count]:\r\n                        count += 1\r\n                        shortest.append(tuple(j))\r\n                        current = tuple(j)\r\n                        visited.append(current)\r\n                        break\r\n    ###################################################\r\n\r\n## This is the main function where all other functions are called. It accepts filepath\r\n## of an image as input. You are not allowed to change any code in this function.\r\ndef main(filePath, flag = 0):                 \r\n    img = readImage(filePath)      ## Read image with specified filepath.\r\n    breadth = len(img)/20          ## Breadthwise number of cells\r\n    length = len(img[0])/20           ## Lengthwise number of cells\r\n    if length == 10:\r\n        initial_point = (0,0)      ## Start coordinates for maze solution\r\n        final_point = (9,9)        ## End coordinates for maze solution    \r\n    else:\r\n        initial_point = (0,0)\r\n        final_point = (19,19)\r\n    graph = buildGraph(img)       ## Build graph from maze image. Pass arguments as required.\r\n    shortestPath = findPath(graph, initial_point, final_point, img)  ## Find shortest path. Pass arguments as required.\r\n    print shortestPath             ## Print shortest path to verify\r\n    string = str(shortestPath) + ""\\n""\r\n    for i in shortestPath:         ## Loop to paint the solution path.\r\n        img = colourCell(img, i[0], i[1], 200)\r\n    if __name__ == \'__main__\':     ## Return value for main() function.\r\n        return img\r\n    else:\r\n        if flag == 0:\r\n            return string\r\n        else:\r\n            return graph\r\n\r\n\r\n## The main() function is called here. Specify the filepath of image in the space given.            \r\nif __name__ == \'__main__\':\r\n    filePath = \'maze00.jpg\'        ## File path for test image\r\n    img = readImage(filePath)\r\n    img = main(filePath)           ## Main function call\r\n    cv2.imshow(\'canvas\', img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n\r\n\r\n\r\n\r\n\r\n'"
