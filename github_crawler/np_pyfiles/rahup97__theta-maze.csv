file_path,api_count,code
mazeSolve-checkpoints/section2.py,2,"b'\'\'\'\r\nTeam Id: eYRC-NT#558\r\nAuthor List: Chethan K P, Rahul Patil, Rahul Ramprasad, Rohit Goud \r\nFilename: section2.py\r\nTheme: Navigate a terrain\r\nFunctions:\r\n    sine(angle)\r\n    cosine(angle)\r\n    readImageHSV(filePath)\r\n    readImageBinary(filepath)\r\n    findNeighbours(img, level, cellnum, size)\r\n    colourCell(img, level, cellnum, size, colourVal)\r\n    buildGraph(img, size)\r\n    findStartPoint(img, size)\r\n    findPath(graph, initial, final)\r\n    findMarkers(filePath)\r\n    findOptimumPath(markers, filePath)\r\n    colourPath(img, path, markers)\r\n    next_num()\r\n    numberMaze(graph, initial, new, l)\r\n    shortestNumberedPath(l, initial, final, path)\r\n    main(filePath, flag)\r\nGlobal variables:\r\n    x - list\r\n    path - list\r\n    new - Dictionary\r\n    l - list\r\n\r\n    *explanation of function and variables used in the function is done right before the function is defined*\r\n\'\'\'\r\nimport numpy as np\r\nimport cv2\r\nimport math\r\nimport time\r\n\r\n#Description for this class is given in the numberMaze() function\r\nclass Link():\r\n    value = 0\r\n    parent = 0\r\n    def __init__(self, a, b):\r\n        self.value = a\r\n        self.parent = b\r\n        \r\n## Reads image in HSV format. Accepts filepath as input argument and returns the HSV\r\n## equivalent of the image.\r\ndef readImageHSV(filePath):\r\n    mazeImg = cv2.imread(filePath)\r\n    hsvImg = cv2.cvtColor(mazeImg, cv2.COLOR_BGR2HSV)\r\n    return hsvImg\r\n\r\n## Reads image in binary format. Accepts filepath as input argument and returns the binary\r\n## equivalent of the image.\r\ndef readImageBinary(filePath):\r\n    mazeImg = cv2.imread(filePath)\r\n    grayImg = cv2.cvtColor(mazeImg, cv2.COLOR_BGR2GRAY)\r\n    ret,binaryImage = cv2.threshold(grayImg,200,255,cv2.THRESH_BINARY)\r\n    return binaryImage\r\n\r\n##  Returns sine of an angle.\r\ndef sine(angle):\r\n    return math.sin(math.radians(angle))\r\n\r\n##  Returns cosine of an angle\r\ndef cosine(angle):\r\n    return math.cos(math.radians(angle))\r\n\r\n##  This function accepts the img, level and cell number of a particular cell and the size of the maze as input\r\n##  arguments and returns the list of cells which are traversable from the specified cell.\r\n\'\'\'\r\n    Function name: findNeighbours(img, level, cellnum, size)\r\n    Input:\r\n        img - binary image of the maze which is a numpy array\r\n        size - 1 or 2 based on the number of levles in the image\r\n        level - Level of the cell\r\n        cellnum - cell number for the cell\r\n    Output:\r\n        Returns the traversable neighbours for a given cell (level, cellnum)\r\n    Logic:\r\n        Based on the level and cellnum of the cell, the distance and angle of the cell from the center pixel of the image is found.\r\n        The circularly topmost( or topleft and topright) pixel for that cell is checked for its value. If the pixel is not 0(black) then the corresponding neighbour is appended to the list neighbours[].\r\n        Similarly left right and bottom neighbours are also found.\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        r and angle depend on the level and cellnum for each cell\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n        top, topleft, left, right, bottom - pixel values in terms of indices of the top (or topleft and topright depending on level), left, right and bottom boundary pixels for the cell\r\n        neighbours - list of neighbours for the given cell\r\n    Example call: findNeighbours(img, level, cellnum, size)\r\n\'\'\'\r\ndef findNeighbours(img, level, cellnum, size):\r\n    neighbours = []\r\n    ############################# Add your Code Here ################################\r\n    r = 40 * (level) + 20\r\n    if level == 0 or level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    offset = angle / 2\r\n    if level == 0:\r\n        for cellnum in range(1, 7):\r\n            top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n            if(img[top[0], top[1]] != 0):\r\n                neighbours.append((level + 1, cellnum))\r\n        return neighbours\r\n    if level == 3 or level == 4:\r\n        top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n        if size == 1:\r\n            if(img[top[0], top[1]] != 0) and level != 4:\r\n                neighbours.append((level + 1, cellnum))\r\n        else:\r\n            if(img[top[0], top[1]] != 0):\r\n                neighbours.append((level + 1, cellnum))\r\n    else:\r\n        topleft = [y0 + int((r + 20) * sine(cellnum * angle - 1.5 * offset)), x0 + int((r + 20) * cosine(cellnum * angle - 1.5 * offset))]\r\n        topright = [y0 + int((r + 20) * sine(cellnum * angle - 0.5 * offset)), x0 + int((r + 20) * cosine(cellnum * angle - 0.5 * offset))]\r\n        if(img[topleft[0], topleft[1]] != 0) and level != 6:\r\n            neighbours.append((level + 1, 2 * cellnum - 1))\r\n        if(img[topright[0], topright[1]] != 0) and level != 6:\r\n            neighbours.append((level + 1, 2 * cellnum))\r\n    bottom = [y0 + int((r - 20) * sine(cellnum * angle - offset)), x0 + int((r - 20) * cosine(cellnum * angle - offset))]\r\n    left = [y0 + int(r * sine(cellnum * angle - angle)), x0 + int(r * cosine(cellnum * angle - angle))]\r\n    right = [y0 + int(r * sine(cellnum * angle)), x0 + int(r * cosine(cellnum * angle))]\r\n    if(img[bottom[0], bottom[1]] != 0):\r\n        if level == 5 or level == 4:\r\n            neighbours.append((level - 1, cellnum))\r\n        elif level == 1:\r\n            neighbours.append((0, 0))\r\n        else:\r\n            neighbours.append((level - 1, (cellnum + 1) // 2))\r\n    if(img[left[0], left[1]] != 0):\r\n        if cellnum > 1:\r\n            cell = cellnum - 1\r\n        else:\r\n            if level == 1:\r\n                cell = 6\r\n            elif level == 2:\r\n                cell = 12\r\n            elif level == 3 or level == 4 or level == 5:\r\n                cell = 24\r\n            else:\r\n                cell = 48\r\n        neighbours.append((level, cell))\r\n    if(img[right[0], right[1]] != 0):\r\n        if level == 1 and cellnum == 6:\r\n            cell = 1\r\n        elif level == 2 and cellnum == 12:\r\n            cell = 1\r\n        elif (level == 3 or level == 4 or level == 5) and cellnum == 24:\r\n            cell = 1\r\n        elif level == 6 and cellnum == 48:\r\n            cell = 1\r\n        else:\r\n            cell = cellnum + 1\r\n        neighbours.append((level, cell))\r\n\r\n    #################################################################################\r\n    return neighbours\r\n\r\n\'\'\'\r\n    colourCell function takes 4 arguments:-\r\n        img - input image\r\n        level - level of cell to be coloured\r\n        cellnum - cell number of cell to be coloured\r\n        flag - Variable to check whether the cell has a marker or not\r\n    Logic:\r\n        colourCell basically highlights the given cell by painting it with the given colourVal. Care should be taken that\r\n        the function doesn\'t paint over the black walls and only paints the empty spaces. This function returns the image\r\n        with the painted cell.\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        r and angle depend on the level and cellnum for each cell\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n        j - iterator for angle in steps of 0.25 , 1\r\n        The angle and radius for the cells are incremented in nested loops and in each pass, the pixel with the corresponding angle and radius is coloured.\r\n        The pixel is coloured only if it is white, therefore cell walls are not coloured.\r\n\'\'\'\r\ndef colourCell(img, level, cellnum, flag):\r\n    ############################# Add your Code Here ################################\r\n    r = 40 * (level) \r\n    if level == 0 or level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    if level == 0:\r\n        for i in range(40):\r\n            for j in np.arange(0, 360, 1):\r\n                x = x0 + int(i * cosine(j))\r\n                y = y0 + int(i * sine(j))\r\n                if img[y, x] == 255:\r\n                    img[y, x] = 150\r\n        return img\r\n    for i in range(40):\r\n        radius = r + i\r\n        for j in np.arange(0, angle, 0.185):\r\n            a = angle * (cellnum - 1) + j\r\n            x = x0 + int(radius * cosine(a))\r\n            y = y0 + int(radius * sine(a))\r\n            if img[y, x] == 255:\r\n                img[y, x] = 150\r\n    if flag == 1:\r\n        r = 40 * (level) + 20\r\n        x = x0 + r * cosine(angle * cellnum - offset)\r\n        y = y0 + r * sine(angle * cellnum - offset)\r\n        cv2.circle(img, (y, x), 10, (0, 0, 0), -1)\r\n\r\n    #################################################################################  \r\n    return img\r\n\r\n##  Function that accepts some arguments from user and returns the graph of the maze image.\r\n\'\'\'\r\n    Function name: buildGraph(img, size)\r\n    Input:\r\n        img - binary image of the maze\r\n        size - 1 or 2 based on the number of levles in the image\r\n    Output: Returns the graph of the image\r\n    Logic: Each cell is traversed and the neighbours for the cell are obtained from the findNeighbours() function.\r\n        A new entry is made in the dictionary with the current cell coordinates as its key and value returned from the findNeighbours function as its value.\r\n        graph - Dictionary with key as cell and values as its corresponding neighbours\r\n        l - Maximum level in the given maze\r\n        c - Maximum cellnum in the current level\r\n    Example call: bulidGraph(img, size)\r\n\'\'\'\r\ndef buildGraph(img, size):      ## You can pass your own arguments in this space.\r\n    graph = {}\r\n    ############################# Add your Code Here ################################\r\n    if size == 1:\r\n        l = 4\r\n    else:\r\n        l = 6\r\n    graph[(0, 0)] = findNeighbours(img, 0, 0, size)\r\n    for i in range(l):\r\n        level = i + 1\r\n        if level == 1:\r\n            c = 6\r\n        elif level == 2:\r\n            c = 12\r\n        elif level == 3 or level == 4 or level == 5:\r\n            c = 24\r\n        else:\r\n            c = 48\r\n        for j in range(c):\r\n            cellnum = j + 1\r\n            graph[(level, cellnum)] = findNeighbours(img, level, cellnum, size)\r\n\r\n    #################################################################################\r\n    return graph\r\n\r\n##  Function accepts some arguments and returns the Start coordinates of the maze.\r\n\'\'\'\r\n    Function name: findStartPoint(img, size)\r\n    Input:\r\n        img - binary image of the maze\r\n        size - 1 or 2 based on the number of levles in the image\r\n    Output: Returns the coordinates (level, cellnum) for the maze in the image\r\n    Logic:\r\n        The entire outer boundary of the maze is traversed and when the boundary is white, the corresponding cell (level, cellnum) is returned.\r\n        The traversal for the outer boundary is done using conversion of polar to cartesian system using:\r\n            x = r * cosine(angle)\r\n            y = r * sine(angle)\r\n        r and angle depend on the level and cellnum for each cell\r\n        top = pixel value of the outer boundary for a given angle of the maze\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n    Example call: findStartPoint(img, size)\r\n\'\'\'\r\ndef findStartPoint(img, size):     ## You can pass your own arguments in this space.\r\n    ############################# Add your Code Here ################################\r\n    if size == 1:\r\n        level = 4\r\n    else:\r\n        level = 6\r\n    r = 40 * (level) + 20\r\n    if level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    offset = angle / 2\r\n    for cellnum in range(1, 49):\r\n        top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n        if(img[top[0], top[1]] != 0):\r\n            start = (level, cellnum)\r\n            break\r\n\r\n    #################################################################################\r\n    return start\r\n\r\n##  Finds shortest path between two coordinates in the maze. Returns a set of coordinates from initial point\r\n##  to final point.\r\n\'\'\'\r\n    Function name: findPath(graph, initial, final)\r\n    Input:\r\n        graph - Obtained from buildGraph()\r\n        final - Coordinates of the final cell\r\n        initial - Coordinates of the initial cell\r\n    Output:\r\n        Returns the shortest path fron initial to final as a list of cell coordinated of the cells to be traversed to reach the final.    \r\n    Logic:\r\n        path - Global variable that holds a list of all the cell coordinates that are along the path to be traversed, to go from initial to final cell.\r\n        visited - List of all the cells in the maze that have already been visited.\r\n        shortest - Shortest path from initial to final in terms of cell numbers\r\n        new - Global variable that holds the dictionary containing a list of all the cell numbers along with their corresponding numbers assigned by the algorithm(see number path)\r\n        l - Global variable that holds the list of objects of type Link containing a value adn a parent\r\n        x - List used to generate successive numbers for successive calls of next_num\r\n        In an infinite loop, the initial is the current cell initially. Checks for a neighbour with the same number. If found, it appends that neighbour to shortest and makes it current.\r\n        If not found, it it checks for a neighbour with the value equal to the next number in list path(whose track is kept using path). When found, it appends that neighbour to shortest and makes it current.\r\n        This is done till final and current are the same cells. Then, shortest is returned.\r\n    Example call: findPath(graph, initial, final)\r\n\'\'\'\r\ndef findPath(graph, initial, final):             ## You can pass your own arguments in this space.\r\n    ############################# Add your Code Here ################################\r\n    shortest = [initial]\r\n    visited = [initial]\r\n    count = 1\r\n    global path\r\n    path = []\r\n    global new\r\n    new = {}\r\n    global l\r\n    l = []\r\n    for k in graph.keys():\r\n        new[k] = -1\r\n    new[initial] = 1\r\n    global x\r\n    x = range(1, 1000)\r\n    numberMaze(graph, initial, new, l)\r\n    path.append(new[final])\r\n    shortestNumberedPath(l, new[initial], new[final], path)\r\n    path.reverse()\r\n    current = initial\r\n    while(True):\r\n        if current == final:\r\n            return shortest\r\n        for j in graph[current]:\r\n            if not tuple(j) in visited:\r\n                if new[tuple(j)] == new[current]:\r\n                    current = tuple(j)\r\n                    shortest.append(current)\r\n                    visited.append(current)\r\n                    break\r\n                else:\r\n                    if new[tuple(j)] == path[count]:\r\n                        count += 1\r\n                        shortest.append(tuple(j))\r\n                        current = tuple(j)\r\n                        visited.append(current)\r\n                        break\r\n\r\n    #################################################################################\r\n    return shortest\r\n\r\n## The findMarkers() function returns a list of coloured markers in form of a python dictionaries\r\n## For example if a blue marker is present at (3,6) and red marker is present at (1,5) then the\r\n## dictionary is returned as :-\r\n##          list_of_markers = { \'Blue\':(3,6), \'Red\':(1,5)}\r\n\'\'\'\r\n    Function name: findMarkers(filepath)\r\n    Input:\r\n        filepath - file path to the image of the maze to be solved\r\n    Output:\r\n        Returns a dictionary containing two entries with the keys being \'Red\' and \'Blue\' and their values being the cell coordinates (level, cellnum) of the cells containing the markers.    \r\n    Logic:\r\n        length - Length of image or the number of rows of pixels in the image\r\n        l - maximum level in the cell based on the its size\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n        The pixel corresponding to the center of each cell is found and checked for its BGR values. If it is coloured, the colour of marker in the cell and its coordinates are added to the dictionary list_of_markers.\r\n        The center pixels of the cells are obtained by using polar system with the center pixel of the image as the origin(x = r * cosine(angle), y = r * sine(angle))\r\n        r and angle depend on the level and cellnum for each cell.\r\n    Example call: findMarkers(filepath)\r\n\'\'\'\r\ndef findMarkers(filepath):             ## You can pass your own arguments in this space.\r\n    list_of_markers = {}\r\n    ############################# Add your Code Here ################################\r\n    img = cv2.imread(filepath)\r\n    length = len(img)\r\n    if length == 440:\r\n        size = 1\r\n        l = 4\r\n    else:\r\n        size = 2\r\n        l = 6\r\n    for i in range(l):\r\n        level = i + 1\r\n        r = 40 * (level) + 20\r\n        if level == 0 or level == 1:\r\n            angle = 60\r\n            c = 6\r\n        elif level == 2:\r\n            angle = 30\r\n            c = 12\r\n        elif level == 3 or level == 4 or level == 5:\r\n            angle = 15\r\n            c = 24\r\n        else:\r\n            angle = 7.5\r\n            c = 48\r\n        x0 = len(img[0]) // 2\r\n        y0 = len(img) // 2\r\n        offset = angle / 2\r\n        for j in range(c):\r\n            cellnum = j + 1\r\n            x = x0 + r * cosine(angle * cellnum - offset)\r\n            y = y0 + r * sine(angle * cellnum - offset)\r\n            pixel = img[y, x]\r\n            if pixel[0] < 10 and pixel[1] < 10:\r\n                list_of_markers[\'Red\'] = (level, cellnum)\r\n            if pixel[1] < 10 and pixel[2] < 10:\r\n                list_of_markers[\'Blue\'] = (level, cellnum)\r\n\r\n    #################################################################################\r\n    return list_of_markers\r\n\r\n## The findOptimumPath() function returns a python list which consists of all paths that need to be traversed\r\n## in order to start from the START cell and traverse to any one of the markers ( either blue or red ) and then\r\n## traverse to FINISH. The length of path should be shortest ( most optimal solution).\r\n\'\'\'\r\n    Function name: findOptimumPath(markers, filePath)\r\n    Input:\r\n        graph - Obtained from buildGraph()\r\n        final - Coordinates of the final cell\r\n        initial - Coordinates of the initial cell\r\n    Output:\r\n        The findOptimumPath() function returns a python list which consists of all paths that need to be traversed in order to start from the START cell and traverse to any one of the markers\r\n        ( either blue or red ) and then traverse to FINISH.    \r\n    Logic:\r\n        red - Path from initial to red\r\n        blue - Path from initial to blue\r\n        red_final - Path from red to final\r\n        blue_final - Path from blue to final\r\n        red_count - Length of path taken from initial to final if red marker is chosen\r\n        blue_count - Length of path taken from initial to final if blue marker is chosen\r\n        red_count and blue_count are compared to find the shorter path of the two paths possibe.\r\n        Then the set of paths from the initial to the corresponding marker and from the corresponding marker to the final are appended to shortest and shortest is returned.\r\n        if red_count and blue_count are equal, then the path in which the marker is closer to initial is chosen and appended to shortest.\r\n    Example call: findOptimumPath(markers, filePath)\r\n\'\'\'\r\ndef findOptimumPath(markers, filePath):     ## You can pass your own arguments in this space.\r\n    pathArray = []\r\n    ############################# Add your Code Here ################################\r\n    shortest = []\r\n    img = readImageBinary(filePath)\r\n    if len(img) == 440:\r\n        size = 1\r\n    else:\r\n        size = 2\r\n    initial = findStartPoint(img, size)\r\n    final = (0, 0)\r\n    graph = buildGraph(img, size)\r\n    blue = findPath(graph, initial, markers[\'Blue\'])\r\n    red = findPath(graph, initial, markers[\'Red\'])\r\n    blue_final = findPath(graph, markers[\'Blue\'], final)\r\n    red_final = red_final = findPath(graph, markers[\'Red\'], final)\r\n    red_count = len(red) + len(red_final)\r\n    blue_count = len(blue) + len(blue_final)\r\n    if red_count < blue_count:\r\n        shortest.append(red)\r\n        shortest.append(red_final)\r\n    elif blue_count < red_count:\r\n        shortest.append(blue)\r\n        shortest.append(blue_final)\r\n    else:\r\n        if len(red) < len(blue):\r\n            shortest.append(red)\r\n            shortest.append(red_final)\r\n        else:\r\n            shortest.append(blue)\r\n            shortest.append(blue_final)\r\n    pathArray = shortest\r\n    #################################################################################\r\n    return pathArray\r\n\r\n## The colourPath() function highlights the whole path that needs to be traversed in the maze image and\r\n## returns the final image.\r\n\'\'\'\r\n    Function name: colourPath(img, path, markers)\r\n    Input:\r\n        img - Binary input image\r\n        path - path obtained from the findOptimumPath() function\r\n        markers - Dictionary of markers obtained from the findMarkers function\r\n    Output:\r\n        Colours the entire path to be traversed and in case the cell has a marker, it colours that cell and then adds a black circle in the center of the cell   \r\n    Logic:\r\n        If the cell in the path is a marker, its coordinates is sent to the colourCell() function with flag = 1, else, flag = 0. colourCell colours the cell as required and returns the image.\r\n        This is done for all the cells in the path.\r\n    Example call: colourPath(img, path, markers)\r\n\'\'\'\r\ndef colourPath(img, path, markers):   ## You can pass your own arguments in this space. \r\n    ############################# Add your Code Here ################################\r\n    for i in path:\r\n        for j in i:\r\n            if j in markers:\r\n                flag = 1\r\n            else:\r\n                flag = 0\r\n            img = colourCell(img, j[0], j[1], flag)\r\n            \r\n    #################################################################################\r\n    return img\r\n\r\n#####################################    Add Utility Functions Here   ###################################\r\n##                                                                                                     ##\r\n##                   You are free to define any functions you want in this space.                      ##\r\n##                             The functions should be properly explained.                             ##\r\n\r\n\'\'\'\r\n    Function name: next_num()\r\n    Output:\r\n        Returns the next number from a list having numbers 0 to 1000 whenever it is called. Returns 1 when it is called for the first time, 2 when called for the second time,\r\n        3 for the third time and so on.\r\n    Logic:\r\n        global variable x is used.\r\n        x is a list containing numbers from 0 to 1000.\r\n        whenever next_num() is called it deletes the first element and returns the new first element.\r\n    Example call: next_num()\r\n\'\'\'\r\ndef next_num():\r\n    del x[0]\r\n    return x[0]\r\n\r\n\'\'\'\r\n    Function name: numberMaze(graph, initial, new, l)\r\n    Input:\r\n        graph - Obtained from buildGraph()\r\n        initial - Cell coordinates of the initial cell\r\n        new - Dictionary with cells as keys and a number assignes to the cells as their corresponding values. It is a global variable.\r\n        l - list of objects of type Link class\r\n        The list l is a global variable that stores objects of the type Link.\r\n        Link is a class with two members:\r\n            value - the number that is assigned to the cell\r\n            parent - the number from which the current cell number has branched or originated\r\n    Output:\r\n        It takes the graph as the input and assigns numbers to the cells based on their neighbours.\r\n    Logic:\r\n        Algorithm used:\r\n            Number 1 is assigned to the initial cell (0, 0). The neighbours of the cell are checked.\r\n            (i) If it has only one neighbour, the same number is assigned to the neighbour cell and this function is called recursively on the neighbour.\r\n            (ii) If it has more than one neighbours, the next number that is to be assigned to the cells (which is obtained from next_num()) is assigned to these neighbours and the\r\n                function is called recursively on these neighbour cells.\r\n            (iii) If it has no neighbours, then it returns.\r\n            The shortest path is then found by going from the final cell to its parent numbered cells till it reaches the initial cell which is assigned from number 1 (done by shortestNumberedPath())\r\n    Example call: numberMaze(graph, initial, new, l)\r\n\'\'\'\r\ndef numberMaze(graph, initial, new, l):\r\n    empty = 0\r\n    lar = 0\r\n    for k in graph[initial]:\r\n        if new[tuple(k)] == -1:\r\n            empty += 1\r\n    if empty == 0:\r\n        return\r\n    elif empty == 1:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                new[tuple(graph[initial][i])] = new[initial] \r\n                numberMaze(graph, tuple(graph[initial][i]), new, l) \r\n    else:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                n = next_num()\r\n                new[tuple(graph[initial][i])] = n\r\n                l.append(Link(n, new[initial]))\r\n                numberMaze(graph, tuple(graph[initial][i]), new, l)\r\n\r\n\'\'\'\r\n    Function name: shortestNumberedPath(l, initial, final, path)\r\n    Input:\r\n        l - list of objects of type Link class\r\n        final - number assigned to the final cell by the algorithm\r\n        initial - the number assigned to the initial cell by the algorithm\r\n        path - global variable to store the path from initial to final cell in terms of the numbers that they are assigned\r\n    Output:\r\n        Returns the shortest path in terms of number assigned to the cells        \r\n    Logic:\r\n        The list l is a global variable that stores objects of the type Link.\r\n        Link is a class with two members:\r\n            value - the number that is assigned to the cell\r\n            parent - the number that the current cell number was branched from\r\n        The function begins by returning the parent number of the number assigned to the final cell and then recursively calls itself\r\n        with the obtained parent number and final and this continues till the values of initial and final are equal. At this point, path\r\n        contains the path going from the final to the initial cell in terms of the numbers assigned to these cells.\r\n    Example call: shortestNumberedPath(l, initial, final, path)\r\n\'\'\'\r\ndef shortestNumberedPath(l, initial, final, path):\r\n    if final == initial:\r\n        return\r\n    else:\r\n        for i in l:\r\n            if i.value == final:\r\n                parent = i.parent\r\n                break\r\n        path.append(parent)\r\n        shortestNumberedPath(l, initial, parent, path)\r\n\r\n    \r\n##                                                                                                     ##\r\n##                                                                                                     ##\r\n#########################################################################################################\r\n\r\n## This is the main() function for the code, you are not allowed to change any statements in this part of\r\n## the code. You are only allowed to change the arguments supplied in the findMarkers(), findOptimumPath()\r\n## and colourPath() functions.    \r\ndef main(filePath, flag = 0):\r\n    img = readImageHSV(filePath)\r\n    imgBinary = readImageBinary(filePath)\r\n    if len(img) == 440:\r\n        size = 1\r\n    else:\r\n        size = 2\r\n    listofMarkers = findMarkers(filePath)\r\n    path = findOptimumPath(listofMarkers, filePath)\r\n    img = colourPath(imgBinary, path, listofMarkers)\r\n    print path\r\n    print listofMarkers\r\n    if __name__ == ""__main__"":                    \r\n        return img\r\n    else:\r\n        if flag == 0:\r\n            return path\r\n        elif flag == 1:\r\n            return str(listofMarkers) + ""\\n""\r\n        else:\r\n            return img\r\n    \r\n## The main() function is called here. Specify the filepath of image in the space given.\r\nif __name__ == ""__main__"":\r\n    filePath = ""image_06.jpg""     ## File path for test image\r\n    img = main(filePath)           ## Main function call\r\n    cv2.imshow(""image"",img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n    \r\n'"
mazeSolve/section1.py,2,"b'\'\'\'\r\nTeam Id: eYRC-NT#558\r\nAuthor List: Chethan K P, Rahul Patil, Rahul Ramprasad, Rohit Goud\r\nFilename: section1.py\r\nTheme: Navigate a terrain\r\nFunctions:\r\n    sine(angle)\r\n    cosine(angle)\r\n    readImage(filepath)\r\n    findNeighbours(img, level, cellnum, size)\r\n    colourCell(img, level, cellnum, size, colourVal)\r\n    buildGraph(img, size)\r\n    findStartPoint(img, size)\r\n    findPath(graph, initial, final)\r\n    next_num()\r\n    numberMaze(graph, initial, new, l)\r\n    shortestNumberedPath(l, initial, final, path)\r\n    main(filePath, flag)\r\nGlobal variables:\r\n    x - list\r\n    path - list\r\n    new - Dictionary\r\n    l - list\r\n\r\n    *explanation of functions and variables used before function definition*\r\n    \'\'\'\r\nimport numpy as np\r\nimport cv2\r\nimport math\r\nimport time\r\n\r\n#Description for this class is given in the numberMaze() function\r\nclass Link():\r\n    value = 0\r\n    parent = 0\r\n    def __init__(self, a, b):\r\n        self.value = a\r\n        self.parent = b\r\n        \r\n##  Returns sine of an angle\r\ndef sine(angle):\r\n    return math.sin(math.radians(angle))\r\n\r\n##  Returns cosine of an angle\r\ndef cosine(angle):\r\n    return math.cos(math.radians(angle))\r\n\r\n##  Reads an image from the specified filepath and converts it to Grayscale. Then applies binary thresholding\r\n##  to the image.\r\ndef readImage(filePath):\r\n    mazeImg = cv2.imread(filePath)\r\n    grayImg = cv2.cvtColor(mazeImg, cv2.COLOR_BGR2GRAY)\r\n    ret,binaryImage = cv2.threshold(grayImg,127,255,cv2.THRESH_BINARY)\r\n    return binaryImage\r\n\r\n##  This function accepts the img, level and cell number of a particular cell and the size of the maze as input\r\n##  arguments and returns the list of cells which are traversable from the specified cell.\r\n\'\'\'\r\n    Function name: findNeighbours(img, level, cellnum, size)\r\n    Input:\r\n        img - binary image of the maze which is a numpy array\r\n        size - 1 or 2 based on the number of levles in the image\r\n        level - Level of the cell\r\n        cellnum - cell number for the cell\r\n    Output:\r\n        Returns the traversable neighbours for a given cell (level, cellnum)\r\n    Logic:\r\n        Based on the level and cellnum of the cell, the distance and angle of the cell from the center pixel of the image is found.\r\n        The circularly topmost( or topleft and topright) pixel for that cell is checked for its value. If the pixel is not 0(black) then the corresponding neighbour is appended to the list neighbours[].\r\n        Similarly left right and bottom neighbours are also found.\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        r and angle depend on the level and cellnum for each cell\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n        top, topleft, left, right, bottom - pixel values in terms of indices of the top (or topleft and topright depending on level), left, right and bottom boundary pixels for the cell\r\n        neighbours - list of neighbours for the given cell\r\n    Example call: findNeighbours(img, level, cellnum, size)\r\n\'\'\'\r\ndef findNeighbours(img, level, cellnum, size):\r\n    neighbours = []\r\n    ############################# Add your Code Here ################################\r\n    r = 40 * (level) + 20\r\n    if level == 0 or level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    offset = angle / 2\r\n    if level == 0:\r\n        for cellnum in range(1, 7):\r\n            top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n            if(img[top[0], top[1]] != 0):\r\n                neighbours.append((level + 1, cellnum))\r\n        return neighbours\r\n    if level == 3 or level == 4:\r\n        top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n        if size == 1:\r\n            if(img[top[0], top[1]] != 0) and level != 4:\r\n                neighbours.append((level + 1, cellnum))\r\n        else:\r\n            if(img[top[0], top[1]] != 0):\r\n                neighbours.append((level + 1, cellnum))\r\n    else:\r\n        topleft = [y0 + int((r + 20) * sine(cellnum * angle - 1.5 * offset)), x0 + int((r + 20) * cosine(cellnum * angle - 1.5 * offset))]\r\n        topright = [y0 + int((r + 20) * sine(cellnum * angle - 0.5 * offset)), x0 + int((r + 20) * cosine(cellnum * angle - 0.5 * offset))]\r\n        if(img[topleft[0], topleft[1]] != 0) and level != 6:\r\n            neighbours.append((level + 1, 2 * cellnum - 1))\r\n        if(img[topright[0], topright[1]] != 0) and level != 6:\r\n            neighbours.append((level + 1, 2 * cellnum))\r\n    bottom = [y0 + int((r - 20) * sine(cellnum * angle - offset)), x0 + int((r - 20) * cosine(cellnum * angle - offset))]\r\n    left = [y0 + int(r * sine(cellnum * angle - angle)), x0 + int(r * cosine(cellnum * angle - angle))]\r\n    right = [y0 + int(r * sine(cellnum * angle)), x0 + int(r * cosine(cellnum * angle))]\r\n    if(img[bottom[0], bottom[1]] != 0):\r\n        if level == 5 or level == 4:\r\n            neighbours.append((level - 1, cellnum))\r\n        elif level == 1:\r\n            neighbours.append((0, 0))\r\n        else:\r\n            neighbours.append((level - 1, (cellnum + 1) // 2))\r\n    if(img[left[0], left[1]] != 0):\r\n        if cellnum > 1:\r\n            cell = cellnum - 1\r\n        else:\r\n            if level == 1:\r\n                cell = 6\r\n            elif level == 2:\r\n                cell = 12\r\n            elif level == 3 or level == 4 or level == 5:\r\n                cell = 24\r\n            else:\r\n                cell = 48\r\n        neighbours.append((level, cell))\r\n    if(img[right[0], right[1]] != 0):\r\n        if level == 1 and cellnum == 6:\r\n            cell = 1\r\n        elif level == 2 and cellnum == 12:\r\n            cell = 1\r\n        elif (level == 3 or level == 4 or level == 5) and cellnum == 24:\r\n            cell = 1\r\n        elif level == 6 and cellnum == 48:\r\n            cell = 1\r\n        else:\r\n            cell = cellnum + 1\r\n        neighbours.append((level, cell))\r\n\r\n    #################################################################################\r\n    return neighbours\r\n\r\n\'\'\'\r\n    colourCell function takes 5 arguments:-\r\n        img - input image\r\n        level - level of cell to be coloured\r\n        cellnum - cell number of cell to be coloured\r\n        size - size of maze\r\n        colourVal - the intensity of the colour.\r\n    Logic: colourCell basically highlights the given cell by painting it with the given colourVal. Care should be taken that\r\n        the function doesn\'t paint over the black walls and only paints the empty spaces. This function returns the image\r\n        with the painted cell.\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        r and angle depend on the level and cellnum for each cell\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n        j - iterator for angle in steps of 0.25 , 1\r\n        The angle and radius for the cells are incremented in nested loops and in each pass, the pixel with the corresponding angle and radius is coloured.\r\n        The pixel is coloured only if it is white, therefore cell walls are not coloured.\r\n\'\'\'\r\ndef colourCell(img, level, cellnum, size, colourVal):\r\n    ############################# Add your Code Here ################################\r\n    r = 40 * (level) \r\n    if level == 0 or level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    if level == 0:\r\n        for i in range(40):\r\n            for j in np.arange(0, 360, 1):\r\n                x = x0 + int(i * cosine(j))\r\n                y = y0 + int(i * sine(j))\r\n                if img[y, x] == 255:\r\n                    img[y, x] = colourVal\r\n        return img\r\n    for i in range(40):\r\n        radius = r + i\r\n        for j in np.arange(0, angle, 0.185):\r\n            a = angle * (cellnum - 1) + j\r\n            x = x0 + int(radius * cosine(a))\r\n            y = y0 + int(radius * sine(a))\r\n            if img[y, x] == 255:\r\n                img[y, x] = colourVal\r\n\r\n    #################################################################################\r\n    return img\r\n\r\n##  Function that accepts some arguments from user and returns the graph of the maze image.\r\n\'\'\'\r\n    Function name: buildGraph(img, size)\r\n    Input:\r\n        img - binary image of the maze\r\n        size - 1 or 2 based on the number of levles in the image\r\n    Output: Returns the graph of the image\r\n    Logic: Each cell is traversed and the neighbours for the cell are obtained from the findNeighbours() function.\r\n        A new entry is made in the dictionary with the current cell coordinates as its key and value returned from the findNeighbours function as its value.\r\n        graph - Dictionary with key as cell and values as its corresponding neighbours\r\n        l - Maximum level in the given maze\r\n        c - Maximum cellnum in the current level\r\n    Example call: bulidGraph(img, size)\r\n\'\'\'\r\ndef buildGraph(img, size):   ## You can pass your own arguments in this space.\r\n    graph = {}\r\n    ############################# Add your Code Here ################################\r\n    if size == 1:\r\n        l = 4\r\n    else:\r\n        l = 6\r\n    graph[(0, 0)] = findNeighbours(img, 0, 0, size)\r\n    for i in range(l):\r\n        level = i + 1\r\n        if level == 1:\r\n            c = 6\r\n        elif level == 2:\r\n            c = 12\r\n        elif level == 3 or level == 4 or level == 5:\r\n            c = 24\r\n        else:\r\n            c = 48\r\n        for j in range(c):\r\n            cellnum = j + 1\r\n            graph[(level, cellnum)] = findNeighbours(img, level, cellnum, size)\r\n\r\n    #################################################################################\r\n    return graph\r\n\r\n##  Function accepts some arguments and returns the Start coordinates of the maze.\r\n\'\'\'\r\n    Function name: findStartPoint(img, size)\r\n    Input:\r\n        img - binary image of the maze\r\n        size - 1 or 2 based on the number of levles in the image\r\n    Output: Returns the coordinates (level, cellnum) for the maze in the image\r\n    Logic:\r\n        The entire outer boundary of the maze is traversed and when the boundary is white, the corresponding cell (level, cellnum) is returned.\r\n        The traversal for the outer boundary is done using conversion of polar to cartesian system using:\r\n            x = r * cosine(angle)\r\n            y = r * sine(angle)\r\n        top = pixel value of the outer boundary for a given angle of the maze\r\n        r - radius of the given level in terms of picel numbers with the center being the center pixel of the image\r\n        angle - angle of the cell from the horizontal in clockwise direction\r\n        r and angle depend on the level and cellnum for each cell\r\n        x0 = Column value of the center pixel of the image\r\n        y0 = Row value of the center pixel of the image\r\n    Example call: findStartPoint(img, size)\r\n\'\'\'\r\ndef findStartPoint(img, size):     ## You can pass your own arguments in this space.\r\n    ############################# Add your Code Here ################################\r\n    if size == 1:\r\n        level = 4\r\n    else:\r\n        level = 6\r\n    r = 40 * (level) + 20\r\n    if level == 1:\r\n        angle = 60\r\n    elif level == 2:\r\n        angle = 30\r\n    elif level == 3 or level == 4 or level == 5:\r\n        angle = 15\r\n    else:\r\n        angle = 7.5\r\n    x0 = len(img[0]) // 2\r\n    y0 = len(img) // 2\r\n    offset = angle / 2\r\n    for cellnum in range(1, 49):\r\n        top = [y0 + int((r + 20) * sine(cellnum * angle - offset)), x0 + int((r + 20) * cosine(cellnum * angle - offset))]\r\n        if(img[top[0], top[1]] != 0):\r\n            start = (level, cellnum)\r\n            break\r\n\r\n    #################################################################################\r\n    return start\r\n\r\n\'\'\'\r\n    Function name: next_num()\r\n    Output:\r\n        Returns the next number from a list having numbers 0 to 1000 whenever it is called. Returns 1 when it is called for the first time, 2 when called for the second time,\r\n        3 for the third time and so on.\r\n    Logic:\r\n        global variable x is used.\r\n        x is a list containing numbers from 0 to 1000.\r\n        whenever next_num() is called it deletes the first element and returns the new first element.\r\n    Example call: next_num()\r\n\'\'\'\r\ndef next_num():\r\n    del x[0]\r\n    return x[0]\r\n\r\n\'\'\'\r\n    Function name: numberMaze(graph, initial, new, l)\r\n    Input:\r\n        graph - Obtained from buildGraph()\r\n        initial - Cell coordinates of the initial cell\r\n        new - Dictionary with cells as keys and a number assignes to the cells as their corresponding values. It is a global variable.\r\n        l - list of objects of type Link class\r\n        The list l is a global variable that stores objects of the type Link.\r\n        Link is a class with two members:\r\n            value - the number that is assigned to the cell\r\n            parent - the number from which the current cell number has branched or originated\r\n    Output:\r\n        It takes the graph as the input and assigns numbers to the cells based on their neighbours.\r\n    Logic:\r\n        Algorithm used:\r\n            Number 1 is assigned to the initial cell (0, 0). The neighbours of the cell are checked.\r\n            (i) If it has only one neighbour, the same number is assigned to the neighbour cell and this function is called recursively on the neighbour.\r\n            (ii) If it has more than one neighbours, the next number that is to be assigned to the cells (which is obtained from next_num()) is assigned to these neighbours and the\r\n                function is called recursively on these neighbour cells.\r\n            (iii) If it has no neighbours, then it returns.\r\n            The shortest path is then found by going from the final cell to its parent numbered cells till it reaches the initial cell which is assigned from number 1 (done by shortestNumberedPath())\r\n    Example call: numberMaze(graph, initial, new, l)\r\n\'\'\'\r\ndef numberMaze(graph, initial, new, l):\r\n    empty = 0\r\n    lar = 0\r\n    for k in graph[initial]:\r\n        if new[tuple(k)] == -1:\r\n            empty += 1\r\n    if empty == 0:\r\n        return\r\n    elif empty == 1:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                new[tuple(graph[initial][i])] = new[initial] \r\n                numberMaze(graph, tuple(graph[initial][i]), new, l) \r\n    else:\r\n        for i in range(len(graph[initial])):\r\n            if new[tuple(graph[initial][i])] == -1:\r\n                n = next_num()\r\n                new[tuple(graph[initial][i])] = n\r\n                l.append(Link(n, new[initial]))\r\n                numberMaze(graph, tuple(graph[initial][i]), new, l)\r\n\r\n\'\'\'\r\n    Function name: shortestNumberedPath(l, initial, final, path)\r\n    Input:\r\n        l - list of objects of type Link class\r\n        final - number assigned to the final cell by the algorithm\r\n        initial - the number assigned to the initial cell by the algorithm\r\n        path - global variable to store the path from initial to final cell in terms of the numbers that they are assigned\r\n    Output:\r\n        Returns the shortest path in terms of number assigned to the cells        \r\n    Logic:\r\n        The list l is a global variable that stores objects of the type Link.\r\n        Link is a class with two members:\r\n            value - the number that is assigned to the cell\r\n            parent - the number that the current cell number was branched from\r\n        The function begins by returning the parent number of the number assigned to the final cell and then recursively calls itself\r\n        with the obtained parent number and final and this continues till the values of initial and final are equal. At this point, path\r\n        contains the path going from the final to the initial cell in terms of the numbers assigned to these cells.\r\n    Example call: shortestNumberedPath(l, initial, final, path)\r\n\'\'\'\r\ndef shortestNumberedPath(l, initial, final, path):\r\n    if final == initial:\r\n        return\r\n    else:\r\n        for i in l:\r\n            if i.value == final:\r\n                parent = i.parent\r\n                break\r\n        path.append(parent)\r\n        shortestNumberedPath(l, initial, parent, path)\r\n\r\n##  Finds shortest path between two coordinates in the maze. Returns a set of coordinates from initial point\r\n##  to final point.\r\n\'\'\'\r\n    Function name: findPath(graph, initial, final)\r\n    Input:\r\n        graph - Obtained from buildGraph()\r\n        final - Coordinates of the final cell\r\n        initial - Coordinates of the initial cell\r\n    Output:\r\n        Returns the shortest path fron initial to final as a list of cell coordinated of the cells to be traversed to reach the final.    \r\n    Logic:\r\n        path - Global variable that holds a list of all the cell coordinates that are along the path to be traversed, to go from initial to final cell.\r\n        visited - List of all the cells in the maze that have already been visited.\r\n        shortest - Shortest path from initial to final in terms of cell numbers\r\n        new - Global variable that holds the dictionary containing a list of all the cell numbers along with their corresponding numbers assigned by the algorithm(see number path)\r\n        l - Global variable that holds the list of objects of type Link containing a value adn a parent\r\n        x - List used to generate successive numbers for successive calls of next_num\r\n        In an infinite loop, the initial is the current cell initially. Checks for a neighbour with the same number. If found, it appends that neighbour to shortest and makes it current.\r\n        If not found, it it checks for a neighbour with the value equal to the next number in list path(whose track is kept using path). When found, it appends that neighbour to shortest and makes it current.\r\n        This is done till final and current are the same cells. Then, shortest is returned\r\n    Example call: findPath(graph, initial, final)\r\n\'\'\'\r\ndef findPath(graph, initial, final):      ## You can pass your own arguments in this space.\r\n    ############################# Add your Code Here ################################\r\n    shortest = [initial]\r\n    visited = [initial]\r\n    count = 1\r\n    global path\r\n    path = []\r\n    global new\r\n    new = {}\r\n    global l\r\n    l = []\r\n    for k in graph.keys():\r\n        new[k] = -1\r\n    new[initial] = 1\r\n    global x\r\n    x = range(1, 1000)\r\n    numberMaze(graph, initial, new, l)\r\n    path.append(new[final])\r\n    shortestNumberedPath(l, new[initial], new[final], path)\r\n    path.reverse()\r\n    current = initial\r\n    while(True):\r\n        if current == final:\r\n            return shortest\r\n        for j in graph[current]:\r\n            if not tuple(j) in visited:\r\n                if new[tuple(j)] == new[current]:\r\n                    current = tuple(j)\r\n                    shortest.append(current)\r\n                    visited.append(current)\r\n                    break\r\n                else:\r\n                    if new[tuple(j)] == path[count]:\r\n                        count += 1\r\n                        shortest.append(tuple(j))\r\n                        current = tuple(j)\r\n                        visited.append(current)\r\n                        break\r\n\r\n    #################################################################################\r\n    return shortest\r\n\r\n##  This is the main function where all other functions are called. It accepts filepath\r\n##  of an image as input. You are not allowed to change any code in this function. You are\r\n##  You are only allowed to change the parameters of the buildGraph, findStartPoint and findPath functions\r\ndef main(filePath, flag = 0):\r\n    img = readImage(filePath)     ## Read image with specified filepath\r\n    if len(img) == 440:           ## Dimensions of smaller maze image are 440x440\r\n        size = 1\r\n    else:\r\n        size = 2\r\n    maze_graph = buildGraph(img, size)   ## Build graph from maze image. Pass arguments as required\r\n    start = findStartPoint(img, size)  ## Returns the coordinates of the start of the maze\r\n    shortestPath = findPath(maze_graph, start, (0, 0))  ## Find shortest path. Pass arguments as required.\r\n    print shortestPath\r\n    string = str(shortestPath) + ""\\n""\r\n    for i in shortestPath:               ## Loop to paint the solution path.\r\n        img = colourCell(img, i[0], i[1], size, 230)\r\n    if __name__ == \'__main__\':     ## Return value for main() function.\r\n        return img\r\n    else:\r\n        if flag == 0:\r\n            return string\r\n        else:\r\n            return graph\r\n## The main() function is called here. Specify the filepath of image in the space given.\r\nif __name__ == ""__main__"":\r\n    filepath = ""image_07.jpg""     ## File path for test image\r\n    img = main(filepath)          ## Main function call\r\n    cv2.imshow(""image"",img)\r\n    cv2.waitKey(0)\r\n    cv2.destroyAllWindows()\r\n'"
