file_path,api_count,code
setup.py,0,"b""import os\n\nfrom setuptools import find_packages, setup\n\nhere = os.path.abspath(os.path.dirname(__file__))\nmeta_info = {}\nwith open(os.path.join(here, 'nptyping', '_meta.py'),\n          mode='r', encoding='utf-8') as f:\n    exec(f.read(), meta_info)\n\nwith open('README.md', mode='r', encoding='utf-8') as f:\n    long_description = f.read()\n\nrequirements = [\n    'numpy',\n    'typish>=1.5.2',\n],\n\ntest_requirements = [\n    'pycodestyle',\n    'pylint',\n    'pytest',\n    'coverage',\n    'codecov',\n]\n\nextras = {\n    'test': test_requirements,\n}\n\nsetup(\n    name=meta_info['__title__'],\n    version=meta_info['__version__'],\n    author=meta_info['__author__'],\n    author_email=meta_info['__author_email__'],\n    description=meta_info['__description__'],\n    url=meta_info['__url__'],\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    license=meta_info['__license__'],\n    packages=find_packages(exclude=('tests', 'test_resources')),\n    install_requires=requirements,\n    tests_require=test_requirements,\n    extras_require=extras,\n    python_requires='>=3.5',\n    test_suite='tests',\n    zip_safe=False,\n    classifiers=[\n        'Intended Audience :: Developers',\n        'License :: OSI Approved :: MIT License',\n        'Operating System :: OS Independent',\n        'Natural Language :: English',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.5',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8'\n    ]\n)\n"""
nptyping/__init__.py,0,"b'from nptyping._meta import __version__\nfrom nptyping.functions._get_type import get_type\nfrom nptyping.functions._py_type import py_type\nfrom nptyping.types._ndarray import NDArray\nfrom nptyping.types._nptype import NPType\nfrom nptyping.types._number import (\n    DEFAULT_INT_BITS,\n    DEFAULT_FLOAT_BITS,\n    Number,\n    Int,\n    Float,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    UInt,\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Float16,\n    Float32,\n    Float64,\n)\nfrom nptyping.types._object import Object\nfrom nptyping.types._unicode import Unicode\n'"
nptyping/_meta.py,0,"b""__title__ = 'nptyping'\n__version__ = '1.1.0'\n__author__ = 'Ramon Hagenaars'\n__author_email__ = 'ramon.hagenaars@gmail.com'\n__description__ = 'Type hints for Numpy.'\n__url__ = 'https://github.com/ramonhagenaars/nptyping'\n__license__ = 'MIT'\n"""
tests/__init__.py,0,b''
nptyping/functions/__init__.py,0,b''
nptyping/functions/_get_type.py,0,"b'from typing import Any, Type, Dict\n\nimport numpy\nfrom typish import ClsFunction\n\nfrom nptyping.functions._py_type import py_type\nfrom nptyping.types._ndarray import NDArray\nfrom nptyping.types._nptype import NPType\nfrom nptyping.types._number import (\n    Int,\n    Float,\n    UInt,\n    Number,\n    DEFAULT_INT_BITS,\n    DEFAULT_FLOAT_BITS\n)\nfrom nptyping.types._object import Object\nfrom nptyping.types._unicode import Unicode\n\n\ndef get_type(obj: Any) -> Type[\'NPType\']:\n    """"""\n    Return the nptyping type of the given obj. The given obj can be a numpy\n    ndarray, a dtype or a Python type. If no corresponding nptyping type\n    can be determined, a TypeError is raised.\n    :param obj: the object for which an nptyping type is to be returned.\n    :return: a subclass of NPType.\n    """"""\n    function = ClsFunction([\n        (NPType, lambda x: x),\n        (type, _get_type_type),\n        (int, get_type_int),\n        (float, get_type_float),\n        (str, get_type_str),\n        (numpy.dtype, _get_type_dtype),\n        (numpy.ndarray, _get_type_arrary),\n        (numpy.signedinteger, get_type_int),\n        (numpy.unsignedinteger, get_type_uint),\n        (numpy.floating, get_type_float),\n    ])\n\n    if not function.understands(obj):\n        raise TypeError(\'Type ""{}"" not understood.\'.format(type(obj).__name__))\n\n    return function(obj)\n\n\ndef _get_type_type(type_: type) -> Type[\'NPType\']:\n    # Return the nptyping type of a type.\n\n    delegates = [\n        (NPType, lambda x: x),\n        (str, get_type_str),\n        (int, get_type_int),\n        (float, get_type_float),\n        (numpy.signedinteger, get_type_int),\n        (numpy.unsignedinteger, get_type_uint),\n        (numpy.floating, get_type_float),\n        (object, lambda _: Object),\n    ]\n\n    for super_type, delegate in delegates:\n        if issubclass(type_, super_type):\n            break\n    return delegate(type_)\n\n\ndef _get_type_dtype(dtype: numpy.dtype) -> Type[\'NPType\']:\n    # Return the nptyping type of a numpy dtype.\n    np_type_per_py_type = {\n        type: _get_type_type,\n        int: get_type_int,\n        float: get_type_float,\n        str: get_type_str,\n        object: lambda _: Object,\n    }\n    return np_type_per_py_type[(py_type(dtype))](dtype)\n\n\ndef _get_type_arrary(arr: numpy.ndarray) -> Type[\'NPType\']:\n    # Return the nptyping type of a numpy array.\n    type_ = get_type(arr.dtype)\n    return NDArray[arr.shape, type_]\n\n\ndef _get_type_of_number(\n        cls: Type[\'Number\'],\n        obj: Any,\n        bits_per_type: Dict[type, int]) -> Type[Number]:\n    # Return the nptyping Number type of the given obj using cls and\n    # bits_per_type.\n    bits = (bits_per_type.get(obj)\n            or bits_per_type.get(getattr(obj, \'type\', None))\n            or bits_per_type.get(type(obj)))\n\n    if not bits:\n        raise TypeError(\'Unsupported type {} for {}\'\n                        .format(type(obj).__name__, cls))\n\n    return cls[bits]\n\n\n# Library private.\ndef get_type_str(obj: Any) -> Type[Unicode]:\n    """"""\n    Return the NPType that corresponds to obj.\n    :param obj: a string compatible object.\n    :return: a Unicode type.\n    """"""\n    if isinstance(obj, numpy.dtype):\n        return Unicode[obj.itemsize / 4]\n    if obj == str:\n        return Unicode\n    if not isinstance(obj, str):\n        raise TypeError(\'Unsupported type {}\'.format(type(obj)))\n    return Unicode[len(obj)]\n\n\n# Library private.\ndef get_type_int(obj: Any) -> Type[Int]:\n    """"""\n    Return the NPType that corresponds to obj.\n    :param obj: an int compatible object.\n    :return: a Int type.\n    """"""\n    return _get_type_of_number(Int, obj, {\n        numpy.int8: 8,\n        numpy.int16: 16,\n        numpy.int32: 32,\n        numpy.int64: 64,\n        int: DEFAULT_INT_BITS,\n    })\n\n\n# Library private.\ndef get_type_uint(obj: Any) -> Type[UInt]:\n    """"""\n    Return the NPType that corresponds to obj.\n    :param obj: an uint compatible object.\n    :return: an UInt type.\n    """"""\n    return _get_type_of_number(UInt, obj, {\n        numpy.uint8: 8,\n        numpy.uint16: 16,\n        numpy.uint32: 32,\n        numpy.uint64: 64,\n        int: DEFAULT_INT_BITS,\n    })\n\n\n# Library private.\ndef get_type_float(obj: Any) -> Type[Float]:\n    """"""\n    Return the NPType that corresponds to obj.\n    :param obj: a float compatible object.\n    :return: a Float type.\n    """"""\n    return _get_type_of_number(Float, obj, {\n        numpy.float16: 16,\n        numpy.float32: 32,\n        numpy.float64: 64,\n        float: DEFAULT_FLOAT_BITS,\n    })\n'"
nptyping/functions/_py_type.py,5,"b'from typing import Union, Any\n\nimport numpy as np\nfrom typish import ClsFunction, Literal\n\n\ndef py_type(np_type: Union[np.dtype, type, Literal[Any]]) -> type:\n    """"""\n    Return the Python equivalent type of a numpy type. Throw a KeyError if no\n    match is found for the given type. If the given np_type is not a type, it\n    is attempted to create a numpy.dtype for it. Any error that is raised\n    during this, is also raised by this function.\n\n    Example:\n\n    >>> py_type(np.int32)\n    <class \'int\'>\n\n    :param np_type: a numpy type (dtype).\n    :return: a Python builtin type.\n    """"""\n    np_type = (np.dtype(np_type) if not isinstance(np_type, np.dtype)\n               else np_type)\n    function = ClsFunction({\n        np.dtype: lambda x: _TYPE_PER_KIND[x.kind],\n        type: lambda x: py_type(np.dtype(x)),\n    })\n    return function(np_type)\n\n\n_TYPE_PER_KIND = {\n    \'i\': int,\n    \'f\': float,\n    \'U\': str,\n    \'O\': object,\n}\n'"
nptyping/types/__init__.py,0,b''
nptyping/types/_ndarray.py,3,"b'from typing import Type\n\nimport numpy as np\n\nfrom nptyping.types._ndarray_meta import _NDArray\n\n\nclass NDArray(np.ndarray, _NDArray):\n    """"""\n    NDArray is a representation of numpy.ndarray.\n\n    An Array with any dimensions of any size and any type:\n    >>> NDArray\n    NDArray[(typing.Any, ...), typing.Any]\n\n    An array with 1 dimension of any size and any type:\n    >>> from typing import Any\n    >>> from nptyping import Int64\n    >>> NDArray[Any]\n    NDArray[(typing.Any,), typing.Any]\n\n    An array with 1 dimension of size 3 and any type:\n    >>> NDArray[3]\n    NDArray[(3,), typing.Any]\n\n    An array with any dimensions of any size and type int:\n    >>> NDArray[Int64]\n    NDArray[(typing.Any, ...), Int[64]]\n\n    An array with 1 dimension of size 3 and type int:\n    >>> NDArray[3, Int64]\n    NDArray[(3,), Int[64]]\n\n    An array with any dimensions of size 3 and type int:\n    >>> NDArray[(3, ...), Int64]\n    NDArray[(3, ...), Int[64]]\n\n    An array with 3 dimensions of sizes 3, 3, 5 and type int:\n    >>> NDArray[(3, 3, 5), Int64]\n    NDArray[(3, 3, 5), Int[64]]\n\n    """"""\n\n    # These variables are to let typish know to use the custom checks.\n    __instancecheck__ = None\n    __subclasscheck__ = None\n\n    @staticmethod\n    def type_of(arr: np.ndarray) -> Type[\'NDArray\']:\n        """"""\n        Return an nptyping.NDArray type T such that isinstance(arr, T).\n\n        >>> NDArray.type_of(np.array([[1, 2], [3, 4.0]]))\n        NDArray[(2, 2), Float[64]]\n\n        :param arr: any numpy.ndarray.\n        :return: a nptyping.NDArray.\n        """"""\n        return NDArray[arr.shape, arr.dtype]\n'"
nptyping/types/_ndarray_meta.py,1,"b'from collections import OrderedDict\nfrom typing import Any, Tuple, Union\n\nimport numpy as np\nfrom typish import SubscriptableType, Literal, ClsFunction, EllipsisType\n\nfrom nptyping.types._nptype import NPType\n\n_Size = Union[int, Literal[Any]]  # TODO add type vars as well\n_Type = Union[type, Literal[Any], np.dtype]\n_NSizes = Tuple[_Size, EllipsisType]\n_SizeAndType = Tuple[_Size, _Type]\n_Sizes = Tuple[_Size, ...]\n_SizesAndType = Tuple[Tuple[_Size, ...], _Type]\n_NSizesAndType = Tuple[_NSizes, _Type]\n_Default = Tuple[Tuple[Literal[Any], EllipsisType], Literal[Any]]\n\n# The types below are for Python 3.5 compatibility. Union[Literal[Any], type]\n# is translated to Union[type], because of Literal inheriting from type.\n_SizeAndTypeAny = Tuple[_Size, Literal[Any]]\n_SizesAndTypeAny = Tuple[Tuple[_Size, ...], Literal[Any]]\n_NSizesAndTypeAny = Tuple[_NSizes, Literal[Any]]\n\n\ndef _is_eq_to(this: Any, that: Any) -> bool:\n    return that is Any or this == that\n\n\nclass _NDArrayMeta(SubscriptableType):\n    _shape = tuple()  # type: Union[Tuple[int, ...], Tuple[int, EllipsisType]]\n    _type = ...  # type: Union[type, Literal[Any]]\n\n    @property\n    def shape(cls) -> Tuple[int, ...]:\n        """"""\n        Return the shape as a tuple of ints.\n        :return: the shape as a tuple of ints.\n        """"""\n        return cls._shape\n\n    def __repr__(cls) -> str:\n        shape_ = cls._shape\n        if len(cls._shape) == 2 and cls._shape[1] is ...:\n            shape_ = (cls._shape[0], \'...\')\n\n        return \'NDArray[{}, {}]\'.format(shape_, cls._type).replace(\'\\\'\', \'\')\n\n    def __str__(cls) -> str:\n        return repr(cls)\n\n    def __eq__(cls, other: object) -> bool:\n        return (isinstance(other, _NDArrayMeta)\n                and cls._shape == other._shape\n                and _is_eq_to(cls._type, other._type))\n\n    def __instancecheck__(cls, instance: Any) -> bool:\n        """"""\n        Check whether the given instance conforms the current NDArray type by\n        checking the shape and the dtype.\n        :param instance: the instance that is checked.\n        :return: True if instance is an instance of cls.\n        """"""\n        return _NDArrayMeta.__subclasscheck__(\n            cls, _NDArray[instance.shape, instance.dtype])\n\n    def __subclasscheck__(cls, subclass: type) -> bool:\n        """"""\n        Check whether the given class is a sub class of cls.\n        :param subclass: the class that is to be checked.\n        :return: True if subclass is a sub class of cls.\n        """"""\n        return (subclass == cls\n                or (isinstance(subclass, _NDArrayMeta)\n                    and cls._is_dtype_eq(subclass._type)  # pylint: disable=no-value-for-parameter # noqa\n                    and cls._is_shape_eq(subclass.shape)))  # pylint: disable=no-value-for-parameter # noqa\n\n    def __hash__(cls) -> int:\n        """"""\n        Hash this _NDArrayMeta by means of its attributes.\n        :return: a hash (int).\n        """"""\n        return hash((cls._shape, cls._type))\n\n    def _is_shape_eq(cls, shape: Tuple[int, ...]) -> bool:\n        if cls._shape == (Any, ...):\n            return True\n        if len(cls._shape) == 2 and cls._shape[1] is ...:\n            size = cls._shape[0]\n            return all([s == size for s in shape])\n        if len(shape) != len(cls._shape):\n            return False\n        zipped = zip(shape, cls._shape)\n        return all([_is_eq_to(a, b) for a, b in zipped])\n\n    def _is_dtype_eq(cls, nptype: NPType) -> bool:\n        return cls._type is Any or issubclass(nptype, cls._type)\n\n\nclass _NDArray(NPType, metaclass=_NDArrayMeta):\n    _shape = (Any, ...)  # type: Union[Tuple[int, ...], Tuple[Any, EllipsisType]]  # noqa\n    _type = Any\n\n    @classmethod\n    def _after_subscription(cls, item: Any) -> None:\n        method = ClsFunction(OrderedDict([\n            (_Size, cls._only_size),\n            (_Type, cls._only_type),\n            (_NSizes, lambda _: ...),\n            (_SizeAndType, cls._size_and_type),\n            (_SizeAndTypeAny, cls._size_and_type),  # For Python 3.5.\n            (_Sizes, cls._only_sizes),\n            (_SizesAndType, cls._sizes_and_type),\n            (_SizesAndTypeAny, cls._sizes_and_type),  # For Python 3.5.\n            (_NSizesAndType, cls._sizes_and_type),\n            (_NSizesAndTypeAny, cls._sizes_and_type),  # For Python 3.5.\n            (_Default, lambda _: ...),\n        ]))\n\n        if not method.understands(item):\n            raise TypeError(\'Invalid parameter for NDArray: ""{}""\'.format(item))\n        method(item)\n\n    @classmethod\n    def _only_size(cls, item: int) -> None:\n        # E.g. NDArray[3]\n        # The given item is the size of the single dimension.\n        cls._shape = (item,)\n\n    @classmethod\n    def _only_type(cls, item: type) -> None:\n        # E.g. NDArray[int]\n        # The given item is the type of the single dimension.\n        from nptyping import get_type  # Put here to prevent cyclic import.\n        cls._type = Any if item is Any else get_type(item)\n\n    @classmethod\n    def _size_and_type(cls, item: Tuple[_Size, _Type]) -> None:\n        # E.g. NDArray[3, int]\n        # The given item is the size of the single dimension and its type.\n        cls._shape = (item[0],)\n        cls._only_type(item[1])\n\n    @classmethod\n    def _only_sizes(cls, item: Tuple[_Size, ...]) -> None:\n        # E.g. NDArray[(2, Any, 2)]\n        # The given item is a tuple with just sizes of the dimensions.\n        cls._shape = item\n\n    @classmethod\n    def _sizes_and_type(cls, item: Tuple[Tuple[_Size, ...], _Type]) -> None:\n        # E.g. NDArray[(2, Any, 2), int]\n        # The given item is a tuple with sizes of the dimensions and the type.\n        # Or e.g. NDArray[(3, ...), int]\n        # The given item is a tuple with sizes of n dimensions and the type.\n        cls._only_sizes(item[0])\n        cls._only_type(item[1])\n'"
nptyping/types/_nptype.py,0,"b'from typish import SubscriptableType\n\n\nclass NPType:\n    """"""\n    The baseclass of all nptyping types.\n    """"""\n\n\nclass SimpleNPTypeMeta(SubscriptableType):\n    """"""\n    A metaclass for all simple NPTypes (e.g. float, int, etc.).\n    """"""\n    def __repr__(cls):\n        repr_args = getattr(cls, \'_repr_args\', None)\n        if not repr_args:\n            return cls.__name__\n        return \'{}[{}]\'.format(cls.__name__, repr_args)\n\n    __str__ = __repr__\n'"
nptyping/types/_number.py,0,"b'from typing import Any, Union, Type\n\nimport numpy\nfrom typish import Literal, get_mro\n\nfrom nptyping.types._nptype import NPType, SimpleNPTypeMeta\n\nDEFAULT_INT_BITS = numpy.dtype(int).itemsize * 8\nDEFAULT_FLOAT_BITS = numpy.dtype(float).itemsize * 8\n\n\nclass _NumberMeta(SimpleNPTypeMeta):\n    """"""\n    Super metaclass for the Number class.\n    """"""\n    base = None\n    npbase = None\n    _bits = None\n    _hashes = {}\n    _repr_args = None\n\n    def __eq__(cls, other):\n        return hash(cls) == hash(other)\n\n    def __hash__(cls):\n        key = (cls.base, cls.npbase, cls._bits)\n        if key not in cls._hashes:\n            cls._hashes[key] = int(numpy.prod([hash(elem) for elem in key]))\n        return cls._hashes[key]\n\n    def __instancecheck__(cls, instance: Any) -> bool:\n        from nptyping.functions._get_type import get_type\n\n        if cls == instance or type(instance) in (int, float):\n            # Covers Python types.\n            return True\n\n        return issubclass(get_type(instance), cls)\n\n    def __subclasscheck__(cls, subclass: type) -> bool:\n        result = False\n        if cls == subclass:\n            result = True\n        elif _is_a(subclass, Number):\n            # Cover nptyping number types.\n            result = _is_number_subclass_of(subclass, cls)\n        elif (issubclass(subclass, numpy.number)\n              or issubclass(subclass, int)\n              or issubclass(subclass, float)):\n            result = _is_numpy_or_python_type_subclass_of(subclass, cls)\n        return result\n\n\nclass Number(NPType, metaclass=_NumberMeta):\n    """"""\n    Superclass for number types (integers and floating point numbers). Can be\n    optionally given the number of bits.\n    """"""\n    base = None\n    npbase = None\n    _bits = None\n    _repr_args = None\n\n    @classmethod\n    def _after_subscription(cls, args: Any) -> None:\n        if isinstance(args, tuple):\n            cls.base = args[0]\n            cls.npbase = args[1]\n            return\n\n        if not isinstance(args, int):\n            raise TypeError(\'Number takes only an int as generic type. \'\n                            \'Given: {}\'.format(type(args).__name__))\n\n        cls._bits = args\n        cls._repr_args = args\n\n        if not hasattr(numpy, \'{}{}\'.format(cls.base.__name__, cls._bits)):\n            raise TypeError(\'Unsupported number of bits: {}\'.format(args))\n\n    @classmethod\n    def bits(cls) -> Union[int, Literal[Any]]:\n        """"""\n        Return the number of bits of this Number type.\n        :return: the number of bits or Any.\n        """"""\n        return cls._bits\n\n\nclass Int(Number[int, numpy.signedinteger]):\n    """"""\n    A (signed) numpy int. Can be given the number of bits optionally.\n\n    >>> Int[32]\n    Int[32]\n    """"""\n\n    @classmethod\n    def type_of(cls, obj: Any) -> Type[\'Int\']:\n        """"""\n        Return the NPType that corresponds to obj.\n        :param obj: an int compatible object.\n        :return: a Int type.\n        """"""\n        from nptyping.functions._get_type import get_type_int\n        return get_type_int(obj)\n\n    @staticmethod\n    def fitting(number: int) -> Type[\'Int\']:\n        """"""\n        Return the Int type that fits the given number.\n        :param number: the number of which the Int type is to be found.\n        :return: a type of Int.\n        """"""\n        bitlen = number.bit_length()\n        for bits in [8, 16, 32, 64]:\n            if bitlen <= bits - 1:  # subtract sign bit.\n                break\n        return Int[bits]\n\n\nclass UInt(Number[int, numpy.unsignedinteger]):\n    """"""\n    An unsigned numpy int. Can be given the number of bits optionally.\n\n    >>> UInt[32]\n    UInt[32]\n    """"""\n\n    @classmethod\n    def type_of(cls, obj: Any) -> Type[\'UInt\']:\n        """"""\n        Return the NPType that corresponds to obj.\n        :param obj: an uint compatible object.\n        :return: an UInt type.\n        """"""\n        from nptyping.functions._get_type import get_type_uint\n        return get_type_uint(obj)\n\n    @staticmethod\n    def fitting(number: int) -> Type[\'UInt\']:\n        """"""\n        Return the UInt type that fits the given number.\n        :param number: the number of which the UInt type is to be found.\n        :return: a type of UInt.\n        """"""\n        bitlen = number.bit_length()\n        for bits in [8, 16, 32, 64]:\n            if bitlen <= bits:\n                break\n        return UInt[bits]\n\n\nclass Float(Number[float, numpy.floating]):\n    """"""\n    A numpy float. Can be given the number of bits optionally.\n\n    >>> Float[32]\n    Float[32]\n    """"""\n\n    @staticmethod\n    def type_of(obj: Any) -> Type[\'Float\']:\n        """"""\n        Return the NPType that corresponds to obj.\n        :param obj: a float compatible object.\n        :return: a Float type.\n        """"""\n        from nptyping.functions._get_type import get_type_float\n        return get_type_float(obj)\n\n\ndef _is_a(this: Any, that: type) -> bool:\n    # Return whether this is a subclass of that, considering the mro.\n    return that in get_mro(this)\n\n\ndef _is_number_subclass_of(\n        subclass: Type[Number],\n        superclass: Type[Number]) -> bool:\n    # Return whether subclass (which must be a type of Number) subclasses\n    # superclass.\n    base_is_eq = (not superclass.npbase\n                  or issubclass(subclass.npbase, superclass.npbase))\n    bits_is_eq = not superclass.bits() or subclass.bits() == superclass.bits()\n    return base_is_eq and bits_is_eq\n\n\ndef _is_numpy_or_python_type_subclass_of(\n        subclass: Any,\n        superclass: Type[Number]) -> bool:\n    # Return whether subclass (which must be a numpy type or a Python type)\n    # subclasses superclass.\n    if not superclass.npbase:\n        # superclass is Number.\n        result = True\n    else:\n        try:\n            nptype = superclass.type_of(subclass)\n        except TypeError:\n            result = False\n        else:\n            result = issubclass(nptype, superclass)\n    return result\n\n\nInt8 = Int[8]\nInt16 = Int[16]\nInt32 = Int[32]\nInt64 = Int[64]\n\nUInt8 = UInt[8]\nUInt16 = UInt[16]\nUInt32 = UInt[32]\nUInt64 = UInt[64]\n\nFloat16 = Float[16]\nFloat32 = Float[32]\nFloat64 = Float[64]\n'"
nptyping/types/_object.py,0,"b'from nptyping.types._nptype import NPType\n\n\nclass _ObjectMeta(type):\n    def __repr__(cls):\n        return \'Object\'\n\n    __str__ = __repr__\n\n\nclass Object(NPType, metaclass=_ObjectMeta):\n    """"""\n    Corresponds to numpy.object.\n    """"""\n'"
nptyping/types/_unicode.py,0,"b'from typing import Any, Type\n\nfrom typish import get_mro\n\nfrom nptyping.types._nptype import NPType, SimpleNPTypeMeta\n\n\nclass _UnicodeMeta(SimpleNPTypeMeta):\n    def __eq__(cls, other: Any) -> bool:\n        return hash(cls) == hash(other)\n\n    def __hash__(cls: Any) -> int:\n        return hash(cls.__name__) * hash(cls.chars)\n\n    def __instancecheck__(cls, instance: Any) -> bool:\n        from nptyping.functions._get_type import get_type_str\n        try:\n            unicode = get_type_str(instance)\n        except TypeError:\n            return False\n        return issubclass(unicode, cls)\n\n    def __subclasscheck__(cls, subclass: type) -> bool:\n        if Unicode in get_mro(subclass):\n            return cls.chars is Any or subclass.chars <= cls.chars\n        return False\n\n\nclass Unicode(NPType, metaclass=_UnicodeMeta):\n    """"""\n    A numpy unicode. Can be given the number of characters optionally.\n\n    >>> Unicode[50]\n    Unicode[50]\n    """"""\n    chars = Any\n    _repr_args = None\n\n    @classmethod\n    def _after_subscription(cls, args: Any) -> None:\n        cls.chars = int(args)\n        cls._repr_args = int(args)\n\n    @classmethod\n    def type_of(cls, obj: Any) -> Type[\'Unicode\']:\n        """"""\n        Return the NPType that corresponds to obj.\n        :param obj: a string compatible object.\n        :return: a Unicode type.\n        """"""\n        from nptyping.functions._get_type import get_type_str\n        return get_type_str(obj)\n'"
tests/test_functions/__init__.py,0,b''
tests/test_functions/test_get_type.py,26,"b""from unittest import TestCase\n\nimport numpy as np\n\nfrom nptyping import (\n    get_type,\n    Int32,\n    Float64,\n    Int8,\n    Int16,\n    Int64,\n    UInt8,\n    UInt16,\n    UInt32,\n    UInt64,\n    Float16,\n    Float32,\n    NDArray,\n    Int,\n    DEFAULT_INT_BITS,\n    DEFAULT_FLOAT_BITS,\n    Float,\n)\nfrom nptyping.types._object import Object\nfrom nptyping.types._unicode import Unicode\n\n\nclass TestGetType(TestCase):\n\n    def test_get_type_int(self):\n        self.assertEqual(Int[DEFAULT_INT_BITS], get_type(42))\n\n    def test_get_type_float(self):\n        self.assertEqual(Float[DEFAULT_FLOAT_BITS], get_type(42.0))\n\n    def test_get_type_str(self):\n        self.assertEqual(Unicode[4], get_type('Test'))\n\n    def test_get_type_nptype(self):\n        self.assertEqual(Int32, get_type(Int32))\n        self.assertEqual(Float64, get_type(Float64))\n        self.assertEqual(Unicode[100], get_type(Unicode[100]))\n\n    def test_get_type_numpy_dtype(self):\n        self.assertEqual(Int8, get_type(np.int8(42)))\n        self.assertEqual(Int16, get_type(np.int16(42)))\n        self.assertEqual(Int32, get_type(np.int32(42)))\n        self.assertEqual(Int64, get_type(np.int64(42)))\n\n        self.assertEqual(UInt8, get_type(np.uint8(42)))\n        self.assertEqual(UInt16, get_type(np.uint16(42)))\n        self.assertEqual(UInt32, get_type(np.uint32(42)))\n        self.assertEqual(UInt64, get_type(np.uint64(42)))\n\n        self.assertEqual(Float16, get_type(np.float16(42.0)))\n        self.assertEqual(Float32, get_type(np.float32(42.0)))\n        self.assertEqual(Float64, get_type(np.float64(42.0)))\n\n        self.assertEqual(Unicode, get_type(np.unicode))\n        self.assertEqual(Unicode[40], get_type(np.dtype(('U', 40))))\n\n    def test_get_type_numpy_type(self):\n        self.assertEqual(Int8, get_type(np.int8))\n        self.assertEqual(Int16, get_type(np.int16))\n        self.assertEqual(Int32, get_type(np.int32))\n        self.assertEqual(Int64, get_type(np.int64))\n\n        self.assertEqual(UInt8, get_type(np.uint8))\n        self.assertEqual(UInt16, get_type(np.uint16))\n        self.assertEqual(UInt32, get_type(np.uint32))\n        self.assertEqual(UInt64, get_type(np.uint64))\n\n        self.assertEqual(Float16, get_type(np.float16))\n        self.assertEqual(Float32, get_type(np.float32))\n        self.assertEqual(Float64, get_type(np.float64))\n\n    def test_get_type_object(self):\n        self.assertEqual(Object, get_type(np.object))\n\n    def test_get_type_array(self):\n        self.assertEqual(NDArray[3, Int[DEFAULT_INT_BITS]], get_type(np.array([1, 2, 3])))\n\n    def test_get_type_not_understood(self):\n        class SomeRandomClass:\n            ...\n\n        # Test invalid instances.\n        with self.assertRaises(TypeError) as err:\n            get_type(SomeRandomClass())\n        self.assertIn(SomeRandomClass.__name__, str(err.exception))\n"""
tests/test_functions/test_py_type.py,12,"b'from unittest import TestCase\n\nimport numpy as np\n\nfrom nptyping import py_type\n\n\nclass TestPyType(TestCase):\n\n    def test_py_type(self):\n        self.assertIs(int, py_type(np.dtype(int)))\n        self.assertIs(str, py_type(np.dtype(str)))\n        self.assertIs(object, py_type(np.dtype(object)))\n        self.assertIs(float, py_type(np.dtype(float)))\n\n        self.assertIs(int, py_type(np.int))\n        self.assertIs(int, py_type(np.int16))\n        self.assertIs(int, py_type(np.int32))\n        self.assertIs(int, py_type(np.int64))\n\n        self.assertIs(float, py_type(np.float))\n        self.assertIs(float, py_type(np.float16))\n        self.assertIs(float, py_type(np.float32))\n        self.assertIs(float, py_type(np.float64))\n'"
tests/test_types/__init__.py,0,b''
tests/test_types/test_ndarray.py,19,"b""from typing import Any, Optional\nfrom unittest import TestCase\n\nimport numpy as np\n\nfrom nptyping import NDArray, DEFAULT_INT_BITS, Int\n\n\nclass TestNDArray(TestCase):\n\n    def test_initialize_with_nothing(self):\n        self.assertEqual((Any, ...), NDArray.shape)\n        self.assertEqual(Any, NDArray._type)\n        self.assertEqual((Any, ...), NDArray[(Any, ...)].shape)\n        self.assertEqual(Any, NDArray[(Any, ...)]._type)\n        self.assertEqual((Any, ...), NDArray[(Any, ...), Any].shape)\n        self.assertEqual(Any, NDArray[(Any, ...), Any]._type)\n\n    def test_initialize_with_size(self):\n        self.assertEqual(1, len(NDArray[5].shape))\n        self.assertEqual(5, NDArray[5].shape[0])\n        self.assertEqual(Any, NDArray[5]._type)\n        self.assertEqual(NDArray[5], NDArray[(5,)])\n        self.assertEqual(NDArray[5], NDArray[(5,), Any])\n\n    def test_initialize_with_any_size(self):\n        self.assertEqual(1, len(NDArray[Any].shape))\n        self.assertEqual(Any, NDArray[Any].shape[0])\n        self.assertEqual(Any, NDArray[Any]._type)\n\n    def test_initialize_with_type(self):\n        self.assertEqual((Any, ...), NDArray[int].shape)\n        self.assertEqual(Int[DEFAULT_INT_BITS], NDArray[int]._type)\n\n    def test_initialize_with_size_and_type(self):\n        self.assertEqual(1, len(NDArray[3, int].shape))\n        self.assertEqual(3, NDArray[3, int].shape[0])\n        self.assertEqual(Int[DEFAULT_INT_BITS], NDArray[3, int]._type)\n\n    def test_initialize_with_only_sizes(self):\n        self.assertEqual(3, len(NDArray[(2, 4, Any)].shape))\n        self.assertEqual(2, NDArray[(2, 4, Any)].shape[0])\n        self.assertEqual(4, NDArray[(2, 4, Any)].shape[1])\n        self.assertEqual(Any, NDArray[(2, 4, Any)].shape[2])\n        self.assertEqual(Any, NDArray[(2, 4, Any)]._type)\n        self.assertEqual(NDArray[(2, 4, Any)], NDArray[2, 4, Any])\n\n    def test_initialize_with_sizes_and_type(self):\n        self.assertEqual(3, len(NDArray[(2, 4, Any), int].shape))\n        self.assertEqual(2, NDArray[(2, 4, Any), int].shape[0])\n        self.assertEqual(4, NDArray[(2, 4, Any), int].shape[1])\n        self.assertEqual(Any, NDArray[(2, 4, Any), int].shape[2])\n        self.assertEqual(Int[DEFAULT_INT_BITS], NDArray[(2, 4, Any), int]._type)\n\n    def test_initialize_with_sizes_and_dtype(self):\n        arr = NDArray[(2, 4, Any), np.dtype(int)]\n\n        self.assertEqual(3, len(arr.shape))\n        self.assertEqual(2, arr.shape[0])\n        self.assertEqual(4, arr.shape[1])\n        self.assertEqual(Any, arr.shape[2])\n        self.assertEqual(Int[DEFAULT_INT_BITS], arr._type)\n\n    def test_initialize_with_ndims(self):\n        self.assertEqual((2, ...), NDArray[(2, ...), int].shape)\n\n    def test_with_any_and_any(self):\n        array_str = repr(NDArray[Any, Any])\n        expected = 'NDArray[(typing.Any,), typing.Any]'\n        self.assertEqual(expected, array_str)\n\n    def test_invalid_initialization(self):\n        with self.assertRaises(TypeError):\n            NDArray['test']\n        with self.assertRaises(TypeError):\n            NDArray[(2, '2'), int]\n        with self.assertRaises(TypeError):\n            NDArray[(2, 2), 'int']\n        with self.assertRaises(TypeError):\n            NDArray[(2, 2, ...), int]\n\n    def test_instance_check_dimension_sizes(self):\n        arr2x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n        arr1x2x2 = np.array([[[1, 2], [3, 4]]])\n        arr3x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])\n        arr2x2 = np.array([[1, 2], [3, 4]])\n\n        self.assertTrue(isinstance(arr2x2x2, NDArray[(2, 2, 2), int]))\n        self.assertTrue(not isinstance(arr1x2x2, NDArray[(2, 2, 2), int]))\n        self.assertTrue(not isinstance(arr3x2x2, NDArray[(2, 2, 2), int]))\n        self.assertTrue(not isinstance(arr2x2, NDArray[(2, 2, 2), int]))\n\n    def test_instance_check_dimension_any(self):\n        arr3x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]], [[9, 10], [11, 12]]])\n        arr2x2 = np.array([[1, 2], [3, 4]])\n\n        self.assertTrue(isinstance(arr3x2x2, NDArray))\n        self.assertTrue(isinstance(arr2x2, NDArray))\n        self.assertTrue(isinstance(arr3x2x2, NDArray[int]))\n        self.assertTrue(isinstance(arr2x2, NDArray[int]))\n\n    def test_instance_check_types(self):\n        arr2x2x2_float = np.array([[[1.0, 2.0], [3.0, 4.0]],\n                                  [[5.0, 6.0], [7.0, 8.0]]])\n        arr2x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n\n        self.assertTrue(isinstance(arr2x2x2_float, NDArray[(2, 2, 2), float]))\n        self.assertTrue(not isinstance(arr2x2x2, NDArray[(2, 2, 2), str]))\n\n    def test_instance_check_types_any(self):\n        arr2x2x2_float = np.array([[[1.0, 2.0], [3.0, 4.0]],\n                                  [[5.0, 6.0], [7.0, 8.0]]])\n        arr2x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n        arr2x2 = np.array([[1, 2], [3, 4]])\n\n        self.assertTrue(isinstance(arr2x2x2, NDArray[(2, 2, 2)]))\n        self.assertTrue(isinstance(arr2x2x2_float, NDArray[(2, 2, 2)]))\n        self.assertTrue(not isinstance(arr2x2, NDArray[(2, 2, 2)]))\n\n    def test_instance_check_ndims(self):\n        arr2x2x2 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n        arr2x2 = np.array([[1, 2], [3, 4]])\n        arr3x2x2 = np.array([[[1, 2], [3, 4]],\n                             [[5, 6], [7, 8]],\n                             [[9, 10], [11, 12]]])\n\n        self.assertTrue(isinstance(arr2x2, NDArray[(2, ...), int]))\n        self.assertTrue(isinstance(arr2x2x2, NDArray[(2, ...), int]))\n        self.assertTrue(not isinstance(arr3x2x2, NDArray[(2, ...), int]))\n\n    def test_subclass_check(self):\n        self.assertTrue(issubclass(NDArray[(2, 2, 2), int], NDArray[(2, 2, 2), int]))\n        self.assertTrue(issubclass(NDArray[(2, 2, 2), int], NDArray))\n        self.assertTrue(issubclass(NDArray[(2, 2, 2), int], NDArray[int]))\n        self.assertTrue(not issubclass(NDArray[(2, 2, 2), int], NDArray[(2, 2, 3), int]))\n\n    def test_repr_and_str(self):\n        # These imports are needed for the evals to work.\n        import typing\n        from nptyping import Int\n\n        arr_1a = NDArray[(2, 2), Int]\n        arr_1b = eval(repr(arr_1a))\n\n        arr_2a = NDArray[(typing.Any, ...), int]\n        arr_2b = eval(repr(arr_2a))\n\n        arr_3a = NDArray\n        arr_3b = eval(repr(arr_3a))\n\n        arr_4a = NDArray[5]\n        arr_4b = eval(repr(arr_4a))\n\n        self.assertEqual(arr_1a, arr_1b)\n        self.assertEqual(arr_2a, arr_2b)\n        self.assertEqual(arr_3a, arr_3b)\n        self.assertEqual(arr_4a, arr_4b)\n\n        self.assertEqual(str(arr_1a), repr(arr_1a))\n        self.assertEqual(str(arr_2a), repr(arr_2a))\n        self.assertEqual(str(arr_3a), repr(arr_3a))\n        self.assertEqual(str(arr_4a), repr(arr_4a))\n\n    def test_type_of(self):\n        arr1 = np.array([1, 2, 3])\n        arr2 = np.array([1, 2, '3'])\n        arr3 = np.array([1, 2, 3.0])\n        arr4 = np.array([1, 2, {}])\n\n        t1 = NDArray.type_of(arr1)\n        t2 = NDArray.type_of(arr2)\n        t3 = NDArray.type_of(arr3)\n        t4 = NDArray.type_of(arr4)\n\n        self.assertIsInstance(arr1, t1)\n        self.assertIsInstance(arr2, t2)\n        self.assertIsInstance(arr3, t3)\n        self.assertIsInstance(arr4, t4)\n\n    def test_hash_ndarray(self):\n        # Hashing should not raise.\n        hash(NDArray[(3,), int])\n\n        # You should now be able to wrap an NDArray in an optional.\n        Optional[NDArray[(3,), int]]\n        Optional[NDArray]\n"""
tests/test_types/test_number.py,0,"b""from unittest import TestCase\n\nimport numpy\n\nfrom nptyping import (\n    Float,\n    Int,\n    Int8,\n    Int16,\n    Int32,\n    Int64,\n    Float16,\n    Float32,\n    Float64,\n    UInt,\n    UInt32,\n    UInt8,\n    UInt16,\n    UInt64,\n    Number,\n    DEFAULT_INT_BITS, DEFAULT_FLOAT_BITS,\n)\n\n\nclass TestNumber(TestCase):\n\n    def test_bits(self):\n        self.assertEqual(8, Int8.bits())\n        self.assertEqual(16, Int16.bits())\n        self.assertEqual(32, Int32.bits())\n        self.assertEqual(64, Int64.bits())\n\n        self.assertEqual(16, Float16.bits())\n        self.assertEqual(32, Float32.bits())\n        self.assertEqual(64, Float64.bits())\n\n    def test_raise_when_invalid_bits(self):\n        with self.assertRaises(TypeError):\n            Float[8]\n\n        with self.assertRaises(TypeError):\n            Int[128]\n\n    def test_raise_when_invalid_args(self):\n        with self.assertRaises(TypeError):\n            Float['wrong']\n\n    def test_isinstance(self):\n        self.assertIsInstance(42, Int)\n        self.assertIsInstance(42, Int32)\n        self.assertIsInstance(42.0, Float)\n        self.assertIsInstance(42.0, Float64)\n        self.assertIsInstance(42, Number)\n\n        self.assertIsInstance(Int64, Int[64])\n        self.assertIsInstance(Float64, Float[64])\n        self.assertIsInstance(Int64, Int)\n        self.assertIsInstance(Float64, Float)\n        self.assertNotIsInstance(Int, Float)\n        self.assertNotIsInstance(Float, Int)\n\n        self.assertIsInstance(numpy.int64(42), Int[64])\n        self.assertIsInstance(numpy.int64(42), Int64)\n        self.assertNotIsInstance(numpy.int32(42), Int64)\n\n        self.assertIsInstance(numpy.float64(42), Float[64])\n        self.assertIsInstance(numpy.float64(42), Float64)\n        self.assertNotIsInstance(numpy.float32(42), Float64)\n        self.assertNotIsInstance(numpy.int64(42), Float64)\n\n        self.assertIsInstance(numpy.float64(42), Number)\n        self.assertIsInstance(numpy.int8(42), Number)\n        self.assertNotIsInstance('I am not a number, I am a free man!', Number)\n\n    def test_eq(self):\n        self.assertTrue(Int8 == Int8)\n        self.assertTrue(Int16 == Int16)\n        self.assertTrue(Int32 == Int32)\n        self.assertTrue(Int64 == Int64)\n\n        self.assertTrue(UInt8 == UInt8)\n        self.assertTrue(UInt16 == UInt16)\n        self.assertTrue(UInt32 == UInt32)\n        self.assertTrue(UInt64 == UInt64)\n\n        self.assertTrue(Float16 == Float16)\n        self.assertTrue(Float32 == Float32)\n        self.assertTrue(Float64 == Float64)\n\n        self.assertTrue(Int8 != Int16)\n        self.assertTrue(Int32 != Float32)\n        self.assertTrue(Int32 != UInt32)\n\n    def test_issubclass(self):\n        self.assertTrue(issubclass(Float[32], Float32))\n        self.assertTrue(issubclass(Int64, Int[64]))\n        self.assertTrue(issubclass(Float16, Float))\n        self.assertTrue(issubclass(Int64, Int))\n        self.assertTrue(issubclass(Int64, Number))\n        self.assertTrue(not issubclass(Int64, Float))\n        self.assertTrue(not issubclass(Float32, Float64))\n\n        self.assertTrue(issubclass(numpy.float64, Number))\n        self.assertTrue(issubclass(numpy.int32, Number))\n        self.assertTrue(issubclass(numpy.int32, Int32))\n        self.assertTrue(not issubclass(numpy.int32, Int64))\n        self.assertTrue(not issubclass(numpy.float32, Int32))\n\n        self.assertTrue(issubclass(int, Number))\n        self.assertTrue(issubclass(float, Number))\n        self.assertTrue(issubclass(int, Int[DEFAULT_INT_BITS]))\n        self.assertTrue(issubclass(float, Float[DEFAULT_FLOAT_BITS]))\n\n    def test_int_of(self):\n        self.assertEqual(Int[DEFAULT_INT_BITS], Int.type_of(1))\n        self.assertEqual(Int[DEFAULT_INT_BITS], Int.type_of(1000000000))\n        self.assertEqual(Int[DEFAULT_INT_BITS], Int.type_of(-1000000000))\n\n        self.assertEqual(Int8, Int.type_of(numpy.int8))\n        self.assertEqual(Int16, Int.type_of(numpy.int16))\n        self.assertEqual(Int32, Int.type_of(numpy.int32))\n        self.assertEqual(Int64, Int.type_of(numpy.int64))\n\n    def test_uint_of(self):\n        self.assertEqual(UInt[DEFAULT_INT_BITS], UInt.type_of(1))\n        self.assertEqual(UInt[DEFAULT_INT_BITS], UInt.type_of(1000000000))\n        self.assertEqual(UInt[DEFAULT_INT_BITS], UInt.type_of(1000000000))\n\n        self.assertEqual(UInt8, UInt.type_of(numpy.uint8))\n        self.assertEqual(UInt16, UInt.type_of(numpy.uint16))\n        self.assertEqual(UInt32, UInt.type_of(numpy.uint32))\n        self.assertEqual(UInt64, UInt.type_of(numpy.uint64))\n\n    def test_float_of(self):\n        default_bytes = numpy.dtype(float).itemsize * 8\n        self.assertEqual(Float[default_bytes], Float.type_of(1.0))\n        self.assertEqual(Float[default_bytes], Float.type_of(1000000000.0))\n        self.assertEqual(Float[default_bytes], Float.type_of(-1000000000.0))\n\n    def test_int_fitting(self):\n        self.assertEqual(Int8, Int.fitting(0))\n        self.assertEqual(Int8, Int.fitting(2 ** 7 - 1))\n        self.assertEqual(Int8, Int.fitting(-(2 ** 7 - 1)))\n\n        self.assertEqual(Int16, Int.fitting(2 ** 7))\n        self.assertEqual(Int16, Int.fitting(2 ** 15 - 1))\n        self.assertEqual(Int16, Int.fitting(-(2 ** 7)))\n        self.assertEqual(Int16, Int.fitting(-(2 ** 15 - 1)))\n\n        self.assertEqual(Int32, Int.fitting(2 ** 15))\n        self.assertEqual(Int32, Int.fitting(2 ** 31 - 1))\n        self.assertEqual(Int32, Int.fitting(-(2 ** 15)))\n        self.assertEqual(Int32, Int.fitting(-(2 ** 31 - 1)))\n\n        self.assertEqual(Int64, Int.fitting(2 ** 31))\n        self.assertEqual(Int64, Int.fitting(2 ** 63 - 1))\n        self.assertEqual(Int64, Int.fitting(-(2 ** 31)))\n        self.assertEqual(Int64, Int.fitting(-(2 ** 63 - 1)))\n\n    def test_uint_fitting(self):\n        self.assertEqual(UInt8, UInt.fitting(0))\n        self.assertEqual(UInt8, UInt.fitting(2 ** 8 - 1))\n        self.assertEqual(UInt8, UInt.fitting(-(2 ** 8 - 1)))\n\n        self.assertEqual(UInt16, UInt.fitting(2 ** 8))\n        self.assertEqual(UInt16, UInt.fitting(2 ** 16 - 1))\n        self.assertEqual(UInt16, UInt.fitting(-(2 ** 8)))\n        self.assertEqual(UInt16, UInt.fitting(-(2 ** 16 - 1)))\n\n        self.assertEqual(UInt32, UInt.fitting(2 ** 16))\n        self.assertEqual(UInt32, UInt.fitting(2 ** 32 - 1))\n        self.assertEqual(UInt32, UInt.fitting(-(2 ** 16)))\n        self.assertEqual(UInt32, UInt.fitting(-(2 ** 32 - 1)))\n\n        self.assertEqual(UInt64, UInt.fitting(2 ** 32))\n        self.assertEqual(UInt64, UInt.fitting(2 ** 64 - 1))\n        self.assertEqual(UInt64, UInt.fitting(-(2 ** 32)))\n        self.assertEqual(UInt64, UInt.fitting(-(2 ** 64 - 1)))\n"""
tests/test_types/test_object.py,0,"b""from unittest import TestCase\n\nfrom nptyping import Object\n\n\nclass TestObject(TestCase):\n\n    def test_repr(self):\n        self.assertEqual('Object', repr(Object))\n"""
tests/test_types/test_unicode.py,0,"b""from unittest import TestCase\n\nfrom nptyping import Unicode\n\n\nclass TestUnicode(TestCase):\n\n    def test_isinstance(self):\n        self.assertIsInstance('Sure', Unicode)\n        self.assertIsInstance('', Unicode)\n        self.assertIsInstance('Yes', Unicode[3])\n        self.assertIsInstance('Yes', Unicode[4])\n        self.assertNotIsInstance('No', Unicode[1])\n        self.assertNotIsInstance(42, Unicode)\n        self.assertNotIsInstance(42, Unicode[42])\n\n    def test_repr(self):\n        self.assertEqual('Unicode', repr(Unicode))\n        self.assertEqual('Unicode[50]', repr(Unicode[50]))\n\n    def test_type_of(self):\n        self.assertEqual(Unicode[4], Unicode.type_of('test'))\n"""
