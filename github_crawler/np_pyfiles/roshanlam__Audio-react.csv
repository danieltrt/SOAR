file_path,api_count,code
config.py,0,"b'from __future__ import print_function\r\nfrom __future__ import divison\r\nimport os \r\n\r\n# Created Roshan Lamichhane\r\n\r\nDEVICE = \'pi\'\r\n"""""" Device used to control the LED strip must be pi, esp8266 or blinkstick\r\n\r\n\r\nesp8266 means that you are using an ESP8266 module to control \r\nthe LED strip and commands will be sent to the ESP8266 over the Wifi.\r\n\r\npi means that you are using a Raspberry Pi as a standalone unit to process\r\naudio input and control the LED strip directly.\r\n\r\nblinkstick means that a BlinkstickPro is connected to this PC which will be used\r\nto control the leds connected to it.""""""\r\n\r\nif DEVICE == \'esp8266\':\r\n    UDP_IP = \'192.168.0.150\'\r\n    """"""IP address of the ESP8266. Must match IP in ws2812_controller.ino. Also this IP address is not my real IP address, I just made this up in my head but it may be a real IP address, it rare but its possible.""""""\r\n    UDP_PORT = 7777\r\n    """"""Port number used for socket communication between Python and ESP8266""""""\r\n    SOFTWARE_GAMMA_CORRECTION = False\r\n    """"""Set to False because the firmware handles gamma correction + dither""""""\r\n\r\nif DEVICE == \'pi\':\r\n    LED_PIN = 18\r\n    """"""GPIO pin connected to the LED strip pixels (must support PWM)""""""\r\n    LED_FREQ_HZ = 800000\r\n    """"""LED signal frequency in Hz (usually 800kHz)""""""\r\n    LED_DMA = 5\r\n    """"""DMA channel used for generating PWM signal (try 5)""""""\r\n    BRIGHTNESS = 255\r\n    """"""Brightness of LED strip between 0 and 255""""""\r\n    LED_INVERT = True\r\n    """"""Set True if using an inverting logic level converter""""""\r\n    SOFTWARE_GAMMA_CORRECTION = True\r\n    """"""Set to True because Raspberry Pi doesn\'t use hardware dithering""""""\r\n\r\nif DEVICE == \'blinkstick\':\r\n    SOFTWARE_GAMMA_CORRECTION = True\r\n    """"""Set to True because blinkstick doesn\'t use hardware dithering""""""\r\n\r\nUSE_GUI = True\r\n""""""Whether or not to display a PyQtGraph GUI plot of visualization""""""\r\n\r\nDISPLAY_FPS = True\r\n""""""Whether to display the FPS when running (can reduce performance)""""""\r\n\r\nN_PIXELS = 60\r\n""""""Number of pixels in the LED strip (must match ESP8266 firmware)""""""\r\n\r\nGAMMA_TABLE_PATH = os.path.join(os.path.dirname(__file__), \'gamma_table.npy\')\r\n""""""Location of the gamma correction table""""""\r\n\r\nMIC_RATE = 44100\r\n""""""Sampling frequency of the microphone in Hz""""""\r\n\r\nFPS = 60\r\n""""""Desired refresh rate of the visualization (frames per second)\r\nFPS indicates the desired refresh rate, or frames-per-second, of the audio\r\nvisualization. The actual refresh rate may be lower if the computer cannot keep\r\nup with desired FPS value.\r\nHigher framerates improve ""responsiveness"" and reduce the latency of the\r\nvisualization but are more computationally expensive.\r\nLow framerates are less computationally expensive, but the visualization may\r\nappear ""sluggish"" or out of sync with the audio being played if it is too low.\r\nThe FPS should not exceed the maximum refresh rate of the LED strip, which\r\ndepends on how long the LED strip is.\r\n""""""\r\n_max_led_FPS = int(((N_PIXELS * 30e-6) + 50e-6)**-1.0)\r\nassert FPS <= _max_led_FPS, \'FPS must be <= {}\'.format(_max_led_FPS)\r\n\r\nMIN_FREQUENCY = 200\r\n""""""Frequencies below this value will be removed during audio processing""""""\r\n\r\nMAX_FREQUENCY = 12000\r\n""""""Frequencies above this value will be removed during audio processing""""""\r\n\r\nN_FFT_BINS = 24\r\n""""""Number of frequency bins to use when transforming audio to frequency domain\r\nFast Fourier transforms are used to transform time-domain audio data to the\r\nfrequency domain. The frequencies present in the audio signal are assigned\r\nto their respective frequency bins. This value indicates the number of\r\nfrequency bins to use.\r\nA small number of bins reduces the frequency resolution of the visualization\r\nbut improves amplitude resolution. The opposite is true when using a large\r\nnumber of bins. More bins is not always better!\r\nThere is no point using more bins than there are pixels on the LED strip.\r\n""""""\r\n\r\nN_ROLLING_HISTORY = 2\r\n""""""Number of past audio frames to include in the rolling window""""""\r\n\r\nMIN_VOLUME_THRESHOLD = 1e-7\r\n""""""No music visualization displayed if recorded audio volume below threshold""""""'"
dsp.py,5,"b'from __future__ import print_function\r\nimport numpy as np\r\nimport config\r\nimport melbank\r\n\r\n# Created By Roshan Lamichhane\r\n\r\nclass ExpFilter:\r\n    """"""Simple exponential smoothing filter""""""\r\n    def __init__(self, val=0.0, alpha_decay=0.5, alpha_rise=0.5):\r\n        """"""Small rise / decay factors = more smoothing""""""\r\n        assert 0.0 < alpha_decay < 1.0, \'Invalid decay smoothing factor\'\r\n        assert 0.0 < alpha_rise < 1.0, \'Invalid rise smoothing factor\'\r\n        self.alpha_decay = alpha_decay\r\n        self.alpha_rise = alpha_rise\r\n        self.value = val\r\n\r\n    def update(self, value):\r\n        if isinstance(self.value, (list, np.ndarray, tuple)):\r\n            alpha = value - self.value\r\n            alpha[alpha > 0.0] = self.alpha_rise\r\n            alpha[alpha <= 0.0] = self.alpha_decay\r\n        else:\r\n            alpha = self.alpha_rise if value > self.value else self.alpha_decay\r\n        self.value = alpha * value + (1.0 - alpha) * self.value\r\n        return self.value\r\n\r\n\r\ndef rfft(data, window=None):\r\n    window = 1.0 if window is None else window(len(data))\r\n    ys = np.abs(np.fft.rfft(data * window))\r\n    xs = np.fft.rfftfreq(len(data), 1.0 / config.MIC_RATE)\r\n    return xs, ys\r\n\r\n\r\ndef fft(data, window=None):\r\n    window = 1.0 if window is None else window(len(data))\r\n    ys = np.fft.fft(data * window)\r\n    xs = np.fft.fftfreq(len(data), 1.0 / config.MIC_RATE)\r\n    return xs, ys\r\n\r\n\r\ndef create_mel_bank():\r\n    global samples, mel_y, mel_x\r\n    samples = int(config.MIC_RATE * config.N_ROLLING_HISTORY / (2.0 * config.FPS))\r\n    mel_y, (_, mel_x) = melbank.compute_melmat(num_mel_bands=config.N_FFT_BINS,\r\n                                               freq_min=config.MIN_FREQUENCY,\r\n                                               freq_max=config.MAX_FREQUENCY,\r\n                                               num_fft_bands=samples,\r\n                                               sample_rate=config.MIC_RATE)\r\nsamples = None\r\nmel_y = None\r\nmel_x = None\r\ncreate_mel_bank()'"
gui.py,3,"b""from __future__ import print_function\r\nfrom __future__ import division\r\nimport time\r\nimport numpy as np\r\nfrom pyqtgraph.Qt import QtGui\r\nimport pyqtgraph as pg\r\nfrom pyqtgraph.dockarea import *\r\n\r\n# Created By Roshan Lamichhane\r\n\r\nclass GUI:\r\n    plot = []\r\n    curve = []\r\n\r\n    def __init__(self, width=800, height=450, title='Audio React'):\r\n        # Create GUI window\r\n        self.app = QtGui.QApplication([])\r\n        self.win = pg.GraphicsWindow(title)\r\n        self.win.resize(width, height)\r\n        self.win.setWindowTitle(title)\r\n        # Create GUI layout\r\n        self.layout = QtGui.QVBoxLayout()\r\n        self.win.setLayout(self.layout)\r\n\r\n    def add_plot(self, title):\r\n        new_plot = pg.PlotWidget()\r\n        self.layout.addWidget(new_plot)\r\n        self.plot.append(new_plot)\r\n        self.curve.append([])\r\n\r\n    def add_curve(self, plot_index, pen=(255, 255, 255)):\r\n        self.curve[plot_index].append(self.plot[plot_index].plot(pen=pen))\r\n\r\n\r\nif __name__ == '__main__':\r\n    # Example test gui\r\n    N = 48\r\n    gui = GUI(title='Audio React (Still In Development)')\r\n    # Sin plot\r\n    gui.add_plot(title='Sin Plot')\r\n    gui.add_curve(plot_index=0)\r\n    gui.win.nextRow()\r\n    # Cos plot\r\n    gui.add_plot(title='Cos Plot')\r\n    gui.add_curve(plot_index=1)\r\n    while True:\r\n        t = time.time()\r\n        x = np.linspace(t, 2 * np.pi + t, N)\r\n        gui.curve[0][0].setData(x=x, y=np.sin(x))\r\n        gui.curve[1][0].setData(x=x, y=np.cos(x))\r\n        gui.app.processEvents()\r\n        time.sleep(1.0 / 30.0)\r\n"""
led.py,18,"b'from __future__ import print_function\r\nfrom __future__ import division\r\nimport platform\r\nimport numpy as np\r\nimport config\r\n\r\n# Created By Roshan Lamichhane\r\n\r\n# ESP8266 uses WiFi communication\r\nif config.DEVICE == \'esp8266\':\r\n    import socket\r\n    _sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\r\n# Raspberry Pi controls the LED strip directly\r\nelif config.DEVICE == \'pi\':\r\n    import neopixel\r\n    strip = neopixel.Adafruit_NeoPixel(config.N_PIXELS, config.LED_PIN,\r\n                                       config.LED_FREQ_HZ, config.LED_DMA,\r\n                                       config.LED_INVERT, config.BRIGHTNESS)\r\n    strip.begin()\r\nelif config.DEVICE == \'blinkstick\':\r\n    from blinkstick import blinkstick\r\n    import signal\r\n    import sys\r\n    #Will turn all leds off when invoked.\r\n    def signal_handler(signal, frame):\r\n        all_off = [0]*(config.N_PIXELS*3)\r\n        stick.set_led_data(0, all_off)\r\n        sys.exit(0)\r\n\r\n    stick = blinkstick.find_first()\r\n    # Create a listener that turns the leds off when the program terminates\r\n    signal.signal(signal.SIGTERM, signal_handler)\r\n    signal.signal(signal.SIGINT, signal_handler)\r\n\r\n_gamma = np.load(config.GAMMA_TABLE_PATH)\r\n""""""Gamma lookup table used for nonlinear brightness correction""""""\r\n\r\n_prev_pixels = np.tile(253, (3, config.N_PIXELS))\r\n""""""Pixel values that were most recently displayed on the LED strip""""""\r\n\r\npixels = np.tile(1, (3, config.N_PIXELS))\r\n""""""Pixel values for the LED strip""""""\r\n\r\n_is_python_2 = int(platform.python_version_tuple()[0]) == 2\r\n\r\ndef _update_esp8266():\r\n    """"""Sends UDP packets to ESP8266 to update LED strip values\r\n    The ESP8266 will receive and decode the packets to determine what values\r\n    to display on the LED strip. The communication protocol supports LED strips\r\n    with a maximum of 256 LEDs.\r\n    The packet encoding scheme is:\r\n        |i|r|g|b|\r\n    where\r\n        i (0 to 255): Index of LED to change (zero-based)\r\n        r (0 to 255): Red value of LED\r\n        g (0 to 255): Green value of LED\r\n        b (0 to 255): Blue value of LED\r\n    """"""\r\n    global pixels, _prev_pixels\r\n    # Truncate values and cast to integer\r\n    pixels = np.clip(pixels, 0, 255).astype(int)\r\n    # Optionally apply gamma correc tio\r\n    p = _gamma[pixels] if config.SOFTWARE_GAMMA_CORRECTION else np.copy(pixels)\r\n    MAX_PIXELS_PER_PACKET = 126\r\n    # Pixel indices\r\n    idx = range(pixels.shape[1])\r\n    idx = [i for i in idx if not np.array_equal(p[:, i], _prev_pixels[:, i])]\r\n    n_packets = len(idx) // MAX_PIXELS_PER_PACKET + 1\r\n    idx = np.array_split(idx, n_packets)\r\n    for packet_indices in idx:\r\n        m = \'\' if _is_python_2 else []\r\n        for i in packet_indices:\r\n            if _is_python_2:\r\n                m += chr(i) + chr(p[0][i]) + chr(p[1][i]) + chr(p[2][i])\r\n            else:\r\n                m.append(i)  # Index of pixel to change\r\n                m.append(p[0][i])  # Pixel red value\r\n                m.append(p[1][i])  # Pixel green value\r\n                m.append(p[2][i])  # Pixel blue value\r\n        m = m if _is_python_2 else bytes(m)\r\n        _sock.sendto(m, (config.UDP_IP, config.UDP_PORT))\r\n    _prev_pixels = np.copy(p)\r\n\r\n\r\ndef _update_pi():\r\n    """"""Writes new LED values to the Raspberry Pi\'s LED strip\r\n    Raspberry Pi uses the rpi_ws281x to control the LED strip directly.\r\n    This function updates the LED strip with new values.\r\n    """"""\r\n    global pixels, _prev_pixels\r\n    # Truncate values and cast to integer\r\n    pixels = np.clip(pixels, 0, 255).astype(int)\r\n    # Optional gamma correction\r\n    p = _gamma[pixels] if config.SOFTWARE_GAMMA_CORRECTION else np.copy(pixels)\r\n    # Encode 24-bit LED values in 32 bit integers\r\n    r = np.left_shift(p[0][:].astype(int), 8)\r\n    g = np.left_shift(p[1][:].astype(int), 16)\r\n    b = p[2][:].astype(int)\r\n    rgb = np.bitwise_or(np.bitwise_or(r, g), b)\r\n    # Update the pixels\r\n    for i in range(config.N_PIXELS):\r\n        # Ignore pixels if they haven\'t changed (saves bandwidth)\r\n        if np.array_equal(p[:, i], _prev_pixels[:, i]):\r\n            continue\r\n        strip._led_data[i] = rgb[i]\r\n    _prev_pixels = np.copy(p)\r\n    strip.show()\r\n\r\ndef _update_blinkstick():\r\n    """"""Writes new LED values to the Blinkstick.\r\n        This function updates the LED strip with new values.\r\n    """"""\r\n    global pixels\r\n    \r\n    # Truncate values and cast to integer\r\n    pixels = np.clip(pixels, 0, 255).astype(int)\r\n    # Optional gamma correction\r\n    p = _gamma[pixels] if config.SOFTWARE_GAMMA_CORRECTION else np.copy(pixels)\r\n    # Read the rgb values\r\n    r = p[0][:].astype(int)\r\n    g = p[1][:].astype(int)\r\n    b = p[2][:].astype(int)\r\n\r\n    #create array in which we will store the led states\r\n    newstrip = [None]*(config.N_PIXELS*3)\r\n\r\n    for i in range(config.N_PIXELS):\r\n        # blinkstick uses GRB format\r\n        newstrip[i*3] = g[i]\r\n        newstrip[i*3+1] = r[i]\r\n        newstrip[i*3+2] = b[i]\r\n    #send the data to the blinkstick\r\n    stick.set_led_data(0, newstrip)\r\n\r\n\r\ndef update():\r\n    """"""Updates the LED strip values""""""\r\n    if config.DEVICE == \'esp8266\':\r\n        _update_esp8266()\r\n    elif config.DEVICE == \'pi\':\r\n        _update_pi()\r\n    elif config.DEVICE == \'blinkstick\':\r\n        _update_blinkstick()\r\n    else:\r\n        raise ValueError(\'Invalid device selected\')\r\n\r\n\r\n# Execute this file to run a LED strand test\r\n# If everything is working, you should see a red, green, and blue pixel scroll\r\n# across the LED strip continously\r\nif __name__ == \'__main__\':\r\n    import time\r\n    # Turn all pixels off\r\n    pixels *= 0\r\n    pixels[0, 0] = 255  # Set 1st pixel red\r\n    pixels[1, 1] = 255  # Set 2nd pixel green\r\n    pixels[2, 2] = 255  # Set 3rd pixel blue\r\n    print(\'Starting LED strand test\')\r\n    while True:\r\n        pixels = np.roll(pixels, 1, axis=1)\r\n        update()\r\n        time.sleep(.1)'"
melbank.py,0,"b'from numpy import abs, append, arange, insert, linspace, log10, round, zeros\r\n\r\n# Created by Roshan Lamichhane\r\n\r\ndef hertz_to_mel(freq):\r\n    """"""Returns mel-frequency from linear frequency input.\r\n    Parameter\r\n    ---------\r\n    freq : scalar or ndarray\r\n        Frequency value or array in Hz.\r\n    Returns\r\n    -------\r\n    mel : scalar or ndarray\r\n        Mel-frequency value or ndarray in Mel\r\n    """"""\r\n    return 2595.0 * log10(1 + (freq / 700.0))\r\n\r\n\r\ndef mel_to_hertz(mel):\r\n    """"""Returns frequency from mel-frequency input.\r\n    Parameter\r\n    ---------\r\n    mel : scalar or ndarray\r\n        Mel-frequency value or ndarray in Mel\r\n    Returns\r\n    -------\r\n    freq : scalar or ndarray\r\n        Frequency value or array in Hz.\r\n    """"""\r\n    return 700.0 * (10**(mel / 2595.0)) - 700.0\r\n\r\n\r\ndef melfrequencies_mel_filterbank(num_bands, freq_min, freq_max, num_fft_bands):\r\n    """"""Returns centerfrequencies and band edges for a mel filter bank\r\n    Parameters\r\n    ----------\r\n    num_bands : int\r\n        Number of mel bands.\r\n    freq_min : scalar\r\n        Minimum frequency for the first band.\r\n    freq_max : scalar\r\n        Maximum frequency for the last band.\r\n    num_fft_bands : int\r\n        Number of fft bands.\r\n    Returns\r\n    -------\r\n    center_frequencies_mel : ndarray\r\n    lower_edges_mel : ndarray\r\n    upper_edges_mel : ndarray\r\n    """"""\r\n\r\n    mel_max = hertz_to_mel(freq_max)\r\n    mel_min = hertz_to_mel(freq_min)\r\n    delta_mel = abs(mel_max - mel_min) / (num_bands + 1.0)\r\n    frequencies_mel = mel_min + delta_mel * arange(0, num_bands + 2)\r\n    lower_edges_mel = frequencies_mel[:-2]\r\n    upper_edges_mel = frequencies_mel[2:]\r\n    center_frequencies_mel = frequencies_mel[1:-1]\r\n    return center_frequencies_mel, lower_edges_mel, upper_edges_mel\r\n\r\n\r\ndef compute_melmat(num_mel_bands=12, freq_min=64, freq_max=8000,\r\n                   num_fft_bands=513, sample_rate=16000):\r\n    """"""Returns tranformation matrix for mel spectrum.\r\n    Parameters\r\n    ----------\r\n    num_mel_bands : int\r\n        Number of mel bands. Number of rows in melmat.\r\n        Default: 24\r\n    freq_min : scalar\r\n        Minimum frequency for the first band.\r\n        Default: 64\r\n    freq_max : scalar\r\n        Maximum frequency for the last band.\r\n        Default: 8000\r\n    num_fft_bands : int\r\n        Number of fft-frequenc bands. This ist NFFT/2+1 !\r\n        number of columns in melmat.\r\n        Default: 513   (this means NFFT=1024)\r\n    sample_rate : scalar\r\n        Sample rate for the signals that will be used.\r\n        Default: 44100\r\n    Returns\r\n    -------\r\n    melmat : ndarray\r\n        Transformation matrix for the mel spectrum.\r\n        Use this with fft spectra of num_fft_bands_bands length\r\n        and multiply the spectrum with the melmat\r\n        this will tranform your fft-spectrum\r\n        to a mel-spectrum.\r\n    frequencies : tuple (ndarray <num_mel_bands>, ndarray <num_fft_bands>)\r\n        Center frequencies of the mel bands, center frequencies of fft spectrum.\r\n    """"""\r\n    center_frequencies_mel, lower_edges_mel, upper_edges_mel =  \\\r\n        melfrequencies_mel_filterbank(\r\n            num_mel_bands,\r\n            freq_min,\r\n            freq_max,\r\n            num_fft_bands\r\n        )\r\n\r\n    center_frequencies_hz = mel_to_hertz(center_frequencies_mel)\r\n    lower_edges_hz = mel_to_hertz(lower_edges_mel)\r\n    upper_edges_hz = mel_to_hertz(upper_edges_mel)\r\n    freqs = linspace(0.0, sample_rate / 2.0, num_fft_bands)\r\n    melmat = zeros((num_mel_bands, num_fft_bands))\r\n\r\n    for imelband, (center, lower, upper) in enumerate(zip(\r\n            center_frequencies_hz, lower_edges_hz, upper_edges_hz)):\r\n\r\n        left_slope = (freqs >= lower) == (freqs <= center)\r\n        melmat[imelband, left_slope] = (\r\n            (freqs[left_slope] - lower) / (center - lower)\r\n        )\r\n\r\n        right_slope = (freqs >= center) == (freqs <= upper)\r\n        melmat[imelband, right_slope] = (\r\n            (upper - freqs[right_slope]) / (upper - center)\r\n        )\r\n\r\n    return melmat, (center_frequencies_mel, freqs)'"
microphone.py,2,"b""import time\r\nimport numpy as np\r\nimport pyaudio\r\nimport config\r\n\r\n# Created by Roshan Lamichhane\r\n\r\ndef start_stream(callback):\r\n    p = pyaudio.PyAudio()\r\n    frames_per_buffer = int(config.MIC_RATE / config.FPS)\r\n    stream = p.open(format=pyaudio.paInt16,\r\n                    channels=1,\r\n                    rate=config.MIC_RATE,\r\n                    input=True,\r\n                    frames_per_buffer=frames_per_buffer)\r\n    overflows = 0\r\n    prev_ovf_time = time.time()\r\n    while True:\r\n        try:\r\n            y = np.fromstring(stream.read(frames_per_buffer, exception_on_overflow=False), dtype=np.int16)\r\n            y = y.astype(np.float32)\r\n            stream.read(stream.get_read_available(), exception_on_overflow=False)\r\n            callback(y)\r\n        except IOError:\r\n            overflows += 1\r\n            if time.time() > prev_ovf_time + 1:\r\n                prev_ovf_time = time.time()\r\n                print('Audio buffer has overflowed {} times'.format(overflows))\r\n    stream.stop_stream()\r\n    stream.close()\r\n    p.terminate()"""
visualization.py,49,"b'from __future__ import print_function\r\nfrom __future__ import division\r\nimport time\r\nimport numpy as np\r\nfrom scipy.ndimage.filters import gaussian_filter1d\r\nimport config\r\nimport microphone\r\nimport dsp\r\nimport led\r\n\r\n# Created by Roshan Lamichhane\r\n\r\n_time_prev = time.time() * 1000.0\r\n""""""The previous time that the frames_per_second() function was called""""""\r\n\r\n_fps = dsp.ExpFilter(val=config.FPS, alpha_decay=0.2, alpha_rise=0.2)\r\n""""""The low-pass filter used to estimate frames-per-second""""""\r\n\r\n\r\ndef frames_per_second():\r\n    """"""Return the estimated frames per second\r\n    Returns the current estimate for frames-per-second (FPS).\r\n    FPS is estimated by measured the amount of time that has elapsed since\r\n    this function was previously called. The FPS estimate is low-pass filtered\r\n    to reduce noise.\r\n    This function is intended to be called one time for every iteration of\r\n    the program\'s main loop.\r\n    Returns\r\n    -------\r\n    fps : float\r\n        Estimated frames-per-second. This value is low-pass filtered\r\n        to reduce noise.\r\n    """"""\r\n    global _time_prev, _fps\r\n    time_now = time.time() * 1000.0\r\n    dt = time_now - _time_prev\r\n    _time_prev = time_now\r\n    if dt == 0.0:\r\n        return _fps.value\r\n    return _fps.update(1000.0 / dt)\r\n\r\n\r\ndef memoize(function):\r\n    """"""Provides a decorator for memoizing functions""""""\r\n    from functools import wraps\r\n    memo = {}\r\n\r\n    @wraps(function)\r\n    def wrapper(*args):\r\n        if args in memo:\r\n            return memo[args]\r\n        else:\r\n            rv = function(*args)\r\n            memo[args] = rv\r\n            return rv\r\n    return wrapper\r\n\r\n\r\n@memoize\r\ndef _normalized_linspace(size):\r\n    return np.linspace(0, 1, size)\r\n\r\n\r\ndef interpolate(y, new_length):\r\n    """"""Intelligently resizes the array by linearly interpolating the values\r\n    Parameters\r\n    ----------\r\n    y : np.array\r\n        Array that should be resized\r\n    new_length : int\r\n        The length of the new interpolated array\r\n    Returns\r\n    -------\r\n    z : np.array\r\n        New array with length of new_length that contains the interpolated\r\n        values of y.\r\n    """"""\r\n    if len(y) == new_length:\r\n        return y\r\n    x_old = _normalized_linspace(len(y))\r\n    x_new = _normalized_linspace(new_length)\r\n    z = np.interp(x_new, x_old, y)\r\n    return z\r\n\r\n\r\nr_filt = dsp.ExpFilter(np.tile(0.01, config.N_PIXELS // 2),\r\n                       alpha_decay=0.2, alpha_rise=0.99)\r\ng_filt = dsp.ExpFilter(np.tile(0.01, config.N_PIXELS // 2),\r\n                       alpha_decay=0.05, alpha_rise=0.3)\r\nb_filt = dsp.ExpFilter(np.tile(0.01, config.N_PIXELS // 2),\r\n                       alpha_decay=0.1, alpha_rise=0.5)\r\ncommon_mode = dsp.ExpFilter(np.tile(0.01, config.N_PIXELS // 2),\r\n                       alpha_decay=0.99, alpha_rise=0.01)\r\np_filt = dsp.ExpFilter(np.tile(1, (3, config.N_PIXELS // 2)),\r\n                       alpha_decay=0.1, alpha_rise=0.99)\r\np = np.tile(1.0, (3, config.N_PIXELS // 2))\r\ngain = dsp.ExpFilter(np.tile(0.01, config.N_FFT_BINS),\r\n                     alpha_decay=0.001, alpha_rise=0.99)\r\n\r\n\r\ndef visualize_scroll(y):\r\n    """"""Effect that originates in the center and scrolls outwards""""""\r\n    global p\r\n    y = y**2.0\r\n    gain.update(y)\r\n    y /= gain.value\r\n    y *= 255.0\r\n    r = int(np.max(y[:len(y) // 3]))\r\n    g = int(np.max(y[len(y) // 3: 2 * len(y) // 3]))\r\n    b = int(np.max(y[2 * len(y) // 3:]))\r\n    # Scrolling effect window\r\n    p[:, 1:] = p[:, :-1]\r\n    p *= 0.98\r\n    p = gaussian_filter1d(p, sigma=0.2)\r\n    # Create new color originating at the center\r\n    p[0, 0] = r\r\n    p[1, 0] = g\r\n    p[2, 0] = b\r\n    # Update the LED strip\r\n    return np.concatenate((p[:, ::-1], p), axis=1)\r\n\r\n\r\ndef visualize_energy(y):\r\n    """"""Effect that expands from the center with increasing sound energy""""""\r\n    global p\r\n    y = np.copy(y)\r\n    gain.update(y)\r\n    y /= gain.value\r\n    # Scale by the width of the LED strip\r\n    y *= float((config.N_PIXELS // 2) - 1)\r\n    # Map color channels according to energy in the different freq bands\r\n    scale = 0.9\r\n    r = int(np.mean(y[:len(y) // 3]**scale))\r\n    g = int(np.mean(y[len(y) // 3: 2 * len(y) // 3]**scale))\r\n    b = int(np.mean(y[2 * len(y) // 3:]**scale))\r\n    # Assign color to different frequency regions\r\n    p[0, :r] = 255.0\r\n    p[0, r:] = 0.0\r\n    p[1, :g] = 255.0\r\n    p[1, g:] = 0.0\r\n    p[2, :b] = 255.0\r\n    p[2, b:] = 0.0\r\n    p_filt.update(p)\r\n    p = np.round(p_filt.value)\r\n    # Apply substantial blur to smooth the edges\r\n    p[0, :] = gaussian_filter1d(p[0, :], sigma=4.0)\r\n    p[1, :] = gaussian_filter1d(p[1, :], sigma=4.0)\r\n    p[2, :] = gaussian_filter1d(p[2, :], sigma=4.0)\r\n    # Set the new pixel value\r\n    return np.concatenate((p[:, ::-1], p), axis=1)\r\n\r\n\r\n_prev_spectrum = np.tile(0.01, config.N_PIXELS // 2)\r\n\r\n\r\ndef visualize_spectrum(y):\r\n    """"""Effect that maps the Mel filterbank frequencies onto the LED strip""""""\r\n    global _prev_spectrum\r\n    y = np.copy(interpolate(y, config.N_PIXELS // 2))\r\n    common_mode.update(y)\r\n    diff = y - _prev_spectrum\r\n    _prev_spectrum = np.copy(y)\r\n    # Color channel mappings\r\n    r = r_filt.update(y - common_mode.value)\r\n    g = np.abs(diff)\r\n    b = b_filt.update(np.copy(y))\r\n    # Mirror the color channels for symmetric output\r\n    r = np.concatenate((r[::-1], r))\r\n    g = np.concatenate((g[::-1], g))\r\n    b = np.concatenate((b[::-1], b))\r\n    output = np.array([r, g,b]) * 255\r\n    return output\r\n\r\n\r\nfft_plot_filter = dsp.ExpFilter(np.tile(1e-1, config.N_FFT_BINS),\r\n                         alpha_decay=0.5, alpha_rise=0.99)\r\nmel_gain = dsp.ExpFilter(np.tile(1e-1, config.N_FFT_BINS),\r\n                         alpha_decay=0.01, alpha_rise=0.99)\r\nmel_smoothing = dsp.ExpFilter(np.tile(1e-1, config.N_FFT_BINS),\r\n                         alpha_decay=0.5, alpha_rise=0.99)\r\nvolume = dsp.ExpFilter(config.MIN_VOLUME_THRESHOLD,\r\n                       alpha_decay=0.02, alpha_rise=0.02)\r\nfft_window = np.hamming(int(config.MIC_RATE / config.FPS) * config.N_ROLLING_HISTORY)\r\nprev_fps_update = time.time()\r\n\r\n\r\ndef microphone_update(audio_samples):\r\n    global y_roll, prev_rms, prev_exp, prev_fps_update\r\n    # Normalize samples between 0 and 1\r\n    y = audio_samples / 2.0**15\r\n    # Construct a rolling window of audio samples\r\n    y_roll[:-1] = y_roll[1:]\r\n    y_roll[-1, :] = np.copy(y)\r\n    y_data = np.concatenate(y_roll, axis=0).astype(np.float32)\r\n    \r\n    vol = np.max(np.abs(y_data))\r\n    if vol < config.MIN_VOLUME_THRESHOLD:\r\n        print(\'No audio input. Volume below threshold. Volume:\', vol)\r\n        led.pixels = np.tile(0, (3, config.N_PIXELS))\r\n        led.update()\r\n    else:\r\n        # Transform audio input into the frequency domain\r\n        N = len(y_data)\r\n        N_zeros = 2**int(np.ceil(np.log2(N))) - N\r\n        # Pad with zeros until the next power of two\r\n        y_data *= fft_window\r\n        y_padded = np.pad(y_data, (0, N_zeros), mode=\'constant\')\r\n        YS = np.abs(np.fft.rfft(y_padded)[:N // 2])\r\n        # Construct a Mel filterbank from the FFT data\r\n        mel = np.atleast_2d(YS).T * dsp.mel_y.T\r\n        # Scale data to values more suitable for visualization\r\n        # mel = np.sum(mel, axis=0)\r\n        mel = np.sum(mel, axis=0)\r\n        mel = mel**2.0\r\n        # Gain normalization\r\n        mel_gain.update(np.max(gaussian_filter1d(mel, sigma=1.0)))\r\n        mel /= mel_gain.value\r\n        mel = mel_smoothing.update(mel)\r\n        # Map filterbank output onto LED strip\r\n        output = visualization_effect(mel)\r\n        led.pixels = output\r\n        led.update()\r\n        if config.USE_GUI:\r\n            # Plot filterbank output\r\n            x = np.linspace(config.MIN_FREQUENCY, config.MAX_FREQUENCY, len(mel))\r\n            mel_curve.setData(x=x, y=fft_plot_filter.update(mel))\r\n            # Plot the color channels\r\n            r_curve.setData(y=led.pixels[0])\r\n            g_curve.setData(y=led.pixels[1])\r\n            b_curve.setData(y=led.pixels[2])\r\n    if config.USE_GUI:\r\n        app.processEvents()\r\n    \r\n    if config.DISPLAY_FPS:\r\n        fps = frames_per_second()\r\n        if time.time() - 0.5 > prev_fps_update:\r\n            prev_fps_update = time.time()\r\n            print(\'FPS {:.0f} / {:.0f}\'.format(fps, config.FPS))\r\n\r\n\r\n# Number of audio samples to read every time frame\r\nsamples_per_frame = int(config.MIC_RATE / config.FPS)\r\n\r\n# Array containing the rolling audio sample window\r\ny_roll = np.random.rand(config.N_ROLLING_HISTORY, samples_per_frame) / 1e16\r\n\r\nvisualization_effect = visualize_spectrum\r\n""""""Visualization effect to display on the LED strip""""""\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    if config.USE_GUI:\r\n        import pyqtgraph as pg\r\n        from pyqtgraph.Qt import QtGui, QtCore\r\n        # Create GUI window\r\n        app = QtGui.QApplication([])\r\n        view = pg.GraphicsView()\r\n        layout = pg.GraphicsLayout(border=(100,100,100))\r\n        view.setCentralItem(layout)\r\n        view.show()\r\n        view.setWindowTitle(\'Visualization\')\r\n        view.resize(800,600)\r\n        # Mel filterbank plot\r\n        fft_plot = layout.addPlot(title=\'Filterbank Output\', colspan=3)\r\n        fft_plot.setRange(yRange=[-0.1, 1.2])\r\n        fft_plot.disableAutoRange(axis=pg.ViewBox.YAxis)\r\n        x_data = np.array(range(1, config.N_FFT_BINS + 1))\r\n        mel_curve = pg.PlotCurveItem()\r\n        mel_curve.setData(x=x_data, y=x_data*0)\r\n        fft_plot.addItem(mel_curve)\r\n        # Visualization plot\r\n        layout.nextRow()\r\n        led_plot = layout.addPlot(title=\'Visualization Output\', colspan=3)\r\n        led_plot.setRange(yRange=[-5, 260])\r\n        led_plot.disableAutoRange(axis=pg.ViewBox.YAxis)\r\n        # Pen for each of the color channel curves\r\n        r_pen = pg.mkPen((255, 30, 30, 200), width=4)\r\n        g_pen = pg.mkPen((30, 255, 30, 200), width=4)\r\n        b_pen = pg.mkPen((30, 30, 255, 200), width=4)\r\n        # Color channel curves\r\n        r_curve = pg.PlotCurveItem(pen=r_pen)\r\n        g_curve = pg.PlotCurveItem(pen=g_pen)\r\n        b_curve = pg.PlotCurveItem(pen=b_pen)\r\n        # Define x data\r\n        x_data = np.array(range(1, config.N_PIXELS + 1))\r\n        r_curve.setData(x=x_data, y=x_data*0)\r\n        g_curve.setData(x=x_data, y=x_data*0)\r\n        b_curve.setData(x=x_data, y=x_data*0)\r\n        # Add curves to plot\r\n        led_plot.addItem(r_curve)\r\n        led_plot.addItem(g_curve)\r\n        led_plot.addItem(b_curve)\r\n        # Frequency range label\r\n        freq_label = pg.LabelItem(\'\')\r\n        # Frequency slider\r\n        def freq_slider_change(tick):\r\n            minf = freq_slider.tickValue(0)**2.0 * (config.MIC_RATE / 2.0)\r\n            maxf = freq_slider.tickValue(1)**2.0 * (config.MIC_RATE / 2.0)\r\n            t = \'Frequency range: {:.0f} - {:.0f} Hz\'.format(minf, maxf)\r\n            freq_label.setText(t)\r\n            config.MIN_FREQUENCY = minf\r\n            config.MAX_FREQUENCY = maxf\r\n            dsp.create_mel_bank()\r\n        freq_slider = pg.TickSliderItem(orientation=\'bottom\', allowAdd=False)\r\n        freq_slider.addTick((config.MIN_FREQUENCY / (config.MIC_RATE / 2.0))**0.5)\r\n        freq_slider.addTick((config.MAX_FREQUENCY / (config.MIC_RATE / 2.0))**0.5)\r\n        freq_slider.tickMoveFinished = freq_slider_change\r\n        freq_label.setText(\'Frequency range: {} - {} Hz\'.format(\r\n            config.MIN_FREQUENCY,\r\n            config.MAX_FREQUENCY))\r\n        # Effect selection\r\n        active_color = \'#16dbeb\'\r\n        inactive_color = \'#FFFFFF\'\r\n        def energy_click(x):\r\n            global visualization_effect\r\n            visualization_effect = visualize_energy\r\n            energy_label.setText(\'Energy\', color=active_color)\r\n            scroll_label.setText(\'Scroll\', color=inactive_color)\r\n            spectrum_label.setText(\'Spectrum\', color=inactive_color)\r\n        def scroll_click(x):\r\n            global visualization_effect\r\n            visualization_effect = visualize_scroll\r\n            energy_label.setText(\'Energy\', color=inactive_color)\r\n            scroll_label.setText(\'Scroll\', color=active_color)\r\n            spectrum_label.setText(\'Spectrum\', color=inactive_color)\r\n        def spectrum_click(x):\r\n            global visualization_effect\r\n            visualization_effect = visualize_spectrum\r\n            energy_label.setText(\'Energy\', color=inactive_color)\r\n            scroll_label.setText(\'Scroll\', color=inactive_color)\r\n            spectrum_label.setText(\'Spectrum\', color=active_color)\r\n        # Create effect ""buttons"" (labels with click event)\r\n        energy_label = pg.LabelItem(\'Energy\')\r\n        scroll_label = pg.LabelItem(\'Scroll\')\r\n        spectrum_label = pg.LabelItem(\'Spectrum\')\r\n        energy_label.mousePressEvent = energy_click\r\n        scroll_label.mousePressEvent = scroll_click\r\n        spectrum_label.mousePressEvent = spectrum_click\r\n        energy_click(0)\r\n        # Layout\r\n        layout.nextRow()\r\n        layout.addItem(freq_label, colspan=3)\r\n        layout.nextRow()\r\n        layout.addItem(freq_slider, colspan=3)\r\n        layout.nextRow()\r\n        layout.addItem(energy_label)\r\n        layout.addItem(scroll_label)\r\n        layout.addItem(spectrum_label)\r\n    # Initialize LEDs\r\n    led.update()\r\n    # Start listening to live audio stream\r\n    microphone.start_stream(microphone_update)\r\n'"
