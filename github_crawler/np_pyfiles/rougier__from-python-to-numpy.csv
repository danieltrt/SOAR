file_path,api_count,code
code/Bridson_sampling.py,13,"b""# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef Bridson_sampling(width=1.0, height=1.0, radius=0.025, k=30):\n    # References: Fast Poisson Disk Sampling in Arbitrary Dimensions\n    #             Robert Bridson, SIGGRAPH, 2007\n    def squared_distance(p0, p1):\n        return (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2\n\n    def random_point_around(p, k=1):\n        # WARNING: This is not uniform around p but we can live with it\n        R = np.random.uniform(radius, 2*radius, k)\n        T = np.random.uniform(0, 2*np.pi, k)\n        P = np.empty((k, 2))\n        P[:, 0] = p[0]+R*np.sin(T)\n        P[:, 1] = p[1]+R*np.cos(T)\n        return P\n\n    def in_limits(p):\n        return 0 <= p[0] < width and 0 <= p[1] < height\n\n    def neighborhood(shape, index, n=2):\n        row, col = index\n        row0, row1 = max(row-n, 0), min(row+n+1, shape[0])\n        col0, col1 = max(col-n, 0), min(col+n+1, shape[1])\n        I = np.dstack(np.mgrid[row0:row1, col0:col1])\n        I = I.reshape(I.size//2, 2).tolist()\n        I.remove([row, col])\n        return I\n\n    def in_neighborhood(p):\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        if M[i, j]:\n            return True\n        for (i, j) in N[(i, j)]:\n            if M[i, j] and squared_distance(p, P[i, j]) < squared_radius:\n                return True\n        return False\n\n    def add_point(p):\n        points.append(p)\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        P[i, j], M[i, j] = p, True\n\n    # Here `2` corresponds to the number of dimension\n    cellsize = radius/np.sqrt(2)\n    rows = int(np.ceil(width/cellsize))\n    cols = int(np.ceil(height/cellsize))\n\n    # Squared radius because we'll compare squared distance\n    squared_radius = radius*radius\n\n    # Positions cells\n    P = np.zeros((rows, cols, 2), dtype=np.float32)\n    M = np.zeros((rows, cols), dtype=bool)\n\n    # Cache generation for neighborhood\n    N = {}\n    for i in range(rows):\n        for j in range(cols):\n            N[(i, j)] = neighborhood(M.shape, (i, j), 2)\n\n    points = []\n    add_point((np.random.uniform(width), np.random.uniform(height)))\n    while len(points):\n        i = np.random.randint(len(points))\n        p = points[i]\n        del points[i]\n        Q = random_point_around(p, k)\n        for q in Q:\n            if in_limits(q) and not in_neighborhood(q):\n                add_point(q)\n    return P[M]\n\n\nif __name__ == '__main__':\n\n    plt.figure()\n    plt.subplot(1, 1, 1, aspect=1)\n\n    points = Bridson_sampling()\n    X = [x for (x, y) in points]\n    Y = [y for (x, y) in points]\n    plt.scatter(X, Y, s=10)\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n    plt.show()\n"""
code/DART_sampling_numpy.py,4,"b""# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import cdist\n\n\ndef DART_sampling_numpy(width=1.0, height=1.0, radius=0.025, k=100):\n\n    # Theoretical limit\n    n = int((width+radius)*(height+radius) / (2*(radius/2)*(radius/2)*np.sqrt(3))) + 1\n    # 5 times the theoretical limit\n    n = 5*n\n\n    # Compute n random points\n    P = np.zeros((n, 2))\n    P[:, 0] = np.random.uniform(0, width, n)\n    P[:, 1] = np.random.uniform(0, height, n)\n\n    # Computes respective distances at once\n    D = cdist(P, P)\n\n    # Cancel null distances on the diagonal\n    D[range(n), range(n)] = 1e10\n\n    points, indices = [P[0]], [0]\n    i = 1\n    last_success = 0\n    while i < n and i - last_success < k:\n        if D[i, indices].min() > radius:\n            indices.append(i)\n            points.append(P[i])\n            last_success = i\n        i += 1\n    return points\n\n\nif __name__ == '__main__':\n\n    plt.figure()\n    plt.subplot(1, 1, 1, aspect=1)\n\n    points = DART_sampling_numpy()\n    X = [x for (x, y) in points]\n    Y = [y for (x, y) in points]\n    plt.scatter(X, Y, s=10)\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n    plt.show()\n"""
code/DART_sampling_python.py,0,"b""# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport math\nimport random\nimport matplotlib.pyplot as plt\n\n\ndef DART_sampling_python(width=1.0, height=1.0, radius=0.025, k=100):\n    def squared_distance(p0, p1):\n        dx, dy = p0[0]-p1[0], p0[1]-p1[1]\n        return dx*dx+dy*dy\n\n    points = []\n    i = 0\n    last_success = 0\n    while True:\n        x = random.uniform(0, width)\n        y = random.uniform(0, height)\n        accept = True\n        for p in points:\n            if squared_distance(p, (x, y)) < radius*radius:\n                accept = False\n                break\n        if accept is True:\n            points.append((x, y))\n            if i-last_success > k:\n                break\n            last_success = i\n        i += 1\n    return points\n\nif __name__ == '__main__':\n\n    plt.figure()\n    plt.subplot(1, 1, 1, aspect=1)\n\n    points = DART_sampling_python()\n    X = [x for (x, y) in points]\n    Y = [y for (x, y) in points]\n    plt.scatter(X, Y, s=10)\n    plt.xlim(0, 1)\n    plt.ylim(0, 1)\n    plt.show()\n"""
code/addition.py,1,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport random\nimport numpy as np\n\n\ndef solution_1(Z1,Z2):\n    return [z1+z2 for (z1,z2) in zip(Z1,Z2)]\n\n\ndef solution_2(Z1,Z2):\n    return np.add(Z1,Z2)\n\n\nif __name__ == \'__main__\':\n    from tools import print_timeit\n\n    Z1 = random.sample(range(10000), 1000)\n    Z2 = random.sample(range(10000), 1000)\n    print_timeit(""solution_1(Z1, Z2)"", globals())\n    print_timeit(""solution_2(Z1, Z2)"", globals())\n\n    Z1 = [[1,2],[3,4]]\n    Z2 = [[5,6],[7,8]]\n    print(solution_1(Z1, Z2))\n    print(solution_2(Z1, Z2))\n\n'"
code/allocations.py,2,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport itertools as it\n\n\ndef solution_1():\n    # Author: Tucker Balch\n    # Brute force\n    # 14641 (=11*11*11*11) iterations & tests\n    Z = []\n    for i in range(11):\n        for j in range(11):\n            for k in range(11):\n                for l in range(11):\n                    if i+j+k+l == 10:\n                        Z.append((i,j,k,l))\n    return Z\n\n\ndef solution_2():\n    # Author: Daniel Vinegrad \n    # Itertools\n    # 14641 (=11*11*11*11) iterations & tests\n    return [(i,j,k,l)\n            for i,j,k,l in it.product(range(11),repeat=4) if i+j+k+l == 10]\n\ndef solution_3():\n    # Author: Nick Poplas\n    # Intricated iterations\n    # 486 iterations, no test\n    return [(a, b, c, (10 - a - b - c))\n            for a in range(11) for b in range(11 - a) for c in range(11 - a - b)]\n\n\ndef solution_3_bis():\n    # Iterator using intricated iterations\n    # 486 iterations, no test\n    return ((a, b, c, (10 - a - b - c))\n            for a in range(11) for b in range(11 - a) for c in range(11 - a - b))\n\n\ndef solution_4():\n    # Author: Yaser Martinez\n    # Numpy indices\n    # No iterations, 1331 (= 11*11*11) tests\n    X123 = np.indices((11,11,11)).reshape(3,11*11*11)\n    X4 = 10 - X123.sum(axis=0)\n    return np.vstack((X123, X4)).T[X4 > -1]\n\n\nif __name__ == \'__main__\':\n    from tools import timeit\n\n    timeit(""solution_1()"", globals())\n    timeit(""solution_2()"", globals())\n    timeit(""solution_3()"", globals())\n    timeit(""solution_4()"", globals())\n    # timeit(""solution_5()"", globals())\n    print()\n    timeit(""solution_3_bis()"", globals())\n\n    print(type(solution_3()))\n    print(type(solution_3_bis()))\n'"
code/anatomy.py,3,"b""# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom tools import info\n\nif __name__ == '__main__':\n    Z = np.arange(4*4).reshape(4,4)\n\n    Z = np.array(Z, order='C')\n    info(Z)\n\n    Z = np.array(Z, order='F')\n    info(Z)\n\n"""
code/array_list.py,17,"b'# -*- coding: utf-8 -*-\n# -----------------------------------------------------------------------------\n# Copyright (c) 2014, Nicolas P. Rougier. All rights reserved.\n# Distributed under the terms of the new BSD License.\n# -----------------------------------------------------------------------------\n""""""\nAn ArrayList is a strongly typed list whose type can be anything that can be\ninterpreted as a numpy data type. \n\nExample\n-------\n\n>>> L = ArrayList( [[0], [1,2], [3,4,5], [6,7,8,9]] )\n>>> print L\n[ [0] [1 2] [3 4 5] [6 7 8 9] ]\n>>> print L.data\n[0 1 2 3 4 5 6 7 8 9]\n\nYou can add several items at once by specifying common or individual size: a\nsingle scalar means all items are the same size while a list of sizes is used to\nspecify individual item sizes.\n\nExample\n-------\n\n>>> L = ArrayList( np.arange(10), [3,3,4])\n>>> print L\n[ [0 1 2] [3 4 5] [6 7 8 9] ]\n>>> print L.data\n[0 1 2 3 4 5 6 7 8 9]\n\n""""""\nimport numpy as np\n\n\nclass ArrayList(object):\n    """"""\n    An ArrayList is a strongly typed list whose type can be anything that can be\n    interpreted as a numpy data type.\n    """"""\n\n    def __init__(self, data=None, sizes=None, dtype=float, sizeable=True, writeable=True):\n        """""" Create a new buffer using given data and sizes or dtype\n\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        sizes:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n\n        dtype: np.dtype\n            Any object that can be interpreted as a numpy data type.\n\n        sizeable : boolean\n            Indicate whether item can be appended/inserted/deleted\n\n        writeable : boolean\n            Indicate whether content can be changed\n        """"""\n\n        self._sizeable = sizeable\n        self._writeable = writeable\n\n        if data is not None:\n            if type(data) in [list,tuple]:\n                if type(data[0]) in [list,tuple]:\n                    sizes = [len(l) for l in data]\n                    data = [item for sublist in data for item in sublist]\n            self._data = np.array(data, copy=False)\n            self._size = self._data.size\n\n            # Default is one group with all data inside\n            _sizes = np.ones(1)*self._data.size\n\n            # Check item sizes and get items count\n            if sizes is not None:\n                if type(sizes) is int:\n                    if (self._size % sizes) != 0:\n                        raise ValueError(""Cannot partition data as requested"")\n                    self._count = self._size//sizes\n                    _sizes = np.ones(self._count,dtype=int)*(self._size//self._count)\n                else:\n                    _sizes = np.array(sizes, copy=False)\n                    self._count = len(sizes)\n                    if _sizes.sum() != self._size:\n                        raise ValueError(""Cannot partition data as requested"")\n            else:\n                self._count = 1\n\n            # Store items\n            self._items = np.zeros((self._count,2),int)\n            C = _sizes.cumsum()\n            self._items[1:,0] += C[:-1]\n            self._items[0:,1] += C\n\n        else:\n            self._data = np.zeros(512, dtype=dtype)\n            self._items = np.zeros((64,2), dtype=int)\n            self._size = 0\n            self._count = 0\n\n\n    @property\n    def data(self):\n        """""" The array\'s elements, in memory. """"""\n        return self._data[:self._size]\n\n\n\n    @property\n    def itemsize(self):\n        """""" Individual item sizes """"""\n        return self._items[:self._count,1] - self._items[:self._count,0]\n\n\n\n    @property\n    def size(self):\n        """""" Number of base elements, in memory. """"""\n        return self._size\n\n\n\n    @property\n    def dtype(self):\n        """""" Describes the format of the elements in the buffer. """"""\n        return self._data.dtype\n\n\n\n    def __len__(self):\n        """""" x.__len__() <==> len(x) """"""\n        return self._count\n\n\n\n    def __str__(self):\n        s = \'[ \'\n        for item in self: s += str(item) + \' \'\n        s += \']\'\n        return s\n\n\n\n    def __getitem__(self, key):\n        """""" x.__getitem__(y) <==> x[y] """"""\n\n        if type(key) is int:\n            if key < 0:\n                key += len(self)\n            if key < 0 or key >= len(self):\n                raise IndexError(""Tuple index out of range"")\n            dstart = self._items[key][0]\n            dstop  = self._items[key][1]\n            return self._data[dstart:dstop]\n\n        elif type(key) is slice:\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart,istop = istop,istart\n            dstart = self._items[istart][0]\n            if istart == istop:\n                dstop = dstart\n            else:\n                dstop  = self._items[istop-1][1]\n            return self._data[dstart:dstop]\n\n        elif isinstance(key,str):\n            return self._data[key][:self._size]\n\n        elif key is Ellipsis:\n            return self.data\n\n        else:\n            raise TypeError(""List indices must be integers"")\n\n\n    def __setitem__(self, key, data):\n        """""" x.__setitem__(i, y) <==> x[i]=y """"""\n\n        if not self._writeable:\n            raise AttributeError(""List is not sizeable"")\n\n        if type(key) is int:\n            if key < 0:\n                key += len(self)\n            if key < 0 or key > len(self):\n                raise IndexError(""List assignment index out of range"")\n            dstart = self._items[key][0]\n            dstop  = self._items[key][1]\n            self._data[dstart:dstop] = data\n\n        elif type(key) is slice:\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart,istop = istop,istart\n            if istart == istop:\n                dstart = self._items[key][0]\n                dstop  = self._items[key][1]\n                self._data[dstart:dstop] = data\n            else:\n                if istart > len(self) or istop > len(self):\n                    raise IndexError(""Can only assign iterable"")\n                dstart = self._items[istart][0]\n                if istart == istop:\n                    dstop = dstart\n                else:\n                    dstop  = self._items[istop-1][1]\n                self._data[dstart:dstop] = data\n\n        elif key is Ellipsis:\n            self.data[...] = data\n\n        elif type(key) is str:\n            self._data[key][:self._size] = data\n\n        else:\n            raise TypeError(""List assignment indices must be integers"")\n\n\n\n    def __delitem__(self, key):\n        """""" x.__delitem__(y) <==> del x[y] """"""\n\n        if not self._sizeable:\n            raise AttributeError(""List is not sizeable"")\n\n        # Deleting a single item\n        if type(key) is int:\n            if key < 0:\n                key += len(self)\n            if key < 0 or key > len(self):\n                raise IndexError(""List deletion index out of range"")\n            istart, istop = key, key+1\n            dstart,dstop = self._items[key]\n\n        # Deleting several items\n        elif type(key) is slice:\n            istart, istop, step = key.indices(len(self))\n            if istart > istop:\n                istart,istop = istop,istart\n            if istart == istop:\n                return\n            dstart = self._items[istart][0]\n            dstop  = self._items[istop-1][1]\n\n        # Ellipsis\n        elif key is Ellipsis:\n            istart,istop = 0, len(self)\n            dstart, dstop = 0, self.size\n        # Error\n        else:\n            raise TypeError(""List deletion indices must be integers"")\n\n        # Remove data\n        size = self._size - (dstop-dstart)\n        self._data[dstart:dstart+size] = self._data[dstop:dstop+size]\n        self._size -= dstop-dstart\n\n        # Remove corresponding items\n        size = self._count - istop\n        self._items[istart:istart+size] = self._items[istop:istop+size]\n\n        # Update other items\n        size = dstop-dstart\n        self._items[istart:istop+size+1] -= size, size\n        self._count -= istop-istart\n\n\n\n    def insert(self, index, data, sizes=None):\n        """""" Insert data before index\n\n        Parameters\n        ----------\n\n        index : int\n            Index before which data will be inserted.\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        sizes:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        """"""\n\n        if not self._sizeable:\n            raise RuntimeError(""List is not sizeable"")\n\n        if type(data) in [list,tuple] and type(data[0]) in [list,tuple]:\n            sizes = [len(l) for l in data]\n            data = [item for sublist in data for item in sublist]\n\n        data = np.array(data,copy=False).ravel()\n        size = data.size\n\n        # Check item size and get item number\n        if sizes is not None:\n            if type(sizes) is int:\n                if (size % sizes) != 0:\n                    raise ValueError(""Cannot partition data as requested"")\n                _count = size//sizes\n                _sizes = np.ones(_count,dtype=int)*(size//_count)\n            else:\n                _sizes = np.array(sizes,copy=False)\n                _count = len(sizes)\n                if _sizes.sum() != size:\n                    raise ValueError(""Cannot partition data as requested"")\n        else:\n            _count = 1\n\n        # Check if data array is big enough and resize it if necessary\n        if self._size + size  >= self._data.size:\n            capacity = int(2**np.ceil(np.log2(self._size + size)))\n            self._data = np.resize(self._data, capacity)\n\n        # Check if item array is big enough and resize it if necessary\n        if self._count + _count  >= len(self._items):\n            capacity = int(2**np.ceil(np.log2(self._count + _count)))\n            self._items = np.resize(self._items, (capacity, 2))\n        \n        # Check index\n        if index < 0:\n            index += len(self)\n        if index < 0 or index > len(self):\n            raise IndexError(""List insertion index out of range"")\n\n        # Inserting\n        if index < self._count:\n            istart = index\n            dstart = self._items[istart][0]\n            dstop  = self._items[istart][1]\n            # Move data\n            self._data[dstart+size:self._size+size] = self._data[dstart:self._size]\n            # Update moved items\n            I = self._items[istart:self._count]+size\n            self._items[istart+_count:self._count+_count] = I\n\n        # Appending\n        else:\n            dstart = self._size\n            istart = self._count\n\n        # Only one item (faster)\n        if _count == 1:\n            # Store data\n            self._data[dstart:dstart+size] = data\n            self._size += size\n            # Store data location (= item)\n            self._items[istart][0] = dstart\n            self._items[istart][1] = dstart+size\n            self._count += 1\n\n        # Several items\n        else:\n            # Store data\n            dstop = dstart + size\n            self._data[dstart:dstop] = data\n            self._size += size\n\n            # Store items\n            items = np.ones((_count,2),int)*dstart\n            C = _sizes.cumsum()\n            items[1:,0] += C[:-1]\n            items[0:,1] += C\n            istop = istart + _count\n            self._items[istart:istop] = items\n            self._count += _count\n\n\n    def append(self, data, sizes=None):\n        """"""\n        Append data to the end.\n\n        Parameters\n        ----------\n\n        data : array_like\n            An array, any object exposing the array interface, an object\n            whose __array__ method returns an array, or any (nested) sequence.\n\n        sizes:  int or 1-D array\n            If `itemsize is an integer, N, the array will be divided\n            into elements of size N. If such partition is not possible,\n            an error is raised.\n\n            If `itemsize` is 1-D array, the array will be divided into\n            elements whose successive sizes will be picked from itemsize.\n            If the sum of itemsize values is different from array size,\n            an error is raised.\n        """"""\n\n        self.insert(len(self), data, sizes)\n'"
code/benchmark.py,17,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom tools import timeit\n\nZ = np.ones(4*1000000, np.float32)\n\nprint("">>> Z.view(np.float16)[...] = 0"")\ntimeit(""Z.view(np.float16)[...] = 0"", globals())\n\nprint("">>> Z.view(np.int16)[...] = 0"")\ntimeit(""Z.view(np.int16)[...] = 0"", globals())\n\nprint("">>> Z.view(np.int32)[...] = 0"")\ntimeit(""Z.view(np.int32)[...] = 0"", globals())\n\nprint("">>> Z.view(np.float32)[...] = 0"")\ntimeit(""Z.view(np.float32)[...] = 0"", globals())\n\nprint("">>> Z.view(np.int64)[...] = 0"")\ntimeit(""Z.view(np.int64)[...] = 0"", globals())\n\nprint("">>> Z.view(np.float64)[...] = 0"")\ntimeit(""Z.view(np.float64)[...] = 0"", globals())\n\nprint("">>> Z.view(np.complex128)[...] = 0"")\ntimeit(""Z.view(np.complex128)[...] = 0"", globals())\n\nprint("">>> Z.view(np.int8)[...] = 0"")\ntimeit(""Z.view(np.int8)[...] = 0"", globals())\n'"
code/boid_numpy.py,45,"b'# -----------------------------------------------------------------------------\n# From Pytnon to Numpy\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.animation import FuncAnimation\nfrom matplotlib.collections import PathCollection\n\n\nclass MarkerCollection:\n    """"""\n    Marker collection\n    """"""\n\n    def __init__(self, n=100):\n        v = np.array([(-0.25, -0.25), (+0.0, +0.5), (+0.25, -0.25), (0, 0)])\n        c = np.array([Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY])\n        self._base_vertices = np.tile(v.reshape(-1), n).reshape(n, len(v), 2)\n        self._vertices = np.tile(v.reshape(-1), n).reshape(n, len(v), 2)\n        self._codes = np.tile(c.reshape(-1), n)\n\n        self._scale = np.ones(n)\n        self._translate = np.zeros((n, 2))\n        self._rotate = np.zeros(n)\n\n        self._path = Path(vertices=self._vertices.reshape(n*len(v), 2),\n                          codes=self._codes)\n        self._collection = PathCollection([self._path], linewidth=0.5,\n                                          facecolor=""k"", edgecolor=""w"")\n\n    def update(self):\n        n = len(self._base_vertices)\n        self._vertices[...] = self._base_vertices * self._scale\n        cos_rotate, sin_rotate = np.cos(self._rotate), np.sin(self._rotate)\n        R = np.empty((n, 2, 2))\n        R[:, 0, 0] = cos_rotate\n        R[:, 1, 0] = sin_rotate\n        R[:, 0, 1] = -sin_rotate\n        R[:, 1, 1] = cos_rotate\n        self._vertices[...] = np.einsum(\'ijk,ilk->ijl\', self._vertices, R)\n        self._vertices += self._translate.reshape(n, 1, 2)\n\n\nclass Flock:\n    def __init__(self, count=500, width=640, height=360):\n        self.width = width\n        self.height = height\n        self.min_velocity = 0.5\n        self.max_velocity = 2.0\n        self.max_acceleration = 0.03\n        self.velocity = np.zeros((count, 2), dtype=np.float32)\n        self.position = np.zeros((count, 2), dtype=np.float32)\n\n        angle = np.random.uniform(0, 2*np.pi, count)\n        self.velocity[:, 0] = np.cos(angle)\n        self.velocity[:, 1] = np.sin(angle)\n        angle = np.random.uniform(0, 2*np.pi, count)\n        radius = min(width, height)/2*np.random.uniform(0, 1, count)\n        self.position[:, 0] = width/2 + np.cos(angle)*radius\n        self.position[:, 1] = height/2 + np.sin(angle)*radius\n\n    def run(self):\n        position = self.position\n        velocity = self.velocity\n        min_velocity = self.min_velocity\n        max_velocity = self.max_velocity\n        max_acceleration = self.max_acceleration\n        n = len(position)\n\n        dx = np.subtract.outer(position[:, 0], position[:, 0])\n        dy = np.subtract.outer(position[:, 1], position[:, 1])\n        distance = np.hypot(dx, dy)\n\n        # Compute common distance masks\n        mask_0 = (distance > 0)\n        mask_1 = (distance < 25)\n        mask_2 = (distance < 50)\n        mask_1 *= mask_0\n        mask_2 *= mask_0\n        mask_3 = mask_2\n        mask_1_count = np.maximum(mask_1.sum(axis=1), 1)\n        mask_2_count = np.maximum(mask_2.sum(axis=1), 1)\n        mask_3_count = mask_2_count\n\n        # Separation\n        mask, count = mask_1, mask_1_count\n        target = np.dstack((dx, dy))\n        target = np.divide(target, distance.reshape(n, n, 1)**2, out=target,\n                           where=distance.reshape(n, n, 1) != 0)\n        steer = (target*mask.reshape(n, n, 1)).sum(axis=1)/count.reshape(n, 1)\n        norm = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        steer = max_velocity*np.divide(steer, norm, out=steer,\n                                       where=norm != 0)\n        steer -= velocity\n\n        # Limit acceleration\n        norm = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        steer = np.multiply(steer, max_acceleration/norm, out=steer,\n                            where=norm > max_acceleration)\n\n        separation = steer\n\n        # Alignment\n        # ---------------------------------------------------------------------\n        # Compute target\n        mask, count = mask_2, mask_2_count\n        target = np.dot(mask, velocity)/count.reshape(n, 1)\n\n        # Compute steering\n        norm = np.sqrt((target*target).sum(axis=1)).reshape(n, 1)\n        target = max_velocity * np.divide(target, norm, out=target,\n                                          where=norm != 0)\n        steer = target - velocity\n\n        # Limit acceleration\n        norm = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        steer = np.multiply(steer, max_acceleration/norm, out=steer,\n                            where=norm > max_acceleration)\n        alignment = steer\n\n        # Cohesion\n        # ---------------------------------------------------------------------\n        # Compute target\n        mask, count = mask_3, mask_3_count\n        target = np.dot(mask, position)/count.reshape(n, 1)\n\n        # Compute steering\n        desired = target - position\n        norm = np.sqrt((desired*desired).sum(axis=1)).reshape(n, 1)\n        desired *= max_velocity / norm\n        steer = desired - velocity\n\n        # Limit acceleration\n        norm = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        steer = np.multiply(steer, max_acceleration/norm, out=steer,\n                            where=norm > max_acceleration)\n        cohesion = steer\n\n        # ---------------------------------------------------------------------\n        acceleration = 1.5 * separation + alignment + cohesion\n        velocity += acceleration\n\n        norm = np.sqrt((velocity*velocity).sum(axis=1)).reshape(n, 1)\n        velocity = np.multiply(velocity, max_velocity/norm, out=velocity,\n                               where=norm > max_velocity)\n        velocity = np.multiply(velocity, min_velocity/norm, out=velocity,\n                               where=norm < min_velocity)\n        position += velocity\n\n        # Wraparound\n        position += (self.width, self.height)\n        position %= (self.width, self.height)\n\n\ndef update(*args):\n    global flock, collection, trace\n\n    # Flock updating\n    flock.run()\n    collection._scale = 10\n    collection._translate = flock.position\n    collection._rotate = -np.pi/2 + np.arctan2(flock.velocity[:, 1],\n                                               flock.velocity[:, 0])\n    collection.update()\n\n    # Trace updating\n    if trace is not None:\n        P = flock.position.astype(int)\n        trace[height-1-P[:, 1], P[:, 0]] = .75\n        trace *= .99\n        im.set_array(trace)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n\n    n = 500\n    width, height = 640, 360\n    flock = Flock(n)\n    fig = plt.figure(figsize=(10, 10*height/width), facecolor=""white"")\n    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], aspect=1, frameon=False)\n    collection = MarkerCollection(n)\n    ax.add_collection(collection._collection)\n    ax.set_xlim(0, width)\n    ax.set_ylim(0, height)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    # Trace\n    trace = None\n    if 0:\n        trace = np.zeros((height, width))\n        im = ax.imshow(trace, extent=[0, width, 0, height], vmin=0, vmax=1,\n                       interpolation=""nearest"", cmap=plt.cm.gray_r)\n\n    animation = FuncAnimation(fig, update, interval=10, frames=1000)\n    animation.save(\'boid.mp4\', fps=40, dpi=80, bitrate=-1, codec=""libx264"",\n                   extra_args=[\'-pix_fmt\', \'yuv420p\'],\n                   metadata={\'artist\': \'Nicolas P. Rougier\'})\n    plt.show()\n'"
code/boid_python.py,2,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport math\nimport random\nfrom vec2 import vec2\n\n\nclass Boid:\n    def __init__(self, x, y):\n        self.acceleration = vec2(0, 0)\n        angle = random.uniform(0, 2*math.pi)\n        self.velocity = vec2(math.cos(angle), math.sin(angle))\n        self.position = vec2(x, y)\n        self.r = 2.0\n        self.max_velocity = 2\n        self.max_acceleration = 0.03\n\n    def seek(self, target):\n        desired = target - self.position\n        desired = desired.normalized()\n        desired *= self.max_velocity\n        steer = desired - self.velocity\n        steer = steer.limited(self.max_acceleration)\n        return steer\n\n    # Wraparound\n    def borders(self):\n        x, y = self.position\n        x = (x+self.width) % self.width\n        y = (y+self.height) % self.height\n        self.position = vec2(x,y)\n\n    # Separation\n    # Method checks for nearby boids and steers away\n    def separate(self, boids):\n        desired_separation = 25.0\n        steer = vec2(0, 0)\n        count = 0\n\n        # For every boid in the system, check if it\'s too close\n        for other in boids:\n            d = (self.position - other.position).length()\n            # If the distance is greater than 0 and less than an arbitrary\n            # amount (0 when you are yourself)\n            if 0 < d < desired_separation:\n                # Calculate vector pointing away from neighbor\n                diff = self.position - other.position\n                diff = diff.normalized()\n                steer += diff/d  # Weight by distance\n                count += 1       # Keep track of how many\n\n        # Average - divide by how many\n        if count > 0:\n            steer /= count\n\n        # As long as the vector is greater than 0\n        if steer.length() > 0:\n            # Implement Reynolds: Steering = Desired - Velocity\n            steer = steer.normalized()\n            steer *= self.max_velocity\n            steer -= self.velocity\n            steer = steer.limited(self.max_acceleration)\n\n        return steer\n\n    # Alignment\n    # For every nearby boid in the system, calculate the average velocity\n    def align(self, boids):\n        neighbor_dist = 50\n        sum = vec2(0, 0)\n        count = 0\n        for other in boids:\n            d = (self.position - other.position).length()\n            if 0 < d < neighbor_dist:\n                sum += other.velocity\n                count += 1\n\n        if count > 0:\n            sum /= count\n            # Implement Reynolds: Steering = Desired - Velocity\n            sum = sum.normalized()\n            sum *= self.max_velocity\n            steer = sum - self.velocity\n            steer = steer.limited(self.max_acceleration)\n            return steer\n        else:\n            return vec2(0, 0)\n\n    # Cohesion\n    # For the average position (i.e. center) of all nearby boids, calculate\n    # steering vector towards that position\n    def cohesion(self, boids):\n        neighbor_dist = 50\n        sum = vec2(0, 0)  # Start with empty vector to accumulate all positions\n        count = 0\n        for other in boids:\n            d = (self.position - other.position).length()\n            if 0 < d < neighbor_dist:\n                sum += other.position  # Add position\n                count += 1\n        if count > 0:\n            sum /= count\n            return self.seek(sum)\n        else:\n            return vec2(0, 0)\n\n    def flock(self, boids):\n        sep = self.separate(boids)  # Separation\n        ali = self.align(boids)  # Alignment\n        coh = self.cohesion(boids)  # Cohesion\n\n        # Arbitrarily weight these forces\n        sep *= 1.5\n        ali *= 1.0\n        coh *= 1.0\n\n        # Add the force vectors to acceleration\n        self.acceleration += sep\n        self.acceleration += ali\n        self.acceleration += coh\n\n    def update(self):\n        # Update velocity\n        self.velocity += self.acceleration\n        # Limit speed\n        self.velocity = self.velocity.limited(self.max_velocity)\n        self.position += self.velocity\n        # Reset acceleration to 0 each cycle\n        self.acceleration = vec2(0, 0)\n\n    def run(self, boids):\n        self.flock(boids)\n        self.update()\n        self.borders()\n\n\nclass Flock:\n    def __init__(self, count=150, width=640, height=360):\n        self.width = width\n        self.height = height\n        self.boids = []\n        for i in range(count):\n            boid = Boid(width/2, height/2)\n            boid.width = width\n            boid.height = height\n            self.boids.append(boid)\n\n    def run(self):\n        for boid in self.boids:\n            # Passing the entire list of boids to each boid individually\n            boid.run(self.boids)\n\n    def cohesion(self, boids):\n        P = np.zeros((len(boids),2))\n        for i, boid in enumerate(self.boids):\n            P[i] = boid.cohesion(self.boids)\n        return P\n\n        \n\n            \nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\nn=50\nflock = Flock(n)\nP = np.zeros((n,2))\n\ndef update(*args):\n    flock.run()\n    for i,boid in enumerate(flock.boids):\n        P[i] = boid.position\n    scatter.set_offsets(P)\n\nfig = plt.figure(figsize=(8, 5))\nax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=True)\nscatter = ax.scatter(P[:,0], P[:,1],\n                     s=30, facecolor=""red"", edgecolor=""None"", alpha=0.5)\n\nanimation = FuncAnimation(fig, update, interval=10)\nax.set_xlim(0,640)\nax.set_ylim(0,360)\nax.set_xticks([])\nax.set_yticks([])\nplt.show()\n'"
code/c_fortran.py,2,"b""# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom display import display_2D_array\n\n\n\nif __name__ == '__main__':\n\n    Z1 = np.arange(9).reshape(3,3)\n    Z2 = np.arange(9).reshape(3, 3, order='F')\n\n    print(Z1.ravel())\n    print(Z2.ravel())\n"""
code/display.py,7,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\n\ndef display_2D_array(ax, Z, origin=""upper""):\n\n    rows, columns = Z.shape\n\n    fontsize = 10 * 8.0/max(rows,columns)\n    \n    ax.set_xlim(0, columns)\n    ax.set_xticks(np.arange(1, columns))\n    ax.set_ylim(0, rows)\n    ax.set_yticks(np.arange(1, rows))\n    ax.grid(color=""0.25"", linestyle=""-"", linewidth=0.5, alpha=0.5)\n    \n    for tick in ax.xaxis.get_major_ticks():\n        tick.tick1On = tick.tick2On = False\n    ax.set_xticklabels([])\n    for tick in ax.yaxis.get_major_ticks():\n        tick.tick1On = tick.tick2On = False\n    ax.set_yticklabels([])\n\n    for y in range(rows):\n        for x in range(columns):\n            text = str(Z[y,x])\n            if origin == ""upper"":\n                ax.text(x+0.5, rows-y-0.5, text, fontsize=fontsize,\n                         horizontalalignment=""center"", verticalalignment=""center"")\n            else:\n                ax.text(x+0.5, y+0.5, text, fontsize=fontsize,\n                         horizontalalignment=""center"", verticalalignment=""center"")\n\n    \n\ndef display(base, view, label, dx, dy):\n\n    fig = plt.figure(figsize=(10,5.5))\n    origin = ""upper""\n    _base = base.copy()\n    _view = view.copy()\n\n    itemsize = view.itemsize\n    offset_start = (np.byte_bounds(view)[0] - np.byte_bounds(base)[0])//itemsize\n    offset_stop = (np.byte_bounds(view)[-1] - np.byte_bounds(base)[-1]-1)//itemsize\n    index_start = np.array(np.unravel_index(offset_start, base.shape))\n    index_stop = np.array(np.unravel_index(base.size+offset_stop, base.shape))\n\n    \n    # Base\n    # ---------------------------------\n    ax1 = plt.subplot(1, 2, 1, aspect=1)\n    display_2D_array(ax1, _base, origin)\n    ax1.set_title(""base"", family=""Menlo"")\n\n    rows, columns = base.shape\n    base[...], view[...] = 0, 1\n    plt.imshow(base, extent=[0,columns, 0, rows], vmin=0, vmax=8,\n               interpolation = ""nearest"", cmap=""gray_r"", origin=origin)\n\n    y, x = index_start\n    h, w = index_stop - index_start + 1\n    if origin == ""upper"":\n        y = base.shape[0] - y - h\n    rect = patches.Rectangle((x,y), width=w, height=h,\n                             linewidth=1.5, linestyle=\'--\',\n                             edgecolor=\'k\', facecolor=\'none\',\n                             transform=ax1.transData)\n    ax1.add_patch(rect)\n\n\n    ox = x\n    oy = y\n    d = 1\n    arrowprops={""width"": .5,\n                ""headlength"": 6.0,\n                ""headwidth"": 6.0,\n                ""facecolor"": ""black"",\n                ""shrink"": 0.0}\n\n    if dx > 0: x0, x1,x2 = ox, ox+d, ox\n    else:      x0, x1, x2 = w+ox, w+ox-d, w+ox\n    if dy > 0: y0, y1,y2 = h+oy, h+oy-d, h+oy\n    else:      y0, y1, y2 = oy, oy+d, oy\n    ax1.annotate("""", arrowprops=arrowprops,\n                 xy=(x1, y0),  xycoords=\'data\',\n                 xytext=(x2, y0), textcoords=\'data\')\n    ax1.annotate("""", arrowprops=arrowprops,\n                 xy=(x0, y1),  xycoords=\'data\',\n                 xytext=(x0, y2), textcoords=\'data\')\n    plt.scatter([x0], [y0], s=50, facecolor=""white"", edgecolor=""black"", zorder=10)\n    \n    \n    # View\n    # ---------------------------------\n    ax2 = plt.subplot(1, 2, 2, aspect=1)\n    display_2D_array(ax2, _view, origin)\n    ax2.set_title(""view = base[%s]"" % label, family=""Menlo"")\n\n    plt.tight_layout()\n    plt.show()\n\n\nif __name__ == \'__main__\':\n    base = np.arange(9*9).reshape(9,9)\n\n    # view = base[-2:1:-2,-2:1:-2]\n    # display(base, view, ""-2:1:-2,-2:1:-2"", -1, -1)\n\n    view = base[1:-1:2, 1:-1:2]\n    display(base, view, ""1:-1:2, 1:-1:2"", +1, +1)\n'"
code/find_index.py,14,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef find_index(base, view):\n    """"""\n    Given an array that is a `view` of a `base`, find an index such that\n    `base[index] is view`\n    """"""\n\n    if not isinstance(view, np.ndarray):\n        return ""...""\n\n    itemsize = view.itemsize\n    offset_start = (np.byte_bounds(view)[0] - np.byte_bounds(base)[0])//itemsize\n    offset_stop = (np.byte_bounds(view)[-1] - np.byte_bounds(base)[-1]-1)//itemsize\n    index_start = np.unravel_index(offset_start, base.shape)\n    index_stop = np.unravel_index(base.size+offset_stop, base.shape)\n    index_step  = np.array(view.strides)//np.array(base.strides)\n\n    index = """"\n    for i in range(len(index_step)):\n        start = index_start[i]\n        stop = index_stop[i]\n        step = index_step[i]\n\n        if stop == start:\n            stop, step = None, None\n        else:\n            if stop == base.shape[i] - 1:\n                stop = None\n            else:\n                stop = stop\n            if start == 0:\n                start = None\n        if step is not None and stop is not None:\n            if step < 0:\n                start, stop = stop, start - 1\n            else:\n                start, stop = start, stop + 1\n            \n        if start is not None:\n            index += str(start)\n        if stop is not None:\n            index += "":"" + str(stop)\n        elif step is not None:\n            index += "":""\n        if step is not None:\n            index += "":"" + str(step)\n        index += \',\'\n    index = index[:-1]\n\n    return index\n\n\n\nif __name__ == \'__main__\':\n\n    base = np.arange(8*8).reshape(8,8)\n\n    # Sub-array\n    Z = base[1:-1,1:-1]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n    \n    # Every two items\n    Z = base[::2,::2]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n    \n    # First column\n    Z = base[:,0]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n    \n    # First row\n    Z = base[0,:]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n    \n    # Partial reverse\n    Z = base[4:1:-1,6:2:-1]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n    \n    # # Full reverse\n    Z = base[::-1,::-1]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n\n    # Random\n    Z = base[1:5:3,3:1:-1]\n    index = find_index(base,Z)\n    print(np.allclose(Z, eval(""base[%s]"" % index)))\n\n'"
code/fractal_dimension.py,8,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef fractal_dimension(Z, threshold=0.9):\n    def boxcount(Z, k):\n        S = np.add.reduceat(\n            np.add.reduceat(Z, np.arange(0, Z.shape[0], k), axis=0),\n                               np.arange(0, Z.shape[1], k), axis=1)\n        return len(np.where((S > 0) & (S < k*k))[0])\n    Z = (Z < threshold)\n    p = min(Z.shape)\n    n = 2**np.floor(np.log(p)/np.log(2))\n    n = int(np.log(n)/np.log(2))\n    sizes = 2**np.arange(n, 1, -1)\n    counts = []\n    for size in sizes:\n        counts.append(boxcount(Z, size))\n    coeffs = np.polyfit(np.log(sizes), np.log(counts), 1)\n    return -coeffs[0]\n\n\nif __name__ == \'__main__\':\n    from scipy import misc\n    import matplotlib.pyplot as plt\n    import matplotlib.patches as patches\n\n    Z = 1.0 - misc.imread(""../data/Great-Britain.png"")/255\n\n    print(fractal_dimension(Z, threshold=0.25))\n\n    sizes = 128, 64, 32\n    xmin, xmax = 0, Z.shape[1]\n    ymin, ymax = 0, Z.shape[0]\n    fig = plt.figure(figsize=(10, 5))\n\n    for i, size in enumerate(sizes):\n        ax = plt.subplot(1, len(sizes), i+1, frameon=False)\n        ax.imshow(1-Z, plt.cm.gray, interpolation=""bicubic"", vmin=0, vmax=1,\n                  extent=[xmin, xmax, ymin, ymax], origin=""upper"")\n        ax.set_xticks([])\n        ax.set_yticks([])\n        for y in range(Z.shape[0]//size+1):\n            for x in range(Z.shape[1]//size+1):\n                s = (Z[y*size:(y+1)*size, x*size:(x+1)*size] > 0.25).sum()\n                if s > 0 and s < size*size:\n                    rect = patches.Rectangle(\n                        (x*size, Z.shape[0]-1-(y+1)*size),\n                        width=size, height=size,\n                        linewidth=.5, edgecolor=\'.25\',\n                        facecolor=\'.75\', alpha=.5)\n                    ax.add_patch(rect)\n\n    plt.tight_layout()\n    plt.savefig(""fractal-dimension.png"")\n    plt.show()\n'"
code/game_of_life_numpy.py,3,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n\ndef update(*args):\n    global Z, M\n\n    N = (Z[0:-2, 0:-2] + Z[0:-2, 1:-1] + Z[0:-2, 2:] +\n         Z[1:-1, 0:-2]                 + Z[1:-1, 2:] +\n         Z[2:  , 0:-2] + Z[2:  , 1:-1] + Z[2:  , 2:])\n    birth = (N == 3) & (Z[1:-1, 1:-1] == 0)\n    survive = ((N == 2) | (N == 3)) & (Z[1:-1, 1:-1] == 1)\n    Z[...] = 0\n    Z[1:-1, 1:-1][birth | survive] = 1\n\n    # Show past activities\n    M[M>0.25] = 0.25\n    M *= 0.995\n    M[Z==1] = 1\n    # Direct activity\n    # M[...] = Z\n    im.set_data(M)\n\n\nZ = np.random.randint(0, 2, (300, 600))\nM = np.zeros(Z.shape)\n\nsize = np.array(Z.shape)\ndpi = 80.0\nfigsize = size[1]/float(dpi), size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi)\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nim = plt.imshow(M, interpolation=\'nearest\', cmap=plt.cm.gray_r, vmin=0, vmax=1)\nplt.xticks([]), plt.yticks([])\n\nanimation = FuncAnimation(fig, update, interval=10, frames=2000)\n# animation.save(\'game-of-life.mp4\', fps=40, dpi=80, bitrate=-1, codec=""libx264"",\n#                extra_args=[\'-pix_fmt\', \'yuv420p\'],\n#                metadata={\'artist\':\'Nicolas P. Rougier\'})\nplt.show()\n'"
code/game_of_life_python.py,0,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\n\ndef compute_neighbours(Z):\n    shape = len(Z), len(Z[0])\n    N = [[0, ]*(shape[0]) for i in range(shape[1])]\n    for x in range(1, shape[0]-1):\n        for y in range(1, shape[1]-1):\n            N[x][y] = Z[x-1][y-1]+Z[x][y-1]+Z[x+1][y-1] \\\n                    + Z[x-1][y]            +Z[x+1][y]   \\\n                    + Z[x-1][y+1]+Z[x][y+1]+Z[x+1][y+1]\n    return N\n\n\ndef iterate(Z):\n    shape = len(Z), len(Z[0])\n\n    N = compute_neighbours(Z)\n    for x in range(1, shape[0]-1):\n        for y in range(1, shape[1]-1):\n            if Z[x][y] == 1 and (N[x][y] < 2 or N[x][y] > 3):\n                Z[x][y] = 0\n            elif Z[x][y] == 0 and N[x][y] == 3:\n                Z[x][y] = 1\n    return Z\n\nif __name__ == \'__main__\':\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Rectangle\n\n    Z = [[0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 1, 0, 0],\n         [0, 1, 0, 1, 0, 0],\n         [0, 0, 1, 1, 0, 0],\n         [0, 0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0, 0]]\n\n    figure = plt.figure(figsize=(12, 3))\n\n    labels = (""Initial state"",\n              ""iteration 1"", ""iteration 2"",\n              ""iteration 3"", ""iteration 4"")\n\n    for i in range(5):\n        ax = plt.subplot(1, 5, i+1, aspect=1, frameon=False)\n\n        for x in range(1, 5):\n            for y in range(1, 5):\n                if Z[x][y] == 1:\n                    facecolor = \'black\'\n                else:\n                    facecolor = \'white\'\n                rect = Rectangle((x, 5-y), width=0.9, height=0.9,\n                                 linewidth=1.0, edgecolor=\'black\',\n                                 facecolor=facecolor)\n                ax.add_patch(rect)\n        ax.set_xlim(.9, 5.1)\n        ax.set_ylim(.9, 5.1)\n        ax.set_xticks([])\n        ax.set_yticks([])\n        ax.set_xlabel(labels[i])\n\n        for tick in ax.xaxis.get_major_ticks():\n            tick.tick1On = tick.tick2On = False\n        for tick in ax.yaxis.get_major_ticks():\n            tick.tick1On = tick.tick2On = False\n\n        iterate(Z)\n\n    plt.tight_layout()\n    plt.savefig(""glider.png"")\n    plt.show()\n'"
code/gpudata.py,13,"b'# -----------------------------------------------------------------------------\n# Copyright (c) 2009-2016 Nicolas P. Rougier. All rights reserved.\n# Distributed under the (new) BSD License.\n# -----------------------------------------------------------------------------\n""""""\nGPU data is the base class for any data that needs to co-exist on both CPU and\nGPU memory. It keeps track of the smallest contiguous area that needs to be\nuploaded to GPU to keep the CPU and GPU data synced. This allows to update the\ndata in one operation. Even though this might be sub-optimal in a few cases, it\nprovides a greater usage flexibility and most of the time, it will be faster.\n\nThis is done transparently and user can use a GPU buffer as a regular numpy\narray. The `pending_data` property indicates the region (offset/nbytes) of\nthe base array that needs to be uploaded.\n\n**Example**:\n\n  .. code::\n\n     data = np.zeros((5,5)).view(GPUData)\n     print data.pending_data\n     (0, 200)\n""""""\nimport numpy as np\n\n\nclass GPUData(np.ndarray):\n    """"""\n    Memory tracked numpy array.\n    """"""\n\n    def __new__(cls, *args, **kwargs):\n        return np.ndarray.__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        pass\n\n    def __array_finalize__(self, obj):\n        if not isinstance(obj, GPUData):\n            self._extents = 0, self.size*self.itemsize\n            self.__class__.__init__(self)\n            self._pending_data = self._extents\n        else:\n            self._extents = obj._extents\n\n\n    @property\n    def pending_data(self):\n        """""" Pending data region as (byte offset, byte size) """"""\n\n        if isinstance(self.base, GPUData):\n            return self.base.pending_data\n\n        if self._pending_data:\n            return self._pending_data\n            # start, stop = self._pending_data\n            # WARN: semantic is offset, nbytes\n            # extents semantic is start, stop\n            # return start, stop-start\n            return start, stop\n        else:\n            return None\n\n    @property\n    def stride(self):\n        """""" Item stride in the base array. """"""\n\n        if self.base is None:\n            return self.ravel().strides[0]\n        else:\n            return self.base.ravel().strides[0]\n\n    @property\n    def offset(self):\n        """""" Byte offset in the base array. """"""\n\n        return self._extents[0]\n\n\n    def _add_pending_data(self, start, stop):\n        """"""\n        Add pending data, taking care of previous pending data such that it\n        is always a contiguous area.\n        """"""\n        base = self.base\n        if isinstance(base, GPUData):\n            base._add_pending_data(start, stop)\n        else:\n            if self._pending_data is None:\n                self._pending_data = start, stop\n            else:\n                start = min(self._pending_data[0], start)\n                stop = max(self._pending_data[1], stop)\n                self._pending_data = start, stop\n\n    def _compute_extents(self, Z):\n        """"""\n        Compute extents (start, stop) in the base array.\n        """"""\n\n        if self.base is not None:\n            base = self.base.__array_interface__[\'data\'][0]\n            view = Z.__array_interface__[\'data\'][0]\n            offset = view - base\n            shape = np.array(Z.shape) - 1\n            strides = np.array(Z.strides)\n            size = (shape*strides).sum() + Z.itemsize\n            return offset, offset+size\n        else:\n            return 0, self.size*self.itemsize\n\n\n    def __getitem__(self, key):\n        """""" FIXME: Need to take care of case where key is a list or array """"""\n\n        Z = np.ndarray.__getitem__(self, key)\n        if not hasattr(Z,\'shape\') or Z.shape == ():\n            return Z\n        Z._extents = self._compute_extents(Z)\n        return Z\n\n    def __setitem__(self, key, value):\n        """""" FIXME: Need to take care of case where key is a list or array """"""\n        \n        Z = np.ndarray.__getitem__(self, key)\n        if Z.shape == ():\n            # WARN: Be careful with negative indices !\n            key = np.mod(np.array(key)+self.shape, self.shape)\n            offset = self._extents[0]+(key * self.strides).sum()\n            size = Z.itemsize\n            self._add_pending_data(offset, offset+size)\n            key = tuple(key)\n        else:\n            Z._extents = self._compute_extents(Z)\n            self._add_pending_data(Z._extents[0], Z._extents[1])\n        np.ndarray.__setitem__(self, key, value)\n\n\n    def __getslice__(self, start, stop):\n        return self.__getitem__(slice(start, stop))\n\n    def __setslice__(self, start, stop,  value):\n        return self.__setitem__(slice(start, stop), value)\n\n    def __iadd__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__iadd__(self, other)\n\n    def __isub__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__isub__(self, other)\n\n    def __imul__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__imul__(self, other)\n\n    def __idiv__(self, other):\n        self._add_pending_data(self._extents[0], self._extents[1])\n        return np.ndarray.__idiv__(self, other)\n'"
code/gray_scott.py,4,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n\n# Parameters from http://www.aliensaint.com/uo/java/rd/\n# -----------------------------------------------------\nn = 256\nDu, Dv, F, k = 0.16, 0.08, 0.035, 0.065  # Bacteria 1\n# Du, Dv, F, k = 0.14, 0.06, 0.035, 0.065  # Bacteria 2\n# Du, Dv, F, k = 0.16, 0.08, 0.060, 0.062  # Coral\n# Du, Dv, F, k = 0.19, 0.05, 0.060, 0.062  # Fingerprint\n# Du, Dv, F, k = 0.10, 0.10, 0.018, 0.050  # Spirals\n# Du, Dv, F, k = 0.12, 0.08, 0.020, 0.050  # Spirals Dense\n# Du, Dv, F, k = 0.10, 0.16, 0.020, 0.050  # Spirals Fast\n# Du, Dv, F, k = 0.16, 0.08, 0.020, 0.055  # Unstable\n# Du, Dv, F, k = 0.16, 0.08, 0.050, 0.065  # Worms 1\n# Du, Dv, F, k = 0.16, 0.08, 0.054, 0.063  # Worms 2\n# Du, Dv, F, k = 0.16, 0.08, 0.035, 0.060  # Zebrafish\n\n\nZ = np.zeros((n+2, n+2), [(\'U\', np.double),\n                          (\'V\', np.double)])\nU, V = Z[\'U\'], Z[\'V\']\nu, v = U[1:-1, 1:-1], V[1:-1, 1:-1]\n\nr = 20\nu[...] = 1.0\nU[n//2-r:n//2+r, n//2-r:n//2+r] = 0.50\nV[n//2-r:n//2+r, n//2-r:n//2+r] = 0.25\nu += 0.05*np.random.uniform(-1, +1, (n, n))\nv += 0.05*np.random.uniform(-1, +1, (n, n))\n\n\ndef update(frame):\n    global U, V, u, v, im\n\n    for i in range(10):\n        Lu = (                  U[0:-2, 1:-1] +\n              U[1:-1, 0:-2] - 4*U[1:-1, 1:-1] + U[1:-1, 2:] +\n                                U[2:  , 1:-1])\n        Lv = (                  V[0:-2, 1:-1] +\n              V[1:-1, 0:-2] - 4*V[1:-1, 1:-1] + V[1:-1, 2:] +\n                                V[2:  , 1:-1])\n        uvv = u*v*v\n        u += (Du*Lu - uvv + F*(1-u))\n        v += (Dv*Lv + uvv - (F+k)*v)\n\n    im.set_data(V)\n    im.set_clim(vmin=V.min(), vmax=V.max())\n\nfig = plt.figure(figsize=(4, 4))\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nim = plt.imshow(V, interpolation=\'bicubic\', cmap=plt.cm.viridis)\nplt.xticks([]), plt.yticks([])\nanimation = FuncAnimation(fig, update, interval=10, frames=2000)\n# animation.save(\'gray-scott-1.mp4\', fps=40, dpi=80, bitrate=-1, codec=""libx264"",\n#                extra_args=[\'-pix_fmt\', \'yuv420p\'],\n#                metadata={\'artist\':\'Nicolas P. Rougier\'})\nplt.show()\n'"
code/mandelbrot.py,12,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\ndef mandelbrot(xmin, xmax, ymin, ymax, xn, yn, itermax, horizon=2.0):\n    # Adapted from\n    # https://thesamovar.wordpress.com/2009/03/22/fast-fractals-with-python-and-numpy/\n    Xi, Yi = np.mgrid[0:xn, 0:yn]\n    Xi, Yi = Xi.astype(np.uint32), Yi.astype(np.uint32)\n    X = np.linspace(xmin, xmax, xn, dtype=np.float32)[Xi]\n    Y = np.linspace(ymin, ymax, yn, dtype=np.float32)[Yi]\n    C = X + Y*1j\n    N_ = np.zeros(C.shape, dtype=np.uint32)\n    Z_ = np.zeros(C.shape, dtype=np.complex64)\n    Xi.shape = Yi.shape = C.shape = xn*yn\n    \n    Z = np.zeros(C.shape, np.complex64)\n    for i in range(itermax):\n        if not len(Z): break\n\n        # Compute for relevant points only\n        np.multiply(Z, Z, Z)\n        np.add(Z, C, Z)\n\n        # Failed convergence\n        I = abs(Z) > horizon\n        N_[Xi[I], Yi[I]] = i+1\n        Z_[Xi[I], Yi[I]] = Z[I]\n\n        # Keep going with those who have not diverged yet\n        np.negative(I,I)\n        Z = Z[I]\n        Xi, Yi = Xi[I], Yi[I]\n        C = C[I]\n    return Z_.T, N_.T\n\n\nif __name__ == \'__main__\':\n    from matplotlib import colors\n    import matplotlib.pyplot as plt\n    from tools import timeit\n\n    # Benchmark\n    xmin, xmax, xn = -2.25, +0.75, int(3000/3)\n    ymin, ymax, yn = -1.25, +1.25, int(2500/3)\n    maxiter = 200\n    timeit(""mandelbrot_1(xmin, xmax, ymin, ymax, xn, yn, maxiter)"", globals())\n    timeit(""mandelbrot_2(xmin, xmax, ymin, ymax, xn, yn, maxiter)"", globals())\n    timeit(""mandelbrot_3(xmin, xmax, ymin, ymax, xn, yn, maxiter)"", globals())\n\n    # Visualization\n    xmin, xmax, xn = -2.25, +0.75, int(3000/2)\n    ymin, ymax, yn = -1.25, +1.25, int(2500/2)\n    maxiter = 200\n    horizon = 2.0 ** 40\n    log_horizon = np.log(np.log(horizon))/np.log(2)\n    Z, N = mandelbrot(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon)\n\n    # Normalized recount as explained in:\n    # http://linas.org/art-gallery/escape/smooth.html\n    M = np.nan_to_num(N + 1 - np.log(np.log(abs(Z)))/np.log(2) + log_horizon)\n    \n    dpi = 72\n    width = 10\n    height = 10*yn/xn\n    \n    fig = plt.figure(figsize=(width, height), dpi=dpi)\n    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False, aspect=1)\n\n    light = colors.LightSource(azdeg=315, altdeg=10)\n    plt.imshow(light.shade(M, cmap=plt.cm.hot, vert_exag=1.5,\n                           norm = colors.PowerNorm(0.3), blend_mode=\'hsv\'),\n               extent=[xmin, xmax, ymin, ymax], interpolation=""bicubic"")\n    ax.set_xticks([])\n    ax.set_yticks([])\n    plt.savefig(""../data/mandelbrot.png"")\n    plt.show()\n\n'"
code/mandelbrot_numpy_1.py,5,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\ndef mandelbrot(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n    # Adapted from https://www.ibm.com/developerworks/community/blogs/jfp/...\n    #              .../entry/How_To_Compute_Mandelbrodt_Set_Quickly?lang=en\n    X = np.linspace(xmin, xmax, xn, dtype=np.float32)\n    Y = np.linspace(ymin, ymax, yn, dtype=np.float32)\n    C = X + Y[:,None]*1j\n    N = np.zeros(C.shape, dtype=int)\n    Z = np.zeros(C.shape, np.complex64)\n    for n in range(maxiter):\n        I = np.less(abs(Z), horizon)\n        N[I] = n\n        Z[I] = Z[I]**2 + C[I]\n    N[N == maxiter-1] = 0\n    return Z, N\n'"
code/mandelbrot_numpy_2.py,10,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef mandelbrot(xmin, xmax, ymin, ymax, xn, yn, itermax, horizon=2.0):\n    # Adapted from\n    # https://thesamovar.wordpress.com/2009/03/22/fast-fractals-with-python-and-numpy/\n    Xi, Yi = np.mgrid[0:xn, 0:yn]\n    Xi, Yi = Xi.astype(np.uint32), Yi.astype(np.uint32)\n    X = np.linspace(xmin, xmax, xn, dtype=np.float32)[Xi]\n    Y = np.linspace(ymin, ymax, yn, dtype=np.float32)[Yi]\n    C = X + Y*1j\n    N_ = np.zeros(C.shape, dtype=np.uint32)\n    Z_ = np.zeros(C.shape, dtype=np.complex64)\n    Xi.shape = Yi.shape = C.shape = xn*yn\n\n    Z = np.zeros(C.shape, np.complex64)\n    for i in range(itermax):\n        if not len(Z):\n            break\n\n        # Compute for relevant points only\n        np.multiply(Z, Z, Z)\n        np.add(Z, C, Z)\n\n        # Failed convergence\n        I = abs(Z) > horizon\n        N_[Xi[I], Yi[I]] = i+1\n        Z_[Xi[I], Yi[I]] = Z[I]\n\n        # Keep going with those who have not diverged yet\n        np.negative(I, I)\n        Z = Z[I]\n        Xi, Yi = Xi[I], Yi[I]\n        C = C[I]\n    return Z_.T, N_.T\n'"
code/mandelbrot_python.py,0,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef mandelbrot(xmin, xmax, ymin, ymax, xn, yn, maxiter, horizon=2.0):\n    def mandelbrot(z, maxiter):\n        c = z\n        for n in range(maxiter):\n            if abs(z) > horizon:\n                return n\n            z = z*z + c\n        return maxiter\n    r1 = [xmin+i*(xmax-xmin)/xn for i in range(xn)]\n    r2 = [ymin+i*(ymax-ymin)/yn for i in range(yn)]\n    return [mandelbrot(complex(r, i), maxiter) for r in r1 for i in r2]\n'"
code/marker_collection.py,15,"b'# Matplotlib / individual rotation markers using a single path\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.path import Path\nfrom matplotlib.animation import FuncAnimation\nfrom matplotlib.collections import PathCollection\n\n\ntriangle = [[(-0.25, -0.5), (+0.0, +0.5), (+0.25, -0.5), (+0.0, +0.0)],\n            [Path.MOVETO, Path.LINETO, Path.LINETO, Path.CLOSEPOLY]]\n\n\nclass MarkerCollection:\n    def __init__(self, n=100, marker=triangle):\n        v, c = marker\n        v, c = np.array(v), np.array(c)\n        self._marker = marker\n        self._base_vertices = np.tile(v.reshape(-1), n).reshape(n, len(v), 2)\n        self._vertices = np.tile(v.reshape(-1), n).reshape(n, len(v), 2)\n        self._codes = np.tile(c.reshape(-1), n)\n        self._scale = np.ones(n)\n        self._translate = np.zeros((n, 2))\n        self._rotate = np.zeros(n)\n        self._path = Path(vertices=self._vertices.reshape(n*len(v), 2),\n                          codes=self._codes)\n        self._collection = PathCollection(\n            [self._path], facecolor=""white"", edgecolor=""black"")\n\n    def __len__(self):\n        return len(self._base_vertices)\n\n    def scale(self, scale):\n        self._scale = scale\n\n    def translate(self, translate):\n        self._translate = translate.reshape(len(self), 1, 2)\n\n    def rotate(self, rotate):\n        self._rotate = rotate\n\n    def update(self):\n        n = len(self)\n\n        # Scale\n        self._vertices[...] = self._base_vertices * self._scale\n\n        # Rotation\n        cos_rotate, sin_rotate = np.cos(self._rotate), np.sin(self._rotate)\n        R = np.empty((n, 2, 2))\n        R[:, 0, 0] = cos_rotate\n        R[:, 1, 0] = sin_rotate\n        R[:, 0, 1] = -sin_rotate\n        R[:, 1, 1] = cos_rotate\n        self._vertices[...] = np.einsum(\'ijk,ilk->ijl\', self._vertices, R)\n\n        # Translation\n        self._vertices += self._translate\n\nfig = plt.figure(figsize=(8, 8))\nax = plt.subplot(1, 1, 1, aspect=1)\n\nn = 750\ncollection = MarkerCollection(n)\ncollection.scale(0.025)\ncollection.rotate(np.linspace(0, 2*np.pi, n, endpoint=False))\nradius = 0.75\nangle = np.linspace(0, 2*np.pi, n, endpoint=False)\nxy = np.dstack((radius*np.cos(angle), radius*np.sin(angle)))\n\ncollection.translate(np.random.uniform(-1,1,(n,2)))\ncollection.update()\n\nax.add_collection(collection._collection)\nax.set_xlim(-1, 1)\nax.set_ylim(-1, 1)\n\ndef update(*args):\n    collection._rotate += np.pi/50\n    collection.update()\n\nanimation = FuncAnimation(fig, update, interval=10)\nplt.show()\n'"
code/maze_build.py,4,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n\ndef build_maze(shape=(65, 65), complexity=0.75, density=0.50):\n    """"""\n    Build a maze using given complexity and density\n\n    Parameters\n    ==========\n\n    shape : (rows,cols)\n      Size of the maze\n\n    complexity: float\n      Mean length of islands (as a ratio of maze size)\n\n    density: float\n      Mean numbers of highland (as a ratio of maze surface)\n\n    """"""\n\n    # Only odd shapes\n    shape = ((shape[0]//2)*2+1, (shape[1]//2)*2+1)\n\n    # Adjust complexity and density relatively to maze size\n    n_complexity = int(complexity*(shape[0]+shape[1]))\n    n_density = int(density*(shape[0]*shape[1]))\n\n    # Build actual maze\n    Z = np.zeros(shape, dtype=bool)\n\n    # Fill borders\n    Z[0, :] = Z[-1, :] = Z[:, 0] = Z[:, -1] = 1\n\n    # Islands starting point with a bias in favor of border\n    P = np.random.normal(0, 0.5, (n_density, 2))\n    P = 0.5 - np.maximum(-0.5, np.minimum(P, +0.5))\n    P = (P*[shape[1], shape[0]]).astype(int)\n    P = 2*(P//2)\n\n    # Create islands\n    for i in range(n_density):\n\n        # Test for early stop: if all starting point are busy, this means we\n        # won\'t be able to connect any island, so we stop.\n        T = Z[2:-2:2, 2:-2:2]\n        if T.sum() == T.size:\n            break\n\n        x, y = P[i]\n        Z[y, x] = 1\n        for j in range(n_complexity):\n            neighbours = []\n            if x > 1:\n                neighbours.append([(y, x-1), (y, x-2)])\n            if x < shape[1]-2:\n                neighbours.append([(y, x+1), (y, x+2)])\n            if y > 1:\n                neighbours.append([(y-1, x), (y-2, x)])\n            if y < shape[0]-2:\n                neighbours.append([(y+1, x), (y+2, x)])\n            if len(neighbours):\n                choice = np.random.randint(len(neighbours))\n                next_1, next_2 = neighbours[choice]\n                if Z[next_2] == 0:\n                    Z[next_1] = 1\n                    yield Z.copy()\n                    Z[next_2] = 1\n                    yield Z.copy()\n                    y, x = next_2\n            else:\n                break\n    return Z\n\n\nif __name__ == \'__main__\':\n    S = []\n    for i, Z in enumerate(build_maze((51, 101))):\n        S.append(Z)\n\n    fig = plt.figure(figsize=(10, 5))\n    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False, aspect=1)\n    im = ax.imshow(S[0], cmap=plt.cm.gray_r,\n                   interpolation=\'nearest\', animated=True)\n    ax.set_xticks([]), ax.set_yticks([])\n\n    def update(frame):\n        im.set_array(S[frame])\n        return im,\n    animation = FuncAnimation(fig, update, interval=10, frames=len(S))\n    # animation.save(\'maze-build.mp4\', fps=40, dpi=80, bitrate=-1,\n    #                codec=""libx264"", extra_args=[\'-pix_fmt\', \'yuv420p\'],\n    #                metadata={\'artist\':\'Nicolas P. Rougier\'})\n    # plt.show()\n'"
code/maze_numpy.py,11,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom collections import deque\nimport matplotlib.pyplot as plt\nfrom scipy.ndimage import generic_filter\n\n\ndef build_maze(shape=(65,65), complexity=0.75, density = 0.50):\n    """"""\n    Build a maze using given complexity and density\n\n    Parameters\n    ==========\n\n    shape : (rows,cols)\n      Size of the maze\n\n    complexity: float\n      Mean length of islands (as a ratio of maze size)\n\n    density: float\n      Mean numbers of highland (as a ratio of maze surface)\n\n    """"""\n    \n    # Only odd shapes\n    shape = ((shape[0]//2)*2+1, (shape[1]//2)*2+1)\n\n    # Adjust complexity and density relatively to maze size\n    n_complexity = int(complexity*(shape[0]+shape[1]))\n    n_density    = int(density*(shape[0]*shape[1]))\n\n    # Build actual maze\n    Z = np.zeros(shape, dtype=bool)\n\n    # Fill borders\n    Z[0,:] = Z[-1,:] = Z[:,0] = Z[:,-1] = 1\n\n    # Islands starting point with a bias in favor of border\n    P = np.random.normal(0, 0.5, (n_density,2))\n    P = 0.5 - np.maximum(-0.5, np.minimum(P, +0.5))\n    P = (P*[shape[1],shape[0]]).astype(int)\n    P = 2*(P//2)\n    \n    # Create islands\n    for i in range(n_density):\n\n        # Test for early stop: if all starting point are busy, this means we\n        # won\'t be able to connect any island, so we stop.\n        T = Z[2:-2:2,2:-2:2]\n        if T.sum() == T.size:\n            break\n\n        x, y = P[i]\n        Z[y,x] = 1\n        for j in range(n_complexity):\n            neighbours = []\n            if x > 1:\n                neighbours.append([(y, x-1), (y, x-2)])\n            if x < shape[1]-2:\n                neighbours.append([(y, x+1), (y, x+2)])\n            if y > 1:\n                neighbours.append([(y-1, x), (y-2, x)])\n            if y < shape[0]-2:\n                neighbours.append([(y+1, x), (y+2, x)])\n            if len(neighbours):\n                choice = np.random.randint(len(neighbours))\n                next_1, next_2 = neighbours[choice]\n                if Z[next_2] == 0:\n                    Z[next_1] = Z[next_2] = 1\n                    y, x = next_2\n            else:\n                break\n    return Z\n\n\n# ------------------------------------------------------ find_shortest_path ---\ndef BellmanFord(Z, start, goal):\n\n    # We reserve Z such that walls have value 0\n    Z = 1 - Z\n    \n    # Build gradient array\n    G = np.zeros(Z.shape)\n\n    # Initialize gradient at the entrance with value 1\n    G[start] = 1\n\n    # Discount factor\n    gamma = 0.99\n    \n    def diffuse(Z):\n        # North, West, Center, East, South\n        return max(gamma*Z[0], gamma*Z[1], Z[2], gamma*Z[3], gamma*Z[4])\n\n    # Shortest path in best case cannot be less the Manhattan distance\n    # from entrance to exit\n    length = Z.shape[0]+Z.shape[1]\n\n    # We iterate until value at exit is > 0. This requires the maze\n    # to have a solution or it will be stuck in the loop.\n\n    G_gamma = np.empty_like(G)\n    while G[goal] == 0.0:\n        # Slow\n        # G = Z * generic_filter(G, diffuse, footprint=[[0, 1, 0],\n        #                                               [1, 1, 1],\n        #                                               [0, 1, 0]])\n\n        # Fast\n        np.multiply(G, gamma, out=G_gamma)\n        N = G_gamma[0:-2,1:-1]\n        W = G_gamma[1:-1,0:-2]\n        C = G[1:-1,1:-1]\n        E = G_gamma[1:-1,2:]\n        S = G_gamma[2:,1:-1]\n        G[1:-1,1:-1] = Z[1:-1,1:-1]*np.maximum(N,np.maximum(W,np.maximum(C,np.maximum(E,S))))\n    \n    # Descent gradient to find shortest path from entrance to exit\n    y, x = goal\n    P = []\n    dirs = [(0,-1), (0,+1), (-1,0), (+1,0)]\n    while (x, y) != start:\n        P.append((x, y))\n        neighbours = [-1, -1, -1, -1]\n        if x > 0:\n            neighbours[0] = G[y, x-1]\n        if x < G.shape[1]-1:\n            neighbours[1] = G[y, x+1]\n        if y > 0:\n            neighbours[2] = G[y-1, x]\n        if y < G.shape[0]-1:\n            neighbours[3] = G[y+1, x]\n        a = np.argmax(neighbours)\n        x, y  = x + dirs[a][1], y + dirs[a][0]\n    P.append((x, y))\n    return G, np.array(P)\n\ndef build_graph(maze):\n    height, width = maze.shape\n    graph = {(i, j): [] for j in range(width) for i in range(height) if not maze[i][j]}\n    for row, col in graph.keys():\n        if row < height - 1 and not maze[row + 1][col]:\n            graph[(row, col)].append((""S"", (row + 1, col)))\n            graph[(row + 1, col)].append((""N"", (row, col)))\n        if col < width - 1 and not maze[row][col + 1]:\n            graph[(row, col)].append((""E"", (row, col + 1)))\n            graph[(row, col + 1)].append((""W"", (row, col)))\n    return graph\n\ndef BreadthFirst(maze, start, goal):\n    queue = deque([([start], start)])\n    visited = set()\n    graph = build_graph(maze)\n    while queue:\n        path, current = queue.popleft()\n        if current == goal:\n            return np.array(path)\n        if current in visited:\n            continue\n        visited.add(current)\n        for direction, neighbour in graph[current]:\n            p = list(path)\n            p.append(neighbour)\n            queue.append((p, neighbour))\n    return None\n\n\n# -------------------------------------------------------------------- main ---\nif __name__ == \'__main__\':\n\n    Z = build_maze((41,81))\n    start, goal = (1,1), (Z.shape[0]-2, Z.shape[1]-2)\n    \n    G, P = BellmanFord(Z, start, goal)\n    X, Y = P[:,0], P[:,1]\n        \n    # P = BreadthFirst(Z, start, goal)\n    # X, Y = P[:,1], P[:,0]\n    \n    # Visualization maze, gradient and shortest path\n    plt.figure(figsize=(13, 13*Z.shape[0]/Z.shape[1]))\n    ax = plt.subplot(1, 1, 1, frameon=False)\n    ax.imshow(Z, interpolation=\'nearest\', cmap=plt.cm.gray_r, vmin=0.0, vmax=1.0)\n    cmap = plt.cm.hot\n    cmap.set_under(color=\'k\', alpha=0.0)\n    ax.imshow(G, interpolation=\'nearest\', cmap=cmap, vmin=0.01, vmax=G[start])\n    ax.scatter(X[1:-1], Y[1:-1], s=60,\n               lw=1, marker=\'o\', edgecolors=\'k\', facecolors=\'w\')\n    ax.scatter(X[[0,-1]], Y[[0,-1]], s=60,\n               lw=3, marker=\'x\', color=[\'w\',\'k\'])\n    ax.set_xticks([])\n    ax.set_yticks([])\n    plt.tight_layout()\n    plt.savefig(""maze.png"")\n    plt.show()\n'"
code/mosaic.py,14,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\ndef poisson_disk_sample(width=1.0, height=1.0, radius=0.025, k=30):\n    # References: Fast Poisson Disk Sampling in Arbitrary Dimensions\n    #             Robert Bridson, SIGGRAPH, 2007\n    def squared_distance(p0, p1):\n        return (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2\n\n    def random_point_around(p, k=1):\n        # WARNING: This is not uniform around p but we can live with it\n        R = np.random.uniform(radius, 2*radius, k)\n        T = np.random.uniform(0, 2*np.pi, k)\n        P = np.empty((k, 2))\n        P[:, 0] = p[0]+R*np.sin(T)\n        P[:, 1] = p[1]+R*np.cos(T)\n        return P\n\n    def in_limits(p):\n        return 0 <= p[0] < width and 0 <= p[1] < height\n\n    def neighborhood(shape, index, n=2):\n        row, col = index\n        row0, row1 = max(row-n, 0), min(row+n+1, shape[0])\n        col0, col1 = max(col-n, 0), min(col+n+1, shape[1])\n        I = np.dstack(np.mgrid[row0:row1, col0:col1])\n        I = I.reshape(I.size//2, 2).tolist()\n        I.remove([row, col])\n        return I\n\n    def in_neighborhood(p):\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        if M[i, j]:\n            return True\n        for (i, j) in N[(i, j)]:\n            if M[i, j] and squared_distance(p, P[i, j]) < squared_radius:\n                return True\n        return False\n\n    def add_point(p):\n        points.append(p)\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        P[i, j], M[i, j] = p, True\n\n    # Here `2` corresponds to the number of dimension\n    cellsize = radius/np.sqrt(2)\n    rows = int(np.ceil(width/cellsize))\n    cols = int(np.ceil(height/cellsize))\n\n    # Squared radius because we\'ll compare squared distance\n    squared_radius = radius*radius\n\n    # Positions cells\n    P = np.zeros((rows, cols, 2), dtype=np.float32)\n    M = np.zeros((rows, cols), dtype=bool)\n\n    # Cache generation for neighborhood\n    N = {}\n    for i in range(rows):\n        for j in range(cols):\n            N[(i, j)] = neighborhood(M.shape, (i, j), 2)\n\n    points = []\n    add_point((np.random.uniform(width), np.random.uniform(height)))\n    while len(points):\n        i = np.random.randint(len(points))\n        p = points[i]\n        del points[i]\n        Q = random_point_around(p, k)\n        for q in Q:\n            if in_limits(q) and not in_neighborhood(q):\n                add_point(q)\n    return P[M]\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    from scipy import misc\n    from voronoi import voronoi\n    from matplotlib.path import Path\n    from matplotlib.patches import PathPatch\n    import matplotlib.pyplot as plt\n\n    img = misc.imread(""starry-night-detail.jpg"")\n    height, width, depth = img.shape\n\n    fig = plt.figure(figsize=(10, 10*(height/width)))\n    ax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False, aspect=1)\n\n    radius = 7\n    P = poisson_disk_sample(width=width-0.1, height=height-0.1, radius=radius, k=30)\n    ax.set_xlim(0, width)\n    ax.set_ylim(0, height)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\n    X, Y = P[:, 0], P[:, 1]\n    cells, triangles, circles = voronoi(X, height-Y)\n    for i, cell in enumerate(cells):\n        codes = [Path.MOVETO] + [Path.LINETO]*(len(cell)-2) + [Path.CLOSEPOLY]\n        path = Path(cell, codes)\n        color = img[int(np.floor(Y[i])), int(np.floor(X[i]))] / 255.0\n        patch = PathPatch(path, facecolor=color, edgecolor=""none"")\n        ax.add_patch(patch)\n\n    plt.savefig(""../data/mosaic.png"")\n    plt.show()\n'"
code/random_walk.py,6,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport random\nimport numpy as np\n\n\n# --- Object-oriented approach ------------------------------------------------\nclass RandomWalker:\n    def __init__(self):\n        self.position = 0\n\n    def walk(self, n):\n        self.position = 0\n        for i in range(n):\n            yield self.position\n            self.position += 2*random.randint(0, 1) - 1\n\n\n# --- Procedural approach -----------------------------------------------------\ndef random_walk(n):\n    position = 0\n    walk = [position]\n    for i in range(n):\n        step = 2*random.randint(0, 1)-1\n        position += step\n        walk.append(position)\n    return walk\n\n\ndef random_walk_faster(n=1000):\n    from itertools import accumulate\n    # Only available from Python 3.6\n    steps = random.choices([-1,+1], k=n)\n    return [0]+list(accumulate(steps))\n\n\n# --- Vectorized approach -----------------------------------------------------\ndef random_walk_fastest(n=1000):\n    # No \'s\' in numpy choice (Python offers choice & choices)\n    steps = np.random.choice([-1,+1], 1000)\n    return np.cumsum(steps)\n\n\n# -----------------------------------------------------------------------------\n# Readable but slow\ndef find_crossing_1(seq, sub):\n    return [i for i in range(len(seq) - len(sub) +1) if seq[i:i+len(sub)] == sub]\n\n# Fast but hardly readable\ndef find_crossing_2(seq, sub):\n    # See stackoverflow.com / ""python-numpy-first-occurrence-of-subarray""\n    target = np.dot(sub, sub)\n    candidates = np.where(np.correlate(seq, sub, mode=\'valid\') == target)[0]\n    # some of the candidates entries may be false positives, double check\n    check = candidates[:, np.newaxis] + np.arange(len(sub))\n    mask = np.all((np.take(seq, check) == sub), axis=-1)\n    return candidates[mask]\n\n\nif __name__ == ""__main__"":\n    from tools import timeit\n\n    walker = RandomWalker()\n\n    timeit(""[position for position in walker.walk(n=10000)]"", globals())\n    timeit(""random_walk(n=10000)"", globals())\n    timeit(""random_walk_faster(n=10000)"", globals())\n    timeit(""random_walk_fastest(n=10000)"", globals())\n    print()\n    W = random_walk_fastest(n=1000)\n    timeit(""find_crossing_1(list(W), [+1,0,-1])"", globals())\n    timeit(""find_crossing_2(W, [+1,0,-1])"", globals())\n'"
code/sampling.py,18,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef Bridson_sampling(width=1.0, height=1.0, radius=0.025, k=30):\n    # References: Fast Poisson Disk Sampling in Arbitrary Dimensions\n    #             Robert Bridson, SIGGRAPH, 2007\n    def squared_distance(p0, p1):\n        return (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2\n\n    def random_point_around(p, k=1):\n        # WARNING: This is not uniform around p but we can live with it\n        R = np.random.uniform(radius, 2*radius, k)\n        T = np.random.uniform(0, 2*np.pi, k)\n        P = np.empty((k, 2))\n        P[:, 0] = p[0]+R*np.sin(T)\n        P[:, 1] = p[1]+R*np.cos(T)\n        return P\n\n    def in_limits(p):\n        return 0 <= p[0] < width and 0 <= p[1] < height\n\n    def neighborhood(shape, index, n=2):\n        row, col = index\n        row0, row1 = max(row-n, 0), min(row+n+1, shape[0])\n        col0, col1 = max(col-n, 0), min(col+n+1, shape[1])\n        I = np.dstack(np.mgrid[row0:row1, col0:col1])\n        I = I.reshape(I.size//2, 2).tolist()\n        I.remove([row, col])\n        return I\n\n    def in_neighborhood(p):\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        if M[i, j]:\n            return True\n        for (i, j) in N[(i, j)]:\n            if M[i, j] and squared_distance(p, P[i, j]) < squared_radius:\n                return True\n        return False\n\n    def add_point(p):\n        points.append(p)\n        i, j = int(p[0]/cellsize), int(p[1]/cellsize)\n        P[i, j], M[i, j] = p, True\n\n    # Here `2` corresponds to the number of dimension\n    cellsize = radius/np.sqrt(2)\n    rows = int(np.ceil(width/cellsize))\n    cols = int(np.ceil(height/cellsize))\n\n    # Squared radius because we\'ll compare squared distance\n    squared_radius = radius*radius\n\n    # Positions cells\n    P = np.zeros((rows, cols, 2), dtype=np.float32)\n    M = np.zeros((rows, cols), dtype=bool)\n\n    # Cache generation for neighborhood\n    N = {}\n    for i in range(rows):\n        for j in range(cols):\n            N[(i, j)] = neighborhood(M.shape, (i, j), 2)\n\n    points = []\n    add_point((np.random.uniform(width), np.random.uniform(height)))\n    while len(points):\n        i = np.random.randint(len(points))\n        p = points[i]\n        del points[i]\n        Q = random_point_around(p, k)\n        for q in Q:\n            if in_limits(q) and not in_neighborhood(q):\n                add_point(q)\n    return P[M]\n\n\ndef draw_voronoi(ax, X, Y):\n    from voronoi import voronoi\n    from matplotlib.path import Path\n    from matplotlib.patches import PathPatch\n    cells, triangles, circles = voronoi(X, Y)\n    for i, cell in enumerate(cells):\n        codes = [Path.MOVETO] \\\n                + [Path.LINETO] * (len(cell)-2) \\\n                + [Path.CLOSEPOLY]\n        path = Path(cell, codes)\n        patch = PathPatch(path,\n                          facecolor=""none"", edgecolor=""0.5"", linewidth=0.5)\n        ax.add_patch(patch)\n\n\n# -----------------------------------------------------------------------------\nif __name__ == \'__main__\':\n    import matplotlib.pyplot as plt\n\n    # Benchmark\n    # from tools import print_timeit\n    # print_timeit(""poisson_disk_sample()"", globals())\n\n    fig = plt.figure(figsize=(18, 6))\n\n    ax = plt.subplot(1, 3, 1, aspect=1)\n    n = 1000\n    X = np.random.uniform(0, 1, n)\n    Y = np.random.uniform(0, 1, n)\n    ax.scatter(X, Y, s=10, facecolor=\'w\', edgecolor=\'0.5\')\n    ax.set_xlim(0, 1), ax.set_ylim(0, 1)\n    ax.set_xticks([]), ax.set_yticks([])\n    ax.set_title(""Random sampling"", fontsize=18)\n    draw_voronoi(ax, X, Y)\n\n    ax = plt.subplot(1, 3, 2, aspect=1)\n    n = 32\n    X, Y = np.meshgrid(np.linspace(0, 1, n), np.linspace(0, 1, n))\n    X += 0.45*np.random.uniform(-1/n, 1/n, (n, n))\n    Y += 0.45*np.random.uniform(-1/n, 1/n, (n, n))\n    ax.scatter(X, Y, s=10, facecolor=\'w\', edgecolor=\'0.5\')\n    ax.set_xlim(0, 1), ax.set_ylim(0,  1)\n    ax.set_xticks([]), ax.set_yticks([])\n    ax.set_title(""Regular grid + jittering"", fontsize=18)\n    draw_voronoi(ax, X.ravel(), Y.ravel())\n\n    ax = plt.subplot(1, 3, 3, aspect=1)\n    P = Bridson_sampling(width=1.0, height=1.0, radius=0.025, k=30)\n    plt.scatter(P[:, 0], P[:, 1], s=10, facecolor=\'w\', edgecolor=\'0.5\')\n    ax.set_xlim(0, 1), ax.set_ylim(0, 1)\n    ax.set_xticks([]), ax.set_yticks([])\n    ax.set_title(""Bridson sampling"", fontsize=18)\n    draw_voronoi(ax, P[:, 0], P[:, 1])\n\n    plt.tight_layout(pad=2.5)\n    plt.savefig(""../data/sampling.png"")\n    plt.show()\n'"
code/smoke_1.py,11,"b'# -----------------------------------------------------------------------------\r\n# From Numpy to Python\r\n# Copyright (2017) Nicolas P. Rougier - BSD license\r\n# More information at https://github.com/rougier/numpy-book\r\n# -----------------------------------------------------------------------------\r\nimport numpy as np\r\nfrom smoke_solver import vel_step, dens_step\r\n\r\nN = 128\r\nsize = N + 2\r\ndt = 0.1\r\ndiff = 0.0\r\nvisc = 0.0\r\nforce = 5.0\r\nsource = 100.0\r\n\r\nu = np.zeros((size, size), np.float32)  # velocity\r\nu_prev = np.zeros((size, size), np.float32)\r\n\r\nv = np.zeros((size, size), np.float32)  # velocity\r\nv_prev = np.zeros((size, size), np.float32)\r\n\r\ndens = np.zeros((size, size), np.float32)  # density\r\ndens_prev = np.zeros((size, size), np.float32)\r\n\r\n\r\ndef initialization():\r\n    global u, v, u_prev, v_prev, dens, dens_prev, size\r\n\r\n    u[:, :] = 0.0\r\n    v[:, :] = 0.0\r\n    u_prev[:, :] = 0.0\r\n    v_prev[:, :] = 0.0\r\n    dens[:, :] = 0.0\r\n    dens_prev[:, :] = 0.0\r\n\r\n    def disc(shape=(size, size), center=(size/2, size/2), radius=10):\r\n        def distance(x, y):\r\n            return np.sqrt((x-center[0])**2+(y-center[1])**2)\r\n        D = np.fromfunction(distance, shape)\r\n        return np.where(D <= radius, True, False)\r\n\r\n    D = disc(radius=32) - disc(radius=16)\r\n    dens[...] = D*source/10\r\n    u[:, :] = force * 0.1 * np.random.uniform(-1, 1, u.shape)\r\n    v[:, :] = force * 0.1 * np.random.uniform(-1, 1, u.shape)\r\n\r\n\r\ndef update(*args):\r\n    global im, dens, dens_prev, u, u_prev, v, v_prev, N, visc, dt, diff\r\n\r\n    vel_step(N, u, v, u_prev, v_prev, visc, dt)\r\n    dens_step(N, dens, dens_prev, u, v, diff, dt)\r\n    im.set_data(dens)\r\n    im.set_clim(vmin=dens.min(), vmax=dens.max())\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    import matplotlib.pyplot as plt\r\n    from matplotlib.animation import FuncAnimation\r\n\r\n    fig = plt.figure(figsize=(5, 5))\r\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False)\r\n    ax.set_xlim(0, 1)\r\n    ax.set_xticks([])\r\n    ax.set_ylim(0, 1)\r\n    ax.set_yticks([])\r\n\r\n    initialization()\r\n    im = ax.imshow(dens[1:-1, 1:-1],\r\n                   interpolation=\'bicubic\', extent=[0, 1, 0, 1],\r\n                   cmap=plt.cm.magma, origin=""lower"", vmin=0, vmax=1)\r\n    animation = FuncAnimation(fig, update, interval=10, frames=800)\r\n    # animation.save(\'smoke-1.mp4\', fps=40, dpi=80, bitrate=-1,\r\n    #                codec=""libx264"", extra_args=[\'-pix_fmt\', \'yuv420p\'],\r\n    #                metadata={\'artist\':\'Nicolas P. Rougier\'})\r\n    plt.show()\r\n'"
code/smoke_2.py,12,"b'# -----------------------------------------------------------------------------\r\n# From Numpy to Python\r\n# Copyright (2017) Nicolas P. Rougier - BSD license\r\n# More information at https://github.com/rougier/numpy-book\r\n# -----------------------------------------------------------------------------\r\nimport numpy as np\r\nfrom smoke_solver import vel_step, dens_step\r\n\r\nN = 128\r\nsize = N + 2\r\ndt = 0.1\r\ndiff = 0.0\r\nvisc = 0.0\r\nforce = 5.0\r\nsource = 100.0\r\ndvel = False\r\n\r\nu = np.zeros((size, size), np.float32)  # velocity\r\nu_prev = np.zeros((size, size), np.float32)\r\n\r\nv = np.zeros((size, size), np.float32)  # velocity\r\nv_prev = np.zeros((size, size), np.float32)\r\n\r\ndens = np.zeros((size, size), np.float32)  # density\r\ndens_prev = np.zeros((size, size), np.float32)\r\n\r\n\r\ndef initialization():\r\n    global u, v, u_prev, v_prev, dens, dens_prev, size\r\n\r\n    u[:, :] = 0.0\r\n    v[:, :] = 0.0\r\n    u_prev[:, :] = 0.0\r\n    v_prev[:, :] = 0.0\r\n    dens[:, :] = 0.0\r\n    dens_prev[:, :] = 0.0\r\n\r\n    def disc(shape=(size, size), center=(size/2, size/2), radius=10):\r\n        def distance(x, y):\r\n            return np.sqrt((x-center[0])**2+(y-center[1])**2)\r\n        D = np.fromfunction(distance, shape)\r\n        return np.where(D <= radius, True, False)\r\n\r\n    D = disc(radius=10) - disc(radius=5)\r\n    dens[...] += D*source/50\r\n\r\n    D = disc(radius=20) - disc(radius=15)\r\n    dens[...] += D*source/50\r\n\r\n    ox, oy = size/2, size/2\r\n    for j in range(1, N+1):\r\n        for i in range(1, N+1):\r\n            d = np.sqrt((i-ox)**2+(j-oy)**2)\r\n            u[i, j] = (i-ox)/max(d, 1) * force * 0.25\r\n            v[i, j] = (j-oy)/max(d, 1) * force * 0.25\r\n    u[:, :] += force * 0.1 * np.random.uniform(-1, 1, u.shape)\r\n    v[:, :] += force * 0.1 * np.random.uniform(-1, 1, u.shape)\r\n\r\n\r\ndef update(*args):\r\n    global im, dens, dens_prev, u, u_prev, v, v_prev, N, visc, dt, diff\r\n\r\n    vel_step(N, u, v, u_prev, v_prev, visc, dt)\r\n    dens_step(N, dens, dens_prev, u, v, diff, dt)\r\n    im.set_data(dens)\r\n    im.set_clim(vmin=dens.min(), vmax=dens.max())\r\n\r\nif __name__ == \'__main__\':\r\n    import matplotlib.pyplot as plt\r\n    from matplotlib.animation import FuncAnimation\r\n\r\n    fig = plt.figure(figsize=(5, 5))\r\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False)\r\n    ax.set_xlim(0, 1)\r\n    ax.set_xticks([])\r\n    ax.set_ylim(0, 1)\r\n    ax.set_yticks([])\r\n    initialization()    \r\n    im = ax.imshow(dens[1:-1, 1:-1],\r\n                   interpolation=\'bicubic\', extent=[0, 1, 0, 1],\r\n                   cmap=plt.cm.gray, origin=""lower"", vmin=0, vmax=1)\r\n    animation = FuncAnimation(fig, update, interval=10, frames=800)\r\n    # animation.save(\'smoke-2.mp4\', fps=40, dpi=80, bitrate=-1,\r\n    #                codec=""libx264"", extra_args=[\'-pix_fmt\', \'yuv420p\'],\r\n    #                metadata={\'artist\': \'Nicolas P. Rougier\'})\r\n    plt.show()\r\n'"
code/smoke_interactive.py,6,"b'# -----------------------------------------------------------------------------\r\n# From Numpy to Python\r\n# Copyright (2017) Nicolas P. Rougier - BSD license\r\n# More information at https://github.com/rougier/numpy-book\r\n# -----------------------------------------------------------------------------\r\nimport numpy as np\r\nfrom smoke_solver import vel_step, dens_step\r\n\r\nN = 64\r\nsize = N + 2\r\ndt = 0.1\r\ndiff = 0.0\r\nvisc = 0.0\r\nforce = 5.0\r\nsource = 100.0\r\ndvel = False\r\n\r\nmouse = {""ox"": 0.0, ""oy"": 0.0,\r\n         ""x"": 0.0,  ""y"": 0.0,\r\n         ""button"": None}\r\n\r\nu = np.zeros((size, size), np.float32)  # velocity\r\nu_prev = np.zeros((size, size), np.float32)\r\n\r\nv = np.zeros((size, size), np.float32)  # velocity\r\nv_prev = np.zeros((size, size), np.float32)\r\n\r\ndens = np.zeros((size, size), np.float32)  # density\r\ndens_prev = np.zeros((size, size), np.float32)\r\n\r\n\r\ndef initialization():\r\n    global u, v, u_prev, v_prev, dens, dens_prev, size\r\n\r\n    u[:, :] = 0.0\r\n    v[:, :] = 0.0\r\n    u_prev[:, :] = 0.0\r\n    v_prev[:, :] = 0.0\r\n    dens[:, :] = 0.0\r\n    dens_prev[:, :] = 0.0\r\n\r\n\r\ndef user_step(d, u, v):\r\n    global mouse\r\n\r\n    d[:, :] = 0.0\r\n    u[:, :] = 0.0\r\n    v[:, :] = 0.0\r\n\r\n    if mouse[""button""] not in [1, 3]:\r\n        return\r\n    if mouse[""x""] is None or mouse[""y""] is None:\r\n        return\r\n\r\n    i = int(mouse[""y""]*N) + 1\r\n    j = int(mouse[""x""]*N) + 1\r\n    if not 0 < i < N+1 and not 0 < j < N+1:\r\n        return\r\n\r\n    if mouse[""button""] == 3:\r\n        d[i, j] = source\r\n    elif mouse[""button""] == 1:\r\n        u[i, j] = force * (mouse[""y""] - mouse[""oy""])*200\r\n        v[i, j] = force * (mouse[""x""] - mouse[""ox""])*200\r\n\r\n    mouse[""ox""] = mouse[""x""]\r\n    mouse[""oy""] = mouse[""y""]\r\n\r\n\r\ndef update(*args):\r\n    global im, dens, dens_prev, u, u_prev, v, v_prev, N, visc, dt, diff\r\n\r\n    user_step(dens_prev, u_prev, v_prev)\r\n    vel_step(N, u, v, u_prev, v_prev, visc, dt)\r\n    dens_step(N, dens, dens_prev, u, v, diff, dt)\r\n    im.set_data(dens)\r\n    # im.set_clim(vmin=dens.min(), vmax=dens.max())\r\n\r\n\r\ndef on_button_press(event):\r\n    global mouse\r\n    mouse[""ox""] = mouse[""x""] = event.xdata\r\n    mouse[""oy""] = mouse[""y""] = event.ydata\r\n    mouse[""button""] = event.button\r\n\r\n\r\ndef on_button_release(event):\r\n    global mouse\r\n    mouse[""ox""] = mouse[""x""] = event.xdata\r\n    mouse[""oy""] = mouse[""y""] = event.ydata\r\n    mouse[""button""] = None\r\n\r\n\r\ndef on_motion(event):\r\n    global mouse\r\n    mouse[""x""] = event.xdata\r\n    mouse[""y""] = event.ydata\r\n\r\n\r\nif __name__ == \'__main__\':\r\n    import matplotlib.pyplot as plt\r\n    from matplotlib.animation import FuncAnimation\r\n\r\n    fig = plt.figure(figsize=(5, 5))\r\n    ax = fig.add_axes([0, 0, 1, 1], frameon=False)\r\n\r\n    cid = fig.canvas.mpl_connect(\'button_press_event\', on_button_press)\r\n    cid = fig.canvas.mpl_connect(\'button_release_event\', on_button_release)\r\n    cid = fig.canvas.mpl_connect(\'motion_notify_event\', on_motion)\r\n\r\n    ax.set_xlim(0, 1)\r\n    ax.set_xticks([])\r\n    ax.set_ylim(0, 1)\r\n    ax.set_yticks([])\r\n\r\n    initialization()\r\n    im = ax.imshow(dens[1:-1, 1:-1],\r\n                   interpolation=\'bicubic\', extent=[0, 1, 0, 1],\r\n                   cmap=plt.cm.gray, origin=""lower"", vmin=0, vmax=1)\r\n    animation = FuncAnimation(fig, update, interval=10, frames=800)\r\n    plt.show()\r\n'"
code/smoke_solver.py,3,"b'# -----------------------------------------------------------------------------\r\n# From Numpy to Python\r\n# Copyright (2017) Nicolas P. Rougier - BSD license\r\n# More information at https://github.com/rougier/numpy-book\r\n# -----------------------------------------------------------------------------\r\n""""""\r\nReal-Time Fluid Dynamics for Games by Jos Stam (2003).\r\n\r\nCopyright (c) 2015 Alberto Santini - MIT License\r\nCode adapted from Alberto Santini implementation available at:\r\nhttps://github.com/albertosantini/python-fluid\r\n""""""\r\nimport numpy as np\r\n\r\n\r\ndef set_bnd(N, b, x):\r\n    """"""We assume that the fluid is contained in a box with solid walls.\r\n\r\n    No flow should exit the walls. This simply means that the horizontal\r\n    component of the velocity should be zero on the vertical walls, while the\r\n    vertical component of the velocity should be zero on the horizontal walls.\r\n    For the density and other fields considered in the code we simply assume\r\n    continuity. The following code implements these conditions.\r\n    """"""\r\n\r\n    if b == 1:\r\n        x[0, 1:-1] = -x[1, 1:-1]\r\n        x[-1, 1:-1] = -x[N, 1:-1]\r\n    else:\r\n        x[ 0, 1:-1] = x[1, 1:-1]\r\n        x[-1, 1:-1] = x[N, 1:-1]\r\n    if b == 2:\r\n        x[1:-1,  0] = -x[1:-1, 1]\r\n        x[1:-1, -1] = -x[1:-1, N]\r\n    else:\r\n        x[1:-1,  0] = x[1:-1, 1]\r\n        x[1:-1, -1] = x[1:-1, N]\r\n\r\n    x[ 0,  0] = 0.5 * (x[1,  0] + x[ 0, 1])\r\n    x[ 0, -1] = 0.5 * (x[1, -1] + x[ 0, N])\r\n    x[-1,  0] = 0.5 * (x[N,  0] + x[-1, 1])\r\n    x[-1, -1] = 0.5 * (x[N, -1] + x[-1, N])\r\n\r\n\r\ndef lin_solve(N, b, x, x0, a, c):\r\n    """"""lin_solve.""""""\r\n\r\n    for k in range(20):\r\n        x[1:-1, 1:-1] = (x0[1:-1, 1:-1] +\r\n                         a * (x[:N, 1:-1] + x[2:, 1:-1] +\r\n                              x[1:-1, :N] + x[1:-1, 2:])) / c\r\n        set_bnd(N, b, x)\r\n\r\n\r\ndef add_source(N, x, s, dt):\r\n    """"""Addition of forces: the density increases due to sources.""""""\r\n    x += dt * s\r\n\r\n\r\ndef diffuse(N, b, x, x0, diff, dt):\r\n    """"""Diffusion: the density diffuses at a certain rate.\r\n\r\n    The basic idea behind our method is to find the densities which when\r\n    diffused backward in time yield the densities we started with. The simplest\r\n    iterative solver which works well in practice is Gauss-Seidel relaxation.\r\n    """"""\r\n\r\n    a = dt * diff * N * N\r\n    lin_solve(N, b, x, x0, a, 1 + 4 * a)\r\n\r\n\r\ndef advect(N, b, d, d0, u, v, dt):\r\n    """"""Advection: the density follows the velocity field.\r\n\r\n    The basic idea behind the advection step. Instead of moving the cell\r\n    centers forward in time through the velocity field, we look for the\r\n    particles which end up exactly at the cell centers by tracing backwards in\r\n    time from the cell centers.\r\n    """"""\r\n\r\n    dt0 = dt * N\r\n\r\n    I, J = np.indices((N, N))\r\n    I += 1\r\n    J += 1\r\n    X = I - dt0 * u[I, J]\r\n    Y = J - dt0 * v[I, J]\r\n\r\n    X = np.minimum(np.maximum(X, 0.5), N+0.5)\r\n    I0 = X.astype(int)\r\n    I1 = I0+1\r\n    S1 = X - I0\r\n    S0 = 1 - S1\r\n\r\n    Y = np.minimum(np.maximum(Y, 0.5), N+0.5)\r\n    J0 = Y.astype(int)\r\n    J1 = J0 + 1\r\n    T1 = Y - J0\r\n    T0 = 1 - T1\r\n\r\n    d[I, J] = (S0 * (T0 * d0[I0, J0] + T1 * d0[I0, J1])\r\n             + S1 * (T0 * d0[I1, J0] + T1 * d0[I1, J1]))\r\n\r\n    set_bnd(N, b, d)\r\n\r\n\r\ndef project(N, u, v, p, div):\r\n    """""" Projection """"""\r\n\r\n    h = 1.0 / N\r\n    div[1:-1, 1:-1] = (-0.5 * h *\r\n                       (u[2:, 1:-1] - u[0:N, 1:-1] +\r\n                        v[1:-1, 2:] - v[1:-1, 0:N]))\r\n    p[1:-1, 1:-1] = 0\r\n    set_bnd(N, 0, div)\r\n    set_bnd(N, 0, p)\r\n    lin_solve(N, 0, p, div, 1, 4)\r\n    u[1:-1, 1:-1] -= 0.5 * (p[2:, 1:-1] - p[0:N, 1:-1]) / h\r\n    v[1:-1, 1:-1] -= 0.5 * (p[1:-1, 2:] - p[1:-1, 0:N]) / h\r\n    set_bnd(N, 1, u)\r\n    set_bnd(N, 2, v)\r\n\r\n\r\ndef dens_step(N, x, x0, u, v, diff, dt):\r\n    # Density step: advection, diffusion & addition of sources.\r\n    add_source(N, x, x0, dt)\r\n    x0, x = x, x0  # swap\r\n    diffuse(N, 0, x, x0, diff, dt)\r\n    x0, x = x, x0  # swap\r\n    advect(N, 0, x, x0, u, v, dt)\r\n\r\n\r\ndef vel_step(N, u, v, u0, v0, visc, dt):\r\n    # Velocity step: self-advection, viscous diffusion & addition of forces\r\n\r\n    add_source(N, u, u0, dt)\r\n    add_source(N, v, v0, dt)\r\n    u0, u = u, u0  # swap\r\n    \r\n    diffuse(N, 1, u, u0, visc, dt)\r\n    v0, v = v, v0  # swap\r\n    \r\n    diffuse(N, 2, v, v0, visc, dt)\r\n    project(N, u, v, u0, v0)\r\n    u0, u = u, u0  # swap\r\n    v0, v = v, v0  # swap\r\n    \r\n    advect(N, 1, u, u0, u0, v0, dt)\r\n    advect(N, 2, v, v0, u0, v0, dt)\r\n    project(N, u, v, u0, v0)\r\n'"
code/tools.py,5,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\ndef sysinfo():\n    import sys\n    import time\n    import numpy as np\n    import scipy as sp\n    import matplotlib\n\n    print(""Date:       %s"" % (time.strftime(""%D"")))\n    version = sys.version_info\n    major, minor, micro = version.major, version.minor, version.micro\n    print(""Python:     %d.%d.%d"" % (major, minor, micro))\n    print(""Numpy:     "", np.__version__)\n    print(""Scipy:     "", sp.__version__)\n    print(""Matplotlib:"", matplotlib.__version__)\n\n    \n\ndef timeit(stmt, globals):\n    import timeit as _timeit\n    import numpy as np\n    \n    # Rough approximation of a single run\n    trial = _timeit.timeit(stmt, globals=globals, number=1)\n    \n    # Maximum duration\n    duration = 1.0\n    \n    # Number of repeat\n    repeat = 3\n    \n    # Compute rounded number of trials\n    number = max(1,int(10**np.floor(np.log(duration/trial/repeat)/np.log(10))))\n    \n    # Only report best run\n    best = min(_timeit.repeat(stmt, globals=globals, number=number, repeat=repeat))\n\n    units = {""usec"": 1, ""msec"": 1e3, ""sec"": 1e6}\n    precision = 3\n    usec = best * 1e6 / number\n    if usec < 1000:\n        print(""%d loops, best of %d: %.*g usec per loop"" % (number, repeat,\n                                                            precision, usec))\n    else:\n        msec = usec / 1000\n        if msec < 1000:\n            print(""%d loops, best of %d: %.*g msec per loop"" % (number, repeat,\n                                                                precision, msec))\n        else:\n            sec = msec / 1000\n            print(""%d loops, best of %d: %.*g sec per loop"" % (number, repeat,\n                                                               precision, sec))\n   \n    # Display results\n    # print(""%d loops, best of %d: %g sec per loop"" % (number, repeat, best/number))\n\n    \ndef info(Z):\n    import numpy as np\n        \n    print(""------------------------------"")\n    print(""Interface (item)"")\n    print(""  shape:      "", Z.shape)\n    print(""  dtype:      "", Z.dtype)\n    print(""  size:       "", Z.size)\n    if np.isfortran(Z):\n        print(""  order:       \xe2\x98\x90 C  \xe2\x98\x91 Fortran"")\n    else:\n        print(""  order:       \xe2\x98\x91 C  \xe2\x98\x90 Fortran"")\n    print("""")\n    print(""Memory (byte)"")\n    print(""  item size:  "", Z.itemsize)\n    print(""  array size: "", Z.size*Z.itemsize)\n    print(""  strides:    "", Z.strides)\n    print("""")\n    print(""Properties"")\n    if Z.flags[""OWNDATA""]:\n        print(""  own data:    \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  own data:    \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if Z.flags[""WRITEABLE""]:\n        print(""  writeable:   \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  writeable:   \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if np.isfortran(Z) and Z.flags[""F_CONTIGUOUS""]:\n        print(""  contiguous:  \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    elif not np.isfortran(Z) and Z.flags[""C_CONTIGUOUS""]:\n        print(""  contiguous:  \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  contiguous:  \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if Z.flags[""ALIGNED""]:\n        print(""  aligned:     \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  aligned:     \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    print(""------------------------------"")\n    print()\n'"
code/vec2.py,0,"b'import math\nfrom collections import namedtuple\n\n\ndef struct(name, members):\n    cls = namedtuple(name, members)\n    cls.__repr__ = lambda self: ""%s(%s)"" % (name, \',\'.join(str(s) for s in self))\n    return cls\n\n\nclass vec2(struct(\'vec2\', (\'x\', \'y\'))):\n\n    def __add__(self, other):\n        if isinstance(other, vec2):\n            return vec2(self.x+other.x, self.y+other.y)\n        return vec2(self.x+other, self.y+other)\n\n    def __sub__(self, other):\n        if isinstance(other, vec2):\n            return vec2(self.x-other.x, self.y-other.y)\n        return vec2(self.x-other, self.y-other)\n\n    def __mul__(self, other):\n        if isinstance(other, vec2):\n            return vec2(self.x*other.x, self.y*other.y)\n        return vec2(self.x*other, self.y*other)\n\n    def __truediv__(self, other):\n        if isinstance(other, vec2):\n            return vec2(self.x/other.x, self.y/other.y)\n        return vec2(self.x/other, self.y/other)\n\n    def length(self):\n        return math.hypot(self.x, self.y)\n\n    def normalized(self):\n        length = self.length()\n        if not length:\n            length = 1.0\n        return vec2(self.x/length, self.y/length)\n\n    def limited(self, maxlength=1.0):\n        length = self.length()\n        if length > maxlength:\n            return vec2(maxlength*self.x/length, maxlength*self.y/length)\n        return self\n'"
code/vectorization.py,1,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n\ndef compute_1(x, y):\n    """""" Pure python version """"""\n\n    result = 0\n    for i in range(len(x)):\n        for j in range(len(y)):\n            result += x[i] * y[j]\n    return result\n\n\ndef compute_2(X, Y):\n    """""" Numpy version, faster """"""\n\n    return (X.reshape(len(X), 1) * Y.reshape(1, len(Y))).sum()\n\n\ndef compute_3(X, Y):\n    """""" Numpy version, fastest """"""\n\n    return X.sum()*Y.sum()\n\n\ndef compute_4(X, Y):\n    """""" Pure python version, fastesr """"""\n\n    return sum(X)*sum(Y)\n\n\nif __name__ == \'__main__\':\n    from tools import timeit\n\n    X = np.arange(1000)\n    timeit(""compute_1(X,X)"", globals())\n    timeit(""compute_2(X,X)"", globals())\n    timeit(""compute_3(X,X)"", globals())\n    timeit(""compute_4(X,X)"", globals())\n'"
code/voronoi.py,13,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\n\ndef circumcircle(P1,P2,P3):\n    """""" \n    This compute the center and radius of the (unique) circle that passes\n    through points P1, P2 & P3.\n\n    Adapted from:\n    http://local.wasp.uwa.edu.au/~pbourke/geometry/circlefrom3/Circle.cpp\n    """"""\n    delta_a = P2 - P1\n    delta_b = P3 - P2\n    epsilon = 0.000000001\n    if np.abs(delta_a[0]) <= epsilon and np.abs(delta_b[1]) <= epsilon:\n        center_x = 0.5*(P2[0] + P3[0])\n        center_y = 0.5*(P1[1] + P2[1])\n    else:\n        aSlope = delta_a[1]/delta_a[0]\n        bSlope = delta_b[1]/delta_b[0]\n        if np.abs(aSlope-bSlope) <= epsilon:\n            return None\n        center_x= (aSlope*bSlope*(P1[1] - P3[1]) + bSlope*(P1[0] + P2 [0]) \\\n                        - aSlope*(P2[0]+P3[0]) )/(2* (bSlope-aSlope) )\n        center_y = -1*(center_x - (P1[0]+P2[0])/2)/aSlope +  (P1[1]+P2[1])/2;\n    radius = np.sqrt( (center_x - P1[0])**2+(center_y - P1[1])**2)\n    return center_x, center_y, radius\n\n\n""""""\ndef circumcircle(P1,P2,P3):\n    \'\'\' \n    Adapted from:\n    http://local.wasp.uwa.edu.au/~pbourke/geometry/circlefrom3/Circle.cpp\n    \'\'\'\n    delta_a = P2 - P1\n    delta_b = P3 - P2\n    if np.abs(delta_a[0]) <= 0.000000001 and np.abs(delta_b[1]) <= 0.000000001:\n        center_x = 0.5*(P2[0] + P3[0])\n        center_y = 0.5*(P1[1] + P2[1])\n    else:\n        aSlope = delta_a[1]/delta_a[0]\n        bSlope = delta_b[1]/delta_b[0]\n        if np.abs(aSlope-bSlope) <= 0.000000001:\n            return None\n        center_x= (aSlope*bSlope*(P1[1] - P3[1]) + bSlope*(P1[0] + P2 [0]) \\\n                        - aSlope*(P2[0]+P3[0]) )/(2* (bSlope-aSlope) )\n        center_y = -1*(center_x - (P1[0]+P2[0])/2)/aSlope +  (P1[1]+P2[1])/2;\n    return center_x, center_y\n\ndef voronoi(X,Y):\n    P = np.zeros((X.size+4,2))\n    P[:X.size,0], P[:Y.size,1] = X, Y\n    # We add four points at ""infinity""\n    m = max(abs(X).max(), abs(Y).max())*1e4\n    P[X.size:,0] = -m, -m, +m, +m\n    P[Y.size:,1] = -m, +m, -m, +m\n    D = matplotlib.tri.Triangulation(P[:,0],P[:,1])\n    T = D.triangles\n    n = T.shape[0]\n    C = np.zeros((n,2))\n    for i in range(n):\n        C[i] = circumcircle(P[T[i,0]],P[T[i,1]],P[T[i,2]])\n    X,Y = C[:,0], C[:,1]\n    segments = []\n    for i in range(n):\n        for j in range(3):\n            k = D.neighbors[i][j]\n            if k != -1:\n                segments.append( [(X[i],Y[i]), (X[k],Y[k])] )\n    return segments\n""""""\n\ndef voronoi(X,Y):\n    """"""\n    This compute the Voronoi diagram of points X,Y\n\n    Return the Voronoi cells (as a list of points), Delaunay triangles (as a\n    list of indices in X and Y) & Delaunay circles as list of (x,y,radius).\n    """"""\n    \n    P = np.zeros((X.size,2))\n    P[:,0] = X\n    P[:,1] = Y\n\n    D = matplotlib.tri.Triangulation(X,Y)\n    T = D.triangles\n    n = T.shape[0]\n    C = np.zeros((n,3))\n\n    # Get circle for each triangle, center will be a voronoi cell point\n    cells = []\n    for i in range(X.size):\n        cells.append( list() )\n    for i in range(n):\n        C[i] = circumcircle(P[T[i,0]],P[T[i,1]],P[T[i,2]])\n        x,y,r = C[i]\n        cells[T[i,0]].append( (x,y) )\n        cells[T[i,1]].append( (x,y) )\n        cells[T[i,2]].append( (x,y) )\n\n    # Reordering cell points in trigonometric way\n    for i,cell in enumerate(cells):\n        xy = np.array(cell)\n        I = np.argsort(np.arctan2(xy[:,1]-Y[i],xy[:,0]-X[i]))\n        cell = xy[I].tolist()\n        cell.append(cell[0])\n        cells[i] = cell\n    return cells, D.triangles, C\n\n\n\nif __name__ == \'__main__\':\n    \n    X = np.random.random(200)\n    Y = np.random.random(200)\n    fig = plt.figure(figsize=(10,10))\n    axes = plt.subplot(1,1,1)\n    plt.scatter(X,Y)\n    segments = voronoi(X,Y)\n    lines = matplotlib.collections.LineCollection(segments, color=\'0.75\')\n    axes.add_collection(lines)\n    plt.axis([0,1,0,1])\n    plt.show()\n'"
code/experiments/boid_2.py,15,"b'# FAST BOIDS\n""""""\nA deliberately bad implementation of [Boids](http://dl.acm.org/citation.cfm?doid=37401.37406)\nfor use as an exercise on refactoring.\n""""""\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import animation\nimport random\n\n# Deliberately terrible code for teaching purposes\n\nboids_x=np.array([random.uniform(-450,50.0) for x in range(50)])\nboids_y=np.array([random.uniform(300.0,600.0) for x in range(50)])\nboid_x_velocities=np.array([random.uniform(0,10.0) for x in range(50)])\nboid_y_velocities=np.array([random.uniform(-20.0,20.0) for x in range(50)])\n\ndef update_boids(xs, ys, xvs, yvs):\n    xdiff = np.add.outer(xs,-xs)\n    ydiff = np.add.outer(ys,-ys)\n        \n    xvdiff = np.add.outer(xvs,-xvs)\n    yvdiff = np.add.outer(yvs,-yvs)\n    distance=xdiff**2+ydiff**2\n    cond1=distance < 100\n    cond2=distance < 10000\n        \n    xvs += np.sum(xdiff[:,],axis=0)*0.01/50\n    yvs += np.sum(ydiff[:,],axis=0)*0.01/50\n        \n    yvs += -np.sum(xdiff[:,]*cond1,axis=0)\n    xvs += -np.sum(ydiff[:,]*cond1,axis=0)\n\n    # Replacing the below loop with this makes the code sigificantly faster but also slightly different.\n    xvs += np.sum(xdiff[:,]*cond2,axis=0)*0.125/50\n    yvs += np.sum(ydiff[:,]*cond2,axis=0)*0.125/50\n\n# This is similar to the other codes but also much slower. It is included in case changes made are unacceptable. \n#\tfor i in range(50):\n#\t\tfor j in range(50):\n#\t\t\tif distance[i,j] < 10000:\n#\t\t\t\txvs[i]+=xvdiff[j,i]*0.125/50\n#\t\t\t\tyvs[i]+=yvdiff[j,i]*0.125/50\n\t\t\t\t\n    xs += xvs\n    ys += yvs\t\t\t\n                   \n\nfigure=plt.figure()\naxes=plt.axes(xlim=(-500,1500), ylim=(-500,1500))\nscatter=axes.scatter(boids_x,boids_y)\n\ndef animate(frame):\n   update_boids(boids_x,boids_y,boid_x_velocities,boid_y_velocities)\n   Z = np.vstack((boids_x,boids_y))\n   print(Z.T.shape)\n   scatter.set_offsets(Z.T) #zip(boids_x,boids_y))\n\n\nanim = animation.FuncAnimation(figure, animate,\n                               frames=50, interval=50)\n\nif __name__ == ""__main__"":\n    plt.show()\n'"
code/experiments/boid_good.py,33,"b'""""""\nBoids\n\nSimulates flocking behavior\n""""""\nimport math\nimport random\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(8, 8), facecolor=""w"")\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\nx_target = random.uniform(0.3, 0.7)\ny_target = random.uniform(0.3, 0.7)\n\n# Simulation parameters\nN = 150\nWORLD_WIDTH = 640\nWORLD_HEIGHT = 360\n\nWALL_REPULSION_LIMIT = WORLD_WIDTH / 10\n\nREPULSION_LIMIT = 25\nREPULSION_STRENGTH = 1.5\nATTRACTION_LIMIT = 50\nATTRACTION_STRENGTH = 0.01\nALIGNMENT_LIMIT = 50\nALIGNMENT_STRENGTH = 0.01\n\nWALL_REPULSION_STRENGTH = 0.01\nTARGET_ATTRACTION_STRENGTH = 1e-3\nMAX_SPEED = 2\nNOISE = 0.3\n# assert REPULSION_LIMIT < ALIGNMENT_LIMIT\n\n# Init boids\nboids = np.zeros(N, dtype=[(\'pos\', float, 2), (\'vel\', float, 2)])\nboids[\'pos\'] = np.ones((N,2)) * (WORLD_WIDTH/2, WORLD_HEIGHT/2)\n\ntheta = np.random.uniform(0,2*np.pi, N)\nboids[\'pos\'] = np.ones((N,2))\nboids[\'pos\'][:,0] = np.cos(theta)\nboids[\'pos\'][:,1] = np.sin(theta)\n\n\n# Use a scatter plot to visualize the boids\nscatter = ax.scatter(boids[\'pos\'][:, 0], boids[\'pos\'][:, 1],\n                     s=30, facecolor=""r"", edgecolor=""None"", alpha=0.75)\n\n\ndef update_boids(xs, ys, xvs, yvs, frame):\n\n    # Matrix off position difference and distance\n    xdiff = np.add.outer(xs, -xs)\n    ydiff = np.add.outer(ys, -ys)\n    distance = np.sqrt(xdiff ** 2 + ydiff ** 2)\n\n    # Matrix of velocity difference\n    xvdiff = np.add.outer(xvs, -xvs)\n    yvdiff = np.add.outer(yvs, -yvs)\n\n    # Calculate the boids that are visible to every other boid\n    angle_towards = np.arctan2(-ydiff, -xdiff)\n    angle_vel = np.arctan2(yvs, xvs)\n    angle_diff = angle_towards - angle_vel[:, np.newaxis]\n    visible = 1+0*np.logical_and(angle_diff < np.pi / 2, angle_diff > -np.pi / 2)\n\n    # Repulse adjacent boids\n    repulsion = np.clip(1.0 - distance / REPULSION_LIMIT, 0.0, 1.0) * visible\n    repulsion_n = np.maximum(np.add.reduce(repulsion > 0.0).astype(float) - 1, 1)\n    yas = -np.sum(xdiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n    xas = -np.sum(ydiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n\n    # Align with nearby boids\n    alignment = (distance < ALIGNMENT_LIMIT).astype(float) * visible\n    alignment_n = np.maximum(np.add.reduce(alignment) - 1, 1)\n    xas += np.sum(xvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n    yas += np.sum(yvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n\n    # Attraction\n    attraction = (distance < ATTRACTION_LIMIT).astype(float) * visible\n    attraction_n = np.maximum(np.add.reduce(attraction) - 1, 1)\n    xas += np.sum(xdiff * attraction, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n    yas += np.sum(ydiff * attraction, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n\n    # Move towards target\n    #global x_target\n    #global y_target\n    # xvs += (x_target - xs) * TARGET_ATTRACTION_STRENGTH\n    # yvs += (y_target - ys) * TARGET_ATTRACTION_STRENGTH\n\n    # Wall repulsion\n    #xvs += np.clip(1.0 - xs / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    #yvs += np.clip(1.0 - ys / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    #xvs -= np.clip(1.0 - (WORLD_WIDTH - xs) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    #yvs -= np.clip(1.0 - (WORLD_WIDTH - ys) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n\n\n    xvs += xas\n    yvs += yas\n    \n    # Enforce max speed and apply some friction\n    xvs = np.clip(xvs, -MAX_SPEED, MAX_SPEED)\n    yvs = np.clip(yvs, -MAX_SPEED, MAX_SPEED)\n\n    # Add some random noise to velocity\n    x_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n    y_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n\n    xs += xvs * x_noise\n    ys += yvs * y_noise\n\n    xs[...] = (xs + WORLD_WIDTH) % WORLD_WIDTH\n    ys[...] = (ys + WORLD_HEIGHT) % WORLD_HEIGHT\n    \n\n\ndef animate(frame):\n\n    update_boids(boids[\'pos\'][:, 0],\n                 boids[\'pos\'][:, 1],\n                 boids[\'vel\'][:, 0],\n                 boids[\'vel\'][:, 1],\n                 frame)\n\n    scatter.set_offsets(boids[\'pos\'])\n\n\ndef mouse_move(ev):\n    global x_target\n    global y_target\n    x_target = ev.xdata\n    y_target = ev.ydata\n\ncid = fig.canvas.mpl_connect(\'button_press_event\', mouse_move)\nanimation = FuncAnimation(fig, animate, interval=30)\nplt.show()\n'"
code/experiments/boid_numpy_animated.py,29,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n\nclass Flock:\n    def __init__(self, count=500, width=640, height=360):\n        self.width = width\n        self.height = height\n        self.max_velocity = 2\n        self.max_acceleration = 0.03\n        self.r = 2\n        angle = np.random.uniform(0, 2*np.pi, count)\n        self.velocity = np.vstack((np.cos(angle), np.sin(angle))).T\n        self.position = np.random.uniform(-1, 1, (count, 2)) + (width/2, height/2)\n\n    def run(self):\n        position = self.position\n        velocity = self.velocity\n        max_velocity = self.max_velocity\n        max_acceleration = self.max_acceleration\n        n = len(position)\n\n        dx = np.subtract.outer(position[:, 0], position[:, 0])\n        dy = np.subtract.outer(position[:, 1], position[:, 1])\n        distance = np.hypot(dx, dy)\n\n        # Compute common distance masks\n        mask_0 = (distance > 0)\n        mask_25 = (distance < 20)\n        mask_50 = (distance < 50)\n        mask_0_25 = mask_0 * mask_25\n        mask_0_50 = mask_0 * mask_50\n        mask_0_25_count = np.maximum(mask_0_25.sum(axis=1), 1)\n        mask_0_50_count = np.maximum(mask_0_50.sum(axis=1), 1)\n\n        # Separation\n        # -----------------------------------------------------------------------------\n        # Compute target\n        mask, count = mask_0_25, mask_0_25_count\n        target = np.dstack((dx, dy))\n        target = np.divide(target, distance.reshape(n, n, 1)**2, out=target,\n                           where=distance.reshape(n, n, 1) != 0)\n\n        # Compute steering\n        steer = (target*mask.reshape(n, n, 1)).sum(axis=1)/count.reshape(n, 1)\n        norm_1 = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        steer = max_velocity * np.divide(steer, norm_1, out=steer, where=norm_1 != 0)\n        steer -= velocity\n\n        # Limit acceleration\n        norm_1 = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        norm_2 = np.minimum(norm_1, max_acceleration)\n        steer = np.multiply(steer, norm_2/norm_1, out=steer, where=norm_1 != 0)\n        separation = steer\n\n        # Alignment\n        # -----------------------------------------------------------------------------\n        # Compute target\n        mask, count = mask_0_50, mask_0_50_count\n        target = np.dot(mask, velocity)/count.reshape(n, 1)\n\n        # Compute steering\n        norm = np.sqrt((target*target).sum(axis=1)).reshape(n, 1)\n        target = max_velocity * np.divide(target, norm, out=target, where=norm != 0)\n        steer = target - velocity\n\n        # Limit acceleration\n        norm_1 = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        norm_2 = np.minimum(norm_1, max_acceleration)\n        steer = np.multiply(steer, norm_2/norm_1, out=steer, where=norm_1 != 0)\n        alignment = steer\n\n        # Cohesion\n        # -----------------------------------------------------------------------------\n        # Compute target\n        mask, count = mask_0_50, mask_0_50_count\n        target = np.dot(mask, position)/count.reshape(n, 1)\n\n        # Compute steering\n        desired = target - position\n        norm = np.sqrt((desired*desired).sum(axis=1)).reshape(n, 1)\n        desired *= max_velocity / norm\n        steer = desired - velocity\n\n        # Limit acceleration\n        norm_1 = np.sqrt((steer*steer).sum(axis=1)).reshape(n, 1)\n        norm_2 = np.minimum(norm_1, max_acceleration)\n        steer = np.multiply(steer, norm_2/norm_1, out=steer, where=norm_1 != 0)\n        cohesion = steer\n\n        # -----------------------------------------------------------------------------\n        acceleration = 1.5 * separation + alignment + cohesion\n        velocity += acceleration\n        norm_1 = np.sqrt((velocity*velocity).sum(axis=1)).reshape(n, 1)\n        norm_2 = np.minimum(norm_1, max_velocity)\n        velocity = np.multiply(velocity, norm_2/norm_1, out=velocity, where=norm_1 != 0)\n        position += velocity\n        \n        # Wraparound\n        position[...] = (position + (self.width, self.height)) % (self.width, self.height)\n\n\ndef update(*args):\n    flock.run()\n    scatter.set_offsets(flock.position)\n\nflock = Flock(1000)\nfig = plt.figure(figsize=(8, 5))\nax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=True)\nscatter = ax.scatter(flock.position[:, 0], flock.position[:, 1],\n                     s=5, facecolor=""red"", edgecolor=""None"", alpha=0.5)\nanimation = FuncAnimation(fig, update, interval=10)\nax.set_xlim(0, 640)\nax.set_ylim(0, 360)\nax.set_xticks([])\nax.set_yticks([])\nplt.show()\n'"
code/experiments/boid_processing.py,0,"b""Flock flock;\n\nvoid setup() {\n  size(640, 360);\n  flock = new Flock();\n  // Add an initial set of boids into the system\n  for (int i = 0; i < 150; i++) {\n    flock.addBoid(new Boid(width/2,height/2));\n  }\n}\n\nvoid draw() {\n  background(50);\n  flock.run();\n}\n\n// Add a new boid into the System\nvoid mousePressed() {\n  flock.addBoid(new Boid(mouseX,mouseY));\n}\n\n\n\n// The Flock (a list of Boid objects)\n\nclass Flock {\n  ArrayList<Boid> boids; // An ArrayList for all the boids\n\n  Flock() {\n    boids = new ArrayList<Boid>(); // Initialize the ArrayList\n  }\n\n  void run() {\n    for (Boid b : boids) {\n      b.run(boids);  // Passing the entire list of boids to each boid individually\n    }\n  }\n\n  void addBoid(Boid b) {\n    boids.add(b);\n  }\n\n}\n\n\n\n\n// The Boid class\n\nclass Boid {\n\n  PVector position;\n  PVector velocity;\n  PVector acceleration;\n  float r;\n  float maxforce;    // Maximum steering force\n  float maxspeed;    // Maximum speed\n\n    Boid(float x, float y) {\n    acceleration = new PVector(0, 0);\n\n    // This is a new PVector method not yet implemented in JS\n    // velocity = PVector.random2D();\n\n    // Leaving the code temporarily this way so that this example runs in JS\n    float angle = random(TWO_PI);\n    velocity = new PVector(cos(angle), sin(angle));\n\n    position = new PVector(x, y);\n    r = 2.0;\n    maxspeed = 2;\n    maxforce = 0.03;\n  }\n\n  void run(ArrayList<Boid> boids) {\n    flock(boids);\n    update();\n    borders();\n    render();\n  }\n\n  void applyForce(PVector force) {\n    // We could add mass here if we want A = F / M\n    acceleration.add(force);\n  }\n\n  // We accumulate a new acceleration each time based on three rules\n  void flock(ArrayList<Boid> boids) {\n    PVector sep = separate(boids);   // Separation\n    PVector ali = align(boids);      // Alignment\n    PVector coh = cohesion(boids);   // Cohesion\n    // Arbitrarily weight these forces\n    sep.mult(1.5);\n    ali.mult(1.0);\n    coh.mult(1.0);\n    // Add the force vectors to acceleration\n    applyForce(sep);\n    applyForce(ali);\n    applyForce(coh);\n  }\n\n  // Method to update position\n  void update() {\n    // Update velocity\n    velocity.add(acceleration);\n    // Limit speed\n    velocity.limit(maxspeed);\n    position.add(velocity);\n    // Reset accelertion to 0 each cycle\n    acceleration.mult(0);\n  }\n\n  // A method that calculates and applies a steering force towards a target\n  // STEER = DESIRED MINUS VELOCITY\n  PVector seek(PVector target) {\n    PVector desired = PVector.sub(target, position);  // A vector pointing from the position to the target\n    // Scale to maximum speed\n    desired.normalize();\n    desired.mult(maxspeed);\n\n    // Above two lines of code below could be condensed with new PVector setMag() method\n    // Not using this method until Processing.js catches up\n    // desired.setMag(maxspeed);\n\n    // Steering = Desired minus Velocity\n    PVector steer = PVector.sub(desired, velocity);\n    steer.limit(maxforce);  // Limit to maximum steering force\n    return steer;\n  }\n\n  void render() {\n    // Draw a triangle rotated in the direction of velocity\n    float theta = velocity.heading2D() + radians(90);\n    // heading2D() above is now heading() but leaving old syntax until Processing.js catches up\n    \n    fill(200, 100);\n    stroke(255);\n    pushMatrix();\n    translate(position.x, position.y);\n    rotate(theta);\n    beginShape(TRIANGLES);\n    vertex(0, -r*2);\n    vertex(-r, r*2);\n    vertex(r, r*2);\n    endShape();\n    popMatrix();\n  }\n\n  // Wraparound\n  void borders() {\n    if (position.x < -r) position.x = width+r;\n    if (position.y < -r) position.y = height+r;\n    if (position.x > width+r) position.x = -r;\n    if (position.y > height+r) position.y = -r;\n  }\n\n  // Separation\n  // Method checks for nearby boids and steers away\n  PVector separate (ArrayList<Boid> boids) {\n    float desiredseparation = 25.0f;\n    PVector steer = new PVector(0, 0, 0);\n    int count = 0;\n    // For every boid in the system, check if it's too close\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      // If the distance is greater than 0 and less than an arbitrary amount (0 when you are yourself)\n      if ((d > 0) && (d < desiredseparation)) {\n        // Calculate vector pointing away from neighbor\n        PVector diff = PVector.sub(position, other.position);\n        diff.normalize();\n        diff.div(d);        // Weight by distance\n        steer.add(diff);\n        count++;            // Keep track of how many\n      }\n    }\n    // Average -- divide by how many\n    if (count > 0) {\n      steer.div((float)count);\n    }\n\n    // As long as the vector is greater than 0\n    if (steer.mag() > 0) {\n      // First two lines of code below could be condensed with new PVector setMag() method\n      // Not using this method until Processing.js catches up\n      // steer.setMag(maxspeed);\n\n      // Implement Reynolds: Steering = Desired - Velocity\n      steer.normalize();\n      steer.mult(maxspeed);\n      steer.sub(velocity);\n      steer.limit(maxforce);\n    }\n    return steer;\n  }\n\n  // Alignment\n  // For every nearby boid in the system, calculate the average velocity\n  PVector align (ArrayList<Boid> boids) {\n    float neighbordist = 50;\n    PVector sum = new PVector(0, 0);\n    int count = 0;\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      if ((d > 0) && (d < neighbordist)) {\n        sum.add(other.velocity);\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div((float)count);\n      // First two lines of code below could be condensed with new PVector setMag() method\n      // Not using this method until Processing.js catches up\n      // sum.setMag(maxspeed);\n\n      // Implement Reynolds: Steering = Desired - Velocity\n      sum.normalize();\n      sum.mult(maxspeed);\n      PVector steer = PVector.sub(sum, velocity);\n      steer.limit(maxforce);\n      return steer;\n    } \n    else {\n      return new PVector(0, 0);\n    }\n  }\n\n  // Cohesion\n  // For the average position (i.e. center) of all nearby boids, calculate steering vector towards that position\n  PVector cohesion (ArrayList<Boid> boids) {\n    float neighbordist = 50;\n    PVector sum = new PVector(0, 0);   // Start with empty vector to accumulate all positions\n    int count = 0;\n    for (Boid other : boids) {\n      float d = PVector.dist(position, other.position);\n      if ((d > 0) && (d < neighbordist)) {\n        sum.add(other.position); // Add position\n        count++;\n      }\n    }\n    if (count > 0) {\n      sum.div(count);\n      return seek(sum);  // Steer towards the position\n    } \n    else {\n      return new PVector(0, 0);\n    }\n  }\n}\n"""
code/experiments/boid_test.py,29,"b'""""""\nBoids\n\nSimulates flocking behavior\n""""""\nimport math\nimport random\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(8, 8), facecolor=""w"")\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\nx_target = random.uniform(0.3, 0.7)\ny_target = random.uniform(0.3, 0.7)\n\n# Simulation parameters\nN = 100\nWORLD_WIDTH = 1.0\nREPULSION_LIMIT = WORLD_WIDTH / 15\nWALL_REPULSION_LIMIT = WORLD_WIDTH / 8\nREPULSION_STRENGTH = 0.010\nWALL_REPULSION_STRENGTH = 0.0012\nATTRACTION_STRENGTH = 9e-6\nTARGET_ATTRACTION_STRENGTH = 1e-3\nALIGNMENT_LIMIT = WORLD_WIDTH / 10\nALIGNMENT_STRENGTH = 0.006\nMAX_SPEED = WORLD_WIDTH / 160\nNOISE = 0.1\nassert REPULSION_LIMIT < ALIGNMENT_LIMIT\n\n# Init boids\nboids = np.zeros(N, dtype=[(\'pos\', float, 2), (\'vel\', float, 2)])\nboids[\'pos\'] = np.random.uniform(WORLD_WIDTH * 0.1, WORLD_WIDTH * 0.9, (N, 2))\nboids[\'vel\'] = np.random.uniform(-WORLD_WIDTH / 200, WORLD_WIDTH / 200, (N, 2))\n\n# Use a scatter plot to visualize the boids\nscatter = ax.scatter(boids[\'pos\'][:, 0], boids[\'pos\'][:, 1],\n                     s=30, facecolor=""r"", edgecolor=""None"", alpha=0.75)\n\n\ndef update_boids(xs, ys, xvs, yvs, frame):\n\n    # Matrix off position difference and distance\n    xdiff = np.add.outer(xs, -xs)\n    ydiff = np.add.outer(ys, -ys)\n    distance = np.sqrt(xdiff ** 2 + ydiff ** 2)\n\n    # Matrix of velocity difference\n    xvdiff = np.add.outer(xvs, -xvs)\n    yvdiff = np.add.outer(yvs, -yvs)\n\n    # Calculate the boids that are visible to every other boid\n    angle_towards = np.arctan2(-ydiff, -xdiff)\n    angle_vel = np.arctan2(yvs, xvs)\n    angle_diff = angle_towards - angle_vel[:, np.newaxis]\n    visible = np.logical_and(angle_diff < np.pi / 2, angle_diff > -np.pi / 2)\n\n    # Repulse adjacent boids\n    repulsion = np.clip(1.0 - distance / REPULSION_LIMIT, 0.0, 1.0) * visible\n\n    repulsion_n = np.maximum(np.add.reduce(repulsion > 0.0).astype(float) - 1, 1)\n    yvs += -np.sum(xdiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n    xvs += -np.sum(ydiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n\n    # Align with nearby boids\n    alignment = (distance < ALIGNMENT_LIMIT).astype(float) * visible\n    alignment_n = np.maximum(np.add.reduce(alignment) - 1, 1)\n    xvs += np.sum(xvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n    yvs += np.sum(yvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n\n    # Attraction\n    xvs += np.sum(xdiff * visible, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n    yvs += np.sum(ydiff * visible, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n\n    # Move towards target\n    global x_target\n    global y_target\n    xvs += (x_target - xs) * TARGET_ATTRACTION_STRENGTH\n    yvs += (y_target - ys) * TARGET_ATTRACTION_STRENGTH\n\n    # Wall repulsion\n    xvs += np.clip(1.0 - xs / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    yvs += np.clip(1.0 - ys / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    xvs -= np.clip(1.0 - (WORLD_WIDTH - xs) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    yvs -= np.clip(1.0 - (WORLD_WIDTH - ys) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n\n    # Enforce max speed and apply some friction\n    xvs = np.clip(xvs * 0.8 , -MAX_SPEED, MAX_SPEED)\n    yvs = np.clip(yvs * 0.8 , -MAX_SPEED, MAX_SPEED)\n\n    # Add some random noise to velocity\n    x_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n    y_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n    xs += xvs * x_noise\n    ys += yvs * y_noise\n\n\ndef animate(frame):\n\n    update_boids(boids[\'pos\'][:, 0],\n                 boids[\'pos\'][:, 1],\n                 boids[\'vel\'][:, 0],\n                 boids[\'vel\'][:, 1],\n                 frame)\n\n    scatter.set_offsets(boids[\'pos\'])\n\n\ndef mouse_move(ev):\n    global x_target\n    global y_target\n    x_target = ev.xdata\n    y_target = ev.ydata\n\ncid = fig.canvas.mpl_connect(\'button_press_event\', mouse_move)\nanimation = FuncAnimation(fig, animate, interval=30)\nplt.show()\n'"
code/experiments/boid_test_2.py,29,"b'""""""\nBoids\n\nSimulates flocking behavior\n""""""\nimport math\nimport random\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n# Create new Figure and an Axes which fills it.\nfig = plt.figure(figsize=(8, 8), facecolor=""w"")\nax = fig.add_axes([0, 0, 1, 1], frameon=False)\nax.set_xlim(0, 1), ax.set_xticks([])\nax.set_ylim(0, 1), ax.set_yticks([])\nx_target = random.uniform(0.3, 0.7)\ny_target = random.uniform(0.3, 0.7)\n\n# Simulation parameters\nN = 100\nWORLD_WIDTH = 1.0\nREPULSION_LIMIT = WORLD_WIDTH / 15\nWALL_REPULSION_LIMIT = WORLD_WIDTH / 8\nREPULSION_STRENGTH = 0.010\nWALL_REPULSION_STRENGTH = 0.0012\nATTRACTION_STRENGTH = 9e-6\nTARGET_ATTRACTION_STRENGTH = 1e-3\nALIGNMENT_LIMIT = WORLD_WIDTH / 10\nALIGNMENT_STRENGTH = 0.006\nMAX_SPEED = WORLD_WIDTH / 160\nNOISE = 0.1\nassert REPULSION_LIMIT < ALIGNMENT_LIMIT\n\n# Init boids\nboids = np.zeros(N, dtype=[(\'pos\', float, 2), (\'vel\', float, 2)])\nboids[\'pos\'] = np.random.uniform(WORLD_WIDTH * 0.1, WORLD_WIDTH * 0.9, (N, 2))\nboids[\'vel\'] = np.random.uniform(-WORLD_WIDTH / 200, WORLD_WIDTH / 200, (N, 2))\n\n# Use a scatter plot to visualize the boids\nscatter = ax.scatter(boids[\'pos\'][:, 0], boids[\'pos\'][:, 1],\n                     s=30, facecolor=""r"", edgecolor=""None"", alpha=0.75)\n\n\ndef update_boids(xs, ys, xvs, yvs, frame):\n\n    # Matrix off position difference and distance\n    xdiff = np.add.outer(xs, -xs)\n    ydiff = np.add.outer(ys, -ys)\n    distance = np.sqrt(xdiff ** 2 + ydiff ** 2)\n\n    # Matrix of velocity difference\n    xvdiff = np.add.outer(xvs, -xvs)\n    yvdiff = np.add.outer(yvs, -yvs)\n\n    # Calculate the boids that are visible to every other boid\n    angle_towards = np.arctan2(-ydiff, -xdiff)\n    angle_vel = np.arctan2(yvs, xvs)\n    angle_diff = angle_towards - angle_vel[:, np.newaxis]\n    visible = np.logical_and(angle_diff < np.pi / 2, angle_diff > -np.pi / 2)\n\n    # Repulse adjacent boids\n    repulsion = np.clip(1.0 - distance / REPULSION_LIMIT, 0.0, 1.0) * visible\n\n    repulsion_n = np.maximum(np.add.reduce(repulsion > 0.0).astype(float) - 1, 1)\n    yvs += -np.sum(xdiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n    xvs += -np.sum(ydiff * repulsion, axis=0) * REPULSION_STRENGTH / repulsion_n\n\n    # Align with nearby boids\n    alignment = (distance < ALIGNMENT_LIMIT).astype(float) * visible\n    alignment_n = np.maximum(np.add.reduce(alignment) - 1, 1)\n    xvs += np.sum(xvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n    yvs += np.sum(yvdiff * alignment, axis=0) * ALIGNMENT_STRENGTH / alignment_n\n\n    # Attraction\n    xvs += np.sum(xdiff * visible, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n    yvs += np.sum(ydiff * visible, axis=0) * ATTRACTION_STRENGTH / (N - 1)\n\n    # Move towards target\n    global x_target\n    global y_target\n    xvs += (x_target - xs) * TARGET_ATTRACTION_STRENGTH\n    yvs += (y_target - ys) * TARGET_ATTRACTION_STRENGTH\n\n    # Wall repulsion\n    xvs += np.clip(1.0 - xs / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    yvs += np.clip(1.0 - ys / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    xvs -= np.clip(1.0 - (WORLD_WIDTH - xs) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n    yvs -= np.clip(1.0 - (WORLD_WIDTH - ys) / WALL_REPULSION_LIMIT, 0.0, 1.0) * WALL_REPULSION_STRENGTH\n\n    # Enforce max speed and apply some friction\n    xvs = np.clip(xvs * 0.8 , -MAX_SPEED, MAX_SPEED)\n    yvs = np.clip(yvs * 0.8 , -MAX_SPEED, MAX_SPEED)\n\n    # Add some random noise to velocity\n    x_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n    y_noise = np.random.uniform(1.0-NOISE, 1.0+NOISE, N)\n    xs += xvs * x_noise\n    ys += yvs * y_noise\n\n\ndef animate(frame):\n\n    update_boids(boids[\'pos\'][:, 0],\n                 boids[\'pos\'][:, 1],\n                 boids[\'vel\'][:, 0],\n                 boids[\'vel\'][:, 1],\n                 frame)\n\n    scatter.set_offsets(boids[\'pos\'])\n\n\ndef mouse_move(ev):\n    global x_target\n    global y_target\n    x_target = ev.xdata\n    y_target = ev.ydata\n\ncid = fig.canvas.mpl_connect(\'button_press_event\', mouse_move)\nanimation = FuncAnimation(fig, animate, interval=30)\nplt.show()\n'"
code/experiments/boids.py,15,"b'# -----------------------------------------------------------------------------\n# From Numpy to Python\n# Copyright (2017) Nicolas P. Rougier - BSD license\n# More information at https://github.com/rougier/numpy-book\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial.distance import cdist\nfrom matplotlib.animation import FuncAnimation\n\n\ndef update(frame_number):\n\n    P = boids[\'position\']\n    Px = boids[\'position\'][:, 0]\n    Py = boids[\'position\'][:, 1]\n\n    V = boids[\'velocity\']\n    Vx = boids[\'velocity\'][:, 0]\n    Vy = boids[\'velocity\'][:, 1]\n\n    # Mask that cancel out diagonal\n    # M = (1-np.diag(np.ones(len(P))))\n\n    # Compute all paired distances between boids (D[i,i] = 0)\n    D = cdist(P, P)\n\n    # Parameters\n    # ----------\n    dt = 0.05\n\n    repulsion_radius = 0.05\n    repulsion_strength = 1.5\n    \n    cohesion_radius = 0.1\n    cohesion_strength = 1.0\n    \n    alignment_radius = 0.1\n    alignment_strength = 1.0\n\n    \n    # Rule 1: repulsion (boids move away from local neihgbours)\n    # ---------------------------------------------------------\n    M = (D < repulsion_radius)*(D > 0)\n    N = M.sum(axis=1)\n\n    \n    \n    Ax = repulsion_strength*(Px - (M*Px).sum(axis=1) / N)\n    Ay = repulsion_strength*(Py - (M*Py).sum(axis=1) / N)\n\n    \n    # Rule 2: cohesion (boids move towards local centers)\n    # ---------------------------------------------------\n    # M = (D < cohesion_radius)\n    # N = M.sum(axis=1)\n    # Ax += cohesion_strength*((M*Px).sum(axis=1) / N - Px)\n    # Ay += cohesion_strength*((M*Py).sum(axis=1) / N - Py)\n\n    # Rule 3: alignment (boids steer likes local boids)\n    # -------------------------------------------------\n    # M = (D < alignment_radius)\n    # N = M.sum(axis=1)\n    # Ax += alignment_strength*(Vx - (M*Vx).sum(axis=1) / N)\n    # Ay += alignment_strength*(Vy - (M*Vy).sum(axis=1) / N)\n\n    Vx += Ax\n    Vy += Ay\n    \n    V[...] = np.maximum(-0.1, V)\n    V[...] = np.minimum(+0.1, V)\n    P[...] = np.maximum(-1.0, P)\n    P[...] = np.minimum(+1.0, P)\n    # V[...] = np.clip(V * 0.8 , -0.1, 0.1)\n\n    P += dt*V\n    scatter.set_offsets(boids[\'position\'])\n\n    """"""\n    dt = 0.1\n    n = len(boids)\n\n    # Position\n    P = boids[\'position\']\n    Px = boids[\'position\'][:,0]\n    Py = boids[\'position\'][:,1]\n\n    # Velocity\n    V = boids[\'velocity\']\n    Vx = boids[\'velocity\'][:,0]\n    Vy = boids[\'velocity\'][:,1]\n\n    # Boids distance\n    T = cKDTree(P)\n    # k nearest neighbors\n    k = 3\n    D, I = T.query(P, k)\n\n    print(D.shape)\n\n    # Cohesion: steer to move toward the average position of local flockmates\n    # C = (P.sum(axis=0)/n - P)\n    C = (P - P[I].sum(axis=1)/(k-1))\n\n    # Alignment: steer towards the average heading of local flockmates\n    # A = (V.sum(axis=0)/n - V)\n    A = (V[I].sum(axis=1)/(k-1) - V)\n\n    # Repulsion: steer to avoid crowding local flockmates\n    R = P - P[I][:,1:,:].sum(axis=1)/(k-1)\n\n    #M = np.repeat(D < 0.05, 2, axis=1).reshape(n, 7, 2)\n    #Z = np.repeat(P, 7, axis=0).reshape(n, 7, 2)\n    #R = ((Z-P[I]) * M).sum(axis=1)\n\n    V += .01*R #.1*(.5*C + 1.5*A + 3.5*R )\n    P += V*dt\n\n    V[...] = np.maximum(-.1,V)\n    V[...] = np.minimum(+.1,V)\n\n    P[...] = np.maximum(-1,P)\n    P[...] = np.minimum(+1,P)\n    #scatter.set_offsets(boids[\'position\'])\n    """"""\n\n\nn = 1000\nxmin, xmax = -1.0, +1.0\nymin, ymax = -1.0, +1.0\n\n\nboids = np.zeros(n, [(\'position\', \'f4\', 2),\n                     (\'velocity\', \'f4\', 2)])\nboids[\'position\'] = 0.2*np.random.uniform(-1.00, +1.00, (n, 2))\nboids[\'velocity\'] = 0.0*np.random.uniform(-0.10, +0.10, (n, 2))\n\n\nfig = plt.figure(figsize=(8, 8))\nax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=True, aspect=1)\nscatter = ax.scatter(boids[""position""][:, 0], boids[""position""][:, 1],\n                     s=10, facecolor=""red"", edgecolor=""None"", alpha=0.5)\nax.set_xlim(-1, 1)\nax.set_ylim(-1, 1)\nanimation = FuncAnimation(fig, update, interval=10)\nplt.show()\n\n'"
code/experiments/boids_3.py,9,"b'""""""\nboids.py \n\nImplementation of Craig Reynold\'s BOIDs\n\nAuthor: Mahesh Venkitachalam\n""""""\n\nimport sys, argparse\nimport math\nimport numpy as np\nimport matplotlib.pyplot as plt \nimport matplotlib.animation as animation\nfrom scipy.spatial.distance import squareform, pdist, cdist\nfrom numpy.linalg import norm\n\nwidth, height = 640, 480\n\nclass Boids:\n    """"""Class that represents Boids simulation""""""\n    def __init__(self, N):\n        """""" initialize the Boid simulation""""""\n        # init position & velocities\n        self.pos = [width/2.0, height/2.0] + 10*np.random.rand(2*N).reshape(N, 2)\n        # normalized random velocities\n        angles = 2*math.pi*np.random.rand(N)\n        self.vel = np.array(list(zip(np.sin(angles), np.cos(angles))))\n        self.N = N\n        # min dist of approach\n        self.minDist = 25.0\n        # max magnitude of velocities calculated by ""rules""\n        self.maxRuleVel = 0.03\n        # max maginitude of final velocity\n        self.maxVel = 2.0\n\n    def tick(self, frameNum, pts, beak):\n        """"""Update the simulation by one time step.""""""\n        # get pairwise distances\n        self.distMatrix = squareform(pdist(self.pos))\n        # apply rules:\n        self.vel += self.applyRules()\n        self.limit(self.vel, self.maxVel)\n        self.pos += self.vel\n        self.applyBC()\n        # update data\n        pts.set_data(self.pos.reshape(2*self.N)[::2], \n                     self.pos.reshape(2*self.N)[1::2])\n        vec = self.pos + 10*self.vel/self.maxVel\n        beak.set_data(vec.reshape(2*self.N)[::2], \n                      vec.reshape(2*self.N)[1::2])\n\n    def limitVec(self, vec, maxVal):\n        """"""limit magnitide of 2D vector""""""\n        mag = norm(vec)\n        if mag > maxVal:\n            vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag\n    \n    def limit(self, X, maxVal):\n        """"""limit magnitide of 2D vectors in array X to maxValue""""""\n        for vec in X:\n            self.limitVec(vec, maxVal)\n            \n    def applyBC(self):\n        """"""apply boundary conditions""""""\n        deltaR = 2.0\n        for coord in self.pos:\n            if coord[0] > width + deltaR:\n                coord[0] = - deltaR\n            if coord[0] < - deltaR:\n                coord[0] = width + deltaR    \n            if coord[1] > height + deltaR:\n                coord[1] = - deltaR\n            if coord[1] < - deltaR:\n                coord[1] = height + deltaR\n    \n    def applyRules(self):\n        # apply rule #1 - Separation\n        D = self.distMatrix < 25.0\n        vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)\n        self.limit(vel, self.maxRuleVel)\n\n        # different distance threshold\n        D = self.distMatrix < 50.0\n\n        # apply rule #2 - Alignment\n        vel2 = D.dot(self.vel)\n        self.limit(vel2, self.maxRuleVel)\n        vel += vel2;\n\n        # apply rule #1 - Cohesion\n        vel3 = D.dot(self.pos) - self.pos\n        self.limit(vel3, self.maxRuleVel)\n        vel += vel3\n\n        return vel\n\n    def buttonPress(self, event):\n        """"""event handler for matplotlib button presses""""""\n        # left click - add a boid\n        if event.button is 1:\n            self.pos = np.concatenate((self.pos, \n                                       np.array([[event.xdata, event.ydata]])), \n                                      axis=0)\n            # random velocity\n            angles = 2*math.pi*np.random.rand(1)\n            v = np.array(list(zip(np.sin(angles), np.cos(angles))))\n            self.vel = np.concatenate((self.vel, v), axis=0)\n            self.N += 1 \n        # right click - scatter\n        elif event.button is 3:\n            # add scattering velocity \n            self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))\n        \ndef tick(frameNum, pts, beak, boids):\n    #print frameNum\n    """"""update function for animation""""""\n    boids.tick(frameNum, pts, beak)\n    return pts, beak\n\n# main() function\ndef main():\n  # use sys.argv if needed\n  print(\'starting boids...\')\n\n  parser = argparse.ArgumentParser(description=""Implementing Craig Reynold\'s Boids..."")\n  # add arguments\n  parser.add_argument(\'--num-boids\', dest=\'N\', required=False)\n  args = parser.parse_args()\n\n  # number of boids\n  N = 500\n  if args.N:\n      N = int(args.N)\n\n  # create boids\n  boids = Boids(N)\n\n  # setup plot\n  fig = plt.figure()\n  ax = plt.axes(xlim=(0, width), ylim=(0, height))\n\n  pts, = ax.plot([], [], markersize=1, \n                  c=\'k\', marker=\'o\', ls=\'None\')\n  beak, = ax.plot([], [], markersize=1, \n                  c=\'r\', marker=\'o\', ls=\'None\')\n  anim = animation.FuncAnimation(fig, tick, fargs=(pts, beak, boids), \n                                 interval=10)\n\n  # add a ""button press"" event handler\n  cid = fig.canvas.mpl_connect(\'button_press_event\', boids.buttonPress)\n\n  plt.show()\n\n# call main\nif __name__ == \'__main__\':\n  main()\n'"
