file_path,api_count,code
scripts/3d.py,13,"b""import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_slice(Z, name):\n    Z = np.atleast_2d(Z)\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols,rows), dpi=72, frameon=False)\n    #ax = plt.subplot(111, frameon=False)\n    ax = plt.axes([0,0,1,1], frameon=False)\n    A = np.arange(rows*cols).reshape(rows,cols)\n    plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n               vmin=0, vmax=max(1,Z.max()), interpolation='nearest',\n               origin='upper')\n    #plt.xticks(1.05+np.arange(cols-1),[]), plt.yticks(1+np.arange(rows-1),[])\n    plt.xticks([]), plt.yticks([])\n    #ax.grid(which='major', axis='x', linewidth=1.5, linestyle='-', color='w')\n    #ax.grid(which='major', axis='y', linewidth=1.5, linestyle='-', color='w')\n    #ax.tick_params(axis='x', colors='w')\n    #ax.tick_params(axis='y', colors='w')\n    plt.savefig('../figures/%s' % name, dpi=16)\n    #plt.show()\n\n\nrows,cols = 5, 9\n\nZ = np.array([0.,0.,0.,0.,0.,0.,0.,0.,0.])\nZ += 0.1\nshow_slice(Z, 'create-list-1.png')\n\nZ = np.zeros(cols)+.1\nshow_slice(Z, 'create-zeros-1.png')\n\nZ = np.ones(cols)+.1\nshow_slice(Z, 'create-ones-1.png')\n\nZ = np.arange(cols)\nshow_slice(Z, 'create-arange-1.png')\n\nZ = np.random.uniform(0,1,cols)\nshow_slice(Z, 'create-uniform-1.png')\n\nZ = np.zeros((rows,cols))+.1\nshow_slice(Z, 'create-zeros-2.png')\n\nZ = np.ones((rows,cols))+.1\nshow_slice(Z, 'create-ones-2.png')\n\nZ = np.array([[0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.]])\nZ += 0.1\nshow_slice(Z, 'create-list-2.png')\n\nZ = np.arange(rows*cols).reshape(rows,cols)\nshow_slice(Z, 'create-arange-2.png')\n\nZ = np.random.uniform(0,1,(rows,cols))\nshow_slice(Z, 'create-uniform-2.png')\n"""
scripts/broadcasts.py,33,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\n\n\ndef show(Z, shape, filename):\n    Z = np.atleast_2d(Z)\n\n    fig = plt.figure(figsize=(shape[1]/4.,shape[0]/4.), dpi=72)\n    ax = plt.subplot(111)\n    plt.imshow(Z, cmap=\'Purples\', extent=[0,Z.shape[1],0,Z.shape[0]],\n               vmin=0, vmax=max(1,Z.max()), interpolation=\'nearest\', origin=\'upper\')\n    plt.xticks([]), plt.yticks([])\n    plt.xlim(0,shape[1])\n    plt.ylim(0,shape[0])\n\n    for pos in [\'top\', \'bottom\', \'right\', \'left\']:\n        ax.spines[pos].set_edgecolor(\'k\')\n        ax.spines[pos].set_alpha(.25)\n        if Z.shape != shape:\n            ax.spines[pos].set_linestyle(\'dashed\')\n            ax.spines[pos].set_alpha(.1)\n    if Z.shape != shape:\n        rect = Rectangle((0.01,0.01),Z.shape[1],Z.shape[0], \n                         zorder=+10,edgecolor=\'black\', alpha=.25,facecolor=\'None\')\n        ax.add_patch(rect)\n        ax.set_axisbelow(True)\n    plt.savefig(filename,dpi=72)\n\n\n\nZ1 = np.random.uniform(0,1,(9,5))\nZ2 = np.ones((1,1))\nZ3 = np.ones(Z1.shape)\nshow(Z1, Z1.shape, ""../figures/broadcast-1.1.png"")\nshow(Z2, Z1.shape, ""../figures/broadcast-1.2.png"")\nshow(Z3, Z1.shape, ""../figures/broadcast-1.3.png"")\nshow(Z1+Z2, Z1.shape, ""../figures/broadcast-1.4.png"")\n\nZ2 = np.arange(9).reshape(9,1)\nZ3 = np.repeat(Z2,5).reshape(9,5)\nshow(Z1, Z1.shape, ""../figures/broadcast-2.1.png"")\nshow(Z2, Z1.shape, ""../figures/broadcast-2.2.png"")\nshow(Z3, Z1.shape, ""../figures/broadcast-2.3.png"")\nshow(Z1+Z2, Z1.shape, ""../figures/broadcast-2.4.png"")\n\nZ2 = np.arange(5).reshape(1,5)\n#Z3 = np.zeros(Z1.shape)\nZ3 = np.repeat(Z2,9).reshape(5,9).T\nshow(Z1, Z1.shape, ""../figures/broadcast-3.1.png"")\nshow(Z2, Z1.shape, ""../figures/broadcast-3.2.png"")\nshow(Z3, Z1.shape, ""../figures/broadcast-3.3.png"")\nshow(Z1+Z2, Z1.shape, ""../figures/broadcast-3.4.png"")\n\nZ = np.zeros((9,5))\nZ1 = np.arange(9).reshape(9,1)\nZ2 = np.arange(5).reshape(1,5)\nZ3 = np.repeat(Z1,5).reshape(9,5)\nZ4 = np.repeat(Z2,9).reshape(5,9).T\nshow(Z1, Z.shape, ""../figures/broadcast-4.1.png"")\nshow(Z2, Z.shape, ""../figures/broadcast-4.2.png"")\nshow(Z3, Z.shape, ""../figures/broadcast-4.3.png"")\nshow(Z4, Z.shape, ""../figures/broadcast-4.4.png"")\nshow(Z1+Z2, Z.shape, ""../figures/broadcast-4.5.png"")\n\n\n# def broadcast(Z1,Z2,Z3,Z4,Z5,filename):\n\n#     filename \'\'.join(filename.split(\'.\')[:-1])\n\n#     show_array(Z1, filename+\'.1.png\')\n#     show_array(Z1, filename+\'.1.png\')\n#     show_array(Z1, filename+\'.1.png\')\n#     show_array(Z1, filename+\'.1.png\')\n\n\n#     def print_array(Z,ox,oy,C):\n#         for x in range(Z.shape[1]):\n#             for y in range(Z.shape[0]):\n#                 if x >= C.shape[1] or y >= C.shape[0]:\n#                     color = \'.75\'\n#                     zorder=  -1\n#                 else:\n#                     color = \'k\'\n#                     zorder=  +1\n#                 plt.text(ox+x+0.5, rows-0.5-oy-y, \'%d\' % Z[y,x],\n#                          ha=\'center\', va= \'center\', size=24, color=color)\n#                 rect = Rectangle((ox+x,rows-1+oy-y),1,1, zorder=zorder,edgecolor=color, facecolor=\'None\')\n#                 ax.add_patch(rect)\n    \n#     rows = 4\n#     cols = 5*3 + (5-1)\n#     fig = plt.figure(figsize=(cols,rows), dpi=72, frameon=False)\n#     ax = plt.axes([0.05,0.05,.9,.9], frameon=False)\n#     plt.xlim(0,cols), plt.xticks([])\n#     plt.ylim(0,rows), plt.yticks([])\n#     ox,oy = 0.0125, 0.0125\n#     print_array(Z1,ox+0,oy,Z1)\n#     plt.text(3.5, 2, \'+\', ha=\'center\', va= \'center\', size=48)\n#     print_array(Z2,ox+4,oy,Z2)\n#     plt.text(7.5, 2, \'=\', ha=\'center\', va= \'center\', size=48)\n#     print_array(Z3,ox+8,oy,Z1)\n#     plt.text(11.5, 2, \'+\', ha=\'center\', va= \'center\', size=48)\n#     print_array(Z4,ox+12,oy,Z2)\n#     plt.text(15.5, 2, \'=\', ha=\'center\', va= \'center\', size=48)\n#     print_array(Z5,ox+16,oy,Z5)\n# #    plt.savefig(\'../figures/%s\' % name, dpi=32)\n# #    plt.show()\n\n\n\n\n# Z  = np.zeros((4,3))\n# Z1 = np.repeat(np.arange(4)*10,3).reshape(4,3)\n# Z2 = np.zeros((1,1))\n# Z3 = Z1+Z2\n# broadcast(Z1,Z2,Z+Z1,Z+Z2,Z1+Z2, ""../figures/broadcast-1.png"")\n\n\n# Z  = np.zeros((4,3))\n# Z1 = np.repeat(np.arange(4)*10,3).reshape(4,3)\n# Z2 = np.resize(np.arange(3),(4,3))\n# Z3 = Z1+Z2\n# broadcast(Z1,Z2,Z+Z1,Z+Z2,Z1+Z2, ""../figures/broadcast-2.png"")\n\n\n# Z  = np.zeros((4,3))\n# Z1 = np.repeat(np.arange(4)*10,3).reshape(4,3)\n# Z2 = np.arange(3).reshape(1,3)\n# Z3 = Z1+Z2\n# broadcast(Z1,Z2,Z+Z1,Z+Z2,Z1+Z2, ""../figures/broadcast-3.png"")\n\n\n# Z  = np.zeros((4,3))\n# Z1 = np.arange(4).reshape(4,1)*10\n# Z2 = np.arange(3).reshape(1,3)\n# Z3 = Z1+Z2\n# broadcast(Z1,Z2,Z+Z1,Z+Z2,Z1+Z2, ""../figures/broadcast-4.png"")\n\n\n\n""""""\ndef show_array(Z1, Z2, name, a):\n    Z1 = np.atleast_2d(Z1)\n    rows,cols = Z2.shape\n    fig = figure(figsize=(cols,rows), dpi=72, frameon=False)\n    ax = axes([0,0,1,1], frameon=False)\n    if a:\n        imshow(Z2, cmap=\'Purples\', extent=[0,Z2.shape[1],0,Z2.shape[0]], alpha=.5,\n               vmin=-0.1, vmax=1, interpolation=\'nearest\', origin=\'lower\')\n        hold(True)\n    imshow(Z1, cmap=\'Purples\', extent=[0,Z1.shape[1],0,Z1.shape[0]],\n           vmin=-0.1, vmax=1, interpolation=\'nearest\', origin=\'lower\')\n    xlim(0,Z2.shape[1]), xticks([])\n    ylim(0,Z2.shape[0]), yticks([])\n    savefig(\'../figures/%s\' % name, dpi=16)\n    #show()\n\n\nrows,cols = 5, 9\n\nZ1 = np.array([1.0])\nZ2 = np.resize(Z1,(5,9))\nshow_array(Z1,Z2, \'broadcasts-1-before.png\', False)\nshow_array(Z1,Z2, \'broadcasts-1-after.png\', True)\n\nZ1 = np.linspace(0,1,cols).reshape(1,cols)\nZ2 = np.repeat(Z1,rows,axis=0)\nshow_array(Z1,Z2, \'broadcasts-2-before.png\', False)\nshow_array(Z1,Z2, \'broadcasts-2-after.png\', True)\n\nZ1 = np.linspace(0,1,rows).reshape(rows,1)\nZ2 = np.repeat(Z1,cols,axis=1)\nshow_array(Z1,Z2, \'broadcasts-3-before.png\', False)\nshow_array(Z1,Z2, \'broadcasts-3-after.png\', True)\n""""""\n'"
scripts/creates.py,17,"b""import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_array2(Z, name):\n    Z = np.atleast_2d(Z)\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols/4.,rows/4.), dpi=72)\n    ax = plt.subplot(111)\n    plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n               vmin=0, vmax=max(1,Z.max()), interpolation='nearest',\n               origin='upper')\n    #plt.xticks(1.05+np.arange(cols-1),[]), plt.yticks(1+np.arange(rows-1),[])\n    plt.xticks([]), plt.yticks([])\n    for pos in ['top', 'bottom', 'right', 'left']:\n        ax.spines[pos].set_edgecolor('k')\n        ax.spines[pos].set_alpha(.25)\n    plt.savefig('../figures/%s' % name, dpi=72)\n    #plt.show()\n\n\ndef show_array3(Z, name):\n    Z = np.atleast_2d(Z)\n    rows,cols = Z.shape[1],Z.shape[2]\n    fig = plt.figure(figsize=(cols,rows), dpi=72, frameon=False)\n    for i in range(Z.shape[0],0,-1):\n        d = .2*i/float(Z.shape[0])\n        ax = plt.axes([d,d,0.7,0.7])\n        plt.imshow(Z[Z.shape[0]-i], cmap='Purples', extent=[0,cols,0,rows],\n                   vmin=0, vmax=max(1,Z.max()), interpolation='nearest',\n                   origin='upper')\n        plt.xticks([]), plt.yticks([])\n        for pos in ['top', 'bottom', 'right', 'left']:\n            ax.spines[pos].set_edgecolor('k')\n            ax.spines[pos].set_alpha(.25)\n    plt.savefig('../figures/%s' % name, dpi=16)\n    #plt.show()\n\n\n\nrows,cols = 5, 9\n\nZ = np.array([0.,0.,0.,0.,0.,0.,0.,0.,0.])\nZ += 0.1\nshow_array2(Z, 'create-list-1.png')\n\nZ = np.zeros(cols)+.1\nshow_array2(Z, 'create-zeros-1.png')\n\nZ = np.ones(cols)+.1\nshow_array2(Z, 'create-ones-1.png')\n\nZ = np.arange(cols)\nshow_array2(Z, 'create-arange-1.png')\n\nZ = np.random.uniform(0,1,cols)\nshow_array2(Z, 'create-uniform-1.png')\n\nZ = np.zeros((rows,cols))+.1\nshow_array2(Z, 'create-zeros-2.png')\n\nZ = np.ones((rows,cols))+.1\nshow_array2(Z, 'create-ones-2.png')\n\nZ = np.array([[0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.],\n              [0.,0.,0.,0.,0.,0.,0.,0.,0.]])\nZ += 0.1\nshow_array2(Z, 'create-list-2.png')\n\nZ = np.arange(rows*cols).reshape(rows,cols)\nshow_array2(Z, 'create-arange-2.png')\n\nZ = np.random.uniform(0,1,(rows,cols))\nshow_array2(Z, 'create-uniform-2.png')\n\nZ = np.zeros((3,5,9))+.1\nshow_array3(Z, 'create-zeros-3.png')\n\nZ = np.ones((3,5,9))+.1\nshow_array3(Z, 'create-ones-3.png')\n\nZ = np.arange(3*5*9).reshape(3,5,9)\nshow_array3(Z, 'create-arange-3.png')\n\nZ = np.random.uniform(0,1,(3,rows,cols))\nshow_array3(Z, 'create-uniform-3.png')\n\n\n"""
scripts/exercice-1.py,2,"b'import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef iterate(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\nZ  = np.zeros((32,32), dtype=int)\nZ[1:4,1:4] = [[0,0,1],\n              [1,0,1],\n              [0,1,1]]\n\nfor i in range(4*20):\n    iterate(Z)\n\nsize = 4*np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.025, 0.025, .95, .95], frameon=True)\nplt.imshow(Z,interpolation=\'nearest\', cmap=plt.cm.Purples)\nplt.xticks([]), plt.yticks([])\nplt.savefig(\'../figures/exercice-1.png\')\nplt.show()\n'"
scripts/exercice-2.py,2,"b'import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef iterate(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\nZ  = np.random.uniform(0,1,(256,512))\nZ = (Z < .2).astype(int)\n\nsize = np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nplt.imshow(Z,interpolation=\'nearest\', cmap=plt.cm.Purples)\nplt.xticks([]), plt.yticks([])\nplt.savefig(\'../figures/exercice-2.png\', dpi=dpi)\nplt.show()\n'"
scripts/exercice-3.py,3,"b'import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef iterate(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\nZ  = np.random.randint(0,2,(256,512)).astype(int)\nU  = np.zeros(Z.shape, dtype=int)\nfor i in range(100):\n    iterate(Z)\n    U = .999*U + Z\n\nsize = np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nplt.imshow(U,interpolation=\'nearest\', cmap=plt.cm.Purples)\nplt.xticks([]), plt.yticks([])\nplt.savefig(\'../figures/exercice-3.png\', dpi=dpi)\nplt.show()\n'"
scripts/exercice-4.py,2,"b'\'\'\'\nReaction Diffusion : Gray-Scott model\n\nReferences:\n----------\nComplex Patterns in a Simple System\nJohn E. Pearson, Science 261, 5118, 189-192, 1993.\n\nEncode movie\n------------\n\nffmpeg -r 30 -i ""tmp-%03d.png"" -c:v libx264 -crf 23 -pix_fmt yuv420p bacteria.mp4\n\'\'\'\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn,k  = 100, 4\nZ = np.zeros((n+2,2*n+2))\ndt = 0.05\n\nplt.ion()\n\nsize = 3*np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nim = plt.imshow(Z, interpolation=\'bicubic\', cmap=plt.cm.hot)\nplt.xticks([]), plt.yticks([])\n\nfor i in range(50000):\n    L = (                 Z[0:-2,1:-1] +\n         Z[1:-1,0:-2] - 4*Z[1:-1,1:-1] + Z[1:-1,2:] +\n                          Z[2:  ,1:-1] )\n    Z[1:-1,1:-1] += k*L*dt\n    Z[ n/2-20:n/2+20, n-5:n-1] =  1\n    Z[ n/2-20:n/2+20, n+1:n+5] = -1\n\n    if i % 30 == 0:\n        im.set_data(Z)\n        im.set_clim(vmin=Z.min(), vmax=Z.max())\n        plt.draw()\n        # To make movie\n        # plt.savefig(""./tmp/tmp-%03d.png"" % (i/10) ,dpi=dpi)\n\nplt.ioff()\n# plt.savefig(""../figures/zebra.png"",dpi=dpi)\n# plt.savefig(""../figures/bacteria.png"",dpi=dpi)\nplt.savefig(""../figures/diffusion.png"",dpi=dpi)\nplt.show()\n'"
scripts/game-of-life-big.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright INRIA\n# Contributors: Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n#\n# DANA is a computing framework for the simulation of distributed,\n# asynchronous, numerical and adaptive models.\n#\n# This software is governed by the CeCILL license under French law and abiding\n# by the rules of distribution of free software. You can use, modify and/ or\n# redistribute the software under the terms of the CeCILL license as circulated\n# by CEA, CNRS and INRIA at the following URL\n# http://www.cecill.info/index.en.html.\n#\n# As a counterpart to the access to the source code and rights to copy, modify\n# and redistribute granted by the license, users are provided only with a\n# limited warranty and the software\'s author, the holder of the economic\n# rights, and the successive licensors have only limited liability.\n#\n# In this respect, the user\'s attention is drawn to the risks associated with\n# loading, using, modifying and/or developing or reproducing the software by\n# the user in light of its specific status of free software, that may mean that\n# it is complicated to manipulate, and that also therefore means that it is\n# reserved for developers and experienced professionals having in-depth\n# computer knowledge. Users are therefore encouraged to load and test the\n# software\'s suitability as regards their requirements in conditions enabling\n# the security of their systems and/or data to be ensured and, more generally,\n# to use and operate it in the same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n# -----------------------------------------------------------------------------\nimport matplotlib\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef iterate(Z):\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\n\nZ = np.random.randint(0,2,(256,512))\nfor i in range(100):\n    iterate(Z)\n\nsize = np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nplt.imshow(Z,interpolation=\'nearest\', cmap=plt.cm.gray_r)\nplt.xticks([]), plt.yticks([])\nplt.savefig(\'../figures/game-of-life-big.png\', dpi=dpi)\nplt.show()\n'"
scripts/game-of-life-numpy.py,6,"b""# -----------------------------------------------------------------------------\n# Copyright INRIA\n# Contributors: Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n#\n# DANA is a computing framework for the simulation of distributed,\n# asynchronous, numerical and adaptive models.\n#\n# This software is governed by the CeCILL license under French law and abiding\n# by the rules of distribution of free software. You can use, modify and/ or\n# redistribute the software under the terms of the CeCILL license as circulated\n# by CEA, CNRS and INRIA at the following URL\n# http://www.cecill.info/index.en.html.\n#\n# As a counterpart to the access to the source code and rights to copy, modify\n# and redistribute granted by the license, users are provided only with a\n# limited warranty and the software's author, the holder of the economic\n# rights, and the successive licensors have only limited liability.\n#\n# In this respect, the user's attention is drawn to the risks associated with\n# loading, using, modifying and/or developing or reproducing the software by\n# the user in light of its specific status of free software, that may mean that\n# it is complicated to manipulate, and that also therefore means that it is\n# reserved for developers and experienced professionals having in-depth\n# computer knowledge. Users are therefore encouraged to load and test the\n# software's suitability as regards their requirements in conditions enabling\n# the security of their systems and/or data to be ensured and, more generally,\n# to use and operate it in the same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\ndef iterate_1(Z):\n    # Count neighbours\n    N = np.zeros(Z.shape, int)\n    N[1:-1,1:-1] += (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n                     Z[1:-1,0:-2]                + Z[1:-1,2:] +\n                     Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n    N_ = N.ravel()\n    Z_ = Z.ravel()\n\n    # Apply rules\n    R1 = np.argwhere( (Z_==1) & (N_ < 2) )\n    R2 = np.argwhere( (Z_==1) & (N_ > 3) )\n    R3 = np.argwhere( (Z_==1) & ((N_==2) | (N_==3)) )\n    R4 = np.argwhere( (Z_==0) & (N_==3) )\n\n    # Set new values\n    Z_[R1] = 0\n    Z_[R2] = 0\n    Z_[R3] = Z_[R3]\n    Z_[R4] = 1\n\n    # Make sure borders stay null\n    Z[0,:] = Z[-1,:] = Z[:,0] = Z[:,-1] = 0\n\n\ndef iterate_2(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\n\nZ = np.array([[0,0,0,0,0,0],\n              [0,0,0,1,0,0],\n              [0,1,0,1,0,0],\n              [0,0,1,1,0,0],\n              [0,0,0,0,0,0],\n              [0,0,0,0,0,0]])\n\nprint(Z)\nprint()\nfor i in range(4): iterate_2(Z)\nprint(Z)\n\n"""
scripts/game-of-life-python.py,0,"b'Z = [[0,0,0,0,0,0],\n     [0,0,0,1,0,0],\n     [0,1,0,1,0,0],\n     [0,0,1,1,0,0],\n     [0,0,0,0,0,0],\n     [0,0,0,0,0,0]]\n\ndef compute_neighbours(Z):\n    shape = len(Z), len(Z[0])\n    N  = [[0,]*(shape[0])  for i in range(shape[1])]\n    for x in range(1,shape[0]-1):\n        for y in range(1,shape[1]-1):\n            N[x][y] = Z[x-1][y-1]+Z[x][y-1]+Z[x+1][y-1] \\\n                    + Z[x-1][y]            +Z[x+1][y]   \\\n                    + Z[x-1][y+1]+Z[x][y+1]+Z[x+1][y+1]\n    return N\n\ndef show(Z):\n    for l in Z[1:-1]:\n        print(l[1:-1])\n    print()\n\ndef iterate(Z):\n    shape = len(Z), len(Z[0])\n    N = compute_neighbours(Z)\n    for x in range(1,shape[0]-1):\n        for y in range(1,shape[1]-1):\n            if Z[x][y] == 1 and (N[x][y] < 2 or N[x][y] > 3):\n                Z[x][y] = 0\n            elif Z[x][y] == 0 and N[x][y] == 3:\n                Z[x][y] = 1\n    return Z\n\nshow(Z)\nfor i in range(4):\n    iterate(Z)\nshow(Z)\n'"
scripts/glider-trace.py,3,"b'import numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\n\ndef iterate(Z):\n    # Count neighbours\n    N = (Z[0:-2,0:-2] + Z[0:-2,1:-1] + Z[0:-2,2:] +\n         Z[1:-1,0:-2]                + Z[1:-1,2:] +\n         Z[2:  ,0:-2] + Z[2:  ,1:-1] + Z[2:  ,2:])\n\n    # Apply rules\n    birth = (N==3) & (Z[1:-1,1:-1]==0)\n    survive = ((N==2) | (N==3)) & (Z[1:-1,1:-1]==1)\n    Z[...] = 0\n    Z[1:-1,1:-1][birth | survive] = 1\n    return Z\n\nZ  = np.random.randint(0,2,(256,256)).astype(int)\nU  = np.zeros((2*128,2*128), dtype=int)\nfor i in range(100):\n    iterate(Z)\n    U = .999*U + Z\n\nsize = np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nplt.imshow(U,interpolation=\'nearest\', cmap=plt.cm.Purples)\nplt.xticks([]), plt.yticks([])\nplt.savefig(\'trace.png\')\nplt.show()\n'"
scripts/glider.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright INRIA\n# Contributors: Nicolas P. Rougier (Nicolas.Rougier@inria.fr)\n#\n# DANA is a computing framework for the simulation of distributed,\n# asynchronous, numerical and adaptive models.\n#\n# This software is governed by the CeCILL license under French law and abiding\n# by the rules of distribution of free software. You can use, modify and/ or\n# redistribute the software under the terms of the CeCILL license as circulated\n# by CEA, CNRS and INRIA at the following URL\n# http://www.cecill.info/index.en.html.\n#\n# As a counterpart to the access to the source code and rights to copy, modify\n# and redistribute granted by the license, users are provided only with a\n# limited warranty and the software\'s author, the holder of the economic\n# rights, and the successive licensors have only limited liability.\n#\n# In this respect, the user\'s attention is drawn to the risks associated with\n# loading, using, modifying and/or developing or reproducing the software by\n# the user in light of its specific status of free software, that may mean that\n# it is complicated to manipulate, and that also therefore means that it is\n# reserved for developers and experienced professionals having in-depth\n# computer knowledge. Users are therefore encouraged to load and test the\n# software\'s suitability as regards their requirements in conditions enabling\n# the security of their systems and/or data to be ensured and, more generally,\n# to use and operate it in the same conditions as regards security.\n#\n# The fact that you are presently reading this means that you have had\n# knowledge of the CeCILL license and that you accept its terms.\n# -----------------------------------------------------------------------------\nimport numpy\n\ndef compute_neighbours(Z):\n    N = numpy.zeros(Z.shape)\n    N[1:, 1:] += Z[:-1, :-1]\n    N[1:, :-1] += Z[:-1, 1:]\n    N[:-1, 1:] += Z[1:, :-1]\n    N[:-1, :-1] += Z[1:, 1:]\n    N[:-1, :] += Z[1:, :]\n    N[1:, :] += Z[:-1, :]\n    N[:, :-1] += Z[:, 1:]\n    N[:, 1:] += Z[:, :-1]\n    return N\n    \ndef iterate(Z):\n    N = compute_neighbours(Z)\n    # a live cell is killed if it has fewer \n    # than 2 or more than 3 neighbours.\n    part1 = ((Z == 1) & (N < 4) & (N > 1)) \n    # a new cell forms if a square has exactly three members\n    part2 = ((Z == 0) & (N == 3))\n    return (part1 | part2).astype(int)\n\n\nZ = numpy.array([[0,0,0,0,0,0,0],\n                 [0,0,0,1,0,0,0],\n                 [0,1,0,1,0,0,0],\n                 [0,0,1,1,0,0,0],\n                 [0,0,0,0,0,0,0],\n                 [0,0,0,0,0,0,0],\n                 [0,0,0,0,0,0,0]])\n#Z  = numpy.random.randint(0,2,(40,80))\n\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle\n\nsize = 12*np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nmatplotlib.rcParams[\'figure.dpi\']  = 72.0\nmatplotlib.rcParams[\'savefig.dpi\'] = 72.0\nmatplotlib.rcParams[\'xtick.major.size\'] = 0\nmatplotlib.rcParams[\'xtick.minor.size\'] = 0\nmatplotlib.rcParams[\'ytick.major.size\'] = 0\nmatplotlib.rcParams[\'ytick.minor.size\'] = 0\n\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nax = fig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\n\nax.set_xlim(0, 1)\nax.set_ylim(0, 1)\nax.set_xticks([])\nax.set_yticks([])\n\n\n\nX,Y = np.meshgrid(np.linspace(0,1,Z.shape[1],endpoint=False),\n                  np.linspace(0,1,Z.shape[0],endpoint=False))\nX += .5/Z.shape[1]\nY += .5/Z.shape[0]\n\ns = ax.transData.transform([1.0/Z.shape[1],1.0/Z.shape[0]])[0]\n\nplt.ion()\nfor i in range(9):\n    plt.cla()\n    plt.scatter(X,Y,c=Z,s=0.75*s*s, cmap=plt.cm.Purples, linewidths=.1)\n    plt.draw()\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_xticks([])\n    ax.set_yticks([])\n    plt.savefig(""../figures/glider-%02d.png"" % i)\n    Z = iterate(Z)\nplt.ioff()\n'"
scripts/gray-scott.py,4,"b'\'\'\'\nReaction Diffusion : Gray-Scott model\n\nReferences:\n----------\nComplex Patterns in a Simple System\nJohn E. Pearson, Science 261, 5118, 189-192, 1993.\n\nEncode movie\n------------\n\nffmpeg -r 30 -i ""tmp-%03d.png"" -c:v libx264 -crf 23 -pix_fmt yuv420p bacteria.mp4\n\'\'\'\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Parameters from http://www.aliensaint.com/uo/java/rd/\n# -----------------------------------------------------\nn  = 200\nDu, Dv, F, k = 0.16, 0.08, 0.035, 0.065 # Bacteria 1\n# Du, Dv, F, k = 0.14, 0.06, 0.035, 0.065 # Bacteria 2\n# Du, Dv, F, k = 0.16, 0.08, 0.060, 0.062 # Coral\n# Du, Dv, F, k = 0.19, 0.05, 0.060, 0.062 # Fingerprint\n# Du, Dv, F, k = 0.10, 0.10, 0.018, 0.050 # Spirals\n# Du, Dv, F, k = 0.12, 0.08, 0.020, 0.050 # Spirals Dense\n# Du, Dv, F, k = 0.10, 0.16, 0.020, 0.050 # Spirals Fast\n# Du, Dv, F, k = 0.16, 0.08, 0.020, 0.055 # Unstable\n# Du, Dv, F, k = 0.16, 0.08, 0.050, 0.065 # Worms 1\n# Du, Dv, F, k = 0.16, 0.08, 0.054, 0.063 # Worms 2\n# Du, Dv, F, k = 0.16, 0.08, 0.035, 0.060 # Zebrafish\n\n\nZ = np.zeros((n+2,n+2), [(\'U\', np.double), (\'V\', np.double)])\nU,V = Z[\'U\'], Z[\'V\']\nu,v = U[1:-1,1:-1], V[1:-1,1:-1]\n\nr = 20\nu[...] = 1.0\nU[n/2-r:n/2+r,n/2-r:n/2+r] = 0.50\nV[n/2-r:n/2+r,n/2-r:n/2+r] = 0.25\nu += 0.05*np.random.random((n,n))\nv += 0.05*np.random.random((n,n))\n\n\nplt.ion()\n\nsize = np.array(Z.shape)\ndpi = 72.0\nfigsize= size[1]/float(dpi),size[0]/float(dpi)\nfig = plt.figure(figsize=figsize, dpi=dpi, facecolor=""white"")\nfig.add_axes([0.0, 0.0, 1.0, 1.0], frameon=False)\nim = plt.imshow(V, interpolation=\'bicubic\', cmap=plt.cm.gray_r)\nplt.xticks([]), plt.yticks([])\n\n\nfor i in range(25000):\n    Lu = (                 U[0:-2,1:-1] +\n          U[1:-1,0:-2] - 4*U[1:-1,1:-1] + U[1:-1,2:] +\n                           U[2:  ,1:-1] )\n    Lv = (                 V[0:-2,1:-1] +\n          V[1:-1,0:-2] - 4*V[1:-1,1:-1] + V[1:-1,2:] +\n                           V[2:  ,1:-1] )\n\n    uvv = u*v*v\n    u += (Du*Lu - uvv +  F   *(1-u))\n    v += (Dv*Lv + uvv - (F+k)*v    )\n\n    if i % 10 == 0:\n        im.set_data(V)\n        im.set_clim(vmin=V.min(), vmax=V.max())\n        plt.draw()\n        # To make movie\n        # plt.savefig(""./tmp/tmp-%03d.png"" % (i/10) ,dpi=dpi)\n\nplt.ioff()\n# plt.savefig(""../figures/zebra.png"",dpi=dpi)\n# plt.savefig(""../figures/bacteria.png"",dpi=dpi)\n# plt.savefig(""../figures/fingerprint.png"",dpi=dpi)\nplt.show()\n'"
scripts/neighbours.py,10,"b'import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_slice(Z, name, text=""""):\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols/4.,rows/4.), dpi=72)\n    #fig.patch.set_alpha(0.0)\n    ax = plt.subplot(111)\n    A = np.arange(rows*cols).reshape(rows,cols)\n    plt.imshow(Z, cmap=\'Purples\', extent=[0,cols,0,rows],\n               vmin=0, vmax=1, interpolation=\'nearest\', origin=\'upper\')\n    plt.xticks([]), plt.yticks([])\n    for pos in [\'top\', \'bottom\', \'right\', \'left\']:\n        ax.spines[pos].set_edgecolor(\'k\')\n        ax.spines[pos].set_alpha(.25)\n    if text:\n        ax.text(cols/2.,-0.15,text,color=\'k\',ha=\'center\',va=\'top\',\n                family=\'monospace\', weight=\'bold\',fontsize=10)\n    plt.savefig(\'../figures/%s\' % name, dpi=72)\n    #plt.show()\n\nrows,cols = 6, 6\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[ :-2,  :-2] = .5\nshow_slice(Z, \'../figures/neighbours-1.png\', ""Z[:-2,:-2]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[ :-2, 1:-1] = .5\nshow_slice(Z, \'../figures/neighbours-2.png\',""Z[:-2,1:-1]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[ :-2, 2:] = .5\nshow_slice(Z, \'../figures/neighbours-3.png\',""Z[:-2,2:]"")\n\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[1:-1, 0:-2] = .5\nshow_slice(Z, \'../figures/neighbours-4.png\', ""Z[1:-1,:-2]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nshow_slice(Z, \'../figures/neighbours-5.png\',""Z[1:-1,1:-1]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[1:-1, 2: ] = .5\nshow_slice(Z, \'../figures/neighbours-6.png\', ""Z[1:-1,2:]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[2:,  :-2] = .5\nshow_slice(Z, \'../figures/neighbours-7.png\', ""Z[2:,:-2]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[2:, 1:-1] = .5\nshow_slice(Z, \'../figures/neighbours-8.png\', ""Z[2:,1:-1]"")\n\nZ = np.zeros((rows,cols))+.1\nZ[1:-1,1:-1] = .25\nZ[2:,   2:] = .5\nshow_slice(Z, \'../figures/neighbours-9.png\', ""Z[2:,2:]"")\n\n'"
scripts/operations.py,8,"b""import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_array(Z, name):\n\n    Z = np.atleast_2d(Z)\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols/4.,rows/4.), dpi=72)\n    ax = plt.subplot(111)\n    #plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n    #           vmin=-.2, vmax=1, interpolation='nearest', origin='upper')\n    plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n               interpolation='nearest', origin='upper')\n    plt.xticks([]), plt.yticks([])\n    for pos in ['top', 'bottom', 'right', 'left']:\n        ax.spines[pos].set_edgecolor('k')\n        ax.spines[pos].set_alpha(.25)\n    plt.savefig('../figures/%s' % name, dpi=72)\n    #plt.show()\n\n\nrows,cols = 5, 9\n\nZ1 = np.linspace(0,1,rows*cols).reshape(rows,cols)\nshow_array(Z1, 'ops-where-before.png')\nZ2 = np.where(Z1 > 0.5, 0, 1)\nshow_array(Z2, 'ops-where-after.png')\n\nZ1 = np.linspace(0,1,rows*cols).reshape(rows,cols)\nshow_array(Z1, 'ops-maximum-before.png')\nZ2 = np.maximum(Z1, 0.5)\nshow_array(Z2, 'ops-maximum-after.png')\n\nZ1 = np.linspace(0,1,rows*cols).reshape(rows,cols)\nshow_array(Z1, 'ops-minimum-before.png')\nZ2 = np.minimum(Z1, 0.5)\nshow_array(Z2, 'ops-minimum-after.png')\n\nZ1 = np.linspace(0,1,rows*cols).reshape(rows,cols)\nshow_array(Z1, 'ops-sum-before.png')\nZ2 = Z1.sum(axis=0)\nshow_array(Z2, 'ops-sum-after.png')\n\n"""
scripts/reshapes.py,2,"b""import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_slice(Z, name):\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols/4.,rows/4.), dpi=72)\n    ax = plt.subplot(111)\n    A = np.arange(rows*cols).reshape(rows,cols)\n    plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n               vmin=0, vmax=1, interpolation='nearest', origin='upper')\n    plt.xticks([]), plt.yticks([])\n    for pos in ['top', 'bottom', 'right', 'left']:\n        ax.spines[pos].set_edgecolor('k')\n        ax.spines[pos].set_alpha(.25)\n    plt.savefig('../figures/%s' % name, dpi=72)\n#    plt.show()\n\n\nrows,cols = 3, 4\n\nZ = np.zeros((rows,cols))+.1\nZ[2,2] = 1\nshow_slice(Z, 'reshape-Z.png')\n\nZ = Z.reshape(4,3)\nshow_slice(Z, 'reshape-Z-reshape(4,3).png')\n\nZ = Z.reshape(12,1)\nshow_slice(Z, 'reshape-Z-reshape(12,1).png')\n\nZ = Z.reshape(1,12)\nshow_slice(Z, 'reshape-Z-reshape(1,12).png')\n\nZ = Z.reshape(6,2)\nshow_slice(Z, 'reshape-Z-reshape(6,2).png')\n\nZ = Z.reshape(2,6)\nshow_slice(Z, 'reshape-Z-reshape(2,6).png')\n\n"""
scripts/slices.py,13,"b""import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef show_slice(Z, name):\n    rows,cols = Z.shape\n    fig = plt.figure(figsize=(cols/4.,rows/4.), dpi=72)\n    ax = plt.subplot(111)\n    A = np.arange(rows*cols).reshape(rows,cols)\n    plt.imshow(Z, cmap='Purples', extent=[0,cols,0,rows],\n               vmin=0, vmax=1, interpolation='nearest', origin='upper')\n    plt.xticks([]), plt.yticks([])\n    for pos in ['top', 'bottom', 'right', 'left']:\n        ax.spines[pos].set_edgecolor('k')\n        ax.spines[pos].set_alpha(.25)\n    plt.savefig('../figures/%s' % name, dpi=72)\n    #plt.show()\n\n\n\nrows,cols = 5, 9\n\nZ = np.zeros((rows,cols))+.1\nshow_slice(Z, 'slice-Z.png')\n\nZ = np.zeros((rows,cols))+.1\nZ[...] = 1\nshow_slice(Z, 'slice-Z[...].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[:,::2] = 1\nshow_slice(Z, 'slice-Z[:,::2].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[::2,:] = 1\nshow_slice(Z, 'slice-Z[::2,:].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[1,1] = 1\nshow_slice(Z, 'slice-Z[1,1].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[:,0] = 1\nshow_slice(Z, 'slice-Z[:,0].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[0,:] = 1\nshow_slice(Z, 'slice-Z[0,:].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[2:,2:] = 1\nshow_slice(Z, 'slice-Z[2:,2:].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[:-2,:-2] = 1\nshow_slice(Z, 'slice-Z[:-2,:-2].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[2:4,2:4] = 1\nshow_slice(Z, 'slice-Z[2:4,2:4].png')\n\nZ = np.zeros((rows,cols))+.1\nZ[::2,::2] = 1\nshow_slice(Z, 'slice-Z[::2,::2].png')\n\n\nZ = np.zeros((rows,cols))+.1\nZ[3::2,3::2] = 1\nshow_slice(Z, 'slice-Z[3::2,3::2].png')\n\n"""
scripts/test-anim.py,3,"b'import matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\n\nFLOOR = -10\nCEILING = 10\n\nclass AnimatedScatter(object):\n    def __init__(self, numpoints=5):\n        self.numpoints = numpoints\n        self.stream = self.data_stream()\n        self.angle = 0\n\n        self.fig = plt.figure()\n        self.fig.canvas.mpl_connect(\'draw_event\',self.forceUpdate)\n        self.ax = self.fig.add_subplot(111,projection = \'3d\')\n        self.ani = animation.FuncAnimation(self.fig, self.update, interval=100, \n                                           init_func=self.setup_plot, frames=1)\n\n    def change_angle(self):\n        self.angle = (self.angle + 1)%360\n\n    def forceUpdate(self, event):\n        self.scat.changed()\n\n    def setup_plot(self):\n        X = next(self.stream)\n        c = [\'b\', \'r\', \'g\', \'y\', \'m\']\n        self.scat = self.ax.scatter(X[:,0], X[:,1], X[:,2] , c=c, s=200)\n\n        self.ax.set_xlim3d(FLOOR, CEILING)\n        self.ax.set_ylim3d(FLOOR, CEILING)\n        self.ax.set_zlim3d(FLOOR, CEILING)\n\n        return self.scat,\n\n    def data_stream(self):\n        data = np.zeros(( self.numpoints , 3 ))\n        xyz = data[:,:3]\n        while True:\n            xyz += 2 * (np.random.random(( self.numpoints,3)) - 0.5)\n            yield data\n\n    def update(self, i):\n        data = next(self.stream)\n        self.scat._offsets3d = ( np.ma.ravel(data[:,0]) , np.ma.ravel(data[:,1]) , np.ma.ravel(data[:,2]) )\n        return self.scat,\n\n    def show(self):\n        plt.show()\n\nif __name__ == \'__main__\':\n    a = AnimatedScatter()\n    #a.ani.save(""movie.gif"")\n    a.show()\n'"
scripts/test.py,0,"b'Z = [[0,0,0,0,0,0],\n     [0,0,0,1,0,0],\n     [0,1,0,1,0,0],\n     [0,0,1,1,0,0],\n     [0,0,0,0,0,0],\n     [0,0,0,0,0,0]]\n\ndef compute_neighbours(Z):\n    shape = len(Z), len(Z[0])\n    N  = [[0,]*(shape[0])  for i in range(shape[1])]\n    for x in range(1,shape[0]-1):\n        for y in range(1,shape[1]-1):\n            N[x][y] = Z[x-1][y-1]+Z[x][y-1]+Z[x+1][y-1] \\\n                    + Z[x-1][y]            +Z[x+1][y]   \\\n                    + Z[x-1][y+1]+Z[x][y+1]+Z[x+1][y+1]\n    return N\n\ndef show(Z):\n    for l in Z[1:-1]:\n        print(l[1:-1])\n    print()\n\ndef iterate(Z):\n    shape = len(Z), len(Z[0])\n    N = compute_neighbours(Z)\n    for x in range(1,shape[0]-1):\n        for y in range(1,shape[1]-1):\n            if Z[x][y] == 1 and (N[x][y] < 2 or N[x][y] > 3):\n                Z[x][y] = 0\n            elif Z[x][y] == 0 and N[x][y] == 3:\n                Z[x][y] = 1\n    return Z\n\nshow(Z)\nfor i in range(4):\n    iterate(Z)\nshow(Z)\n'"
