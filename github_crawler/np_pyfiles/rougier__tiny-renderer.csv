file_path,api_count,code
bunny.py,28,"b'# Tiny 3D Renderer (with outlines)\nimport numpy as np\n\ndef triangle(t, v0, v1, v2, intensity):\n    global coords, image, zbuffer\n\n    # Barycentric coordinates of points inside the triangle bounding box\n    xmin = int(max(0,              min(v0[0], v1[0], v2[0])))\n    xmax = int(min(image.shape[1], max(v0[0], v1[0], v2[0])+1))\n    ymin = int(max(0,              min(v0[1], v1[1], v2[1])))\n    ymax = int(min(image.shape[0], max(v0[1], v1[1], v2[1])+1))\n    P = coords[:, xmin:xmax, ymin:ymax].reshape(2,-1)\n    B = np.dot(t, np.vstack((P, np.ones((1, P.shape[1]), dtype=int))))\n\n    # Cartesian coordinates of points inside the triangle\n    I = np.argwhere(np.all(B >= 0, axis=0))\n    X, Y, Z = P[0,I], P[1,I], v0[2]*B[0,I] + v1[2]*B[1,I] + v2[2]*B[2,I]\n\n    # Z-Buffer test\n    I = np.argwhere(zbuffer[Y,X] < Z)[:,0]\n    X, Y, Z = X[I], Y[I], Z[I]\n    zbuffer[Y, X] = Z\n    image[Y, X] = intensity, intensity, intensity, 255\n\n    # Outline (black color)\n    P = []\n    P.extend(line(v0,v1))\n    P.extend(line(v1,v2))\n    P.extend(line(v2,v0))\n    P = np.array(P).T\n    B = np.dot(t, np.vstack((P, np.ones((1, P.shape[1]), dtype=int))))\n    I = np.argwhere(np.all(B >= 0, axis=0))\n    X, Y, Z = P[0,I], P[1,I], v0[2]*B[0,I] + v1[2]*B[1,I] + v2[2]*B[2,I]\n    I = np.argwhere(zbuffer[Y,X] <= Z)[:,0]\n    X, Y, Z = X[I], Y[I], Z[I]\n    image[Y, X] = 0, 0, 0, 255\n\n\ndef line(A, B):\n    (x0, y0, _), (x1, y1, _) = np.array(A).astype(int), np.array(B).astype(int)\n    P = []\n    steep = False\n    if abs(x0-x1) < abs(y0-y1): \n        steep, x0, y0, x1, y1 = True, y0, x0, y1, x1\n    if x0 > x1: x0, x1, y0, y1 = x1, x0, y1, y0\n    dx, dy = x1-x0, y1-y0\n    y, error2, derror2 = y0, 0, abs(dy)*2\n    for x in range(x0,x1+1):\n        if steep: P.append((y,x))\n        else:     P.append((x,y))\n        error2 += derror2; \n        if error2 > dx:\n            y += 1 if y1 > y0 else -1 \n            error2 -= dx*2\n    return P\n\ndef obj_load(filename):\n    V, Vi = [], []\n    with open(filename) as f:\n       for line in f.readlines():\n           if line.startswith(\'#\'): continue\n           values = line.split()\n           if not values: continue\n           if values[0] == \'v\':\n               V.append([float(x) for x in values[1:4]])\n           elif values[0] == \'f\' :\n               Vi.append([int(x) for x in values[1:4]])\n    return np.array(V), np.array(Vi)-1\n\n\ndef lookat(eye, center, up):\n    normalize = lambda x: x/np.linalg.norm(x)\n    M = np.eye(4)\n    z = normalize(eye-center)\n    x = normalize(np.cross(up,z))\n    y = normalize(np.cross(z,x))\n    M[0,:3], M[1,:3], M[2,:3], M[:3,3] = x, y, z, -center\n    return M\n\ndef viewport(x, y, w, h, d):\n    return np.array([[w/2, 0, 0, x+w/2],\n                     [0, h/2, 0, y+h/2],\n                     [0, 0, d/2,   d/2],\n                     [0, 0, 0,       1]])\n\n    \nif __name__ == \'__main__\':\n    import time\n    import PIL.Image\n\n    width, height = 1200,1200\n    light         = np.array([0,0,-1])\n    eye           = np.array([-1,1,3])\n    center        = np.array([0,0,0])\n    up            = np.array([0,1,0])\n\n    image = np.zeros((height,width,4), dtype=np.uint8)\n    zbuffer = -1000*np.ones((height,width))\n    coords = np.mgrid[0:width, 0:height].astype(int)\n\n    V, Vi = obj_load(""bunny.obj"")\n\n    # Centering and scaling\n    vmin, vmax = V.min(), V.max()\n    V = (2*(V-vmin)/(vmax-vmin) - 1)*1.25\n    xmin, xmax = V[:,0].min(), V[:,0].max()\n    V[:,0] = V[:,0] - xmin - (xmax-xmin)/2\n    ymin, ymax = V[:,1].min(), V[:,1].max()\n    V[:,1] = V[:,1] - ymin - (ymax-ymin)/2\n\n    viewport = viewport(32, 32, width-64, height-64, 1000)\n    modelview = lookat(eye, center, up)\n\n    Vh = np.c_[V, np.ones(len(V))] # Homogenous coordinates\n    V = Vh @ modelview.T           # World coordinates\n    Vs = V @ viewport.T            # Screen coordinates\n    V, Vs = V[:,:3],  Vs[:,:3]     # Back to cartesian coordinates\n\n    V, Vs = V[Vi], Vs[Vi]\n    \n    # Pre-compute tri-linear coordinates\n    T = np.transpose(Vs, axes=[0,2,1]).copy()\n    T[:,2,:] = 1\n    T = np.linalg.inv(T)\n\n    # Pre-compute normal vectors and intensity\n    N = np.cross(V[:,2]-V[:,0], V[:,1]-V[:,0])\n    N = N / np.linalg.norm(N,axis=1).reshape(len(N),1)\n    I = np.dot(N, light)*255\n\n    start = time.time()\n    for i in np.argwhere(I>=0)[:,0]:\n        (vs0, vs1, vs2) = Vs[i]\n        triangle(T[i], vs0, vs1, vs2, I[i])\n        #line(vs0, vs1, (0,0,0,255))\n        #line(vs1, vs2, (0,0,0,255))\n        #line(vs2, vs0, (0,0,0,255))\n        \n    end = time.time()\n    \n    print(""Rendering time: {}"".format(end-start))\n    PIL.Image.fromarray(image[::-1,:,:]).save(""bunny.png"")\n'"
head.py,25,"b'# Tiny 3D Renderer\nimport numpy as np\n\ndef triangle(t, A, B, C, intensity):\n    global coords, texture, image, zbuffer\n    (v0, uv0), (v1, uv1), (v2, uv2) = A, B, C\n\n    # Barycentric coordinates of points inside the triangle bounding box\n    # t = np.linalg.inv([[v0[0],v1[0],v2[0]], [v0[1],v1[1],v2[1]], [1,1,1]])\n    xmin = int(max(0,              min(v0[0], v1[0], v2[0])))\n    xmax = int(min(image.shape[1], max(v0[0], v1[0], v2[0])+1))\n    ymin = int(max(0,              min(v0[1], v1[1], v2[1])))\n    ymax = int(min(image.shape[0], max(v0[1], v1[1], v2[1])+1))\n    P = coords[:, xmin:xmax, ymin:ymax].reshape(2,-1)\n    B = np.dot(t, np.vstack((P, np.ones((1, P.shape[1])))))\n\n    # Cartesian coordinates of points inside the triangle\n    I = np.argwhere(np.all(B >= 0, axis=0))\n    X, Y, Z = P[0,I], P[1,I], v0[2]*B[0,I] + v1[2]*B[1,I] + v2[2]*B[2,I]\n\n    # Texture coordinates of points inside the triangle\n    U = (    (uv0[0]*B[0,I] + uv1[0]*B[1,I] + uv2[0]*B[2,I]))*(texture.shape[0]-1)\n    V = (1.0-(uv0[1]*B[0,I] + uv1[1]*B[1,I] + uv2[1]*B[2,I]))*(texture.shape[1]-1)\n    C = texture[V.astype(int), U.astype(int)]\n\n    # Z-Buffer test\n    I = np.argwhere(zbuffer[Y,X] < Z)[:,0]\n    X, Y, Z, C = X[I], Y[I], Z[I], C[I]\n    zbuffer[Y, X] = Z\n    image[Y, X] = C * (intensity, intensity, intensity, 1)\n\ndef obj_load(filename):\n    V, T, Vi, Ti = [], [], [], []\n    with open(filename) as f:\n       for line in f.readlines():\n           if line.startswith(\'#\'): continue\n           values = line.split()\n           if not values: continue\n           if values[0] == \'v\':\n               V.append([float(x) for x in values[1:4]])\n           elif values[0] == \'vt\':\n               T.append([float(x) for x in values[1:3]])\n           elif values[0] == \'f\' :\n               Vi.append([int(indices.split(\'/\')[0]) for indices in values[1:]])\n               Ti.append([int(indices.split(\'/\')[1]) for indices in values[1:]])\n    return np.array(V), np.array(T), np.array(Vi)-1, np.array(Ti)-1\n\ndef lookat(eye, center, up):\n    normalize = lambda x: x/np.linalg.norm(x)\n    M = np.eye(4)\n    z = normalize(eye-center)\n    x = normalize(np.cross(up,z))\n    y = normalize(np.cross(z,x))\n    M[0,:3], M[1,:3], M[2,:3], M[:3,3] = x, y, z, -center\n    return M\n\ndef viewport(x, y, w, h, d):\n    return np.array([[w/2, 0, 0, x+w/2],\n                     [0, h/2, 0, y+h/2],\n                     [0, 0, d/2,   d/2],\n                     [0, 0, 0,       1]])\n    \nif __name__ == \'__main__\':\n    import time\n    import PIL.Image\n\n    width, height = 1200,1200\n    light         = np.array([0,0,-1])\n    eye           = np.array([1,1,3])\n    center        = np.array([0,0,0])\n    up            = np.array([0,1,0])\n\n    image = np.zeros((height,width,4), dtype=np.uint8)\n    zbuffer = -1000*np.ones((height,width))\n    coords = np.mgrid[0:width, 0:height]\n\n    V, UV, Vi, UVi = obj_load(""head.obj"")\n    texture = np.asarray(PIL.Image.open(""uv-grid.png""))\n    viewport = viewport(32, 32, width-64, height-64, 1000)\n    modelview = lookat(eye, center, up)\n\n    start = time.time()\n    Vh = np.c_[V, np.ones(len(V))] # Homogenous coordinates\n    V = Vh @ modelview.T           # World coordinates\n    Vs = V @ viewport.T            # Screen coordinates\n    V, Vs = V[:,:3],  Vs[:,:3]     # Back to cartesian coordinates\n    V, Vs, UV = V[Vi], Vs[Vi], UV[UVi]\n    \n    # Pre-compute tri-linear coordinates\n    T = np.transpose(Vs, axes=[0,2,1]).copy()\n    T[:,2,:] = 1\n    T = np.linalg.inv(T)\n\n    # Pre-compute normal vectors and intensity\n    N = np.cross(V[:,2]-V[:,0], V[:,1]-V[:,0])\n    N = N / np.linalg.norm(N,axis=1).reshape(len(N),1)\n    I = np.dot(N, light)\n\n    for i in np.argwhere(I>=0)[:,0]:\n        (vs0, vs1, vs2), (uv0, uv1, uv2) = Vs[i], UV[i]\n        triangle(T[i], (vs0,uv0), (vs1,uv1), (vs2,uv2), I[i])\n    end = time.time()\n    \n    print(""Rendering time: {}"".format(end-start))\n    PIL.Image.fromarray(image[::-1,:,:]).save(""head.png"")\n'"
