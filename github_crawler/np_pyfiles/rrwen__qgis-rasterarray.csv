file_path,api_count,code
RasterArray.py,0,"b'\'\'\'\n RasterArray.py\n Richard Wen @ Ryerson University (rwen@ryerson.ca)\n V0.05a\n \n Dependencies: QGIS 2.6.1 Brighton, Python 2.7\n Developed on: Windows 8 64-bit\n \n===============================================================\n \n Contains classes for raster image data interaction using\n numpy array structures.\n \n Modules: Submodules\n -------------------\n * osgeo: gdal, osr\n * qgis: core, qgsMapLayerRegistry, QgsRasterLayer\n * numpy\n * os\n * time\n * shutil\n \n Helpers\n -------\n * (H1.) Array2Raster\n * (H2.) xyOffset\n * (H3.) createDirectory\n \n Classes: Methods\n ----------------\n * (1.) Cells: get, modify, toRaster\n * (2.) GameofLife: cycle, reset\n   \n===============================================================\n\'\'\'\n\n# =============================================================\n# A. Modules\n# =============================================================\nfrom osgeo import gdal, osr\nimport qgis, numpy, os, time, shutil\nfrom qgis.core import QgsMapLayerRegistry, QgsRasterLayer\n\n# =============================================================\n# B. Helpers\n# =============================================================\n\n\'\'\'\n (H1.) Array2Raster: numpyArray str (tupleof float) str\n                     (tupleof float) float float int -> Effect\n \n---------------------------------------------------------------\n\n Converts a numpy array into a raster image at the specified\n directory in geotif format (.tif)\n \n Notes\n -----\n * Modified from Python GDAL/OGR Cookbook 1.0 @\n   http://pcjericks.github.io/py-gdalogr-cookbook/\n  raster_layers.html#create-raster-from-array\n\n Required Parameters\n -------------------\n * inArray: numpyArray\n         The numpy array to be converted into a geographic raster.\n * outRaster: str\n         The output raser path with geotif extenstion (.tif).\n * rasterOrigin: (tupleof float)\n         The geographic origin of the output raster.\n * pixelWidth: float\n         The width of a cell in the raster.\n * pixelHeight: float\n\tThe height of a cell in the raster.\n * EPSG: int\n         The spatial reference system number to define the\n         raster in.\n \n Effects\n -------\n * Produces a geotif raster at the [outRaster] directory\n   location\n\n---------------------------------------------------------------\n\'\'\'\ndef Array2Raster(inArray,\n                 outRaster,\n                 rasterOrigin,\n                 pixelWidth,\n                 pixelHeight,\n                 EPSG):\n    \n    # (H1.1) Obtain Array Information\n    cols = inArray.shape[1]\n    rows = inArray.shape[0]\n    originX = rasterOrigin[0]\n    originY = rasterOrigin[1]\n    \n    # (H1.2) Write Array to Raster       \n    driver = gdal.GetDriverByName(\'GTiff\')\n    outRaster = driver.Create(outRaster,\n                              cols,\n                              rows,\n                              1,\n                              gdal.GDT_Byte)\n    outRaster.SetGeoTransform((originX,\n                               pixelWidth,\n                               0,\n                               originY,\n                               0,\n                               pixelHeight))\n    outband = outRaster.GetRasterBand(1)\n    outband.WriteArray(inArray,0,0)\n    outRasterSRS = osr.SpatialReference()\n    outRasterSRS.ImportFromEPSG(EPSG)\n    outRaster.SetProjection(outRasterSRS.ExportToWkt())\n    outband.FlushCache()\n    outband.SetNoDataValue(-99)\n    \n    # (H1.3) Reset\n    driver = None\n    outRaster = None\n    outBand = None\n    inArray = None\n    \n\'\'\'\n (H2.) xyOffset: int int (float,float) float float\n\t\t -> (int int)\n------------------------------------------------------------\n\n Calculates the offset for the geographic x and y locations \n using the raster origin and cell dimensions.\n \n Required Parameters\n -------------------\n * x: int\n         The x-axis, row, geographic coordinate.\n * y: int\n         The y-axis, row, geographic coordinate.\n * rasterOrigin: (float, float)\n         The raster\'s origin coordinates.\n * cellWidth: float\n         The width of a cell in the raster.\n * cellHeight: float\n         The height of a cell in the raster.\n \n Output\n ------\n A tuple of integers representing the array position from\n the geographic coordinates [rasterOrigin].\n\n---------------------------------------------------------------\n\'\'\'\ndef xyOffset (x, y, rasterOrigin, cellWidth, cellHeight):\n    xOffset = int((x - rasterOrigin[0])/cellWidth) ## X\n    yOffset = int(((y+1) - rasterOrigin[1])/cellHeight) ## Y\n    return (xOffset, yOffset)\n\n\'\'\'\n (H3.) createDirectory: str -> Effect\n---------------------------------------------------------------\n \n Creates a directory.\n \n Required Parameters\n -------------------\n * directory: str\n         The path to create the folder at.\n \n Effects\n -------\n Creates a folder at the [directory], it the folder does\n not exist.\n\n---------------------------------------------------------------\n\'\'\'\ndef createDirectory(directory):    \n    if not os.path.exists(directory):\n\tos.makedirs(directory)\n    return directory\n\n# =============================================================\n# C. Classes\n# =============================================================\n\n\'\'\'\n (1.) Cells: (str/int/float/None) int int (float, float)\n              int int float float -> Object\n-------------------------------------------------------------\n\n A cells object obtained from a raster image file with a\n selected band. The cells represent an array that is mutable\n with method calls. The cells object can then be converted\n to a raster representing changes made to the original raster.\n \n Notes\n -----\n * An appropriate EPSG number must be set, the default is 4326\n * If no input directory is specified, a random raster will be\n   used\n\n Optional Parameters\n -------------------\n * inRaster: (str/int/float/None)\n         The input raster to be created or read.\n           - If int/float, fill raster with the number\n           - If str, read the raster from str path\n           - If None, create random raster and read it\n * nband: int\n         The band of the raster to read from.\n * EPSG: int\n         The spatial reference system number of the raster.\n * rasterOrigin: (float, float)\n         The geographic origin coordinates of the raster.\n * cols: int\n         The number of columns in the raster.\n * rows: int\n         The number of rows in the raster.\n * pixelWidth: float\n         The pixel width of the raster.\n * pixelHeight: float\n\tThe pixel height of the raster.\n   \n Object Attributes\n -----------------\n * self.array: numpyArray\n         A numpy array representing the [inRaster]\n * self.EPSG: int\n         [EPSG]\n * self.cols: int\n         [cols]\n * self.rows: int\n         [rows]\n * self.origin: (float, float)\n         [rasterOrigin]\n * self.cellWidth: float\n         [pixelWidth]\n * self.cellHeight: float\n         [pixelHeight]\n \n Object Methods\n --------------\n * (1.1) modify\n         Modify a cell\'s value.\n * (1.2) get\n         Get a cell\'s value.\n * (1.3) toRaster\n         Convert the array into a geotif raster, with changes if \n         applicable.\n\n-------------------------------------------------------------\n\'\'\'\nclass Cells (object):\n    \n    # (1.0) Initialization\n    # -------------------------------------------------------\n    def __init__(self,\n                 inRaster=None,\n                 nband=1,\n                 EPSG=4326,\n                 rasterOrigin=(0,0),\n                 cols=10,\n                 rows=10,\n                 pixelWidth=1,\n                 pixelHeight=1):\n        \n\t# (1.0.0) Default Random Cells\n\tif inRaster == None:\n\t    array = numpy.random.randint(2,size = (rows,cols))\n\t\n\t# (1.0.1) Cell Filled with Numbers\n\telif isinstance(inRaster,(int, long, float, complex)):\n\t    array = numpy.zeros((rows,cols))\n\t    array.fill(inRaster)\n\t\n\t# (1.0.2) Custom Cell with List\n\telif isinstance(inRaster,(list, tuple)):\n\t    array = numpy.array(inRaster)\n\t    shape = array.shape\n\t    rows = shape[0]\n\t    cols = shape[1]\n\t    \n\t# (1.0.3) Specified Raster\n\telse:\n\t    \n\t    # (1.0.3a) Obtain Raster Information\n\t    openRaster = gdal.Open(inRaster)\n\t    band = openRaster.GetRasterBand(nband) ## get single band\n\t    rows = openRaster.RasterYSize ## dimension rows\n\t    cols = openRaster.RasterXSize ## dimension columns\n\t    geotransform = openRaster.GetGeoTransform()\n\t    rasterOrigin = (geotransform[0], geotransform[3]) ## coor of origin\n\t    pixelWidth = geotransform[1] ## cell size x\n\t    pixelHeight =  geotransform[5] ## cell size y\n\t    \n\t    # (1.0.3b) Obtain Array Data     \n\t    array = band.ReadAsArray(0, 0, cols, rows).astype(numpy.float)\n        \n        # (1.0.4) Attributes\n        self.array = array\n        self.EPSG = EPSG\n        self.cols = cols\n        self.rows= rows\n        self.origin = rasterOrigin\n        self.cellWidth = pixelWidth\n        self.cellHeight = pixelHeight\n     \n    \'\'\'\n     (1.1) modify: int int float bool -> Effect\n    --------------------------------------------------------\n     \n     Modifies the cell at the location with a new value set by\n     the user.\n     \n     Required Parameters\n     -------------------\n     * x: float/int\n             The x-axis, row, reference.\n     * y: float/int\n             The y-axis, row, reference.\n     * value: float/int\n             The value to be set at the [x] and [y] location\n    \n     Optional Parameters\n     -------------------\n     * geographic: bool\n             Set to determine if [x] and [y] are geographic\n\t     coordinates instead of array references.\n\t       - If True, [x][y] are geographic references\n\t       - If False, [x][y] are array references\n\t \n     Effects\n     -------\n     Mutates the [self.array] field at [x] and [y]\n       \n    --------------------------------------------------------\n    \'\'\'\n    def modify (self, x, y, value, geographic=True):\n        \n        # (1.1.1) Calculate XY Geographic Offsets If Needed\n\tif geographic:\n\t    Offsets = xyOffset (x,\n\t\t               y,\n\t\t               self.origin,\n\t\t               self.cellWidth,\n\t\t               self.cellHeight)\n\telse:\n\t    Offsets = (x,y)\n        \n        # (1.1.2) Modify Array\n        self.array[Offsets[1],Offsets[0]] = value\n\t\n    \'\'\'\n     (1.2) get: int int bool -> float\n    --------------------------------------------------------\n     \n     Obtains the value of the cell at the user specified\n     location.\n     \n     Required Parameters\n     -------------------\n     * x: float/int\n             The x-axis, row,, column, reference.\n     * y: float/int\n             The y-axis, row,, row, reference.\n\t \n     Optional Parameters\n     -------------------\n     * geographic: bool\n             Set to determine if [x] and [y] are geographic\n\t     coordinates instead of array references.\n\t       - If True, [x][y] are geographic references\n\t       - If False, [x][y] are array references\n\t \n     Output\n     ------\n     Returns the value at the [x] and [y] location\n    \n    --------------------------------------------------------\n    \'\'\'\n    def get (self, x, y, geographic=True):\n        \n        # (1.2.1) Calculate XY Geographic Offsets If Needed\n\tif geographic:\n\t    Offsets = xyOffset (x,\n\t\t                y,\n\t\t                self.origin,\n\t\t                self.cellWidth,\n\t\t                self.cellHeight)\n\telse:\n\t    Offsets = (x,y)\n                \n        # (1.2.2) Return Cell Value        \n        return self.array[Offsets[1],Offsets[0]] \n    \n    \'\'\'\n     (1.3) toRaster: str -> Effect\n    --------------------------------------------------------\n    \n     Creates a raster from the array data supplied by the \n     class at the location speicifed by the user.\n     \n     Required Parameters\n     -------------------\n     * outRaster: str\n             The location path to produce the geotif raster\n\t     from the [self.array] attribute.\n\t \n     Effects\n     -------\n     Creates a geotif (.tif) format raster at the \n     [outRaster] location path with the array from the\n     [self.array] attribute.\n    \n    --------------------------------------------------------\n    \'\'\'\n    def toRaster(self, outRaster):\n        Array2Raster(self.array,\n                     outRaster,\n                     self.origin,\n                     self.cellWidth,\n                     self.cellHeight,\n                     self.EPSG)\n\t\n\'\'\'\n (2.) GameofLife: str int str int (float,float) int int\n                  float float bool str -> Object\n-------------------------------------------------------------\n\n Based on Conway\'s Game of Life, creates a game of life object\n from a randomly generated raster or a given raster file. The\n user may then choose to start the game, and iterate through\n a given number of cycles.\n\n Notes\n -----\n Utilizes the Cells class from the RasterArray Module\n \n Optional Parameters\n -------------------\n * outDirectory: None/str\n         The output directory to transfer the cycled \n\t rasters.\n * EPSG: int\n         The spatial reference number of the rasters to\n\t be cycled.\n * raster: None/str\n         The raster to be used as the starting board.\n\t   - If None, starting board is a random board\n\t   - If str, starting board is the path at str\n * band: int\n         The band number of the [raster]\n * origin: (float,float)\n         The origin coordiantes of the [raster]\n * width: int\n         The width of the [raster]\n * height: int\n         The height of the [raster]\n * cellWidth: float\n         The width of a cell in the [raster]\n * cellHeight: float\n         The height of a cell in the [raster]\n * overwrite: bool\n         Whether or not to overwrite cycled raster.\n\t   - If True, overwrite and don\'t save cycles\n\t   - If False, save cycles at [outDirectory]\n * qmlStyle: str\n         The style file to be used to visualize\n\t the [raster] and its cycles.\n\t \n Object Attributes\n -----------------\n * self.startRaster: str\n         Path to the input starting raster.\n * self.inRaster: str\n         Path to the raster to be cycled.\n * self.output: str\n         Path to the output cycled raster at [outDirectory]\n * self.cycles: int\n         The cycle count so far.\n * self.board: obj\n         The board, stored as a Cells object.\n * self.speed: float\n         The speed in which to delay the board by.\n * self.overwrite: bool\n         [overwrite]\n * self.style: str\n         [qmlStyle]\n * self.EPSG: int\n         [EPSG]\n * self.band: int\n         [band]\n\t \t \n Object Methods\n --------------\n * (2.1) cycle\n         Cycle the board a number of times.\n * (2.2) reset\n         Reset current board to the starting board.\n\n-------------------------------------------------------------\n\'\'\'\nclass GameofLife (object):\n    \n    # (2.0) Initial Settings\n    # -------------------------------------------------------\n    def __init__(self,\n                 out_directory=None,\n                 EPSG=4326,\n                 raster = None,\n                 band=1,\n                 origin=(0,0),\n                 width=25,\n                 height=25,\n                 cellWidth=1,\n                 cellHeight=1,\n                 overwrite=True,\n                 qmlStyle=os.path.join(\n                     os.path.dirname(os.path.realpath(__file__)),\n                     ""GameofLife_Style.qml"")):\n\t\n\t# (2.0.1) Create Default Path at Script Directory\n\tif out_directory == None:\n\t    outPath = os.path.join(os.path.dirname(os.path.realpath(__file__)),\n\t                           ""GameofLife_Output"")\n\t    createDirectory(outPath)\n\telse:\n\t    outPath = createDirectory(out_directory)\n        \n        # (2.0.1) Create Random Raster if no raster settings defined\n        if raster == None:\n\t    random_array = numpy.random.randint(2,size = (height,width))\n            rasterPath = os.path.join(outPath,""start.tif"")\n            Array2Raster(random_array,\n                         rasterPath,\n                         origin,\n                         cellWidth,\n                         cellHeight,\n                         EPSG)\n        \n        # (2.0.2) Otherwise use the Raster Defined by the User\n        else:\n            rasterPath = raster\n\t    \n\t# (2.0.3) Add Raster to Display\n\tstartLayer = QgsRasterLayer(rasterPath, ""start"")\n\tstartLayer.loadNamedStyle(qmlStyle)\n\tQgsMapLayerRegistry.instance().addMapLayer(startLayer)\n        \n        # (2.0.4) Main Attribute Settings\n\tself.startRaster = rasterPath\n        self.inRaster = rasterPath\n        self.output = outPath\n\tself.cycles=0\n        self.board = Cells(rasterPath, band, EPSG)\n        self.speed = 0.65 ## delay in seconds after creating each cycle\n\tself.overwrite = overwrite ## whether or not to overwrite each cycle\n\tself.style = qmlStyle ## raster legend style\n\t\n\t# (2.0.6) Sub Attribute Settings\n\tself.EPSG = EPSG\n\tself.band = band\n\t\n    \'\'\'\n     (2.1) cycle: int int -> Effect\n    --------------------------------------------------------\n    \n     Cycles through the game of life board a number of times\n     (n) set by the user.\n     \n     Notes\n     -----\n     Modified from code provided by Dr. Claus Rinner @\n     Ryerson University\n     \n     Optional Parameters\n     -------------------\n     * n: int\n             The number of times to cycle the booard.\n     * jump: int\n\t     The jumps made for each interval it \n\t     reaches [n]\n\t     \n     Effect\n     ------\n     Creates cycled raster(s) as a geotif (.tif) at the\n     [self.output] directory, updates [self.cycles],\n     [self.inRaster], and [self.board]\n    \n    --------------------------------------------------------\n    \'\'\'\n    def cycle(self, n=1,jump=1):\n        \n        # (2.1.1) Cycle Cells of Game Board n Times\n\tsumTime = 0\n\trows = self.board.rows\n\tcols = self.board.cols\n\titerations = (n*jump)+1\n\tfor cyclenum in range(1,iterations):\n\t     ## store copy of original cells\n\t    inBoard = Cells(self.inRaster,nband=self.band,EPSG=self.EPSG)\n\t    start_time = time.time() ## start cycle time\n\t    \n\t    # (2.1.1) Keep track of number of cycles\n\t    if cyclenum%jump == 0:\n\t\tself.cycles+=jump\n\t\tprint ""Cycle: "" + str(cyclenum)\n\t\t\n\t    # (2.1.1) Iterate All Cells on Board n Times\n\t    for i in range(0, rows): \n\t\tfor j in range(0, cols):\n\t\t    sumNeighbors = 0 ## counter for neighbors\n\t\t    boardValue = inBoard.get(j,i,geographic=False)\n\n\t\t    # (2.1.1) Count Neighbours\n\t\t    for k in range(i-1, i+2): \n\t\t\tfor l in range(j-1, j+2):\n\t\t\t    ## Only count neighbours and not the cell itself\n\t\t\t    if (l,k) != (j,i):\n\t\t\t\tsumNeighbors = sumNeighbors+inBoard.get(l%cols,\n\t\t\t\t                                        k%rows,\n\t\t\t\t                                        geographic=False)\n\t\t\t\n\t\t    # (2.1.2a) Alive Cells\n\t\t    if boardValue == 1:\n\t\t\t## Under-population\n\t\t\tif sumNeighbors < 2:\n\t\t\t    self.board.modify(j,i,0,geographic=False)\n\t\t\t## Over-crowding\n\t\t\telif sumNeighbors > 3:\n\t\t\t    self.board.modify(j,i,0,geographic=False)\n\t\t    \n\t\t    # (2.1.2b) Reproduction\n\t\t    elif boardValue == 0 and sumNeighbors == 3:\n\t\t\tself.board.modify(j,i,1,geographic=False)\n\t\n\t    # (2.1.3) Save Cycle as Raster\n\t    ## Overwrite Raster if needed\n\t    if self.overwrite:\n\t\toutLayer = ""cycle""\n\t    ## Otherwise Produce Rasters\n\t    else:\n\t\toutLayer = ""cycle""+str(self.cycles)\n\t    ## Set input raster to new cycle\n\t    outCyclePath = os.path.join(self.output,\n\t                                outLayer+"".tif"")\n\t    self.board.toRaster(outCyclePath)\n\t    self.board = Cells(outCyclePath,self.band,self.EPSG)\n\t    self.inRaster = outCyclePath\n\t\n\t    # (2.1.4) Display the Saved Raster Cycle\n\t    if (cyclenum%jump == 0) or cyclenum+1 == iterations:\n\t\tif self.overwrite: ## remove layer displays if overwriting\n\t\t    QgsMapLayerRegistry.instance().removeAllMapLayers()\n\t\trlayer = QgsRasterLayer(outCyclePath, outLayer)\n\t\trlayer.loadNamedStyle(self.style)\n\t\tQgsMapLayerRegistry.instance().addMapLayer(rlayer)\n\t\ttime.sleep(self.speed) ## suspend display\n\t    sumTime += (time.time() - start_time) ## end time cycles\n\tprint ""Average Cycle Time: "" + str(round(sumTime/n,2)) + "" sec""\n\t\n    \'\'\'\t\t\n    (2.2) reset -> Effect\n    --------------------------------------------------------\n    \n     Resets the game to the starting board.\n     \n     Effect\n     ------\n     Updates [self.inRaster] to the [self.startRaster] and\n     resets [self.cycles] and [self.board]\n    \n    --------------------------------------------------------\n    \'\'\'\n    def reset (self):\n\t\n\t# (2.2.1) Reset the Game Board and Cycles\n\tQgsMapLayerRegistry.instance().removeAllMapLayers() ## clear disp\n\tself.cycles=0\n\tself.inRaster=self.startRaster\n\tself.board=Cells(self.startRaster,self.band,self.EPSG)\n\tstartLayer = QgsRasterLayer(self.inRaster, ""start"")\n\tstartLayer.loadNamedStyle(self.style)\n\tQgsMapLayerRegistry.instance().addMapLayer(startLayer)\n\t\n\t# (2.2.2) Delete the Cycle Files\n\tfor the_file in os.listdir(self.output):\n\t    file_path = os.path.join(self.output, the_file)\n\t    if ""cycle"" in file_path:\n\t\t## Try to delete cycle files\n\t\ttry:\n\t\t    os.remove(file_path)\n\t\t## Notify if unable to delete cycle file\n\t\texcept Exception:\n\t\t    basename = os.path.basename(os.path.splitext(file_path)[0])\n\t\t    print (""**Unable to Delete Cycle Raster: ""+basename)\n'"
