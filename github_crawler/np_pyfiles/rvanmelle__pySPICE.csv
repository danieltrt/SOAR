file_path,api_count,code
DSpiceParser.py,0,"b'from dparser import Dparser\n\ndef d_number(t):\n\t\'exp : ""([+-]?[\\de\\-\\.]+)(\\w*)"" \'\n\t'"
Laplace.py,0,"b'#################################################################\n#   Function InvLap(t,omega,sigma,nint), numerically inverts a  #\n#   Laplace transform F(s) into f(t) using the Fast Fourier     #\n#   Transform (FFT) algorithm for a specific time ""t"", an       #\n#   upper frequency limit ""omega"", a real parameter ""sigma""     #\n#   and the number of integration intervals ""nint"" .            #\n#                                                               #\n#   Function F(s) is defined in separate as Fs(s) (see code     #\n#   below). Fs(s) has to be changed accordingly everytime the   #\n#   user wants to invert a different function.                  #\n#                                                               #\n#   I suggest to use omega>100 and nint=50*omega. The higher    #\n#   the values for omega, the more accurate the results will be #\n#   in general, but at the expense of longer processing times.  #\n#                                                               #\n#   Sigma is a real number which must be a little bigger than   #\n#   the real part of rightmost pole of the function F(s). For   #\n#   example, F(s) = 1/s + 1/(s-2) + 1/(s+1) has poles for s=0,  #\n#   s=2 and s=-1. Hence, sigma must be made equal to, say,      #\n#   2.05 so as to keep all poles at the left of this value.     #\n#   The analytical inverse for this simple function is          #\n#   f(t) = 1 + exp(-t) + exp(2t). For t=1.25, omega=200,        #\n#   nint=10000 and sigma=2.05, the numerical inversion yields   #\n#   f(1.25) ~= 13.456844516, or -0.09% away from the actual     #\n#   analytical result, 13.468998757 (results truncated to 9     #\n#   decimal places). This is the example used in this code.     #\n#                                                               #\n#   Creator: Fausto Arinos de Almeida Barbuto (Calgary, Canada) #\n#   Date: May 18, 2002                                          #\n#   E-mail: fausto_barbuto@yahoo.ca                             #\n#                                                               #\n#   Reference:                                                  #\n#   Huddleston, T. and Byrne, P: ""Numerical Inversion of        #\n#   Laplace Transforms"", University of South Alabama, April     #\n#   1999 (found at http://www.eng.usouthal.edu/huddleston/      #\n#   SoftwareSupport/Download/Inversion99.doc)                   #\n#                                                               #\n#   Usage: invoke InvLap(t,omega,sigma,nint), for t>0.          #\n#                                                               #\n#################################################################\n#   We need cmath because F(s) is a function operating on the\n#   complex argument s = a + bj\nfrom math import ceil\nfrom cmath import *\n\n#   *** The Laplace function F(s) is defined here.  ***\ndef Fs(s):\n    return (1.0/s + 1.0/(s+1.0) + 1.0/(s-2.0))\n\n#   *** Driver InvLap function  ***\ndef InvLap(t,omega,sigma,nint,func=Fs):\n#   Sanity check on some parameters.\n    omega = ceil(omega)\n    nint = ceil(nint)\n\n    if omega <= 0:\n       omega = 200\n\n    if nint <= 0:\n        nint = 10000\n\n    return (trapezoid(t,omega,sigma,nint,func))\n\n\n\n#   *** Function trapezoid computes the numerical inversion. ***\ndef trapezoid(t,omega,sigma,nint,func):\n    sum = 0.0\n    delta = float(omega)/nint\n    wi = 0.0\n\n#   The for-loop below computes the FFT Inversion Algorithm.\n#   It is in fact the trapezoidal rule for numerical integration.\n    for i in range(1,(nint+1)):\n        witi = complex(0,wi*t)\n\n        wf = wi + delta\n        wfti = complex(0,wf*t)\n\n        fi = (exp(witi)*func(complex(sigma,wi))).real\n        ff = (exp(wfti)*func(complex(sigma,wf))).real\n        sum = sum + 0.5*(wf-wi)*(fi+ff)\n        wi = wf\n \n    return ((sum*exp(sigma*t)/pi).real)\n\n\n\n#   Function InvLap(t,omega,sigma,nint) is invoked.\n#print InvLap(1.25,200,2.05,10000)\n#for i in range(100):\n#    x = InvLap(i*0.01, 200, 2.05, 10000)\n'"
Laplace2.py,0,"b'#################################################################\n#   Function Zakian(t), numerically inverts a Laplace transform #\n#   F(s) into f(t) for a specific time ""t"" using the Zakian     #\n#   algorithm.                                                  #\n#                                                               #\n#   Function F(s) is defined in separate as Fs(s) (see code     #\n#   below). In the present case, F(s) = 1/(s-1), whose          #\n#   analytical inversion is f(t) = exp(t), and t=1.0 thus       #\n#   yielding f(1) = 2.71828180837 what is ""e"" with an error     #\n#   of -7.4e-007%. Oscillatory systems may become innacurate    #\n#   after the second cycle, though.                             #\n#                                                               #\n#   Fs(s) has to be changed accordingly everytime the user      #\n#   wants to invert a different function.                       #\n#                                                               #\n#   Creator: Fausto Arinos de Almeida Barbuto (Calgary, Canada) #\n#   Date: May 16, 2002                                          #\n#   E-mail: fausto_barbuto@yahoo.ca                             #\n#                                                               #\n#   Reference:                                                  #\n#   Huddleston, T. and Byrne, P: ""Numerical Inversion of        #\n#   Laplace Transforms"", University of South Alabama, April     #\n#   1999 (found at http://www.eng.usouthal.edu/huddleston/      #\n#   SoftwareSupport/Download/Inversion99.doc)                   #\n#                                                               #\n#   Usage: just invoke Zakian(t), where t>0.                    #\n#                                                               #\n#################################################################\n\n#   We need cmath because F(s) is a function operating on the\n#   complex argument s = a + bj\nfrom cmath import *\n\n#   The Laplace function F(s) is defined here.\ndef Fs(s):\n    return 1.0/(s-1.0)\n\ndef Zakian(t,func=Fs):\n#   Tupple ""a"", of five complex members.\n    a = 12.83767675+1.666063445j, 12.22613209+5.012718792j,\\\n    10.93430308+8.409673116j, 8.776434715+11.92185389j,\\\n    5.225453361+15.72952905j\n\n#   Tupple ""K"", of five complex members.\n    K = -36902.08210+196990.4257j, 61277.02524-95408.62551j,\\\n    -28916.56288+18169.18531j, +4655.361138-1.901528642j,\\\n    -118.7414011-141.3036911j\n\n    sum = 0.0\n\n#   Zakian\'s method does not work for t=0. Check that out.\n    if t == 0:\n        print ""\\n""\n        print ""ERROR:   Inverse transform can not be calculated for t=0""\n        print ""WARNING: Routine zakian() exiting. \\n""\n        return (""Error"");\n\n#   The for-loop below is the heart of Zakian\'s Inversion Algorithm.\n    for j in range(0,5):\n        sum = sum + (K[j]*func(a[j]/t)).real\n \n    return (2.0*sum/t)\n\n#   Function Zakian(t) is invoked.\nfor i in range(10000):\n    Zakian(i*0.01 + 0.0001)\n\nprint Zakian(1.0)\n'"
MathHelpers.py,0,"b'import numpy\nimport numpy.linalg\nimport Gnuplot\nimport cmath, math, copy\n\ndef step_function(t):\n    # This function implements the step function\n    if t > 0.0:\n\treturn 1.0\n    return 0.0\n\ndef pole_residue_solver(t, c, poles, residues):\n    # This function solves a time domain function\n    # of the form that corresponds to a pole/residue\n    # inverse Laplace transform.\n    #\n    # t : time\n    # c : c[0]*delta(t) + c[1]*u(t) + c[2]*t + c[3]*t^2 + ...\n    # poles: p1, p2, p3, ...\n    # residues: r1, r2, r3, ...\n    assert len(poles) == len(residues)\n    sum = 0.0\n\n    for i in range(len(c)):\n\tif i == 0 and t == 0.0:\n\t    sum += c[0]\n\telif i == 1:\n\t    sum += c[1]\n\telif i == 2:\n\t    sum += c[i]*t\n\telif i > 2:\n\t    assert 0, ""%s %s %s"" % (c, poles, residues)\n\n    for i in range(len(poles)):\n\tsum += residues[i] * cmath.exp(poles[i]*t)\n\n    return sum\n\ndef integrate(c, p, r, impulse=None, scaling=1):\n    # equivalent to multiplying by 1/s\n    # f(t) = c[0] + c[1]*t + c[2]*t^2 + r[0]*exp(p[0]*t) + \n    #        r[1]*exp(p[1]*t)\n    assert len(p) == len(r)\n    new_c = []\n    new_r = []\n    sum = 0.0\n    # special case of impulse\n    if impulse is not None:\n\tsum += impulse\n\n    # loop through the time coefficients\n    for i in range(len(c)):\n\tnew_c.append(c[i] / (i+1))\n\n    # loop through the poles and residues\n    for i in range(len(p)):\n\tnew_r.append(r[i] / p[i])\n\tsum -= scaling*new_r[-1]\n    \n    # add the new scalar to the beginning of the list\n    new_c.insert(0, sum)\n\n    return new_c, copy.copy(p), new_r\n\ndef zroots(coef, polish=1, sort=1):\n    # finds and returns all of the roots for the \n    # given polynominal\n    EPS = 2e-6\n    MAXM = 100\n    m = len(coef) - 1\n    roots = range(m)\n\n    ad = copy.copy(coef)\n    for j in range(m, 0, -1):\n\tx = 0+0.0j\n\tx = laguer(ad, j, x)\n\tif abs(x.imag) <= 2.0*EPS*abs(x.real):\n\t    x = x - x.imag\n\troots[j-1] = x\n\tb = ad[j]\n\tfor jj in range(j-1, -1, -1):\n\t    c = ad[jj]\n\t    ad[jj] = b\n\t    b = x*b + c\n\n    if polish:\n\tfor j in range(1, m+1):\n\t    roots[j-1] = laguer(coef, m, roots[j-1])\n\t\n    if sort:\n\tfor j in range(2, m+1):\n\t    x = roots[j-1]\n\t    for i in range(j-1, 0, -1):\n\t\tif roots[i-1].real <= x.real:\n\t\t    break\n\t\troots[i] = roots[i-1]\n\t    roots[i] = x\n\n    return roots\n\t\ndef laguer(coef, m, x):\n    # Returns a single coefficient\n    MAXIT = 80\n    MT = 10\n    EPSS = 1.0e-7\n    frac = [0.0, 0.5, 0.25, 0.75, 0.13, 0.38, 0.62, 0.88, 1.0]\n\n    for iter in range(1, MAXIT+1):\n\tb = coef[m]\n\terr = abs(b)\n\td = 0+0j\n\tf = 0+0j\n\tabx = abs(x)\n\tfor j in range(m-1, -1, -1):\n\t    f = d + x*f\n\t    d = b + x*d\n\t    b = coef[j] + x*b\n\t    err = abs(b) + abx*err\n\terr *= EPSS\n\tif abs(b) <= err:\n\t    return x\n\n\tg = d / b\n\tg2 = g * g\n\th = g2 - 2.0*(f/b)\n\tsq = cmath.sqrt(float(m-1)*(m*h - g2))\n\tgp = g + sq\n\tgm = g - sq\n\tabp = abs(gp)\n\tabm = abs(gm)\n\tif (abp < abm):\n\t    gp = gm\n\tif max(abp, abm) > 0.0:\n\t    dx = (m+0.0j) / gp\n\telse:\n\t    dx = cmath.exp(cmath.log(1+abx)) * complex(math.cos(float(iter)),\n\t\t\t\t\t\t      math.sin(float(iter)))\n\tx1 = x - dx\n\tif x.real == x1.real and x.imag == x1.imag:\n\t    return x\n\t\n\tif iter % MT:\n\t    x = x1\n\telse:\n\t    x = x - frac[iter/MT] * dx\n\t    \n    print ""too many iterations in laguerre""\n    return x\n\ndef my_pade(coef, complex=True):\n    L = (len(coef) / 2) - 1\n    M = L + 1\n    assert len(coef) == L + M + 1\n\n    rows = []\n    rhs = []\n    for i in range(M):\n\trows.append([])\n\tif i >= M:\n\t    rhs.append(0.0)\n\telse:\n\t    rhs.append( -coef[M+i] )\n\tfor j in range(M):\n\t    if i+j >= len(coef):\n\t\trows[-1].append(0.0)\n\t    else:\n\t\trows[-1].append( coef[i+j] )\n\n    matrix = numpy.array(rows)\n    rhs_matrix = numpy.array(rhs)\n    b_coef = list(numpy.linalg.solve_linear_equations( matrix, rhs_matrix ))\n    b_coef.reverse()\n\n    if complex == True:\n\tb_coef.insert(0, 1.0+0j)\n    else:\n\tb_coef.insert(0, 1.0)\n\n    a_coef = []\n    for i in range(1, M+1):\n\tnew_coef = 0.0\n\tfor j in range(i):\n\t    new_coef += b_coef[j]*coef[i-j-1]\n\ta_coef.append(new_coef)\n\n    return (numpy.array(a_coef), numpy.array(b_coef))\n\ndef my_pade2(coef):\n    L = len(coef) / 2\n    M = L + 1\n    assert len(coef) == L + M\n\n    rows = []\n    rhs = []\n    for i in range(L, M+1):\n\trows.append([])\n\trhs.append( -coef[i+1] )\n\tfor j in range(0, L):\n\t    rows[-1].append( coef[i-j] )\n\n    matrix = numpy.array(rows)\n    rhs_matrix = numpy.array(rhs)\n    b_coef = list(numpy.linalg.solve_linear_equations( matrix, rhs_matrix ))\n    b_coef.insert(0, 1.0+0j)\n\n    a_coef = []\n    for i in range(1, M+1):\n\tnew_coef = 0.0\n\tfor j in range(i):\n\t    new_coef += b_coef[j]*coef[i-j-1]\n\ta_coef.append(new_coef)\n\n    return (numpy.array(a_coef), numpy.array(b_coef))\n\ndef pade(coef, complex=True):\n    n = len(coef) / 2\n    assert len(coef) == 2*n+1\n    \n    y = []\n    rows = []\n    for j in range(1, n+1):\n\ty.append(-coef[n+j])\n\trows.append([])\n\tfor k in range(1, n+1):\n\t    rows[-1].append(coef[j-k+n])\n\n    rhs = numpy.array(y)\n    matrix = numpy.array(rows)\n\n    solution = numpy.linalg.solve_linear_equations(matrix, rhs)\n\n    b_coef = solution\n    a_coef = [coef[0]]\n    for k in range(1,n+1):\n\tsum = coef[k]\n\tfor j in range(1,k+1):\n\t    sum += solution[j-1]*coef[k-j]\n\ta_coef.append(sum)\n\n    b_coef = solution\n    b_coef = list(b_coef)\n    if complex:\n\tb_coef.insert(0, 1.0+0j)\n    else:\n\tb_coef.insert(0, 1.0)\n\n    return (numpy.array(a_coef), numpy.array(b_coef))\n\ndef solve_poly(c_num, c_den, x):\n    num = 0.0\n    den = 0.0\n\n    for i in range(len(c_num)):\n\tnum += c_num[i] * pow(x, i)\n\n    for i in range(len(c_den)):\n\tden += c_den[i] * pow(x, i)\n\n    if den != 0.0:\n\treturn num / den\n    return num\n\nfrom math import *\ndef func(x):\n    return pow( 7 + pow(1+x, 4.0/3.0), 1.0/3.0 )\n\nif __name__==""1__main__"":\n    print laguer([3,4,1], 2, 100+0.0j)\n    print zroots([3,4,1])\n    print zroots([-27, -72, -6, 1])\n\nif __name__==""__main__"":\n    c = []\n    p = [-1.0, -2.0]\n    r = [2.0,1.0]\n    print ""c="", c\n    print ""p="", p\n    print ""r="", r\n\n    c, p, r = integrate(c,p,r, impulse=3)\n    print ""\\nc="", c\n    print ""p="", p\n    print ""r="", r\n\n    c,p,r = integrate(c,p,r)\n    print ""\\nc="", c\n    print ""p="", p\n    print ""r="", r\n\nif __name__==""h__main__"":\n\n    def my_func(x):\n\treturn math.exp(-x)\n\n    poly = [1.0, -1.0, 0.5, -1.0/6, 1.0/24, -1.0/120]\n    a_coef, b_coef = my_pade(poly, complex=False)\n\n    p = Gnuplot.Gnuplot()\n    p(""set terminal X11"")\n    p(""set logscale y"")\n    p(""set grid"")\n\n    res1, res2, res3 = [], [], []\n    n = 1000\n    for i in range(n):\n\tx = i*(10.0/n)\n\tres1.append((x, solve_poly(poly, [], x)))\n\tres2.append((x, solve_poly(a_coef, b_coef, x)))\n\tres3.append((x, my_func(x)))\n\t    \n    d = Gnuplot.Data(res1, title=\'Taylor\',\n\t\t     with=\'lines\')\n    p.plot(d)\n    d = Gnuplot.Data(res2, title=\'pade\', with=\'lines\')\n    p.replot(d)\n    d = Gnuplot.Data(res3, title=\'func\', with=\'lines\')\n    p.replot(d)\n    #d = Gnuplot.Data(res4, title=\'my_pade\', with=\'lines\')\n    #p.replot(d)\n\n    import time\n    time.sleep(1000)\n\nif __name__==""t__main__"":\n    \n    poly = [2.0, 1.0/9, 1.0/81, -49.0/8747, 175.0/78732, 0.000356]\n    #a_coef, b_coef = pade(poly, complex=False)\n    #print ""a_coef="", a_coef\n    #print ""b_coef="", b_coef\n\n    a_coef2, b_coef2 = my_pade(poly, complex=False)\n    print ""my_a_coef="", a_coef2\n    print ""my_b_coef="", b_coef2\n    \n    p = Gnuplot.Gnuplot()\n    p(""set terminal X11"")\n    p(""set grid"")\n\n    res1, res2, res3, res4 = [], [], [], []\n    n = 1000\n    for i in range(n):\n\tx = i*(10.0/n)\n\tres1.append((x, solve_poly(poly, [], x)))\n\t#res2.append((x, solve_poly(a_coef, b_coef, x)))\n\tres3.append((x, func(x)))\n\tres4.append((x, solve_poly(a_coef2, b_coef2, x)))\n\t    \n    d = Gnuplot.Data(res1, title=\'Taylor\',\n\t\t     with=\'lines\')\n    #p.plot(d)\n    #d = Gnuplot.Data(res2, title=\'pade\', with=\'lines\')\n    #p.replot(d)\n    d = Gnuplot.Data(res3, title=\'func\', with=\'lines\')\n    p.replot(d)\n    d = Gnuplot.Data(res4, title=\'my_pade\', with=\'lines\')\n    p.replot(d)\n\n    import time\n    time.sleep(1000)\n'"
SpiceCircuit.py,0,"b'import numpy\nimport numpy.linalg\nimport math, cmath\nimport Gnuplot\nimport MathHelpers\nimport copy\n\nclass SpiceException(Exception):\n    pass\n\nclass CircuitException(SpiceException):\n    pass\n\nclass SpiceCircuit:\n    """"""This is a simple circuit representation.  It performs basic SPICE\n    style analyses such as AC, DC, Transient.  It is hooked to Gnuplot\n    which it uses for a native plotter.  Matrix solutions are obtained\n    using the numpy package.\n    """"""\n\n    #############\n    #  CONSTANTS\n    #############\n\n    # analysis types\n    AC=""ac""\n    DC=""dc""\n    Transient=""tran""\n\n    # signal types\n    Voltage = ""Voltage""\n    Current = ""Current""\n    Condition = ""Cond""\n\n    # transient solution methods\n    Trapezoidal = ""trap""\n    BackwardEuler = ""euler""\n\n    # AC solution methods\n    MNA = ""mna""\n    AWE = ""awe""\n\n    # HELPER CLASSES\n    class XYFunc:\n        def __init__(self, func):\n            self.__func = func\n        def __call__(self, num):\n            return (num[0], self.__func(num[1]))\n\n    def __init__(self):\n        self.__Size = 0\n        self.__NodeMap = {}\n        self.__G = {} # The actual G matrix data\n        self.__G_array = None # cache\n        self.__C = {} # The actual C matrix data\n        self.__C_array = None # cache\n        self.__X = [] # The actual X array data\n        self.__X_array = None # cache\n        self.__B = {} # The actual B array data\n        self.__B_array = None # cache\n        self.__Branches = {} # The names of branch currents\n        self.__Conditions = [] # Conditions numbers\n\n        # Global data during simulations\n        self.__Time = None # current time during transient\n        self.__CurAnalysis = None #current type of analysis\n        \n        # Settings\n        self.__RecordCondition = True\n\n\tself.NUM_AWE = 0\n\tself.Scaling = 1\n\n        # For plotting\n        self.__Plotter = Gnuplot.Gnuplot() \n\n        # Holds all of the results from simulations\n        self.__Results = {}\n\n    def __getattr__(self, name):\n        # This provides more convenient access to \n        # various data structures... slists etc\n        # are converted into matrices and arrays in\n        # this process as well.\n        if name == ""Size"":\n            return self.__Size\n\n        elif name == ""Time"":\n            return self.__Time\n\n        elif name == ""G"":\n            # Covert sparse matrix representation into matrix\n            if self.__G_array is None:\n                rows = []\n                for i in range(1,self.__Size+1):\n                    rows.append([]) \n                    for j in range(1,self.__Size+1):\n                        if self.__G.has_key((i,j)):\n                            rows[-1].append(self.__G[(i,j)])\n                        else:\n                            rows[-1].append(0.0)\n                self.__G_array = numpy.array(rows)\n            return self.__G_array\n\n        elif name == ""C"":\n            # Covert sparse matrix representation into matrix\n            if self.__C_array is None:\n                rows = []\n                for i in range(1,self.__Size+1):\n                    rows.append([]) \n                    for j in range(1,self.__Size+1):\n                        if self.__C.has_key((i,j)):\n                            rows[-1].append(self.__C[(i,j)])\n                        else:\n                            rows[-1].append(0.0)\n                self.__C_Array = numpy.array(rows)\n            return numpy.array(rows)\n\n        elif name == ""X"":\n            if self.__X_array is None:\n                x_array = numpy.array(self.__X)\n                self.__X_array = numpy.transpose(x_array)\n            return self.__X_array\n\n        elif name == ""Cond"":\n            # FIXME: could cache this here\n            return numpy.array(self.__Conditions)\n\n        elif name == ""B"":\n            # The B array contains the voltage and current\n            # source data.  These may be time dependent sources\n            # so the B array needs to be re-evaluated at every\n            # point in time.\n            # FIXME: Make this far more efficient by only\n            # re-evaluating if necessary and certainly only\n            # those values which are actually functions\n            if self.__B_array is None or self.Time is not None:\n                b = []\n                for i in range(1, self.__Size+1):\n                    if self.__B.has_key(i):\n                        # Eval the B function at time self.Time\n                        b.append(self.__B[i](self.Time, self.__CurAnalysis))\n                    else:\n                        b.append(0.0)\n                self.__B_array = numpy.transpose(numpy.array([b]))\n            return self.__B_array\n\n        else: raise AttributeError, name\n\n    def __setattr__(self, name, value):\n        if name == ""Time"":\n            self.__Time = value\n            self.__B_array = None\n        else:\n            self.__dict__[name] = value\n\n    def __Solve(self, freq=0.0):\n        # Solve circuit at a particular frequency.\n        # This solver uses the built-in lineary equation solver\n        # from the numpy package.\n        if freq == 0.0:\n            total_mna = self.G\n        else:\n            total_mna = self.G + 2*math.pi*freq*1j*self.C\n\n        solution = numpy.linalg.solve_linear_equations(total_mna, self.B)\n        if self.__RecordCondition:\n            v, s, wt = numpy.linalg.singular_value_decomposition(total_mna)\n            cond = max(s) / min(s)\n            self.__Conditions.append((freq,cond))\n        return solution\n\n    def reset_plotter(self):\n        self.__Plotter = Gnuplot.Gnuplot()\n\n    ##############################\n    #### ANALYSIS SECTION #######\n    def SetAnalysis(self, newAnalysis):\n        self.__CurAnalysis = newAnalysis\n        self.__B_array = None\n\n    def dc(self, name=""dc""):\n        # Run a DC analysis by solving at freq=0.0\n        self.__CurAnalysis = self.DC\n        self.__Results[name] = self.__Solve(0.0)\n        self.__CurAnalysis = None\n\n    def __pade_approximation(self, nodeName, L, M, debug=0):\n        assert L == M - 1\n        num_moments = L+M+1\n        if debug: ""DATA L=%s M=%s num_moments=%s"" % (L, M, num_moments)\n\n        if debug: print ""num_moments"", num_moments\n        #scaling = 766423.0\n        node_index = self.TranslateNode(nodeName)\n        node_moments = []\n        # step 1: calculate the Moments\n        g_inverse = numpy.linalg.inverse(self.G)\n        if debug: print ""g_inverse"", g_inverse\n        last_moment = numpy.matrixmultiply(g_inverse, self.B)\n        if debug: print ""last_moment"", last_moment, node_index\n        node_moments.append(last_moment[node_index-1][0])\n\n\t\t# test commit\n        for i in range(num_moments-1):\n            intermediate = -1 * numpy.matrixmultiply(g_inverse, self.C)\n            last_moment = numpy.matrixmultiply( intermediate, last_moment )\n            moment = self.Scaling * last_moment[node_index-1][0]\n            node_moments.append(moment)\n            last_moment = self.Scaling * last_moment\n            if debug: print ""last_moment"", last_moment\n\n        print ""suggested scaling ="", node_moments[0]/node_moments[1]\n        if debug: print ""node_moments="", node_moments\n\n        # Call the general pade algorithm\n        a_coef, b_coef = MathHelpers.my_pade(node_moments, complex=False)\n\n        # Return results\n        return a_coef, b_coef, node_moments\n\n    def __ac_awe(self, name, nodeName, L, M, start, stop, steps):\n\n        a_coef, b_coef, node_moments = self.__pade_approximation(nodeName, L, M)\n\n        def solve(a_coef, b_coef, freq):\n            numerator = 0+0j\n            denominator = 0+0j\n            freq = freq / (self.Scaling)\n\n            for i in range(len(a_coef)):\n                numerator += a_coef[i] * pow(2*math.pi*freq*1j,i)\n            \n            for i in range(len(b_coef)):\n                denominator += b_coef[i] * pow(2*math.pi*freq*1j, i)\n\n            return numerator / denominator\n\n        # evaluate the function at the specified frequencies\n        result_vec = []\n        interval = 1.0 / steps\n        num_points = int((math.log10(stop) - math.log10(start)) / interval)\n        for point in range(num_points):\n            freq = math.pow(10, math.log10(start) + point * interval)\n            result_vec.append( (freq, abs(solve(a_coef, b_coef, freq))) )\n\n        g = self.__Plotter\n        g(""set output \\""data.ps\\"""")\n        g(""set terminal postscript color"")\n        g(""set terminal postscript solid"")\n\n        d = Gnuplot.Data(result_vec,\n                         title=\'AWE(%s/%s)\' % (L,M),\n                         with=\'lines\')\n        g.replot(d)\n\n    def __ac_normal(self, name, start, stop, steps):\n        if stop == -1:\n            # this indicates that we are going to do a single frequency\n            # at start\n            self.__Results[name].append((start, self.__Solve(start)))\n        else:\n            interval = 1.0 / steps\n            num_points = int((math.log10(stop) - math.log10(start)) / interval)\n            for point in range(num_points):\n                freq = math.pow(10, math.log10(start) + point * interval)\n                self.__Results[name].append((freq, self.__Solve(freq)))\n\n    def ac(self, start, stop=-1, steps=10, name=""ac"", options={}):\n        # start : starting frequency\n        # stop : final frequency\n        # steps: steps per decade\n        self.__Results[name] = []\n        self.__CurAnalysis = self.AC\n        method = self.MNA\n        if options.has_key(\'method\'):\n            method = options[\'method\']\n        assert method in [self.MNA, self.AWE]\n\n        if method == self.MNA:\n            self.__ac_normal(name, start, stop, steps)\n\n        elif method == self.AWE:\n            assert options.has_key(\'node\')\n            assert options.has_key(\'order\')\n            node = str(int(options[\'node\']))\n            M = int(options[\'order\'])\n            L = int(M-1)\n            self.__ac_awe(name, node, L, M, start, stop, steps)\n\n        self.__CurAnalysis = None\n\n    def tran(self, stop, step, name=""tran"", method=1, options={}):\n        self.__Results[name] = []\n        self.__CurAnalysis = self.Transient\n        method = self.MNA\n        if options.has_key(\'method\'):\n            method = options[\'method\']\n        assert method in [self.MNA, self.AWE]\n\n        if method == self.MNA:\n            self.__tran_normal(stop, step, name, method)\n        elif method == self.AWE:\n            assert options.has_key(\'node\')\n            assert options.has_key(\'order\')\n            assert options.has_key(\'scaling\')\n            assert options.has_key(\'mode\')\n            assert options.has_key(\'size\')\n            assert options.has_key(\'tr\')\n            assert options.has_key(\'width\')\n            node = str(int(options[\'node\']))\n            M = int(options[\'order\'])\n            L = int(M-1)\n            self.Scaling = options[\'scaling\']\n            mode = options[\'mode\']\n            size = options[\'size\']\n            tr = options[\'tr\']\n            width = options[\'width\']\n            self.__tran_awe(name, node, L, M, stop, step, mode, size, \n                            tr, width)\n\n        self.__CurAnalysis = None\n        # back to non time-domain\n        self.Time = None\n\n    def __tran_awe(self, name, nodeName, L, M, stop, step, mode, size,\n                   tr, width):\n        # stop : stopping time\n        # step: size of the time step\n        # L: order of the numerator\n        # M: order of the denominator\n        # mode: one of ""IMPULSE"", ""IDEAL_STEP"", ""STEP"", ""PULSE"", ""RAMP""\n        # size: height of the step or pulse\n        # tr: rise and fall time of the STEP or PULSE\n        # width: width of the PULSE\n        \n        self.__CurAnalysis = self.AC\n        a_coef, b_coef, node_moments = self.__pade_approximation(\\\n            nodeName, L, M, debug=0)\n\n        # now, calculate the poles of the sequence\n        poles = MathHelpers.zroots(1j*b_coef, sort=0)\n        print ""L=%s M=%s POLES=%s"" % (L, M, poles)\n\n        # calculate the residues of the sequence\n        # using the formula given in the paper\n        p_rows = []\n        for i in range(M+1):\n            p_rows.append([])\n            for j in range(M):\n                p_rows[i].append(poles[j]**-(i+1))\n            if i == 0:\n                p_rows[i].append(-1+0j)\n            else:\n                p_rows[i].append(0+0j)\n\n        p_matrix = numpy.array(p_rows)\n        rhs = -1*numpy.array(node_moments[0:L+2])\n        residues = numpy.linalg.solve_linear_equations( p_matrix, rhs )\n\n        #NOTE: residues are in the form: [k1, k2, ... km, c]\n        #    : poles are in the form: [p1, p2, ... pm]\n        # i.e. H(s) = c + (k1 / (s+p1)) + (k2 / (s+p2))  + ...\n        # L-1{ H(s) } = c*sigma(t) + k1*exp(-p1*t) + k2*exp(-p2*t) = h(t)\n        # L-1{ H(s) / s } = INTEGRAL{ h(t) }\n            \n        # The residues actually contains both the actual residues\n        # and the direct coupling c\n        impulse = residues[-1]\n        residues = residues[0:-1]\n\n        # Now we calculate all of the responses that we may need\n        # first, record the impulse response\n        c0, poles0, residues0 = [], copy.copy(poles), copy.copy(residues)\n        c0.insert(0, impulse)\n\n        # integrate once to get step response and record\n        c, poles, residues = MathHelpers.integrate([], poles, residues, impulse)\n        c1, poles1, residues1 = copy.copy(c), copy.copy(poles), \\\n            copy.copy(residues)\n        c1.insert(0, 0.0)\n\n        # integrate again to get the ramp response and record\n        c2, poles2, residues2 = MathHelpers.integrate(c, poles, residues)\n        c2.insert(0, 0.0)\n\n        # Setup some shorthands and calculate required values\n        impulse_response = lambda t: MathHelpers.pole_residue_solver(\\\n            t*self.Scaling, c0, poles0, residues0)\n        step_response = lambda t: MathHelpers.pole_residue_solver(\\\n            t*self.Scaling, c1, poles1, residues1)\n        ramp_response = lambda t: MathHelpers.pole_residue_solver(\\\n            t*self.Scaling, c2, poles2, residues2)\n        u = MathHelpers.step_function\n        slope = (size / tr) / self.Scaling\n\n        # Calculate the answers by looping through the time\n        # steps\n        result = []\n        for i in range(int(stop/step)):\n            t = step*i\n            k = slope\n\n            if mode == ""ramp"":\n                answer = k * ramp_response(t)\n            elif mode == ""impulse"":\n                answer = impulse_response(t)\n            elif mode == ""step"":\n                answer = k * ramp_response(t) \\\n                    - k * ramp_response(t-tr) * u(t-tr)\n            elif mode == ""ideal_step"":\n                answer = size * step_response(t)\n            elif mode == ""pulse"":\n                answer = answer3 = k * ramp_response(t) \\\n                    - k * ramp_response(t-tr) * u(t-tr) \\\n                    - k * ramp_response(t-tr-width) * u(t-tr-width) \\\n                    + k * ramp_response(t-2*tr-width) * u(t-2*tr-width)\n            else:\n                assert 0, ""UNRECOGNIZED MODE %s"" % mode\n\n            # Add the (time, answer) pair... NOTE: we must\n            # extract the real value from the answer\n            result.append((t, answer.real))\n\n        # Add the results to the most recent plot\n        g = self.__Plotter\n        g(""set output \\""data.ps\\"""")\n        g(""set terminal postscript color"")\n        g(""set terminal postscript solid"")\n\n        d = Gnuplot.Data(result,\n                         title=\'AWE(%s/%s)\' % (L,M),\n                         with=\'lines\')\n        g.replot(d)            \n\n    def __tran_normal(self, stop, step, name, method):\n        # stop : time to stop the analysis\n        # step : time step interval\n        last_solution = numpy.zeros((self.Size,1))\n\n        if method == 1:\n            method = self.Trapezoidal\n        else:\n            method = self.BackwardEuler\n        \n        for i in range(0, int(stop/step)):\n            #print ""tran t=%s"" % self.Time\n            if method == self.BackwardEuler:\n                self.Time = i*step\n                mna_total = self.G + (self.C / step)\n                intermediate = numpy.dot( (self.C / step), last_solution )\n                rhs_total = intermediate + self.B\n                last_solution = numpy.linalg.solve_linear_equations(\\\n                    mna_total, rhs_total)\n            elif method == self.Trapezoidal:\n                self.Time = i*step\n                mna_total = self.G + (2*self.C / step)\n                intermediate = numpy.dot( ((2*self.C) / step - self.G), \n                                          last_solution )\n                rhs_total = intermediate + self.B\n                self.Time = (i+1)*step\n                rhs_total += self.B\n                last_solution = numpy.linalg.solve_linear_equations(\\\n                    mna_total, rhs_total)\n            self.__Results[name].append((self.Time, last_solution))\n\n    #######################################\n    ##### RESULTS RETRIEVAL SECTION #######\n    #######################################\n    def IDC(self, node):\n        # convenience routine for testing\n        return self.retrieve_raw( self.DC, self.Current, node )\n\n    def VDC(self, node):\n        # convenience routine for testing\n        return self.retrieve_raw( self.DC, self.Voltage, node )\n\n    def VF(self, node):\n        # convenience routine for testing\n        return self.retrieve_raw( self.AC, self.Voltage, node )\n\n    def IF(self, node):\n        # convenience routine for testing\n        return self.retrieve_raw( self.AC, self.Current, node )\n\n    def retrieve_raw(self, analysis, plot_type, node):\n        if analysis in [self.AC, self.Transient]:\n            results = self.__Results[analysis]\n            # AC/Tran Voltage: returns the (x,y) pair\n            if plot_type == self.Condition:\n                return self.Cond\n            else:\n                if plot_type == self.Voltage:\n                    index = self.TranslateNode(node)\n                elif plot_type == self.Current:\n                    index = self.TranslateBranch(node)\n                else:\n                    assert 0, plot_type\n\n                vec = []\n                for freq, solution in results:\n                    vec.append((freq, solution[index-1]))\n                if len(vec) == 1:\n                    #print ""1"", vec\n                    #print ""2"", vec[0]\n                    #print ""3"", vec[0][1]\n                    return vec[0][1][0]\n                else:\n                    return vec\n\n        elif analysis == self.DC:\n            # DC voltage/current: returns the y value\n            dc_result = self.__Results[self.DC]\n            if plot_type == self.Voltage:\n                index = self.TranslateNode(node)\n                return dc_result[index-1]\n            elif plot_type == self.Current:\n                index = self.TranslateBranch(node)\n                return dc_result[index-1]\n\n        else:\n            assert 0, ""Unsupported analysis %s"" % analysis\n\n    def vdb(self, num):\n        return 20*numpy.log10(abs(num))\n\n    def phase(self, num):\n        x = numpy.real(num)\n        y = numpy.imag(num)\n        r = numpy.sqrt(x**2+y**2)\n        phi = numpy.arccos(x/r)\n        if y < 0.:\n            phi = 2.*numpy.pi-phi\n        # FIXME: I added this extra -numpy.pi in order to \n        # match spice... in addition to the source inversion\n        return phi - numpy.pi       \n\n    def cartesianToPolar(self, num):\n        x = numpy.real(num)\n        y = numpy.imag(num)\n        r = numpy.sqrt(x**2+y**2)\n        phi = numpy.arccos(x/r)\n        if y < 0.:\n            phi = 2.*numpy.pi-phi\n        return r, phi - numpy.pi\n\n    def retrieve_signal(self, analType, funcName, signalSpec):\n        spice_func_dict = {\n            ""v"" : None, \n            ""i"" : None,\n            ""cond"" : None,\n            ""vm"" : self.XYFunc(abs),\n            ""vp"" : self.XYFunc(self.phase),\n            ""vdb"" : self.XYFunc(self.vdb),\n            ""vr"" : self.XYFunc(numpy.real),\n            ""vi"" : self.XYFunc(numpy.imag),\n            ""im"" : self.XYFunc(abs),\n            ""ip"" : self.XYFunc(self.phase),\n            ""idb"" : self.XYFunc(self.vdb),\n            ""ir"" : self.XYFunc(numpy.real),\n            ""ii"" : self.XYFunc(numpy.imag),\n            }\n        if funcName not in spice_func_dict:\n            msg = ""Unknown signal retrieval function: %s"" % funcName\n            raise CircuitException(msg)\n        if funcName == ""cond"":\n            plot_type = self.Condition\n        elif funcName[0] == ""i"":\n            plot_type = self.Current\n        elif funcName[0] == ""v"":\n            plot_type = self.Voltage\n\n        signals = signalSpec.split(\',\')\n        assert len(signals) == 1 or len(signals) == 2\n        if len(signals) == 1:\n            return map(spice_func_dict[funcName], \n                       self.retrieve_raw(analType, plot_type, signals[0]) )\n        else:\n            assert 0, ""Not supported""\n\n    def plot(self, analysis, funcName, signalSpec, logx, logy, file):\n        self.reset_plotter()\n        self.__plot(analysis, funcName, signalSpec,\n                    logx, logy, file)\n\n    def replot(self, analysis, funcName, signalSpec, logx, logy, file):\n        self.__plot(analysis, funcName, signalSpec,\n                    logx, logy, file)\n\n    def __plot(self, analysis, funcName, signalSpec, logx, logy, file):\n        #print ""plot"", analysis, funcName, signalSpec\n        #print ""__plot"", funcName, signalSpec\n        if analysis not in self.__Results:\n            raise CircuitException(\\\n                ""Analyis does not exist \'%s\': %s"" % (analysis, \n                                                     self.GetAnalyses()) )\n        if analysis in [self.AC, self.Transient]:\n            results = self.__Results[analysis]\n            if len(results) == 1:\n                # no need to plot anything\n                freq, result = results[0]\n                #print ""***"", result\n                # FIXME: cartesianToPolar for transient results\n                for node_name in self.GetNodes():\n                    index = self.TranslateNode(node_name)\n                    print ""V(%s) = %s"" % (node_name, \n                                          cartesianToPolar(result[index-1]))\n                for branch_name in self.GetBranches():\n                    index = self.TranslateBranch(branch_name)\n                    print ""I(%s) = %s"" % (branch_name,\n                                          cartesianToPolar(result[index-1]))\n                return\n            #g = Gnuplot.Gnuplot()\n            g = self.__Plotter\n            if logx:\n                g(""set logscale x"")\n            if logy:\n                g(""set logscale y"")\n            if file is not None:\n                g(""set output \\""%s\\"""" % file)\n                g(""set terminal postscript eps"")\n            else:\n                g(""set terminal X11"")\n\n            g(""set grid"")\n            if analysis == self.AC:\n                g.title(\'Frequency Response\')\n                g.xlabel(\'Frequency\')\n                g.ylabel(\'Magnitude\')\n            elif analysis == self.Transient:\n                g.title(\'Transient Response\')\n                g.xlabel(\'Time\')\n                g.ylabel(\'Voltage\')\n\n            vec = self.retrieve_signal( analysis, funcName, signalSpec )\n            #print ""***vec"", vec\n            d = Gnuplot.Data(vec,\n                             title=""%s(%s)"" % (funcName, signalSpec),\n                             with=\'lines\')\n            g.replot(d)\n\n        elif analysis == self.DC:\n            dc_result = self.__Results[self.DC]\n            if len(args) == 0:\n                # plot everything\n                #print ""NODES:"", x.GetNodes()\n                for node_name in self.GetNodes():\n                    index = self.TranslateNode(node_name)\n                    print ""V(%s) = %s"" % (node_name, dc_result[index-1])\n                for branch_name in self.GetBranches():\n                    index = self.TranslateBranch(branch_name)\n                    print ""I(%s) = %s"" % (branch_name, dc_result[index-1])\n            else:\n                for plot_type, node in args:\n                    if plot_type == self.Voltage:\n                        index = self.TranslateNode(node)\n                        print ""V(%s) = %s"" % (node, dc_result[index-1])\n                    elif plot_type == self.Current:\n                        index = self.TranslateBranch(node)\n                        print ""I(%s) = %s"" % (node, dc_result[index-1])\n                #print dc_result\n\n    def GetAnalyses(self):\n        """"""Returns the name of all of the available analysis results""""""\n        return self.__Results.keys()\n\n    def GetBranches(self):\n        """"""Returns the names of all the defined branches""""""\n        return self.__Branches.keys()\n\n    def GetNodes(self):\n        return self.__NodeMap.keys()\n\n    def Print(self, name=None):\n        # Print out everything to the screen.\n        if name is None:\n            print ""G="", self.G\n            print ""C="", self.C\n            print ""X="", self.X\n            print ""B="", self.B\n            print ""Branches="", self.Branches\n            print ""Nodemap="", self.__NodeMap\n        elif name == ""X"":\n            print self.X\n        elif name == ""Branches"":\n            print self.__Branches\n\n    ##############################\n    ### BUILDING THE CIRCUIT #####\n    ##############################            \n    def TranslateBranch(self, branchName):\n        if branchName not in self.__Branches:\n            assert 0, ""Unknown branch \'%s\': %s"" % (branchName, \n                                                   self.GetBranches())\n        return self.__Branches[branchName]\n\n    def TranslateNode(self, nodeName):\n        # Return the translation for nodeName\n        if nodeName == 0:\n            return 0\n        if nodeName not in self.__NodeMap:\n            raise CircuitException(\\\n                ""Unknown node \'%s\': %s"" % (nodeName, self.GetNodes()) )\n        return self.__NodeMap[nodeName]\n\n    def __MapNode(self, nodeName):\n        # Returns the internal node index for nodeName.\n        # If nodeName does not exist, it is created and\n        # added to the map.\n        if nodeName == 0 or nodeName == \'0\':\n            return nodeName\n        if nodeName not in self.__NodeMap:\n            self.__Size += 1\n            self.__NodeMap[nodeName] = self.__Size\n            self.__X.append((self.Voltage, self.__Size))\n        return self.__NodeMap[nodeName]\n\n    def __AddAdmittance(self, node1, node2, x, y):\n        # node1: TERMINAL 1 external node name\n        # node2: TERMINAL 2 external node name\n        # x : dictionary to add equations to\n        # y : magnitude of the Admittance\n        assert node1 != node2\n        n1 = self.__MapNode(node1)\n        n2 = self.__MapNode(node2)\n        if n1 != 0:\n            x.setdefault((n1,n1),0.0)\n            x[(n1,n1)] += y\n        if n2 != 0:\n            x.setdefault((n2,n2),0.0)\n            x[(n2,n2)] += y\n        if n1 != 0 and n2 != 0:\n            x.setdefault((n1,n2),0.0)\n            x[(n1,n2)] -= y\n            x.setdefault((n2,n1),0.0)\n            x[(n2,n1)] -= y\n\n    def AddResistor(self, name, node1, node2, r):\n        assert r > 0\n        self.__AddAdmittance(node1, node2, self.__G, 1.0/r)\n        \n    def AddCapacitor(self, name, node1, node2, c):\n        assert c > 0\n        self.__AddAdmittance(node1, node2, self.__C, c)\n\n    def AddInductor(self, name, node1, node2, l):\n        assert l > 0\n        self.__AddBranch(name, node1, node2)\n        self.__C[(self.__Size, self.__Size)] = -l\n\n    def AddCCVS(self, name, node1, node2, refDevice, A):\n        # A : transconductance\n        # refDevice: name of the device to measure current through\n        # FIXME: Should these be +=?\n        n1 = self.__MapNode(node1)\n        n2 = self.__MapNode(node2)\n        index = self.__Branches[refDevice]\n        self.__AddBranch( name, node1, node2 )\n        self.__G[(self.__Size, index)] = -1.0\n        if n1 != 0:\n            self.__G[(n1, self.__Size)] = 1.0\n            self.__G[(self.__Size, n1)] = 1.0/A\n        if n2 != 0:\n            self.__G[(n2, self.__Size)] = -1.0\n            self.__G[(self.__Size, n2)] = -1.0/A\n\n    def AddVCCS(self, name, refNode1, refNode2, node1, node2, A):\n        # A : gain\n        # refNode1, refNode2: external reference nodes\n        # (node1 - node2) <= A*(refNode1 - refNode2)\n        ref1 = self.__MapNode(refNode1)\n        ref2 = self.__MapNode(refNode2)\n        n1 = self.__MapNode(node1)\n        n2 = self.__MapNode(node2)\n        #self.__AddBranch( name, node1, node2 )\n        if ref1 != 0:\n            if n1 != 0:\n                self.__G.setdefault((n1, ref1), 0.0)\n                self.__G[(n1, ref1)] += A\n            if n2 != 0:\n                self.__G.setdefault((n2, ref1), 0.0)\n                self.__G[(n2, ref1)] += -A\n        if ref2 != 0:\n            if n1 != 0:\n                self.__G.setdefault((n1, ref2), 0.0)\n                self.__G[(n1, ref2)] += -A\n            if n2 != 0:\n                self.__G.setdefault((n2, ref2), 0.0)\n                self.__G[(n2, ref2)] += A\n\n    def AddVCVS(self, name, refNode1, refNode2, node1, node2, A):\n        # A : gain\n        # refNode1, refNode2: external reference nodes\n        # (node1 - node2) <= A*(refNode1 - refNode2)\n        ref1 = self.__MapNode(refNode1)\n        ref2 = self.__MapNode(refNode2)\n        self.__AddBranch( name, node1, node2, 1.0/A )\n        if ref1 != 0:\n            self.__G[(self.__Size, ref1)] = -1.0\n        if ref2 != 0:\n            self.__G[(self.__Size, ref2)] = 1.0\n        \n    def __AddBranch(self, name, node1, node2, mag=1.0):\n        # name: label for the branch\n        # node1: external node name\n        # node2: external node name\n        n1 = self.__MapNode(node1)\n        n2 = self.__MapNode(node2)\n        self.__Size += 1\n        # FIXME: this is written badly\n        if n1 == 0:\n            self.__G[(n2, self.__Size)] = mag\n            self.__G[(self.__Size, n2)] = mag\n        elif n2 == 0:\n            self.__G[(n1, self.__Size)] = mag\n            self.__G[(self.__Size, n1)] = mag\n        else:\n            self.__G[(n1, self.__Size)] = mag\n            self.__G[(self.__Size, n1)] = mag\n            self.__G[(n2, self.__Size)] = -mag\n            self.__G[(self.__Size, n2)] = -mag\n        self.__X.append((self.Current, self.__Size))\n        self.__Branches[name] = self.__Size\n\n    def __ConstructSourceFunction(self, vdc, vac, pulse_args):\n        # vdc: the value to be used during DC and Transient analyses\n        # vac: the value to be used during AC analyses\n        # pulse: specification tuple for a pulse which consists of the \n        #        following  v1 : voltage before/after pulse\n        #                   v2 : voltage during pulse\n        #                   td : delay before pulse starts\n        #                   tr : rise time\n        #                   tf : fall time\n        #                   pw : pulse width\n        #                   per : period\n        # according to nghelp: if a pulse() is specified, that is\n        #   the value to be used at time t=0\n        def pulse(time, v1, v2, td, tr, tf, pw, per):\n            t = time % per\n            t1, t2, t3, t4 = td, td+tr, td+tr+pw, td+tr+pw+tf\n            if t < t1 or t >= t4:\n                # outside the pulse\n                val = v1\n            if t >= t1 and t < t2:\n                # rising edge\n                slope = (v2-v1)/(t2-t1)\n                val = v1 + slope*(t - t1)\n            elif t >=t2 and t < t3:\n                # inside the pulse\n                val = v2\n            elif t >=t3 and t < t4:\n                # falling edge\n                slope = (v1-v2)/(t4-t3)\n                val = v2 + slope*(t-t3)\n            return val\n\n        def source(time, analysis, vac, vdc): \n            return {SpiceCircuit.AC : vac,\n                    SpiceCircuit.DC : vdc,\n                    SpiceCircuit.Transient : vdc}[analysis](time)\n\n        if pulse_args is not None:\n            time_func = lambda t: pulse(t, *pulse_args)\n        else:\n            time_func = lambda t: vdc\n\n        ac_func = lambda t: vac\n        source_func = lambda t, anal: source(t, anal, ac_func, time_func)\n        return source_func\n\n    def AddVoltageSource(self, name, node1, node2, vdc=0.0, \n                         vac=0.0, pulse_args=None):\n        self.__AddBranch(name, node1, node2)\n        source_func = self.__ConstructSourceFunction(vdc, vac, pulse_args)\n        self.__B[self.__Size] = source_func\n\n    def AddCurrentSource(self, name, node1, node2, iac=0.0, \n                         idc=0.0, pulse_args=None):\n        # FIXME: This does not handle not being connect to ground\n        n1 = self.__MapNode(node1)\n        n2 = self.__MapNode(node2)\n\tif n1 != 0:\n\t    source_func = self.__ConstructSourceFunction(idc, iac, pulse_args)\n\t    self.__B[n1] = source_func\n\tif n2 != 0:\n\t    v1, v2, td, tr, tf, pw, per = pulse_args\n\t    new_args = (-v1, -v2, td, tr, tf, pw, per)\n\t    source_func = self.__ConstructSourceFunction(-idc, -iac, new_args)\n\t    self.__B[n2] = source_func\n'"
SpiceParser.py,0,"b'#from sim import SpiceException\nfrom SpiceCircuit import SpiceCircuit, SpiceException\nimport re\n\nclass Callable:\n    """"""Simple class to add support for static class methods.""""""\n    def __init__(self, anycallable):\n        self.__call__ = anycallable\n\nclass NumberConverter:\n    """"""This class converts a number with SPICE suffix into\n    a real float.  It is case insensitive.\n    If the suffix is not found, it assumed to be UNITS and is ignored.""""""\n\n    num_re = re.compile(""([+-]?[\\de\\-\\.]+)(\\w*)"")\n    suffix_dict = {\'\': 1,\n\t\t   \'g\':1e9,\n                   \'meg\':1e6,\n                   \'k\':1e3,\n                   \'m\':1e-3,\n                   \'u\':1e-6,\n                   \'n\':1e-9,\n                   \'p\':1e-12} \n\n    def isnumber(num):\n\treturn NumberConverter.num_re.match(num) is not None\n    isnumber = Callable(isnumber)\n\n    def convert(num):\n        match_obj = NumberConverter.num_re.match(num)\n        assert match_obj is not None\n        number = match_obj.group(1)\n        suffix = match_obj.group(2)\n        if not NumberConverter.suffix_dict.has_key(suffix):\n            warning = ""Invalid suffix \'%s\'. IGNORED!"" % suffix\n            suffix = \'\'\n            print warning\n        return float(number) * NumberConverter.suffix_dict[suffix]        \n    convert = Callable(convert)\n\nclass SpiceParserException(SpiceException):\n    pass\n\nclass SpiceParser:\n    """"""This class takes a filename or buffer in a Spice-like format\n    and constructs a Circuit object.\n    """"""\n    func_re = re.compile(""(\\w+)\\(([^()]*)\\)"")\n\n    def __init__(self, filename=None):\n        self.__Filename = filename\n        self.__Circuit = None\n        if self.__Filename is not None:\n            f = open(filename, \'r\')\n            self.__Circuit = self.ParseLines(f.readlines())\n\n    def GetCircuit(self):\n        return self.__Circuit\n\n    def __convert(self, num):\n        # Uses the NumberConverter class to perform\n        # simple spice style numeric conversions\n        return NumberConverter.convert(num)\n\n    def __ProcessParams(self, params, default=None):\n        # Takes a list of numeric named parameters in the form:\n        #      x=3.3 y=4.4k...\n        # and returns a dictionary of the form:\n        #      {\'x\':3.3, \'y\':4400}\n        # NOTE: If there is only a single parameter and a default\n        # parameter name is passed in, then the default name\n        # will be used.\n        \n        if default is not None:\n            assert len(params) == 1\n        \n        param_dict = {}\n        for param in params:\n            pieces = param.split(\'=\')\n            if len(pieces) == 1:\n\t\tif NumberConverter.isnumber(pieces[0]):\n\t\t    param_dict[default] = self.__convert(pieces[0])\n\t\telse:\n\t\t    param_dict[default] = pieces[0]\n            else:\n\t\tif NumberConverter.isnumber(pieces[1]):\n\t\t    param_dict[pieces[0]] = self.__convert(pieces[1])\n\t\telse:\n\t\t    param_dict[pieces[0]] = pieces[1]\n\n        return param_dict\n\n    def __ProcessDotCard(self, pieces):\n        # Process any dotcards which are encountered\n        # pieces: list[string] ---> the line broken on whitespace\n        command = pieces[0]\n        if command == "".end"":\n            # nothing to do\n            # FIXME: should force an exit from parser and ignore any\n            #        further input\n            pass\n\n        elif command == "".dc"":\n            # form 1: .dc\n            assert len(pieces) == 1\n            self.__Circuit.dc()\n\n        elif command == "".tran"":\n            # form 1: .tran <step> <stop>\n\t    assert len(pieces) >= 3\n\t    params = {}\n            if len(pieces) > 3:\n\t\tparams = self.__ProcessParams(pieces[3:])\n            step = self.__convert(pieces[1])\n            stop = self.__convert(pieces[2])\n            self.__Circuit.tran(stop, step, options=params)\n\n        elif command == "".ac"":\n            # form 1: .ac DEC 10 1 100MEG\n            # form 2: .ac 1k\n\t    # form 3: .ac DEC 10 10k 10MEG method=AWE\n            if len(pieces) == 2:\n                self.__Circuit.ac(start=self.__convert(pieces[1]))\n            else:\n                assert len(pieces) >= 5\n                assert pieces[1] == ""dec""\n\t\tparams = {}\n\t\tif len(pieces) > 5:\n\t\t    params = self.__ProcessParams(pieces[5:])\n                steps_per_decade = self.__convert(pieces[2])\n                start = self.__convert(pieces[3])\n                stop = self.__convert(pieces[4])\n                self.__Circuit.ac(start=start, stop=stop, \n                                  steps=steps_per_decade, \n\t\t\t\t  options=params)\n\n        elif command in ["".plot"", "".replot"", "".print""]:\n            # .plot ac vm(3) vp(3)\n            # .plot tran v(3) v(4)\n            # .plot dc v(7)\n            assert len(pieces) >= 3\n            assert pieces[1] in [\'ac\', \'dc\', \'tran\']\n            anal_type = {\'ac\':self.__Circuit.AC, \n                         \'dc\':self.__Circuit.DC,\n                         \'tran\':self.__Circuit.Transient}[pieces[1]]\n            signal_list = []\n            logx = False\n            logy = False\n            file = None\n            for signal in pieces[2:]:\n                if signal[0] == "">"":\n                    file = signal[1:]\n                elif signal == ""logx"":\n                    logx = True\n                elif signal == ""logy"":\n                    logy = True\n                elif self.func_re.match(signal):\n                    func_name, signal_spec = self.func_re.match(signal).groups()\n\t\t    signal_list.append((func_name, signal_spec))\n                else:\n                    msg = ""Must pass a signal retrieval function: %s"" % signal\n                    raise SpiceParserException(msg)\n\n\t    replot = False\n\t    for func_name, signal_spec in signal_list:\n                if command == "".replot"" or replot == True:\n                    self.__Circuit.replot( anal_type, func_name, signal_spec,\n                                           logx, logy, file)\n                elif command == "".plot"":\n                    self.__Circuit.plot( anal_type, func_name, signal_spec,\n                                         logx, logy, file)\n\t\t    replot = True\n                elif command == "".print"":\n                    val = self.__Circuit.retrieve_signal( anal_type,\n                                                          func_name, \n                                                          signal_spec )\n                    print ""%s = %s"" % (signal, val)\n\n        else:\n            msg = ""Unrecognized dot card: \'%s\'. IGNORED!"" % command\n            raise SpiceParserException(msg)\n\n    def ParseLines(self, lines):\n        # lines: list[string] which are the lines of the file to be parsed\n        # returns the Circuit object\n        #\n        # NOTE: Spice traditianally ignored the first line,\n        #       but I hate this and simply *will not* do this.\n        self.__Circuit = SpiceCircuit()\n        for line in lines:\n            self.ParseLine(line)\n        return self.__Circuit\n\n    def ParseLine(self, line):\n        line = line.lower() # lowercase the line to be case insensitive\n        pieces = line.split() # splits line on whitespace\n        if len(pieces) == 0:\n            # empty line, let\'s skip ahead to the next\n            return\n            \n        first_char = pieces[0][0]\n        if first_char == \'*\':\n            #comment, do nothing\n            pass\n\n        elif first_char == \'.\':\n            # DOT CARD\n            # form: .COMMAND [...]\n            self.__ProcessDotCard(pieces)\n\n        elif first_char in [""v"", ""i""]:\n            # voltage source or current source\n            # form 1: [V|I]XXX N+ N- NUM\n            # form 2: [V|I]XXX N+ N- DC NUM\n            # form 3: VXXX N+ N- AC NUM\n            # form 4: VXXX N+ N- DC NUM AC NUM\n            # form 5: VXXX N+ N- PULSE(V1 V2 TD TR TF PW PER)\n            # form 6: VXXX N+ N- AC NUM PULSE(V1 V2 TD TR TF PW PER)\n            name, n1, n2 = pieces[0:3]\n            cv = self.__convert\n            params = {\'dc\':0.0, \'ac\':0.0, \'pulse\':None}\n            if re.search(""pulse\\(.*\\)"", line):\n                match_obj = re.search(""pulse\\((.*)\\)"", line)\n                v1, v2, td, tr, tf, pw, per = match_obj.group(1).split()\n                params[\'pulse\'] = ( cv(v1), cv(v2), cv(td), \n                                    cv(tr), cv(tf), cv(pw), cv(per) )\n                # now, remove the pulse() portion and continue processing\n                line = re.sub(""pulse\\(.*\\)"", """", line)\n                pieces = line.split()\n\n            if len(pieces) == 4: # form 1\n                params[\'dc\'] = cv(pieces[3])\n            elif len(pieces) == 5: # form 2 or 3\n                assert pieces[3] in params, \\\n                    \'%s not in %s\' % (pieces[3], params.keys())\n                params[pieces[3]] = cv(pieces[4])\n            elif len(pieces) == 7: # form 4\n                assert pieces[3] in params, \\\n                    \'%s not in %s\' % (pieces[3], params.keys())\n                assert pieces[5] in params\n                assert pieces[3] != pieces[5]\n                params[pieces[3]] = cv(pieces[4])\n                params[pieces[5]] = cv(pieces[6])\n\n            if first_char == \'v\':\n                self.__Circuit.AddVoltageSource(\\\n                    name, n1, n2, vac=params[\'ac\'], vdc=params[\'dc\'],\n                    pulse_args=params[\'pulse\'])\n            elif first_char == \'i\':\n                self.__Circuit.AddCurrentSource(\\\n                    name, n1, n2, iac=params[\'ac\'], idc=params[\'dc\'],\n\t\t    pulse_args=params[\'pulse\'])\n\n        elif first_char in [\'r\', \'l\', \'c\']:\n            # resistor, inductor, capacitor, voltage, current\n            # form: RXXX N+ N- [r=]NUM\n            func_map = {\'r\':self.__Circuit.AddResistor,\n                        \'l\':self.__Circuit.AddInductor,\n                        \'c\':self.__Circuit.AddCapacitor,\n                        }\n            assert len(pieces) == 4\n            name, n1, n2 = pieces[0:3]\n            params = self.__ProcessParams(pieces[3:], default=first_char)\n            assert params.has_key(first_char)\n            func_map[first_char](name, n1, n2, params[first_char])\n\n        elif first_char == \'h\':\n            # Current controlled voltage source\n            # form: HXXX N+ N- DEVNAME GAIN\n            assert len(pieces) == 5\n            name, out_pos, out_neg, in_dev = pieces[0:4]\n            params = self.__ProcessParams(pieces[4:], default=\'gain\')\n            assert params.has_key(\'gain\')\n            self.__Circuit.AddCCVS(name, out_pos, out_neg, in_dev,\n                                   params[\'gain\'])\n\n        elif first_char == \'g\':\n            # voltage controlled current source\n            # form: GXXX N+ N- NC+ NC- VALUE\n            assert len(pieces) == 6\n            name, out_pos, out_neg, in_pos, in_neg, = pieces[0:5]\n            params = self.__ProcessParams(pieces[5:], default=\'gain\')\n            assert params.has_key(\'gain\')\n            self.__Circuit.AddVCCS(name, in_pos, in_neg, out_pos,\n                                   out_neg, params[\'gain\'])\n\n        elif first_char == \'e\':\n            # Voltage controlled voltage source\n            # form: EXXX OUT+ OUT- IN+ IN- GAIN\n            assert len(pieces) == 6\n            name, out_pos, out_neg, in_pos, in_neg = pieces[0:5]\n            params = self.__ProcessParams(pieces[5:], default=\'gain\')\n            assert params.has_key(\'gain\')\n            self.__Circuit.AddVCVS(name, in_pos, in_neg, out_pos, \n                                   out_neg, params[\'gain\'])\n\n'"
affine.py,0,"b'\nclass affnum:\n\t\n\tERROR_TERMS = {}\n\t\n\tdef __init__(self, x, coef):\n\t\tself.X = x\n\t\tself.coef = coef\n\t\t\n\tdef expand(self):\n\t\tpairs = []\n\t\tfor x in self.coef:\n\t\t\tpairs.append((self.X))\n\t\t\tfor y in self.coef\n\t\t\n\tdef __str__(self):\n\t\tt = ""%s"" % self.X\n\t\tfor x in self.coef:\n\t\t\tt += "" + %s*%s"" % (self.coef[x], x)\n\t\treturn t\n\t\t\n\tdef __add__(self, other):\n\t\tnew_coef = {}\n\t\tnew_val = self.X + other.X\n\t\tfor x in set(self.coef).union(other.coef):\n\t\t\tsum = 0.0\n\t\t\tif self.coef.has_key(x):\n\t\t\t\tsum += self.coef[x]\n\t\t\tif other.coef.has_key(x):\n\t\t\t\tsum += other.coef[x]\n\t\t\tnew_coef[x] = sum \n\t\t\t\t\n\t\treturn affnum(new_val, new_coef)\n\t\t\t\n\t\t\n\tdef __sub__(self, other):\n\t\tpass\n\t\t\n\tdef __mul__(self, other):\n\t\tpass\n\t\t\n\tdef __div__(self, other):\n\t\tpass\n\t\t\nif __name__ == ""__main__"":\n\tx = affnum(10, {\'e3\':2.0, \'e8\':-6})\n\ty = affnum(20, {\'e4\':3.0, \'e8\':4})\n\tz = x + y\n\t\n\tprint set([1,2,3])\n\tprint x\n\tprint y\n\tprint z'"
cir.py,0,"b'import unittest\nfrom sim import SpiceParser\n\nclass TestSequenceFunctions(unittest.TestCase):\n\n    def assertDoublesEqual(self, d1, d2):\n\tif d1 == 0.0 or d2 == 0.0:\n\t    if abs(d1-d2) > 1e-6:\n\t\tself.assert_(False, ""%s != %s"" % (d1, d2))\n\telse:\n\t    if (abs(d1 - d2)) / (abs(d1)+abs(d2)) > 1e-6:\n\t\tself.assert_(False, ""%s != %s"" % (d1, d2))\n\n    def test_inductor(self):\n\tnetlist = """"""\nv1 1 0 AC 2\nl1 1 2 1m\nl2 2 0 5m\n.AC 1k\n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\tself.assertDoublesEqual( abs(cir.IF(""v1"")), 5.30516e-2)\n\tself.assertDoublesEqual( abs(cir.VF(""1"")), 2.0 )\n\tself.assertDoublesEqual( abs(cir.VF(""2"")), 2.0*(5.0/6.0) )\n\n    def test_capacitor(self):\n\t# Tests a basic capacitor divider network\n\tnetlist = """"""\nv1 1 0 AC 1\nc1 1 2 1u\nc2 2 0 5u\n.AC 1MEG \n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\t#cir.plot( cir.AC )\n\tself.assertDoublesEqual( abs(cir.IF(""v1"")), 5.23598 )\n\tself.assertDoublesEqual( abs(cir.VF(""1"")), 1.0 )\n\tself.assertDoublesEqual( abs(cir.VF(""2"")), 1.0/6.0)\n\t#print ""***"", abs(cir.VF(""1""))\n\t#print ""***"", abs(cir.VF(""2""))\n\t#print ""***"", abs(cir.IF(""v1""))\n\n    def test_ccvs(self):\n\t# Tests a current-controlled voltage source\n\tnetlist = """"""\n*v1 1 0 AC 1\ni1 1 0 1\nv2 1 2 AC 0\nr1 2 0 50\nr2 1 3 50\nh1 3 0 v2 10\nr3 4 0 50\n.DC \n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\t#cir.plot( cir.DC )\n\t#self.assertDoublesEqual( cir.VDC(""2""), 5*(2.0/3.0) )\n\n    def test_vcvs(self):\n\t# testing VCVS\n\tnetlist = """"""\nv1 1 0 AC 1\nr1 1 2 50\nr2 2 0 50\ne1 3 0 2 0 10\nr3 3 0 50\n.DC\n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\tself.assertDoublesEqual( cir.VDC(""3""), 5.0 )\n\n    def test_voltage_divider(self):\n\t# Confirms basic resistor operation\n\tnetlist = """"""\nr1 1 2 50\nr2 2 3 50\nr3 3 0 50\nv1 1 0 AC 5\n.DC\n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\tself.assertDoublesEqual( cir.VDC(""1""), 5.0 )\n\tself.assertDoublesEqual( cir.VDC(""2""), 5*(2.0/3.0) )\n\tself.assertDoublesEqual( cir.VDC(""3""), 5*(1.0/3.0) )\n\n    def test_opamp(self):\n\t# opamp test\n\tnetlist = """"""\nv1 1 0 AC 1\nr1 1 2 50\nr2 2 3 50\ne1 3 0 0 2 5MEG\n.DC    \n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\tself.assertDoublesEqual( cir.VDC(""2""), 0.0)\n\tself.assertDoublesEqual( cir.VDC(""3""), -1.0)\n\nif __name__ == \'__main__\':\n    unittest.main()\n\n\n'"
cir_test.py,0,"b'from sim import *\n\ndef figure2():\n    # Figure 2\n    isource(1,0,i=1)\n    resistor(1,0,r=50)\n    resistor(1,2,r=10)\n    capacitor(1,0,c=10e-9)\n    resistor(2,3,r=10)\n    capacitor(3,0,c=10e-9)\n    resistor(3,4,r=10)\n    capacitor(4,0,c=10e-9)\n    resistor(4,5,r=10)\n    capacitor(5,0,c=10e-9)\n    resistor(5,0,r=50)\n    resistor(3,6,r=10)\n    capacitor(6,0,c=10e-9)\n    resistor(6,7,r=10)\n    capacitor(7,0,c=10e-9)\n    resistor(7,0,r=50)\n\ndef figure3():\n    # Figure 3\n    vsource(1,0,v=1)\n    resistor(1,2,r=9606) # r1a\n    resistor(2,0,r=23280) #r1b\n    resistor(2,3,r=6800) # r2\n    capacitor(3,0,c=20.5e-9) # c2\n    capacitor(2,4,c=94.9e-9) # c1\n    opamp(3,4,4,A=50000) # opamp1\n    resistor(4,5,r=9304) # rg\n    opamp(0,5,6,A=50000) # opamp2\n    capacitor(5,6,c=15e-9) # c3\n    resistor(5,6,r=52107) # rq\n    resistor(5,10,r=9304) # r3\n    resistor(6,7,r=9304) # r4\n    opamp(0,7,8,A=50000) # opamp3\n    capacitor(7,8,c=15e-9) # c4\n    resistor(8,9,r=20e3) # r\n    resistor(9,10,r=20e3) # r\n    opamp(0,9,10,A=50000) # opamp4\n    ac(start=1, stop=100e6, steps=10)\n    #ac(100)\n    plot(AC, v(10), v(5), v(3), v(7))\n    #dc()\n    #plot(DC)\n\ndef figure1():\n    # Figure 1\n    resistor(1,2,r=50)\n    capacitor(2,0,c=0.319e-6)\n    inductor(2,0,l=0.3176e-6)\n    inductor(2,3,l=1.59e-6)\n    capacitor(3,4,c=63.72e-12)\n    inductor(4,0,l=0.3176e-6)\n    capacitor(4,0,c=0.319e-6)\n    resistor(4,0,r=50)\n    vsource(1,0,v=1)\n    ac(start=1, stop=100e6, steps=10)\n    plot(AC, v(4))\n\n#figure3()\n\nimport unittest\nclass TestSequenceFunctions(unittest.TestCase):\n    \n    def setUp(self):\n        reset()\n\n    def assertDoublesEqual(self, d1, d2):\n\tif d1 == 0.0 or d2 == 0.0:\n\t    if abs(d1-d2) > 1e-6:\n\t\tself.assert_(False)\n\telse:\n\t    if (abs(d1 - d2)) / (abs(d1)+abs(d2)) > 1e-6:\n\t\tself.assert_(False)\n\n    def test_vcvs(self):\n\t# testing VCVS\n\tvsource(1,0,v=1)\n\tresistor(1,2,r=50)\n\tresistor(2,0,r=50)\n\tvcvs(2,0,3,0,A=10)\n\tresistor(3,0,r=50)\n\tdc()\n\tself.assertDoublesEqual( VDC(3), 5.0 )\n\n    def test_spice_voltage_divider(self):\n\tnetlist = """"""\nr1 1 2 50\nr2 2 3 50\nr3 3 0 50\nv1 1 0 5\n.DC\n""""""\n\tparser = SpiceParser()\n\tcir = parser.ParseLines(netlist.splitlines())\n\tself.assertDoublesEqual( cir.VDC(""2""), 5*(2.0/3.0) )\n\tself.assertDoublesEqual( cir.VDC(""3""), 5*(1.0/3.0) )\n\n    def test_voltage_divider(self):\n\t# assert_(x in y)\n\t# assertEqual(x,y)\n\t# assertRaises(ValueError, random.sample, self.seq)\n\tresistor(1,2,r=50)\n\tresistor(2,3,r=50)\n\tresistor(3,0,r=50)\n\tvsource(1,0,v=5)\n\tdc()\n\tself.assertDoublesEqual( VDC(2), 5*(2.0/3.0) )\n\tself.assertDoublesEqual( VDC(3), 5*(1.0/3.0) )\n\n    def test_opamp(self):\n\t# opamp test\n\tvsource(1,0,v=1)\n\tresistor(1,2,r=50)\n\tresistor(2,3,r=50)\n\t#capacitor(2,3,c=1e-6)\n\t#inductor(2,3,l=1e-6)\n\t#resistor(2,3,r=10e3)\n\topamp(0,2,3,A=5000000)\n\t#ac(start=10, stop=100e6, steps=20)\n\t#plot(AC, v(1), v(2), v(3))\n\tdc()\n\t#plot(DC)\n\tself.assertDoublesEqual( VDC(2), 0.0)\n\tself.assertDoublesEqual( VDC(3), -1.0)\n\nif __name__ == \'__main__\':\n    unittest.main()\n\n#list()\n#x = solve(freq=0.0)\n#print x\n#ac(start=10, stop=100e6, steps=20)\n#plot(AC, v(1), v(2), v(3))\n#plot(AC, v(4), v(6), v(8), v(10))\n#plot(AC, v(4), v(3), v(1), v(10))\n\n#dc()\n#plot(DC)\n\n#plot(DC, v(1), v(2), v(3))\n#plot([v(4)])\n#plot(v(3))\n\n'"
commands.py,0,"b'from SpiceCircuit import SpiceCircuit\n\n###################################################\n# What follows is a command-line interface which is more\n# convenience for interactive mode.\n###################################################\n#### GLOBAL DATA ####\nx = SpiceCircuit()\n\n#### COMMANDS ####\nvcvs = lambda rn1, rn2, n1, n2, A: x.AddVCVS("""", rn1, rn2, n1, n2, A) #DONE\nopamp = lambda plus, minus, out, A: x.AddVCVS("""", plus, minus, out, 0, A)\nvsource = lambda n1, n2, vdc=0.0, vac=0.0: x.AddVoltageSource("""", n1, n2, vac=vac, vdc=vdc) #DONE\nisource = lambda n1, n2, i, idc=0.0, iac=0.0: x.AddCurrentSource("""", n1, n2, iac=iac, idc=idc) #DONE\ncapacitor = lambda n1, n2, c: x.AddCapacitor("""", n1, n2, c) #DONE\ninductor = lambda n1, n2, l: x.AddInductor("""", n1, n2, l) #DONE\nlist = lambda: x.Print()\nresistor = lambda n1, n2, r: x.AddResistor("""", n1, n2, r) #DONE\n# ANALYSES\nac = lambda start, stop=-1, steps=10, name=""ac"": x.ac(start, stop, steps, name)\ndc = lambda name=""dc"": x.dc(name)\n# DISPLAY\nplot = lambda analsis, *args: x.plot(analysis, args)\n# RETRIEVAL\nVDC = lambda node: x.VDC( node )\nIDC = lambda branch: x.IDC( branch )\nVF = lambda node: x.VF( node )\nIF = lambda branch: x.VF( branch )\n#plot = lambda analysis, *args: x.plot(analysis, args)\n\n#### CONSTANTS ####\ndef reset():\n    global x\n    x = SpiceCircuit()\n\n\n'"
sim.py,0,"b'#!/usr/bin/env python\nimport cmd\nfrom SpiceParser import SpiceParser\nfrom SpiceCircuit import SpiceCircuit, SpiceException\n\nclass SpiceInteractive(cmd.Cmd):\n    def __init__(self, parser, circuit):\n        cmd.Cmd.__init__(self)\n        self.prompt = ""spice% ""\n        self.__Parser = parser\n        self.__Circuit = circuit\n\n    def do_show(self, line):\n        print ""ANALYSES:"", self.__Circuit.GetAnalyses()\n        print ""BRANCHES:"", self.__Circuit.GetBranches()\n        print ""NODES:"", self.__Circuit.GetNodes()\n\n    def do_reset(self, line):\n        self.__Circuit.reset_plotter()\n\n    def default(self, line):\n        try:\n            self.__Parser.ParseLine("".""+line)\n        except SpiceException, e:\n            print str(e)\n\n    def do_EOF(self, line):\n        print ""Thank you! Exiting.\\n""\n        sys.exit(0)\n\n\nif __name__==""__main__"":\n    # command line version\n    import sys\n    file_name = sys.argv[1]\n    x = SpiceParser(file_name)\n    cir = x.GetCircuit()\n    interpreter = SpiceInteractive(x, x.GetCircuit())\n    interpreter.cmdloop(""Welcome to spice!"")\n    \n\n\n\n  \n'"
spice_test.py,0,"b'from commands import *\nimport math\nfrom SpiceParser import SpiceParser\n\nimport unittest\nclass TestSequenceFunctions(unittest.TestCase):\n    \n    def assertDoublesEqual(self, d1, d2):\n        # helper function to test equality for doubles\n        # which may not be ""exactly"" the same\n        if d1 == 0.0 or d2 == 0.0:\n            if abs(d1-d2) > 1e-6:\n                self.assert_(False, ""%s != %s"" % (d1, d2))\n        else:\n            if (abs(d1 - d2)) / (abs(d1)+abs(d2)) > 1e-6:\n                self.assert_(False, ""%s != %s"" % (d1, d2))\n\n    def run_netlist(self, netlist):\n        # helper function\n        parser = SpiceParser()\n        return parser.ParseLines( netlist.splitlines() )\n\n    def test_capacitor(self):\n        # TEST: verify basic operation of capacitor using\n        #       an AC voltage divider at f=2k Hz\n        cir = self.run_netlist(""""""\nv1 1 0 ac 1\nc1 1 2 1u\nc2 2 0 2u\n.AC 2k\n"""""")\n        freq = 2e3\n        z1 = 1/(2*math.pi*freq*1e-6)\n        z2 = 1/(2*math.pi*freq*2e-6)\n        self.assertDoublesEqual( cir.VF(""2""), 1.0 * (z2 / (z1 + z2)) )\n        self.assertDoublesEqual( abs(cir.IF(""v1"")),\n                                 1.0 / (z1+z2) )\n\n    def test_inductor(self):\n        # TEST: verify basic operationg of inductor using\n        #       an AC voltage divider at f=10k Hz\n        cir = self.run_netlist(""""""\nv1 1 0 ac 1\nl1 1 2 1n\nl2 2 0 5n\n.AC 100k\n"""""")\n        freq = 100e3\n        z1 = 2*math.pi*freq*1e-9\n        z2 = 2*math.pi*freq*5e-9\n        self.assertDoublesEqual( cir.VF(""2""), 1.0 * (z2 / (z1 + z2)) )\n        x = cir.IF(""v1"")\n        print x\n        print cir.phase(x)\n        print cir.cartesianToPolar(x)\n        self.assertDoublesEqual( abs(cir.IF(""v1"")),\n                                 1.0 / (z1+z2) )\n        \n    def test_current_source(self):\n        cir = self.run_netlist(""""""\ni1 1 0 dc 1\nv1 1 0 dc 0\n.DC\n"""""")\n        self.assertDoublesEqual( cir.IDC(""v1""), 1.0 )\n\n    def test_voltage_source(self):\n        # TEST: verify basic operation of voltage source\n        cir = self.run_netlist(""""""\nv1 1 0 dc 1\n.DC\n"""""")\n        self.assertDoublesEqual( cir.VDC(""1""), 1.0 )\n\n    def test_ccvs(self):\n        # TEST: verify operation of the CCVS using a voltage\n        #       divider with a known current value\n        cir = self.run_netlist(""""""\nv1 1 0 dc 1\nr1 1 2 50\nr2 2 0 50\nh1 3 4 v1 10\nr3 3 0 10\nr4 4 0 10\n.DC\n"""""")\n        gain = 10\n        self.assertDoublesEqual( cir.IDC(""v1""), -1.0/100.0 )\n        self.assertDoublesEqual( cir.VDC(""3"") - cir.VDC(""4""),\n                                 gain*cir.IDC(""v1"") )\n\n\n    def test_vccs(self):\n        # TEST: verify operation of the VCCS\n        # CHECK: verify that the correct current is flowing;\n        #        NOTE: we need to add a voltage source to measure\n        #        this since this is not for free in the matrix\n        cir = self.run_netlist(""""""\nv1 1 0 dc 1\nr1 1 2 50\nr2 2 0 50\nv2 3 4 dc 0\ng1 4 5 2 1 10\nr3 3 0 10\nr4 5 0 10\n.DC \n"""""")\n        self.assertDoublesEqual( cir.VDC(""2""), 0.5 )\n        self.assertDoublesEqual( cir.VDC(""1""), 1.0 )\n        self.assertDoublesEqual( cir.IDC(""v2""), -5.0 )\n        self.assertDoublesEqual( cir.VDC(""3""), 50 )\n        self.assertDoublesEqual( cir.VDC(""5""), -50 )\n\n    def test_vcvs(self):\n        # TEST: verify operation of the VCVS by setting up a simple\n        #       simple voltage divider and then a VCVS with gain=10\n        # CHECK: verify that the correct gain is achieved\n        cir = self.run_netlist(""""""\nv1 1 0 dc 1\nr1 1 2 50\nr2 2 0 50\ne1 3 0 2 0 10\nr3 3 0 50\n.DC\n"""""")\n        self.assertDoublesEqual( cir.VDC(""2""), 0.5 )\n        self.assertDoublesEqual( cir.VDC(""3""), cir.VDC(""2"")*10 )\n\n    def test_resistor(self):\n        # TEST: setup a 3 resistor voltage divider and ensure\n        #       that all voltages are calculated properly\n        # CHECK: voltage at each node\n        cir = self.run_netlist(""""""\nr1 1 2 50\nr2 2 3 50\nr3 3 0 50\nv1 1 0 DC 5\n.DC\n"""""")\n        self.assertDoublesEqual( cir.IDC(""v1""), -5.0/(150.0) )\n        self.assertDoublesEqual( cir.VDC(""1""), 5.0 )\n        self.assertDoublesEqual( cir.VDC(""2""), 5*(2.0/3.0) )\n        self.assertDoublesEqual( cir.VDC(""3""), 5*(1.0/3.0) )\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n\n\n'"
test_svd.py,0,"b'from numpy import *\nimport numpy.linalg\n\nx = array([[92.477, 10.202, -28.832], \n\t   [1.963, 32.816, 62.414],\n\t   [26.821, 36.816, 57.234]])\n\t   #[23.2134, -86.3925, 44.693]])\n\nprint x\n\nv, s, wt = numpy.linalg.singular_value_decomposition(x, 1)\n\nprint ""v *********""\nprint v\nprint ""s *********""\nprint s\nprint ""wt *********""\nprint wt\nprint ""*************""\n\ncond = max(s) / min(s)\nrcond = 1 / cond\n\nprint ""rcond="", rcond\n'"
