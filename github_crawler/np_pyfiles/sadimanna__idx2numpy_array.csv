file_path,api_count,code
idx2ndarray.py,12,"b'#If no. of images is not a integer multiple of nBatch\n#Uncomment ""try-except"" part\n#This may increase the execution time by less than 1 sec\n\nimport time,math\nimport struct as st\nimport numpy as np\n\ntrainingfilenames = {\'images\' : \'training_set/train-images.idx3-ubyte\' ,\'labels\' : \'training_set/train-labels.idx1-ubyte\'}\ntestfilenames = {\'images\' : \'test_set/t10k-images.idx3-ubyte\' ,\'labels\' : \'test_set/t10k-labels.idx1-ubyte\'}\n\ndata_types = {\n        0x08: (\'ubyte\', \'B\', 1),\n        0x09: (\'byte\', \'b\', 1),\n        0x0B: (\'>i2\', \'h\', 2),\n        0x0C: (\'>i4\', \'i\', 4),\n        0x0D: (\'>f4\', \'f\', 4),\n        0x0E: (\'>f8\', \'d\', 8)}\n\n#..........................................................For training dataset..............................................................\nprint ""Training Dataset.......""\nstime = time.time()\nfor name in trainingfilenames.keys():\n\tif name == \'images\':\n\t\ttrain_imagesfile = open(trainingfilenames[name],\'r+\')\n\tif name == \'labels\':\n\t\ttrain_labelsfile = open(trainingfilenames[name],\'r+\')\n\ntrain_imagesfile.seek(0)\nmagic = st.unpack(\'>4B\',train_imagesfile.read(4))\nif(magic[0] and magic[1])or(magic[2] not in data_types):\n\traise ValueError(""File Format not correct"")\n\n#Information\nnDim = magic[3]\nprint ""Data is ""+str(nDim)+""-D""\ndataType = data_types[magic[2]][0]\nprint ""Data Type :: "",dataType\ndataFormat = data_types[magic[2]][1]\nprint ""Data Format :: "",dataFormat\ndataSize = data_types[magic[2]][2]\nprint ""Data Size :: ""+str(dataSize)+"" byte\\n""\n\n#offset = 0004 for number of images\n#offset = 0008 for number of rows\n#offset = 0012 for number of columns\n#32-bit integer (32 bits = 4 bytes)\ntrain_imagesfile.seek(4)\nnImg = st.unpack(\'>I\',train_imagesfile.read(4))[0] #num of images/labels\nnR = st.unpack(\'>I\',train_imagesfile.read(4))[0] #num of rows\nnC = st.unpack(\'>I\',train_imagesfile.read(4))[0] #num of columns\n\ntrain_labelsfile.seek(8) #Since no. of items = no. of images and is already read\nprint ""no. of images :: "",nImg\nprint ""no. of rows :: "",nR\nprint ""no. of columns :: "",nC\nprint\n#Training set\n#Reading the labels\ntrain_labels_array = np.asarray(st.unpack(\'>\'+dataFormat*nImg,train_labelsfile.read(nImg*dataSize))).reshape((nImg,1))\n#Reading the Image data\nnBatch = 10000\nnIter = int(math.ceil(nImg/nBatch))\nnBytes = nBatch*nR*nC*dataSize\nnBytesTot = nImg*nR*nC*dataSize\ntrain_images_array = np.array([])\nfor i in xrange(0,nIter):\n\t#try:\n\ttemp_images_array = 255 - np.asarray(st.unpack(\'>\'+dataFormat*nBytes,train_imagesfile.read(nBytes))).reshape((nBatch,nR,nC))\n\t\'\'\'except:\n\t\tnbytes = nBytesTot - (nIter-1)*nBytes\n\t\ttemp_images_array = 255 - np.asarray(st.unpack(\'>\'+\'B\'*nbytes,train_imagesfile.read(nbytes))).reshape((nBatch,nR,nC))\'\'\'\n\t#Stacking each nBatch block to form a larger block\n\tif train_images_array.size == 0:\n\t\ttrain_images_array = temp_images_array\n\telse:\n\t\ttrain_images_array = np.vstack((train_images_array,temp_images_array))\n\ttemp_images_array = np.array([])\n\tprint ""Time taken :: ""+str(time.time()-stime)+"" seconds\\n""\n\tprint str((float(i+1)/nIter)*100)+""% complete...\\n""\n\n\nprint ""Training Set Labels shape ::"",train_labels_array.shape\nprint ""Training Set Image shape ::"",train_images_array.shape\n\nprint ""Time of execution :: ""+str(time.time()-stime)+"" seconds\\n""\n#..........................................................For test dataset..................................................................\nprint ""Test Dataset.......""\nstime = time.time()\nfor name in testfilenames.keys():\n\tif name == \'images\':\n\t\ttest_imagesfile = open(testfilenames[name],\'r+\')\n\tif name == \'labels\':\n\t\ttest_labelsfile = open(testfilenames[name],\'r+\')\ntest_imagesfile.seek(0)\nmagic = st.unpack(\'>4B\',test_imagesfile.read(4))\nif(magic[0] and magic[1])or(magic[2] not in data_types):\n\traise ValueError(""File Format not correct"")\n\nnDim = magic[3]\nprint ""Data is "",nDim,""-D""\nprint\n#offset = 0004 for number of images\n#offset = 0008 for number of rows\n#offset = 0012 for number of columns\n#32-bit integer (32 bits = 4 bytes)\ntest_imagesfile.seek(4)\nnImg = st.unpack(\'>I\',test_imagesfile.read(4))[0] #num of images/labels\nnR = st.unpack(\'>I\',test_imagesfile.read(4))[0] #num of rows\nnC = st.unpack(\'>I\',test_imagesfile.read(4))[0] #num of columns\n\ntest_labelsfile.seek(8) #Since no. of items = no. of images and is already read\nprint ""no. of images :: "",nImg\nprint ""no. of rows :: "",nR\nprint ""no. of columns :: "",nC\nprint\n#Test set\n#Reading the labels\ntest_labels_array = np.asarray(st.unpack(\'>\'+dataFormat*nImg,test_labelsfile.read(nImg*dataSize))).reshape((nImg,1))\n#Reading the Image data\nnBatch = 10000\nnIter = int(math.ceil(nImg/nBatch))\nnBytes = nBatch*nR*nC*dataSize\nnBytesTot = nImg*nR*nC*dataSize\ntest_images_array = np.array([])\nfor i in xrange(0,nIter):\n\t#try:\n\ttemp_images_array = 255 - np.asarray(st.unpack(\'>\'+dataFormat*nBytes,test_imagesfile.read(nBytes))).reshape((nBatch,nR,nC))\n\t\'\'\'except:\n\t\tnbytes = nBytesTot - (nIter-1)*nBytes\n\t\ttemp_images_array = 255 - np.asarray(st.unpack(\'>\'+\'B\'*nbytes,test_imagesfile.read(nbytes))).reshape((nBatch,nR,nC))\'\'\'\n\t#Stacking each nBatch block to form a larger block\n\tif test_images_array.size == 0:\n\t\ttest_images_array = temp_images_array\n\telse:\n\t\ttest_images_array = np.vstack((test_images_array,temp_images_array))\n\ttemp_images_array = np.array([])\n\tprint ""Time taken :: ""+str(time.time()-stime)+"" seconds\\n""\n\tprint str((float(i+1)/nIter)*100)+""% complete...\\n""\n\n\nprint ""Test Set Labels shape ::"",test_labels_array.shape\nprint ""Test Set Image shape ::"",test_images_array.shape\n\nprint ""Time of execution : %s seconds"" % str(time.time()-stime)\n'"
idx2nparr.py,13,"b'import time\nstime = time.time()\n\nimport struct as st\nimport numpy as np\n\nfilename = {\'images\' : \'train-images.idx3-ubyte\' ,\'labels\' : \'train-labels.idx1-ubyte\'}\nimages_array = np.array([])\nlabels_array = np.array([])\n\nfor name in filename.keys():\n\tif name == \'images\':\n\t\timagesfile = open(filename[name],\'r+\')\n\tif name == \'labels\':\n\t\tlabelsfile = open(filename[name],\'r+\')\n\n#offset = 0004 for number of images\n#offset = 0008 for number of rows\n#offset = 0012 for number of columns\n#32-bit integer (32 bits = 4 bytes)\nimagesfile.seek(4)\nnImg = st.unpack(\'>I\',imagesfile.read(4))[0] #num of images/labels\nnR = st.unpack(\'>I\',imagesfile.read(4))[0] #num of rows\nnC = st.unpack(\'>I\',imagesfile.read(4))[0] #num of columns\nlabelsfile.seek(8) #Since no. of items = no. of images and is already read\nprint ""no. of images :: "",nImg\nprint ""no. of rows :: "",nR\nprint ""no. of columns :: "",nC\n\ntemp_array = np.array([])\nimages10000_array = np.array([])\nfor i in xrange(1,nImg+1):\n\t#Read labels\n\tlabels_array = np.append(labels_array,st.unpack(\'>B\',labelsfile.read(1))[0])\n\t#Read training images\n\tif temp_array.size == 0:\n\t\t#invert the image as 255 is white and 0 is black\n\t\ttemp_array = 255 - np.asarray(st.unpack(\'>784B\',imagesfile.read(784))).reshape((nR,nC))\n\telse:\n\t\tnextimage = 255 - np.asarray(st.unpack(\'>784B\',imagesfile.read(784))).reshape((nR,nC))\n\t\tif len(temp_array.shape)==2:\n\t\t\ttemp_array = np.vstack((temp_array[None],nextimage[None]))\n\t\telse:\n\t\t\ttemp_array = np.vstack((temp_array,nextimage[None]))\n\t\n\t#Extra stuffs to speed up the stacking process (took 51.804361105 seconds in my case)\n\t#Stacking each 1000 block to form a block of 10000\n\tif i%1000==0 and i != 0:\n\t\tif images10000_array.size == 0:\n\t\t\timages10000_array = temp_array\n\t\telse:\n\t\t\timages10000_array = np.vstack((images10000_array,temp_array))\n\t\ttemp_array = np.array([])\n\t\tprint ""Time taken :: "",time.time()-stime\n\t#Stacking each 10000 block to form the whole dataset\n\tif i%10000==0 and i != 0: \n\t\tif images_array.size == 0:\n\t\t\timages_array = images10000_array\n\t\telse:\n\t\t\timages_array = np.vstack((images_array,images10000_array))\n\t\timages10000_array = np.array([])\n\t\tprint (float(i)/nImg)*100,""% complete...""\n\nprint labels_array.shape\nprint images_array.shape\n\nprint ""Time of execution : %s seconds"" % str(time.time()-stime)\n'"
idx2numpyarray.py,3,"b'import time\nstime = time.time()\n\nimport struct as st\nimport numpy as np\n\nfilename = {\'images\' : \'training_set/train-images.idx3-ubyte\' ,\'labels\' : \'training_set/train-labels.idx1-ubyte\'}\n\nlabels_array = np.array([])\n\ndata_types = {\n        0x08: (\'ubyte\', \'B\', 1),\n        0x09: (\'byte\', \'b\', 1),\n        0x0B: (\'>i2\', \'h\', 2),\n        0x0C: (\'>i4\', \'i\', 4),\n        0x0D: (\'>f4\', \'f\', 4),\n        0x0E: (\'>f8\', \'d\', 8)}\n\nfor name in filename.keys():\n\tif name == \'images\':\n\t\timagesfile = open(filename[name],\'r+\')\n\tif name == \'labels\':\n\t\tlabelsfile = open(filename[name],\'r+\')\n\nimagesfile.seek(0)\nmagic = st.unpack(\'>4B\',imagesfile.read(4))\nif(magic[0] and magic[1])or(magic[2] not in data_types):\n\traise ValueError(""File Format not correct"")\n\nnDim = magic[3]\nprint ""Data is "",nDim,""-D""\n\n#offset = 0004 for number of images\n#offset = 0008 for number of rows\n#offset = 0012 for number of columns\n#32-bit integer (32 bits = 4 bytes)\nimagesfile.seek(4)\nnImg = st.unpack(\'>I\',imagesfile.read(4))[0] #num of images/labels\nnR = st.unpack(\'>I\',imagesfile.read(4))[0] #num of rows\nnC = st.unpack(\'>I\',imagesfile.read(4))[0] #num of columns\nnBytes = nImg*nR*nC\nlabelsfile.seek(8) #Since no. of items = no. of images and is already read\nprint ""no. of images :: "",nImg\nprint ""no. of rows :: "",nR\nprint ""no. of columns :: "",nC\n\n#Read all data bytes at once and then reshape\nimages_array = 255 - np.asarray(st.unpack(\'>\'+\'B\'*nBytes,imagesfile.read(nBytes))).reshape((nImg,nR,nC))\nlabels_array = np.asarray(st.unpack(\'>\'+\'B\'*nImg,labelsfile.read(nImg))).reshape((nImg,1))\n\nprint labels_array\nprint labels_array.shape\nprint images_array.shape\n\nprint ""Time of execution : %s seconds"" % str(time.time()-stime)\n'"
ndarr2img.py,2,"b'import time\nimport numpy as np\nfrom scipy.misc import imsave\n\nstime = time.time()\nfrom idx2ndarray import train_images_array,test_images_array,train_labels_array,test_labels_array\nprint ""\\nTime for loading numpy arrays from idx2ndarray :: ""+str(time.time()-stime)+"" seconds\\n""\n\ntrainImgshape = train_images_array.shape\ntrainLabelshape = train_labels_array.shape\ntestImgshape = test_images_array.shape\ntestLabelshape = test_labels_array.shape\n\nstime = time.time()\ntraining_folderName = \'training_set_images/\'\nfileNameLen = len(str(trainImgshape[0]))\nnIter = trainImgshape[0]+1\nfor n in xrange(1,nIter):\n\tfilename = \'0\'*(fileNameLen - len(str(n)))+str(n)+\'.jpg\'\n\t#print filename\n\timsave(training_folderName+filename,train_images_array[n-1,:,:])\nprint ""Time for converting training dataset array to images :: ""+str(time.time()-stime)+"" seconds\\n""\n\nstime = time.time()\ntest_folderName = \'test_set_images/\'\nfileNameLen = len(str(testImgshape[0]))\nnIter = testImgshape[0]+1\nfor n in xrange(1,nIter):\n\tfilename = \'0\'*(fileNameLen - len(str(n)))+str(n)+\'.jpg\'\n\t#print filename\n\timsave(test_folderName+filename,test_images_array[n-1,:,:])\nprint ""Time for converting test dataset array to images :: ""+str(time.time()-stime)+"" seconds\\n""\n\nstime = time.time()\ntrainingLabelFileName = \'training_set_labels\'\nnp.save(trainingLabelFileName,train_labels_array,allow_pickle=False,fix_imports=False)\nprint ""Time for saving Training Labels array as .npy file :: ""+str(time.time()-stime)+"" seconds\\n""\n\nstime = time.time()\ntestLabelFileName = \'test_set_labels\'\nnp.save(testLabelFileName,test_labels_array,allow_pickle=False,fix_imports=False)\nprint ""Time for saving Test Labels array as .npy file :: ""+str(time.time()-stime)+"" seconds\\n""\n\n#saved as .npy\n'"
