file_path,api_count,code
__init__.py,0,b''
prettymatrix.py,25,"b'import itertools\n\nimport numpy as np\n\n\nDOT = "".""\nPLUS = \'+\'\nMINUS = \'-\'\nHADAMARD = \'\xe2\x88\x98\'\nEQUALS = \'=\'\n\n_PAD = \' \' \n_TOP_LEFT_CORNER = \'\xe2\x94\x8c\'\n_TOP_RIGHT_CORNER = \'\xe2\x94\x90\'\n_BOTTOM_LEFT_CORNER = \'\xe2\x94\x94\'\n_BOTTOM_RIGHT_CORNER = \'\xe2\x94\x98\'\n_BORDER = \'\xe2\x94\x82\'\n\n_ELLIPSIS = \'\xe2\x80\xa6\'\n\n_MAX_HEIGHT = _MAX_WIDTH = 10\n_SHRUNK_NUM_ROWS = _SHRUNK_NUM_COLS = 3\n\n\ndef matrix_to_string(M, name=None, include_dimensions=False):\n    """"""Stringify a 2D matrix, M.""""""\n    return _render(_format_matrix(M, name, include_dimensions))\n\n\ndef matrices_to_string(*seq, names=None, include_dimensions=False):\n    """"""Stringify a sequence of 2D matrices.""""""\n\n    if names and len(names) > len(seq):\n        raise ValueError((""Number of names must be less than or ""\n                          ""equal to number of matrices""))\n    \n    # A bit of a hack: if any names are specified at all, we must pad any\n    # matrix with an empty name if it doesn\'t have one specified. Otherwise, it\n    # will be missing a row.\n    name_fallback = \' \' if names else None\n\n    formatted = [_format_matrix(M, name=name or name_fallback, include_dimensions=include_dimensions)\n                 for M, name in itertools.zip_longest(seq, names or [])]\n\n    num_rows = max(M.shape[0] for M in formatted)\n    padded = [_pad_horizontally(M, top_padding=0, bottom_padding=num_rows - M.shape[0]) for M in formatted]\n    widths = [M.shape[1] for M in padded]\n    x = _space_columns(np.concatenate(padded, axis=1), widths)\n    return _render(x)\n\n\ndef expression_to_string(*seq, names=None, include_dimensions=False):\n    """"""Stringify an expression, comprising matrices and operators.\n\n    Operators can be any string, but for convenience the following are defined:\n\n    prettymatrix.DOT\n    prettymatrix.HADAMARD\n    prettymatrix.PLUS\n    prettymatrix.MINUS\n    prettymatrix.EQUALS\n    """"""\n    # Expand the names array with Nones such that its the same length as the\n    # input sequence.\n    if names:\n        for i, M in enumerate(seq):\n            if isinstance(M, str):\n                names.insert(i, None)\n\n    if names and len(names) > len(seq):\n        raise ValueError((""Number of names must be less than or ""\n                          ""equal to number of matrices""))\n\n    # Dynamically format an item in the input sequence depending on whether its\n    # a matrix or an operator (a string).\n    def _format(M, name=None, include_dimensions=False):\n        if isinstance(M, str):\n            height = int(bool(name)) + int(bool(include_dimensions))\n            return np.concatenate((np.full((height, 1), _PAD), np.full((1, 1),\n                M)), axis=0)\n        else:\n            return _format_matrix(M, name=name, include_dimensions=include_dimensions)\n\n    # A bit of a hack: if any names are specified at all, we must pad any\n    # matrix with an empty name if it doesn\'t have one specified. Otherwise, it\n    # will be missing a row.\n    name_fallback = \' \' if names else None\n\n    formatted = [_format(M, name=name or name_fallback, include_dimensions=include_dimensions)\n                 for M, name in itertools.zip_longest(seq, names or [])]\n    num_rows = max(M.shape[0] for M in formatted)\n    padded = [_pad_horizontally(M, top_padding=0, bottom_padding=num_rows - M.shape[0]) for M in formatted]\n    widths = [M.shape[1] for M in padded]\n    return _render(_space_columns(np.concatenate(padded, axis=1), widths)) \n\n\ndef _format_matrix(M, name=None, include_dimensions=False):\n    """"""Return a copy of M with all formatting steps applied.\n\n    This includes:\n    * Split the contents of every cell to contain at most one character\n    * Add a column of padding between every two columns\n    * Wrap the entire matrix in padding\n    * Add typical matrix-notation bracketing\n    * Replace internal rows and columns with ellipses if matrix is too large\n    * Optionally prepend a row containing the matrix\'s dimensions\n    * Optionally prepend a name row to the matrix\n    """"""\n    N = _border(\n            _pad(\n            _space_columns(\n            *_normalize_all_cells(\n            _cells_to_string(\n            _cap_dimensions(M))))))\n\n    if include_dimensions:\n        N = _prepend_string_row(N, \'({}x{})\'.format(*M.shape))\n\n    if name:\n        N = _prepend_string_row(N, name)\n\n    return N\n\n\ndef _character_cell(c):\n    """"""Return a (1x1) array wrapping character c.""""""\n    return np.full((1,1), c)\n\n\ndef _character_column(c, height, width=1):\n    """"""Return a column of fixed height filled with character c.""""""\n    return np.full((height, width), c)\n\n\ndef _character_row(c, width, height=1):\n    """"""Return a row of fixed width filled with character c.""""""\n    return np.full((height, width), c)\n\n\ndef _left_border(M):\n    """"""Build a left-hand border that would fit a matrix, M.""""""\n    num_rows, num_cols = M.shape\n\n    top_left_corner = _character_cell(_TOP_LEFT_CORNER)\n    border = _character_column(_BORDER, num_rows - 2)\n    bottom_left_corner = _character_cell(_BOTTOM_LEFT_CORNER)\n\n    left_border = np.concatenate(\n        (top_left_corner,\n         border,\n         bottom_left_corner),\n        axis=0)\n\n    return left_border\n\n\ndef _right_border(M):\n    """"""Build a right-hand border that would fit a matrix, M.""""""\n    num_rows, num_cols = M.shape\n\n    top_right_corner = _character_cell(_TOP_RIGHT_CORNER)\n    border = _character_column(_BORDER, num_rows - 2)\n    bottom_right_corner = _character_cell(_BOTTOM_RIGHT_CORNER)\n\n    right_border = np.concatenate(\n        (top_right_corner,\n         border,\n         bottom_right_corner),\n        axis=0)\n\n    return right_border\n\n\ndef _border(M):\n    """"""Return a copy of M wrapped in the convention matrix brackets.""""""\n    left_border = _left_border(M)\n    right_border = _right_border(M)\n\n    bordered = np.concatenate((left_border, M, right_border), axis=1)\n\n    return bordered\n\n\ndef _pad_vertically(M, left_padding=1, right_padding=1):\n    """"""Return a copy of M wrapped on each side by columns of padding.""""""\n    num_rows, num_cols = M.shape\n    left_pad = _character_column(_PAD, num_rows, left_padding)\n    right_pad = _character_column(_PAD, num_rows, right_padding)\n\n    padded = np.concatenate(\n         (left_pad,\n          M,\n          right_pad), axis=1)\n\n    return padded\n\n\ndef _pad_horizontally(M, top_padding=1, bottom_padding=1):\n    """"""Return a copy of M wrapped on the top and bottom by a single row of padding.""""""\n    num_rows, num_cols = M.shape\n\n    top_pad = _character_row(_PAD, num_cols, top_padding)\n    bottom_pad = _character_row(_PAD, num_cols, bottom_padding)\n\n    padded = np.concatenate(\n        (top_pad,\n         M,\n         bottom_pad),\n        axis=0)\n\n    return padded\n\n\ndef _pad(M):\n    """"""Return a copy of M wrapped by a single layer of padding on all sides.""""""\n    return _pad_vertically(_pad_horizontally(M))\n\n\ndef _normalize_cell_width(M, min_column_width=0):\n    """"""Return a cell with its contents normalized.\n\n    See _normalize_all_cells for a description of normalization.\n\n    Note that M should be a matrix of size (1x1).\n    """"""\n    split = np.concatenate([_character_cell(c) for c in M[0,0]], axis=1)\n    right_padding_size = max(0, min_column_width - split.shape[1])\n    right_padding = _character_row(_PAD, right_padding_size)\n    return np.concatenate((split, right_padding), axis=1)\n    \n\ndef _normalize_column_width(M, min_column_width=0):\n    """"""Return a column where every cell has had its contents normalized.\n\n    See _normalize_all_cells for a description of normalization.\n\n    Note that M should be a column vector, that is, of size (nx1).\n    """"""\n    return np.concatenate([_normalize_cell_width(M[i:i+1, :], min_column_width)\n                           for i in range(0, M.shape[0])], axis=0)\n\n\ndef _normalize_all_cells(M):\n    """"""Return a matrix where every cell has had its contents normalized.\n\n    By normalized, we mean that every cell containing a string s of length n,\n    is split into n cells, each containing a single character of s.\n    """"""\n    if M.shape == (0, 0):\n        # Bit of a hack because we can\'t apply vectorized operations to 0x0\n        # matrices.\n        return M, np.full((0,0), 0)\n\n    max_column_widths = np.max(np.vectorize(len)(M), axis=0)\n\n    if M.shape[1] == 1:\n        return _normalize_column_width(M, max_column_widths[0]), max_column_widths\n\n    columns = np.split(M, M.shape[1], axis=1)\n    zipped = zip(columns, max_column_widths)\n\n    return np.concatenate([_normalize_column_width(col, w) for col, w in zipped],\n                          axis=1), max_column_widths\n\n\ndef _space_columns(M, column_widths):\n    """"""Return a matrix with a column of whitespace between every column in M.""""""\n    if len(column_widths) == 1:\n        return M\n\n    num_rows, _ = M.shape\n\n    indices = np.cumsum(column_widths)[:-1]\n    columns = np.split(M, indices, axis=1)\n    spacers = [_character_column(_PAD, num_rows)] * (len(columns) - 1)\n\n    columns_with_spacers = [col for cols in itertools.zip_longest(columns, spacers)\n                            for col in cols if col is not None]\n\n    return np.concatenate(columns_with_spacers, axis=1)\n\n\ndef _cells_to_string(M):\n    """"""Return a matrix where every cell of M has been stringified.""""""\n    return M.astype(str)\n\n\ndef _prepend_string_row(M, string):\n    """"""Prepend a new row containing string to the top of the matrix.""""""\n    if not string:\n        return M\n\n    num_rows, num_cols = M.shape\n    string_row = _normalize_cell_width(np.array([[string]]), num_cols)\n    right_padding = string_row.shape[1] - num_cols\n    padded = _pad_vertically(M, 0, right_padding)\n    return np.concatenate((string_row, padded), axis=0)\n\n\ndef _cap_dimensions(M):\n    """"""Return a copy of M bounded to a fixed size.\n\n    We keep a fixed number of the original columns and rows, but replace all\n    the internals with ellipses to indicate omission.\n    """"""\n    return _cap_width(_cap_height(M))\n\n\ndef _cap_height(M):\n    """"""Return a copy of M bounded to a fixed number of rows.""""""\n    num_rows, num_cols = M.shape\n\n    if num_rows <= _MAX_HEIGHT:\n        return M\n\n    top_segment = M[:_SHRUNK_NUM_ROWS, :]\n    middle_segment = _character_row(_ELLIPSIS, num_cols, height=_SHRUNK_NUM_ROWS)\n    bottom_segment = M[-_SHRUNK_NUM_ROWS:, :]\n\n    return np.concatenate(\n            (top_segment,\n             middle_segment,\n             bottom_segment), axis=0)\n\n\ndef _cap_width(M):\n    """"""Return a copy of M bounded to a fixed number of columns.""""""\n    num_rows, num_cols = M.shape\n\n    if num_cols <= _MAX_WIDTH:\n        return M\n\n    top_segment = M[:, :_SHRUNK_NUM_COLS]\n    middle_segment = _character_column(_ELLIPSIS, num_rows, width=_SHRUNK_NUM_COLS)\n    bottom_segment = M[:, -_SHRUNK_NUM_COLS:]\n\n    return np.concatenate(\n            (top_segment,\n             middle_segment,\n             bottom_segment), axis=1)\n\n\ndef _render(M):\n    """"""Return a string representation of the matrix, M.""""""\n    return \'\\n\'.join((\'\'.join(row) for row in M))\n'"
setup.py,0,"b""from setuptools import setup\n\nsetup(\n    name='prettymatrix',\n    version='1.0.0',\n    py_modules=['prettymatrix'],\n    license='MIT',\n    author='Samuel Bell',\n    author_email='samueljamesbell@gmail.com',\n    url='https://github.com/samueljamesbell/prettymatrix',\n    description='Pretty printer for matrices and column vectors.',\n    keywords='matrix matrices vector formatting string numpy',\n    install_requires=['numpy'],\n)\n"""
test_prettymatrix.py,71,"b'import unittest\n\nimport numpy as np\n\nimport prettymatrix\n\n\nclass MatrixToStringTest(unittest.TestCase):\n\n    def test_empty_matrix(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((0, 0), \'\'))\n        self.assertEqual(expected, actual)\n\n    def test_1_x_1_matrix(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_1_matrix(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((2, 1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_1_x_1_matrix_with_multi_digit_cell(self):\n        expected = (\n            ""\xe2\x94\x8c    \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94    \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 1), \'00\'))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_1_matrix_with_multi_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c    \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94    \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((2, 1), \'00\'))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_1_matrix_with_single_and_multi_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c    \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0  \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94    \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'0\'], [\'00\']]))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_1_matrix_with_multi_and_single_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c    \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0  \xe2\x94\x82\\n""\n            ""\xe2\x94\x94    \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\'], [\'0\']]))\n        self.assertEqual(expected, actual)\n\n    def test_1_x_2_matrix_with_single_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 2), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_1_x_2_matrix_with_single_and_multi_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c      \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94      \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'0\']]))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_single_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((2,2), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_single_and_multi_digit_cells(self):\n        expected = (\n            ""\xe2\x94\x8c      \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0  0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94      \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'0\'], [\'0\', \'0\']]))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_single_and_multi_digit_cells_2(self):\n        expected = (\n            ""\xe2\x94\x8c      \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 00 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94      \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'0\'], [\'00\', \'0\']]))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_single_and_multi_digit_cells_3(self):\n        expected = (\n            ""\xe2\x94\x8c       \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 00 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0  0  \xe2\x94\x82\\n""\n            ""\xe2\x94\x94       \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'00\'], [\'0\', \'0\']]))\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_single_and_multi_digit_cells_4(self):\n        expected = (\n            ""\xe2\x94\x8c        \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 000 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0  00  \xe2\x94\x82\\n""\n            ""\xe2\x94\x94        \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'000\'], [\'0\', \'00\']]))\n        self.assertEqual(expected, actual)\n\n    def test_empty_matrix_with_short_name(self):\n        expected = (\n            ""W   \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((0, 0), \'\'), name=\'W\')\n        self.assertEqual(expected, actual)\n\n    def test_empty_matrix_with_long_name(self):\n        expected = (\n            ""W_x_y\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((0, 0), \'\'), name=\'W_x_y\')\n        self.assertEqual(expected, actual)\n\n    def test_1_x_1_matrix_with_short_name(self):\n        expected = (\n            ""W    \\n""\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 1), \'0\'), name=\'W\')\n        self.assertEqual(expected, actual)\n\n    def test_1_x_1_matrix_with_long_name(self):\n        expected = (\n            ""W_x_y_z\\n""\n            ""\xe2\x94\x8c   \xe2\x94\x90  \\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82  \\n""\n            ""\xe2\x94\x94   \xe2\x94\x98  ""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 1), \'0\'),\n                                               name=\'W_x_y_z\')\n        self.assertEqual(expected, actual)\n\n    def test_1_x_2_matrix_with_short_name(self):\n        expected = (\n            ""W      \\n""\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 2), \'0\'), name=\'W\')\n        self.assertEqual(expected, actual)\n\n    def test_1_x_2_matrix_with_long_name(self):\n        expected = (\n            ""W_x_y_z\\n""\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 2), \'0\'),\n                                               name=\'W_x_y_z\')\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_short_name(self):\n        expected = (\n            ""W         \\n""\n            ""\xe2\x94\x8c        \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 00 000 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0  00  \xe2\x94\x82\\n""\n            ""\xe2\x94\x94        \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'000\'], [\'0\', \'00\']]),\n                                               name=\'W\')\n        self.assertEqual(expected, actual)\n\n    def test_2_x_2_matrix_with_long_name(self):\n        expected = (\n            ""W_long_name\\n""\n            ""\xe2\x94\x8c        \xe2\x94\x90 \\n""\n            ""\xe2\x94\x82 00 000 \xe2\x94\x82 \\n""\n            ""\xe2\x94\x82 0  00  \xe2\x94\x82 \\n""\n            ""\xe2\x94\x94        \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrix_to_string(np.array([[\'00\', \'000\'], [\'0\', \'00\']]),\n                                               name=\'W_long_name\')\n        self.assertEqual(expected, actual)\n\n    def test_empty_matrix_with_dimensions(self):\n        expected = (\n            ""(0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((0, 0), \'\'),\n                                               include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_1_x_1_matrix_with_dimensions(self):\n        expected = (\n            ""(1x1)\\n""\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 1), \'0\'),\n                                               include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_1_x_2_matrix_with_dimensions(self):\n        expected = (\n            ""(1x2)  \\n""\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1, 2), \'0\'),\n                                               include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_2_x_1_matrix_with_dimensions(self):\n        expected = (\n            ""(2x1)\\n""\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((2, 1), \'0\'),\n                                               include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_empty_matrix_with_name_and_dimensions(self):\n        expected = (\n            ""M    \\n""\n            ""(0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((0, 0), \'\'),\n                                               name=\'M\',\n                                               include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_10x1_matrix_renders_normally(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((10,1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_11x1_matrix_inserts_ellipses(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((11,1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_11x2_matrix_inserts_ellipses(self):\n        expected = (\n            ""\xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((11,2), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_1x10_matrix_renders_normally(self):\n        expected = (\n            ""\xe2\x94\x8c                     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94                     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1,10), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_1x10_matrix_inserts_ellipses(self):\n        expected = (\n            ""\xe2\x94\x8c                   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94                   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((1,11), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_10x10_matrix_renders_normally(self):\n        expected = (\n            ""\xe2\x94\x8c                     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 0 0 0 0 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94                     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((10,10), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_11x11_matrix_inserts_ellipses(self):\n        expected = (\n            ""\xe2\x94\x8c                   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 0 0 \xe2\x80\xa6 \xe2\x80\xa6 \xe2\x80\xa6 0 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94                   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrix_to_string(np.full((11,11), \'0\'))\n        self.assertEqual(expected, actual)\n\n\nclass MatricesToStringTest(unittest.TestCase):\n\n    def test_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'), np.full((0, 0), \'\'))\n        self.assertEqual(expected, actual)\n\n    def test_two_1x1_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90 \xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82 \xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98 \xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((1, 1), \'0\'), np.full((1, 1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_different_width_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90 \xe2\x94\x8c     \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82 \xe2\x94\x82 0 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98 \xe2\x94\x94     \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((1, 1), \'0\'), np.full((1, 2), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_different_height_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90 \xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82 \xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98 \xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""      \xe2\x94\x94   \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((1, 1), \'0\'), np.full((2, 1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_different_height_matrices_mirror(self):\n        expected = (\n            ""\xe2\x94\x8c   \xe2\x94\x90 \xe2\x94\x8c   \xe2\x94\x90\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82 \xe2\x94\x82 0 \xe2\x94\x82\\n""\n            ""\xe2\x94\x82 0 \xe2\x94\x82 \xe2\x94\x94   \xe2\x94\x98\\n""\n            ""\xe2\x94\x94   \xe2\x94\x98      ""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((2, 1), \'0\'), np.full((1, 1), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_two_empty_matrices_with_single_name(self):\n        expected = (\n            ""M        \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 names=[\'M\'])\n        self.assertEqual(expected, actual)\n\n\n    def test_two_empty_matrices_with_names(self):\n        expected = (\n            ""M    N   \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98 \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 names=[\'M\', \'N\'])\n        self.assertEqual(expected, actual)\n\n    def test_two_empty_matrices_with_long_names(self):\n        expected = (\n            ""M_x_y N   \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90  \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98  \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 names=[\'M_x_y\', \'N\'])\n        self.assertEqual(expected, actual)\n\n    def test_two_empty_matrices_with_dimensions(self):\n        expected = (\n            ""(0x0) (0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90  \xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98  \xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_two_empty_matrices_with_dimensions_and_names(self):\n        expected = (\n            ""M     N    \\n""\n            ""(0x0) (0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90  \xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98  \xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 names=[\'M\', \'N\'],\n                                                 include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_two_empty_matrices_with_dimensions_and_long_names(self):\n        expected = (\n            ""M_x_y_z N    \\n""\n            ""(0x0)   (0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90    \xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98    \xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.matrices_to_string(np.full((0, 0), \'\'),\n                                                 np.full((0, 0), \'\'),\n                                                 names=[\'M_x_y_z\', \'N\'],\n                                                 include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_too_many_names(self):\n        with self.assertRaises(ValueError):\n            prettymatrix.matrices_to_string(np.full((0, 0), \'0\'),\n                                            names=[\'M\', \'N\'])\n\n\nclass ExpressionToStringTest(unittest.TestCase):\n\n    def test_dot_product(self):\n        expected = (\n            "".""\n        )\n        actual = prettymatrix.expression_to_string(prettymatrix.DOT)\n        self.assertEqual(expected, actual)\n\n    def test_plus(self):\n        expected = (\n            ""+""\n        )\n        actual = prettymatrix.expression_to_string(prettymatrix.PLUS)\n        self.assertEqual(expected, actual)\n\n    def test_minus(self):\n        expected = (\n            ""-""\n        )\n        actual = prettymatrix.expression_to_string(prettymatrix.MINUS)\n        self.assertEqual(expected, actual)\n\n    def test_hadamard(self):\n        expected = (\n            ""\xe2\x88\x98""\n        )\n        actual = prettymatrix.expression_to_string(prettymatrix.HADAMARD)\n        self.assertEqual(expected, actual)\n\n    def test_dot_product_of_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 . \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.DOT,\n                                                   np.full((0, 0), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_hadamard_product_of_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 \xe2\x88\x98 \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.HADAMARD,\n                                                   np.full((0, 0), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_addition_of_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 + \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.PLUS,\n                                                   np.full((0, 0), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_subtraction_of_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 - \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.MINUS,\n                                                   np.full((0, 0), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_equality_of_two_empty_matrices(self):\n        expected = (\n            ""\xe2\x94\x8c  \xe2\x94\x90 = \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.EQUALS,\n                                                   np.full((0, 0), \'0\'))\n        self.assertEqual(expected, actual)\n\n    def test_expression_with_one_name(self):\n        expected = (\n            ""W          \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 . \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.DOT,\n                                                   np.full((0, 0), \'0\'),\n                                                   names=[\'W\'])\n        self.assertEqual(expected, actual)\n\n    def test_expression_with_two_names(self):\n        expected = (\n            ""M      N   \\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90 . \xe2\x94\x8c  \xe2\x94\x90\\n""\n            ""\xe2\x94\x94  \xe2\x94\x98   \xe2\x94\x94  \xe2\x94\x98""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.DOT,\n                                                   np.full((0, 0), \'0\'),\n                                                   names=[\'M\', \'N\'])\n        self.assertEqual(expected, actual)\n\n    def test_expression_with_dimensions(self):\n        expected = (\n            ""(0x0)   (0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90  . \xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98    \xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.DOT,\n                                                   np.full((0, 0), \'0\'),\n                                                   include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_expression_with_dimensions_and_names(self):\n        expected = (\n            ""M       N    \\n""\n            ""(0x0)   (0x0)\\n""\n            ""\xe2\x94\x8c  \xe2\x94\x90  . \xe2\x94\x8c  \xe2\x94\x90 \\n""\n            ""\xe2\x94\x94  \xe2\x94\x98    \xe2\x94\x94  \xe2\x94\x98 ""\n        )\n        actual = prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                                   prettymatrix.DOT,\n                                                   np.full((0, 0), \'0\'),\n                                                   names=[\'M\', \'N\'],\n                                                   include_dimensions=True)\n        self.assertEqual(expected, actual)\n\n    def test_expression_with_too_many_names(self):\n        with self.assertRaises(ValueError):\n            prettymatrix.expression_to_string(np.full((0, 0), \'0\'),\n                                              names=[\'M\', \'N\'])\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
