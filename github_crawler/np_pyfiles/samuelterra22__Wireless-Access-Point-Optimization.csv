file_path,api_count,code
main.py,21,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nimport random as rd\nimport sys\nfrom random import random\n\nimport ezdxf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pygame\nfrom colour import Color\nfrom math import sqrt, log10, exp\nfrom numba import cuda, jit\n\nfrom utils.propagations_models import five_par_log_model\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_file_path, dxf_scale):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_scale:\n    :param dxf_file_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_file_path)\n\n    dxf_walls = []\n\n    model_space = dwg.modelspace()\n\n    min_x = -1\n    min_y = -1\n    for e in model_space:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < min_x or min_x == -1:\n                min_x = e.dxf.start[0]\n            if e.dxf.start[1] < min_y or min_y == -1:\n                min_y = e.dxf.start[1]\n\n    for e in model_space:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - min_x) * dxf_scale),\n                int((e.dxf.start[1] - min_y) * dxf_scale),\n                int((e.dxf.end[0] - min_x) * dxf_scale),\n                int((e.dxf.end[1] - min_y) * dxf_scale)\n            ]\n            dxf_walls.append(line)\n\n    return dxf_walls\n\n\n@jit\ndef side(a_x, a_y, b_x, b_y, c_x, c_y):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param c_y:\n    :param c_x:\n    :param b_y:\n    :param b_x:\n    :param a_y:\n    :param a_x:\n    :return:\n    """"""\n    d = (c_y - a_y) * (b_x - a_x) - (b_y - a_y) * (c_x - a_x)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(a_x, a_y, b_x, b_y, c_x, c_y):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param c_y:\n    :param c_x:\n    :param b_y:\n    :param b_x:\n    :param a_y:\n    :param a_x:\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if a_x < b_x:\n        return a_x <= c_x <= b_x\n    if b_x < a_x:\n        return b_x <= c_x <= a_x\n\n    if a_y < b_y:\n        return a_y <= c_y <= b_y\n    if b_y < a_y:\n        return b_y <= c_y <= a_y\n\n    return a_x == c_x and a_y == c_y\n\n\n@jit\ndef closed_segment_intersect(a_x, a_y, b_x, b_y, c_x, c_y, d_x, d_y):\n    """"""\n    Verifies if closed segments a, b, c, d do intersect.\n    :param a_x:\n    :param a_y:\n    :param b_x:\n    :param b_y:\n    :param c_x:\n    :param c_y:\n    :param d_x:\n    :param d_y:\n    :return:\n    """"""\n    if (a_x == b_x) and (a_y == b_y):\n        return (a_x == c_x and a_y == c_y) or (a_x == d_x and a_y == d_y)\n    if (c_x == d_x) and (c_y == d_y):\n        return (c_x == a_x and c_y == a_y) or (c_x == b_x and c_y == b_y)\n\n    s1 = side(a_x, a_y, b_x, b_y, c_x, c_y)\n    s2 = side(a_x, a_y, b_x, b_y, d_x, d_y)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        return \\\n            is_point_in_closed_segment(a_x, a_y, b_x, b_y, c_x, c_y) or is_point_in_closed_segment(a_x, a_y, b_x, b_y,\n                                                                                                   d_x, d_y) or \\\n            is_point_in_closed_segment(c_x, c_y, d_x, d_y, a_x, a_y) or is_point_in_closed_segment(c_x, c_y, d_x, d_y,\n                                                                                                   b_x, b_y)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(c_x, c_y, d_x, d_y, a_x, a_y)\n    s2 = side(c_x, c_y, d_x, d_y, b_x, b_y)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n@jit\ndef absorption_in_walls(ap_x, ap_y, destiny_x, destiny_y, floor_plan_model):\n    intersections = 0\n\n    size = len(floor_plan_model)\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(ap_x, ap_y, destiny_x, destiny_y, floor_plan_model[i][0], floor_plan_model[i][1],\n                                    floor_plan_model[i][2],\n                                    floor_plan_model[i][3]):\n            intersections += 1\n\n    intersections_with_walls = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precision em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    # dbm_absorbed_by_wall = 8 ## AGORA \xc3\x89 UMA CONSTANTE GLOBAL\n\n    return intersections_with_walls * dbm_absorbed_by_wall\n\n\n@jit\ndef mw_to_dbm(mw):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mw: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mw)\n\n\n@jit\ndef dbm_to_mw(dbm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dbm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dbm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precision\n\n\n@jit\ndef propagation_model(x, y, ap_x, ap_y, floor_plan_model):\n    d = calc_distance(x, y, ap_x, ap_y)\n\n    loss_in_wall = absorption_in_walls(ap_x, ap_y, x, y, floor_plan_model)\n\n    if d == 0:\n        d = 1\n\n    # CUIDADO: um modelo de propaga\xc3\xa7\xc3\xa3o pessimista prende o SA se a FO n\xc3\xa3o for ajustada\n\n    # value = log_distance(d, 3, 11, -72, pt_dbm) - loss_in_wall\n    # value = log_distance(d, 3,  1, -60, pt_dbm) - loss_in_wall\n    # value = log_distance(d, 3, 10, -69, pt_dbm) - loss_in_wall\n    value = five_par_log_model(pt_dbm, d) - loss_in_wall\n    # value = four_par_log(pt_dbm, d) - loss_in_wall\n\n    # TODO teste\n    # return dbm_to_mw(value)\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    # TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    # Desabilitado pois \'ficou pesado\'.\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < SENSITIVITY:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n\n    # TODO: Penalizar os valores que est\xc3\xa3o abaixo da sensibilidade.\n    # fo = abs(np.sum(matrix))\n\n    # acima da sensibilidade\n    fo = 0\n    for line in matrix:\n        for value in line:\n            if value >= SENSITIVITY:\n                fo += 1\n\n    coverage_percent = (fo / TOTAL_OF_POINTS) * 100  # porcentagem de cobertura\n    shadow_percent = 100 - coverage_percent  # porcentagem de sombra\n\n    # return coverage_percent \t\t\t\t\t ## maximiza a cobertura\n    # return (-1 * pow(shadow_percent,2))\t\t\t ## miminiza as sombras, penalizadas\n    # return pow(coverage_percent,2)\t\t\t\t ## maximiza a cobertura, difereciando mais os bons resultados\n\n    # return ( 2*coverage_percent - shadow_percent )\n\n    fo_alpha = 7\n    return fo_alpha * coverage_percent - (10 - fo_alpha) * shadow_percent  # pesos 7 pra 3\n    # return (0.7 * coverage_percent - 0.3 * shadow_percent)  # pesos 7 pra 3\n\n    # TODO testing VALADAO\n    # return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@cuda.jit\ndef objective_function_kernel(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param soma:\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    matrix_width = len(matrix)\n    matrix_height = len(matrix[0])\n\n    start_x, start_y = cuda.grid(2)\n    grid_x = cuda.gridDim.x * cuda.blockDim.x\n    grid_y = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(start_x, matrix_width, grid_x):\n        for y in range(start_y, matrix_height, grid_y):\n            soma += matrix[x][y]\n\n            #         if matrix[x][y] >= SENSITIVITY:\n            #             soma += 1\n\n            # soma = ((soma / TOTAL_OF_POINTS) * 100)\n\n\n@cuda.jit\ndef simulate_kernel(ap_x, ap_y, matrix_results, floor_plan_model):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan_model:\n    :param ap_y:\n    :param ap_x:\n    :param matrix_results:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    start_x, start_y = cuda.grid(2)\n    grid_x = cuda.gridDim.x * cuda.blockDim.x\n    grid_y = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(start_x, WIDTH, grid_x):\n        for y in range(start_y, HEIGHT, grid_y):\n            matrix_results[x][y] = propagation_model_gpu(x, y, ap_x, ap_y, floor_plan_model)\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n\n@jit\ndef simulate_cpu(ap_x, ap_y, matrix_results, floor_plan_model):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan_model:\n    :param matrix_results:\n    :param ap_y:\n    :param ap_x:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            matrix_results[x][y] = propagation_model(x, y, ap_x, ap_y, floor_plan_model)\n\n    return matrix_results\n\n\n@jit\ndef get_point_in_circle(point_x, point_y, ray):\n    """"""\n    M\xc3\xa9todo reponsavel por retornar um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point_y:\n    :param point_x:\n    :param ray: Valor do raio desejado.\n    valores discretos para posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xb5es da matriz.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n    num = 1\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + point_x\n    y = r * np.sin(t) + point_y\n\n    # Converte todos os valores negativos da lista em positivos\n\n    x = round(abs(x[0]))\n    y = round(abs(y[0]))\n\n    # Verifica se o valor estrapolou as dimens\xc3\xb5es da simula\xc3\xa7\xc3\xa3o\n    if x > WIDTH:\n        x = WIDTH\n\n    if y > HEIGHT:\n        y = HEIGHT\n\n    return list([x, y])\n\n\n@jit\ndef disturb_array(s_array, size):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param size:\n    :param s_array:\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    new_s = np.empty([num_aps, 2], np.float32)\n\n    for i in range(size):\n        # Obtem um ponto aleatorio em um raio de X metros\n        new_s[i] = get_point_in_circle(s_array[i][0], s_array[i][1], DISTURBANCE_RADIUS)\n\n    return new_s\n\n\n@jit\ndef disturb_solution(solution):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param solution: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n\n    return get_point_in_circle(solution[0], solution[1], DISTURBANCE_RADIUS)\n\n\n@jit\ndef evaluate_array(s_array, size):\n    propagation_matrices = []\n    for i in range(size):\n        propagation_matrices.append(simulates_propagation(s_array[i][0], s_array[i][1]))\n\n    # simplesmente guloso VALADAO testing\n    overlaid_matrix = solution_overlap_max(propagation_matrices, size)\n\n    # penaliza APs muito proximos (CUIDADO: junto com FO % de cobertura prender o SA)\n    # overlaid_matrix = solution_overlap_div_dbm(propagation_matrices, size)\n\n    return objective_function(overlaid_matrix), propagation_matrices\n\n\n@jit\ndef solution_overlap_max(propagation_array, size):\n    max_value = propagation_array[0]\n    for i in range(1, size):\n        max_value = np.maximum(propagation_array[i], max_value)\n\n    return max_value\n\n\n@jit\ndef solution_overlap_sub(propagation_array, size):\n    sub = propagation_array[0]\n    for i in range(1, size):\n        sub = np.subtract(propagation_array[i], sub)\n\n    return sub\n\n\n@jit\ndef solution_overlap_div_dbm(propagation_array, size):\n    # verificar se \xc3\xa9 veridico\n    if size == 1:\n        return propagation_array[0]\n\n    matrix_min_x = propagation_array[0]\n    matrix_max = propagation_array[0]\n\n    for i in range(1, size):\n        matrix_min_x = np.minimum(propagation_array[i], matrix_min_x)\n        matrix_max = np.maximum(propagation_array[i], matrix_max)\n\n    # pois ao subtrair dbm, deve ser o maior/menor\n    sub = np.divide(matrix_max, matrix_min_x)\n\n    return sub\n\n\n@jit\ndef simulates_propagation_cpu(ap_x, ap_y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param ap_y:\n    :param ap_x:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    matrix_results = np.empty([WIDTH, HEIGHT], np.float32)\n\n    return simulate_cpu(ap_x, ap_y, matrix_results, floor_plan)\n\n\n@jit\ndef simulates_propagation_gpu(point_x, point_y):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param point_x:\n    :param point_y: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n    block_dim = (48, 8)\n    grid_dim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[grid_dim, block_dim](point_x, point_y, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return g_matrix\n\n\n@jit\ndef simulates_propagation(point_x, point_y):\n    """"""\n    M\xc3\xa9todo respos\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o de acordo com o ambiente escolhido (CPU ou GPU)\n    :param point_x:\n    :param point_y:\n    :return:\n    """"""\n\n    if ENVIRONMENT == ""GPU"":\n        # with GPU CUDA Threads\n        return simulates_propagation_gpu(point_x, point_y)\n\n    elif ENVIRONMENT == ""CPU"":\n        #  with CPU Threads\n        return simulates_propagation_cpu(point_x, point_y)\n    else:\n        # exit(-1)\n        sys.exit(""(ERROR) Nenhum ambiente de execu\xc3\xa7\xc3\xa3o bem definido."")\n\n\n@jit\ndef objective_function_mw(array_matrix):\n    matrix = solution_overlap_max(array_matrix, len(array_matrix))\n\n    sum_matrix = 0\n\n    for line in matrix:\n        for value in line:\n            sum_matrix += dbm_to_mw(value)\n\n    return sum_matrix\n\n\ndef simulated_annealing(size, M, P, L, T0, alpha):\n    """"""\n    :param size:\n    :param T0: Temperatura inicial.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es.\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o.\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o.\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura.\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n\n    # cria Solu\xc3\xa7\xc3\xb5es iniciais com pontos aleat\xc3\xb3rios para os APs\n    s_array = np.empty([size, 2], np.float32)\n\n    for i in range(size):  # VALADAO testing\n        if INITIAL_POSITION == RANDOM:\n            s_array[i] = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n        elif INITIAL_POSITION == CENTER:\n            s_array[i] = [WIDTH * 0.5, HEIGHT * 0.5]\n\n    s0 = s_array.copy()\n    print(""Solu\xc3\xa7\xc3\xa3o inicial:\\n"" + str(s0))\n\n    result = evaluate_array(s_array, size)\n    f_s = result[0]\n\n    T = T0\n    j = 1\n\n    i_ap = 0\n\n    # Armazena a MELHOR solu\xc3\xa7\xc3\xa3o encontrada\n    best_s_array = s_array.copy()\n    best_fs = f_s\n    # BEST_matrix_FO = result[1]\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        n_success = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            initial_solutions_array = s_array.copy()\n\n            # a cada itera\xc3\xa7\xc3\xa3o do SA, disturb_solution um dos APs\n            i_ap = (i_ap + 1) % num_aps\n\n            initial_solutions_array[i_ap] = disturb_solution(s_array[i_ap])\n\n            # retorna a FO e suas matrizes\n            result = evaluate_array(initial_solutions_array, num_aps)\n            f_si = result[0]\n            # matrix_FO = result[1]\n\n            # Cuidado pois fica demasiado lento o desempenho do SA\n            # if ANIMATION_STEP_BY_STEP:\n            #   show_solution(s_array, py_game_display_surf)\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            delta_fi = f_si - f_s\n\n            # Minimiza\xc3\xa7\xc3\xa3o: delta_fi >= 0\n            # Maximiza\xc3\xa7\xc3\xa3o: delta_fi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (delta_fi <= 0) or (exp(-delta_fi / T) > random()):\n\n                s_array = initial_solutions_array.copy()\n                f_s = f_si\n\n                n_success = n_success + 1\n\n                # Cuidado pois fica demasiado lento o desempenho do SA\n                # if ANIMATION_BEST_PLACES:\n                #   show_solution(s_array, py_game_display_surf)\n\n                if f_s > best_fs:\n                    best_fs = f_s\n                    best_s_array = s_array.copy()\n\n                    if ANIMATION_BESTS:\n                        show_solution(s_array, py_game_display_surf)\n\n                FOs.append(f_s)\n\n            i = i + 1\n\n            if (n_success >= L) or (i > P):\n                break\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (n_success == 0) or (j > M):\n            break\n\n    print(""Dist\xc3\xa2ncia da solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(solution_overlap_sub(s_array, num_aps)))\n\n    print(""FO last cand:   "" + \'{:.3e}\'.format(float(f_si)))\n    print(""FO local best:  "" + \'{:.3e}\'.format(float(f_s)))\n    print(""FO global best: "" + \'{:.3e}\'.format(float(best_fs)))\n\n    # FOs.append( objective_function_mw(BEST_matrix_FO) )\n    # FOs.append( mw_to_dbm(objective_function_mw(BEST_matrix_FO)) )\n    FOs.append(best_fs)\n\n    return best_s_array\n\n\ndef hex_to_rgb(hex_value):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex_value: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    hex_value = str(hex_value).lstrip(\'#\')\n    lv = len(hex_value)\n    return tuple(int(hex_value[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n\ndef draw_line(py_game_display_surf_value, x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param py_game_display_surf_value:\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(py_game_display_surf_value, color, (x1, y1), (x2, y2))\n\n\ndef print_py_game(matrix_results, access_points, py_game_display_surf_value):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param py_game_display_surf_value:\n    :param access_points:\n    :param matrix_results: Matrix float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :return: None.\n    """"""\n\n    matrix_max_value = matrix_results.max()\n\n    # matrix_max_value = -30\n    matrix_min_value = -100\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_results[x][y], matrix_max_value, matrix_min_value)\n            draw_point(py_game_display_surf_value, color, x, y)\n\n    # Printa de vermelho a posi\xc3\xa7\xc3\xa3o dos Access Points\n    for ap in access_points:\n        draw_point(py_game_display_surf_value, RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(py_game_display_surf_value, color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param py_game_display_surf_value:\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(py_game_display_surf_value, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan_model):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por obter as dimen\xc3\xa7\xc3\xb5es da planta\n    :param floor_plan_model:\n    :return:\n    """"""\n    x_max = y_max = 0\n\n    for lines in floor_plan_model:\n        if lines[0] > x_max:\n            x_max = lines[0]\n        if lines[2] > x_max:\n            x_max = lines[2]\n\n        if lines[1] > y_max:\n            y_max = lines[1]\n        if lines[3] > y_max:\n            y_max = lines[3]\n\n    return [x_max, y_max]\n\n\ndef draw_floor_plan(floor_plan_model, py_game_display_surf_value):\n    for line in floor_plan_model:\n        draw_line(py_game_display_surf_value, line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min_value, max_value, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min_value: Valor m\xc3\xadnimo do intervalo.\n    :param max_value: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    return ((x - min_value) / (max_value - min_value)) * 100\n\n\ndef get_value_in_list(percent, list_numbers):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list_numbers: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list_numbers)\n    if position < 1:\n        position = 1\n    elif position >= len(list_numbers):\n        position = len(list_numbers)\n    return hex_to_rgb(list_numbers[int(position - 1)])\n\n\ndef get_color_of_interval(x, max_value=-30, min_value=-100):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min_value: Valor m\xc3\xadnimo do intervalo.\n    :param max_value: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n\n    if PAINT_BLACK_BELOW_SENSITIVITY and x < SENSITIVITY:\n        return BLACK\n\n    percentage = get_percentage_of_range(min_value, max_value, x)\n    color = get_value_in_list(percentage, COLORS)\n\n    return color\n\n\ndef show_solution(s_array, py_game_display_surf_value):\n    propagation_matrices = []\n\n    for i in range(len(s_array)):\n        propagation_matrices.append(simulates_propagation(s_array[i][0], s_array[i][1]))\n\n    # propagation = solution_overlap_ADD(propagation_matrices, len(s_array))\n    propagation = solution_overlap_max(propagation_matrices, len(s_array))\n\n    # generate_summary(s_array)\n\n    print_py_game(propagation, s_array, py_game_display_surf_value)\n\n    draw_floor_plan(walls, py_game_display_surf_value)\n\n    pygame.display.update()\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n    return cores\n\n\ndef show_configs():\n    print(""\\nOtimizacao via Simulated Annealing com a seguinte configuracao:"" + ""\\n"")\n    print(""\\tNumero maximo de iteracoes:\\t\\t\\t"" + str(max_inter))\n    print(""\\tNumero maximo de pertubacoes por iteracao:\\t"" + str(max_disturbances))\n    print(""\\tNumero maximo de sucessos por iteracao:\\t\\t"" + str(num_max_success))\n    print(""\\tTemperatura inicial:\\t\\t\\t\\t"" + str(initial_temperature))\n    print(""\\tDecaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""\\tRaio de perturbacao:\\t\\t\\t\\t"" + str(int(DISTURBANCE_RADIUS)))\n\n    print(""\\tExecucoes do otimziador: \\t\\t\\t"" + str(max_SA))\n    print(""\\nHardware de simulacao:\\t"" + str(ENVIRONMENT) + ""\\n"")\n\n    print(""\\nSimulacao do ambiente com a seguinte configuracao:"" + ""\\n"")\n    print(""\\tSimulando ambiente com:  \\t\\t"" + str(WIDTH) + "" x "" + str(HEIGHT) + "" pixels"")\n    print(""\\tEscala de simulacao:     \\t\\t1 px : "" + \'{:.4f}\'.format(float((1 / scale))) + "" metros"")\n\n    print(""\\tQuantidade de APs:       \\t\\t"" + str(num_aps))\n    print(""\\tPotencia de cada APs:    \\t\\t"" + str(pt_dbm) + "" dBm"")\n\n    if INITIAL_POSITION == RANDOM:\n        print(""\\tPosicao inicial dos APs: \\t\\tALEATORIA"")\n    elif INITIAL_POSITION == CENTER:\n        print(""\\tPosicao inicial dos APs: \\t\\tCENTRALIZADA (W/2, H/2)"")\n    elif INITIAL_POSITION == CUSTOM:\n        print(""\\tPosicao inicial dos APs: \\t\\tCUSTOMIZADA"")\n\n\ndef run():\n    best_solution = simulated_annealing(num_aps, max_inter, max_disturbances, num_max_success, initial_temperature,\n                                        alpha)\n    evaluate_array(best_solution, len(best_solution))\n\n    # Gera resumo da simula\xc3\xa7\xc3\xa3o\n    generate_summary(best_solution)\n\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o..."")\n    if ANIMATION_STEP_BY_STEP or ANIMATION_BEST_PLACES or ANIMATION_BESTS:\n        show_solution(best_solution, py_game_display_surf)\n\n\ndef fixed_aps(best_solution):\n    evaluate_array(best_solution, len(best_solution))\n\n    # Gera resumo da simula\xc3\xa7\xc3\xa3o\n    generate_summary(best_solution)\n\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o..."")\n    if ANIMATION_STEP_BY_STEP or ANIMATION_BEST_PLACES or ANIMATION_BESTS:\n        show_solution(best_solution, py_game_display_surf)\n\n\ndef test_propagation():\n    """"""\n    M\xc3\xa9todo usado apenas para fim de testes com a simula\xc3\xa7\xc3\xa3o em pontos espec\xc3\xadficos.\n    :return: None.\n    """"""\n    test_ap_in_the_middle = [[int(WIDTH / 2), int(HEIGHT / 2)]]\n\n    #\n    if ANIMATION_STEP_BY_STEP or ANIMATION_BEST_PLACES or ANIMATION_BESTS:\n        # Initialize PyGame\n        pygame.init()\n\n        # Set window size\n        py_game_display_surf_value = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n        show_solution(test_ap_in_the_middle, py_game_display_surf_value)\n\n\ndef generate_summary(s_array):\n    length = len(s_array)\n\n    print(""\\n****** Gerando sumarios dos resultados da simulacao ******"")\n    print(""Numero de APs:\\t"" + str(length))\n    print(""Solu\xc3\xa7\xc3\xa3o: "", s_array)\n\n    propagation_matrices = []\n    for i in range(length):\n        propagation_matrices.append(simulates_propagation(s_array[i][0], s_array[i][1]))\n\n    matrix = solution_overlap_max(propagation_matrices, length)\n\n    above_sensitivity = [value for line in matrix for value in line if value >= SENSITIVITY]\n    under_sensitivity = [value for line in matrix for value in line if value < SENSITIVITY]\n\n    total = WIDTH * HEIGHT\n\n    percent_cover_above_sensitivity = (len(above_sensitivity) / total) * 100\n    percent_cover_under_sensitivity = (len(under_sensitivity) / total) * 100\n\n    print(""\\nCOBERTURA DE SINAL WI-FI:"")\n    print(""\\t"" + \'{:.2f}\'.format(float(percent_cover_above_sensitivity)) + ""%\\t com boa cobertura (sinal forte)"")\n    print(""\\t"" + \'{:.2f}\'.format(\n        float(percent_cover_under_sensitivity)) + ""%\\t de zonas de sombra (abaixo da sensibilidade)"")\n\n    range_1 = range_2 = range_3 = faixa4 = 0\n\n    for line in matrix:\n        for value in line:\n            if value >= -67:  # \xc3\xb3timo\n                range_1 += 1\n\n            elif -67 > value >= -77:  # bom\n                range_2 += 1\n\n            elif -77 > value >= SENSITIVITY:  # ruim\n                range_3 += 1\n\n            elif value < SENSITIVITY:  # sem conectividade (zona de sombra)\n                faixa4 += 1\n\n    total = range_1 + range_2 + range_3 + faixa4  # deveria ser igual a WIDTH * HEIGHT\n\n    percent_range_1 = range_1 / total * 100\n    percent_range_2 = range_2 / total * 100\n    percent_range_3 = range_3 / total * 100\n\n    print(""\\n\\tCobertura por FAIXAS de intensidade de sinal"")\n    print(""\\t\\tsinal Otimo  \\t"" + \'{:.1f}\'.format(float(percent_range_1)) + ""%"")\n    print(""\\t\\tsinal Bom    \\t"" + \'{:.1f}\'.format(float(percent_range_2)) + ""%"")\n    print(""\\t\\tsinal Ruim   \\t"" + \'{:.1f}\'.format(float(percent_range_3)) + ""%"")\n\n    if FOs:\n        # Plota gr\xc3\xa1fico da fun\xc3\xa7\xc3\xa3o objetivo\n        print(""\\n... gerando grafico do comportamento da FO."")\n        plt.plot(FOs)\n        plt.title(""Comportamento do Simulated Annealing"")\n        plt.ylabel(\'Valor da FO\')\n        plt.xlabel(\'Solucao candidata\')\n        plt.show()\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DOS EQUIPAMENTOS\n\n    # OBS.: por conta da precision de casas decimais do float\n    #        \xc3\xa9 melhor pegar a ordem de magnitude com o dBm do\n    #        que tentar usar o valor exato com mW\n\n    # Sensibilidade dos equipamentos receptores\n    SENSITIVITY = -90\n\n    # Gradiente de cores da visualiza\xc3\xa7\xc3\xa3o gr\xc3\xa1fica\n    COLORS = get_color_gradient(16)  # 64, 32, 24, 16, 8\n\n    PAINT_BLACK_BELOW_SENSITIVITY = True\n    # PAINT_BLACK_BELOW_SENSITIVITY = False\n\n    DBM_MIN_VALUE = np.finfo(np.float32).min\n\n    # parede de concredo, de 8 a 15 dB.\n    dbm_absorbed_by_wall = 8\n\n    # Pot\xc3\xaancia de transmiss\xc3\xa3o de cada AP\n    # pt_dbm = -14\n    # pt_dbm = -17\n    # pt_dbm = -20\n    pt_dbm = -25\n    # pt_dbm = -30\n\n    # Quantidade de APs\n    num_aps = 3\n\n    # Constantes para controle da estrat\xc3\xa9gia de posi\xc3\xa7\xc3\xa3o inicial dos APs\n    RANDOM = 0\n    CENTER = 1\n    CUSTOM = 3\n    INITIAL_POSITION = CENTER\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE E PLANTA-BAIXA\n\n    LENGTH_BLOCK_A = 48.0\n    LENGTH_BLOCK_B = 36.0\n    LENGTH_BLOCK_C = 51.0\n\n    LENGTH_BUILDING = LENGTH_BLOCK_A\n    # LARGURA_EDIFICIO = ???\n\n    # dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n    dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n    # carrega para saber o comprimento da planta\n    walls = read_walls_from_dxf(dxf_path, 1)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    floor_plan_length = floor_size[0]\n    floor_plan_width = floor_size[1]\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE SIMULADO\n\n    ENVIRONMENT = ""GPU""\n    # ENVIRONMENT = ""CPU""\n\n    # Tamanho da simula\xc3\xa7\xc3\xa3o\n    # SIMULATION_SIZE = 400\n    SIMULATION_SIZE = 600\n\n    # Ativa / Desativa a anima\xc3\xa7\xc3\xa3o passo a passo da otimiza\xc3\xa7\xc3\xa3o\n    # ANIMATION_STEP_BY_STEP   = True\n    ANIMATION_STEP_BY_STEP = False\n\n    # ANIMATION_BEST_PLACES = True\n    ANIMATION_BEST_PLACES = False\n\n    ANIMATION_BESTS = True\n    # ANIMATION_BESTS = False\n\n    ##################################################\n\n    # Lista para guardar as fun\xc3\xa7\xc3\xb5es objetivos calculadas durante a simula\xc3\xa7\xc3\xa3o\n    FOs = []\n\n    WIDTH = SIMULATION_SIZE\n    HEIGHT = int(WIDTH * (floor_plan_width / floor_plan_length))\n    scale = WIDTH / floor_plan_length\n    precision = LENGTH_BUILDING / WIDTH\n\n    TOTAL_OF_POINTS = WIDTH * HEIGHT\n\n    # HEIGHT = SIMULATION_SIZE\n    # WIDTH = int(HEIGHT * (floor_plan_length / floor_plan_width))\n    # scale = HEIGHT / floor_plan_width\n    # precision = LARGURA_EDIFICIO / WIDTH\n\n    # RE-carrega utilizando a escala apropriada\n    walls = read_walls_from_dxf(dxf_path, scale)\n    floor_plan = np.array(walls, dtype=np.float32)\n    ##################################################\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO OTIMIZADOR\n\n    # fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600\n    # max_inter = 600 * (1 + num_aps)\n    # max_inter = 600 * (10 * num_aps)\n    # max_inter = TOTAL_OF_POINTS * 0.2\n\n    # p - M\xc3\xa1ximo de perturba\xc3\xa7\xc3\xb5es\n    max_disturbances = 5\n\n    # DISTURBANCE_RADIUS = WIDTH * 0.0100\n    # DISTURBANCE_RADIUS = WIDTH * 0.0175\n    # DISTURBANCE_RADIUS = WIDTH * 0.0250\n    # DISTURBANCE_RADIUS = WIDTH * 0.1100\n    beta = 1\n    DISTURBANCE_RADIUS = (1 / precision) * (beta + num_aps)  # VALADAO testing\n    # DISTURBANCE_RADIUS = (1 / precision) * (1 + num_aps)  # VALADAO testing\n\n    # v - M\xc3\xa1ximo de vizinhos\n    # num_max_success = 80\n    # num_max_success = 80 * 10\n    # num_max_success = 80 * (beta + num_aps) * 3\n    num_max_success = 240 * (beta + num_aps)\n\n    # a - Alpha\n    alpha = .85\n    # alpha = .95\n\n    # t - Temperatura\n    initial_temperature = 300 * (beta + num_aps)\n    # initial_temperature = 300 * (1 + num_aps) * 10\n\n    # M\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n    ##################################################\n\n    # Visualiza\xc3\xa7\xc3\xa3o dos dados\n    # Inicia o PyGame e configura o tamanho da janela\n\n    # ANIMATION_STEP_BY_STEP   = True\n\n    # S\xc3\xb3 inicializa a janela do PyGame se alguma flag estiver ativa\n    if ANIMATION_STEP_BY_STEP or ANIMATION_BEST_PLACES or ANIMATION_BESTS:\n        pygame.init()\n        icon = pygame.image.load(\'images/icon.png\')\n        pygame.display.set_icon(icon)\n        pygame.display.set_caption(""Resultado Simula\xc3\xa7\xc3\xa3o - IFMG Campus Formiga"")\n        py_game_display_surf = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n\n    show_configs()\n    # test_propagation()\n    run()\n    # fixed_aps([[1., 210.], [300., 225.], [385., 225.], [540, 225]])\n    #\n    # best_solution = [\n    #     [WIDTH * 0.5, HEIGHT * 0.5]\n    # ]\n    #\n    # show_solution(best_solution, py_game_display_surf)\n\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    # cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    # python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    # cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n\n    # generate_summary([[50, 50]])\n\n    input(\'\\nAperte ESC para fechar a simula\xc3\xa7\xc3\xa3o.\')\n\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    # cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    # python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    # cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n'"
CAD/__init__.py,0,b''
CAD/cad.py,0,"b'import ezdxf\n\n# dwg = ezdxf.readfile(""../DXFs/bloco-A.dxf"")\n# dwg = ezdxf.readfile(""../DXFs/bloco-A-l.dxf"")\n# dwg = ezdxf.readfile(""../DXFs/bloco-A-c.dxf"")\n# dwg = ezdxf.readfile(""../DXFs/retangulo1.dxf"")\ndwg = ezdxf.readfile(""../DXFs/bloco-a-linhas-sem-porta.dxf"")\n\nmodelspace = dwg.modelspace()\n\nsaida_pygame = \'\'\n\nescala = 25\n\n\nxMin = -1\nyMin = -1\nfor e in modelspace:\n    if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n        if e.dxf.start[0] < xMin or xMin == -1:\n            xMin = e.dxf.start[0]\n        if e.dxf.start[1] < yMin or yMin == -1:\n            yMin = e.dxf.start[1]\n\n\nfor e in modelspace:\n    if e.dxftype() == \'LINE\':\n        if e.dxf.layer == \'ARQ\':\n            # print(""LINE on layer: %s\\n"" % str(e.dxf.layer))\n            # print(""start point: %s\\n"" % str(e.dxf.start))\n            # print(""end point: %s\\n"" % str(e.dxf.end))\n            #teste += \'draw.line(((\'+str(e.dxf.start[0]*tam)+\', \'+str(e.dxf.start[1]*tam)+\'), (\'+str(e.dxf.end[0]*tam)+\', \'+str(e.dxf.end[1]*tam)+\')), fill=128, width=3)\\n\'\n            saida_pygame += \'pygame.draw.line(DISPLAYSURF, BLUE, (\'+str(int((e.dxf.start[0]-xMin)*escala))+\', \'+str(int((e.dxf.start[1]-yMin)*escala))+\'), (\'+str(int((e.dxf.end[0]-xMin)*escala))+\', \'+str(int((e.dxf.end[1]-yMin)*escala))+\'))\\n\'\n\n# for e in dwg.entities:\n#     print(""DXF Entity: %s\\n"" % e.dxftype())\n\n# for layer in dwg.layers:\n#     if layer.dxf.name != \'0\':\n#         layer.off()  # switch all layers off except layer \'0\'\n#         print(layer.dxf.name)\n\nf = open(\'saida\', \'w\')\nf.write(saida_pygame)\nf.close()\n\n'"
CAD/draw.py,0,"b""#from PIL import Image, ImageDraw\n\n#im = Image.new('RGBA', (1000, 500), (0, 255, 0, 0))\n#draw = ImageDraw.Draw(im)\n# draw.line(((0, 0), (100, 100)), fill=64)\n\n#im.show()\n\n\nimport pygame\nimport sys\nimport time\nfrom pygame.locals import *\n\npygame.init()\n\n# set up the window\nDISPLAYSURF = pygame.display.set_mode((2000, 900), 0, 32)\npygame.display.set_caption('Drawing')\n\n# set up the colors\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\n# draw on the surface object\n# pygame.draw.line(DISPLAYSURF, BLUE, (0, 0), (50, 50))\n# pygame.draw.line(DISPLAYSURF, BLUE, (50, 50), (30, 20))\n\npygame.draw.line(DISPLAYSURF, BLUE, (1015, 462), (1015, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (920, 462), (920, 670))\npygame.draw.line(DISPLAYSURF, BLUE, (569, 374), (569, 0))\npygame.draw.line(DISPLAYSURF, BLUE, (821, 374), (821, 0))\npygame.draw.line(DISPLAYSURF, BLUE, (826, 462), (826, 670))\npygame.draw.line(DISPLAYSURF, BLUE, (0, 374), (569, 375))\npygame.draw.line(DISPLAYSURF, BLUE, (192, 462), (192, 670))\npygame.draw.line(DISPLAYSURF, BLUE, (381, 462), (381, 670))\npygame.draw.line(DISPLAYSURF, BLUE, (821, 0), (569, 0))\npygame.draw.line(DISPLAYSURF, BLUE, (1202, 167), (1202, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (1013, 374), (1013, 167))\npygame.draw.line(DISPLAYSURF, BLUE, (821, 167), (1202, 167))\npygame.draw.line(DISPLAYSURF, BLUE, (1202, 374), (821, 374))\npygame.draw.line(DISPLAYSURF, BLUE, (381, 374), (381, 167))\npygame.draw.line(DISPLAYSURF, BLUE, (192, 167), (192, 374))\npygame.draw.line(DISPLAYSURF, BLUE, (508, 462), (508, 670))\npygame.draw.line(DISPLAYSURF, BLUE, (622, 669), (636, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (636, 462), (636, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (0, 462), (1202, 462))\npygame.draw.line(DISPLAYSURF, BLUE, (0, 670), (1202, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (0, 167), (0, 669))\npygame.draw.line(DISPLAYSURF, BLUE, (569, 167), (0, 167))\n\n\n\npixObj = pygame.PixelArray(DISPLAYSURF)\npixObj[380][280] = BLACK\npixObj[382][282] = BLACK\npixObj[384][284] = BLACK\npixObj[386][286] = BLACK\npixObj[388][288] = BLACK\ndel pixObj\n\n# run the game loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n\n        if event.type == pygame.MOUSEBUTTONUP:\n            print(pygame.mouse.get_pos())\n\n    pygame.display.update()\n    #sleep ou yield\n    time.sleep(5)"""
ProjetoFatorial/ProjetoFatorial2K.py,21,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nimport math\nimport profile\nimport random as rd\nimport cProfile\n\nimport ezdxf\nimport numpy as np\nimport pygame\nimport matplotlib.pyplot as plt\n\nfrom datetime import datetime\n\nfrom math import sqrt, log10, exp\nfrom random import random\n\nfrom colour import Color\nfrom numba import cuda, jit\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path, escala):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param escala:\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    # TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param cY:\n    :param cX:\n    :param bY:\n    :param bX:\n    :param aY:\n    :param aX:\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param cY:\n    :param cX:\n    :param bY:\n    :param bX:\n    :param aY:\n    :param aX:\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """"""\n    Verifies if closed segments a, b, c, d do intersect.\n    :param aX:\n    :param aY:\n    :param bX:\n    :param bY:\n    :param cX:\n    :param cY:\n    :param dX:\n    :param dY:\n    :return:\n    """"""\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precisao em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    # dbm_absorvido_por_parede = 8 ## AGORA \xc3\x89 UMA CONSTANTE GLOBAL\n\n    return intersecoes_com_paredes * dbm_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precisao\n\n\n@jit\ndef log_distance(d, gamma=3, d0=1, Pr_d0=-60, Pt=-17):\n    """"""\n       Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n       e do ganho das antenas transmissora e receptora.\n       Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n       :param Pr_d0:\n       :param Pt:\n       :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n       :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n       :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n       :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n       """"""\n\n    # path_loss(d0) + 10 * gamma * log10(d / d0)\n    # HAVIAMOS CODIFICADO ASSIM PARA ECONOMIZAR 1 SUBTRACAO e 1 VAR\n    # return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    # REESCREVI FACILITAR A COMPREENSAO\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    # return 0 - (PL + 10 * gamma * log10(d / d0) )\n    # return   - (PL + 10 * gamma * log10(d / d0) )\n    # return   -PL   - 10 * gamma * log10(d / d0)\n    # return   -(Pt-Pr0)   - (10 * gamma * log10(d / d0))\n    # return   -Pt + Pr0   - (10 * gamma * log10(d / d0))\n    # return   Pr0  - 10 * gamma * log10(d / d0) - Pt\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef log_distance_v2(d, gamma=3, d0=10, Pr_d0=-69, Pt=-20):\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef two_par_logistic(x):\n    # https://en.wikipedia.org/wiki/Logistic_distribution#Related_distributions\n    return Pt_dBm - (-15.11596 * math.log10(x * 2.1642))\n\n\n@jit\ndef four_par_log(x):\n    A = 79.500\n    B = -38\n    C = -100.000\n    D = 0.0\n    E = 0.005\n\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef five_par_log(x):\n    A = 84.0\n    B = -48\n    C = -121.0\n    D = -5.0\n    E = 0.005\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    ## CUIDADO: um modelo de propaga\xc3\xa7\xc3\xa3o pessimista prende o SA se a FO n\xc3\xa3o for ajustada\n\n    # value = log_distance(d, 3, 11, -72, Pt_dBm) - loss_in_wall\n    # value = log_distance(d, 3,  1, -60, Pt_dBm) - loss_in_wall\n    # value = log_distance(d, 3, 10, -69, Pt_dBm) - loss_in_wall\n    value = five_par_log(d) - loss_in_wall\n    # value = four_par_log(d) - loss_in_wall\n\n    ## TODO teste\n    # return dbm_to_mw(value)\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    # def objective_function(x):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    # TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    # Desabilitado pois \'ficou pesado\'.\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < SENSITIVITY:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n\n    # TODO: Penalizar os valores que est\xc3\xa3o abaixo da sensibilidade.\n    # fo = abs(np.sum(matrix))\n\n    ## acima da sensibilidade\n    fo = 0\n    for line in matrix:\n        for value in line:\n            if value >= SENSITIVITY:\n                fo += 1\n\n    coberturaPercent = (fo / TOTAL_PONTOS) * 100  ## porcentagem de cobertura\n    sombraPercent = 100 - coberturaPercent  ## porcentagem de sombra\n\n    # return coberturaPercent \t\t\t\t\t ## maximiza a cobertura\n    # return (-1 * pow(sombraPercent,2))\t\t\t ## miminiza as sombras, penalizadas\n    # return pow(coberturaPercent,2)\t\t\t\t ## maximiza a cobertura, difereciando mais os bons resultados\n\n    # return ( 2*coberturaPercent - sombraPercent )\n\n    alpha = 7\n    return (alpha * coberturaPercent - (10 - alpha) * sombraPercent)  # pesos 7 pra 3\n    # return (0.7 * coberturaPercent - 0.3 * sombraPercent)  # pesos 7 pra 3\n\n    ## TODO testing VALADAO\n    # return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@cuda.jit\ndef objective_function_kernel(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param soma:\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    W = len(matrix)\n    H = len(matrix[0])\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, W, gridX):\n        for y in range(startY, H, gridY):\n            soma += matrix[x][y]\n\n            #         if matrix[x][y] >= SENSITIVITY:\n            #             soma += 1\n\n            # soma = ((soma / TOTAL_PONTOS) * 100)\n\n\n@cuda.jit\ndef simulate_kernel(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param apY:\n    :param apX:\n    :param matrix_results:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, WIDTH, gridX):\n        for y in range(startY, HEIGHT, gridY):\n            matrix_results[x][y] = propagation_model_gpu(x, y, apX, apY, floor_plan)\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n\n@jit\ndef simulate_cpu(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param matrix_results:\n    :param apY:\n    :param apX:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            matrix_results[x][y] = propagation_model(x, y, apX, apY, floor_plan)\n\n    return matrix_results\n\n\n@jit\ndef get_point_in_circle(pointX, pointY, ray):\n    """"""\n    M\xc3\x83\xc2\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param pointY:\n    :param pointX:\n    :param ray: Valor do raio desejado.\n    valores discretos para posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xb5es da matriz.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n    num = 1\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n\n    x = round(abs(x[0]))\n    y = round(abs(y[0]))\n\n    return list([x, y])\n\n\n@jit\ndef perturba_array(S_array, size):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param size:\n    :param S_array:\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    novoS = np.empty([num_aps, 2], np.float32)\n\n    for i in range(size):\n        # Obtem um ponto aleatorio em um raio de X metros\n        novoS[i] = get_point_in_circle(S_array[i][0], S_array[i][1], RAIO_PERTURBACAO)\n\n    return novoS\n\n\n@jit\ndef perturba(S):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n\n    return get_point_in_circle(S[0], S[1], RAIO_PERTURBACAO)\n\n\n@jit\ndef avalia_array(S_array, size):\n    matrizes_propagacao = []\n    for i in range(size):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    # TODO: s\xc3\xb3 pra testes, simples demais\n    # fo_APs = 0\n    # for i in range(size):\n    #     fo_APs += objective_function(matrizes_propagacao[i])\n    #\n    # return fo_APs\n\n    # #simplesmente guloso VALADAO testing\n    matriz_sobreposta = sobrepoe_solucoes_MAX(matrizes_propagacao, size)\n\n    # #penaliza APs muito proximos (CUIDADO: junto com FO % de cobertura prender o SA)\n    # matriz_sobreposta = sobrepoe_solucoes_DIV_dBm(matrizes_propagacao, size)\n\n    return objective_function(matriz_sobreposta), matrizes_propagacao\n\n\n@jit\ndef sobrepoe_solucoes_MAX(propagation_array, size):\n    max = propagation_array[0]\n    for i in range(1, size):\n        max = np.maximum(propagation_array[i], max)\n\n    return max\n\n\n@jit\ndef sobrepoe_solucoes_SUB(propagation_array, size):\n    sub = propagation_array[0]\n    for i in range(1, size):\n        sub = np.subtract(propagation_array[i], sub)\n\n    return sub\n\n\n@jit\ndef sobrepoe_solucoes_DIV_dBm(propagation_array, size):\n    # verificar se \xc3\xa9 veridico\n    if size == 1:\n        return propagation_array[0]\n\n    matrixMin = propagation_array[0]\n    matrixMax = propagation_array[0]\n\n    for i in range(1, size):\n        matrixMin = np.minimum(propagation_array[i], matrixMin)\n        matrixMax = np.maximum(propagation_array[i], matrixMax)\n\n    # pois ao subtrair dBm, deve ser o maior/menor\n    sub = np.divide(matrixMax, matrixMin)\n\n    return sub\n\n\n@jit\ndef simula_propagacao_cpu(apX, apY):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param apY:\n    :param apX:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    matrix_results = np.empty([WIDTH, HEIGHT], np.float32)\n\n    return simulate_cpu(apX, apY, matrix_results, floor_plan)\n\n\n@jit\ndef simula_propagacao_gpu(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param pointX:\n    :param pointY: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return g_matrix\n\n\n@jit\ndef simula_propagacao(pointX, pointY):\n    """"""\n    M\xc3\xa9todo respos\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o de acordo com o ambiente escolhido (CPU ou GPU)\n    :param pointX:\n    :param pointY:\n    :return:\n    """"""\n\n    if ENVIRONMENT == ""GPU"":\n        # with GPU CUDA Threads\n        return simula_propagacao_gpu(pointX, pointY)\n\n    elif ENVIRONMENT == ""CPU"":\n        #  with CPU Threads\n        return simula_propagacao_cpu(pointX, pointY)\n    else:\n        exit(-1)\n\n\n@jit\ndef objective_function_mW(array_matrix):\n    matrix = sobrepoe_solucoes_MAX(array_matrix, len(array_matrix))\n\n    sum = 0\n\n    for line in matrix:\n        for value in line:\n            sum += dbm_to_mw(value)\n\n    return sum\n\n\ndef simulated_annealing(size, M, P, L, T0, alpha):\n    """"""\n    :param size:\n    :param T0: Temperatura inicial.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n\n    # cria Solu\xc3\xa7\xc3\xb5es iniciais com pontos aleat\xc3\xb3rios para os APs\n    S_array = np.empty([size, 2], np.float32)\n\n    for i in range(size):  ## VALADAO testing\n        if (POSICAO_INICIAL_ALEATORIA):\n            S_array[i] = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n        else:\n            S_array[i] = [WIDTH * 0.5, HEIGHT * 0.5]\n\n    S0 = S_array.copy()\n    print(""Solu\xc3\xa7\xc3\xa3o inicial:\\n"" + str(S0))\n\n    result = avalia_array(S_array, size)\n    fS = result[0]\n\n    T = T0\n    j = 1\n\n    i_ap = 0\n\n    # Armazena a MELHOR solu\xc3\xa7\xc3\xa3o encontrada\n    BEST_S_array = S_array.copy()\n    BEST_fS = fS\n    # BEST_matrix_FO = result[1]\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            Si_array = S_array.copy()\n\n            # a cada itera\xc3\xa7\xc3\xa3o do SA, perturba um dos APs\n            i_ap = (i_ap + 1) % num_aps\n\n            Si_array[i_ap] = perturba(S_array[i_ap])\n\n            # retorna a FO e suas matrizes\n            result = avalia_array(Si_array, num_aps)\n            fSi = result[0]\n            # matrix_FO = result[1]\n\n            ## Cuidado pois fica demasiado lento o desempenho do SA\n            # if ANIMACAO_PASSO_A_PASSO:\n            #   show_solution(S_array, DISPLAYSURF)\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            # Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):\n\n                S_array = Si_array.copy()\n                fS = fSi\n\n                nSucesso = nSucesso + 1\n\n                ## Cuidado pois fica demasiado lento o desempenho do SA\n                # if ANIMACAO_MELHORES_LOCAIS:\n                #   show_solution(S_array, DISPLAYSURF)\n\n                if fS > BEST_fS:\n                    BEST_fS = fS\n                    BEST_S_array = S_array.copy()\n                    # BEST_matrix_FO = matrix_FO\n                    # print(""FO: "" + \'{:.5e}\'.format(float(fS)) + "" \\t\\t <<< BEST "" + ""\\tTemp="" + str(\n                    #    int(T)) + ""\xc2\xba"" + ""\\tIter="" + str(j) + ""/Suc="" + str(nSucesso))\n\n                    if ANIMACAO_MELHORES:\n                        show_solution(S_array, DISPLAYSURF)\n\n                ## DEBUG\n                # print(""FO: "" + \'{:.5e}\'.format(float(fS)) + "" \\t ... LOCAL"")\n\n                # FOs.append( objective_function_mW(matrix_FO) )\n                # FOs.append( mw_to_dbm(objective_function_mW(matrix_FO)) )\n                FOs.append(fS)\n\n            i = i + 1\n\n            ## DEBUG\n            # print(""FO: "" + \'{:.5e}\'.format(float(fS)) + "" CANDIDATE"")\n            # FOs.append( fSi )\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    # saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n\n    print(""Dist\xc3\xa2ncia da solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(sobrepoe_solucoes_SUB(S_array, num_aps)))\n\n    print(""FO last cand:   "" + \'{:.3e}\'.format(float(fSi)))\n    print(""FO local best:  "" + \'{:.3e}\'.format(float(fS)))\n    print(""FO global best: "" + \'{:.3e}\'.format(float(BEST_fS)))\n\n    # FOs.append( objective_function_mW(BEST_matrix_FO) )\n    # FOs.append( mw_to_dbm(objective_function_mW(BEST_matrix_FO)) )\n    FOs.append(BEST_fS)\n\n    return BEST_S_array\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    # hex = str(hex).lstrip(\'#\')\n    # return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n\n    hex = str(hex).lstrip(\'#\')\n    lv = len(hex)\n    return tuple(int(hex[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n    # corR = int(Color(hex).get_red() * 255)\n    # corG = int(Color(hex).get_green() * 255)\n    # corB = int(Color(hex).get_blue() * 255)\n    #\n    # return tuple([corR, corG, corB])\n\n\ndef draw_line(DISPLAYSURF, x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param DISPLAYSURF:\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame_pyOpenGL(matrix_results, access_points, DISPLAYSURF):\n    # pxarray = pygame.PixelArray (surface)\n    x = 0\n\n\ndef print_pygame(matrix_results, access_points, DISPLAYSURF):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param DISPLAYSURF:\n    :param access_points:\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :return: None.\n    """"""\n\n    matrix_max_value = matrix_results.max()\n    # #matrix_min_value = matrix_results.min()\n\n    # # Se utilizar a fun\xc3\xa7\xc3\xa3o min tradicional, a penaliza\xc3\xa7\xc3\xa3o de DBM_MIN_VALUE ir\xc3\xa1 interferir no range de cor\n    # matrix_min_value = matrix_max_value\n    # for x in range(WIDTH):\n    #     for y in range(HEIGHT):\n    #         if matrix_results[x][y] != DBM_MIN_VALUE and matrix_results[x][y] < matrix_min_value:\n    #             matrix_min_value = matrix_results[x][y]\n\n    # matrix_max_value = -30\n    matrix_min_value = -100\n\n    # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_results[x][y], matrix_max_value, matrix_min_value)\n            draw_point(DISPLAYSURF, color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o dos Access Points\n    for ap in access_points:\n        draw_point(DISPLAYSURF, RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(DISPLAYSURF, color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param DISPLAYSURF:\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por obter as dimen\xc3\xa7\xc3\xb5es da planta\n    :param floor_plan:\n    :return:\n    """"""\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan, DISPLAYSURF):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(DISPLAYSURF, line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n    # return list[int(position - 1)]\n\n\ndef get_color_of_interval(x, max=-30, min=-100):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n\n    if PAINT_BLACK_BELOW_SENSITIVITY and x < SENSITIVITY:\n        return BLACK\n\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n\n    return color\n\n\ndef show_solution_opengl(S_array):\n    # print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyOpenGL."")\n\n    matrizes_propagacao = []\n    for i in range(len(S_array)):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n    # propagacao = sobrepoe_solucoes_ADD(matrizes_propagacao, len(S_array))\n    propagacao = sobrepoe_solucoes_MAX(matrizes_propagacao, len(S_array))\n\n    print_pygame(propagacao, S_array, DISPLAYSURF)\n    draw_floor_plan(walls, DISPLAYSURF)\n\n\ndef show_solution(S_array, DISPLAYSURF):\n    # print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyGame."")\n\n    matrizes_propagacao = []\n\n    for i in range(len(S_array)):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    # propagacao = sobrepoe_solucoes_ADD(matrizes_propagacao, len(S_array))\n    propagacao = sobrepoe_solucoes_MAX(matrizes_propagacao, len(S_array))\n\n    print_pygame(propagacao, S_array, DISPLAYSURF)\n\n    draw_floor_plan(walls, DISPLAYSURF)\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    # cores = list(Color(""blue"").range_to(Color(""red""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n\n    return cores\n\n\ndef show_configs():\n    print(""\\nOtimiza\xc3\xa7\xc3\xa3o via Simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"" + ""\\n"")\n    print(""\\tN\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""\\tN\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""\\tN\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""\\tTemperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""\\tDecaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""\\tRaio de perturba\xc3\xa7\xc3\xa3o:\\t\\t\\t\\t"" + str(int(RAIO_PERTURBACAO)))\n\n    print(""\\tExecu\xc3\xa7\xc3\xb5es do otimziador: \\t\\t"" + str(max_SA))\n    print(""\\nHardware de simula\xc3\xa7\xc3\xa3o:\\t"" + str(ENVIRONMENT) + ""\\n"")\n\n    print(""\\nSimula\xc3\xa7\xc3\xa3o do ambiente com a seguinte configura\xc3\xa7\xc3\xa3o:"" + ""\\n"")\n    print(""\\tSimulando ambiente com:  \\t\\t"" + str(WIDTH) + "" x "" + str(HEIGHT) + "" pixels"")\n    print(""\\tEscala de simula\xc3\xa7\xc3\xa3o:     \\t\\t1 px : "" + \'{:.4f}\'.format(float((1 / escala))) + "" metros"")\n\n    print(""\\tQuantidade de APs:       \\t\\t"" + str(num_aps))\n    print(""\\tPot\xc3\xaancia de cada APs:    \\t\\t"" + str(Pt_dBm) + "" dBm"")\n\n    if (POSICAO_INICIAL_ALEATORIA):\n        print(""\\tPosi\xc3\xa7\xc3\xa3o inicial dos APs: \\t\\tALEAT\xc3\x93RIA"")\n    else:\n        print(""\\tPosi\xc3\xa7\xc3\xa3o inicial dos APs: \\t\\tCENTRALIZADA (W/2, H/2)"")\n\n\ndef run():\n\n    bestSolution = simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha)\n    result = avalia_array(bestSolution, len(bestSolution))\n    bestSolution_fo = result[0]\n\n    # Gera resumo da simula\xc3\xa7\xc3\xa3o\n    generate_summary(bestSolution)\n\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o..."")\n    show_solution(bestSolution, DISPLAYSURF)\n    # show_solution(1, 1)\n\n\ndef test_propagation():\n    """"""\n    M\xc3\xa9todo usado apenas para fim de testes com a simula\xc3\xa7\xc3\xa3o em pontos espec\xc3\xadficos.\n    :return: None.\n    """"""\n    test_AP_in_the_middle = [[int(WIDTH / 2), int(HEIGHT / 2)]]\n\n    # Inicia o PyGame\n    pygame.init()\n\n    # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n    #\n    show_solution(test_AP_in_the_middle, DISPLAYSURF)\n    # show_solution(1, 1)\n\n\ndef generate_summary(S_array):\n    length = len(S_array)\n\n    print(""\\n****** Gerando sum\xc3\xa1rios dos resultados da simula\xc3\xa7\xc3\xa3o ******"")\n    print(""Numero de solu\xc3\xa7\xc3\xb5es:\\t"" + str(length))\n\n    matrizes_propagacao = []\n    for i in range(length):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    matrix = sobrepoe_solucoes_MAX(matrizes_propagacao, length)\n\n    above_sensitivity = [value for line in matrix for value in line if value >= SENSITIVITY]\n    # between_sensitivity = [value for line in matrix for value in line if value == SENSITIVITY]\n    under_sensitivity = [value for line in matrix for value in line if value < SENSITIVITY]\n\n    total = WIDTH * HEIGHT\n\n    percent_cover_above_sensitivity = (len(above_sensitivity) / total) * 100\n    # percent_cover_between_sensitivity = (len(between_sensitivity) / total) * 100\n    percent_cover_under_sensitivity = (len(under_sensitivity) / total) * 100\n\n    print(""COBERTURA DE SINAL WI-FI:"")\n    print(""\\t"" + \'{:.2f}\'.format(float(percent_cover_above_sensitivity)) + ""%\\t com boa cobertura (sinal forte)"")\n    # print(""\\t"" + str(round(percent_cover_between_sensitivity, 2)) + ""%\\tdos pontos est\xc3\xa3o sob sensibilidade do AP."")\n    print(""\\t"" + \'{:.2f}\'.format(\n        float(percent_cover_under_sensitivity)) + ""%\\t de zonas de sombra (abaixo da sensibilidade)"")\n\n    faixa1 = faixa2 = faixa3 = faixa4 = faixa5 = 0\n\n    for line in matrix:\n        for value in line:\n\n            if value >= -67:  # \xc3\xb3timo\n                faixa2 += 1\n\n            elif -67 > value >= -77:  # bom\n                faixa3 += 1\n\n            elif -77 > value >= SENSITIVITY:  # ruim\n                faixa4 += 1\n\n            elif value < SENSITIVITY:  # sem conectividade (zona de sombra)\n                faixa5 += 1\n\n    total = faixa1 + faixa2 + faixa3 + faixa4 + faixa5  ## deveria ser igual a WIDTH * HEIGHT\n\n    percent_faixa2 = faixa2 / total * 100\n    percent_faixa3 = faixa3 / total * 100\n    percent_faixa4 = faixa4 / total * 100\n\n    print(""\\n\\tCobertura por FAIXAS de intensidade de sinal"")\n    print(""\\t\\tsinal \xc3\x93timo  \\t"" + \'{:.1f}\'.format(float(percent_faixa2)) + ""%"")\n    print(""\\t\\tsinal Bom    \\t"" + \'{:.1f}\'.format(float(percent_faixa3)) + ""%"")\n    print(""\\t\\tsinal Ruim   \\t"" + \'{:.1f}\'.format(float(percent_faixa4)) + ""%"")\n\n    print(""\\n... gerando gr\xc3\xa1fico do comportamento da FO."")\n\n    # Plota gr\xc3\xa1fico da fun\xc3\xa7\xc3\xa3o objetivo\n    plt.plot(FOs)\n    plt.title(""Comportamento do Simulated Annealing"")\n    plt.ylabel(\'Valor da FO\')\n    plt.xlabel(\'Solu\xc3\xa7\xc3\xa3o candidata\')\n    plt.show()\n\ndef print_results_2k(values):\n    seconds = values.get(\'dura_seg\')\n    minutes = values.get(\'dura_min\')\n    fo = values.get(\'f_o\')\n\n    print(""F.O.\\tSegundos\\tMinutos\\n"")\n    for i in range(len(seconds)):\n        print(str(fo[i]) + ""\\t"" + str(round(seconds[i], 2)) + ""\\t"" + str(minutes[i]))\n\n    print(""-------------------------------------"")\n    print(""Maior valor da F.O.:\\t"" + str(max(fo)))\n    print(""Menor valor da F.O.:\\t"" + str(min(fo)))\n    print(""-------------------------------------"")\n    print(""Maior valor do tempo (seg.):\\t"" + str(max(seconds)))\n    print(""Menor valor do tempo (seg.):\\t"" + str(min(seconds)))\n    print(""-------------------------------------"")\n    print(""Maior valor do tempo (min.):\\t"" + str(round(max(minutes), 3)))\n    print(""Menor valor do tempo (min.):\\t"" + str(round(min(minutes), 3)))\n    print(""-------------------------------------"")\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\n# if __name__ == \'__main__\':\nBLACK   = (0, 0, 0)\nWHITE   = (255, 255, 255)\nRED     = (255, 0, 0)\nGREEN   = (0, 255, 0)\nBLUE    = (0, 0, 255)\n\n##################################################\n#  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE SIMULADO\n\nENVIRONMENT = ""GPU""\n# ENVIRONMENT = ""CPU""\n\n# Tamanho da simula\xc3\xa7\xc3\xa3o\nTAMAMHO_SIMULACAO = 400\n# TAMAMHO_SIMULACAO = 600\n\n# Ativa / Desativa a anima\xc3\xa7\xc3\xa3o passo a passo da otimiza\xc3\xa7\xc3\xa3o\n# ANIMACAO_PASSO_A_PASSO   = True\nANIMACAO_PASSO_A_PASSO = False\n\n# ANIMACAO_MELHORES_LOCAIS = True\nANIMACAO_MELHORES_LOCAIS = False\n\n# ANIMACAO_MELHORES = True\nANIMACAO_MELHORES = False\n\nPOSICAO_INICIAL_ALEATORIA = False\n\n##################################################\n#  CONFIGURA\xc3\x87\xc3\x95ES DOS EQUIPAMENTOS\n\n# OBS.: por conta da precisao de casas decimais do float\n#        \xc3\xa9 melhor pegar a ordem de magnitude com o dBm do\n#        que tentar usar o valor exato com mW\n\n# Sensibilidade dos equipamentos receptores\nSENSITIVITY = -90\n\n# Gradiente de cores da visualiza\xc3\xa7\xc3\xa3o gr\xc3\xa1fica\nCOLORS = get_color_gradient(16)  # 64, 32, 24, 16, 8\n\nPAINT_BLACK_BELOW_SENSITIVITY = True\n# PAINT_BLACK_BELOW_SENSITIVITY = False\n\nDBM_MIN_VALUE = np.finfo(np.float32).min\n\n# parede de concredo, de 8 a 15 dB.\ndbm_absorvido_por_parede = 8\n\n# Pot\xc3\xaancia de transmiss\xc3\xa3o de cada AP\n# Pt_dBm = -14\n# Pt_dBm = -17\n# Pt_dBm = -20\nPt_dBm = -25\n# Pt_dBm = -30\n\n# Quantidade de APs\nnum_aps = 2\n\n##################################################\n#  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE E PLANTA-BAIXA\n\nCOMPRIMENTO_BLOCO_A = 48.0\nCOMPRIMENTO_BLOCO_B = 36.0\nCOMPRIMENTO_BLOCO_C = 51.0\n\nCOMPRIMENTO_EDIFICIO = COMPRIMENTO_BLOCO_B\n# LARGURA_EDIFICIO = ???\n\n# dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n# dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n# dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\ndxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n# dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n# dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n# dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n# dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n# carrega para saber o comprimento da planta\nwalls = read_walls_from_dxf(dxf_path, 1)\nfloor_plan = np.array(walls, dtype=np.float32)\n\nfloor_size = size_of_floor_plan(walls)\ncomprimento_planta = floor_size[0]\nlargura_planta = floor_size[1]\n\n##################################################\n\n# Lista para guardar as fun\xc3\xa7\xc3\xb5es objetivos calculadas durante a simula\xc3\xa7\xc3\xa3o\nFOs = []\n\nWIDTH = TAMAMHO_SIMULACAO\nHEIGHT = int(WIDTH * (largura_planta / comprimento_planta))\nescala = WIDTH / comprimento_planta\nprecisao = COMPRIMENTO_EDIFICIO / WIDTH\n\nTOTAL_PONTOS = WIDTH * HEIGHT\n\n# RE-carrega utilizando a escala apropriada\nwalls = read_walls_from_dxf(dxf_path, escala)\nfloor_plan = np.array(walls, dtype=np.float32)\n##################################################\n\n##################################################\n#  CONFIGURA\xc3\x87\xc3\x95ES DO OTIMIZADOR\n\n# fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\nmax_inter = 600\n# max_inter = 600 * (1 + num_aps)\n# max_inter = 600 * (10 * num_aps)\n# max_inter = TOTAL_PONTOS * 0.2\n\n# p - M\xc3\xa1ximo de perturba\xc3\xa7\xc3\xb5es\nmax_pertub = 5\n\nbeta = 1\nRAIO_PERTURBACAO = (1 / precisao) * (beta + num_aps)  ## VALADAO testing\n# RAIO_PERTURBACAO = (1 / precisao) * (1 + num_aps)  ## VALADAO testing\n\n# v - M\xc3\xa1ximo de vizinhos\nnum_max_succ = 240 * (beta + num_aps)\n\n# a - Alpha\nalpha = .85\n\n# t - Temperatura\ntemp_inicial = 300 * (beta + num_aps)\n# temp_inicial = 300 * (1 + num_aps) * 10\n\n# M\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\nmax_SA = 1\n##################################################\n\n# Vizinhos\nA = [80, 240]\n\n# Temperatura Inicial\nB = [300, 600]\n\n# Beta (aps * beta)\nC = [1, 3]\n\n# Alpha (m\xc3\xa9dia exponencial)\nD = [7, 8]\n\n# Tabela verdade com as configura\xc3\xa7\xc3\xb5es das possibilidades. Os valores representam a posi\xc3\xa7\xc3\xa3o dos vetores de\n# parametros.\nCONFIGURACOES = [\n    [1, 1, 1, 1],\n    [1, 1, 1, 0],\n    [1, 1, 0, 1],\n    [1, 1, 0, 0],\n    [1, 0, 1, 1],\n    [1, 0, 1, 0],\n    [1, 0, 0, 1],\n    [1, 0, 0, 0],\n    [0, 1, 1, 1],\n    [0, 1, 1, 0],\n    [0, 1, 0, 1],\n    [0, 1, 0, 0],\n    [0, 0, 1, 1],\n    [0, 0, 1, 0],\n    [0, 0, 0, 1],\n    [0, 0, 0, 0]\n]\n\n\n# fixo\naccess_point = [0, 0]\n\n# fixo\nmax_inter = 50\n\n# Cria o arquivo de saida\nprint(""Gerando arquivo de saida."")\nf = open(\'saida_2k\', \'w\')\nf.write(""i\\tPonto\\tItera\xc3\xa7\xc3\xb5es\\tVizinhos\\tT0\\tAlfa\\tPertuba\xc3\xa7\xc3\xb5es\\tInicio\\tFim\\tDura\xc3\xa7\xc3\xa3o(Seg)\\tDura\xc3\xa7\xc3\xa3o(Min)\\tF.O.\\n"")\nf.write(""-\\t-----\\t---------\\t--------\\t--\\t----\\t-----------\\t------\\t---\\t------------\\t------------\\t----\\n"")\nf.close()\n\n# contador usado apenas no arquivo de saida\ni = 0\n\ndura_seg = []\ndura_min = []\nf_o = []\n\nfor line in CONFIGURACOES:\n    # Abre o aquivo em modo \'append\'\n    f = open(\'saida_2k-\', \'a\')\n\n    print(""Itera\xc3\xa7\xc3\xa3o: "" + str(i))\n\n    # vizinhos - A\n    num_max_succ = A[line[0]]\n\n    # Temperatura inicial - B\n    temp_inicial = B[line[1]]\n\n    # fator de resfriamento - C\n    alpha = C[line[2]]\n\n    # pertubacoes - D\n    max_pertub = D[line[3]]\n\n    print(""Iniciando simula\xc3\xa7\xc3\xa3o."")\n\n    # Marca o tempo do inicio da simula\xc3\xa7\xc3\xa3o\n    inicio = datetime.now()\n\n    # Realiza a busca do melhor ponto\n\n    show_configs()\n    # test_propagation()\n    run()\n\n    # Marca o tempo do fim da simula\xc3\xa7\xc3\xa3o\n    fim = datetime.now()\n\n    time_seconds = (fim - inicio).seconds\n    time_minutes = time_seconds / 60\n\n    fo = p.f(point)\n\n    print(""\\nInicio: \\t"" + str(inicio.time()))\n    print(""Fim: \\t\\t"" + str(fim.time()))\n    print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str(time_seconds) + "" segundos ("" + str(round(time_minutes, 2)) + "" minutos).\\n"")\n    print(""Valor da fun\xc3\xa7\xc3\xa3o objetivo: \\t"" + str(fo))\n\n    print(""i\\tPonto\\tItera\xc3\xa7\xc3\xb5es\\tVizinhos\\tT0\\tAlfa\\tPertuba\xc3\xa7\xc3\xb5es\\tInicio\\tFim\\tDura\xc3\xa7\xc3\xa3o(Seg)\\tDura\xc3\xa7\xc3\xa3o(Min)\\tF.O.\\n"")\n    print(str(i) + ""\\t"" + str(access_point) + ""\\t"" + str(max_inter) + ""\\t"" + str(num_max_succ) + ""\\t"" +\n          str(temp_inicial) + ""\\t"" + str(alpha) + ""\\t"" + str(max_pertub) + ""\\t"" + str(inicio) + ""\\t"" + str(fim) +\n          ""\\t"" + str(time_seconds) + ""\\t"" + str(round(time_minutes, 2)) + ""\\t"" + str(fo) + ""\\n"")\n\n    f.write(str(i) + ""\\t"" + str(access_point) + ""\\t"" + str(max_inter) + ""\\t"" + str(num_max_succ) + ""\\t"" +\n            str(temp_inicial) + ""\\t"" + str(alpha) + ""\\t"" + str(max_pertub) + ""\\t"" + str(inicio) + ""\\t"" + str(fim) +\n            ""\\t"" + str(time_seconds) + ""\\t"" + str(round(time_minutes, 2)) + ""\\t"" + str(fo) + ""\\n"")\n\n    # Adiciona resultados em listas\n    dura_seg.append(time_seconds)\n    dura_min.append(time_minutes)\n    f_o.append(fo)\n\n    i = i + 1\n\n    # Fecha o arquivo\n    f.close()\n\nresults = {\n    ""dura_seg"": dura_seg,\n    ""dura_min"": dura_min,\n    ""f_o"": f_o\n}\n\nprint(""Experimento Fatorial 2K terminado."")\ninput(\'\\nAperte ESC para fechar a simula\xc3\xa7\xc3\xa3o.\')'"
ProjetoFatorial/ProjetoFatorial2K1.py,0,"b'# Ler/Escrever arquivo em python\n# http://www.pythonforbeginners.com/files/reading-and-writing-files-in-python\n#\n#\n\nfrom datetime import datetime\n\nfrom debugs.Placement import Placement\n\n\ndef p_f_2_k():\n\n    # Vizinhos\n    A = [80, 240]\n\n    # Temperatura Inicial\n    B = [300, 600]\n\n    # Beta (aps * beta)\n    C = [1, 3]\n\n    # Alpha (m\xc3\xa9dia exponencial)\n    D = [7, 8]\n\n    # Tabela verdade com as configura\xc3\xa7\xc3\xb5es das possibilidades. Os valores representam a posi\xc3\xa7\xc3\xa3o dos vetores de\n    # parametros.\n    CONFIGURACOES = [\n        [1, 1, 1, 1],\n        [1, 1, 1, 0],\n        [1, 1, 0, 1],\n        [1, 1, 0, 0],\n        [1, 0, 1, 1],\n        [1, 0, 1, 0],\n        [1, 0, 0, 1],\n        [1, 0, 0, 0],\n        [0, 1, 1, 1],\n        [0, 1, 1, 0],\n        [0, 1, 0, 1],\n        [0, 1, 0, 0],\n        [0, 0, 1, 1],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n        [0, 0, 0, 0]\n    ]\n\n    p = Placement()\n\n    # fixo\n    access_point = [0, 0]\n\n    # fixo\n    max_inter = 50\n\n    # Cria o arquivo de saida\n    print(""Gerando arquivo de saida."")\n    f = open(\'saida_2k\', \'w\')\n    f.write(""i\\tPonto\\tItera\xc3\xa7\xc3\xb5es\\tVizinhos\\tT0\\tAlfa\\tPertuba\xc3\xa7\xc3\xb5es\\tInicio\\tFim\\tDura\xc3\xa7\xc3\xa3o(Seg)\\tDura\xc3\xa7\xc3\xa3o(Min)\\tF.O.\\n"")\n    f.write(""-\\t-----\\t---------\\t--------\\t--\\t----\\t-----------\\t------\\t---\\t------------\\t------------\\t----\\n"")\n    f.close()\n\n    # contador usado apenas no arquivo de saida\n    i = 0\n\n    dura_seg = []\n    dura_min = []\n    f_o = []\n\n    for line in CONFIGURACOES:\n        # Abre o aquivo em modo \'append\'\n        f = open(\'saida_2k\', \'a\')\n\n        print(""Itera\xc3\xa7\xc3\xa3o: "" + str(i))\n\n        ## vizinhos - A\n        num_max_succ = A[line[0]]\n\n        ## Temperatura inicial - B\n        temp_inicial = B[line[1]]\n\n        ## fator de resfriamento - C\n        alpha = C[line[2]]\n\n        ## pertubacoes - D\n        max_pertub = D[line[3]]\n\n        print(""Iniciando simula\xc3\xa7\xc3\xa3o."")\n\n        # Marca o tempo do inicio da simula\xc3\xa7\xc3\xa3o\n        inicio = datetime.now()\n\n        # Realiza a busca do melhor ponto\n        point = p.simulated_annealing(S0=access_point, M=max_inter, P=max_pertub, L=num_max_succ, T0=temp_inicial,\n                                      alpha=alpha, debug=True)\n\n        # Marca o tempo do fim da simula\xc3\xa7\xc3\xa3o\n        fim = datetime.now()\n\n        time_seconds = (fim - inicio).seconds\n        time_minutes = time_seconds / 60\n\n        fo = p.f(point)\n\n        print(""\\nInicio: \\t"" + str(inicio.time()))\n        print(""Fim: \\t\\t"" + str(fim.time()))\n        print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str(time_seconds) + "" segundos ("" + str(round(time_minutes, 2)) + "" minutos).\\n"")\n        print(""Valor da fun\xc3\xa7\xc3\xa3o objetivo: \\t"" + str(fo))\n\n        print(""i\\tPonto\\tItera\xc3\xa7\xc3\xb5es\\tVizinhos\\tT0\\tAlfa\\tPertuba\xc3\xa7\xc3\xb5es\\tInicio\\tFim\\tDura\xc3\xa7\xc3\xa3o(Seg)\\tDura\xc3\xa7\xc3\xa3o(Min)\\tF.O.\\n"")\n        print(str(i) + ""\\t"" + str(access_point) + ""\\t"" + str(max_inter) + ""\\t"" + str(num_max_succ) + ""\\t"" +\n              str(temp_inicial) + ""\\t"" + str(alpha) + ""\\t"" + str(max_pertub) + ""\\t"" + str(inicio) + ""\\t"" + str(fim) +\n              ""\\t"" + str(time_seconds) + ""\\t"" + str(round(time_minutes, 2)) + ""\\t"" + str(fo) + ""\\n"")\n\n        f.write(str(i) + ""\\t"" + str(access_point) + ""\\t"" + str(max_inter) + ""\\t"" + str(num_max_succ) + ""\\t"" +\n                str(temp_inicial) + ""\\t"" + str(alpha) + ""\\t"" + str(max_pertub) + ""\\t"" + str(inicio) + ""\\t"" + str(fim) +\n                ""\\t"" + str(time_seconds) + ""\\t"" + str(round(time_minutes, 2)) + ""\\t"" + str(fo) + ""\\n"")\n\n        # Adiciona resultados em listas\n        dura_seg.append(time_seconds)\n        dura_min.append(time_minutes)\n        f_o.append(fo)\n\n        i = i + 1\n\n        # Fecha o arquivo\n        f.close()\n\n    results = {\n        ""dura_seg"": dura_seg,\n        ""dura_min"": dura_min,\n        ""f_o"": f_o\n    }\n\n    print(""Experimento Fatorial 2K terminado."")\n    return results\n\ndef print_results_2k(values):\n\n    seconds = values.get(\'dura_seg\')\n    minutes = values.get(\'dura_min\')\n    fo = values.get(\'f_o\')\n\n    print(""F.O.\\tSegundos\\tMinutos\\n"")\n    for i in range(len(seconds)):\n        print(str(fo[i]) + ""\\t""+str(round(seconds[i], 2)) + ""\\t""+str(minutes[i]))\n\n    print(""-------------------------------------"")\n    print(""Maior valor da F.O.:\\t"" + str(max(fo)))\n    print(""Menor valor da F.O.:\\t"" + str(min(fo)))\n    print(""-------------------------------------"")\n    print(""Maior valor do tempo (seg.):\\t"" + str(max(seconds)))\n    print(""Menor valor do tempo (seg.):\\t"" + str(min(seconds)))\n    print(""-------------------------------------"")\n    print(""Maior valor do tempo (min.):\\t"" + str(round(max(minutes), 3)))\n    print(""Menor valor do tempo (min.):\\t"" + str(round(min(minutes), 3)))\n    print(""-------------------------------------"")\n\nvalues = p_f_2_k()\n\nprint_results_2k(values)'"
ProjetoFatorial/__init__.py,0,b''
debugs/JogoDaVida.py,3,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Fri Aug 17 11:28:17 2012\n@author: User\n""""""\n#################### D O C U M E N T A \xc3\x87 \xc3\x83 O ###################################\n# Vari\xc3\xa1veis:\n#   i         --> \xc3\xa9 usado para percorrer as  linhas  de uma matriz\n#   j         --> \xc3\xa9 usado para percorrer as  colunas de uma matriz\n#   tx        --> \xc3\xa9 o tamanho \'x\' da matriz principal\n#   ty        --> \xc3\xa9 o tamanho \'y\' da matriz principal\n#   m         --> \xc3\xa9 a matriz principal\n#   n         --> \xc3\xa9 uma c\xc3\xb3pia da matriz principal\n#   v         --> \xc3\xa9 uma matriz que guarda o n\xc2\xba de vizinhos atuais de cada c\xc3\xa9lula\n#   aux_cont  --> guarda quantas vezes foi chamada a fun\xc3\xa7\xc3\xa3o\n#   cont_ger  --> conta qual o numero da gera\xc3\xa7\xc3\xa3o atual\n#\n# Fun\xc3\xa7\xc3\xb5es:\n#   def_var   --> inicializa as vari\xc3\xa1veis globais\n#   def_bts   --> inicializa os bot\xc3\xb5es globais\n#   destroy_bt--> destroi os bot\xc3\xb5es para serem reUpados em ""def_bts"" posteriormente\n#   callback  --> \xc3\xa9 a fun\xc3\xa7\xc3\xa3o a ser executada quando o bot\xc3\xa3o bt1 \xc3\xa9 clicado\n#   callback_2--> \xc3\xa9 a fun\xc3\xa7\xc3\xa3o a ser executada quando o bot\xc3\xa3o bt2 \xc3\xa9 clicado\n#   geracao           -->\n#   monta             -->\n################################################################################\n\n# JOGO DA VIDA:\nfrom tkinter import *\nfrom functools import partial\nimport random\nimport time\nimport numpy as np\n\n\ndef def_var():\n    global cont_ger\n    global tx\n    global ty\n    global m\n    global n\n    global root\n    global canvas\n    global cell\n    cont_ger = 1\n    tx = 40\n    ty = 40\n    m = np.zeros((tx, ty))\n    n = m.copy()\n    root = Tk()\n    root.title(""jogo da vida"")\n    canvas = Canvas(root, width=ty * 10, height=tx * 10, highlightthickness=0, bd=0, bg=\'black\')\n    cell = [[0 for row in range(-1, tx + 1)] for col in range(-1, ty + 1)]\n    for y in range(-1, tx + 1):\n        for x in range(-1, ty + 1):\n            cell[x][y] = canvas.create_rectangle((x * 10, y * 10, x * 10 + 10, y * 10 + 10), outline=""gray"",\n                                                 fill=""white"")\n\n\ndef def_bts(m, n, aux_cont):\n    global bt1\n    global bt2\n\n    bt1 = Button(root, text=""PR\xc3\x93XIMA GERA\xc3\x87AO"", command=lambda: callback(m, n, aux_cont))\n    bt2 = Button(root, text=""PLAY"", command=lambda: callback_2(m, n, aux_cont))\n    bt1.pack()\n    bt2.pack()\n    canvas.pack()\n\n\ndef geracao(m, n, aux_cont):\n    v = np.zeros((tx,ty))\n    for i in range(1,tx-1):\n        for j in range(1,ty-1):\n            if m[i-1][j-1] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i-1][j] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i-1][j+1] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i][j-1] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i][j+1] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i+1][j-1] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i+1][j] == 1:\n                v[i][j] = v[i][j] + 1\n            if m[i+1][j+1] == 1:\n                v[i][j] = v[i][j] + 1\n    for y in range(1,tx-1):\n        for x in range(1,ty-1):\n            if m[x][y] == 0:\n                canvas.itemconfig(cell[x][y], fill=""white"")\n            else:\n                canvas.itemconfig(cell[x][y], fill=""black"")\n    canvas.pack()\n    for i in range (tx):\n        for j in range (ty):\n            ########################################CONDI\xc3\x87OES DO  GAME OF LIFE\n            if m[i][j] == 0:\n                if v[i][j] == 3:\n                    n[i][j] = 1\n            elif m[i][j] == 1:\n                if v[i][j] > 3:\n                    n[i][j] = 0\n                if v[i][j] < 2:\n                    n[i][j] = 0\n                if v[i][j] == 2 or v[i][j] == 3:\n                    n[i][j] = 1\n            ########################################\n    m = n.copy()\n    return m\n\ndef monta(m, n, aux_cont):\n    for y in range(1, tx-1):\n        for x in range(1, ty-1):\n            if m[x][y] == 0:\n                canvas.itemconfig(cell[x][y], fill=""white"")\n            else:\n                canvas.itemconfig(cell[x][y], fill=""black"")\n    ################################################(Re)define os Bot\xc3\xb5es\n    global bt1\n    global bt2\n    bt1 = Button(root, text=""PR\xc3\x93XIMA GERA\xc3\x87AO"", command=lambda: callback(m, n, aux_cont))\n    bt2 = Button(root, text=""PLAY"", command=lambda: callback_2(m, n, aux_cont))\n    bt1.pack()\n    bt2.pack()\n    canvas.pack()\n    ################################################\n    if aux_cont == 0:\n        print (\'nnn1\')\n        root.mainloop()\n        def_var()\n    return\n\n\ndef callback(m, n, aux_cont):\n    aux_cont = aux_cont + 1\n    print()\n    ""t = %d"" % (aux_cont + 1)\n    destroy_bt()\n    m = geracao(m, n, aux_cont)\n    monta(m, n, aux_cont)\n\n\ndef callback_2(m, n, aux_cont):\n    aux_cont = aux_cont + 1\n    print()\n    ""t = %d"" % (aux_cont + 1)\n    destroy_bt()\n    m = geracao(m, n, aux_cont)\n    monta(m, n, aux_cont)\n    root.after(100, lambda: callback_2(m, n, aux_cont))\n\n\ndef destroy_bt():\n    bt1.destroy()\n    bt2.destroy()\n\n\n################################################################################\n###########################   M    A   I   N   #################################\n################################################################################\nif __name__ == ""__main__"":\n    aux_cont = 0\n    def_var()\n    #################################################\n    ## I N I C I A L I Z A \xc3\x87 A O   D A  M A T R I Z##\n    #################################################\n\n\n    m = np.zeros((tx, ty))\n    m[1][6] = 1\n    m[2][6] = 1\n    m[1][7] = 1\n    m[2][7] = 1\n    m[10][6] = 1\n    m[11][6] = 1\n    m[9][7] = 1\n    m[11][7] = 1\n    m[9][8] = 1\n    m[10][8] = 1\n    m[17][8] = 1\n    m[18][8] = 1\n    m[17][9] = 1\n    m[19][9] = 1\n    m[17][10] = 1\n    m[24][4] = 1\n    m[25][4] = 1\n    m[23][5] = 1\n    m[25][5] = 1\n    m[23][6] = 1\n    m[24][6] = 1\n    m[25][16] = 1\n    m[26][16] = 1\n    m[27][16] = 1\n    m[25][17] = 1\n    m[26][18] = 1\n    m[35][4] = 1\n    m[36][4] = 1\n    m[35][5] = 1\n    m[36][5] = 1\n    m[36][11] = 1\n    m[37][11] = 1\n    m[36][12] = 1\n    m[38][12] = 1\n    m[36][13] = 1\n    n = m.copy()\n    m = geracao(m, n, aux_cont)\n    monta(m, n, aux_cont)\n    ################################################################################\n    ################################################################################'"
debugs/LogNormal.py,3,"b'import numpy as np\nimport pylab as pl\nfrom math import log10\nfrom scipy.stats import lognorm\nimport matplotlib.pyplot as plt\n\ncoleta = [-34,-43,-35,-48,-27,-30,-39,-40,-45,-44,-58,-53,-56,-56,-49,-49,-53,-62,-54,-66,-56,-60,-66,-56,-51,-65,-54,-59,-60,-64,-53,-69,-54,-71,-71,-58,-61,-61,-56,-56,-71]\n\nx = np.linspace(1, 10, 200)\n\nsigma=np.std(coleta)\nmu=np.mean(coleta)\ndist = lognorm(sigma, loc=mu)\n\npl.plot(dist.pdf(x))\n#pl.plot(x)\n\npl.show()'"
debugs/Main.py,2,"b'# from math import sqrt\n# import numpy as np\n#\n# global Pt\n# global L0\n# global lamb\n# global frequencia\n# global canal\n#\n# global Ht\n# global Hr\n#\n# global C\n#\n# def inicializaVariaveis():\n#     global Gr\n#     global Gt\n#\n#     Gr = 3.24\n#     Gt = 2\n#\n# def calculaDistancia(x1, x2, y1, y2):\n#     return sqrt((x2 - x1) ** 2) + ((y2 - y1) ** 2)\n#\n# def criaMatriz(linha, coluna):\n#     return np.zeros(shape=(linha, coluna))\n#\n# def imprimeMatriz(matriz):\n#     print(""Diman\xc3\xa7\xc3\xb5es na matriz: ""+ str(np.shape(matriz)))\n#     for linha in matriz:\n#         for valor in linha:\n#             print(str(valor)+""\\t\\t"", end=\'\')\n#         print("""")\n#\n# def calculaPotencia():\n#     pass\n#\n# inicializaVariaveis()\n#\n# print(Gr)\n\ndef teste():\n    global a\n    a = 10\n\n\nif __name__ == \'__main__\':\n    b = 0\n\n    print(b)\n\n    teste()\n\n    print(a)\n'"
debugs/Placement.py,9,"b'#!/usr/bin/python\n# -*- coding: latin1 -*-\n\nimport math\nimport tkinter as tk\nfrom datetime import datetime\nfrom math import sqrt, pi, log10, exp\nfrom random import random\n\nimport ezdxf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pygame\n\nfrom numba import autojit, prange, cuda, jit\nimport numba\n\nclass Placement(object):\n    """"""\n    Classe que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\n    Point Informado.\n    """"""\n\n    def __init__(self, debug=False, floor_plan=None):\n        """"""\n        Contrutor da classe Placement.\n        """"""\n        # self.WIDTH = self.get_monitor_size()[0] - 100  # Retira 100pxs para folga\n        # self.HEIGHT = self.get_monitor_size()[1] - 100  # Retira 100pxs para folga\n\n        self.contador_uso_func_objetivo = 0\n\n        self.floor_plan = self.read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-A-l.dxf"")\n\n        ## print(numba.typeof(self.floor_plan))\n\n\n        self.heat_map = None\n\n        self.WIDTH = 350\n        self.HEIGHT = 200\n\n        self.comprimento_planta = 800\n        self.largura_planta = 600\n        self.precisao = 1  # metro\n\n        self.escala = self.HEIGHT / self.largura_planta\n\n        # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n        self.proporcao_planta = self.comprimento_planta / self.largura_planta\n        # self.WIDTH = int(self.HEIGHT * self.proporcao_planta)\n\n        if debug:\n            print(""Dimens\xc3\xa3o da planta: "" + str(self.comprimento_planta) + ""x"" + str(self.largura_planta))\n            print(""Dimens\xc3\xa3o da matriz de valores: "" + str(self.WIDTH) + ""x"" + str(self.HEIGHT))\n            print(""Precis\xc3\xa3o de "" + str(self.precisao) + "" metros."")\n            print(""Escala de 1:"" + str(self.escala) + ""."")\n\n        self.CHANNEL = 9\n\n        # Posi\xc3\xa7\xc3\xa3o menor -> Azul, Posi\xc3\xa7\xc3\xa3o Maior -> Amarelo/Vermelho\n        self.COLORS = [\n            \'#0C0786\', \'#100787\', \'#130689\', \'#15068A\', \'#18068B\', \'#1B068C\', \'#1D068D\', \'#1F058E\',\n            \'#21058F\', \'#230590\', \'#250591\', \'#270592\', \'#290593\', \'#2B0594\', \'#2D0494\', \'#2F0495\',\n            \'#310496\', \'#330497\', \'#340498\', \'#360498\', \'#380499\', \'#3A049A\', \'#3B039A\', \'#3D039B\',\n            \'#3F039C\', \'#40039C\', \'#42039D\', \'#44039E\', \'#45039E\', \'#47029F\', \'#49029F\', \'#4A02A0\',\n            \'#4C02A1\', \'#4E02A1\', \'#4F02A2\', \'#5101A2\', \'#5201A3\', \'#5401A3\', \'#5601A3\', \'#5701A4\',\n            \'#5901A4\', \'#5A00A5\', \'#5C00A5\', \'#5E00A5\', \'#5F00A6\', \'#6100A6\', \'#6200A6\', \'#6400A7\',\n            \'#6500A7\', \'#6700A7\', \'#6800A7\', \'#6A00A7\', \'#6C00A8\', \'#6D00A8\', \'#6F00A8\', \'#7000A8\',\n            \'#7200A8\', \'#7300A8\', \'#7500A8\', \'#7601A8\', \'#7801A8\', \'#7901A8\', \'#7B02A8\', \'#7C02A7\',\n            \'#7E03A7\', \'#7F03A7\', \'#8104A7\', \'#8204A7\', \'#8405A6\', \'#8506A6\', \'#8607A6\', \'#8807A5\',\n            \'#8908A5\', \'#8B09A4\', \'#8C0AA4\', \'#8E0CA4\', \'#8F0DA3\', \'#900EA3\', \'#920FA2\', \'#9310A1\',\n            \'#9511A1\', \'#9612A0\', \'#9713A0\', \'#99149F\', \'#9A159E\', \'#9B179E\', \'#9D189D\', \'#9E199C\',\n            \'#9F1A9B\', \'#A01B9B\', \'#A21C9A\', \'#A31D99\', \'#A41E98\', \'#A51F97\', \'#A72197\', \'#A82296\',\n            \'#A92395\', \'#AA2494\', \'#AC2593\', \'#AD2692\', \'#AE2791\', \'#AF2890\', \'#B02A8F\', \'#B12B8F\',\n            \'#B22C8E\', \'#B42D8D\', \'#B52E8C\', \'#B62F8B\', \'#B7308A\', \'#B83289\', \'#B93388\', \'#BA3487\',\n            \'#BB3586\', \'#BC3685\', \'#BD3784\', \'#BE3883\', \'#BF3982\', \'#C03B81\', \'#C13C80\', \'#C23D80\',\n            \'#C33E7F\', \'#C43F7E\', \'#C5407D\', \'#C6417C\', \'#C7427B\', \'#C8447A\', \'#C94579\', \'#CA4678\',\n            \'#CB4777\', \'#CC4876\', \'#CD4975\', \'#CE4A75\', \'#CF4B74\', \'#D04D73\', \'#D14E72\', \'#D14F71\',\n            \'#D25070\', \'#D3516F\', \'#D4526E\', \'#D5536D\', \'#D6556D\', \'#D7566C\', \'#D7576B\', \'#D8586A\',\n            \'#D95969\', \'#DA5A68\', \'#DB5B67\', \'#DC5D66\', \'#DC5E66\', \'#DD5F65\', \'#DE6064\', \'#DF6163\',\n            \'#DF6262\', \'#E06461\', \'#E16560\', \'#E26660\', \'#E3675F\', \'#E3685E\', \'#E46A5D\', \'#E56B5C\',\n            \'#E56C5B\', \'#E66D5A\', \'#E76E5A\', \'#E87059\', \'#E87158\', \'#E97257\', \'#EA7356\', \'#EA7455\',\n            \'#EB7654\', \'#EC7754\', \'#EC7853\', \'#ED7952\', \'#ED7B51\', \'#EE7C50\', \'#EF7D4F\', \'#EF7E4E\',\n            \'#F0804D\', \'#F0814D\', \'#F1824C\', \'#F2844B\', \'#F2854A\', \'#F38649\', \'#F38748\', \'#F48947\',\n            \'#F48A47\', \'#F58B46\', \'#F58D45\', \'#F68E44\', \'#F68F43\', \'#F69142\', \'#F79241\', \'#F79341\',\n            \'#F89540\', \'#F8963F\', \'#F8983E\', \'#F9993D\', \'#F99A3C\', \'#FA9C3B\', \'#FA9D3A\', \'#FA9F3A\',\n            \'#FAA039\', \'#FBA238\', \'#FBA337\', \'#FBA436\', \'#FCA635\', \'#FCA735\', \'#FCA934\', \'#FCAA33\',\n            \'#FCAC32\', \'#FCAD31\', \'#FDAF31\', \'#FDB030\', \'#FDB22F\', \'#FDB32E\', \'#FDB52D\', \'#FDB62D\',\n            \'#FDB82C\', \'#FDB92B\', \'#FDBB2B\', \'#FDBC2A\', \'#FDBE29\', \'#FDC029\', \'#FDC128\', \'#FDC328\',\n            \'#FDC427\', \'#FDC626\', \'#FCC726\', \'#FCC926\', \'#FCCB25\', \'#FCCC25\', \'#FCCE25\', \'#FBD024\',\n            \'#FBD124\', \'#FBD324\', \'#FAD524\', \'#FAD624\', \'#FAD824\', \'#F9D924\', \'#F9DB24\', \'#F8DD24\',\n            \'#F8DF24\', \'#F7E024\', \'#F7E225\', \'#F6E425\', \'#F6E525\', \'#F5E726\', \'#F5E926\', \'#F4EA26\',\n            \'#F3EC26\', \'#F3EE26\', \'#F2F026\', \'#F2F126\', \'#F1F326\', \'#F0F525\', \'#F0F623\', \'#EFF821\'\n        ]\n\n        self.BLACK = (0, 0, 0)\n        self.WHITE = (255, 255, 255)\n        self.RED = (255, 0, 0)\n        self.GREEN = (0, 255, 0)\n        self.BLUE = (0, 0, 255)\n\n        # print(""W"" + str(self.WIDTH))\n        # print(""H"" + str(self.HEIGHT))\n\n        # Inicia o PyGame\n        # pygame.init()\n\n        # Configura o tamanho da janela\n        # self.DISPLAYSURF = pygame.display.set_mode((self.WIDTH, self.HEIGHT), 0, 32)\n\n    def read_walls_from_dxf(self, dxf_path):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n        :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n        :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n        refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n        """"""\n        dwg = ezdxf.readfile(dxf_path)\n\n        walls = []\n\n        modelspace = dwg.modelspace()\n\n        escala = 7\n\n        xMin = -1\n        yMin = -1\n        for e in modelspace:\n            if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n                if e.dxf.start[0] < xMin or xMin == -1:\n                    xMin = e.dxf.start[0]\n                if e.dxf.start[1] < yMin or yMin == -1:\n                    yMin = e.dxf.start[1]\n\n        for e in modelspace:\n            if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n                line = [\n                    int((e.dxf.start[0] - xMin) * escala),\n                    int((e.dxf.start[1] - yMin) * escala),\n                    int((e.dxf.end[0] - xMin) * escala),\n                    int((e.dxf.end[1] - yMin) * escala)\n                ]\n                walls.append(line)\n\n        return walls\n\n    # @cuda.jit\n    def side(self, a, b, c):\n        """"""\n        Returns a position of the point c relative to the line going through a and b\n            Points a, b are expected to be different.\n        :param a: Ponto A.\n        :param b: Ponto B.\n        :param c: Ponto C.\n        :return:\n        """"""\n        d = (c[1] - a[1]) * (b[0] - a[0]) - (b[1] - a[1]) * (c[0] - a[0])\n        return 1 if d > 0 else (-1 if d < 0 else 0)\n\n    # @cuda.jit\n    def is_point_in_closed_segment(self, a, b, c):\n        """"""\n        Returns True if c is inside closed segment, False otherwise.\n            a, b, c are expected to be collinear\n        :param a: Ponto A.\n        :param b: Ponto B.\n        :param c: Ponto C.\n        :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n        """"""\n        if a[0] < b[0]:\n            return a[0] <= c[0] <= b[0]\n        if b[0] < a[0]:\n            return b[0] <= c[0] <= a[0]\n\n        if a[1] < b[1]:\n            return a[1] <= c[1] <= b[1]\n        if b[1] < a[1]:\n            return b[1] <= c[1] <= a[1]\n\n        return a[0] == c[0] and a[1] == c[1]\n\n    # @cuda.jit\n    def closed_segment_intersect(self, a, b, c, d):\n        """""" Verifies if closed segments a, b, c, d do intersect.\n        """"""\n        if a == b:\n            return a == c or a == d\n        if c == d:\n            return c == a or c == b\n\n        # TODO ao inves de invocar a funcao side, colocar a formula aqui\n        s1 = self.side(a, b, c)\n        s2 = self.side(a, b, d)\n\n        # All points are collinear\n        if s1 == 0 and s2 == 0:\n            # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n            return \\\n                self.is_point_in_closed_segment(a, b, c) or self.is_point_in_closed_segment(a, b, d) or \\\n                self.is_point_in_closed_segment(c, d, a) or self.is_point_in_closed_segment(c, d, b)\n\n        # No touching and on the same side\n        if s1 and s1 == s2:\n            return False\n\n        s1 = self.side(c, d, a)\n        s2 = self.side(c, d, b)\n\n        # No touching and on the same side\n        if s1 and s1 == s2:\n            return False\n\n        return True\n\n\n    ## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n    ## @numba.jit(""float64( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n    ## @numba.jit(target=\'cpu\', forceobj=True)\n    def absorption_in_walls(self, access_point, destiny, walls):\n        # Seus pontos (origem, destino)\n        # AccessPoint = [0,0]\n        # Destino = [899, 579]\n\n        intersections = 0\n\n        # tSum=0\n        # for line in walls:\n        #     # Coordenadas da parede\n        #     wall_xy_a = line[0:2]\n        #     wall_xy_b = line[2:4]\n        #\n        #     ##TODO 2.5 microseg ==> Reduzir o tempo do closed_segment_intersect por sera realizado 1,5 bilh\xc3\xa3o de vezes!!!!!\n        #     t0 = datetime.now()\n        #     if self.closed_segment_intersect(access_point, destiny, wall_xy_a, wall_xy_b):\n        #         intersections += 1\n        #\n        #     tSum+=(datetime.now() - t0).microseconds\n        #\n        # print( round(tSum / len(walls),2) )\n\n        intersections = (sum(1 for _ in (map(lambda x: intersect(access_point, destiny, x[0:2], x[2:4]), walls))))\n\n        # b = filter(lambda x: x != 0, a)\n\n        # intersections = len(list(b))\n\n        # print(""Res: "" + str(intersections))\n\n        # print(""paredes: "" + str(sum(list(a))))\n\n        # for line in walls:\n        #     if self.intersect(access_point, destiny, line[0:2], line[2:4]):\n        #         intersections += 1\n\n        intersecoes_com_paredes = intersections / 2\n        # print(""intersecoes_com_paredes = "" + str(intersecoes_com_paredes))\n\n        # dBm_absorvido_por_parede = 0.01\n        # miliWatts_absorvido_por_parede = pow(10, (dBm_absorvido_por_parede / 10))\n        miliWatts_absorvido_por_parede = 1\n\n        # if debug:\n        #     print(""Access Point "" + str(access_point))\n        #     print(""Destiny "" + str(destiny))\n        #     # print(""Perda por parede: (dBm) "" + str(dBm_absorvido_por_parede))\n        #     print(""Perda por parede: (mW) "" + str(miliWatts_absorvido_por_parede))\n        #     print(""N\xc2\xba de intercess\xc3\xb5es: "" + str(intersecoes_com_paredes))\n\n        return intersecoes_com_paredes * miliWatts_absorvido_por_parede\n\n    def get_monitor_size(self):\n        """"""\n        M\xc3\xa9todo que identifica o tamanho da tela do computador.\n        :return: Retorna os valores de largura e altura.\n        """"""\n        root = tk.Tk()\n        return root.winfo_screenwidth(), root.winfo_screenheight()\n\n    def mw_to_dbm(self, mW):\n        """"""\n        M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n        :param mW: Valor em miliwatts.\n        :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n        """"""\n        return 10. * log10(mW)\n\n    def dbm_to_mw(self, dBm):\n        """"""\n        M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n        :param dBm: Valor em decib\xc3\xa9is.\n        :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n        """"""\n        return 10 ** (dBm / 10.)\n\n    def hex_to_rgb(self, hex):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n        :param hex: Valor em hexadecimal da cor.\n        :return: Tupla representando a cor em formato RGB.\n        """"""\n        hex = str(hex).lstrip(\'#\')\n        return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n\n    def draw_line(self, x1, y1, x2, y2, color):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n        :param x1: Valor de X no ponto 1.\n        :param y1: Valor de Y no ponto 1.\n        :param x2: Valor de X no ponto 2.\n        :param y2: Valor de Y no ponto 2.\n        :param color: Cor que a linha ir\xc3\xa1 ter.\n        :return: None\n        """"""\n        pygame.draw.line(self.DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n    def draw_point(self, color, x, y):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n        :param color: A cor que ir\xc3\xa1 ser o ponto.\n        :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n        :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n        :return: None.\n        """"""\n        pygame.draw.line(self.DISPLAYSURF, color, (x, y), (x, y))\n\n    def draw_floor_plan(self, floor_plan):\n\n        for line in floor_plan:\n            self.draw_line(line[0], line[1], line[2], line[3], self.WHITE)\n\n        # Atualiza a janela do PyGame para que exiba a imagem\n        pygame.display.update()\n\n    def calc_distance(self, x1, y1, x2, y2):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n        :param x1: Valor de X no ponto 1.\n        :param y1: Valor de Y no ponto 1.\n        :param x2: Valor de X no ponto 2.\n        :param y2: Valor de Y no ponto 2.\n        :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n        """"""\n        return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0))\n\n    def frequency(self):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por calcular a frequ\xc3\xaancia de acordo com o canal.\n        :return: Frequ\xc3\xaancia do canal.\n        """"""\n        return (2.407 + (5 * self.CHANNEL) / 1000) * 10 ** 9\n\n    def wave_length(self):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por calcular o comprimento de onda como raz\xc3\xa3o a velocidade da luz da frequ\xc3\xaancia do canal.\n        :return: Comprimento de onda de acordo com a frequ\xc3\xaancia.\n        """"""\n        C = 299792458\n        return C / self.frequency()\n\n    def path_loss(self, d):\n        """"""\n        Perda no caminho (Path Loss) mensurado em dB.\n        :param d: Dist\xc3\xa2cia.\n        :return: Perda no caminho.\n        """"""\n        return 20 * log10((4 * pi * d) / self.wave_length())\n\n    def two_ray_ground_reflection_model(self, Pt, Gt, Gr, Ht, Hr, d, L):\n        """"""\n        Pr\n        """"""\n        return (Pt * Gt * Gr * pow(Ht, 2) * pow(Hr, 2)) / (pow(d, 4) * L)\n\n    def free_space_model(self, Pt, Gt, Gr, lamb, d, L):\n        """"""\n        Pr\n        """"""\n        return (Pt * Gt * Gr * (pow(lamb, 2))) / (pow((4 * pi), 2) * pow(d, 2) * L)\n\n    def log_distance(self, d0, d, gamma):\n        """"""\n        Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n        e do ganho das antenas transmissora e receptora.\n        Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n        :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n        :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n        :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n        :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n        """"""\n        # return path_loss(d) + 10 * gamma * log10(d / d0)\n        return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    def tree_par_log(self, x):\n        return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n    # @cuda.jit\n    def propagation_model(self, x, y, access_point):\n\n        d = self.calc_distance(x, y, access_point[0], access_point[1])\n\n        ## 00.1 segundos para cada FuncaoObjetivo com absorption_in_walls\n        loss_in_wall = 0\n\n        ## TODO 500 microsec absoprtion_in_walls\n\n\n\n        loss_in_wall = self.absorption_in_walls(access_point=access_point, destiny=[x, y], walls=self.floor_plan)\n\n        # print(str((datetime.now() - inicio).microseconds) + "" segundos ==> absorption_in_walls"")\n\n        # print(""loss_in_wall = "" + str(loss_in_wall))\n\n        if d == 0:\n            d = 1\n        gamma = 5\n\n        ## 10 microsec por tree_par_log\n\n        # value = self.log_distance(1, d, gamma)\n        value = self.tree_par_log(d) - loss_in_wall\n        # value = self.tree_par_log(d)\n\n        return value\n\n    def print_matriz(self, matrix):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por imprimir a matriz em um arquivo.\n        :param matrix: Matriz N x M.\n        :return: None.\n        """"""\n        print(""Escrevendo matrix no arquivo de saida..."")\n        print(""Diman\xc3\xa7\xc3\xb5es na matrix: "" + str(np.shape(matrix)))\n        f = open(\'saida_passo_01\', \'w\')\n        for line in matrix:\n            for value in line:\n                f.write(str(value) + ""\\t"")\n            f.write(\'\\n\')\n        f.close()\n        print(""Matriz salva no arquivo."")\n\n    def print_pygame(self, matrix_results, access_point):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n        :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n        :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n        :return: None.\n        """"""\n        matrix_max_value = matrix_results.max()\n        matrix_min_value = matrix_results.min()\n\n        # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n        # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n        for x in range(self.WIDTH):\n            for y in range(self.HEIGHT):\n                color = self.get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n                self.draw_point(color, x, y)\n\n        # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o do Access Point\n        ap = access_point\n        self.draw_point(self.RED, ap[0], ap[1])\n\n        # self.draw_floor_plan(self.floor_plan)\n\n        # Atualiza a janela do PyGame para que exiba a imagem\n        pygame.display.update()\n\n    def get_percentage_of_range(self, min, max, x):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n        :param min: Valor m\xc3\xadnimo do intervalo.\n        :param max: Valor m\xc3\xa1ximo do intervalo.\n        :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n        :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n        """"""\n        return ((x - min) / (max - min)) * 100\n\n    def get_value_in_list(self, percent, list):\n        """"""\n        M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n        :param percent: Valor float representando a porcentagem.\n        :param list: Lista com n n\xc3\xbameros.\n        :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n        """"""\n        position = (percent / 100) * len(list)\n        if position < 1:\n            position = 1\n        elif position >= len(list):\n            position = len(list)\n        return self.hex_to_rgb(list[int(position - 1)])\n\n    def get_color_of_interval(self, min, max, x):\n        """"""\n        Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n        este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n        :param min: Valor m\xc3\xadnimo do intervalo.\n        :param max: Valor m\xc3\xa1ximo do intervalo.\n        :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n        :return: Retorna uma tupla representando um cor no formato RGB.\n        """"""\n        percentage = self.get_percentage_of_range(min, max, x)\n        color = self.get_value_in_list(percentage, self.COLORS)\n        # print(\'Color: \' + str(color))\n        return color\n\n    def objective_function(self, matrix):\n        """"""\n        Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n        :param matrix: Matriz a ser avaliada.\n        :return: Retorna a soma de todos os elementos da metriz.\n        """"""\n        # g = 0\n        # for line in matrix:\n        #     for value in line:\n        #         g += value\n\n        return abs(np.sum(matrix))\n\n    def simulate(self, save_matrix=False, show_pygame=False, debug=False, access_point=None):\n        """"""\n        M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n        :param save_matrix: Flag que sinaliza se quero salvar a matriz de resultados em um arquivo.\n        :param show_pygame: Flag que sinaliza se quero exibir o resultado gr\xc3\xa1fico da simula\xc3\xa7\xc3\xa3o usando o PyGame.\n        :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n        :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n        """"""\n        # if debug:\n        #     print(""Iniciando simula\xc3\xa7\xc3\xa3o."")\n\n        # Marca o inicio da simula\xc3\xa7\xc3\xa3o\n        # inicio = datetime.now()\n\n\n        # if False:\n        #     # Inicia o PyGame\n        #     pygame.init()\n        #\n        #     # Configura o tamanho da janela\n        #     self.DISPLAYSURF = pygame.display.set_mode((self.WIDTH, self.HEIGHT), 0, 32)\n        #     pygame.display.set_caption(\'Simulando...\')\n\n        # Cria uma matriz para guardar os resultados calculados\n        # matrix_results = np.zeros(shape=(self.WIDTH, self.HEIGHT))\n        # matrix_results = np.zeros(shape=(int(self.largura_planta / self.precisao), int(self.comprimento_planta / self.precisao)))\n\n        # print(""Posi\xc3\xa7\xc3\xa3o do access point: "" + str(access_point))\n\n\n\n        # Preenche a matriz de resultados usando um modelo de propaga\xc3\xa7\xc3\xa3o\n        # t0 = datetime.now()\n\n        ## TODO: fix List Comprehension\n        matrix_results = [[self.propagation_model(x, y, access_point) for x in range(self.WIDTH)] for y in\n                          range(self.HEIGHT)]\n        matrix_results = np.array(matrix_results)\n\n        ## FOR\n        # for x in range(self.WIDTH):\n        #     #inicio = datetime.now()\n        #     for y in range(self.HEIGHT):\n        #         value = self.propagation_model(x, y, access_point)\n        #         matrix_results[x][y] = value\n        # print(str((datetime.now() - inicio).microseconds/1000.0 ) + "" milisegundos ==> por LINHA"")\n\n        # t1 = datetime.now()\n        # print(str((t1 - t0).seconds) + "" segundos ==> por MATRIZ"")\n\n\n        # Guarda os valores m\xc3\xa1ximo e m\xc3\xadnimo da matriz\n        matrix_max_value = matrix_results.max()\n        matrix_min_value = matrix_results.min()\n\n        # if show_pygame:\n        # Desenha a matriz usando o PyGame\n        # self.print_pygame(matrix_results, access_point)\n\n        # if save_matrix:\n        #     # Grava os valores da matriz no arquivo\n        #     self.print_matriz(matrix_results)\n        #\n        # if show_pygame:\n        #     # Atualiza o titulo da janela do PyGame\n        #     pygame.display.set_caption(\'Simula\xc3\xa7\xc3\xa3o terminada\')\n        #\n        # if debug:\n        #     # Marca o fim da simula\xc3\xa7\xc3\xa3o\n        #     fim = datetime.now()\n        #     # Exibe um resumo da simula\xc3\xa7\xc3\xa3o\n        #     print(\'Simula\xc3\xa7\xc3\xa3o terminada.\')\n        #     print(""\\nInicio: \\t"" + str(inicio.time()))\n        #     print(""Fim: \\t\\t"" + str(fim.time()))\n        #     print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str((fim - inicio).seconds) + "" segundos.\\n"")\n        #\n        #     print(""Maior valor da matriz: "" + str(matrix_max_value))\n        #     print(""Menor valor da matriz: "" + str(matrix_min_value))\n\n        # input(\'\\nPrecione qualquer tecla para encerrar a aplica\xc3\xa7\xc3\xa3o.\')\n\n        return matrix_results\n\n    # @numba.jit()\n    def get_point_in_circle(self, point, ray, round_values=True, num=1, absolute_values=True, debug=False):\n        """"""\n        M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n        :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n        :param ray: Valor do raio desejado.\n        :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n        valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n        :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n        :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n        :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n        refer\xc3\xaancia.\n        :return: Um ponto ou um conjunto de pontos do tipo float.\n        """"""\n\n        t = np.random.uniform(0.0, 2.0 * np.pi, num)\n        r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n        x = r * np.cos(t) + point[0]\n        y = r * np.sin(t) + point[1]\n\n        # Converte todos os valores negativos da lista em positivos\n        if absolute_values:\n            x = [abs(k) for k in x]\n            y = [abs(k) for k in y]\n\n        # if debug:\n        #     plt.plot(x, y, ""ro"", ms=1)\n        #     plt.axis([-15, 15, -15, 15])\n        #\n        #     for i in range(num):\n        #         print(""Dist\xc3\xa2ncia entre o ponto ({}, {}) ""\n        #               ""e o ponto ({}, {}) com raio [{}] = {}"".format(point[0], point[1], x[i], y[i], ray,\n        #                                                              self.calc_distance(point[0], point[1], x[i],\n        #                                                                                 y[i])))\n        #     plt.show()\n\n        if round_values:\n            x = [round(k) for k in x]\n            y = [round(k) for k in y]\n\n        # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n        if num == 1:\n            return [x[0], y[0]]\n        else:\n            return [x, y]\n\n    def starting_temperature(self):\n        """"""\n        Fun\xc3\xa7\xc3\xa3o que calcula a temperatura inicial;\n        :return:\n        """"""\n        return 100\n\n    def perturb(self, S):\n        """"""\n         Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n         Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n        :param S: Ponto atual.\n        :return: Retorna um ponto dentro do raio informado.\n        """"""\n        # Obtem um ponto aleatorio em um raio de X metros\n        return self.get_point_in_circle(point=S, ray=10)\n\n    def f(self, x):\n        """"""\n        Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n        :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n        :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n        """"""\n\n        inicio = datetime.now()\n\n        matrix_result = self.simulate(save_matrix=False, show_pygame=False, debug=False, access_point=x)\n\n        goal = self.objective_function(matrix_result)\n\n        # print(""Fun\xc3\xa7\xc3\xa3o objetivo: "" + str(goal))\n        print(str((datetime.now() - inicio).seconds) + "" segundos ==> por f(x)"")\n\n        # self.contador_uso_func_objetivo += 1\n\n        return goal\n\n    def randomize(self, ):\n        """"""\n        Fun\xc3\xa7\xc3\xa3o que gera um n\xc3\xbamero aleat\xc3\xb3rio no intervalo [0,1];\n        :return:\n        """"""\n\n        rand = random()\n\n        # print(""Randomiza: "" + str(rand))\n\n        return rand\n\n    def showSolution(self, S):\n        self.print_pygame(self.simulate(save_matrix=False, show_pygame=False, debug=False, access_point=S), S)\n        self.draw_floor_plan(self.floor_plan)\n\n    def simulated_annealing(self, S0, M, P, L, T0, alpha, debug=False):\n        """"""\n\n        :param T0: Temperatura inicial.\n        :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?.\n        :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n        :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n        :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n        :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n        :return: Retorna um ponto sendo o mais indicado.\n        """"""\n        S = S0\n        T = T0\n        j = 1\n\n        if debug:\n            print(""\\nIniciando Simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n            print(""Ponto inicial:\\t\\t\\t\\t\\t\\t\\t\\t"" + str(S0))\n            print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t\\t\\t"" + str(M))\n            print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(P))\n            print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(L))\n            print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t\\t"" + str(alpha))\n            # input(""Aperte qualquer tecla para continuar."")\n\n        fS = self.f(S0)\n\n        # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n        while True:\n            i = 1\n            nSucesso = 0\n\n            # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n            while True:\n\n                # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n                Si = self.perturb(S)\n                fSi = self.f(Si)\n\n                # self.show_solution(Si)\n                print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S) + ""\\t Si: "" + str(Si))\n\n                # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n                deltaFi = fSi - fS\n\n                # print(""deltaFi: "" + str(deltaFi))\n\n                ## Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n                ## Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n                # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n                if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # self.randomize()):\n                    # print(""Ponto escolhido: "" + str(Si))\n                    ## LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                    S = Si\n                    fS = fSi\n                    nSucesso = nSucesso + 1\n\n                    # self.show_solution(S)\n                    print(""melhor S: "" + str(S))\n\n                i = i + 1\n\n                if (nSucesso >= L) or (i > P):\n                    break\n\n            print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n            print(""temperat: "" + str(T) + ""\\n"")\n\n            # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n            T = alpha * T\n\n            # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n            j = j + 1\n\n            if (nSucesso == 0) or (j > M):\n                break\n\n        ## saiu do loop principal\n        # self.show_solution(S)\n        # print(""invocacoes de self.f(): "" + str(self.contador_uso_func_objetivo))\n        return S\n\n\n# def ccw(self, A, B, C):\n#     return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\n# @cuda.jit\n\n# @numba.jit(""uint8(uint16[:,:], uint16[:,:], uint16[:,:], uint16[:,:])"", target=\'cpu\')\ndef intersect(A, B, C, D):\n\n    # return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\n    if ((D[1] - A[1]) * (C[0] - A[0]) > (C[1] - A[1]) * (D[0] - A[0])) \\\n            != ((D[1] - B[1]) * (C[0] - B[0]) > (C[1] - B[1]) * (D[0] - B[0])) \\\n            and ((C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])) \\\n                    != ((D[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (D[0] - A[0])):\n        return 1\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n\n    if False:\n        p = Placement()\n\n        # w = p.read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-A-l.dxf"")\n        w = p.read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-porta.dxf"")\n\n        a = p.absorption_in_walls([0, 0], [237, 241], w)\n\n        p.draw_floor_plan(w)\n\n        input()\n\n    if True:\n        p = Placement()\n        # access_point = [0, 0]\n        # m = p.simulate_kernel(save_matrix=True, show_pygame=True, access_point=access_point)\n        # print(p.objective_function(matrix=m))\n\n        access_point = [0, 0]\n        ## sugest\xc3\xa3o: sortear o X,Y do ponto inicial (dentro da matriz)\n\n        ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n        max_inter = 600\n\n        ## p\n        max_pertub = 5\n\n        ## v\n        num_max_succ = 80\n\n        ## a\n        alpha = .85\n\n        ## t\n        temp_inicial = 300\n\n        # Marca o tempo do inicio da simula\xc3\xa7\xc3\xa3o\n        inicio = datetime.now()\n\n        point = p.simulated_annealing(S0=access_point, M=max_inter, P=max_pertub, L=num_max_succ, T0=temp_inicial,\n                                      alpha=alpha, debug=True)\n\n        # Marca o tempo do fim da simula\xc3\xa7\xc3\xa3o\n        fim = datetime.now()\n\n        time_seconds = (fim - inicio).seconds\n        time_minutes = time_seconds / 60\n\n        print(""\\nInicio: \\t"" + str(inicio.time()))\n        print(""Fim: \\t\\t"" + str(fim.time()))\n        print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str(time_seconds) + "" segundos ("" + str(round(time_minutes, 2)) + "" minutos).\\n"")\n\n        print(""Melhor ponto sugerido pelo algoritmo: "" + str(point))\n        input(\'\\nPrecione qualquer tecla para encerrar a aplica\xc3\xa7\xc3\xa3o.\')\n'"
debugs/PlacementAPs.py,27,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nimport math\nimport profile\nimport random as rd\nfrom math import sqrt, log10, exp\nfrom random import random\n\nimport ezdxf\nimport numpy as np\nimport pygame\nfrom colour import Color\nfrom numba import cuda, jit\n\nimport cProfile\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    ##TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float32( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    ## OBS.: dividir por dois se cada parede for um retangulo no DXF\n    # intersecoes_com_paredes = intersections / 2\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precisao em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    dbm_absorvido_por_parede = 8\n\n    return intersecoes_com_paredes * dbm_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precisao\n\n\n@jit\ndef log_distance(d, gamma=3, d0=1, Pr_d0=-60, Pt=-17):\n    """"""\n       Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n       e do ganho das antenas transmissora e receptora.\n       Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n       :param Pr_d0:\n       :param Pt:\n       :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n       :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n       :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n       :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n       """"""\n\n    ## path_loss(d0) + 10 * gamma * log10(d / d0)\n    ## HAVIAMOS CODIFICADO ASSIM PARA ECONOMIZAR 1 SUBTRACAO e 1 VAR\n    # return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    ## REESCREVI FACILITAR A COMPREENSAO\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    # return 0 - (PL + 10 * gamma * log10(d / d0) )\n    # return   - (PL + 10 * gamma * log10(d / d0) )\n    # return   -PL   - 10 * gamma * log10(d / d0)\n    # return   -(Pt-Pr0)   - (10 * gamma * log10(d / d0))\n    # return   -Pt + Pr0   - (10 * gamma * log10(d / d0))\n    # return   Pr0  - 10 * gamma * log10(d / d0) - Pt\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef log_distance_v2(d, gamma=3, d0=10, Pr_d0=-69, Pt=-20):\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef two_par_logistic(x):\n    # https://en.wikipedia.org/wiki/Logistic_distribution#Related_distributions\n    return Pt_dBm - (-15.11596 * math.log10(x * 2.1642))\n\n\n@jit\ndef four_par_log(x):\n    A = 79.500\n    B = -38\n    C = -100.000\n    D = 0.0\n    E = 0.005\n\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef five_par_log(x):\n    A = 84.0\n    B = -48\n    C = -121.0\n    D = -5.0\n    E = 0.005\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    # value = log_distance(d, 3, 11, -72, -20) - loss_in_wall\n    # value = log_distance(d, 3, 1, -60, -17) - loss_in_wall\n    # value = log_distance(d, 3, 10, -69, -20) - loss_in_wall\n    # value = four_par_log(d) - loss_in_wall\n    value = five_par_log(d) - loss_in_wall\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    # def objective_function(x):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    ##TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    ## Desabilitado pois \'ficou pesado\'.\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < minSensibilidade:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n\n    ## TODO: Penalizar os valores que est\xc3\xa3o abaixo da sensibilidade.\n    return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@cuda.jit\ndef objective_function_kernel(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param soma:\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    W = len(matrix)\n    H = len(matrix[0])\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, W, gridX):\n        for y in range(startY, H, gridY):\n            soma += matrix[x][y]\n\n\ndef simulate_cpu(apX, apY, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param apY:\n    :param apX:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    matrix_results = np.zeros(shape=(WIDTH, HEIGHT))\n\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            value = propagation_model(x, y, apX, apY, floor_plan)\n            matrix_results[x][y] = value\n\n    return matrix_results\n\n\n@cuda.jit\ndef simulate_kernel(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param apY:\n    :param apX:\n    :param matrix_results:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, WIDTH, gridX):\n        for y in range(startY, HEIGHT, gridY):\n            matrix_results[x][y] = propagation_model_gpu(x, y, apX, apY, floor_plan)\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n\n# TODO copiar a vers\xc3\xa3o mais enxuta do PlacementGPUaps.py\n\n# def get_point_in_circle(pointX, pointY, ray, round_values=True, num=1, absolute_values=True):\n#     """"""\n#     M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n#     :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n#     :param ray: Valor do raio desejado.\n#     :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n#     valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n#     :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n#     :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n#     :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n#     refer\xc3\xaancia.\n#     :return: Um ponto ou um conjunto de pontos do tipo float.\n#     """"""\n#\n#     t = np.random.uniform(0.0, 2.0 * np.pi, num)\n#     r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n#\n#     x = r * np.cos(t) + pointX\n#     y = r * np.sin(t) + pointY\n#\n#     # Converte todos os valores negativos da lista em positivos\n#     if absolute_values:\n#         x = [abs(k) for k in x]\n#         y = [abs(k) for k in y]\n#\n#     if round_values:\n#         x = [round(k) for k in x]\n#         y = [round(k) for k in y]\n#\n#     # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n#     if num == 1:\n#         return [x[0], y[0]]\n#     else:\n#         return [x, y]\n\n@jit\ndef get_point_in_circle(pointX, pointY, ray):\n    """"""\n    M\xc3\x83\xc2\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xa3o [x, y] de refer\xc3\x83\xc2\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    valores discretos para posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xb5es da matriz.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n    num = 1\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n\n    x = round(abs(x[0]))\n    y = round(abs(y[0]))\n\n    return list([x, y])\n\n\n@jit\ndef perturba_array(S_array, size):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param size:\n    :param S_array:\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    novoS = np.empty([num_aps, 2], np.float32)\n\n    for i in range(size):\n        # Obtem um ponto aleatorio em um raio de X metros\n        novoS[i] = get_point_in_circle(S_array[i][0], S_array[i][1], RAIO_PERTURBACAO)\n\n    return novoS\n\n\n@jit\ndef perturba(S):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n\n    return get_point_in_circle(S[0], S[1], RAIO_PERTURBACAO)\n\n\n@jit\ndef avalia_array(S_array, size):\n    matrizes_propagacao = []\n    for i in range(size):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    ## TODO: s\xc3\xb3 pra testes, simples demais\n    # fo_APs = 0\n    # for i in range(size):\n    #     fo_APs += objective_function(matrizes_propagacao[i])\n    #\n    # return fo_APs\n\n    ## simplesmente guloso\n    # matriz_sobreposta = sobrepoe_solucoes_MAX(matrizes_propagacao, size)\n\n    ## penaliza APs muito proximos\n    matriz_sobreposta = sobrepoe_solucoes_DIV_dBm(matrizes_propagacao, size)\n\n    return objective_function(matriz_sobreposta)\n\n\n@jit\ndef sobrepoe_solucoes_MAX(propagation_array, size):\n    max = propagation_array[0]\n    for i in range(1, size):\n        max = np.maximum(propagation_array[i], max)\n\n    return max\n\n\n@jit\ndef sobrepoe_solucoes_SUB(propagation_array, size):\n    sub = propagation_array[0]\n    for i in range(1, size):\n        sub = np.subtract(propagation_array[i], sub)\n\n    return sub\n\n\n@jit\ndef sobrepoe_solucoes_DIV_dBm(propagation_array, size):\n    # verificar se \xc3\xa9 veridico\n    if size == 1:\n        return propagation_array[0]\n\n    matrixMin = propagation_array[0]\n    matrixMax = propagation_array[0]\n\n    for i in range(1, size):\n        matrixMin = np.minimum(propagation_array[i], matrixMin)\n        matrixMax = np.maximum(propagation_array[i], matrixMax)\n\n    ## pois ao subtrair dBm, deve ser o maior/menor\n    sub = np.divide(matrixMax, matrixMin)\n\n    return sub\n\n\n@jit\ndef simula_propagacao(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param pointX:\n    :param pointY: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n\n    if ENVIRONMENT == ""GPU"":\n\n        g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n        blockDim = (48, 8)\n        gridDim = (32, 16)\n\n        d_matrix = cuda.to_device(g_matrix)\n\n        simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n        d_matrix.to_host()\n\n        # ----------------------------------------------------------------------------\n\n        # g_matrix = np.asmatrix(g_matrix, dtype=np.float32)\n        # g_soma = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n        #\n        # d_matrix = cuda.to_device(g_matrix)\n        # d_soma = cuda.to_device(g_soma)\n        #\n        # objective_function_kernel[gridDim, blockDim](d_matrix, d_soma)\n        #\n        # d_matrix.to_host()\n        # d_soma.to_host()\n        #\n        # return abs(np.sum(g_soma))\n        # return objective_function(g_matrix)\n\n        return g_matrix\n    elif ENVIRONMENT == ""CPU"":\n        return simulate_cpu(pointX, pointY, floor_plan)\n\n    else:\n        exit(-1)\n\n\ndef simulated_annealing(size, M, P, L, T0, alpha):\n    """"""\n    :param size:\n    :param T0: Temperatura inicial.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n\n    # cria Solu\xc3\xa7\xc3\xb5es iniciais com pontos aleat\xc3\xb3rios para os APs\n    S_array = np.empty([size, 2], np.float32)\n\n    for i in range(size):\n        # S_array[i] = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n        S_array[i] = [WIDTH * 0.5, HEIGHT * 0.5]\n\n    S0 = S_array.copy()\n    print(""Solu\xc3\xa7\xc3\xa3o inicial:\\n"" + str(S0))\n\n    fS = avalia_array(S_array, size)\n\n    T = T0\n    j = 1\n\n    i_ap = 0\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            # Si = perturb(S[0], S[1])\n            # fSi = f(Si[0], Si[1])\n\n            # TODO perturbar todos\n            # Si_array = perturba_array(S_array, num_aps)\n            Si_array = S_array.copy()\n\n            # a cada itera\xc3\xa7\xc3\xa3o do SA, perturba um dos APs\n            i_ap = (i_ap + 1) % num_aps\n\n            Si_array[i_ap] = perturba(S_array[i_ap])\n\n            fSi = avalia_array(Si_array, num_aps)\n\n            # show_solution(Si) print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S_array)\n            #  + ""\\t Si: "" + str(Si_array))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            # Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            # Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                # LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S_array = Si_array\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n\n    print(""Dist\xc3\xa2ncia da solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(sobrepoe_solucoes_SUB(S_array, num_aps)))\n\n    return S_array\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    # hex = str(hex).lstrip(\'#\')\n    # return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n\n    hex = str(hex).lstrip(\'#\')\n    lv = len(hex)\n    return tuple(int(hex[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n    # corR = int(Color(hex).get_red() * 255)\n    # corG = int(Color(hex).get_green() * 255)\n    # corB = int(Color(hex).get_blue() * 255)\n    #\n    # return tuple([corR, corG, corB])\n\n\ndef draw_line(DISPLAYSURF, x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame(matrix_results, access_points, DISPLAYSURF):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param DISPLAYSURF:\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_points: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n    # matrix_max_value = matrix_results.max()\n    # matrix_min_value = matrix_results.min()\n\n    # testes\n    matrix_max_value = -100\n    matrix_min_value = -10\n\n    # Se utilizar a fun\xc3\xa7\xc3\xa3o min tradicionar, a penaliza\xc3\xa7\xc3\xa3o de DBM_MIN_VALUE ir\xc3\xa1 interferir no range de cor\n    # matrix_min_value = matrix_max_value\n    # for x in range(WIDTH):\n    #     for y in range(HEIGHT):\n    #         if matrix_results[x][y] != DBM_MIN_VALUE and matrix_results[x][y] < matrix_min_value:\n    #             matrix_min_value = matrix_results[x][y]\n\n                # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(DISPLAYSURF, color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o dos Access Points\n    for ap in access_points:\n        draw_point(DISPLAYSURF, RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(DISPLAYSURF, color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param DISPLAYSURF:\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan, DISPLAYSURF):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(DISPLAYSURF, line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    ##TODO escala de cor linear, mas poderia ser exponencial (logaritmica)\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n    # return list[int(position - 1)]\n\n\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n\n    # if x < SENSITIVITY:\n    #     return hex_to_rgb(""#000000"")\n\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n\n    return color\n\n\ndef showSolution(S_array, DISPLAYSURF):\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyGame."")\n\n    matrizes_propagacao = []\n\n    for i in range(len(S_array)):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    # propagacao = sobrepoe_solucoes_ADD(matrizes_propagacao, len(S_array))\n    propagacao = sobrepoe_solucoes_MAX(matrizes_propagacao, len(S_array))\n\n    print_pygame(propagacao, S_array, DISPLAYSURF)\n\n    draw_floor_plan(walls, DISPLAYSURF)\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    # cores = list(Color(""blue"").range_to(Color(""red""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n\n    return cores\n\n\ndef run():\n    print(""\\nIniciando simula\xc3\xa7\xc3\xa3o com simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""Temperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""Repeti\xc3\xa7\xc3\xb5es do Simulated Annealing:\\t\\t"" + str(max_SA) + ""\\n"")\n\n    print(""Raio de perturba\xc3\xa7\xc3\xa3o:\\t\\t\\t\\t"" + str(RAIO_PERTURBACAO))\n    print(""Simulando ambiente com :\\t\\t\\t"" + str(WIDTH) + ""x"" + str(HEIGHT) + "" pixels"")\n    print(""Escala de simula\xc3\xa7\xc3\xa3o da planta:\\t\\t\\t1 px : "" + str(escala) + "" metros"")\n    print(""Ambiente de simula\xc3\xa7\xc3\xa3o:\\t\\t\\t\\t"" + str(ENVIRONMENT) + ""\\n"")\n\n    # variasSolucoes = []\n    #\n    # for i in range(max_SA):\n    #     print(""Calculando o melhor ponto ["" + str(i) + ""]"")\n    #     variasSolucoes.append(\n    #         simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha))\n    #\n    # maxFO = 0\n    # bestSolution = variasSolucoes[0]\n    #\n    # print(""Analizando a melhor solu\xc3\xa7\xc3\xa3o."")\n    #\n    # for ap_array in variasSolucoes:\n    #     ap_array_fo = avalia_array(ap_array)\n    #     if ap_array_fo > maxFO:\n    #         maxFO = ap_array_fo\n    #         bestSolution = ap_array\n\n    # bestSolution = simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha)\n    # bestSolution_fo = avalia_array(bestSolution, len(bestSolution))\n\n    # x = 1230\n    # y = 360\n    # xx = (1610/864)*660\n    # yy = (600/435)*260\n\n    xx = 1175\n    yy = 360\n\n    bestSolution = [[xx, yy]]\n\n    # print(""\\nMelhor ponto sugerido pelo algoritmo: "" + str(bestSolution) + ""\\n FO: "" + str(bestSolution_fo))\n    #\n    # # Inicia o PyGame\n    pygame.init()\n    #\n    # # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n    #\n    showSolution(bestSolution, DISPLAYSURF)\n    # # show_solution(1, 1)\n    #\n    input(\'\\nFim de execu\xc3\xa7\xc3\xa3o.\')\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    COLORS = get_color_gradient(25)\n\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    Pt_dBm = -20\n\n    # ENVIRONMENT = ""GPU""\n    ENVIRONMENT = ""CPU""\n\n    # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n    # dxf_path = ""../DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n    # dxf_path = ""../DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n    # dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\n    dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n    escala = 1\n    # walls = read_walls_from_dxf(""./DXFs/bloco-A-l.dxf"")\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n    ## carreguei a planta so para obter a proporcao\n    proporcao_planta = comprimento_planta / largura_planta\n\n    # HEIGHT = int(largura_planta)\n    # WIDTH = int(comprimento_planta)\n    HEIGHT = 600  # 40\n    WIDTH = int(HEIGHT * proporcao_planta)\n\n    escala = HEIGHT / largura_planta\n    # escala = WIDTH / comprimento_planta\n    # precisao = 1  # metro\n    precisao = 36.0 / WIDTH\n\n    # walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-sem-porta.dxf"")\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    SENSITIVITY = -90\n    DBM_MIN_VALUE = np.finfo(np.float32).min\n\n    ## Quantidade de APs\n    num_aps = 1\n\n    ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600 * num_aps\n\n    ## p\n    max_pertub = 5\n\n    # RAIO_PERTURBACAO = WIDTH * 0.01\n    # RAIO_PERTURBACAO = WIDTH * 0.0175\n    RAIO_PERTURBACAO = WIDTH * 0.025\n\n    ## v\n    num_max_succ = 80\n\n    ## a\n    alpha = .85\n\n    ## t\n    temp_inicial = 300 * 2\n\n    ## m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n\n    # run()\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    ## python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    ## cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n'"
debugs/PlacementAPsCPU.py,21,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\nimport cProfile\nimport math\nimport random as rd\nfrom math import sqrt, log10, exp\nfrom random import random\n\nimport ezdxf\nimport numpy as np\nimport pygame\nfrom colour import Color\nfrom numba import cuda, jit\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    ##TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float32( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    ## OBS.: dividir por dois se cada parede for um retangulo no DXF\n    # intersecoes_com_paredes = intersections / 2\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precisao em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    dbm_absorvido_por_parede = 8\n\n    return intersecoes_com_paredes * dbm_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precisao\n\n\n@jit\ndef log_distance(d0, d, gamma):\n    """"""\n    Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n    e do ganho das antenas transmissora e receptora.\n    Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n    :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n    :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n    :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n    :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n    """"""\n    # return path_loss(d) + 10 * gamma * log10(d / d0)\n    return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    ## TODO XXX voltar pra 17 dBm\n    # return -10  - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n    # return 1  - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    ## outra coisa: quando conseguir adaptar o SA para varios APs (ex.: 2 ou 3), acho que convem testar uma alteracao\n    # no propagation_model: zerarmos de acordo com a sensibilidade na propria matriz de propagacao ao inves de somente\n    # no showSolucao. Talvez o SA convirja mais rapido do que deixarmos os dBms inuteis\n\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = 0\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    value = log_distance(1, d, 3) - loss_in_wall\n\n    # value = tree_par_log(d) - loss_in_wall\n    # value = loss_in_wall\n    # value = tree_par_log(d)\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    # def objective_function(x):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    ##TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < minSensibilidade:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n    return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@jit\ndef objective_function(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    soma = abs(np.sum(matrix))\n\n\n@jit\ndef simulate(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    for x in range(WIDTH):\n        # inicio = datetime.now()\n        for y in range(HEIGHT):\n            value = propagation_model(x, y, apX, apY, floor_plan)\n            matrix_results[x][y] = value\n\n    return matrix_results\n\n#TODO copiar a vers\xc3\xa3o mais limpa do Placement2.py\ndef get_point_in_circle(pointX, pointY, ray, round_values=True, num=1, absolute_values=True):\n    """"""\n    M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n    valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n    :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n    :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n    :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n    refer\xc3\xaancia.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n    if absolute_values:\n        x = [abs(k) for k in x]\n        y = [abs(k) for k in y]\n\n    if round_values:\n        x = [round(k) for k in x]\n        y = [round(k) for k in y]\n\n    # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n    if num == 1:\n        return [x[0], y[0]]\n    else:\n        return [x, y]\n\n\n@jit\ndef perturba_array(S_array, size):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    novoS = np.empty([num_aps, 2], np.float32)\n\n    for i in range(size):\n        # Obtem um ponto aleatorio em um raio de X metros\n        novoS[i] = get_point_in_circle(S_array[i][0], S_array[i][1], RAIO_PERTURBACAO)\n\n    return novoS\n\n\n@jit\ndef perturba(S):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n\n    return get_point_in_circle(S[0], S[1], RAIO_PERTURBACAO)\n\n\n@jit\ndef avalia_array(S_array, size):\n    # matrizes_propagacao = np.empty(size, np.float32)\n    matrizes_propagacao = []\n    for i in range(size):\n        print(S_array[i][0], S_array[i][1])\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n        ## TODO: s\xc3\xb3 pra testes, simples demais\n    # fo_APs = 0\n    # for i in range(size):\n    #     fo_APs += objective_function(matrizes_propagacao[i])\n    #\n    # return fo_APs\n\n    ## simplesmente guloso\n    # matriz_sobreposta = sobrepoe_solucoes_MAX(matrizes_propagacao, size)\n\n    ## penaliza APs muito proximos\n    matriz_sobreposta = sobrepoe_solucoes_SUB_dBm(matrizes_propagacao, size)\n\n    return objective_function(matriz_sobreposta)\n\n\n@jit\ndef sobrepoe_solucoes_MAX(propagation_array, size):\n    ## TODO: implementar o max das matrizes\n    max = propagation_array[0]\n    for i in range(1, size):\n        max = np.maximum(propagation_array[i], max)\n\n    return max\n\n\n@jit\ndef sobrepoe_solucoes_SUB(propagation_array, size):\n    ## TODO: implementar o max das matrizes\n    max = propagation_array[0]\n    for i in range(1, size):\n        max = np.subtract(propagation_array[i], max)\n\n    return max\n\n\n@jit\ndef sobrepoe_solucoes_SUB_dBm(propagation_array, size):\n    matrixMin = propagation_array[0]\n    matrixMax = propagation_array[0]\n\n    for i in range(1, size):\n        matrixMin = np.minimum(propagation_array[i], matrixMin)\n        matrixMax = np.maximum(propagation_array[i], matrixMax)\n\n    ## pois ao subtrair dBm, deve ser o maior/menor\n    sub = np.divide(matrixMax, matrixMin)\n\n    return sub\n\n\n@jit\ndef simula_propagacao(apX, apY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n\n    matrix_results = np.empty([WIDTH, HEIGHT], np.float32)\n    matrix_results = simulate(apX, apY, matrix_results, floor_plan)\n\n    goal = objective_function(matrix_results)\n\n    return goal\n\n\ndef simulated_annealing(size, M, P, L, T0, alpha):\n    """"""\n    :param T0: Temperatura inicial.\n    :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n\n    ## cria Solu\xc3\xa7\xc3\xb5es iniciais com pontos aleat\xc3\xb3rios para os APs\n    S_array = np.empty([size, 2], np.float32)\n\n    for i in range(size):\n        # S_array[i] = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n        S_array[i] = [WIDTH * 0.50, HEIGHT * 0.50]\n\n    S0 = S_array.copy()\n    print(""Solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(S0))\n\n    print(""\\nlen="" + str(len(S_array)) + "" size="" + str(size))\n\n    fS = avalia_array(S_array, size)\n\n    T = T0\n    j = 1\n\n    i_ap = 0\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            # Si = perturb(S[0], S[1])\n            # fSi = f(Si[0], Si[1])\n\n            ## TODO perturbar todos\n            # Si_array = perturba_array(S_array, num_aps)\n            Si_array = S_array.copy()\n\n            ## a cada itera\xc3\xa7\xc3\xa3o do SA, perturba um dos APs\n            i_ap = (i_ap + 1) % num_aps\n\n            Si_array[i_ap] = perturba(S_array[i_ap])\n\n            fSi = avalia_array(Si_array, num_aps)\n\n            # show_solution(Si)\n            # print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S_array) + ""\\t Si: "" + str(Si_array))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            ## Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            ## Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                ## LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S_array = Si_array\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n\n    print(""Dist\xc3\xa2ncia da solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(sobrepoe_solucoes_SUB(S_array, num_aps)))\n\n    return S_array\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    # hex = str(hex).lstrip(\'#\')\n    # return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n    hex = str(hex).lstrip(\'#\')\n    lv = len(hex)\n    return tuple(int(hex[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n\ndef draw_line(x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame(matrix_results, access_points):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n    matrix_max_value = matrix_results.max()\n    matrix_min_value = matrix_results.min()\n    # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o do Access Point\n    for ap in access_points:\n        draw_point(RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    ##TODO escala de cor linear, mas poderia ser exponencial (logaritmica)\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n    # return list[int(position - 1)]\n\n\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n    # SENSITIVITY = 3.1622776601683793319988935444327185337195551393252168e-9 # -85\n    # SENSITIVITY = 3.1622776601683793319988935444327185337195551393252168e-8 # -75\n    # SENSITIVITY = 1e-10 # -100\n    # SENSITIVITY = -85\n    # SENSITIVITY = -75\n    SENSITIVITY = -100\n    if x < SENSITIVITY:\n        return hex_to_rgb(""#000000"")\n\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n    return color\n\n\ndef showSolution(S_array):\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyGame."")\n\n    matrizes_propagacao = []\n\n    for i in range(len(S_array)):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    # propagacao = sobrepoe_solucoes_ADD(matrizes_propagacao, len(S_array))\n    propagacao = sobrepoe_solucoes_MAX(matrizes_propagacao, len(S_array))\n\n    print_pygame(propagacao, S_array)\n\n    draw_floor_plan(walls)\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n    return cores\n\n\n\ndef run():\n    print(""\\nIniciando simula\xc3\xa7\xc3\xa3o com simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""Temperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""Repeti\xc3\xa7\xc3\xb5es do Simulated Annealing:\\t\\t"" + str(max_SA) + ""\\n"")\n    print(""Raio de perturba\xc3\xa7\xc3\xa3o:\\t\\t"" + str(RAIO_PERTURBACAO) + ""\\n"")\n    print(""Simulando ambiente com :\\t\\t"" + str(WIDTH) + ""x"" + str(HEIGHT) + "" pixels\\n"")\n    print(""Escala de simula\xc3\xa7\xc3\xa3o da planta:\\t\\t 1 px : "" + str(escala) + "" metros\\n"")\n\n    # variasSolucoes = []\n    #\n    # for i in range(max_SA):\n    #     print(""Calculando o melhor ponto ["" + str(i) + ""]"")\n    #     variasSolucoes.append(\n    #         simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha))\n    #\n    # maxFO = 0\n    # bestSolution = variasSolucoes[0]\n    #\n    # print(""Analizando a melhor solu\xc3\xa7\xc3\xa3o."")\n    #\n    # for ap_array in variasSolucoes:\n    #     ap_array_fo = avalia_array(ap_array)\n    #     if ap_array_fo > maxFO:\n    #         maxFO = ap_array_fo\n    #         bestSolution = ap_array\n\n    # bestSolution = simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha)\n    # bestSolution_fo = avalia_array(bestSolution, len(bestSolution))\n\n    # x = 1230\n    # y = 360\n    # xx = (1610/864)*660\n    # yy = (600/435)*260\n\n    xx = 1175\n    yy = 360\n\n    bestSolution = [[xx, yy]]\n\n    # print(""\\nMelhor ponto sugerido pelo algoritmo: "" + str(bestSolution) + ""\\n FO: "" + str(bestSolution_fo))\n    #\n    # # Inicia o PyGame\n    pygame.init()\n    #\n    # # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n    #\n    showSolution(bestSolution, DISPLAYSURF)\n    # # show_solution(1, 1)\n    #\n    input(\'\\nFim de execu\xc3\xa7\xc3\xa3o.\')\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    COLORS = get_color_gradient(25)\n\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    Pt_dBm = -20\n\n    # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n    # dxf_path = ""../DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n    # dxf_path = ""../DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n    # dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\n    dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""../DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""../DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n    escala = 1\n    # walls = read_walls_from_dxf(""./DXFs/bloco-A-l.dxf"")\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n    ## carreguei a planta so para obter a proporcao\n    proporcao_planta = comprimento_planta / largura_planta\n\n    # HEIGHT = int(largura_planta)\n    # WIDTH = int(comprimento_planta)\n    HEIGHT = 600  # 40\n    WIDTH = int(HEIGHT * proporcao_planta)\n\n    escala = HEIGHT / largura_planta\n    # escala = WIDTH / comprimento_planta\n    # precisao = 1  # metro\n    precisao = 36.0 / WIDTH\n\n    # walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-sem-porta.dxf"")\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    SENSITIVITY = -90\n    DBM_MIN_VALUE = np.finfo(np.float32).min\n\n    ## Quantidade de APs\n    num_aps = 1\n\n    ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600 * num_aps\n\n    ## p\n    max_pertub = 5\n\n    # RAIO_PERTURBACAO = WIDTH * 0.01\n    # RAIO_PERTURBACAO = WIDTH * 0.0175\n    RAIO_PERTURBACAO = WIDTH * 0.025\n\n    ## v\n    num_max_succ = 80\n\n    ## a\n    alpha = .85\n\n    ## t\n    temp_inicial = 300 * 2\n\n    ## m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n\n    # run()\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    ## python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    ## cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n'"
debugs/PlacementAPs_CPUouGPU.py,24,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\nimport math\nimport profile\nimport random as rd\nfrom math import sqrt, log10, exp\nfrom random import random\n\nimport ezdxf\nimport numpy as np\nimport pygame\nfrom colour import Color\nfrom numba import cuda, jit\n\nimport cProfile\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    ##TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float32( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    ## OBS.: dividir por dois se cada parede for um retangulo no DXF\n    # intersecoes_com_paredes = intersections / 2\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precisao em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    dbm_absorvido_por_parede = 8\n\n    return intersecoes_com_paredes * dbm_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precisao\n\n\n@jit\ndef log_distance(d, gamma=3, d0=1, Pr_d0=-60, Pt=-17):\n    """"""\n       Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n       e do ganho das antenas transmissora e receptora.\n       Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n       :param Pr_d0:\n       :param Pt:\n       :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n       :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n       :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n       :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n       """"""\n\n    ## path_loss(d0) + 10 * gamma * log10(d / d0)\n    ## HAVIAMOS CODIFICADO ASSIM PARA ECONOMIZAR 1 SUBTRACAO e 1 VAR\n    # return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    ## REESCREVI FACILITAR A COMPREENSAO\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    # return 0 - (PL + 10 * gamma * log10(d / d0) )\n    # return   - (PL + 10 * gamma * log10(d / d0) )\n    # return   -PL   - 10 * gamma * log10(d / d0)\n    # return   -(Pt-Pr0)   - (10 * gamma * log10(d / d0))\n    # return   -Pt + Pr0   - (10 * gamma * log10(d / d0))\n    # return   Pr0  - 10 * gamma * log10(d / d0) - Pt\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef log_distance_v2(d, gamma=3, d0=10, Pr_d0=-69, Pt=-20):\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef two_par_logistic(x):\n    # https://en.wikipedia.org/wiki/Logistic_distribution#Related_distributions\n    return Pt_dBm - (-15.11596 * math.log10(x * 2.1642))\n\n\n@jit\ndef four_par_log(x):\n    A = 79.500\n    B = -38\n    C = -100.000\n    D = 0.0\n    E = 0.005\n\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef five_par_log(x):\n    A = 84.0\n    B = -48\n    C = -121.0\n    D = -5.0\n    E = 0.005\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return Pt_dBm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    # value = log_distance(d, 3, 11, -72, -20) - loss_in_wall\n    # value = log_distance(d, 3, 1, -60, -17) - loss_in_wall\n    # value = log_distance(d, 3, 10, -69, -20) - loss_in_wall\n    # value = four_par_log(d) - loss_in_wall\n    value = five_par_log(d) - loss_in_wall\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    # def objective_function(x):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    ##TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    ## Desabilitado pois \'ficou pesado\'.\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < minSensibilidade:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n\n    ## TODO: Penalizar os valores que est\xc3\xa3o abaixo da sensibilidade.\n    return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@cuda.jit\ndef objective_function_kernel(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param soma:\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    W = len(matrix)\n    H = len(matrix[0])\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, W, gridX):\n        for y in range(startY, H, gridY):\n            soma += matrix[x][y]\n\n\n@cuda.jit\ndef simulate_kernel(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param apY:\n    :param apX:\n    :param matrix_results:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, WIDTH, gridX):\n        for y in range(startY, HEIGHT, gridY):\n            matrix_results[x][y] = propagation_model_gpu(x, y, apX, apY, floor_plan)\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n@jit\ndef simulate_cpu(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    for x in range(WIDTH):\n        # inicio = datetime.now()\n        for y in range(HEIGHT):\n            value = propagation_model(x, y, apX, apY, floor_plan)\n            matrix_results[x][y] = value\n\n    return matrix_results\n\n\n# TODO copiar a vers\xc3\xa3o mais enxuta do PlacementGPUaps.py\n\n# def get_point_in_circle(pointX, pointY, ray, round_values=True, num=1, absolute_values=True):\n#     """"""\n#     M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n#     :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n#     :param ray: Valor do raio desejado.\n#     :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n#     valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n#     :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n#     :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n#     :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n#     refer\xc3\xaancia.\n#     :return: Um ponto ou um conjunto de pontos do tipo float.\n#     """"""\n#\n#     t = np.random.uniform(0.0, 2.0 * np.pi, num)\n#     r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n#\n#     x = r * np.cos(t) + pointX\n#     y = r * np.sin(t) + pointY\n#\n#     # Converte todos os valores negativos da lista em positivos\n#     if absolute_values:\n#         x = [abs(k) for k in x]\n#         y = [abs(k) for k in y]\n#\n#     if round_values:\n#         x = [round(k) for k in x]\n#         y = [round(k) for k in y]\n#\n#     # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n#     if num == 1:\n#         return [x[0], y[0]]\n#     else:\n#         return [x, y]\n\n@jit\ndef get_point_in_circle(pointX, pointY, ray):\n    """"""\n    M\xc3\x83\xc2\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xa3o [x, y] de refer\xc3\x83\xc2\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    valores discretos para posi\xc3\x83\xc2\xa7\xc3\x83\xc2\xb5es da matriz.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n    num = 1\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n\n    x = round(abs(x[0]))\n    y = round(abs(y[0]))\n\n    return list([x, y])\n\n@jit\ndef perturba_array(S_array, size):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param size:\n    :param S_array:\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    novoS = np.empty([num_aps, 2], np.float32)\n\n    for i in range(size):\n        # Obtem um ponto aleatorio em um raio de X metros\n        novoS[i] = get_point_in_circle(S_array[i][0], S_array[i][1], RAIO_PERTURBACAO)\n\n    return novoS\n\n\n@jit\ndef perturba(S):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n\n    return get_point_in_circle(S[0], S[1], RAIO_PERTURBACAO)\n\n\n@jit\ndef avalia_array(S_array, size):\n\n    matrizes_propagacao = []\n    for i in range(size):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    ## TODO: s\xc3\xb3 pra testes, simples demais\n    # fo_APs = 0\n    # for i in range(size):\n    #     fo_APs += objective_function(matrizes_propagacao[i])\n    #\n    # return fo_APs\n\n    ## simplesmente guloso\n    # matriz_sobreposta = sobrepoe_solucoes_MAX(matrizes_propagacao, size)\n\n    ## penaliza APs muito proximos\n    matriz_sobreposta = sobrepoe_solucoes_DIV_dBm(matrizes_propagacao, size)\n\n    return objective_function(matriz_sobreposta)\n\n\n@jit\ndef sobrepoe_solucoes_MAX(propagation_array, size):\n    max = propagation_array[0]\n    for i in range(1, size):\n        max = np.maximum(propagation_array[i], max)\n\n    return max\n\n\n@jit\ndef sobrepoe_solucoes_SUB(propagation_array, size):\n    sub = propagation_array[0]\n    for i in range(1, size):\n        sub = np.subtract(propagation_array[i], sub)\n\n    return sub\n\n\n@jit\ndef sobrepoe_solucoes_DIV_dBm(propagation_array, size):\n\n    # verificar se \xc3\xa9 veridico\n    if size == 1:\n        return propagation_array[0]\n\n    matrixMin = propagation_array[0]\n    matrixMax = propagation_array[0]\n\n    for i in range(1, size):\n        matrixMin = np.minimum(propagation_array[i], matrixMin)\n        matrixMax = np.maximum(propagation_array[i], matrixMax)\n\n    ## pois ao subtrair dBm, deve ser o maior/menor\n    sub = np.divide(matrixMax, matrixMin)\n\n    return sub\n\n\n@jit\ndef simula_propagacao_cpu(apX, apY):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param floor_plan:\n    :param apY:\n    :param apX:\n    :param matrix_results:\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    matrix_results = np.empty([WIDTH, HEIGHT], np.float32)\n\n    return simulate_cpu(apX, apY, matrix_results, floor_plan)\n\n\n@jit\ndef simula_propagacao_gpu(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param pointX:\n    :param pointY: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return g_matrix\n\n@jit\ndef simula_propagacao(pointX, pointY):\n\n    ## with GPU CUDA Threads\n    #return simula_propagacao_gpu(pointX, pointY)\n    \n    ## with CPU Threads\n    return simula_propagacao_cpu(pointX, pointY)\n\ndef simulated_annealing(size, M, P, L, T0, alpha):\n    """"""\n    :param size:\n    :param T0: Temperatura inicial.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n\n    # cria Solu\xc3\xa7\xc3\xb5es iniciais com pontos aleat\xc3\xb3rios para os APs\n    S_array = np.empty([size, 2], np.float32)\n\n    for i in range(size):\n        # S_array[i] = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n        S_array[i] = [WIDTH * 0.5, HEIGHT * 0.5]\n\n    S0 = S_array.copy()\n    print(""Solu\xc3\xa7\xc3\xa3o inicial:\\n"" + str(S0))\n\n    fS = avalia_array(S_array, size)\n\n    T = T0\n    j = 1\n\n    i_ap = 0\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            # Si = perturb(S[0], S[1])\n            # fSi = f(Si[0], Si[1])\n\n            # TODO perturbar todos\n            # Si_array = perturba_array(S_array, num_aps)\n            Si_array = S_array.copy()\n\n            # a cada itera\xc3\xa7\xc3\xa3o do SA, perturba um dos APs\n            i_ap = (i_ap + 1) % num_aps\n\n            Si_array[i_ap] = perturba(S_array[i_ap])\n\n            fSi = avalia_array(Si_array, num_aps)\n\n            # show_solution(Si) print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S_array)\n            #  + ""\\t Si: "" + str(Si_array))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            # Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            # Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                # LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S_array = Si_array\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n\n    print(""Dist\xc3\xa2ncia da solu\xc3\xa7\xc3\xa3o inicial:\\t\\t\\t\\t\\t"" + str(sobrepoe_solucoes_SUB(S_array, num_aps)))\n\n    return S_array\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    # hex = str(hex).lstrip(\'#\')\n    # return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n    hex = str(hex).lstrip(\'#\')\n    lv = len(hex)\n    return tuple(int(hex[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n\ndef draw_line(DISPLAYSURF, x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame(matrix_results, access_points, DISPLAYSURF):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n\n    # matrix_max_value = matrix_results.max()\n    # matrix_min_value = matrix_results.min()\n\n    matrix_max_value = -100\n    matrix_min_value = -10\n\n    # Se utilizar a fun\xc3\xa7\xc3\xa3o min tradicionar, a penaliza\xc3\xa7\xc3\xa3o de DBM_MIN_VALUE ir\xc3\xa1 interferir no range de cor\n    # matrix_min_value = matrix_max_value\n    # for x in range(WIDTH):\n    #     for y in range(HEIGHT):\n    #         if matrix_results[x][y] != DBM_MIN_VALUE and matrix_results[x][y] < matrix_min_value:\n    #             matrix_min_value = matrix_results[x][y]\n\n                # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(DISPLAYSURF, color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o dos Access Points\n    for ap in access_points:\n        draw_point(DISPLAYSURF, RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(DISPLAYSURF, color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param DISPLAYSURF:\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan, DISPLAYSURF):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(DISPLAYSURF, line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    ##TODO escala de cor linear, mas poderia ser exponencial (logaritmica)\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n    # return list[int(position - 1)]\n\n\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n\n    # if x < SENSITIVITY:\n    #     return hex_to_rgb(""#000000"")\n\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n\n    return color\n\n\ndef showSolution(S_array, DISPLAYSURF):\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyGame."")\n\n    matrizes_propagacao = []\n\n    for i in range(len(S_array)):\n        matrizes_propagacao.append(simula_propagacao(S_array[i][0], S_array[i][1]))\n\n    # propagacao = sobrepoe_solucoes_ADD(matrizes_propagacao, len(S_array))\n    propagacao = sobrepoe_solucoes_MAX(matrizes_propagacao, len(S_array))\n\n    print_pygame(propagacao, S_array, DISPLAYSURF)\n\n    draw_floor_plan(walls, DISPLAYSURF)\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    # cores = list(Color(""blue"").range_to(Color(""red""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n\n    return cores\n\n\ndef run():\n    print(""\\nIniciando simula\xc3\xa7\xc3\xa3o com simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""Temperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""Repeti\xc3\xa7\xc3\xb5es do Simulated Annealing:\\t\\t"" + str(max_SA) + ""\\n"")\n\n    print(""Raio de perturba\xc3\xa7\xc3\xa3o:\\t\\t\\t\\t"" + str(RAIO_PERTURBACAO))\n    print(""Simulando ambiente com :\\t\\t\\t"" + str(WIDTH) + ""x"" + str(HEIGHT) + "" pixels"")\n    print(""Escala de simula\xc3\xa7\xc3\xa3o da planta:\\t\\t\\t1 px : "" + str(escala) + "" metros"")\n    print(""Ambiente de simula\xc3\xa7\xc3\xa3o:\\t\\t\\t\\t"" + str(ENVIRONMENT) + ""\\n"")\n\n    # variasSolucoes = []\n    #\n    # for i in range(max_SA):\n    #     print(""Calculando o melhor ponto ["" + str(i) + ""]"")\n    #     variasSolucoes.append(\n    #         simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha))\n    #\n    # maxFO = 0\n    # bestSolution = variasSolucoes[0]\n    #\n    # print(""Analizando a melhor solu\xc3\xa7\xc3\xa3o."")\n    #\n    # for ap_array in variasSolucoes:\n    #     ap_array_fo = avalia_array(ap_array)\n    #     if ap_array_fo > maxFO:\n    #         maxFO = ap_array_fo\n    #         bestSolution = ap_array\n\n    # bestSolution = simulated_annealing(num_aps, max_inter, max_pertub, num_max_succ, temp_inicial, alpha)\n    # bestSolution_fo = avalia_array(bestSolution, len(bestSolution))\n    #\n    # print(""\\nMelhor ponto sugerido pelo algoritmo: "" + str(bestSolution) + ""\\n FO: "" + str(bestSolution_fo))\n\n    # x = 1230\n    # y = 360\n    # xx = (1610/864)*660\n    # yy = (600/435)*260\n\n    xx = 1175\n    yy = 360\n\n    bestSolution = [[xx, yy]]\n\n    #\n    # # Inicia o PyGame\n    pygame.init()\n    #\n    # # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n    #\n    showSolution(bestSolution, DISPLAYSURF)\n    # # show_solution(1, 1)\n    #\n    input(\'\\nFim de execu\xc3\xa7\xc3\xa3o.\')\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    COLORS = get_color_gradient(25)\n\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    Pt_dBm = -20\n\n    # ENVIRONMENT = ""GPU""\n    ENVIRONMENT = ""CPU""\n\n    # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n    # dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\n    dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n    escala = 1\n\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n    ## carreguei a planta so para obter a proporcao\n    proporcao_planta = comprimento_planta / largura_planta\n\n    # HEIGHT = int(largura_planta)\n    # WIDTH = int(comprimento_planta)\n    HEIGHT = 600  # 40\n    WIDTH = int(HEIGHT * proporcao_planta)\n\n    escala = HEIGHT / largura_planta\n    # escala = WIDTH / comprimento_planta\n    # precisao = 1  # metro\n    precisao = 36.0 / WIDTH\n\n    walls = read_walls_from_dxf(dxf_path)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    SENSITIVITY = -90\n    DBM_MIN_VALUE = np.finfo(np.float32).min\n\n    ## Quantidade de APs\n    num_aps = 1\n\n    ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600 * num_aps\n\n    ## p\n    max_pertub = 5\n\n    # RAIO_PERTURBACAO = WIDTH * 0.01\n    # RAIO_PERTURBACAO = WIDTH * 0.0175\n    RAIO_PERTURBACAO = WIDTH * 0.025\n\n    ## v\n    num_max_succ = 80\n\n    ## a\n    alpha = .85\n\n    ## t\n    temp_inicial = 300 * 2\n\n    ## m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n\n    run()\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    # cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    ## python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    ## cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n'"
debugs/PlacementCPU.py,11,"b'#!/usr/bin/python\n\nimport math\nimport tkinter as tk\nfrom datetime import datetime\nfrom math import sqrt, pi, log10, exp\nfrom random import random\n\nimport ezdxf\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pygame\n\nfrom numba import autojit, prange, cuda, jit\nimport numba\nimport profile\n\ncontador_uso_func_objetivo = 0\n\n\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\ndebug = False\n\n# WIDTH = get_monitor_size()[0] - 100  # Retira 100pxs para folga\n# HEIGHT = get_monitor_size()[1] - 100  # Retira 100pxs para folga\n\n\n\n#floor_plan = np.array(read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-porta.dxf""), np.int32)\n\n## print(numba.typeof(floor_plan))\n\n\nheat_map = None\n\n# WIDTH = 350\n# HEIGHT = 200\nWIDTH = 70\nHEIGHT = 40\n\ncomprimento_planta = 800\nlargura_planta = 600\nprecisao = 1  # metro\n\nescala = HEIGHT / largura_planta\n\n# tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\nproporcao_planta = comprimento_planta / largura_planta\n# WIDTH = int(HEIGHT * proporcao_planta)\n\nif debug:\n    print(""Dimens\xc3\xa3o da planta: "" + str(comprimento_planta) + ""x"" + str(largura_planta))\n    print(""Dimens\xc3\xa3o da matriz de valores: "" + str(WIDTH) + ""x"" + str(HEIGHT))\n    print(""Precis\xc3\xa3o de "" + str(precisao) + "" metros."")\n    print(""Escala de 1:"" + str(escala) + ""."")\n\nCHANNEL = 9\n\n# Posi\xc3\xa7\xc3\xa3o menor -> Azul, Posi\xc3\xa7\xc3\xa3o Maior -> Amarelo/Vermelho\nCOLORS = [\n    \'#0C0786\', \'#100787\', \'#130689\', \'#15068A\', \'#18068B\', \'#1B068C\', \'#1D068D\', \'#1F058E\',\n    \'#21058F\', \'#230590\', \'#250591\', \'#270592\', \'#290593\', \'#2B0594\', \'#2D0494\', \'#2F0495\',\n    \'#310496\', \'#330497\', \'#340498\', \'#360498\', \'#380499\', \'#3A049A\', \'#3B039A\', \'#3D039B\',\n    \'#3F039C\', \'#40039C\', \'#42039D\', \'#44039E\', \'#45039E\', \'#47029F\', \'#49029F\', \'#4A02A0\',\n    \'#4C02A1\', \'#4E02A1\', \'#4F02A2\', \'#5101A2\', \'#5201A3\', \'#5401A3\', \'#5601A3\', \'#5701A4\',\n    \'#5901A4\', \'#5A00A5\', \'#5C00A5\', \'#5E00A5\', \'#5F00A6\', \'#6100A6\', \'#6200A6\', \'#6400A7\',\n    \'#6500A7\', \'#6700A7\', \'#6800A7\', \'#6A00A7\', \'#6C00A8\', \'#6D00A8\', \'#6F00A8\', \'#7000A8\',\n    \'#7200A8\', \'#7300A8\', \'#7500A8\', \'#7601A8\', \'#7801A8\', \'#7901A8\', \'#7B02A8\', \'#7C02A7\',\n    \'#7E03A7\', \'#7F03A7\', \'#8104A7\', \'#8204A7\', \'#8405A6\', \'#8506A6\', \'#8607A6\', \'#8807A5\',\n    \'#8908A5\', \'#8B09A4\', \'#8C0AA4\', \'#8E0CA4\', \'#8F0DA3\', \'#900EA3\', \'#920FA2\', \'#9310A1\',\n    \'#9511A1\', \'#9612A0\', \'#9713A0\', \'#99149F\', \'#9A159E\', \'#9B179E\', \'#9D189D\', \'#9E199C\',\n    \'#9F1A9B\', \'#A01B9B\', \'#A21C9A\', \'#A31D99\', \'#A41E98\', \'#A51F97\', \'#A72197\', \'#A82296\',\n    \'#A92395\', \'#AA2494\', \'#AC2593\', \'#AD2692\', \'#AE2791\', \'#AF2890\', \'#B02A8F\', \'#B12B8F\',\n    \'#B22C8E\', \'#B42D8D\', \'#B52E8C\', \'#B62F8B\', \'#B7308A\', \'#B83289\', \'#B93388\', \'#BA3487\',\n    \'#BB3586\', \'#BC3685\', \'#BD3784\', \'#BE3883\', \'#BF3982\', \'#C03B81\', \'#C13C80\', \'#C23D80\',\n    \'#C33E7F\', \'#C43F7E\', \'#C5407D\', \'#C6417C\', \'#C7427B\', \'#C8447A\', \'#C94579\', \'#CA4678\',\n    \'#CB4777\', \'#CC4876\', \'#CD4975\', \'#CE4A75\', \'#CF4B74\', \'#D04D73\', \'#D14E72\', \'#D14F71\',\n    \'#D25070\', \'#D3516F\', \'#D4526E\', \'#D5536D\', \'#D6556D\', \'#D7566C\', \'#D7576B\', \'#D8586A\',\n    \'#D95969\', \'#DA5A68\', \'#DB5B67\', \'#DC5D66\', \'#DC5E66\', \'#DD5F65\', \'#DE6064\', \'#DF6163\',\n    \'#DF6262\', \'#E06461\', \'#E16560\', \'#E26660\', \'#E3675F\', \'#E3685E\', \'#E46A5D\', \'#E56B5C\',\n    \'#E56C5B\', \'#E66D5A\', \'#E76E5A\', \'#E87059\', \'#E87158\', \'#E97257\', \'#EA7356\', \'#EA7455\',\n    \'#EB7654\', \'#EC7754\', \'#EC7853\', \'#ED7952\', \'#ED7B51\', \'#EE7C50\', \'#EF7D4F\', \'#EF7E4E\',\n    \'#F0804D\', \'#F0814D\', \'#F1824C\', \'#F2844B\', \'#F2854A\', \'#F38649\', \'#F38748\', \'#F48947\',\n    \'#F48A47\', \'#F58B46\', \'#F58D45\', \'#F68E44\', \'#F68F43\', \'#F69142\', \'#F79241\', \'#F79341\',\n    \'#F89540\', \'#F8963F\', \'#F8983E\', \'#F9993D\', \'#F99A3C\', \'#FA9C3B\', \'#FA9D3A\', \'#FA9F3A\',\n    \'#FAA039\', \'#FBA238\', \'#FBA337\', \'#FBA436\', \'#FCA635\', \'#FCA735\', \'#FCA934\', \'#FCAA33\',\n    \'#FCAC32\', \'#FCAD31\', \'#FDAF31\', \'#FDB030\', \'#FDB22F\', \'#FDB32E\', \'#FDB52D\', \'#FDB62D\',\n    \'#FDB82C\', \'#FDB92B\', \'#FDBB2B\', \'#FDBC2A\', \'#FDBE29\', \'#FDC029\', \'#FDC128\', \'#FDC328\',\n    \'#FDC427\', \'#FDC626\', \'#FCC726\', \'#FCC926\', \'#FCCB25\', \'#FCCC25\', \'#FCCE25\', \'#FBD024\',\n    \'#FBD124\', \'#FBD324\', \'#FAD524\', \'#FAD624\', \'#FAD824\', \'#F9D924\', \'#F9DB24\', \'#F8DD24\',\n    \'#F8DF24\', \'#F7E024\', \'#F7E225\', \'#F6E425\', \'#F6E525\', \'#F5E726\', \'#F5E926\', \'#F4EA26\',\n    \'#F3EC26\', \'#F3EE26\', \'#F2F026\', \'#F2F126\', \'#F1F326\', \'#F0F525\', \'#F0F623\', \'#EFF821\'\n]\n\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\n\n# print(""W"" + str(WIDTH))\n# print(""H"" + str(HEIGHT))\n\n# Inicia o PyGame\n# pygame.init()\n\n# Configura o tamanho da janela\n# DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n\n\n\n# @numba.jit()\ndef side(a, b, c):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (c[1] - a[1]) * (b[0] - a[0]) - (b[1] - a[1]) * (c[0] - a[0])\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n# @numba.jit()\ndef is_point_in_closed_segment(a, b, c):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if a[0] < b[0]:\n        return a[0] <= c[0] <= b[0]\n    if b[0] < a[0]:\n        return b[0] <= c[0] <= a[0]\n\n    if a[1] < b[1]:\n        return a[1] <= c[1] <= b[1]\n    if b[1] < a[1]:\n        return b[1] <= c[1] <= a[1]\n\n    return a[0] == c[0] and a[1] == c[1]\n\n\n# @numba.jit()\ndef closed_segment_intersect(a, b, c, d):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n    if a == b:\n        return a == c or a == d\n    if c == d:\n        return c == a or c == b\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(a, b, c)\n    s2 = side(a, b, d)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(a, b, c) or is_point_in_closed_segment(a, b, d) or \\\n            is_point_in_closed_segment(c, d, a) or is_point_in_closed_segment(c, d, b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(c, d, a)\n    s2 = side(c, d, b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float64( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n# @numba.jit()\n# @numba.jit(""f4(u4[:,:],u4[:,:],u4[:,:,:,:])"", target=\'cpu\')\n# @numba.jit()\ndef absorption_in_walls(access_point, destiny, walls):\n    # Seus pontos (origem, destino)\n    # AccessPoint = [0,0]\n    # Destino = [899, 579]\n\n    intersections = 0\n\n    # tSum=0\n    # for line in walls:\n    #     # Coordenadas da parede\n    #     wall_xy_a = line[0:2]\n    #     wall_xy_b = line[2:4]\n    #\n    #     ##TODO 2.5 microseg ==> Reduzir o tempo do closed_segment_intersect por sera realizado 1,5 bilh\xc3\xa3o de vezes!!!!!\n    #     t0 = datetime.now()\n    #     if closed_segment_intersect(access_point, destiny, wall_xy_a, wall_xy_b):\n    #         intersections += 1\n    #\n    #     tSum+=(datetime.now() - t0).microseconds\n    #\n    # print( round(tSum / len(walls),2) )\n\n    intersections = (sum(1 for _ in (map(lambda x: intersect(access_point, destiny, x[0:2], x[2:4]), walls))))\n\n    # b = filter(lambda x: x != 0, a)\n\n    # intersections = len(list(b))\n\n    # print(""Res: "" + str(intersections))\n\n    # print(""paredes: "" + str(sum(list(a))))\n\n    # for line in walls:\n    #     if intersect(access_point, destiny, line[0:2], line[2:4]):\n    #         intersections += 1\n\n    intersecoes_com_paredes = intersections / 2\n    # print(""intersecoes_com_paredes = "" + str(intersecoes_com_paredes))\n\n    # dBm_absorvido_por_parede = 0.01\n    # miliWatts_absorvido_por_parede = pow(10, (dBm_absorvido_por_parede / 10))\n    miliWatts_absorvido_por_parede = 1\n\n    # if debug:\n    #     print(""Access Point "" + str(access_point))\n    #     print(""Destiny "" + str(destiny))\n    #     # print(""Perda por parede: (dBm) "" + str(dBm_absorvido_por_parede))\n    #     print(""Perda por parede: (mW) "" + str(miliWatts_absorvido_por_parede))\n    #     print(""N\xc2\xba de intercess\xc3\xb5es: "" + str(intersecoes_com_paredes))\n\n    return intersecoes_com_paredes * miliWatts_absorvido_por_parede\n\n\ndef get_monitor_size():\n    """"""\n    M\xc3\xa9todo que identifica o tamanho da tela do computador.\n    :return: Retorna os valores de largura e altura.\n    """"""\n    root = tk.Tk()\n    return root.winfo_screenwidth(), root.winfo_screenheight()\n\n\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    hex = str(hex).lstrip(\'#\')\n    return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n\n\ndef draw_line(x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    # pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef draw_point(color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    # pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef draw_floor_plan(floor_plan):\n    for line in floor_plan:\n        draw_line(line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\n# @numba.jit(""f4(u4,u4,u4,u4)"", target=\'cpu\')\n@numba.jit()\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0))\n\n\n@numba.jit(""f4()"", target=\'cpu\')\ndef frequency():\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por calcular a frequ\xc3\xaancia de acordo com o canal.\n    :return: Frequ\xc3\xaancia do canal.\n    """"""\n    return (2.407 + (5 * CHANNEL) / 1000) * 10 ** 9\n\n\n@numba.jit(""f4()"", target=\'cpu\')\ndef wave_length():\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por calcular o comprimento de onda como raz\xc3\xa3o a velocidade da luz da frequ\xc3\xaancia do canal.\n    :return: Comprimento de onda de acordo com a frequ\xc3\xaancia.\n    """"""\n    C = 299792458\n    return C / frequency()\n\n\n## TODO calcular a frequency() e a wave_length() UMA VEZ, salvando como variaveis globais e usando na formula da propaga\xc3\xa7\xc3\xa3o\ndef path_loss(d):\n    """"""\n    Perda no caminho (Path Loss) mensurado em dB.\n    :param d: Dist\xc3\xa2cia.\n    :return: Perda no caminho.\n    """"""\n    return 20 * log10((4 * pi * d) / wave_length())\n\n\ndef two_ray_ground_reflection_model(Pt, Gt, Gr, Ht, Hr, d, L):\n    """"""\n    Pr\n    """"""\n    return (Pt * Gt * Gr * pow(Ht, 2) * pow(Hr, 2)) / (pow(d, 4) * L)\n\n\ndef free_space_model(Pt, Gt, Gr, lamb, d, L):\n    """"""\n    Pr\n    """"""\n    return (Pt * Gt * Gr * (pow(lamb, 2))) / (pow((4 * pi), 2) * pow(d, 2) * L)\n\n\ndef log_distance(d0, d, gamma):\n    """"""\n    Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n    e do ganho das antenas transmissora e receptora.\n    Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n    :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n    :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n    :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n    :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n    """"""\n    # return path_loss(d) + 10 * gamma * log10(d / d0)\n    return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n\n@numba.jit(""f4(f4)"", target=\'cpu\')\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n## TODO jit trava run\n@numba.jit(""(u4,u4,u4[:,:])"", target=\'cpu\')\ndef propagation_model(x, y, access_point):\n    d = calc_distance(x, y, access_point[0], access_point[1])\n\n    ## 00.1 segundos para cada FuncaoObjetivo com absorption_in_walls\n    loss_in_wall = 0\n\n    ## TODO 500 microsec absoprtion_in_walls\n\n\n    # inicio = datetime.now()\n\n    #loss_in_wall = absorption_in_walls(access_point, [x, y], walls=floor_plan)\n\n    # print(str((datetime.now() - inicio).microseconds/1000) + "" microsegundos ==> absorption_in_walls"")\n\n    # print(""loss_in_wall = "" + str(loss_in_wall))\n\n    if d == 0:\n        d = 1\n    gamma = 5\n\n    ## 10 microsec por tree_par_log\n\n    # value = log_distance(1, d, gamma)\n    value = tree_par_log(d) - loss_in_wall\n    # value = tree_par_log(d)\n\n    return value\n\n\ndef print_matriz(matrix):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por imprimir a matriz em um arquivo.\n    :param matrix: Matriz N x M.\n    :return: None.\n    """"""\n    print(""Escrevendo matrix no arquivo de saida..."")\n    print(""Diman\xc3\xa7\xc3\xb5es na matrix: "" + str(np.shape(matrix)))\n    f = open(\'saida_passo_01\', \'w\')\n    for line in matrix:\n        for value in line:\n            f.write(str(value) + ""\\t"")\n        f.write(\'\\n\')\n    f.close()\n    print(""Matriz salva no arquivo."")\n\n\ndef print_pygame(matrix_results, access_point):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n    matrix_max_value = matrix_results.max()\n    matrix_min_value = matrix_results.min()\n\n    # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o do Access Point\n    ap = access_point\n    draw_point(RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n    return ((x - min) / (max - min)) * 100\n\n\n# @numba.jit(""u1[:](f4,i1[i1[:]])"", target=\'cpu\')\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n\n\n# @numba.jit(""i1[:](f4,f4,f4)"", target=\'cpu\')\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n    # print(\'Color: \' + str(color))\n    return color\n\n\n@numba.jit(""f4(f4[:,:])"", target=\'cpu\')\ndef objective_function(matrix):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += value\n\n    return abs(np.sum(matrix))\n\n\n# @numba.jit(""f4[:,:](b1, b1, b1, u4[:,:])"", target=\'cpu\')\n#def simulate(save_matrix=False, show_pygame=False, debug=False, access_point=None):\n@numba.jit(""f4[:,:](u4[:,:])"", target=\'cpu\')\ndef simulate(access_point):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param save_matrix: Flag que sinaliza se quero salvar a matriz de resultados em um arquivo.\n    :param show_pygame: Flag que sinaliza se quero exibir o resultado gr\xc3\xa1fico da simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n    # if debug:\n    #     print(""Iniciando simula\xc3\xa7\xc3\xa3o."")\n\n    # Marca o inicio da simula\xc3\xa7\xc3\xa3o\n    # inicio = datetime.now()\n\n\n    # if False:\n    #     # Inicia o PyGame\n    #     pygame.init()\n    #\n    #     # Configura o tamanho da janela\n    #     DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n    #     pygame.display.set_caption(\'Simulando...\')\n\n    # Cria uma matriz para guardar os resultados calculados\n    #matrix_results = np.zeros(shape=(WIDTH, HEIGHT))\n    matrix_results = np.empty([WIDTH, HEIGHT], np.float32)\n    # matrix_results = np.zeros(shape=(int(largura_planta / precisao), int(comprimento_planta / precisao)))\n\n    # print(""Posi\xc3\xa7\xc3\xa3o do access point: "" + str(access_point))\n\n\n\n    # Preenche a matriz de resultados usando um modelo de propaga\xc3\xa7\xc3\xa3o\n    # t0 = datetime.now()\n\n    ## TODO: fix List Comprehension\n    # matrix_results = [[propagation_model(x, y, access_point) for x in range(WIDTH)] for y in\n    #                   range(HEIGHT)]\n    # matrix_results = np.array(matrix_results)\n\n    ## FOR\n    for x in range(WIDTH):\n        #inicio = datetime.now()\n        for y in range(HEIGHT):\n            value = propagation_model(x, y, access_point)\n            matrix_results[x][y] = value\n    # print(str((datetime.now() - inicio).microseconds/1000.0 ) + "" milisegundos ==> por LINHA"")\n\n    # t1 = datetime.now()\n    # print(str((t1 - t0).seconds) + "" segundos ==> por MATRIZ"")\n\n\n    # Guarda os valores m\xc3\xa1ximo e m\xc3\xadnimo da matriz\n    # matrix_max_value = matrix_results.max()\n    # matrix_min_value = matrix_results.min()\n\n    # if show_pygame:\n    # Desenha a matriz usando o PyGame\n    # print_pygame(matrix_results, access_point)\n\n    # if save_matrix:\n    #     # Grava os valores da matriz no arquivo\n    #     print_matriz(matrix_results)\n    #\n    # if show_pygame:\n    #     # Atualiza o titulo da janela do PyGame\n    #     pygame.display.set_caption(\'Simula\xc3\xa7\xc3\xa3o terminada\')\n    #\n    # if debug:\n    #     # Marca o fim da simula\xc3\xa7\xc3\xa3o\n    #     fim = datetime.now()\n    #     # Exibe um resumo da simula\xc3\xa7\xc3\xa3o\n    #     print(\'Simula\xc3\xa7\xc3\xa3o terminada.\')\n    #     print(""\\nInicio: \\t"" + str(inicio.time()))\n    #     print(""Fim: \\t\\t"" + str(fim.time()))\n    #     print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str((fim - inicio).seconds) + "" segundos.\\n"")\n    #\n    #     print(""Maior valor da matriz: "" + str(matrix_max_value))\n    #     print(""Menor valor da matriz: "" + str(matrix_min_value))\n\n    # input(\'\\nPrecione qualquer tecla para encerrar a aplica\xc3\xa7\xc3\xa3o.\')\n\n    return matrix_results\n\n\n@numba.jit(""u4[:,:](u4[:,:],u4)"")\ndef get_point_in_circle(point, ray):\n    """"""\n    M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n    valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n    :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n    :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n    :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n    refer\xc3\xaancia.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n    num = 1\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + point[0]\n    y = r * np.sin(t) + point[1]\n\n    # Converte todos os valores negativos da lista em positivos\n# if absolute_values:\n#     x = [abs(k) for k in x]\n#     y = [abs(k) for k in y]\n\n    x = round(abs(x[0]))\n    y = round(abs(y[0]))\n\n    # if debug:\n    #     plt.plot(x, y, ""ro"", ms=1)\n    #     plt.axis([-15, 15, -15, 15])\n    #\n    #     for i in range(num):\n    #         print(""Dist\xc3\xa2ncia entre o ponto ({}, {}) ""\n    #               ""e o ponto ({}, {}) com raio [{}] = {}"".format(point[0], point[1], x[i], y[i], ray,\n    #                                                              calc_distance(point[0], point[1], x[i],\n    #                                                                                 y[i])))\n    #     plt.show()\n\n#if round_values:\n    # x = [round(k) for k in x]\n    # y = [round(k) for k in y]\n\n    # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n# if num == 1:\n    #return [x[0], y[0]]\n# else:\n    return [x, y]\n\n\n@numba.jit(""u4()"")\ndef starting_temperature():\n    """"""\n    Fun\xc3\xa7\xc3\xa3o que calcula a temperatura inicial;\n    :return:\n    """"""\n    return 100\n\n\n@numba.jit(""u4[:,:](u4[:,:])"")\ndef perturb(S):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    # Obtem um ponto aleatorio em um raio de X metros\n    return get_point_in_circle(S,10)\n\n\n@numba.jit(""f4(u4[:,:])"")\ndef f(x):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n\n    # inicio = datetime.now()\n\n    matrix_result = simulate(x)\n\n    goal = objective_function(matrix_result)\n\n    # print(""Fun\xc3\xa7\xc3\xa3o objetivo: "" + str(goal))\n    # print(str((datetime.now() - inicio).seconds) + "" segundos ==> por f(x)"")\n\n    # contador_uso_func_objetivo += 1\n\n    return goal\n\n\n@numba.jit(""f4()"")\ndef randomize():\n    """"""\n    Fun\xc3\xa7\xc3\xa3o que gera um n\xc3\xbamero aleat\xc3\xb3rio no intervalo [0,1];\n    :return:\n    """"""\n\n    rand = random()\n\n    # print(""Randomiza: "" + str(rand))\n\n    return rand\n\n\n@numba.jit(""void(u4[:,:])"", target=\'cpu\')\ndef showSolution(S):\n    print_pygame(simulate(S), S)\n    draw_floor_plan(floor_plan)\n\n\n# @numba.jit(""u8[:,:]( u8[:,:], u8, u8, u8, u8, f4)"", target=\'cpu\')\ndef simulated_annealing(S0, M, P, L, T0, alpha):\n    """"""\n\n    :param T0: Temperatura inicial.\n    :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n    S = S0\n    T = T0\n    j = 1\n\n    print(""\\nIniciando Simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""Ponto inicial:\\t\\t\\t\\t\\t\\t\\t\\t"" + str(S0))\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t\\t\\t"" + str(M))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(P))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(L))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t\\t"" + str(alpha))\n    # input(""Aperte qualquer tecla para continuar."")\n\n    # contador_uso_func_objetivo = 0\n\n    fS = f(S0)\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            Si = perturb(S)\n            fSi = f(Si)\n\n            # contador_uso_func_objetivo += 1\n\n            # show_solution(Si)\n            # print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S) + ""\\t Si: "" + str(Si))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            ## Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            ## Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                ## LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S = Si\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n    return S\n\n\n# def ccw( A, B, C):\n#     return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\n# @cuda.jit\n\n@numba.jit(""uint8(uint16[:,:], uint16[:,:], uint16[:,:], uint16[:,:])"", target=\'cpu\')\ndef intersect(A, B, C, D):\n    # return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\n    if ((D[1] - A[1]) * (C[0] - A[0]) > (C[1] - A[1]) * (D[0] - A[0])) \\\n            != ((D[1] - B[1]) * (C[0] - B[0]) > (C[1] - B[1]) * (D[0] - B[0])) \\\n            and ((C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])) \\\n                    != ((D[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (D[0] - A[0])):\n        return 1\n\n\ndef run():\n    if False:\n        w = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-A-l.dxf"")\n\n        a = absorption_in_walls([0, 0], [237, 241], w)\n\n        draw_floor_plan(w)\n\n        input()\n\n    if True:\n        # access_point = [0, 0]\n        # m = p.simulate_kernel(save_matrix=True, show_pygame=True, access_point=access_point)\n        # print(p.objective_function(matrix=m))\n\n        access_point = [0, 0]\n        ## sugest\xc3\xa3o: sortear o X,Y do ponto inicial (dentro da matriz)\n\n        ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n        max_inter = 600\n\n        ## p\n        max_pertub = 5\n\n        ## v\n        num_max_succ = 80\n\n        ## a\n        alpha = .85\n\n        ## t\n        temp_inicial = 300\n\n        # Marca o tempo do inicio da simula\xc3\xa7\xc3\xa3o\n        #inicio = datetime.now()\n\n        point = simulated_annealing(access_point, max_inter, max_pertub, num_max_succ, temp_inicial, alpha)\n\n        # Marca o tempo do fim da simula\xc3\xa7\xc3\xa3o\n        #fim = datetime.now()\n\n        # time_seconds = (fim - inicio).seconds\n        # time_minutes = time_seconds / 60\n        #\n        # print(""\\nInicio: \\t"" + str(inicio.time()))\n        # print(""Fim: \\t\\t"" + str(fim.time()))\n        # print(""Dura\xc3\xa7\xc3\xa3o: \\t"" + str(time_seconds) + "" segundos ("" + str(round(time_minutes, 2)) + "" minutos).\\n"")\n\n        print(""Melhor ponto sugerido pelo algoritmo: "" + str(point))\n        # input(\'\\nPrecione qualquer tecla para encerrar a aplica\xc3\xa7\xc3\xa3o.\')\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    #run()\n    profile.runctx(\'run()\', globals(), locals())\n\n    ## python ../PlacementCPU.py | egrep ""(tottime)|(PlacementCPU.py)"" | tee ../cProfile/PlacementCPU.py_COM-JIT.txt\n    ## cat ../cProfile/PlacementCPU.py_COM-JIT.txt | sort -k 2 -r'"
debugs/PlacementGPU.py,15,"b'#!/usr/bin/python\n\nimport math\nimport random as rd\nfrom math import sqrt, log10, exp\nfrom random import random\n\nimport ezdxf\nimport numpy as np\nimport pygame\nfrom colour import Color\nfrom numba import cuda, jit\n\n""""""\nAlgoritmo que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    ##TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float32( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    ## OBS.: dividir por dois se cada parede for um retangulo no DXF\n    # intersecoes_com_paredes = intersections / 2\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB. Por conta da precisao em casas decimais do float32, \xc3\xa9 melhor pegar a ordem de\n    # magnitude com o dBm do que tentar usar o valor exato com mW\n    dbm_absorvido_por_parede = 8\n\n    return intersecoes_com_paredes * dbm_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0)) * precisao\n\n\n@jit\ndef log_distance(d0, d, gamma):\n    """"""\n    Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n    e do ganho das antenas transmissora e receptora.\n    Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n    :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n    :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n    :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n    :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n    """"""\n    # return path_loss(d) + 10 * gamma * log10(d / d0)\n    return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    ## outra coisa: quando conseguir adaptar o SA para varios APs (ex.: 2 ou 3), acho que convem testar uma alteracao\n    # no propagation_model: zerarmos de acordo com a sensibilidade na propria matriz de propagacao ao inves de somente\n    # no showSolucao. Talvez o SA convirja mais rapido do que deixarmos os dBms inuteis\n\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = 0\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    value = log_distance(1, d, 3) - loss_in_wall\n\n    # value = tree_par_log(d) - loss_in_wall\n    # value = loss_in_wall\n    # value = tree_par_log(d)\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    # def objective_function(x):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    ##TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    # return abs(np.mean(matrix))\n\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < minSensibilidade:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n    # return abs(np.sum(np.power(10, matrix)))\n    # return pow(10, x)\n    return abs(np.sum(matrix))\n\n    # sum_reduce = cuda.reduce(lambda a, b: a + b)\n    # return sum_reduce(np.array([10 ** (x / 10.) for line in matrix for x in line]))\n\n\n@cuda.jit\ndef objective_function_kernel(matrix, soma):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n    W = len(matrix)\n    H = len(matrix[0])\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, W, gridX):\n        for y in range(startY, H, gridY):\n            soma += matrix[x][y]\n\n\n@cuda.jit\ndef simulate_kernel(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, WIDTH, gridX):\n        for y in range(startY, HEIGHT, gridY):\n            matrix_results[x][y] = propagation_model_gpu(x, y, apX, apY, floor_plan)\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n\ndef get_point_in_circle(pointX, pointY, ray, round_values=True, num=1, absolute_values=True):\n    """"""\n    M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n    valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n    :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n    :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n    :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n    refer\xc3\xaancia.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n    if absolute_values:\n        x = [abs(k) for k in x]\n        y = [abs(k) for k in y]\n\n    if round_values:\n        x = [round(k) for k in x]\n        y = [round(k) for k in y]\n\n    # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n    if num == 1:\n        return [x[0], y[0]]\n    else:\n        return [x, y]\n\n\n@jit\ndef perturb(SX, SY):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    # Obtem um ponto aleatorio em um raio de X metros\n    return get_point_in_circle(SX, SY, WIDTH * 0.01)\n\n\n@jit\ndef f(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    # ----------------------------------------------------------------------------\n\n    # g_matrix = np.asmatrix(g_matrix, dtype=np.float32)\n    # g_soma = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n    #\n    # d_matrix = cuda.to_device(g_matrix)\n    # d_soma = cuda.to_device(g_soma)\n    #\n    # objective_function_kernel[gridDim, blockDim](d_matrix, d_soma)\n    #\n    # d_matrix.to_host()\n    # d_soma.to_host()\n    #\n    # return abs(np.sum(g_soma))\n    return objective_function(g_matrix)\n\n\ndef simulated_annealing(x0, y0, M, P, L, T0, alpha):\n    """"""\n    :param T0: Temperatura inicial.\n    :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n    S = [x0, y0]\n    T = T0\n    j = 1\n\n    fS = f(S[0], S[1])\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            Si = perturb(S[0], S[1])\n            fSi = f(Si[0], Si[1])\n\n            # show_solution(Si)\n            # print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S) + ""\\t Si: "" + str(Si))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            ## Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            ## Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                ## LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S = Si\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n    return S\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    # hex = str(hex).lstrip(\'#\')\n    # return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n    hex = str(hex).lstrip(\'#\')\n    lv = len(hex)\n    return tuple(int(hex[i:i + lv // 3], 16) for i in range(0, lv, lv // 3))\n\n\ndef draw_line(x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame(matrix_results, access_point):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n    matrix_max_value = matrix_results.max()\n    matrix_min_value = matrix_results.min()\n    # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o do Access Point\n    ap = access_point\n    draw_point(RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n\n    ##TODO escala de cor linear, mas poderia ser exponencial (logaritmica)\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n    # return list[int(position - 1)]\n\n\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n    # SENSITIVITY = 3.1622776601683793319988935444327185337195551393252168e-9 # -85\n    # SENSITIVITY = 3.1622776601683793319988935444327185337195551393252168e-8 # -75\n    # SENSITIVITY = 1e-10 # -100\n    # SENSITIVITY = -85\n    # SENSITIVITY = -75\n    SENSITIVITY = -100\n    if x < SENSITIVITY:\n        return hex_to_rgb(""#000000"")\n\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n    return color\n\n\n@jit\ndef f_plot(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float32)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return g_matrix\n\n\ndef showSolution(SX, SY):\n    print(""\\nDesenhando resultado da simula\xc3\xa7\xc3\xa3o com PyGame."")\n    print_pygame(f_plot(SX, SY), [SX, SY])\n    draw_floor_plan(walls)\n\n\ndef get_color_gradient(steps=250):\n    cores = list(Color(""red"").range_to(Color(""green""), steps))\n    cores.pop(0)\n    cores.pop(len(cores) - 1)\n    return cores\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n    # COLORS = [\n    #     \'#0C0786\', \'#100787\', \'#130689\', \'#15068A\', \'#18068B\', \'#1B068C\', \'#1D068D\', \'#1F058E\',\n    #     \'#21058F\', \'#230590\', \'#250591\', \'#270592\', \'#290593\', \'#2B0594\', \'#2D0494\', \'#2F0495\',\n    #     \'#310496\', \'#330497\', \'#340498\', \'#360498\', \'#380499\', \'#3A049A\', \'#3B039A\', \'#3D039B\',\n    #     \'#3F039C\', \'#40039C\', \'#42039D\', \'#44039E\', \'#45039E\', \'#47029F\', \'#49029F\', \'#4A02A0\',\n    #     \'#4C02A1\', \'#4E02A1\', \'#4F02A2\', \'#5101A2\', \'#5201A3\', \'#5401A3\', \'#5601A3\', \'#5701A4\',\n    #     \'#5901A4\', \'#5A00A5\', \'#5C00A5\', \'#5E00A5\', \'#5F00A6\', \'#6100A6\', \'#6200A6\', \'#6400A7\',\n    #     \'#6500A7\', \'#6700A7\', \'#6800A7\', \'#6A00A7\', \'#6C00A8\', \'#6D00A8\', \'#6F00A8\', \'#7000A8\',\n    #     \'#7200A8\', \'#7300A8\', \'#7500A8\', \'#7601A8\', \'#7801A8\', \'#7901A8\', \'#7B02A8\', \'#7C02A7\',\n    #     \'#7E03A7\', \'#7F03A7\', \'#8104A7\', \'#8204A7\', \'#8405A6\', \'#8506A6\', \'#8607A6\', \'#8807A5\',\n    #     \'#8908A5\', \'#8B09A4\', \'#8C0AA4\', \'#8E0CA4\', \'#8F0DA3\', \'#900EA3\', \'#920FA2\', \'#9310A1\',\n    #     \'#9511A1\', \'#9612A0\', \'#9713A0\', \'#99149F\', \'#9A159E\', \'#9B179E\', \'#9D189D\', \'#9E199C\',\n    #     \'#9F1A9B\', \'#A01B9B\', \'#A21C9A\', \'#A31D99\', \'#A41E98\', \'#A51F97\', \'#A72197\', \'#A82296\',\n    #     \'#A92395\', \'#AA2494\', \'#AC2593\', \'#AD2692\', \'#AE2791\', \'#AF2890\', \'#B02A8F\', \'#B12B8F\',\n    #     \'#B22C8E\', \'#B42D8D\', \'#B52E8C\', \'#B62F8B\', \'#B7308A\', \'#B83289\', \'#B93388\', \'#BA3487\',\n    #     \'#BB3586\', \'#BC3685\', \'#BD3784\', \'#BE3883\', \'#BF3982\', \'#C03B81\', \'#C13C80\', \'#C23D80\',\n    #     \'#C33E7F\', \'#C43F7E\', \'#C5407D\', \'#C6417C\', \'#C7427B\', \'#C8447A\', \'#C94579\', \'#CA4678\',\n    #     \'#CB4777\', \'#CC4876\', \'#CD4975\', \'#CE4A75\', \'#CF4B74\', \'#D04D73\', \'#D14E72\', \'#D14F71\',\n    #     \'#D25070\', \'#D3516F\', \'#D4526E\', \'#D5536D\', \'#D6556D\', \'#D7566C\', \'#D7576B\', \'#D8586A\',\n    #     \'#D95969\', \'#DA5A68\', \'#DB5B67\', \'#DC5D66\', \'#DC5E66\', \'#DD5F65\', \'#DE6064\', \'#DF6163\',\n    #     \'#DF6262\', \'#E06461\', \'#E16560\', \'#E26660\', \'#E3675F\', \'#E3685E\', \'#E46A5D\', \'#E56B5C\',\n    #     \'#E56C5B\', \'#E66D5A\', \'#E76E5A\', \'#E87059\', \'#E87158\', \'#E97257\', \'#EA7356\', \'#EA7455\',\n    #     \'#EB7654\', \'#EC7754\', \'#EC7853\', \'#ED7952\', \'#ED7B51\', \'#EE7C50\', \'#EF7D4F\', \'#EF7E4E\',\n    #     \'#F0804D\', \'#F0814D\', \'#F1824C\', \'#F2844B\', \'#F2854A\', \'#F38649\', \'#F38748\', \'#F48947\',\n    #     \'#F48A47\', \'#F58B46\', \'#F58D45\', \'#F68E44\', \'#F68F43\', \'#F69142\', \'#F79241\', \'#F79341\',\n    #     \'#F89540\', \'#F8963F\', \'#F8983E\', \'#F9993D\', \'#F99A3C\', \'#FA9C3B\', \'#FA9D3A\', \'#FA9F3A\',\n    #     \'#FAA039\', \'#FBA238\', \'#FBA337\', \'#FBA436\', \'#FCA635\', \'#FCA735\', \'#FCA934\', \'#FCAA33\',\n    #     \'#FCAC32\', \'#FCAD31\', \'#FDAF31\', \'#FDB030\', \'#FDB22F\', \'#FDB32E\', \'#FDB52D\', \'#FDB62D\',\n    #     \'#FDB82C\', \'#FDB92B\', \'#FDBB2B\', \'#FDBC2A\', \'#FDBE29\', \'#FDC029\', \'#FDC128\', \'#FDC328\',\n    #     \'#FDC427\', \'#FDC626\', \'#FCC726\', \'#FCC926\', \'#FCCB25\', \'#FCCC25\', \'#FCCE25\', \'#FBD024\',\n    #     \'#FBD124\', \'#FBD324\', \'#FAD524\', \'#FAD624\', \'#FAD824\', \'#F9D924\', \'#F9DB24\', \'#F8DD24\',\n    #     \'#F8DF24\', \'#F7E024\', \'#F7E225\', \'#F6E425\', \'#F6E525\', \'#F5E726\', \'#F5E926\', \'#F4EA26\',\n    #     \'#F3EC26\', \'#F3EE26\', \'#F2F026\', \'#F2F126\', \'#F1F326\', \'#F0F525\', \'#F0F623\', \'#EFF821\'\n    # ]\n\n    COLORS = get_color_gradient(16)\n\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n    escala = 1\n    # walls = read_walls_from_dxf(""./DXFs/bloco-A-l.dxf"")\n    walls = read_walls_from_dxf(""./DXFs/bloco-a-linhas-porta.dxf"")\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n    ## carreguei a planta so para obter a proporcao\n    proporcao_planta = comprimento_planta / largura_planta\n\n    # HEIGHT = int(largura_planta)\n    # WIDTH = int(comprimento_planta)\n    HEIGHT = 200\n    WIDTH = int(HEIGHT * proporcao_planta)\n\n    escala = HEIGHT / largura_planta\n    # escala = WIDTH / comprimento_planta\n    # precisao = 1  # metro\n    precisao = 36.0 / WIDTH\n\n    # walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-sem-porta.dxf"")\n    walls = read_walls_from_dxf(""./DXFs/bloco-a-linhas-porta.dxf"")\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    initial_point = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n\n    ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600\n\n    ## p\n    max_pertub = 5\n\n    ## v\n    num_max_succ = 80\n\n    ## a\n    alpha = .85\n\n    ## t\n    temp_inicial = 300\n\n    ## m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n\n    print(""\\nIniciando simula\xc3\xa7\xc3\xa3o com simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""Ponto inicial:\\t\\t\\t\\t\\t"" + str([initial_point[0], initial_point[1]]))\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""Temperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""Repeti\xc3\xa7\xc3\xb5es do Simulated Annealing:\\t\\t"" + str(max_SA) + ""\\n"")\n\n    bests = []\n\n    for i in range(max_SA):\n        print(""Calculando o melhor ponto ["" + str(i) + ""]"")\n        bests.append(\n            simulated_annealing(initial_point[0], initial_point[1], max_inter, max_pertub, num_max_succ, temp_inicial,\n                                alpha))\n\n    maxFO = 0\n    bestAP = [-1, -1]\n\n    print(""Analizando a melhor solu\xc3\xa7\xc3\xa3o."")\n\n    for ap in bests:\n        ap_fo = objective_function(f_plot(ap[0], ap[1]))\n        if ap_fo > maxFO:\n            maxFO = ap_fo\n            bestAP = ap\n\n    # Inicia o PyGame\n    pygame.init()\n\n    # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n\n    print(""\\nMelhor ponto sugerido pelo algoritmo: "" + str(bestAP))\n\n    showSolution(bestAP[0], bestAP[1])\n    # show_solution(1, 1)\n\n    input(\'\\nFim de execu\xc3\xa7\xc3\xa3o.\')\n'"
debugs/TEST.py,0,"b'def FFF(A, B, D):\n    return (D[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (D[0] - A[0])'"
debugs/Testes.py,10,"b'""""""\nhttps://matplotlib.org/users/pyplot_tutorial.html\nhttp://reliawiki.org/index.php/The_Lognormal_Distribution\nhttp://www.boost.org/doc/libs/1_43_0/libs/math/doc/sf_and_dist/html/math_toolkit/dist/dist_ref/dists/lognormal_dist.html\nhttps://docs.scipy.org/doc/scipy/reference/tutorial/stats.html\n\n\n""""""\n\nimport numpy as np\nimport pylab as pl\nfrom math import log10\nfrom scipy.stats import lognorm\nimport matplotlib.pyplot as plt\n\n\n#stddev = 0.859455801705594\n#mean = 0.418749176686875\n#dist = lognorm([stddev], loc=mean)\n\n\n\ndef mw_to_dbm(mW):\n    """"""This function converts a power given in mW to a power given in dBm.""""""\n    return 10.*log10(mW)\n\ndef dbm_to_mw(dBm):\n    """"""This function converts a power given in dBm to a power given in mW.""""""\n    return 10**((dBm)/10.)\n\ncoleta = [-34,-43,-35,-48,-27,-30,-39,-40,-45,-44,-58,-53,-56,-56,-49,-49,-53,-62,-54,-66,-56,-60,-66,-56,-51,-65,-54,-59,-60,-64,-53,-69,-54,-71,-71,-58,-61,-61,-56,-56,-71]\nitu = [-1.3436E+02, -1.4279E+02, -1.4772E+02, -1.5122E+02, -1.5393E+02, -1.5615E+02, -1.5802E+02, -1.5965E+02, -1.6108E+02, -1.6236E+02, -1.6352E+02, -1.6458E+02, -1.6555E+02, -1.6645E+02, -1.6729E+02, -1.6808E+02, -1.6881E+02, -1.6951E+02, -1.7017E+02, -1.7079E+02, -1.7138E+02, -1.7195E+02, -1.7249E+02, -1.7301E+02, -1.7350E+02, -1.7398E+02, -1.7444E+02, -1.7488E+02, -1.7531E+02, -1.7572E+02, -1.7612E+02, -1.7651E+02, -1.7688E+02, -1.7724E+02, -1.7760E+02, -1.7794E+02, -1.7827E+02, -1.7860E+02, -1.7891E+02, -1.7922E+02, -1.7952E+02]\nfriis = [-3.1898E-02, -7.9744E-03, -3.5442E-03, -1.9936E-03, -1.2759E-03, -8.8605E-04, -6.5097E-04, -4.9840E-04, -3.9380E-04, -3.1898E-04, -2.6362E-04, -2.2151E-04, -1.8874E-04, -1.6274E-04, -1.4177E-04, -1.2460E-04, -1.1037E-04, -9.8450E-05, -8.8359E-05, -7.9744E-05, -7.2330E-05, -6.5904E-05, -6.0298E-05, -5.5378E-05, -5.1036E-05, -4.7186E-05, -4.3755E-05, -4.0686E-05, -3.7928E-05, -3.5442E-05, -3.3192E-05, -3.1150E-05, -2.9291E-05, -2.7593E-05, -2.6039E-05, -2.4612E-05, -2.3300E-05, -2.2090E-05, -2.0972E-05, -1.9936E-05, -1.8975E-05]\ndoisRaios = [37, 25, 18, 13, 9, 6, 3, 1, -1, -3, -4, -6, -7, -9, -10, -11, -12, -13, -14, -15, -16, -17, -17, -18, -19, -19, -20, -21, -21, -22, -22, -23, -24, -24, -25, -25, -26, -26, -26, -27, -27]\n\n# teste de visualizacao da lognormal: OK\n#x = np.linspace(1, 10, 200)\nsigma=np.std(coleta)\nmu=np.mean(coleta)\ndist = lognorm(sigma, loc=mu)\n#pl.plot(x, dist.pdf(x))\n#pl.plot(x, dist.cdf(x))\n#pl.plot(x)\n\npl.plot(coleta)\n\ncoleta_mW = []\nfor value in coleta:\n    coleta_mW.append( dbm_to_mw(value) )\n\nlogNormal_mW = np.random.lognormal( np.mean(coleta_mW) , np.std(coleta_mW) , len(coleta))\n#pl.plot(logNormal_mW)\n\n\nlogNormal_dBm = []\nfor value in logNormal_mW:\n    logNormal_dBm.append( mw_to_dbm(value) )\n\n#pl.plot(logNormal_dBm)\n#logNormal_dBm.sort()\n#pl.plot( logNormal_dBm[::-1] )\n\nlogNormal_dBm_GAMBIARRA = []\n#for value in logNormal_dBm[::-1]:\nfor value in logNormal_dBm:\n\n    logNormal_dBm_GAMBIARRA.append( value*10000 - 70 )\n\npl.plot(logNormal_dBm_GAMBIARRA)\n\n#for i in range(1, 30):\n#    logNormal.append( np.random.lognormal(mu, sigma) )\n#    #logNormal.append(np.random.lognormal(-10.47, 1.6))\n\n\n\n\n#pl.plot(itu)\n#pl.plot(friis)\n#pl.plot(doisRaios)\npl.show()\n\n#mu, sigma = np.mean(coleta_mW), np.std(coleta_mW) # mean and standard deviation\n#s = np.random.lognormal(mu, sigma, 100)\n##print(s)\n##pl.plot(s)\n#s_dBm = []\n#for value in s:\n#    s_dBm.append(mw_to_dbm(value))\n#print(logNormal_dBm)\n#pl.plot(s_dBm)\n#count, bins, ignored = plt.hist(s, 100, normed=True, align=\'mid\')\n#x = np.linspace(min(bins), max(bins), 10000)\n#pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2)) / (x * sigma * np.sqrt(2 * np.pi)))\n#plt.plot(x, pdf, linewidth=2, color=\'r\')\n#plt.axis(\'tight\')\n#plt.show()'"
debugs/__init__.py,0,b''
debugs/backtracking-maze.py,0,"b'def step(maze, x, y):\n    # https://thetokenizer.com/2013/01/13/practicing-backtracking/\n\n    # Accept case - we found the exit\n    if maze[x][y] == \'X\':\n        return True\n\n    # Reject case - we hit a wall or our path\n    if maze[x][y] == \'#\' or maze[x][y] == \'*\':\n        return False\n\n    maze[x][y] = \'*\'\n\n    # Try to go Right\n    result = step(maze, x, y + 1)\n    if result:\n        return True\n\n    # Try to go Up\n    result = step(maze, x - 1, y)\n    if result:\n        return True\n\n    # Try to go Left\n    result = step(maze, x, y - 1)\n    if result:\n        return True\n\n    # Try to go Down\n    result = step(maze, x + 1, y)\n    if result:\n        return True\n\n    # Deadend - this location can\'t be part of the solution\n    # Unmark this location\n    maze[x][y] = \' \'\n\n    # Go back\n    return False\n\n\n# Get the start location (x,y) and try to solve the maze\ndef solve(maze, x, y):\n    if step(maze, x, y):\n        maze[x][y] = \'S\'\n\n\ndef toString():\n    output = """"\n    for x in range(len(maze)):\n        for y in range(len(maze[0])):\n            output += maze[x][y] + "" ""\n\n        output += ""\\n""\n\n    return output\n\n\nif __name__ == \'__main__\':\n    maze = [\n        [\'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\'],\n        [\'#\', \' \', \' \', \' \', \'#\', \' \', \'#\', \' \', \' \', \'#\'],\n        [\'#\', \' \', \' \', \' \', \'#\', \' \', \'#\', \' \', \'#\', \'#\'],\n        [\'#\', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \'#\'],\n        [\'#\', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \' \', \'#\'],\n        [\'#\', \'#\', \'#\', \' \', \' \', \' \', \' \', \' \', \' \', \'#\'],\n        [\'#\', \' \', \' \', \' \', \' \', \'#\', \'#\', \'#\', \'#\', \'#\'],\n        [\'#\', \' \', \' \', \' \', \' \', \' \', \'#\', \' \', \'#\', \'#\'],\n        [\'#\', \' \', \'#\', \' \', \' \', \' \', \' \', \' \', \' \', \'#\'],\n        [\'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\', \'#\']\n    ]\n\n    maze[7][7] = \'X\'\n\n    solve(maze, 8, 1)\n\n    print(toString())\n'"
debugs/backtracking.py,1,"b""import sys\n\n#   https://stackoverflow.com/questions/20034023/maximum-recursion-depth-exceeded-in-comparison\n#\n#\n#\nimport numpy as np\n\nsys.setrecursionlimit(10000 * 10000)\n\n\ndef solveMaze(Maze, position, point):\n    N = len(Maze)  # lin\n    M = len(Maze[0])  # col\n\n    # print(position)\n\n    # returns a list of the paths taken\n    if position == point:\n        return [point]\n\n    x, y = position\n\n    # if x <= point[0] and y <= point[1]:\n    #\n    #     if y + 1 < M and x + 1 < N and x <= point[0] and y <= point[1] and Maze[x + 1][y + 1] == 0:\n    #         a = solveMaze(Maze, (x + 1, y + 1), point)\n    #         if a is not None:\n    #             return [(x, y)] + a\n    #\n    #     if x + 1 < N and Maze[x + 1][y] == 0:\n    #         b = solveMaze(Maze, (x + 1, y), point)\n    #         if b is not None:\n    #             return [(x, y)] + b\n    #\n    #     if y + 1 < M and Maze[x][y + 1] == 0:\n    #         c = solveMaze(Maze, (x, y + 1), point)\n    #         if c is not None:\n    #             return [(x, y)] + c\n    # # ---------------------------------------------------------\n    # elif x >= point[0] and y >= point[1]:\n    #\n    #     if y - 1 >= 0 and x - 1 >= 0 and x >= point[0] and y >= point[1] and Maze[x - 1][y - 1] == 0:\n    #         d = solveMaze(Maze, (x - 1, y - 1), point)\n    #         if d is not None:\n    #             return [(x, y)] + d\n    #\n    #     if x - 1 >= 0 and Maze[x - 1][y] == 0:\n    #         e = solveMaze(Maze, (x - 1, y), point)\n    #         if e is not None:\n    #             return [(x, y)] + e\n    #\n    #     if y - 1 >= 0 and Maze[x][y - 1] == 0:\n    #         f = solveMaze(Maze, (x, y - 1), point)\n    #         if f is not None:\n    #             return [(x, y)] + f\n\n    if y + 1 < M and x + 1 < N and Maze[x + 1][y + 1] == 0:\n        a = solveMaze(Maze, (x + 1, y + 1), point)\n        if a is not None:\n            return [(x, y)] + a\n\n    if x + 1 < N and Maze[x + 1][y] == 0:\n        b = solveMaze(Maze, (x + 1, y), point)\n        if b is not None:\n            return [(x, y)] + b\n\n    if y + 1 < M and Maze[x][y + 1] == 0:\n        c = solveMaze(Maze, (x, y + 1), point)\n        if c is not None:\n            return [(x, y)] + c\n\n\nMaze = np.zeros(shape=(10, 10))\n\nimport pygame\nimport sys\nimport time\nfrom pygame.locals import *\n\npygame.init()\ns = 50\nDISPLAYSURF = pygame.display.set_mode((len(Maze)*s, len(Maze[0])*s), 0, 32)\npygame.display.set_caption('Drawing')\n\n# set up the colors\nBLACK = (0, 0, 0)\nGRAY = (50, 50, 50)\nWHITE = (255, 255, 255)\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nBLUE = (0, 0, 255)\n\nsolucao = solveMaze(Maze, (0, 0), (5, 9))\nx=0\ny=1\n\nfor i in range(len(Maze)):\n    pygame.draw.line(DISPLAYSURF, GRAY, (s*i,s*0), (s*i,s*len(Maze[0])) )\n\nfor j in range(len(Maze[0])):\n    pygame.draw.line(DISPLAYSURF, GRAY, (s*0,s*j), (s*len(Maze),s*j) )\n\nfor i in range(1, len(solucao)-1):\n    pygame.draw.line(DISPLAYSURF, GREEN, (s*solucao[i-1][x], s*solucao[i-1][y]), (s*solucao[i][x], s*solucao[i][y]))\n\n\nwhile True:\n    for event in pygame.event.get():\n        if event.type == QUIT:\n            pygame.quit()\n            sys.exit()\n    pygame.display.update()\n    #sleep ou yield\n    time.sleep(5)"""
debugs/between.py,0,"b'matrix = [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\nbla = [[x for row in range(len(matrix))] for x in range(len(matrix[0]))]\n\nWIDTH = 10\nHEIGHT = 10\n'"
debugs/blue.py,0,"b'#  https://stackoverflow.com/questions/19532473/floor-plan-edge-detection-image-processing\n\nimport numpy as np\nimport cv2\n\nimg = cv2.imread(""/home/samuel/PycharmProjects/TCC/floor.png"")\n\nimg_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n\nret, thresh = cv2.threshold(img_gray, 230, 255, cv2.THRESH_BINARY_INV)\n\nimg_, contours, hierarchy = cv2.findContours(thresh.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\nlargest_contour_area = 0\nfor cnt in contours:\n    if cv2.contourArea(cnt) > largest_contour_area:\n        largest_contour_area = cv2.contourArea(cnt)\n        largest_contour = cnt\n\nepsilon = 0.001 * cv2.arcLength(largest_contour, True)\napprox = cv2.approxPolyDP(largest_contour, epsilon, True)\n\nfinal = cv2.drawContours(img, [approx], 0, [0, 255, 0])\n\ncv2.imwrite(\'image-saida.png\', final)\n'"
debugs/color_levels.py,3,"b""import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import LogNorm\n\nfrom matplotlib.ticker import LogFormatter\n\ndelta = 0.025\n\nx = y = np.arange(0, 3.01, delta)\nX, Y = np.meshgrid(x, y)\nZ1 = plt.mlab.bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)\nZ2 = plt.mlab.bivariate_normal(X, Y, 1.5, 0.5, 1, 1)\nZ = 10 * (Z1 * Z2)\n\nfig = plt.figure()\nax1 = fig.add_subplot(111)\nlvls = np.logspace(-4, 0, 20)\nCF = ax1.contourf(X, Y, Z,\n                  norm=LogNorm(),\n                  levels=lvls\n                  )\nCS = ax1.contour(X, Y, Z,\n                 norm=LogNorm(),\n                 colors='k',\n                 levels=lvls\n                 )\n\nl_f = LogFormatter(10, labelOnlyBase=False)\n\ncbar = plt.colorbar(CF, ticks=lvls, format=l_f)\nplt.show()\n"""
debugs/colors.py,0,"b'""""""\n========================\nVisualizing named colors\n========================\n\nSimple plot example with the named colors and its visual representation.\n""""""\nfrom __future__ import division\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors as mcolors\n\ncolors = dict(mcolors.BASE_COLORS, **mcolors.CSS4_COLORS)\n\n# Sort colors by hue, saturation, value and name.\nby_hsv = sorted((tuple(mcolors.rgb_to_hsv(mcolors.to_rgba(color)[:3])), name)\n                for name, color in colors.items())\nsorted_names = [name for hsv, name in by_hsv]\n\nn = len(sorted_names)\nncols = 4\nnrows = n // ncols + 1\n\nfig, ax = plt.subplots(figsize=(8, 5))\n\n# Get height and width\nX, Y = fig.get_dpi() * fig.get_size_inches()\nh = Y / (nrows + 1)\nw = X / ncols\n\nfor i, name in enumerate(sorted_names):\n    col = i % ncols\n    row = i // ncols\n    y = Y - (row * h) - h\n\n    xi_line = w * (col + 0.05)\n    xf_line = w * (col + 0.25)\n    xi_text = w * (col + 0.3)\n\n    ax.text(xi_text, y, name, fontsize=(h * 0.8),\n            horizontalalignment=\'left\',\n            verticalalignment=\'center\')\n\n    ax.hlines(y + h * 0.1, xi_line, xf_line,\n              color=colors[name], linewidth=(h * 0.6))\n\nax.set_xlim(0, X)\nax.set_ylim(0, Y)\nax.set_axis_off()\n\nfig.subplots_adjust(left=0, right=1,\n                    top=1, bottom=0,\n                    hspace=0, wspace=0)\nplt.show()\n'"
debugs/copia_main.py,3,"b'if __name__ == \'__main__\':\n\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DOS EQUIPAMENTOS\n\n    # OBS.: por conta da precisao de casas decimais do float\n    #        \xc3\xa9 melhor pegar a ordem de magnitude com o dBm do\n    #        que tentar usar o valor exato com mW\n\n    # Sensibilidade dos equipamentos receptores\n    SENSITIVITY = -90\n\n    # Gradiente de cores da visualiza\xc3\xa7\xc3\xa3o gr\xc3\xa1fica\n    COLORS = get_color_gradient(16)  # 64, 32, 24, 16, 8\n\n    PAINT_BLACK_BELOW_SENSITIVITY = True\n    # PAINT_BLACK_BELOW_SENSITIVITY = False\n\n    DBM_MIN_VALUE = np.finfo(np.float32).min\n\n    # parede de concredo, de 8 a 15 dB.\n    dbm_absorvido_por_parede = 8\n\n    # Pot\xc3\xaancia de transmiss\xc3\xa3o de cada AP\n    # Pt_dBm = -14\n    # Pt_dBm = -17\n    # Pt_dBm = -20\n    Pt_dBm = -25\n    # Pt_dBm = -30\n\n    # Quantidade de APs\n    num_aps = 2\n\n    POSICAO_INICIAL_ALEATORIA = False\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE E PLANTA-BAIXA\n\n    COMPRIMENTO_BLOCO_A = 48.0\n    COMPRIMENTO_BLOCO_B = 36.0\n    COMPRIMENTO_BLOCO_C = 51.0\n\n    COMPRIMENTO_EDIFICIO = COMPRIMENTO_BLOCO_B\n    # LARGURA_EDIFICIO = ???\n\n    # dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_a/bloco_A_planta baixa_piso1_porta.dxf""\n\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso1.dxf""\n    dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/com_porta/bloco_C_planta baixa_piso3.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta_baixa_piso1.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso2.dxf""\n    # dxf_path = ""./DXFs/bloco_c/sem_porta/bloco_C_planta baixa_piso3.dxf""\n\n    # carrega para saber o comprimento da planta\n    walls = read_walls_from_dxf(dxf_path, 1)\n    floor_plan = np.array(walls, dtype=np.float32)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO AMBIENTE SIMULADO\n\n    # ENVIRONMENT = ""GPU""\n    ENVIRONMENT = ""CPU""\n\n    # Tamanho da simula\xc3\xa7\xc3\xa3o\n    TAMAMHO_SIMULACAO = 400\n    # TAMAMHO_SIMULACAO = 600\n\n    # Ativa / Desativa a anima\xc3\xa7\xc3\xa3o passo a passo da otimiza\xc3\xa7\xc3\xa3o\n    # ANIMACAO_PASSO_A_PASSO   = True\n    ANIMACAO_PASSO_A_PASSO = False\n\n    # ANIMACAO_MELHORES_LOCAIS = True\n    ANIMACAO_MELHORES_LOCAIS = False\n\n    # ANIMACAO_MELHORES = True\n    ANIMACAO_MELHORES = False\n\n    ##################################################\n\n    # Lista para guardar as fun\xc3\xa7\xc3\xb5es objetivos calculadas durante a simula\xc3\xa7\xc3\xa3o\n    FOs = []\n\n    WIDTH = TAMAMHO_SIMULACAO\n    HEIGHT = int(WIDTH * (largura_planta / comprimento_planta))\n    escala = WIDTH / comprimento_planta\n    precisao = COMPRIMENTO_EDIFICIO / WIDTH\n\n    TOTAL_PONTOS = WIDTH * HEIGHT\n\n    # HEIGHT = TAMAMHO_SIMULACAO\n    # WIDTH = int(HEIGHT * (comprimento_planta / largura_planta))\n    # escala = HEIGHT / largura_planta\n    # precisao = LARGURA_EDIFICIO / WIDTH\n\n    # RE-carrega utilizando a escala apropriada\n    walls = read_walls_from_dxf(dxf_path, escala)\n    floor_plan = np.array(walls, dtype=np.float32)\n    ##################################################\n\n    ##################################################\n    #  CONFIGURA\xc3\x87\xc3\x95ES DO OTIMIZADOR\n\n    # fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600\n    # max_inter = 600 * (1 + num_aps)\n    # max_inter = 600 * (10 * num_aps)\n    # max_inter = TOTAL_PONTOS * 0.2\n\n    # p - M\xc3\xa1ximo de perturba\xc3\xa7\xc3\xb5es\n    max_pertub = 5\n\n    # RAIO_PERTURBACAO = WIDTH * 0.0100\n    # RAIO_PERTURBACAO = WIDTH * 0.0175\n    # RAIO_PERTURBACAO = WIDTH * 0.0250\n    # RAIO_PERTURBACAO = WIDTH * 0.1100\n    beta = 1\n    RAIO_PERTURBACAO = (1 / precisao) * (beta + num_aps)  ## VALADAO testing\n    # RAIO_PERTURBACAO = (1 / precisao) * (1 + num_aps)  ## VALADAO testing\n\n    # v - M\xc3\xa1ximo de vizinhos\n    # num_max_succ = 80\n    # num_max_succ = 80 * 10\n    # num_max_succ = 80 * (beta + num_aps) * 3\n    num_max_succ = 240 * (beta + num_aps)\n\n    # a - Alpha\n    alpha = .85\n    # alpha = .95\n\n    # t - Temperatura\n    temp_inicial = 300 * (beta + num_aps)\n    # temp_inicial = 300 * (1 + num_aps) * 10\n\n    # M\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n    ##################################################\n\n    # Visualiza\xc3\xa7\xc3\xa3o dos dados\n    # Inicia o PyGame e configura o tamanho da janela\n    # pygame.init()\n    # icon = pygame.image.load(\'images/icon.png\')\n    # pygame.display.set_icon(icon)\n    # pygame.display.set_caption(""Resultado Simula\xc3\xa7\xc3\xa3o - IFMG Campus Formiga"")\n    # DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n\n    show_configs()\n    # test_propagation()\n    run()\n\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    # cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    # python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    # cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n\n    # generate_summary([[50, 50]])\n\n    # input(\'\\nAperte ESC para fechar a simula\xc3\xa7\xc3\xa3o.\')\n\n    # profile.runctx(\'run()\', globals(), locals(),\'tese\')\n    # cProfile.run(statement=\'run()\', filename=\'PlacementAPs.cprof\')\n\n    # python ../main.py | egrep ""(tottime)|(main.py)"" | tee ../cProfile/PlacementAPs.py_COM-JIT.txt\n    # cat ../cProfile/PlacementAPs.py_COM-JIT.txt | sort -k 2 -r\n\n    # python main.py | egrep \'(ncalls)|(PlacementAPs)\'\n    # https://julien.danjou.info/blog/2015/guide-to-python-profiling-cprofile-concrete-case-carbonara\n'"
debugs/cor.py,0,"b'from colour import Color\n\nhex = ""#adf""\n\ncorR = int(Color(hex).get_red() * 255)\ncorG = int(Color(hex).get_green() * 255)\ncorB = int(Color(hex).get_blue() * 255)\n\ncor = tuple([corR, corG, corB])\n\nprint(cor)\n'"
debugs/cpu_fractal.py,1,"b'import numpy as np\nfrom pylab import imshow, show\nfrom timeit import default_timer as timer\nfrom numba import autojit, prange, jit, cuda\nimport numba\n\n#@cuda.autojit()\n@jit()\ndef mandel(x, y, max_iters):\n    """"""\n      Given the real and imaginary parts of a complex number,\n      determine if it is a candidate for membership in the Mandelbrot\n      set given a fixed number of iterations.\n    """"""\n    c = complex(x, y)\n    z = 0.0j\n    for i in prange(max_iters):\n        z = z * z + c\n        if (z.real * z.real + z.imag * z.imag) >= 4:\n            return i\n\n    return max_iters\n\n#@cuda.autojit()\n@jit()\ndef create_fractal(min_x, max_x, min_y, max_y, image, iters):\n    height = image.shape[0]\n    width = image.shape[1]\n\n    pixel_size_x = (max_x - min_x) / width\n    pixel_size_y = (max_y - min_y) / height\n\n    for x in prange(width):\n        real = min_x + x * pixel_size_x\n        for y in prange(height):\n            imag = min_y + y * pixel_size_y\n            color = mandel(real, imag, iters)\n            image[y, x] = color\n\n\nimage = np.zeros((1024*10, 1536*10), dtype=np.uint8)\nstart = timer()\ncreate_fractal(-2.0, 1.0, -1.0, 1.0, image, 20)\ndt = timer() - start\n\nprint(""Mandelbrot created in "" + str(dt) + "" s"")\n#imshow(image)\n#show()\n'"
debugs/cuda2.py,2,"b'import numpy as np\nimport time\n\nfrom numbapro import vectorize\n\n@vectorize([""float32(float32, float32)""], target=\'cuda\')\ndef VectorAdd(a, b):\n    return a + b\n\n\ndef main():\n    N = 32000000\n\n    A = np.ones(N, dtype=np.float32)\n    B = np.ones(N, dtype=np.float32)\n\n    start = time.time()\n    C = VectorAdd(A, B)\n    vector_add_time = time.time() - start\n\n    print(""C[:5] = "" + str(C[:5]))\n    print(""C[-5:] = "" + str(C[-5:]))\n\n    print(""VectorAdd took for %f seconds"" % vector_add_time)\n\n\nif __name__ == \'__main__\':\n    main()\n\n\n    # https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=deblocal\n    # https://devblogs.nvidia.com/parallelforall/even-easier-introduction-cuda/\n    # https://developer.nvidia.com/cuda-toolkit\n    # https://developer.nvidia.com/how-to-cuda-python\n    # https://docs.anaconda.com/anaconda/install/linux\n    # https://www.anaconda.com/download/#linux'"
debugs/cuda_fractal.py,2,"b'from timeit import default_timer as timer\nfrom numba import cuda\nfrom numba import *\nfrom timeit import default_timer as timer\n\nimport numpy as np\n\nfrom pylab import *\n\nfrom numba import *\nfrom numba import cuda\n\n\n# @guvectorize([""void(float32, float32, uint8, uint8[:])""], ""(),(),()->()"", target=\'cuda\')\n# def mandel(x, y, max_iters, out):\n# @guvectorize([\'uint8(float32, float32, uint8, uint8[:])\'], \'(),(),()->()\', target=\'cuda\')\n# def mandel(x, y, max_iters, out):\n@autojit\ndef mandel(x, y, max_iters):\n    """"""\n      Given the real and imaginary parts of a complex number,\n      determine if it is a candidate for membership in the Mandelbrot\n      set given a fixed number of iterations.\n    """"""\n    # out[0] = 0\n\n    c = complex(x, y)\n    z = 0.0j\n    # i = np.dtype(0, np.uint8)\n    for i in range(max_iters):\n        z = z * z + c\n        if (z.real * z.real + z.imag * z.imag) >= 4:\n            # out[0] = i\n            return i\n\n    # if out > 0:\n    #    out[0] = max_iters\n    return max_iters\n\n\n@cuda.jit\ndef mandel_kernel(min_x, max_x, min_y, max_y, image, iters):\n    height = image.shape[0]\n    width = image.shape[1]\n\n    pixel_size_x = (max_x - min_x) / width\n    pixel_size_y = (max_y - min_y) / height\n\n    ## CUDA FIX\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    ## CUDA FIX\n    for x in prange(startX, width, gridX):\n        # for x in range(width):\n        real = min_x + x * pixel_size_x\n        ## CUDA FIX\n        for y in prange(startY, height, gridY):\n            # for y in range(height):\n            imag = min_y + y * pixel_size_y\n            image[y, x] = mandel_gpu(real, imag, iters)\n\n\n# @guvectorize([""void(float32, float32, float32, float32, int32, uint8[:,:])""], ""(),(),(),(),()->(,)"", target=\'cuda\')\n# def create_fractal(min_x, max_x, min_y, max_y, iters, image):\n# @guvectorize([""void(uint8[:,:],uint8[:])""], ""(m,n)"", target=\'cuda\')\n# def create_fractal(image,out):\n\nmandel_gpu = cuda.jit(device=True)(mandel)\n\ngimage = np.zeros((1024 * 10, 1536 * 10), dtype=np.uint8)\n\n## CUDA WTF\n## A GPU GeForce GT 740M tem 384 n\xc3\xbacleos\n## blocos de 48x8 = 384 threads\nblockDim = (48, 8)\n## cada thread trabalha num grid de 32x16\ngridDim = (32, 16)\n\nstart = timer()\n\n## copia a matrix g_image da RAM para a GPU (d_image)\nd_image = cuda.to_device(gimage)\n\n## calcula a matrix d_image na GPU, passando para cada thread os blocos\nmandel_kernel[gridDim, blockDim](-2.0, 1.0, -1.0, 1.0, d_image, 20)\n\n## copia o resultado da d_image GPU para g_image na RAM\nd_image.to_host()\n\ndt = timer() - start\n\nprint(""Mandelbrot created in "" + str(dt) + "" s"")\n# imshow(gimage)\n# show()\n'"
debugs/cuda_mult.py,3,"b'import numpy as np\nimport math\nfrom timeit import default_timer as timer\nfrom numba import cuda\nfrom numba import *\n\n\ndef mult(a, b):\n    return a * b\n\n\nmult_gpu = cuda.jit(restype=float32, argtypes=[float32, float32], device=True)(mult)\n\n\n@cuda.jit(argtypes=[float32[:, :], float32[:, :], float32[:, :, :]])\ndef mult_kernel(a, b, c):\n    Ni = c.shape[0]\n    Nj = c.shape[1]\n    Nk = c.shape[2]\n\n    startX, startY, startZ = cuda.grid(3)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n    gridZ = cuda.gridDim.z * cuda.blockDim.z\n\n    for i in range(startX, Ni, gridX):\n        for j in range(startY, Nj, gridY):\n            c[i, j] = 0\n            for k in range(startZ, Nk, gridZ):\n                c[i, j] = c[i, j] + mult_gpu(a[i, k], b[j, k])\n\n\ndef main():\n    A = np.ones((20, 50000), dtype=np.float32)\n    B = np.ones((3072, 50000), dtype=np.float32)\n    C = np.ones((20, 3072, 50000), dtype=np.float32)\n    (Ni, Nj, Nk) = C.shape\n\n    my_gpu = cuda.get_current_device()\n    thread_ct = 8\n    block_ct_x = int(math.ceil(float(Ni) / thread_ct))\n    block_ct_y = int(math.ceil(float(Nj) / thread_ct))\n    block_ct_z = int(math.ceil(float(Nk) / thread_ct))\n\n    blockdim = thread_ct, thread_ct, thread_ct\n    griddim = block_ct_x, block_ct_y, block_ct_z\n    print(""Threads per block:"", blockdim)\n    print(""Blocks per grid:"", griddim)\n\n    start = timer()\n    Cg = cuda.to_device(C)\n    mult_kernel[griddim, blockdim](A, B, Cg)\n    Cg.to_host()\n    dt = timer() - start\n    print(""Computation done in %f s"" % (dt))\n\n    print(\'C[:3,1,1] = \', C[:3, 1, 1])\n    print(\'C[-3:,1,1] = \', C[-3:, 1, 1])\n\n\nif __name__ == \'__main__\':\n    main()\n'"
debugs/cuda_reduce.py,0,"b'import numpy\nfrom numba import cuda\n\n\n@cuda.reduce\ndef sum_reduce(a, b):\n    return a + b\n\n\nA = (numpy.arange(1234, dtype=numpy.float64)) + 1\nexpect = A.sum()  # numpy sum reduction\ngot = sum_reduce(A)  # cuda sum reduction\nassert expect == got\nprint(expect == got)'"
debugs/cudamatt.py,0,"b'def maior_que_zero(x):\n     return x > 0\n\nvalores = [10, 4, -1, 3, 5, -9, -11]\nprint (list(filter(maior_que_zero, valores)))'"
debugs/desenha-planta.py,0,"b'# Figure 8.20, page 444.\n# Floor planning example.\n# https://github.com/troyshu/python-cvxopt/blob/master/examples/book/chap8/floorplan.py\n\nfrom cvxopt import solvers, matrix, spmatrix, mul, div\n\ntry:\n    import pylab\nexcept ImportError:\n    pylab_installed = False\nelse:\n    pylab_installed = True\n\n\ndef floorplan(Amin):\n    #     minimize    W+H\n    #     subject to  Amin1 / h1 <= w1\n    #                 Amin2 / h2 <= w2\n    #                 Amin3 / h3 <= w3\n    #                 Amin4 / h4 <= w4\n    #                 Amin5 / h5 <= w5\n    #                 x1 >= 0\n    #                 x2 >= 0\n    #                 x4 >= 0\n    #                 x1 + w1 + rho <= x3\n    #                 x2 + w2 + rho <= x3\n    #                 x3 + w3 + rho <= x5\n    #                 x4 + w4 + rho <= x5\n    #                 x5 + w5 <= W\n    #                 y2 >= 0\n    #                 y3 >= 0\n    #                 y5 >= 0\n    #                 y2 + h2 + rho <= y1\n    #                 y1 + h1 + rho <= y4\n    #                 y3 + h3 + rho <= y4\n    #                 y4 + h4 <= H\n    #                 y5 + h5 <= H\n    #                 h1/gamma <= w1 <= gamma*h1\n    #                 h2/gamma <= w2 <= gamma*h2\n    #                 h3/gamma <= w3 <= gamma*h3\n    #                 h4/gamma <= w4 <= gamma*h4\n    #                 h5/gamma <= w5 <= gamma*h5\n    #\n    # 22 Variables W, H, x (5), y (5), w (5), h (5).\n    #\n    # W, H:  scalars; bounding box width and height\n    # x, y:  5-vectors; coordinates of bottom left corners of blocks\n    # w, h:  5-vectors; widths and heigths of the 5 blocks\n\n    rho, gamma = 1.0, 5.0  # min spacing, min aspect ratio\n\n    # The objective is to minimize W + H.  There are five nonlinear\n    # constraints\n    #\n    #     -w1 + Amin1 / h1 <= 0\n    #     -w2 + Amin2 / h2 <= 0\n    #     -w3 + Amin3 / h3 <= 0\n    #     -w4 + Amin4 / h4 <= 0\n    #     -w5 + Amin5 / h5 <= 0.\n\n    c = matrix(2 * [1.0] + 20 * [0.0])\n\n    def F(x=None, z=None):\n        if x is None:\n            return 5, matrix(17 * [0.0] + 5 * [1.0])\n        if min(x[17:]) <= 0.0:\n            return None\n        f = -x[12:17] + div(Amin, x[17:])\n        Df = matrix(0.0, (5, 22))\n        Df[:, 12:17] = spmatrix(-1.0, range(5), range(5))\n        Df[:, 17:] = spmatrix(-div(Amin, x[17:] ** 2), range(5), range(5))\n        if z is None:\n            return f, Df\n        H = spmatrix(2.0 * mul(z, div(Amin, x[17::] ** 3)), range(17, 22),\n                     range(17, 22))\n        return f, Df, H\n\n    # linear inequalities\n    G = matrix(0.0, (26, 22))\n    h = matrix(0.0, (26, 1))\n\n    # -x1 <= 0\n    G[0, 2] = -1.0\n\n    # -x2 <= 0\n    G[1, 3] = -1.0\n\n    # -x4 <= 0\n    G[2, 5] = -1.0\n\n    # x1 - x3 + w1 <= -rho\n    G[3, [2, 4, 12]], h[3] = [1.0, -1.0, 1.0], -rho\n\n    # x2 - x3 + w2 <= -rho\n    G[4, [3, 4, 13]], h[4] = [1.0, -1.0, 1.0], -rho\n\n    # x3 - x5 + w3 <= -rho\n    G[5, [4, 6, 14]], h[5] = [1.0, -1.0, 1.0], -rho\n\n    # x4 - x5 + w4 <= -rho\n    G[6, [5, 6, 15]], h[6] = [1.0, -1.0, 1.0], -rho\n\n    # -W + x5 + w5 <= 0\n    G[7, [0, 6, 16]] = -1.0, 1.0, 1.0\n\n    # -y2 <= 0\n    G[8, 8] = -1.0\n\n    # -y3 <= 0\n    G[9, 9] = -1.0\n\n    # -y5 <= 0\n    G[10, 11] = -1.0\n\n    # -y1 + y2 + h2 <= -rho\n    G[11, [7, 8, 18]], h[11] = [-1.0, 1.0, 1.0], -rho\n\n    # y1 - y4 + h1 <= -rho\n    G[12, [7, 10, 17]], h[12] = [1.0, -1.0, 1.0], -rho\n\n    # y3 - y4 + h3 <= -rho\n    G[13, [9, 10, 19]], h[13] = [1.0, -1.0, 1.0], -rho\n\n    # -H + y4 + h4 <= 0\n    G[14, [1, 10, 20]] = -1.0, 1.0, 1.0\n\n    # -H + y5 + h5 <= 0\n    G[15, [1, 11, 21]] = -1.0, 1.0, 1.0\n\n    # -w1 + h1/gamma <= 0\n    G[16, [12, 17]] = -1.0, 1.0 / gamma\n\n    # w1 - gamma * h1 <= 0\n    G[17, [12, 17]] = 1.0, -gamma\n\n    # -w2 + h2/gamma <= 0\n    G[18, [13, 18]] = -1.0, 1.0 / gamma\n\n    # w2 - gamma * h2 <= 0\n    G[19, [13, 18]] = 1.0, -gamma\n\n    # -w3 + h3/gamma <= 0\n    G[20, [14, 18]] = -1.0, 1.0 / gamma\n\n    # w3 - gamma * h3 <= 0\n    G[21, [14, 19]] = 1.0, -gamma\n\n    # -w4  + h4/gamma <= 0\n    G[22, [15, 19]] = -1.0, 1.0 / gamma\n\n    # w4 - gamma * h4 <= 0\n    G[23, [15, 20]] = 1.0, -gamma\n\n    # -w5 + h5/gamma <= 0\n    G[24, [16, 21]] = -1.0, 1.0 / gamma\n\n    # w5 - gamma * h5 <= 0.0\n    G[25, [16, 21]] = 1.0, -gamma\n\n    # solve and return W, H, x, y, w, h\n    sol = solvers.cpl(c, F, G, h)\n    return sol[\'x\'][0], sol[\'x\'][1], sol[\'x\'][2:7], sol[\'x\'][7:12], \\\n           sol[\'x\'][12:17], sol[\'x\'][17:]\n\n\n# solvers.options[\'show_progress\'] = False\n\nif pylab_installed: pylab.figure(facecolor=\'w\')\n\nAmin = matrix([100., 100., 100., 100., 100.])\nW, H, x, y, w, h = floorplan(Amin)\nif pylab_installed:\n    if pylab_installed: pylab.subplot(221)\n    for k in range(5):\n        pylab.fill([x[k], x[k], x[k] + w[k], x[k] + w[k]],\n                   [y[k], y[k] + h[k], y[k] + h[k], y[k]],\n                   facecolor=\'#D0D0D0\')\n        pylab.text(x[k] + .5 * w[k], y[k] + .5 * h[k], ""%d"" % (k + 1))\n    pylab.axis([-1.0, 26, -1.0, 26])\n    pylab.xticks([])\n    pylab.yticks([])\n\nAmin = matrix([20., 50., 80., 150., 200.])\nW, H, x, y, w, h = floorplan(Amin)\nif pylab_installed:\n    pylab.subplot(222)\n    for k in range(5):\n        pylab.fill([x[k], x[k], x[k] + w[k], x[k] + w[k]],\n                   [y[k], y[k] + h[k], y[k] + h[k], y[k]],\n                   facecolor=\'#D0D0D0\')\n        pylab.text(x[k] + .5 * w[k], y[k] + .5 * h[k], ""%d"" % (k + 1))\n    pylab.axis([-1.0, 26, -1.0, 26])\n    pylab.xticks([])\n    pylab.yticks([])\n\nAmin = matrix([180., 80., 80., 80., 80.])\nW, H, x, y, w, h = floorplan(Amin)\nif pylab_installed:\n    pylab.subplot(223)\n    for k in range(5):\n        pylab.fill([x[k], x[k], x[k] + w[k], x[k] + w[k]],\n                   [y[k], y[k] + h[k], y[k] + h[k], y[k]],\n                   facecolor=\'#D0D0D0\')\n        pylab.text(x[k] + .5 * w[k], y[k] + .5 * h[k], ""%d"" % (k + 1))\n    pylab.axis([-1.0, 26, -1.0, 26])\n    pylab.xticks([])\n    pylab.yticks([])\n\nAmin = matrix([20., 150., 20., 200., 110.])\nW, H, x, y, w, h = floorplan(Amin)\nif pylab_installed:\n    pylab.subplot(224)\n    for k in range(5):\n        pylab.fill([x[k], x[k], x[k] + w[k], x[k] + w[k]],\n                   [y[k], y[k] + h[k], y[k] + h[k], y[k]],\n                   facecolor=\'#D0D0D0\')\n        pylab.text(x[k] + .5 * w[k], y[k] + .5 * h[k], ""%d"" % (k + 1))\n    pylab.axis([-1.0, 26, -1.0, 26])\n    pylab.xticks([])\n    pylab.yticks([])\n\n    pylab.show()\n'"
debugs/intercept.py,0,"b'import numpy as np\n\nretas_paredes = [\n    [944, 466, 944, 469],\n    [1011, 469, 1011, 669],\n    [1015, 469, 1015, 669],\n    [406, 378, 569, 378],\n    [406, 374, 566, 374],\n    [383, 378, 383, 374],\n    [406, 378, 406, 374],\n    [920, 469, 920, 669],\n    [917, 469, 917, 669],\n    [1011, 482, 964, 482],\n    [1011, 481, 964, 481],\n    [944, 469, 1011, 469],\n    [944, 466, 1016, 466],\n    [826, 469, 893, 469],\n    [826, 481, 872, 481],\n    [826, 482, 872, 482],\n    [962, 479, 962, 469],\n    [963, 479, 963, 469],\n    [922, 466, 915, 466],\n    [922, 469, 920, 469],\n    [893, 466, 893, 469],\n    [922, 466, 922, 469],\n    [915, 466, 915, 469],\n    [917, 469, 915, 469],\n    [915, 469, 917, 469],\n    [915, 466, 922, 466],\n    [920, 469, 922, 469],\n    [874, 479, 874, 469],\n    [875, 479, 875, 469],\n    [1011, 669, 920, 669],\n    [917, 669, 826, 670],\n    [958, 546, 958, 556],\n    [959, 576, 920, 576],\n    [959, 577, 920, 577],\n    [959, 607, 920, 607],\n    [958, 608, 920, 608],\n    [958, 597, 958, 607],\n    [958, 632, 958, 633],\n    [958, 632, 958, 632],\n    [958, 632, 958, 632],\n    [959, 633, 959, 632],\n    [959, 633, 959, 632],\n    [959, 632, 958, 632],\n    [959, 609, 958, 609],\n    [959, 608, 959, 609],\n    [959, 608, 959, 609],\n    [958, 609, 958, 609],\n    [958, 609, 958, 609],\n    [958, 609, 958, 608],\n    [958, 609, 935, 609],\n    [935, 609, 935, 610],\n    [935, 610, 958, 610],\n    [958, 610, 958, 609],\n    [958, 608, 959, 608],\n    [958, 633, 959, 633],\n    [958, 633, 958, 669],\n    [959, 633, 959, 669],\n    [958, 579, 958, 578],\n    [940, 579, 958, 579],\n    [940, 578, 940, 579],\n    [958, 578, 940, 578],\n    [958, 578, 958, 577],\n    [958, 578, 958, 578],\n    [958, 578, 958, 578],\n    [959, 577, 959, 578],\n    [959, 577, 959, 578],\n    [959, 578, 958, 578],\n    [959, 596, 958, 596],\n    [959, 597, 959, 596],\n    [959, 597, 959, 596],\n    [958, 596, 958, 596],\n    [958, 596, 958, 596],\n    [958, 596, 958, 597],\n    [958, 597, 959, 597],\n    [959, 597, 959, 608],\n    [959, 576, 959, 577],\n    [958, 557, 958, 556],\n    [958, 557, 958, 557],\n    [958, 557, 958, 557],\n    [959, 556, 959, 557],\n    [959, 556, 959, 557],\n    [959, 557, 958, 557],\n    [959, 574, 958, 574],\n    [959, 576, 959, 574],\n    [959, 576, 959, 574],\n    [958, 574, 958, 575],\n    [958, 575, 958, 575],\n    [958, 575, 958, 576],\n    [958, 575, 940, 575],\n    [940, 575, 940, 574],\n    [940, 574, 958, 574],\n    [958, 574, 958, 575],\n    [958, 556, 959, 556],\n    [959, 546, 959, 556],\n    [998, 652, 998, 651],\n    [1011, 652, 998, 652],\n    [1011, 651, 998, 651],\n    [1011, 633, 998, 633],\n    [1011, 632, 998, 632],\n    [998, 632, 998, 633],\n    [1011, 614, 998, 614],\n    [1011, 613, 998, 613],\n    [998, 613, 998, 614],\n    [998, 596, 998, 594],\n    [1011, 596, 998, 596],\n    [1011, 594, 998, 594],\n    [959, 514, 920, 514],\n    [959, 512, 920, 512],\n    [959, 512, 959, 514],\n    [959, 546, 920, 546],\n    [959, 544, 920, 544],\n    [959, 514, 959, 524],\n    [958, 524, 959, 524],\n    [958, 543, 958, 543],\n    [940, 543, 958, 543],\n    [940, 543, 940, 543],\n    [958, 543, 940, 543],\n    [958, 543, 958, 544],\n    [958, 543, 958, 543],\n    [958, 543, 958, 543],\n    [959, 544, 959, 543],\n    [959, 544, 959, 543],\n    [959, 543, 958, 543],\n    [959, 526, 958, 526],\n    [959, 524, 959, 526],\n    [959, 524, 959, 526],\n    [958, 526, 958, 525],\n    [958, 525, 958, 525],\n    [958, 525, 958, 524],\n    [958, 514, 958, 524],\n    [879, 514, 879, 524],\n    [879, 525, 879, 524],\n    [879, 525, 879, 525],\n    [879, 526, 879, 525],\n    [878, 524, 878, 526],\n    [878, 524, 878, 526],\n    [878, 526, 879, 526],\n    [878, 543, 879, 543],\n    [878, 544, 878, 543],\n    [878, 544, 878, 543],\n    [879, 543, 879, 543],\n    [879, 543, 879, 543],\n    [879, 543, 879, 544],\n    [879, 543, 897, 543],\n    [897, 543, 897, 543],\n    [897, 543, 879, 543],\n    [879, 543, 879, 543],\n    [879, 524, 878, 524],\n    [878, 514, 878, 524],\n    [878, 544, 917, 544],\n    [878, 546, 917, 546],\n    [878, 512, 878, 514],\n    [878, 512, 917, 512],\n    [878, 514, 917, 514],\n    [878, 546, 878, 556],\n    [879, 556, 878, 556],\n    [879, 574, 879, 575],\n    [897, 574, 879, 574],\n    [897, 575, 897, 574],\n    [879, 575, 897, 575],\n    [879, 575, 879, 576],\n    [879, 575, 879, 575],\n    [879, 574, 879, 575],\n    [878, 576, 878, 574],\n    [878, 576, 878, 574],\n    [878, 574, 879, 574],\n    [878, 557, 879, 557],\n    [878, 556, 878, 557],\n    [878, 556, 878, 557],\n    [879, 557, 879, 557],\n    [879, 557, 879, 557],\n    [879, 557, 879, 556],\n    [878, 576, 878, 577],\n    [878, 597, 878, 608],\n    [879, 597, 878, 597],\n    [879, 596, 879, 597],\n    [879, 596, 879, 596],\n    [879, 596, 879, 596],\n    [878, 597, 878, 596],\n    [878, 597, 878, 596],\n    [878, 596, 879, 596],\n    [878, 578, 879, 578],\n    [878, 577, 878, 578],\n    [878, 577, 878, 578],\n    [879, 578, 879, 578],\n    [879, 578, 879, 578],\n    [879, 578, 879, 577],\n    [879, 578, 897, 578],\n    [897, 578, 897, 579],\n    [897, 579, 879, 579],\n    [879, 579, 879, 578],\n    [879, 633, 878, 633],\n    [879, 608, 878, 608],\n    [879, 610, 879, 609],\n    [902, 610, 879, 610],\n    [902, 609, 902, 610],\n    [879, 609, 902, 609],\n    [879, 609, 879, 608],\n    [879, 609, 879, 609],\n    [879, 609, 879, 609],\n    [878, 608, 878, 609],\n    [878, 608, 878, 609],\n    [878, 609, 879, 609],\n    [878, 632, 879, 632],\n    [878, 633, 878, 632],\n    [878, 633, 878, 632],\n    [879, 632, 879, 632],\n    [879, 632, 879, 632],\n    [879, 632, 879, 633],\n    [879, 597, 879, 607],\n    [879, 608, 917, 608],\n    [878, 607, 917, 607],\n    [878, 577, 917, 577],\n    [878, 576, 917, 576],\n    [879, 546, 879, 556],\n    [878, 633, 878, 669],\n    [879, 633, 879, 669],\n    [566, 171, 566, 0],\n    [569, 378, 569, 3],\n    [821, 378, 821, 3],\n    [825, 171, 825, 0],\n    [1038, 469, 1198, 469],\n    [1038, 466, 1038, 469],\n    [1016, 466, 1016, 469],\n    [797, 466, 631, 466],\n    [797, 469, 636, 469],\n    [893, 466, 820, 466],\n    [820, 466, 820, 469],\n    [797, 466, 797, 469],\n    [508, 469, 511, 469],\n    [822, 669, 636, 669],\n    [822, 469, 820, 469],\n    [1015, 469, 1016, 469],\n    [822, 469, 822, 669],\n    [826, 469, 826, 669],\n    [188, 469, 188, 669],\n    [3, 466, 163, 466],\n    [3, 378, 163, 378],\n    [192, 469, 192, 669],\n    [377, 469, 377, 669],\n    [381, 469, 381, 669],\n    [377, 669, 192, 669],\n    [374, 466, 383, 466],\n    [374, 469, 377, 469],\n    [352, 466, 352, 469],\n    [406, 466, 406, 469],\n    [383, 466, 383, 469],\n    [374, 466, 374, 469],\n    [381, 469, 383, 469],\n    [406, 466, 511, 466],\n    [3, 469, 163, 469],\n    [406, 469, 504, 469],\n    [825, 0, 566, 0],\n    [821, 3, 569, 3],\n    [1198, 174, 1198, 374],\n    [1202, 171, 1202, 673],\n    [1013, 374, 1013, 174],\n    [1009, 374, 1009, 174],\n    [825, 171, 1202, 171],\n    [1009, 175, 825, 174],\n    [1016, 378, 1007, 378],\n    [1016, 374, 1013, 374],\n    [1038, 378, 1038, 374],\n    [984, 378, 984, 374],\n    [1007, 378, 1007, 374],\n    [1016, 378, 1016, 374],\n    [1009, 374, 1007, 374],\n    [984, 378, 821, 378],\n    [984, 374, 825, 374],\n    [1198, 374, 1038, 374],\n    [1198, 378, 1038, 378],\n    [825, 374, 825, 174],\n    [566, 374, 566, 174],\n    [3, 374, 163, 374],\n    [381, 374, 383, 374],\n    [374, 378, 383, 378],\n    [374, 378, 374, 374],\n    [352, 378, 352, 374],\n    [186, 374, 188, 374],\n    [381, 374, 381, 174],\n    [377, 374, 377, 174],\n    [188, 174, 188, 374],\n    [192, 174, 192, 374],\n    [381, 669, 391, 669],\n    [467, 632, 504, 632],\n    [467, 632, 467, 649],\n    [463, 628, 504, 628],\n    [463, 628, 463, 649],\n    [504, 632, 504, 669],\n    [467, 669, 504, 669],\n    [463, 667, 467, 667],\n    [463, 649, 467, 649],\n    [463, 667, 463, 669],\n    [467, 667, 467, 669],\n    [381, 669, 463, 669],\n    [504, 469, 504, 628],\n    [508, 469, 508, 628],\n    [504, 632, 504, 669],\n    [549, 603, 549, 606],\n    [546, 628, 528, 628],\n    [546, 599, 546, 606],\n    [546, 632, 528, 632],\n    [508, 632, 508, 669],\n    [508, 669, 546, 669],\n    [622, 673, 636, 673],\n    [549, 669, 632, 669],\n    [511, 628, 511, 632],\n    [528, 628, 528, 632],\n    [511, 628, 508, 628],\n    [511, 632, 508, 632],\n    [632, 603, 549, 603],\n    [632, 599, 546, 599],\n    [546, 632, 546, 669],\n    [632, 469, 632, 599],\n    [549, 606, 546, 606],\n    [549, 626, 546, 626],\n    [546, 626, 546, 628],\n    [549, 626, 549, 669],\n    [636, 469, 636, 669],\n    [533, 466, 533, 469],\n    [511, 466, 511, 469],\n    [533, 466, 636, 466],\n    [533, 469, 632, 469],\n    [1198, 469, 1198, 669],\n    [1038, 466, 1198, 466],\n    [1015, 669, 1198, 669],\n    [0, 673, 1202, 673],\n    [632, 603, 632, 669],\n    [566, 174, 381, 175],\n    [3, 469, 3, 669],\n    [0, 171, 0, 673],\n    [3, 174, 3, 374],\n    [192, 469, 352, 469],\n    [188, 669, 3, 669],\n    [566, 171, 0, 171],\n    [377, 174, 366, 174],\n    [186, 466, 186, 469],\n    [163, 466, 163, 469],\n    [163, 378, 163, 374],\n    [186, 378, 186, 374],\n    [186, 466, 352, 466],\n    [186, 469, 188, 469],\n    [186, 378, 352, 378],\n    [3, 378, 3, 466],\n    [1198, 378, 1198, 466],\n    [1013, 174, 1198, 174],\n    [188, 175, 3, 175],\n    [377, 175, 192, 175],\n    [192, 374, 352, 374],\n    [374, 374, 377, 374],\n]\n\n\ndef side(a, b, c):\n    """""" Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different\n    """"""\n    d = (c[1] - a[1]) * (b[0] - a[0]) - (b[1] - a[1]) * (c[0] - a[0])\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\ndef is_point_in_closed_segment(a, b, c):\n    """""" Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    """"""\n    if a[0] < b[0]:\n        return a[0] <= c[0] and c[0] <= b[0]\n    if b[0] < a[0]:\n        return b[0] <= c[0] and c[0] <= a[0]\n\n    if a[1] < b[1]:\n        return a[1] <= c[1] and c[1] <= b[1]\n    if b[1] < a[1]:\n        return b[1] <= c[1] and c[1] <= a[1]\n\n    return a[0] == c[0] and a[1] == c[1]\n\n\n#\ndef closed_segment_intersect(a, b, c, d):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n    if a == b:\n        return a == c or a == d\n    if c == d:\n        return c == a or c == b\n\n    s1 = side(a, b, c)\n    s2 = side(a, b, d)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        return \\\n            is_point_in_closed_segment(a, b, c) or is_point_in_closed_segment(a, b, d) or \\\n            is_point_in_closed_segment(c, d, a) or is_point_in_closed_segment(c, d, b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(c, d, a)\n    s2 = side(c, d, b)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n#\n# def ccw(A, B, C):\n#     return (C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\n\ndef intersect(A, B, C, D):\n    if ((D[1] - A[1]) * (C[0] - A[0]) > (C[1] - A[1]) * (D[0] - A[0])) \\\n            != ((D[1] - B[1]) * (C[0] - B[0]) > (C[1] - B[1]) * (D[0] - B[0])) \\\n            and ((C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])) \\\n                    != ((D[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (D[0] - A[0])):\n        return 1\n    return 0\n        # return ccw(A, C, D) != ccw(B, C, D) and ccw(A, B, C) != ccw(A, B, D)\n\ndef absorcao_paredes(AccessPoint, Destino):\n    # Seus pontos (origem, destino)\n    # AccessPoint = [0,0]\n    # Destino = [899, 579]\n\n    intersecoes = 0\n\n    a = filter(lambda x: intersect(AccessPoint, Destino, x[0:2], x[2:4]), retas_paredes)\n\n    b = filter(lambda x: x != 0, a)\n\n    intersecoes = len(list(b))\n\n    # for reta_parede in retas_paredes:\n    #     # Coordenadas da parede\n    #     ParedePxyA = reta_parede[0:2]\n    #     ParedePxyB = reta_parede[2:4]\n\n        # if(closed_segment_intersect(AccessPoint, Destino, ParedePxyA, ParedePxyB)):\n        #     intersecoes = intersecoes + 1\n\n        # if intersect(AccessPoint, Destino, ParedePxyA, ParedePxyB):\n        #     intersecoes = intersecoes + 1\n\n            # if(intersectLines(AccessPoint, Destino, ParedePxyA, ParedePxyB)):\n            #     intersecoes = intersecoes + 1\n\n            # if(intersection(    AccessPoint, Destino, ParedePxyA, ParedePxyB)):\n            #     intersecoes = intersecoes + 1\n\n    dBm_absorvido_por_parede = 5\n    miliWatts_absorvido_por_parede = pow(10, (dBm_absorvido_por_parede / 10))\n\n    intersecoes_com_paredes = intersecoes / 2\n    print(""intersecoes_com_paredes = "" + str(intersecoes_com_paredes))\n    return intersecoes_com_paredes * miliWatts_absorvido_por_parede\n\n\nabsorcao_paredes((0, 0), (899, 579))\n'"
debugs/log_color.py,1,"b""import matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\nimport numpy as np\nfrom matplotlib.mlab import bivariate_normal\n\n\nN = 100\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\n\n# A low hump with a spike coming out of the top right.\n# Needs to have z/colour axis on a log scale so we see both hump and spike.\n# linear scale only shows the spike.\nZ1 = bivariate_normal(X, Y, 0.1, 0.2, 1.0, 1.0) + 0.1 * bivariate_normal(X, Y, 1.0, 1.0, 0.0, 0.0)\n\nplt.subplot(2, 1, 1)\nplt.pcolor(X, Y, Z1, norm=LogNorm(vmin=Z1.min(), vmax=Z1.max()), cmap='PuBu_r')\nplt.colorbar()\n\nplt.subplot(2, 1, 2)\nplt.pcolor(X, Y, Z1, cmap='PuBu_r')\nplt.colorbar()\n\n\nplt.show()"""
debugs/neural.py,9,"b'# coding: utf-8\n\n# # Annotations for the Sirajology Python NN Example\n#\n# This code comes from a demo NN program from the YouTube video https://youtu.be/h3l4qz76JhQ. The program creates an neural network that simulates the exclusive OR function with two inputs and one output.\n#\n#\n\n# In[23]:\n\nimport numpy as np  # Note: there is a typo on this line in the video\n\n\n# The following is a function definition of the sigmoid function, which is the type of non-linearity chosen for this neural net. It is not the only type of non-linearity that can be chosen, but is has nice analytical features and is easy to teach with. In practice, large-scale deep learning systems use piecewise-linear functions because they are much less expensive to evaluate.\n#\n# The implementation of this function does double duty. If the deriv=True flag is passed in, the function instead calculates the derivative of the function, which is used in the error backpropogation step.\n\n# In[24]:\n\ndef nonlin(x, deriv=False):  # Note: there is a typo on this line in the video\n    if (deriv == True):\n        return (x * (1 - x))\n\n    return 1 / (1 + np.exp(-x))  # Note: there is a typo on this line in the video\n\n\n# The following code creates the input matrix. Although not mentioned in the video, the third column is for accommodating the bias term and is not part of the input.\n\n# In[25]:\n\n# input data\nX = np.array([[0, 0, 1],  # Note: there is a typo on this line in the video\n              [0, 1, 1],\n              [1, 0, 1],\n              [1, 1, 1]])\n\n# The output of the exclusive OR function follows.\n\n# In[26]:\n\n# output data\ny = np.array([[0],\n              [1],\n              [1],\n              [0]])\n\n# The seed for the random generator is set so that it will return the same random numbers each time, which is sometimes useful for debugging.\n\n# In[27]:\n\nnp.random.seed(1)\n\n# Now we intialize the weights to random values. syn0 are the weights between the input layer and the hidden layer.  It is a 3x4 matrix because there are two input weights plus a bias term (=3) and four nodes in the hidden layer (=4). syn1 are the weights between the hidden layer and the output layer. It is a 4x1 matrix because there are 4 nodes in the hidden layer and one output. Note that there is no bias term feeding the output layer in this example. The weights are initially generated randomly because optimization tends not to work well when all the weights start at the same value. Note that neither of the neural networks shown in the video describe the example.\n\n# In[28]:\n\n# synapses\nsyn0 = 2 * np.random.random((3, 4)) - 1  # 3x4 matrix of weights ((2 inputs + 1 bias) x 4 nodes in the hidden layer)\nsyn1 = 2 * np.random.random(\n    (4, 1)) - 1  # 4x1 matrix of weights. (4 nodes x 1 output) - no bias term in the hidden layer.\n\n# This is the main training loop. The output shows the evolution of the error between the model and desired. The error steadily decreases.\n\n# In[29]:\n\n# training step\n# Python2 Note: In the follow command, you may improve\n#   performance by replacing \'range\' with \'xrange\'.\nfor j in range(60000):\n\n    # Calculate forward through the network.\n    l0 = X\n    l1 = nonlin(np.dot(l0, syn0))\n    l2 = nonlin(np.dot(l1, syn1))\n\n    # Back propagation of errors using the chain rule.\n    l2_error = y - l2\n    if (j % 10000) == 0:  # Only print the error every 10000 steps, to save time and limit the amount of output.\n        print(""Error: "" + str(np.mean(np.abs(l2_error))))\n\n    l2_delta = l2_error * nonlin(l2, deriv=True)\n\n    l1_error = l2_delta.dot(syn1.T)\n\n    l1_delta = l1_error * nonlin(l1, deriv=True)\n\n    # update weights (no learning rate term)\n    syn1 += l1.T.dot(l2_delta)\n    syn0 += l0.T.dot(l1_delta)\n\nprint(""Output after training"")\nprint(l2)\n\n# See how the final output closely approximates the true output [0, 1, 1, 0]. If you increase the number of interations in the training loop (currently 60000), the final output will be even closer.\n\n# In[30]:\n\n# get_ipython().run_cell_magic(u\'HTML\', u\'\', u\'#The following line is for embedding the YouTube video \\n#   in this Jupyter Notebook. You may remove it without peril. \\n<iframe width=""560"" height=""315"" src=""https://www.youtube.com/embed/h3l4qz76JhQ"" frameborder=""0"" allowfullscreen></iframe>\')\n\n\n# In[ ]:\n\n\n\n'"
debugs/notification.py,0,"b'import gi\n\ngi.require_version(\'Gio\', \'2.0\')\nfrom gi.repository import Gio\n\nApplication = Gio.Application.new(""hello.world"", Gio.ApplicationFlags.FLAGS_NONE)\nApplication.register()\nNotification = Gio.Notification.new(""Hello world"")\nNotification.set_body(""This is an example notification."")\nIcon = Gio.ThemedIcon.new(""dialog-information"")\nNotification.set_icon(Icon)\nApplication.send_notification(None, Notification)\n'"
debugs/polynomial.py,6,"b""from __future__ import print_function\nimport polynomial as poly\nfrom numba import *\nimport numpy as np\nfrom timeit import default_timer as time\nimport sys\n\ndef main():\n    cu_discriminant = vectorize([f4(f4, f4, f4), f8(f8, f8, f8)],\n                                target='cuda')(poly.discriminant)\n\n    N = 1e+8 // 2\n\n    print('Data size', N)\n\n    A, B, C = poly.generate_input(N, dtype=np.float32)\n    D = np.empty(A.shape, dtype=A.dtype)\n\n    stream = cuda.stream()\n\n    print('== One')\n\n    ts = time()\n\n    with stream.auto_synchronize():\n        dA = cuda.to_device(A, stream)\n        dB = cuda.to_device(B, stream)\n        dC = cuda.to_device(C, stream)\n        dD = cuda.to_device(D, stream, copy=False)\n        cu_discriminant(dA, dB, dC, out=dD, stream=stream)\n        dD.to_host(stream)\n\n    te = time()\n\n\n    total_time = (te - ts)\n\n    print('Execution time %.4f' % total_time)\n    print('Throughput %.2f' % (N / total_time))\n\n    print('== Chunked')\n\n    chunksize = 1e+7\n    chunkcount = N // chunksize\n\n    print('Chunk size', chunksize)\n\n    sA = np.split(A, chunkcount)\n    sB = np.split(B, chunkcount)\n    sC = np.split(C, chunkcount)\n    sD = np.split(D, chunkcount)\n\n    device_ptrs = []\n\n    ts = time()\n\n    with stream.auto_synchronize():\n        for a, b, c, d in zip(sA, sB, sC, sD):\n            dA = cuda.to_device(a, stream)\n            dB = cuda.to_device(b, stream)\n            dC = cuda.to_device(c, stream)\n            dD = cuda.to_device(d, stream, copy=False)\n            cu_discriminant(dA, dB, dC, out=dD, stream=stream)\n            dD.to_host(stream)\n            device_ptrs.extend([dA, dB, dC, dD])\n\n    te = time()\n\n    total_time = (te - ts)\n\n    print('Execution time %.4f' % total_time)\n    print('Throughput %.2f' % (N / total_time))\n\n\n    if '-verify' in sys.argv[1:]:\n        poly.check_answer(D, A, B, C)\n\n\nif __name__ == '__main__':\n    main()\n"""
debugs/raytracer.py,4,"b'## https://gist.github.com/hawkerpl/5487c62d6b14b3f8b40d\n\nimport numpy as np\n\ndef _range_when_zero(iterlist):\n    for i, pixel in enumerate(iterlist):\n        if pixel == 0:\n            return i\n    else:\n        return float(len(iterlist))\n\n\ndef _count_step(d_x, d_y, x, y, i, sina, minim):\n    if minim == 1:\n        return np.floor(sina*i), i\n    else:\n        return i, np.floor(i/sina)\n\ndef _range_when_non_zero(d_x, d_y, x, y, tab):\n    maxval = max(d_x, d_y)\n    sina = d_x/float(d_y)\n    minim = (d_x, d_y).index(maxval)\n    for i in xrange(maxval):\n        step_x, step_y = _count_step(d_x, d_y, x, y, i, sina, minim)\n        value = tab[y+step_y, x+step_x, 0]\n        if value == 0:\n            return np.sqrt(step_x**2 + step_y**2)\n    return np.sqrt(d_x**2 + d_y**2)\n\ndef trace_ray(tab, start, end):\n    x0, y0 = map(int,start)\n    x1, y1 = map(int,end)\n    d_x = x1 - x0\n    d_y = y1 - y0\n    if d_x == 0:\n        ym = (y0,y1)\n        return _range_when_zero(iterlist=tab[min(ym):max(ym), x0, 0])\n    elif d_y == 0:\n        xm = (x0,x1)\n        return _range_when_zero(iterlist=tab[y0, min(xm):max(xm), 0])\n    else:\n        return _range_when_non_zero(d_x, d_y, x0, y0, tab)'"
debugs/read_srtm.py,1,"b""import numpy as np\n\nSAMPLES = 1201  # Change this to 3601 for SRTM1\n\n\n# https://librenepal.com/article/reading-srtm-data-with-python/\n\ndef read_elevation_from_file(hgt_file, lon, lat):\n    with open(hgt_file, 'rb') as hgt_data:\n        # Each data is 16bit signed integer(i2) - big endian(>)\n        elevations = np.fromfile(hgt_data, np.dtype('>i2'), SAMPLES * SAMPLES) \\\n            .reshape((SAMPLES, SAMPLES))\n\n        lat_row = int(round((lat - int(lat)) * (SAMPLES - 1), 0))\n        lon_row = int(round((lon - int(lon)) * (SAMPLES - 1), 0))\n\n        return elevations[SAMPLES - 1 - lat_row, lon_row].astype(int)\n\n\nprint(read_elevation_from_file('S17W065.hgt', 86.925278, 27.988056))\n"""
debugs/sa.py,4,"b'#   https://am207.github.io/2017/wiki/lab4.html\n#   https://pt.wikipedia.org/wiki/Simulated_annealing\n#   https://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly\n#   https://stackoverflow.com/questions/19720445/invert-negative-values-in-a-list\n#   https://www.ime.usp.br/~ghaeser/Hae_Gom.pdf\n\nfrom math import sqrt, exp\nfrom random import random\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\ndef get_points_in_circle(ray, point, round_values=True, num=1, absolute_values=True, debug=False):\n    """"""\n    M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param ray: Valor do raio desejado.\n    :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n    :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n    valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n    :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n    :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n    :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n    refer\xc3\xaancia.\n    :return: Um ponto ou um conjunto de pontos do tipo float\n    """"""\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + point[0]\n    y = r * np.sin(t) + point[1]\n\n    # Converte todos os valores negativos da lista em positivos\n    if absolute_values:\n        x = [abs(k) for k in x]\n        y = [abs(k) for k in y]\n\n    if debug:\n        plt.plot(x, y, ""ro"", ms=1)\n        plt.axis([-15, 15, -15, 15])\n\n        for i in range(num):\n            print(""Dist\xc3\xa2ncia entre o ponto ({}, {}) ""\n                  ""e o ponto ({}, {}) com raio [{}] = {}"".format(point[0], point[1], x[i], y[i], ray,\n                                                                 calc_distance(point[0], point[1], x[i], y[i])))\n        plt.show()\n\n    if round_values:\n        x = [round(k) for k in x]\n        y = [round(k) for k in y]\n\n    # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n    if num == 1:\n        return [x[0], y[0]]\n    else:\n        return [x, y]\n\n\ndef temperatura_inicial():\n    """"""\n    Fun\xc3\xa7\xc3\xa3o que calcula a temperatura inicial;\n    :return:\n    """"""\n    return 100\n\n\ndef pertuba(S, matrix):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S;\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o\n    :param S:\n    :return:\n    """"""\n    return 0\n\n\ndef f(x):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x:\n    :return:\n    """"""\n    return 0\n\n\ndef randomiza():\n    """"""\n    Fun\xc3\xa7\xc3\xa3o que gera um n\xc3\xbamero aleat\xc3\xb3rio no intervalo [0,1];\n    :return:\n    """"""\n    return random.random()\n\ndef simulated_annealing(S0, M, P, L, alpha, matrix):\n    """"""\n\n    :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?;\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada);\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada);\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada);\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada);\n    :return:\n    """"""\n    S = S0\n    T0 = temperatura_inicial()   # Pode ser passado por paramentro?\n    T = T0\n    j = 1\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            Si = pertuba(S, matrix)         # Tera que mandar o ponto atual e a matriz tbm. Realiza a simula\xc3\xa7\xc3\xa3o\n            deltaFi = f(Si) - f(S)  # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto.\n\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > randomiza()):\n                S = Si\n                nSucesso = nSucesso + 1\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    return S\n\n\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0))\n\n\nif __name__ == \'__main__\':\n\n    print(get_points_in_circle(3, [0, 0]))\n'"
debugs/save.py,0,"b'\n\n\ndef ZZw(X, Y, Z):\n    return (Z[1] - X[1]) * (Y[0] - X[0]) > (Y[1] - X[1]) * (Z[0] - X[0])'"
debugs/teste_colors.py,0,"b'from colour import Color\n\n\ndef get_color_gradient(steps=256):\n    return list(Color(""green"").range_to(Color(""red""), steps))\n\n\ncores = get_color_gradient()\ncores.pop(0)\ncores.pop(len(cores)-1)\n\ncor = cores[0]\n\nfor cor in cores:\n    print(cor)\n'"
debugs/teste_cuda.py,11,"b'import math\nimport tkinter as tk\nfrom datetime import datetime\nfrom math import sqrt, pi, log10, exp\nfrom random import random\nimport random as rd\n\nimport ezdxf\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom numpy import matrix\nimport pygame\n\nfrom numba import autojit, prange, cuda, jit\nimport numba\n\n""""""\nClasse que realiza a simula\xc3\xa7\xc3\xa3o da propaga\xc3\xa7\xc3\xa3o do sinal wireless de determinado ambiente 2D de acordo com um Access\nPoint Informado.\n""""""\n\n\n@jit\ndef read_walls_from_dxf(dxf_path):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por ler um arquivo DXF e filtrar pela camada ARQ as paredes do ambiente.\n    :param dxf_path: Caminho do arquivo de entrada, sendo ele no formato DFX.\n    :return: Retorna uma lista contendo em cada posi\xc3\xa7\xc3\xa3o, uma lista de quatro elementos, sendo os dois primeiros\n    refer\xc3\xaantes ao ponto inicial da parede e os dois ultimo refer\xc3\xaante ao ponto final da parede.\n    """"""\n    dwg = ezdxf.readfile(dxf_path)\n\n    walls = []\n\n    modelspace = dwg.modelspace()\n\n    ##TODO 7 por que?\n    # escala = 7\n\n    xMin = -1\n    yMin = -1\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            if e.dxf.start[0] < xMin or xMin == -1:\n                xMin = e.dxf.start[0]\n            if e.dxf.start[1] < yMin or yMin == -1:\n                yMin = e.dxf.start[1]\n\n    for e in modelspace:\n        if e.dxftype() == \'LINE\' and e.dxf.layer == \'ARQ\':\n            line = [\n                int((e.dxf.start[0] - xMin) * escala),\n                int((e.dxf.start[1] - yMin) * escala),\n                int((e.dxf.end[0] - xMin) * escala),\n                int((e.dxf.end[1] - yMin) * escala)\n            ]\n            walls.append(line)\n\n    return walls\n\n\n@jit\ndef side(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns a position of the point c relative to the line going through a and b\n        Points a, b are expected to be different.\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return:\n    """"""\n    d = (cY - aY) * (bX - aX) - (bY - aY) * (cX - aX)\n    return 1 if d > 0 else (-1 if d < 0 else 0)\n\n\n@jit\ndef is_point_in_closed_segment(aX, aY, bX, bY, cX, cY):\n    """"""\n    Returns True if c is inside closed segment, False otherwise.\n        a, b, c are expected to be collinear\n    :param a: Ponto A.\n    :param b: Ponto B.\n    :param c: Ponto C.\n    :return: Retorna valor booleano True se for um ponto fechado por segmento de reta. Caso contrario retorna False.\n    """"""\n    if aX < bX:\n        return aX <= cX <= bX\n    if bX < aX:\n        return bX <= cX <= aX\n\n    if aY < bY:\n        return aY <= cY <= bY\n    if bY < aY:\n        return bY <= cY <= aY\n\n    return aX == cX and aY == cY\n\n\n@jit\ndef closed_segment_intersect(aX, aY, bX, bY, cX, cY, dX, dY):\n    """""" Verifies if closed segments a, b, c, d do intersect.\n    """"""\n\n    if (aX == bX) and (aY == bY):\n        return (aX == cX and aY == cY) or (aX == dX and aY == dY)\n    if (cX == dX) and (cY == dY):\n        return (cX == aX and cY == aY) or (cX == bX and cY == bY)\n\n    # TODO ao inves de invocar a funcao side, colocar a formula aqui\n    s1 = side(aX, aY, bX, bY, cX, cY)\n    s2 = side(aX, aY, bX, bY, dX, dY)\n\n    # All points are collinear\n    if s1 == 0 and s2 == 0:\n        # TODO ao inves de invocar a funcao is_point_in_closed_segment, colocar a formula aqui\n        return \\\n            is_point_in_closed_segment(aX, aY, bX, bY, cX, cY) or is_point_in_closed_segment(aX, aY, bX, bY, dX, dY) or \\\n            is_point_in_closed_segment(cX, cY, dX, dY, aX, aY) or is_point_in_closed_segment(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    s1 = side(cX, cY, dX, dY, aX, aY)\n    s2 = side(cX, cY, dX, dY, bX, bY)\n\n    # No touching and on the same side\n    if s1 and s1 == s2:\n        return False\n\n    return True\n\n\n## TODO: otimizar este procedimento pois est\xc3\xa1 fazendo a simula\xc3\xa7\xc3\xa3o ficar 163x mais lento\n## @numba.jit(""float64( int32[2], int32[2], List(List(int64)) )"", target=\'parallel\')\n## @numba.jit(target=\'cpu\', forceobj=True)\n@jit\ndef absorption_in_walls(apX, apY, destinyX, destinyY, floor_plan):\n    intersections = 0\n\n    size = len(floor_plan)\n\n    # if size > 0:\n    #     intersections = 1000000000\n\n    for i in range(size):\n        # Coordenadas da parede\n\n        if closed_segment_intersect(apX, apY, destinyX, destinyY, floor_plan[i][0], floor_plan[i][1], floor_plan[i][2],\n                                    floor_plan[i][3]):\n            intersections += 1\n\n    ## OBS.: dividir por dois se cada parede for um retangulo no DXF\n    # intersecoes_com_paredes = intersections / 2\n    intersecoes_com_paredes = intersections\n\n    # parede de concredo, de 8 a 15 dB\n    miliWatts_absorvido_por_parede = dbm_to_mw(10)\n\n    return intersecoes_com_paredes * miliWatts_absorvido_por_parede\n\n\n@jit\ndef mw_to_dbm(mW):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em mW para dBm\n    :param mW: Valor em miliwatts.\n    :return: Valor de miliwatts convertido para decib\xc3\xa9is.\n    """"""\n    return 10. * log10(mW)\n\n\n@jit\ndef dbm_to_mw(dBm):\n    """"""\n    M\xc3\xa9todo que converte a pot\xc3\xaancia recebida dada em dBm para mW.\n    :param dBm: Valor em decib\xc3\xa9is.\n    :return: Valor de decib\xc3\xa9is convertidos em miliwatts.\n    """"""\n    return 10 ** (dBm / 10.)\n\n\n@jit\ndef calc_distance(x1, y1, x2, y2):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar o calculo da dist\xc3\xa2ncia entre dois pontos no plano cartesiano.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :return: Retorna um valor float representando a dist\xc3\xa2ncia dos pontos informados.\n    """"""\n    return sqrt(pow((x1 - x2), 2.0) + pow((y1 - y2), 2.0))\n\n\n@jit\ndef log_distance(d0, d, gamma):\n    """"""\n    Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n    e do ganho das antenas transmissora e receptora.\n    Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n    :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n    :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n    :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n    :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n    """"""\n    # return path_loss(d) + 10 * gamma * log10(d / d0)\n    return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n\n@jit\ndef tree_par_log(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef propagation_model(x, y, apX, apY, floor_plan):\n    d = calc_distance(x, y, apX, apY)\n\n    loss_in_wall = 0\n\n    loss_in_wall = absorption_in_walls(apX, apY, x, y, floor_plan)\n\n    if d == 0:\n        d = 1\n\n    value = log_distance(1, d, 3) - loss_in_wall\n    # value = tree_par_log(d) - loss_in_wall\n    # value = loss_in_wall\n    # value = tree_par_log(d)\n\n    return value\n\n\n@jit\ndef objective_function(matrix):\n    """"""\n    Fun\xc3\xa7\xc3\xa3o objetivo para a avalia\xc3\xa7\xc3\xa3o da solu\xc3\xa7\xc3\xa3o atual.\n    :param matrix: Matriz a ser avaliada.\n    :return: Retorna a soma de todos os elementos da metriz.\n    """"""\n\n    return abs(np.sum(matrix))\n    ##TODO pra avaliar 2 FO de 2 APs, subtraia as duas matrizes (R[x][y] = abs(A[x][y]-B[x][y])) e pegue a soma de R\n    #return abs(np.mean(matrix))\n\n    # minSensibilidade = dbm_to_mw(-84)\n    # g = 0\n    # for line in matrix:\n    #     for value in line:\n    #         g += -1/value\n    #         # if value < minSensibilidade:\n    #         #     g += -1\n    #         # else:\n    #         #     g += value\n    #\n    # return g\n\n\npropagation_model_gpu = cuda.jit(device=True)(propagation_model)\n\n\n@cuda.jit\ndef simulate_kernel(apX, apY, matrix_results, floor_plan):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por realizar a simula\xc3\xa7\xc3\xa3o do ambiente de acordo com a posi\xc3\xa7\xc3\xa3o do Access Point.\n    :param access_point: Access Point com a sua posi\xc3\xa7\xc3\xa3o.\n    :return: Retorna a matriz NxM contendo o resultado da simula\xc3\xa7\xc3\xa3o de acordo com o modelo de propaga\xc3\xa7\xc3\xa3o.\n    """"""\n\n    startX, startY = cuda.grid(2)\n    gridX = cuda.gridDim.x * cuda.blockDim.x\n    gridY = cuda.gridDim.y * cuda.blockDim.y\n\n    for x in range(startX, WIDTH, gridX):\n        for y in range(startY, HEIGHT, gridY):\n            matrix_results[x][y] = propagation_model_gpu(x, y, apX, apY, floor_plan)\n\n\ndef get_point_in_circle(pointX, pointY, ray, round_values=True, num=1, absolute_values=True):\n    """"""\n    M\xc3\xa9todo por retorna um ponto ou conjunto de pontos dentro de um determinado raio de um ponto.\n    :param point: Ponto contendo posi\xc3\xa7\xc3\xa3o [x, y] de refer\xc3\xaancia do ponto.\n    :param ray: Valor do raio desejado.\n    :param round_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o arredondados. Geralmente ser\xc3\xa1 usando para retornar\n    valores discretos para posi\xc3\xa7\xc3\xb5es da matriz.\n    :param absolute_values: Flag que informa se o(s) ponto(s) ser\xc3\xa3o absolutos (positivos).\n    :param num: N\xc3\xbamero de pontos que deseja gerar. Gera um ponto como default.\n    :param debug: Flag que quando informada True, printa na tela o(s) ponto(s) gerados e a dist\xc3\xa2ncia do ponto de\n    refer\xc3\xaancia.\n    :return: Um ponto ou um conjunto de pontos do tipo float.\n    """"""\n\n    t = np.random.uniform(0.0, 2.0 * np.pi, num)\n    r = ray * np.sqrt(np.random.uniform(0.0, 1.0, num))\n\n    x = r * np.cos(t) + pointX\n    y = r * np.sin(t) + pointY\n\n    # Converte todos os valores negativos da lista em positivos\n    if absolute_values:\n        x = [abs(k) for k in x]\n        y = [abs(k) for k in y]\n\n    if round_values:\n        x = [round(k) for k in x]\n        y = [round(k) for k in y]\n\n    # Verifica se o retorno ser\xc3\xa1 um ponto \xc3\xbanico ou uma lista de pontos.\n    if num == 1:\n        return [x[0], y[0]]\n    else:\n        return [x, y]\n\n\n@jit\ndef perturb(SX, SY):\n    """"""\n     Fun\xc3\xa7\xc3\xa3o que realiza uma perturba\xc3\xa7\xc3\xa3o na Solu\xc3\xa7\xc3\xa3o S.\n     Solu\xc3\xa7\xc3\xa3o pode ser perturbada em um raio \'r\' dentro do espa\xc3\xa7o de simula\xc3\xa7\xc3\xa3o.\n    :param S: Ponto atual.\n    :return: Retorna um ponto dentro do raio informado.\n    """"""\n    # Obtem um ponto aleatorio em um raio de X metros\n    return get_point_in_circle(SX, SY, WIDTH * 0.01)\n\n\n@jit\ndef f(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float64)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return objective_function(g_matrix)\n\n\ndef simulated_annealing(x0, y0, M, P, L, T0, alpha):\n    """"""\n    :param T0: Temperatura inicial.\n    :param S0: Configura\xc3\xa7\xc3\xa3o Inicial (Entrada) -> Ponto?.\n    :param M: N\xc3\xbamero m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es (Entrada).\n    :param P: N\xc3\xbamero m\xc3\xa1ximo de Perturba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param L: N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o (Entrada).\n    :param alpha: Factor de redu\xc3\xa7\xc3\xa3o da temperatura (Entrada).\n    :return: Retorna um ponto sendo o mais indicado.\n    """"""\n    S = [x0, y0]\n    T = T0\n    j = 1\n\n    fS = f(S[0], S[1])\n\n    # Loop principal \xe2\x80\x93 Verifica se foram atendidas as condi\xc3\xa7\xc3\xb5es de termino do algoritmo\n    while True:\n        i = 1\n        nSucesso = 0\n\n        # Loop Interno \xe2\x80\x93 Realiza\xc3\xa7\xc3\xa3o de perturba\xc3\xa7\xc3\xa3o em uma itera\xc3\xa7\xc3\xa3o\n        while True:\n\n            # Tera que mandar o ponto atual e a matriz (certeza?) tbm. Realiza a sele\xc3\xa7\xc3\xa3o do ponto.\n            Si = perturb(S[0], S[1])\n            fSi = f(Si[0], Si[1])\n\n            # show_solution(Si)\n            # print(""[\\t"" + (str(round((100 - 100 * fSi / fS) * 100, 1))) + ""\\t] S: "" + str(S) + ""\\t Si: "" + str(Si))\n\n            # Verificar se o retorno da fun\xc3\xa7\xc3\xa3o objetivo est\xc3\xa1 correto. f(x) \xc3\xa9 a fun\xc3\xa7\xc3\xa3o objetivo\n            deltaFi = fSi - fS\n\n            # print(""deltaFi: "" + str(deltaFi))\n\n            ## Minimiza\xc3\xa7\xc3\xa3o: deltaFi >= 0\n            ## Maximiza\xc3\xa7\xc3\xa3o: deltaFi <= 0\n            # Teste de aceita\xc3\xa7\xc3\xa3o de uma nova solu\xc3\xa7\xc3\xa3o\n            if (deltaFi <= 0) or (exp(-deltaFi / T) > random()):  # randomize()):\n                # print(""Ponto escolhido: "" + str(Si))\n                ## LEMBRETE: guardar o ponto anterior, S_prev = S (para ver o caminho do Si pro S_prev)\n                S = Si\n                fS = fSi\n                nSucesso = nSucesso + 1\n\n                # show_solution(S)\n                # print(""melhor S: "" + str(S))\n\n            i = i + 1\n\n            if (nSucesso >= L) or (i > P):\n                break\n\n        # print(""itera\xc3\xa7\xc3\xa3o: "" + str(j))\n        # print(""temperat: "" + str(T) + ""\\n"")\n\n        # Atualiza\xc3\xa7\xc3\xa3o da temperatura (Deicaimento geom\xc3\xa9trico)\n        T = alpha * T\n\n        # Atualiza\xc3\xa7\xc3\xa3o do contador de itera\xc3\xa7\xc3\xb5es\n        j = j + 1\n\n        if (nSucesso == 0) or (j > M):\n            break\n\n    ## saiu do loop principal\n    # show_solution(S)\n    # print(""invocacoes de f(): "" + str(contador_uso_func_objetivo))\n    return S\n\n\ndef hex_to_rgb(hex):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por converter uma cor no formato hexadecial para um RGB.\n    :param hex: Valor em hexadecimal da cor.\n    :return: Tupla representando a cor em formato RGB.\n    """"""\n    hex = str(hex).lstrip(\'#\')\n    return tuple(int(hex[i:i + 2], 16) for i in (0, 2, 4))\n\n\ndef draw_line(x1, y1, x2, y2, color):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar uma linha reta usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o de dois pontos.\n    :param x1: Valor de X no ponto 1.\n    :param y1: Valor de Y no ponto 1.\n    :param x2: Valor de X no ponto 2.\n    :param y2: Valor de Y no ponto 2.\n    :param color: Cor que a linha ir\xc3\xa1 ter.\n    :return: None\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x1, y1), (x2, y2))\n\n\ndef print_pygame(matrix_results, access_point):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar a simula\xc3\xa7\xc3\xa3o usando o PyGame.\n    :param matrix_results: Matriz float contendo os resultados da simula\xc3\xa7\xc3\xa3o.\n    :param access_point: Posi\xc3\xa7\xc3\xa3o (x, y) do ponto de acesso.\n    :return: None.\n    """"""\n    matrix_max_value = matrix_results.max()\n    matrix_min_value = matrix_results.min()\n\n    # print(""Desenhando simula\xc3\xa7\xc3\xa3o com PyGame..."")\n\n    # L\xc3\xaa os valores da matriz que cont\xc3\xaam valores calculados e colore\n    for x in range(WIDTH):\n        for y in range(HEIGHT):\n            color = get_color_of_interval(matrix_min_value, matrix_max_value, matrix_results[x][y])\n            draw_point(color, x, y)\n\n    # Pinta de vermelho a posi\xc3\xa7\xc3\xa3o do Access Point\n    ap = access_point\n    draw_point(RED, ap[0], ap[1])\n\n    # draw_floor_plan(floor_plan)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef draw_point(color, x, y):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por desenhar um ponto usando o PyGame de acordo com a posi\xc3\xa7\xc3\xa3o (x,y).\n    :param color: A cor que ir\xc3\xa1 ser o ponto.\n    :param x: Posi\xc3\xa7\xc3\xa3o do ponto no eixo X.\n    :param y: Posi\xc3\xa7\xc3\xa3o do ponto no eixo Y.\n    :return: None.\n    """"""\n    pygame.draw.line(DISPLAYSURF, color, (x, y), (x, y))\n\n\ndef size_of_floor_plan(floor_plan):\n    xMax = yMax = 0\n\n    for lines in floor_plan:\n        if lines[0] > xMax:\n            xMax = lines[0]\n        if lines[2] > xMax:\n            xMax = lines[2]\n\n        if lines[1] > yMax:\n            yMax = lines[1]\n        if lines[3] > yMax:\n            yMax = lines[3]\n\n    # x1 = matrix(floor_plan).transpose()[0].getA()[0]\n    # y1 = matrix(floor_plan).transpose()[1].getA()[0]\n    # x2 = matrix(floor_plan).transpose()[2].getA()[0]\n    # y2 = matrix(floor_plan).transpose()[3].getA()[0]\n    #\n    # x12 = x1+x2\n    # y12 = y1+y2\n    #\n    # xMin = min(x12)\n    # xMax = max(x12)\n    #\n    # yMin = min(y12)\n    # yMax = max(y12)\n\n    # return [xMax - xMin, yMax - yMin]\n    return [xMax, yMax]\n\n\ndef draw_floor_plan(floor_plan):\n    for line in floor_plan:\n        # draw_line(line[0]*escala, line[1]*escala, line[2]*escala, line[3]*escala, WHITE)\n        draw_line(line[0], line[1], line[2], line[3], WHITE)\n\n    # Atualiza a janela do PyGame para que exiba a imagem\n    pygame.display.update()\n\n\ndef get_percentage_of_range(min, max, x):\n    """"""\n    M\xc3\xa9todo respons\xc3\xa1vel por retornar a porcentagem de acordo com um respectivo intervalo.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 no intervalo de min-max que deseja saber sua respectiva porcentagem.\n    :return: Retorna uma porcentagem que est\xc3\xa1 de acordo com o intervalo min-max.\n    """"""\n    if (max == min):\n        return 100\n\n    ##TODO escala de cor linear, mas poderia ser exponencial (logaritmica)\n    return ((x - min) / (max - min)) * 100\n\n\ndef get_value_in_list(percent, list):\n    """"""\n    M\xc3\xa9todo retorna o valor de uma posi\xc3\xa7\xc3\xa3o de uma lista. A posi\xc3\xa7\xc3\xa3o \xc3\xa9 calculada de acordo a porcentagem.\n    :param percent: Valor float representando a porcentagem.\n    :param list: Lista com n n\xc3\xbameros.\n    :return: Retorna a cor da posi\xc3\xa7\xc3\xa3o calculada.\n    """"""\n    position = (percent / 100) * len(list)\n    if position < 1:\n        position = 1\n    elif position >= len(list):\n        position = len(list)\n    return hex_to_rgb(list[int(position - 1)])\n\n\ndef get_color_of_interval(min, max, x):\n    """"""\n    Este m\xc3\xa9todo retorna uma cor de acordo com o valor que est\xc3\xa1 entre o intervalo min-max. Em outras palavras,\n    este m\xc3\xa9todo transforma um n\xc3\xbamero em uma cor dentro de uma faixa informada.\n    :param min: Valor m\xc3\xadnimo do intervalo.\n    :param max: Valor m\xc3\xa1ximo do intervalo.\n    :param x: Valor que est\xc3\xa1 dentro do intervalo e que deseja saber sua cor.\n    :return: Retorna uma tupla representando um cor no formato RGB.\n    """"""\n    percentage = get_percentage_of_range(min, max, x)\n    color = get_value_in_list(percentage, COLORS)\n    # print(\'Color: \' + str(color))\n    return color\n\n\n@jit\ndef f_plot(pointX, pointY):\n    """"""\n    Valor da fun\xc3\xa7\xc3\xa3o objetivo correspondente \xc3\xa1 configura\xc3\xa7\xc3\xa3o x;\n    :param x: Ponto para realizar a simula\xc3\xa7\xc3\xa3o.\n    :return: Retorna um numero float representando o valor da situa\xc3\xa7\xc3\xa3o atual.\n    """"""\n    g_matrix = np.zeros(shape=(WIDTH, HEIGHT), dtype=np.float64)\n\n    blockDim = (48, 8)\n    gridDim = (32, 16)\n\n    d_matrix = cuda.to_device(g_matrix)\n\n    simulate_kernel[gridDim, blockDim](pointX, pointY, d_matrix, floor_plan)\n\n    d_matrix.to_host()\n\n    return g_matrix\n\n\ndef showSolution(SX, SY):\n    print_pygame(f_plot(SX, SY), [SX, SY])\n    draw_floor_plan(walls)\n\n\n########################################################################################################################\n#   Main                                                                                                               #\n########################################################################################################################\nif __name__ == \'__main__\':\n\n    COLORS = [\n        \'#0C0786\', \'#100787\', \'#130689\', \'#15068A\', \'#18068B\', \'#1B068C\', \'#1D068D\', \'#1F058E\',\n        \'#21058F\', \'#230590\', \'#250591\', \'#270592\', \'#290593\', \'#2B0594\', \'#2D0494\', \'#2F0495\',\n        \'#310496\', \'#330497\', \'#340498\', \'#360498\', \'#380499\', \'#3A049A\', \'#3B039A\', \'#3D039B\',\n        \'#3F039C\', \'#40039C\', \'#42039D\', \'#44039E\', \'#45039E\', \'#47029F\', \'#49029F\', \'#4A02A0\',\n        \'#4C02A1\', \'#4E02A1\', \'#4F02A2\', \'#5101A2\', \'#5201A3\', \'#5401A3\', \'#5601A3\', \'#5701A4\',\n        \'#5901A4\', \'#5A00A5\', \'#5C00A5\', \'#5E00A5\', \'#5F00A6\', \'#6100A6\', \'#6200A6\', \'#6400A7\',\n        \'#6500A7\', \'#6700A7\', \'#6800A7\', \'#6A00A7\', \'#6C00A8\', \'#6D00A8\', \'#6F00A8\', \'#7000A8\',\n        \'#7200A8\', \'#7300A8\', \'#7500A8\', \'#7601A8\', \'#7801A8\', \'#7901A8\', \'#7B02A8\', \'#7C02A7\',\n        \'#7E03A7\', \'#7F03A7\', \'#8104A7\', \'#8204A7\', \'#8405A6\', \'#8506A6\', \'#8607A6\', \'#8807A5\',\n        \'#8908A5\', \'#8B09A4\', \'#8C0AA4\', \'#8E0CA4\', \'#8F0DA3\', \'#900EA3\', \'#920FA2\', \'#9310A1\',\n        \'#9511A1\', \'#9612A0\', \'#9713A0\', \'#99149F\', \'#9A159E\', \'#9B179E\', \'#9D189D\', \'#9E199C\',\n        \'#9F1A9B\', \'#A01B9B\', \'#A21C9A\', \'#A31D99\', \'#A41E98\', \'#A51F97\', \'#A72197\', \'#A82296\',\n        \'#A92395\', \'#AA2494\', \'#AC2593\', \'#AD2692\', \'#AE2791\', \'#AF2890\', \'#B02A8F\', \'#B12B8F\',\n        \'#B22C8E\', \'#B42D8D\', \'#B52E8C\', \'#B62F8B\', \'#B7308A\', \'#B83289\', \'#B93388\', \'#BA3487\',\n        \'#BB3586\', \'#BC3685\', \'#BD3784\', \'#BE3883\', \'#BF3982\', \'#C03B81\', \'#C13C80\', \'#C23D80\',\n        \'#C33E7F\', \'#C43F7E\', \'#C5407D\', \'#C6417C\', \'#C7427B\', \'#C8447A\', \'#C94579\', \'#CA4678\',\n        \'#CB4777\', \'#CC4876\', \'#CD4975\', \'#CE4A75\', \'#CF4B74\', \'#D04D73\', \'#D14E72\', \'#D14F71\',\n        \'#D25070\', \'#D3516F\', \'#D4526E\', \'#D5536D\', \'#D6556D\', \'#D7566C\', \'#D7576B\', \'#D8586A\',\n        \'#D95969\', \'#DA5A68\', \'#DB5B67\', \'#DC5D66\', \'#DC5E66\', \'#DD5F65\', \'#DE6064\', \'#DF6163\',\n        \'#DF6262\', \'#E06461\', \'#E16560\', \'#E26660\', \'#E3675F\', \'#E3685E\', \'#E46A5D\', \'#E56B5C\',\n        \'#E56C5B\', \'#E66D5A\', \'#E76E5A\', \'#E87059\', \'#E87158\', \'#E97257\', \'#EA7356\', \'#EA7455\',\n        \'#EB7654\', \'#EC7754\', \'#EC7853\', \'#ED7952\', \'#ED7B51\', \'#EE7C50\', \'#EF7D4F\', \'#EF7E4E\',\n        \'#F0804D\', \'#F0814D\', \'#F1824C\', \'#F2844B\', \'#F2854A\', \'#F38649\', \'#F38748\', \'#F48947\',\n        \'#F48A47\', \'#F58B46\', \'#F58D45\', \'#F68E44\', \'#F68F43\', \'#F69142\', \'#F79241\', \'#F79341\',\n        \'#F89540\', \'#F8963F\', \'#F8983E\', \'#F9993D\', \'#F99A3C\', \'#FA9C3B\', \'#FA9D3A\', \'#FA9F3A\',\n        \'#FAA039\', \'#FBA238\', \'#FBA337\', \'#FBA436\', \'#FCA635\', \'#FCA735\', \'#FCA934\', \'#FCAA33\',\n        \'#FCAC32\', \'#FCAD31\', \'#FDAF31\', \'#FDB030\', \'#FDB22F\', \'#FDB32E\', \'#FDB52D\', \'#FDB62D\',\n        \'#FDB82C\', \'#FDB92B\', \'#FDBB2B\', \'#FDBC2A\', \'#FDBE29\', \'#FDC029\', \'#FDC128\', \'#FDC328\',\n        \'#FDC427\', \'#FDC626\', \'#FCC726\', \'#FCC926\', \'#FCCB25\', \'#FCCC25\', \'#FCCE25\', \'#FBD024\',\n        \'#FBD124\', \'#FBD324\', \'#FAD524\', \'#FAD624\', \'#FAD824\', \'#F9D924\', \'#F9DB24\', \'#F8DD24\',\n        \'#F8DF24\', \'#F7E024\', \'#F7E225\', \'#F6E425\', \'#F6E525\', \'#F5E726\', \'#F5E926\', \'#F4EA26\',\n        \'#F3EC26\', \'#F3EE26\', \'#F2F026\', \'#F2F126\', \'#F1F326\', \'#F0F525\', \'#F0F623\', \'#EFF821\'\n    ]\n\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    RED = (255, 0, 0)\n    GREEN = (0, 255, 0)\n    BLUE = (0, 0, 255)\n\n    # tamanho da matriz = dimens\xc3\xa3o da planta / precis\xc3\xa3o\n\n    escala = 1\n    # walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-A-l.dxf"")\n    walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-porta.dxf"")\n    floor_plan = np.array(walls, dtype=np.float64)\n\n    floor_size = size_of_floor_plan(walls)\n    comprimento_planta = floor_size[0]\n    largura_planta = floor_size[1]\n    ## carreguei a planta so para obter a proporcao\n    proporcao_planta = comprimento_planta / largura_planta\n\n    # HEIGHT = int(largura_planta)\n    # WIDTH = int(comprimento_planta)\n    HEIGHT = 600\n    WIDTH = int(HEIGHT * proporcao_planta)\n\n    escala = HEIGHT / largura_planta\n    # escala = WIDTH / comprimento_planta\n    # precisao = 1  # metro\n\n    #walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-sem-porta.dxf"")\n    walls = read_walls_from_dxf(""/home/samuel/PycharmProjects/TCC/DXFs/bloco-a-linhas-porta.dxf"")\n    floor_plan = np.array(walls, dtype=np.float64)\n\n    initial_point = [rd.randrange(0, WIDTH), rd.randrange(0, HEIGHT)]\n\n    ## fixo, procurar uma f\xc3\xb3rmula para definir o max_iter em fun\xc3\xa7\xc3\xa3o do tamanho da matriz (W*H)\n    max_inter = 600\n\n    ## p\n    max_pertub = 5\n\n    ## v\n    num_max_succ = 80\n\n    ## a\n    alpha = .85\n\n    ## t\n    temp_inicial = 300\n\n    ## m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es do S.A.\n    max_SA = 1\n\n    print(""\\nIniciando simula\xc3\xa7\xc3\xa3o com simulated Annealing com a seguinte configura\xc3\xa7\xc3\xa3o:"")\n    print(""Ponto inicial:\\t\\t\\t\\t\\t"" + str([initial_point[0], initial_point[1]]))\n    print(""N\xc3\xbameto m\xc3\xa1ximo de itera\xc3\xa7\xc3\xb5es:\\t\\t\\t"" + str(max_inter))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de pertuba\xc3\xa7\xc3\xb5es por itera\xc3\xa7\xc3\xa3o:\\t"" + str(max_pertub))\n    print(""N\xc3\xbamero m\xc3\xa1ximo de sucessos por itera\xc3\xa7\xc3\xa3o:\\t\\t"" + str(num_max_succ))\n    print(""Temperatura inicial:\\t\\t\\t\\t"" + str(temp_inicial))\n    print(""Decaimento da teperatura com \xce\xb1=\\t\\t\\t"" + str(alpha))\n    print(""Repeti\xc3\xa7\xc3\xb5es do Simulated Annealing:\\t\\t"" + str(max_SA))\n\n\n    bests = []\n\n    for i in range(max_SA):\n        print(""Calculando o melhor ponto ["" + str(i) + ""]"")\n        bests.append(\n            simulated_annealing(initial_point[0], initial_point[1], max_inter, max_pertub, num_max_succ, temp_inicial,\n                                alpha))\n\n    # Media das colunas, m\xc3\xa9dia dos melhores pontos\n    # best_mean = np.mean(bests, axis=0)\n    maxFO = 0\n    bestAP = [-1, -1]\n    for ap in bests:\n        ap_fo = objective_function(f_plot(ap[0], ap[1]))\n        if ap_fo > maxFO:\n            maxFO = ap_fo\n            bestAP = ap\n\n    # Inicia o PyGame\n    pygame.init()\n\n    # Configura o tamanho da janela\n    DISPLAYSURF = pygame.display.set_mode((WIDTH, HEIGHT), 0, 32)\n\n    showSolution(bestAP[0], bestAP[1])\n    # show_solution(1, 1)\n\n    print(""Melhor ponto sugerido pelo algoritmo: "" + str(bestAP))\n    input(\'FIM\')\n'"
debugs/teste_reduce.py,2,"b'#!/usr/bin/python\n# -*- coding: latin1 -*-\n\n\nmatrix = np.ones(shape=(5, 5))\nsum_reduce = cuda.reduce(lambda a, b: a + b)\nsoma_mw = sum_reduce(np.array([10**(x/10.) for line in matrix for x in line]))\n\nprint(soma_mw)'"
debugs/time.py,0,"b'###############################################\n## calculando a qtde de nros pares de 1 a 1001\nimport timeit\n\ncmd = \'calculando a qtde de nros pares de 1 a 1001\'\nprint(cmd)\n\ncmd = """""" \nsum([~x%2 for x in range(1,1001)])\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nsum([f() for...): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \ncount = 0\nfor x in range(1,1001): \n        count += ~x%2\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nfor...count+=f()): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \nlen(filter(lambda x: ~x%2, range(1,1001)) )\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nlen(filter(f())): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \nsum(filter(lambda x: ~x%2, range(1,1001)) )\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nsum(filter(f())): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \nsum(map(lambda x: ~x%2, range(1,1001)) )\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nsum(map(f())): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \nreduce(lambda x,y: x+y, filter(lambda x: ~x%2, range(1,1001)) )\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nreduce(filter(f())): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n\ncmd = """""" \nreduce(lambda x,y: x+y, map(lambda x: ~x%2, range(1,1001)) )\n""""""\nt1 = timeit.timeit(cmd, number=1000)\nprint(\'\\nreduce(map(f())): \\n\' + str(round(t1, 4) * 1000) + "" ms"")\n'"
debugs/two_linear_ranger.py,3,"b'""""""\nDemonstration of using norm to map colormaps onto data in non-linear ways.\n""""""\n\nimport matplotlib.colors as colors\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.mlab import bivariate_normal\n\nN = 100\n\'\'\'\nCustom Norm: An example with a customized normalization.  This one\nuses the example above, and normalizes the negative data differently\nfrom the positive.\n\'\'\'\nX, Y = np.mgrid[-3:3:complex(0, N), -2:2:complex(0, N)]\nZ1 = (bivariate_normal(X, Y, 1., 1., 1.0, 1.0)) ** 2 \\\n     - 0.4 * (bivariate_normal(X, Y, 1.0, 1.0, -1.0, 0.0)) ** 2\nZ1 = Z1 / 0.03\n\n\n# Example of making your own norm.  Also see matplotlib.colors.\n# From Joe Kington: This one gives two different linear ramps:\n\n\nclass MidpointNormalize(colors.Normalize):\n    def __init__(self, vmin=None, vmax=None, midpoint=None, clip=False):\n        self.midpoint = midpoint\n        colors.Normalize.__init__(self, vmin, vmax, clip)\n\n    def __call__(self, value, clip=None):\n        # I\'m ignoring masked values and all kinds of edge cases to make a\n        # simple example...\n        x, y = [self.vmin, self.midpoint, self.vmax], [0, 0.5, 1]\n        return np.ma.masked_array(np.interp(value, x, y))\n\n\n#####\nfig, ax = plt.subplots(2, 1)\n\npcm = ax[0].pcolormesh(X, Y, Z1,\n                       norm=MidpointNormalize(midpoint=0.),\n                       cmap=\'RdBu_r\')\nfig.colorbar(pcm, ax=ax[0], extend=\'both\')\n\npcm = ax[1].pcolormesh(X, Y, Z1, cmap=\'RdBu_r\', vmin=-np.max(Z1))\nfig.colorbar(pcm, ax=ax[1], extend=\'both\')\nfig.show()\ninput(\'\')\n'"
images/__init__.py,0,b''
utils/__init__.py,0,b''
utils/propagations_models.py,0,"b'import math\nfrom math import log10\nfrom numba import jit\n\n\n@jit\ndef log_distance_model(d, gamma=3, d0=1, Pr_d0=-60, Pt=-17):\n    """"""\n       Modelo logaritmo de perda baseado em resultados experimentais. Independe da frequ\xc3\xaancia do sinal transmitido\n       e do ganho das antenas transmissora e receptora.\n       Livro Comunica\xc3\xa7\xc3\xb5es em Fio - Pricipios e Pr\xc3\xa1ticas - Rappaport (p\xc3\xa1ginas 91-92).\n       :param Pr_d0:\n       :param Pt:\n       :param d0: Dist\xc3\xa2ncia do ponto de refer\xc3\xaancia d0.\n       :param d: Dist\xc3\xa2ncia que desejo calcular a perda do sinal.\n       :param gamma: Valor da constante de propaga\xc3\xa7\xc3\xa3o que difere para cada tipo de ambiente.\n       :return: Retorna um float representando a perda do sinal entre a dist\xc3\xa2ncia d0 e d.\n       """"""\n\n    # path_loss(d0) + 10 * gamma * log10(d / d0)\n    # HAVIAMOS CODIFICADO ASSIM PARA ECONOMIZAR 1 SUBTRACAO e 1 VAR\n    # return 17 - (60 + 10 * gamma * log10(d / d0))  # igual est\xc3\xa1 na tabela\n\n    # REESCREVI FACILITAR A COMPREENSAO\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    # return 0 - (PL + 10 * gamma * log10(d / d0) )\n    # return   - (PL + 10 * gamma * log10(d / d0) )\n    # return   -PL   - 10 * gamma * log10(d / d0)\n    # return   -(Pt-Pr0)   - (10 * gamma * log10(d / d0))\n    # return   -Pt + Pr0   - (10 * gamma * log10(d / d0))\n    # return   Pr0  - 10 * gamma * log10(d / d0) - Pt\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef log_distance_v2_model(d, gamma=3, d0=10, Pr_d0=-69, Pt=-20):\n    # return   -( PL + 10 * gamma * log10(d / d0) )\n    return (Pr_d0 - 10 * gamma * log10(d / d0)) - Pt\n\n\n@jit\ndef tree_par_log_model(x):\n    return -17.74321 - 15.11596 * math.log(x + 2.1642)\n\n\n@jit\ndef two_par_logistic_model(pt_dbm, x):\n    # https://en.wikipedia.org/wiki/Logistic_distribution#Related_distributions\n    return pt_dbm - (-15.11596 * math.log10(x * 2.1642))\n\n\n@jit\ndef four_par_log_model(pt_dbm, x):\n    A = 79.500\n    B = -38\n    C = -100.000\n    D = 0.0\n    E = 0.005\n\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return pt_dbm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n\n\n@jit\ndef five_par_log_model(pt_dbm, x):\n    A = 84.0\n    B = -48\n    C = -121.0\n    D = -5.0\n    E = 0.005\n    # https://en.wikipedia.org/wiki/Shifted_log-logistic_distribution\n    return pt_dbm - (D + (A - D) / (pow((1 + pow((x / C), B)), E)))\n'"
