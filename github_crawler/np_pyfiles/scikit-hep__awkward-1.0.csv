file_path,api_count,code
src/awkward1/__init__.py,1,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport distutils.version\n\n# NumPy 1.13.1 introduced NEP13, without which Awkward ufuncs won\'t work, which\n# would be worse than lacking a feature: it would cause unexpected output.\n# NumPy 1.17.0 introduced NEP18, which is optional (use ak.* instead of np.*).\nimport numpy\n\nif distutils.version.LooseVersion(numpy.__version__) < distutils.version.LooseVersion(\n    ""1.13.1""\n):\n    raise ImportError(""Numpy 1.13.1 or later required"")\n\n# shims for C++ (now everything is compiled into one \'awkward1._ext\' module)\nimport awkward1.layout\nimport awkward1.types\nimport awkward1.forms\nimport awkward1.partition\n\n# third-party connectors\nimport awkward1._connect._numba\n\nnumba = type(awkward1._connect._numba)(""numba"")\nnumba.register = awkward1._connect._numba.register\n\nimport awkward1._connect._pandas\n\npandas = type(awkward1._connect._pandas)(""pandas"")\npandas.register = awkward1._connect._pandas.register\npandas.df = awkward1._connect._pandas.df\npandas.dfs = awkward1._connect._pandas.dfs\n\nimport awkward1._connect._numexpr\n\nnumexpr = type(awkward1._connect._numexpr)(""numexpr"")\nnumexpr.evaluate = awkward1._connect._numexpr.evaluate\nnumexpr.re_evaluate = awkward1._connect._numexpr.re_evaluate\n\nimport awkward1._connect._autograd\n\nautograd = type(awkward1._connect._autograd)(""autograd"")\nautograd.elementwise_grad = awkward1._connect._autograd.elementwise_grad\n\n# high-level interface\nbehavior = {}\nfrom awkward1.highlevel import Array\nfrom awkward1.highlevel import Record\nfrom awkward1.highlevel import ArrayBuilder\n\n# behaviors\nimport awkward1.behaviors.string\n\n# operations\nfrom awkward1.operations.convert import *\nfrom awkward1.operations.describe import *\nfrom awkward1.operations.structure import *\nfrom awkward1.operations.reducers import *\n\n# version\n__version__ = awkward1._ext.__version__\n\n__all__ = [\n    x\n    for x in list(globals())\n    if not x.startswith(""_"") and x not in (""distutils"", ""numpy"")\n]\n'"
src/awkward1/highlevel.py,19,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport re\nimport keyword\n\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward1._connect._numpy\nimport awkward1._connect._pandas\nimport awkward1.layout\nimport awkward1.operations.convert\nimport awkward1.operations.structure\n\n_dir_pattern = re.compile(r""^[a-zA-Z_]\\w*$"")\n\n\nclass Array(\n    awkward1._connect._numpy.NDArrayOperatorsMixin,\n    awkward1._connect._pandas.PandasMixin,\n):\n    """"""\n    Args:\n        data (#ak.layout.Content, #ak.Array, np.ndarray, str, or iterable):\n            Data to wrap or convert into an array.\n            If a NumPy array, the regularity of its dimensions is preserved\n            and the data are viewed, not copied.\n            If a string, the data are assumed to be JSON.\n            If an iterable, calls #ak.from_iter, which assumes all dimensions\n            have irregular lengths.\n        behavior (None or dict): Custom #ak.behavior for this Array only.\n        with_name (None or str): Gives tuples and records a name that can be\n            used to override their behavior (see below).\n        check_valid (bool): If True, verify that the #layout is valid.\n\n    High-level array that can contain data of any type.\n\n    For most users, this is the only class in Awkward Array that matters: it\n    is the entry point for data analysis with an emphasis on usability. It\n    intentionally has a minimum of methods, preferring standalone functions\n    like\n\n        ak.num(array1)\n        ak.combinations(array1)\n        ak.cartesian([array1, array2])\n        ak.zip({""x"": array1, ""y"": array2, ""z"": array3})\n\n    instead of bound methods like\n\n        array1.num()\n        array1.combinations()\n        array1.cartesian([array2, array3])\n        array1.zip(...)   # ?\n\n    because its namespace is valuable for domain-specific parameters and\n    functionality. For example, if records contain a field named `""num""`,\n    they can be accessed as\n\n        array1.num\n\n    instead of\n\n        array1[""num""]\n\n    without any confusion or interference from #ak.num. The same is true\n    for domain-specific methods that have been attached to the data. For\n    instance, an analysis of mailing addresses might have a function that\n    computes zip codes, which can be attached to the data with a method\n    like\n\n        latlon.zip()\n\n    without any confusion or interference from #ak.zip. Custom methods like\n    this can be added with #ak.behavior, and so the namespace of Array\n    attributes must be kept clear for such applications.\n\n    See also #ak.Record.\n\n    Interfaces to other libraries\n    =============================\n\n    NumPy\n    *****\n\n    When NumPy\n    [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)\n    (ufuncs) are applied to an ak.Array, they are passed through the Awkward\n    data structure, applied to the numerical data at its leaves, and the output\n    maintains the original structure.\n\n    For example,\n\n        >>> array = ak.Array([[1, 4, 9], [], [16, 25]])\n        >>> np.sqrt(array)\n        <Array [[1, 2, 3], [], [4, 5]] type=\'3 * var * float64\'>\n\n    See also #ak.Array.__array_ufunc__.\n\n    Some NumPy functions other than ufuncs are also handled properly in\n    NumPy >= 1.17 (see\n    [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html))\n    and if an Awkward override exists. That is,\n\n        np.concatenate\n\n    can be used on an Awkward Array because\n\n        ak.concatenate\n\n    exists. If your NumPy is older than 1.17, use `ak.concatenate` directly.\n\n    Pandas\n    ******\n\n    ak.Arrays can be used as [Pandas](https://pandas.pydata.org/) DataFrame\n    columns and Series, in place of NumPy arrays. Their data structures are not\n    copied or converted into Python objects (not even NumPy\'s `""O""` dtype), so\n    this is the most efficient way to fill DataFrames with arbitrary data\n    structures.\n\n    As a consequence, however, ak.Array must include the following methods in\n    its namespace (other than names with underscores):\n\n       * `columns`: Property like #ak.keys, except that the list cannot be\n         empty (a special placeholder is used instead).\n       * `dtype`: Property with the same value as\n         #ak._connect._pandas.get_dtype. It provides no information about\n         the type of data in the array.\n       * `ndim`: Property whose value is `1`, which does not reflect the\n         structure of the data in the array.\n       * `shape`: Property whose value is a single-item tuple containing\n         the length of the array (#ak.Array.__len__). It does not reflect\n         the structure of the data in the array.\n       * `isna()`: Method whose value is equal to #ak.is_none, implementing\n         [pd.Series.isna](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.isna.html)\n       * `take(indices, allow_fill=None, fill_value=None)`: method implementing\n         [pd.Series.take](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.take.html)\n         for the ak.Array.\n       * `copy()`: Method implementing\n         [pd.Series.copy](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.copy.html),\n         which completely copies the array (all nodes, all buffers).\n\n    It\'s also possible to convert Awkward data structures into Pandas\n    [MultiIndex](https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html)\n    rows and columns. In this case, the data in Pandas are not Awkward Arrays.\n\n    See #ak.pandas.df to convert an ak.Array into one Pandas DataFrame (lossy).\n\n    See #ak.pandas.dfs to convert an ak.Array into as many DataFrames as are\n    needed to preserve its list structure.\n\n    Numba\n    *****\n\n    Arrays can be used in [Numba](http://numba.pydata.org/): they can be\n    passed as arguments to a Numba-compiled function or returned as return\n    values. The only limitation is that Awkward Arrays cannot be *created*\n    inside the Numba-compiled function; to make outputs, consider\n    #ak.ArrayBuilder.\n\n    Arrow\n    *****\n\n    Arrays are convertible to and from [Apache Arrow](https://arrow.apache.org/),\n    a standard for representing nested data structures in columnar arrays.\n    See #ak.to_arrow and #ak.from_arrow.\n\n    NumExpr\n    *******\n\n    [NumExpr](https://numexpr.readthedocs.io/en/latest/user_guide.html) can\n    calculate expressions on a set of ak.Arrays, but only if the functions in\n    `ak.numexpr` are used, not the functions in the `numexpr` library directly.\n\n    Like NumPy ufuncs, the expression is evaluated on the numeric leaves of the\n    data structure, maintaining structure in the output.\n\n    See #ak.numexpr.evaluate to calculate an expression.\n\n    See #ak.numexpr.re_evaluate to recalculate an expression without\n    rebuilding its virtual machine.\n\n    Autograd\n    ********\n\n    Derivatives of a calculation on a set of ak.Arrays can be calculated with\n    [Autograd](https://github.com/HIPS/autograd#readme), but only if the\n    function in `ak.autograd` is used, not the functions in the `autograd`\n    library directly.\n\n    Like NumPy ufuncs, the function and its derivatives are evaluated on the\n    numeric leaves of the data structure, maintaining structure in the output.\n\n    See #ak.autograd.elementwise_grad to calculate a function and its\n    derivatives elementwise on each numeric value in an ak.Array.\n    """"""\n\n    def __init__(self, data, behavior=None, with_name=None, check_valid=False):\n        if isinstance(\n            data, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n        ):\n            layout = data\n        elif isinstance(data, Array):\n            layout = data.layout\n        elif isinstance(data, numpy.ndarray):\n            layout = awkward1.operations.convert.from_numpy(data, highlevel=False)\n        elif isinstance(data, str):\n            layout = awkward1.operations.convert.from_json(data, highlevel=False)\n        elif isinstance(data, dict):\n            raise TypeError(\n                ""could not convert dict into an awkward1.Array; "" ""try awkward1.Record""\n            )\n        else:\n            layout = awkward1.operations.convert.from_iter(\n                data, highlevel=False, allow_record=False\n            )\n        if not isinstance(\n            layout, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n        ):\n            raise TypeError(""could not convert data into an awkward1.Array"")\n\n        if with_name is not None:\n            layout = awkward1.operations.structure.with_name(\n                layout, with_name, highlevel=False\n            )\n        if self.__class__ is Array:\n            self.__class__ = awkward1._util.arrayclass(layout, behavior)\n\n        self.layout = layout\n        self.behavior = behavior\n        if check_valid:\n            awkward1.operations.describe.validity_error(self, exception=True)\n\n    @property\n    def layout(self):\n        """"""\n        The composable #ak.layout.Content elements that determine how this\n        Array is structured.\n\n        This may be considered a ""low-level"" view, as it distinguishes between\n        arrays that have the same logical meaning (i.e. same JSON output and\n        high-level #type) but different\n\n           * node types, such as #ak.layout.ListArray64 and\n             #ak.layout.ListOffsetArray64,\n           * integer type specialization, such as #ak.layout.ListArray64\n             and #ak.layout.ListArray32,\n           * or specific values, such as gaps in a #ak.layout.ListArray64.\n\n        The #ak.layout.Content elements are fully composable, whereas an\n        Array is not; the high-level Array is a single-layer ""shell"" around\n        its layout.\n\n        Layouts are rendered as XML instead of a nested list. For example,\n        the following `array`\n\n            ak.Array([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n\n        is presented as\n\n            <Array [[1.1, 2.2, 3.3], [], [4.4, 5.5]] type=\'3 * var * float64\'>\n\n        but `array.layout` is presented as\n\n            <ListOffsetArray64>\n                <offsets>\n                    <Index64 i=""[0 3 3 5]"" offset=""0"" length=""4"" at=""0x55a26df62590""/>\n                </offsets>\n                <content>\n                    <NumpyArray format=""d"" shape=""5"" data=""1.1 2.2 3.3 4.4 5.5"" at=""0x55a26e0c5f50""/>\n                </content>\n            </ListOffsetArray64>\n\n        (with truncation for large arrays).\n        """"""\n        return self._layout\n\n    @layout.setter\n    def layout(self, layout):\n        if isinstance(\n            layout, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n        ):\n            self._layout = layout\n            self._numbaview = None\n        else:\n            raise TypeError(""layout must be a subclass of awkward1.layout.Content"")\n\n    @property\n    def behavior(self):\n        """"""\n        The `behavior` parameter passed into this Array\'s constructor.\n\n           * If a dict, this `behavior` overrides the global #ak.behavior.\n             Any keys in the global #ak.behavior but not this `behavior` are\n             still valid, but any keys in both are overridden by this\n             `behavior`. Keys with a None value are equivalent to missing keys,\n             so this `behavior` can effectively remove keys from the\n             global #ak.behavior.\n\n           * If None, the Array defaults to the global #ak.behavior.\n\n        See #ak.behavior for a list of recognized key patterns and their\n        meanings.\n        """"""\n        return self._behavior\n\n    @behavior.setter\n    def behavior(self, behavior):\n        if behavior is None or isinstance(behavior, dict):\n            self._behavior = behavior\n        else:\n            raise TypeError(""behavior must be None or a dict"")\n\n    class Mask(object):\n        def __init__(self, array, valid_when):\n            self._array = array\n            self._valid_when = valid_when\n\n        def __str__(self, limit_value=85):\n            return self._array.__str__(limit_value=limit_value)\n\n        def __repr__(self, limit_value=40, limit_total=85):\n            import awkward1.operations.structure\n\n            layout = awkward1.operations.structure.with_cache(\n                self._layout, {}, chain=""last"", highlevel=False\n            )\n            value = awkward1._util.minimally_touching_string(\n                limit_value, layout, self._behavior\n            )\n\n            try:\n                name = super(Array, self._array).__getattribute__(""__name__"")\n            except AttributeError:\n                name = type(self._array).__name__\n            limit_type = limit_total - (len(value) + len(name) + len(""<.mask  type=>""))\n            typestr = repr(\n                str(awkward1._util.highlevel_type(layout, self._array._behavior, True))\n            )\n            if len(typestr) > limit_type:\n                typestr = typestr[: (limit_type - 4)] + ""..."" + typestr[-1]\n\n            return ""<{0}.mask {1} type={2}>"".format(name, value, typestr)\n\n        def __getitem__(self, where):\n            return awkward1.operations.structure.mask(\n                self._array, where, self._valid_when\n            )\n\n    @property\n    def mask(self, valid_when=True):\n        """"""\n        Whereas\n\n            array[array_of_booleans]\n\n        removes elements from `array` in which `array_of_booleans` is False,\n\n            array.mask[array_of_booleans]\n\n        returns data with the same length as the original `array` but False\n        values in `array_of_booleans` are mapped to None. Such an output\n        can be used in mathematical expressions with the original `array`\n        because they are still aligned.\n\n        See <<filtering>> and #ak.mask.\n        """"""\n        return self.Mask(self, valid_when)\n\n    def tolist(self):\n        """"""\n        Converts this Array into Python objects; same as #ak.to_list\n        (but without the underscore, like NumPy\'s\n        [tolist](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.tolist.html)).\n\n        Awkward Array types have the following Pythonic translations.\n\n           * #ak.types.PrimitiveType: converted into bool, int, float.\n           * #ak.types.OptionType: missing values are converted into None.\n           * #ak.types.ListType: converted into list.\n           * #ak.types.RegularType: also converted into list. Python (and JSON)\n             forms lose information about the regularity of list lengths.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__bytestring__""`: converted into bytes.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__string__""`: converted into str.\n           * #ak.types.RecordArray without field names: converted into tuple.\n           * #ak.types.RecordArray with field names: converted into dict.\n           * #ak.types.UnionArray: Python data are naturally heterogeneous.\n\n        See also #ak.to_list and #ak.from_iter.\n        """"""\n        return awkward1.operations.convert.to_list(self)\n\n    def tojson(\n        self, destination=None, pretty=False, maxdecimals=None, buffersize=65536\n    ):\n        """"""\n        Args:\n            destination (None or str): If None, this method returns a JSON str;\n                if a str, it uses that as a file name and writes (overwrites)\n                that file (returning None).\n            pretty (bool): If True, indent the output for human readability; if\n                False, output compact JSON without spaces.\n            maxdecimals (None or int): If an int, limit the number of\n                floating-point decimals to this number; if None, write all\n                digits.\n            buffersize (int): Size (in bytes) of the buffer used by the JSON\n                parser.\n\n        Converts this Array into a JSON string or file; same as #ak.to_json\n        (but without the underscore, like #ak.Array.tolist).\n\n        Awkward Array types have the following JSON translations.\n\n           * #ak.types.PrimitiveType: converted into JSON booleans and numbers.\n           * #ak.types.OptionType: missing values are converted into None.\n           * #ak.types.ListType: converted into JSON lists.\n           * #ak.types.RegularType: also converted into JSON lists. JSON (and\n             Python) forms lose information about the regularity of list\n             lengths.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__bytestring__""` or `""__string__""`: converted into JSON strings.\n           * #ak.types.RecordArray without field names: converted into JSON\n             objects with numbers as strings for keys.\n           * #ak.types.RecordArray with field names: converted into JSON\n             objects.\n           * #ak.types.UnionArray: JSON data are naturally heterogeneous.\n\n        See also #ak.to_json and #ak.from_json.\n        """"""\n        return awkward1.operations.convert.to_json(\n            self, destination, pretty, maxdecimals, buffersize\n        )\n\n    @property\n    def nbytes(self):\n        """"""\n        The total number of bytes in all the #ak.layout.Index,\n        #ak.layout.Identities, and #ak.layout.NumpyArray buffers in this\n        array tree.\n\n        Note: this calculation takes overlapping buffers into account, to the\n        extent that overlaps are not double-counted, but overlaps are currently\n        assumed to be complete subsets of one another, and so it is\n        theoretically possible (though unlikely) that this number is an\n        underestimate of the true usage.\n\n        It also does not count buffers that must be kept in memory because\n        of ownership, but are not directly used in the array. Nor does it count\n        the (small) C++ nodes or Python objects that reference the (large)\n        array buffers.\n        """"""\n        return self._layout.nbytes\n\n    def __len__(self):\n        """"""\n        The length of this Array, only counting the outermost structure.\n\n        For example, the length of\n\n            ak.Array([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n\n        is `3`, not `5`.\n        """"""\n        return len(self._layout)\n\n    def __iter__(self):\n        """"""\n        Iterates over this Array in Python.\n\n        Note that this is the *slowest* way to access data (even slower than\n        native Python objects, like lists and dicts). Usually, you should\n        express your problems in array-at-a-time operations.\n\n        In other words, do this:\n\n            >>> print(np.sqrt(ak.Array([[1.1, 2.2, 3.3], [], [4.4, 5.5]])))\n            [[1.05, 1.48, 1.82], [], [2.1, 2.35]]\n\n        not this:\n\n            >>> for outer in ak.Array([[1.1, 2.2, 3.3], [], [4.4, 5.5]]):\n            ...     for inner in outer:\n            ...         print(np.sqrt(inner))\n            ...\n            1.0488088481701516\n            1.4832396974191326\n            1.816590212458495\n            2.0976176963403033\n            2.345207879911715\n\n        Iteration over Arrays exists so that they can be more easily inspected\n        as Python objects.\n\n        See also #ak.to_list.\n        """"""\n        for x in self._layout:\n            yield awkward1._util.wrap(x, self._behavior)\n\n    def __getitem__(self, where):\n        """"""\n        Args:\n            where (many types supported; see below): Index of positions to\n                select from this Array.\n\n        Select items from the Array using an extension of NumPy\'s (already\n        quite extensive) rules.\n\n        All methods of selecting items described in\n        [NumPy indexing](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html)\n        are supported with one exception\n        ([combining advanced and basic indexing](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#combining-advanced-and-basic-indexing)\n        with basic indexes *between* two advanced indexes: the definition\n        NumPy chose for the result does not have a generalization beyond\n        rectilinear arrays).\n\n        The `where` parameter can be any of the following or a tuple of\n        the following.\n\n           * **An integer** selects one element. Like Python/NumPy, it is\n             zero-indexed: `0` is the first item, `1` is the second, etc.\n             Negative indexes count from the end of the list: `-1` is the\n             last, `-2` is the second-to-last, etc.\n             Indexes beyond the size of the array, either because they\'re too\n             large or because they\'re too negative, raise errors. In\n             particular, some nested lists might contain a desired element\n             while others don\'t; this would raise an error.\n           * **A slice** (either a Python `slice` object or the\n             `start:stop:step` syntax) selects a range of elements. The\n             `start` and `stop` values are zero-indexed; `start` is inclusive\n             and `stop` is exclusive, like Python/NumPy. Negative `step`\n             values are allowed, but a `step` of `0` is an error. Slices\n             beyond the size of the array are not errors but are truncated,\n             like Python/NumPy.\n           * **A string** selects a tuple or record field, even if its\n             position in the tuple is to the left of the dimension where the\n             tuple/record is defined. (See <<projection>> below.) This is\n             similar to NumPy\'s\n             [field access](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#field-access),\n             except that strings are allowed in the same tuple with other\n             slice types. While record fields have names, tuple fields are\n             integer strings, such as `""0""`, `""1""`, `""2""` (always\n             non-negative). Be careful to distinguish these from non-string\n             integers.\n           * **An iterable of strings** (not the top-level tuple) selects\n             multiple tuple/record fields.\n           * **An ellipsis** (either the Python `Ellipsis` object or the\n             `...` syntax) skips as many dimensions as needed to put the\n             rest of the slice items to the innermost dimensions.\n           * **A np.newaxis** or its equivalent, None, does not select items\n             but introduces a new regular dimension in the output with size\n             `1`. This is a convenient way to explicitly choose a dimension\n             for broadcasting.\n           * **A boolean array** with the same length as the current dimension\n             (or any iterable, other than the top-level tuple) selects elements\n             corresponding to each True value in the array, dropping those\n             that correspond to each False. The behavior is similar to\n             NumPy\'s\n             [compress](https://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html)\n             function.\n           * **An integer array** (or any iterable, other than the top-level\n             tuple) selects elements like a single integer, but produces a\n             regular dimension of as many as are desired. The array can have\n             any length, any order, and it can have duplicates and incomplete\n             coverage. The behavior is similar to NumPy\'s\n             [take](https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html)\n             function.\n           * **An integer Array with missing (None) items** selects multiple\n             values by index, as above, but None values are passed through\n             to the output. This behavior matches pyarrow\'s\n             [Array.take](https://arrow.apache.org/docs/python/generated/pyarrow.Array.html#pyarrow.Array.take)\n             which also manages arrays with missing values. See\n             <<option indexing>> below.\n           * **An Array of nested lists**, ultimately containing booleans or\n             integers and having the same lengths of lists at each level as\n             the Array to which they\'re applied, selects by boolean or by\n             integer at the deeply nested level. See <<nested indexing>> below.\n\n        A tuple of the above applies each slice item to a dimension of the\n        data, which can be very expressive. More than one flat boolean/integer\n        array are ""iterated as one"" as described in the\n        [NumPy documentation](https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing).\n\n        Filtering\n        *********\n\n        A common use of selection by boolean arrays is to filter a dataset by\n        some property. For instance, to get the odd values of the `array`\n\n            ak.Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n        one can put an array expression with True for each odd value inside\n        square brackets:\n\n            >>> array[array % 2 == 1]\n            <Array [1, 3, 5, 7, 9] type=\'5 * int64\'>\n\n        This technique is so common in NumPy and Pandas data analysis that it\n        is often read as a syntax, rather than a consequence of array slicing.\n\n        The extension to nested arrays like\n\n            ak.Array([[[0, 1, 2], [], [3, 4], [5]], [[6, 7, 8], [9]]])\n\n        allows us to use the same syntax more generally.\n\n            >>> array[array % 2 == 1]\n            <Array [[[1], [], [3], [5]], [[7], [9]]] type=\'2 * var * var * int64\'>\n\n        In this example, the boolean array is itself nested (see\n        <<nested indexing>> below).\n\n            >>> array % 2 == 1\n            <Array [[[False, True, False], ... [True]]] type=\'2 * var * var * bool\'>\n\n        This also applies to data with record structures.\n\n        For nested data, we often need to select the first or first two\n        elements from variable-length lists. That can be a problem if some\n        lists are empty. A function like #ak.num can be useful for first\n        selecting by the lengths of lists.\n\n            >>> array = ak.Array([[1.1, 2.2, 3.3],\n            ...                   [],\n            ...                   [4.4, 5.5],\n            ...                   [6.6],\n            ...                   [],\n            ...                   [7.7, 8.8, 9.9]])\n            ...\n            >>> array[ak.num(array) > 0, 0]\n            <Array [1.1, 4.4, 6.6, 7.7] type=\'4 * float64\'>\n            >>> array[ak.num(array) > 1, 1]\n            <Array [2.2, 5.5, 8.8] type=\'3 * float64\'>\n\n        It\'s sometimes also a problem that ""cleaning"" the dataset by dropping\n        empty lists changes its alignment, so that it can no longer be used\n        in calculations with ""uncleaned"" data. For this, #ak.mask can be\n        useful because it inserts None in positions that fail the filter,\n        rather than removing them.\n\n            >>> print(ak.mask(array, ak.num(array) > 1))\n            [[1.1, 2.2, 3.3], None, [4.4, 5.5], None, None, [7.7, 8.8, 9.9]]\n\n        Note, however, that the `0` or `1` to pick the first or second\n        item of each nested list is in the second dimension, so the first\n        dimension of the slice must be a `:`.\n\n            >>> ak.mask(array, ak.num(array) > 1)[:, 0]\n            <Array [1.1, None, 4.4, None, None, 7.7] type=\'6 * ?float64\'>\n            >>> ak.mask(array, ak.num(array) > 1)[:, 1]\n            <Array [2.2, None, 5.5, None, None, 8.8] type=\'6 * ?float64\'>\n\n        Another syntax for\n\n            ak.mask(array, array_of_booleans)\n\n        is\n\n            array.mask[array_of_booleans]\n\n        (which is 5 characters away from simply filtering the `array`).\n\n        Projection\n        **********\n\n        The following `array`\n\n            ak.Array([[{""x"": 1.1, ""y"": [1]}, {""x"": 2.2, ""y"": [2, 2]}],\n                      [{""x"": 3.3, ""y"": [3, 3, 3]}],\n                      [{""x"": 0, ""y"": []}, {""x"": 1.1, ""y"": [1, 1, 1]}]])\n\n        has records inside of nested lists:\n\n            >>> ak.type(array)\n            3 * var * {""x"": float64, ""y"": var * int64}\n\n        In principle, one should select nested lists before record fields,\n\n            >>> array[2, :, ""x""]\n            <Array [0, 1.1] type=\'2 * float64\'>\n            >>> array[::2, :, ""x""]\n            <Array [[1.1, 2.2], [0, 1.1]] type=\'2 * var * float64\'>\n\n        but it\'s also possible to select record fields first.\n\n            >>> array[""x""]\n            <Array [[1.1, 2.2], [3.3], [0, 1.1]] type=\'3 * var * float64\'>\n\n        The string can ""commute"" to the left through integers and slices to\n        get the same result as it would in its ""natural"" position.\n\n            >>> array[2, :, ""x""]\n            <Array [0, 1.1] type=\'2 * float64\'>\n            >>> array[2, ""x"", :]\n            <Array [0, 1.1] type=\'2 * float64\'>\n            >>> array[""x"", 2, :]\n            <Array [0, 1.1] type=\'2 * float64\'>\n\n        The is analogous to selecting rows (integer indexes) before columns\n        (string names) or columns before rows, except that the rows are\n        more complex (like a Pandas\n        [MultiIndex](https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html)).\n        This would be an expensive operation in a typical object-oriented\n        environment, in which the records with fields `""x""` and `""y""` are\n        akin to C structs, but for columnar Awkward Arrays, projecting\n        through all records to produce an array of nested lists of `""x""`\n        values just changes the metadata (no loop over data, and therefore\n        fast).\n\n        Thus, data analysts should think of records as fluid objects that\n        can be easily projected apart and zipped back together with\n        #ak.zip.\n\n        Note, however, that while a column string can ""commute"" with row\n        indexes to the left of its position in the tree, it can\'t commute\n        to the right. For example, it\'s possible to use slices inside\n        `""y""` because `""y""` is a list:\n\n            >>> array[0, :, ""y""]\n            <Array [[1], [2, 2]] type=\'2 * var * int64\'>\n            >>> array[0, :, ""y"", 0]\n            <Array [1, 2] type=\'2 * int64\'>\n\n        but it\'s not possible to move `""y""` to the right\n\n            >>> array[0, :, 0, ""y""]\n            ValueError: in NumpyArray, too many dimensions in slice\n\n        because the `array[0, :, 0, ...]` slice applies to both `""x""` and\n        `""y""` before `""y""` is selected, and `""x""` is a one-dimensional\n        NumpyArray that can\'t take more than its share of slices.\n\n        Option indexing\n        ***************\n\n        NumPy arrays can be sliced by all of the above slice types except\n        arrays with missing values and arrays with nested lists, both of\n        which are inexpressible in NumPy. Missing values, represented by\n        None in Python, are called option types (#ak.types.OptionType) in\n        Awkward Array and can be used as a slice.\n\n        For example, an `array` like\n\n            ak.Array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n\n        can be sliced with a boolean array\n\n            >>> array[[False, False, False, False, True, False, True, False, True]]\n            <Array [5.5, 7.7, 9.9] type=\'3 * float64\'>\n\n        or a boolean array containing None values:\n\n            >>> array[[False, False, False, False, True, None, True, None, True]]\n            <Array [5.5, None, 7.7, None, 9.9] type=\'5 * ?float64\'>\n\n        Similarly for arrays of integers and None:\n\n            >>> array[[0, 1, None, None, 7, 8]]\n            <Array [1.1, 2.2, None, None, 8.8, 9.9] type=\'6 * ?float64\'>\n\n        This is the same behavior as pyarrow\'s\n        [Array.take](https://arrow.apache.org/docs/python/generated/pyarrow.Array.html#pyarrow.Array.take),\n        which establishes a convention for how to interpret slice arrays\n        with option type:\n\n            >>> import pyarrow as pa\n            >>> array = pa.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n            >>> array.take(pa.array([0, 1, None, None, 7, 8]))\n            <pyarrow.lib.DoubleArray object at 0x7efc7f060210>\n            [\n              1.1,\n              2.2,\n              null,\n              null,\n              8.8,\n              9.9\n            ]\n\n        Nested indexing\n        ***************\n\n        Awkward Array\'s nested lists can be used as slices as well, as long\n        as the type at the deepest level of nesting is boolean or integer.\n\n        For example, the `array`\n\n            ak.Array([[[0.0, 1.1, 2.2], [], [3.3, 4.4]], [], [[5.5]]])\n\n        can be sliced at the top level with one-dimensional arrays:\n\n            >>> array[[False, True, True]]\n            <Array [[], [[5.5]]] type=\'2 * var * var * float64\'>\n            >>> array[[1, 2]]\n            <Array [[], [[5.5]]] type=\'2 * var * var * float64\'>\n\n        with singly nested lists:\n\n            >>> array[[[False, True, True], [], [True]]]\n            <Array [[[], [3.3, 4.4]], [], [[5.5]]] type=\'3 * var * var * float64\'>\n            >>> array[[[1, 2], [], [0]]]\n            <Array [[[], [3.3, 4.4]], [], [[5.5]]] type=\'3 * var * var * float64\'>\n\n        and with doubly nested lists:\n\n            >>> array[[[[False, True, False], [], [True, False]], [], [[False]]]]\n            <Array [[[1.1], [], [3.3]], [], [[]]] type=\'3 * var * var * float64\'>\n            >>> array[[[[1], [], [0]], [], [[]]]]\n            <Array [[[1.1], [], [3.3]], [], [[]]] type=\'3 * var * var * float64\'>\n\n        The key thing is that the nested slice has the same number of elements\n        as the array it\'s slicing at every level of nesting that it reproduces.\n        This is similar to the requirement that boolean arrays have the same\n        length as the array they\'re filtering.\n\n        This kind of slicing is useful because NumPy\'s\n        [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)\n        produce arrays with the same structure as the original array, which\n        can then be used as filters.\n\n            >>> print((array * 10) % 2 == 1)\n            [[[False, True, False], [], [True, False]], [], [[True]]]\n            >>> print(array[(array * 10) % 2 == 1])\n            [[[1.1], [], [3.3]], [], [[5.5]]]\n\n        Functions whose names start with ""arg"" return index positions, which\n        can be used with the integer form.\n\n            >>> print(np.argmax(array, axis=-1))\n            [[2, None, 1], [], [0]]\n            >>> print(array[np.argmax(array, axis=-1)])\n            [[[3.3, 4.4], None, []], [], [[5.5]]]\n\n        Here, the `np.argmax` returns the integer position of the maximum\n        element or None for empty arrays. It\'s a nice example of\n        <<option indexing>> with <<nested indexing>>.\n        """"""\n        return awkward1._util.wrap(self._layout[where], self._behavior)\n\n    def __setitem__(self, where, what):\n        """"""\n        Args:\n            where (str): Field name to add to records in the array.\n            what (#ak.Array): Array to add as the new field.\n\n        Unlike #__getitem__, which allows a wide variety of slice types,\n        only single field-slicing is supported for assignment.\n        (#ak.layout.Content arrays are immutable; field assignment replaces\n        the #layout with an array that has the new field using #ak.with_field.)\n\n        However, a field can be assigned deeply into a nested record e.g.\n\n            >>> nested = ak.zip({""a"" : ak.zip({""x"" : [1, 2, 3]})})\n            >>> nested[""a"", ""y""] = 2 * nested.a.x\n            >>> ak.to_list(nested)\n            [{\'a\': {\'x\': 1, \'y\': 2}}, {\'a\': {\'x\': 2, \'y\': 4}}, {\'a\': {\'x\': 3, \'y\': 6}}]\n\n        Note that the following does **not** work:\n\n            >>> nested[""a""][""y""] = 2 * nested.a.x # does not work, nested[""a""] is a copy!\n\n        Always assign by passing the whole path to the top level\n\n            >>> nested[""a"", ""y""] = 2 * nested.a.x\n\n        If necessary, the new field will be broadcasted to fit the array.\n        For example, given an `array` like\n\n            ak.Array([[{""x"": 1.1}, {""x"": 2.2}, {""x"": 3.3}], [], [{""x"": 4.4}, {""x"": 5.5}]])\n\n        which has three elements with nested data in each, assigning\n\n            >>> array[""y""] = [100, 200, 300]\n\n        will result in\n\n            >>> ak.to_list(array)\n            [[{\'x\': 1.1, \'y\': 100}, {\'x\': 2.2, \'y\': 100}, {\'x\': 3.3, \'y\': 100}],\n             [],\n             [{\'x\': 4.4, \'y\': 300}, {\'x\': 5.5, \'y\': 300}]]\n\n        because the `100` in `what[0]` is broadcasted to all three nested\n        elements of `array[0]`, the `200` in `what[1]` is broadcasted to the\n        empty list `array[1]`, and the `300` in `what[2]` is broadcasted to\n        both elements of `array[2]`.\n\n        See #ak.with_field for a variant that does not change the #ak.Array\n        in-place. (Internally, this method uses #ak.with_field, so performance\n        is not a factor in choosing one over the other.)\n        """"""\n        if not (\n            isinstance(where, str)\n            or (isinstance(where, tuple) and all(isinstance(x, str) for x in where))\n        ):\n            raise TypeError(""only fields may be assigned in-place (by field name)"")\n        self._layout = awkward1.operations.structure.with_field(\n            self._layout, what, where\n        ).layout\n        self._numbaview = None\n\n    def __getattr__(self, where):\n        """"""\n        Whenever possible, fields can be accessed as attributes.\n\n        For example, the fields of an `array` like\n\n            ak.Array([[{""x"": 1.1, ""y"": [1]}, {""x"": 2.2, ""y"": [2, 2]}, {""x"": 3.3, ""y"": [3, 3, 3]}],\n                      [],\n                      [{""x"": 4.4, ""y"": [4, 4, 4, 4]}, {""x"": 5.5, ""y"": [5, 5, 5, 5, 5]}]])\n\n        can be accessed as\n\n            >>> array.x\n            <Array [[1.1, 2.2, 3.3], [], [4.4, 5.5]] type=\'3 * var * float64\'>\n            >>> array.y\n            <Array [[[1], [2, 2], ... [5, 5, 5, 5, 5]]] type=\'3 * var * var * int64\'>\n\n        which are equivalent to `array[""x""]` and `array[""y""]`. (See\n        <<projection>>.)\n\n        Fields can\'t be accessed as attributes when\n\n           * #ak.Array methods or properties take precedence,\n           * a domain-specific behavior has methods or properties that take\n             precedence, or\n           * the field name is not a valid Python identifier or is a Python\n             keyword.\n\n        Note that while fields can be accessed as attributes, they cannot be\n        *assigned* as attributes: the following doesn\'t work.\n\n            array.z = new_field\n\n        Always use\n\n            array[""z""] = new_field\n\n        to add a field.\n        """"""\n        if where in dir(type(self)):\n            return super(Array, self).__getattribute__(where)\n        else:\n            if where in self._layout.keys():\n                try:\n                    return self[where]\n                except Exception as err:\n                    raise AttributeError(\n                        ""while trying to get field {0}, an exception ""\n                        ""occurred:\\n{1}: {2}"".format(repr(where), type(err), str(err))\n                    )\n            else:\n                raise AttributeError(""no field named {0}"".format(repr(where)))\n\n    def __dir__(self):\n        """"""\n        Lists all methods, properties, and field names (see #__getattr__)\n        that can be accessed as attributes.\n        """"""\n        return sorted(\n            set(\n                dir(super(Array, self))\n                + [\n                    x\n                    for x in self._layout.keys()\n                    if _dir_pattern.match(x) and not keyword.iskeyword(x)\n                ]\n            )\n        )\n\n    @property\n    def slot0(self):\n        """"""\n        Equivalent to #__getitem__ with `""0""`, which selects slot `0` from\n        all tuples.\n\n        Record fields can be accessed from #__getitem__ with strings (see\n        <<projection>>), but tuples only have slot positions, which are\n        0-indexed integers. However, they must also be quoted as strings\n        to avoid confusion with integers as array indexes. Sometimes, though,\n        interleaving integers in strings and integers outside of strings\n        can be confusing in analysis code.\n\n        Record fields can also be accessed as attributes (with limitations),\n        and the distinction between attributes (#__getattr__) and subscripts\n        (#__getitem__) shows up more clearly in dense code. But integers would\n        not be valid attribute names, so they\'re named #slot0 through #slot9.\n\n        (Tuples with more than 10 slots are rare and can defer to\n        #__getitem__.)\n        """"""\n        return self[""0""]\n\n    @property\n    def slot1(self):\n        """"""\n        Equivalent to #__getitem__ with `""1""`. See #slot0.\n        """"""\n        return self[""1""]\n\n    @property\n    def slot2(self):\n        """"""\n        Equivalent to #__getitem__ with `""2""`. See #slot0.\n        """"""\n        return self[""2""]\n\n    @property\n    def slot3(self):\n        """"""\n        Equivalent to #__getitem__ with `""3""`. See #slot0.\n        """"""\n        return self[""3""]\n\n    @property\n    def slot4(self):\n        """"""\n        Equivalent to #__getitem__ with `""4""`. See #slot0.\n        """"""\n        return self[""4""]\n\n    @property\n    def slot5(self):\n        """"""\n        Equivalent to #__getitem__ with `""5""`. See #slot0.\n        """"""\n        return self[""5""]\n\n    @property\n    def slot6(self):\n        """"""\n        Equivalent to #__getitem__ with `""6""`. See #slot0.\n        """"""\n        return self[""6""]\n\n    @property\n    def slot7(self):\n        """"""\n        Equivalent to #__getitem__ with `""7""`. See #slot0.\n        """"""\n        return self[""7""]\n\n    @property\n    def slot8(self):\n        """"""\n        Equivalent to #__getitem__ with `""8""`. See #slot0.\n        """"""\n        return self[""8""]\n\n    @property\n    def slot9(self):\n        """"""\n        Equivalent to #__getitem__ with `""9""`. See #slot0.\n        """"""\n        return self[""9""]\n\n    def __str__(self, limit_value=85):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the Array as a string.\n\n        Presents this Array as a string without type or `""<Array ...>""`.\n\n        Large Arrays are truncated to the first few elements and the last\n        few elements to fit within `limit_value` characters, using ellipsis\n        to indicate the break. For example, an `array` like\n\n            ak.Array([[1.1, 2.2, 3.3],\n                      [],\n                      [4.4, 5.5, 6.6],\n                      [7.7, 8.8, 9.9, 10.0],\n                      [],\n                      [],\n                      [],\n                      [11.1, 12.2]])\n\n        is shown as\n\n            [[1.1, 2.2, 3.3], [], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9, ... [], [], [], [11.1, 12.2]]\n\n        The algorithm does not split tokens; it will not show half a number\n        (which can be very misleading), but it can lose structural elements\n        like the `]` that closes `[7.7, 8.8, 9.9, 10.0]`.\n\n        The algorithm also avoids reading data unnecessarily: most of the data\n        in the ellipsis are not even read. This can be particularly important\n        for datasets that contain #ak.layout.VirtualArray nodes that might\n        be expensive to read.\n\n        Note that the string also does not quote field names. An `array` like\n\n            ak.Array([[{""x"": 1.1, ""y"": [1]}, {""x"": 2.2, ""y"": [2, 2]}, {""x"": 3.3, ""y"": [3, 3, 3]}],\n                      [],\n                      [{""x"": 4.4, ""y"": [4, 4, 4, 4]}]])\n\n        is presented as\n\n            [[{x: 1.1, y: [1]}, {x: 2.2, y: [2, 2]}, ... [], [{x: 4.4, y: [4, 4, 4, 4]}]]\n\n        Floating point numbers are presented in `.3g` format (3 digits using\n        exponential notation if necessary).\n\n        The string representation cannot be read as JSON or as an #ak.Array\n        constructor.\n\n        See #ak.to_list and #ak.to_json to convert whole Arrays into Python\n        data or JSON strings without loss (except for #type).\n        """"""\n        import awkward1.operations.structure\n\n        layout = awkward1.operations.structure.with_cache(\n            self._layout, {}, chain=""last"", highlevel=False\n        )\n        return awkward1._util.minimally_touching_string(\n            limit_value, layout, self._behavior\n        )\n\n    def __repr__(self, limit_value=40, limit_total=85):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the data of the Array.\n            limit_total (int): Maximum number of characters to use for\n                the whole string (should be larger than `limit_value`).\n\n        Presents this Array as a string with its type and `""<Array ...>""`.\n\n        See #__str__ for details of the string truncation algorithm.\n\n        The #type is truncated as well, but showing only the left side\n        of its string (the outermost data structures).\n        """"""\n        import awkward1.operations.structure\n\n        layout = awkward1.operations.structure.with_cache(\n            self._layout, {}, chain=""last"", highlevel=False\n        )\n        value = awkward1._util.minimally_touching_string(\n            limit_value, layout, self._behavior\n        )\n\n        try:\n            name = super(Array, self).__getattribute__(""__name__"")\n        except AttributeError:\n            name = type(self).__name__\n        limit_type = limit_total - (len(value) + len(name) + len(""<  type=>""))\n        typestr = repr(str(awkward1._util.highlevel_type(layout, self._behavior, True)))\n        if len(typestr) > limit_type:\n            typestr = typestr[: (limit_type - 4)] + ""..."" + typestr[-1]\n\n        return ""<{0} {1} type={2}>"".format(name, value, typestr)\n\n    def __array__(self, *args, **kwargs):\n        """"""\n        Intercepts attempts to convert this Array into a NumPy array and\n        either performs a zero-copy conversion or raises an error.\n\n        This function is also called by the\n        [np.asarray](https://docs.scipy.org/doc/numpy/reference/generated/numpy.asarray.html)\n        family of functions, which have `copy=False` by default.\n\n            >>> np.asarray(ak.Array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]]))\n            array([[1.1, 2.2, 3.3],\n                   [4.4, 5.5, 6.6]])\n\n        If the data are numerical and regular (nested lists have equal lengths\n        in each dimension, as described by the #type), they can be losslessly\n        converted to a NumPy array and this function returns without an error.\n\n        Otherwise, the function raises an error. It does not create a NumPy\n        array with dtype `""O""` for `np.object_` (see the\n        [note on object_ type](https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#arrays-scalars-built-in))\n        since silent conversions to dtype `""O""` arrays would not only be a\n        significant performance hit, but would also break functionality, since\n        nested lists in a NumPy `""O""` array are severed from the array and\n        cannot be sliced as dimensions.\n\n        Only exception: Pandas can generate NumPy `""O""` arrays to print\n        Array fragments to the screen.\n        """"""\n        if awkward1._util.called_by_module(\n            ""pandas.io.formats.format""\n        ) or awkward1._util.called_by_module(""pandas.core.generic""):\n            out = numpy.empty(len(self._layout), dtype=""O"")\n            for i, x in enumerate(self._layout):\n                out[i] = awkward1._util.wrap(x, self._behavior)\n            return out\n        elif awkward1._util.called_by_module(""pandas""):\n            try:\n                return awkward1._connect._numpy.convert_to_array(\n                    self._layout, args, kwargs\n                )\n            except Exception:\n                out = numpy.empty(len(self._layout), dtype=""O"")\n                for i, x in enumerate(self._layout):\n                    out[i] = awkward1._util.wrap(x, self._behavior)\n                return out\n        else:\n            return awkward1._connect._numpy.convert_to_array(self._layout, args, kwargs)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        """"""\n        Intercepts attempts to pass this Array to a NumPy\n        [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)\n        (ufuncs) and passes it through the Array\'s structure.\n\n        This method conforms to NumPy\'s\n        [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html)\n        for overriding ufuncs, which has been\n        [available since NumPy 1.13](https://numpy.org/devdocs/release/1.13.0-notes.html#array-ufunc-added)\n        (and thus NumPy 1.13 is the minimum allowed version).\n\n        When any ufunc is applied to an Awkward Array, it applies to the\n        innermost level of structure and preserves the structure through the\n        operation.\n\n        For example, with an `array` like\n\n            ak.Array([[{""x"": 0.0, ""y"": []}, {""x"": 1.1, ""y"": [1]}], [], [{""x"": 2.2, ""y"": [2, 2]}]])\n\n        applying `np.sqrt` would yield\n\n            >>> print(np.sqrt(array))\n            [[{x: 0, y: []}, {x: 1.05, y: [1]}], [], [{x: 1.48, y: [1.41, 1.41]}]]\n\n        In addition, many unary and binary operators implicitly call ufuncs,\n        such as `np.power` in\n\n            >>> print(array**2)\n            [[{x: 0, y: []}, {x: 1.21, y: [1]}], [], [{x: 4.84, y: [4, 4]}]]\n\n        In the above example, `array` is a nested list of records and `2` is\n        a scalar. Awkward Array applies the same broadcasting rules as NumPy\n        plus a few more to deal with nested structures. In addition to\n        broadcasting a scalar, as above, it is possible to broadcast\n        arrays with less depth into arrays with more depth, such as\n\n            >>> print(array + ak.Array([10, 20, 30]))\n            [[{x: 10, y: []}, {x: 11.1, y: [11]}], [], [{x: 32.2, y: [32, 32]}]]\n\n        See #ak.broadcast_arrays for details about broadcasting and the\n        generalized set of broadcasting rules.\n\n        Third party libraries can create ufuncs, not just NumPy, so any library\n        that ""plays well"" with the NumPy ecosystem can be used with Awkward\n        Arrays:\n\n            >>> import numba as nb\n            >>> @nb.vectorize([nb.float64(nb.float64)])\n            ... def sqr(x):\n            ...     return x * x\n            ...\n            >>> print(sqr(array))\n            [[{x: 0, y: []}, {x: 1.21, y: [1]}], [], [{x: 4.84, y: [4, 4]}]]\n\n        See also #__array_function__.\n        """"""\n        return awkward1._connect._numpy.array_ufunc(ufunc, method, inputs, kwargs)\n\n    def __array_function__(self, func, types, args, kwargs):\n        """"""\n        Intercepts attempts to pass this Array to those NumPy functions other\n        than universal functions that have an Awkward equivalent.\n\n        This method conforms to NumPy\'s\n        [NEP 18](https://numpy.org/neps/nep-0018-array-function-protocol.html)\n        for overriding functions, which has been\n        [available since NumPy 1.17](https://numpy.org/devdocs/release/1.17.0-notes.html#numpy-functions-now-always-support-overrides-with-array-function)\n        (and\n        [NumPy 1.16 with an experimental flag set](https://numpy.org/devdocs/release/1.16.0-notes.html#numpy-functions-now-support-overrides-with-array-function)).\n        This is not crucial for Awkward Array to work correctly, as NumPy\n        functions like np.concatenate can be manually replaced with\n        #ak.concatenate for early versions of NumPy.\n\n        See also #__array_ufunc__.\n        """"""\n        return awkward1._connect._numpy.array_function(func, types, args, kwargs)\n\n    @property\n    def numba_type(self):\n        """"""\n        The type of this Array when it is used in Numba. It contains enough\n        information to generate low-level code for accessing any element,\n        down to the leaves.\n\n        See [Numba documentation](https://numba.pydata.org/numba-doc/dev/reference/types.html)\n        on types and signatures.\n        """"""\n        import awkward1._connect._numba\n\n        awkward1._connect._numba.register_and_check()\n        if self._numbaview is None:\n            self._numbaview = awkward1._connect._numba.arrayview.ArrayView.fromarray(\n                self\n            )\n        import numba\n\n        return numba.typeof(self._numbaview)\n\n\nclass Record(awkward1._connect._numpy.NDArrayOperatorsMixin):\n    """"""\n    Args:\n        data (#ak.layout.Record, #ak.Record, str, or dict):\n            Data to wrap or convert into a record.\n            If a string, the data are assumed to be JSON.\n            If a dict, calls #ak.from_iter, which assumes all inner\n            dimensions have irregular lengths.\n        behavior (None or dict): Custom #ak.behavior for this Record only.\n        with_name (None or str): Gives the record type a name that can be\n            used to override its behavior (see below).\n        check_valid (bool): If True, verify that the #layout is valid.\n\n    High-level record that can contain fields of any type.\n\n    Most users won\'t be creating Records manually. This class primarily exists\n    to be overridden in the same way as #ak.Array.\n\n    Records can be used in [Numba](http://numba.pydata.org/): they can be\n    passed as arguments to a Numba-compiled function or returned as return\n    values. The only limitation is that they cannot be *created*\n    inside the Numba-compiled function; to make outputs, consider\n    #ak.ArrayBuilder.\n\n    See also #ak.Array and #ak.behavior.\n    """"""\n\n    def __init__(self, data, behavior=None, with_name=None, check_valid=False):\n        if isinstance(data, awkward1.layout.Record):\n            layout = data\n        elif isinstance(data, Record):\n            layout = data.layout\n        elif isinstance(data, str):\n            layout = awkward1.operations.convert.from_json(data, highlevel=False)\n        elif isinstance(data, dict):\n            layout = awkward1.operations.convert.from_iter([data], highlevel=False)[0]\n        elif isinstance(data, Iterable):\n            raise TypeError(\n                ""could not convert non-dict into an ""\n                ""awkward1.Record; try awkward1.Array""\n            )\n        else:\n            layout = None\n        if not isinstance(layout, awkward1.layout.Record):\n            raise TypeError(""could not convert data into an awkward1.Record"")\n\n        if self.__class__ is Record:\n            self.__class__ = awkward1._util.recordclass(layout, behavior)\n\n        if with_name is not None:\n            layout = awkward1.operations.structure.with_name(\n                layout, with_name, highlevel=False\n            )\n\n        self.layout = layout\n        self.behavior = behavior\n        if check_valid:\n            awkward1.operations.describe.validity_error(self, exception=True)\n\n    @property\n    def layout(self):\n        """"""\n        The #ak.layout.Record that contains composable #ak.layout.Content\n        elements to determine how the array is structured.\n\n        See #ak.Array.layout for a more complete description.\n\n        The #ak.layout.Record is not a subclass of #ak.layout.Content in\n        Python (note: [Record](../_static/classawkward_1_1Record.html) *is* a\n        subclass of [Content](../_static/classawkward_1_1Content.html) in\n        C++!) and it is not composable with them: #ak.layout.Record contains\n        one #ak.layout.RecordArray (which is a #ak.layout.Content), but\n        #ak.layout.Content nodes cannot contain a #ak.layout.Record.\n\n        A #ak.layout.Record is not an independent entity from its\n        #ak.layout.RecordArray; it\'s really just a marker indicating which\n        element to select. The XML representation reflects that:\n\n            >>> vectors = ak.Array([{""x"": 0.1, ""y"": 1.0, ""z"": 30.0},\n            ...                     {""x"": 0.2, ""y"": 2.0, ""z"": 20.0},\n            ...                     {""x"": 0.3, ""y"": 3.0, ""z"": 10.0}])\n\n            >>> vectors[1].layout\n            <Record at=""1"">\n                <RecordArray>\n                    <field index=""0"" key=""x"">\n                        <NumpyArray format=""d"" shape=""3"" data=""0.1 0.2 0.3"" at=""0x555660dfe7d0""/>\n                    </field>\n                    <field index=""1"" key=""y"">\n                        <NumpyArray format=""d"" shape=""3"" data=""1 2 3"" at=""0x555660df4180""/>\n                    </field>\n                    <field index=""2"" key=""z"">\n                        <NumpyArray format=""d"" shape=""3"" data=""30 20 10"" at=""0x555660df6190""/>\n                    </field>\n                </RecordArray>\n            </Record>\n        """"""\n        return self._layout\n\n    @layout.setter\n    def layout(self, layout):\n        if isinstance(layout, awkward1.layout.Record):\n            self._layout = layout\n            self._numbaview = None\n        else:\n            raise TypeError(""layout must be a subclass of awkward1.layout.Record"")\n\n    @property\n    def behavior(self):\n        """"""\n        The `behavior` parameter passed into this Record\'s constructor.\n\n           * If a dict, this `behavior` overrides the global #ak.behavior.\n             Any keys in the global #ak.behavior but not this `behavior` are\n             still valid, but any keys in both are overridden by this\n             `behavior`. Keys with a None value are equivalent to missing keys,\n             so this `behavior` can effectively remove keys from the\n             global #ak.behavior.\n\n           * If None, the Record defaults to the global #ak.behavior.\n\n        See #ak.behavior for a list of recognized key patterns and their\n        meanings.\n        """"""\n        return self._behavior\n\n    @behavior.setter\n    def behavior(self, behavior):\n        if behavior is None or isinstance(behavior, dict):\n            self._behavior = behavior\n        else:\n            raise TypeError(""behavior must be None or a dict"")\n\n    def tolist(self):\n        """"""\n        Converts this Record into Python objects.\n\n        Awkward Array types have the following Pythonic translations.\n\n           * #ak.types.PrimitiveType: converted into bool, int, float.\n           * #ak.types.OptionType: missing values are converted into None.\n           * #ak.types.ListType: converted into list.\n           * #ak.types.RegularType: also converted into list. Python (and JSON)\n             forms lose information about the regularity of list lengths.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__bytestring__""`: converted into bytes.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__string__""`: converted into str.\n           * #ak.types.RecordArray without field names: converted into tuple.\n           * #ak.types.RecordArray with field names: converted into dict.\n           * #ak.types.UnionArray: Python data are naturally heterogeneous.\n\n        See also #ak.to_list and #ak.from_iter.\n        """"""\n        return awkward1.operations.convert.to_list(self)\n\n    def tojson(\n        self, destination=None, pretty=False, maxdecimals=None, buffersize=65536\n    ):\n        """"""\n        Args:\n            destination (None or str): If None, this method returns a JSON str;\n                if a str, it uses that as a file name and writes (overwrites)\n                that file (returning None).\n            pretty (bool): If True, indent the output for human readability; if\n                False, output compact JSON without spaces.\n            maxdecimals (None or int): If an int, limit the number of\n                floating-point decimals to this number; if None, write all\n                digits.\n            buffersize (int): Size (in bytes) of the buffer used by the JSON\n                parser.\n\n        Converts this Record into a JSON string or file.\n\n        Awkward Array types have the following JSON translations.\n\n           * #ak.types.PrimitiveType: converted into JSON booleans and numbers.\n           * #ak.types.OptionType: missing values are converted into None.\n           * #ak.types.ListType: converted into JSON lists.\n           * #ak.types.RegularType: also converted into JSON lists. JSON (and\n             Python) forms lose information about the regularity of list\n             lengths.\n           * #ak.types.ListType with parameter `""__array__""` equal to\n             `""__bytestring__""` or `""__string__""`: converted into JSON strings.\n           * #ak.types.RecordArray without field names: converted into JSON\n             objects with numbers as strings for keys.\n           * #ak.types.RecordArray with field names: converted into JSON\n             objects.\n           * #ak.types.UnionArray: JSON data are naturally heterogeneous.\n\n        See also #ak.to_json and #ak.from_json.\n        """"""\n        return awkward1.operations.convert.to_json(\n            self, destination, pretty, maxdecimals, buffersize\n        )\n\n    @property\n    def nbytes(self):\n        """"""\n        The total number of bytes in all the #ak.layout.Index,\n        #ak.layout.Identities, and #ak.layout.NumpyArray buffers in this\n        array tree.\n\n        Note: this calculation takes overlapping buffers into account, to the\n        extent that overlaps are not double-counted, but overlaps are currently\n        assumed to be complete subsets of one another, and so it is\n        theoretically possible (though unlikely) that this number is an\n        underestimate of the true usage.\n\n        It also does not count buffers that must be kept in memory because\n        of ownership, but are not directly used in the array. Nor does it count\n        the (small) C++ nodes or Python objects that reference the (large)\n        array buffers.\n        """"""\n        return self._layout.nbytes\n\n    def __getitem__(self, where):\n        """"""\n        Args:\n            where (many types supported; see below): Index of positions to\n                select from this Record.\n\n        Select items from the Record using an extension of NumPy\'s (already\n        quite extensive) rules.\n\n        See #ak.Array.__getitem__ for a more complete description. Since\n        this is a record, the first item in the slice tuple must be a\n        string, selecting a field.\n\n        For example, with a `record` like\n\n            ak.Record({""x"": 3.3, ""y"": [1, 2, 3]})\n\n        we can select\n\n            >>> record[""x""]\n            3.3\n            >>> record[""y""]\n            <Array [1, 2, 3] type=\'3 * int64\'>\n            >>> record[""y"", 1]\n            2\n        """"""\n        return awkward1._util.wrap(self._layout[where], self._behavior)\n\n    def __setitem__(self, where, what):\n        """"""\n        Args:\n            where (str): Field name to add data to the record.\n            what: Data to add as the new field.\n\n        For example:\n\n            >>> record = ak.Record({""x"": 3.3})\n            >>> record[""y""] = 4\n            >>> record[""z""] = {""another"": ""record""}\n            >>> print(record)\n            {x: 3.3, y: 4, z: {another: \'record\'}}\n\n        See #ak.with_field for a variant that does not change the #ak.Record\n        in-place. (Internally, this method uses #ak.with_field, so performance\n        is not a factor in choosing one over the other.)\n        """"""\n        if not (\n            isinstance(where, str)\n            or (isinstance(where, tuple) and all(isinstance(x, str) for x in where))\n        ):\n            raise TypeError(""only fields may be assigned in-place (by field name)"")\n        self._layout = awkward1.operations.structure.with_field(\n            self._layout, what, where\n        ).layout\n        self._numbaview = None\n\n    def __getattr__(self, where):\n        """"""\n        Whenever possible, fields can be accessed as attributes.\n\n        For example, the fields of an `record` like\n\n            ak.Record({""x"": 1.1, ""y"": [2, 2], ""z"": ""three""})\n\n        can be accessed as\n\n            >>> record.x\n            1.1\n            >>> record.y\n            <Array [2, 2] type=\'2 * int64\'>\n            >>> record.z\n            \'three\'\n\n        which are equivalent to `record[""x""]`, `record[""y""]`, and\n        `record[""z""]`.\n\n        Fields can\'t be accessed as attributes when\n\n           * #ak.Record methods or properties take precedence,\n           * a domain-specific behavior has methods or properties that take\n             precedence, or\n           * the field name is not a valid Python identifier or is a Python\n             keyword.\n        """"""\n        if where in dir(type(self)):\n            return super(Record, self).__getattribute__(where)\n        else:\n            if where in self._layout.keys():\n                try:\n                    return self[where]\n                except Exception as err:\n                    raise AttributeError(\n                        ""while trying to get field {0}, an exception ""\n                        ""occurred:\\n{1}: {2}"".format(repr(where), type(err), str(err))\n                    )\n            else:\n                raise AttributeError(""no field named {0}"".format(repr(where)))\n\n    def __dir__(self):\n        """"""\n        Lists all methods, properties, and field names (see #__getattr__)\n        that can be accessed as attributes.\n        """"""\n        return sorted(\n            set(\n                dir(super(Record, self))\n                + [\n                    x\n                    for x in self._layout.keys()\n                    if _dir_pattern.match(x) and not keyword.iskeyword(x)\n                ]\n            )\n        )\n\n    @property\n    def slot0(self):\n        """"""\n        Equivalent to #__getitem__ with `""0""`, which selects slot `0` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""0""]\n\n    @property\n    def slot1(self):\n        """"""\n        Equivalent to #__getitem__ with `""1""`, which selects slot `1` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""1""]\n\n    @property\n    def slot2(self):\n        """"""\n        Equivalent to #__getitem__ with `""2""`, which selects slot `2` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""2""]\n\n    @property\n    def slot3(self):\n        """"""\n        Equivalent to #__getitem__ with `""3""`, which selects slot `3` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""3""]\n\n    @property\n    def slot4(self):\n        """"""\n        Equivalent to #__getitem__ with `""4""`, which selects slot `4` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""4""]\n\n    @property\n    def slot5(self):\n        """"""\n        Equivalent to #__getitem__ with `""5""`, which selects slot `5` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""5""]\n\n    @property\n    def slot6(self):\n        """"""\n        Equivalent to #__getitem__ with `""6""`, which selects slot `6` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""6""]\n\n    @property\n    def slot7(self):\n        """"""\n        Equivalent to #__getitem__ with `""7""`, which selects slot `7` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""7""]\n\n    @property\n    def slot8(self):\n        """"""\n        Equivalent to #__getitem__ with `""8""`, which selects slot `8` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""8""]\n\n    @property\n    def slot9(self):\n        """"""\n        Equivalent to #__getitem__ with `""9""`, which selects slot `9` from\n        the Record as a tuple.\n\n        See #ak.Array.slot0 for a more complete description.\n        """"""\n        return self[""9""]\n\n    def __str__(self, limit_value=85):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the Record as a string.\n\n        Presents this Record as a string without type or `""<Record ...>""`.\n\n        See #ak.Array.__str__ for a more complete description.\n        """"""\n        import awkward1.operations.structure\n\n        layout = awkward1.operations.structure.with_cache(\n            self._layout, {}, chain=""last"", highlevel=False\n        )\n        return awkward1._util.minimally_touching_string(\n            limit_value + 2, layout, self._behavior\n        )[1:-1]\n\n    def __repr__(self, limit_value=40, limit_total=85):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the data of the Record.\n            limit_total (int): Maximum number of characters to use for\n                the whole string (should be larger than `limit_value`).\n\n        Presents this Record as a string with its type and `""<Record ...>""`.\n\n        See #ak.Array.__repr__ for a more complete description.\n        """"""\n        import awkward1.operations.structure\n\n        layout = awkward1.operations.structure.with_cache(\n            self._layout, {}, chain=""last"", highlevel=False\n        )\n        value = awkward1._util.minimally_touching_string(\n            limit_value + 2, layout, self._behavior\n        )[1:-1]\n\n        try:\n            name = super(Record, self).__getattribute__(""__name__"")\n        except AttributeError:\n            name = type(self).__name__\n        limit_type = limit_total - (len(value) + len(name) + len(""<  type=>""))\n        typestr = repr(\n            str(awkward1._util.highlevel_type(layout, self._behavior, False))\n        )\n        if len(typestr) > limit_type:\n            typestr = typestr[: (limit_type - 4)] + ""..."" + typestr[-1]\n\n        return ""<{0} {1} type={2}>"".format(name, value, typestr)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        """"""\n        Intercepts attempts to pass this Record to a NumPy\n        [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)\n        (ufuncs) and passes it through the Record\'s structure.\n\n        This method conforms to NumPy\'s\n        [NEP 13](https://numpy.org/neps/nep-0013-ufunc-overrides.html)\n        for overriding ufuncs, which has been\n        [available since NumPy 1.13](https://numpy.org/devdocs/release/1.13.0-notes.html#array-ufunc-added)\n        (and thus NumPy 1.13 is the minimum allowed version).\n\n        See #ak.Array.__array_ufunc__ for a more complete description.\n        """"""\n        return awkward1._connect._numpy.array_ufunc(ufunc, method, inputs, kwargs)\n\n    @property\n    def numba_type(self):\n        """"""\n        The type of this Record when it is used in Numba. It contains enough\n        information to generate low-level code for accessing any element,\n        down to the leaves.\n\n        See [Numba documentation](https://numba.pydata.org/numba-doc/dev/reference/types.html)\n        on types and signatures.\n        """"""\n        import awkward1._connect._numba\n\n        awkward1._connect._numba.register_and_check()\n        if self._numbaview is None:\n            self._numbaview = awkward1._connect._numba.arrayview.RecordView.fromrecord(\n                self\n            )\n        import numba\n\n        return numba.typeof(self._numbaview)\n\n\nclass ArrayBuilder(object):\n    """"""\n    Args:\n        behavior (None or dict): Custom #ak.behavior for arrays built by\n            this ArrayBuilder.\n        initial (int): Initial size (in bytes) of buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions).\n        resize (float): Resize multiplier for buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions);\n            should be strictly greater than 1.\n\n    General tool for building arrays of nested data structures from a sequence\n    of commands. Most data types can be constructed by calling commands in the\n    right order, similar to printing tokens to construct JSON output.\n\n    To illustrate how this works, consider the following example.\n\n        b = ak.ArrayBuilder()\n\n        # fill commands   # as JSON   # current array type\n        ##########################################################################################\n        b.begin_list()    # [         # 0 * var * unknown     (initially, the type is unknown)\n        b.integer(1)      #   1,      # 0 * var * int64\n        b.integer(2)      #   2,      # 0 * var * int64\n        b.real(3)         #   3.0     # 0 * var * float64     (all the integers have become floats)\n        b.end_list()      # ],        # 1 * var * float64\n        b.begin_list()    # [         # 1 * var * float64\n        b.end_list()      # ],        # 2 * var * float64\n        b.begin_list()    # [         # 2 * var * float64\n        b.integer(4)      #   4,      # 2 * var * float64\n        b.null()          #   null,   # 2 * var * ?float64    (now the floats are nullable)\n        b.integer(5)      #   5       # 2 * var * ?float64\n        b.end_list()      # ],        # 3 * var * ?float64\n        b.begin_list()    # [         # 3 * var * ?float64\n        b.begin_record()  #   {       # 3 * var * ?union[float64, {}]\n        b.field(""x"")      #     ""x"":  # 3 * var * ?union[float64, {""x"": unknown}]\n        b.integer(1)      #      1,   # 3 * var * ?union[float64, {""x"": int64}]\n        b.field(""y"")      #      ""y"": # 3 * var * ?union[float64, {""x"": int64, ""y"": unknown}]\n        b.begin_list()    #      [    # 3 * var * ?union[float64, {""x"": int64, ""y"": var * unknown}]\n        b.integer(2)      #        2, # 3 * var * ?union[float64, {""x"": int64, ""y"": var * int64}]\n        b.integer(3)      #        3  # 3 * var * ?union[float64, {""x"": int64, ""y"": var * int64}]\n        b.end_list()      #      ]    # 3 * var * ?union[float64, {""x"": int64, ""y"": var * int64}]\n        b.end_record()    #   }       # 3 * var * ?union[float64, {""x"": int64, ""y"": var * int64}]\n        b.end_list()      # ]         # 4 * var * ?union[float64, {""x"": int64, ""y"": var * int64}]\n\n    To get an array, we take a #snapshot of the ArrayBuilder\'s current state.\n\n        >>> ak.to_list(b.snapshot())\n        [[1.0, 2.0, 3.0], [], [4.0, None, 5.0], [{\'x\': 1, \'y\': [2, 3]}]]\n\n    The full set of filling commands is the following.\n\n       * #null: appends a None value.\n       * #boolean: appends True or False.\n       * #integer: appends an integer.\n       * #real: appends a floating-point value.\n       * #bytestring: appends an unencoded string (raw bytes).\n       * #string: appends a UTF-8 encoded string.\n       * #begin_list: begins filling a list; must be closed with #end_list.\n       * #end_list: ends a list.\n       * #begin_tuple: begins filling a tuple; must be closed with #end_tuple.\n       * #index: selects a tuple slot to fill; must be followed by a command\n         that actually fills that slot.\n       * #end_tuple: ends a tuple.\n       * #begin_record: begins filling a record; must be closed with\n         #end_record.\n       * #field: selects a record field to fill; must be followed by a command\n         that actually fills that field.\n       * #end_record: ends a record.\n       * #append: generic method for filling #null, #boolean, #integer, #real,\n         #bytestring, #string, #ak.Array, #ak.Record, or arbitrary Python data.\n         When filling from #ak.Array or #ak.Record, the output holds references\n         to the original data, rather than copying.\n       * #extend: appends all the items from an #ak.Array (by reference).\n       * #list: context manager for #begin_list and #end_list.\n       * #tuple: context manager for #begin_tuple and #end_tuple.\n       * #record: context manager for #begin_record and #end_record.\n\n    ArrayBuilders can be used in [Numba](http://numba.pydata.org/): they can\n    be passed as arguments to a Numba-compiled function or returned as return\n    values. (Since ArrayBuilder works by accumulating side-effects, it\'s not\n    strictly necessary to return the object.)\n\n    The primary limitation is that ArrayBuilders cannot be *created* and\n    #snapshot cannot be called inside the Numba-compiled function. Awkward\n    Array uses Numba as a transformer: #ak.Array and an empty #ak.ArrayBuilder\n    go in and a filled #ak.ArrayBuilder is the result; #snapshot can be called\n    outside of the compiled function.\n\n    Also, context managers (Python\'s `with` statement) are not supported in\n    Numba yet, so the #list, #tuple, and #record methods are not available\n    in Numba-compiled functions.\n\n    Here is an example of filling an ArrayBuilder in Numba, which makes a\n    tree of dynamic depth.\n\n        >>> import numba as nb\n        >>> @nb.njit\n        ... def deepnesting(builder, probability):\n        ...     if np.random.uniform(0, 1) > probability:\n        ...         builder.append(np.random.normal())\n        ...     else:\n        ...         builder.begin_list()\n        ...         for i in range(np.random.poisson(3)):\n        ...             deepnesting(builder, probability**2)\n        ...         builder.end_list()\n        ...\n        >>> builder = ak.ArrayBuilder()\n        >>> deepnesting(builder, 0.9)\n        >>> builder.snapshot()\n        <Array [... 1.23, -0.498, 0.272], -0.0519]]]] type=\'1 * var * var * union[var * ...\'>\n        >>> ak.to_list(builder)\n        [[[[2.052949634260401, 0.9522057655747124], [[[0.2560810133948006], 1.8668954120287653, 0.8933700720920406, 0.31709173110067773], 0.38515995466456676, -1.6259655150460695, [[0.18211022402412927], 0.46592679548320143, 0.39275072293709223], [-0.572569956850481, 1.3991748897028693, -0.15414122174138611, -0.20008742443379549]], [[[-0.7410750761192828, -0.34455689325781347], -0.8446675414135969], [-0.8139112572198548, -0.7250728258598154, -0.42851563653684244, [1.0498296931855706, 1.6969612860075955, -0.18093559189614564, 1.078608791657082]]], [[0.5172670690419124]]], [[-1.9731106633939228, 0.5778640337060391], [-1.2488533773832633, -2.1458066486349434, -0.5439318468515132, [[0.2419441207503176, -2.313974422156488, [-0.6811651539055098, 0.08323572953509818], 1.801261721511669, 0.16653718365329456], -0.6348811801078983, [0.016350096268563003, [-1.2867920376687112, 0.38205295881313484, 1.4093210810506318, -0.2698869943849985, -0.48804922126979045]]], -0.6297773736098737, -2.5333506573111424], [-1.6680144776019314, 0.5862818687707498]], [0.6266171347177766, [[-0.7660737060966999, -0.677432480564727, -1.1527197837522167], -0.5025371508398492, [0.3610998752041169, 0.4811870365139723, -0.8030689233086394, [1.1538103888031122, -1.0955905747145644], -1.3980944016010062, 1.2822990047991039]], 0.939566155023095, [1.3581048298505891, [0.36949478822799947, 1.096666130135532, -0.2769024331557954, -0.7993215902675834], [-0.4103823967097248], [0.6789480075462166, 0.8991579880810466, 0.7900472554969632]], [], [0.6772644918729233, [-0.48385354748861575, -0.39154812719778437], 1.069329510451712, 0.8057750827838897, -0.3440192823735095], [[1.5687828887524105, -1.6086288847970498, [-0.6907842744344904], -0.42627155869364414], 0.33605387861917574, -0.7329513818714791, 0.5040026160756554, -1.2529377572694538, -1.1566264096307166], [[0.6407540268295862], [-0.017540252205401917], -0.9530971110439417], [[0.41643810453893765, -0.682997865214066, 0.7930286671567052], 0.5142103949393788]], [[0.6271004836147108, [0.5895664560584991, -0.7563863809912544]], [1.6176958047983054, 0.5226854288884638, 0.24149248202497436], -1.0912185170716135, [-1.1122535648683918], 0.22727974012353094], [-0.4161362684360263, [[0.4234696267033054], 0.7866791657813567, [1.225201951430818, -0.49790730839958713, 0.2715010029532568], -0.051866117232298316]]]]\n        >>> ak.type(builder.snapshot())\n        1 * var * var * union[var * union[float64, var * union[var * union[float64, var * float64], float64]], float64]\n\n    Note that this is a *general* method for building arrays; if the type is\n    known in advance, more specialized procedures can be faster. This should\n    be considered the ""least effort"" approach.\n    """"""\n\n    def __init__(self, behavior=None, initial=1024, resize=1.5):\n        self._layout = awkward1.layout.ArrayBuilder(initial=initial, resize=resize)\n        self.behavior = behavior\n\n    @classmethod\n    def _wrap(cls, layout, behavior=None):\n        """"""\n        Args:\n            layout (#ak.layout.ArrayBuilder): Low-level builder to wrap.\n            behavior (None or dict): Custom #ak.behavior for arrays built by\n                this ArrayBuilder.\n\n        Wraps a low-level #ak.layout.ArrayBuilder as a high-level\n        #ak.ArrayBulider.\n\n        The #ak.ArrayBuilder constructor creates a new #ak.layout.ArrayBuilder\n        with no accumulated data, but Numba needs to wrap existing data\n        when returning from a lowered function.\n        """"""\n        assert isinstance(layout, awkward1.layout.ArrayBuilder)\n        out = cls.__new__(cls)\n        out._layout = layout\n        out.behavior = behavior\n        return out\n\n    @property\n    def behavior(self):\n        """"""\n        The `behavior` parameter passed into this ArrayBuilder\'s constructor.\n\n           * If a dict, this `behavior` overrides the global #ak.behavior.\n             Any keys in the global #ak.behavior but not this `behavior` are\n             still valid, but any keys in both are overridden by this\n             `behavior`. Keys with a None value are equivalent to missing keys,\n             so this `behavior` can effectively remove keys from the\n             global #ak.behavior.\n\n           * If None, the Array defaults to the global #ak.behavior.\n\n        See #ak.behavior for a list of recognized key patterns and their\n        meanings.\n        """"""\n        return self._behavior\n\n    @behavior.setter\n    def behavior(self, behavior):\n        if behavior is None or isinstance(behavior, dict):\n            self._behavior = behavior\n        else:\n            raise TypeError(""behavior must be None or a dict"")\n\n    def __len__(self):\n        """"""\n        The current length of the accumulated array.\n        """"""\n        return len(self._layout)\n\n    def __getitem__(self, where):\n        """"""\n        Args:\n            where (many types supported; see below): Index of positions to\n                select from the array.\n\n        Takes a #snapshot and selects items from the array.\n\n        See #ak.Array.__getitem__ for a more complete description.\n        """"""\n        return awkward1._util.wrap(self._layout[where], self._behavior)\n\n    def __iter__(self):\n        """"""\n        Iterates over a #snapshot of the array in Python.\n\n        See #ak.Array.__iter__ for performance considerations.\n        """"""\n        for x in self.snapshot():\n            yield x\n\n    def __str__(self, limit_value=85, snapshot=None):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the ArrayBuilder as a string.\n\n        Presents this ArrayBuilder as a string without type or\n        `""<ArrayBuilder ...>""`.\n\n        See #ak.Array.__str__ for a more complete description.\n        """"""\n        if snapshot is None:\n            snapshot = self.snapshot()\n        return snapshot.__str__(limit_value=limit_value)\n\n    def __repr__(self, limit_value=40, limit_total=85):\n        """"""\n        Args:\n            limit_value (int): Maximum number of characters to use when\n                presenting the data of the ArrayBuilder.\n            limit_total (int): Maximum number of characters to use for\n                the whole string (should be larger than `limit_value`).\n\n        Presents this ArrayBuilder as a string with its type and\n        `""<ArrayBuilder ...>""`.\n\n        See #ak.Array.__repr__ for a more complete description.\n        """"""\n        snapshot = self.snapshot()\n        value = self.__str__(limit_value=limit_value, snapshot=snapshot)\n\n        limit_type = limit_total - len(value) - len(""<ArrayBuilder  type=>"")\n        typestrs = awkward1._util.typestrs(self._behavior)\n        typestr = repr(str(snapshot.layout.type(typestrs)))\n        if len(typestr) > limit_type:\n            typestr = typestr[: (limit_type - 4)] + ""..."" + typestr[-1]\n\n        return ""<ArrayBuilder {0} type={1}>"".format(value, typestr)\n\n    def __array__(self, *args, **kwargs):\n        """"""\n        Intercepts attempts to convert a #snapshot of this array into a\n        NumPy array and either performs a zero-copy conversion or raises\n        an error.\n\n        See #ak.Array.__array__ for a more complete description.\n        """"""\n        return awkward1._connect._numpy.convert_to_array(self.snapshot(), args, kwargs)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        """"""\n        Intercepts attempts to pass this ArrayBuilder to a NumPy\n        [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html)\n        (ufuncs) and passes it through the structure of the array\'s #snapshot.\n\n        See #ak.Array.__array_ufunc__ for a more complete description.\n        """"""\n        return awkward1._connect._numpy.array_ufunc(ufunc, method, inputs, kwargs)\n\n    def __array_function__(self, func, types, args, kwargs):\n        """"""\n        Intercepts attempts to pass this ArrayBuilder to those NumPy functions\n        other than universal functions that have an Awkward equivalent.\n\n        See #ak.ArrayBuilder.__array_ufunc__ for a more complete description.\n        """"""\n        return awkward1._connect._numpy.array_function(func, types, args, kwargs)\n\n    @property\n    def numba_type(self):\n        """"""\n        The type of this Array when it is used in Numba. It contains enough\n        information to generate low-level code for accessing any element,\n        down to the leaves.\n\n        See [Numba documentation](https://numba.pydata.org/numba-doc/dev/reference/types.html)\n        on types and signatures.\n        """"""\n        import awkward1._connect._numba\n\n        awkward1._connect._numba.register_and_check()\n        import awkward1._connect._numba.builder\n\n        return awkward1._connect._numba.builder.ArrayBuilderType(self._behavior)\n\n    def snapshot(self):\n        """"""\n        Converts the currently accumulated data into an #ak.Array.\n\n        This is almost always an *O(1)* operation (does not scale with the\n        size of the accumulated data, and therefore safe to call relatively\n        often).\n\n        The resulting #ak.Array shares memory with the accumulated data (it\n        is a zero-copy operation), but it is safe to continue filling the\n        ArrayBuilder because its append-only operations only affect data\n        outside the range viewed by old snapshots. If ArrayBuilder reallocates\n        an internal buffer, the data are no longer shared, but they\'re\n        reference-counted by the #ak.Array and the #ak.ArrayBuilder, so all\n        buffers are deleted exactly once.\n        """"""\n        layout = self._layout.snapshot()\n        return awkward1._util.wrap(layout, self._behavior)\n\n    def null(self):\n        """"""\n        Appends a None value at the current position in the accumulated array.\n        """"""\n        self._layout.null()\n\n    def boolean(self, x):\n        """"""\n        Appends a boolean value `x` at the current position in the accumulated\n        array.\n        """"""\n        self._layout.boolean(x)\n\n    def integer(self, x):\n        """"""\n        Appends an integer `x` at the current position in the accumulated\n        array.\n        """"""\n        self._layout.integer(x)\n\n    def real(self, x):\n        """"""\n        Appends a floating point number `x` at the current position in the\n        accumulated array.\n        """"""\n        self._layout.real(x)\n\n    def bytestring(self, x):\n        """"""\n        Appends an unencoded string (raw bytes) `x` at the current position\n        in the accumulated array.\n        """"""\n        self._layout.bytestring(x)\n\n    def string(self, x):\n        """"""\n        Appends a UTF-8 encoded string `x` at the current position in the\n        accumulated array.\n        """"""\n        self._layout.string(x)\n\n    def begin_list(self):\n        """"""\n        Begins filling a list; must be closed with #end_list.\n\n        For example,\n\n            builder.begin_list()\n            builder.real(1.1)\n            builder.real(2.2)\n            builder.real(3.3)\n            builder.end_list()\n            builder.begin_list()\n            builder.end_list()\n            builder.begin_list()\n            builder.real(4.4)\n            builder.real(5.5)\n            builder.end_list()\n\n        produces\n\n            [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        """"""\n        self._layout.beginlist()\n\n    def end_list(self):\n        """"""\n        Ends a list.\n        """"""\n        self._layout.endlist()\n\n    def begin_tuple(self, numfields):\n        """"""\n        Begins filling a tuple with `numfields` fields; must be closed with\n        #end_tuple.\n\n        For example,\n\n            builder.begin_tuple(3)\n            builder.index(0).integer(1)\n            builder.index(1).real(1.1)\n            builder.index(2).string(""one"")\n            builder.end_tuple()\n            builder.begin_tuple(3)\n            builder.index(0).integer(2)\n            builder.index(1).real(2.2)\n            builder.index(2).string(""two"")\n            builder.end_tuple()\n\n        produces\n\n            [(1, 1.1, ""one""), (2, 2.2, ""two"")]\n        """"""\n        self._layout.begintuple(numfields)\n\n    def index(self, i):\n        """"""\n        Args:\n            i (int): The tuple slot to fill.\n\n        This method also returns the #ak.ArrayBuilder, so that it can be\n        chained with the value that fills the slot.\n\n        Prepares to fill a tuple slot; see #begin_tuple for an example.\n        """"""\n        self._layout.index(i)\n        return self\n\n    def end_tuple(self):\n        """"""\n        Ends a tuple.\n        """"""\n        self._layout.endtuple()\n\n    def begin_record(self, name=None):\n        """"""\n        Begins filling a record with an optional `name`; must be closed with\n        #end_record.\n\n        For example,\n\n            >>> builder = ak.ArrayBuilder()\n            >>> builder.begin_record(""points"")\n            >>> builder.field(""x"").real(1)\n            >>> builder.field(""y"").real(1.1)\n            >>> builder.end_record()\n            >>> builder.begin_record(""points"")\n            >>> builder.field(""x"").real(2)\n            >>> builder.field(""y"").real(2.2)\n            >>> builder.end_record()\n\n        produces\n\n            >>> ak.to_list(builder.snapshot())\n            [{""x"": 1.0, ""y"": 1.1}, {""x"": 2.0, ""y"": 2.2}]\n\n        with type\n\n            >>> ak.type(builder.snapshot())\n            2 * points[""x"": float64, ""y"": float64]\n\n        The record type is named `""points""` because its `""__record__""`\n        parameter is set to that value:\n\n            >>> builder.snapshot().layout.parameters\n            {\'__record__\': \'points\'}\n\n        The `""__record__""` parameter can be used to add behavior to the records\n        in the array, as described in #ak.Array, #ak.Record, and #ak.behavior.\n        """"""\n        self._layout.beginrecord(name)\n\n    def field(self, key):\n        """"""\n        Args:\n            key (str): The field key to fill.\n\n        This method also returns the #ak.ArrayBuilder, so that it can be\n        chained with the value that fills the slot.\n\n        Prepares to fill a field; see #begin_record for an example.\n        """"""\n        self._layout.field(key)\n        return self\n\n    def end_record(self):\n        """"""\n        Ends a record.\n        """"""\n        self._layout.endrecord()\n\n    def append(self, obj, at=None):\n        """"""\n        Args:\n            obj: The object to append.\n            at (None or int): which value to select from `obj` if `obj` is\n                an #ak.Array.\n\n        Appends any type of object, which can be a shorthand for #null,\n        #boolean, #integer, #real, #bytestring, or #string, but also\n        an #ak.Array or #ak.Record to *reference* values from an existing\n        dataset, or any Python object to *convert* to Awkward Array.\n\n        If `obj` is an #ak.Array or #ak.Record, the output will be an\n        #ak.layout.IndexedArray64 (or #ak.layout.IndexedOptionArray64 if\n        there are any None values) that references the existing data. This\n        can be a more time and memory-efficient way to put old data in a\n        new structure, since it avoids copying and even walking over the\n        old data structure (matters more when the structures are large).\n\n        If `obj` is an arbitrary Python object, this is equivalent to\n        #ak.from_iter except that it fills an existing #ak.ArrayBuilder,\n        rather than creating a new one.\n\n        If `obj` is an #ak.Array and `at` is an int, this method fills the\n        ArrayBuilder with a reference to `obj[at]` instead of `obj`.\n        """"""\n        if at is None:\n            if isinstance(obj, Record):\n                self._layout.append(obj.layout.array, obj.layout.at)\n            elif isinstance(obj, Array):\n                self._layout.extend(obj.layout)\n            else:\n                self._layout.fromiter(obj)\n\n        else:\n            if isinstance(obj, Array):\n                self._layout.append(obj.layout, at)\n            else:\n                raise TypeError(\n                    ""\'append\' method can only be used with \'at\' when ""\n                    ""\'obj\' is an ak.Array""\n                )\n\n    def extend(self, obj):\n        """"""\n        Args:\n            obj (#ak.Array): The Array to concatenate with the data in this\n                ArrayBuilder.\n\n        Appends every value from `obj`, by reference (see #append).\n        """"""\n        if isinstance(obj, Array):\n            self._layout.extend(obj.layout)\n        else:\n            raise TypeError(""\'extend\' method requires an ak.Array"")\n\n    class _Nested(object):\n        def __init__(self, arraybuilder):\n            self._arraybuilder = arraybuilder\n\n        def __repr__(self, limit_value=40, limit_total=85):\n            snapshot = self._arraybuilder.snapshot()\n            value = self._arraybuilder.__str__(\n                limit_value=limit_value, snapshot=snapshot\n            )\n\n            limit_type = (\n                limit_total\n                - len(value)\n                - len(""<ArrayBuilder.  type=>"")\n                - len(self._name)\n            )\n            typestrs = awkward1._util.typestrs(self._arraybuilder._behavior)\n            typestr = repr(str(snapshot.layout.type(typestrs)))\n            if len(typestr) > limit_type:\n                typestr = typestr[: (limit_type - 4)] + ""..."" + typestr[-1]\n\n            return ""<ArrayBuilder.{0} {1} type={2}>"".format(self._name, value, typestr)\n\n    class List(_Nested):\n        _name = ""list""\n\n        def __enter__(self):\n            self._arraybuilder.begin_list()\n\n        def __exit__(self, type, value, traceback):\n            self._arraybuilder.end_list()\n\n    def list(self):\n        """"""\n        Context manager to prevent unpaired #begin_list and #end_list. The\n        example in the #begin_list documentation can be rewritten as\n\n            with builder.list():\n                builder.real(1.1)\n                builder.real(2.2)\n                builder.real(3.3)\n            with builder.list():\n                pass\n            with builder.list():\n                builder.real(4.4)\n                builder.real(5.5)\n\n        to produce the same result.\n\n            [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n\n        Since context managers aren\'t yet suppored by Numba, this method\n        can\'t be used in Numba.\n        """"""\n        return self.List(self)\n\n    class Tuple(_Nested):\n        _name = ""tuple""\n\n        def __init__(self, arraybuilder, numfields):\n            super(ArrayBuilder.Tuple, self).__init__(arraybuilder)\n            self._numfields = numfields\n\n        def __enter__(self):\n            self._arraybuilder.begin_tuple(self._numfields)\n\n        def __exit__(self, type, value, traceback):\n            self._arraybuilder.end_tuple()\n\n    def tuple(self, numfields):\n        """"""\n        Context manager to prevent unpaired #begin_tuple and #end_tuple. The\n        example in the #begin_tuple documentation can be rewritten as\n\n            with builder.tuple(3):\n                builder.index(0).integer(1)\n                builder.index(1).real(1.1)\n                builder.index(2).string(""one"")\n            with builder.tuple(3):\n                builder.index(0).integer(2)\n                builder.index(1).real(2.2)\n                builder.index(2).string(""two"")\n\n        to produce the same result.\n\n            [(1, 1.1, ""one""), (2, 2.2, ""two"")]\n\n        Since context managers aren\'t yet suppored by Numba, this method\n        can\'t be used in Numba.\n        """"""\n        return self.Tuple(self, numfields)\n\n    class Record(_Nested):\n        _name = ""record""\n\n        def __init__(self, arraybuilder, name):\n            super(ArrayBuilder.Record, self).__init__(arraybuilder)\n            self._name = name\n\n        def __enter__(self):\n            self._arraybuilder.begin_record(name=self._name)\n\n        def __exit__(self, type, value, traceback):\n            self._arraybuilder.end_record()\n\n    def record(self, name=None):\n        """"""\n        Context manager to prevent unpaired #begin_record and #end_record. The\n        example in the #begin_record documentation can be rewritten as\n\n            with builder.record(""points""):\n                builder.field(""x"").real(1)\n                builder.field(""y"").real(1.1)\n            with builder.record(""points""):\n                builder.field(""x"").real(2)\n                builder.field(""y"").real(2.2)\n\n        to produce the same result.\n\n            [{""x"": 1.0, ""y"": 1.1}, {""x"": 2.0, ""y"": 2.2}]\n\n        Since context managers aren\'t yet suppored by Numba, this method\n        can\'t be used in Numba.\n        """"""\n        return self.Record(self, name)\n'"
src/awkward1/operations/convert.py,9,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport numbers\nimport json\nimport collections\nimport math\n\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward1.layout\nimport awkward1._ext\nimport awkward1._util\n\n\ndef from_numpy(array, regulararray=False, highlevel=True, behavior=None):\n    """"""\n    Args:\n        array (np.ndarray): The NumPy array to convert into an Awkward Array.\n            This array can be a np.ma.MaskedArray.\n        regulararray (bool): If True and the array is multidimensional,\n            the dimensions are represented by nested #ak.layout.RegularArray\n            nodes; if False and the array is multidimensional, the dimensions\n            are represented by a multivalued #ak.layout.NumpyArray.shape.\n            If the array is one-dimensional, this has no effect.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n\n    Converts a NumPy array into an Awkward Array.\n\n    The resulting layout may involve the following #ak.layout.Content types\n    (only):\n\n       * #ak.layout.NumpyArray\n       * #ak.layout.ByteMaskedArray or #ak.layout.UnmaskedArray if the\n         `array` is an np.ma.MaskedArray.\n       * #ak.layout.RegularArray if `regulararray=True`.\n\n    See also #ak.to_numpy.\n    """"""\n\n    def recurse(array, mask):\n        if regulararray and len(array.shape) > 1:\n            return awkward1.layout.RegularArray(\n                recurse(array.reshape((-1,) + array.shape[2:]), mask), array.shape[1]\n            )\n\n        if len(array.shape) == 0:\n            data = awkward1.layout.NumpyArray(array.reshape(1))\n        else:\n            data = awkward1.layout.NumpyArray(array)\n\n        if mask is None:\n            return data\n        elif mask is False:\n            # NumPy\'s MaskedArray with mask == False is an UnmaskedArray\n            return awkward1.layout.UnmaskedArray(data)\n        else:\n            # NumPy\'s MaskedArray is a ByteMaskedArray with valid_when=False\n            return awkward1.layout.ByteMaskedArray(\n                awkward1.layout.Index8(mask), data, valid_when=False\n            )\n\n    if isinstance(array, numpy.ma.MaskedArray):\n        mask = numpy.ma.getmask(array)\n        array = numpy.ma.getdata(array)\n        if isinstance(mask, numpy.ndarray) and len(mask.shape) > 1:\n            regulararray = True\n            mask = mask.reshape(-1)\n    else:\n        mask = None\n\n    layout = recurse(array, mask)\n    if highlevel:\n        return awkward1._util.wrap(layout, behavior)\n    else:\n        return layout\n\n\ndef to_numpy(array, allow_missing=True):\n    """"""\n    Converts `array` (many types supported, including all Awkward Arrays and\n    Records) into a NumPy array, if possible.\n\n    If the data are numerical and regular (nested lists have equal lengths\n    in each dimension, as described by the #type), they can be losslessly\n    converted to a NumPy array and this function returns without an error.\n\n    Otherwise, the function raises an error. It does not create a NumPy\n    array with dtype `""O""` for `np.object_` (see the\n    [note on object_ type](https://docs.scipy.org/doc/numpy/reference/arrays.scalars.html#arrays-scalars-built-in))\n    since silent conversions to dtype `""O""` arrays would not only be a\n    significant performance hit, but would also break functionality, since\n    nested lists in a NumPy `""O""` array are severed from the array and\n    cannot be sliced as dimensions.\n\n    If `array` is a scalar, it is converted into a NumPy scalar.\n\n    If `allow_missing` is True; NumPy\n    [masked arrays](https://docs.scipy.org/doc/numpy/reference/maskedarray.html)\n    are a possible result; otherwise, missing values (None) cause this\n    function to raise an error.\n\n    See also #ak.from_numpy.\n    """"""\n    import awkward1.highlevel\n\n    if isinstance(array, (bool, str, bytes, numbers.Number)):\n        return numpy.array([array])[0]\n\n    elif awkward1._util.py27 and isinstance(array, awkward1._util.unicode):\n        return numpy.array([array])[0]\n\n    elif isinstance(array, numpy.ndarray):\n        return array\n\n    elif isinstance(array, awkward1.highlevel.Array):\n        return to_numpy(array.layout, allow_missing=allow_missing)\n\n    elif isinstance(array, awkward1.highlevel.Record):\n        out = array.layout\n        return to_numpy(out.array[out.at : out.at + 1], allow_missing=allow_missing)[0]\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return to_numpy(array.snapshot().layout, allow_missing=allow_missing)\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return to_numpy(array.snapshot(), allow_missing=allow_missing)\n\n    elif (\n        awkward1.operations.describe.parameters(array).get(""__array__"") == ""bytestring""\n    ):\n        return numpy.array(\n            [\n                awkward1.behaviors.string.ByteBehavior(array[i]).__bytes__()\n                for i in range(len(array))\n            ]\n        )\n\n    elif awkward1.operations.describe.parameters(array).get(""__array__"") == ""string"":\n        return numpy.array(\n            [\n                awkward1.behaviors.string.CharBehavior(array[i]).__str__()\n                for i in range(len(array))\n            ]\n        )\n\n    elif isinstance(array, awkward1.partition.PartitionedArray):\n        tocat = [to_numpy(x, allow_missing=allow_missing) for x in array.partitions]\n        if any(isinstance(x, numpy.ma.MaskedArray) for x in tocat):\n            return numpy.ma.concatenate(tocat)\n        else:\n            return numpy.concatenate(tocat)\n\n    elif isinstance(array, awkward1._util.virtualtypes):\n        return to_numpy(array.array, allow_missing=True)\n\n    elif isinstance(array, awkward1._util.unknowntypes):\n        return numpy.array([])\n\n    elif isinstance(array, awkward1._util.indexedtypes):\n        return to_numpy(array.project(), allow_missing=allow_missing)\n\n    elif isinstance(array, awkward1._util.uniontypes):\n        contents = [\n            to_numpy(array.project(i), allow_missing=allow_missing)\n            for i in range(array.numcontents)\n        ]\n\n        if any(isinstance(x, numpy.ma.MaskedArray) for x in contents):\n            try:\n                out = numpy.ma.concatenate(contents)\n            except Exception:\n                raise ValueError(\n                    ""cannot convert {0} into numpy.ma.MaskedArray"".format(array)\n                )\n        else:\n            try:\n                out = numpy.concatenate(contents)\n            except Exception:\n                raise ValueError(""cannot convert {0} into numpy.ndarray"".format(array))\n\n        tags = numpy.asarray(array.tags)\n        for tag, content in enumerate(contents):\n            mask = tags == tag\n            out[mask] = content\n        return out\n\n    elif isinstance(array, awkward1.layout.UnmaskedArray):\n        content = to_numpy(array.content, allow_missing=allow_missing)\n        if allow_missing:\n            return numpy.ma.MaskedArray(content)\n        else:\n            return content\n\n    elif isinstance(array, awkward1._util.optiontypes):\n        content = to_numpy(array.project(), allow_missing=allow_missing)\n        shape = list(content.shape)\n        shape[0] = len(array)\n        data = numpy.empty(shape, dtype=content.dtype)\n        mask0 = numpy.asarray(array.bytemask()).view(numpy.bool_)\n        if mask0.any():\n            if allow_missing:\n                mask = numpy.broadcast_to(\n                    mask0.reshape((shape[0],) + (1,) * (len(shape) - 1)), shape\n                )\n                data[~mask0] = content\n                return numpy.ma.MaskedArray(data, mask)\n            else:\n                raise ValueError(\n                    ""to_numpy cannot convert \'None\' values to ""\n                    ""np.ma.MaskedArray unless the ""\n                    ""\'allow_missing\' parameter is set to True""\n                )\n        else:\n            if allow_missing:\n                return numpy.ma.MaskedArray(content)\n            else:\n                return content\n\n    elif isinstance(array, awkward1.layout.RegularArray):\n        out = to_numpy(array.content, allow_missing=allow_missing)\n        head, tail = out.shape[0], out.shape[1:]\n        shape = (head // array.size, array.size) + tail\n        return out[: shape[0] * array.size].reshape(shape)\n\n    elif isinstance(array, awkward1._util.listtypes):\n        return to_numpy(array.toRegularArray(), allow_missing=allow_missing)\n\n    elif isinstance(array, awkward1._util.recordtypes):\n        if array.numfields == 0:\n            return numpy.empty(len(array), dtype=[])\n        contents = [\n            to_numpy(array.field(i), allow_missing=allow_missing)\n            for i in range(array.numfields)\n        ]\n        if any(len(x.shape) != 1 for x in contents):\n            raise ValueError(""cannot convert {0} into numpy.ndarray"".format(array))\n        out = numpy.empty(\n            len(contents[0]),\n            dtype=[(str(n), x.dtype) for n, x in zip(array.keys(), contents)],\n        )\n        for n, x in zip(array.keys(), contents):\n            out[n] = x\n        return out\n\n    elif isinstance(array, awkward1.layout.NumpyArray):\n        return numpy.asarray(array)\n\n    elif isinstance(array, awkward1.layout.Content):\n        raise AssertionError(""unrecognized Content type: {0}"".format(type(array)))\n\n    elif isinstance(array, Iterable):\n        return numpy.asarray(array)\n\n    else:\n        raise ValueError(""cannot convert {0} into numpy.ndarray"".format(array))\n\n\ndef from_iter(\n    iterable, highlevel=True, behavior=None, allow_record=True, initial=1024, resize=1.5\n):\n    """"""\n    Args:\n        iterable (Python iterable): Data to convert into an Awkward Array.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n        allow_record (bool): If True, the outermost element may be a record\n            (returning #ak.Record or #ak.layout.Record type, depending on\n            `highlevel`); if False, the outermost element must be an array.\n        initial (int): Initial size (in bytes) of buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions).\n        resize (float): Resize multiplier for buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions);\n            should be strictly greater than 1.\n\n    Converts Python data into an Awkward Array.\n\n    Internally, this function uses #ak.layout.ArrayBuilder (see the high-level\n    #ak.ArrayBuilder documentation for a more complete description), so it\n    has the same flexibility and the same constraints. Any heterogeneous\n    and deeply nested Python data can be converted, but the output will never\n    have regular-typed array lengths.\n\n    The following Python types are supported.\n\n       * bool, including `np.bool_`: converted into #ak.layout.NumpyArray.\n       * int, including `np.integer`: converted into #ak.layout.NumpyArray.\n       * float, including `np.floating`: converted into #ak.layout.NumpyArray.\n       * bytes: converted into #ak.layout.ListOffsetArray with parameter\n         `""__array__""` equal to `""bytestring""` (unencoded bytes).\n       * str: converted into #ak.layout.ListOffsetArray with parameter\n         `""__array__""` equal to `""string""` (UTF-8 encoded string).\n       * tuple: converted into #ak.layout.RecordArray without field names\n         (i.e. homogeneously typed, uniform sized tuples).\n       * dict: converted into #ak.layout.RecordArray with field names\n         (i.e. homogeneously typed records with the same sets of fields).\n       * iterable, including np.ndarray: converted into\n         #ak.layout.ListOffsetArray.\n\n    See also #ak.to_list.\n    """"""\n    if isinstance(iterable, dict):\n        if allow_record:\n            return from_iter(\n                [iterable],\n                highlevel=highlevel,\n                behavior=behavior,\n                initial=initial,\n                resize=resize,\n            )[0]\n        else:\n            raise ValueError(""cannot produce an array from a dict"")\n    out = awkward1.layout.ArrayBuilder(initial=initial, resize=resize)\n    for x in iterable:\n        out.fromiter(x)\n    layout = out.snapshot()\n    if highlevel:\n        return awkward1._util.wrap(layout, behavior)\n    else:\n        return layout\n\n\ndef to_list(array):\n    """"""\n    Converts `array` (many types supported, including all Awkward Arrays and\n    Records) into Python objects.\n\n    Awkward Array types have the following Pythonic translations.\n\n       * #ak.types.PrimitiveType: converted into bool, int, float.\n       * #ak.types.OptionType: missing values are converted into None.\n       * #ak.types.ListType: converted into list.\n       * #ak.types.RegularType: also converted into list. Python (and JSON)\n         forms lose information about the regularity of list lengths.\n       * #ak.types.ListType with parameter `""__array__""` equal to\n         `""__bytestring__""`: converted into bytes.\n       * #ak.types.ListType with parameter `""__array__""` equal to\n         `""__string__""`: converted into str.\n       * #ak.types.RecordArray without field names: converted into tuple.\n       * #ak.types.RecordArray with field names: converted into dict.\n       * #ak.types.UnionArray: Python data are naturally heterogeneous.\n\n    See also #ak.from_iter and #ak.Array.tolist.\n    """"""\n    import awkward1.highlevel\n\n    if array is None or isinstance(array, (bool, str, bytes, numbers.Number)):\n        return array\n\n    elif awkward1._util.py27 and isinstance(array, awkward1._util.unicode):\n        return array\n\n    elif isinstance(array, numpy.ndarray):\n        return array.tolist()\n\n    elif isinstance(array, awkward1.behaviors.string.ByteBehavior):\n        return array.__bytes__()\n\n    elif isinstance(array, awkward1.behaviors.string.CharBehavior):\n        return array.__str__()\n\n    elif awkward1.operations.describe.parameters(array).get(""__array__"") == ""byte"":\n        return awkward1.behaviors.string.CharBehavior(array).__bytes__()\n\n    elif awkward1.operations.describe.parameters(array).get(""__array__"") == ""char"":\n        return awkward1.behaviors.string.CharBehavior(array).__str__()\n\n    elif isinstance(array, awkward1.highlevel.Array):\n        return [to_list(x) for x in array]\n\n    elif isinstance(array, awkward1.highlevel.Record):\n        return to_list(array.layout)\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return to_list(array.snapshot())\n\n    elif isinstance(array, awkward1.layout.Record) and array.istuple:\n        return tuple(to_list(x) for x in array.fields())\n\n    elif isinstance(array, awkward1.layout.Record):\n        return {n: to_list(x) for n, x in array.fielditems()}\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return [to_list(x) for x in array.snapshot()]\n\n    elif isinstance(array, awkward1.layout.NumpyArray):\n        return numpy.asarray(array).tolist()\n\n    elif isinstance(\n        array, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n    ):\n        return [to_list(x) for x in array]\n\n    elif isinstance(array, dict):\n        return dict((n, to_list(x)) for n, x in array.items())\n\n    elif isinstance(array, Iterable):\n        return [to_list(x) for x in array]\n\n    else:\n        raise TypeError(""unrecognized array type: {0}"".format(type(array)))\n\n\ndef from_json(\n    source, highlevel=True, behavior=None, initial=1024, resize=1.5, buffersize=65536\n):\n    """"""\n    Args:\n        source (str): JSON-formatted string to convert into an array.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n        initial (int): Initial size (in bytes) of buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions).\n        resize (float): Resize multiplier for buffers used by\n            #ak.layout.ArrayBuilder (see #ak.layout.ArrayBuilderOptions);\n            should be strictly greater than 1.\n        buffersize (int): Size (in bytes) of the buffer used by the JSON\n            parser.\n\n    Converts a JSON string into an Awkward Array.\n\n    Internally, this function uses #ak.layout.ArrayBuilder (see the high-level\n    #ak.ArrayBuilder documentation for a more complete description), so it\n    has the same flexibility and the same constraints. Any heterogeneous\n    and deeply nested JSON can be converted, but the output will never have\n    regular-typed array lengths.\n\n    See also #ak.to_json.\n    """"""\n    layout = awkward1._ext.fromjson(\n        source, initial=initial, resize=resize, buffersize=buffersize\n    )\n    if highlevel:\n        return awkward1._util.wrap(layout, behavior)\n    else:\n        return layout\n\n\ndef to_json(array, destination=None, pretty=False, maxdecimals=None, buffersize=65536):\n    """"""\n    Args:\n        array: Data to convert to JSON.\n        destination (None or str): If None, this function returns a JSON str;\n            if a str, it uses that as a file name and writes (overwrites) that\n            file (returning None).\n        pretty (bool): If True, indent the output for human readability; if\n            False, output compact JSON without spaces.\n        maxdecimals (None or int): If an int, limit the number of\n            floating-point decimals to this number; if None, write all digits.\n        buffersize (int): Size (in bytes) of the buffer used by the JSON\n            parser.\n\n    Converts `array` (many types supported, including all Awkward Arrays and\n    Records) into a JSON string or file.\n\n    Awkward Array types have the following JSON translations.\n\n       * #ak.types.PrimitiveType: converted into JSON booleans and numbers.\n       * #ak.types.OptionType: missing values are converted into None.\n       * #ak.types.ListType: converted into JSON lists.\n       * #ak.types.RegularType: also converted into JSON lists. JSON (and\n         Python) forms lose information about the regularity of list lengths.\n       * #ak.types.ListType with parameter `""__array__""` equal to\n         `""__bytestring__""` or `""__string__""`: converted into JSON strings.\n       * #ak.types.RecordArray without field names: converted into JSON\n         objects with numbers as strings for keys.\n       * #ak.types.RecordArray with field names: converted into JSON objects.\n       * #ak.types.UnionArray: JSON data are naturally heterogeneous.\n\n    See also #ak.from_json and #ak.Array.tojson.\n    """"""\n    import awkward1.highlevel\n\n    if array is None or isinstance(array, (bool, str, bytes, numbers.Number)):\n        return json.dumps(array)\n\n    elif isinstance(array, bytes):\n        return json.dumps(array.decode(""utf-8"", ""surrogateescape""))\n\n    elif awkward1._util.py27 and isinstance(array, awkward1._util.unicode):\n        return json.dumps(array)\n\n    elif isinstance(array, numpy.ndarray):\n        out = awkward1.layout.NumpyArray(array)\n\n    elif isinstance(array, awkward1.highlevel.Array):\n        out = array.layout\n\n    elif isinstance(array, awkward1.highlevel.Record):\n        out = array.layout\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        out = array.snapshot().layout\n\n    elif isinstance(array, awkward1.layout.Record):\n        out = array\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        out = array.snapshot()\n\n    elif isinstance(\n        array, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n    ):\n        out = array\n\n    else:\n        raise TypeError(""unrecognized array type: {0}"".format(repr(array)))\n\n    if destination is None:\n        return out.tojson(pretty=pretty, maxdecimals=maxdecimals)\n    else:\n        return out.tojson(\n            destination, pretty=pretty, maxdecimals=maxdecimals, buffersize=buffersize\n        )\n\n\ndef from_awkward0(\n    array, keeplayout=False, regulararray=False, highlevel=True, behavior=None\n):\n    """"""\n    Args:\n        array (Awkward 0.x or Awkward 1.x array): Data to convert to Awkward\n            1.x.\n        keeplayout (bool): If True, stay true to the Awkward 0.x layout,\n            ensuring zero-copy; otherwise, allow transformations that copy\n            data for more flexibility.\n        regulararray (bool): If True and the array is multidimensional,\n            the dimensions are represented by nested #ak.layout.RegularArray\n            nodes; if False and the array is multidimensional, the dimensions\n            are represented by a multivalued #ak.layout.NumpyArray.shape.\n            If the array is one-dimensional, this has no effect.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n\n    Converts an array from Awkward 0.x to Awkward 1.x.\n\n    This is only needed during the transition from the old library to the\n    new library.\n\n    If `array` is already an Awkward 1.x Array, it is simply passed through\n    this function (so that interfaces that scripts don\'t need to remove this\n    function when their 0.x sources are replaced by 1.x).\n    """"""\n    # See https://github.com/scikit-hep/awkward-0.x/blob/405b7eaeea51b60947a79c782b1abf0d72f6729b/specification.adoc\n    import awkward as awkward0\n\n    # If a source of Awkward0 arrays ever starts emitting Awkward1 arrays\n    # (e.g. Uproot), this function turns into a pass-through.\n    if isinstance(array, (awkward1.highlevel.Array, awkward1.highlevel.Record)):\n        if highlevel:\n            return array\n        else:\n            return array.layout\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        if highlevel:\n            return array.snapshot()\n        else:\n            return array._layout.snapshot()\n    elif isinstance(array, (awkward1.layout.Content, awkward1.layout.Record)):\n        if highlevel:\n            return awkward1._util.wrap(array, behavior)\n        else:\n            return array\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        if highlevel:\n            return awkward1._util.wrap(array.snapshot(), behavior)\n        else:\n            return array.snapshot()\n\n    def recurse(array, level):\n        if isinstance(array, dict):\n            keys = []\n            values = []\n            for n, x in array.items():\n                keys.append(n)\n                if isinstance(\n                    x,\n                    (\n                        dict,\n                        tuple,\n                        numpy.ma.MaskedArray,\n                        numpy.ndarray,\n                        awkward0.array.base.AwkwardArray,\n                    ),\n                ):\n                    values.append(recurse(x, level + 1)[numpy.newaxis])\n                else:\n                    values.append(awkward1.layout.NumpyArray(numpy.array([x])))\n            return awkward1.layout.RecordArray(values, keys)[0]\n\n        elif isinstance(array, tuple):\n            values = []\n            for x in array:\n                if isinstance(\n                    x,\n                    (\n                        dict,\n                        tuple,\n                        numpy.ma.MaskedArray,\n                        numpy.ndarray,\n                        awkward0.array.base.AwkwardArray,\n                    ),\n                ):\n                    values.append(recurse(x, level + 1)[numpy.newaxis])\n                else:\n                    values.append(awkward1.layout.NumpyArray(numpy.array([x])))\n            return awkward1.layout.RecordArray(values)[0]\n\n        elif isinstance(array, numpy.ma.MaskedArray):\n            return from_numpy(array, regulararray=regulararray, highlevel=False)\n\n        elif isinstance(array, numpy.ndarray):\n            return from_numpy(array, regulararray=regulararray, highlevel=False)\n\n        elif isinstance(array, awkward0.JaggedArray):\n            # starts, stops, content\n            # offsetsaliased(starts, stops)\n            startsmax = numpy.iinfo(array.starts.dtype.type).max\n            stopsmax = numpy.iinfo(array.stops.dtype.type).max\n            if (\n                len(array.starts.shape) == 1\n                and len(array.stops.shape) == 1\n                and awkward0.JaggedArray.offsetsaliased(array.starts, array.stops)\n            ):\n                if startsmax >= from_awkward0.int64max:\n                    offsets = awkward1.layout.Index64(array.offsets)\n                    return awkward1.layout.ListOffsetArray64(\n                        offsets, recurse(array.content, level + 1)\n                    )\n                elif startsmax >= from_awkward0.uint32max:\n                    offsets = awkward1.layout.IndexU32(array.offsets)\n                    return awkward1.layout.ListOffsetArrayU32(\n                        offsets, recurse(array.content, level + 1)\n                    )\n                else:\n                    offsets = awkward1.layout.Index32(array.offsets)\n                    return awkward1.layout.ListOffsetArray32(\n                        offsets, recurse(array.content, level + 1)\n                    )\n\n            else:\n                if (\n                    startsmax >= from_awkward0.int64max\n                    or stopsmax >= from_awkward0.int64max\n                ):\n                    starts = awkward1.layout.Index64(array.starts.reshape(-1))\n                    stops = awkward1.layout.Index64(array.stops.reshape(-1))\n                    out = awkward1.layout.ListArray64(\n                        starts, stops, recurse(array.content, level + 1)\n                    )\n                elif (\n                    startsmax >= from_awkward0.uint32max\n                    or stopsmax >= from_awkward0.uint32max\n                ):\n                    starts = awkward1.layout.IndexU32(array.starts.reshape(-1))\n                    stops = awkward1.layout.IndexU32(array.stops.reshape(-1))\n                    out = awkward1.layout.ListArrayU32(\n                        starts, stops, recurse(array.content, level + 1)\n                    )\n                else:\n                    starts = awkward1.layout.Index32(array.starts.reshape(-1))\n                    stops = awkward1.layout.Index32(array.stops.reshape(-1))\n                    out = awkward1.layout.ListArray32(\n                        starts, stops, recurse(array.content, level + 1)\n                    )\n                for size in array.starts.shape[:0:-1]:\n                    out = awkward1.layout.RegularArray(out, size)\n                return out\n\n        elif isinstance(array, awkward0.Table):\n            # contents\n            if array.istuple:\n                return awkward1.layout.RecordArray(\n                    [recurse(x, level + 1) for x in array.contents.values()]\n                )\n            else:\n                keys = []\n                values = []\n                for n, x in array.contents.items():\n                    keys.append(n)\n                    values.append(recurse(x, level + 1))\n                return awkward1.layout.RecordArray(values, keys)\n\n        elif isinstance(array, awkward0.UnionArray):\n            # tags, index, contents\n            indexmax = numpy.iinfo(array.index.dtype.type).max\n            if indexmax >= from_awkward0.int64max:\n                tags = awkward1.layout.Index8(array.tags.reshape(-1))\n                index = awkward1.layout.Index64(array.index.reshape(-1))\n                out = awkward1.layout.UnionArray8_64(\n                    tags, index, [recurse(x, level + 1) for x in array.contents]\n                )\n            elif indexmax >= from_awkward0.uint32max:\n                tags = awkward1.layout.Index8(array.tags.reshape(-1))\n                index = awkward1.layout.IndexU32(array.index.reshape(-1))\n                out = awkward1.layout.UnionArray8_U32(\n                    tags, index, [recurse(x, level + 1) for x in array.contents]\n                )\n            else:\n                tags = awkward1.layout.Index8(array.tags.reshape(-1))\n                index = awkward1.layout.Index32(array.index.reshape(-1))\n                out = awkward1.layout.UnionArray8_32(\n                    tags, index, [recurse(x, level + 1) for x in array.contents]\n                )\n\n            for size in array.tags.shape[:0:-1]:\n                out = awkward1.layout.RegularArray(out, size)\n            return out\n\n        elif isinstance(array, awkward0.MaskedArray):\n            # mask, content, maskedwhen\n            mask = awkward1.layout.Index8(array.mask.view(numpy.int8).reshape(-1))\n            out = awkward1.layout.ByteMaskedArray(\n                mask,\n                recurse(array.content, level + 1),\n                valid_when=(not array.maskedwhen),\n            )\n            for size in array.mask.shape[:0:-1]:\n                out = awkward1.layout.RegularArray(out, size)\n            return out\n\n        elif isinstance(array, awkward0.BitMaskedArray):\n            # mask, content, maskedwhen, lsborder\n            mask = awkward1.layout.IndexU8(array.mask.view(numpy.uint8))\n            return awkward1.layout.BitMaskedArray(\n                mask,\n                recurse(array.content, level + 1),\n                valid_when=(not array.maskedwhen),\n                length=len(array.content),\n                lsb_order=array.lsborder,\n            )\n\n        elif isinstance(array, awkward0.IndexedMaskedArray):\n            # mask, content, maskedwhen\n            indexmax = numpy.iinfo(array.index.dtype.type).max\n            if indexmax >= from_awkward0.int64max:\n                index = awkward1.layout.Index64(array.index.reshape(-1))\n                out = awkward1.layout.IndexedOptionArray64(\n                    index, recurse(array.content, level + 1)\n                )\n            elif indexmax >= from_awkward0.uint32max:\n                index = awkward1.layout.IndexU32(array.index.reshape(-1))\n                out = awkward1.layout.IndexedOptionArrayU32(\n                    index, recurse(array.content, level + 1)\n                )\n            else:\n                index = awkward1.layout.Index32(array.index.reshape(-1))\n                out = awkward1.layout.IndexedOptionArray32(\n                    index, recurse(array.content, level + 1)\n                )\n\n            for size in array.tags.shape[:0:-1]:\n                out = awkward1.layout.RegularArray(out, size)\n            return out\n\n        elif isinstance(array, awkward0.IndexedArray):\n            # index, content\n            indexmax = numpy.iinfo(array.index.dtype.type).max\n            if indexmax >= from_awkward0.int64max:\n                index = awkward1.layout.Index64(array.index.reshape(-1))\n                out = awkward1.layout.IndexedArray64(\n                    index, recurse(array.content, level + 1)\n                )\n            elif indexmax >= from_awkward0.uint32max:\n                index = awkward1.layout.IndexU32(array.index.reshape(-1))\n                out = awkward1.layout.IndexedArrayU32(\n                    index, recurse(array.content, level + 1)\n                )\n            else:\n                index = awkward1.layout.Index32(array.index.reshape(-1))\n                out = awkward1.layout.IndexedArray32(\n                    index, recurse(array.content, level + 1)\n                )\n\n            for size in array.tags.shape[:0:-1]:\n                out = awkward1.layout.RegularArray(out, size)\n            return out\n\n        elif isinstance(array, awkward0.SparseArray):\n            # length, index, content, default\n            if keeplayout:\n                raise ValueError(\n                    ""awkward1.SparseArray hasn\'t been written (if at all); ""\n                    ""try keeplayout=False""\n                )\n            return recurse(array.dense, level + 1)\n\n        elif isinstance(array, awkward0.StringArray):\n            # starts, stops, content, encoding\n            out = recurse(array._content, level + 1)\n            if array.encoding is None:\n                out.content.setparameter(""__array__"", ""byte"")\n                out.setparameter(""__array__"", ""bytestring"")\n            elif array.encoding == ""utf-8"":\n                out.content.setparameter(""__array__"", ""char"")\n                out.setparameter(""__array__"", ""string"")\n            else:\n                raise ValueError(\n                    ""unsupported encoding: {0}"".format(repr(array.encoding))\n                )\n            return out\n\n        elif isinstance(array, awkward0.ObjectArray):\n            # content, generator, args, kwargs\n            if keeplayout:\n                raise ValueError(\n                    ""there isn\'t (and won\'t ever be) an awkward1 equivalent ""\n                    ""of awkward0.ObjectArray; try keeplayout=False""\n                )\n            out = recurse(array.content, level + 1)\n            out.setparameter(\n                ""__record__"",\n                getattr(\n                    array.generator,\n                    ""__qualname__"",\n                    getattr(array.generator, ""__name__"", repr(array.generator)),\n                ),\n            )\n            return out\n\n        if isinstance(array, awkward0.ChunkedArray):\n            # chunks, chunksizes\n            if keeplayout and level != 0:\n                raise ValueError(\n                    ""awkward1 PartitionedArrays are only allowed ""\n                    ""at the root of a data structure, unlike ""\n                    ""awkward0.ChunkedArray; try keeplayout=False""\n                )\n            elif level == 0:\n                return awkward1.partition.IrregularlyPartitionedArray(\n                    [recurse(x, level + 1) for x in array.chunks]\n                )\n            else:\n                return awkward1.operations.structure.concatenate(\n                    [recurse(x, level + 1) for x in array.chunks], highlevel=False\n                )\n\n        elif isinstance(array, awkward0.AppendableArray):\n            # chunkshape, dtype, chunks\n            raise ValueError(\n                ""the awkward1 equivalent of awkward0.AppendableArray is ""\n                ""awkward1.ArrayBuilder, but it is not a Content type, not ""\n                ""mixable with immutable array elements""\n            )\n\n        elif isinstance(array, awkward0.VirtualArray):\n            # generator, args, kwargs, cache, persistentkey, type, nbytes, persistvirtual\n            if keeplayout:\n                raise NotImplementedError(""FIXME"")\n            else:\n                return recurse(array.array, level + 1)\n\n        else:\n            raise TypeError(""not an awkward0 array: {0}"".format(repr(array)))\n\n    out = recurse(array, 0)\n    if highlevel:\n        return awkward1._util.wrap(out, behavior)\n    else:\n        return out\n\n\nfrom_awkward0.int8max = numpy.iinfo(numpy.int8).max\nfrom_awkward0.int32max = numpy.iinfo(numpy.int32).max\nfrom_awkward0.uint32max = numpy.iinfo(numpy.uint32).max\nfrom_awkward0.int64max = numpy.iinfo(numpy.int64).max\n\n\ndef to_awkward0(array, keeplayout=False):\n    """"""\n    Args:\n        array: Data to convert into an Awkward 0.x array.\n        keeplayout (bool): If True, stay true to the Awkward 1.x layout,\n            ensuring zero-copy; otherwise, allow transformations that copy\n            data for more flexibility.\n\n    Converts `array` (many types supported, including all Awkward Arrays and\n    Records) into an Awkward 0.x array.\n\n    This is only needed during the transition from the old library to the new\n    library.\n    """"""\n    # See https://github.com/scikit-hep/awkward-0.x/blob/405b7eaeea51b60947a79c782b1abf0d72f6729b/specification.adoc\n    import awkward as awkward0\n\n    def recurse(layout):\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            return awkward0.ChunkedArray([recurse(x) for x in layout.partitions])\n\n        elif isinstance(layout, awkward1.layout.NumpyArray):\n            return numpy.asarray(layout)\n\n        elif isinstance(layout, awkward1.layout.EmptyArray):\n            return numpy.array([])\n\n        elif isinstance(layout, awkward1.layout.RegularArray):\n            # content, size\n            if keeplayout:\n                raise ValueError(\n                    ""awkward0 has no equivalent of RegularArray; ""\n                    ""try keeplayout=False""\n                )\n            offsets = numpy.arange(0, (len(layout) + 1) * layout.size, layout.size)\n            return awkward0.JaggedArray.fromoffsets(offsets, recurse(layout.content))\n\n        elif isinstance(layout, awkward1.layout.ListArray32):\n            # starts, stops, content\n            return awkward0.JaggedArray(\n                numpy.asarray(layout.starts),\n                numpy.asarray(layout.stops),\n                recurse(layout.content),\n            )\n\n        elif isinstance(layout, awkward1.layout.ListArrayU32):\n            # starts, stops, content\n            return awkward0.JaggedArray(\n                numpy.asarray(layout.starts),\n                numpy.asarray(layout.stops),\n                recurse(layout.content),\n            )\n\n        elif isinstance(layout, awkward1.layout.ListArray64):\n            # starts, stops, content\n            return awkward0.JaggedArray(\n                numpy.asarray(layout.starts),\n                numpy.asarray(layout.stops),\n                recurse(layout.content),\n            )\n\n        elif isinstance(layout, awkward1.layout.ListOffsetArray32):\n            # offsets, content\n            return awkward0.JaggedArray.fromoffsets(\n                numpy.asarray(layout.offsets), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.ListOffsetArrayU32):\n            # offsets, content\n            return awkward0.JaggedArray.fromoffsets(\n                numpy.asarray(layout.offsets), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.ListOffsetArray64):\n            # offsets, content\n            return awkward0.JaggedArray.fromoffsets(\n                numpy.asarray(layout.offsets), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.Record):\n            # istuple, numfields, field(i)\n            out = []\n            for i in range(layout.numfields):\n                content = layout.field(i)\n                if isinstance(\n                    content, (awkward1.layout.Content, awkward1.layout.Record)\n                ):\n                    out.append(recurse(content))\n                else:\n                    out.append(content)\n            if layout.istuple:\n                return tuple(out)\n            else:\n                return dict(zip(layout.keys(), out))\n\n        elif isinstance(layout, awkward1.layout.RecordArray):\n            # istuple, numfields, field(i)\n            if layout.numfields == 0 and len(layout) != 0:\n                raise ValueError(\n                    ""cannot convert zero-field, nonzero-length RecordArray ""\n                    ""to awkward0.Table (limitation in awkward0)""\n                )\n            keys = layout.keys()\n            values = [recurse(x) for x in layout.contents]\n            pairs = collections.OrderedDict(zip(keys, values))\n            out = awkward0.Table(pairs)\n            if layout.istuple:\n                out._rowname = ""tuple""\n            return out\n\n        elif isinstance(layout, awkward1.layout.UnionArray8_32):\n            # tags, index, numcontents, content(i)\n            return awkward0.UnionArray(\n                numpy.asarray(layout.tags),\n                numpy.asarray(layout.index),\n                [recurse(x) for x in layout.contents],\n            )\n\n        elif isinstance(layout, awkward1.layout.UnionArray8_U32):\n            # tags, index, numcontents, content(i)\n            return awkward0.UnionArray(\n                numpy.asarray(layout.tags),\n                numpy.asarray(layout.index),\n                [recurse(x) for x in layout.contents],\n            )\n\n        elif isinstance(layout, awkward1.layout.UnionArray8_64):\n            # tags, index, numcontents, content(i)\n            return awkward0.UnionArray(\n                numpy.asarray(layout.tags),\n                numpy.asarray(layout.index),\n                [recurse(x) for x in layout.contents],\n            )\n\n        elif isinstance(layout, awkward1.layout.IndexedOptionArray32):\n            # index, content\n            index = numpy.asarray(layout.index)\n            toosmall = index < -1\n            if toosmall.any():\n                index = index.copy()\n                index[toosmall] = -1\n            return awkward0.IndexedMaskedArray(index, recurse(layout.content))\n\n        elif isinstance(layout, awkward1.layout.IndexedOptionArray64):\n            # index, content\n            index = numpy.asarray(layout.index)\n            toosmall = index < -1\n            if toosmall.any():\n                index = index.copy()\n                index[toosmall] = -1\n            return awkward0.IndexedMaskedArray(index, recurse(layout.content))\n\n        elif isinstance(layout, awkward1.layout.IndexedArray32):\n            # index, content\n            return awkward0.IndexedArray(\n                numpy.asarray(layout.index), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.IndexedArrayU32):\n            # index, content\n            return awkward0.IndexedArray(\n                numpy.asarray(layout.index), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.IndexedArray64):\n            # index, content\n            return awkward0.IndexedArray(\n                numpy.asarray(layout.index), recurse(layout.content)\n            )\n\n        elif isinstance(layout, awkward1.layout.ByteMaskedArray):\n            # mask, content, valid_when\n            return awkward0.MaskedArray(\n                numpy.asarray(layout.mask),\n                recurse(layout.content),\n                maskedwhen=(not layout.valid_when),\n            )\n\n        elif isinstance(layout, awkward1.layout.BitMaskedArray):\n            # mask, content, valid_when, length, lsb_order\n            return awkward0.BitMaskedArray(\n                numpy.asarray(layout.mask),\n                recurse(layout.content),\n                maskedwhen=(not layout.valid_when),\n                lsborder=layout.lsb_order,\n            )\n\n        elif isinstance(layout, awkward1.layout.UnmaskedArray):\n            # content\n            return recurse(layout.content)  # no equivalent in awkward0\n\n        elif isinstance(layout, awkward1.layout.VirtualArray):\n            raise NotImplementedError(""FIXME"")\n\n        else:\n            raise AssertionError(\n                ""missing converter for {0}"".format(type(layout).__name__)\n            )\n\n    layout = to_layout(\n        array, allow_record=True, allow_other=False, numpytype=(numpy.generic,)\n    )\n    return recurse(layout)\n\n\ndef to_layout(\n    array,\n    allow_record=True,\n    allow_other=False,\n    numpytype=(numpy.number, numpy.bool_, numpy.bool),\n):\n    """"""\n    Args:\n        array: Data to convert into an #ak.layout.Content and maybe\n            #ak.layout.Record and other types.\n        allow_record (bool): If True, allow #ak.layout.Record as an output;\n            otherwise, if the output would be a scalar record, raise an error.\n        allow_other (bool): If True, allow non-Awkward outputs; otherwise,\n            if the output would be another type, raise an error.\n        numpytype (tuple of NumPy types): Allowed NumPy types in\n            #ak.layout.NumpyArray outputs.\n\n    Converts `array` (many types supported, including all Awkward Arrays and\n    Records) into a #ak.layout.Content and maybe #ak.layout.Record and other\n    types.\n\n    This function is usually used to sanitize inputs for other functions; it\n    would rarely be used in a data analysis.\n    """"""\n    import awkward1.highlevel\n\n    if isinstance(array, awkward1.highlevel.Array):\n        return array.layout\n\n    elif allow_record and isinstance(array, awkward1.highlevel.Record):\n        return array.layout\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return array.snapshot().layout\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return array.snapshot()\n\n    elif isinstance(\n        array, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n    ):\n        return array\n\n    elif allow_record and isinstance(array, awkward1.layout.Record):\n        return array\n\n    elif isinstance(array, numpy.ma.MaskedArray):\n        mask = numpy.ma.getmask(array)\n        data = numpy.ma.getdata(array)\n        if mask is False:\n            out = awkward1.layout.UnmaskedArray(\n                awkward1.layout.NumpyArray(data.reshape(-1))\n            )\n        else:\n            out = awkward1.layout.ByteMaskedArray(\n                awkward1.layout.Index8(mask.reshape(-1)),\n                awkward1.layout.NumpyArray(data.reshape(-1)),\n            )\n        for size in array.shape[:0:-1]:\n            out = awkward1.layout.RegularArray(out, size)\n        return out\n\n    elif isinstance(array, numpy.ndarray):\n        if not issubclass(array.dtype.type, numpytype):\n            raise ValueError(""NumPy {0} not allowed"".format(repr(array.dtype)))\n        out = awkward1.layout.NumpyArray(array.reshape(-1))\n        for size in array.shape[:0:-1]:\n            out = awkward1.layout.RegularArray(out, size)\n        return out\n\n    elif isinstance(array, (str, bytes)) or (\n        awkward1._util.py27 and isinstance(array, awkward1._util.unicode)\n    ):\n        return from_iter([array], highlevel=False)\n\n    elif isinstance(array, Iterable):\n        return from_iter(array, highlevel=False)\n\n    elif not allow_other:\n        raise TypeError(""{0} cannot be converted into an Awkward Array"".format(array))\n\n    else:\n        return array\n\n\ndef regularize_numpyarray(array, allow_empty=True, highlevel=True):\n    """"""\n    Args:\n        array: Data to convert into an Awkward Array.\n        allow_empty (bool): If True, allow #ak.layout.EmptyArray in the output;\n            otherwise, convert empty arrays into #ak.layout.NumpyArray.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Converts any multidimensional #ak.layout.NumpyArray.shape into nested\n    #ak.layout.RegularArray nodes. The output may have any Awkward data type:\n    this only changes the representation of #ak.layout.NumpyArray.\n\n    This function is usually used to sanitize inputs for other functions; it\n    would rarely be used in a data analysis.\n    """"""\n\n    def getfunction(layout, depth):\n        if isinstance(layout, awkward1.layout.NumpyArray) and layout.ndim != 1:\n            return lambda: layout.toRegularArray()\n        elif isinstance(layout, awkward1.layout.EmptyArray) and not allow_empty:\n            return lambda: layout.toNumpyArray()\n        elif isinstance(layout, awkward1.layout.VirtualArray):\n            # FIXME: we must transform the Form (replacing inner_shape with\n            # RegularForms) and wrap the ArrayGenerator with regularize_numpy\n            return lambda: layout\n        else:\n            return None\n\n    out = awkward1._util.recursively_apply(to_layout(array), getfunction)\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef to_arrow(array):\n    """"""\n    Args:\n        array: Data to convert to an Apache Arrow array.\n\n    Converts an Awkward Array into an Apache Arrow array.\n\n    This produces arrays of type `pyarrow.Array`. You might need to further\n    manipulations (using the pyarrow library) to build a `pyarrow.ChunkedArray`,\n    a `pyarrow.RecordBatch`, or a `pyarrow.Table`.\n\n    See also #ak.from_arrow.\n    """"""\n\n    import pyarrow\n\n    layout = to_layout(array)\n\n    def recurse(layout, mask=None):\n        if isinstance(layout, awkward1.layout.NumpyArray):\n            numpy_arr = numpy.asarray(layout)\n            length = len(numpy_arr)\n            arrow_type = pyarrow.from_numpy_dtype(numpy_arr.dtype)\n\n            if issubclass(numpy_arr.dtype.type, (numpy.bool_, numpy.bool)):\n                if len(numpy_arr) % 8 == 0:\n                    ready_to_pack = numpy_arr\n                else:\n                    ready_to_pack = numpy.empty(\n                        int(numpy.ceil(len(numpy_arr) / 8.0)) * 8, dtype=numpy_arr.dtype\n                    )\n                    ready_to_pack[: len(numpy_arr)] = numpy_arr\n                    ready_to_pack[len(numpy_arr) :] = 0\n                numpy_arr = numpy.packbits(\n                    ready_to_pack.reshape(-1, 8)[:, ::-1].reshape(-1)\n                )\n\n            if numpy_arr.ndim == 1:\n                if mask is not None:\n                    return pyarrow.Array.from_buffers(\n                        arrow_type,\n                        length,\n                        [pyarrow.py_buffer(mask), pyarrow.py_buffer(numpy_arr)],\n                    )\n                else:\n                    return pyarrow.Array.from_buffers(\n                        arrow_type, length, [None, pyarrow.py_buffer(numpy_arr)]\n                    )\n            else:\n                return pyarrow.Tensor.from_numpy(numpy_arr)\n\n        elif isinstance(layout, awkward1.layout.EmptyArray):\n            return pyarrow.Array.from_buffers(pyarrow.float64(), 0, [None, None])\n\n        elif isinstance(layout, awkward1.layout.ListOffsetArray32):\n            offsets = numpy.asarray(layout.offsets, dtype=numpy.int32)\n\n            if layout.parameter(""__array__"") == ""bytestring"":\n                if mask is None:\n                    arrow_arr = pyarrow.Array.from_buffers(\n                        pyarrow.binary(),\n                        len(offsets) - 1,\n                        [\n                            None,\n                            pyarrow.py_buffer(offsets),\n                            pyarrow.py_buffer(layout.content),\n                        ],\n                        children=[],\n                    )\n                else:\n                    arrow_arr = pyarrow.Array.from_buffers(\n                        pyarrow.binary(),\n                        len(offsets) - 1,\n                        [\n                            pyarrow.py_buffer(mask),\n                            pyarrow.py_buffer(offsets),\n                            pyarrow.py_buffer(layout.content),\n                        ],\n                        children=[],\n                    )\n                return arrow_arr\n\n            if layout.parameter(""__array__"") == ""string"":\n                if mask is None:\n                    arrow_arr = pyarrow.StringArray.from_buffers(\n                        len(offsets) - 1,\n                        pyarrow.py_buffer(offsets),\n                        pyarrow.py_buffer(layout.content),\n                    )\n                else:\n                    arrow_arr = pyarrow.StringArray.from_buffers(\n                        len(offsets) - 1,\n                        pyarrow.py_buffer(offsets),\n                        pyarrow.py_buffer(layout.content),\n                        pyarrow.py_buffer(mask),\n                    )\n                return arrow_arr\n\n            content_buffer = recurse(layout.content[: offsets[-1]])\n            if mask is None:\n                arrow_arr = pyarrow.Array.from_buffers(\n                    pyarrow.list_(content_buffer.type),\n                    len(offsets) - 1,\n                    [None, pyarrow.py_buffer(offsets)],\n                    children=[content_buffer],\n                )\n            else:\n                arrow_arr = pyarrow.Array.from_buffers(\n                    pyarrow.list_(content_buffer.type),\n                    len(offsets) - 1,\n                    [pyarrow.py_buffer(mask), pyarrow.py_buffer(offsets)],\n                    children=[content_buffer],\n                )\n            return arrow_arr\n\n        elif isinstance(\n            layout,\n            (awkward1.layout.ListOffsetArray64, awkward1.layout.ListOffsetArrayU32),\n        ):\n            offsets = numpy.asarray(layout.offsets, dtype=numpy.int64)\n\n            if layout.parameter(""__array__"") == ""bytestring"":\n                if mask is None:\n                    arrow_arr = pyarrow.Array.from_buffers(\n                        pyarrow.large_binary(),\n                        len(offsets) - 1,\n                        [\n                            None,\n                            pyarrow.py_buffer(offsets),\n                            pyarrow.py_buffer(layout.content),\n                        ],\n                        children=[],\n                    )\n                else:\n                    arrow_arr = pyarrow.Array.from_buffers(\n                        pyarrow.large_binary(),\n                        len(offsets) - 1,\n                        [\n                            pyarrow.py_buffer(mask),\n                            pyarrow.py_buffer(offsets),\n                            pyarrow.py_buffer(layout.content),\n                        ],\n                        children=[],\n                    )\n                return arrow_arr\n\n            if layout.parameter(""__array__"") == ""string"":\n                if mask is None:\n                    arrow_arr = pyarrow.LargeStringArray.from_buffers(\n                        len(offsets) - 1,\n                        pyarrow.py_buffer(offsets),\n                        pyarrow.py_buffer(layout.content),\n                    )\n                else:\n                    arrow_arr = pyarrow.LargeStringArray.from_buffers(\n                        len(offsets) - 1,\n                        pyarrow.py_buffer(offsets),\n                        pyarrow.py_buffer(layout.content),\n                        pyarrow.py_buffer(mask),\n                    )\n                return arrow_arr\n\n            content_buffer = recurse(layout.content[: offsets[-1]])\n            if mask is None:\n                arrow_arr = pyarrow.Array.from_buffers(\n                    pyarrow.large_list(content_buffer.type),\n                    len(offsets) - 1,\n                    [None, pyarrow.py_buffer(offsets)],\n                    children=[content_buffer],\n                )\n            else:\n                arrow_arr = pyarrow.Array.from_buffers(\n                    pyarrow.large_list(content_buffer.type),\n                    len(offsets) - 1,\n                    [pyarrow.py_buffer(mask), pyarrow.py_buffer(offsets)],\n                    children=[content_buffer],\n                )\n            return arrow_arr\n\n        elif isinstance(layout, awkward1.layout.RegularArray):\n            return recurse(\n                layout.broadcast_tooffsets64(layout.compact_offsets64()), mask\n            )\n\n        elif isinstance(\n            layout,\n            (\n                awkward1.layout.ListArray32,\n                awkward1.layout.ListArrayU32,\n                awkward1.layout.ListArray64,\n            ),\n        ):\n            if mask is not None:\n                return recurse(\n                    layout.broadcast_tooffsets64(layout.compact_offsets64()), mask\n                )\n            else:\n                return recurse(layout.broadcast_tooffsets64(layout.compact_offsets64()))\n\n        elif isinstance(layout, awkward1.layout.RecordArray):\n            values = [recurse(x[: len(layout)]) for x in layout.contents]\n\n            min_list_len = min(map(len, values))\n\n            types = pyarrow.struct(\n                [\n                    pyarrow.field(layout.keys()[i], values[i].type)\n                    for i in range(len(values))\n                ]\n            )\n\n            if mask is not None:\n                return pyarrow.Array.from_buffers(\n                    types, min_list_len, [pyarrow.py_buffer(mask)], children=values\n                )\n            else:\n                return pyarrow.Array.from_buffers(\n                    types, min_list_len, [None], children=values\n                )\n\n        elif isinstance(\n            layout,\n            (\n                awkward1.layout.UnionArray8_32,\n                awkward1.layout.UnionArray8_64,\n                awkward1.layout.UnionArray8_U32,\n            ),\n        ):\n            values = [recurse(x) for x in layout.contents]\n            types = pyarrow.union(\n                [pyarrow.field(str(i), values[i].type) for i in range(len(values))],\n                ""dense"",\n                list(range(len(values))),\n            )\n\n            if mask is not None:\n                return pyarrow.Array.from_buffers(\n                    types,\n                    len(layout.tags),\n                    [\n                        pyarrow.py_buffer(mask),\n                        pyarrow.py_buffer(numpy.asarray(layout.tags)),\n                        pyarrow.py_buffer(\n                            numpy.asarray(layout.index).astype(numpy.int32)\n                        ),\n                    ],\n                    children=values,\n                )\n            else:\n                return pyarrow.Array.from_buffers(\n                    types,\n                    len(layout.tags),\n                    [\n                        None,\n                        pyarrow.py_buffer(numpy.asarray(layout.tags)),\n                        pyarrow.py_buffer(\n                            numpy.asarray(layout.index).astype(numpy.int32)\n                        ),\n                    ],\n                    children=values,\n                )\n\n        elif isinstance(\n            layout,\n            (\n                awkward1.layout.IndexedArray32,\n                awkward1.layout.IndexedArrayU32,\n                awkward1.layout.IndexedArray64,\n            ),\n        ):\n            index = numpy.asarray(layout.index)\n            dictionary = recurse(layout.content)\n            if mask is None:\n                return pyarrow.DictionaryArray.from_arrays(index, dictionary)\n            else:\n                bytemask = (\n                    numpy.unpackbits(~mask)\n                    .reshape(-1, 8)[:, ::-1]\n                    .reshape(-1)\n                    .view(numpy.bool_)\n                )[: len(index)]\n                return pyarrow.DictionaryArray.from_arrays(index, dictionary, bytemask)\n\n        elif isinstance(\n            layout,\n            (\n                awkward1.layout.IndexedOptionArray32,\n                awkward1.layout.IndexedOptionArray64,\n            ),\n        ):\n            index = numpy.array(layout.index, copy=True)\n            nulls = index < 0\n            index[nulls] = 0\n\n            if len(nulls) % 8 == 0:\n                this_bytemask = (~nulls).view(numpy.uint8)\n            else:\n                length = int(numpy.ceil(len(nulls) / 8.0)) * 8\n                this_bytemask = numpy.empty(length, dtype=numpy.uint8)\n                this_bytemask[: len(nulls)] = ~nulls\n                this_bytemask[len(nulls) :] = 0\n\n            this_bitmask = numpy.packbits(\n                this_bytemask.reshape(-1, 8)[:, ::-1].reshape(-1)\n            )\n\n            if isinstance(layout, awkward1.layout.IndexedOptionArray32):\n                next = awkward1.layout.IndexedArray32(\n                    awkward1.layout.Index32(index), layout.content\n                )\n            else:\n                next = awkward1.layout.IndexedArray64(\n                    awkward1.layout.Index64(index), layout.content\n                )\n\n            if mask is None:\n                return recurse(next, this_bitmask)\n            else:\n                return recurse(next, mask & this_bitmask)\n\n        elif isinstance(layout, awkward1.layout.BitMaskedArray):\n            bitmask = numpy.asarray(layout.mask, dtype=numpy.uint8)\n\n            if layout.lsb_order is False:\n                bitmask = numpy.packbits(\n                    numpy.unpackbits(bitmask).reshape(-1, 8)[:, ::-1].reshape(-1)\n                )\n\n            if layout.valid_when is False:\n                bitmask = ~bitmask\n\n            return recurse(layout.content[: len(layout)], bitmask).slice(\n                length=min(len(bitmask) * 8, len(layout.content))\n            )\n\n        elif isinstance(layout, awkward1.layout.ByteMaskedArray):\n            mask = numpy.asarray(layout.mask, dtype=numpy.bool) == layout.valid_when\n\n            bytemask = numpy.zeros(\n                8 * math.ceil(len(layout.content) / 8), dtype=numpy.bool\n            )\n            bytemask[: len(mask)] = mask\n            bitmask = numpy.packbits(bytemask.reshape(-1, 8)[:, ::-1].reshape(-1))\n\n            return recurse(layout.content[: len(layout)], bitmask).slice(\n                length=len(mask)\n            )\n\n        elif isinstance(layout, (awkward1.layout.UnmaskedArray)):\n            return recurse(layout.content)\n\n        else:\n            raise TypeError(""unrecognized array type: {0}"".format(repr(layout)))\n\n    return recurse(layout)\n\n\ndef from_arrow(array, highlevel=True, behavior=None):\n    """"""\n    Args:\n        array (`pyarrow.Array`, `pyarrow.ChunkedArray`, `pyarrow.RecordBatch`,\n            or `pyarrow.Table`): Apache Arrow array to convert into an\n            Awkward Array.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n\n    Converts an Apache Arrow array into an Awkward Array.\n\n    See also #ak.to_arrow.\n    """"""\n\n    import pyarrow\n\n    def popbuffers(array, tpe, buffers, length):\n        if isinstance(tpe, pyarrow.lib.DictionaryType):\n            index = popbuffers(\n                None if array is None else array.indices,\n                tpe.index_type,\n                buffers,\n                length,\n            )\n            if array is not None:\n                content = recurse(array.dictionary)\n            else:\n                raise NotImplementedError(""Arrow dictionary inside of UnionArray"")\n\n            if isinstance(index, awkward1.layout.BitMaskedArray):\n                return awkward1.layout.BitMaskedArray(\n                    index.mask,\n                    awkward1.layout.IndexedArray32(\n                        awkward1.layout.Index32(index.content), content\n                    ),\n                    True,\n                    length,\n                    True,\n                )\n            else:\n                return awkward1.layout.IndexedArray32(\n                    awkward1.layout.Index32(index), content\n                )\n\n        elif isinstance(tpe, pyarrow.lib.StructType):\n            assert tpe.num_buffers == 1\n            mask = buffers.pop(0)\n            child_arrays = []\n            keys = []\n            for i in range(tpe.num_children):\n                child_arrays.append(\n                    popbuffers(\n                        None if array is None else array.field(tpe[i].name),\n                        tpe[i].type,\n                        buffers,\n                        length,\n                    )\n                )\n                keys.append(tpe[i].name)\n\n            out = awkward1.layout.RecordArray(child_arrays, keys)\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.ListType):\n            assert tpe.num_buffers == 2\n            mask = buffers.pop(0)\n            offsets = awkward1.layout.Index32(\n                numpy.frombuffer(buffers.pop(0), dtype=numpy.int32)[: length + 1]\n            )\n            content = popbuffers(\n                None if array is None else array.flatten(),\n                tpe.value_type,\n                buffers,\n                offsets[-1],\n            )\n\n            out = awkward1.layout.ListOffsetArray32(offsets, content)\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.LargeListType):\n            assert tpe.num_buffers == 2\n            mask = buffers.pop(0)\n            offsets = awkward1.layout.Index64(\n                numpy.frombuffer(buffers.pop(0), dtype=numpy.int64)[: length + 1]\n            )\n            content = popbuffers(\n                None if array is None else array.flatten(),\n                tpe.value_type,\n                buffers,\n                offsets[-1],\n            )\n\n            out = awkward1.layout.ListOffsetArray64(offsets, content)\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""sparse"":\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n            tags = numpy.frombuffer(buffers.pop(0), dtype=numpy.int8)[:length]\n            assert buffers.pop(0) is None\n            index = numpy.arange(len(tags), dtype=numpy.int32)\n\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i][-1] + 1\n                except IndexError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these[-1] + 1]\n\n            tags = awkward1.layout.Index8(tags)\n            index = awkward1.layout.Index32(index)\n            out = awkward1.layout.UnionArray8_32(tags, index, contents)\n\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""dense"":\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n            tags = numpy.frombuffer(buffers.pop(0), dtype=numpy.int8)[:length]\n            index = numpy.frombuffer(buffers.pop(0), dtype=numpy.int32)[:length]\n\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i].max() + 1\n                except ValueError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these.max() + 1]\n\n            tags = awkward1.layout.Index8(tags)\n            index = awkward1.layout.Index32(index)\n            out = awkward1.layout.UnionArray8_32(tags, index, contents)\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        elif tpe == pyarrow.string():\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n\n            offsets = numpy.frombuffer(buffers.pop(0), dtype=numpy.int32)\n            contents = numpy.frombuffer(buffers.pop(0), dtype=numpy.uint8)\n\n            offsets = awkward1.layout.Index32(offsets)\n\n            contents = awkward1.layout.NumpyArray(contents)\n            contents.setparameter(""__array__"", ""char"")\n\n            awk_arr = awkward1.layout.ListOffsetArray32(offsets, contents)\n            awk_arr.setparameter(""__array__"", ""string"")\n\n            if mask is None:\n                return awk_arr\n            else:\n                awk_mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(\n                    awk_mask, awk_arr, True, len(offsets) - 1, True\n                )\n\n        elif tpe == pyarrow.large_string():\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n\n            offsets = numpy.frombuffer(buffers.pop(0), dtype=numpy.int64)\n            contents = numpy.frombuffer(buffers.pop(0), dtype=numpy.uint8)\n\n            offsets = awkward1.layout.Index64(offsets)\n\n            contents = awkward1.layout.NumpyArray(contents)\n            contents.setparameter(""__array__"", ""char"")\n\n            awk_arr = awkward1.layout.ListOffsetArray64(offsets, contents)\n            awk_arr.setparameter(""__array__"", ""string"")\n\n            if mask is None:\n                return awk_arr\n            else:\n                awk_mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(\n                    awk_mask, awk_arr, True, len(offsets) - 1, True\n                )\n\n        elif tpe == pyarrow.binary():\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n\n            offsets = numpy.frombuffer(buffers.pop(0), dtype=numpy.int32)\n            contents = numpy.frombuffer(buffers.pop(0), dtype=numpy.uint8)\n\n            offsets = awkward1.layout.Index32(offsets)\n\n            contents = awkward1.layout.NumpyArray(contents)\n            contents.setparameter(""__array__"", ""byte"")\n\n            awk_arr = awkward1.layout.ListOffsetArray32(offsets, contents)\n            awk_arr.setparameter(""__array__"", ""bytestring"")\n\n            if mask is None:\n                return awk_arr\n            else:\n                awk_mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(\n                    awk_mask, awk_arr, True, len(offsets) - 1, True\n                )\n\n        elif tpe == pyarrow.large_binary():\n            assert tpe.num_buffers == 3\n            mask = buffers.pop(0)\n\n            offsets = numpy.frombuffer(buffers.pop(0), dtype=numpy.int64)\n            contents = numpy.frombuffer(buffers.pop(0), dtype=numpy.uint8)\n\n            offsets = awkward1.layout.Index64(offsets)\n\n            contents = awkward1.layout.NumpyArray(contents)\n            contents.setparameter(""__array__"", ""byte"")\n\n            awk_arr = awkward1.layout.ListOffsetArray64(offsets, contents)\n            awk_arr.setparameter(""__array__"", ""bytestring"")\n\n            if mask is None:\n                return awk_arr\n            else:\n                awk_mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(\n                    awk_mask, awk_arr, True, len(offsets) - 1, True\n                )\n\n        elif tpe == pyarrow.bool_():\n            assert tpe.num_buffers == 2\n            mask = buffers.pop(0)\n            data = buffers.pop(0)\n            out = numpy.frombuffer(data, dtype=numpy.uint8)\n            out = numpy.unpackbits(out).reshape(-1, 8)[:, ::-1].reshape(-1)\n            out = awkward1.layout.NumpyArray(out[:length])\n            if mask is not None:\n                awk_mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                mask = numpy.frombuffer(mask, dtype=numpy.uint8)\n                return awkward1.layout.BitMaskedArray(awk_mask, out, True, length, True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.DataType):\n            assert tpe.num_buffers == 2\n            mask = buffers.pop(0)\n            out = awkward1.layout.NumpyArray(\n                numpy.frombuffer(buffers.pop(0), dtype=tpe.to_pandas_dtype())[:length]\n            )\n            if mask is not None:\n                mask = awkward1.layout.IndexU8(\n                    numpy.frombuffer(mask, dtype=numpy.uint8)\n                )\n                return awkward1.layout.BitMaskedArray(mask, out, True, length, True)\n            else:\n                return out\n\n        else:\n            raise TypeError(""unrecognized Arrow array type: {0}"".format(repr(tpe)))\n\n    def recurse(obj):\n        if isinstance(obj, pyarrow.lib.Array):\n            buffers = obj.buffers()\n            out = popbuffers(obj, obj.type, buffers, len(obj))\n            assert len(buffers) == 0\n            return out\n\n        elif isinstance(obj, pyarrow.lib.ChunkedArray):\n            chunks = [x for x in obj.chunks if len(x) > 0]\n            if len(chunks) == 1:\n                return recurse(chunks[0])\n            else:\n                return awkward1.operations.structure.concatenate(\n                    [recurse(x) for x in chunks], highlevel=False\n                )\n\n        elif isinstance(obj, pyarrow.lib.RecordBatch):\n            child_array = [recurse(obj.column(x)) for x in range(obj.num_columns)]\n            keys = obj.schema.names\n            awk_arr = awkward1.layout.RecordArray(child_array, keys)\n            return awk_arr\n\n        elif isinstance(obj, pyarrow.lib.Table):\n            chunks = []\n            for batch in obj.to_batches():\n                chunk = recurse(batch)\n                if len(chunk) > 0:\n                    chunks.append(chunk)\n            if len(chunks) == 1:\n                return chunks[0]\n            else:\n                return awkward1.operations.structure.concatenate(\n                    chunks, highlevel=False\n                )\n\n        else:\n            raise TypeError(""unrecognized Arrow type: {0}"".format(type(obj)))\n\n    if highlevel:\n        return awkward1._util.wrap(recurse(array), behavior)\n    else:\n        return recurse(array)\n\n\n__all__ = [\n    x\n    for x in list(globals())\n    if not x.startswith(""_"")\n    and x not in (""numbers"", ""json"", ""Iterable"", ""numpy"", ""awkward1"")\n]\n'"
src/awkward1/operations/describe.py,1,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport numbers\n\nimport numpy\n\nimport awkward1.layout\n\n\ndef is_valid(array, exception=False):\n    """"""\n    Args:\n        array (#ak.Array, #ak.Record, #ak.layout.Content, #ak.layout.Record,\n            #ak.ArrayBuilder, #ak.layout.ArrayBuilder): Array or record to check.\n        exception (bool): If True, validity errors raise exceptions.\n\n    Returns True if there are no errors and False if there is an error.\n\n    Checks for errors in the structure of the array, such as indexes that run\n    beyond the length of a node\'s `content`, etc. Either an error is raised or\n    the function returns a boolean.\n\n    See also #ak.validity_error.\n    """"""\n    out = validity_error(array, exception=exception)\n    return out is None\n\n\ndef validity_error(array, exception=False):\n    """"""\n    Args:\n        array (#ak.Array, #ak.Record, #ak.layout.Content, #ak.layout.Record,\n            #ak.ArrayBuilder, #ak.layout.ArrayBuilder): Array or record to check.\n        exception (bool): If True, validity errors raise exceptions.\n\n    Returns None if there are no errors and a str containing the error message\n    if there are.\n\n    Checks for errors in the structure of the array, such as indexes that run\n    beyond the length of a node\'s `content`, etc. Either an error is raised or\n    a string describing the error is returned.\n\n    See also #ak.is_valid.\n    """"""\n    if isinstance(array, (awkward1.highlevel.Array, awkward1.highlevel.Record)):\n        return validity_error(array.layout, exception=exception)\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return validity_error(array.snapshot().layout, exception=exception)\n\n    elif isinstance(\n        array,\n        (\n            awkward1.layout.Content,\n            awkward1.layout.Record,\n            awkward1.partition.PartitionedArray,\n        ),\n    ):\n        out = array.validityerror()\n        if out is not None and exception:\n            raise ValueError(out)\n        else:\n            return out\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return validity_error(array.snapshot(), exception=exception)\n\n    else:\n        raise TypeError(""not an awkward array: {0}"".format(repr(array)))\n\n\ndef type(array):\n    """"""\n    The high-level type of an `array` (many types supported, including all\n    Awkward Arrays and Records) as #ak.types.Type objects.\n\n    The high-level type ignores #layout differences like\n    #ak.layout.ListArray64 versus #ak.layout.ListOffsetArray64, but\n    not differences like ""regular-sized lists"" (i.e.\n    #ak.layout.RegularArray) versus ""variable-sized lists"" (i.e.\n    #ak.layout.ListArray64 and similar).\n\n    Types are rendered as [Datashape](https://datashape.readthedocs.io/)\n    strings, which makes the same distinctions.\n\n    For example,\n\n        ak.Array([[{""x"": 1.1, ""y"": [1]}, {""x"": 2.2, ""y"": [2, 2]}],\n                  [],\n                  [{""x"": 3.3, ""y"": [3, 3, 3]}]])\n\n    has type\n\n        3 * var * {""x"": float64, ""y"": var * int64}\n\n    but\n\n        ak.Array(np.arange(2*3*5).reshape(2, 3, 5))\n\n    has type\n\n        2 * 3 * 5 * int64\n\n    Some cases, like heterogeneous data, require [extensions beyond the\n    Datashape specification](https://github.com/blaze/datashape/issues/237).\n    For example,\n\n        ak.Array([1, ""two"", [3, 3, 3]])\n\n    has type\n\n        3 * union[int64, string, var * int64]\n\n    but ""union"" is not a Datashape type-constructor. (Its syntax is\n    similar to existing type-constructors, so it\'s a plausible addition\n    to the language.)\n    """"""\n    if array is None:\n        return awkward1.types.UnknownType()\n\n    elif isinstance(array, (bool, numpy.bool, numpy.bool_)):\n        return awkward1.types.PrimitiveType(""bool"")\n\n    elif isinstance(array, numbers.Integral):\n        return awkward1.types.PrimitiveType(""int64"")\n\n    elif isinstance(array, numbers.Real):\n        return awkward1.types.PrimitiveType(""float64"")\n\n    elif isinstance(\n        array,\n        (\n            numpy.int8,\n            numpy.int16,\n            numpy.int32,\n            numpy.int64,\n            numpy.uint8,\n            numpy.uint16,\n            numpy.uint32,\n            numpy.uint64,\n            numpy.float32,\n            numpy.float64,\n        ),\n    ):\n        return awkward1.types.PrimitiveType(type.dtype2primitive[array.dtype.type])\n\n    elif isinstance(array, awkward1.highlevel.Array):\n        return awkward1._util.highlevel_type(array.layout, array.behavior, True)\n\n    elif isinstance(array, awkward1.highlevel.Record):\n        return awkward1._util.highlevel_type(array.layout, array.behavior, False)\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return awkward1._util.highlevel_type(\n            array.snapshot().layout, array.behavior, True\n        )\n\n    elif isinstance(array, awkward1.layout.Record):\n        return array.type(awkward1._util.typestrs(None))\n\n    elif isinstance(array, numpy.ndarray):\n        if len(array.shape) == 0:\n            return type(array.reshape((1,))[0])\n        else:\n            out = awkward1.types.PrimitiveType(type.dtype2primitive[array.dtype.type])\n            for x in array.shape[-1:0:-1]:\n                out = awkward1.types.RegularType(out, x)\n            return awkward1.types.ArrayType(out, array.shape[0])\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return array.type(awkward1._util.typestrs(None))\n\n    elif isinstance(\n        array, (awkward1.layout.Content, awkward1.partition.PartitionedArray)\n    ):\n        return array.type(awkward1._util.typestrs(None))\n\n    else:\n        raise TypeError(""unrecognized array type: {0}"".format(repr(array)))\n\n\ntype.dtype2primitive = {\n    numpy.int8: ""int8"",\n    numpy.int16: ""int16"",\n    numpy.int32: ""int32"",\n    numpy.int64: ""int64"",\n    numpy.uint8: ""uint8"",\n    numpy.uint16: ""uint16"",\n    numpy.uint32: ""uint32"",\n    numpy.uint64: ""uint64"",\n    numpy.float32: ""float32"",\n    numpy.float64: ""float64"",\n}\n\n\ndef parameters(array):\n    """"""\n    Extracts parameters from the outermost array node of `array` (many types\n    supported, including all Awkward Arrays and Records).\n\n    Parameters are a dict from str to JSON-like objects, usually strings.\n    Every #ak.layout.Content node has a different set of parameters. Some\n    key names are special, such as `""__record__""` and `""__array__""` that name\n    particular records and arrays as capable of supporting special behaviors.\n\n    See #ak.Array and #ak.behavior for a more complete description of\n    behaviors.\n    """"""\n    if isinstance(array, (awkward1.highlevel.Array, awkward1.highlevel.Record)):\n        return array.layout.parameters\n\n    elif isinstance(\n        array,\n        (\n            awkward1.layout.Content,\n            awkward1.layout.Record,\n            awkward1.partition.PartitionedArray,\n        ),\n    ):\n        return array.parameters\n\n    elif isinstance(array, awkward1.highlevel.ArrayBuilder):\n        return array.snapshot().layout.parameters\n\n    elif isinstance(array, awkward1.layout.ArrayBuilder):\n        return array.snapshot().parameters\n\n    else:\n        return {}\n\n\ndef keys(array):\n    """"""\n    Extracts record or tuple keys from `array` (many types supported,\n    including all Awkward Arrays and Records).\n\n    If the array contains nested records, only the outermost record is\n    queried. If it contains tuples instead of records, the keys are\n    string representations of integers, such as `""0""`, `""1""`, `""2""`, etc.\n    The records or tuples may be within multiple layers of nested lists.\n\n    If the array contains neither tuples nor records, this returns an empty\n    list.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=True, allow_other=False\n    )\n    return layout.keys()\n\n\n__all__ = [\n    x\n    for x in list(globals())\n    if not x.startswith(""_"") and x not in (""numbers"", ""numpy"", ""awkward1"")\n]\n'"
src/awkward1/operations/reducers.py,6,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport numpy\n\nimport awkward1._util\nimport awkward1._connect._numpy\nimport awkward1.layout\nimport awkward1.operations.convert\n\n\ndef count(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data in which to count elements.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Counts elements of `array` (many types supported, including all\n    Awkward Arrays and Records). The identity of counting is `0` and it is\n    usually not masked.\n\n    This function has no analog in NumPy because counting values in a\n    rectilinear array would only result in elements of the NumPy array\'s\n    [shape](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html).\n\n    However, for nested lists of variable dimension and missing values, the\n    result of counting is non-trivial. For example, with this `array`,\n\n        ak.Array([[ 0.1,  0.2      ],\n                  [None, 10.2, None],\n                  None,\n                  [20.1, 20.2, 20.3],\n                  [30.1, 30.2      ]])\n\n    the result of counting over the innermost dimension is\n\n        >>> ak.count(array, axis=-1)\n        <Array [2, 1, None, 3, 2] type=\'5 * ?int64\'>\n\n    the outermost dimension is\n\n        >>> ak.count(array, axis=0)\n        <Array [3, 4, 1] type=\'3 * int64\'>\n\n    and all dimensions is\n\n        >>> ak.count(array, axis=None)\n        8\n\n    The gaps and None values are not counted, and if a None value occurs at\n    a higher axis than the one being counted, it is kept as a placeholder\n    so that the outer list length does not change.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n\n    Note also that this function is different from #ak.num, which counts\n    the number of values at a given depth, maintaining structure: #ak.num\n    never counts across different lists the way that reducers do (#ak.num\n    is not a reducer; #ak.count is). For the same `array`,\n\n        >>> ak.num(array, axis=0)\n        5\n        >>> ak.num(array, axis=1)\n        <Array [2, 3, None, 3, 2] type=\'5 * ?int64\'>\n\n    If it is desirable to include None values in #ak.count, use #ak.fill_none\n    to turn the None values into something that would be counted.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] + reduce(xs[1:])\n\n        return reduce(\n            [numpy.size(x) for x in awkward1._util.completely_flatten(layout)]\n        )\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.count(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.count_nonzero)\ndef count_nonzero(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data in which to count nonzero elements.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Counts nonzero elements of `array` (many types supported, including all\n    Awkward Arrays and Records). The identity of counting is `0` and it is\n    usually not masked. This operation is the same as NumPy\'s\n    [count_nonzero](https://docs.scipy.org/doc/numpy/reference/generated/numpy.count_nonzero.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n\n    Following the same rules as other reducers, #ak.count_nonzero does not\n    count None values. If it is desirable to count them, use #ak.fill_none\n    to turn them into something that would be counted.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] + reduce(xs[1:])\n\n        return reduce(\n            [numpy.count_nonzero(x) for x in awkward1._util.completely_flatten(layout)]\n        )\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.count_nonzero(axis=axis, mask=mask_identity, keepdims=keepdims),\n            behavior,\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.sum)\ndef sum(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data to sum over.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Sums over `array` (many types supported, including all Awkward Arrays\n    and Records). The identity of addition is `0` and it is usually not\n    masked. This operation is the same as NumPy\'s\n    [sum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    For example, consider this `array`, in which all lists at a given dimension\n    have the same length.\n\n        ak.Array([[ 0.1,  0.2,  0.3],\n                  [10.1, 10.2, 10.3],\n                  [20.1, 20.2, 20.3],\n                  [30.1, 30.2, 30.3]])\n\n    A sum over `axis=-1` combines the inner lists, leaving one value per\n    outer list:\n\n        >>> ak.sum(array, axis=-1)\n        <Array [0.6, 30.6, 60.6, 90.6] type=\'4 * float64\'>\n\n    while a sum over `axis=0` combines the outer lists, leaving one value\n    per inner list:\n\n        >>> ak.sum(array, axis=0)\n        <Array [60.4, 60.8, 61.2] type=\'3 * float64\'>\n\n    Now with some values missing,\n\n        ak.Array([[ 0.1,  0.2      ],\n                  [10.1            ],\n                  [20.1, 20.2, 20.3],\n                  [30.1, 30.2      ]])\n\n    The sum over `axis=-1` results in\n\n        >>> ak.sum(array, axis=-1)\n        <Array [0.3, 10.1, 60.6, 60.3] type=\'4 * float64\'>\n\n    and the sum over `axis=0` results in\n\n        >>> ak.sum(array, axis=0)\n        <Array [60.4, 50.6, 20.3] type=\'3 * float64\'>\n\n    How we ought to sum over the innermost lists is unambiguous, but for all\n    other `axis` values, we must choose whether to align contents to the\n    left before summing, to the right before summing, or something else.\n    As suggested by the way the text has been aligned, we choose the\n    left-alignment convention: the first `axis=0` result is the sum of all\n    first elements\n\n        60.4 = 0.1 + 10.1 + 20.1 + 30.1\n\n    the second is the sum of all second elements\n\n        50.6 = 0.2 + 20.2 + 30.2\n\n    and the third is the sum of the only third element\n\n        20.3 = 20.3\n\n    The same is true if the values were None, rather than gaps:\n\n        ak.Array([[ 0.1,  0.2, None],\n                  [10.1, None, None],\n                  [20.1, 20.2, 20.3],\n                  [30.1, 30.2, None]])\n\n        >>> ak.sum(array, axis=-1)\n        <Array [0.3, 10.1, 60.6, 60.3] type=\'4 * float64\'>\n        >>> ak.sum(array, axis=0)\n        <Array [60.4, 50.6, 20.3] type=\'3 * float64\'>\n\n    However, the missing value placeholder, None, allows us to align the\n    remaining data differently:\n\n        ak.Array([[None,  0.1,  0.2],\n                  [None, None, 10.1],\n                  [20.1, 20.2, 20.3],\n                  [None, 30.1, 30.2]])\n\n    Now the `axis=-1` result is the same but the `axis=0` result has changed:\n\n        >>> ak.sum(array, axis=-1)\n        <Array [0.3, 10.1, 60.6, 60.3] type=\'4 * float64\'>\n        >>> ak.sum(array, axis=0)\n        <Array [20.1, 50.4, 60.8] type=\'3 * float64\'>\n\n    because\n\n        20.1 = 20.1\n        50.4 = 0.1 + 20.2 + 30.1\n        60.8 = 0.2 + 10.1 + 20.3 + 30.2\n\n    If, instead of missing numbers, we had missing lists,\n\n        ak.Array([[ 0.1,  0.2,  0.3],\n                  None,\n                  [20.1, 20.2, 20.3],\n                  [30.1, 30.2, 30.3]])\n\n    then the placeholder would pass through the `axis=-1` sum because summing\n    over the inner dimension shouldn\'t change the length of the outer\n    dimension.\n\n        >>> ak.sum(array, axis=-1)\n        <Array [0.6, None, 60.6, 90.6] type=\'4 * ?float64\'>\n\n    However, the `axis=0` sum loses information about the None value.\n\n        >>> ak.sum(array, axis=0)\n        <Array [50.3, 50.6, 50.9] type=\'3 * float64\'>\n\n    which is\n\n        50.3 = 0.1 + (None) + 20.1 + 30.1\n        50.6 = 0.2 + (None) + 20.2 + 30.2\n        50.9 = 0.3 + (None) + 20.3 + 30.3\n\n    An `axis=0` sum would be reducing that information if it had not been\n    None, anyway. If the None values were replaced with `0`, the result for\n    `axis=0` would be the same. The result for `axis=-1` would not be the\n    same because this None is in the `0` axis, not the axis that `axis=-1`\n    sums over.\n\n    The `keepdims` parameter ensures that the number of dimensions does not\n    change: scalar results are put into new length-1 dimensions:\n\n        >>> ak.sum(array, axis=-1, keepdims=True)\n        <Array [[0.6], None, [60.6], [90.6]] type=\'4 * option[1 * float64]\'>\n        >>> ak.sum(array, axis=0, keepdims=True)\n        <Array [[50.3, 50.6, 50.9]] type=\'1 * var * float64\'>\n\n    and `axis=None` ignores all None values and adds up everything in the\n    array (`keepdims` has no effect).\n\n        >>> ak.sum(array, axis=None)\n        151.8\n\n    The `mask_identity`, which has no equivalent in NumPy, inserts None in\n    the output wherever a reduction takes place over zero elements. This is\n    different from reductions that are otherwise equal to the identity or\n    are equal to the identity by cancellation.\n\n        >>> array = ak.Array([[2.2, 2.2], [4.4, -2.2, -2.2], [], [0.0]])\n        >>> ak.sum(array, axis=-1)\n        <Array [4.4, 0, 0, 0] type=\'4 * float64\'>\n        >>> ak.sum(array, axis=-1, mask_identity=True)\n        <Array [4.4, 0, None, 0] type=\'4 * ?float64\'>\n\n    The third list is reduced to `0` if `mask_identity=False` because `0` is\n    the identity of addition, but it is reduced to None if\n    `mask_identity=True`.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] + reduce(xs[1:])\n\n        return reduce([numpy.sum(x) for x in awkward1._util.completely_flatten(layout)])\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.sum(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.prod)\ndef prod(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data to multiply.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Multiplies elements of `array` (many types supported, including all\n    Awkward Arrays and Records). The identity of multiplication is `1` and it\n    is usually not masked. This operation is the same as NumPy\'s\n    [prod](https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] * reduce(xs[1:])\n\n        return reduce(\n            [numpy.prod(x) for x in awkward1._util.completely_flatten(layout)]\n        )\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.prod(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.any)\ndef any(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data to combine with ""logical or.""\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns True in each group of elements from `array` (many types supported,\n    including all Awkward Arrays and Records) if any values are True; False\n    otherwise. Thus, it represents reduction over the ""logical or"" operation,\n    whose identity is False (i.e. asking if there are any True values in an\n    empty list results in False). This operation is the same as NumPy\'s\n    [any](https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] or reduce(xs[1:])\n\n        return reduce([numpy.any(x) for x in awkward1._util.completely_flatten(layout)])\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.any(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.all)\ndef all(array, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        array: Data to combine with ""logical all.""\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns True in each group of elements from `array` (many types supported,\n    including all Awkward Arrays and Records) if all values are True; False\n    otherwise. Thus, it represents reduction over the ""logical and"" operation,\n    whose identity is True (i.e. asking if all the values are True in an\n    empty list results in True). This operation is the same as NumPy\'s\n    [all](https://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 1:\n                return xs[0]\n            else:\n                return xs[0] and reduce(xs[1:])\n\n        return reduce([numpy.all(x) for x in awkward1._util.completely_flatten(layout)])\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.all(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.min)\ndef min(array, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        array: Data to minimize.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns the minimum value in each group of elements from `array` (many\n    types supported, including all Awkward Arrays and Records). The identity\n    of minimization is `inf` if floating-point or the largest integer value\n    if applied to integers. This identity is usually masked: the minimum of\n    an empty list is None, unless `mask_identity=False`.\n    This operation is the same as NumPy\'s\n    [amin](https://docs.scipy.org/doc/numpy/reference/generated/numpy.amin.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 0:\n                return None\n            elif len(xs) == 1:\n                return xs[0]\n            else:\n                x, y = xs[0], reduce(xs[1:])\n                return x if x < y else y\n\n        tmp = awkward1._util.completely_flatten(layout)\n        return reduce([numpy.min(x) for x in tmp if len(x) > 0])\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.min(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.max)\ndef max(array, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        array: Data to maximize.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns the maximum value in each group of elements from `array` (many\n    types supported, including all Awkward Arrays and Records). The identity\n    of maximization is `-inf` if floating-point or the smallest integer value\n    if applied to integers. This identity is usually masked: the maximum of\n    an empty list is None, unless `mask_identity=False`.\n    This operation is the same as NumPy\'s\n    [amax](https://docs.scipy.org/doc/numpy/reference/generated/numpy.amax.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if axis is None:\n\n        def reduce(xs):\n            if len(xs) == 0:\n                return None\n            elif len(xs) == 1:\n                return xs[0]\n            else:\n                x, y = xs[0], reduce(xs[1:])\n                return x if x > y else y\n\n        tmp = awkward1._util.completely_flatten(layout)\n        return reduce([numpy.max(x) for x in tmp if len(x) > 0])\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.max(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.argmin)\ndef argmin(array, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        array: Data to find the index positions of the minimum values.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns the index position of the minimum value in each group of elements\n    from `array` (many types supported, including all Awkward Arrays and\n    Records). The identity of minimization would be infinity, but argmin\n    must return the position of the minimum element, which has no value for\n    empty lists. Therefore, the identity should be masked: the argmin of\n    an empty list is None. If `mask_identity=False`, the result would be `-1`,\n    which is distinct from all valid index positions, but care should be taken\n    that it is not misinterpreted as ""the last element of the list.""\n\n    This operation is the same as NumPy\'s\n    [argmin](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n\n    if axis is None:\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            start = 0\n            best_index = None\n            best_value = None\n            for partition in layout.partitions:\n                for tmp in awkward1._util.completely_flatten(partition):\n                    out = numpy.argmin(tmp, axis=None)\n                    if best_index is None or tmp[out] < best_value:\n                        best_index = start + out\n                        best_value = tmp[out]\n                start += len(partition)\n            return best_index\n\n        else:\n            best_index = None\n            best_value = None\n            for tmp in awkward1._util.completely_flatten(layout):\n                out = numpy.argmin(tmp, axis=None)\n                if best_index is None or tmp[out] < best_value:\n                    best_index = out\n                    best_value = tmp[out]\n            return best_index\n\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.argmin(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n@awkward1._connect._numpy.implements(numpy.argmax)\ndef argmax(array, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        array: Data to find the index positions of the maximum values.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this reducer descreases the number of\n            dimensions by 1; if True, the reduced values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, reducing over empty lists results in\n            None (an option type); otherwise, reducing over empty lists\n            results in the operation\'s identity.\n\n    Returns the index position of the maximum value in each group of elements\n    from `array` (many types supported, including all Awkward Arrays and\n    Records). The identity of maximization would be negative infinity, but\n    argmax must return the position of the maximum element, which has no value\n    for empty lists. Therefore, the identity should be masked: the argmax of\n    an empty list is None. If `mask_identity=False`, the result would be `-1`,\n    which is distinct from all valid index positions, but care should be taken\n    that it is not misinterpreted as ""the last element of the list.""\n\n    This operation is the same as NumPy\'s\n    [argmax](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    See #ak.sum for a more complete description of nested list and missing\n    value (None) handling in reducers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n\n    if axis is None:\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            start = 0\n            best_index = None\n            best_value = None\n            for partition in layout.partitions:\n                for tmp in awkward1._util.completely_flatten(partition):\n                    out = numpy.argmax(tmp, axis=None)\n                    if best_index is None or tmp[out] > best_value:\n                        best_index = start + out\n                        best_value = tmp[out]\n                start += len(partition)\n            return best_index\n\n        else:\n            best_index = None\n            best_value = None\n            for tmp in awkward1._util.completely_flatten(layout):\n                out = numpy.argmax(tmp, axis=None)\n                if best_index is None or tmp[out] > best_value:\n                    best_index = out\n                    best_value = tmp[out]\n            return best_index\n\n    else:\n        behavior = awkward1._util.behaviorof(array)\n        return awkward1._util.wrap(\n            layout.argmax(axis=axis, mask=mask_identity, keepdims=keepdims), behavior\n        )\n\n\n# The following are not strictly reducers, but are defined in terms of\n# reducers and ufuncs.\n\n\ndef moment(x, n, weight=None, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: the data on which to compute the moment.\n        n (int): the choice of moment: `0` is a sum of weights, `1` is\n            #ak.mean, `2` is #ak.var without subtracting the mean, etc.\n        weight: data that can be broadcasted to `x` to give each value a\n            weight. Weighting values equally is the same as no weights;\n            weighting some values higher increases the significance of those\n            values. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the `n`th moment in each group of elements from `x` (many\n    types supported, including all Awkward Arrays and Records). The grouping\n    is performed the same way as for reducers, though this operation is not a\n    reducer and has no identity.\n\n    This function has no NumPy equivalent.\n\n    Passing all arguments to the reducers, the moment is calculated as\n\n        ak.sum((x*weight)**n) / ak.sum(weight)\n\n    The `n=2` moment differs from #ak.var in that #ak.var also subtracts the\n    mean (the `n=1` moment).\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        if weight is None:\n            sumw = count(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwxn = sum(\n                x ** n, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n        else:\n            sumw = sum(\n                x * 0 + weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwxn = sum(\n                (x * weight) ** n,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        return numpy.true_divide(sumwxn, sumw)\n\n\n@awkward1._connect._numpy.implements(numpy.mean)\ndef mean(x, weight=None, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: the data on which to compute the mean.\n        weight: data that can be broadcasted to `x` to give each value a\n            weight. Weighting values equally is the same as no weights;\n            weighting some values higher increases the significance of those\n            values. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the mean in each group of elements from `x` (many\n    types supported, including all Awkward Arrays and Records). The grouping\n    is performed the same way as for reducers, though this operation is not a\n    reducer and has no identity. It is the same as NumPy\'s\n    [mean](https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    Passing all arguments to the reducers, the mean is calculated as\n\n        ak.sum(x*weight) / ak.sum(weight)\n\n    For example, with an `array` like\n\n        ak.Array([[0, 1, 2, 3],\n                  [          ],\n                  [4, 5      ]])\n\n    The mean of the innermost lists is\n\n        >>> ak.mean(array, axis=-1)\n        <Array [1.5, None, 4.5] type=\'3 * ?float64\'>\n\n    because there are three lists, the first has mean `1.5`, the second is\n    empty, and the third has mean `4.5`.\n\n    The mean of the outermost lists is\n\n        >>> ak.mean(array, axis=0)\n        <Array [2, 3, 2, 3] type=\'4 * ?float64\'>\n\n    because the longest list has length 4, the mean of `0` and `4` is `2.0`,\n    the mean of `1` and `5` is `3.0`, the mean of `2` (by itself) is `2.0`,\n    and the mean of `3` (by itself) is `3.0`. This follows the same grouping\n    behavior as reducers.\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        if weight is None:\n            sumw = count(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwx = sum(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n        else:\n            sumw = sum(\n                x * 0 + weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwx = sum(\n                x * weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n        return numpy.true_divide(sumwx, sumw)\n\n\n@awkward1._connect._numpy.implements(numpy.var)\ndef var(x, weight=None, ddof=0, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: the data on which to compute the variance.\n        weight: data that can be broadcasted to `x` to give each value a\n            weight. Weighting values equally is the same as no weights;\n            weighting some values higher increases the significance of those\n            values. Weights can be zero or negative.\n        ddof (int): ""delta degrees of freedom"": the divisor used in the\n            calculation is `sum(weights) - ddof`. Use this for ""reduced\n            variance.""\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the variance in each group of elements from `x` (many\n    types supported, including all Awkward Arrays and Records). The grouping\n    is performed the same way as for reducers, though this operation is not a\n    reducer and has no identity. It is the same as NumPy\'s\n    [var](https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    Passing all arguments to the reducers, the variance is calculated as\n\n        ak.sum((x - ak.mean(x))**2 * weight) / ak.sum(weight)\n\n    If `ddof` is not zero, the above is further corrected by a factor of\n\n        ak.sum(weight) / (ak.sum(weight) - ddof)\n\n    Even without `ddof`, #ak.var differs from #ak.moment with `n=2` because\n    the mean is subtracted from all points before summing their squares.\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        xmean = mean(\n            x, weight=weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n        )\n        if weight is None:\n            sumw = count(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwxx = sum(\n                (x - xmean) ** 2,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        else:\n            sumw = sum(\n                x * 0 + weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwxx = sum(\n                (x - xmean) ** 2 * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        if ddof != 0:\n            return numpy.true_divide(sumwxx, sumw) * numpy.true_divide(\n                sumw, sumw - ddof\n            )\n        else:\n            return numpy.true_divide(sumwxx, sumw)\n\n\n@awkward1._connect._numpy.implements(numpy.std)\ndef std(x, weight=None, ddof=0, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: the data on which to compute the standard deviation.\n        weight: data that can be broadcasted to `x` to give each value a\n            weight. Weighting values equally is the same as no weights;\n            weighting some values higher increases the significance of those\n            values. Weights can be zero or negative.\n        ddof (int): ""delta degrees of freedom"": the divisor used in the\n            calculation is `sum(weights) - ddof`. Use this for ""reduced\n            standard deviation.""\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the standard deviation in each group of elements from `x`\n    (many types supported, including all Awkward Arrays and Records). The\n    grouping is performed the same way as for reducers, though this operation\n    is not a reducer and has no identity. It is the same as NumPy\'s\n    [std](https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html)\n    if all lists at a given dimension have the same length and no None values,\n    but it generalizes to cases where they do not.\n\n    Passing all arguments to the reducers, the standard deviation is\n    calculated as\n\n        np.sqrt(ak.var(x, weight))\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        return numpy.sqrt(\n            var(\n                x,\n                weight=weight,\n                ddof=ddof,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        )\n\n\ndef covar(x, y, weight=None, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: one coordinate to use in the covariance calculation.\n        y: the other coordinate to use in the covariance calculation.\n        weight: data that can be broadcasted to `x` and `y` to give each point\n            a weight. Weighting points equally is the same as no weights;\n            weighting some points higher increases the significance of those\n            points. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the covariance of `x` and `y` (many types supported, including\n    all Awkward Arrays and Records, must be broadcastable to each other).\n    The grouping is performed the same way as for reducers, though this\n    operation is not a reducer and has no identity.\n\n    This function has no NumPy equivalent.\n\n    Passing all arguments to the reducers, the covariance is calculated as\n\n        ak.sum((x - ak.mean(x))*(y - ak.mean(y))*weight) / ak.sum(weight)\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        xmean = mean(\n            x, weight=weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n        )\n        ymean = mean(\n            y, weight=weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n        )\n        if weight is None:\n            sumw = count(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwxy = sum(\n                (x - xmean) * (y - ymean),\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        else:\n            sumw = sum(\n                x * 0 + weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwxy = sum(\n                (x - xmean) * (y - ymean) * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        return numpy.true_divide(sumwxy, sumw)\n\n\ndef corr(x, y, weight=None, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: one coordinate to use in the correlation.\n        y: the other coordinate to use in the correlation.\n        weight: data that can be broadcasted to `x` and `y` to give each point\n            a weight. Weighting points equally is the same as no weights;\n            weighting some points higher increases the significance of those\n            points. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the correlation of `x` and `y` (many types supported, including\n    all Awkward Arrays and Records, must be broadcastable to each other).\n    The grouping is performed the same way as for reducers, though this\n    operation is not a reducer and has no identity.\n\n    This function has no NumPy equivalent.\n\n    Passing all arguments to the reducers, the correlation is calculated as\n\n        ak.sum((x - ak.mean(x))*(y - ak.mean(y))*weight)\n            / np.sqrt(ak.sum((x - ak.mean(x))**2))\n            / np.sqrt(ak.sum((y - ak.mean(y))**2))\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        xmean = mean(\n            x, weight=weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n        )\n        ymean = mean(\n            y, weight=weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n        )\n        xdiff = x - xmean\n        ydiff = y - ymean\n        if weight is None:\n            sumwxx = sum(\n                xdiff ** 2, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n            sumwyy = sum(\n                ydiff ** 2, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n            sumwxy = sum(\n                xdiff * ydiff, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n        else:\n            sumwxx = sum(\n                (xdiff ** 2) * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwyy = sum(\n                (ydiff ** 2) * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwxy = sum(\n                (xdiff * ydiff) * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        return numpy.true_divide(sumwxy, numpy.sqrt(sumwxx * sumwyy))\n\n\ndef linear_fit(x, y, weight=None, axis=None, keepdims=False, mask_identity=True):\n    """"""\n    Args:\n        x: one coordinate to use in the linear fit.\n        y: the other coordinate to use in the linear fit.\n        weight: data that can be broadcasted to `x` and `y` to give each point\n            a weight. Weighting points equally is the same as no weights;\n            weighting some points higher increases the significance of those\n            points. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the linear fit of `y` with respect to `x` (many types supported,\n    including all Awkward Arrays and Records, must be broadcastable to each\n    other). The grouping is performed the same way as for reducers, though\n    this operation is not a reducer and has no identity.\n\n    This function has no NumPy equivalent.\n\n    Passing all arguments to the reducers, the linear fit is calculated as\n\n        sumw            = ak.sum(weight)\n        sumwx           = ak.sum(weight * x)\n        sumwy           = ak.sum(weight * y)\n        sumwxx          = ak.sum(weight * x**2)\n        sumwxy          = ak.sum(weight * x * y)\n        delta           = (sumw*sumwxx) - (sumwx*sumwx)\n\n        intercept       = ((sumwxx*sumwy) - (sumwx*sumwxy)) / delta\n        slope           = ((sumw*sumwxy) - (sumwx*sumwy))   / delta\n        intercept_error = np.sqrt(sumwxx / delta)\n        slope_error     = np.sqrt(sumw   / delta)\n\n    The results, `intercept`, `slope`, `intercept_error`, and `slope_error`,\n    are given as an #ak.Record with four fields. The values of these fields\n    might be arrays or even nested arrays; they match the structure of `x` and\n    `y`.\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        if weight is None:\n            sumw = count(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwx = sum(x, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwy = sum(y, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n            sumwxx = sum(\n                x ** 2, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n            sumwxy = sum(\n                x * y, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n        else:\n            sumw = sum(\n                x * 0 + weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwx = sum(\n                x * weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n            sumwy = sum(\n                y * weight, axis=axis, keepdims=keepdims, mask_identity=mask_identity\n            )\n            sumwxx = sum(\n                (x ** 2) * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n            sumwxy = sum(\n                x * y * weight,\n                axis=axis,\n                keepdims=keepdims,\n                mask_identity=mask_identity,\n            )\n        delta = (sumw * sumwxx) - (sumwx * sumwx)\n        intercept = numpy.true_divide(((sumwxx * sumwy) - (sumwx * sumwxy)), delta)\n        slope = numpy.true_divide(((sumw * sumwxy) - (sumwx * sumwy)), delta)\n        intercept_error = numpy.sqrt(numpy.true_divide(sumwxx, delta))\n        slope_error = numpy.sqrt(numpy.true_divide(sumw, delta))\n\n        intercept = awkward1.operations.convert.to_layout(\n            intercept, allow_record=True, allow_other=True\n        )\n        slope = awkward1.operations.convert.to_layout(\n            slope, allow_record=True, allow_other=True\n        )\n        intercept_error = awkward1.operations.convert.to_layout(\n            intercept_error, allow_record=True, allow_other=True\n        )\n        slope_error = awkward1.operations.convert.to_layout(\n            slope_error, allow_record=True, allow_other=True\n        )\n\n        scalar = False\n        if not isinstance(\n            intercept,\n            (\n                awkward1.layout.Content,\n                awkward1.layout.Record,\n                awkward1.partition.PartitionedArray,\n            ),\n        ):\n            intercept = awkward1.layout.NumpyArray(numpy.array([intercept]))\n            scalar = True\n        if not isinstance(\n            slope,\n            (\n                awkward1.layout.Content,\n                awkward1.layout.Record,\n                awkward1.partition.PartitionedArray,\n            ),\n        ):\n            slope = awkward1.layout.NumpyArray(numpy.array([slope]))\n            scalar = True\n        if not isinstance(\n            intercept_error,\n            (\n                awkward1.layout.Content,\n                awkward1.layout.Record,\n                awkward1.partition.PartitionedArray,\n            ),\n        ):\n            intercept_error = awkward1.layout.NumpyArray(numpy.array([intercept_error]))\n            scalar = True\n        if not isinstance(\n            slope_error,\n            (\n                awkward1.layout.Content,\n                awkward1.layout.Record,\n                awkward1.partition.PartitionedArray,\n            ),\n        ):\n            slope_error = awkward1.layout.NumpyArray(numpy.array([slope_error]))\n            scalar = True\n\n        sample = None\n        if isinstance(intercept, awkward1.partition.PartitionedArray):\n            sample = intercept\n        elif isinstance(slope, awkward1.partition.PartitionedArray):\n            sample = slope\n        elif isinstance(intercept_error, awkward1.partition.PartitionedArray):\n            sample = intercept_error\n        elif isinstance(slope_error, awkward1.partition.PartitionedArray):\n            sample = slope_error\n\n        if sample is not None:\n            (\n                intercept,\n                slope,\n                intercept_error,\n                slope_error,\n            ) = awkward1.partition.partition_as(\n                sample, (intercept, slope, intercept_error, slope_error)\n            )\n            output = []\n            for a, b, c, d in awkward1.partition.iterate(\n                sample.numpartitions, (intercept, slope, intercept_error, slope_error)\n            ):\n                output.append(\n                    awkward1.layout.RecordArray(\n                        [a, b, c, d],\n                        [""intercept"", ""slope"", ""intercept_error"", ""slope_error""],\n                        parameters={""__record__"": ""LinearFit""},\n                    )\n                )\n            out = awkward1.partition.IrregularlyPartitionedArray(output)\n\n        else:\n            out = awkward1.layout.RecordArray(\n                [intercept, slope, intercept_error, slope_error],\n                [""intercept"", ""slope"", ""intercept_error"", ""slope_error""],\n                parameters={""__record__"": ""LinearFit""},\n            )\n            if scalar:\n                out = out[0]\n\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(x, y))\n\n\ndef softmax(x, axis=None, keepdims=False, mask_identity=False):\n    """"""\n    Args:\n        x: the data on which to compute the softmax.\n        weight: data that can be broadcasted to `x` to give each value a\n            weight. Weighting values equally is the same as no weights;\n            weighting some values higher increases the significance of those\n            values. Weights can be zero or negative.\n        axis (None or int): If None, combine all values from the array into\n            a single scalar result; if an int, group by that axis: `0` is the\n            outermost, `1` is the first level of nested lists, etc., and\n            negative `axis` counts from the innermost: `-1` is the innermost,\n            `-2` is the next level up, etc.\n        keepdims (bool): If False, this function descreases the number of\n            dimensions by 1; if True, the output values are wrapped in a new\n            length-1 dimension so that the result of this operation may be\n            broadcasted with the original array.\n        mask_identity (bool): If True, the application of this function on\n            empty lists results in None (an option type); otherwise, the\n            calculation is followed through with the reducers\' identities,\n            usually resulting in floating-point `nan`.\n\n    Computes the softmax in each group of elements from `x` (many\n    types supported, including all Awkward Arrays and Records). The grouping\n    is performed the same way as for reducers, though this operation is not a\n    reducer and has no identity.\n\n    This function has no NumPy equivalent.\n\n    Passing all arguments to the reducers, the softmax is calculated as\n\n        np.exp(x) / ak.sum(np.exp(x))\n\n    See #ak.sum for a complete description of handling nested lists and\n    missing values (None) in reducers, and #ak.mean for an example with another\n    non-reducer.\n    """"""\n    with numpy.errstate(invalid=""ignore""):\n        expx = numpy.exp(x)\n        denom = sum(expx, axis=axis, keepdims=keepdims, mask_identity=mask_identity)\n        return numpy.true_divide(expx, denom)\n\n\n__all__ = [\n    x\n    for x in list(globals())\n    if not x.startswith(""_"") and x not in (""collections"", ""numpy"", ""awkward1"")\n]\n'"
src/awkward1/operations/structure.py,11,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport numbers\nimport json\n\ntry:\n    from collections.abc import Iterable\n    from collections.abc import MutableMapping\nexcept ImportError:\n    from collections import Iterable\n    from collections import MutableMapping\n\nimport numpy\n\nimport awkward1._util\nimport awkward1.layout\nimport awkward1._connect._numpy\nimport awkward1.operations.convert\n\n\ndef mask(array, mask, valid_when=True, highlevel=True):\n    """"""\n    Args:\n        array: Data to mask, rather than filter.\n        mask (array of booleans): The mask that overlays elements in the\n            `array` with None. Must have the same length as `array`.\n        valid_when (bool): If True, True values in `mask` are considered\n            valid (passed from `array` to the output); if False, False\n            values in `mask` are considered valid.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an array for which\n\n        output[i] = array[i] if mask[i] == valid_when else None\n\n    Unlike filtering data with #ak.Array.__getitem__, this `output` has the\n    same length as the original `array` and can therefore be used in\n    calculations with it, such as\n    [universal functions](https://docs.scipy.org/doc/numpy/reference/ufuncs.html).\n\n    For example, with an `array` like\n\n        ak.Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    with a boolean selection of `good` elements like\n\n        >>> good = (array % 2 == 1)\n        >>> good\n        <Array [False, True, False, ... False, True] type=\'10 * bool\'>\n\n    could be used to filter the original `array` (or another with the same\n    length).\n\n        >>> array[good]\n        <Array [1, 3, 5, 7, 9] type=\'5 * int64\'>\n\n    However, this eliminates information about which elements were dropped and\n    where they were. If we instead use #ak.mask,\n\n        >>> ak.mask(array, good)\n        <Array [None, 1, None, 3, ... None, 7, None, 9] type=\'10 * ?int64\'>\n\n    this information and the length of the array is preserved, and it can be\n    used in further calculations with the original `array` (or another with\n    the same length).\n\n        >>> ak.mask(array, good) + array\n        <Array [None, 2, None, 6, ... 14, None, 18] type=\'10 * ?int64\'>\n\n    In particular, successive filters can be applied to the same array.\n\n    Even if the `array` and/or the `mask` is nested,\n\n        >>> array = ak.Array([[[0, 1, 2], [], [3, 4], [5]], [[6, 7, 8], [9]]])\n        >>> good = (array % 2 == 1)\n        >>> good\n        <Array [[[False, True, False], ... [True]]] type=\'2 * var * var * bool\'>\n\n    it can still be used with #ak.mask because the `array` and `mask`\n    parameters are broadcasted.\n\n        >>> ak.mask(array, good)\n        <Array [[[None, 1, None], ... None], [9]]] type=\'2 * var * var * ?int64\'>\n\n    See #ak.broadcast_arrays for details about broadcasting and the generalized\n    set of broadcasting rules.\n\n    Another syntax for\n\n        ak.mask(array, array_of_booleans)\n\n    is\n\n        array.mask[array_of_booleans]\n\n    (which is 5 characters away from simply filtering the `array`).\n    """"""\n\n    def getfunction(inputs, depth):\n        layoutarray, layoutmask = inputs\n        if isinstance(layoutmask, awkward1.layout.NumpyArray):\n            m = numpy.asarray(layoutmask)\n            if not issubclass(m.dtype.type, (numpy.bool, numpy.bool_)):\n                raise ValueError(\n                    ""mask must have boolean type, not "" ""{0}"".format(repr(m.dtype))\n                )\n            bytemask = awkward1.layout.Index8(m.view(numpy.int8))\n            return lambda: (\n                awkward1.layout.ByteMaskedArray(\n                    bytemask, layoutarray, valid_when=valid_when\n                ).simplify(),\n            )\n        else:\n            return None\n\n    layoutarray = awkward1.operations.convert.to_layout(\n        array, allow_record=True, allow_other=False\n    )\n    layoutmask = awkward1.operations.convert.to_layout(\n        mask, allow_record=True, allow_other=False\n    )\n\n    behavior = awkward1._util.behaviorof(array, mask)\n    out = awkward1._util.broadcast_and_apply(\n        [layoutarray, layoutmask], getfunction, behavior\n    )\n    assert isinstance(out, tuple) and len(out) == 1\n    if highlevel:\n        return awkward1._util.wrap(out[0], behavior)\n    else:\n        return out[0]\n\n\ndef num(array, axis=1, highlevel=True):\n    """"""\n    Args:\n        array: Data containing nested lists to count.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an array of integers specifying the number of elements at a\n    particular level.\n\n    For instance, given the following doubly nested `array`,\n\n        ak.Array([[\n                   [1.1, 2.2, 3.3],\n                   [],\n                   [4.4, 5.5],\n                   [6.6]\n                  ],\n                  [],\n                  [\n                   [7.7],\n                   [8.8, 9.9]]\n                  ])\n\n    The number of elements in `axis=1` is\n\n        >>> ak.num(array, axis=1)\n        <Array [4, 0, 2] type=\'3 * int64\'>\n\n    and the number of elements at the next level down, `axis=2`, is\n\n        >>> ak.num(array, axis=2)\n        <Array [[3, 0, 2, 1], [], [1, 2]] type=\'3 * var * int64\'>\n\n    The `axis=0` case is special: it returns a scalar, the length of the array.\n\n        >>> ak.num(array, axis=0)\n        3\n\n    This function is useful for ensuring that slices do not raise errors. For\n    instance, suppose that we want to select the first element from each\n    of the outermost nested lists of `array`. One of these lists is empty, so\n    selecting the first element (`0`) would raise an error. However, if our\n    first selection is `ak.num(array) > 0`, we are left with only those lists\n    that *do* have a first element:\n\n        >>> array[ak.num(array) > 0, 0]\n        <Array [[1.1, 2.2, 3.3], [7.7]] type=\'2 * var * float64\'>\n\n    To keep a placeholder (None) in each place we do not want to select,\n    consider using #ak.mask instead of a #ak.Array.__getitem__.\n\n        >>> ak.mask(array, ak.num(array) > 0)[:, 0]\n        <Array [[1.1, 2.2, 3.3], None, [7.7]] type=\'3 * option[var * float64]\'>\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    out = layout.num(axis=axis)\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef zip(arrays, depth_limit=None, parameters=None, with_name=None, highlevel=True):\n    """"""\n    Args:\n        arrays (dict or iterable of arrays): Arrays to combine into a\n            record-containing structure (if a dict) or a tuple-containing\n            structure (if any other kind of iterable).\n        depth_limit (None or int): If None, attempt to fully broadcast the\n            `array` to all levels. If an int, limit the number of dimensions\n            that get broadcasted. The minimum value is `1`, for no\n            broadcasting.\n        parameters (None or dict): Parameters for the new\n            #ak.layout.RecordArray node that is created by this operation.\n        with_name (None or str): Assigns a `""__record__""` name to the new\n            #ak.layout.RecordArray node that is created by this operation\n            (overriding `parameters`, if necessary).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Combines `arrays` into a single structure as the fields of a collection\n    of records or the slots of a collection of tuples. If the `arrays` have\n    nested structure, they are broadcasted with one another to form the\n    records or tuples as deeply as possible, though this can be limited by\n    `depth_limit`.\n\n    This operation may be thought of as the opposite of projection in\n    #ak.Array.__getitem__, which extracts fields one at a time, or\n    #ak.unzip, which extracts them all in one call.\n\n    Consider the following arrays, `one` and `two`.\n\n        >>> one = ak.Array([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6]])\n        >>> two = ak.Array([[""a"", ""b"", ""c""], [], [""d"", ""e""], [""f""]])\n\n    Zipping them together using a dict creates a collection of records with\n    the same nesting structure as `one` and `two`.\n\n        >>> ak.to_list(ak.zip({""x"": one, ""y"": two}))\n        [\n         [{\'x\': 1.1, \'y\': \'a\'}, {\'x\': 2.2, \'y\': \'b\'}, {\'x\': 3.3, \'y\': \'c\'}],\n         [],\n         [{\'x\': 4.4, \'y\': \'d\'}, {\'x\': 5.5, \'y\': \'e\'}],\n         [{\'x\': 6.6, \'y\': \'f\'}]\n        ]\n\n    Doing so with a list creates tuples, whose fields are not named.\n\n        >>> ak.to_list(ak.zip([one, two]))\n        [\n         [(1.1, \'a\'), (2.2, \'b\'), (3.3, \'c\')],\n         [],\n         [(4.4, \'d\'), (5.5, \'e\')],\n         [(6.6, \'f\')]\n        ]\n\n    Adding a third array with the same length as `one` and `two` but less\n    internal structure is okay: it gets broadcasted to match the others.\n    (See #ak.broadcast_arrays for broadcasting rules.)\n\n        >>> three = ak.Array([100, 200, 300, 400])\n        >>> ak.to_list(ak.zip([one, two, three]))\n        [\n         [[(1.1, 97, 100)], [(2.2, 98, 100)], [(3.3, 99, 100)]],\n         [],\n         [[(4.4, 100, 300)], [(5.5, 101, 300)]],\n         [[(6.6, 102, 400)]]\n        ]\n\n    However, if arrays have the same depth but different lengths of nested\n    lists, attempting to zip them together is a broadcasting error.\n\n        >>> one = ak.Array([[[1, 2, 3], [], [4, 5], [6]], [], [[7, 8]]])\n        >>> two = ak.Array([[[1.1, 2.2], [3.3], [4.4], [5.5]], [], [[6.6]]])\n        >>> ak.zip([one, two])\n        ValueError: in ListArray64, cannot broadcast nested list\n\n    For this, one can set the `depth_limit` to prevent the operation from\n    attempting to broadcast what can\'t be broadcasted.\n\n        >>> ak.to_list(ak.zip([one, two], depth_limit=1))\n        [([[1, 2, 3], [], [4, 5], [6]], [[1.1, 2.2], [3.3], [4.4], [5.5]]),\n         ([], []),\n         ([[7, 8]], [[6.6]])]\n\n    As an extreme, `depth_limit=1` is a handy way to make a record structure\n    at the outermost level, regardless of whether the fields have matching\n    structure or not.\n    """"""\n    if depth_limit is not None and depth_limit <= 0:\n        raise ValueError(""depth_limit must be None or at least 1"")\n\n    if isinstance(arrays, dict):\n        recordlookup = []\n        layouts = []\n        for n, x in arrays.items():\n            recordlookup.append(n)\n            layouts.append(\n                awkward1.operations.convert.to_layout(\n                    x, allow_record=False, allow_other=False\n                )\n            )\n\n    else:\n        recordlookup = None\n        layouts = []\n        for x in arrays:\n            layouts.append(\n                awkward1.operations.convert.to_layout(\n                    x, allow_record=False, allow_other=False\n                )\n            )\n\n    if with_name is not None:\n        if parameters is None:\n            parameters = {}\n        else:\n            parameters = dict(parameters)\n        parameters[""__record__""] = with_name\n\n    def getfunction(inputs, depth):\n        if (depth_limit is None and all(x.purelist_depth == 1 for x in inputs)) or (\n            depth_limit == depth\n        ):\n            return lambda: (\n                awkward1.layout.RecordArray(\n                    inputs, recordlookup, parameters=parameters\n                ),\n            )\n        else:\n            return None\n\n    behavior = awkward1._util.behaviorof(*arrays)\n    out = awkward1._util.broadcast_and_apply(layouts, getfunction, behavior)\n    assert isinstance(out, tuple) and len(out) == 1\n    if highlevel:\n        return awkward1._util.wrap(out[0], behavior)\n    else:\n        return out[0]\n\n\ndef unzip(array):\n    """"""\n    If the `array` contains tuples or records, this operation splits them\n    into a Python tuple of arrays, one for each field.\n\n    If the `array` does not contain tuples or records, the single `array`\n    is placed in a length 1 Python tuple.\n\n    For example,\n\n        >>> array = ak.Array([{""x"": 1.1, ""y"": [1]},\n        ...                   {""x"": 2.2, ""y"": [2, 2]},\n        ...                   {""x"": 3.3, ""y"": [3, 3, 3]}])\n        >>> x, y = ak.unzip(array)\n        >>> x\n        <Array [1.1, 2.2, 3.3] type=\'3 * float64\'>\n        >>> y\n        <Array [[1], [2, 2], [3, 3, 3]] type=\'3 * var * int64\'>\n    """"""\n    keys = awkward1.operations.describe.keys(array)\n    if len(keys) == 0:\n        return (array,)\n    else:\n        return tuple(array[n] for n in keys)\n\n\ndef with_name(array, name, highlevel=True):\n    """"""\n    Args:\n        base: Data containing records or tuples.\n        name (str): Name to give to the records or tuples; this assigns\n            the `""__record__""` parameter.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an #ak.Array or #ak.Record (or low-level equivalent, if\n    `highlevel=False`) with a new name. This function does not change the\n    array in-place.\n\n    The records or tuples may be nested within multiple levels of nested lists.\n    If records are nested within records, only the outermost are affected.\n\n    Setting the `""__record__""` parameter makes it possible to add behaviors\n    to the data; see #ak.Array and #ak.behavior for a more complete\n    description.\n    """"""\n\n    def getfunction(layout, depth):\n        if isinstance(layout, awkward1.layout.RecordArray):\n            parameters = dict(layout.parameters)\n            parameters[""__record__""] = name\n            return lambda: awkward1.layout.RecordArray(\n                layout.contents,\n                layout.recordlookup,\n                len(layout),\n                layout.identities,\n                parameters,\n            )\n        else:\n            return None\n\n    out = awkward1._util.recursively_apply(\n        awkward1.operations.convert.to_layout(array), getfunction\n    )\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef with_field(base, what, where=None, highlevel=True):\n    """"""\n    Args:\n        base: Data containing records or tuples.\n        what: Data to add as a new field.\n        where (None or str or non-empy iterable of str): If None, the new field\n            has no name (can be accessed as an integer slot number in a\n            string); If str, the name of the new field. If iterable, it is\n            interpreted as a path where to add the field in a nested record.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an #ak.Array or #ak.Record (or low-level equivalent, if\n    `highlevel=False`) with a new field attached. This function does not\n    change the array in-place.\n\n    See #ak.Array.__setitem__ and #ak.Record.__setitem__ for a variant that\n    changes the high-level object in-place. (These methods internally use\n    #ak.with_field, so performance is not a factor in choosing one over the\n    other.)\n    """"""\n\n    if not (\n        where is None\n        or isinstance(where, str)\n        or (isinstance(where, Iterable) and all(isinstance(x, str) for x in where))\n    ):\n        raise TypeError(\n            ""New fields may only be assigned by field name(s) ""\n            ""or as a new integer slot by passing None for \'where\'""\n        )\n    if (\n        not isinstance(where, str)\n        and isinstance(where, Iterable)\n        and all(isinstance(x, str) for x in where)\n        and len(where) > 1\n    ):\n        return with_field(\n            base,\n            with_field(base[where[0]], what, where=where[1:], highlevel=highlevel),\n            where=where[0],\n            highlevel=highlevel\n        )\n    else:\n        if not (isinstance(where, str) or where is None):\n            where = where[0]\n\n        behavior = awkward1._util.behaviorof(base, what)\n        base = awkward1.operations.convert.to_layout(\n            base, allow_record=True, allow_other=False\n        )\n        if base.numfields < 0:\n            raise ValueError(""no tuples or records in array; cannot add a new "" ""field"")\n\n        what = awkward1.operations.convert.to_layout(\n            what, allow_record=True, allow_other=True\n        )\n\n        def getfunction(inputs, depth):\n            base, what = inputs\n            if isinstance(base, awkward1.layout.RecordArray):\n                if not isinstance(what, awkward1.layout.Content):\n                    what = awkward1.layout.NumpyArray(\n                        numpy.repeat(what, len(base))\n                    )\n                return lambda: (base.setitem_field(where, what),)\n            else:\n                return None\n\n        keys = base.keys()\n        if where in base.keys():\n            keys.remove(where)\n        if len(keys) == 0:\n            # the only key was removed, so just create new Record\n            out = (awkward1.layout.RecordArray([what], [where]),)\n        else:\n            base = base[keys]\n            out = awkward1._util.broadcast_and_apply([base, what], getfunction, behavior)\n        assert isinstance(out, tuple) and len(out) == 1\n\n        if highlevel:\n            return awkward1._util.wrap(out[0], behavior=behavior)\n        else:\n            return out[0]\n\n\ndef with_parameter(array, parameter, value, highlevel=True):\n    """"""\n    Args:\n        array: Data convertible into an Awkward Array.\n        parameter (str): Name of the parameter to set on that array.\n        value (JSON): Value of the parameter to set on that array.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    This function returns a new array with a parameter set on the outermost\n    node of its #ak.Array.layout.\n\n    Note that a ""new array"" is a lightweight shallow copy, not a duplication\n    of large data buffers.\n\n    You can also remove a single parameter with this function, since setting\n    a parameter to None is equivalent to removing it.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=True, allow_other=False\n    )\n\n    if isinstance(layout, awkward1.partition.PartitionedArray):\n        out = layout.replace_partitions(\n            x.withparameter(parameter, value) for x in layout.partitions\n        )\n    else:\n        out = layout.withparameter(parameter, value)\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef without_parameters(array, highlevel=True):\n    """"""\n    Args:\n        array: Data convertible into an Awkward Array.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    This function returns a new array without any parameters in its\n    #ak.Array.layout, on nodes of any level of depth.\n\n    Note that a ""new array"" is a lightweight shallow copy, not a duplication\n    of large data buffers.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=True, allow_other=False\n    )\n\n    out = awkward1._util.recursively_apply(\n        layout, lambda layout, depth: None, keep_parameters=False\n    )\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\n@awkward1._connect._numpy.implements(numpy.broadcast_arrays)\ndef broadcast_arrays(*arrays, **kwargs):\n    """"""\n    Args:\n        arrays: Arrays to broadcast into the same structure.\n        highlevel (bool, default is True): If True, return an #ak.Array;\n            otherwise, return a low-level #ak.layout.Content subclass.\n\n    Like NumPy\'s\n    [broadcast_arrays](https://docs.scipy.org/doc/numpy/reference/generated/numpy.broadcast_arrays.html)\n    function, this function returns the input `arrays` with enough elements\n    duplicated that they can be combined element-by-element.\n\n    For NumPy arrays, this means that scalars are replaced with arrays with\n    the same scalar value repeated at every element of the array, and regular\n    dimensions are created to increase low-dimensional data into\n    high-dimensional data.\n\n    For example,\n\n        >>> ak.broadcast_arrays(5,\n        ...                     [1, 2, 3, 4, 5])\n        [<Array [5, 5, 5, 5, 5] type=\'5 * int64\'>,\n         <Array [1, 2, 3, 4, 5] type=\'5 * int64\'>]\n\n    and\n\n        >>> ak.broadcast_arrays(np.array([1, 2, 3]),\n        ...                     np.array([[0.1, 0.2, 0.3], [10, 20, 30]]))\n        [<Array [[  1,   2,   3], [ 1,  2,  3]] type=\'2 * 3 * int64\'>,\n         <Array [[0.1, 0.2, 0.3], [10, 20, 30]] type=\'2 * 3 * float64\'>]\n\n    Note that in the second example, when the `3 * int64` array is expanded\n    to match the `2 * 3 * float64` array, it is the deepest dimension that\n    is aligned. If we try to match a `2 * int64` with the `2 * 3 * float64`,\n\n        >>> ak.broadcast_arrays(np.array([1, 2]),\n        ...                     np.array([[0.1, 0.2, 0.3], [10, 20, 30]]))\n        ValueError: cannot broadcast RegularArray of size 2 with RegularArray of size 3\n\n    NumPy has the same behavior: arrays with different numbers of dimensions\n    are aligned to the right before expansion. One can control this by\n    explicitly adding a new axis (reshape to add a dimension of length 1)\n    where the expansion is supposed to take place because a dimension of\n    length 1 can be expanded like a scalar.\n\n        >>> ak.broadcast_arrays(np.array([1, 2])[:, np.newaxis],\n        ...                     np.array([[0.1, 0.2, 0.3], [10, 20, 30]]))\n        [<Array [[  1,   1,   1], [ 2,  2,  2]] type=\'2 * 3 * int64\'>,\n         <Array [[0.1, 0.2, 0.3], [10, 20, 30]] type=\'2 * 3 * float64\'>]\n\n    Again, NumPy does the same thing (`np.newaxis` is equal to None, so this\n    trick is often shown with None in the slice-tuple). Where the broadcasting\n    happens can be controlled, but numbers of dimensions that don\'t match are\n    implicitly aligned to the right (fitting innermost structure, not\n    outermost).\n\n    While that might be an arbitrary decision for rectilinear arrays, it is\n    much more natural for implicit broadcasting to align left for tree-like\n    structures. That is, the root of each data structure should agree and\n    leaves may be duplicated to match. For example,\n\n        >>> ak.broadcast_arrays([            100,   200,        300],\n        ...                     [[1.1, 2.2, 3.3],    [], [4.4, 5.5]])\n        [<Array [[100, 100, 100], [], [300, 300]] type=\'3 * var * int64\'>,\n         <Array [[1.1, 2.2, 3.3], [], [4.4, 5.5]] type=\'3 * var * float64\'>]\n\n    One typically wants single-item-per-element data to be duplicated to\n    match multiple-items-per-element data. Operations on the broadcasted\n    arrays like\n\n        one_dimensional + nested_lists\n\n    would then have the same effect as the procedural code\n\n        for x, outer in zip(one_dimensional, nested_lists):\n            output = []\n            for inner in outer:\n                output.append(x + inner)\n            yield output\n\n    where `x` has the same value for each `inner` in the inner loop.\n\n    Awkward Array\'s broadcasting manages to have it both ways by applying the\n    following rules:\n\n       * If a dimension is regular (i.e. #ak.types.RegularType), like NumPy,\n         implicit broadcasting aligns to the right, like NumPy.\n       * If a dimension is variable (i.e. #ak.types.ListType), which can\n         never be true of NumPy, implicit broadcasting aligns to the left.\n       * Explicit broadcasting with a length-1 regular dimension always\n         broadcasts, like NumPy.\n\n    Thus, it is important to be aware of the distinction between a dimension\n    that is declared to be regular in the type specification and a dimension\n    that is allowed to be variable (even if it happens to have the same length\n    for all elements). This distinction is can be accessed through the\n    #ak.Array.type, but it is lost when converting an array into JSON or\n    Python objects.\n    """"""\n    (highlevel,) = awkward1._util.extra((), kwargs, [(""highlevel"", True)])\n\n    inputs = []\n    for x in arrays:\n        y = awkward1.operations.convert.to_layout(\n            x, allow_record=True, allow_other=True\n        )\n        if isinstance(y, awkward1.partition.PartitionedArray):\n            y = y.toContent()\n        if not isinstance(y, (awkward1.layout.Content, awkward1.layout.Record)):\n            y = awkward1.layout.NumpyArray(numpy.array([y]))\n        inputs.append(y)\n\n    def getfunction(inputs, depth):\n        if all(isinstance(x, awkward1.layout.NumpyArray) for x in inputs):\n            return lambda: tuple(inputs)\n        else:\n            return None\n\n    behavior = awkward1._util.behaviorof(*arrays)\n    out = awkward1._util.broadcast_and_apply(inputs, getfunction, behavior)\n    assert isinstance(out, tuple)\n    if highlevel:\n        return [awkward1._util.wrap(x, behavior) for x in out]\n    else:\n        return list(out)\n\n\n@awkward1._connect._numpy.implements(numpy.concatenate)\ndef concatenate(arrays, axis=0, mergebool=True, highlevel=True):\n    """"""\n    Args:\n        arrays: Arrays to concatenate along any dimension.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        mergebool (bool): If True, boolean and nummeric data can be combined\n            into the same buffer, losing information about False vs `0` and\n            True vs `1`; otherwise, they are kept in separate buffers with\n            distinct types (using an #ak.layout.UnionArray8_64).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an array with `arrays` concatenated. For `axis=0`, this means that\n    one whole array follows another. For `axis=1`, it means that the `arrays`\n    must have the same lengths and nested lists are each concatenated,\n    element for element, and similarly for deeper levels.\n    """"""\n    if axis != 0:\n        raise NotImplementedError(""axis={0}"".format(axis))\n\n    contents = [\n        awkward1.operations.convert.to_layout(x, allow_record=False) for x in arrays\n    ]\n\n    contents = [\n        x.toContent() if isinstance(x, awkward1.partition.PartitionedArray) else x\n        for x in contents\n    ]\n\n    if len(contents) == 0:\n        raise ValueError(""need at least one array to concatenate"")\n    out = contents[0]\n    for x in contents[1:]:\n        if not out.mergeable(x, mergebool=mergebool):\n            out = out.merge_as_union(x)\n        else:\n            out = out.merge(x)\n        if isinstance(out, awkward1._util.uniontypes):\n            out = out.simplify(mergebool=mergebool)\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(*arrays))\n    else:\n        return out\n\n\n@awkward1._connect._numpy.implements(numpy.where)\ndef where(condition, *args, **kwargs):\n    """"""\n    Args:\n        condition (np.ndarray or rectilinear #ak.Array of booleans): In the\n            three-argument form of this function (`condition`, `x`, `y`),\n            True values in `condition` select values from `x` and False\n            values in `condition` select values from `y`.\n        x: Data with the same length as `condition`.\n        y: Data with the same length as `condition`.\n        mergebool (bool, default is True): If True, boolean and nummeric data\n            can be combined into the same buffer, losing information about\n            False vs `0` and True vs `1`; otherwise, they are kept in separate\n            buffers with distinct types (using an #ak.layout.UnionArray8_64).\n        highlevel (bool, default is True): If True, return an #ak.Array;\n            otherwise, return a low-level #ak.layout.Content subclass.\n\n    This function has a one-argument form, `condition` without `x` or `y`, and\n    a three-argument form, `condition`, `x`, and `y`. In the one-argument form,\n    it is completely equivalent to NumPy\'s\n    [nonzero](https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html)\n    function.\n\n    In the three-argument form, it acts as a vectorized ternary operator:\n    `condition`, `x`, and `y` must all have the same length and\n\n        output[i] = x[i] if condition[i] else y[i]\n\n    for all `i`. The structure of `x` and `y` do not need to be the same; if\n    they are incompatible types, the output will have #ak.type.UnionType.\n    """"""\n    mergebool, highlevel = awkward1._util.extra(\n        (), kwargs, [(""mergebool"", True), (""highlevel"", True)]\n    )\n\n    akcondition = awkward1.operations.convert.to_layout(condition, allow_record=False)\n\n    if isinstance(akcondition, awkward1.partition.PartitionedArray):\n        akcondition = akcondition.replace_partitions(\n            [\n                awkward1.layout.NumpyArray(awkward1.operations.convert.to_numpy(x))\n                for x in akcondition.partitions\n            ]\n        )\n    else:\n        akcondition = awkward1.layout.NumpyArray(\n            awkward1.operations.convert.to_numpy(akcondition)\n        )\n\n    if len(args) == 0:\n        out = numpy.nonzero(awkward1.operations.convert.to_numpy(akcondition))\n        if highlevel:\n            return tuple(\n                awkward1._util.wrap(\n                    awkward1.layout.NumpyArray(x), awkward1._util.behaviorof(condition)\n                )\n                for x in out\n            )\n        else:\n            return tuple(awkward1.layout.NumpyArray(x) for x in out)\n\n    elif len(args) == 1:\n        raise ValueError(""either both or neither of x and y should be given"")\n\n    elif len(args) == 2:\n        x = awkward1.operations.convert.to_layout(args[0], allow_record=False)\n        y = awkward1.operations.convert.to_layout(args[1], allow_record=False)\n\n        def do_one(akcondition, x, y):\n            tags = numpy.asarray(akcondition) == 0\n            assert tags.itemsize == 1\n            index = numpy.empty(len(tags), dtype=numpy.int64)\n            index = numpy.arange(len(akcondition), dtype=numpy.int64)\n\n            tags = awkward1.layout.Index8(tags.view(numpy.int8))\n            index = awkward1.layout.Index64(index)\n            tmp = awkward1.layout.UnionArray8_64(tags, index, [x, y])\n            return tmp.simplify(mergebool=mergebool)\n\n        sample = None\n        if isinstance(akcondition, awkward1.partition.PartitionedArray):\n            sample = akcondition\n        elif isinstance(x, awkward1.partition.PartitionedArray):\n            sample = x\n        elif isinstance(y, awkward1.partition.PartitionedArray):\n            sample = y\n\n        if sample is not None:\n            akcondition, x, y = awkward1.partition.partition_as(\n                sample, (akcondition, x, y)\n            )\n            output = []\n            for part in awkward1.partition.iterate(\n                sample.numpartitions, (akcondition, x, y)\n            ):\n                output.append(do_one(*part))\n\n            out = awkward1.partition.IrregularlyPartitionedArray(output)\n\n        else:\n            out = do_one(akcondition, x, y)\n\n        return awkward1._util.wrap(\n            out, behavior=awkward1._util.behaviorof(condition, *args)\n        )\n\n    else:\n        raise TypeError(\n            ""where() takes from 1 to 3 positional arguments but {0} were ""\n            ""given"".format(len(args) + 1)\n        )\n\n\ndef flatten(array, axis=1, highlevel=True):\n    """"""\n    Args:\n        array: Data containing nested lists to flatten.\n        axis (None or int): If None, the operation flattens all levels of\n            nesting, returning a 1-dimensional array. Otherwise, it flattens\n            at a specified depth. The outermost dimension is `0`, followed\n            by `1`, etc., and negative values count backward from the\n            innermost: `-1` is the innermost dimension, `-2` is the next\n            level up, etc.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an array with one level of nesting removed by erasing the\n    boundaries between consecutive lists. Since this operates on a level of\n    nesting, `axis=0` is a special case that only removes values at the\n    top level that are equal to None.\n\n    Consider the following doubly nested `array`.\n\n        ak.Array([[\n                   [1.1, 2.2, 3.3],\n                   [],\n                   [4.4, 5.5],\n                   [6.6]],\n                  [],\n                  [\n                   [7.7],\n                   [8.8, 9.9]\n                  ]])\n\n    At `axis=1`, the outer lists (length 4, length 0, length 2) become a single\n    list (of length 6).\n\n        >>> print(ak.flatten(array, axis=1))\n        [[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6], [7.7], [8.8, 9.9]]\n\n    At `axis=2`, the inner lists (lengths 3, 0, 2, 1, 1, and 2) become three\n    lists (of lengths 6, 0, and 3).\n\n        >>> print(ak.flatten(array, axis=2))\n        [[1.1, 2.2, 3.3, 4.4, 5.5, 6.6], [], [7.7, 8.8, 9.9]]\n\n    There\'s also an option to completely flatten the array with `axis=None`.\n    This is useful for passing the data to a function that doesn\'t care about\n    nested structure, such as a plotting routine.\n\n        >>> print(ak.flatten(array, axis=None))\n        [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n\n    Missing values are eliminated by flattening: there is no distinction\n    between an empty list and a value of None at the level of flattening.\n\n        >>> array = ak.Array([[1.1, 2.2, 3.3], None, [4.4], [], [5.5]])\n        >>> ak.flatten(array, axis=1)\n        <Array [1.1, 2.2, 3.3, 4.4, 5.5] type=\'5 * float64\'>\n\n    As a consequence, flattening at `axis=0` does only one thing: it removes\n    None values from the top level.\n\n        >>> ak.flatten(array, axis=0)\n        <Array [[1.1, 2.2, 3.3], [4.4], [], [5.5]] type=\'4 * var * float64\'>\n\n    As a technical detail, the flattening operation can be trivial in a common\n    case, #ak.layout.ListOffsetArray in which the first `offset` is `0`.\n    In that case, the flattened data is simply the array node\'s `content`.\n\n        >>> array.layout\n        <ListOffsetArray64>\n            <offsets><Index64 i=""[0 4 4 6]"" offset=""0"" length=""4""/></offsets>\n            <content><ListOffsetArray64>\n                <offsets><Index64 i=""[0 3 3 5 6 7 9]"" offset=""0"" length=""7""/></offsets>\n                <content>\n                    <NumpyArray format=""d"" shape=""9"" data=""1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 9.9""/>\n                </content>\n            </ListOffsetArray64></content>\n        </ListOffsetArray64>\n        >>> np.asarray(array.layout.content.content)\n        array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n\n    However, it is important to keep in mind that this is a special case:\n    #ak.flatten and `content` are not interchangeable!\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n\n    if axis is None:\n        out = awkward1._util.completely_flatten(layout)\n        assert isinstance(out, tuple) and all(isinstance(x, numpy.ndarray) for x in out)\n\n        if any(isinstance(x, numpy.ma.MaskedArray) for x in out):\n            out = awkward1.layout.NumpyArray(numpy.ma.concatenate(out))\n        else:\n            out = awkward1.layout.NumpyArray(numpy.concatenate(out))\n\n    elif awkward1.layout.Content.axis_wrap_if_negative(axis) == 0:\n\n        def apply(layout):\n            if isinstance(layout, awkward1._util.virtualtypes):\n                return apply(layout.array)\n\n            elif isinstance(layout, awkward1._util.unknowntypes):\n                return apply(awkward1.layout.NumpyArray(numpy.array([])))\n\n            elif isinstance(layout, awkward1._util.indexedtypes):\n                return apply(layout.project())\n\n            elif isinstance(layout, awkward1._util.uniontypes):\n                if not any(\n                    isinstance(x, awkward1._util.optiontypes)\n                    and not isinstance(x, awkward1.layout.UnmaskedArray)\n                    for x in layout.contents\n                ):\n                    return layout\n\n                tags = numpy.asarray(layout.tags)\n                index = numpy.array(numpy.asarray(layout.index), copy=True)\n                bigmask = numpy.empty(len(index), dtype=numpy.bool_)\n                for tag, content in enumerate(layout.contents):\n                    if isinstance(\n                        content, awkward1._util.optiontypes\n                    ) and not isinstance(content, awkward1.layout.UnmaskedArray):\n                        bigmask[:] = False\n                        bigmask[tags == tag] = numpy.asarray(content.bytemask()).view(\n                            numpy.bool_\n                        )\n                        index[bigmask] = -1\n\n                good = index >= 0\n                return awkward1.layout.UnionArray8_64(\n                    awkward1.layout.Index8(tags[good]),\n                    awkward1.layout.Index64(index[good]),\n                    layout.contents,\n                )\n\n            elif isinstance(layout, awkward1._util.optiontypes):\n                return layout.project()\n\n            else:\n                return layout\n\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            out = awkward1.partition.IrregularlyPartitionedArray(\n                [apply(x) for x in layout.partitions]\n            )\n        else:\n            out = apply(layout)\n\n        if highlevel:\n            return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n        else:\n            return out\n\n    else:\n        out = layout.flatten(axis)\n\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef pad_none(array, target, axis=1, clip=False, highlevel=True):\n    """"""\n    Args:\n        array: Data containing nested lists to pad to a target length.\n        target (int): The intended length of the lists. If `clip=True`,\n            the output lists will have exactly this length; otherwise,\n            they will have *at least* this length.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        clip (bool): If True, the output lists will have regular lengths\n            (#ak.types.RegularType) of exactly `target`; otherwise the\n            output lists will have in-principle variable lengths\n            (#ak.types.ListType) of at least `target`.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Increase the lengths of lists to a target length by adding None values.\n\n    Consider the following doubly nested `array`.\n\n        ak.Array([[\n                   [1.1, 2.2, 3.3],\n                   [],\n                   [4.4, 5.5],\n                   [6.6]],\n                  [],\n                  [\n                   [7.7],\n                   [8.8, 9.9]\n                  ]])\n\n    At `axis=0`, this operation pads the whole array, adding None at the\n    outermost level:\n\n        >>> ak.to_list(ak.pad_none(array, 5, axis=0))\n        [[\n          [1.1, 2.2, 3.3],\n          [],\n          [4.4, 5.5],\n          [6.6]],\n         [],\n         [\n          [7.7],\n          [8.8, 9.9]\n         ],\n         None,\n         None]\n\n    At `axis=1`, this operation pads the first nested level:\n\n        >>> ak.to_list(ak.pad_none(array, 3, axis=1))\n        [[\n          [1.1, 2.2, 3.3],\n          [],\n          [4.4, 5.5],\n          [6.6]\n         ],\n         [\n          None,\n          None,\n          None],\n         [\n          [7.7],\n          [8.8, 9.9],\n          None\n         ]]\n\n    And so on for higher values of `axis`:\n\n        >>> ak.to_list(ak.pad_none(array, 2, axis=2))\n        [[\n          [1.1, 2.2, 3.3],\n          [None, None],\n          [4.4, 5.5],\n          [6.6, None]\n         ],\n         [],\n         [\n          [7.7, None],\n          [8.8, 9.9]\n         ]]\n\n    Note that the `clip` parameter not only determines whether the lengths are\n    at least `target` or exactly `target`, it also determines the type of the\n    output:\n\n       * `clip=True` returns regular lists (#ak.types.RegularType), and\n       * `clip=False` returns in-principle variable lengths\n         (#ak.types.ListType).\n\n    The in-principle variable-length lists might, in fact, all have the same\n    length, but the type difference is significant, for instance in\n    broadcasting rules (see #ak.broadcast_arrays).\n\n    The difference between\n\n        >>> ak.pad_none(array, 2, axis=2)\n        <Array [[[1.1, 2.2, 3.3], ... [8.8, 9.9]]] type=\'3 * var * var * ?float64\'>\n\n    and\n\n        >>> ak.pad_none(array, 2, axis=2, clip=True)\n        <Array [[[1.1, 2.2], [None, ... [8.8, 9.9]]] type=\'3 * var * 2 * ?float64\'>\n\n    is not just in the length of `[1.1, 2.2, 3.3]` vs `[1.1, 2.2]`, but also\n    in the distinction between the following types.\n\n        >>> ak.type(ak.pad_none(array, 2, axis=2))\n        3 * var * var * ?float64\n        >>> ak.type(ak.pad_none(array, 2, axis=2, clip=True))\n        3 * var *   2 * ?float64\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if clip:\n        out = layout.rpad_and_clip(target, axis)\n    else:\n        out = layout.rpad(target, axis)\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef fill_none(array, value, highlevel=True):\n    """"""\n    Args:\n        array: Data in which to replace None with a given value.\n        value: Data with which to replace None.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Replaces missing values (None) with a given `value`.\n\n    For example, in the following `array`,\n\n        ak.Array([[1.1, None, 2.2], [], [None, 3.3, 4.4]])\n\n    The None values could be replaced with `0` by\n\n        >>> ak.fill_none(array, 0)\n        <Array [[1.1, 0, 2.2], [], [0, 3.3, 4.4]] type=\'3 * var * float64\'>\n\n    The replacement value doesn\'t strictly need the same type as the\n    surrounding data. For example, the None values could also be replaced\n    by a string.\n\n        >>> ak.fill_none(array, ""hi"")\n        <Array [[1.1, \'hi\', 2.2], ... [\'hi\', 3.3, 4.4]] type=\'3 * var * union[float64, s...\'>\n\n    The list content now has a union type:\n\n        >>> ak.type(ak.fill_none(array, ""hi""))\n        3 * var * union[float64, string]\n\n    The values could be floating-point numbers or strings.\n    """"""\n    arraylayout = awkward1.operations.convert.to_layout(\n        array, allow_record=True, allow_other=False\n    )\n\n    if isinstance(arraylayout, awkward1.partition.PartitionedArray):\n        out = awkward1.partition.apply(\n            lambda x: fill_none(x, value, highlevel=False), arraylayout\n        )\n\n    else:\n        if isinstance(value, Iterable) and not (\n            isinstance(value, (str, bytes))\n            or (awkward1._util.py27 and isinstance(value, awkward1._util.unicode))\n        ):\n            valuelayout = awkward1.operations.convert.to_layout(\n                value, allow_record=True, allow_other=False\n            )\n            if isinstance(valuelayout, awkward1.layout.Record):\n                valuelayout = valuelayout.array[valuelayout.at : valuelayout.at + 1]\n            elif len(valuelayout) == 0:\n                offsets = awkward1.layout.Index64(\n                    numpy.array([0, 0], dtype=numpy.int64)\n                )\n                valuelayout = awkward1.layout.ListOffsetArray64(offsets, valuelayout)\n            else:\n                valuelayout = awkward1.layout.RegularArray(\n                    valuelayout, len(valuelayout)\n                )\n        else:\n            valuelayout = awkward1.operations.convert.to_layout(\n                [value], allow_record=True, allow_other=False\n            )\n\n        out = arraylayout.fillna(valuelayout)\n\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef is_none(array, highlevel=True):\n    """"""\n    Args:\n        array: Data to check for missing values (None).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns an array whose value is True where an element of `array` is None;\n    False otherwise.\n    """"""\n\n    def apply(layout):\n        if isinstance(layout, awkward1._util.virtualtypes):\n            return apply(layout.array)\n\n        elif isinstance(layout, awkward1._util.unknowntypes):\n            return apply(awkward1.layout.NumpyArray(numpy.array([])))\n\n        elif isinstance(layout, awkward1._util.indexedtypes):\n            return apply(layout.project())\n\n        elif isinstance(layout, awkward1._util.uniontypes):\n            contents = [apply(layout.project(i)) for i in range(layout.numcontents)]\n            out = numpy.empty(len(layout), dtype=numpy.bool_)\n            tags = numpy.asarray(layout.tags)\n            for tag, content in enumerate(contents):\n                out[tags == tag] = content\n            return out\n\n        elif isinstance(layout, awkward1._util.optiontypes):\n            return numpy.asarray(layout.bytemask()).view(numpy.bool_)\n\n        else:\n            return numpy.zeros(len(layout), dtype=numpy.bool_)\n\n    layout = awkward1.operations.convert.to_layout(array, allow_record=False)\n\n    if isinstance(layout, awkward1.partition.PartitionedArray):\n        out = awkward1.partition.apply(\n            lambda x: awkward1.layout.NumpyArray(apply(x)), layout\n        )\n    else:\n        out = awkward1.layout.NumpyArray(apply(layout))\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef singletons(array, highlevel=True):\n    """"""\n    Args:\n        array: Data to wrap in lists of length 1 if present and length 0\n            if missing (None).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Returns a singleton list (length 1) wrapping each non-missing value and\n    an empty list (length 0) in place of each missing value.\n\n    For example,\n\n        >>> array = ak.Array([1.1, 2.2, None, 3.3, None, None, 4.4, 5.5])\n        >>> print(ak.singletons(array))\n        [[1.1], [2.2], [], [3.3], [], [], [4.4], [5.5]]\n\n    See #ak.firsts to invert this function.\n    """"""\n\n    def getfunction(layout, depth):\n        if isinstance(layout, awkward1._util.optiontypes):\n            nulls = numpy.asarray(layout.bytemask()).view(numpy.bool_)\n            offsets = numpy.ones(len(layout) + 1, dtype=numpy.int64)\n            offsets[0] = 0\n            offsets[1:][nulls] = 0\n            numpy.cumsum(offsets, out=offsets)\n            return lambda: awkward1.layout.ListOffsetArray64(\n                awkward1.layout.Index64(offsets), layout.project()\n            )\n        else:\n            return None\n\n    layout = awkward1.operations.convert.to_layout(array)\n    out = awkward1._util.recursively_apply(layout, getfunction)\n\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef firsts(array, axis=1, highlevel=True):\n    """"""\n    Args:\n        array: Data from which to select the first elements from nested lists.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Selects the first element of each non-empty list and inserts None for each\n    empty list.\n\n    For example,\n\n        >>> array = ak.Array([[1.1], [2.2], [], [3.3], [], [], [4.4], [5.5]])\n        >>> print(ak.firsts(array))\n        [1.1, 2.2, None, 3.3, None, None, 4.4, 5.5]\n\n    See #ak.singletons to invert this function.\n    """"""\n    if axis <= 0:\n        raise NotImplementedError(""ak.firsts with axis={0}"".format(axis))\n    toslice = (slice(None, None, None),) * axis + (0,)\n    out = awkward1.mask(array, awkward1.num(array, axis=axis) > 0, highlevel=False)[\n        toslice\n    ]\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef cartesian(\n    arrays, axis=1, nested=None, parameters=None, with_name=None, highlevel=True\n):\n    """"""\n    Args:\n        arrays (dict or iterable of arrays): Arrays on which to compute the\n            Cartesian product.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        nested (None, True, False, or iterable of str or int): If None or\n            False, all combinations of elements from the `arrays` are\n            produced at the same level of nesting; if True, they are grouped\n            in nested lists by combinations that share a common item from\n            each of the `arrays`; if an iterable of str or int, group common\n            items for a chosen set of keys from the `array` dict or slots\n            of the `array` iterable.\n        parameters (None or dict): Parameters for the new\n            #ak.layout.RecordArray node that is created by this operation.\n        with_name (None or str): Assigns a `""__record__""` name to the new\n            #ak.layout.RecordArray node that is created by this operation\n            (overriding `parameters`, if necessary).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Computes a Cartesian product (i.e. cross product) of data from a set of\n    `arrays`. This operation creates records (if `arrays` is a dict) or tuples\n    (if `arrays` is another kind of iterable) that hold the combinations\n    of elements, and it can introduce new levels of nesting.\n\n    As a simple example with `axis=0`, the Cartesian product of\n\n        >>> one = ak.Array([1, 2, 3])\n        >>> two = ak.Array([""a"", ""b""])\n\n    is\n\n        >>> ak.to_list(ak.cartesian([one, two], axis=0))\n        [(1, \'a\'), (1, \'b\'), (2, \'a\'), (2, \'b\'), (3, \'a\'), (3, \'b\')]\n\n    With nesting, a new level of nested lists is created to group combinations\n    that share the same element from `one` into the same list.\n\n        >>> ak.to_list(ak.cartesian([one, two], axis=0, nested=True))\n        [[(1, \'a\'), (1, \'b\')], [(2, \'a\'), (2, \'b\')], [(3, \'a\'), (3, \'b\')]]\n\n    The primary purpose of this function, however, is to compute a different\n    Cartesian product for each element of an array: in other words, `axis=1`.\n    The following arrays each have four elements.\n\n        >>> one = ak.Array([[1, 2, 3], [], [4, 5], [6]])\n        >>> two = ak.Array([[""a"", ""b""], [""c""], [""d""], [""e"", ""f""]])\n\n    The default `axis=1` produces 6 pairs from the Cartesian product of\n    `[1, 2, 3]` and `[""a"", ""b""]`, 0 pairs from `[]` and `[""c""]`, 1 pair from\n    `[4, 5]` and `[""d""]`, and 1 pair from `[6]` and `[""e"", ""f""]`.\n\n        >>> ak.to_list(ak.cartesian([one, two]))\n        [[(1, \'a\'), (1, \'b\'), (2, \'a\'), (2, \'b\'), (3, \'a\'), (3, \'b\')],\n         [],\n         [(4, \'d\'), (5, \'d\')],\n         [(6, \'e\'), (6, \'f\')]]\n\n    The nesting depth is the same as the original arrays; with `nested=True`,\n    the nesting depth is increased by 1 and tuples are grouped by their\n    first element.\n\n        >>> ak.to_list(ak.cartesian([one, two], nested=True))\n        [[[(1, \'a\'), (1, \'b\')], [(2, \'a\'), (2, \'b\')], [(3, \'a\'), (3, \'b\')]],\n         [],\n         [[(4, \'d\')], [(5, \'d\')]],\n         [[(6, \'e\'), (6, \'f\')]]]\n\n    These tuples are #ak.layout.RecordArray nodes with unnamed fields. To\n    name the fields, we can pass `one` and `two` in a dict, rather than a list.\n\n        >>> ak.to_list(ak.cartesian({""x"": one, ""y"": two}))\n        [\n         [{\'x\': 1, \'y\': \'a\'},\n          {\'x\': 1, \'y\': \'b\'},\n          {\'x\': 2, \'y\': \'a\'},\n          {\'x\': 2, \'y\': \'b\'},\n          {\'x\': 3, \'y\': \'a\'},\n          {\'x\': 3, \'y\': \'b\'}],\n         [],\n         [{\'x\': 4, \'y\': \'d\'},\n          {\'x\': 5, \'y\': \'d\'}],\n         [{\'x\': 6, \'y\': \'e\'},\n          {\'x\': 6, \'y\': \'f\'}]\n        ]\n\n    With more than two elements in the Cartesian product, `nested` can specify\n    which are grouped and which are not. For example,\n\n        >>> one = ak.Array([1, 2, 3, 4])\n        >>> two = ak.Array([1.1, 2.2, 3.3])\n        >>> three = ak.Array([""a"", ""b""])\n\n    can be left entirely ungrouped:\n\n        >>> ak.to_list(ak.cartesian([one, two, three], axis=0))\n        [\n         (1, 1.1, \'a\'),\n         (1, 1.1, \'b\'),\n         (1, 2.2, \'a\'),\n         (1, 2.2, \'b\'),\n         (1, 3.3, \'a\'),\n         (1, 3.3, \'b\'),\n         (2, 1.1, \'a\'),\n         (2, 1.1, \'b\'),\n         (2, 2.2, \'a\'),\n         (2, 2.2, \'b\'),\n         (2, 3.3, \'a\'),\n         (2, 3.3, \'b\'),\n         (3, 1.1, \'a\'),\n         (3, 1.1, \'b\'),\n         (3, 2.2, \'a\'),\n         (3, 2.2, \'b\'),\n         (3, 3.3, \'a\'),\n         (3, 3.3, \'b\'),\n         (4, 1.1, \'a\'),\n         (4, 1.1, \'b\'),\n         (4, 2.2, \'a\'),\n         (4, 2.2, \'b\'),\n         (4, 3.3, \'a\'),\n         (4, 3.3, \'b\')\n        ]\n\n    can be grouped by `one` (adding 1 more dimension):\n\n        >>> ak.to_list(ak.cartesian([one, two, three], axis=0, nested=[0]))\n        [\n         [(1, 1.1, \'a\'), (1, 1.1, \'b\'), (1, 2.2, \'a\')],\n         [(1, 2.2, \'b\'), (1, 3.3, \'a\'), (1, 3.3, \'b\')],\n         [(2, 1.1, \'a\'), (2, 1.1, \'b\'), (2, 2.2, \'a\')],\n         [(2, 2.2, \'b\'), (2, 3.3, \'a\'), (2, 3.3, \'b\')],\n         [(3, 1.1, \'a\'), (3, 1.1, \'b\'), (3, 2.2, \'a\')],\n         [(3, 2.2, \'b\'), (3, 3.3, \'a\'), (3, 3.3, \'b\')],\n         [(4, 1.1, \'a\'), (4, 1.1, \'b\'), (4, 2.2, \'a\')],\n         [(4, 2.2, \'b\'), (4, 3.3, \'a\'), (4, 3.3, \'b\')]\n        ]\n\n    can be grouped by `one` and `two` (adding 2 more dimensions):\n\n        >>> ak.to_list(ak.cartesian([one, two, three], axis=0, nested=[0, 1]))\n        [\n         [\n          [(1, 1.1, \'a\'), (1, 1.1, \'b\')],\n          [(1, 2.2, \'a\'), (1, 2.2, \'b\')],\n          [(1, 3.3, \'a\'), (1, 3.3, \'b\')]\n         ],\n         [\n          [(2, 1.1, \'a\'), (2, 1.1, \'b\')],\n          [(2, 2.2, \'a\'), (2, 2.2, \'b\')],\n          [(2, 3.3, \'a\'), (2, 3.3, \'b\')]\n         ],\n         [\n          [(3, 1.1, \'a\'), (3, 1.1, \'b\')],\n          [(3, 2.2, \'a\'), (3, 2.2, \'b\')],\n          [(3, 3.3, \'a\'), (3, 3.3, \'b\')]],\n         [\n          [(4, 1.1, \'a\'), (4, 1.1, \'b\')],\n          [(4, 2.2, \'a\'), (4, 2.2, \'b\')],\n          [(4, 3.3, \'a\'), (4, 3.3, \'b\')]]\n        ]\n\n    or grouped by unique `one`-`two` pairs (adding 1 more dimension):\n\n        >>> ak.to_list(ak.cartesian([one, two, three], axis=0, nested=[1]))\n        [\n         [(1, 1.1, \'a\'), (1, 1.1, \'b\')],\n         [(1, 2.2, \'a\'), (1, 2.2, \'b\')],\n         [(1, 3.3, \'a\'), (1, 3.3, \'b\')],\n         [(2, 1.1, \'a\'), (2, 1.1, \'b\')],\n         [(2, 2.2, \'a\'), (2, 2.2, \'b\')],\n         [(2, 3.3, \'a\'), (2, 3.3, \'b\')],\n         [(3, 1.1, \'a\'), (3, 1.1, \'b\')],\n         [(3, 2.2, \'a\'), (3, 2.2, \'b\')],\n         [(3, 3.3, \'a\'), (3, 3.3, \'b\')],\n         [(4, 1.1, \'a\'), (4, 1.1, \'b\')],\n         [(4, 2.2, \'a\'), (4, 2.2, \'b\')],\n         [(4, 3.3, \'a\'), (4, 3.3, \'b\')]\n        ]\n\n    The order of the output is fixed: it is always lexicographical in the\n    order that the `arrays` are written. (Before Python 3.6, the order of\n    keys in a dict were not guaranteed, so the dict interface is not\n    recommended for these versions of Python.) Thus, it is not possible to\n    group by `three` in the example above.\n\n    To emulate an SQL or Pandas ""group by"" operation, put the keys that you\n    wish to group by *first* and use `nested=[0]` or `nested=[n]` to group by\n    unique n-tuples. If necessary, record keys can later be reordered with a\n    list of strings in #ak.Array.__getitem__.\n\n    To get list index positions in the tuples/records, rather than data from\n    the original `arrays`, use #ak.argcartesian instead of #ak.cartesian. The\n    #ak.argcartesian form can be particularly useful as nested indexing in\n    #ak.Array.__getitem__.\n    """"""\n    behavior = awkward1._util.behaviorof(*arrays)\n\n    is_partitioned = False\n    if isinstance(arrays, dict):\n        new_arrays = {}\n        for n, x in arrays.items():\n            new_arrays[n] = awkward1.operations.convert.to_layout(\n                x, allow_record=False, allow_other=False\n            )\n            if isinstance(new_arrays[n], awkward1.partition.PartitionedArray):\n                is_partitioned = True\n    else:\n        new_arrays = []\n        for x in arrays:\n            new_arrays.append(\n                awkward1.operations.convert.to_layout(\n                    x, allow_record=False, allow_other=False\n                )\n            )\n            if isinstance(new_arrays[-1], awkward1.partition.PartitionedArray):\n                is_partitioned = True\n\n    if with_name is not None:\n        if parameters is None:\n            parameters = {}\n        else:\n            parameters = dict(parameters)\n        parameters[""__record__""] = with_name\n\n    if axis < 0:\n        raise ValueError(""the \'axis\' of cartesian must be non-negative"")\n\n    elif awkward1.layout.Content.axis_wrap_if_negative(axis) == 0:\n        if nested is None or nested is False:\n            nested = []\n\n        if isinstance(new_arrays, dict):\n            if nested is True:\n                nested = list(new_arrays.keys())  # last key is ignored below\n            if any(not (isinstance(n, str) and n in new_arrays) for x in nested):\n                raise ValueError(\n                    ""the \'nested\' parameter of cartesian must be dict keys ""\n                    ""for a dict of arrays""\n                )\n            recordlookup = []\n            layouts = []\n            tonested = []\n            for i, (n, x) in enumerate(new_arrays.items()):\n                recordlookup.append(n)\n                layouts.append(x)\n                if n in nested:\n                    tonested.append(i)\n            nested = tonested\n\n        else:\n            if nested is True:\n                nested = list(range(len(new_arrays) - 1))\n            if any(\n                not (isinstance(x, int) and 0 <= x < len(new_arrays) - 1)\n                for x in nested\n            ):\n                raise ValueError(\n                    ""the \'nested\' prarmeter of cartesian must be integers in ""\n                    ""[0, len(arrays) - 1) for an iterable of arrays""\n                )\n            recordlookup = None\n            layouts = []\n            for x in new_arrays:\n                layouts.append(x)\n\n        layouts = [\n            x.toContent() if isinstance(x, awkward1.partition.PartitionedArray) else x\n            for x in layouts\n        ]\n\n        indexes = [\n            awkward1.layout.Index64(x.reshape(-1))\n            for x in numpy.meshgrid(\n                *[numpy.arange(len(x), dtype=numpy.int64) for x in layouts],\n                indexing=""ij""\n            )\n        ]\n        outs = [\n            awkward1.layout.IndexedArray64(x, y)\n            for x, y in __builtins__[""zip""](indexes, layouts)\n        ]\n\n        result = awkward1.layout.RecordArray(outs, recordlookup, parameters=parameters)\n        for i in range(len(new_arrays) - 1, -1, -1):\n            if i in nested:\n                result = awkward1.layout.RegularArray(result, len(layouts[i + 1]))\n\n    elif is_partitioned:\n        sample = None\n        if isinstance(new_arrays, dict):\n            for x in new_arrays.values():\n                if isinstance(x, awkward1.partition.PartitionedArray):\n                    sample = x\n                    break\n        else:\n            for x in new_arrays:\n                if isinstance(x, awkward1.partition.PartitionedArray):\n                    sample = x\n                    break\n\n        partition_arrays = awkward1.partition.partition_as(sample, new_arrays)\n\n        output = []\n        for part_arrays in awkward1.partition.iterate(\n            sample.numpartitions, partition_arrays\n        ):\n            output.append(\n                cartesian(\n                    part_arrays,\n                    axis=axis,\n                    nested=nested,\n                    parameters=parameters,\n                    with_name=None,  # already set: see above\n                    highlevel=False,\n                )\n            )\n\n        result = awkward1.partition.IrregularlyPartitionedArray(output)\n\n    else:\n\n        def newaxis(layout, i):\n            if i == 0:\n                return layout\n            else:\n                return awkward1.layout.RegularArray(newaxis(layout, i - 1), 1)\n\n        def getfunction1(layout, depth, i):\n            if depth == 2:\n                return lambda: newaxis(layout, i)\n            else:\n                return None\n\n        def getfunction2(layout, depth, i):\n            if depth == axis:\n                inside = len(new_arrays) - i - 1\n                outside = i\n                return lambda: newaxis(\n                    awkward1._util.recursively_apply(\n                        layout, getfunction1, args=(inside,)\n                    ),\n                    outside,\n                )\n            else:\n                return None\n\n        def apply(x, i):\n            return awkward1._util.recursively_apply(\n                awkward1.operations.convert.to_layout(\n                    x, allow_record=False, allow_other=False\n                ),\n                getfunction2,\n                args=(i,),\n            )\n\n        toflatten = []\n        if nested is None or nested is False:\n            nested = []\n\n        if isinstance(new_arrays, dict):\n            if nested is True:\n                nested = list(new_arrays.keys())  # last key is ignored below\n            if any(not (isinstance(n, str) and n in new_arrays) for x in nested):\n                raise ValueError(\n                    ""the \'nested\' parameter of cartesian must be dict keys ""\n                    ""for a dict of arrays""\n                )\n            recordlookup = []\n            layouts = []\n            for i, (n, x) in enumerate(new_arrays.items()):\n                recordlookup.append(n)\n                layouts.append(apply(x, i))\n                if i < len(new_arrays) - 1 and n not in nested:\n                    toflatten.append(axis + i + 1)\n\n        else:\n            if nested is True:\n                nested = list(range(len(new_arrays) - 1))\n            if any(\n                not (isinstance(x, int) and 0 <= x < len(new_arrays) - 1)\n                for x in nested\n            ):\n                raise ValueError(\n                    ""the \'nested\' parameter of cartesian must be integers in ""\n                    ""[0, len(arrays) - 1) for an iterable of arrays""\n                )\n            recordlookup = None\n            layouts = []\n            for i, x in enumerate(new_arrays):\n                layouts.append(apply(x, i))\n                if i < len(new_arrays) - 1 and i not in nested:\n                    toflatten.append(axis + i + 1)\n\n        def getfunction3(inputs, depth):\n            if depth == axis + len(new_arrays):\n                return lambda: (\n                    awkward1.layout.RecordArray(\n                        inputs, recordlookup, parameters=parameters\n                    ),\n                )\n            else:\n                return None\n\n        out = awkward1._util.broadcast_and_apply(layouts, getfunction3, behavior)\n        assert isinstance(out, tuple) and len(out) == 1\n        result = out[0]\n\n        while len(toflatten) != 0:\n            axis = toflatten.pop()\n            result = flatten(result, axis=axis, highlevel=False)\n\n    if highlevel:\n        return awkward1._util.wrap(result, behavior)\n    else:\n        return result\n\n\ndef argcartesian(\n    arrays, axis=1, nested=None, parameters=None, with_name=None, highlevel=True\n):\n    """"""\n    Args:\n        arrays (dict or iterable of arrays): Arrays on which to compute the\n            Cartesian product.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        nested (None, True, False, or iterable of str or int): If None or\n            False, all combinations of elements from the `arrays` are\n            produced at the same level of nesting; if True, they are grouped\n            in nested lists by combinations that share a common item from\n            each of the `arrays`; if an iterable of str or int, group common\n            items for a chosen set of keys from the `array` dict or slots\n            of the `array` iterable.\n        parameters (None or dict): Parameters for the new\n            #ak.layout.RecordArray node that is created by this operation.\n        with_name (None or str): Assigns a `""__record__""` name to the new\n            #ak.layout.RecordArray node that is created by this operation\n            (overriding `parameters`, if necessary).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Computes a Cartesian product (i.e. cross product) of data from a set of\n    `arrays`, like #ak.cartesian, but returning integer indexes for\n    #ak.Array.__getitem__.\n\n    For example, the Cartesian product of\n\n        >>> one = ak.Array([1.1, 2.2, 3.3])\n        >>> two = ak.Array([""a"", ""b""])\n\n    is\n\n        >>> ak.to_list(ak.cartesian([one, two], axis=0))\n        [(1.1, \'a\'), (1.1, \'b\'), (2.2, \'a\'), (2.2, \'b\'), (3.3, \'a\'), (3.3, \'b\')]\n\n    But with argcartesian, only the indexes are returned.\n\n        >>> ak.to_list(ak.argcartesian([one, two], axis=0))\n        [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]\n\n    These are the indexes that can select the items that go into the actual\n    Cartesian product.\n\n        >>> one_index, two_index = ak.unzip(ak.argcartesian([one, two], axis=0))\n        >>> one[one_index]\n        <Array [1.1, 1.1, 2.2, 2.2, 3.3, 3.3] type=\'6 * float64\'>\n        >>> two[two_index]\n        <Array [\'a\', \'b\', \'a\', \'b\', \'a\', \'b\'] type=\'6 * string\'>\n\n    All of the parameters for #ak.cartesian apply equally to #ak.argcartesian,\n    so see the #ak.cartesian documentation for a more complete description.\n    """"""\n    if axis < 0:\n        raise ValueError(""the \'axis\' of argcartesian must be non-negative"")\n\n    else:\n        if isinstance(arrays, dict):\n            layouts = dict(\n                (\n                    n,\n                    awkward1.operations.convert.to_layout(\n                        x, allow_record=False, allow_other=False\n                    ).localindex(axis),\n                )\n                for n, x in arrays.items()\n            )\n        else:\n            layouts = [\n                awkward1.operations.convert.to_layout(\n                    x, allow_record=False, allow_other=False\n                ).localindex(axis)\n                for x in arrays\n            ]\n\n        if with_name is not None:\n            if parameters is None:\n                parameters = {}\n            else:\n                parameters = dict(parameters)\n            parameters[""__record__""] = with_name\n\n        result = cartesian(\n            layouts, axis=axis, nested=nested, parameters=parameters, highlevel=False\n        )\n\n        if highlevel:\n            return awkward1._util.wrap(result, awkward1._util.behaviorof(*arrays))\n        else:\n            return result\n\n\ndef combinations(\n    array,\n    n,\n    replacement=False,\n    axis=1,\n    keys=None,\n    parameters=None,\n    with_name=None,\n    highlevel=True,\n):\n    """"""\n    Args:\n        array: Array from which to choose `n` items without replacement.\n        n (int): The number of items to choose in each list: `2` chooses\n            unique pairs, `3` chooses unique triples, etc.\n        replacement (bool): If True, combinations that include the same\n            item more than once are allowed; otherwise each item in a\n            combinations is strictly unique.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        keys (None or list of str): If None, the pairs/triples/etc. are\n            tuples with unnamed fields; otherwise, these `keys` name the\n            fields. The number of `keys` must be equal to `n`.\n        parameters (None or dict): Parameters for the new\n            #ak.layout.RecordArray node that is created by this operation.\n        with_name (None or str): Assigns a `""__record__""` name to the new\n            #ak.layout.RecordArray node that is created by this operation\n            (overriding `parameters`, if necessary).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Computes a Cartesian product (i.e. cross product) of `array` with itself\n    that is restricted to combinations sampled without replacement. If the\n    normal Cartesian product is thought of as an `n` dimensional tensor, these\n    represent the ""upper triangle"" of sets without repetition. If\n    `replacement=True`, the diagonal of this ""upper triangle"" is included.\n\n    As a simple example with `axis=0`, consider the following `array`\n\n        ak.Array([""a"", ""b"", ""c"", ""d"", ""e""])\n\n    The combinations choose `2` are:\n\n        >>> ak.to_list(ak.combinations(array, 2, axis=0))\n        [(\'a\', \'b\'), (\'a\', \'c\'), (\'a\', \'d\'), (\'a\', \'e\'),\n                     (\'b\', \'c\'), (\'b\', \'d\'), (\'b\', \'e\'),\n                                 (\'c\', \'d\'), (\'c\', \'e\'),\n                                             (\'d\', \'e\')]\n\n    Including the diagonal allows pairs like `(\'a\', \'a\')`.\n\n        >>> ak.to_list(ak.combinations(array, 2, axis=0, replacement=True))\n        [(\'a\', \'a\'), (\'a\', \'b\'), (\'a\', \'c\'), (\'a\', \'d\'), (\'a\', \'e\'),\n                     (\'b\', \'b\'), (\'b\', \'c\'), (\'b\', \'d\'), (\'b\', \'e\'),\n                                 (\'c\', \'c\'), (\'c\', \'d\'), (\'c\', \'e\'),\n                                             (\'d\', \'d\'), (\'d\', \'e\'),\n                                                         (\'e\', \'e\')]\n\n    The combinations choose `3` can\'t be easily arranged as a triangle\n    in two dimensions.\n\n        >>> ak.to_list(ak.combinations(array, 3, axis=0))\n        [(\'a\', \'b\', \'c\'), (\'a\', \'b\', \'d\'), (\'a\', \'b\', \'e\'), (\'a\', \'c\', \'d\'), (\'a\', \'c\', \'e\'),\n         (\'a\', \'d\', \'e\'), (\'b\', \'c\', \'d\'), (\'b\', \'c\', \'e\'), (\'b\', \'d\', \'e\'), (\'c\', \'d\', \'e\')]\n\n    Including the (three-dimensional) diagonal allows triples like\n    `(\'a\', \'a\', \'a\')`, but also `(\'a\', \'a\', \'b\')`, `(\'a\', \'b\', \'b\')`, etc.,\n    but not `(\'a\', \'b\', \'a\')`. All combinations are in the same order as\n    the original array.\n\n        >>> ak.to_list(ak.combinations(array, 3, axis=0, replacement=True))\n        [(\'a\', \'a\', \'a\'), (\'a\', \'a\', \'b\'), (\'a\', \'a\', \'c\'), (\'a\', \'a\', \'d\'), (\'a\', \'a\', \'e\'),\n         (\'a\', \'b\', \'b\'), (\'a\', \'b\', \'c\'), (\'a\', \'b\', \'d\'), (\'a\', \'b\', \'e\'), (\'a\', \'c\', \'c\'),\n         (\'a\', \'c\', \'d\'), (\'a\', \'c\', \'e\'), (\'a\', \'d\', \'d\'), (\'a\', \'d\', \'e\'), (\'a\', \'e\', \'e\'),\n         (\'b\', \'b\', \'b\'), (\'b\', \'b\', \'c\'), (\'b\', \'b\', \'d\'), (\'b\', \'b\', \'e\'), (\'b\', \'c\', \'c\'),\n         (\'b\', \'c\', \'d\'), (\'b\', \'c\', \'e\'), (\'b\', \'d\', \'d\'), (\'b\', \'d\', \'e\'), (\'b\', \'e\', \'e\'),\n         (\'c\', \'c\', \'c\'), (\'c\', \'c\', \'d\'), (\'c\', \'c\', \'e\'), (\'c\', \'d\', \'d\'), (\'c\', \'d\', \'e\'),\n         (\'c\', \'e\', \'e\'), (\'d\', \'d\', \'d\'), (\'d\', \'d\', \'e\'), (\'d\', \'e\', \'e\'), (\'e\', \'e\', \'e\')]\n\n    The primary purpose of this function, however, is to compute a different\n    set of combinations for each element of an array: in other words, `axis=1`.\n    The following `array` has a different number of items in each element.\n\n        ak.Array([[1, 2, 3, 4], [], [5], [6, 7, 8]])\n\n    There are 6 ways to choose pairs from 4 elements, 0 ways to choose pairs\n    from 0 elements, 0 ways to choose pairs from 1 element, and 3 ways to\n    choose pairs from 3 elements.\n\n        >>> ak.to_list(ak.combinations(array, 2))\n        [\n         [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)],\n         [],\n         [],\n         [(6, 7), (6, 8), (7, 8)]\n        ]\n\n    Note, however, that the combinatorics isn\'t determined by equality of\n    the data themselves, but by their placement in the array. For example,\n    even if all elements of an array are equal, the output has the same\n    structure.\n\n        >>> same = ak.Array([[7, 7, 7, 7], [], [7], [7, 7, 7]])\n        >>> ak.to_list(ak.combinations(same, 2))\n        [\n         [(7, 7), (7, 7), (7, 7), (7, 7), (7, 7), (7, 7)],\n         [],\n         [],\n         [(7, 7), (7, 7), (7, 7)]\n        ]\n\n    To get records instead of tuples, pass a set of field names to `keys`.\n\n        >>> ak.to_list(ak.combinations(array, 2, keys=[""x"", ""y""]))\n        [\n         [{\'x\': 1, \'y\': 2}, {\'x\': 1, \'y\': 3}, {\'x\': 1, \'y\': 4},\n                            {\'x\': 2, \'y\': 3}, {\'x\': 2, \'y\': 4},\n                                              {\'x\': 3, \'y\': 4}],\n         [],\n         [],\n         [{\'x\': 6, \'y\': 7}, {\'x\': 6, \'y\': 8},\n                            {\'x\': 7, \'y\': 8}]]\n\n    This operation can be constructed from #ak.argcartesian and other\n    primitives:\n\n        >>> left, right = ak.unzip(ak.argcartesian([array, array]))\n        >>> keep = left < right\n        >>> result = ak.zip([array[left][keep], array[right][keep]])\n        >>> ak.to_list(result)\n        [\n         [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)],\n         [],\n         [],\n         [(6, 7), (6, 8), (7, 8)]]\n\n    but it is frequently needed for data analysis, and the logic of which\n    indexes to `keep` (above) gets increasingly complicated for large `n`.\n\n    To get list index positions in the tuples/records, rather than data from\n    the original `array`, use #ak.argcombinations instead of #ak.combinations.\n    The #ak.argcombinations form can be particularly useful as nested indexing\n    in #ak.Array.__getitem__.\n    """"""\n    if parameters is None:\n        parameters = {}\n    else:\n        parameters = dict(parameters)\n    if with_name is not None:\n        parameters[""__record__""] = with_name\n\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    out = layout.combinations(\n        n, replacement=replacement, keys=keys, parameters=parameters, axis=axis\n    )\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef argcombinations(\n    array,\n    n,\n    replacement=False,\n    axis=1,\n    keys=None,\n    parameters=None,\n    with_name=None,\n    highlevel=True,\n):\n    """"""\n    Args:\n        array: Array from which to choose `n` items without replacement.\n        n (int): The number of items to choose from each list: `2` chooses\n            unique pairs, `3` chooses unique triples, etc.\n        replacement (bool): If True, combinations that include the same\n            item more than once are allowed; otherwise each item in a\n            combinations is strictly unique.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n        keys (None or list of str): If None, the pairs/triples/etc. are\n            tuples with unnamed fields; otherwise, these `keys` name the\n            fields. The number of `keys` must be equal to `n`.\n        parameters (None or dict): Parameters for the new\n            #ak.layout.RecordArray node that is created by this operation.\n        with_name (None or str): Assigns a `""__record__""` name to the new\n            #ak.layout.RecordArray node that is created by this operation\n            (overriding `parameters`, if necessary).\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Computes a Cartesian product (i.e. cross product) of `array` with itself\n    that is restricted to combinations sampled without replacement,\n    like #ak.combinations, but returning integer indexes for\n    #ak.Array.__getitem__.\n\n    The motivation and uses of this function are similar to those of\n    #ak.argcartesian. See #ak.combinations and #ak.argcartesian for a more\n    complete description.\n    """"""\n    if parameters is None:\n        parameters = {}\n    else:\n        parameters = dict(parameters)\n    if with_name is not None:\n        parameters[""__record__""] = with_name\n\n    if axis < 0:\n        raise ValueError(""the \'axis\' for argcombinations must be non-negative"")\n    else:\n        layout = awkward1.operations.convert.to_layout(\n            array, allow_record=False, allow_other=False\n        ).localindex(axis)\n        out = layout.combinations(\n            n, replacement=replacement, keys=keys, parameters=parameters, axis=axis\n        )\n        if highlevel:\n            return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n        else:\n            return out\n\n\ndef partitions(array):\n    """"""\n    Args:\n        array: A possibly-partitioned array.\n\n    Returns a list of partition lengths if the array is a PartitionedArray;\n    returns None otherwise.\n\n    Partitioning is an internal aspect of an array: it should behave\n    identically to a non-partitioned array, but possibly with different\n    performance characteristics.\n\n    Arrays can only be partitioned in the first dimension; it is intended\n    for performing calculations in memory-sized chunks.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n    if isinstance(layout, awkward1.partition.PartitionedArray):\n        return layout.lengths\n    else:\n        return None\n\n\ndef partitioned(generate, numpartitions, highlevel=True, behavior=None):\n    """"""\n    Args:\n        generate (int -> array): A function that generates an array partition\n            given a partition number.\n        numpartitions (int): Number of partitions to generate.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content or #ak.partition.PartitionedArray\n            subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n\n    Returns a partitioned array, produced by calling a function for each\n    partition.\n\n    Partitioning is an internal aspect of an array: it should behave\n    identically to a non-partitioned array, but possibly with different\n    performance characteristics.\n\n    Arrays can only be partitioned in the first dimension; it is intended\n    for performing calculations in memory-sized chunks.\n    """"""\n    total_length = 0\n    partitions = []\n    stops = []\n    for partitionid in range(numpartitions):\n        layout = awkward1.operations.convert.to_layout(\n            generate(partitionid), allow_record=False, allow_other=False\n        )\n        total_length += len(layout)\n        partitions.append(layout)\n        stops.append(total_length)\n\n    out = awkward1.partition.IrregularlyPartitionedArray(partitions, stops)\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=behavior)\n    else:\n        return out\n\n\ndef repartition(array, lengths, highlevel=True):\n    """"""\n    Args:\n        array: A possibly-partitioned array.\n        lengths (None, int, or iterable of int): If None, concatenate the\n            pieces of a partitioned array into a non-partitioned array.\n            If an integer, split or repartition into partitions of the\n            given number of entries (except the last, if the length of the\n            array doesn\'t fit an integer number of equal-sized chunks).\n            If an iterable of integers, split or repartition into the given\n            sequence of lengths.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content or #ak.partition.PartitionedArray\n            subclass.\n\n    Returns a possibly-partitioned array: unpartitioned if `lengths` is None;\n    partitioned otherwise.\n\n    Partitioning is an internal aspect of an array: it should behave\n    identically to a non-partitioned array, but possibly with different\n    performance characteristics.\n\n    Arrays can only be partitioned in the first dimension; it is intended\n    for performing calculations in memory-sized chunks.\n    """"""\n    layout = awkward1.operations.convert.to_layout(\n        array, allow_record=False, allow_other=False\n    )\n\n    if lengths is None:\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            out = layout.toContent()\n        else:\n            out = layout\n\n    else:\n        if isinstance(lengths, (int, numbers.Integral, numpy.integer)):\n            if lengths < 1:\n                raise ValueError(\n                    ""lengths must be at least 1 (and probably "" ""considerably more)""\n                )\n\n            howmany = len(layout) // lengths\n            remainder = len(layout) - howmany * lengths\n            if remainder == 0:\n                lengths = [lengths] * howmany\n            else:\n                lengths = [lengths] * howmany + [remainder]\n\n        total_length = 0\n        stops = []\n        for x in lengths:\n            total_length += x\n            stops.append(total_length)\n\n        if total_length != len(layout):\n            raise ValueError(\n                ""cannot repartition array of length {0} into ""\n                ""these lengths"".format(len(layout))\n            )\n\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            out = layout.repartition(stops)\n        else:\n            out = awkward1.partition.IrregularlyPartitionedArray.toPartitioned(\n                layout, stops\n            )\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\ndef virtual(\n    generate,\n    args=(),\n    kwargs={},\n    form=None,\n    length=None,\n    cache=None,\n    cache_key=None,\n    parameters=None,\n    highlevel=True,\n    behavior=None,\n):\n    """"""\n    Args:\n        generate (callable): Function that makes an array from `args` and\n            `kwargs`.\n        args (tuple): Positional arguments to pass to `generate`.\n        kwargs (dict): Keyword arguments to pass to `generate`.\n        form (None, Form, or JSON): If None, the layout of the generated array\n            is unknown until it is generated, which might require it to be\n            generated earlier than intended; if a Form, use this Form to\n            predict the layout and verify that the generated array complies;\n            if a JSON string, convert the JSON into a Form and use it.\n        length (None or int): If None or negative, the length of the generated\n            array is unknown until it is generated, which might require it to\n            be generated earlier than intended; if a non-negative int, use this\n            to predict the length and verify that the generated array complies.\n        cache (None or MutableMapping): If None, arrays are generated every\n            time they are needed; otherwise, generated arrays are stored in the\n            mapping with `__setitem__`, retrieved with `__getitem__`, and only\n            re-generated if `__getitem__` raises a `KeyError`. This mapping may\n            evict elements according to any caching algorithm (LRU, LFR, RR,\n            TTL, etc.).\n        cache_key (None or str): If None, a unique string is generated for this\n            virtual array for use with the `cache` (unique per Python process);\n            otherwise, the explicitly provided key is used (which ought to\n            ensure global uniquness for the scope in which these arrays are\n            used).\n        parameters (None or dict): Parameters for the new\n            #ak.layout.VirtualArray node that is created by this operation.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n        behavior (bool): Custom #ak.behavior for the output array, if\n            high-level.\n\n    Creates a virtual array, an array that is created on demand.\n\n    For example:\n\n        >>> len(array)\n        3\n        >>> awkward1.type(array)\n        3 * var * float64\n        >>> array[2]\n        generating\n        <Array [4.4, 5.5] type=\'2 * float64\'>\n    """"""\n    if form in (\n        ""float64"",\n        ""float32"",\n        ""int64"",\n        ""uint64"",\n        ""int32"",\n        ""uint32"",\n        ""int16"",\n        ""uint16"",\n        ""int8"",\n        ""uint8"",\n        ""bool"",\n    ):\n        form = awkward1.forms.Form.fromjson(\'""\' + form + \'""\')\n\n    elif isinstance(form, (str, bytes)) or (\n        awkward1._util.py27 and isinstance(form, awkward1._util.unicode)\n    ):\n        form = awkward1.forms.Form.fromjson(form)\n\n    elif form is not None and not isinstance(form, awkward1.forms.Form):\n        form = awkward1.forms.Form.fromjson(json.dumps(form))\n\n    gen = awkward1.layout.ArrayGenerator(\n        generate, args, kwargs, form=form, length=length\n    )\n    if cache is not None:\n        cache = awkward1.layout.ArrayCache(cache)\n\n    out = awkward1.layout.VirtualArray(\n        gen, cache, cache_key=cache_key, parameters=parameters\n    )\n\n    if highlevel:\n        return awkward1._util.wrap(out, behavior=behavior)\n    else:\n        return out\n\n\ndef with_cache(array, cache, chain=None, highlevel=True):\n    """"""\n    Args:\n        array: Data to search for nested virtual arrays.\n        cache (None or MutableMapping): If None, arrays are generated every\n            time they are needed; otherwise, generated arrays are stored in the\n            mapping with `__setitem__`, retrieved with `__getitem__`, and only\n            re-generated if `__getitem__` raises a `KeyError`. This mapping may\n            evict elements according to any caching algorithm (LRU, LFR, RR,\n            TTL, etc.).\n        chain (None, ""first"", ""last"", or bool): If None, the provided `cache`\n            simply replaces any existing virtual array caches. If ""first"", the\n            provided `cache` becomes first in a chain of caches; virtual arrays\n            will attempt to `__getitem__`/`__setitem__` the provided `cache`\n            first, falling back to preexisting caches if necessary. If ""last"",\n            the provided `cache` becomes last in a chain of caches: the\n            preexisting caches get priority. If a bool, True is equivalent to\n            ""first"" and False is equivalent to None.\n        highlevel (bool): If True, return an #ak.Array; otherwise, return\n            a low-level #ak.layout.Content subclass.\n\n    Remove caches from all virtual arrays nested within `array` if `cache` is\n    None; adds a cache otherwise.\n\n    For example:\n\n        >>> cache1 = {}\n        >>> one = ak.virtual(lambda: [[1.1, 2.2, 3.3], [], [4.4, 5.5]], cache=cache1, length=3)\n        >>> two = ak.virtual(lambda: [100, 200, 300], cache=cache1, length=3)\n        >>> array1 = ak.zip({""x"": one, ""y"": two}, depth_limit=1)\n        >>> len(cache1)\n        0\n\n    creates an array of records with virtual fields that would fill `cache1`.\n\n    We can then switch every instance of `cache1` in `array` with `cache2`:\n\n        >>> cache2 = {}\n        >>> array2 = ak.with_cache(array1, cache2)\n        >>> array2[""x""]\n        <Array [[1.1, 2.2, 3.3], [], [4.4, 5.5]] type=\'3 * var * float64\'>\n        >>>\n        >>> len(cache1), len(cache2)\n        (0, 1)\n\n    Viewing the `array2[""x""]` filled `cache2` and not `cache1`.\n\n    We can also chain `cache1` and `cache2`:\n\n        >>> array3 = ak.with_cache(array2, cache1, chain=""first"")\n        >>> array3\n        <Array [{x: [1.1, 2.2, 3.3], ... 5.5], y: 300}] type=\'3 * {""x"": var * float64, ...\'>\n        >>>\n        >>> len(cache1), len(cache2)\n        (1, 1)\n\n    The request for `array3[""x""]` deferred to the already-filled `cache2`,\n    while the request for `array3[""y""]` put a new array into `cache1`.\n\n    See #ak.virtual.\n    """"""\n    if chain is True:\n        chain = ""first""\n    elif chain is False:\n        chain = None\n    elif chain is not None and chain not in (""first"", ""last""):\n        raise ValueError(""chain must be None, \'first\', \'last\', or bool"")\n\n    if not isinstance(cache, awkward1.layout.ArrayCache):\n        cache = awkward1.layout.ArrayCache(cache)\n\n    def getfunction(layout, depth):\n        if isinstance(layout, awkward1.layout.VirtualArray):\n            if chain is None:\n                newcache = cache\n            elif cache is None:\n                newcache = layout.cache\n            elif layout.cache is None:\n                newcache = cache\n            elif chain == ""first"":\n                newcache = awkward1.layout.ArrayCache(_CacheChain(cache, layout.cache))\n            elif chain == ""last"":\n                newcache = awkward1.layout.ArrayCache(_CacheChain(layout.cache, cache))\n            return lambda: awkward1.layout.VirtualArray(\n                layout.generator,\n                newcache,\n                layout.cache_key,\n                layout.identities,\n                layout.parameters,\n            )\n        else:\n            return None\n\n    out = awkward1._util.recursively_apply(\n        awkward1.operations.convert.to_layout(array), getfunction\n    )\n    if highlevel:\n        return awkward1._util.wrap(out, awkward1._util.behaviorof(array))\n    else:\n        return out\n\n\nclass _CacheChain(MutableMapping):\n    def __init__(self, first, last):\n        if isinstance(first, awkward1.layout.ArrayCache):\n            first = first.mutablemapping\n        if isinstance(last, awkward1.layout.ArrayCache):\n            last = last.mutablemapping\n        self.first = first\n        self.last = last\n\n    def __getitem__(self, where):\n        try:\n            return self.first[where]\n        except KeyError:\n            return self.last[where]\n\n    def __setitem__(self, where, what):\n        if where not in self.last:\n            self.first[where] = what\n\n    def __delitem__(self, where):\n        try:\n            del self.first[where]\n        except KeyError:\n            del self.last[where]\n\n    def __iter__(self):\n        seen = set()\n        for x in self.first:\n            seen.add(x)\n            yield x\n        for x in self.last:\n            if x not in seen:\n                yield x\n\n    def __len__(self):\n        return len(set(self.first).union(set(self.last)))\n\n\n@awkward1._connect._numpy.implements(numpy.size)\ndef size(array, axis=None):\n    """"""\n    Args:\n        array: Rectilinear array whose `shape` needs to be known.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n\n    Returns an int or a list of ints, one for each regular dimension.\n\n    Implements NumPy\'s\n    [size](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ma.size.html)\n    function in a way that accepts #ak.Array as the `array`.\n\n    If the `array` is not rectilinear (i.e. if #np.to_numpy would raise an\n    error), then this function raise an error.\n    """"""\n    if axis is not None and axis < 0:\n        raise NotImplementedError(""ak.size with axis < 0"")\n\n    def recurse(layout, axis, sizes):\n        if isinstance(layout, awkward1._util.virtualtypes):\n            recurse(layout.array, axis, sizes)\n        elif isinstance(layout, awkward1._util.unknowntypes):\n            pass\n        elif isinstance(layout, awkward1._util.indexedtypes):\n            recurse(layout.content, axis, sizes)\n        elif isinstance(layout, awkward1._util.uniontypes):\n            compare = None\n            for x in layout.contents:\n                inner = []\n                recurse(x, axis, inner)\n                if compare is None:\n                    compare = inner\n                elif compare != inner:\n                    raise ValueError(\n                        ""ak.size is ambiguous due to union of different "" ""sizes""\n                    )\n            sizes.extend(compare)\n        elif isinstance(layout, awkward1._util.optiontypes):\n            return recurse(layout.content, axis, sizes)\n        elif isinstance(layout, awkward1._util.listtypes):\n            if isinstance(layout, awkward1.layout.RegularArray):\n                sizes.append(layout.size)\n            else:\n                sizes.append(None)\n            if axis is None:\n                recurse(layout.content, axis, sizes)\n            elif axis > 0:\n                recurse(layout.content, axis - 1, sizes)\n        elif isinstance(layout, awkward1._util.recordtypes):\n            compare = None\n            for x in layout.contents:\n                inner = []\n                recurse(x, axis, inner)\n                if compare is None:\n                    compare = inner\n                elif compare != inner:\n                    raise ValueError(\n                        ""ak.size is ambiguous due to record of different "" ""sizes""\n                    )\n            sizes.extend(compare)\n        elif isinstance(layout, awkward1.layout.NumpyArray):\n            if axis is None:\n                sizes.extend(numpy.asarray(layout).shape[1:])\n            else:\n                sizes.extend(numpy.asarray(layout).shape[1 : axis + 2])\n        else:\n            raise AssertionError(""unrecognized Content type"")\n\n    layout = awkward1.operations.convert.to_layout(array, allow_record=False)\n    if isinstance(layout, awkward1.partition.PartitionedArray):\n        layout = layout.toContent()\n    layout = awkward1.layout.RegularArray(layout, len(layout))\n\n    sizes = []\n    recurse(layout, axis, sizes)\n\n    if axis is None:\n        out = 1\n        for size in sizes:\n            if size is None:\n                raise ValueError(\n                    ""ak.size is ambiguous due to variable-length arrays ""\n                    ""(try ak.flatten to remove structure or ak.to_numpy ""\n                    ""to force regularity, if possible)""\n                )\n            else:\n                out *= size\n        return out\n    else:\n        if sizes[-1] is None:\n            raise ValueError(\n                ""ak.size is ambiguous due to variable-length arrays at ""\n                ""axis {0} (try ak.flatten to remove structure or ""\n                ""ak.to_numpy to force regularity, if possible)"".format(axis)\n            )\n        else:\n            return sizes[-1]\n\n\n@awkward1._connect._numpy.implements(numpy.atleast_1d)\ndef atleast_1d(*arrays):\n    """"""\n    Args:\n        arrays: Rectilinear arrays to be converted to NumPy arrays of at\n            least 1 dimension.\n        axis (int): The dimension at which this operation is applied. The\n            outermost dimension is `0`, followed by `1`, etc., and negative\n            values count backward from the innermost: `-1` is the innermost\n            dimension, `-2` is the next level up, etc.\n\n    Implements NumPy\'s\n    [atleast_1d](https://docs.scipy.org/doc/numpy/reference/generated/numpy.atleast_1d.html)\n    function in a way that accepts #ak.Array objects as the `arrays`.\n\n    If the `arrays` are not all rectilinear (i.e. if #np.to_numpy would raise an\n    error), then this function raise an error.\n\n    Note: this function returns a NumPy array, not an Awkward Array.\n    """"""\n    return numpy.atleast_1d(*[awkward1.operations.convert.to_numpy(x) for x in arrays])\n\n\n__all__ = [\n    x\n    for x in list(globals())\n    if not x.startswith(""_"") and x not in (""numpy"", ""awkward1"")\n]\n'"
src/awkward1/_connect/_numba/arrayview.py,2,"b'# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-1.0/blob/master/LICENSE\n\nfrom __future__ import absolute_import\n\nimport operator\n\nimport numpy\nimport numba\nimport numba.core.typing\nimport numba.core.typing.ctypes_utils\n\nimport awkward1.operations.convert\nimport awkward1._util\nimport awkward1._connect._numba.layout\n\n########## Lookup\n\n\nclass Lookup(object):\n    def __init__(self, layout):\n        positions = []\n        sharedptrs = []\n        arrays = []\n        tolookup(layout, positions, sharedptrs, arrays)\n        assert len(positions) == len(sharedptrs)\n\n        def find(x):\n            for i, array in enumerate(arrays):\n                if x is array:\n                    return i\n            else:\n                assert isinstance(x, int)\n                return x\n\n        self.original_positions = positions\n        self.positions = [find(x) for x in positions]\n        self.sharedptrs_hold = sharedptrs\n        self.arrays = arrays\n\n        def arrayptr(x):\n            if isinstance(x, int):\n                return x\n            else:\n                return x.ctypes.data\n\n        def sharedptr(x):\n            if x is None:\n                return -1\n            elif x == 0:\n                return 0\n            else:\n                return x.ptr()\n\n        self.arrayptrs = numpy.array([arrayptr(x) for x in positions], dtype=numpy.intp)\n        self.sharedptrs = numpy.array(\n            [sharedptr(x) for x in sharedptrs], dtype=numpy.intp\n        )\n\n    def _view_as_array(self):\n        return numpy.vstack(\n            [numpy.arange(len(self.arrayptrs)), self.arrayptrs, self.sharedptrs]\n        ).T\n\n\ndef tolookup(layout, positions, sharedptrs, arrays):\n    import awkward1.layout\n    import awkward1.forms\n\n    if isinstance(layout, awkward1.layout.NumpyArray):\n        return awkward1._connect._numba.layout.NumpyArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.NumpyForm):\n        return awkward1._connect._numba.layout.NumpyArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.RegularArray):\n        return awkward1._connect._numba.layout.RegularArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.RegularForm):\n        return awkward1._connect._numba.layout.RegularArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(\n        layout,\n        (\n            awkward1.layout.ListArray32,\n            awkward1.layout.ListArrayU32,\n            awkward1.layout.ListArray64,\n            awkward1.layout.ListOffsetArray32,\n            awkward1.layout.ListOffsetArrayU32,\n            awkward1.layout.ListOffsetArray64,\n        ),\n    ):\n        return awkward1._connect._numba.layout.ListArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, (awkward1.forms.ListForm, awkward1.forms.ListOffsetForm)):\n        return awkward1._connect._numba.layout.ListArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(\n        layout,\n        (\n            awkward1.layout.IndexedArray32,\n            awkward1.layout.IndexedArrayU32,\n            awkward1.layout.IndexedArray64,\n        ),\n    ):\n        return awkward1._connect._numba.layout.IndexedArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.IndexedForm):\n        return awkward1._connect._numba.layout.IndexedArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(\n        layout,\n        (awkward1.layout.IndexedOptionArray32, awkward1.layout.IndexedOptionArray64),\n    ):\n        return awkward1._connect._numba.layout.IndexedOptionArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.IndexedOptionForm):\n        return awkward1._connect._numba.layout.IndexedOptionArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.ByteMaskedArray):\n        return awkward1._connect._numba.layout.ByteMaskedArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.ByteMaskedForm):\n        return awkward1._connect._numba.layout.ByteMaskedArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.BitMaskedArray):\n        return awkward1._connect._numba.layout.BitMaskedArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.BitMaskedForm):\n        return awkward1._connect._numba.layout.BitMaskedArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.UnmaskedArray):\n        return awkward1._connect._numba.layout.UnmaskedArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.UnmaskedForm):\n        return awkward1._connect._numba.layout.UnmaskedArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.RecordArray):\n        return awkward1._connect._numba.layout.RecordArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.RecordForm):\n        return awkward1._connect._numba.layout.RecordArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.Record):\n        return awkward1._connect._numba.layout.RecordType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(\n        layout,\n        (\n            awkward1.layout.UnionArray8_32,\n            awkward1.layout.UnionArray8_U32,\n            awkward1.layout.UnionArray8_64,\n        ),\n    ):\n        return awkward1._connect._numba.layout.UnionArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.UnionForm):\n        return awkward1._connect._numba.layout.UnionArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.layout.VirtualArray):\n        return awkward1._connect._numba.layout.VirtualArrayType.tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    elif isinstance(layout, awkward1.forms.VirtualForm):\n        return awkward1._connect._numba.layout.VirtualArrayType.form_tolookup(\n            layout, positions, sharedptrs, arrays\n        )\n\n    else:\n        raise AssertionError(\n            ""unrecognized Content or Form type: {0}"".format(type(layout))\n        )\n\n\ndef tonumbatype(form):\n    import awkward1.forms\n\n    if isinstance(form, awkward1.forms.NumpyForm):\n        return awkward1._connect._numba.layout.NumpyArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.RegularForm):\n        return awkward1._connect._numba.layout.RegularArrayType.from_form(form)\n\n    elif isinstance(form, (awkward1.forms.ListForm, awkward1.forms.ListOffsetForm)):\n        return awkward1._connect._numba.layout.ListArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.IndexedForm):\n        return awkward1._connect._numba.layout.IndexedArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.IndexedOptionForm):\n        return awkward1._connect._numba.layout.IndexedOptionArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.ByteMaskedForm):\n        return awkward1._connect._numba.layout.ByteMaskedArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.BitMaskedForm):\n        return awkward1._connect._numba.layout.BitMaskedArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.UnmaskedForm):\n        return awkward1._connect._numba.layout.UnmaskedArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.RecordForm):\n        return awkward1._connect._numba.layout.RecordArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.UnionForm):\n        return awkward1._connect._numba.layout.UnionArrayType.from_form(form)\n\n    elif isinstance(form, awkward1.forms.VirtualForm):\n        return awkward1._connect._numba.layout.VirtualArrayType.from_form(form)\n\n    else:\n        raise AssertionError(""unrecognized Form type: {0}"".format(type(form)))\n\n\n@numba.extending.typeof_impl.register(Lookup)\ndef typeof_Lookup(obj, c):\n    return LookupType()\n\n\nclass LookupType(numba.types.Type):\n    arraytype = numba.types.Array(numba.intp, 1, ""C"")\n\n    def __init__(self):\n        super(LookupType, self).__init__(name=""awkward1.LookupType()"")\n\n\n@numba.extending.register_model(LookupType)\nclass LookupModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [(""arrayptrs"", fe_type.arraytype), (""sharedptrs"", fe_type.arraytype)]\n        super(LookupModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.unbox(LookupType)\ndef unbox_Lookup(lookuptype, lookupobj, c):\n    arrayptrs_obj = c.pyapi.object_getattr_string(lookupobj, ""arrayptrs"")\n    sharedptrs_obj = c.pyapi.object_getattr_string(lookupobj, ""sharedptrs"")\n\n    proxyout = c.context.make_helper(c.builder, lookuptype)\n    proxyout.arrayptrs = c.pyapi.to_native_value(\n        lookuptype.arraytype, arrayptrs_obj\n    ).value\n    proxyout.sharedptrs = c.pyapi.to_native_value(\n        lookuptype.arraytype, sharedptrs_obj\n    ).value\n\n    c.pyapi.decref(arrayptrs_obj)\n    c.pyapi.decref(sharedptrs_obj)\n\n    is_error = numba.core.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(proxyout._getvalue(), is_error)\n\n\n########## ArrayView\n\n\nclass ArrayView(object):\n    @classmethod\n    def fromarray(self, array):\n        behavior = awkward1._util.behaviorof(array)\n        layout = awkward1.operations.convert.to_layout(\n            array,\n            allow_record=False,\n            allow_other=False,\n            numpytype=(numpy.number, numpy.bool_, numpy.bool),\n        )\n        layout = awkward1.operations.convert.regularize_numpyarray(\n            layout, allow_empty=False, highlevel=False\n        )\n\n        if isinstance(layout, awkward1.partition.PartitionedArray):\n            numba_type = None\n            for part in layout.partitions:\n                if numba_type is None:\n                    numba_type = numba.typeof(part)\n                elif numba_type != numba.typeof(part):\n                    raise ValueError(\n                        ""partitioned arrays can only be used in Numba if all ""\n                        ""partitions have the same numba_type""\n                    )\n            return PartitionedView(\n                numba.typeof(part),\n                behavior,\n                [Lookup(x) for x in layout.partitions],\n                numpy.asarray(layout.stops, dtype=numpy.intp),\n                0,\n                len(layout),\n                (),\n            )\n\n        else:\n            return ArrayView(\n                numba.typeof(layout), behavior, Lookup(layout), 0, 0, len(layout), ()\n            )\n\n    def __init__(self, type, behavior, lookup, pos, start, stop, fields):\n        self.type = type\n        self.behavior = behavior\n        self.lookup = lookup\n        self.pos = pos\n        self.start = start\n        self.stop = stop\n        self.fields = fields\n\n    def toarray(self):\n        layout = self.type.tolayout(self.lookup, self.pos, self.fields)\n        sliced = layout.getitem_range_nowrap(self.start, self.stop)\n        return awkward1._util.wrap(sliced, self.behavior)\n\n\n@numba.extending.typeof_impl.register(ArrayView)\ndef typeof_ArrayView(obj, c):\n    return ArrayViewType(obj.type, obj.behavior, obj.fields)\n\n\ndef wrap(type, viewtype, fields):\n    if fields is None:\n        return ArrayViewType(type, viewtype.behavior, viewtype.fields)\n    else:\n        return ArrayViewType(type, viewtype.behavior, fields)\n\n\nclass ArrayViewType(numba.types.Type):\n    def __init__(self, type, behavior, fields):\n        super(ArrayViewType, self).__init__(\n            name=""awkward1.ArrayView({0}, {1}, {2})"".format(\n                type.name,\n                awkward1._connect._numba.repr_behavior(behavior),\n                repr(fields),\n            )\n        )\n        self.type = type\n        self.behavior = behavior\n        self.fields = fields\n\n\n@numba.extending.register_model(ArrayViewType)\nclass ArrayViewModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [\n            (""pos"", numba.intp),\n            (""start"", numba.intp),\n            (""stop"", numba.intp),\n            (""arrayptrs"", numba.types.CPointer(numba.intp)),\n            (""sharedptrs"", numba.types.CPointer(numba.intp)),\n            (""pylookup"", numba.types.pyobject),\n        ]\n        super(ArrayViewModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.unbox(ArrayViewType)\ndef unbox_Array(viewtype, arrayobj, c):\n    view_obj = c.pyapi.object_getattr_string(arrayobj, ""_numbaview"")\n    out = unbox_ArrayView(viewtype, view_obj, c)\n    c.pyapi.decref(view_obj)\n    return out\n\n\ndef unbox_ArrayView(viewtype, view_obj, c):\n    lookup_obj = c.pyapi.object_getattr_string(view_obj, ""lookup"")\n    pos_obj = c.pyapi.object_getattr_string(view_obj, ""pos"")\n    start_obj = c.pyapi.object_getattr_string(view_obj, ""start"")\n    stop_obj = c.pyapi.object_getattr_string(view_obj, ""stop"")\n\n    lookup_val = c.pyapi.to_native_value(LookupType(), lookup_obj).value\n    lookup_proxy = c.context.make_helper(c.builder, LookupType(), lookup_val)\n\n    proxyout = c.context.make_helper(c.builder, viewtype)\n    proxyout.pos = c.pyapi.number_as_ssize_t(pos_obj)\n    proxyout.start = c.pyapi.number_as_ssize_t(start_obj)\n    proxyout.stop = c.pyapi.number_as_ssize_t(stop_obj)\n    proxyout.arrayptrs = c.context.make_helper(\n        c.builder, LookupType.arraytype, lookup_proxy.arrayptrs\n    ).data\n    proxyout.sharedptrs = c.context.make_helper(\n        c.builder, LookupType.arraytype, lookup_proxy.sharedptrs\n    ).data\n    proxyout.pylookup = lookup_obj\n\n    c.pyapi.decref(lookup_obj)\n    c.pyapi.decref(pos_obj)\n    c.pyapi.decref(start_obj)\n    c.pyapi.decref(stop_obj)\n\n    if c.context.enable_nrt:\n        c.context.nrt.decref(c.builder, LookupType(), lookup_val)\n\n    is_error = numba.core.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(proxyout._getvalue(), is_error)\n\n\n@numba.extending.box(ArrayViewType)\ndef box_Array(viewtype, viewval, c):\n    arrayview_obj = box_ArrayView(viewtype, viewval, c)\n    out = c.pyapi.call_method(arrayview_obj, ""toarray"", ())\n    c.pyapi.decref(arrayview_obj)\n    return out\n\n\ndef dict2serializable(obj):\n    if obj is None:\n        return None\n    else:\n        return tuple(obj.items())\n\n\ndef serializable2dict(obj):\n    if obj is None:\n        return None\n    else:\n        return dict(obj)\n\n\ndef box_ArrayView(viewtype, viewval, c):\n    serializable2dict_obj = c.pyapi.unserialize(\n        c.pyapi.serialize_object(serializable2dict)\n    )\n    behavior2_obj = c.pyapi.unserialize(\n        c.pyapi.serialize_object(dict2serializable(viewtype.behavior))\n    )\n    behavior_obj = c.pyapi.call_function_objargs(\n        serializable2dict_obj, (behavior2_obj,)\n    )\n    ArrayView_obj = c.pyapi.unserialize(c.pyapi.serialize_object(ArrayView))\n    type_obj = c.pyapi.unserialize(c.pyapi.serialize_object(viewtype.type))\n    fields_obj = c.pyapi.unserialize(c.pyapi.serialize_object(viewtype.fields))\n\n    proxyin = c.context.make_helper(c.builder, viewtype, viewval)\n    pos_obj = c.pyapi.long_from_ssize_t(proxyin.pos)\n    start_obj = c.pyapi.long_from_ssize_t(proxyin.start)\n    stop_obj = c.pyapi.long_from_ssize_t(proxyin.stop)\n    lookup_obj = proxyin.pylookup\n\n    out = c.pyapi.call_function_objargs(\n        ArrayView_obj,\n        (type_obj, behavior_obj, lookup_obj, pos_obj, start_obj, stop_obj, fields_obj),\n    )\n\n    c.pyapi.decref(serializable2dict_obj)\n    c.pyapi.decref(behavior2_obj)\n    c.pyapi.decref(behavior_obj)\n    c.pyapi.decref(ArrayView_obj)\n    c.pyapi.decref(type_obj)\n    c.pyapi.decref(fields_obj)\n    c.pyapi.decref(pos_obj)\n    c.pyapi.decref(start_obj)\n    c.pyapi.decref(stop_obj)\n\n    return out\n\n\n@numba.core.typing.templates.infer_global(len)\nclass type_len(numba.core.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], ArrayViewType):\n            return numba.intp(args[0])\n\n\n@numba.extending.lower_builtin(len, ArrayViewType)\ndef lower_len(context, builder, sig, args):\n    proxyin = context.make_helper(builder, sig.args[0], args[0])\n    return builder.sub(proxyin.stop, proxyin.start)\n\n\n@numba.core.typing.templates.infer_global(operator.getitem)\nclass type_getitem(numba.core.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if len(args) == 2 and len(kwargs) == 0 and isinstance(args[0], ArrayViewType):\n            viewtype, wheretype = args\n            if isinstance(wheretype, numba.types.Integer):\n                return viewtype.type.getitem_at_check(viewtype)(viewtype, wheretype)\n            elif (\n                isinstance(wheretype, numba.types.SliceType) and not wheretype.has_step\n            ):\n                return viewtype.type.getitem_range(viewtype)(viewtype, wheretype)\n            elif isinstance(wheretype, numba.types.StringLiteral):\n                return viewtype.type.getitem_field(viewtype, wheretype.literal_value)(\n                    viewtype, wheretype\n                )\n            else:\n                raise TypeError(\n                    ""only an integer, start:stop range, or a *constant* ""\n                    ""field name string may be used as awkward1.Array ""\n                    ""slices in compiled code""\n                )\n\n\n@numba.extending.lower_builtin(operator.getitem, ArrayViewType, numba.types.Integer)\ndef lower_getitem_at(context, builder, sig, args):\n    rettype, (viewtype, wheretype) = sig.return_type, sig.args\n    viewval, whereval = args\n    viewproxy = context.make_helper(builder, viewtype, viewval)\n    return viewtype.type.lower_getitem_at_check(\n        context,\n        builder,\n        rettype,\n        viewtype,\n        viewval,\n        viewproxy,\n        wheretype,\n        whereval,\n        True,\n        True,\n    )\n\n\n@numba.extending.lower_builtin(operator.getitem, ArrayViewType, numba.types.slice2_type)\ndef lower_getitem_range(context, builder, sig, args):\n    rettype, (viewtype, wheretype) = sig.return_type, sig.args\n    viewval, whereval = args\n    viewproxy = context.make_helper(builder, viewtype, viewval)\n    whereproxy = context.make_helper(builder, wheretype, whereval)\n    return viewtype.type.lower_getitem_range(\n        context,\n        builder,\n        rettype,\n        viewtype,\n        viewval,\n        viewproxy,\n        whereproxy.start,\n        whereproxy.stop,\n        True,\n    )\n\n\n@numba.extending.lower_builtin(\n    operator.getitem, ArrayViewType, numba.types.StringLiteral\n)\ndef lower_getitem_field(context, builder, sig, args):\n    _, (viewtype, wheretype) = sig.return_type, sig.args\n    viewval, whereval = args\n    return viewtype.type.lower_getitem_field(\n        context, builder, viewtype, viewval, wheretype.literal_value\n    )\n\n\n@numba.core.typing.templates.infer_getattr\nclass type_getattr(numba.core.typing.templates.AttributeTemplate):\n    key = ArrayViewType\n\n    def generic_resolve(self, viewtype, attr):\n        # if attr == ""???"":\n        #     do_something_specific\n        return viewtype.type.getitem_field(viewtype, attr)\n\n\n@numba.extending.lower_getattr_generic(ArrayViewType)\ndef lower_getattr_generic(context, builder, viewtype, viewval, attr):\n    return viewtype.type.lower_getitem_field(context, builder, viewtype, viewval, attr)\n\n\nclass IteratorType(numba.types.common.SimpleIteratorType):\n    def __init__(self, viewtype):\n        super(IteratorType, self).__init__(\n            ""awkward1.Iterator({0})"".format(viewtype.name),\n            viewtype.type.getitem_at_check(viewtype),\n        )\n        self.viewtype = viewtype\n\n\n@numba.core.typing.templates.infer\nclass type_getiter(numba.core.typing.templates.AbstractTemplate):\n    key = ""getiter""\n\n    def generic(self, args, kwargs):\n        if len(args) == 1 and len(kwargs) == 0 and isinstance(args[0], ArrayViewType):\n            return IteratorType(args[0])(args[0])\n\n\n@numba.core.datamodel.registry.register_default(IteratorType)\nclass IteratorModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [\n            (""view"", fe_type.viewtype),\n            (""length"", numba.intp),\n            (""at"", numba.types.EphemeralPointer(numba.intp)),\n        ]\n        super(IteratorModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.lower_builtin(""getiter"", ArrayViewType)\ndef lower_getiter(context, builder, sig, args):\n    rettype, (viewtype,) = sig.return_type, sig.args\n    (viewval,) = args\n    viewproxy = context.make_helper(builder, viewtype, viewval)\n    proxyout = context.make_helper(builder, rettype)\n    proxyout.view = viewval\n    proxyout.length = builder.sub(viewproxy.stop, viewproxy.start)\n    proxyout.at = numba.core.cgutils.alloca_once_value(\n        builder, context.get_constant(numba.intp, 0)\n    )\n    if context.enable_nrt:\n        context.nrt.incref(builder, viewtype, viewval)\n    return numba.core.imputils.impl_ret_new_ref(\n        context, builder, rettype, proxyout._getvalue()\n    )\n\n\n@numba.extending.lower_builtin(""iternext"", IteratorType)\n@numba.core.imputils.iternext_impl(numba.core.imputils.RefType.BORROWED)\ndef lower_iternext(context, builder, sig, args, result):\n    (itertype,) = sig.args\n    (iterval,) = args\n    proxyin = context.make_helper(builder, itertype, iterval)\n    at = builder.load(proxyin.at)\n\n    is_valid = builder.icmp_signed(""<"", at, proxyin.length)\n    result.set_valid(is_valid)\n\n    with builder.if_then(is_valid, likely=True):\n        result.yield_(\n            lower_getitem_at(\n                context,\n                builder,\n                itertype.yield_type(itertype.viewtype, numba.intp),\n                (proxyin.view, at),\n            )\n        )\n        nextat = numba.core.cgutils.increment_index(builder, at)\n        builder.store(nextat, proxyin.at)\n\n\n########## RecordView\n\n\nclass RecordView(object):\n    @classmethod\n    def fromrecord(self, record):\n        behavior = awkward1._util.behaviorof(record)\n        layout = awkward1.operations.convert.to_layout(\n            record,\n            allow_record=True,\n            allow_other=False,\n            numpytype=(numpy.number, numpy.bool_, numpy.bool),\n        )\n        assert isinstance(layout, awkward1.layout.Record)\n        arraylayout = layout.array\n        return RecordView(\n            ArrayView(\n                numba.typeof(arraylayout),\n                behavior,\n                Lookup(arraylayout),\n                0,\n                0,\n                len(arraylayout),\n                (),\n            ),\n            layout.at,\n        )\n\n    def __init__(self, arrayview, at):\n        self.arrayview = arrayview\n        self.at = at\n\n    def torecord(self):\n        arraylayout = self.arrayview.toarray().layout\n        return awkward1._util.wrap(\n            awkward1.layout.Record(arraylayout, self.at), self.arrayview.behavior\n        )\n\n\n@numba.extending.typeof_impl.register(RecordView)\ndef typeof_RecordView(obj, c):\n    return RecordViewType(numba.typeof(obj.arrayview))\n\n\nclass RecordViewType(numba.types.Type):\n    def __init__(self, arrayviewtype):\n        super(RecordViewType, self).__init__(\n            name=""awkward1.RecordViewType({0})"".format(arrayviewtype.name)\n        )\n        self.arrayviewtype = arrayviewtype\n\n    @property\n    def behavior(self):\n        return self.arrayviewtype.behavior\n\n    @property\n    def fields(self):\n        return self.arrayviewtype.fields\n\n    def typer_field(self, key):\n        return self.arrayviewtype.type.getitem_field_record(self, key)\n\n    def lower_field(self, context, builder, val, key):\n        return self.arrayviewtype.type.lower_getitem_field_record(\n            context, builder, self, val, key\n        )\n\n\n@numba.extending.register_model(RecordViewType)\nclass RecordViewModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [(""arrayview"", fe_type.arrayviewtype), (""at"", numba.intp)]\n        super(RecordViewModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.unbox(RecordViewType)\ndef unbox_RecordView(recordviewtype, recordobj, c):\n    recordview_obj = c.pyapi.object_getattr_string(recordobj, ""_numbaview"")\n    arrayview_obj = c.pyapi.object_getattr_string(recordview_obj, ""arrayview"")\n    at_obj = c.pyapi.object_getattr_string(recordview_obj, ""at"")\n\n    arrayview_val = unbox_ArrayView(\n        recordviewtype.arrayviewtype, arrayview_obj, c\n    ).value\n\n    proxyout = c.context.make_helper(c.builder, recordviewtype)\n    proxyout.arrayview = arrayview_val\n    proxyout.at = c.pyapi.number_as_ssize_t(at_obj)\n\n    c.pyapi.decref(recordview_obj)\n    c.pyapi.decref(at_obj)\n\n    if c.context.enable_nrt:\n        c.context.nrt.decref(c.builder, recordviewtype.arrayviewtype, arrayview_val)\n\n    is_error = numba.core.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(proxyout._getvalue(), is_error)\n\n\n@numba.extending.box(RecordViewType)\ndef box_RecordView(recordviewtype, viewval, c):\n    RecordView_obj = c.pyapi.unserialize(c.pyapi.serialize_object(RecordView))\n\n    proxyin = c.context.make_helper(c.builder, recordviewtype, viewval)\n    arrayview_obj = box_ArrayView(recordviewtype.arrayviewtype, proxyin.arrayview, c)\n    at_obj = c.pyapi.long_from_ssize_t(proxyin.at)\n\n    recordview_obj = c.pyapi.call_function_objargs(\n        RecordView_obj, (arrayview_obj, at_obj)\n    )\n\n    out = c.pyapi.call_method(recordview_obj, ""torecord"", ())\n\n    c.pyapi.decref(RecordView_obj)\n    c.pyapi.decref(arrayview_obj)\n    c.pyapi.decref(at_obj)\n    c.pyapi.decref(recordview_obj)\n\n    return out\n\n\n@numba.core.typing.templates.infer_global(operator.getitem)\nclass type_getitem_record(numba.core.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if len(args) == 2 and len(kwargs) == 0 and isinstance(args[0], RecordViewType):\n            recordviewtype, wheretype = args\n            if isinstance(wheretype, numba.types.StringLiteral):\n                return recordviewtype.arrayviewtype.type.getitem_field_record(\n                    recordviewtype, wheretype.literal_value\n                )(recordviewtype, wheretype)\n            else:\n                raise TypeError(\n                    ""only a *constant* field name string may be used as ""\n                    ""awkward1.Record slices in compiled code""\n                )\n\n\n@numba.extending.lower_builtin(\n    operator.getitem, RecordViewType, numba.types.StringLiteral\n)\ndef lower_getitem_field_record(context, builder, sig, args):\n    _, (recordviewtype, wheretype) = sig.return_type, sig.args\n    recordviewval, whereval = args\n    return recordviewtype.arrayviewtype.type.lower_getitem_field_record(\n        context, builder, recordviewtype, recordviewval, wheretype.literal_value\n    )\n\n\n@numba.core.typing.templates.infer_getattr\nclass type_getattr_record(numba.core.typing.templates.AttributeTemplate):\n    key = RecordViewType\n\n    def generic_resolve(self, recordviewtype, attr):\n        for methodname, typer, lower in awkward1._util.numba_methods(\n            recordviewtype.arrayviewtype.type, recordviewtype.arrayviewtype.behavior\n        ):\n            if attr == methodname:\n\n                class type_method(numba.core.typing.templates.AbstractTemplate):\n                    key = methodname\n\n                    def generic(_, args, kwargs):\n                        if len(kwargs) == 0:\n                            sig = typer(recordviewtype, args)\n                            sig = numba.core.typing.templates.Signature(\n                                sig.return_type, sig.args, recordviewtype\n                            )\n                            numba.extending.lower_builtin(\n                                methodname,\n                                recordviewtype,\n                                *[\n                                    x.literal_type\n                                    if isinstance(x, numba.types.Literal)\n                                    else x\n                                    for x in args\n                                ]\n                            )(lower)\n                            return sig\n\n                return numba.types.BoundFunction(type_method, recordviewtype)\n\n        for attrname, typer, lower in awkward1._util.numba_attrs(\n            recordviewtype.arrayviewtype.type, recordviewtype.arrayviewtype.behavior\n        ):\n            if attr == attrname:\n                return typer(recordviewtype)\n\n        else:\n            return recordviewtype.typer_field(attr)\n\n\n@numba.extending.lower_getattr_generic(RecordViewType)\ndef lower_getattr_generic_record(context, builder, recordviewtype, recordviewval, attr):\n    for attrname, typer, lower in awkward1._util.numba_attrs(\n        recordviewtype.arrayviewtype.type, recordviewtype.arrayviewtype.behavior\n    ):\n        if attr == attrname:\n            return lower(\n                context,\n                builder,\n                typer(recordviewtype)(recordviewtype),\n                (recordviewval,),\n            )\n    else:\n        return recordviewtype.lower_field(context, builder, recordviewval, attr)\n\n\ndef register_unary_operator(unaryop):\n    @numba.core.typing.templates.infer_global(unaryop)\n    class type_binary_operator(numba.core.typing.templates.AbstractTemplate):\n        def generic(self, args, kwargs):\n            if len(args) == 1 and len(kwargs) == 0:\n                behavior = None\n\n                if isinstance(args[0], RecordViewType):\n                    left = args[0].arrayviewtype.type\n                    behavior = args[0].arrayviewtype.behavior\n\n                for typer, lower in awkward1._util.numba_unaryops(\n                    unaryop, left, behavior\n                ):\n                    numba.extending.lower_builtin(unaryop, *args)(lower)\n                    return typer(unaryop, args[0])\n\n\nfor unaryop in (\n    abs,\n    operator.inv,\n    operator.invert,\n    operator.neg,\n    operator.not_,\n    operator.pos,\n    operator.truth,\n):\n    register_unary_operator(unaryop)\n\n\ndef register_binary_operator(binop):\n    @numba.core.typing.templates.infer_global(binop)\n    class type_binary_operator(numba.core.typing.templates.AbstractTemplate):\n        def generic(self, args, kwargs):\n            if len(args) == 2 and len(kwargs) == 0:\n                left, right, behavior = None, None, None\n\n                if isinstance(args[0], RecordViewType):\n                    left = args[0].arrayviewtype.type\n                    behavior = args[0].arrayviewtype.behavior\n\n                if isinstance(args[1], RecordViewType):\n                    right = args[1].arrayviewtype.type\n                    if behavior is None:\n                        behavior = args[1].arrayviewtype.behavior\n\n                for typer, lower in awkward1._util.numba_binops(\n                    binop, left, right, behavior\n                ):\n                    numba.extending.lower_builtin(binop, *args)(lower)\n                    return typer(binop, args[0], args[1])\n\n\nfor binop in (\n    operator.add,\n    operator.and_,\n    operator.contains,\n    operator.eq,\n    operator.floordiv,\n    operator.ge,\n    operator.gt,\n    operator.le,\n    operator.lshift,\n    operator.lt,\n    operator.mod,\n    operator.mul,\n    operator.ne,\n    operator.or_,\n    operator.pow,\n    operator.rshift,\n    operator.sub,\n    operator.truediv,\n    operator.xor,\n) + (() if not hasattr(operator, ""matmul"") else (operator.matmul,)):\n    register_binary_operator(binop)\n\n########## PartitionedView\n\n\nclass PartitionedView(object):\n    def __init__(self, type, behavior, lookups, stops, start, stop, fields):\n        self.type = type\n        self.behavior = behavior\n        self.lookups = lookups\n        self.stops = stops\n        self.start = start\n        self.stop = stop\n        self.fields = fields\n\n    def toarray(self):\n        output = []\n        partition_start = 0\n        for partitionid, lookup in enumerate(self.lookups):\n            partition_stop = self.stops[partitionid]\n\n            if partition_start <= self.start and self.stop <= partition_stop:\n                layout = self.type.tolayout(lookup, 0, self.fields)\n                output.append(\n                    layout[self.start - partition_start : self.stop - partition_start]\n                )\n                break\n\n            elif partition_start <= self.start < partition_stop:\n                layout = self.type.tolayout(lookup, 0, self.fields)\n                output.append(\n                    layout[\n                        self.start - partition_start : partition_stop - partition_start\n                    ]\n                )\n\n            elif partition_start < self.stop <= partition_stop:\n                layout = self.type.tolayout(lookup, 0, self.fields)\n                output.append(layout[0 : self.stop - partition_start])\n                break\n\n            elif self.start < partition_start and partition_stop < self.stop:\n                layout = self.type.tolayout(lookup, 0, self.fields)\n                output.append(layout[0 : partition_stop - partition_start])\n\n            partition_start = partition_stop\n\n        return awkward1._util.wrap(\n            awkward1.partition.IrregularlyPartitionedArray(output), self.behavior\n        )\n\n\n@numba.extending.typeof_impl.register(PartitionedView)\ndef typeof_PartitionedView(obj, c):\n    return PartitionedViewType(obj.type, obj.behavior, obj.fields)\n\n\nclass PartitionedViewType(numba.types.Type):\n    stopstype = numba.types.Array(numba.intp, 1, ""C"")\n\n    def __init__(self, type, behavior, fields):\n        super(PartitionedViewType, self).__init__(\n            name=""awkward1.PartitionedView({0}, {1}, {2})"".format(\n                type.name,\n                awkward1._connect._numba.repr_behavior(behavior),\n                repr(fields),\n            )\n        )\n        self.type = type\n        self.behavior = behavior\n        self.fields = fields\n\n    def toArrayViewType(self):\n        return ArrayViewType(self.type, self.behavior, self.fields)\n\n    def getitem_field(self, key):\n        return PartitionedViewType(self.type, self.behavior, self.fields + (key,))\n\n    def lower_get_localstart(self, context, builder, stops, partitionid):\n        out = numba.core.cgutils.alloca_once_value(\n            builder, context.get_constant(numba.intp, 0)\n        )\n\n        with builder.if_then(\n            builder.icmp_signed(""!="", partitionid, context.get_constant(numba.intp, 0))\n        ):\n            stopsproxy = context.make_helper(builder, self.stopstype, stops)\n            newval = numba.np.arrayobj._getitem_array_single_int(\n                context,\n                builder,\n                numba.intp,\n                self.stopstype,\n                stopsproxy,\n                builder.sub(partitionid, context.get_constant(numba.intp, 1)),\n            )\n            builder.store(newval, out)\n\n        return builder.load(out)\n\n    def lower_get_localstop(self, context, builder, stops, partitionid):\n        stopsproxy = context.make_helper(builder, self.stopstype, stops)\n        return numba.np.arrayobj._getitem_array_single_int(\n            context, builder, numba.intp, self.stopstype, stopsproxy, partitionid\n        )\n\n    def lower_get_partitionid(\n        self, context, builder, pyapi, pylookups, partitionid, viewlength\n    ):\n        lookup_obj = pyapi.list_getitem(pylookups, partitionid)  # borrowed\n        lookup = pyapi.to_native_value(LookupType(), lookup_obj).value\n        lookupproxy = context.make_helper(builder, LookupType(), value=lookup)\n\n        viewproxy = context.make_helper(builder, self.toArrayViewType())\n        viewproxy.pos = context.get_constant(numba.intp, 0)\n        viewproxy.start = context.get_constant(numba.intp, 0)\n        viewproxy.stop = viewlength\n        viewproxy.arrayptrs = context.make_helper(\n            builder, LookupType.arraytype, lookupproxy.arrayptrs\n        ).data\n        viewproxy.sharedptrs = context.make_helper(\n            builder, LookupType.arraytype, lookupproxy.sharedptrs\n        ).data\n        viewproxy.pylookup = lookup_obj\n        return viewproxy._getvalue()\n\n\n@numba.extending.register_model(PartitionedViewType)\nclass PartitionedViewModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [\n            (""pylookups"", numba.types.pyobject),\n            (""partitionid"", numba.types.CPointer(numba.intp)),\n            (""stops"", fe_type.stopstype),\n            (""view"", numba.types.CPointer(fe_type.toArrayViewType())),\n            (""start"", numba.intp),\n            (""stop"", numba.intp),\n        ]\n        super(PartitionedViewModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.unbox(PartitionedViewType)\ndef unbox_PartitionedArray(partviewtype, arrayobj, c):\n    partview_obj = c.pyapi.object_getattr_string(arrayobj, ""_numbaview"")\n    out = unbox_PartitionedView(partviewtype, partview_obj, c)\n    c.pyapi.decref(partview_obj)\n    return out\n\n\ndef unbox_PartitionedView(partviewtype, partview_obj, c):\n    lookups_obj = c.pyapi.object_getattr_string(partview_obj, ""lookups"")\n    stops_obj = c.pyapi.object_getattr_string(partview_obj, ""stops"")\n    start_obj = c.pyapi.object_getattr_string(partview_obj, ""start"")\n    stop_obj = c.pyapi.object_getattr_string(partview_obj, ""stop"")\n\n    proxyout = c.context.make_helper(c.builder, partviewtype)\n    proxyout.pylookups = lookups_obj\n    partitionid = c.context.get_constant(numba.intp, 0)\n    proxyout.partitionid = numba.core.cgutils.alloca_once_value(c.builder, partitionid)\n    proxyout.stops = c.pyapi.to_native_value(partviewtype.stopstype, stops_obj).value\n    viewlength = partviewtype.lower_get_localstop(\n        c.context, c.builder, proxyout.stops, partitionid\n    )\n    proxyout.view = numba.core.cgutils.alloca_once_value(\n        c.builder,\n        partviewtype.lower_get_partitionid(\n            c.context, c.builder, c.pyapi, proxyout.pylookups, partitionid, viewlength\n        ),\n    )\n    proxyout.start = c.pyapi.number_as_ssize_t(start_obj)\n    proxyout.stop = c.pyapi.number_as_ssize_t(stop_obj)\n\n    c.pyapi.decref(lookups_obj)\n    c.pyapi.decref(stops_obj)\n    c.pyapi.decref(start_obj)\n    c.pyapi.decref(stop_obj)\n\n    is_error = numba.core.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(proxyout._getvalue(), is_error)\n\n\n@numba.extending.box(PartitionedViewType)\ndef box_PartitionedArray(partviewtype, partviewval, c):\n    arrayview_obj = box_PartitionedView(partviewtype, partviewval, c)\n    out = c.pyapi.call_method(arrayview_obj, ""toarray"", ())\n    c.pyapi.decref(arrayview_obj)\n    return out\n\n\ndef box_PartitionedView(partviewtype, partviewval, c):\n    serializable2dict_obj = c.pyapi.unserialize(\n        c.pyapi.serialize_object(serializable2dict)\n    )\n    behavior2_obj = c.pyapi.unserialize(\n        c.pyapi.serialize_object(dict2serializable(partviewtype.behavior))\n    )\n    behavior_obj = c.pyapi.call_function_objargs(\n        serializable2dict_obj, (behavior2_obj,)\n    )\n    PartitionedView_obj = c.pyapi.unserialize(c.pyapi.serialize_object(PartitionedView))\n    type_obj = c.pyapi.unserialize(c.pyapi.serialize_object(partviewtype.type))\n    fields_obj = c.pyapi.unserialize(c.pyapi.serialize_object(partviewtype.fields))\n\n    proxyin = c.context.make_helper(c.builder, partviewtype, partviewval)\n    lookups_obj = proxyin.pylookups\n    stops_obj = c.pyapi.from_native_value(\n        partviewtype.stopstype, proxyin.stops, c.env_manager\n    )\n    start_obj = c.pyapi.long_from_ssize_t(proxyin.start)\n    stop_obj = c.pyapi.long_from_ssize_t(proxyin.stop)\n\n    out = c.pyapi.call_function_objargs(\n        PartitionedView_obj,\n        (\n            type_obj,\n            behavior_obj,\n            lookups_obj,\n            stops_obj,\n            start_obj,\n            stop_obj,\n            fields_obj,\n        ),\n    )\n\n    c.pyapi.decref(serializable2dict_obj)\n    c.pyapi.decref(behavior2_obj)\n    c.pyapi.decref(behavior_obj)\n    c.pyapi.decref(PartitionedView_obj)\n    c.pyapi.decref(type_obj)\n    c.pyapi.decref(fields_obj)\n    c.pyapi.decref(stops_obj)\n    c.pyapi.decref(start_obj)\n    c.pyapi.decref(stop_obj)\n\n    return out\n\n\n@numba.core.typing.templates.infer_global(operator.getitem)\nclass type_getitem_partitioned(numba.core.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if (\n            len(args) == 2\n            and len(kwargs) == 0\n            and isinstance(args[0], PartitionedViewType)\n        ):\n            partviewtype, wheretype = args\n\n            if isinstance(wheretype, numba.types.Integer):\n                arrayviewtype = partviewtype.toArrayViewType()\n                rettype = partviewtype.type.getitem_at_check(arrayviewtype)\n                return rettype(partviewtype, wheretype)\n\n            elif (\n                isinstance(wheretype, numba.types.SliceType) and not wheretype.has_step\n            ):\n                return partviewtype(partviewtype, wheretype)\n\n            elif isinstance(wheretype, numba.types.StringLiteral):\n                rettype = partviewtype.getitem_field(wheretype.literal_value)\n                return rettype(partviewtype, wheretype)\n\n            else:\n                raise TypeError(\n                    ""only an integer, start:stop range, or a *constant* ""\n                    ""field name string may be used as awkward1.Array ""\n                    ""slices in compiled code""\n                )\n\n\n@numba.extending.lower_builtin(\n    operator.getitem, PartitionedViewType, numba.types.Integer\n)\ndef lower_getitem_at_partitioned(context, builder, sig, args):\n    rettype, (partviewtype, wheretype) = sig.return_type, sig.args\n    partviewval, whereval = args\n    partviewproxy = context.make_helper(builder, partviewtype, partviewval)\n\n    length = builder.sub(partviewproxy.stop, partviewproxy.start)\n    regular_atval = numba.core.cgutils.alloca_once_value(builder, whereval)\n\n    with builder.if_then(\n        builder.icmp_signed(""<"", whereval, context.get_constant(numba.intp, 0))\n    ):\n        builder.store(builder.add(whereval, length), regular_atval)\n    atval = builder.load(regular_atval)\n\n    with builder.if_then(\n        builder.or_(\n            builder.icmp_signed(""<"", atval, context.get_constant(numba.intp, 0)),\n            builder.icmp_signed("">="", atval, length),\n        )\n    ):\n        context.call_conv.return_user_exc(\n            builder, ValueError, (""slice index out of bounds"",)\n        )\n\n    localstart = partviewtype.lower_get_localstart(\n        context, builder, partviewproxy.stops, builder.load(partviewproxy.partitionid)\n    )\n    localstop = partviewtype.lower_get_localstop(\n        context, builder, partviewproxy.stops, builder.load(partviewproxy.partitionid)\n    )\n\n    with builder.if_then(\n        builder.not_(\n            builder.and_(\n                builder.icmp_signed(""<="", localstart, atval),\n                builder.icmp_signed("">"", atval, localstop),\n            )\n        ),\n        likely=False,\n    ):\n\n        searchsorted_sig = numba.intp(partviewtype.stopstype, wheretype)\n        searchsorted_args = (partviewproxy.stops, atval)\n\n        def searchsorted_impl(stops, where):\n            return numpy.searchsorted(stops, where, side=""right"")\n\n        partitionid_val = context.compile_internal(\n            builder, searchsorted_impl, searchsorted_sig, searchsorted_args\n        )\n        builder.store(partitionid_val, partviewproxy.partitionid)\n\n        pyapi = context.get_python_api(builder)\n        gil = pyapi.gil_ensure()\n        builder.store(\n            partviewtype.lower_get_partitionid(\n                context,\n                builder,\n                pyapi,\n                partviewproxy.pylookups,\n                builder.load(partviewproxy.partitionid),\n                builder.sub(localstop, localstart),\n            ),\n            partviewproxy.view,\n        )\n        pyapi.gil_release(gil)\n\n    viewtype = partviewtype.toArrayViewType()\n    viewval = builder.load(partviewproxy.view)\n    viewproxy = context.make_helper(builder, viewtype, value=viewval)\n\n    reallocalstart = partviewtype.lower_get_localstart(\n        context, builder, partviewproxy.stops, builder.load(partviewproxy.partitionid)\n    )\n    subatval = builder.sub(atval, reallocalstart)\n\n    return viewtype.type.lower_getitem_at_check(\n        context,\n        builder,\n        rettype,\n        viewtype,\n        viewval,\n        viewproxy,\n        numba.intp,\n        subatval,\n        False,\n        False,\n    )\n\n\n@numba.extending.lower_builtin(\n    operator.getitem, PartitionedViewType, numba.types.slice2_type\n)\ndef lower_getitem_range_partitioned(context, builder, sig, args):\n    _, (partviewtype, wheretype) = sig.return_type, sig.args\n    partviewval, whereval = args\n\n    whereproxy = context.make_helper(builder, wheretype, whereval)\n    start = whereproxy.start\n    stop = whereproxy.stop\n\n    partviewproxy = context.make_helper(builder, partviewtype, partviewval)\n    length = builder.sub(partviewproxy.stop, partviewproxy.start)\n\n    regular_start = numba.core.cgutils.alloca_once_value(builder, start)\n    regular_stop = numba.core.cgutils.alloca_once_value(builder, stop)\n\n    with builder.if_then(\n        builder.icmp_signed(""<"", start, context.get_constant(numba.intp, 0))\n    ):\n        builder.store(builder.add(start, length), regular_start)\n    with builder.if_then(\n        builder.icmp_signed(""<"", stop, context.get_constant(numba.intp, 0))\n    ):\n        builder.store(builder.add(stop, length), regular_stop)\n\n    with builder.if_then(\n        builder.icmp_signed(\n            ""<"", builder.load(regular_start), context.get_constant(numba.intp, 0)\n        )\n    ):\n        builder.store(context.get_constant(numba.intp, 0), regular_start)\n    with builder.if_then(builder.icmp_signed("">"", builder.load(regular_start), length)):\n        builder.store(length, regular_start)\n\n    with builder.if_then(\n        builder.icmp_signed(\n            ""<"", builder.load(regular_stop), builder.load(regular_start)\n        )\n    ):\n        builder.store(builder.load(regular_start), regular_stop)\n    with builder.if_then(builder.icmp_signed("">"", builder.load(regular_stop), length)):\n        builder.store(length, regular_stop)\n\n    proxyout = context.make_helper(builder, partviewtype)\n    proxyout.pylookups = partviewproxy.pylookups\n    proxyout.partitionid = numba.core.cgutils.alloca_once_value(\n        builder, builder.load(partviewproxy.partitionid)\n    )\n    proxyout.stops = partviewproxy.stops\n    proxyout.view = numba.core.cgutils.alloca_once_value(\n        builder, builder.load(partviewproxy.view)\n    )\n    proxyout.start = builder.load(regular_start)\n    proxyout.stop = builder.load(regular_stop)\n\n    if context.enable_nrt:\n        context.nrt.incref(builder, partviewtype.stopstype, proxyout.stops)\n\n    return proxyout._getvalue()\n\n\n@numba.extending.lower_builtin(\n    operator.getitem, PartitionedViewType, numba.types.StringLiteral\n)\ndef lower_getitem_field_partitioned(context, builder, sig, args):\n    _, (partviewtype, _) = sig.return_type, sig.args\n    partviewval, whereval = args\n\n    if context.enable_nrt:\n        partviewproxy = context.make_helper(builder, partviewtype, partviewval)\n        context.nrt.incref(builder, partviewtype.stopstype, partviewproxy.stops)\n\n    return partviewval\n\n\n@numba.core.typing.templates.infer_global(len)\nclass type_len_partitioned(numba.core.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if (\n            len(args) == 1\n            and len(kwargs) == 0\n            and isinstance(args[0], PartitionedViewType)\n        ):\n            return numba.intp(args[0])\n\n\n@numba.extending.lower_builtin(len, PartitionedViewType)\ndef lower_len_partitioned(context, builder, sig, args):\n    proxyin = context.make_helper(builder, sig.args[0], args[0])\n    return builder.sub(proxyin.stop, proxyin.start)\n\n\n@numba.core.typing.templates.infer_getattr\nclass type_getattr_partitioned(numba.core.typing.templates.AttributeTemplate):\n    key = PartitionedViewType\n\n    def generic_resolve(self, partviewtype, attr):\n        # if attr == ""???"":\n        #     do_something_specific\n        return partviewtype.getitem_field(attr)\n\n\n@numba.extending.lower_getattr_generic(PartitionedViewType)\ndef lower_getattr_generic_partitioned(\n    context, builder, partviewtype, partviewval, attr\n):\n    if context.enable_nrt:\n        partviewproxy = context.make_helper(builder, partviewtype, partviewval)\n        context.nrt.incref(builder, partviewtype.stopstype, partviewproxy.stops)\n\n    return partviewval\n\n\nclass PartitionedIteratorType(numba.types.common.SimpleIteratorType):\n    def __init__(self, partviewtype):\n        super(PartitionedIteratorType, self).__init__(\n            ""awkward1.PartitionedIterator({0})"".format(partviewtype.name),\n            partviewtype.type.getitem_at_check(partviewtype.toArrayViewType()),\n        )\n        self.partviewtype = partviewtype\n\n\n@numba.core.typing.templates.infer\nclass type_getiter_partitioned(numba.core.typing.templates.AbstractTemplate):\n    key = ""getiter""\n\n    def generic(self, args, kwargs):\n        if (\n            len(args) == 1\n            and len(kwargs) == 0\n            and isinstance(args[0], PartitionedViewType)\n        ):\n            return PartitionedIteratorType(args[0])(args[0])\n\n\n@numba.core.datamodel.registry.register_default(PartitionedIteratorType)\nclass PartitionedIteratorModel(numba.core.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [\n            (""partview"", fe_type.partviewtype),\n            (""length"", numba.intp),\n            (""at"", numba.types.EphemeralPointer(numba.intp)),\n        ]\n        super(PartitionedIteratorModel, self).__init__(dmm, fe_type, members)\n\n\n@numba.extending.lower_builtin(""getiter"", PartitionedViewType)\ndef lower_getiter_partitioned(context, builder, sig, args):\n    rettype, (partviewtype,) = sig.return_type, sig.args\n    (partviewval,) = args\n    partviewproxy = context.make_helper(builder, partviewtype, partviewval)\n\n    partitionid = context.get_constant(numba.intp, 0)\n    viewlength = partviewtype.lower_get_localstop(\n        context, builder, partviewproxy.stops, partitionid\n    )\n\n    partoutproxy = context.make_helper(builder, partviewtype)\n    partoutproxy.pylookups = partviewproxy.pylookups\n    partoutproxy.partitionid = numba.core.cgutils.alloca_once_value(\n        builder, partitionid\n    )\n    partoutproxy.stops = partviewproxy.stops\n\n    pyapi = context.get_python_api(builder)\n    gil = pyapi.gil_ensure()\n    partoutproxy.view = numba.core.cgutils.alloca_once_value(\n        builder,\n        partviewtype.lower_get_partitionid(\n            context, builder, pyapi, partviewproxy.pylookups, partitionid, viewlength\n        ),\n    )\n    pyapi.gil_release(gil)\n\n    partoutproxy.start = partviewproxy.start\n    partoutproxy.stop = partviewproxy.stop\n\n    proxyout = context.make_helper(builder, rettype)\n    proxyout.partview = partoutproxy._getvalue()\n    proxyout.length = builder.sub(partviewproxy.stop, partviewproxy.start)\n    proxyout.at = numba.core.cgutils.alloca_once_value(\n        builder, context.get_constant(numba.intp, 0)\n    )\n\n    if context.enable_nrt:\n        context.nrt.incref(builder, partviewtype.stopstype, partoutproxy.stops)\n\n    return numba.core.imputils.impl_ret_new_ref(\n        context, builder, rettype, proxyout._getvalue()\n    )\n\n\n@numba.extending.lower_builtin(""iternext"", PartitionedIteratorType)\n@numba.core.imputils.iternext_impl(numba.core.imputils.RefType.BORROWED)\ndef lower_iternext_partitioned(context, builder, sig, args, result):\n    (itertype,) = sig.args\n    (iterval,) = args\n\n    proxyin = context.make_helper(builder, itertype, iterval)\n    partviewproxy = context.make_helper(\n        builder, itertype.partviewtype, proxyin.partview\n    )\n    at = builder.load(proxyin.at)\n\n    is_valid = builder.icmp_signed(""<"", at, proxyin.length)\n    result.set_valid(is_valid)\n\n    with builder.if_then(is_valid, likely=True):\n        maybestop = itertype.partviewtype.lower_get_localstop(\n            context,\n            builder,\n            partviewproxy.stops,\n            builder.load(partviewproxy.partitionid),\n        )\n\n        with builder.if_then(builder.icmp_signed(""=="", at, maybestop)):\n            builder.store(\n                builder.add(\n                    builder.load(partviewproxy.partitionid),\n                    context.get_constant(numba.intp, 1),\n                ),\n                partviewproxy.partitionid,\n            )\n\n            localstart = itertype.partviewtype.lower_get_localstart(\n                context,\n                builder,\n                partviewproxy.stops,\n                builder.load(partviewproxy.partitionid),\n            )\n            localstop = itertype.partviewtype.lower_get_localstop(\n                context,\n                builder,\n                partviewproxy.stops,\n                builder.load(partviewproxy.partitionid),\n            )\n\n            pyapi = context.get_python_api(builder)\n            gil = pyapi.gil_ensure()\n            builder.store(\n                itertype.partviewtype.lower_get_partitionid(\n                    context,\n                    builder,\n                    pyapi,\n                    partviewproxy.pylookups,\n                    builder.load(partviewproxy.partitionid),\n                    builder.sub(localstop, localstart),\n                ),\n                partviewproxy.view,\n            )\n            pyapi.gil_release(gil)\n\n        realstart = itertype.partviewtype.lower_get_localstart(\n            context,\n            builder,\n            partviewproxy.stops,\n            builder.load(partviewproxy.partitionid),\n        )\n\n        outview = builder.load(partviewproxy.view)\n        outviewtype = itertype.partviewtype.toArrayViewType()\n        outviewproxy = context.make_helper(builder, outviewtype, outview)\n\n        result.yield_(\n            itertype.partviewtype.type.lower_getitem_at_check(\n                context,\n                builder,\n                itertype.partviewtype.type.getitem_at_check(outviewtype),\n                outviewtype,\n                outview,\n                outviewproxy,\n                numba.intp,\n                builder.sub(at, realstart),\n                False,\n                False,\n            )\n        )\n\n        nextat = numba.core.cgutils.increment_index(builder, at)\n        builder.store(nextat, proxyin.at)\n'"
