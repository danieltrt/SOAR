file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport os.path\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\ndef get_version():\n    g = {}\n    exec(open(os.path.join(""awkward"", ""version.py"")).read(), g)\n    return g[""__version__""]\n\ndef get_description():\n    description = open(""README.rst"", ""rb"").read().decode(""utf8"", ""ignore"")\n    start = description.index("".. inclusion-marker-1-5-do-not-remove"")\n    stop = description.index("".. inclusion-marker-3-do-not-remove"")\n\n    before = """""".. image:: https://raw.githubusercontent.com/scikit-hep/awkward-array/master/docs/source/logo-300px.png\n   :alt: awkward-array\n   :target: https://github.com/scikit-hep/awkward-array\n\n|\n\n""""""\n\n    after = """"""\n\nTutorial\n========\n\nSee the `project homepage <https://github.com/scikit-hep/awkward-array>`__ for a `tutorial <https://github.com/scikit-hep/awkward-array#tutorial>`__.\n\nInteractive tutorial\n====================\n\nRun `this tutorial <https://mybinder.org/v2/gh/scikit-hep/awkward-array/master?filepath=binder%2Ftutorial.ipynb>`__ on Binder.\n\nReference documentation\n=======================\n\n""""""\n\n    return before + description[start:stop].strip() # + after\n\nsetup(name = ""awkward"",\n      version = get_version(),\n      packages = find_packages(exclude = [""tests""]),\n      scripts = [],\n      description = ""Manipulate arrays of complex data structures as easily as Numpy."",\n      long_description = get_description(),\n      author = ""Jim Pivarski (IRIS-HEP)"",\n      author_email = ""pivarski@princeton.edu"",\n      maintainer = ""Jim Pivarski (IRIS-HEP)"",\n      maintainer_email = ""pivarski@princeton.edu"",\n      url = ""https://github.com/scikit-hep/awkward-array"",\n      download_url = ""https://github.com/scikit-hep/awkward-array/releases"",\n      license = ""BSD 3-clause"",\n      test_suite = ""tests"",\n      install_requires = [""numpy>=1.13.1""],\n      setup_requires = [""pytest-runner""],\n      tests_require = [""pytest"", ""pandas""],\n      classifiers = [\n          # ""Development Status :: 1 - Planning"",\n          # ""Development Status :: 2 - Pre-Alpha"",\n          # ""Development Status :: 3 - Alpha"",\n          # ""Development Status :: 4 - Beta"",\n          ""Development Status :: 5 - Production/Stable"",\n          # ""Development Status :: 6 - Mature"",\n          ""Intended Audience :: Developers"",\n          ""Intended Audience :: Information Technology"",\n          ""Intended Audience :: Science/Research"",\n          ""License :: OSI Approved :: BSD License"",\n          ""Operating System :: MacOS"",\n          ""Operating System :: POSIX"",\n          ""Operating System :: Unix"",\n          ""Programming Language :: Python"",\n          ""Programming Language :: Python :: 2.7"",\n          ""Programming Language :: Python :: 3.4"",\n          ""Programming Language :: Python :: 3.5"",\n          ""Programming Language :: Python :: 3.6"",\n          ""Programming Language :: Python :: 3.7"",\n          ""Topic :: Scientific/Engineering"",\n          ""Topic :: Scientific/Engineering :: Information Analysis"",\n          ""Topic :: Scientific/Engineering :: Mathematics"",\n          ""Topic :: Scientific/Engineering :: Physics"",\n          ""Topic :: Software Development"",\n          ""Topic :: Utilities"",\n          ],\n      platforms = ""Any"",\n      )\n'"
awkward-cpp/setup.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport os.path\nimport pybind11\nimport sys\nimport setuptools\nfrom setuptools import Extension\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools import find_packages\nfrom setuptools import setup\n\ndef get_version():\n    g = {}\n    exec(open(os.path.join("".."", ""awkward"", ""version.py"")).read(), g)\n    return g[""__version__""]\n\n#################################################################################\n# The following code is copy-pasted from pybind/python_example/setup.py on github:\n\nclass get_pybind_include(object):\n    """"""Helper class to determine the pybind11 include path\n\n    The purpose of this class is to postpone importing pybind11\n    until it is actually installed, so that the ``get_include()``\n    method can be invoked. """"""\n    \n    def __init__(self, user=False):\n        self.user = user\n\n    def __str__(self):\n        import pybind11\n        return pybind11.get_include(self.user)\n\next_modules = [\n    Extension(\n        \'awkward.cpp.array.array_impl\',\n        [os.path.join(""awkward"", ""cpp"", ""array"", ""array_impl.cpp"")],\n        include_dirs=[\n            # Path to pybind11 headers\n            get_pybind_include(),\n            get_pybind_include(user=True)\n        ],\n        language=\'c++\'\n    ),\n]\n\ndef has_flag(compiler, flagname):\n    """"""Return a boolean indicating whether a flag name is supported on\n    the specified compiler.\n    """"""\n    import tempfile\n    with tempfile.NamedTemporaryFile(\'w\', suffix=\'.cpp\') as f:\n        f.write(\'int main (int argc, char **argv) { return 0; }\')\n        try:\n            compiler.compile([f.name], extra_postargs=[flagname])\n        except setuptools.distutils.errors.CompileError:\n            return False\n    return True\n\ndef cpp_flag(compiler):\n    """"""Return the -std=c++[11/14] compiler flag.\n\n    The c++14 is prefered over c++11 (when it is available).\n    """"""\n    if has_flag(compiler, \'-std=c++14\'):\n        return \'-std=c++14\'\n    elif has_flag(compiler, \'-std=c++11\'):\n        return \'-std=c++11\'\n    else:\n        raise RuntimeError(\'Unsupported compiler -- at least C++11 support \'\n                           \'is needed!\')\n\nclass BuildExt(build_ext):\n    """"""A custom build extension for adding compiler-specific options.""""""\n    c_opts = {\n        \'msvc\': [\'/EHsc\'],\n        \'unix\': [],\n    }\n\n    if sys.platform == \'darwin\':\n        c_opts[\'unix\'] += [\'-stdlib=libc++\', \'-mmacosx-version-min=10.7\']\n\n    def build_extensions(self):\n        ct = self.compiler.compiler_type\n        opts = self.c_opts.get(ct, [])\n        if ct == \'unix\':\n            opts.append(\'-DVERSION_INFO=""%s""\' % self.distribution.get_version())\n            opts.append(cpp_flag(self.compiler))\n            if has_flag(self.compiler, \'-fvisibility=hidden\'):\n                opts.append(\'-fvisibility=hidden\')\n        elif ct == \'msvc\':\n            opts.append(\'/DVERSION_INFO=\\\\""%s\\\\""\' % self.distribution.get_version())\n        for ext in self.extensions:\n            ext.extra_compile_args = opts\n        build_ext.build_extensions(self)\n\n############################# end copy-pasted code ##############################\n        \nsetup(name = ""awkward-cpp"",\n      version = get_version(),\n      packages = find_packages(exclude = [""tests""]),\n      scripts = [],\n      description = ""Connect awkward-arrays to C++ using pybind11."",\n      long_description = """",\n      author = ""Charles Escott"",\n      author_email = ""charlescescott@gmail.com"",\n      maintainer = ""Jim Pivarski (IRIS-HEP)"",\n      maintainer_email = ""pivarski@princeton.edu"",\n      url = ""https://github.com/scikit-hep/awkward-array"",\n      download_url = ""https://github.com/scikit-hep/awkward-array/releases"",\n      license = ""BSD 3-clause"",\n      test_suite = ""tests"",\n      install_requires = [""awkward=="" + get_version(), ""pybind11>=2.2""],\n      setup_requires = [""pytest-runner""],\n      tests_require = [""pytest""],\n      ext_modules = ext_modules,\n      cmdclass = {""build_ext"": BuildExt},\n      classifiers = [\n          ""Development Status :: 1 - Planning"",\n          # ""Development Status :: 2 - Pre-Alpha"",\n          # ""Development Status :: 3 - Alpha"",\n          # ""Development Status :: 4 - Beta"",\n          # ""Development Status :: 5 - Production/Stable"",\n          # ""Development Status :: 6 - Mature"",\n          ""Intended Audience :: Developers"",\n          ""Intended Audience :: Information Technology"",\n          ""Intended Audience :: Science/Research"",\n          ""License :: OSI Approved :: BSD License"",\n          ""Operating System :: MacOS"",\n          ""Operating System :: POSIX"",\n          ""Operating System :: Unix"",\n          ""Programming Language :: Python"",\n          ""Programming Language :: Python :: 2.7"",\n          ""Programming Language :: Python :: 3.4"",\n          ""Programming Language :: Python :: 3.5"",\n          ""Programming Language :: Python :: 3.6"",\n          ""Programming Language :: Python :: 3.7"",\n          ""Topic :: Scientific/Engineering"",\n          ""Topic :: Scientific/Engineering :: Information Analysis"",\n          ""Topic :: Scientific/Engineering :: Mathematics"",\n          ""Topic :: Scientific/Engineering :: Physics"",\n          ""Topic :: Software Development"",\n          ""Topic :: Utilities"",\n          ],\n      platforms = ""Any"",\n      )\n'"
awkward-numba/setup.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport os.path\n\nfrom setuptools import find_packages\nfrom setuptools import setup\n\ndef get_version():\n    g = {}\n    exec(open(os.path.join("".."", ""awkward"", ""version.py"")).read(), g)\n    return g[""__version__""]\n\nsetup(name = ""awkward-numba"",\n      version = get_version(),\n      packages = find_packages(exclude = [""tests""]),\n      scripts = [],\n      description = ""Allows awkward arrays to be used in Numba-compiled code and optimizes awkward methods with JIT compilation."",\n      long_description = """""".. image:: https://raw.githubusercontent.com/scikit-hep/awkward-array/master/docs/source/logo-300px.png\n   :alt: awkward-array\n   :target: https://github.com/scikit-hep/awkward-array\n\n|\n\nAllows awkward arrays to be used in Numba-compiled code and optimizes awkward methods with JIT compilation.\n\nSee tests/study_numba_speed.py for an example.\n\nNote: be sure to ``import awkward.numba`` before attempting to use an awkward array in a Numba routine.\n\nStatus: only JaggedArrays have been implemented.\n"""""",\n      author = ""Jim Pivarski (IRIS-HEP)"",\n      author_email = ""pivarski@princeton.edu"",\n      maintainer = ""Jim Pivarski (IRIS-HEP)"",\n      maintainer_email = ""pivarski@princeton.edu"",\n      url = ""https://github.com/scikit-hep/awkward-array"",\n      download_url = ""https://github.com/scikit-hep/awkward-array/releases"",\n      license = ""BSD 3-clause"",\n      test_suite = ""tests"",\n      install_requires = [""awkward=="" + get_version(), ""numba""],\n      setup_requires = [""pytest-runner""],\n      tests_require = [""pytest""],\n      classifiers = [\n          # ""Development Status :: 1 - Planning"",\n          # ""Development Status :: 2 - Pre-Alpha"",\n          ""Development Status :: 3 - Alpha"",\n          # ""Development Status :: 4 - Beta"",\n          # ""Development Status :: 5 - Production/Stable"",\n          # ""Development Status :: 6 - Mature"",\n          ""Intended Audience :: Developers"",\n          ""Intended Audience :: Information Technology"",\n          ""Intended Audience :: Science/Research"",\n          ""License :: OSI Approved :: BSD License"",\n          ""Operating System :: MacOS"",\n          ""Operating System :: POSIX"",\n          ""Operating System :: Unix"",\n          ""Programming Language :: Python"",\n          ""Programming Language :: Python :: 2.7"",\n          ""Programming Language :: Python :: 3.4"",\n          ""Programming Language :: Python :: 3.5"",\n          ""Programming Language :: Python :: 3.6"",\n          ""Programming Language :: Python :: 3.7"",\n          ""Topic :: Scientific/Engineering"",\n          ""Topic :: Scientific/Engineering :: Information Analysis"",\n          ""Topic :: Scientific/Engineering :: Mathematics"",\n          ""Topic :: Scientific/Engineering :: Physics"",\n          ""Topic :: Software Development"",\n          ""Topic :: Utilities"",\n          ],\n      platforms = ""Any"",\n      )\n'"
awkward/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport distutils.version\n\nimport numpy\nif distutils.version.LooseVersion(numpy.__version__) < distutils.version.LooseVersion(""1.13.1""):\n    raise ImportError(""Numpy 1.13.1 or later required"")\n\nfrom awkward.array.base import AwkwardArray\nfrom awkward.array.chunked import ChunkedArray, AppendableArray\nfrom awkward.array.indexed import IndexedArray, SparseArray\nfrom awkward.array.jagged import JaggedArray\nfrom awkward.array.masked import MaskedArray, BitMaskedArray, IndexedMaskedArray\nfrom awkward.array.objects import Methods, ObjectArray, StringArray\nfrom awkward.array.table import Table\nfrom awkward.array.union import UnionArray\nfrom awkward.array.virtual import VirtualArray\n\ndef concatenate(arrays, axis=0):\n    return AwkwardArray.concatenate(arrays, axis=axis)\n\nfrom awkward.generate import fromiter\n\nfrom awkward.persist import serialize, deserialize, save, load, hdf5\n\nfrom awkward.arrow import toarrow, fromarrow, toparquet, fromparquet\nfrom awkward.util import topandas\n\n# convenient access to the version number\nfrom awkward.version import __version__\n\n__all__ = [""numpy"", ""AwkwardArray"", ""ChunkedArray"", ""AppendableArray"", ""IndexedArray"", ""SparseArray"", ""JaggedArray"", ""MaskedArray"", ""BitMaskedArray"", ""IndexedMaskedArray"", ""Methods"", ""ObjectArray"", ""Table"", ""UnionArray"", ""VirtualArray"", ""StringArray"", ""fromiter"", ""serialize"", ""deserialize"", ""save"", ""load"", ""hdf5"", ""toarrow"", ""fromarrow"", ""toparquet"", ""fromparquet"", ""topandas"", ""__version__""]\n\n__path__ = __import__(""pkgutil"").extend_path(__path__, __name__)\n'"
awkward/arrow.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport codecs\nimport json\n\nimport numpy\n\nimport awkward.array.base\nimport awkward.array.chunked\nimport awkward.array.indexed\nimport awkward.array.jagged\nimport awkward.array.masked\nimport awkward.array.objects\nimport awkward.array.table\nimport awkward.array.virtual\nimport awkward.type\nimport awkward.util\n\n################################################################################ type conversions\n\ndef schema2type(schema):\n    import pyarrow\n\n    def recurse(tpe, nullable):\n        if isinstance(tpe, pyarrow.lib.DictionaryType):\n            out = recurse(tpe.dictionary.type, nullable)\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.StructType):\n            out = None\n            for i in range(tpe.num_children):\n                x = awkward.type.ArrayType(tpe[i].name, recurse(tpe[i].type, tpe[i].nullable))\n                if out is None:\n                    out = x\n                else:\n                    out = out & x\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.ListType):\n            out = awkward.type.ArrayType(float(""inf""), recurse(tpe.value_type, nullable))\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType):\n            out = None\n            for i in range(tpe.num_children):\n                x = recurse(tpe[i].type, nullable)\n                if out is None:\n                    out = x\n                else:\n                    out = out | x\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif tpe == pyarrow.string():\n            if nullable:\n                return awkward.type.OptionType(str)\n            else:\n                return str\n\n        elif tpe == pyarrow.binary():\n            if nullable:\n                return awkward.type.OptionType(bytes)\n            else:\n                return bytes\n\n        elif tpe == pyarrow.bool_():\n            out = awkward.numpy.dtype(bool)\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.DataType):\n            if nullable:\n                return awkward.type.OptionType(tpe.to_pandas_dtype())\n            else:\n                return tpe.to_pandas_dtype()\n\n        else:\n            raise NotImplementedError(repr(tpe))\n\n    out = None\n    for name in schema.names:\n        field = schema.field_by_name(name)\n        mytype = awkward.type.ArrayType(name, recurse(field.type, field.nullable))\n        if out is None:\n            out = mytype\n        else:\n            out = out & mytype\n\n    return out\n\n################################################################################ value conversions\n\n# we need an opt-out of the large indices in certain cases, otherwise use by default\ndef toarrow(obj):\n    import pyarrow\n\n    def recurse(obj, mask):\n        if isinstance(obj, numpy.ndarray):\n            return pyarrow.array(obj, mask=mask)\n\n        elif isinstance(obj, awkward.array.chunked.ChunkedArray):   # includes AppendableArray\n            raise TypeError(""only top-level ChunkedArrays can be converted to Arrow (as RecordBatches)"")\n\n        elif isinstance(obj, awkward.array.indexed.IndexedArray):\n            if mask is None:\n                return pyarrow.DictionaryArray.from_arrays(obj.index, recurse(obj.content, mask))\n            else:\n                return recurse(obj.content[obj.index], mask)\n\n        elif isinstance(obj, awkward.array.indexed.SparseArray):\n            return recurse(obj.dense, mask)\n\n        elif isinstance(obj, awkward.array.jagged.JaggedArray):\n            obj = obj.compact()\n            if mask is not None:\n                mask = obj.tojagged(mask).flatten()\n            arrow_type = pyarrow.ListArray\n            # 64bit offsets not yet completely golden in arrow\n            # if hasattr(pyarrow, \'LargeListArray\') and obj.starts.itemsize > 4:\n            #     arrow_type = pyarrow.LargeListArray\n            return arrow_type.from_arrays(obj.offsets, recurse(obj.content, mask))\n\n        elif isinstance(obj, awkward.array.masked.IndexedMaskedArray):\n            thismask = obj.boolmask(maskedwhen=True)\n            if mask is not None:\n                thismask = mask | thismask\n            if len(obj.content) == 0:\n                content = obj.numpy.empty(len(obj.mask), dtype=obj.DEFAULTTYPE)\n            else:\n                content = obj.content[obj.mask]\n            return recurse(content, thismask)\n\n        elif isinstance(obj, awkward.array.masked.MaskedArray):   # includes BitMaskedArray\n            thismask = obj.boolmask(maskedwhen=True)\n            if mask is not None:\n                thismask = mask | thismask\n            return recurse(obj.content, thismask)\n\n        elif isinstance(obj, awkward.array.objects.StringArray):\n            if obj.encoding is None and hasattr(pyarrow.BinaryArray, \'from_buffers\'):\n                arrow_type = pyarrow.BinaryArray\n                arrow_offset_type = pyarrow.binary()\n                # 64bit offsets not yet completely golden in arrow\n                # if hasattr(pyarrow, \'LargeBinaryArray\') and obj.starts.itemsize > 4:\n                #     arrow_type = pyarrow.LargeBinaryArray\n                #     arrow_offset_type = pyarrow.large_binary()\n                convert = lambda length, offsets, content: arrow_type.from_buffers(arrow_offset_type, length, [None, offsets, content])\n            elif codecs.lookup(obj.encoding) is codecs.lookup(""utf-8"") or obj.encoding is None:\n                arrow_type = pyarrow.StringArray\n                # if hasattr(pyarrow, \'LargeStringArray\') and obj.starts.itemsize > 4:\n                #     arrow_type = pyarrow.LargeStringArray\n                convert = lambda length, offsets, content: arrow_type.from_buffers(length, offsets, content)\n            else:\n                raise ValueError(""only encoding=None or encoding=\'utf-8\' can be converted to Arrow"")\n\n            obj = obj.compact()\n            offsets = obj.offsets\n            if offsets.dtype != numpy.dtype(numpy.int32):\n                offsets = offsets.astype(numpy.int32)\n\n            return convert(len(offsets) - 1, pyarrow.py_buffer(offsets), pyarrow.py_buffer(obj.content))\n\n        elif isinstance(obj, awkward.array.objects.ObjectArray):\n            # throw away Python object interpretation, which Arrow can\'t handle while being multilingual\n            return recurse(obj.content, mask)\n\n        elif isinstance(obj, awkward.array.table.Table):\n            return pyarrow.StructArray.from_arrays([recurse(x, mask) for x in obj.contents.values()], list(obj.contents))\n\n        elif isinstance(obj, awkward.array.union.UnionArray):\n            contents = []\n            for i, x in enumerate(obj.contents):\n                if mask is None:\n                    thismask = None\n                else:\n                    thistags = (obj.tags == i)\n                    thismask = obj.numpy.empty(len(x), dtype=obj.MASKTYPE)\n                    thismask[obj.index[thistags]] = mask[thistags]    # hmm... obj.index could have repeats; the Arrow mask in that case would not be well-defined...\n                contents.append(recurse(x, thismask))\n\n            return pyarrow.UnionArray.from_dense(pyarrow.array(obj.tags.astype(numpy.int8)), pyarrow.array(obj.index.astype(numpy.int32)), contents)\n\n        elif isinstance(obj, awkward.array.virtual.VirtualArray):\n            return recurse(obj.array, mask)\n\n        else:\n            raise TypeError(""cannot convert type {0} to Arrow"".format(type(obj)))\n\n    if isinstance(obj, awkward.array.chunked.ChunkedArray):   # includes AppendableArray\n        batches = []\n        for chunk in obj.chunks:\n            arr = toarrow(chunk)\n            if isinstance(arr, pyarrow.Table):\n                batches.extend(arr.to_batches())\n            else:\n                batches.append(pyarrow.RecordBatch.from_arrays([arr], [""""]))\n        return pyarrow.Table.from_batches(batches)\n\n    elif isinstance(obj, awkward.array.masked.IndexedMaskedArray) and isinstance(obj.content, awkward.array.table.Table):\n        mask = obj.boolmask(maskedwhen=True)\n        if len(obj.content) == 0:\n            content = obj.numpy.empty(len(obj.mask), dtype=obj.DEFAULTTYPE)\n        else:\n            content = obj.content[obj.mask]\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, mask) for x in obj.content.contents.values()], list(obj.content.contents))])\n\n    elif isinstance(obj, awkward.array.masked.MaskedArray) and isinstance(obj.content, awkward.array.table.Table):   # includes BitMaskedArray\n        mask = obj.boolmask(maskedwhen=True)\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, mask) for x in obj.content.contents.values()], list(obj.content.contents))])\n\n    elif isinstance(obj, awkward.array.table.Table):\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, None) for x in obj.contents.values()], list(obj.contents))])\n\n    else:\n        return recurse(obj, None)\n\ndef fromarrow(obj, awkwardlib=None):\n    import pyarrow\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    ARROW_BITMASKTYPE = awkwardlib.numpy.uint8\n    ARROW_INDEXTYPE = awkwardlib.numpy.int32\n    ARROW_LARGEINDEXTYPE = awkwardlib.numpy.int64\n    ARROW_TAGTYPE = awkwardlib.numpy.uint8\n    ARROW_CHARTYPE = awkwardlib.numpy.uint8\n\n    def popbuffers(array, tpe, buffers, length):\n        if isinstance(tpe, pyarrow.lib.DictionaryType):\n            index = popbuffers(None if array is None else array.indices, tpe.index_type, buffers, length)\n            if hasattr(tpe, ""dictionary""):\n                content = fromarrow(tpe.dictionary)\n            elif array is not None:\n                content = fromarrow(array.dictionary)\n            else:\n                raise NotImplementedError(""no way to access Arrow dictionary inside of UnionArray"")\n            if isinstance(index, awkwardlib.BitMaskedArray):\n                return awkwardlib.BitMaskedArray(index.mask, awkwardlib.IndexedArray(index.content, content), maskedwhen=index.maskedwhen, lsborder=index.lsborder)\n            else:\n                return awkwardlib.IndexedArray(index, content)\n\n        elif isinstance(tpe, pyarrow.lib.StructType):\n            assert getattr(tpe, ""num_buffers"", 1) == 1\n            mask = buffers.pop(0)\n            pairs = []\n            for i in range(tpe.num_children):\n                pairs.append((tpe[i].name, popbuffers(None if array is None else array.field(tpe[i].name), tpe[i].type, buffers, length)))\n            out = awkwardlib.Table.frompairs(pairs, 0)   # FIXME: better rowstart\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.ListType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = popbuffers(None if array is None else array.flatten(), tpe.value_type, buffers, offsets[-1])\n            out = awkwardlib.JaggedArray.fromoffsets(offsets, content)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n                \n        elif hasattr(pyarrow.lib, \'LargeListType\') and isinstance(tpe, pyarrow.lib.LargeListType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = popbuffers(None if array is None else array.flatten(), tpe.value_type, buffers, offsets[-1])\n            out = awkwardlib.JaggedArray.fromoffsets(offsets, content)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""sparse"":\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            tags = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_TAGTYPE)[:length]\n            assert buffers.pop(0) is None\n            index = awkwardlib.numpy.arange(len(tags), dtype=ARROW_INDEXTYPE)\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i][-1] + 1\n                except IndexError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these[-1] + 1]\n            out = awkwardlib.UnionArray(tags, index, contents)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""dense"":\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            tags = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_TAGTYPE)[:length]\n            index = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length]\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i].max() + 1\n                except ValueError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these.max() + 1]\n            out = awkwardlib.UnionArray(tags, index, contents)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.string():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=""utf-8"")\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n                \n        elif tpe == pyarrow.large_string():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=""utf-8"")\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.binary():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=None)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n        \n        elif tpe == pyarrow.large_binary():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=None)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.bool_():\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            out = awkwardlib.numpy.unpackbits(awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)).view(awkwardlib.MaskedArray.BOOLTYPE)\n            out = out.reshape(-1, 8)[:,::-1].reshape(-1)[:length]    # lsborder=True\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.DataType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            out = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=tpe.to_pandas_dtype())[:length]\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        else:\n            raise NotImplementedError(repr(tpe))\n\n    if isinstance(obj, pyarrow.lib.Array):\n        buffers = obj.buffers()\n        out = popbuffers(obj, obj.type, buffers, len(obj))\n        assert len(buffers) == 0\n        return out\n\n    elif isinstance(obj, pyarrow.lib.ChunkedArray):\n        chunks = [x for x in obj.chunks if len(x) > 0]\n        if len(chunks) == 1:\n            return fromarrow(chunks[0])\n        else:\n            return awkwardlib.ChunkedArray([fromarrow(x) for x in chunks], chunksizes=[len(x) for x in chunks])\n\n    elif isinstance(obj, pyarrow.lib.RecordBatch):\n        out = awkwardlib.Table()\n        for n, x in zip(obj.schema.names, obj.columns):\n            out[n] = fromarrow(x)\n        return out\n\n    elif isinstance(obj, pyarrow.lib.Table):\n        chunks = []\n        chunksizes = []\n        for batch in obj.to_batches():\n            chunk = fromarrow(batch)\n            if len(chunk) > 0:\n                chunks.append(chunk)\n                chunksizes.append(len(chunk))\n        if len(chunks) == 1:\n            return chunks[0]\n        else:\n            return awkwardlib.ChunkedArray(chunks, chunksizes=chunksizes)\n\n    else:\n        raise NotImplementedError(type(obj))\n\n################################################################################ Parquet file handling\n\ndef toparquet(where, obj, **options):\n    import pyarrow.parquet\n\n    options[""where""] = where\n\n    def convert(obj, message):\n        if isinstance(obj, (awkward.array.base.AwkwardArray, numpy.ndarray)):\n            out = toarrow(obj)\n            if isinstance(out, pyarrow.Table):\n                return out\n            else:\n                return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([out], [""""])])\n        else:\n            raise TypeError(message)\n\n    if isinstance(obj, awkward.array.chunked.ChunkedArray):\n        obj = iter(obj.chunks)\n        try:\n            awkitem = next(obj)\n        except StopIteration:\n            raise ValueError(""iterable is empty"")\n\n        arritem = convert(awkitem, None)\n        if ""schema"" not in options:\n            options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n\n        try:\n            while True:\n                try:\n                    awkitem = next(obj)\n                except StopIteration:\n                    break\n                else:\n                    writer.write_table(convert(awkitem, None))\n        finally:\n            writer.close()\n\n    elif isinstance(obj, (awkward.array.base.AwkwardArray, numpy.ndarray)):\n        arritem = convert(obj, None)\n        options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n        writer.close()\n\n    else:\n        try:\n            obj = iter(obj)\n        except TypeError:\n            raise TypeError(""cannot write {0} to Parquet file"".format(type(obj)))\n        try:\n            awkitem = next(obj)\n        except StopIteration:\n            raise ValueError(""iterable is empty"")\n\n        arritem = convert(awkitem, ""cannot write iterator of {0} to Parquet file"".format(type(awkitem)))\n        if ""schema"" not in options:\n            options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n\n        try:\n            while True:\n                try:\n                    awkitem = next(obj)\n                except StopIteration:\n                    break\n                else:\n                    writer.write_table(convert(awkitem, ""cannot write iterator of {0} to Parquet file"".format(type(awkitem))))\n        finally:\n            writer.close()\n\nclass _ParquetFile(object):\n    def __init__(self, file, metadata=None, common_metadata=None):\n        self.file = file\n        self.metadata = metadata\n        self.common_metadata = common_metadata\n        self._init()\n\n    def _init(self):\n        import pyarrow.parquet\n        self.parquetfile = pyarrow.parquet.ParquetFile(self.file, metadata=self.metadata, common_metadata=self.common_metadata)\n        self.type = schema2type(self.parquetfile.schema.to_arrow_schema())\n\n    def __getstate__(self):\n        return {""file"": self.file, ""metadata"": self.metadata, ""common_metadata"": self.common_metadata}\n\n    def __setstate__(self, state):\n        self.file = state[""file""]\n        self.metadata = state[""metadata""]\n        self.common_metadata = state[""common_metadata""]\n        self._init()\n\n    def __call__(self, rowgroup, column):\n        return fromarrow(self.parquetfile.read_row_group(rowgroup, columns=[column]))[column]\n\n    def tojson(self):\n        json.dumps([self.file, self.metadata, self.common_metadata])\n        return {""file"": self.file, ""metadata"": self.metadata, ""common_metadata"": self.common_metadata}\n\n    @classmethod\n    def fromjson(cls, state):\n        return cls(state[""file""], metadata=state[""metadata""], common_metadata=state[""common_metadata""])\n\ndef fromparquet(file, awkwardlib=None, cache=None, persistvirtual=False, metadata=None, common_metadata=None):\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    parquetfile = _ParquetFile(file, metadata=metadata, common_metadata=common_metadata)\n    columns = parquetfile.type.columns\n\n    chunks = []\n    chunksizes = []\n    for i in range(parquetfile.parquetfile.num_row_groups):\n        numrows = parquetfile.parquetfile.metadata.row_group(i).num_rows\n        if numrows > 0:\n            if columns == [""""]:\n                chunk = awkwardlib.VirtualArray(parquetfile, (i, """"), cache=cache, type=awkwardlib.type.ArrayType(numrows, parquetfile.type[""""]), persistvirtual=persistvirtual)\n            else:\n                chunk = awkwardlib.Table()\n                for n in columns:\n                    q = awkwardlib.VirtualArray(parquetfile, (i, n), cache=cache, type=awkwardlib.type.ArrayType(numrows, parquetfile.type[n]), persistvirtual=persistvirtual)\n                    chunk.contents[n] = q\n\n            chunks.append(chunk)\n            chunksizes.append(numrows)\n\n    return awkwardlib.ChunkedArray(chunks, chunksizes)\n'"
awkward/generate.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport codecs\nimport collections\nimport numbers\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward.type\nimport awkward.util\n\ndef typeof(obj):\n    if obj is None:\n        return None\n\n    elif isinstance(obj, (bool, numpy.bool_, numpy.bool)):\n        return BoolFillable\n    elif isinstance(obj, (numbers.Number, awkward.numpy.number)):\n        return NumberFillable\n    elif isinstance(obj, bytes):\n        return BytesFillable\n    elif isinstance(obj, awkward.util.string):\n        return StringFillable\n\n    elif isinstance(obj, dict):\n        if any(not isinstance(x, str) for x in obj):\n            raise TypeError(""only dicts with str-typed keys may be converted"")\n        if len(obj) == 0:\n            return None\n        else:\n            return set(obj)\n\n    elif isinstance(obj, tuple) and hasattr(obj, ""_fields"") and obj._fields is type(obj)._fields:\n        return obj._fields, type(obj)\n\n    elif isinstance(obj, Iterable):\n        return JaggedFillable\n\n    else:\n        return set(n for n in obj.__dict__ if not n.startswith(""_"")), type(obj)\n\nclass Fillable(object):\n    def __init__(self, awkwardlib):\n        self.awkwardlib = awkwardlib\n\n    @staticmethod\n    def make(tpe, awkwardlib):\n        if tpe is None:\n            return MaskedFillable(UnknownFillable(awkwardlib), 0, awkwardlib)\n\n        elif isinstance(tpe, type):\n            return tpe(awkwardlib)\n\n        elif isinstance(tpe, set):\n            return TableFillable(tpe, awkwardlib)\n\n        elif isinstance(tpe, tuple) and len(tpe) == 2 and isinstance(tpe[0], set):\n            if len(tpe[0]) == 0:\n                return ObjectFillable(JaggedFillable(awkwardlib), tpe[1], awkwardlib)\n            else:\n                return ObjectFillable(TableFillable(tpe[0], awkwardlib), tpe[1], awkwardlib)\n\n        elif isinstance(tpe, tuple) and len(tpe) == 2 and isinstance(tpe[0], tuple):\n            if len(tpe[0]) == 0:\n                return NamedTupleFillable(JaggedFillable(awkwardlib), tpe[1], awkwardlib)\n            else:\n                return NamedTupleFillable(TableFillable(tpe[0], awkwardlib), tpe[1], awkwardlib)\n\n        else:\n            raise AssertionError(tpe)\n\n    def matches(self, tpe):\n        return type(self) is tpe\n\nclass UnknownFillable(Fillable):\n    __slots__ = [""count"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.count = 0\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return self.count\n\n    def clear(self):\n        self.count = 0\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            self.count += 1\n            return self\n\n        else:\n            fillable = Fillable.make(tpe, self.awkwardlib)\n            if self.count == 0:\n                return fillable.append(obj, tpe)\n            else:\n                return MaskedFillable(fillable.append(obj, tpe), self.count, self.awkwardlib)\n\n    def finalize(self, **options):\n        maskedwhen = options.get(""maskedwhen"", True)\n        if self.count == 0:\n            return self.awkwardlib.numpy.empty(0, dtype=self.awkwardlib.JaggedArray.DEFAULTTYPE)\n        else:\n            if maskedwhen:\n                mask = self.awkwardlib.numpy.ones(self.count, dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n            else:\n                mask = self.awkwardlib.numpy.zeros(self.count, dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n            return self.awkwardlib.MaskedArray(mask, mask, maskedwhen=maskedwhen)\n\nclass SimpleFillable(Fillable):\n    __slots__ = [""data"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.data = []\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.data)\n\n    def clear(self):\n        self.data = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            self.data.append(obj)\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\nclass BoolFillable(SimpleFillable):\n    def finalize(self, **options):\n        return self.awkwardlib.numpy.array(self.data, dtype=self.awkwardlib.JaggedArray.BOOLTYPE)\n\nclass NumberFillable(SimpleFillable):\n    def finalize(self, **options):\n        return self.awkwardlib.numpy.array(self.data)\n\nclass BytesFillable(SimpleFillable):\n    def finalize(self, **options):\n        dictencoding = options.get(""dictencoding"", False)\n        if (callable(dictencoding) and dictencoding(self.data)) or (not callable(dictencoding) and dictencoding):\n            dictionary, index = self.awkwardlib.numpy.unique(self.data, return_inverse=True)\n            return self.awkwardlib.IndexedArray(index, self.awkwardlib.StringArray.fromiter(dictionary, encoding=None))\n        else:\n            return self.awkwardlib.StringArray.fromiter(self.data, encoding=None)\n\nclass StringFillable(SimpleFillable):\n    def finalize(self, **options):\n        dictencoding = options.get(""dictencoding"", False)\n        if (callable(dictencoding) and dictencoding(self.data)) or (not callable(dictencoding) and dictencoding):\n            dictionary, index = self.awkwardlib.numpy.unique(self.data, return_inverse=True)\n            return self.awkwardlib.IndexedArray(index, self.awkwardlib.StringArray.fromiter(dictionary, encoding=""utf-8""))\n        else:\n            return self.awkwardlib.StringArray.fromiter(self.data, encoding=""utf-8"")\n\nclass JaggedFillable(Fillable):\n    __slots__ = [""content"", ""offsets"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.content = UnknownFillable(awkwardlib)\n        self.offsets = [0]\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.offsets) - 1\n\n    def clear(self):\n        self.content.clear()\n        self.offsets = [0]\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            for x in obj:\n                self.content = self.content.append(x, typeof(x))\n            self.offsets.append(len(self.content))\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        return self.awkwardlib.JaggedArray.fromoffsets(self.offsets, self.content.finalize(**options))\n\nclass TableFillable(Fillable):\n    __slots__ = [""fields"", ""contents"", ""count"", ""awkwardlib""]\n\n    def __init__(self, fields, awkwardlib):\n        assert len(fields) > 0\n        self.fields = fields\n        self.contents = {n: UnknownFillable(awkwardlib) for n in fields}\n        self.count = 0\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return self.count\n\n    def clear(self):\n        for content in self.contents.values():\n            content.clear()\n        self.count = 0\n\n    def matches(self, tpe):\n        return self.fields == tpe\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            for n in self.fields:\n                x = obj[n]\n                self.contents[n] = self.contents[n].append(x, typeof(x))\n            self.count += 1\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        return self.awkwardlib.Table.frompairs([(n, self.contents[n].finalize(**options)) for n in sorted(self.fields)], 0)\n\nclass ObjectFillable(Fillable):\n    __slots__ = [""content"", ""cls"", ""awkwardlib""]\n\n    def __init__(self, content, cls, awkwardlib):\n        self.content = content\n        self.cls = cls\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.content)\n\n    def clear(self):\n        self.content.clear()\n\n    def matches(self, tpe):\n        return isinstance(tpe, tuple) and len(tpe) == 2 and tpe[1] is self.cls and (len(tpe[0]) == 0 or self.content.matches(tpe[0]))\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            if len(tpe[0]) == 0:\n                self.content.append([], JaggedFillable)\n            else:\n                self.content.append(obj.__dict__, tpe[0])\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        def make(x):\n            out = self.cls.__new__(self.cls)\n            out.__dict__.update(x.tolist())\n            return out\n\n        return self.awkwardlib.ObjectArray(self.content.finalize(**options), make)\n\nclass NamedTupleFillable(ObjectFillable):\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            if len(tpe[0]) == 0:\n                self.content.append([], JaggedFillable)\n            else:\n                self.content.append({n: x for n, x in zip(obj._fields, obj)}, tpe[0])\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        def make(x):\n            asdict = x.tolist()\n            return self.cls(*[asdict[n] for n in self.cls._fields])\n\n        return self.awkwardlib.ObjectArray(self.content.finalize(**options), make)\n\nclass MaskedFillable(Fillable):\n    __slots__ = [""content"", ""nullpos"", ""awkwardlib""]\n\n    def __init__(self, content, count, awkwardlib):\n        self.content = content\n        self.nullpos = list(range(count))\n        self.awkwardlib = awkwardlib\n\n    def matches(self, tpe):\n        return tpe is None\n\n    def __len__(self):\n        return len(self.content) + len(self.nullpos)\n\n    def clear(self):\n        self.content.clear()\n        self.nullpos = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            self.nullpos.append(len(self))\n        else:\n            self.content = self.content.append(obj, tpe)\n        return self\n\n    def finalize(self, **options):\n        maskedwhen = options.get(""maskedwhen"", True)\n\n        if isinstance(self.content, (TableFillable, ObjectFillable, UnionFillable)):\n            index = self.awkwardlib.numpy.zeros(len(self), dtype=self.awkwardlib.IndexedMaskedArray.INDEXTYPE)\n            index[self.nullpos] = -1\n            index[index == 0] = awkward.numpy.arange(len(self.content))\n\n            return self.awkwardlib.IndexedMaskedArray(index, self.content.finalize(**options))\n\n        valid = self.awkwardlib.numpy.ones(len(self), dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n        valid[self.nullpos] = False\n\n        if isinstance(self.content, (BoolFillable, NumberFillable)):\n            compact = self.content.finalize(**options)\n            expanded = self.awkwardlib.numpy.empty(len(self), dtype=compact.dtype)\n            expanded[valid] = compact\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        elif isinstance(self.content, (BytesFillable, StringFillable)):\n            compact = self.content.finalize(**options)\n\n            if isinstance(compact, self.awkwardlib.IndexedArray):\n                index = self.awkwardlib.numpy.zeros(len(self), dtype=compact.index.dtype)\n                index[valid] = compact.index\n                expanded = self.awkwardlib.IndexedArray(index, compact.content)\n            else:\n                counts = self.awkwardlib.numpy.zeros(len(self), dtype=compact.counts.dtype)\n                counts[valid] = compact.counts\n                expanded = self.awkwardlib.StringArray.fromcounts(counts, compact.content, encoding=compact.encoding)\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        elif isinstance(self.content, JaggedFillable):\n            compact = self.content.finalize(**options)\n            counts = self.awkwardlib.numpy.zeros(len(self), dtype=compact.counts.dtype)\n            counts[valid] = compact.counts\n            expanded = self.awkwardlib.JaggedArray.fromcounts(counts, compact.content)\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        else:\n            raise AssertionError(self.content)\n\nclass UnionFillable(Fillable):\n    __slots__ = [""contents"", ""tags"", ""index"", ""awkwardlib""]\n\n    def __init__(self, content, awkwardlib):\n        self.contents = [content]\n        self.tags = [0] * len(content)\n        self.index = list(range(len(content)))\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.tags)\n\n    def clear(self):\n        for content in self.contents:\n            content.clear()\n        self.tags = []\n        self.index = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        else:\n            for tag, content in enumerate(self.contents):\n                if content.matches(tpe):\n                    self.tags.append(tag)\n                    self.index.append(len(content))\n                    content.append(obj, tpe)\n                    break\n\n            else:\n                fillable = Fillable.make(tpe, self.awkwardlib)\n                self.tags.append(len(self.contents))\n                self.index.append(len(fillable))\n                self.contents.append(fillable.append(obj, tpe))\n\n            return self\n\n    def finalize(self, **options):\n        return self.awkwardlib.UnionArray(self.tags, self.index, [x.finalize(**options) for x in self.contents])\n\ndef _checkoptions(options):\n    unrecognized = set(options).difference([""dictencoding"", ""maskedwhen""])\n    if len(unrecognized) != 0:\n        raise TypeError(""unrecognized options: {0}"".format("", "".join(sorted(unrecognized))))\n\ndef fromiter(iterable, awkwardlib=None, **options):\n    _checkoptions(options)\n\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    fillable = UnknownFillable(awkwardlib)\n\n    for obj in iterable:\n        fillable = fillable.append(obj, typeof(obj))\n\n    return fillable.finalize(**options)\n'"
awkward/pandas.py,0,"b' #!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nfrom __future__ import absolute_import\nimport pandas\nimport pandas.api.extensions\n\nimport awkward.array\n\ndef delegated_method(method, index, name, *args, **kwargs):\n    return pandas.Series\n\nclass Delegated(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, type=None):\n        index = object.__getattribute__(obj, ""_index"")\n        name = object.__getattribute__(obj, ""_name"")\n        result = self._get_result(obj)\n        return pandas.Series(result, index, name=name)\n\nclass DelegatedProperty(Delegated):\n    def _get_result(self, obj, type=None):\n        return getattr(object.__getattribute__(obj, ""_data""), self.name)\n\nclass DelegatedMethod(Delegated):\n    def __get__(self, obj, type=None):\n        index = object.__getattribute__(obj, ""_index"")\n        name = object.__getattribute__(bj, ""_name"")\n        method = getattr(object.__getattribute__(obj, ""_data""), self.name)\n        return delegated_method(method, index, name)\n\nclass AwkwardSeriesDtype(pandas.api.extensions.ExtensionDtype):\n    name = ""awkward""\n    type = awkward.array.base.AwkwardArray\n    kind = ""O""\n\n    @classmethod\n    def construct_from_string(cls, string):\n        if string == cls.name:\n            return cls()\n        else:\n            raise TypeError(""Cannot construct a \'{}\' from \'{}\'"".format(cls, string))\n\n@pandas.api.extensions.register_series_accessor(""awkward"")\nclass AwkwardAccessor(object):\n    def __init__(self, pandas_obj):\n        self._validate(pandas_obj)\n\n        self._data = pandas_obj.values\n        self._index = pandas_obj.index\n        self._name = pandas_obj.name\n\n    @staticmethod\n    def _validate(obj):\n        if not is_awkward_type(obj):\n            raise AttributeError(""Cannot use \'awkward\' accessor on objects of dtype \'{}\'."".format(obj.dtype))\n\ndef is_awkward_type(obj):\n    t = getattr(obj, ""dtype"", obj)\n    try:\n        return isinstance(t, AwkwardSeriesDtype) or issubclass(t, AwkwardSeriesDtype)\n    except Exception:\n        return False\n\nclass AwkwardSeries(object):\n    @property\n    def dtype(self):\n        return AwkwardSeriesDtype()\n\n    @staticmethod\n    def _findclass(cls):\n        for base in cls.__bases__:\n            if issubclass(base, awkward.array.base.AwkwardArray):\n                if not issubclass(base, AwkwardSeries):\n                    return base\n                else:\n                    out = AwkwardSeries._findclass(base)\n                    if out is not None:\n                        return out\n        return None\n\n    def __array__(self, dtype=None):\n        cls = self._findclass(type(self))\n\n        if dtype is None:\n            dtype = cls.dtype.fget(self)\n\n        return cls.__array__(self, dtype=dtype)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        out = self._findclass(type(self)).__array_ufunc__(self, ufunc, method, *inputs, **kwargs)\n        return out.pandas\n\n    def isna(self):\n        return self.numpy.zeros(self.shape, dtype=self.BOOLTYPE)\n\n    @classmethod\n    def _concat_same_type(cls, to_concat):\n        return cls.concatenate(to_concat)\n\n    @property\n    def ChunkedArray(self):\n        return mixin(self._findclass(type(self)).ChunkedArray.fget(self))\n\n    @property\n    def AppendableArray(self):\n        return mixin(self._findclass(type(self)).AppendableArray.fget(self))\n\n    @property\n    def IndexedArray(self):\n        return mixin(self._findclass(type(self)).IndexedArray.fget(self))\n\n    @property\n    def SparseArray(self):\n        return mixin(self._findclass(type(self)).SparseArray.fget(self))\n\n    @property\n    def JaggedArray(self):\n        return mixin(self._findclass(type(self)).JaggedArray.fget(self))\n\n    @property\n    def MaskedArray(self):\n        return mixin(self._findclass(type(self)).MaskedArray.fget(self))\n\n    @property\n    def BitMaskedArray(self):\n        return mixin(self._findclass(type(self)).BitMaskedArray.fget(self))\n\n    @property\n    def IndexedMaskedArray(self):\n        return mixin(self._findclass(type(self)).IndexedMaskedArray.fget(self))\n\n    @property\n    def ObjectArray(self):\n        return mixin(self._findclass(type(self)).ObjectArray.fget(self))\n\n    @property\n    def StringArray(self):\n        return mixin(self._findclass(type(self)).StringArray.fget(self))\n\n    @property\n    def Table(self):\n        return mixin(self._findclass(type(self)).Table.fget(self))\n\n    @property\n    def UnionArray(self):\n        return mixin(self._findclass(type(self)).UnionArray.fget(self))\n\n    @property\n    def VirtualArray(self):\n        return mixin(self._findclass(type(self)).VirtualArray.fget(self))\n\ndef mixin(tpe):\n    return type(tpe._topandas_name, (AwkwardSeries, tpe, pandas.api.extensions.ExtensionArray), {})\n'"
awkward/persist.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport base64\nimport fnmatch\nimport importlib\nimport json\nimport numbers\nimport os\nimport pickle\nimport types\nimport zipfile\nimport zlib\nfrom itertools import count\ntry:\n    from collections.abc import Mapping, MutableMapping\nexcept ImportError:\n    from collections import Mapping, MutableMapping\n\nimport numpy\n\nimport awkward.type\nimport awkward.version\n\ncompression = [\n        {""minsize"": 8192, ""types"": [numpy.bool_, numpy.bool, numpy.integer], ""contexts"": ""*"", ""pair"": (zlib.compress, (""zlib"", ""decompress""))},\n    ]\n\nwhitelist = [\n        [""numpy"", ""frombuffer""],\n        [""zlib"", ""decompress""],\n        [""lzma"", ""decompress""],\n        [""backports.lzma"", ""decompress""],\n        [""lz4.block"", ""decompress""],\n        [""awkward"", ""*Array""],\n        [""awkward"", ""Table""],\n        [""awkward"", ""numpy"", ""frombuffer""],\n        [""awkward.util"", ""frombuffer""],\n        [""awkward.persist""],\n        [""awkward.arrow"", ""_ParquetFile"", ""fromjson""],\n        [""uproot_methods.classes.*""],\n        [""uproot_methods.profiles.*""],\n        [""uproot.tree"", ""_LazyFiles""],\n        [""uproot.tree"", ""_LazyTree""],\n        [""uproot.tree"", ""_LazyBranch""],\n    ]\n\ndef frompython(obj):\n    return base64.b64encode(pickle.dumps(obj)).decode(""ascii"")\n\ndef topython(string):\n    return pickle.loads(base64.b64decode(string.encode(""ascii"")))\n\ndef spec2function(obj, awkwardlib=""awkward"", whitelist=whitelist):\n    for white in whitelist:\n        for n, p in zip(obj, white):\n            if not fnmatch.fnmatchcase(n, p):\n                break\n        else:\n            if obj[0] == ""awkward"":\n                obj = [awkwardlib] + obj[1:]\n            gen, genname = importlib.import_module(obj[0]), obj[1:]\n            if not isinstance(gen, types.ModuleType):\n                raise TypeError(""first item of a function description must be a module"")\n            if genname[:1] == [""numpy""]:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n            while len(genname) > 0:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n                if isinstance(gen, types.ModuleType):\n                    raise TypeError(""non-first items of a function description must not be a module"")\n            break\n    else:\n        raise RuntimeError(""callable not in whitelist; add it by passing a whitelist argument:\\n\\n    whitelist = awkward.persist.whitelist + [{0}]"".format(repr(obj)))\n    return gen\n\ndef dtype2json(obj):\n    if obj.subdtype is not None:\n        dt, sh = obj.subdtype\n        return (dtype2json(dt), sh)\n    elif obj.names is not None:\n        return [(n, dtype2json(obj[n])) for n in obj.names]\n    else:\n        return str(obj)\n\ndef json2dtype(obj):\n    def recurse(obj):\n        if isinstance(obj, (list, tuple)) and len(obj) > 0 and (isinstance(obj[-1], numbers.Integral) or isinstance(obj[0], str) or (isinstance(obj[-1], (list, tuple)) and all(isinstance(x, numbers.Integral) for x in obj[-1]))):\n            return tuple(recurse(x) for x in obj)\n        elif isinstance(obj, (list, tuple)):\n            return [recurse(x) for x in obj]\n        else:\n            return obj\n    return numpy.dtype(recurse(obj))\n\ndef type2json(obj):\n    if isinstance(obj, awkward.type.Type):\n        labeled = obj._labeled()\n    else:\n        labeled = []\n\n    seen = set()\n\n    def takes(n):\n        if n == float(""inf""):\n            return ""inf""\n        else:\n            return int(n)\n\n    def recurse(obj):\n        if isinstance(obj, awkward.type.Type):\n            if id(obj) in seen:\n                for i, x in enumerate(labeled):\n                    if obj is x:\n                        return {""ref"": ""T{0}"".format(i)}\n\n            else:\n                seen.add(id(obj))\n                if isinstance(obj, awkward.type.ArrayType):\n                    out = {""takes"": takes(obj._takes), ""to"": recurse(obj._to)}\n\n                elif isinstance(obj, awkward.type.TableType):\n                    out = {""fields"": [[n, recurse(x)] for n, x in obj._fields.items()]}\n\n                elif isinstance(obj, awkward.type.UnionType):\n                    out = {""possibilities"": [recurse(x) for x in obj._possibilities]}\n\n                elif isinstance(obj, awkward.type.OptionType):\n                    out = {""type"": recurse(obj._type)}\n\n                for i, x in enumerate(labeled):\n                    if obj is x:\n                        return {""set"": ""T{0}"".format(i), ""as"": out}\n                else:\n                    return out\n\n        elif isinstance(obj, numpy.dtype):\n            return {""dtype"": dtype2json(obj)}\n\n        elif callable(obj):\n            if obj.__module__ == ""__main__"":\n                raise TypeError(""cannot persist object type: its generator is defined in __main__, which won\'t be available in a subsequent session"")\n            if hasattr(obj, ""__qualname__""):\n                spec = [obj.__module__] + obj.__qualname__.split(""."")\n            else:\n                spec = [obj.__module__, obj.__name__]\n\n            gen, genname = importlib.import_module(spec[0]), spec[1:]\n            while len(genname) > 0:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n            if gen is not obj:\n                raise TypeError(""cannot persist object type: its generator cannot be found via its __name__ (Python 2) or __qualname__ (Python 3)"")\n\n            return {""function"": spec}\n\n        else:\n            raise TypeError(""only awkward.type.Type, numpy.dtype, and callables are types"")\n\n    return recurse(obj)\n\ndef json2type(obj, whitelist=whitelist):\n    labels = {}\n\n    def takes(n):\n        if n == ""inf"":\n            return float(""inf"")\n        else:\n            return n\n\n    def recurse(obj):\n        if not isinstance(obj, dict):\n            raise TypeError(""json2type is expecting a JSON object, found: {0}"".format(repr(obj)))\n\n        if ""set"" in obj:\n            placeholder = labels[obj[""set""]] = awkward.type.Placeholder()\n            placeholder.value = recurse(obj[""as""])\n            return placeholder\n\n        elif ""ref"" in obj:\n            return labels[obj[""ref""]]\n\n        elif ""takes"" in obj and ""to"" in obj:\n            return awkward.type.ArrayType(takes(obj[""takes""]), recurse(obj[""to""]))\n\n        elif ""fields"" in obj:\n            out = awkward.type.TableType()\n            for n, x in obj[""fields""]:\n                out[n] = recurse(x)\n            return out\n\n        elif ""possibilities"" in obj:\n            return awkward.type.UnionType(*[recurse(x) for x in obj[""possibilities""]])\n\n        elif ""type"" in obj:\n            return awkward.type.OptionType(recurse(obj[""type""]))\n\n        elif ""dtype"" in obj:\n            return json2dtype(obj[""dtype""])\n\n        elif ""function"" in obj:\n            return spec2function(obj[""function""], whitelist=whitelist)\n\n        else:\n            raise ValueError(""unexpected set of keys in JSON: {0}"".format("", "".join(repr(x) for x in obj)))\n\n    return awkward.type._resolve(recurse(obj), {})\n\ndef jsonable(obj):\n    if obj is None:\n        return obj\n\n    elif isinstance(obj, dict) and all(isinstance(n, str) for n in obj):\n        return {n: jsonable(x) for n, x in obj.items()}\n\n    elif isinstance(obj, list):\n        return [jsonable(x) for x in obj]\n\n    elif isinstance(obj, str):\n        return str(obj)\n\n    elif isinstance(obj, (bool, numpy.bool_, numpy.bool)):\n        return bool(obj)      # policy: eliminate Numpy types\n\n    elif isinstance(obj, (numbers.Integral, numpy.integer)):\n        return int(obj)       # policy: eliminate Numpy types\n\n    elif isinstance(obj, (numbers.Real, numpy.floating)) and numpy.isfinite(obj):\n        return float(obj)     # policy: eliminate Numpy types\n\n    else:\n        raise TypeError(""object cannot be losslessly serialized as JSON"")\n\nclass ObjRef(object):\n    def __init__(self, idgen=None):\n        if idgen:\n            self.idgen = iter(idgen)\n        self._i2r = {}\n        self._r2o = {}\n\n    def nextid(self):\n        return next(self.idgen)\n\n    def __contains__(self, obj):\n        return id(obj) in self._i2r\n\n    def __setitem__(self, obj, ref):\n        self._i2r[id(obj)] = ref\n        self._r2o[ref] = obj\n\n    def __getitem__(self, obj):\n        if obj not in self:\n            self[obj] = self.nextid()\n        return self._i2r[id(obj)]\n\n    def __delitem__(self, obj):\n        assert obj in self\n        del self._r2o[self._i2r[id(obj)]]\n        del self._i2r[id(obj)]\n\n    def get(self, obj, default=None):\n        return self[obj] if obj in self else default\n\n    def obj(self, ref):\n        if ref in self._r2o:\n            return self._r2o[ref]\n        else:\n            return awkward.array.virtual.VirtualArray(lambda: self._r2o[ref])\n\nclass Serializer(object):\n    def __init__(self, storage, prefix="""", suffix="""", schemasuffix=""""):\n        self.storage = storage\n        self.suffix = suffix\n        self.prefix = prefix\n        self.schemasuffix = schemasuffix\n        self.seen = ObjRef(idgen=count())\n\n    def store(self, name, obj):\n        schema = {""awkward"": awkward.version.__version__, ""schema"": self(obj)}\n        if self.prefix != """":\n            schema[""prefix""] = self.prefix\n\n        schema = self._finalize_schema(schema) or schema\n\n        self.storage[name + self.schemasuffix] = self._encode_schema(schema)\n        return schema\n\n    def load(self, *args, **kwargs):\n        return deserialize(*args, storage=self.storage, seen=self.seen, **kwargs)\n\n    def encode_call(self, *args, **kwargs):\n        func, args = args[0], args[1:]\n        out = {""call"": self._obj2spec(func) if callable(func) else tuple(func)}\n        if args:\n            out[""args""] = list(args)\n        if kwargs:\n            out[""kwargs""] = kwargs\n        return out\n\n    def encode_json(self, obj):\n        return {""json"": jsonable(obj)}\n\n    def encode_python(self, obj):\n        return {""python"": frompython(obj)}\n\n    @classmethod\n    def _encode_primitive(cls, obj):\n        if isinstance(obj, numpy.dtype):\n            return {""dtype"": dtype2json(obj)}\n\n    @classmethod\n    def _obj2spec(cls, obj, test=True):\n        if hasattr(obj, ""__qualname__""):\n            spec = [obj.__module__] + obj.__qualname__.split(""."")\n        else:\n            spec = [obj.__module__, obj.__name__]\n\n        if test:\n            val = importlib.import_module(spec[0])\n            for key in spec[1:]:\n                val = getattr(val, key)\n            assert val == obj\n\n        return spec\n\n    def _encode_complex(self, obj, context):\n        if callable(getattr(obj, ""__awkward_serialize__"", None)):\n            return obj.__awkward_serialize__(self)\n\n        if hasattr(obj, ""tojson"") and hasattr(type(obj), ""fromjson""):\n            try:\n                return self.encode_call(self._obj2spec(type(obj).fromjson), self.encode_json(obj.tojson()))\n            except:\n                pass\n\n        if isinstance(obj, numpy.ndarray):\n            return self._encode_numpy(obj, context)\n\n        if hasattr(obj, ""__module__"") and (hasattr(obj, ""__qualname__"") or hasattr(obj, ""__name__"")) and obj.__module__ != ""__main__"":\n            try:\n                return {""function"": self._obj2spec(obj)}\n            except:\n                pass\n\n        try:\n            return self.encode_json(obj)\n        except TypeError:\n            pass\n\n        try:\n            return self.encode_python(obj)\n        except:\n            pass\n\n    def _encode_numpy(self, obj, context):\n        key = str(self.seen[obj]) + self.suffix\n        self.storage[self.prefix + key] = obj\n        return {""read"": key}\n\n    def _encode_schema(self, schema):\n        return json.dumps(schema).encode(""ascii"")\n\n    def _finalize_schema(self, schema):\n        pass\n\n    def __call__(self, obj, context=""""):\n        out = self._encode_primitive(obj)\n\n        if out is not None:\n            return out\n\n        if obj in self.seen:\n            return {""ref"": self.seen[obj]}\n        else:\n            ident = self.seen[obj]\n\n        out = self._encode_complex(obj, context)\n        if out is None:\n            raise TypeError(""failed to encode {0} (type: {1})"".format(repr(obj), type(obj)))\n\n        if ""id"" in out:\n            if out[""id""] is False:\n                del self.seen[obj]\n            elif out[""id""] != self.seen[obj]:\n                raise RuntimeError(""unexpected id change"")\n        else:\n            out[""id""] = ident\n\n        return out\n\n    def fill(self, obj, context, prefix, suffix, schemasuffix, storage, compression, **kwargs):\n        assert self.prefix == prefix\n        assert self.suffix == suffix\n        assert self.schemasuffix == schemasuffix\n        assert self.storage == storage\n        assert self.compression == compression\n        return self(obj, context=context)\n\nclass BlobSerializer(Serializer):\n    class CompressPolicy(object):\n        enc2dec = {\n            zlib.compress: (""zlib"", ""decompress""),\n        }\n\n        @classmethod\n        def parse(cls, x):\n            if isinstance(x, cls):\n                return x\n            elif isinstance(x, dict):\n                return cls(**x)\n            elif callable(x):\n                return cls(enc=x)\n            elif len(x) == 2 and callable(x[0]):\n                return cls(enc=x[0], dec=x[1])\n            else:\n                raise TypeError(""can\'t parse compression policy {0}"".format(x))\n\n        def __init__(self, pair=None, enc=None, dec=None, minsize=0, types=object, contexts=""*""):\n            if pair is not None:\n                enc, dec = pair\n            if dec is None:\n                dec = self.enc2dec[enc]\n            if isinstance(types, list):\n                types = tuple(types)\n            elif not isinstance(types, tuple):\n                types = types,\n            if isinstance(contexts, list):\n                contexts = tuple(contexts)\n            elif not isinstance(contexts, tuple):\n                contexts = contexts,\n            assert callable(enc)\n            assert isinstance(dec, tuple)\n            assert 0 <= minsize\n            self.enc = enc\n            self.dec = dec\n            self.minsize = minsize\n            self.types = types\n            self.contexts = contexts\n\n        @property\n        def pair(self):\n            return (self.enc, self.dec)\n\n        def test(self, obj, context):\n            return (obj.nbytes >= self.minsize and issubclass(obj.dtype.type, tuple(self.types)) and any(fnmatch.fnmatchcase(context, p) for p in self.contexts))\n\n    @classmethod\n    def _parse_compression(cls, comp):\n        if comp is None or comp is False:\n            comp = []\n        elif comp is True:\n            comp = [{""minsize"": 0, ""types"": object, ""contexts"": ""*"", ""pair"": (zlib.compress, (""zlib"", ""decompress""))}]\n        elif not isinstance(comp, (list, tuple)):\n            comp = [comp]\n\n        return list(map(cls.CompressPolicy.parse, comp))\n\n    def __init__(self, *args, **kwargs):\n        self.compression = self._parse_compression(kwargs.pop(""compression"", compression))\n        super(BlobSerializer, self).__init__(*args, **kwargs)\n\n    def _put_raw(self, data, ref=None):\n        if ref is None:\n            ref = data\n        key = str(self.seen[ref]) + self.suffix\n        self.storage[self.prefix + key] = data\n        return dict(read=key)\n\n    def _encode_numpy(self, obj, context):\n        if obj.ndim > 1:\n            dtype = numpy.dtype((obj.dtype, obj.shape[1:]))\n        else:\n            dtype = obj.dtype\n\n        buf = None\n        for policy in self._parse_compression(self.compression):\n            if policy.test(obj, context):\n                buf = self.encode_call(policy.dec, self._put_raw(policy.enc(obj.ravel()), ref=obj))\n                break\n        else:\n            buf = self._put_raw(obj.ravel(), ref=obj)\n\n        return self.encode_call([""awkward"", ""numpy"", ""frombuffer""], buf, self(dtype), self(obj.shape[0]))\n\ndef serialize(obj, storage, name="""", delimiter=""-"", **kwargs):\n    if delimiter is None:\n        delimiter = """"\n    if name:\n        kwargs.setdefault(""prefix"", name + delimiter)\n    return BlobSerializer(storage, **kwargs).store(name, obj)\n\ndef deserialize(storage, name="""", awkwardlib=""awkward"", whitelist=whitelist, cache=None, seen=None):\n    import awkward.array.virtual\n\n    schema = storage[name]\n    if isinstance(schema, numpy.ndarray):\n        schema = schema.tostring()\n    if isinstance(schema, bytes):\n        schema = schema.decode(""ascii"")\n    schema = json.loads(schema)\n\n    if ""awkward"" not in schema:\n        raise ValueError(""JSON object is not an awkward-array schema (missing \'awkward\' field)"")\n\n    prefix = schema.get(""prefix"", """")\n    if seen is None:\n        seen = ObjRef()\n\n    if isinstance(whitelist, str):\n        whitelist = [whitelist]\n    elif len(whitelist) > 0 and isinstance(whitelist[0], str):\n        whitelist = [whitelist]\n\n    def unfill(schema):\n        if isinstance(schema, dict):\n            if ""call"" in schema and isinstance(schema[""call""], list) and len(schema[""call""]) > 0:\n                gen = spec2function(schema[""call""], awkwardlib=awkwardlib, whitelist=whitelist)\n                args = [unfill(x) for x in schema.get(""args"", [])]\n\n                kwargs = {}\n                if schema.get(""cacheable"", False):\n                    kwargs[""cache""] = cache\n                if schema.get(""whitelistable"", False):\n                    kwargs[""whitelist""] = whitelist\n                if ""kwargs"" in schema:\n                    kwargs.update({n: unfill(x) for n, x in schema[""kwargs""].items()})\n\n                out = gen(*args, **kwargs)\n\n            elif ""read"" in schema:\n                if schema.get(""absolute"", False):\n                    out = storage[schema[""read""]]\n                else:\n                    out = storage[prefix + schema[""read""]]\n\n            elif ""list"" in schema:\n                out = [unfill(x) for x in schema[""list""]]\n\n            elif ""tuple"" in schema:\n                out = tuple(unfill(x) for x in schema[""tuple""])\n\n            elif ""dict"" in schema:\n                out = {n: unfill(x) for n, x in schema[""dict""].items()}\n\n            elif ""pairs"" in schema:\n                out = [(n, unfill(x)) for n, x in schema[""pairs""]]\n\n            elif ""dtype"" in schema:\n                out = json2dtype(schema[""dtype""])\n\n            elif ""function"" in schema:\n                out = spec2function(schema[""function""], awkwardlib=awkwardlib, whitelist=whitelist)\n\n            elif ""json"" in schema:\n                out = schema[""json""]\n\n            elif ""python"" in schema:\n                out = topython(schema[""python""])\n\n            elif ""ref"" in schema:\n                out = seen.obj(schema[""ref""])\n\n            else:\n                raise ValueError(""unrecognized JSON object with fields {0}"".format("", "".join(repr(x) for x in schema)))\n\n            if ""id"" in schema:\n                seen[out] = schema[""id""]\n            return out\n\n        elif isinstance(schema, list):\n            raise ValueError(""unrecognized JSON list with length {0}"".format(len(schema)))\n\n        else:\n            raise ValueError(""unrecognized JSON object: {0}"".format(repr(schema)))\n\n    return unfill(schema[""schema""])\n\ndef keys(storage, name="""", subschemas=True):\n    schema = storage[name]\n    if isinstance(schema, numpy.ndarray):\n        schema = schema.tostring()\n    if isinstance(schema, bytes):\n        schema = schema.decode(""ascii"")\n    schema = json.loads(schema)\n\n    prefix = schema.get(""prefix"", """")\n\n    def recurse(schema):\n        if isinstance(schema, dict):\n            if ""call"" in schema and isinstance(schema[""call""], list) and len(schema[""call""]) > 0:\n                for x in schema.get(""args"", []):\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""kwargs"", {}).values():\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""*"", []):\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""**"", {}).values():\n                    for y in recurse(x):\n                        yield y\n\n            elif ""read"" in schema:\n                if schema.get(""absolute"", False):\n                    yield schema[""read""]\n                else:\n                    yield prefix + schema[""read""]\n\n            elif ""list"" in schema:\n                for x in schema[""list""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""tuple"" in schema:\n                for x in schema[""tuple""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""dict"" in schema:\n                for x in schema[""dict""].values():\n                    for y in recurse(x):\n                        yield y\n\n            elif ""pairs"" in schema:\n                for n, x in schema[""pairs""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""dtype"" in schema:\n                pass\n\n            elif ""function"" in schema:\n                pass\n\n            elif ""json"" in schema:\n                pass\n\n            elif ""python"" in schema:\n                pass\n\n            elif ""ref"" in schema:\n                pass\n\n    yield name\n    for x in recurse(schema[""schema""]):\n        yield x\n\ndef save(file, array, name=None, mode=""a"", **options):\n    if isinstance(array, dict):\n        arrays = array\n    else:\n        arrays = {"""": array}\n\n    if name is not None:\n        arrays = {name + n: x for n, x in arrays.items()}\n\n    arraynames = list(arrays)\n    for i in range(len(arraynames)):\n        for j in range(i + 1, len(arraynames)):\n            if arraynames[i].startswith(arraynames[j]) or arraynames[j].startswith(arraynames[i]):\n                raise KeyError(""cannot write both {0} and {1} to zipfile because one is a prefix of the other"", repr(arraynames[i]), repr(arraynames[j]))\n\n    if isinstance(file, getattr(os, ""PathLike"", ())):\n        file = os.fspath(file)\n    elif hasattr(file, ""__fspath__""):\n        file = file.__fspath__()\n    elif file.__class__.__module__ == ""pathlib"":\n        import pathlib\n        if isinstance(file, pathlib.Path):\n             file = str(file)\n\n    if isinstance(file, str) and not file.endswith("".awkd""):\n        file = file + "".awkd""\n\n    alloptions = {""delimiter"": ""-"", ""suffix"": "".raw"", ""schemasuffix"": "".json"", ""compression"": compression}\n    alloptions.update(options)\n    options = alloptions\n\n    class Wrap(object):\n        def __init__(self, f):\n            self.f = f\n        def __setitem__(self, where, what):\n            if isinstance(what, numpy.ndarray):\n                what = what.tostring()\n            self.f.writestr(where, what, compress_type=zipfile.ZIP_STORED)\n\n    with zipfile.ZipFile(file, mode=mode, compression=zipfile.ZIP_STORED) as f:\n        namelist = f.namelist()\n        for name in arraynames:\n            if any(n.startswith(name) for n in namelist):\n                raise KeyError(""cannot add {0} to zipfile because the following already exist: {1}"".format(repr(name), "", "".join(repr(n) for n in namelist if n.startswith(name))))\n\n        wrapped = Wrap(f)\n        for name, array in arrays.items():\n            serialize(array, wrapped, name=name, **options)\n\ndef load(file, **options):\n    f = Load(file, **options)\n    if list(f) == [""""]:\n        out = f[""""]\n        f.close()\n        return out\n    else:\n        return f\n\nclass Load(Mapping):\n    def __init__(self, file, **options):\n        class Wrap(object):\n            def __init__(self):\n                self.f = zipfile.ZipFile(file, mode=""r"")\n            def __getitem__(self, where):\n                return self.f.read(where)\n\n        self._file = Wrap()\n\n        alloptions = {""schemasuffix"": "".json"", ""awkwardlib"": ""awkward"", ""whitelist"": whitelist, ""cache"": None}\n        alloptions.update(options)\n        self.schemasuffix = alloptions.pop(""schemasuffix"")\n        self.options = alloptions\n\n    def __getitem__(self, where):\n        return deserialize(self._file, name=where + self.schemasuffix, awkwardlib=self.options[""awkwardlib""], whitelist=self.options[""whitelist""], cache=self.options[""cache""])\n\n    def __iter__(self):\n        for n in self._file.f.namelist():\n            if n.endswith("".json""):\n                yield n[:-5]\n\n    def __len__(self):\n        count = 0\n        for n in self._file.f.namelist():\n            if n.endswith("".json""):\n                count += 1\n        return count\n\n    def __repr__(self):\n        return ""<awkward.load ({0} members)>"".format(len(self))\n\n    def close(self):\n        self._file.f.close()\n\n    def __del__(self):\n        self.close()\n\n    def __enter__(self, *args, **kwds):\n        return self\n\n    def __exit__(self, *args, **kwds):\n        self.close()\n\nclass hdf5(MutableMapping):\n    def __init__(self, group, **options):\n        alloptions = {""compression"": compression, ""awkwardlib"": ""awkward"", ""whitelist"": whitelist, ""cache"": None}\n        alloptions.update(options)\n        self.options = alloptions\n        self.options[""delimiter""] = ""/""\n        self.options[""schemasuffix""] = ""/schema.json""\n\n        class Wrap(object):\n            def __init__(self):\n                self.g = group\n            def __getitem__(self, where):\n                return self.g[where][()]\n            def __setitem__(self, where, what):\n                self.g[where] = numpy.frombuffer(what, dtype=numpy.uint8)\n\n        self._group = Wrap()\n\n    def __getitem__(self, where):\n        return deserialize(self._group, name=where + self.options[""schemasuffix""], awkwardlib=self.options[""awkwardlib""], whitelist=self.options[""whitelist""], cache=self.options[""cache""])\n\n    def __setitem__(self, where, what):\n        options = dict(self.options)\n        if ""awkwardlib"" in options:\n            del options[""awkwardlib""]\n        if ""whitelist"" in options:\n            del options[""whitelist""]\n        if ""cache"" in options:\n            del options[""cache""]\n        self._group.g.create_group(where)\n        serialize(what, self._group, name=where, **options)\n\n    def __delitem__(self, where):\n        for subname in keys(self._group, name=where + self.options[""schemasuffix""]):\n            del self._group.g[subname]\n        del self._group.g[where]\n\n    def __iter__(self):\n        schemaname = self.options[""schemasuffix""].split(""/"")[-1]\n        for subname in self._group.g:\n            if schemaname in self._group.g[subname]:\n                yield subname\n\n    def __len__(self):\n        schemaname = self.options[""schemasuffix""].split(""/"")[-1]\n        count = 0\n        for subname in self._group.g:\n            if schemaname in self._group.g[subname]:\n                count += 1\n        return count\n\n    def __repr__(self):\n        return ""<awkward.hdf5 {0} ({1} members)>"".format(repr(self._group.g.name), len(self))\n'"
awkward/type.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport math\nimport numbers\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Mapping\nexcept ImportError:\n    from collections import Mapping\n\nimport numpy\n\nimport awkward.util\n\ndef _str(tpe, indent=""""):\n    if isinstance(tpe, Type):\n        return tpe.__str__(indent=indent)\n    else:\n        return indent + str(tpe)\n\nclass Type(object):\n    check = True\n\n    def hascolumn(self, name):\n        return self._hascolumn(name, set())\n\n    @property\n    def isnumpy(self):\n        return self._isnumpy(set())\n\n    def __or__(self, other):\n        out = UnionType.__new__(UnionType)\n\n        if isinstance(self, UnionType) and isinstance(other, UnionType):\n            out._possibilities = self._possibilities + other._possibilities\n        elif isinstance(self, UnionType):\n            out._possibilities = self._possibilities + [other]\n        elif isinstance(other, UnionType):\n            out._possibilities = [self] + other._possibilities\n        else:\n            out._possibilities = [self, other]\n\n        return out\n\n    def _labeled(self):\n        seen = set()\n        labeled = []\n        def find(x):\n            if isinstance(x, Type):\n                if id(x) not in seen:\n                    seen.add(id(x))\n                    if isinstance(x, ArrayType):\n                        find(x._to)\n                    elif isinstance(x, TableType):\n                        for y in x._fields.values():\n                            find(y)\n                    elif isinstance(x, UnionType):\n                        for y in x._possibilities:\n                            find(y)\n                    elif isinstance(x, OptionType):\n                        find(x._type)\n                else:\n                    labeled.append(x)\n        find(self)\n        return labeled\n\n    def __repr__(self):\n        return self._repr(self._labeled(), set())\n\n    def _repr(self, labeled, seen):\n        if id(self) in seen:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    return ""T{0}"".format(i)\n        else:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    out = ""T{0} := "".format(i)\n                    break\n            else:\n                out = """"\n            seen.add(id(self))\n            return out + self._subrepr(labeled, seen)\n\n    def __str__(self, indent=""""):\n        return self._str(self._labeled(), set(), indent)\n\n    def _str(self, labeled, seen, indent):\n        if id(self) in seen:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    return indent + ""T{0}"".format(i)\n            raise AssertionError(""{0} not in {1}"".format(id(self), seen))\n        else:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    out = indent + ""T{0} := "".format(i)\n                    break\n            else:\n                out = """"\n            seen.add(id(self))\n            return out + self._substr(labeled, seen, indent + ("" "" * len(out)))\n\n    @staticmethod\n    def _copy(x, seen):\n        if id(x) in seen:\n            return seen[id(x)]\n\n        elif isinstance(x, ArrayType):\n            seen[id(x)] = ArrayType.__new__(ArrayType)\n            seen[id(x)]._takes = x.takes\n            seen[id(x)]._to = Type._copy(x.to, seen)\n            return seen[id(x)]\n\n        elif isinstance(x, TableType):\n            seen[id(x)] = TableType.__new__(TableType)\n            seen[id(x)]._fields = OrderedDict()\n            for n, y in x._fields.items():\n                seen[id(x)]._fields[n] = Type._copy(y, seen)\n            return seen[id(x)]\n\n        elif isinstance(x, UnionType):\n            seen[id(x)] = UnionType.__new__(UnionType)\n            seen[id(x)]._possibilities = []\n            for y in x._possibilities:\n                seen[id(x)]._possibilities.append(Type._copy(y, seen))\n            return seen[id(x)]\n\n        elif isinstance(x, OptionType):\n            seen[id(x)] = OptionType.__new__(OptionType)\n            seen[id(x)]._type = Type._copy(x._type, seen)\n            return seen[id(x)]\n\n        else:\n            return x\n\n    @staticmethod\n    def _canonical(x, seen):\n        if id(x) not in seen:\n            # apply string-integer commutation so that TableTypes are nested as deeply as possible\n            if isinstance(x, TableType) and len(x._fields) > 0 and all(isinstance(y, ArrayType) for y in x._fields.values()):\n                newtable = TableType.__new__(TableType)\n                newtable._fields = OrderedDict()\n                first = None\n                for n, y in x._fields.items():\n                    if first is None:\n                        first = y._takes\n                    elif first != y._takes or math.isinf(y._takes):\n                        break\n                    newtable._fields[n] = y._to\n                else:\n                    x = ArrayType.__new__(ArrayType)\n                    x._takes = first\n                    x._to = newtable\n\n            # apply union(X, union(Y)) == union(X, Y)\n            if isinstance(x, UnionType) and any(isinstance(y, UnionType) for y in x._possibilities):\n                possibilities = []\n                for y in x._possibilities:\n                    if isinstance(y, UnionType):\n                        possibilities.extend(y._possibilities)\n                    else:\n                        possibilities.append(y)\n                x = UnionType.__new__(UnionType)\n                x._possibilities = possibilities\n\n            # apply optional(optional(X)) == optional(X)\n            if isinstance(x, OptionType) and isinstance(x._type, OptionType):\n                x = x._type\n\n            seen.add(id(x))\n            if isinstance(x, ArrayType):\n                x._to = Type._canonical(x._to, seen)\n            elif isinstance(x, TableType):\n                for n in x._fields:\n                    x._fields[n] = Type._canonical(x._fields[n], seen)\n            elif isinstance(x, UnionType):\n                for i in range(len(x._possibilities)):\n                    x._possibilities[i] = Type._canonical(x._possibilities[i], seen)\n            elif isinstance(x, OptionType):\n                x._type = Type._canonical(x._type, seen)\n\n        return x\n\n    def __eq__(self, other):\n        if not isinstance(other, Type):\n            return False\n        else:\n            one = Type._canonical(Type._copy(self, {}), set())\n            two = Type._canonical(Type._copy(other, {}), set())\n            return one._eq(two, set(), ignoremask=False)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    @staticmethod\n    def _eq2(one, two, seen, ignoremask=False):\n        if isinstance(one, Type):\n            return one._eq(two, seen, ignoremask=ignoremask)\n        elif one == two:\n            return True\n        elif callable(one) and callable(two):\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def _finaltype(x):\n        if isinstance(x, type) and issubclass(x, (numbers.Number, numpy.generic)):\n            return numpy.dtype(x)\n        elif isinstance(x, (awkward.util.unicode, bytes)):\n            return numpy.dtype(x)\n        else:\n            return x\n\nclass ArrayType(Type):\n    def __init__(self, *args):\n        if len(args) < 2:\n            raise ValueError(""type specification missing"")\n\n        elif isinstance(args[0], awkward.util.string):\n            self.__class__ = TableType\n            self._fields = OrderedDict()\n            if len(args) == 2:\n                self[args[0]] = args[1]\n            else:\n                self[args[0]] = ArrayType(*args[1:])\n\n        else:\n            self.takes = args[0]\n            if len(args) == 2:\n                self.to = args[1]\n            else:\n                self.to = ArrayType(*args[1:])\n\n    @property\n    def takes(self):\n        return self._takes\n\n    @takes.setter\n    def takes(self, value):\n        if value == numpy.inf or (isinstance(value, (numbers.Integral, numpy.integer)) and value >= 0):\n            self._takes = value\n        else:\n            raise ValueError(""{0} is not allowed in type specification"".format(value))\n\n    @property\n    def to(self):\n        return self._to\n\n    @to.setter\n    def to(self, value):\n        if isinstance(value, Type):\n            self._to = value\n        else:\n            self._to = self._finaltype(value)\n\n    @property\n    def shape(self):\n        if self._takes == numpy.inf:\n            return ()\n\n        elif isinstance(self._to, (Type, numpy.dtype)):\n            return (self._takes,) + self._to.shape\n\n        else:\n            return (self._takes,)\n\n    @property\n    def dtype(self):\n        if self._takes == numpy.inf:\n            return numpy.dtype(object)\n\n        elif isinstance(self._to, Type):\n            return self._to.dtype\n\n        elif isinstance(self._to, numpy.dtype):\n            if self._to.subdtype is None:\n                return self._to\n            else:\n                return self._to.subdtype[0]\n\n        else:\n            return numpy.dtype(object)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if self._takes == numpy.inf:\n            return False\n        elif isinstance(self._to, numpy.dtype):\n            return True\n        else:\n            return self._to._isnumpy(seen)\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if isinstance(self._to, numpy.dtype) and self._to.names is None:\n            return False\n        elif isinstance(self._to, numpy.dtype):\n            return name in self._to.names\n        elif isinstance(self._to, Type):\n            return self._to._hascolumn(name, seen)\n        else:\n            return False\n\n    def _subrepr(self, labeled, seen):\n        if isinstance(self._to, Type):\n            to = self._to._repr(labeled, seen)\n            if to.startswith(""ArrayType("") and to.endswith("")""):\n                to = to[10:-1]\n            return ""ArrayType({0}, {1})"".format(repr(self._takes), to)\n        else:\n            return ""ArrayType({0}, {1})"".format(repr(self._takes), repr(self._to))\n\n    def _substr(self, labeled, seen, indent):\n        takes = ""[0, {0}) -> "".format(self._takes)\n        if isinstance(self._to, Type):\n            to = self._to._str(labeled, seen, indent + ("" "" * len(takes))).lstrip("" "")\n        else:\n            to = str(self._to)\n        return takes + to\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, ArrayType) and self._takes == other._takes:\n                return self._eq2(self._to, other._to, seen, ignoremask=ignoremask)\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((ArrayType, self._takes, self._to))\n\nclass TableType(Type):\n    def __init__(self, **fields):\n        self._fields = OrderedDict()\n        for n, x in fields.items():\n            self._fields[n] = x\n\n    @property\n    def shape(self):\n        return ()\n\n    @property\n    def dtype(self):\n        out = []\n        for n, x in self._fields.items():\n            if x.shape != ():\n                raise TypeError(""Table with non-primitive fields has no Numpy dtype"")\n            elif isinstance(x, numpy.dtype):\n                out.append((n, x))\n            else:\n                out.append((n, x.dtype))\n        return numpy.dtype(out)\n\n    @property\n    def columns(self):\n        return list(self._fields)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        for x in self._fields.values():\n            if isinstance(x, numpy.dtype):\n                return True\n            elif not isinstance(x, OptionType) and x._isnumpy(seen):\n                return x.shape != ()\n            else:\n                return False\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        return name in self._fields\n\n    def __getitem__(self, key):\n        return self._fields[key]\n\n    def __setitem__(self, key, value):\n        if isinstance(value, Type):\n            self._fields[key] = value\n        else:\n            self._fields[key] = self._finaltype(value)\n\n    def __delitem__(self, key):\n        del self._fields[key]\n\n    def __and__(self, other):\n        out = TableType.__new__(TableType)\n        out._fields = OrderedDict(list(self._fields.items()) + list(other._fields.items()))\n        return out\n\n    def _subrepr(self, labeled, seen):\n        return ""TableType({0})"".format("", "".join(""{0}={1}"".format(n, x._repr(labeled, seen) if isinstance(x, Type) else repr(x)) for n, x in self._fields.items()))\n\n    def _substr(self, labeled, seen, indent):\n        width = max(len(repr(n)) for n in self._fields.keys())\n        subindent = indent + ("" "" * width) + ""    ""\n        out = []\n        for n, x in self._fields.items():\n            if isinstance(x, Type):\n                to = x._str(labeled, seen, subindent).lstrip("" "")\n            else:\n                to = str(x)\n            out.append((""{0}{1:%ds} -> {2}"" % width).format(indent, repr(n), to))\n        return ""\\n"".join(out).lstrip("" "")\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, TableType) and sorted(self._fields) == sorted(other._fields):\n                for n in self._fields:\n                    if not self._eq2(self._fields[n], other._fields[n], seen, ignoremask=ignoremask):\n                        return False\n                else:\n                    return True    # nothing failed in the loop over fields\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((TableType, tuple((n, self._fields[n]) for n in sorted(self._fields))))\n\nclass UnionType(Type):\n    def __init__(self, *possibilities):\n        self._possibilities = []\n        for x in possibilities:\n            self.append(x)\n\n    @property\n    def shape(self):\n        raise TypeError(""Union has no Numpy dtype"")\n\n    @property\n    def dtype(self):\n        raise TypeError(""Union has no Numpy dtype"")\n\n    def _isnumpy(self, seen):\n        return False\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        for x in self._possibilities:\n            if isinstance(x, numpy.dtype) and x.names is not None and name in x.names:\n                return True\n            elif isinstance(x, Type) and x._hascolumn(name, seen):\n                return True\n        else:\n            return False\n\n    def __len__(self):\n        return len(self._possibilities)\n\n    def __getitem__(self, index):\n        return self._possibilities[index]\n\n    def __setitem__(self, index, value):\n        if isinstance(value, Type):\n            self._possibilities[index] = value\n        else:\n            self._possibilities[index] = self._finaltype(value)\n\n    def __delitem__(self, index):\n        del self._possibilities[index]\n\n    def append(self, value):\n        if isinstance(value, Type):\n            self._possibilities.append(value)\n        else:\n            self._possibilities.append(self._finaltype(value))\n\n    def _subrepr(self, labeled, seen):\n        return ""UnionType({0})"".format("", "".join(x._repr(labeled, seen) if isinstance(x, Type) else repr(x) for x in self._possibilities))\n\n    def _substr(self, labeled, seen, indent):\n        subs = [x._str(labeled, seen, indent + "" "") if isinstance(x, Type) else str(x) for x in self._possibilities]\n        def lstrip(x):\n            if x.startswith(indent + "" ""):\n                return x[len(indent) + 1:]\n            else:\n                return x\n        width = max(len(lstrip(y)) for x in subs for y in x.split(""\\n""))\n        out = [x + "" "" * (width - len(lstrip(x.split(""\\n"")[-1]))) for x in subs]\n        return ""("" + ("" |\\n"" + indent + "" "").join(out) + "" )""\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, UnionType) and len(self._possibilities) == len(other._possibilities):\n                for x, y in zip(sorted(self._possibilities), sorted(self._possibilities)):\n                    if not self._eq2(x, y, seen, ignoremask=ignoremask):\n                        return False\n                else:\n                    return True    # nothing failed in the loop over possibilities\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((UnionType, tuple(self._possibilities)))\n\nclass OptionType(Type):\n    def __init__(self, type):\n        self.type = type\n\n    @property\n    def type(self):\n        return self._type\n\n    @type.setter\n    def type(self, value):\n        if isinstance(value, Type):\n            self._type = value\n        else:\n            self._type = self._finaltype(value)\n\n    @property\n    def shape(self):\n        if isinstance(self._type, (Type, numpy.dtype)):\n            return self._type.shape\n        else:\n            return ()\n\n    @property\n    def dtype(self):\n        if isinstance(self._type, Type):\n            return self._type.dtype\n\n        elif isinstance(self._type, numpy.dtype):\n            if self._type.subdtype is None:\n                return self._type\n            else:\n                return self._type.subdtype[0]\n\n        else:\n            return numpy.dtype(object)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if isinstance(self._type, numpy.dtype):\n            return True\n        else:\n            return self._type._isnumpy(seen)\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        return self._type._hascolumn(name, seen)\n\n    def _subrepr(self, labeled, seen):\n        return ""OptionType({0})"".format(self._type._repr(labeled, seen) if isinstance(self._type, Type) else repr(self._type))\n\n    def _substr(self, labeled, seen, indent):\n        if isinstance(self._type, Type):\n            type = self._type._str(labeled, seen, indent + ""  "").lstrip("" "")\n        else:\n            type = str(self._type)\n        return ""?({0})"".format(type)\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, OptionType):\n                if self._eq2(self._type, other._type, seen, ignoremask=ignoremask):\n                    return True\n            if ignoremask:    # applied asymmetrically; only the left can ignore mask\n                return self._eq2(self._type, other, seen, ignoremask=ignoremask)\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((OptionType, self._type))\n\n###############################################################################\n\ndef fromnumpy(shape, dtype, masked=False):\n    if not isinstance(shape, tuple):\n        shape = (shape,)\n    if not isinstance(dtype, numpy.dtype):\n        dtype = numpy.dtype(dtype)\n\n    if masked:\n        return OptionType(fromnumpy(shape, dtype))\n    elif dtype.subdtype is not None:\n        dt, sh = dtype.subdtype\n        return fromnumpy(shape + sh, dt)\n    else:\n        return ArrayType(*(shape + (dtype,)))\n\ndef fromarray(array):\n    return ArrayType(len(array), _resolve(_fromarray(array, {}), {}))\n\ndef _fromarray(array, seen):\n    if id(array) not in seen:\n        seen[id(array)] = placeholder = Placeholder()\n\n        if isinstance(array, numpy.ndarray):\n            if array.dtype.names is None:\n                out = array.dtype\n\n            else:\n                out = TableType.__new__(TableType)\n                out._fields = OrderedDict()\n                for n in array.dtype.names:\n                    out[n] = array.dtype[n]\n\n            for x in array.shape[:0:-1]:\n                out = ArrayType(x, out)\n            if isinstance(array, numpy.ma.MaskedArray):\n                out = OptionType(out)\n\n            placeholder.value = out\n\n        else:\n            placeholder.value = array._gettype(seen)\n\n    return seen[id(array)]\n\nclass Placeholder(Type):\n    def __init__(self, value=None):\n        self.value = value\n\n    def _subrepr(self, labeled, seen):\n        return ""Placeholder({0})"".format(self.value._repr(labeled, seen) if isinstance(self.value, Type) else repr(self.value))\n\ndef _resolve(tpe, seen):\n    while isinstance(tpe, Placeholder):\n        tpe = tpe.value\n\n    assert tpe is not None\n\n    if id(tpe) not in seen:\n        if isinstance(tpe, ArrayType):\n            seen[id(tpe)] = ArrayType.__new__(ArrayType)\n            seen[id(tpe)]._takes = tpe.takes\n            seen[id(tpe)]._to = _resolve(tpe._to, seen)\n\n        elif isinstance(tpe, TableType):\n            seen[id(tpe)] = TableType.__new__(TableType)\n            seen[id(tpe)]._fields = OrderedDict()\n            for n, y in tpe._fields.items():\n                seen[id(tpe)]._fields[n] = _resolve(y, seen)\n\n        elif isinstance(tpe, UnionType):\n            seen[id(tpe)] = UnionType.__new__(UnionType)\n            seen[id(tpe)]._possibilities = []\n            for y in tpe._possibilities:\n                seen[id(tpe)]._possibilities.append(_resolve(y, seen))\n\n        elif isinstance(tpe, OptionType):\n            seen[id(tpe)] = OptionType.__new__(OptionType)\n            seen[id(tpe)]._type = _resolve(tpe._type, seen)\n\n        else:\n            seen[id(tpe)] = tpe\n\n    return seen[id(tpe)]\n\n###############################################################################\n\nclass Layout(Mapping):\n    def __init__(self, array):\n        self.lookup = {}\n        self.top = LayoutNode(array, Position(), {}, self.lookup)\n\n    @staticmethod\n    def keystr(x):\n        return ""()"" if len(x) == 0 else "", "".join(repr(i) for i in x)\n\n    @staticmethod\n    def valstr(x):\n        if isinstance(x, Position):\n            return ""layout["" + (""()"" if len(x) == 0 else "", "".join(repr(i) for i in x)) + ""]""\n        elif isinstance(x, type):\n            return x.__name__\n        else:\n            return str(x)\n\n    def __repr__(self):\n        out = ["" layout ""]\n        longest = max(6, max([len(self.keystr(i)) for i in self.lookup]))\n        for i in sorted(self.lookup):\n            x = self.lookup[i]\n            indent = ""  "" * len(i)\n            if x.args is None:\n                out.append((""[{0:>%ds}] {1}-> {2}"" % longest).format(self.keystr(i), indent, self.valstr(x.cls)))\n            else:\n                out.append((""[{0:>%ds}] {1}{2}({3})"" % longest).format(self.keystr(i), indent, self.valstr(x.cls), "", "".join(str(y) for y in x.args)))\n        return ""\\n"".join(out)\n\n    def __iter__(self):\n        return (i for i in sorted(self.lookup))\n\n    def __getitem__(self, where):\n        if not isinstance(where, tuple):\n            where = (where,)\n        return self.lookup[where]\n\n    def __len__(self):\n        return len(self.lookup)\n\nclass LayoutNode(object):\n    def __init__(self, array, position, seen, lookup):\n        import awkward.array.base\n        self.array = array\n        self.position = position\n        lookup[position] = self\n        self.args = None\n        if id(array) in seen:\n            self.cls = seen[id(array)]\n        else:\n            self.cls = type(array)\n            seen[id(array)] = position\n            if isinstance(array, awkward.array.base.AwkwardArray):\n                self.args = array._util_layout(position, seen, lookup)\n            else:\n                self.args = (LayoutArg(""shape"", array.shape), LayoutArg(""dtype"", array.dtype))\n\n    def __repr__(self):\n        if self.args is None:\n            return ""<LayoutNode [{0}] -> {1}>"".format(Layout.keystr(self.position), Layout.valstr(self.cls))\n        return ""<LayoutNode [{0}] {1}>"".format(self.position, self.cls.__name__)\n\nclass Position(tuple):\n    def __add__(self, other):\n        return Position(super(Position, self).__add__(other))\n\nclass LayoutArg(object):\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __repr__(self):\n        return ""LayoutArg({0}, {1})"".format(repr(self.name), repr(self.value))\n\n    def __str__(self):\n        if isinstance(self.value, list):\n            return self.name + ""=["" + "", "".join(Layout.valstr(x) for x in self.value) + ""]""\n        elif self.name == ""shape"":\n            return ""shape={0}"".format(self.value[0] if len(self.value) == 1 else self.value)\n        elif self.name == ""dtype"":\n            return ""dtype={0}"".format(repr(self.value))\n        else:\n            return ""{0}={1}"".format(str(self.name), Layout.valstr(self.value))\n'"
awkward/util.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport itertools\nimport importlib\nimport sys\nimport os\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nfrom functools import wraps\n\nimport numpy\n\nif sys.version_info[0] <= 2:\n    izip = itertools.izip\n    string = basestring\n    unicode = unicode\nelse:\n    izip = zip\n    string = str\n    unicode = str\n\nfrombuffer = numpy.frombuffer\n\ndef toarray(value, defaultdtype, passthrough=None):\n    import awkward.array.base\n    return awkward.array.base.AwkwardArray._util_toarray(value, defaultdtype, passthrough=passthrough)\n\ndef awkwardlib(awkwardlib):\n    if awkwardlib is None:\n        import awkward\n        return awkward\n    elif isinstance(awkwardlib, str):\n        return importlib.import_module(awkwardlib)\n    else:\n        return awkwardlib\n\nclass bothmethod(object):\n    def __init__(self, fcn):\n        self.fcn = fcn\n    def __get__(self, ins, typ):\n        if ins is None:\n            return lambda *args, **kwargs: self.fcn(True, typ, *args, **kwargs)\n        else:\n            return lambda *args, **kwargs: self.fcn(False, ins, *args, **kwargs)\n\n# numpy on windows has some strange behavior with dtypes of certain functions\n# requiring us to cast down to int32 for (at least): ufunc.reduceat, repeat\ndef windows_safe(array):\n    if os.name == ""nt"":\n        return array.astype(numpy.int32)\n    return array\n\n################################################################ wrappers (used to be in uproot-methods)\n\ndef _normalize_arrays(cls, arrays):\n    length = None\n    for i in range(len(arrays)):\n        if isinstance(arrays[i], Iterable):\n            if length is None:\n                length = len(arrays[i])\n                break\n    if length is None:\n        raise TypeError(""cannot construct an array if all arguments are scalar"")\n\n    arrays = list(arrays)\n    jaggedtype = [cls.awkward.JaggedArray] * len(arrays)\n    starts, stops = None, None\n    for i in range(len(arrays)):\n        if starts is None and isinstance(arrays[i], cls.awkward.JaggedArray):\n            starts, stops = arrays[i].starts, arrays[i].stops\n\n        if isinstance(arrays[i], cls.awkward.JaggedArray):\n            jaggedtype[i] = type(arrays[i])\n\n        if not isinstance(arrays[i], Iterable):\n            arrays[i] = cls.awkward.numpy.full(length, arrays[i])\n\n        arrays[i] = cls.awkward.util.toarray(arrays[i], cls.awkward.numpy.float64)\n\n    if starts is None:\n        return arrays\n\n    for i in range(len(arrays)):\n        if not isinstance(arrays[i], cls.awkward.JaggedArray) or not (cls.awkward.numpy.array_equal(starts, arrays[i].starts) and cls.awkward.numpy.array_equal(stops, arrays[i].stops)):\n            content = cls.awkward.numpy.zeros(stops.max(), dtype=cls.awkward.numpy.float64)\n            arrays[i] = jaggedtype[i](starts, stops, content) + arrays[i]    # invoke jagged broadcasting to align arrays\n\n    return arrays\n\ndef unwrap_jagged(cls, awkcls, arrays):\n    if not isinstance(arrays[0], cls.awkward.JaggedArray):\n        return lambda x: x, arrays\n\n    counts = arrays[0].counts.reshape(-1)\n    offsets = awkcls.counts2offsets(counts)\n    starts, stops = offsets[:-1], offsets[1:]\n    starts = starts.reshape(arrays[0].starts.shape[:-1] + (-1,))\n    stops = stops.reshape(arrays[0].stops.shape[:-1] + (-1,))\n    wrap, arrays = unwrap_jagged(cls, awkcls, [x.flatten() for x in arrays])\n    return lambda x: awkcls(starts, stops, wrap(x)), arrays\n\ndef wrapjaggedmethod(awkcls):\n    def wrapjagged_decorator(func):\n        @wraps(func)\n        def func_wrapper(cls, *arrays):\n            wrap, arrays = unwrap_jagged(cls, awkcls, _normalize_arrays(cls, arrays))\n            return wrap(func(cls, *arrays))\n        return func_wrapper\n    return wrapjagged_decorator\n\n################################################################ array helpers\n\ntry:\n    NDArrayOperatorsMixin = numpy.lib.mixins.NDArrayOperatorsMixin\n\nexcept AttributeError:\n    from numpy.core import umath as um\n\n    def _disables_array_ufunc(obj):\n        """"""True when __array_ufunc__ is set to None.""""""\n        try:\n            return obj.__array_ufunc__ is None\n        except AttributeError:\n            return False\n\n    def _binary_method(ufunc, name):\n        """"""Implement a forward binary method with a ufunc, e.g., __add__.""""""\n        def func(self, other):\n            if _disables_array_ufunc(other):\n                return NotImplemented\n            return ufunc(self, other)\n        func.__name__ = \'__{}__\'.format(name)\n        return func\n\n    def _reflected_binary_method(ufunc, name):\n        """"""Implement a reflected binary method with a ufunc, e.g., __radd__.""""""\n        def func(self, other):\n            if _disables_array_ufunc(other):\n                return NotImplemented\n            return ufunc(other, self)\n        func.__name__ = \'__r{}__\'.format(name)\n        return func\n\n    def _inplace_binary_method(ufunc, name):\n        """"""Implement an in-place binary method with a ufunc, e.g., __iadd__.""""""\n        def func(self, other):\n            return ufunc(self, other, out=(self,))\n        func.__name__ = \'__i{}__\'.format(name)\n        return func\n\n    def _numeric_methods(ufunc, name):\n        """"""Implement forward, reflected and inplace binary methods with a ufunc.""""""\n        return (_binary_method(ufunc, name),\n                _reflected_binary_method(ufunc, name),\n                _inplace_binary_method(ufunc, name))\n\n    def _unary_method(ufunc, name):\n        """"""Implement a unary special method with a ufunc.""""""\n        def func(self):\n            return ufunc(self)\n        func.__name__ = \'__{}__\'.format(name)\n        return func\n\n    class NDArrayOperatorsMixin(object):\n        __lt__ = _binary_method(um.less, \'lt\')\n        __le__ = _binary_method(um.less_equal, \'le\')\n        __eq__ = _binary_method(um.equal, \'eq\')\n        __ne__ = _binary_method(um.not_equal, \'ne\')\n        __gt__ = _binary_method(um.greater, \'gt\')\n        __ge__ = _binary_method(um.greater_equal, \'ge\')\n\n        # numeric methods\n        __add__, __radd__, __iadd__ = _numeric_methods(um.add, \'add\')\n        __sub__, __rsub__, __isub__ = _numeric_methods(um.subtract, \'sub\')\n        __mul__, __rmul__, __imul__ = _numeric_methods(um.multiply, \'mul\')\n        if sys.version_info.major < 3:\n            # Python 3 uses only __truediv__ and __floordiv__\n            __div__, __rdiv__, __idiv__ = _numeric_methods(um.divide, \'div\')\n        __truediv__, __rtruediv__, __itruediv__ = _numeric_methods(\n            um.true_divide, \'truediv\')\n        __floordiv__, __rfloordiv__, __ifloordiv__ = _numeric_methods(\n            um.floor_divide, \'floordiv\')\n        __mod__, __rmod__, __imod__ = _numeric_methods(um.remainder, \'mod\')\n        if hasattr(um, ""divmod""):\n            __divmod__ = _binary_method(um.divmod, \'divmod\')\n            __rdivmod__ = _reflected_binary_method(um.divmod, \'divmod\')\n        # __idivmod__ does not exist\n        # TODO: handle the optional third argument for __pow__?\n        __pow__, __rpow__, __ipow__ = _numeric_methods(um.power, \'pow\')\n        __lshift__, __rlshift__, __ilshift__ = _numeric_methods(\n            um.left_shift, \'lshift\')\n        __rshift__, __rrshift__, __irshift__ = _numeric_methods(\n            um.right_shift, \'rshift\')\n        __and__, __rand__, __iand__ = _numeric_methods(um.bitwise_and, \'and\')\n        __xor__, __rxor__, __ixor__ = _numeric_methods(um.bitwise_xor, \'xor\')\n        __or__, __ror__, __ior__ = _numeric_methods(um.bitwise_or, \'or\')\n\n        # unary methods\n        __neg__ = _unary_method(um.negative, \'neg\')\n        if hasattr(um, ""positive""):\n            __pos__ = _unary_method(um.positive, \'pos\')\n            __abs__ = _unary_method(um.absolute, \'abs\')\n            __invert__ = _unary_method(um.invert, \'invert\')\n\n################################################################ conversion of arrays to Pandas\n\ndef topandas(array, flatten=False):\n    import pandas\n    import awkward.array.base\n\n    if isinstance(array, awkward.array.base.AwkwardArray):\n        if flatten:\n            return topandas_flatten(array)\n        else:\n            out = array._topandas({})\n            if len(out.columns) == 0:\n                return pandas.Series(out)\n            else:\n                return pandas.DataFrame({n: out[n] for n in out.columns}, columns=out.columns)\n    else:\n        out = numpy.array(array, copy=False)\n        if out.dtype.fields is None:\n            return pandas.Series(out)\n        else:\n            return pandas.DataFrame(out)\n\ndef topandas_flatten(array):\n    import numpy\n    import pandas\n\n    import awkward.array.base\n    import awkward.array.chunked\n    import awkward.array.jagged\n    import awkward.array.objects\n    import awkward.array.table\n    import awkward.array.virtual\n    import awkward.type\n\n    if isinstance(array, awkward.array.base.AwkwardArray):\n        numpy = array.numpy\n        JaggedArray = array.JaggedArray\n        Table = array.Table\n    else:\n        JaggedArray = awkward.array.jagged.JaggedArray\n        Table = awkward.array.table.Table\n\n    def unwrap(a):\n        if isinstance(a, awkward.array.chunked.ChunkedArray):\n            chunks = [unwrap(x) for x in a.chunks]\n            if any(isinstance(x, awkward.array.jagged.JaggedArray) for x in chunks):\n                return awkward.array.jagged.JaggedArray.concatenate(chunks)\n            else:\n                return numpy.concatenate([x.regular() for x in chunks])\n        elif isinstance(a, awkward.array.virtual.VirtualArray):\n            return a.array\n        else:\n            return a\n\n    globalindex = [None]\n    localindex = []\n    columns = []\n    def recurse(array, tpe, cols, seriously):\n        if isinstance(tpe, awkward.type.TableType):\n            starts, stops = None, None\n            out, deferred, unflattened = None, {}, None\n\n            for n in tpe.columns:\n                if not isinstance(n, str):\n                    raise ValueError(""column names must be strings"")\n\n                arrayn = unwrap(array[n])\n                tpen = tpe[n]\n                colsn = cols + (n,) if seriously else cols\n\n                if isinstance(arrayn, awkward.array.objects.ObjectArray) and not isinstance(arrayn, awkward.array.objects.StringArray):\n                    arrayn = arrayn.content\n                if not isinstance(tpen, (numpy.dtype, str, bytes, awkward.type.Type)):\n                    tpen = awkward.type.fromarray(arrayn).to\n                if isinstance(tpen, numpy.dtype):\n                    columns.append(colsn)\n                    tmp = arrayn\n\n                elif isinstance(tpen, type) and issubclass(tpen, (str, bytes)):\n                    columns.append(colsn)\n                    tmp = arrayn\n\n                elif isinstance(tpen, awkward.type.ArrayType) and tpen.takes == numpy.inf:\n                    tmp = JaggedArray(arrayn.starts, arrayn.stops, recurse(arrayn.content, tpen.to, colsn, True))\n\n                elif isinstance(tpen, awkward.type.TableType):\n                    tmp = recurse(arrayn, tpen, colsn, True)\n\n                elif isinstance(tpen, awkward.type.OptionType) and isinstance(arrayn.content, numpy.ndarray):\n                    columns.append(colsn)\n                    tmp = numpy.ma.MaskedArray(arrayn.content, arrayn.boolmask(maskedwhen=True))\n\n                else:\n                    raise ValueError(""this array has unflattenable substructure:\\n\\n{0}"".format(str(tpen)))\n\n                if isinstance(tmp, awkward.array.jagged.JaggedArray):\n                    if isinstance(tmp.content, awkward.array.jagged.JaggedArray):\n                        unflattened = tmp\n                        tmp = tmp.flatten(axis=1)\n\n                    if starts is None:\n                        starts, stops = tmp.starts, tmp.stops\n                    elif not numpy.array_equal(starts, tmp.starts) or not numpy.array_equal(stops, tmp.stops):\n                        raise ValueError(""this array has more than one jagged array structure"")\n                    if out is None:\n                        out = JaggedArray(starts, stops, Table({n: tmp.content}))\n                    else:\n                        out[n] = tmp\n\n                else:\n                    deferred[n] = tmp\n\n            if out is None:\n                out = Table()\n\n            for n, x in deferred.items():\n                out[n] = x\n\n            m = """"\n            while m in tpe.columns:\n                m = m + "" ""\n            out[m] = numpy.arange(len(out))\n            globalindex[0] = out[m].flatten()\n\n            for n in tpe.columns:\n                arrayn = unwrap(array[n])\n                if isinstance(arrayn, awkward.array.jagged.JaggedArray):\n                    if unflattened is None:\n                        localindex.insert(0, out[n].localindex.flatten())\n                    else:\n                        oldloc = unflattened.content.localindex\n                        tab = JaggedArray(oldloc.starts, oldloc.stops, Table({""oldloc"": oldloc.content}))\n                        tab[""newloc""] = arrayn.localindex.flatten()\n                        localindex.insert(0, tab[""newloc""].flatten())\n                    break\n\n            return out[tpe.columns]\n\n        else:\n            return recurse(Table({"""": array}), awkward.type.TableType(**{"""": tpe}), cols, False)[""""]\n\n    tmp = recurse(array, awkward.type.fromarray(array).to, (), True)\n    if isinstance(tmp, awkward.array.jagged.JaggedArray):\n        tmp = tmp.flatten()\n\n    deepest = max(len(x) for x in columns)\n\n    out = {}\n    for i, col in enumerate(columns):\n        x = tmp\n        for c in col:\n            x = x[c]\n        columns[i] = col + ("""",) * (deepest - len(col))\n        out[columns[i]] = x\n\n    index = globalindex + localindex\n    if len(index) == 1:\n        index = pandas.Index(index[0])\n    else:\n        index = pandas.MultiIndex.from_arrays(index)\n\n    if len(columns) == 1 and deepest == 0:\n        return pandas.Series(out[()], index=index)\n    else:\n        return pandas.DataFrame(data=out, index=index, columns=pandas.MultiIndex.from_tuples(columns))\n'"
awkward/version.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport re\n\n__version__ = ""0.12.21""\nversion = __version__\nversion_info = tuple(re.split(r""[-\\.]"", __version__))\n\ndel re\n'"
docs/frontpage-source.py,0,"b'# %%markdown\n# # Introduction\n#\n# Numpy is great for exploratory data analysis because it encourages the analyst to calculate one operation at a time, rather than one datum at a time. To compute an expression like\n#\n# .. math::\n#\n#     m = \\\\sqrt{(E_1 + E_2)^2 - (p_{x1} + p_{x2})^2 - (p_{y1} + p_{y2})^2 - (p_{z1} + p_{z2})^2}\n#\n# you might first compute :math:`\\\\sqrt{(p_{x1} + p_{x2})^2 + (p_{y1} + p_{y2})^2}` for all data (which is a meaningful quantity: :math:`p_T`), then compute :math:`\\\\sqrt{{p_T}^2 + (p_{z1} + p_{z2})^2}` for all data (another meaningful quantity: :math:`|p|`), then compute the whole expression as :math:`\\\\sqrt{(E_1 + E_2)^2 - |p|^2}`. Performing each step separately on all data lets you plot and cross-check distributions of partial computations, to discover surprises as early as possible.\n#\n# This order of data processing is called ""columnar"" in the sense that a dataset may be visualized as a table in which rows are repeated measurements and columns are the different measurable quantities (same layout as `Pandas DataFrames <https://pandas.pydata.org>`__). It is also called ""vectorized"" in that a Single (virtual) Instruction is applied to Multiple Data (virtual SIMD). Numpy can be hundreds to thousands of times faster than pure Python because it avoids the overhead of handling Python instructions in the loop over numbers. Most data processing languages (R, MATLAB, IDL, all the way back to APL) work this way: an interactive interpreter controlling fast, array-at-a-time math.\n#\n# However, it\'s difficult to apply this methodology to non-rectangular data. If your dataset has nested structure, a different number of values per row, different data types in the same column, or cross-references or even circular references, Numpy can\'t help you.\n#\n# If you try to make an array with non-trivial types:\n\n# %%\nimport numpy\nnested = numpy.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}])\nnested\n# array([{\'x\': 1, \'y\': 1.1}, {\'x\': 2, \'y\': 2.2}, {\'x\': 3, \'y\': 3.3},\n#        {\'x\': 4, \'y\': 4.4}, {\'x\': 5, \'y\': 5.5}], dtype=object)\n\n# %%markdown\n# Numpy gives up and returns a ``dtype=object`` array, which means Python objects and pure Python processing. You don\'t get the columnar operations or the performance boost.\n#\n# For instance, you might want to say\n\n# %%\ntry:\n    nested + 100\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'TypeError\'> unsupported operand type(s) for +: \'dict\' and \'int\'\n\n# %%markdown\n# but there is no vectorized addition for an array of dicts because there is no addition for dicts defined in pure Python. Numpy is not using its vectorized routines\xe2\x80\x94it\'s calling Python code on each element.\n#\n# The same applies to variable-length data, such as lists of lists, where the inner lists have different lengths. This is a more serious shortcoming than the above because the list of dicts (Python\'s equivalent of an ""`array of structs <https://en.wikipedia.org/wiki/AOS_and_SOA>`__`"") could be manually reorganized into two numerical arrays, ``""x""`` and ``""y""`` (a ""`struct of arrays <https://en.wikipedia.org/wiki/AOS_and_SOA>`__""). Not so with a list of variable-length lists.\n\n# %%\nvarlen = numpy.array([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6], [7.7, 8.8, 9.9]])\nvarlen\n# array([list([1.1, 2.2, 3.3]), list([]), list([4.4, 5.5]), list([6.6]),\n#        list([7.7, 8.8, 9.9])], dtype=object)\n\n# %%markdown\n# As before, we get a ``dtype=object`` without vectorized methods.\n\n# %%\ntry:\n    varlen + 100\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'TypeError\'> can only concatenate list (not ""int"") to list\n\n# %%markdown\n# What\'s worse, this array looks purely numerical and could have been made by a process that was *supposed* to create equal-length inner lists.\n#\n# Awkward-array provides a way of talking about these data structures as arrays.\n\n# %%\nimport awkward\nnested = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}])\nnested\n# <Table [<Row 0> <Row 1> <Row 2> <Row 3> <Row 4>] at 0x7f25e80a01d0>\n\n# %%markdown\n# This ``Table`` is a columnar data structure with the same meaning as the Python data we built it with. To undo ``awkward.fromiter``, call ``.tolist()``.\n\n# %%\nnested.tolist()\n# [{\'x\': 1, \'y\': 1.1},\n#  {\'x\': 2, \'y\': 2.2},\n#  {\'x\': 3, \'y\': 3.3},\n#  {\'x\': 4, \'y\': 4.4},\n#  {\'x\': 5, \'y\': 5.5}]\n\n# %%markdown\n# Values at the same position of the tree structure are contiguous in memory: this is a struct of arrays.\n\n# %%\nnested.contents[""x""]\n# array([1, 2, 3, 4, 5])\n\n# %%\nnested.contents[""y""]\n# array([1.1, 2.2, 3.3, 4.4, 5.5])\n\n# %%markdown\n# Having a structure like this means that we can perform vectorized operations on the whole structure with relatively few Python instructions (number of Python instructions scales with the complexity of the data type, not with the number of values in the dataset).\n\n# %%\n(nested + 100).tolist()\n# [{\'x\': 101, \'y\': 101.1},\n#  {\'x\': 102, \'y\': 102.2},\n#  {\'x\': 103, \'y\': 103.3},\n#  {\'x\': 104, \'y\': 104.4},\n#  {\'x\': 105, \'y\': 105.5}]\n\n# %%\n(nested + numpy.arange(100, 600, 100)).tolist()\n# [{\'x\': 101, \'y\': 101.1},\n#  {\'x\': 202, \'y\': 202.2},\n#  {\'x\': 303, \'y\': 303.3},\n#  {\'x\': 404, \'y\': 404.4},\n#  {\'x\': 505, \'y\': 505.5}]\n\n# %%markdown\n# It\'s less obvious that variable-length data can be represented in a columnar format, but it can.\n\n# %%\nvarlen = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6], [7.7, 8.8, 9.9]])\nvarlen\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5] [6.6] [7.7 8.8 9.9]] at 0x7f25bc7b1438>\n\n# %%markdown\n# Unlike Numpy\'s ``dtype=object`` array, the inner lists are *not* Python lists and the numerical values *are* contiguous in memory. This is made possible by representing the structure (where each inner list starts and stops) in one array and the values in another.\n\n# %%\nvarlen.counts, varlen.content\n# (array([3, 0, 2, 1, 3]), array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n\n# %%markdown\n# (For fast random access, the more basic representation is ``varlen.offsets``, which is in turn a special case of a ``varlen.starts, varlen.stops`` pair. These details are discussed below.)\n#\n# A structure like this can be broadcast like Numpy with a small number of Python instructions (scales with the complexity of the data type, not the number of values).\n\n# %%\nvarlen + 100\n# <JaggedArray [[101.1 102.2 103.3] [] [104.4 105.5] [106.6] [107.7 108.8 109.9]] at 0x7f25bc7b1400>\n\n# %%\nvarlen + numpy.arange(100, 600, 100)\n# <JaggedArray [[101.1 102.2 103.3] [] [304.4 305.5] [406.6] [507.7 508.8 509.9]] at 0x7f25bc7b1da0>\n\n# %%markdown\n# You can even slice this object as though it were multidimensional (each element is a tensor of the same rank, but with different numbers of dimensions).\n\n# %%\n# Skip the first two inner lists; skip the last value in each inner list that remains.\nvarlen[2:, :-1]\n# <JaggedArray [[4.4] [] [7.7 8.8]] at 0x7f25bc755588>\n\n# %%markdown\n# The data are not rectangular, so some inner lists might have as many elements as your selection. Don\'t worry\xe2\x80\x94you\'ll get error messages.\n\n# %%\ntry:\n    varlen[:, 1]\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'IndexError\'> index 1 is out of bounds for jagged min size 0\n\n# %%markdown\n# Masking with the ``.counts`` is handy because all the Numpy advanced indexing rules apply (in an extended sense) to jagged arrays.\n\n# %%\nvarlen[varlen.counts > 1, 1]\n# array([2.2, 5.5, 8.8])\n\n# %%markdown\n# I\'ve only presented the two most important awkward classes, ``Table`` and ``JaggedArray`` (and not how they combine). Each class is presented in more detail below. For now, I\'d just like to point out that you can make crazy complicated data structures\n\n# %%\ncrazy = awkward.fromiter([[1.21, 4.84, None, 10.89, None],\n                          [19.36, [30.25]],\n                          [{""x"": 36, ""y"": {""z"": 49}}, None, {""x"": 64, ""y"": {""z"": 81}}]\n                         ])\n\n# %%markdown\n# and they vectorize and slice as expected.\n\n# %%\nnumpy.sqrt(crazy).tolist()\n# [[1.1, 2.2, None, 3.3000000000000003, None],\n#  [4.4, [5.5]],\n#  [{\'x\': 6.0, \'y\': {\'z\': 7.0}}, None, {\'x\': 8.0, \'y\': {\'z\': 9.0}}]]\n\n# %%markdown\n# This is because any awkward array can be the content of any other awkward array. Like Numpy, the features of awkward-array are simple, yet compose nicely to let you build what you need.\n\n# %%markdown\n# # Overview with sample datasets\n#\n# Many of the examples in this tutorial use ``awkward.fromiter`` to make awkward arrays from lists and ``array.tolist()`` to turn them back into lists (or dicts for ``Table``, tuples for ``Table`` with anonymous fields, Python objects for ``ObjectArrays``, etc.). These should be considered slow methods, since Python instructions are executed in the loop, but that\'s a necessary part of examining or building Python objects.\n#\n# Ideally, you\'d want to get your data from a binary, columnar source and produce binary, columnar output, or convert only once and reuse the converted data. `Parquet <https://parquet.apache.org>`__ is a popular columnar format for storing data on disk and `Arrow <https://arrow.apache.org>`__ is a popular columnar format for sharing data in memory (between functions or applications). `ROOT <https://root.cern>`__ is a popular columnar format for particle physicists, and `uproot <https://github.com/scikit-hep/uproot>`__ natively produces awkward arrays from ROOT files.\n#\n# `HDF5 <https://www.hdfgroup.org>`__ and its Python library `h5py <https://www.h5py.org/>`__ are columnar, but only for rectangular arrays, unlike the others mentioned here. Awkward-array can *wrap* HDF5 with an interpretation layer to store columnar data structures, but then the awkward-array library wuold be needed to read the data back in a meaningful way. Awkward also has a native file format, ``.awkd`` files, which are simply ZIP archives of columns as binary blobs and metadata (just as Numpy\'s ``.npz`` is a ZIP of arrays with metadata). The HDF5, awkd, and pickle serialization procedures use the same protocol, which has backward and forward compatibility features.\n\n# %%markdown\n# ## NASA exoplanets from a Parquet file\n#\n# Let\'s start by opening a Parquet file. Awkward reads Parquet through the `pyarrow <https://arrow.apache.org/docs/python>`__ module, which is an optional dependency, so be sure you have it installed before trying the next line.\n\n# %%\nstars = awkward.fromparquet(""tests/samples/exoplanets.parquet"")\nstars\n# <ChunkedArray [<Row 0> <Row 1> <Row 2> ... <Row 2932> <Row 2933> <Row 2934>] at 0x7f25b9c67780>\n\n# %%markdown\n# (There is also an ``awkward.toparquet`` that takes the file name and array as arguments.)\n#\n# Columns are accessible with square brackets and strings\n\n# %%\nstars[""name""]\n# <ChunkedArray [\'11 Com\' \'11 UMi\' \'14 And\' ... \'tau Gem\' \'ups And\' \'xi Aql\'] at 0x7f25b9c67dd8>\n\n# %%markdown\n# or by dot-attribute (if the name doesn\'t have weird characters and doesn\'t conflict with a method or property name).\n\n# %%\nstars.ra, stars.dec\n# (<ChunkedArray [185.179276 229.27453599999998 352.822571 ... 107.78488200000001 24.199345 298.56201200000004] at 0x7f25b94ccf28>,\n#  <ChunkedArray [17.792868 71.823898 39.236198 ... 30.245163 41.40546 8.461452] at 0x7f25b94cca90>)\n\n# %%markdown\n# This file contains data about extrasolar planets and their host stars. As such, it\'s a ``Table`` full of Numpy arrays and ``JaggedArrays``. The star attributes (`""name""`, `""ra""` or right ascension in degrees, `""dec""` or declination in degrees, `""dist""` or distance in parsecs, `""mass""` in multiples of the sun\'s mass, and `""radius""` in multiples of the sun\'s radius) are plain Numpy arrays and the planet attributes (`""name""`, `""orbit""` or orbital distance in AU, `""eccen""` or eccentricity, `""period""` or periodicity in days, `""mass""` in multiples of Jupyter\'s mass, and `""radius""` in multiples of Jupiter\'s radius) are jagged because each star may have a different number of planets.\n\n# %%\nstars.planet_name\n# <ChunkedArray [[\'b\'] [\'b\'] [\'b\'] ... [\'b\'] [\'b\' \'c\' \'d\'] [\'b\']] at 0x7f25b94dc550>\n\n# %%\nstars.planet_period, stars.planet_orbit\n# (<ChunkedArray [[326.03] [516.21997] [185.84] ... [305.5] [4.617033 241.258 1276.46] [136.75]] at 0x7f25b94cccc0>,\n#  <ChunkedArray [[1.29] [1.53] [0.83] ... [1.17] [0.059222000000000004 0.827774 2.51329] [0.68]] at 0x7f25b94cc978>)\n\n# %%markdown\n# For large arrays, only the first and last values are printed: the second-to-last star has three planets; all the other stars shown here have one planet.\n#\n# These arrays are called ``ChunkedArrays`` because the Parquet file is lazily read in chunks (Parquet\'s row group structure). The ``ChunkedArray`` (subdivides the file) contains ``VirtualArrays`` (read one chunk on demand), which generate the ``JaggedArrays``. This is an illustration of how each awkward class provides one feature, and you get desired behavior by combining them.\n#\n# The ``ChunkedArrays`` and ``VirtualArrays`` support the same Numpy-like access as ``JaggedArray``, so we can compute with them just as we would any other array.\n\n# %%\n# distance in parsecs \xe2\x86\x92 distance in light years\nstars.dist * 3.26156\n# <ChunkedArray [304.5318572 410.0433232 246.5413204 ... 367.38211839999997 43.7375196 183.5279812] at 0x7f25b94cce80>\n\n# %%\n# for all stars, drop the first planet\nstars.planet_mass[:, 1:]\n# <ChunkedArray [[] [] [] ... [] [1.981 4.132] []] at 0x7f25b94ccf60>\n\n# %%markdown\n# ## NASA exoplanets from an Arrow buffer\n#\n# The pyarrow implementation of Arrow is more complete than its implementation of Parquet, so we can use more features in the Arrow format, such as nested tables.\n#\n# Unlike Parquet, which is intended as a file format, Arrow is a memory format. You might get an Arrow buffer as the output of another function, through interprocess communication, from a network RPC call, a message bus, etc. Arrow can be saved as files, though this isn\'t common. In this case, we\'ll get it from a file.\n\n# %%\nimport pyarrow\narrow_buffer = pyarrow.ipc.open_file(open(""tests/samples/exoplanets.arrow"", ""rb"")).get_batch(0)\nstars = awkward.fromarrow(arrow_buffer)\nstars\n# <Table [<Row 0> <Row 1> <Row 2> ... <Row 2932> <Row 2933> <Row 2934>] at 0x7f25b94f2518>\n\n# %%markdown\n# (There is also an ``awkward.toarrow`` that takes an awkward array as its only argument, returning the relevant Arrow structure.)\n#\n# This file is structured differently. Instead of jagged arrays of numbers like ``""planet_mass""``, ``""planet_period""``, and ``""planet_orbit""``, this file has a jagged table of ``""planets""``. A jagged table is a ``JaggedArray`` of ``Table``.\n\n# %%\nstars[""planets""]\n# <JaggedArray [[<Row 0>] [<Row 1>] [<Row 2>] ... [<Row 3928>] [<Row 3929> <Row 3930> <Row 3931>] [<Row 3932>]] at 0x7f25b94fb080>\n\n# %%markdown\n# Notice that the square brackets are nested, but the contents are ``<Row>`` objects. The second-to-last star has three planets, as before.\n#\n# We can find the non-jagged ``Table`` in the ``JaggedArray.content``.\n\n# %%\nstars[""planets""].content\n# <Table [<Row 0> <Row 1> <Row 2> ... <Row 3930> <Row 3931> <Row 3932>] at 0x7f25b94f2d68>\n\n# %%markdown\n# When viewed as Python lists and dicts, the ``\'planets\'`` field is a list of planet dicts, each with its own fields.\n\n# %%\nstars[:2].tolist()\n# [{\'dec\': 17.792868,\n#   \'dist\': 93.37,\n#   \'mass\': 2.7,\n#   \'name\': \'11 Com\',\n#   \'planets\': [{\'eccen\': 0.231,\n#     \'mass\': 19.4,\n#     \'name\': \'b\',\n#     \'orbit\': 1.29,\n#     \'period\': 326.03,\n#     \'radius\': nan}],\n#   \'ra\': 185.179276,\n#   \'radius\': 19.0},\n#  {\'dec\': 71.823898,\n#   \'dist\': 125.72,\n#   \'mass\': 2.78,\n#   \'name\': \'11 UMi\',\n#   \'planets\': [{\'eccen\': 0.08,\n#     \'mass\': 14.74,\n#     \'name\': \'b\',\n#     \'orbit\': 1.53,\n#     \'period\': 516.21997,\n#     \'radius\': nan}],\n#   \'ra\': 229.27453599999998,\n#   \'radius\': 29.79}]\n\n# %%markdown\n# Despite being packaged in an arguably more intuitive way, we can still get jagged arrays of numbers by requesting ``""planets""`` and a planet attribute (two column selections) without specifying which star or which parent.\n\n# %%\nstars.planets.name\n# <JaggedArray [[\'b\'] [\'b\'] [\'b\'] ... [\'b\'] [\'b\' \'c\' \'d\'] [\'b\']] at 0x7f25b94dc780>\n\n# %%\nstars.planets.mass\n# <JaggedArray [[19.4] [14.74] [4.8] ... [20.6] [0.6876 1.981 4.132] [2.8]] at 0x7f25b94fb240>\n\n# %%markdown\n# Even though the ``Table`` is hidden inside the ``JaggedArray``, its ``columns`` pass through to the top.\n\n# %%\nstars.columns\n# [\'dec\', \'dist\', \'mass\', \'name\', \'planets\', \'ra\', \'radius\']\n\n# %%\nstars.planets.columns\n# [\'eccen\', \'mass\', \'name\', \'orbit\', \'period\', \'radius\']\n\n# %%markdown\n# For a more global view of the structures contained within one of these arrays, print out its high-level type. (""High-level"" because it presents logical distinctions, like jaggedness and tables, but not physical distinctions, like chunking and virtualness.)\n\n# %%\nprint(stars.type)\n# [0, 2935) -> \'dec\'     -> float64\n#              \'dist\'    -> float64\n#              \'mass\'    -> float64\n#              \'name\'    -> <class \'str\'>\n#              \'planets\' -> [0, inf) -> \'eccen\'  -> float64\n#                                       \'mass\'   -> float64\n#                                       \'name\'   -> <class \'str\'>\n#                                       \'orbit\'  -> float64\n#                                       \'period\' -> float64\n#                                       \'radius\' -> float64\n#              \'ra\'      -> float64\n#              \'radius\'  -> float64\n\n# %%markdown\n# The above should be read like a function\'s data type: ``argument type -> return type`` for the function that takes an index in square brackets and returns something else. For example, the first ``[0, 2935)`` means that you could put any non-negative integer less than ``2935`` in square brackets after ``stars``, like this:\n\n# %%\nstars[1734]\n# <Row 1734>\n\n# %%markdown\n# and get an object that would take ``\'dec\'``, ``\'dist\'``, ``\'mass\'``, ``\'name\'``, ``\'planets\'``, ``\'ra\'``, or ``\'radius\'`` in its square brackets. The return type depends on which of those strings you provide.\n\n# %%\nstars[1734][""mass""]   # type is float64\n# 0.54\n\n# %%\nstars[1734][""name""]   # type is <class \'str\'>\n# \'Kepler-186\'\n\n# %%\nstars[1734][""planets""]\n# <Table [<Row 2192> <Row 2193> <Row 2194> <Row 2195> <Row 2196>] at 0x7f25b94dc438>\n\n# %%markdown\n# The planets have their own table structure:\n\n# %%\nprint(stars[1734][""planets""].type)\n# [0, 5) -> \'eccen\'  -> float64\n#           \'mass\'   -> float64\n#           \'name\'   -> <class \'str\'>\n#           \'orbit\'  -> float64\n#           \'period\' -> float64\n#           \'radius\' -> float64\n\n# %%markdown\n# Notice that within the context of ``stars``, the ``planets`` could take any non-negative integer ``[0, inf)``, but for a particular star, the allowed domain is known with more precision: ``[0, 5)``. This is because ``stars[""planets""]`` is a jagged array\xe2\x80\x94a different number of planets for each star\xe2\x80\x94but one ``stars[1734][""planets""]`` is a simple array\xe2\x80\x94five planets for *this* star.\n#\n# Passing a non-negative integer less than 5 to this array, we get an object that takes one of six strings: : ``\'eccen\'``, ``\'mass\'``, ``\'name\'``, ``\'orbit\'``, ``\'period\'``, and ``\'radius\'``.\n\n# %%\nstars[1734][""planets""][4]\n# <Row 2196>\n\n# %%markdown\n# and the return type of these depends on which string you provide.\n\n# %%\nstars[1734][""planets""][4][""period""]   # type is float\n# 129.9441\n\n# %%\nstars[1734][""planets""][4][""name""]   # type is <class \'str\'>\n# \'f\'\n\n# %%\nstars[1734][""planets""][4].tolist()\n# {\'eccen\': 0.04,\n#  \'mass\': nan,\n#  \'name\': \'f\',\n#  \'orbit\': 0.432,\n#  \'period\': 129.9441,\n#  \'radius\': 0.10400000000000001}\n\n# %%markdown\n# (Incidentally, this is a `potentially habitable exoplanet <https://www.nasa.gov/ames/kepler/kepler-186f-the-first-earth-size-planet-in-the-habitable-zone>`__`, the first ever discovered.)\n\n# %%\nstars[1734][""name""], stars[1734][""planets""][4][""name""]\n# (\'Kepler-186\', \'f\')\n\n# %%markdown\n# Some of these arguments ""commute"" and others don\'t. Dimensional axes have a particular order, so you can\'t request a planet by its row number before selecting a star, but you can swap a column-selection (string) and a row-selection (integer). For a rectangular table, it\'s easy to see how you can slice column-first or row-first, but it even works when the table is jagged.\n\n# %%\nstars[""planets""][""name""][1734][4]\n# \'f\'\n\n# %%\nstars[1734][""planets""][4][""name""]\n# \'f\'\n\n# %%markdown\n# None of these intermediate slices actually process data, so you can slice in any order that is logically correct without worrying about performance. Projections, even multi-column projections\n\n# %%\norbits = stars[""planets""][[""name"", ""eccen"", ""orbit"", ""period""]]\norbits[1734].tolist()\nIn this representation, each star\'s attributes must be duplicated for all of its planets, and it is not possible to show stars that have no planets (not present in this dataset), but the information is preserved in a way that Pandas can recognize and operate on. (For instance, .unstack() would widen each planet attribute into a separate column per planet and simplify the index to strictly one row per star.)\n\nThe limitation is that only a single jagged structure can be represented by a DataFrame. The structure can be arbitrarily deep in Tables (which add depth to the column names),\n\n\n# %%\narray = awkward.fromiter([{""a"": {""b"": 1, ""c"": {""d"": [2]}}, ""e"": 3},\n\n# %%\nstars[1734][""planets""][4][""name""]\n# \'f\'\n\n# %%markdown\n# None of these intermediate slices actually process data, so you can slice in any order that is logically correct without worrying about performance. Projections,\neven multi-column projections\n\n# %%\norbits = stars[""planets""][[""name"", ""eccen"", ""orbit"", ""period""]]\norbits[1734].tolist()\n# [{\'name\': \'b\', \'eccen\': nan, \'orbit\': 0.0343, \'period\': 3.8867907},\n#  {\'name\': \'c\', \'eccen\': nan, \'orbit\': 0.0451, \'period\': 7.267302},\n#  {\'name\': \'d\', \'eccen\': nan, \'orbit\': 0.0781, \'period\': 13.342996},\n#  {\'name\': \'e\', \'eccen\': nan, \'orbit\': 0.11, \'period\': 22.407704},\n#  {\'name\': \'f\', \'eccen\': 0.04, \'orbit\': 0.432, \'period\': 129.9441}]\n\n# %%markdown\n# are a useful way to restructure data without incurring a runtime cost.\n\n# %%markdown\n# ## Relationship to Pandas\n#\n# Arguably, this kind of dataset could be manipulated as a `Pandas DataFrame <https://pandas.pydata.org>`__ instead of awkward arrays. Despite the variable number of planets per star, the exoplanets dataset could be flattened into a rectangular DataFrame, in which the distinction between solar systems is represented by a two-component index (leftmost pair of columns below), a `MultiIndex <https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html>`__.\n\n# %%\nawkward.topandas(stars, flatten=True)[-9:]\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>dec</th>\\n"",\n       ""      <th>dist</th>\\n"",\n       ""      <th>mass</th>\\n"",\n       ""      <th>name</th>\\n"",\n       ""      <th colspan=\\""6\\"" halign=\\""left\\"">planets</th>\\n"",\n       ""      <th>ra</th>\\n"",\n       ""      <th>radius</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>eccen</th>\\n"",\n       ""      <th>mass</th>\\n"",\n       ""      <th>name</th>\\n"",\n       ""      <th>orbit</th>\\n"",\n       ""      <th>period</th>\\n"",\n       ""      <th>radius</th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""4\\"" valign=\\""top\\"">2931</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>-15.937480</td>\\n"",\n       ""      <td>3.60</td>\\n"",\n       ""      <td>0.78</td>\\n"",\n       ""      <td>49</td>\\n"",\n       ""      <td>0.1800</td>\\n"",\n       ""      <td>0.01237</td>\\n"",\n       ""      <td>101</td>\\n"",\n       ""      <td>0.538000</td>\\n"",\n       ""      <td>162.870000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>26.017012</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>-15.937480</td>\\n"",\n       ""      <td>3.60</td>\\n"",\n       ""      <td>0.78</td>\\n"",\n       ""      <td>49</td>\\n"",\n       ""      <td>0.1600</td>\\n"",\n       ""      <td>0.01237</td>\\n"",\n       ""      <td>102</td>\\n"",\n       ""      <td>1.334000</td>\\n"",\n       ""      <td>636.130000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>26.017012</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>-15.937480</td>\\n"",\n       ""      <td>3.60</td>\\n"",\n       ""      <td>0.78</td>\\n"",\n       ""      <td>49</td>\\n"",\n       ""      <td>0.0600</td>\\n"",\n       ""      <td>0.00551</td>\\n"",\n       ""      <td>103</td>\\n"",\n       ""      <td>0.133000</td>\\n"",\n       ""      <td>20.000000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>26.017012</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <td>-15.937480</td>\\n"",\n       ""      <td>3.60</td>\\n"",\n       ""      <td>0.78</td>\\n"",\n       ""      <td>49</td>\\n"",\n       ""      <td>0.2300</td>\\n"",\n       ""      <td>0.00576</td>\\n"",\n       ""      <td>104</td>\\n"",\n       ""      <td>0.243000</td>\\n"",\n       ""      <td>49.410000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>26.017012</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2932</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>30.245163</td>\\n"",\n       ""      <td>112.64</td>\\n"",\n       ""      <td>2.30</td>\\n"",\n       ""      <td>53</td>\\n"",\n       ""      <td>0.0310</td>\\n"",\n       ""      <td>20.60000</td>\\n"",\n       ""      <td>98</td>\\n"",\n       ""      <td>1.170000</td>\\n"",\n       ""      <td>305.500000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>107.784882</td>\\n"",\n       ""      <td>26.80</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">2933</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>41.405460</td>\\n"",\n       ""      <td>13.41</td>\\n"",\n       ""      <td>1.30</td>\\n"",\n       ""      <td>48</td>\\n"",\n       ""      <td>0.0215</td>\\n"",\n       ""      <td>0.68760</td>\\n"",\n       ""      <td>98</td>\\n"",\n       ""      <td>0.059222</td>\\n"",\n       ""      <td>4.617033</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>24.199345</td>\\n"",\n       ""      <td>1.56</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>41.405460</td>\\n"",\n       ""      <td>13.41</td>\\n"",\n       ""      <td>1.30</td>\\n"",\n       ""      <td>48</td>\\n"",\n       ""      <td>0.2596</td>\\n"",\n       ""      <td>1.98100</td>\\n"",\n       ""      <td>99</td>\\n"",\n       ""      <td>0.827774</td>\\n"",\n       ""      <td>241.258000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>24.199345</td>\\n"",\n       ""      <td>1.56</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>41.405460</td>\\n"",\n       ""      <td>13.41</td>\\n"",\n       ""      <td>1.30</td>\\n"",\n       ""      <td>48</td>\\n"",\n       ""      <td>0.2987</td>\\n"",\n       ""      <td>4.13200</td>\\n"",\n       ""      <td>100</td>\\n"",\n       ""      <td>2.513290</td>\\n"",\n       ""      <td>1276.460000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>24.199345</td>\\n"",\n       ""      <td>1.56</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2934</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>8.461452</td>\\n"",\n       ""      <td>56.27</td>\\n"",\n       ""      <td>2.20</td>\\n"",\n       ""      <td>55</td>\\n"",\n       ""      <td>0.0000</td>\\n"",\n       ""      <td>2.80000</td>\\n"",\n       ""      <td>98</td>\\n"",\n       ""      <td>0.680000</td>\\n"",\n       ""      <td>136.750000</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>298.562012</td>\\n"",\n       ""      <td>12.00</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# In this representation, each star\'s attributes must be duplicated for all of its planets, and it is not possible to show stars that have no planets (not present in this dataset), but the information is preserved in a way that Pandas can recognize and operate on. (For instance, ``.unstack()`` would widen each planet attribute into a separate column per planet and simplify the index to strictly one row per star.)\n#\n# The limitation is that only a single jagged structure can be represented by a DataFrame. The structure can be arbitrarily deep in ``Tables`` (which add depth to the column names),\n\n# %%\narray = awkward.fromiter([{""a"": {""b"": 1, ""c"": {""d"": [2]}}, ""e"": 3},\n                          {""a"": {""b"": 4, ""c"": {""d"": [5, 5.1]}}, ""e"": 6},\n                          {""a"": {""b"": 7, ""c"": {""d"": [8, 8.1, 8.2]}}, ""e"": 9}])\nawkward.topandas(array, flatten=True)\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th colspan=\\""2\\"" halign=\\""left\\"">a</th>\\n"",\n       ""      <th>e</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""      <th>c</th>\\n"",\n       ""      <th></th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>d</th>\\n"",\n       ""      <th></th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>2.0</td>\\n"",\n       ""      <td>3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>4</td>\\n"",\n       ""      <td>5.0</td>\\n"",\n       ""      <td>6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>4</td>\\n"",\n       ""      <td>5.1</td>\\n"",\n       ""      <td>6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.0</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.1</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.2</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# and arbitrarily deep in ``JaggedArrays`` (which add depth to the row names),\n\n# %%\narray = awkward.fromiter([{""a"": 1, ""b"": [[2.2, 3.3, 4.4], [], [5.5, 6.6]]},\n                          {""a"": 10, ""b"": [[1.1], [2.2, 3.3], [], [4.4]]},\n                          {""a"": 100, ""b"": [[], [9.9]]}])\nawkward.topandas(array, flatten=True)\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>a</th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""5\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>5.5</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>6.6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""4\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>1.1</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>100</td>\\n"",\n       ""      <td>9.9</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# and they can even have two ``JaggedArrays`` at the same level if their number of elements is the same (at all levels of depth).\n\n# %%\narray = awkward.fromiter([{""a"": [[1.1, 2.2, 3.3], [], [4.4, 5.5]], ""b"": [[1, 2, 3], [], [4, 5]]},\n                          {""a"": [[1.1], [2.2, 3.3], [], [4.4]],    ""b"": [[1], [2, 3], [], [4]]},\n                          {""a"": [[], [9.9]],                       ""b"": [[], [9]]}])\nawkward.topandas(array, flatten=True)\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>a</th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""5\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1.1</td>\\n"",\n       ""      <td>1</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""      <td>2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""      <td>4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>5.5</td>\\n"",\n       ""      <td>5</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""4\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1.1</td>\\n"",\n       ""      <td>1</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""      <td>2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""      <td>4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>9.9</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# But if there are two ``JaggedArrays`` with *different* structure at the same level, a single DataFrame cannot represent them.\n\n# %%\narray = awkward.fromiter([{""a"": [1, 2, 3], ""b"": [1.1, 2.2]},\n                          {""a"": [1],       ""b"": [1.1, 2.2, 3.3]},\n                          {""a"": [1, 2],    ""b"": []}])\ntry:\n    awkward.topandas(array, flatten=True)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> this array has more than one jagged array structure\n\n# %%markdown\n# To describe data like these, you\'d need two DataFrames, and any calculations involving both ``""a""`` and ``""b""`` would have to include a join on those DataFrames. Awkward arrays are not limited in this way: the last ``array`` above is a valid awkward array and is useful for calculations that mix ``""a""`` and ``""b""``.\n\n# %%markdown\n# ## LHC data from a ROOT file\n#\n# Particle physicsts need structures like these\xe2\x80\x94in fact, they have been a staple of particle physics analyses for decades. The `ROOT <https://root.cern>`__ file format was developed in the mid-90\'s to serialize arbitrary C++ data structures in a columnar way (replacing ZEBRA and similar Fortran projects that date back to the 70\'s). The `PyROOT <https://root.cern.ch/pyroot>`__ library dynamically wraps these objects to present them in Python, though with a performance penalty. The `uproot <https://github.com/scikit-hep/uproot>`__ library reads columnar data directly from ROOT files in Python without intermediary C++.\n\n# %%\nimport uproot\nevents = uproot.open(""http://scikit-hep.org/uproot/examples/HZZ-objects.root"")[""events""].lazyarrays()\nevents\n# <Table [<Row 0> <Row 1> <Row 2> ... <Row 2418> <Row 2419> <Row 2420>] at 0x781189cd7b70>\n\n# %%\nevents.columns\n# [\'jetp4\',\n#  \'jetbtag\',\n#  \'jetid\',\n#  \'muonp4\',\n#  \'muonq\',\n#  \'muoniso\',\n#  \'electronp4\',\n#  \'electronq\',\n#  \'electroniso\',\n#  \'photonp4\',\n#  \'photoniso\',\n#  \'MET\',\n#  \'MC_bquarkhadronic\',\n#  \'MC_bquarkleptonic\',\n#  \'MC_wdecayb\',\n#  \'MC_wdecaybbar\',\n#  \'MC_lepton\',\n#  \'MC_leptonpdgid\',\n#  \'MC_neutrino\',\n#  \'num_primaryvertex\',\n#  \'trigger_isomu24\',\n#  \'eventweight\']\n\n# %%markdown\n# This is a typical particle physics dataset (though small!) in that it represents the momentum and energy (``""p4""`` for `Lorentz 4-momentum <https://en.wikipedia.org/wiki/Four-vector`__) of several different species of particles: ``""jet""``, ``""muon""``, ``""electron""``, and ``""photon""``. Each collision can produce a different number of particles in each species. Other variables, such as missing transverse energy or ``""MET""``, have one value per collision event. Events with zero particles in a species are valuable for the event-level data.\n\n# %%\n# The first event has two muons.\nevents.muonp4\n# <ChunkedArray [[TLorentzVector(-52.899, -11.655, -8.1608, 54.779) TLorentzVector(37.738, 0.69347, -11.308, 39.402)] [TLorentzVector(-0.81646, -24.404, 20.2, 31.69)] [TLorentzVector(48.988, -21.723, 11.168, 54.74) TLorentzVector(0.82757, 29.801, 36.965, 47.489)] ... [TLorentzVector(-29.757, -15.304, -52.664, 62.395)] [TLorentzVector(1.1419, 63.61, 162.18, 174.21)] [TLorentzVector(23.913, -35.665, 54.719, 69.556)]] at 0x781189cd7fd0>\n\n# %%\n# The first event has zero jets.\nevents.jetp4\n# <ChunkedArray [[] [TLorentzVector(-38.875, 19.863, -0.89494, 44.137)] [] ... [TLorentzVector(-3.7148, -37.202, 41.012, 55.951)] [TLorentzVector(-36.361, 10.174, 226.43, 229.58) TLorentzVector(-15.257, -27.175, 12.12, 33.92)] []] at 0x781189cd7be0>\n\n# %%\n# Every event has exactly one MET.\nevents.MET\n# <ChunkedArray [TVector2(5.9128, 2.5636) TVector2(24.765, -16.349) TVector2(-25.785, 16.237) ... TVector2(18.102, 50.291) TVector2(79.875, -52.351) TVector2(19.714, -3.5954)] at 0x781189cfe780>\n\n# %%markdown\n# Unlike the exoplanet data, these events cannot be represented as a DataFrame because of the different numbers of particles in each species and because zero-particle events have value. Even with just ``""muonp4""``, ``""jetp4""``, and ``""MET""``, there is no translation.\n\n# %%\ntry:\n    awkward.topandas(events[[""muonp4"", ""jetp4"", ""MET""]], flatten=True)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'NameError\'> name \'awkward\' is not defined\n\n# %%markdown\n# It could be described as a collection of DataFrames, in which every operation relating particles in the same event would require a join. But that would make analysis harder, not easier. An event has meaning on its own.\n\n# %%\nevents[0].tolist()\n# {\'jetp4\': [],\n#  \'jetbtag\': [],\n#  \'jetid\': [],\n#  \'muonp4\': [TLorentzVector(-52.899, -11.655, -8.1608, 54.779),\n#   TLorentzVector(37.738, 0.69347, -11.308, 39.402)],\n#  \'muonq\': [1, -1],\n#  \'muoniso\': [4.200153350830078, 2.1510612964630127],\n#  \'electronp4\': [],\n#  \'electronq\': [],\n#  \'electroniso\': [],\n#  \'photonp4\': [],\n#  \'photoniso\': [],\n#  \'MET\': TVector2(5.9128, 2.5636),\n#  \'MC_bquarkhadronic\': TVector3(0, 0, 0),\n#  \'MC_bquarkleptonic\': TVector3(0, 0, 0),\n#  \'MC_wdecayb\': TVector3(0, 0, 0),\n#  \'MC_wdecaybbar\': TVector3(0, 0, 0),\n#  \'MC_lepton\': TVector3(0, 0, 0),\n#  \'MC_leptonpdgid\': 0,\n#  \'MC_neutrino\': TVector3(0, 0, 0),\n#  \'num_primaryvertex\': 6,\n#  \'trigger_isomu24\': True,\n#  \'eventweight\': 0.009271008893847466}\n\n# %%markdown\n# Particle physics isn\'t alone in this: analyzing JSON-formatted log files in production systems or allele likelihoods in genomics are two other fields where variable-length, nested structures can help. Arbitrary data structures are useful and working with them in columns provides a new way to do exploratory data analysis: one array at a time.\n\n# %%markdown\n# # Awkward-array data model\n#\n# Awkward array features are provided by a suite of classes that each extend Numpy arrays in one small way. These classes may then be composed to combine features.\n#\n# In this sense, Numpy arrays are awkward-array\'s most basic array class. A Numpy array is a small Python object that points to a large, contiguous region of memory, and, as much as possible, operations replace or change the small Python object, not the big data buffer. Therefore, many Numpy operations are *views*, rather than *in-place operations* or *copies*, leaving the original value intact but returning a new value that is linked to the original. Assigning to arrays and in-place operations are allowed, but they are more complicated to use because one must be aware of which arrays are views and which are copies.\n#\n# Awkward-array\'s model is to treat all arrays as though they were immutable, favoring views over copies, and not providing any high-level in-place operations on low-level memory buffers (i.e. no in-place assignment).\n#\n# Numpy provides complete control over the interpretation of an ``N`` dimensional array. A Numpy array has a `dtype <https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html>`__ to interpret bytes as signed and unsigned integers of various bit-widths, floating-point numbers, booleans, little endian and big endian, fixed-width bytestrings (for applications such as 6-byte MAC addresses or human-readable strings with padding), or `record arrays <https://docs.scipy.org/doc/numpy/user/basics.rec.html>`__ for contiguous structures. A Numpy array has a `pointer <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.ctypes.html>`__ to the first element of its data buffer (``array.ctypes.data``) and a `shape <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html>`__ to describe its ``N`` dimensions as a rank-``N`` tensor. Only ``shape[0]`` is the length as returned by the Python function ``len``. Furthermore, an `order <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flags.html>`__ flag determines if rank > 1 arrays are laid out in ""C"" order or ""Fortran"" order. A Numpy array also has a `stride <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.strides.html>`__ to determine how many bytes separate one element from the next. (Data in a Numpy array need not be strictly contiguous, but they must be regular: the number of bytes seprating them is a constant.) This stride may even be negative to describe a reversed view of an array, which allows any ``slice`` of an array, even those with ``skip != 1`` to be a view, rather than a copy. Numpy arrays also have flags to determine whether they `own <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flags.html>`__ their data buffer (and should therefore delete it when the Python object goes out of scope) and whether the data buffer is `writable <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.flags.html>`__.\n\n# %%markdown\n#\n# The biggest restriction on this data model is that Numpy arrays are strictly rectangular. The ``shape`` and ``stride`` are constants, enforcing a regular layout. Awkward\'s ``JaggedArray`` is a generalization of Numpy\'s rank-2 arrays\xe2\x80\x94that is, arrays of arrays\xe2\x80\x94in that the inner arrays of a ``JaggedArray`` may all have different lengths. For higher ranks, such as arrays of arrays of arrays, put a ``JaggedArray`` inside another as its ``content``. An important special case of ``JaggedArray`` is ``StringArray``, whose ``content`` is interpreted as characters (with or without encoding), which represents an array of strings without unnecessary padding, as in Numpy\'s case.\n#\n# Although Numpy\'s `record arrays <https://docs.scipy.org/doc/numpy/user/basics.rec.html>`__ present a buffer as a table, with differently typed, named columns, that table must be contiguous or interleaved (with non-trivial ``strides``) in memory: an `array of structs <https://en.wikipedia.org/wiki/AOS_and_SOA>`__. Awkward\'s ``Table`` provides the same interface, except that each column may be anywhere in memory, stored in a ``contents`` dict mapping field names to arrays. This is a true generalization: a ``Table`` may be a wrapped view of a Numpy record array, but not vice-versa. Use a ``Table`` anywhere you\'d have a record/class/struct in non-columnar data structures. A ``Table`` with anonymous (integer-valued, rather than string-valued) fields is like an array of strongly typed tuples.\n#\n# Numpy has a `masked array <https://docs.scipy.org/doc/numpy/reference/maskedarray.html>`__ module for nullable data\xe2\x80\x94values that may be ""missing"" (like Python\'s ``None``). Naturally, the only kinds of arrays Numpy can mask are subclasses of its own ``ndarray``, and we need to be able to mask any awkward array, so the awkward library defines its own ``MaskedArray``. Additionally, we sometimes want to mask with bits, rather than bytes (e.g. for Arrow compatibility), so there\'s a ``BitMaskedArray``, and sometimes we want to mask large structures without using memory for the masked-out values, so there\'s an ``IndexedMaskedArray`` (fusing the functionality of a ``MaskedArray`` with an ``IndexedArray``).\n#\n# Numpy has no provision for an array containing different data types (""heterogeneous""), but awkward-array has a ``UnionArray``. The ``UnionArray`` stores data for each type as separate ``contents`` and identifies the types and positions of each element in the ``contents`` using ``tags`` and ``index`` arrays (equivalent to Arrow\'s `dense union type <https://arrow.apache.org/docs/memory_layout.html#dense-union-type>`__ with ``types`` and ``offsets`` buffers). As a data type, unions are a counterpart to records or tuples (making ``UnionArray`` a counterpart to ``Table``): each record/tuple contains *all* of its ``contents`` but a union contains *any* of its ``contents``. (Note that a ``UnionArray`` may be the best way to interleave two arrays, even if they have the same type. Heterogeneity is not a necessary feature of a ``UnionArray``.)\n#\n# Numpy has a ``dtype=object`` for arrays of Python objects, but awkward\'s ``ObjectArray`` creates Python objects on demand from array data. A large dataset of some ``Point`` class, containing floating-point members ``x`` and ``y``, can be stored as an ``ObjectArray`` of a ``Table`` of ``x`` and ``y`` with much less memory than a Numpy array of ``Point`` objects. The ``ObjectArray`` has a ``generator`` function that produces Python objects from array elements.  ``StringArray`` is also a special case of ``ObjectArray``, which instantiates variable-length character contents as Python strings.\n#\n# Although an ``ObjectArray`` can save memory, creating Python objects in a loop may still use more computation time than is necessary. Therefore, awkward arrays can also have vectorized ``Methods``\xe2\x80\x94bound functions that operate on the array data, rather than instantiating every Python object in an ``ObjectArray``. Although an ``ObjectArray`` is a good use-case for ``Methods``, any awkward array can have them. (The second most common case being a ``JaggedArray`` of ``ObjectArrays``.)\n#\n# The nesting of awkward arrays within awkward arrays need not be tree-like: they can have cross-references and cyclic references (using ordinary Python assignment). ``IndexedArray`` can aid in building complex structures: it is simply an integer ``index`` that would be applied to its ``content`` with `integer array indexing <https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#integer-array-indexing>`__ to get any element. ``IndexedArray`` is the equivalent of a pointer in non-columnar data structures.\n#\n# The counterpart of an ``IndexedArray`` is a ``SparseArray``: whereas an ``IndexedArray`` consists of pointers *to* elements of its ``content``, a ``SparseArray`` consists of pointers *from* elements of its content, representing a very large array in terms of its non-zero (or non-``default``) elements. Awkward\'s ``SparseArray`` is a `coordinate format (COO) <https://scipy-lectures.org/advanced/scipy_sparse/coo_matrix.html>`__, one-dimensional array.\n#\n# Another limitation of Numpy is that arrays cannot span multiple memory buffers. Awkward\'s ``ChunkedArray`` represents a single logical array made of physical ``chunks`` that may be anywhere in memory. A ``ChunkedArray``\'s ``chunksizes`` may be known or unknown. One application of ``ChunkedArray`` is to append data to an array without allocating on every call: ``AppendableArray`` allocates memory in equal-sized chunks.\n#\n# Another application of ``ChunkedArray`` is to lazily load data in chunks. Awkward\'s ``VirtualArray`` calls its ``generator`` function to materialize an array when needed, and a ``ChunkedArray`` of ``VirtualArrays`` is a classic lazy-loading array, used to gradually read Parquet and ROOT files. In most libraries, lazy-loading is not a part of the data but a feature of the reading interface. Nesting virtualness makes it possible to load ``Tables`` within ``Tables``, where even the columns of the inner ``Tables`` are on-demand.\n#\n# For more details, see `array classes <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc>`__.\n#\n# * `Jaggedness <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#jaggedness>`__\n#\n#    * `JaggedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#jaggedarray>`__\n#    * `Helper functions <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#helper-functions>`__\n#\n# * `Product types <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#product-types>`__\n#\n#    * `Table <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#table>`__\n#\n# * `Sum types <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#sum-types>`__\n#\n#    * `UnionArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#unionarray>`__\n#\n# * `Option types <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#option-types>`__\n#\n#    * `MaskedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#maskedarray>`__\n#    * `BitMaskedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#bitmaskedarray>`__\n#    * `IndexedMaskedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#indexedmaskedarray>`__\n#\n# * `Indirection <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#indirection>`__\n#\n#    * `IndexedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#indexedarray>`__\n#    * `SparseArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#sparsearray>`__\n#    * `Helper functions <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#helper-functions-1>`__\n#\n# * `Opaque objects <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#opaque-objects>`__\n#\n#    * `Mix-in Methods <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#mix-in-methods>`__\n#    * `ObjectArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#objectarray>`__\n#    * `StringArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#stringarray>`__\n#\n# * `Non-contiguousness <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#non-contiguousness>`__\n#\n#    * `ChunkedArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#chunkedarray>`__\n#    * `AppendableArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#appendablearray>`__\n#\n# * `Laziness <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#laziness>`__\n#\n#    * `VirtualArray <https://github.com/scikit-hep/awkward-array/blob/master/docs/classes.adoc#virtualarray>`__\n\n# %%markdown\n# ## Mutability\n#\n# Awkward arrays are considered immutable in the sense that elements of the data cannot be modified in-place. That is, assignment with square brackets at an integer index raises an error. Awkward does not prevent the underlying Numpy arrays from being modified in-place, though that can lead to confusing results\xe2\x80\x94the behavior is left undefined. The reason for this omission in functionality is that the internal representation of columnar data structures is more constrained than their non-columnar counterparts: some in-place modification can\'t be defined, and others have surprising side-effects.\n#\n# However, the Python objects representing awkward arrays can be changed in-place. Each class has properties defining its structure, such as ``content``, and these may be replaced at any time. (Replacing properties does not change values in any Numpy arrays.) In fact, this is the only way to build cyclic references: an object in Python must be assigned to a name before that name can be used as a reference.\n#\n# Awkward arrays are appendable, but only through ``AppendableArray``, and ``Table`` columns may be added, changed, or removed. The only use of square-bracket assignment (i.e. ``__setitem__``) is to modify ``Table`` columns.\n#\n# Awkward arrays produced by an external program may grow continuously, as long as more deeply nested arrays are filled first. That is, the ``content`` of a ``JaggedArray`` must be updated before updating its structure arrays (``starts`` and ``stops``). The definitions of awkward array validity allow for nested elements with no references pointing at them (""unreachable"" elements), but not for references pointing to a nested element that doesn\'t exist.\n\n# %%markdown\n# ## Relationship to Arrow\n#\n# `Apache Arrow <https://arrow.apache.org>`__ is a cross-language, columnar memory format for complex data structures. There is intentionally a high degree of overlap between awkward-array and Arrow. But whereas Arrow\'s focus is data portability, awkward\'s focus is computation: it would not be unusual to get data from Arrow, compute something with awkward-array, then return it to another Arrow buffer. For this reason, ``awkward.fromarrow`` is a zero-copy view. Awkward\'s data representation is broader than Arrow\'s, so ``awkward.toarrow`` does, in general, perform a copy.\n#\n# The main difference between awkward-array and Arrow is that awkward-array does not require all arrays to be included within a contiguous memory buffer, though libraries like `pyarrow <https://arrow.apache.org/docs/python>`__ relax this criterion while building a compliant Arrow buffer. This restriction does imply that Arrow cannot encode cross-references or cyclic dependencies.\n#\n# Arrow also doesn\'t have the luxury of relying on Numpy to define its `primitive arrays <https://arrow.apache.org/docs/memory_layout.html#primitive-value-arrays>`__, so it has a fixed endianness, has no regular tensors without expressing it as a jagged array, and requires 32-bit integers for indexing, instead of taking whatever integer type a user provides.\n#\n# `Nullability <https://arrow.apache.org/docs/memory_layout.html#null-bitmaps>`__ is an optional property of every data type in Arrow, but it\'s a structure element in awkward. Similarly, `dictionary encoding <https://arrow.apache.org/docs/memory_layout.html#dictionary-encoding>`__ is built into Arrow as a fundamental property, but it would be built from an ``IndexedArray`` in awkward. Chunking and lazy-loading are supported by readers such as `pyarrow <https://arrow.apache.org/docs/python>`__, but they\'re not part of the Arrow data model.\n#\n# The following list translates awkward-array classes and features to their Arrow counterparts, if possible.\n#\n# * ``JaggedArray``: Arrow\'s `list type <https://arrow.apache.org/docs/memory_layout.html#list-type>`__.\n# * ``Table``: Arrow\'s `struct type <https://arrow.apache.org/docs/memory_layout.html#struct-type>`__, though columns can be added to or removed from awkward ``Tables`` whereas Arrow is strictly immutable.\n# * ``BitMaskedArray``: every data type in Arrow potentially has a `null bitmap <https://arrow.apache.org/docs/memory_layout.html#null-bitmaps>`__, though it\'s an explicit array structure in awkward. (Arrow has no counterpart for Awkward\'s ``MaskedArray`` or ``IndexedMaskedArray``.)\n# * ``UnionArray``: directly equivalent to Arrow\'s `dense union <https://arrow.apache.org/docs/memory_layout.html#dense-union-type>`__. Arrow also has a `sparse union <https://arrow.apache.org/docs/memory_layout.html#sparse-union-type>`__, which awkward-array only has as a ``UnionArray.fromtags`` constructor that builds the dense union on the fly from a sparse union.\n# * ``ObjectArray`` and ``Methods``: no counterpart because Arrow must be usable in any language.\n# * ``StringArray``: ""string"" is a logical type built on top of Arrow\'s `list type <https://arrow.apache.org/docs/memory_layout.html#list-type>`__.\n# * ``IndexedArray``: no counterpart (though its role in building `dictionary encoding <https://arrow.apache.org/docs/memory_layout.html#dictionary-encoding>`__ is built into Arrow as a fundamental property).\n# * ``SparseArray``: no counterpart.\n# * ``ChunkedArray``: no counterpart (though a reader may deal with non-contiguous data).\n# * ``AppendableArray``: no counterpart; Arrow is strictly immutable.\n# * ``VirtualArray``: no counterpart (though a reader may lazily load data).\n\n# %%markdown\n# # High-level operations: common to all classes\n#\n# There are three levels of abstraction in awkward-array: high-level operations for data analysis, low-level operations for engineering the structure of the data, and implementation details. Implementation details are handled in the usual way for Python: if exposed at all, class, method, and function names begin with underscores and are not guaranteed to be stable from one release to the next. There is more than one implementation of awkward: the original awkward library, which depends only on Numpy, awkward-numba, which uses Numba to just-in-time compile its operations, and awkward-cpp, which has precompiled operations. Each has its own implementation details.\n#\n# The distinction between high-level operations and low-level operations is more subtle and developed as awkward-array was put to use. Data analysts care about the logical structure of the data\xe2\x80\x94whether it is jagged, what the column names are, whether certain values could be ``None``, etc. Data engineers (or an analyst in ""engineering mode"") care about contiguousness, how much data are in memory at a given time, whether strings are dictionary-encoded, whether arrays have unreachable elements, etc. The dividing line is between high-level types and low-level array layout (both of which are defined in their own sections below). The following awkward classes have the same high-level type as their content:\n#\n# * ``IndexedArray`` because indirection to type ``T`` has type ``T``,\n# * ``SparseArray`` because a lookup of elements with type ``T`` has type ``T``,\n# * ``ChunkedArray`` because the chunks, which must have the same type as each other, collectively have that type when logically concatenated,\n# * ``AppendableArray`` because it\'s a special case of ``ChunkedArray``,\n# * ``VirtualArray`` because it produces an array of a given type on demand,\n# * ``UnionArray`` has the same type as its ``contents`` *only if* all ``contents`` have the same type as each other.\n#\n# All other classes, such as ``JaggedArray``, have a logically distinct type from their contents.\n#\n# This section describes a suite of operations that are common to all awkward classes. For some high-level types, the operation is meaningless or results in an error, such as the jagged ``counts`` of an array that is not jagged at any level, or the ``columns`` of an array that contains no tables, but the operation has a well-defined action on every array class. To use these operations, you do need to understand the high-level type of your data, but not whether it is wrapped in an ``IndexedArray``, a ``SparseArray``, a ``ChunkedArray``, an ``AppendableArray``, or a ``VirtualArray``.\n\n# %%markdown\n# ## Slicing with square brackets\n#\n# The primary operation for all classes is slicing with square brackets. This is the operation defined by Python\'s ``__getitem__`` method. It is so basic that high-level types are defined in terms of what they return when a scalar argument is passed in square brakets.\n#\n# Just as Numpy\'s slicing reproduces but generalizes Python sequence behavior, awkward-array reproduces (most of) `Numpy\'s slicing behavior <https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html>`__ and generalizes it in certain cases. An integer argument, a single slice argument, a single Numpy array-like of booleans or integers, and a tuple of any of the above is handled just like Numpy. Awkward-array does not handle ellipsis (because the depth of an awkward array can be different on different branches of a ``Table`` or ``UnionArray``) or ``None`` (because it\'s not always possible to insert a ``newaxis``). Numpy `record arrays <https://docs.scipy.org/doc/numpy/user/basics.rec.html>`__ accept a string or sequence of strings as a column argument if it is the only argument, not in a tuple with other types. Awkward-array accepts a string or sequence of strings if it contains a ``Table`` at some level.\n#\n# An integer argument selects one element from the top-level array (starting at zero), changing the type by decreasing rank or jaggedness by one level.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8], [9.9]])\na[0]\n# array([1.1, 2.2, 3.3])\n\n# %%markdown\n# Negative indexes count backward from the last element,\n\n# %%\na[-1]\n# array([9.9])\n\n# %%markdown\n# and the index (after translating negative indexes) must be at least zero and less than the length of the top-level array.\n\n# %%\ntry:\n    a[-6]\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'IndexError\'> index -6 is out of bounds for axis 0 with size 5\n\n# %%markdown\n# A slice selects a range of elements from the top-level array, maintaining the array\'s type. The first index is the inclusive starting point (starting at zero) and the second index is the exclusive endpoint.\n\n# %%\na[2:4]\n# <JaggedArray [[4.4 5.5] [6.6 7.7 8.8]] at 0x7811883f8390>\n\n# %%markdown\n# Python\'s slice syntax (above) or literal ``slice`` objects may be used.\n\n# %%\na[slice(2, 4)]\n# <JaggedArray [[4.4 5.5] [6.6 7.7 8.8]] at 0x7811883f8630>\n\n# %%markdown\n# Negative indexes count backward from the last element and endpoints may be omitted.\n\n# %%\na[-2:]\n# <JaggedArray [[6.6 7.7 8.8] [9.9]] at 0x7811883f8978>\n\n# %%markdown\n# Start and endpoints beyond the array are not errors: they are truncated.\n\n# %%\na[2:100]\n# <JaggedArray [[4.4 5.5] [6.6 7.7 8.8] [9.9]] at 0x7811883f8be0>\n\n# %%markdown\n# A skip value (third index of the slice) sets the stride for indexing, allowing you to skip elements, and this skip can be negative. It cannot, however, be zero.\n\n# %%\na[::-1]\n# <JaggedArray [[9.9] [6.6 7.7 8.8] [4.4 5.5] [] [1.1 2.2 3.3]] at 0x7811883f8ef0>\n\n# %%markdown\n# A Numpy array-like of booleans with the same length as the array may be used to filter elements. Numpy has a specialized `numpy.compress <https://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html>`__ function for this operation, but the only way to get it in awkward-array is through square brackets.\n\n# %%\na[[True, True, False, True, False]]\n# <JaggedArray [[1.1 2.2 3.3] [] [6.6 7.7 8.8]] at 0x781188407278>\n\n# %%markdown\n# A Numpy array-like of integers with the same length as the array may be used to select a collection of indexes. Numpy has a specialized `numpy.take <https://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html>`__ function for this operation, but the only way to get it in awkward-array is through square brakets. Negative indexes and repeated elements are handled in the same way as Numpy.\n\n# %%\na[[-1, 0, 1, 2, 2, 2]]\n# <JaggedArray [[9.9] [1.1 2.2 3.3] [] [4.4 5.5] [4.4 5.5] [4.4 5.5]] at 0x781188407550>\n\n# %%markdown\n# A tuple of length ``N`` applies selections to the first ``N`` levels of rank or jaggedness. Our example array has only two levels, so we can apply two kinds of indexes.\n\n# %%\na[2:, 0]\n# array([4.4, 6.6, 9.9])\n\n# %%\na[[True, False, True, True, False], ::-1]\n# <JaggedArray [[3.3 2.2 1.1] [5.5 4.4] [8.8 7.7 6.6]] at 0x7811884079e8>\n\n# %%\na[[0, 3, 0], 1::]\n# <JaggedArray [[2.2 3.3] [7.7 8.8] [2.2 3.3]] at 0x781188407cc0>\n\n# %%markdown\n# As described in Numpy\'s `advanced indexing <https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing>`__, advanced indexes (boolean or integer arrays) are broadcast and iterated as one:\n\n# %%\na[[0, 3], [True, False, True]]\n# array([1.1, 8.8])\n\n# %%markdown\n# Awkward array has two extensions beyond Numpy, both of which affect only jagged data. If an array is jagged and a jagged array of booleans with the same structure (same length at all levels) is passed in square brackets, only inner arrays would be filtered.\n\n# %%\na    = awkward.fromiter([[  1.1,   2.2,  3.3], [], [ 4.4,  5.5], [ 6.6,  7.7,   8.8], [  9.9]])\nmask = awkward.fromiter([[False, False, True], [], [True, True], [True, True, False], [False]])\na[mask]\n# <JaggedArray [[3.3] [] [4.4 5.5] [6.6 7.7] []] at 0x7811883f8f60>\n\n# %%markdown\n# Similarly, if an array is jagged and a jagged array of integers with the same structure is passed in square brackets, only inner arrays would be filtered/duplicated/rearranged.\n\n# %%\na     = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8], [9.9]])\nindex = awkward.fromiter([[2, 2, 2, 2], [], [1, 0], [2, 1, 0], []])\na[index]\n# <JaggedArray [[3.3 3.3 3.3 3.3] [] [5.5 4.4] [8.8 7.7 6.6] []] at 0x78118847acf8>\n\n# %%markdown\n# Although all of the above use a ``JaggedArray`` as an example, the principles are general: you should get analogous results with jagged tables, masked jagged arrays, etc. Non-jagged arrays only support Numpy-like slicing.\n#\n# If an array contains a ``Table``, it can be selected with a string or a sequence of strings, just like Numpy `record arrays <https://docs.scipy.org/doc/numpy/user/basics.rec.html>`__.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1, ""z"": ""one""}, {""x"": 2, ""y"": 2.2, ""z"": ""two""}, {""x"": 3, ""y"": 3.3, ""z"": ""three""}])\na\n# <Table [<Row 0> <Row 1> <Row 2>] at 0x7811883930f0>\n\n# %%\na[""x""]\n# array([1, 2, 3])\n\n# %%\na[[""z"", ""y""]].tolist()\n# [{\'z\': \'one\', \'y\': 1.1}, {\'z\': \'two\', \'y\': 2.2}, {\'z\': \'three\', \'y\': 3.3}]\n\n# %%markdown\n# Like Numpy, integer indexes and string indexes commute if the integer index corresponds to a structure outside the ``Table`` (this condition is always met for Numpy record arrays).\n\n# %%\na[""y""][1]\n# 2.2\n\n# %%\na[1][""y""]\n# 2.2\n\n# %%\na = awkward.fromiter([[{""x"": 1, ""y"": 1.1, ""z"": ""one""}, {""x"": 2, ""y"": 2.2, ""z"": ""two""}], [], [{""x"": 3, ""y"": 3.3, ""z"": ""three""}]])\na\n# <JaggedArray [[<Row 0> <Row 1>] [] [<Row 2>]] at 0x781188407358>\n\n# %%\na[""y""][0][1]\n# 2.2\n\n# %%\na[0][""y""][1]\n# 2.2\n\n# %%\na[0][1][""y""]\n# 2.2\n\n# %%markdown\n# but not\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": [1.1]}, {""x"": 2, ""y"": [2.1, 2.2]}, {""x"": 3, ""y"": [3.1, 3.2, 3.3]}])\na\n# <Table [<Row 0> <Row 1> <Row 2>] at 0x7811883934a8>\n\n# %%\na[""y""][2][1]\n# 3.2\n\n# %%\na[2][""y""][1]\n# 3.2\n\n# %%\ntry:\n    a[2][1][""y""]\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'AttributeError\'> no column named \'_util_isstringslice\'\n\n# %%markdown\nbecause\n\n# %%\na[2].tolist()\n# {\'x\': 3, \'y\': [3.1, 3.2, 3.3]}\n\n# %%markdown\n# cannot take a ``1`` argument before ``""y""``.\n#\n# Just as integer indexes can be alternated with string/sequence of string indexes, so can slices, arrays, and tuples of slices and arrays.\n\n# %%\na[""y""][:, 0]\n# array([1.1, 2.1, 3.1])\n\n# %%markdown\n# Generally speaking, string and sequence of string indexes are *column* indexes, while all other types are *row* indexes.\n\n# %%markdown\n# ## Assigning with square brackets\n#\n# As discussed above, awkward arrays are generally immutable with few exceptions. Row assignment is only possible via appending to an ``AppendableArray``. Column assignment, reassignment, and deletion are in general allowed. The syntax for assigning and reassigning columns is through assignment to a square bracket expression. This operation is defined by Python\'s ``__setitem__`` method. The syntax for deleting columns is through the ``del`` operators on a square bracket expression. This operation is defined by Python\'s ``__delitem__`` method.\n#\n# Since only columns can be changed, only strings and sequences of strings are allowed as indexes.\n\n# %%\na = awkward.fromiter([[{""x"": 1, ""y"": 1.1, ""z"": ""one""}, {""x"": 2, ""y"": 2.2, ""z"": ""two""}], [], [{""x"": 3, ""y"": 3.3, ""z"": ""three""}]])\na\n# <JaggedArray [[<Row 0> <Row 1>] [] [<Row 2>]] at 0x7811883905c0>\n\n# %%\na[""a""] = awkward.fromiter([[100, 200], [], [300]])\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'one\', \'a\': 100},\n#   {\'x\': 2, \'y\': 2.2, \'z\': \'two\', \'a\': 200}],\n#  [],\n#  [{\'x\': 3, \'y\': 3.3, \'z\': \'three\', \'a\': 300}]]\n\n# %%\ndel a[""a""]\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'one\'}, {\'x\': 2, \'y\': 2.2, \'z\': \'two\'}],\n#  [],\n#  [{\'x\': 3, \'y\': 3.3, \'z\': \'three\'}]]\n\n# %%\na[[""a"", ""b""]] = awkward.fromiter([[{""first"": 100, ""second"": 111}, {""first"": 200, ""second"": 222}], [], [{""first"": 300, ""second"": 333}]])\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'one\', \'a\': 100, \'b\': 111},\n#   {\'x\': 2, \'y\': 2.2, \'z\': \'two\', \'a\': 200, \'b\': 222}],\n#  [],\n#  [{\'x\': 3, \'y\': 3.3, \'z\': \'three\', \'a\': 300, \'b\': 333}]]\n\n# %%markdown\n# Note that the names of the columns on the right-hand side of the assignment are irrelevant; we\'re setting two columns, there needs to be two columns on the right. Columns can be anonymous:\n\n# %%\na[[""a"", ""b""]] = awkward.Table(awkward.fromiter([[100, 200], [], [300]]), awkward.fromiter([[111, 222], [], [333]]))\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'one\', \'a\': 100, \'b\': 111},\n#   {\'x\': 2, \'y\': 2.2, \'z\': \'two\', \'a\': 200, \'b\': 222}],\n#  [],\n#  [{\'x\': 3, \'y\': 3.3, \'z\': \'three\', \'a\': 300, \'b\': 333}]]\n\n# %%markdown\n# Another thing to note is that the structure (lengths at all levels of jaggedness) must match if the depth is the same.\n\n# %%\ntry:\n    a[""c""] = awkward.fromiter([[100, 200, 300], [400], [500, 600]])\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> cannot broadcast JaggedArray to match JaggedArray with a different counts\n\n# %%markdown\n# But if the right-hand side is shallower and can be *broadcasted* to the left-hand side, it will be. (See below for broadcasting.)\n\n# %%\na[""c""] = awkward.fromiter([100, 200, 300])\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'one\', \'a\': 100, \'b\': 111, \'c\': 100},\n#   {\'x\': 2, \'y\': 2.2, \'z\': \'two\', \'a\': 200, \'b\': 222, \'c\': 100}],\n#  [],\n#  [{\'x\': 3, \'y\': 3.3, \'z\': \'three\', \'a\': 300, \'b\': 333, \'c\': 300}]]\n\n# %%markdown\n# ## Numpy-like broadcasting\n#\n# In assignments and mathematical operations between higher-rank and lower-rank arrays, Numpy repeats values in the lower-rank array to ""fit,"" if possible, before applying the operation. This is called `boradcasting <https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>`__. For example,\n\n# %%\nnumpy.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]]) + 100\n# array([[101.1, 102.2, 103.3],\n#        [104.4, 105.5, 106.6]])\n\n# %%markdown\nSingletons are also expanded to fit.\n\n# %%\nnumpy.array([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6]]) + numpy.array([[100], [200]])\n# array([[101.1, 102.2, 103.3],\n#        [204.4, 205.5, 206.6]])\n\n# %%markdown\n# Awkward arrays have the same feature, but this has particularly useful effects for jagged arrays. In an operation involving two arrays of different depths of jaggedness, the shallower one expands to fit the deeper one.\n\n# %%\nawkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]) + awkward.fromiter([100, 200, 300])\n# <JaggedArray [[101.1 102.2 103.3] [] [304.4 305.5]] at 0x781188390940>\n\n# %%markdown\n# Note that the ``100`` was broadcasted to all three of the elements of the first inner array, ``200`` was broadcasted to no elements in the second inner array (because the second inner array is empty), and ``300`` was broadcasted to all two of the elements of the third inner array.\n#\n# This is the columnar equivalent to accessing a variable defined outside of an inner loop.\n\n# %%\njagged = [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\nflat = [100, 200, 300]\nfor i in range(3):\n    for j in range(len(jagged[i])):\n        # j varies in this loop, but i is constant\n        print(i, j, jagged[i][j] + flat[i])\n# 0 0 101.1\n# 0 1 102.2\n# 0 2 103.3\n# 2 0 304.4\n# 2 1 305.5\n\n# %%markdown\n# Many translations of non-columnar code to columnar code has this form. It\'s often surprising to users that they don\'t have to do anything special to get this feature (e.g. ``cross``).\n\n# %%markdown\n# ## Support for Numpy universal functions (ufuncs)\n#\n# Numpy\'s key feature of array-at-a-time programming is mainly provided by ""universal functions"" or ""ufuncs."" This is a special class of function that applies a scalars \xe2\x86\x92 scalar kernel independently to aligned elements of internal arrays to return a same-shape output array. That is, for a scalars \xe2\x86\x92 scalar function ``f(x1, ..., xN) \xe2\x86\x92 y``, the ufunc takes ``N`` input arrays of the same ``shape`` and returns one output array with that ``shape`` in which ``output[i] = f(input1[i], ..., inputN[i])`` for all ``i``.\n\n# %%\n# N = 1\nnumpy.sqrt(numpy.array([1, 4, 9, 16, 25]))\n# array([1., 2., 3., 4., 5.])\n\n# %%\n# N = 2\nnumpy.add(numpy.array([[1.1, 2.2], [3.3, 4.4]]), numpy.array([[100, 200], [300, 400]]))\n# array([[101.1, 202.2],\n#        [303.3, 404.4]])\n\n# %%markdown\n# Keep in mind that a ufunc is not simply a function that has this property, but a specially named class, deriving from a type in the Numpy library.\n\n# %%\nnumpy.sqrt, numpy.add\n# (<ufunc \'sqrt\'>, <ufunc \'add\'>)\n\n# %%\nisinstance(numpy.sqrt, numpy.ufunc), isinstance(numpy.add, numpy.ufunc)\n# (True, True)\n\n# %%markdown\n# This class of functions can be overridden, and awkward-array overrides them to recognize and properly handle awkward arrays.\n\n# %%\nnumpy.sqrt(awkward.fromiter([[1, 4, 9], [], [16, 25]]))\n# <JaggedArray [[1.0 2.0 3.0] [] [4.0 5.0]] at 0x7811883f88d0>\n\n# %%\nnumpy.add(awkward.fromiter([[[1.1], 2.2], [], [3.3, None]]), awkward.fromiter([[[100], 200], [], [None, 300]]))\n# <JaggedArray [[[101.1] 202.2] [] [None None]] at 0x7811883f8d68>\n\n# %%markdown\n# Only the primary action of the ufunc (``ufunc.__call__``) has been overridden; methods like ``ufunc.at``, ``ufunc.reduce``, and ``ufunc.reduceat`` are not supported. Also, the in-place ``out`` parameter is not supported because awkward array data cannot be changed in-place.\n#\n# For awkward arrays, the input arguments to a ufunc must all have the same structure or, if shallower, be broadcastable to the deepest structure. (See above for ""broadcasting."") The scalar function is applied to elements at the same positions within this structure from different input arrays. The output array has this structure, populated by return values of the scalar function.\n#\n# * Rectangular arrays must have the same shape, just as in Numpy. A scalar can be broadcasted (expanded) to have the same shape as the arrays.\n# * Jagged arrays must have the same number of elements in all inner arrays. A rectangular array with the same outer shape (i.e. containing scalars instead of inner arrays) can be broadcasted to inner arrays with the same lengths.\n# * Tables must have the same sets of columns (though not necessarily in the same order). There is no broadcasting of missing columns.\n# * Missing values (``None`` from ``MaskedArrays``) transform to missing values in every ufunc. That is, ``None + 5`` is ``None``, ``None + None`` is ``None``, etc.\n# * Different data types (through a ``UnionArray``) must be compatible at every site where values are included in the calculation. For instance, input arrays may contain tables with different sets of columns, but all inputs at index ``i`` must have the same sets of columns as each other:\n\n# %%\nnumpy.add(awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""y"": 1.1, ""z"": 100}]),\n          awkward.fromiter([{""x"": 3, ""y"": 3.3}, {""y"": 3.3, ""z"": 300}])).tolist()\n# [{\'x\': 4, \'y\': 4.4}, {\'y\': 4.4, \'z\': 400}]\n\n# %%markdown\n# Unary and binary operations on awkward arrays, such as ``-x``, ``x + y``, and ``x**2``, are actually Numpy ufuncs, so all of the above applies to them as well (such as broadcasting the scalar ``2`` in ``x**2``).\n#\n# Remember that only ufuncs have been overridden by awkward-array: other Numpy functions such as ``numpy.concatenate`` are ignorant of awkward arrays and will attempt to convert them to Numpy first. In some cases, that may be what you want, but in many, especially any cases involving jagged arrays, it will be a major performance loss and a loss of functionality: jagged arrays turn into Numpy ``dtype=object`` arrays containing Numpy arrays, which can be a very large number of Python objects and doesn\'t behave as a multidimensional array.\n#\n# You can check to see if a function from Numpy is a ufunc with ``isinstance``.\n\n# %%\nisinstance(numpy.concatenate, numpy.ufunc)\n# False\n\n# %%markdown\n# and you can prevent accidental conversions to Numpy by setting ``allow_tonumpy`` to ``False``, either on one array or globally on a whole class of awkward arrays. (See ""global switches"" below.)\n\n# %%\nx = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\ny = awkward.fromiter([[6.6, 7.7, 8.8], [9.9]])\nnumpy.concatenate([x, y])\n# array([array([1.1, 2.2, 3.3]), array([], dtype=float64),\n#        array([4.4, 5.5]), array([6.6, 7.7, 8.8]), array([9.9])],\n#       dtype=object)\n\n# %%\nx.allow_tonumpy = False\ntry:\n    numpy.concatenate([x, y])\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'RuntimeError\'> awkward.array.base.AwkwardArray.allow_tonumpy is False; refusing to convert to Numpy\n\n# %%markdown\n# ## Global switches\n#\n# The ``AwkwardArray`` abstract base class has the following switches to turn off sometmes-undesirable behavior. These switches could be set on the ``AwkwardArray`` class itself, affecting all awkward arrays, or they could be set on a particular class like ``JaggedArray`` to only affect ``JaggedArray`` instances, or they could be set on a particular instance, to affect only that instance.\n#\n# * ``allow_tonumpy`` (default is ``True``); if ``False``, forbid any action that would convert an awkward array into a Numpy array (with a likely loss of performance and functionality).\n# * ``allow_iter`` (default is ``True``); if ``False``, forbid any action that would iterate over an awkward array in Python (except printing a few elements as part of its string representation).\n# * ``check_prop_valid`` (default is ``True``); if ``False``, skip the single-property validity checks in array constructors and when setting properties.\n# * ``check_whole_valid`` (default is ``True``); if ``False``, skip the whole-array validity checks that are typically called before methods that need them.\n\n# %%\nawkward.AwkwardArray.check_prop_valid\n# True\n\n# %%\nawkward.JaggedArray.check_whole_valid\n# True\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nnumpy.array(a)\n# array([array([1.1, 2.2, 3.3]), array([], dtype=float64),\n#        array([4.4, 5.5])], dtype=object)\n\n# %%\na.allow_tonumpy = False\ntry:\n    numpy.array(a)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'RuntimeError\'> awkward.array.base.AwkwardArray.allow_tonumpy is False; refusing to convert to Numpy\n\n# %%\nlist(a)\n# [array([1.1, 2.2, 3.3]), array([], dtype=float64), array([4.4, 5.5])]\n\n# %%\na.allow_iter = False\ntry:\n    list(a)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'RuntimeError\'> awkward.array.base.AwkwardArray.allow_iter is False; refusing to iterate\n\n# %%\na\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78118847ae10>\n\n# %%markdown\n# ## Generic properties and methods\n#\n# All awkward arrays have the following properties and methods.\n\n# %%markdown\n# * ``type``: the high-level type of the array. (See below for a detailed description of high-level types.)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                      [4.4, [5.5]],\n                      [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                     ])\n\n# %%\na.type\n# ArrayType(3, inf, dtype(\'float64\'))\n\n# %%\nprint(a.type)\n# [0, 3) -> [0, inf) -> float64\n\n# %%\nb.type\n# ArrayType(3, inf, OptionType(UnionType(dtype(\'float64\'), ArrayType(inf, dtype(\'float64\')), TableType(x=dtype(\'int64\'), y=TableType(z=dtype(\'int64\'))))))\n\n# %%\nprint(b.type)\n# [0, 3) -> [0, inf) -> ?((float64             |\n#                          [0, inf) -> float64 |\n#                          \'x\' -> int64\n#                          \'y\' -> \'z\' -> int64 ))\n\n# %%markdown\n# * ``layout``: the low-level layout of the array. (See below for a detailed description of low-level layouts.)\n\n# %%\na.layout\n#  layout\n# [    ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])\n# [     0]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     1]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     2]   ndarray(shape=5, dtype=dtype(\'float64\'))\n\n# %%\nb.layout\n#  layout\n# [           ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])\n# [            0]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [            1]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [            2]   IndexedMaskedArray(mask=layout[2, 0], content=layout[2, 1], maskedwhen=-1)\n# [         2, 0]     ndarray(shape=10, dtype=dtype(\'int64\'))\n# [         2, 1]     UnionArray(tags=layout[2, 1, 0], index=layout[2, 1, 1], contents=[layout[2, 1, 2], layout[2, 1, 3], layout[2, 1, 4]])\n# [      2, 1, 0]       ndarray(shape=7, dtype=dtype(\'uint8\'))\n# [      2, 1, 1]       ndarray(shape=7, dtype=dtype(\'int64\'))\n# [      2, 1, 2]       ndarray(shape=4, dtype=dtype(\'float64\'))\n# [      2, 1, 3]       JaggedArray(starts=layout[2, 1, 3, 0], stops=layout[2, 1, 3, 1], content=layout[2, 1, 3, 2])\n# [   2, 1, 3, 0]         ndarray(shape=1, dtype=dtype(\'int64\'))\n# [   2, 1, 3, 1]         ndarray(shape=1, dtype=dtype(\'int64\'))\n# [   2, 1, 3, 2]         ndarray(shape=1, dtype=dtype(\'float64\'))\n# [      2, 1, 4]       Table(x=layout[2, 1, 4, 0], y=layout[2, 1, 4, 1])\n# [   2, 1, 4, 0]         ndarray(shape=2, dtype=dtype(\'int64\'))\n# [   2, 1, 4, 1]         Table(z=layout[2, 1, 4, 1, 0])\n# [2, 1, 4, 1, 0]           ndarray(shape=2, dtype=dtype(\'int64\'))\n\n# %%markdown\n# * ``dtype``: the `Numpy dtype <https://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html>`__ that this array would have if cast as a Numpy array. Numpy dtypes cannot fully specify awkward arrays: use the ``type`` for an analyst-friendly description of the data type or ``layout`` for details about how the arrays are represented.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na.dtype   # the closest Numpy dtype to a jagged array is dtype=object (\'O\')\n# dtype(\'O\')\n\n# %%\nnumpy.array(a)\n# array([array([1.1, 2.2, 3.3]), array([], dtype=float64),\n#        array([4.4, 5.5])], dtype=object)\n\n# %%markdown\n# * ``shape``: the `Numpy shape <https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.shape.html>`__ that this array would have if cast as a Numpy array. This only specifies the first regular dimensions, not any jagged dimensions or regular dimensions nested within awkward structures. The Python length (``__len__``) of the array is the first element of this ``shape``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na.shape\n# (3,)\n\n# %%\nlen(a)\n# 3\n\n# %%markdown\n# The following ``JaggedArray`` has two fixed-size dimensions at the top, followed by a jagged dimension inside of that. The shape only represents the first few dimensions.\n\n# %%\na = awkward.JaggedArray.fromcounts([[3, 0], [2, 4]], [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\na\n# <JaggedArray [[[1.1 2.2 3.3] []] [[4.4 5.5] [6.6 7.7 8.8 9.9]]] at 0x7811883bc0b8>\n\n# %%\na.shape\n# (2, 2)\n\n# %%\nlen(a)\n# 2\n\n# %%\nprint(a.type)\n# [0, 2) -> [0, 2) -> [0, inf) -> float64\n\n# %%markdown\n# Also, a dimension can effectively be fixed-size, but represented by a ``JaggedArray``. The ``shape`` does not encompass any dimensions represented by a ``JaggedArray``.\n\n# %%\n# Same structure, but it\'s JaggedArrays all the way down.\nb = a.structure1d()\nb\n# <JaggedArray [[[1.1 2.2 3.3] []] [[4.4 5.5] [6.6 7.7 8.8 9.9]]] at 0x781188407240>\n\n# %%\nb.shape\n# (2,)\n\n# %%markdown\n# * ``size``: the product of ``shape``, as in Numpy.\n\n# %%\na.shape\n# (2, 2)\n\n# %%\na.size\n# 4\n\n# %%markdown\n# * ``nbytes``: the total number of bytes in all memory buffers referenced by the array, not including bytes in Python objects (which are Python-implementation dependent, not even available in PyPy). Same as the Numpy property of the same name.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na.nbytes\n# 72\n\n# %%\na.offsets.nbytes + a.content.nbytes\n# 72\n\n# %%markdown\n# * ``tolist()``: converts the array into Python objects: ``lists`` for arrays, ``dicts`` for table rows, ``tuples`` for table rows with anonymous fields and a ``rowname`` of ``""tuple""``, ``None`` for missing data, and Python objects from ``ObjectArrays``. This is an approximate inverse of ``awkward.fromiter``.\n\n# %%\nawkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]).tolist()\n# [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n\n# %%\nawkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]).tolist()\n# [{\'x\': 1, \'y\': 1.1}, {\'x\': 2, \'y\': 2.2}, {\'x\': 3, \'y\': 3.3}]\n\n# %%\nawkward.Table.named(""tuple"", [1, 2, 3], [1.1, 2.2, 3.3]).tolist()\n# [(1, 1.1), (2, 2.2), (3, 3.3)]\n\n# %%\nawkward.fromiter([[1.1, 2.2, None], [], [None, 3.3]]).tolist()\n# [[1.1, 2.2, None], [], [None, 3.3]]\n\n# %%\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __repr__(self):\n        return f""Point({self.x}, {self.y})""\n\na = awkward.fromiter([[Point(1, 1.1), Point(2, 2.2), Point(3, 3.3)], [], [Point(4, 4.4), Point(5, 5.5)]])\na\n# <JaggedArray [[Point(1, 1.1) Point(2, 2.2) Point(3, 3.3)] [] [Point(4, 4.4) Point(5, 5.5)]] at 0x7811883bccf8>\n\n# %%\na.tolist()\n# [[Point(1, 1.1), Point(2, 2.2), Point(3, 3.3)],\n#  [],\n#  [Point(4, 4.4), Point(5, 5.5)]]\n\n# %%markdown\n# * ``valid(exception=False, message=False)``: manually invoke the whole-array validity checks on the top-level array (not recursively). With the default options, this function returns ``True`` if valid and ``False`` if not. If ``exception=True``, it returns nothing on success and raises the appropriate exception on failure. If ``message=True``, it returns ``None`` on success and the error string on failure. (TODO: ``recursive=True``?)\n\n# %%\na = awkward.JaggedArray.fromcounts([3, 0, 2], [1.1, 2.2, 3.3, 4.4])  # content array is too short\na.valid()\n# False\n\n# %%\ntry:\n    a.valid(exception=True)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> maximum offset 5 is beyond the length of the content (4)\n\n# %%\na.valid(message=True)\n# ""<class \'ValueError\'>: maximum offset 5 is beyond the length of the content (4)""\n\n# %%markdown\n# * ``astype(dtype)``: convert *nested Numpy arrays* into the given type while maintaining awkward structure.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na.astype(numpy.int32)\n# <JaggedArray [[1 2 3] [] [4 5]] at 0x7811883b9898>\n\n# %%markdown\n# * ``regular()``: convert the awkward array into a Numpy array and (unlike ``numpy.array(awkward_array)``) raise an error if it cannot be faithfully represented.\n\n# %%\n# This JaggedArray happens to have equal-sized inner arrays.\na = awkward.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]])\na\n# <JaggedArray [[1.1 2.2 3.3] [4.4 5.5 6.6] [7.7 8.8 9.9]] at 0x781188390240>\n\n# %%\na.regular()\n# array([[1.1, 2.2, 3.3],\n#        [4.4, 5.5, 6.6],\n#        [7.7, 8.8, 9.9]])\n\n# %%\n# This one does not.\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x7811883b9c18>\n\n# %%\ntry:\n    a.regular()\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> jagged array is not regular: different elements have different counts\n\n# %%markdown\n# * ``copy(optional constructor arguments...)``: copy an awkward array object, non-recursively and without copying memory buffers, possibly replacing some of its parameters. If the class is an awkward subclass or has mix-in methods, they are propagated to the copy.\n\n# %%\nclass Special:\n    def get(self, index):\n        try:\n            return self[index]\n        except IndexError:\n            return None\n\nJaggedArrayMethods = awkward.Methods.mixin(Special, awkward.JaggedArray)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\na.__class__ = JaggedArrayMethods\na\n# <JaggedArrayMethods [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x7811883bc2b0>\n\n# %%\na.get(2)\n# array([4.4, 5.5])\n\n# %%\na.get(3)\n\n# %%\nb = a.copy(content=[100, 200, 300, 400, 500])\nb\n# <JaggedArrayMethods [[100 200 300] [] [400 500]] at 0x7811883c5908>\n\n# %%\nb.get(2)\n# array([400, 500])\n\n# %%\nb.get(3)\n\n# %%markdown\n# Internally, all the methods that return views of the array (like slicing) use ``copy`` to retain the special methods.\n\n# %%\nc = a[1:]\nc\n# <JaggedArrayMethods [[] [4.4 5.5]] at 0x7811883c5be0>\n\n# %%\nc.get(1)\n# array([4.4, 5.5])\n\n# %%\nc.get(2)\n\n# %%markdown\n# * ``deepcopy(optional constructor arguments...)``: like ``copy``, except that it recursively copies all internal structure, including memory buffers associated with Numpy arrays.\n\n# %%\nb = a.deepcopy(content=[100, 200, 300, 400, 500])\nb\n# <JaggedArrayMethods [[100 200 300] [] [400 500]] at 0x781188355748>\n\n# %%\n# Modify the structure of a (not recommended; this is a demo).\na.starts[0] = 1\na\n# <JaggedArrayMethods [[2.2 3.3] [] [4.4 5.5]] at 0x7811883bc2b0>\n\n# %%\n# But b is not modified. (If it were, it would start with 200.)\nb\n# <JaggedArrayMethods [[100 200 300] [] [400 500]] at 0x781188355748>\n\n# %%markdown\n# * ``empty_like(optional constructor arguments...)``\n# * ``zeros_like(optional constructor arguments...)``\n# * ``ones_like(optional constructor arguments...)``: recursively copies structure, replacing contents with new uninitialized buffers, new buffers full of zeros, or new buffers full of ones. Not usually used in analysis, but needed for implementation.\n\n# %%\nd = a.zeros_like()\nd\n# <JaggedArrayMethods [[0.0 0.0] [] [0.0 0.0]] at 0x7811883c59b0>\n\n# %%\ne = a.ones_like()\ne\n# <JaggedArrayMethods [[1.0 1.0] [] [1.0 1.0]] at 0x78118847a2b0>\n\n# %%markdown\n# ## Reducers\n#\n# All awkward arrays also have a complete set of reducer methods. Reducers can be found in Numpy as well (as array methods and as free-standing functions), but they\'re not called out as a special class the way that universal functions (""ufuncs"") are. Reducers decrease the rank or jaggedness of an array by one dimension, replacing subarrays with scalars. Examples include ``sum``, ``min``, and ``max``, but any monoid (associative operation with an identity) can be a reducer.\n#\n# In awkward-array, reducers are only array methods (not free-standing functions) and unlike Numpy, they do not take an ``axis`` parameter. When a reducer is called at any level, it reduces the innermost dimension. (Since outer dimensions can be jagged, this is the only dimension that can be meaningfully reduced.)\n\n# %%\na = awkward.fromiter([[[[1, 2], [3]], [[4, 5]]], [[[], [6, 7, 8, 9]]]])\na\n# <JaggedArray [[[[1 2] [3]] [[4 5]]] [[[] [6 7 8 9]]]] at 0x7811883b9470>\n\n# %%\na.sum()\n# <JaggedArray [[[3 3] [9]] [[0 30]]] at 0x7811883bc4a8>\n\n# %%\na.sum().sum()\n# <JaggedArray [[6 9] [30]] at 0x7811883bc048>\n\n# %%\na.sum().sum().sum()\n# array([15, 30])\n\n# %%\na.sum().sum().sum().sum()\n# 45\n\n# %%markdown\n# In the following example, ""the deepest axis"" of different fields in the table are at different depths: singly jagged in ``""x""`` and doubly jagged array in ``""y""``. The ``sum`` reduces each depth by one, producing a flat array ``""x""`` and a singly jagged array in ``""y""``.\n\n# %%\na = awkward.fromiter([{""x"": [], ""y"": [[0.1, 0.2], [], [0.3]]}, {""x"": [1, 2, 3], ""y"": [[0.4], [], [0.5, 0.6]]}])\na.tolist()\n# [{\'x\': [], \'y\': [[0.1, 0.2], [], [0.3]]},\n#  {\'x\': [1, 2, 3], \'y\': [[0.4], [], [0.5, 0.6]]}]\n\n# %%\na.sum().tolist()\n[{\'x\': 0, \'y\': [0.3, 0.0, 0.3]},\n {\'x\': 6, \'y\': [0.4, 0.0, 1.1]}]\n\n# %%markdown\n# This sum cannot be reduced again because ``""x""`` is not jagged (would reduce to a scalar) and ``""y""`` is (would reduce to an array). The result cannot be scalar in one field (a single row, not a collection) and an array in another field (a collection).\n\n# %%\ntry:\n    a.sum().sum()\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> some Table columns are jagged and others are not\n\n# %%markdown\n# A table can be reduced if all of its fields are jagged or if all of its fields are not jagged; here\'s an example of the latter.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}])\na.tolist()\n# [{\'x\': 1, \'y\': 1.1}, {\'x\': 2, \'y\': 2.2}, {\'x\': 3, \'y\': 3.3}]\n\n# %%\na.sum()\n# <sum {\'x\': 6, \'y\': 6.6}>\n\n# %%markdown\n# The resulting object is a scalar row\xe2\x80\x94for your convenience, it has been labeled with the reducer that produced it.\n\n# %%\nisinstance(a.sum(), awkward.Table.Row)\n# True\n\n# %%markdown\n# ``UnionArrays`` are even more constrained: they can only be reduced if they have primitive (Numpy) type.\n\n# %%\na = awkward.fromiter([1, 2, 3, {""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}])\na\n# <UnionArray [1 2 3 <Row 0> <Row 1>] at 0x781188355550>\n\n# %%\ntry:\n    a.sum()\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'TypeError\'> cannot reduce a UnionArray of non-primitive type\n\n# %%\na = awkward.UnionArray.fromtags([0, 0, 0, 1, 1],\n                                [numpy.array([1, 2, 3], dtype=numpy.int32),\n                                 numpy.array([4, 5], dtype=numpy.float64)])\na\n# <UnionArray [1 2 3 4.0 5.0] at 0x781188355da0>\n\n# %%\na.sum()\n# 15.0\n\n# %%markdown\n# In all reducers, ``NaN`` in floating-point arrays and ``None`` in ``MaskedArrays`` are skipped, so these reducers are more like ``numpy.nansum``, ``numpy.nanmax``, and ``numpy.nanmin``, but generalized to all nullable types.\n\n# %%\na = awkward.fromiter([[[[1.1, numpy.nan], [2.2]], [[None, 3.3]]], [[[], [None, numpy.nan, None]]]])\na\n# <JaggedArray [[[[1.1 nan] [2.2]] [[None 3.3]]] [[[] [None nan None]]]] at 0x78118835c7b8>\n\n# %%\na.sum()\n# <JaggedArray [[[1.1 2.2] [3.3]] [[0.0 0.0]]] at 0x781188355a20>\n\n# %%\na = awkward.fromiter([[{""x"": 1, ""y"": 1.1}, None, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": numpy.nan}]])\na.tolist()\n# [[{\'x\': 1, \'y\': 1.1}, None, {\'x\': 3, \'y\': 3.3}], [], [{\'x\': 4, \'y\': nan}]]\n\n# %%\na.sum().tolist()\n# [{\'x\': 4, \'y\': 4.4}, {\'x\': 0, \'y\': 0.0}, {\'x\': 4, \'y\': 0.0}]\n\n# %%markdown\n# The following reducers are defined as methods on all awkward arrays.\n\n# %%markdown\n# * ``reduce(ufunc, identity)``: generic reducer, calls ``ufunc.reduceat`` and returns ``identity`` for empty arrays.\n\n# %%\n# numba.vectorize makes new ufuncs (requires type signatures and a kernel function)\nimport numba\n@numba.vectorize([numba.int64(numba.int64, numba.int64)])\ndef sum_mod_10(x, y):\n    return (x + y) % 10\n\n# %%\na = awkward.fromiter([[1, 2, 3], [], [4, 5, 6], [7, 8, 9, 10]])\na.sum()\n# array([ 6,  0, 15, 34])\n\n# %%\na.reduce(sum_mod_10, 0)\n# array([6, 0, 5, 4])\n\n# %%\n# Missing (None) values are ignored.\na = awkward.fromiter([[1, 2, None, 3], [], [None, None, None], [7, 8, 9, 10]])\na.reduce(sum_mod_10, 0)\n# array([6, 0, 0, 4])\n\n# %%markdown\n# * ``any()``: boolean reducer, returns ``True`` if any (logical or) of the elements of an array are ``True``, returns ``False`` for empty arrays.\n\n# %%\na = awkward.fromiter([[False, False], [True, True], [True, False], []])\na.any()\n# array([False,  True,  True, False])\n\n# %%\n# Missing (None) values are ignored.\na = awkward.fromiter([[False, None], [True, None], [None]])\na.any()\n# array([False,  True, False])\n\n# %%markdown\n# * ``all()``: boolean reducer, returns ``True`` if all (logical and) of the elements of an array are ``True``, returns ``True`` for empty arrays.\n\n# %%\na = awkward.fromiter([[False, False], [True, True], [True, False], []])\na.all()\n# array([False,  True, False,  True])\n\n# %%\n# Missing (None) values are ignored.\na = awkward.fromiter([[False, None], [True, None], [None]])\na.all()\n# array([False,  True,  True])\n\n# %%markdown\n# * ``count()``: returns the (integer) number of elements in an array, skipping ``None`` and ``NaN``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None], [], [3.3, numpy.nan]])\na.count()\n# array([2, 0, 1])\n\n# %%markdown\n# * ``count_nonzero()``: returns the (integer) number of non-zero elements in an array, skipping ``None`` and ``NaN``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None, 0], [], [3.3, numpy.nan, 0]])\na.count_nonzero()\n# array([2, 0, 1])\n\n# %%markdown\n# * ``sum()``: returns the sum of each array, skipping ``None`` and ``NaN``, returning 0 for empty arrays.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None], [], [3.3, numpy.nan]])\na.sum()\n# array([3.3, 0. , 3.3])\n\n# %%markdown\n# * ``prod()``: returns the product (multiplication) of each array, skipping ``None`` and ``NaN``, returning 1 for empty arrays.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None], [], [3.3, numpy.nan]])\na.prod()\n# array([2.42, 1.  , 3.3 ])\n\n# %%markdown\n# * ``min()``: returns the minimum number in each array, skipping ``None`` and ``NaN``, returning infinity or the largest possible integer for empty arrays. (Note that Numpy raises errors for empty arrays.)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None], [], [3.3, numpy.nan]])\na.min()\n# array([1.1, inf, 3.3])\n\n# %%\na = awkward.fromiter([[1, 2, None], [], [3]])\na.min()\n# array([                  1, 9223372036854775807,                   3])\n\n# %%markdown\n# The identity of minimization is ``inf`` for floating-point values and ``9223372036854775807`` for ``int64`` because minimization with any other value would return the other value. This is more convenient for data analysts than raising an error because empty inner arrays are common.\n\n# %%markdown\n# * ``max()``: returns the maximum number in each array, skipping ``None`` and ``NaN``, returning negative infinity or the smallest possible integer for empty arrays. (Note that Numpy raises errors for empty arrays.)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None], [], [3.3, numpy.nan]])\na.max()\n# array([ 2.2, -inf,  3.3])\n\n# %%\na = awkward.fromiter([[1, 2, None], [], [3]])\na.max()\n# array([                   2, -9223372036854775808,                    3])\n\n# %%markdown\n# The identity of maximization is ``-inf`` for floating-point values and ``-9223372036854775808`` for ``int64`` because maximization with any other value would return the other value. This is more convenient for data analysts than raising an error because empty inner arrays are common.\n#\n# Note that the maximization-identity for unsigned types is ``0``.\n\n# %%\na = awkward.JaggedArray.fromcounts([3, 0, 2], numpy.array([1.1, 2.2, 3.3, 4.4, 5.5], dtype=numpy.uint16))\na\n# <JaggedArray [[1 2 3] [] [4 5]] at 0x78112c0e9a58>\n\n# %%\na.max()\n# array([3, 0, 5], dtype=uint16)\n\n# %%markdown\n# Functions like mean and standard deviation aren\'t true reducers because they\'re not associative (``mean(mean(x1, x2, x3), mean(x4, x5))`` is not equal to ``mean(mean(x1, x2), mean(x3, x4, x5))``). However, they\'re useful methods that exist on all awkward arrays, defined in terms of reducers.\n\n# %%markdown\n# * ``moment(n, weight=None)``: returns the ``n``th moment of each array (a floating-point value), skipping ``None`` and ``NaN``, returning ``NaN`` for empty arrays. If ``weight`` is given, it is taken as an array of weights, which may have the same structure as the ``array`` or be broadcastable to it, though any broadcasted weights would have no effect on the moment.\n\n# %%\na = awkward.fromiter([[1, 2, 3], [], [4, 5]])\n\n# %%\na.moment(1)\n# array([2. , nan, 4.5])\n\n# %%\na.moment(2)\n# array([ 4.66666667,         nan, 20.5       ])\n\n# %%markdown\n# Here is the first moment (mean) with a weight broadcasted from a scalar and from a non-jagged array, to show how it doesn\'t affect the result. The moment is calculated over an inner array, so if a constant value is broadcasted to all elements of that inner array, they all get the same weight.\n\n# %%\na.moment(1)\n# array([2. , nan, 4.5])\n\n# %%\na.moment(1, 100)\n# array([2. , nan, 4.5])\n\n# %%\na.moment(1, numpy.array([100, 200, 300]))\n# array([2. , nan, 4.5])\n\n# %%markdown\n# Only when the weight varies across an inner array does it have an effect.\n\n# %%\na.moment(1, awkward.fromiter([[1, 10, 100], [], [0, 100]]))\n# array([2.89189189,        nan, 5.        ])\n\n# %%markdown\n# * ``mean(weight=None)``: returns the mean of each array (a floating-point value), skipping ``None`` and ``NaN``, returning ``NaN`` for empty arrays, using optional ``weight`` as above.\n\n# %%\na = awkward.fromiter([[1, 2, 3], [], [4, 5]])\na.mean()\n# array([2. , nan, 4.5])\n\n# %%markdown\n# * ``var(weight=None, ddof=0)``: returns the variance of each array (a floating-point value), skipping ``None`` and ``NaN``, returning ``NaN`` for empty arrays, using optional ``weight`` as above. The ``ddof`` or ""Delta Degrees of Freedom"" replaces a divisor of ``N`` (count or sum of weights) with a divisor of ``N - ddof``, following `numpy.var <https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html>`__.\n\n# %%\na = awkward.fromiter([[1, 2, 3], [], [4, 5]])\na.var()\n# array([0.66666667,        nan, 0.25      ])\n\n# %%\na.var(ddof=1)\n# array([1. , nan, 0.5])\n\n# %%markdown\n# * ``std(weight=None, ddof=0)``: returns the standard deviation of each array, the square root of the variance described above.\n\n# %%\na.std()\n# array([0.81649658,        nan, 0.5       ])\n\n# %%\na.std(ddof=1)\n# array([1.        ,        nan, 0.70710678])\n\n# %%markdown\n# ## Properties and methods for jaggedness\n#\n# All awkward arrays have these methods, but they provide information about the first nested ``JaggedArray`` within a structure. If, for instance, the ``JaggedArray`` is within some structure that doesn\'t affect high-level type (e.g. ``IndexedArray``, ``ChunkedArray``, ``VirtualArray``), then the methods are passed through to the ``JaggedArray``. If it\'s nested within something that does change type, but can meaningfully pass on the call, such as ``MaskedArray``, then that\'s what they do. If, however, it reaches a ``Table``, which may have some jagged columns and some non-jagged columns, the propagation stops.\n#\n# * ``counts``: Numpy array of the number of elements in each inner array of the shallowest ``JaggedArray``. The ``counts`` may have rank > 1 if there are any fixed-size dimensions before the ``JaggedArray``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\na.counts\n# array([3, 0, 2, 4])\n\n# %%\n# MaskedArrays return -1 for missing values.\na = awkward.fromiter([[1.1, 2.2, 3.3], [], None, [6.6, 7.7, 8.8, 9.9]])\na.counts\n# array([ 3,  0, -1,  4])\n\n# %%markdown\n# A missing inner array (counts is ``-1``) is distinct from an empty inner array (counts is ``0``), but if you want to ensure that you\'re working with data that have at least ``N`` elements, ``counts >= N`` works.\n\n# %%\na.counts >= 1\n# array([ True, False, False,  True])\n\n# %%\na[a.counts >= 1]\n# <MaskedArray [[1.1 2.2 3.3] [6.6 7.7 8.8 9.9]] at 0x78112c0d54a8>\n\n# %%\n# UnionArrays return -1 for non-jagged arrays mixed with jagged arrays.\na = awkward.fromiter([[1.1, 2.2, 3.3], [], 999, [6.6, 7.7, 8.8, 9.9]])\na.counts\n# array([ 3,  0, -1,  4])\n\n# %%\n# Same for tabular data, regardless of whether they contain nested jagged arrays.\na = awkward.fromiter([[1.1, 2.2, 3.3], [], {""x"": 1, ""y"": [1.1, 1.2, 1.3]}, [6.6, 7.7, 8.8, 9.9]])\na.counts\n# array([ 3,  0, -1,  4])\n\n# %%markdown\n# Note! This means that pure ``Tables`` will always return zeros for counts, regardless of what they contain.\n\n# %%\na = awkward.fromiter([{""x"": [], ""y"": []}, {""x"": [1], ""y"": [1.1]}, {""x"": [1, 2], ""y"": [1.1, 2.2]}])\na.counts\n# array([-1, -1, -1])\n\n# %%markdown\n# If all of the columns of a ``Table`` are ``JaggedArrays`` with the same structure, you probably want to zip them into a single ``JaggedArray``.\n\n# %%\nb = awkward.JaggedArray.zip(x=a.x, y=a.y)\nb\n# <JaggedArray [[] [<Row 0>] [<Row 1> <Row 2>]] at 0x78112c0dc7f0>\n\n# %%\nb.counts\n# array([0, 1, 2])\n\n# %%markdown\n# * ``flatten(axis=0)``: removes one level of structure (losing information about boundaries between inner arrays) at a depth of jaggedness given by ``axis``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\na.flatten()\n# array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n\n# %%markdown\n# Unlike a ``JaggedArray``\'s ``content``, which is part of its low-level layout, ``flatten()`` performs a high-level logical operation. Here\'s an example of the distinction.\n\n# %%\n# JaggedArray with an unusual but valid structure.\na = awkward.JaggedArray([3, 100, 0, 6], [6, 100, 2, 10],\n                        [4.4, 5.5, 999, 1.1, 2.2, 3.3, 6.6, 7.7, 8.8, 9.9, 123])\na\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5] [6.6 7.7 8.8 9.9]] at 0x78112c127cf8>\n\n# %%\na.flatten()   # gives you a logically flattened array\n# array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n\n# %%\na.content     # gives you an internal structure component of the array\n# array([  4.4,   5.5, 999. ,   1.1,   2.2,   3.3,   6.6,   7.7,   8.8,\n#          9.9, 123. ])\n\n# %%markdown\n# In many cases, the output of ``flatten()`` corresponds to the output of ``content``, but be aware of the difference and use the one you want.\n#\n# With ``flatten(axis=1)``, we can internally flatten nested ``JaggedArrays``.\n\n# %%\na = awkward.fromiter([[[1.1, 2.2], [3.3]], [], [[4.4, 5.5]], [[6.6, 7.7, 8.8], [], [9.9]]])\na\n# <JaggedArray [[[1.1 2.2] [3.3]] [] [[4.4 5.5]] [[6.6 7.7 8.8] [] [9.9]]] at 0x78112c127208>\n\n# %%\na.flatten(axis=0)\n# <JaggedArray [[1.1 2.2] [3.3] [4.4 5.5] [6.6 7.7 8.8] [] [9.9]] at 0x78112c1276a0>\n\n# %%\na.flatten(axis=1)\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5] [6.6 7.7 8.8 9.9]] at 0x78112c127320>\n\n# %%markdown\n# Even if a ``JaggedArray``\'s inner structure is due to a fixed-shape Numpy array, the ``axis`` parameter propagates down and does the right thing.\n\n# %%\na = awkward.JaggedArray.fromcounts(numpy.array([3, 0, 2]),\n                                   numpy.array([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5]]))\na\n# <JaggedArray [[[1 1] [2 2] [3 3]] [] [[4 4] [5 5]]] at 0x78112c0d5ac8>\n\n# %%\ntype(a.content)\n# numpy.ndarray\n\n# %%\na.flatten(axis=1)\n# <JaggedArray [[1 1 2 2 3 3] [] [4 4 5 5]] at 0x78112c0d5a20>\n\n# %%markdown\n# But, unlike Numpy, we can\'t ask for an ``axis`` starting from the other end (with a negative index). The ""deepest array"" is not a well-defined concept for awkward arrays.\n\n# %%\ntry:\n    a.flatten(axis=-1)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'TypeError\'> axis must be a non-negative integer (can\'t count from the end)\n\n# %%\na = awkward.fromiter([[[1.1, 2.2], [3.3]], [], None, [[6.6, 7.7, 8.8], [], [9.9]]])\na\n# <MaskedArray [[[1.1 2.2] [3.3]] [] None [[6.6 7.7 8.8] [] [9.9]]] at 0x78112c0d51d0>\n\n# %%\na.flatten(axis=1)\n# <JaggedArray [[1.1 2.2 3.3] [] [6.6 7.7 8.8 9.9]] at 0x78112c0dcfd0>\n\n# %%markdown\n# * ``pad(length, maskedwhen=True, clip=False)``: ensures that each inner array has at least ``length`` elements by filling in the empty spaces with ``None`` (i.e. by inserting a ``MaskedArray`` layer). The ``maskedwhen`` parameter determines whether ``mask[i] == True`` means the element is ``None`` (``maskedwhen=True``) or not ``None`` (``maskedwhen=False``). Setting ``maskedwhen`` doesn\'t change the logical meaning of the array. If ``clip=True``, then the inner arrays will have exactly ``length`` elements (by clipping the ones that are too long). Even though this results in regular sizes, they are still represented by a ``JaggedArray``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\na\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5] [6.6 7.7 8.8 9.9]] at 0x78112c127be0>\n\n# %%\na.pad(3)\n# <JaggedArray [[1.1 2.2 3.3] [None None None] [4.4 5.5 None] [6.6 7.7 8.8 9.9]] at 0x78112c122588>\n\n# %%\na.pad(3, maskedwhen=False)\n# <JaggedArray [[1.1 2.2 3.3] [None None None] [4.4 5.5 None] [6.6 7.7 8.8 9.9]] at 0x78112c122c18>\n\n# %%\na.pad(3, clip=True)\n# <JaggedArray [[1.1 2.2 3.3] [None None None] [4.4 5.5 None] [6.6 7.7 8.8]] at 0x78112c127940>\n\n# %%markdown\n# If you want to get rid of the ``MaskedArray`` layer, replace ``None`` with some value.\n\n# %%\na.pad(3).fillna(-999)\n# <JaggedArray [[1.1 2.2 3.3] [-999.0 -999.0 -999.0] [4.4 5.5 -999.0] [6.6 7.7 8.8 9.9]] at 0x78112c0dc0b8>\n\n# %%markdown\n# If you want to make an effectively regular array into a real Numpy array, use ``regular``.\n\n# %%\na.pad(3, clip=True).fillna(0).regular()\n# array([[1.1, 2.2, 3.3],\n#        [0. , 0. , 0. ],\n#        [4.4, 5.5, 0. ],\n#        [6.6, 7.7, 8.8]])\n\n# %%markdown\n# If a ``JaggedArray`` is nested within some other type, ``pad`` will propagate down to it.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], None, [4.4, 5.5], None])\na\n# <MaskedArray [[1.1 2.2 3.3] [] None [4.4 5.5] None] at 0x78112c0d52b0>\n\n# %%\na.pad(3)\n# <MaskedArray [[1.1 2.2 3.3] [None None None] None [4.4 5.5 None] None] at 0x78112c0e9908>\n\n# %%\na = awkward.Table(x=[[1, 1], [2, 2], [3, 3], [4, 4]],\n                  y=awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]]))\na.tolist()\n# [{\'x\': [1, 1], \'y\': [1.1, 2.2, 3.3]},\n#  {\'x\': [2, 2], \'y\': []},\n#  {\'x\': [3, 3], \'y\': [4.4, 5.5]},\n#  {\'x\': [4, 4], \'y\': [6.6, 7.7, 8.8, 9.9]}]\n\n# %%\na.pad(3).tolist()\n# [{\'x\': [1, 1, None], \'y\': [1.1, 2.2, 3.3]},\n#  {\'x\': [2, 2, None], \'y\': [None, None, None]},\n#  {\'x\': [3, 3, None], \'y\': [4.4, 5.5, None]},\n#  {\'x\': [4, 4, None], \'y\': [6.6, 7.7, 8.8, 9.9]}]\n\n# %%\na.pad(3, clip=True).tolist()\n# [{\'x\': [1, 1, None], \'y\': [1.1, 2.2, 3.3]},\n#  {\'x\': [2, 2, None], \'y\': [None, None, None]},\n#  {\'x\': [3, 3, None], \'y\': [4.4, 5.5, None]},\n#  {\'x\': [4, 4, None], \'y\': [6.6, 7.7, 8.8]}]\n\n# %%markdown\n# If you pass a ``pad`` through a ``Table``, be sure that every field in each record is a nested array (and therefore can be padded).\n\n# %%\na = awkward.Table(x=[1, 2, 3, 4],\n                  y=awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]]))\na.tolist()\n# [{\'x\': 1, \'y\': [1.1, 2.2, 3.3]},\n#  {\'x\': 2, \'y\': []},\n#  {\'x\': 3, \'y\': [4.4, 5.5]},\n#  {\'x\': 4, \'y\': [6.6, 7.7, 8.8, 9.9]}]\n\n# %%\ntry:\n    a.pad(3)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> pad cannot be applied to scalars\n\n# %%markdown\n# The same goes for ``UnionArrays``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3, [1, 2, 3]], [], [4.4, 5.5, [4, 5]]])\na\n# <JaggedArray [[1.1 2.2 3.3 [1 2 3]] [] [4.4 5.5 [4 5]]] at 0x7811883c5d30>\n\n# %%\na.pad(5)\n# <JaggedArray [[1.1 2.2 3.3 [1 2 3] None] [None None None None None] [4.4 5.5 [4 5] None None]] at 0x78112c0e9a20>\n\n# %%\na = awkward.UnionArray.fromtags([0, 0, 0, 1, 1],\n                                [awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]),\n                                 awkward.fromiter([[100, 101], [102]])])\na\n# <UnionArray [[1.1 2.2 3.3] [] [4.4 5.5] [100 101] [102]] at 0x78112c0bed30>\n\n# %%\na.pad(3)\n# <UnionArray [[1.1 2.2 3.3] [None None None] [4.4 5.5 None] [100 101 None] [102 None None]] at 0x78112c0bedd8>\n\n# %%\na = awkward.UnionArray.fromtags([0, 0, 0, 1, 1],\n                                [awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]),\n                                 awkward.fromiter([100, 200])])\na\n# <UnionArray [[1.1 2.2 3.3] [] [4.4 5.5] 100 200] at 0x78112c0e9b00>\n\n# %%\ntry:\n    a.pad(3)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'ValueError\'> pad cannot be applied to scalars\n\n# %%markdown\n# The general behavior of ``pad`` is to replace the shallowest ``JaggedArray`` with a ``JaggedArray`` containing a ``MaskedArray``. The one exception to this type signature is that ``StringArrays`` are padded with characters.\n\n# %%\na = awkward.fromiter([""one"", ""two"", ""three""])\na\n# <StringArray [\'one\' \'two\' \'three\'] at 0x78112c0dcb00>\n\n# %%\na.pad(4, clip=True)\n# <StringArray [\'one \' \'two \' \'thre\'] at 0x78112c1222b0>\n\n# %%\na.pad(4, maskedwhen=b""."", clip=True)\n# <StringArray [\'one.\' \'two.\' \'thre\'] at 0x78112c122f98>\n\n# %%\na.pad(4, maskedwhen=b""\\x00"", clip=True)\n# <StringArray [\'one\\x00\' \'two\\x00\' \'thre\'] at 0x78112c122be0>\n\n# %%markdown\n# * ``argmin()`` and ``argmax()``: returns the index of the minimum or maximum value in a non-jagged array or the indexes where each inner array is minimized or maximized. The jagged structure of the return value consists of empty arrays for each empty array and singleton arrays for non-empty ones, consisting of a single index in an inner array. This is the form needed to extract one element from each inner array using jagged indexing.\n\n# %%\na = awkward.fromiter([[-3.3, 5.5, -8.8], [], [-6.6, 0.0, 2.2, 3.3], [], [2.2, -2.2, 4.4]])\nabsa = abs(a)\n\n# %%\na\n# <JaggedArray [[-3.3 5.5 -8.8] [] [-6.6 0.0 2.2 3.3] [] [2.2 -2.2 4.4]] at 0x78112c0beb70>\n\n# %%\nabsa\n# <JaggedArray [[3.3 5.5 8.8] [] [6.6 0.0 2.2 3.3] [] [2.2 2.2 4.4]] at 0x78112c0bec18>\n\n# %%\nindex = absa.argmax()\nindex\n# <JaggedArray [[2] [] [0] [] [2]] at 0x78112c0d0128>\n\n# %%\nabsa[index]\n# <JaggedArray [[8.8] [] [6.6] [] [4.4]] at 0x78112c122c50>\n\n# %%\na[index]\n# <JaggedArray [[-8.8] [] [-6.6] [] [4.4]] at 0x78112c0d5eb8>\n\n# %%markdown\n# * ``cross(other, nested=False)`` and ``argcross(other, nested=False)``: returns jagged tuples representing the `cross-join <https://en.wikipedia.org/wiki/Join_(SQL)#Cross_join>`__ of `array[i]` and `other[i]` separately for each `i`. If `nested=True`, the result is doubly jagged so that each element of the output corresponds to exactly one element in the original `array`.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\nb = awkward.fromiter([[""one"", ""two""], [""three""], [""four"", ""five"", ""six""], [""seven""]])\na.cross(b)\n# <JaggedArray [[(1.1, one) (1.1, two) (2.2, one) (2.2, two) (3.3, one) (3.3, two)] [] [(4.4, four) (4.4, five) (4.4, six) (5.5, four) (5.5, five) (5.5, six)] [(6.6, seven) (7.7, seven) (8.8, seven) (9.9, seven)]] at 0x78112c0e9550>\n\n# %%\na.cross(b, nested=True)\n# <JaggedArray [[[(1.1, one) (1.1, two)] [(2.2, one) (2.2, two)] [(3.3, one) (3.3, two)]] [] [[(4.4, four) (4.4, five) (4.4, six)] [(5.5, four) (5.5, five) (5.5, six)]] [[(6.6, seven)] [(7.7, seven)] [(8.8, seven)] [(9.9, seven)]]] at 0x78112c0be978>\n\n# %%markdown\n# The ""arg"" version returns indexes at which the appropriate objects may be found, as usual.\n\n# %%\na.argcross(b)\n# <JaggedArray [[(0, 0) (0, 1) (1, 0) (1, 1) (2, 0) (2, 1)] [] [(0, 0) (0, 1) (0, 2) (1, 0) (1, 1) (1, 2)] [(0, 0) (1, 0) (2, 0) (3, 0)]] at 0x78112c122470>\n\n# %%\na.argcross(b, nested=True)\n# <JaggedArray [[[(0, 0) (0, 1)] [(1, 0) (1, 1)] [(2, 0) (2, 1)]] [] [[(0, 0) (0, 1) (0, 2)] [(1, 0) (1, 1) (1, 2)]] [[(0, 0)] [(1, 0)] [(2, 0)] [(3, 0)]]] at 0x78112c122dd8>\n\n# %%markdown\n# This method is good to use with ``unzip``, which separates the ``Table`` of tuples into a left half and a right half.\n\n# %%\nleft, right = a.cross(b).unzip()\nleft, right\n# (<JaggedArray [[1.1 1.1 2.2 2.2 3.3 3.3] [] [4.4 4.4 4.4 5.5 5.5 5.5] [6.6 7.7 8.8 9.9]] at 0x78112c0be278>,\n#  <JaggedArray [[\'one\' \'two\' \'one\' \'two\' \'one\' \'two\'] [] [\'four\' \'five\' \'six\' \'four\' \'five\' \'six\'] [\'seven\' \'seven\' \'seven\' \'seven\']] at 0x78112c0d0470>)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\nb = awkward.fromiter([[1, 2], [3], [4, 5, 6], [7]])\nleft, right = a.cross(b, nested=True).unzip()\nleft, right\n# (<JaggedArray [[[1.1 1.1] [2.2 2.2] [3.3 3.3]] [] [[4.4 4.4 4.4] [5.5 5.5 5.5]] [[6.6] [7.7] [8.8] [9.9]]] at 0x78112c127048>,\n#  <JaggedArray [[[1 2] [1 2] [1 2]] [] [[4 5 6] [4 5 6]] [[7] [7] [7] [7]]] at 0x78112c127630>)\n\n# %%markdown\n# This can be handy if a subsequent function takes two jagged arrays as arguments.\n\n# %%\ndistance = round(abs(left - right), 1)\ndistance\n# <JaggedArray [[[0.1 0.9] [1.2 0.2] [2.3 1.3]] [] [[0.4 0.6 1.6] [1.5 0.5 0.5]] [[0.4] [0.7] [1.8] [2.9]]] at 0x78112c0bec88>\n\n# %%markdown\n# Cross with ``nested=True``, followed by some calculation on the pairs and then some reducer, is a common pattern. Because of the ``nested=True`` and the reducer, the resulting array has the same structure as the original.\n\n# %%\ndistance.min()\n# <JaggedArray [[0.1 0.2 1.3] [] [0.4 0.5] [0.4 0.7 1.8 2.9]] at 0x78112c0d50f0>\n\n# %%\nround(a + distance.min(), 1)\n# <JaggedArray [[1.2 2.4 4.6] [] [4.8 6.0] [7.0 8.4 10.6 12.8]] at 0x78112c122518>\n\n# %%markdown\n# * ``pairs(nested=False)`` and ``argpairs(nested=False)``: returns jagged tuples representing the `self-join <https://en.wikipedia.org/wiki/Join_(SQL)#Self-join>`__ removing duplicates but not same-object pairs (i.e. a self-join with ``i1 <= i2``) for each inner array separately.\n\n# %%\na = awkward.fromiter([[""a"", ""b"", ""c""], [], [""d"", ""e""]])\na.pairs()\n# <JaggedArray [[(a, a) (a, b) (a, c) (b, b) (b, c) (c, c)] [] [(d, d) (d, e) (e, e)]] at 0x78112c127898>\n\n# %%markdown\n# The ""arg"" and ``nested=True`` versions have the same meanings as with ``cross`` (above).\n\n# %%\na.argpairs()\n# <JaggedArray [[(0, 0) (0, 1) (0, 2) (1, 1) (1, 2) (2, 2)] [] [(0, 0) (0, 1) (1, 1)]] at 0x78112c0d0978>\n\n# %%\na.pairs(nested=True)\n# <JaggedArray [[[(a, a) (a, b) (a, c)] [(b, b) (b, c)] [(c, c)]] [] [[(d, d) (d, e)] [(e, e)]]] at 0x78112c0be2b0>\n\n# %%markdown\n# Just as with ``cross`` (above), this is good to combine with ``unzip`` and maybe a reducer.\n\n# %%\na.pairs().unzip()\n# (<JaggedArray [[\'a\' \'a\' \'a\' \'b\' \'b\' \'c\'] [] [\'d\' \'d\' \'e\']] at 0x78112c0d08d0>,\n#  <JaggedArray [[\'a\' \'b\' \'c\' \'b\' \'c\' \'c\'] [] [\'d\' \'e\' \'e\']] at 0x78112c0d0fd0>)\n\n# %%markdown\n# * ``distincts(nested=False)`` and ``argdistincts(nested=False)``: returns jagged tuples representing the `self-join <https://en.wikipedia.org/wiki/Join_(SQL)#Self-join>`__ removing duplicates and same-object pairs (i.e. a self-join with ``i1 < i2``) for each inner array separately.\n\n# %%\na = awkward.fromiter([[""a"", ""b"", ""c""], [], [""d"", ""e""]])\na.distincts()\n# <JaggedArray [[(a, b) (a, c) (b, c)] [] [(d, e)]] at 0x78112c127080>\n\n# %%markdown\n# The ""arg"" and ``nested=True`` versions have the same meanings as with ``cross`` (above).\n\n# %%\na.argdistincts()\n# <JaggedArray [[(0, 1) (0, 2) (1, 2)] [] [(0, 1)]] at 0x78112c0d04e0>\n\n# %%\na.distincts(nested=True)\n# <JaggedArray [[[(a, b) (a, c)] [(b, c)]] [] [[(d, e)]]] at 0x78112c0d0a58>\n\n# %%markdown\n# Just as with ``cross`` (above), this is good to combine with ``unzip`` and maybe a reducer.\n\n# %%\na.distincts().unzip()\n# (<JaggedArray [[\'a\' \'a\' \'b\'] [] [\'d\']] at 0x78112c11e908>,\n#  <JaggedArray [[\'b\' \'c\' \'c\'] [] [\'e\']] at 0x78112c11e518>)\n\n# %%markdown\n# * ``choose(n)`` and ``argchoose(n)``: returns jagged tuples for distinct combinations of ``n`` elements from every inner array separately. ``array.choose(2)`` is the same as ``array.distincts()`` apart from order.\n\n# %%\na = awkward.fromiter([[""a"", ""b"", ""c""], [], [""d"", ""e""], [""f"", ""g"", ""h"", ""i"", ""j""]])\na\n# <JaggedArray [[\'a\' \'b\' \'c\'] [] [\'d\' \'e\'] [\'f\' \'g\' \'h\' \'i\' \'j\']] at 0x78112c0d0400>\n\n# %%\na.choose(2)\n# <JaggedArray [[(a, b) (a, c) (b, c)] [] [(d, e)] [(f, g) (f, h) (g, h) ... (g, j) (h, j) (i, j)]] at 0x78112c11e0f0>\n\n# %%\na.choose(3)\n# <JaggedArray [[(a, b, c)] [] [] [(f, g, h) (f, g, i) (f, h, i) ... (f, i, j) (g, i, j) (h, i, j)]] at 0x78114c6e46a0>\n\n# %%\na.choose(4)\n# <JaggedArray [[] [] [] [(f, g, h, i) (f, g, h, j) (f, g, i, j) (f, h, i, j) (g, h, i, j)]] at 0x78112c0d0cc0>\n\n# %%markdown\n# The ""arg"" version has the same meaning as ``cross`` (above), but there is no ``nested=True`` because of the order.\n\n# %%\na.argchoose(2)\n# <JaggedArray [[(0, 1) (0, 2) (1, 2)] [] [(0, 1)] [(0, 1) (0, 2) (1, 2) ... (1, 4) (2, 4) (3, 4)]] at 0x78112c11e2b0>\n\n# %%markdown\n# Just as with ``cross`` (above), this is good to combine with ``unzip`` and maybe a reducer.\n\n# %%\na.choose(2).unzip()\n# (<JaggedArray [[\'a\' \'a\' \'b\'] [] [\'d\'] [\'f\' \'f\' \'g\' ... \'g\' \'h\' \'i\']] at 0x78112c11e5c0>,\n#  <JaggedArray [[\'b\' \'c\' \'c\'] [] [\'e\'] [\'g\' \'h\' \'h\' ... \'j\' \'j\' \'j\']] at 0x78112c0f7ac8>)\n\n# %%\na.choose(3).unzip()\n# (<JaggedArray [[\'a\'] [] [] [\'f\' \'f\' \'f\' ... \'f\' \'g\' \'h\']] at 0x78112c0dc5f8>,\n#  <JaggedArray [[\'b\'] [] [] [\'g\' \'g\' \'h\' ... \'i\' \'i\' \'i\']] at 0x78112c0dc3c8>,\n#  <JaggedArray [[\'c\'] [] [] [\'h\' \'i\' \'i\' ... \'j\' \'j\' \'j\']] at 0x78112c0dc6d8>)\n\n# %%\na.choose(4).unzip()\n# (<JaggedArray [[] [] [] [\'f\' \'f\' \'f\' \'f\' \'g\']] at 0x78112c0d0eb8>,\n#  <JaggedArray [[] [] [] [\'g\' \'g\' \'g\' \'h\' \'h\']] at 0x78112c11e550>,\n#  <JaggedArray [[] [] [] [\'h\' \'h\' \'i\' \'i\' \'i\']] at 0x78112c11e2e8>,\n#  <JaggedArray [[] [] [] [\'i\' \'j\' \'j\' \'j\' \'j\']] at 0x78112c11e4a8>)\n\n# %%markdown\n# * ``JaggedArray.zip(columns...)``: combines jagged arrays with the same structure into a single jagged array. The columns may be unnamed (resulting in a jagged array of tuples) or named with keyword arguments or dict keys (resulting in a jagged array of a table with named columns).\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[100, 200, 300], [], [400, 500]])\nawkward.JaggedArray.zip(a, b)\n# <JaggedArray [[(1.1, 100) (2.2, 200) (3.3, 300)] [] [(4.4, 400) (5.5, 500)]] at 0x78112c0f71d0>\n\n# %%\nawkward.JaggedArray.zip(x=a, y=b).tolist()\n# [[{\'x\': 1.1, \'y\': 100}, {\'x\': 2.2, \'y\': 200}, {\'x\': 3.3, \'y\': 300}],\n#  [],\n#  [{\'x\': 4.4, \'y\': 400}, {\'x\': 5.5, \'y\': 500}]]\n\n# %%\nawkward.JaggedArray.zip({""x"": a, ""y"": b}).tolist()\n# [[{\'x\': 1.1, \'y\': 100}, {\'x\': 2.2, \'y\': 200}, {\'x\': 3.3, \'y\': 300}],\n#  [],\n#  [{\'x\': 4.4, \'y\': 400}, {\'x\': 5.5, \'y\': 500}]]\n\n# %%markdown\n# Not all of the arguments need to be jagged; those that aren\'t will be broadcasted to the right shape.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([100, 200, 300])\nawkward.JaggedArray.zip(a, b)\n# <JaggedArray [[(1.1, 100) (2.2, 100) (3.3, 100)] [] [(4.4, 300) (5.5, 300)]] at 0x78112c0f7c18>\n\n# %%\nawkward.JaggedArray.zip(a, 1000)\n# <JaggedArray [[(1.1, 1000) (2.2, 1000) (3.3, 1000)] [] [(4.4, 1000) (5.5, 1000)]] at 0x78112c0f72e8>\n\n# %%markdown\n# ## Properties and methods for tabular columns\n#\n# All awkward arrays have these methods, but they provide information about the first nested ``Table`` within a structure. If, for instance, the ``Table`` is within some structure that doesn\'t affect high-level type (e.g. ``IndexedArray``, ``ChunkedArray``, ``VirtualArray``), then the methods are passed through to the ``Table``. If it\'s nested within something that does change type, but can meaningfully pass on the call, such as ``MaskedArray``, then that\'s what they do.\n#\n# * ``columns``: the names of the columns at the first tabular level of depth.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1, ""z"": ""one""}, {""x"": 2, ""y"": 2.2, ""z"": ""two""}, {""x"": 3, ""y"": 3.3, ""z"": ""three""}])\na.tolist()\n# [{\'x\': 1, \'y\': 1.1, \'z\': \'one\'},\n#  {\'x\': 2, \'y\': 2.2, \'z\': \'two\'},\n#  {\'x\': 3, \'y\': 3.3, \'z\': \'three\'}]\n\n# %%\na.columns\n# [\'x\', \'y\', \'z\']\n\n# %%\na = awkward.Table(x=[1, 2, 3],\n                  y=[1.1, 2.2, 3.3],\n                  z=awkward.Table(a=[4, 5, 6], b=[4.4, 5.5, 6.6]))\na.tolist()\n# [{\'x\': 1, \'y\': 1.1, \'z\': {\'a\': 4, \'b\': 4.4}},\n#  {\'x\': 2, \'y\': 2.2, \'z\': {\'a\': 5, \'b\': 5.5}},\n#  {\'x\': 3, \'y\': 3.3, \'z\': {\'a\': 6, \'b\': 6.6}}]\n\n# %%\na.columns\n# [\'x\', \'y\', \'z\']\n\n# %%\na[""z""].columns\n# [\'a\', \'b\']\n\n# %%\na.z.columns\n# [\'a\', \'b\']\n\n# %%markdown\n# * ``unzip()``: returns a tuple of projections through each of the columns (in the same order as the ``columns`` property).\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1, ""z"": ""one""}, {""x"": 2, ""y"": 2.2, ""z"": ""two""}, {""x"": 3, ""y"": 3.3, ""z"": ""three""}])\na.unzip()\n# (array([1, 2, 3]),\n#  array([1.1, 2.2, 3.3]),\n#  <StringArray [\'one\' \'two\' \'three\'] at 0x78112c0d02b0>)\n\n# %%markdown\n# The ``unzip`` method is the opposite of the ``Table`` constructor,\n\n# %%\na = awkward.Table(x=[1, 2, 3],\n                  y=[1.1, 2.2, 3.3],\n                  z=awkward.fromiter([""one"", ""two"", ""three""]))\na.tolist()\n# [{\'x\': 1, \'y\': 1.1, \'z\': \'one\'},\n#  {\'x\': 2, \'y\': 2.2, \'z\': \'two\'},\n#  {\'x\': 3, \'y\': 3.3, \'z\': \'three\'}]\n\n# %%\na.unzip()\n# (array([1, 2, 3]),\n#  array([1.1, 2.2, 3.3]),\n#  <StringArray [\'one\' \'two\' \'three\'] at 0x78112c115a20>)\n\n# %%markdown\n# but it is also the opposite of ``JaggedArray.zip``.\n\n# %%\nb = awkward.JaggedArray.zip(x=awkward.fromiter([[1, 2, 3], [], [4, 5]]),\n                            y=awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]),\n                            z=awkward.fromiter([[""a"", ""b"", ""c""], [], [""d"", ""e""]]))\nb.tolist()\n# [[{\'x\': 1, \'y\': 1.1, \'z\': \'a\'},\n#   {\'x\': 2, \'y\': 2.2, \'z\': \'b\'},\n#   {\'x\': 3, \'y\': 3.3, \'z\': \'c\'}],\n#  [],\n#  [{\'x\': 4, \'y\': 4.4, \'z\': \'d\'}, {\'x\': 5, \'y\': 5.5, \'z\': \'e\'}]]\n\n# %%\nb.unzip()\n# (<JaggedArray [[1 2 3] [] [4 5]] at 0x78112c14fe10>,\n#  <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78112c14f9b0>,\n#  <JaggedArray [[\'a\' \'b\' \'c\'] [] [\'d\' \'e\']] at 0x78112c14fa90>)\n\n# %%markdown\n# ``JaggedArray.zip`` produces a jagged array of ``Table`` whereas the ``Table`` constructor produces just a ``Table``, and these are distinct things, though they can both be inverted by the same function because row indexes and column indexes commute:\n\n# %%\nb[0][""y""]\n# array([1.1, 2.2, 3.3])\n\n# %%\nb[""y""][0]\n# array([1.1, 2.2, 3.3])\n\n# %%markdown\n# So ``unzip`` turns a flat ``Table`` into a tuple of flat arrays (opposite of the ``Table`` constructor) and it turns a jagged ``Table`` into a tuple of jagged arrays (opposite of ``JaggedArray.zip``).\n#\n# * ``istuple``: an array of tuples is a special kind of ``Table``, one whose ``rowname`` is ``""tuple""`` and columns are ``""0""``, ``""1""``, ``""2""``, etc. If these conditions are met, ``istuple`` is ``True``; otherwise, ``False``.\n\n# %%\na = awkward.Table(x=[1, 2, 3],\n                  y=[1.1, 2.2, 3.3],\n                  z=awkward.fromiter([""one"", ""two"", ""three""]))\na.tolist()\n# [{\'x\': 1, \'y\': 1.1, \'z\': \'one\'},\n#  {\'x\': 2, \'y\': 2.2, \'z\': \'two\'},\n#  {\'x\': 3, \'y\': 3.3, \'z\': \'three\'}]\n\n# %%\na.istuple\n# False\n\n# %%\na = awkward.Table([1, 2, 3],\n                  [1.1, 2.2, 3.3],\n                  awkward.fromiter([""one"", ""two"", ""three""]))\na.tolist()\n# [(1, 1.1, \'one\'), (2, 2.2, \'two\'), (3, 3.3, \'three\')]\n\n# %%\na.istuple\n# True\n\n# %%markdown\n# Even though the following tuples are inside of a jagged array, the first level of ``Table`` is a tuple, so ``istuple`` is ``True``.\n\n# %%\nb = awkward.JaggedArray.zip(awkward.fromiter([[1, 2, 3], [], [4, 5]]),\n                            awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]]),\n                            awkward.fromiter([[""a"", ""b"", ""c""], [], [""d"", ""e""]]))\nb\n# <JaggedArray [[(1, 1.1, a) (2, 2.2, b) (3, 3.3, c)] [] [(4, 4.4, d) (5, 5.5, e)]] at 0x78112c0d0e48>\n\n# %%\nb.istuple\n# True\n\n# %%markdown\n# * ``i0`` through ``i9``: one of the two conditions for a ``Table`` to be a ``tuple`` is that columns are named ``""0""``, ``""1""``, ``""2""``, etc. Columns like that could be selected with ``[""0""]`` at the risk of being misread as ``[0]``, and they could not be selected with attribute dot-access because pure numbers are not valid Python attributes. However, ``i0`` through ``i9`` are provided as shortcuts (overriding any columns with these exact names) for the first 10 tuple slots.\n\n# %%\na = awkward.Table([1, 2, 3],\n                  [1.1, 2.2, 3.3],\n                  awkward.fromiter([""one"", ""two"", ""three""]))\na.tolist()\n# [(1, 1.1, \'one\'), (2, 2.2, \'two\'), (3, 3.3, \'three\')]\n\n# %%\na.i0\n# array([1, 2, 3])\n\n# %%\na.i1\n# array([1.1, 2.2, 3.3])\n\n# %%\na.i2\n# <StringArray [\'one\' \'two\' \'three\'] at 0x78112c14fe80>\n\n# %%markdown\n# * ``flattentuple()``: calling ``cross`` repeatedly can result in tuples nested within tuples; this flattens them at all levels, turning all ``(i, (j, k))`` into ``(i, j, k)``. Whereas ``array.flatten()`` removes one level of structure from the rows (losing information), ``array.flattentuple()`` removes all levels of structure from the columns (renaming them, but not losing information).\n\n# %%\na = awkward.Table([1, 2, 3], [1, 2, 3], awkward.Table(awkward.Table([1, 2, 3], [1, 2, 3]), [1, 2, 3]))\na.tolist()\n# [(1, 1, ((1, 1), 1)), (2, 2, ((2, 2), 2)), (3, 3, ((3, 3), 3))]\n\n# %%\na.flattentuple().tolist()\n# [(1, 1, 1, 1, 1), (2, 2, 2, 2, 2), (3, 3, 3, 3, 3)]\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]])\nb = awkward.fromiter([[100, 200], [300], [400, 500, 600], [700]])\nc = awkward.fromiter([[""a""], [""b"", ""c""], [""d""], [""e"", ""f""]])\n\n# %%markdown\n# The ``cross`` method internally calls ``flattentuples()`` if it detects that one of its arguments is the result of a ``cross``.\n\n# %%\na.cross(b).cross(c).tolist()\n# [[(1.1, 100, \'a\'),\n#   (1.1, 200, \'a\'),\n#   (2.2, 100, \'a\'),\n#   (2.2, 200, \'a\'),\n#   (3.3, 100, \'a\'),\n#   (3.3, 200, \'a\')],\n#  [],\n#  [(4.4, 400, \'d\'),\n#   (4.4, 500, \'d\'),\n#   (4.4, 600, \'d\'),\n#   (5.5, 400, \'d\'),\n#   (5.5, 500, \'d\'),\n#   (5.5, 600, \'d\')],\n#  [(6.6, 700, \'e\'),\n#   (6.6, 700, \'f\'),\n#   (7.7, 700, \'e\'),\n#   (7.7, 700, \'f\'),\n#   (8.8, 700, \'e\'),\n#   (8.8, 700, \'f\'),\n#   (9.9, 700, \'e\'),\n#   (9.9, 700, \'f\')]]\n\n# %%markdown\n# ## Properties and methods for missing values\n#\n# All awkward arrays have these methods, but they provide information about the first nested ``MaskedArray`` within a structure. If, for instance, the ``MaskedArray`` is within some structure that doesn\'t affect high-level type (e.g. ``IndexedArray``, ``ChunkedArray``, ``VirtualArray``), then the methods are passed through to the ``MaskedArray``. If it\'s nested within something that does change type, but can meaningfully pass on the call, such as ``JaggedArray``, then that\'s what they do.\n#\n# * ``boolmask(maskedwhen=None)``: returns a Numpy array of booleans indicating which elements are missing (""masked"") and which are not. If ``maskedwhen=True``, a ``True`` value in the Numpy array means missing/masked; if ``maskedwhen=False``, a ``False`` value in the Numpy array means missing/masked. If no value is passed (or ``None``), the ``MaskedArray``\'s own ``maskedwhen`` property is used (which is by default ``True``). Non-``MaskedArrays`` are assumed to have a ``maskedwhen`` of ``True`` (the default).\n\n# %%\na = awkward.fromiter([1, 2, None, 3, 4, None, None, 5])\na.boolmask()\n# array([False, False,  True, False, False,  True,  True, False])\n\n# %%\na.boolmask(maskedwhen=False)\n# array([ True,  True, False,  True,  True, False, False,  True])\n\n# %%markdown\n# ``MaskedArrays`` inside of ``JaggedArrays`` or ``Tables`` are hidden.\n\n# %%\na = awkward.fromiter([[1.1, None, 2.2], [], [3.3, 4.4, None, 5.5]])\na.boolmask()\n# array([False, False, False])\n\n# %%\na.flatten().boolmask()\n# array([False,  True, False, False, False,  True, False])\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": None, ""y"": 2.2}, {""x"": None, ""y"": 3.3}, {""x"": 4, ""y"": None}])\na.boolmask()\n# array([False, False, False, False])\n\n# %%\na.x.boolmask()\n# array([False,  True,  True, False])\n\n# %%\na.y.boolmask()\n# array([False, False, False,  True])\n\n# %%markdown\n# * ``ismasked`` and ``isunmasked``: shortcut for ``boolmask(maskedwhen=True)`` and ``boolmask(maskedwhen=False)`` as a property, which is more appropriate for analysis.\n\n# %%\na = awkward.fromiter([1, 2, None, 3, 4, None, None, 5])\na.ismasked\n# array([False, False,  True, False, False,  True,  True, False])\n\n# %%\na.isunmasked\n# array([ True,  True, False,  True,  True, False, False,  True])\n\n# %%markdown\n# * ``fillna(value)``: turn a ``MaskedArray`` into a non-``MaskedArray`` by replacing ``None`` with ``value``. Applies to the outermost ``MaskedArray``, but it passes through ``JaggedArrays`` and into all ``Table`` columns.\n\n# %%\na = awkward.fromiter([1, 2, None, 3, 4, None, None, 5])\na.fillna(999)\n# array([  1,   2, 999,   3,   4, 999, 999,   5])\n\n# %%\na = awkward.fromiter([[1.1, None, 2.2], [], [3.3, 4.4, None, 5.5]])\na.fillna(999)\n# <JaggedArray [[1.1 999.0 2.2] [] [3.3 4.4 999.0 5.5]] at 0x78112c0859b0>\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": None, ""y"": 2.2}, {""x"": None, ""y"": 3.3}, {""x"": 4, ""y"": None}])\na.fillna(999).tolist()\n# [{\'x\': 1, \'y\': 1.1},\n#  {\'x\': 999, \'y\': 2.2},\n#  {\'x\': 999, \'y\': 3.3},\n#  {\'x\': 4, \'y\': 999.0}]\n\n# %%markdown\n# ## Functions for structure manipulation\n#\n# Only one structure-manipulation function (for now) is defined at top-level in awkward-array: ``awkward.concatenate``.\n#\n# * ``awkward.concatenate(arrays, axis=0)``: concatenate two or more ``arrays``. If ``axis=0``, the arrays are concatenated lengthwise (the resulting length is the sum of the lengths of each of the ``arrays``). If ``axis=1``, each inner array is concatenated: the input ``arrays`` must all be jagged with the same outer array length. (Values of ``axis`` greater than ``1`` are not yet supported.)\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[100, 200], [300], [400, 500, 600]])\nawkward.concatenate([a, b])\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5] [100.0 200.0] [300.0] [400.0 500.0 600.0]] at 0x78112c122c88>\n\n# %%\nawkward.concatenate([a, b], axis=1)\n# <JaggedArray [[1.1 2.2 3.3 100.0 200.0] [300.0] [4.4 5.5 400.0 500.0 600.0]] at 0x78112c425978>\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}])\nb = awkward.fromiter([{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}])\nawkward.concatenate([a, b]).tolist()\n# [{\'x\': 1, \'y\': 1.1},\n#  {\'x\': 2, \'y\': 2.2},\n#  {\'x\': 3, \'y\': 3.3},\n#  {\'x\': 4, \'y\': 4.4},\n#  {\'x\': 5, \'y\': 5.5}]\n\n# %%markdown\n# If the arrays have different types, their concatenation is a ``UnionArray``.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}])\nb = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nawkward.concatenate([a, b]).tolist()\n# [{\'x\': 1, \'y\': 1.1},\n#  {\'x\': 2, \'y\': 2.2},\n#  {\'x\': 3, \'y\': 3.3},\n#  [1.1, 2.2, 3.3],\n#  [],\n#  [4.4, 5.5]]\n\n# %%\na = awkward.fromiter([1, None, 2])\nb = awkward.fromiter([None, 3, None])\nawkward.concatenate([a, b])\n# <MaskedArray [1 None 2 None 3 None] at 0x78112c085da0>\n\n# %%\nimport awkward, numpy\na = awkward.fromiter([""one"", ""two"", ""three""])\nb = awkward.fromiter([""four"", ""five"", ""six""])\nawkward.concatenate([a, b])\n# <StringArray [\'one\' \'two\' \'three\' \'four\' \'five\' \'six\'] at 0x78112c14f7f0>\n\n# %%\nawkward.concatenate([a, b], axis=1)\n# <StringArray [\'onefour\' \'twofive\' \'threesix\'] at 0x78112c115518>\n\n# %%markdown\n# # Functions for input/output and conversion\n#\n# Most of the functions defined at the top-level of the library are conversion functions.\n#\n# * ``awkward.fromiter(iterable, awkwardlib=None, dictencoding=False, maskedwhen=True)``: convert Python or JSON data into awkward arrays. Not a fast function: it necessarily involves a Python for loop. The ``awkwardlib`` determines which awkward module to use to make arrays (``awkward`` is the default, but ``awkward.numba`` and ``awkward.cpp`` are alternatives). If ``dictencoding`` is ``True``, bytes and strings will be ""dictionary-encoded"" in Arrow/Parquet terms\xe2\x80\x94this is an ``IndexedArray`` in awkward. The ``maskedwhen`` parameter determines whether ``MaskedArrays`` have a mask that is ``True`` when data are missing or ``False`` when data are missing.\n\n# %%\n# We have been using this function all along, but why not another example?\ncomplicated = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                                [4.4, [5.5]],\n                                [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                               ])\ncomplicated\n# <JaggedArray [[1.1 2.2 None 3.3 None] [4.4 [5.5]] [<Row 0> None <Row 1>]] at 0x78112c0ef438>\n\n# %%markdown\n# The fact that this nested, row-wise data have been converted into columnar arrays can be seen by inspecting its ``layout``.\n\n# %%\ncomplicated.layout\n#  layout\n# [           ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])\n# [            0]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [            1]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [            2]   IndexedMaskedArray(mask=layout[2, 0], content=layout[2, 1], maskedwhen=-1)\n# [         2, 0]     ndarray(shape=10, dtype=dtype(\'int64\'))\n# [         2, 1]     UnionArray(tags=layout[2, 1, 0], index=layout[2, 1, 1], contents=[layout[2, 1, 2], layout[2, 1, 3], layout[2, 1, 4]])\n# [      2, 1, 0]       ndarray(shape=7, dtype=dtype(\'uint8\'))\n# [      2, 1, 1]       ndarray(shape=7, dtype=dtype(\'int64\'))\n# [      2, 1, 2]       ndarray(shape=4, dtype=dtype(\'float64\'))\n# [      2, 1, 3]       JaggedArray(starts=layout[2, 1, 3, 0], stops=layout[2, 1, 3, 1], content=layout[2, 1, 3, 2])\n# [   2, 1, 3, 0]         ndarray(shape=1, dtype=dtype(\'int64\'))\n# [   2, 1, 3, 1]         ndarray(shape=1, dtype=dtype(\'int64\'))\n# [   2, 1, 3, 2]         ndarray(shape=1, dtype=dtype(\'float64\'))\n# [      2, 1, 4]       Table(x=layout[2, 1, 4, 0], y=layout[2, 1, 4, 1])\n# [   2, 1, 4, 0]         ndarray(shape=2, dtype=dtype(\'int64\'))\n# [   2, 1, 4, 1]         Table(z=layout[2, 1, 4, 1, 0])\n# [2, 1, 4, 1, 0]           ndarray(shape=2, dtype=dtype(\'int64\'))\n\n# %%\nfor index, node in complicated.layout.items():\n    if node.cls == numpy.ndarray:\n        print(""[{0:>13s}] {1}"".format("", "".join(repr(i) for i in index), repr(node.array)))\n# [            0] array([0, 5, 7])\n# [            1] array([ 5,  7, 10])\n# [         2, 0] array([ 0,  1, -1,  2, -1,  3,  4,  5, -1,  6])\n# [      2, 1, 0] array([0, 0, 0, 0, 1, 2, 2], dtype=uint8)\n# [      2, 1, 1] array([0, 1, 2, 3, 0, 0, 1])\n# [      2, 1, 2] array([1.1, 2.2, 3.3, 4.4])\n# [   2, 1, 3, 0] array([0])\n# [   2, 1, 3, 1] array([1])\n# [   2, 1, 3, 2] array([5.5])\n# [   2, 1, 4, 0] array([6, 8])\n# [2, 1, 4, 1, 0] array([7, 9])\n\n# %%markdown\n# The number of arrays in this object scales with the complexity of its data type, but not with the size of the dataset. If it were as complicated as it is now but billions of elements long, it would still contain 11 Numpy arrays, and operations on it would scale as Numpy scales. However, converting a billion Python objects to these 11 arrays would be a large up-front cost.\n#\n# More detail on the row-wise to columnar conversion process is given in `docs/fromiter.adoc <https://github.com/scikit-hep/awkward-array/blob/master/docs/fromiter.adoc>`__.\n\n# %%markdown\n# * ``load(file, awkwardlib=None, whitelist=awkward.persist.whitelist, cache=None, schemasuffix="".json"")``: loads data from an ""awkd"" (special ZIP) file. This function is like ``numpy.load``, but for awkward arrays. If the file contains a single object, that object will be read immediately; if it has a collection of named arrays, it will return a loader that loads those arrays on demand. The ``awkwardlib`` determines the module to use to define arrays, the ``whitelist`` is where you can provide a list of functions that may be called in this process, ``cache`` is a global cache object assigned to ``VirtualArrays``, and ``schemasuffix`` determines the file name pattern to look for objects inside the ZIP file.\n#\n# * ``save(file, array, name=None, mode=""a"", compression=awkward.persist.compression, delimiter=""-"", suffix="".raw"", schemasuffix="".json"")``: saves data to an ""awkd"" (special ZIP) file. This function is like ``numpy.savez`` and is the reverse of ``load`` (above). The ``array`` may be a single object or a dict of named arrays, the ``name`` is a name to use inside the file, ``mode=""a""`` means create or append to an existing file, refusing to overwrite data while ``mode=""w""`` overwrites data, ``compression`` is a compression policy (set of rules determining which arrays to compress and how), and the rest of the arguments determine file names within the ZIP: ``delimiter`` between name components, ``suffix`` for array data, and ``schemasuffix`` for the schemas that tell ``load`` how to find all other data.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                      [4.4, [5.5]],\n                      [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                     ])\n\n# %%\nawkward.save(""single.awkd"", a, mode=""w"")\n\n# %%\nawkward.load(""single.awkd"")\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78112c14ff98>\n\n# %%\nawkward.save(""multi.awkd"", {""a"": a, ""b"": b}, mode=""w"")\n\n# %%\nmulti = awkward.load(""multi.awkd"")\n\n# %%\nmulti[""a""]\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78112c0906d8>\n\n# %%\nmulti[""b""]\n# <JaggedArray [[1.1 2.2 None 3.3 None] [4.4 [5.5]] [<Row 0> None <Row 1>]] at 0x78112c0906a0>\n\n# %%markdown\n# Only ``save`` has a ``compression`` parameter because only the writing process gets to decide how arrays are compressed. We don\'t use ZIP\'s built-in compression, but use Python compression functions and encode the choice in the metadata. If ``compression=True``, all arrays will be compressed with zlib; if ``compression=False``, ``None``, or ``[]``, none will. In general, ``compression`` is a list of rules; the first rule that is satisfied by a given array uses the specified compress/decompress pair of functions. Here\'s the default policy:\n\n# %%\nawkward.persist.compression\n# [{\'minsize\': 8192,\n#   \'types\': [numpy.bool_, bool, numpy.integer],\n#   \'contexts\': \'*\',\n#   \'pair\': (<function zlib.compress(data, /, level=-1)>,\n#    (\'zlib\', \'decompress\'))}]\n\n# %%markdown\n# The default policy has only one rule. If any array has a minimum size (``minsize``) of 8 kB (``8192`` bytes), a numeric type (``array.dtype.type``) that is a subclass of ``numpy.bool_``, ``bool``, or ``numpy.integer``, and is in any awkward-array context (``JaggedArray.starts``, ``MaskedArray.mask``, etc.), then it will be compressed with ``zip.compress`` and decompressed with ``(\'zlib\', \'decompress\')``. The compression function is given as an object\xe2\x80\x94the Python function that will be called to transform byte strings into compressed byte strings\xe2\x80\x94but the decompression function is given as a location in Python\'s namespace: a tuple of nested objects, the first of which is a fully qualified module name (submodules separated by dots). This is because only the *location* of the decompression function needs to be written to the file.\n#\n# The saved awkward array consists of a collection of byte strings for Numpy arrays (2 for object ``a`` and 11 for object ``b``, above) and JSON-formatted metadata that reconstructs the nested hierarchy of awkward classes around those Numpy arrays. This metadata includes information such as which byte strings should be decompressed and how, but also which awkward constructors to call to fit everything together. As such, the JSON metadata is code, a limited language without looping or function definitions (i.e. not Turing complete) but with the ability to call any Python function.\n#\n# Using a mini-language as metadata gives us great capacity for backward and forward compatibility (new or old ways of encoding things are simply calling different functions), but it does raise the danger of malicious array files calling unwanted Python functions. For this reason, ``load`` refuses to call any functions not specified in a ``whitelist``. The default whitelist consists of functions known to be safe:\n\n# %%\nawkward.persist.whitelist\n# [[\'numpy\', \'frombuffer\'],\n#  [\'zlib\', \'decompress\'],\n#  [\'lzma\', \'decompress\'],\n#  [\'backports.lzma\', \'decompress\'],\n#  [\'lz4.block\', \'decompress\'],\n#  [\'awkward\', \'*Array\'],\n#  [\'awkward\', \'Table\'],\n#  [\'awkward\', \'numpy\', \'frombuffer\'],\n#  [\'awkward.util\', \'frombuffer\'],\n#  [\'awkward.persist\'],\n#  [\'awkward.arrow\', \'_ParquetFile\', \'fromjson\'],\n#  [\'uproot_methods.classes.*\'],\n#  [\'uproot_methods.profiles.*\'],\n#  [\'uproot.tree\', \'_LazyFiles\'],\n#  [\'uproot.tree\', \'_LazyTree\'],\n#  [\'uproot.tree\', \'_LazyBranch\']]\n\n# %%markdown\n# The format of each item in the whitelist is a list of nested objects, the first of which being a fully qualified module name (submodules separated by dots). For instance, in the ``awkward.arrow`` submodule, there is a class named ``_ParquetFile`` and it has a static method ``fromjson`` that is deemed to be safe. Patterns of safe names are can be wildcarded, such as ``[\'awkward\', \'*Array\']`` and ``[\'uproot_methods.classes.*\']``.\n#\n# You can add your own functions, and forward compatibility (using data made by a new version in an old version of awkward-array) often dictates that you must add a function manually. The error message explains how to do this.\n#\n# The same serialization format is used when you pickle an awkward array or save it in an HDF5 file. More detail on the metadata mini-language is given in `docs/serialization.adoc <https://github.com/scikit-hep/awkward-array/blob/master/docs/serialization.adoc>`__.\n\n# %%markdown\n# * ``hdf5(group, awkwardlib=None, compression=awkward.persist.compression, whitelist=awkward.persist.whitelist, cache=None)``: wrap a ``h5py.Group`` as an awkward-aware group, to save awkward arrays to HDF5 files and to read them back again. The options have the same meaning as ``load`` and ``save``.\n#\n# Unlike ""awkd"" (special ZIP) files, HDF5 files can be written and overwritten like a database, rather than write-once files.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                      [4.4, [5.5]],\n                      [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                     ])\n\n# %%\nimport h5py\nf = h5py.File(""awkward.hdf5"", ""w"")\nf\n# <HDF5 file ""awkward.hdf5"" (mode r+)>\n\n# %%\ng = awkward.hdf5(f)\ng\n# <awkward.hdf5 \'/\' (0 members)>\n\n# %%\ng[""array""] = a\n\n# %%\ng[""array""]\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x781115141320>\n\n# %%\ndel g[""array""]\n\n# %%\ng[""array""] = b\n\n# %%\ng[""array""]\n# <JaggedArray [[1.1 2.2 None 3.3 None] [4.4 [5.5]] [<Row 0> None <Row 1>]] at 0x7811883b9198>\n\n# %%markdown\n# The HDF5 format does not include columnar representations of arbitrary nested data, as awkward-array does, so what we\'re actually storing are plain Numpy arrays and the metadata necessary to reconstruct the awkward array.\n\n# %%\n# Reopen file, without wrapping it as awkward.hdf5 this time.\nf = h5py.File(""awkward.hdf5"", ""r"")\nf\n# <HDF5 file ""awkward.hdf5"" (mode r+)>\n\n# %%\nf[""array""]\n# <HDF5 group ""/array"" (9 members)>\n\n# %%\nf[""array""].keys()\n# <KeysViewHDF5 [\'1\', \'12\', \'14\', \'16\', \'19\', \'4\', \'7\', \'9\', \'schema.json\']>\n\n# %%markdown\n# The ""schema.json"" array is the JSON metadata, containing directives like ``{""call"": [""awkward"", ""JaggedArray"", ""fromcounts""]}`` and ``{""read"": ""1""}`` meaning the array named ``""1""``, etc.\n\n# %%\nimport json\njson.loads(f[""array""][""schema.json""][:].tostring())\n# {\'awkward\': \'0.12.0rc1\',\n#  \'schema\': {\'call\': [\'awkward\', \'JaggedArray\', \'fromcounts\'],\n#   \'args\': [{\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#     \'args\': [{\'read\': \'1\'}, {\'dtype\': \'int64\'}, {\'json\': 3, \'id\': 2}],\n#     \'id\': 1},\n#    {\'call\': [\'awkward\', \'IndexedMaskedArray\'],\n#     \'args\': [{\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#       \'args\': [{\'read\': \'4\'}, {\'dtype\': \'int64\'}, {\'json\': 10, \'id\': 5}],\n#       \'id\': 4},\n#      {\'call\': [\'awkward\', \'UnionArray\', \'fromtags\'],\n#       \'args\': [{\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#         \'args\': [{\'read\': \'7\'}, {\'dtype\': \'uint8\'}, {\'json\': 7, \'id\': 8}],\n#         \'id\': 7},\n#        {\'list\': [{\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#           \'args\': [{\'read\': \'9\'}, {\'dtype\': \'float64\'}, {\'json\': 4, \'id\': 10}],\n#           \'id\': 9},\n#          {\'call\': [\'awkward\', \'JaggedArray\', \'fromcounts\'],\n#           \'args\': [{\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#             \'args\': [{\'read\': \'12\'},\n#              {\'dtype\': \'int64\'},\n#              {\'json\': 1, \'id\': 13}],\n#             \'id\': 12},\n#            {\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#             \'args\': [{\'read\': \'14\'}, {\'dtype\': \'float64\'}, {\'ref\': 13}],\n#             \'id\': 14}],\n#           \'id\': 11},\n#          {\'call\': [\'awkward\', \'Table\', \'frompairs\'],\n#           \'args\': [{\'pairs\': [[\'x\',\n#               {\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#                \'args\': [{\'read\': \'16\'},\n#                 {\'dtype\': \'int64\'},\n#                 {\'json\': 2, \'id\': 17}],\n#                \'id\': 16}],\n#              [\'y\',\n#               {\'call\': [\'awkward\', \'Table\', \'frompairs\'],\n#                \'args\': [{\'pairs\': [[\'z\',\n#                    {\'call\': [\'awkward\', \'numpy\', \'frombuffer\'],\n#                     \'args\': [{\'read\': \'19\'}, {\'dtype\': \'int64\'}, {\'ref\': 17}],\n#                     \'id\': 19}]]},\n#                 {\'json\': 0}],\n#                \'id\': 18}]]},\n#            {\'json\': 0}],\n#           \'id\': 15}]}],\n#       \'id\': 6},\n#      {\'json\': -1}],\n#     \'id\': 3}],\n#   \'id\': 0},\n#  \'prefix\': \'array/\'}\n\n# %%markdown\n# Without awkward-array, these objects can\'t be meaningfully read back from the HDF5 file.\n\n# %%markdown\n# * ``awkward.fromarrow(arrow, awkwardlib=None)``: convert an `Apache Arrow <https://arrow.apache.org>`__ formatted buffer to an awkward array (zero-copy). The ``awkwardlib`` parameter has the same meaning as above.\n#\n# * ``awkward.toarrow(array)``: convert an awkward array to an Apache Arrow buffer, if possible (involving a data copy, but no Python loops).\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                      [4.4, [5.5]],\n                      [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                     ])\n\n# %%\nawkward.toarrow(a)\n# <pyarrow.lib.ListArray object at 0x78110846b1a8>\n# [\n#   [\n#     1.1,\n#     2.2,\n#     3.3\n#   ],\n#   [],\n#   [\n#     4.4,\n#     5.5\n#   ]\n# ]\n\n# %%\nawkward.fromarrow(awkward.toarrow(a))\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78110846d550>\n\n# %%\nawkward.toarrow(b)\n# <pyarrow.lib.ListArray object at 0x78110846b6d0>\n# [\n#   -- is_valid: all not null\n#   -- type_ids:     [\n#       0,\n#       0,\n#       2,\n#       0,\n#       2\n#     ]\n#   -- value_offsets:     [\n#       0,\n#       1,\n#       1,\n#       2,\n#       1\n#     ]\n#   -- child 0 type: double\n#     [\n#       1.1,\n#       2.2,\n#       3.3,\n#       4.4\n#     ]\n#   -- child 1 type: list<item: double>\n#     [\n#       [\n#         5.5\n#       ]\n#     ]\n#   -- child 2 type: struct<x: int64, y: struct<z: int64>>\n#     -- is_valid: all not null\n#     -- child 0 type: int64\n#       [\n#         6,\n#         8\n#       ]\n#     -- child 1 type: struct<z: int64>\n#       -- is_valid: all not null\n#       -- child 0 type: int64\n#         [\n#           7,\n#           9\n#         ],\n#   -- is_valid: all not null\n#   -- type_ids:     [\n#       0,\n#       1\n#     ]\n#   -- value_offsets:     [\n#       3,\n#       0\n#     ]\n#   -- child 0 type: double\n#     [\n#       1.1,\n#       2.2,\n#       3.3,\n#       4.4\n#     ]\n#   -- child 1 type: list<item: double>\n#     [\n#       [\n#         5.5\n#       ]\n#     ]\n#   -- child 2 type: struct<x: int64, y: struct<z: int64>>\n#     -- is_valid: all not null\n#     -- child 0 type: int64\n#       [\n#         6,\n#         8\n#       ]\n#     -- child 1 type: struct<z: int64>\n#       -- is_valid: all not null\n#       -- child 0 type: int64\n#         [\n#           7,\n#           9\n#         ],\n#   -- is_valid: all not null\n#   -- type_ids:     [\n#       2,\n#       2,\n#       2\n#     ]\n#   -- value_offsets:     [\n#       0,\n#       1,\n#       1\n#     ]\n#   -- child 0 type: double\n#     [\n#       1.1,\n#       2.2,\n#       3.3,\n#       4.4\n#     ]\n#   -- child 1 type: list<item: double>\n#     [\n#       [\n#         5.5\n#       ]\n#     ]\n#   -- child 2 type: struct<x: int64, y: struct<z: int64>>\n#     -- is_valid: all not null\n#     -- child 0 type: int64\n#       [\n#         6,\n#         8\n#       ]\n#     -- child 1 type: struct<z: int64>\n#       -- is_valid: all not null\n#       -- child 0 type: int64\n#         [\n#           7,\n#           9\n#         ]\n# ]\n\n# %%\nawkward.fromarrow(awkward.toarrow(b))\n# <JaggedArray [[1.1 2.2 <Row 1> 3.3 <Row 1>] [4.4 [5.5]] [<Row 0> <Row 1> <Row 1>]] at 0x78110846de48>\n\n# %%markdown\n# Unlike HDF5, Arrow is capable of columnar jagged arrays, nullable values, nested structures, etc. If you save an awkward array in Arrow format, someone else can read it without the awkward-array library. There are a few awkward array classes that don\'t have an Arrow equivalent, though. Below is a list of all translations.\n#\n# * Numpy array \xe2\x86\x92 Arrow `BooleanArray <https://arrow.apache.org/docs/python/generated/pyarrow.BooleanArray.html>`__, `IntegerArray <https://arrow.apache.org/docs/python/generated/pyarrow.IntegerArray.html>`__, or `FloatingPointArray <https://arrow.apache.org/docs/python/generated/pyarrow.FloatingPointArray.html>`__.\n# * ``JaggedArray`` \xe2\x86\x92 Arrow `ListArray <https://arrow.apache.org/docs/python/generated/pyarrow.ListArray.html>`__.\n# * ``StringArray`` \xe2\x86\x92 Arrow `StringArray <https://arrow.apache.org/docs/python/generated/pyarrow.StringArray.html>`__.\n# * ``Table`` \xe2\x86\x92 Arrow `Table <https://arrow.apache.org/docs/python/generated/pyarrow.Table.html>`__ at top-level, but an Arrow `StructArray <https://arrow.apache.org/docs/python/generated/pyarrow.StructArray.html>`__ if nested.\n# * ``MaskedArray`` \xe2\x86\x92 missing data mask (nullability in Arrow is an array attribute, rather than an array wrapper).\n# * ``IndexedMaskedArray`` \xe2\x86\x92 unfolded into a simple mask before the Arrow translation.\n# * ``IndexedArray`` \xe2\x86\x92 Arrow `DictionaryArray <https://arrow.apache.org/docs/python/generated/pyarrow.DictionaryArray.html>`__.\n# * ``SparseArray`` \xe2\x86\x92 converted to a dense array before the Arrow translation.\n# * ``ObjectArray`` \xe2\x86\x92 Pythonic interpretation is discarded before the Arrow translation.\n# * ``UnionArray`` \xe2\x86\x92 Arrow dense `UnionArray <https://arrow.apache.org/docs/python/generated/pyarrow.UnionArray.html>`__ if possible, sparse UnionArray if necessary.\n# * ``ChunkedArray`` (including ``AppendableArray``) \xe2\x86\x92 Arrow `RecordBatches <https://arrow.apache.org/docs/python/generated/pyarrow.RecordBatch.html>`__, but only at top-level: nested ``ChunkedArrays`` cannot be converted.\n# * ``VirtualArray`` \xe2\x86\x92 array gets materialized before the Arrow translation (i.e. the lazy-loading is not preserved).\n\n# %%markdown\n# Since Arrow is an in-memory format, both ``toarrow`` and ``fromarrow`` are side-effect-free functions with a return value. Functions that write to files have a side-effect (the state of your disk changing) and no return value. Once you\'ve made your Arrow buffer, you have to figure out what to do with it. (You may want to `write it to a stream <https://arrow.apache.org/docs/python/ipc.html>`__ for interprocess communication.)\n\n# %%markdown\n# * ``awkward.fromparquet(where, awkwardlib=None)``: reads from a Parquet file (at filename/URI ``where``) into an awkward array, through pyarrow. The ``awkwardlib`` parameter has the same meaning as above.\n#\n# * ``awkward.toparquet(where, array, schema=None)``: writes an awkward array to a Parquet file (at filename/URI ``where``), through pyarrow. The Parquet ``schema`` may be inferred from the awkward array or explicitly specified.\n#\n# Like Arrow and unlike HDF5, Parquet natively stores complex data structures in a columnar format and doesn\'t need to be wrapped by an interpretation layer like ``awkward.hdf5``. Like HDF5 and unlike Arrow, Parquet is a file format, intended for storage.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nb = awkward.fromiter([[1.1, 2.2, None, 3.3, None],\n                      [4.4, [5.5]],\n                      [{""x"": 6, ""y"": {""z"": 7}}, None, {""x"": 8, ""y"": {""z"": 9}}]\n                     ])\n\n# %%\nawkward.toparquet(""dataset.parquet"", a)\n\n# %%\na2 = awkward.fromparquet(""dataset.parquet"")\na2\n# <ChunkedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78110846dc50>\n\n# %%markdown\n# Notice that we get a ``ChunkedArray`` back. This is because ``awkward.fromparquet`` is lazy-loading the Parquet file, which might be very large (not in this case, obviously). It\'s actually a ``ChunkedArray`` (one `row group <https://parquet.apache.org/documentation/latest/#unit-of-parallelization>`__ per chunk) of ``VirtualArrays``, and each ``VirtualArray`` is read when it is accessed (for instance, to print it above).\n\n# %%\na2.chunks\n# [<VirtualArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78110846dc18>]\n\n# %%\na2.chunks[0].array\n# <BitMaskedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78110849aeb8>\n\n# %%markdown\n# The next layer of new structure is that the jagged array is bit-masked. Even though none of the values are nullable, this is an artifact of the way Parquet formats columnar data.\n\n# %%\na2.chunks[0].array.content\n# <JaggedArray [[1.1 2.2 3.3] [] [4.4 5.5]] at 0x78110849a518>\n\n# %%\na2.layout\n#  layout\n# [           ()] ChunkedArray(chunks=[layout[0]], chunksizes=[3])\n# [            0]   VirtualArray(generator=<awkward.arrow._ParquetFile object at 0x78110846df98>, args=(0, \'\'), kwargs={}, array=layout[0, 0])\n# [         0, 0]     BitMaskedArray(mask=layout[0, 0, 0], content=layout[0, 0, 1], maskedwhen=False, lsborder=True)\n# [      0, 0, 0]       ndarray(shape=1, dtype=dtype(\'uint8\'))\n# [      0, 0, 1]       JaggedArray(starts=layout[0, 0, 1, 0], stops=layout[0, 0, 1, 1], content=layout[0, 0, 1, 2])\n# [   0, 0, 1, 0]         ndarray(shape=3, dtype=dtype(\'int32\'))\n# [   0, 0, 1, 1]         ndarray(shape=3, dtype=dtype(\'int32\'))\n# [   0, 0, 1, 2]         BitMaskedArray(mask=layout[0, 0, 1, 2, 0], content=layout[0, 0, 1, 2, 1], maskedwhen=False, lsborder=True)\n# [0, 0, 1, 2, 0]           ndarray(shape=1, dtype=dtype(\'uint8\'))\n# [0, 0, 1, 2, 1]           ndarray(shape=5, dtype=dtype(\'float64\'))\n\n# %%markdown\n# Fewer types can be written to Parquet files than Arrow buffers, since pyarrow does not yet have a complete Arrow \xe2\x86\x92 Parquet transformation.\n\n# %%\ntry:\n    awkward.toparquet(""dataset2.parquet"", b)\nexcept Exception as err:\n    print(type(err), str(err))\n# <class \'pyarrow.lib.ArrowNotImplementedError\'> Unhandled type for Arrow to Parquet schema conversion: union[dense]<0: double=0, 1: list<item: double>=1, 2: struct<x: int64, y: struct<z: int64>>=2>\n\n# %%markdown\n# * ``awkward.topandas(array, flatten=False)``: convert the array into a Pandas DataFrame (if tabular) or a Pandas Series (otherwise). If ``flatten=False``, wrap the awkward arrays as a new Pandas extension type (not fully implemented). If ``flatten=True``, convert the jaggedness and nested tables into row and column ``pandas.MultiIndex`` without introducing any new types (not always possible).\n\n# %%\na = awkward.Table(x=awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8, 9.9]]),\n                  y=awkward.fromiter([100, 200, 300, 400]))\ndf = awkward.topandas(a)\ndf\n\nif False:\n      [<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr style=\\""text-align: right;\\"">\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>x</th>\\n"",\n       ""      <th>y</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>[1.1 2.2 3.3]</td>\\n"",\n       ""      <td>100</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>[]</td>\\n"",\n       ""      <td>200</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>[4.4 5.5]</td>\\n"",\n       ""      <td>300</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <td>[6.6 7.7 8.8 9.9]</td>\\n"",\n       ""      <td>400</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%\ndf.x\n# 0        [1.1 2.2 3.3]\n# 1                   []\n# 2            [4.4 5.5]\n# 3    [6.6 7.7 8.8 9.9]\n# Name: x, dtype: awkward\n\n# %%markdown\n# Note that the ``dtype`` is ``awkward``. The array has not been converted into Numpy ``dtype=object`` (which would imply a performance loss); it has been wrapped as a container that Pandas recognizes. You can get the awkward array back the same way you would a Numpy array:\n\n# %%\ndf.x.values\n# <JaggedSeries [[1.1 2.2 3.3] [] [4.4 5.5] [6.6 7.7 8.8 9.9]] at 0x78110846d400>\n\n# %%markdown\n# (``JaggedSeries`` is a thin wrapper on ``JaggedArray``; they behave the same way.)\n#\n# The value of this is that awkward slice semantics can be applied to data in Pandas.\n\n# %%\ndf[1:]\n\nif False:\n      [<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr style=\\""text-align: right;\\"">\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>x</th>\\n"",\n       ""      <th>y</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>[]</td>\\n"",\n       ""      <td>200</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>[4.4 5.5]</td>\\n"",\n       ""      <td>300</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <td>[6.6 7.7 8.8 9.9]</td>\\n"",\n       ""      <td>400</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%\ndf.x[df.x.values.counts > 0]\n# 0        [1.1 2.2 3.3]\n# 2            [4.4 5.5]\n# 3    [6.6 7.7 8.8 9.9]\n# Name: x, dtype: awkward\n\n# %%markdown\n# However, Pandas has a (limited) way of handling jaggedness and nested tables, with ``pandas.MultiIndex`` rows and columns, respectively.\n\n# %%\n# Nested tables become MultiIndex-valued column names.\narray = awkward.fromiter([{""a"": {""b"": 1, ""c"": {""d"": [2]}}, ""e"": 3},\n                          {""a"": {""b"": 4, ""c"": {""d"": [5, 5.1]}}, ""e"": 6},\n                          {""a"": {""b"": 7, ""c"": {""d"": [8, 8.1, 8.2]}}, ""e"": 9}])\ndf = awkward.topandas(array, flatten=True)\ndf\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th colspan=\\""2\\"" halign=\\""left\\"">a</th>\\n"",\n       ""      <th>e</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""      <th>c</th>\\n"",\n       ""      <th></th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>d</th>\\n"",\n       ""      <th></th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>2.0</td>\\n"",\n       ""      <td>3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>4</td>\\n"",\n       ""      <td>5.0</td>\\n"",\n       ""      <td>6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>4</td>\\n"",\n       ""      <td>5.1</td>\\n"",\n       ""      <td>6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.0</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.1</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>7</td>\\n"",\n       ""      <td>8.2</td>\\n"",\n       ""      <td>9</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%\n# Jagged arrays become MultiIndex-valued rows (index).\narray = awkward.fromiter([{""a"": 1, ""b"": [[2.2, 3.3, 4.4], [], [5.5, 6.6]]},\n                          {""a"": 10, ""b"": [[1.1], [2.2, 3.3], [], [4.4]]},\n                          {""a"": 100, ""b"": [[], [9.9]]}])\ndf = awkward.topandas(array, flatten=True)\ndf\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>a</th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""5\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>5.5</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>6.6</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""4\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>1.1</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>100</td>\\n"",\n       ""      <td>9.9</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# The advantage of this is that no new column types are introduced, and Pandas already has functions for managing structure in its ``MultiIndex``. For instance, this structure can be unstacked into Pandas\'s columns.\n\n# %%\ndf.unstack()\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th colspan=\\""3\\"" halign=\\""left\\"">a</th>\\n"",\n       ""      <th colspan=\\""3\\"" halign=\\""left\\"">b</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""2\\"" valign=\\""top\\"">0</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>5.5</td>\\n"",\n       ""      <td>6.6</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th rowspan=\\""3\\"" valign=\\""top\\"">1</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>1.1</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>2.2</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>100.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>9.9</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%\ndf.unstack().unstack()\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th colspan=\\""10\\"" halign=\\""left\\"">a</th>\\n"",\n       ""      <th>...</th>\\n"",\n       ""      <th colspan=\\""10\\"" halign=\\""left\\"">b</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th colspan=\\""4\\"" halign=\\""left\\"">0</th>\\n"",\n       ""      <th colspan=\\""4\\"" halign=\\""left\\"">1</th>\\n"",\n       ""      <th colspan=\\""2\\"" halign=\\""left\\"">2</th>\\n"",\n       ""      <th>...</th>\\n"",\n       ""      <th colspan=\\""2\\"" halign=\\""left\\"">0</th>\\n"",\n       ""      <th colspan=\\""4\\"" halign=\\""left\\"">1</th>\\n"",\n       ""      <th colspan=\\""4\\"" halign=\\""left\\"">2</th>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>...</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>3</th>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <th>3</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>1.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>...</td>\\n"",\n       ""      <td>5.5</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>6.6</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>10.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>...</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>4.4</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>3.3</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>100.0</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>...</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""      <td>NaN</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%markdown\n# It is also possible to get `Pandas Series and DataFrames through Arrow <https://arrow.apache.org/docs/python/pandas.html>`__, though this doesn\'t handle jagged arrays well: they get converted into Numpy ``dtype=object`` arrays.\n\n# %%\ndf = awkward.toarrow(array).to_pandas()\ndf\n\nif False:\n      [""<table border=\\""1\\"" class=\\""dataframe\\"">\\n"",\n       ""  <thead>\\n"",\n       ""    <tr style=\\""text-align: right;\\"">\\n"",\n       ""      <th></th>\\n"",\n       ""      <th>a</th>\\n"",\n       ""      <th>b</th>\\n"",\n       ""    </tr>\\n"",\n       ""  </thead>\\n"",\n       ""  <tbody>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>0</th>\\n"",\n       ""      <td>1</td>\\n"",\n       ""      <td>[[2.2, 3.3, 4.4], [], [5.5, 6.6]]</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>1</th>\\n"",\n       ""      <td>10</td>\\n"",\n       ""      <td>[[1.1], [2.2, 3.3], [], [4.4]]</td>\\n"",\n       ""    </tr>\\n"",\n       ""    <tr>\\n"",\n       ""      <th>2</th>\\n"",\n       ""      <td>100</td>\\n"",\n       ""      <td>[[], [9.9]]</td>\\n"",\n       ""    </tr>\\n"",\n       ""  </tbody>\\n"",\n       ""</table>\\n""]\n\n# %%\ndf.b\n# 0    [[2.2, 3.3, 4.4], [], [5.5, 6.6]]\n# 1       [[1.1], [2.2, 3.3], [], [4.4]]\n# 2                          [[], [9.9]]\n# Name: b, dtype: object\n\n# %%\ndf.b[0]\n# array([array([2.2, 3.3, 4.4]), array([], dtype=float64),\n#        array([5.5, 6.6])], dtype=object)\n\n# %%markdown\n# # High-level types\n#\n# The high-level type of an array describes its characteristics in terms of what it *represents*, a *logical* view of the data. By contrast, the layouts (below) describe the nested arrays themselves, a *physical* view of the data.\n#\n# The logical view of Numpy arrays is described in terms of ``shape`` and ``dtype``. The awkward type of a Numpy array is presented a little differently.\n\n# %%\na = numpy.array([[1.1, 2.2], [3.3, 4.4], [5.5, 6.6]])\nt = awkward.type.fromarray(a)\nt\n# ArrayType(3, 2, dtype(\'float64\'))\n\n# %%markdown\n# Above is the object-form of the high-level type and object that ``takes`` arguments ``to`` return values.\n\n# %%\nt.takes\n# 3\n\n# %%\nt.to\n# ArrayType(2, dtype(\'float64\'))\n\n# %%\nt.to.to\n# dtype(\'float64\')\n\n# %%markdown\n# High-level type objects also have a printable form for human readability.\n\n# %%\nprint(t)\n# [0, 3) -> [0, 2) -> float64\n\n# %%markdown\n# The above should be read like a function\'s data type: ``argument type -> return type`` for the function that takes an index in square brackets and returns something else. For example, the first ``[0, 3)`` means that you could put any non-negative integer less than ``3`` in square brackets after the array, like this:\n\n# %%\na[2]\n# array([5.5, 6.6])\n\n# %%markdown\n# The second ``[0, 2)`` means that the next argument can be any non-negative integer less than ``2``.\n\n# %%\na[2][1]\n# 6.6\n\n# %%markdown\n# And then you have a Numpy ``dtype``.\n#\n# The reason high-level types are expressed like this, instead of Numpy ``shape`` and ``dtype`` is to generalize to arbitrary objects.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": []}, {""x"": 2, ""y"": [1.1, 2.2]}, {""x"": 3, ""y"": [1.1, 2.2, 3.3]}])\nprint(a.type)\n# [0, 3) -> \'x\' -> int64\n#           \'y\' -> [0, inf) -> float64\n\n# %%markdown\n# In the above, you could call ``a[2][""x""]`` to get ``3`` or ``a[2][""y""][1]`` to get ``2.2``, but the types and even number of allowed arguments depend on which path you take. Numpy\'s ``shape`` and ``dtype`` have no equivalent.\n#\n# Also in the above, the allowed argument for the jagged array is specified as ``[0, inf)``, which doesn\'t literally mean any value up to infinity is allowed\xe2\x80\x94the constraint simply isn\'t specific because it depends on the details of the jagged array. Even specifying the maximum length of any sublist (``a[""y""].counts.max()``) would require a calculation that scales with the size of the dataset, which can be infeasible in some cases. Instead, ``[0, inf)`` simply means ""jagged.""\n#\n# Fixed-length arrays inside of ``JaggedArrays`` or ``Tables`` are presented with known upper limits:\n\n# %%\na = awkward.Table(x=[[1.1, 2.2], [3.3, 4.4], [5.5, 6.6]],\n                  y=awkward.fromiter([[1, 2, 3], [], [4, 5]]))\nprint(a.type)\n# [0, 3) -> \'x\' -> [0, 2) -> float64\n#           \'y\' -> [0, inf) -> int64\n\n# %%markdown\n# Whereas each value of a ``Table`` row (`product type <https://en.wikipedia.org/wiki/Product_type>`__) contains a member of every one of its fields, each value of a ``UnionArray`` item (`sum type <https://en.wikipedia.org/wiki/Tagged_union>`__) contains a member of exactly one of its possibilities. The distinction is drawn as the lack or presence of a vertical bar (meaning ""or"": ``|``).\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": ""one""}, {""x"": 2, ""y"": ""two""}, {""x"": 3, ""y"": ""three""}])\nprint(a.type)\n# [0, 3) -> \'x\' -> int64\n#           \'y\' -> <class \'str\'>\n\n# %%\na = awkward.fromiter([1, 2, 3, ""four"", ""five"", ""six""])\nprint(a.type)\n# [0, 6) -> (int64         |\n#            <class \'str\'> )\n\n# %%markdown\n# The parenthesis is to keep ``Table`` fields from being mixed up with ``UnionArray`` possibilities.\n\n# %%\na = awkward.fromiter([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": ""three""}, {""x"": 4, ""y"": ""four""}])\nprint(a.type)\n# [0, 4) -> \'x\' -> int64\n#           \'y\' -> (float64       |\n#                   <class \'str\'> )\n\n# %%markdown\n# As in mathematics, products and the adjacency operator take precedence over sums.\n\n# %%\na = awkward.fromiter([1, 2, 3, {""x"": 4.4, ""y"": ""four""}, {""x"": 5.5, ""y"": ""five""}, {""x"": 6.6, ""y"": ""six""}])\nprint(a.type)\n# [0, 6) -> (int64                |\n#            \'x\' -> float64\n#            \'y\' -> <class \'str\'> )\n\n# %%markdown\n# Missing data, represented by ``MaskedArrays``, ``BitMaskedArrays``, or ``IndexedMaskedArrays``, are called ""option types"" in the high-level type language.\n\n# %%\na = awkward.fromiter([1, 2, 3, None, None, 4, 5])\nprint(a.type)\n# [0, 7) -> ?(int64)\n\n# %%\n# Inner arrays could be missing values.\na = awkward.fromiter([[1.1, 2.2, 3.3], None, [4.4, 5.5]])\nprint(a.type)\n# [0, 3) -> ?([0, inf) -> float64)\n\n# %%\n# Numbers in those arrays could be missing values.\na = awkward.fromiter([[1.1, 2.2, None], [], [4.4, 5.5]])\nprint(a.type)\n# [0, 3) -> [0, inf) -> ?(float64)\n\n# %%markdown\n# Cross-references and cyclic references are expressed in awkward type objects by creating the same graph structure among the type objects as the arrays. Thus,\n\n# %%\ntree = awkward.fromiter([\n    {""value"": 1.23, ""left"":    1, ""right"":    2},     # node 0\n    {""value"": 3.21, ""left"":    3, ""right"":    4},     # node 1\n    {""value"": 9.99, ""left"":    5, ""right"":    6},     # node 2\n    {""value"": 3.14, ""left"":    7, ""right"": None},     # node 3\n    {""value"": 2.71, ""left"": None, ""right"":    8},     # node 4\n    {""value"": 5.55, ""left"": None, ""right"": None},     # node 5\n    {""value"": 8.00, ""left"": None, ""right"": None},     # node 6\n    {""value"": 9.00, ""left"": None, ""right"": None},     # node 7\n    {""value"": 0.00, ""left"": None, ""right"": None},     # node 8\n])\nleft = tree.contents[""left""].content\nright = tree.contents[""right""].content\nleft[(left < 0) | (left > 8)] = 0         # satisfy overzealous validity checks\nright[(right < 0) | (right > 8)] = 0\ntree.contents[""left""].content = awkward.IndexedArray(left, tree)\ntree.contents[""right""].content = awkward.IndexedArray(right, tree)\n\ntree[0].tolist()\n# {\'left\': {\'left\': {\'left\': {\'left\': None, \'right\': None, \'value\': 9.0},\n#    \'right\': None,\n#    \'value\': 3.14},\n#   \'right\': {\'left\': None,\n#    \'right\': {\'left\': None, \'right\': None, \'value\': 0.0},\n#    \'value\': 2.71},\n#   \'value\': 3.21},\n#  \'right\': {\'left\': {\'left\': None, \'right\': None, \'value\': 5.55},\n#   \'right\': {\'left\': None, \'right\': None, \'value\': 8.0},\n#   \'value\': 9.99},\n#  \'value\': 1.23}\n\n# %%markdown\n# In the print-out, labels (``T0 :=``, ``T1 :=``, ``T2 :=``) are inserted to indicate where cross-references begin and end.\n\n# %%\nprint(tree.type)\n[0, 9) -> \'left\'  -> T0 := ?(T1 := \'left\'  -> T0\n                                   \'right\' -> T2 := ?(T1)\n                                   \'value\' -> float64)\n          \'right\' -> T2\n          \'value\' -> float64\n\n# %%markdown\n# The ``ObjectArray`` class turns awkward array structures into Python objects on demand. From an analysis point of view, the elements of the array *are* Python objects, and that is reflected in the type.\n\n# %%\nclass Point:\n    def __init__(self, x, y):\n        self.x, self.y = x, y\n    def __repr__(self):\n        return ""Point({0}, {1})"".format(self.x, self.y)\n\na = awkward.fromiter([Point(0, 0), Point(3, 2), Point(1, 1), Point(2, 4), Point(0, 0)])\na\n# <ObjectArray [Point(0, 0) Point(3, 2) Point(1, 1) Point(2, 4) Point(0, 0)] at 0x781106089390>\n\n# %%\nprint(a.type)\n# [0, 5) -> <function ObjectFillable.finalize.<locals>.make at 0x781106085a60>\n\n# %%markdown\n# In summary,\n#\n# * each element of a Numpy ``shape`` like ``(i, j, k)`` becomes a functional argument: ``[0, i) -> [0, j) -> [0, k)``;\n# * high-level types terminate on Numpy ``dtypes`` or ``ObjectArray`` functions;\n# * columns of a ``Table`` are presented adjacent to one another: the type is field 1 *and* field 2 *and* field 3, etc.;\n# * possibilities of a ``UnionArray`` are separated by vertical bars ``|``: the type is possibility 1 *or* possibility 2 *or* possibility 3, etc.;\n# * nullable types are indicated by a question mark;\n# * cross-references and cyclic references are maintained in the type objects, printed with labels.\n\n# %%markdown\n# # Low-level layouts\n#\n# The layout of an array describes how it is constructed in terms of Numpy arrays and other parameters. It has more information than a high-level type (above), more that would typically be needed for data analysis, but very necessary for data engineering.\n#\n# A ``Layout`` object is a mapping from position tuples to ``LayoutNodes``. The screen representation is sufficient for reading.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\nt = a.layout\nt\n#  layout\n# [    ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])\n# [     0]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     1]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     2]   ndarray(shape=5, dtype=dtype(\'float64\'))\n\n# %%\nt[2]\n# <LayoutNode [(2,)] ndarray>\n\n# %%\nt[2].array\n# array([1.1, 2.2, 3.3, 4.4, 5.5])\n\n# %%\na = awkward.fromiter([[[1.1, 2.2], [3.3]], [], [[4.4, 5.5]]])\nt = a.layout\nt\n#  layout\n# [    ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])\n# [     0]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     1]   ndarray(shape=3, dtype=dtype(\'int64\'))\n# [     2]   JaggedArray(starts=layout[2, 0], stops=layout[2, 1], content=layout[2, 2])\n# [  2, 0]     ndarray(shape=3, dtype=dtype(\'int64\'))\n# [  2, 1]     ndarray(shape=3, dtype=dtype(\'int64\'))\n# [  2, 2]     ndarray(shape=5, dtype=dtype(\'float64\'))\n\n# %%\nt[2]\n# <LayoutNode [(2,)] JaggedArray>\n\n# %%\nt[2].array\n# <JaggedArray [[1.1 2.2] [3.3] [4.4 5.5]] at 0x7811060a1208>\n\n# %%\nt[2, 2].array\n# array([1.1, 2.2, 3.3, 4.4, 5.5])\n\n# %%markdown\n# Classes like ``IndexedArray``, ``SparseArray``, ``ChunkedArray``, ``AppendableArray``, and ``VirtualArray`` don\'t change the high-level type of an array, but they do change the layout. Consider, for instance, an array made with ``awkward.fromiter`` and an array read by ``awkward.fromparquet``.\n\n# %%\na = awkward.fromiter([[1.1, 2.2, None, 3.3], [], None, [4.4, 5.5]])\n\n# %%\nawkward.toparquet(""tmp.parquet"", a)\n\n# %%\nb = awkward.fromparquet(""tmp.parquet"")\n\n# %%markdown\n# At first, it terminates at ``VirtualArray`` because the data haven\'t been read\xe2\x80\x94we don\'t know what arrays are associated with it.\n\n# %%\nb.layout\n#  layout\n# [    ()] ChunkedArray(chunks=[layout[0]], chunksizes=[4])\n# [     0]   VirtualArray(generator=<awkward.arrow._ParquetFile object at 0x781106089668>, args=(0, \'\'), kwargs={})\n\n# %%markdown\n# But after reading,\n\n# %%\nb\n# <ChunkedArray [[1.1 2.2 None 3.3] [] [] [4.4 5.5]] at 0x7811060890b8>\n\n# %%markdown\n# The layout shows that it has more structure than ``a``.\n\n# %%\nb.layout\n#  layout\n# [           ()] ChunkedArray(chunks=[layout[0]], chunksizes=[4])\n# [            0]   VirtualArray(generator=<awkward.arrow._ParquetFile object at 0x781106089668>, args=(0, \'\'), kwargs={}, array=layout[0, 0])\n# [         0, 0]     BitMaskedArray(mask=layout[0, 0, 0], content=layout[0, 0, 1], maskedwhen=False, lsborder=True)\n# [      0, 0, 0]       ndarray(shape=1, dtype=dtype(\'uint8\'))\n# [      0, 0, 1]       JaggedArray(starts=layout[0, 0, 1, 0], stops=layout[0, 0, 1, 1], content=layout[0, 0, 1, 2])\n# [   0, 0, 1, 0]         ndarray(shape=4, dtype=dtype(\'int32\'))\n# [   0, 0, 1, 1]         ndarray(shape=4, dtype=dtype(\'int32\'))\n# [   0, 0, 1, 2]         BitMaskedArray(mask=layout[0, 0, 1, 2, 0], content=layout[0, 0, 1, 2, 1], maskedwhen=False, lsborder=True)\n# [0, 0, 1, 2, 0]           ndarray(shape=1, dtype=dtype(\'uint8\'))\n# [0, 0, 1, 2, 1]           ndarray(shape=6, dtype=dtype(\'float64\'))\n\n# %%\na.layout\n#  layout\n# [     ()] MaskedArray(mask=layout[0], content=layout[1], maskedwhen=True)\n# [      0]   ndarray(shape=4, dtype=dtype(\'bool\'))\n# [      1]   JaggedArray(starts=layout[1, 0], stops=layout[1, 1], content=layout[1, 2])\n# [   1, 0]     ndarray(shape=4, dtype=dtype(\'int64\'))\n# [   1, 1]     ndarray(shape=4, dtype=dtype(\'int64\'))\n# [   1, 2]     MaskedArray(mask=layout[1, 2, 0], content=layout[1, 2, 1], maskedwhen=True)\n# [1, 2, 0]       ndarray(shape=6, dtype=dtype(\'bool\'))\n# [1, 2, 1]       ndarray(shape=6, dtype=dtype(\'float64\'))\n\n# %%markdown\n# However, they have the same high-level type.\n\n# %%\nprint(b.type)\n# [0, 4) -> ?([0, inf) -> ?(float64))\n\n# %%\nprint(a.type)\n# [0, 4) -> ?([0, inf) -> ?(float64))\n\n# %%markdown\n# Cross-references and cyclic references are also encoded in the ``layout``, as references to previously seen indexes.\n\n# %%\ntree.layout\n#  layout\n# [     ()] Table(left=layout[0], right=layout[1], value=layout[2])\n# [      0]   MaskedArray(mask=layout[0, 0], content=layout[0, 1], maskedwhen=True)\n# [   0, 0]     ndarray(shape=9, dtype=dtype(\'bool\'))\n# [   0, 1]     IndexedArray(index=layout[0, 1, 0], content=layout[0, 1, 1])\n# [0, 1, 0]       ndarray(shape=9, dtype=dtype(\'int64\'))\n# [0, 1, 1]       -> layout[()]\n# [      1]   MaskedArray(mask=layout[1, 0], content=layout[1, 1], maskedwhen=True)\n# [   1, 0]     ndarray(shape=9, dtype=dtype(\'bool\'))\n# [   1, 1]     IndexedArray(index=layout[1, 1, 0], content=layout[1, 1, 1])\n# [1, 1, 0]       ndarray(shape=9, dtype=dtype(\'int64\'))\n# [1, 1, 1]       -> layout[()]\n# [      2]   ndarray(shape=9, dtype=dtype(\'float64\'))\n\n# %%markdown\n# # Applications\n\n# %%markdown\n# ## Decision tree as an awkward array\n\n# %%markdown\n# ## Mixed-source data with persistvirtual\n\n# %%markdown\n# ## Using Pandas with awkward arrays\n\n# %%markdown\n# ## Using Numba with awkward arrays\n\n# %%markdown\n# ## Flattening awkard arrays for machine learning\n'"
tests/__init__.py,0,b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n'
tests/study_indexing.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2019, IRIS-HEP\n# All rights reserved.\n# \n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n# \n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n# \n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n# \n# * Neither the name of the copyright holder nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nimport numpy\nimport awkward\n\ndef spread_advanced(starts, stops, advanced):\n    if advanced is None:\n        return advanced\n    else:\n        assert len(starts) == len(stops) == len(advanced)\n        counts = stops - starts\n        nextadvanced = numpy.full(counts.sum(), 999, int)\n        k = 0\n        for i in range(len(counts)):\n            length = counts[i]\n            nextadvanced[k : k + length] = advanced[i]\n            k += length\n        return nextadvanced\n\ndef getitem_integer(array, head, tail, advanced):\n    index = numpy.full(len(array.starts), 999, int)\n    for i in range(len(array.starts)):\n        j = array.starts[i] + head\n        if j >= array.stops[i]:\n            raise ValueError(""integer index is beyond the range of one of the JaggedArray.starts-JaggedArray.stops pairs"")\n        index[i] = j\n\n    next = getitem_next(array.content[index], tail, advanced)    \n    return next\n\ndef getitem_slice2(array, head, tail, advanced):\n    if (head.start is None or head.start == 0) and head.stop is None:\n        next = getitem_next(array.content, tail, advanced)\n        return awkward.JaggedArray(array.starts, array.stops, next)\n\n    starts = numpy.full(len(array.starts), 999, int)\n    stops = numpy.full(len(array.starts), 999, int)\n    for i in range(len(array.starts)):\n        length = array.stops[i] - array.starts[i]\n        a, b = head.start, head.stop\n\n        if a is None:\n            a = 0\n        elif a < 0:\n            a += length\n        if b is None:\n            b = length\n        elif b < 0:\n            b += length\n\n        if b <= a:\n            a, b = 0, 0\n        if a < 0:\n            a = 0\n        elif a > length:\n            a = length\n        if b < 0:\n            b = 0\n        elif b > length:\n            b = length\n\n        starts[i] = array.starts[i] + a\n        stops[i] = array.starts[i] + b\n\n    next = getitem_next(array.content, tail, advanced)\n    return awkward.JaggedArray(starts, stops, next)\n\ndef getitem_slice3(array, head, tail, advanced):\n    if head.step == 0:\n        raise ValueError\n\n    offsets = numpy.full(len(array.starts) + 1, 999, int)\n    offsets[0] = 0\n    index = numpy.full(len(array.content), 999, int)  # too big, but okay\n    k = 0\n    for i in range(len(array.starts)):\n        length = array.stops[i] - array.starts[i]\n        a, b, c = head.start, head.stop, head.step\n        if c is None:\n            c = 1\n\n        if a is None and c > 0:\n            a = 0\n        elif a is None:\n            a = length - 1\n        elif a < 0:\n            a += length\n\n        if b is None and c > 0:\n            b = length\n        elif b is None:\n            b = -1\n        elif b < 0:\n            b += length\n\n        if c > 0:\n            if b <= a:\n                a, b = 0, 0\n            if a < 0:\n                a = 0\n            elif a > length:\n                a = length\n            if b < 0:\n                b = 0\n            elif b > length:\n                b = length\n        else:\n            if a <= b:\n                a, b = 0, 0\n            if a < -1:\n                a = -1\n            elif a >= length:\n                a = length - 1\n            if b < -1:\n                b = -1\n            elif b >= length:\n                b = length - 1\n\n        for j in range(a, b, c):\n            index[k] = array.starts[i] + j\n            k += 1\n        offsets[i + 1] = k\n\n    starts = offsets[:-1]\n    stops = offsets[1:]\n    next = getitem_next(array.content[index[:k]], tail, spread_advanced(starts, stops, advanced))\n    return awkward.JaggedArray(starts, stops, next)\n\ndef getitem_intarray_none(array, head, tail, advanced):\n    offsets = numpy.full(len(array.starts) + 1, 999, int)\n    offsets[0] = 0\n    index = numpy.full(len(head)*len(array.starts), 999, int)\n    nextadvanced = numpy.full(len(index), 999, int)\n\n    k = 0\n    for i in range(len(array.starts)):\n        length = array.stops[i] - array.starts[i]\n\n        for j in range(len(head)):\n            norm = head[j]\n            if norm < 0:\n                norm += length\n            if norm < 0 or norm >= length:\n                raise IndexError(""advanced index is out of bounds in JaggedArray"")\n            index[k] = array.starts[i] + norm\n            nextadvanced[k] = j\n            k += 1\n        offsets[i + 1] = k\n\n    starts = offsets[:-1]\n    stops = offsets[1:]\n    next = getitem_next(array.content[index], tail, nextadvanced)\n    return awkward.JaggedArray(starts, stops, next)\n\ndef getitem_intarray_some(array, head, tail, advanced):\n    index = numpy.full(len(array.starts), 999, int)\n    nextadvanced = numpy.full(len(index), 999, int)\n\n    for i in range(len(advanced)):\n        length = array.stops[i] - array.starts[i]\n        if advanced[i] >= len(head):\n            raise IndexError(""advanced index lengths do not match"")\n        norm = head[advanced[i]]\n        if norm < 0:\n            norm += length\n        if norm < 0 or norm >= length:\n            raise IndexError(""advanced index is out of bounds in JaggedArray"")\n        index[i] = array.starts[i] + norm\n        nextadvanced[i] = i\n\n    next = getitem_next(array.content[index], tail, nextadvanced)\n    return next\n\ndef getitem_next(array, where, advanced):\n    if len(where) == 0:\n        return array\n    if isinstance(array, numpy.ndarray):\n        return array[where]\n    \n    head = where[0]\n    tail = where[1:]\n    if isinstance(head, int):\n        return getitem_integer(array, head, tail, advanced)\n\n    elif isinstance(head, slice) and (head.step is None or head.step == 1) and advanced is None and not any(isinstance(x, numpy.ndarray) for x in where):\n        return getitem_slice2(array, head, tail, advanced)\n\n    elif isinstance(head, slice):\n        return getitem_slice3(array, head, tail, advanced)\n\n    elif isinstance(head, numpy.ndarray) and issubclass(head.dtype.type, numpy.integer):\n        if advanced is None:\n            return getitem_intarray_none(array, head, tail, advanced)\n        else:\n            return getitem_intarray_some(array, head, tail, advanced)\n\n    else:\n        raise NotImplementedError(head)\n\ndef getitem_enter(array, where):\n    if len(where) == 0:\n        return array\n\n    arraylen = 0\n    for x in where:\n        if isinstance(x, numpy.ndarray) and len(x.shape) == 1:\n            if issubclass(x.dtype.type, (numpy.bool_, numpy.bool)):\n                arraylen = max(arraylen, numpy.count_nonzero(x))\n            else:\n                arraylen = max(arraylen, len(x))\n\n    newwhere = []\n    for x in where:\n        if isinstance(x, numpy.ndarray) and len(x.shape) == 1 and issubclass(x.dtype.type, (numpy.bool, numpy.bool_)):\n            newwhere.append(numpy.nonzero(x)[0])\n        elif isinstance(x, int) and arraylen != 0:\n            newwhere.append(numpy.full(arraylen, x, int))\n        elif isinstance(x, numpy.ndarray) and x.shape == (1,):\n            newwhere.append(numpy.full(arraylen, x, int))\n        else:\n            newwhere.append(x)\n\n    fake = getitem_next(awkward.JaggedArray([0], [len(array)], array), newwhere, None)\n    if isinstance(fake, numpy.ndarray):\n        return fake[0]\n    else:\n        return fake.content[fake.starts[0]:fake.stops[-1]]\n\nslices = [2, slice(None), slice(2, 4), slice(1, None, 2), slice(None, None, -1), numpy.array([2, 0, 0]), numpy.array([3, 1, 2]), numpy.array([True, False, True, True]), numpy.array([True, True, True, False])]\n\na = numpy.arange(4**4).reshape(4, 4, 4, 4)\na2 = awkward.fromiter(a)\n\nfor x in slices:\n    print(x)\n    assert a[x,].tolist() == getitem_enter(a2, (x,)).tolist()\n    for y in slices:\n        print(x, y)\n        assert a[x, y].tolist() == getitem_enter(a2, (x, y)).tolist()\n        for z in slices:\n            print(x, y, z)\n            assert a[x, y, z].tolist() == getitem_enter(a2, (x, y, z)).tolist()\n\ntmp = a2.content.content.content.tolist()\ntmp.insert(4, 999)\na2.content.content.stops = a2.content.content.stops.copy()\na2.content.content.starts[1:] += 1\na2.content.content.stops[1:] += 1\na2.content.content.content = tmp\n\nfor x in slices:\n    print(x)\n    assert a[x,].tolist() == getitem_enter(a2, (x,)).tolist()\n    for y in slices:\n        print(x, y)\n        assert a[x, y].tolist() == getitem_enter(a2, (x, y)).tolist()\n        for z in slices:\n            print(x, y, z)\n            assert a[x, y, z].tolist() == getitem_enter(a2, (x, y, z)).tolist()\n\na = numpy.arange(4**3).reshape(4, 4, 4)\na2 = awkward.fromiter(a)\nfor x in slices:\n    print(x)\n    assert a[x,].tolist() == getitem_enter(a2, (x,)).tolist()\n    for y in slices:\n        print(x, y)\n        assert a[x, y].tolist() == getitem_enter(a2, (x, y)).tolist()\n        for z in slices:\n            print(x, y, z)\n            assert a[x, y, z].tolist() == getitem_enter(a2, (x, y, z)).tolist()\n'"
tests/study_numba_speed.py,0,"b'import time\n\nimport numpy\nimport numba\n\nimport awkward\nimport awkward.numba\n\nnum_muons = numpy.random.poisson(1.5, 100000)\npt_muons  = awkward.JaggedArray.fromcounts(num_muons, numpy.random.exponential(10, num_muons.sum()) + 50)\neta_muons = awkward.JaggedArray.fromcounts(num_muons, numpy.random.normal(0, 1, num_muons.sum()))\nphi_muons = awkward.JaggedArray.fromcounts(num_muons, numpy.random.uniform(-numpy.pi, numpy.pi, num_muons.sum()))\n\nnum_jets = numpy.random.poisson(3.5, 100000)\npt_jets  = awkward.JaggedArray.fromcounts(num_jets, numpy.random.exponential(10, num_jets.sum()) + 50)\neta_jets = awkward.JaggedArray.fromcounts(num_jets, numpy.random.normal(0, 1, num_jets.sum()))\nphi_jets = awkward.JaggedArray.fromcounts(num_jets, numpy.random.uniform(-numpy.pi, numpy.pi, num_jets.sum()))\n\n####################################################### for-loopy\n\ndef run_python(num_muons, pt_muons, eta_muons, phi_muons, num_jets, pt_jets, eta_jets, phi_jets):\n    offsets = numpy.empty(len(num_muons) + 1, numpy.int64)\n    content = numpy.empty((num_muons * num_jets).sum())\n    offsets[0] = 0\n    for i in range(len(num_muons)):\n        offsets[i + 1] = offsets[i]\n        for muoni in range(num_muons[i]):\n            pt1  = pt_muons[i][muoni]\n            eta1 = eta_muons[i][muoni]\n            phi1 = phi_muons[i][muoni]\n            for jeti in range(num_jets[i]):\n                pt2  = pt_jets[i][jeti]\n                eta2 = eta_jets[i][jeti]\n                phi2 = phi_jets[i][jeti]\n                content[offsets[i + 1]] = numpy.sqrt(2*pt1*pt2*(numpy.cosh(eta1 - eta2) - numpy.cos(phi1 - phi2)))\n                offsets[i + 1] += 1\n    return awkward.JaggedArray(offsets[:-1], offsets[1:], content)\n\nstarttime = time.time()\nmass1 = run_python(num_muons, pt_muons, eta_muons, phi_muons, num_jets, pt_jets, eta_jets, phi_jets)\nprint(""Python"", time.time() - starttime)\n\n####################################################### Numpythonic\n\ndef run_numpy(num_muons, pt_muons, eta_muons, phi_muons, num_jets, pt_jets, eta_jets, phi_jets):\n    def unzip(pairs):\n        return pairs.i0, pairs.i1\n\n    pt1, pt2   = unzip(pt_muons.cross(pt_jets))\n    eta1, eta2 = unzip(eta_muons.cross(eta_jets))\n    phi1, phi2 = unzip(phi_muons.cross(phi_jets))\n\n    return numpy.sqrt(2*pt1*pt2*(numpy.cosh(eta1 - eta2) - numpy.cos(phi1 - phi2)))\n\nfor i in range(5):\n    starttime = time.time()\n    mass2 = run_numpy(num_muons, pt_muons, eta_muons, phi_muons, num_jets, pt_jets, eta_jets, phi_jets)\n    print(""Numpy"", time.time() - starttime)\n\n####################################################### with Numba\n\nrun_numba = numba.jit(nopython=True)(run_python)\n\nfor i in range(5):\n    starttime = time.time()\n    mass3 = run_numba(num_muons, pt_muons, eta_muons, phi_muons, num_jets, pt_jets, eta_jets, phi_jets)\n    print(""Numba"", time.time() - starttime)\n'"
tests/study_typeinference.py,0,"b'import operator\n\nimport numpy\nimport numba\n\nclass Dependent(object):\n    def __init__(self, **available):\n        self.available = available\n\n    def __getitem__(self, where):\n        return self.available[where]\n\n@numba.extending.typeof_impl.register(Dependent)\ndef _Dependent_typeof(val, c):\n    return DependentType(list(val.available))\n\nclass DependentType(numba.types.Type):\n    def __init__(self, available):\n        self.available = available\n        self.requested = set()\n        super(DependentType, self).__init__(name=""DependentType({0})"".format("", "".join(sorted(self.available))))\n\n    def request(self, name):\n        if name not in self.requested:\n            self.requested.add(name)\n\n@numba.typing.templates.infer\nclass _DependentType_type_getitem(numba.typing.templates.AbstractTemplate):\n    key = ""static_getitem""\n    def generic(self, args, kwargs):\n        if len(args) == 2 and len(kwargs) == 0:\n            objtype, where = args\n            print(""checking type"", objtype, where)\n            objtype.request(where)\n            return numba.types.int64\n\n@numba.extending.register_model(DependentType)\nclass DependentModel(numba.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        print(""making model"", fe_type)\n        print(""requested"", fe_type.requested)\n        members = []\n        super(DependentModel, self).__init__(dmm, fe_type, members)\n\n@numba.extending.unbox(DependentType)\ndef _JaggedArray_unbox(typ, obj, c):\n    print(""unboxing"", typ)\n    print(""requested"", typ.requested)\n    out = numba.cgutils.create_struct_proxy(typ)(c.context, c.builder)\n    is_error = numba.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(out._getvalue(), is_error)\n\n@numba.extending.lower_builtin(""static_getitem"", DependentType, numba.types.StringLiteral)\ndef _DependentType_lower_static_getitem(context, builder, sig, args):\n    print(""lowering"", sig.args[0], sig.args[1].literal_value)\n    return context.get_constant(numba.types.int64, 999)\n\nobj = Dependent(one=999, two=999, three=999)\n\n@numba.njit\ndef f(x):\n    return x[""one""]\nprint(f(obj))\nprint(f(obj))\n\n@numba.njit\ndef g(x):\n    return x[""two""]\nprint(g(obj))\nprint(g(obj))\nprint(f(obj))\n\nobj = Dependent(one=999, two=999, three=999)\n\nprint(f(obj))\nprint(g(obj))\n\nobj = Dependent(one=999, two=999, three=999)\n\n@numba.njit\ndef h(x):\n    return f(x)\nprint(h(obj))\n'"
tests/test_arrow.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport os.path\nimport sys\nimport unittest\n\nimport pytest\n\nimport numpy\nimport pytest\n\npyarrow = pytest.importorskip(""pyarrow"")\n# pyarrow_parquet = pytest.importorskip(""pyarrow.parquet"")\n\nimport awkward.arrow\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_arrow_toarrow(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            try:\n                import uproot_methods\n            except ImportError:\n                pytest.skip(""unable to import uproot_methods"")\n            else:\n                jet_m   = awkward.fromiter([[60.0, 70.0, 80.0], [], [90.0, 100.0]])\n                jet_pt  = awkward.fromiter([[10.0, 20.0, 30.0], [], [40.0, 50.0]])\n                jet_eta = awkward.fromiter([[-3.0, -2.0, 2.0],  [], [-1.0, 1.0]])\n                jet_phi = awkward.fromiter([[-1.5,  0.0, 1.5],  [], [0.78, -0.78]])\n                jets    = uproot_methods.TLorentzVectorArray.from_ptetaphim(jet_pt, jet_eta, jet_phi, jet_m)\n\n                assert list(awkward.arrow.toarrow(jets)) == [[{""fPt"": 10.0, ""fEta"": -3.0, ""fPhi"": -1.5, ""fMass"": 60.0}, {""fPt"": 20.0, ""fEta"": -2.0, ""fPhi"": 0.0, ""fMass"": 70.0}, {""fPt"": 30.0, ""fEta"": 2.0, ""fPhi"": 1.5, ""fMass"": 80.0}], [], [{""fPt"": 40.0, ""fEta"": -1.0, ""fPhi"": 0.78, ""fMass"": 90.0}, {""fPt"": 50.0, ""fEta"": 1.0, ""fPhi"": -0.78, ""fMass"": 100.0}]]\n\n                # FIXME: it might be possible to avoid this ""mask push-down"" in Arrow, but I don\'t know how\n                maskedjets = awkward.MaskedArray([False, False, True], jets, maskedwhen=True)\n                assert list(awkward.arrow.toarrow(maskedjets)) == [[{""fPt"": 10.0, ""fEta"": -3.0, ""fPhi"": -1.5, ""fMass"": 60.0}, {""fPt"": 20.0, ""fEta"": -2.0, ""fPhi"": 0.0, ""fMass"": 70.0}, {""fPt"": 30.0, ""fEta"": 2.0, ""fPhi"": 1.5, ""fMass"": 80.0}], [], [{""fPt"": None, ""fEta"": None, ""fPhi"": None, ""fMass"": None}, {""fPt"": None, ""fEta"": None, ""fPhi"": None, ""fMass"": None}]]\n\n    def test_arrow_toarrow_string(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = awkward.fromiter([""one"", ""two"", ""three""])\n            assert awkward.fromarrow(awkward.toarrow(a)).tolist() == a.tolist()\n            a = awkward.fromiter([[""one"", ""two"", ""three""], [], [""four"", ""five""]])\n            assert awkward.fromarrow(awkward.toarrow(a)).tolist() == a.tolist()\n            if hasattr(pyarrow.BinaryArray, \'from_buffers\'):\n                a = awkward.fromiter([b""one"", b""two"", b""three""])\n                assert awkward.fromarrow(awkward.toarrow(a)).tolist() == [b""one"", b""two"", b""three""]\n                a = awkward.fromiter([[b""one"", b""two"", b""three""], [], [b""four"", b""five""]])\n                assert awkward.fromarrow(awkward.toarrow(a)).tolist() == [[b""one"", b""two"", b""three""], [], [b""four"", b""five""]]\n            else:\n                a = awkward.fromiter([b""one"", b""two"", b""three""])\n                assert awkward.fromarrow(awkward.toarrow(a)).tolist() == [""one"", ""two"", ""three""]\n                a = awkward.fromiter([[b""one"", b""two"", b""three""], [], [b""four"", b""five""]])\n                assert awkward.fromarrow(awkward.toarrow(a)).tolist() == [[""one"", ""two"", ""three""], [], [""four"", ""five""]]\n\n    def test_arrow_array(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([1.1, 2.2, 3.3, 4.4, 5.5])\n            assert awkward.arrow.fromarrow(a).tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n\n    def test_arrow_boolean(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([True, True, False, False, True])\n            assert awkward.arrow.fromarrow(a).tolist() == [True, True, False, False, True]\n\n    def test_arrow_array_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([1.1, 2.2, 3.3, None, 4.4, 5.5])\n            assert awkward.arrow.fromarrow(a).tolist() == [1.1, 2.2, 3.3, None, 4.4, 5.5]\n\n    def test_arrow_nested_array(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n\n    def test_arrow_nested_nested_array(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[[1.1, 2.2], [3.3], []], [], [[4.4, 5.5]]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[[1.1, 2.2], [3.3], []], [], [[4.4, 5.5]]]\n\n    def test_arrow_nested_array_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[1.1, 2.2, None], [], [4.4, 5.5]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[1.1, 2.2, None], [], [4.4, 5.5]]\n\n    def test_arrow_null_nested_array_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[1.1, 2.2, None], [], None, [4.4, 5.5]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[1.1, 2.2, None], [], None, [4.4, 5.5]]\n\n    def test_arrow_chunked_array(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.chunked_array([pyarrow.array([1.1, 2.2, 3.3, 4.4, 5.5]), pyarrow.array([], pyarrow.float64()), pyarrow.array([6.6, 7.7, 8.8])])\n            assert awkward.arrow.fromarrow(a).tolist() == [1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8]\n\n    def test_arrow_struct(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]\n\n    def test_arrow_struct_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}]\n\n    def test_arrow_null_struct(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": 1, ""y"": 1.1}, None, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": 1, ""y"": 1.1}, None, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]\n\n    def test_arrow_null_struct_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": 1, ""y"": 1.1}, None, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": 1, ""y"": 1.1}, None, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}]\n\n    def test_arrow_chunked_struct(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            t = pyarrow.struct({""x"": pyarrow.int64(), ""y"": pyarrow.float64()})\n            a = pyarrow.chunked_array([pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], t), pyarrow.array([], t), pyarrow.array([{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}], t)])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]\n\n    def test_arrow_nested_struct(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]]\n\n    def test_arrow_nested_struct_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]]\n\n    def test_arrow_null_nested_struct(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], None, [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], None, [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]]\n\n    def test_arrow_null_nested_struct_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}], None, [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": None}, {""x"": 3, ""y"": 3.3}], None, [], [{""x"": 4, ""y"": 4.4}, {""x"": 5, ""y"": 5.5}]]\n\n    def test_arrow_struct_nested(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [3, 3], ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [3, 3], ""y"": 3.3}]\n\n    def test_arrow_struct_nested_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [None, 3], ""y"": 3.3}])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [None, 3], ""y"": 3.3}]\n\n    def test_arrow_nested_struct_nested(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [3, 3], ""y"": 3.3}], [], [{""x"": [4, 4, 4], ""y"": 4.4}, {""x"": [5, 5, 5, 5], ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [3, 3], ""y"": 3.3}], [], [{""x"": [4, 4, 4], ""y"": 4.4}, {""x"": [5, 5, 5, 5], ""y"": 5.5}]]\n\n    def test_arrow_null_nested_struct_nested_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [None, 3], ""y"": 3.3}], None, [], [{""x"": [4, 4, 4], ""y"": 4.4}, {""x"": [5, 5, 5, 5], ""y"": 5.5}]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[{""x"": [], ""y"": 1.1}, {""x"": [2], ""y"": 2.2}, {""x"": [None, 3], ""y"": 3.3}], None, [], [{""x"": [4, 4, 4], ""y"": 4.4}, {""x"": [5, 5, 5, 5], ""y"": 5.5}]]\n\n    def test_arrow_strings(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        elif sys.version_info[0] < 3:\n            pytest.skip(""skipping strings test in Python 2"")\n        else:\n            a = pyarrow.array([""one"", ""two"", ""three"", u""fo\\u2014ur"", ""five""])\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""two"", ""three"", u""fo\\u2014ur"", ""five""]\n\n    def test_arrow_strings_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        elif sys.version_info[0] < 3:\n            pytest.skip(""skipping strings test in Python 2"")\n        else:\n            a = pyarrow.array([""one"", ""two"", None, u""fo\\u2014ur"", ""five""])\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""two"", None, u""fo\\u2014ur"", ""five""]\n\n    def test_arrow_binary(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([b""one"", b""two"", b""three"", b""four"", b""five""])\n            assert awkward.arrow.fromarrow(a).tolist() == [b""one"", b""two"", b""three"", b""four"", b""five""]\n\n    def test_arrow_binary_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([b""one"", b""two"", None, b""four"", b""five""])\n            assert awkward.arrow.fromarrow(a).tolist() == [b""one"", b""two"", None, b""four"", b""five""]\n\n    def test_arrow_chunked_strings(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.chunked_array([pyarrow.array([""one"", ""two"", ""three"", ""four"", ""five""]), pyarrow.array([""six"", ""seven"", ""eight""])])\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""two"", ""three"", ""four"", ""five"", ""six"", ""seven"", ""eight""]\n\n    def test_arrow_nested_strings(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[""one"", ""two"", ""three""], [], [""four"", ""five""]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[""one"", ""two"", ""three""], [], [""four"", ""five""]]\n\n    def test_arrow_nested_strings_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[""one"", ""two"", None], [], [""four"", ""five""]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[""one"", ""two"", None], [], [""four"", ""five""]]\n\n    def test_arrow_null_nested_strings_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.array([[""one"", ""two"", None], [], None, [""four"", ""five""]])\n            assert awkward.arrow.fromarrow(a).tolist() == [[""one"", ""two"", None], [], None, [""four"", ""five""]]\n\n    def test_arrow_union_sparse(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_sparse(pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()), [pyarrow.array([0.0, 1.1, 2.2, 3.3, 4.4]), pyarrow.array([True, True, False, True, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, True, 2.2, 3.3, False]\n\n    def test_arrow_union_sparse_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_sparse(pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()), [pyarrow.array([0.0, 1.1, None, 3.3, 4.4]), pyarrow.array([True, True, False, True, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, True, None, 3.3, False]\n\n    def test_arrow_union_sparse_null_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_sparse(pyarrow.array([0, 1, 0, 0, 1], type=pyarrow.int8()), [pyarrow.array([0.0, 1.1, None, 3.3, 4.4]), pyarrow.array([True, None, False, True, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, None, None, 3.3, False]\n\n    def test_arrow_union_dense(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_dense(pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()), pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()), [pyarrow.array([0.0, 1.1, 2.2, 3.3]), pyarrow.array([True, True, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, True, 1.1, 2.2, 3.3, True, False]\n\n    def test_arrow_union_dense_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_dense(pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()), pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()), [pyarrow.array([0.0, 1.1, None, 3.3]), pyarrow.array([True, True, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, True, 1.1, None, 3.3, True, False]\n\n    def test_arrow_union_dense_null_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.UnionArray.from_dense(pyarrow.array([0, 1, 0, 0, 0, 1, 1], type=pyarrow.int8()), pyarrow.array([0, 0, 1, 2, 3, 1, 2], type=pyarrow.int32()), [pyarrow.array([0.0, 1.1, None, 3.3]), pyarrow.array([True, None, False])])\n            assert awkward.arrow.fromarrow(a).tolist() == [0.0, True, 1.1, None, 3.3, None, False]\n\n    def test_arrow_dictarray(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.DictionaryArray.from_arrays(pyarrow.array([0, 0, 2, 2, 1, 0, 2, 1, 1]), pyarrow.array([""one"", ""two"", ""three""]))\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""one"", ""three"", ""three"", ""two"", ""one"", ""three"", ""two"", ""two""]\n\n    def test_arrow_dictarray_null(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.DictionaryArray.from_arrays(pyarrow.array([0, 0, 2, None, 1, None, 2, 1, 1]), pyarrow.array([""one"", ""two"", ""three""]))\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""one"", ""three"", None, ""two"", None, ""three"", ""two"", ""two""]\n\n    def test_arrow_null_dictarray(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.DictionaryArray.from_arrays(pyarrow.array([0, 0, 2, 2, 1, 0, 2, 1, 1]), pyarrow.array([""one"", None, ""three""]))\n            assert awkward.arrow.fromarrow(a).tolist() == [""one"", ""one"", ""three"", ""three"", None, ""one"", ""three"", None, None]\n\n    def test_arrow_batch(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.RecordBatch.from_arrays(\n                [pyarrow.array([1.1, 2.2, 3.3, None, 5.5]),\n                 pyarrow.array([[1, 2, 3], [], [4, 5], [None], [6]]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, None, None, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}], [None], [{""x"": 6, ""y"": 6.6}]])],\n                [""a"", ""b"", ""c"", ""d"", ""e""])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""a"": 1.1, ""b"": [1, 2, 3], ""c"": {""x"": 1, ""y"": 1.1}, ""d"": {""x"": 1, ""y"": 1.1}, ""e"": [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]}, {""a"": 2.2, ""b"": [], ""c"": {""x"": 2, ""y"": 2.2}, ""d"": None, ""e"": []}, {""a"": 3.3, ""b"": [4, 5], ""c"": {""x"": 3, ""y"": 3.3}, ""d"": None, ""e"": [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]}, {""a"": None, ""b"": [None], ""c"": {""x"": 4, ""y"": None}, ""d"":{""x"": 4, ""y"": None}, ""e"": [None]}, {""a"": 5.5, ""b"": [6], ""c"": {""x"": 5, ""y"": 5.5}, ""d"": {""x"": 5, ""y"": 5.5}, ""e"": [{""x"": 6, ""y"": 6.6}]}]\n\n    def test_arrow_table(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = pyarrow.Table.from_batches([\n                pyarrow.RecordBatch.from_arrays(\n                [pyarrow.array([1.1, 2.2, 3.3, None, 5.5]),\n                 pyarrow.array([[1, 2, 3], [], [4, 5], [None], [6]]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, None, None, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}], [None], [{""x"": 6, ""y"": 6.6}]])],\n                [""a"", ""b"", ""c"", ""d"", ""e""]),\n                pyarrow.RecordBatch.from_arrays(\n                [pyarrow.array([1.1, 2.2, 3.3, None, 5.5]),\n                 pyarrow.array([[1, 2, 3], [], [4, 5], [None], [6]]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([{""x"": 1, ""y"": 1.1}, None, None, {""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]),\n                 pyarrow.array([[{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}], [], [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}], [None], [{""x"": 6, ""y"": 6.6}]])],\n                [""a"", ""b"", ""c"", ""d"", ""e""])])\n            assert awkward.arrow.fromarrow(a).tolist() == [{""a"": 1.1, ""b"": [1, 2, 3], ""c"": {""x"": 1, ""y"": 1.1}, ""d"": {""x"": 1, ""y"": 1.1}, ""e"": [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]}, {""a"": 2.2, ""b"": [], ""c"": {""x"": 2, ""y"": 2.2}, ""d"": None, ""e"": []}, {""a"": 3.3, ""b"": [4, 5], ""c"": {""x"": 3, ""y"": 3.3}, ""d"": None, ""e"": [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]}, {""a"": None, ""b"": [None], ""c"": {""x"": 4, ""y"": None}, ""d"": {""x"": 4, ""y"": None}, ""e"": [None]}, {""a"": 5.5, ""b"": [6], ""c"": {""x"": 5, ""y"": 5.5}, ""d"": {""x"": 5, ""y"": 5.5}, ""e"": [{""x"": 6, ""y"": 6.6}]}, {""a"": 1.1, ""b"": [1, 2, 3], ""c"": {""x"": 1, ""y"": 1.1}, ""d"": {""x"": 1, ""y"": 1.1}, ""e"": [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]}, {""a"": 2.2, ""b"": [], ""c"": {""x"": 2, ""y"": 2.2}, ""d"": None, ""e"": []}, {""a"": 3.3, ""b"": [4, 5], ""c"": {""x"": 3, ""y"": 3.3}, ""d"": None, ""e"": [{""x"": 4, ""y"": None}, {""x"": 5, ""y"": 5.5}]}, {""a"": None, ""b"": [None], ""c"": {""x"": 4, ""y"": None}, ""d"": {""x"": 4, ""y"": None}, ""e"": [None]}, {""a"": 5.5, ""b"": [6], ""c"": {""x"": 5, ""y"": 5.5}, ""d"": {""x"": 5, ""y"": 5.5}, ""e"": [{""x"": 6, ""y"": 6.6}]}]\n\n    def test_arrow_nonnullable_table(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            x = pyarrow.array([1, 2, 3])\n            y = pyarrow.array([1.1, 2.2, 3.3])\n            table = pyarrow.Table.from_arrays([x], [""x""])\n            if hasattr(pyarrow, ""column""):\n                table2 = table.add_column(1, pyarrow.column(pyarrow.field(""y"", y.type, False), numpy.array([1.1, 2.2, 3.3])))\n            else:\n                table2 = table.add_column(1, ""y"", y)\n            assert awkward.arrow.fromarrow(table2).tolist() == [{""x"": 1, ""y"": 1.1}, {""x"": 2, ""y"": 2.2}, {""x"": 3, ""y"": 3.3}]\n\n    def test_arrow_trailing_zero(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8], [], [9.9]])\n        pa_table = awkward.toarrow(awkward.Table(a=a))\n\n        batches = pa_table.to_batches()\n        sink = pyarrow.BufferOutputStream()\n        writer = pyarrow.RecordBatchStreamWriter(sink, batches[0].schema)\n        writer.write_batch(batches[0])\n        writer.close()\n\n        buf = sink.getvalue()\n        reader = pyarrow.ipc.open_stream(buf)\n        for batch in reader:\n            b = awkward.fromarrow(batch)\n            assert a.tolist() == b[""a""].tolist()\n\n    def test_arrow_fromarrow_zerocopy(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5], [6.6, 7.7, 8.8], [], [9.9]])\n            b = awkward.toarrow(a)\n            c = awkward.fromarrow(b)\n            assert c.offsets.ctypes.data == b.buffers()[1].address\n            assert c.content.ctypes.data == b.buffers()[3].address\n            assert c.offsetsaliased(c.starts, c.stops)\n\n    # def test_arrow_writeparquet(self):\n    #     if pyarrow is None:\n    #         pytest.skip(""unable to import pyarrow"")\n    #     else:\n    #         a = pyarrow.Table.from_batches([\n    #             pyarrow.RecordBatch.from_arrays(\n    #             [pyarrow.array([1.1, 2.2, 3.3, None, 5.5]),\n    #              pyarrow.array([[1, 2, 3], [], [None], None, [4, 5, 6]]),\n    #              pyarrow.array([[[1.1, 2.2]], None, [[3.3, None], []], [], [None, [4.4, 5.5]]])],\n    #             [""a"", ""b"", ""c""]),\n    #             pyarrow.RecordBatch.from_arrays(\n    #             [pyarrow.array([2.2, 1.1, 3.3, None, 5.5]),\n    #              pyarrow.array([[2, 1, 3], [], [None], None, [4, 5, 6]]),\n    #              pyarrow.array([[[2.2, 1.1]], None, [[3.3, None], []], [], [None, [4.4, 5.5]]])],\n    #             [""a"", ""b"", ""c""])])\n    #         writer = pyarrow.parquet.ParquetWriter(""tests/samples/features-0_11_1.parquet"", a.schema)\n    #         writer.write_table(a)\n    #         writer.write_table(a)\n    #         writer.close()\n\n    def test_arrow_readparquet(self):\n        if pyarrow is None:\n            pytest.skip(""unable to import pyarrow"")\n        else:\n            a = awkward.arrow.fromparquet(""tests/samples/features-0_11_1.parquet"", persistvirtual=True)\n            assert a[""a""].tolist() == [1.1, 2.2, 3.3, None, 5.5, 2.2, 1.1, 3.3, None, 5.5, 1.1, 2.2, 3.3, None, 5.5, 2.2, 1.1, 3.3, None, 5.5]\n            storage = {}\n            awkward.serialize(a, storage)\n            b = awkward.deserialize(storage)\n            assert b[""b""].tolist() == [[1, 2, 3], [], [None], None, [4, 5, 6], [2, 1, 3], [], [None], None, [4, 5, 6], [1, 2, 3], [], [None], None, [4, 5, 6], [2, 1, 3], [], [None], None, [4, 5, 6]]\n            assert a[""c""].tolist() == [[[1.1, 2.2]], None, [[3.3, None], []], [], [None, [4.4, 5.5]], [[2.2, 1.1]], None, [[3.3, None], []], [], [None, [4.4, 5.5]], [[1.1, 2.2]], None, [[3.3, None], []], [], [None, [4.4, 5.5]], [[2.2 , 1.1]], None, [[3.3, None], []], [], [None, [4.4, 5.5]]]\n\ndef test_arrow_writeparquet2(tmpdir):\n    if pyarrow is None:\n        pytest.skip(""unable to import pyarrow"")\n    else:\n        filename = os.path.join(str(tmpdir), ""tmp.parquet"")\n\n    a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n    b = awkward.fromiter([100, 200, None])\n\n    awkward.toparquet(filename, [b, b, b])\n    assert awkward.fromparquet(filename).tolist() == [100, 200, None, 100, 200, None, 100, 200, None]\n\n    awkward.toparquet(filename, a)\n    assert awkward.fromparquet(filename).tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n\n    awkward.toparquet(filename, awkward.Table(x=a, y=b))\n    c = awkward.fromparquet(filename)\n    assert c.tolist() == [{\'x\': [1.1, 2.2, 3.3], \'y\': 100}, {\'x\': [], \'y\': 200}, {\'x\': [4.4, 5.5], \'y\': None}]\n\n    awkward.toparquet(filename, c)\n    d = awkward.fromparquet(filename)\n    assert c.tolist() == d.tolist()\n    assert isinstance(c, awkward.ChunkedArray) and isinstance(d, awkward.ChunkedArray)\n    assert len(c.chunks) == 1 and len(d.chunks) == 1\n    assert isinstance(c.chunks[0], awkward.Table) and isinstance(d.chunks[0], awkward.Table)\n    assert c.chunks[0].columns == d.chunks[0].columns\n    cstuff = c.chunks[0][""x""][:]\n    dstuff = d.chunks[0][""x""][:]\n    assert isinstance(cstuff, awkward.BitMaskedArray) and isinstance(dstuff, awkward.BitMaskedArray)\n    assert cstuff.boolmask().tolist() == dstuff.boolmask().tolist()\n    assert isinstance(cstuff.content, awkward.JaggedArray) and isinstance(dstuff.content, awkward.JaggedArray)\n    assert isinstance(cstuff.content.content, awkward.BitMaskedArray) and isinstance(dstuff.content.content, awkward.BitMaskedArray)\n    assert cstuff.content.content.boolmask().tolist() == dstuff.content.content.boolmask().tolist()\n    assert isinstance(cstuff.content.content.content, numpy.ndarray) and isinstance(dstuff.content.content.content, numpy.ndarray)\n'"
tests/test_awkward_numba.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport pytest\nimport numpy\n\nawkward_numba = pytest.importorskip(""awkward.numba"")\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_awkward_numba_init(self):\n        a = awkward_numba.JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a, awkward_numba.array.jagged.JaggedArrayNumba)\n        assert a.JaggedArray is awkward_numba.array.jagged.JaggedArrayNumba\n\n        assert isinstance(a[2:], awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a[[False, True, True, False]], awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a[[1, 2]], awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a + 100, awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(numpy.sin(a), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.cross(a), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.pairs(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.distincts(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.cross(a, nested=True), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.pairs(nested=True), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.distincts(nested=True), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert isinstance(a.concatenate([a]), awkward_numba.array.jagged.JaggedArrayNumba)\n\n        b = awkward_numba.JaggedArray([1, 4, 4, 6], [4, 4, 6, 11], [999, 0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a + b, awkward_numba.array.jagged.JaggedArrayNumba)\n\n    def test_awkward_numba_argmin(self):\n        a = awkward_numba.JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a.argmin(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert a.argmin().tolist() == [[0], [], [0], [0]]\n\n        a = awkward_numba.JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a.argmin(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert a.argmin().tolist() == [[[0], []], [[0], [0]]]\n\n    def test_awkward_numba_argmax(self):\n        a = awkward_numba.JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a.argmin(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert a.argmax().tolist() == [[2], [], [1], [4]]\n\n        a = awkward_numba.JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert isinstance(a.argmin(), awkward_numba.array.jagged.JaggedArrayNumba)\n        assert a.argmax().tolist() == [[[2], []], [[1], [4]]]\n'"
tests/test_chunked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_chunked_nbytes(self):\n        assert isinstance(ChunkedArray([[], [0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []]).nbytes, int)\n\n    def test_chunked_allslices(self):\n        chunked = ChunkedArray([[], [0.0, 1.1, 2.2, 3.3, 4.4], [5.5, 6.6], [], [7.7], [8.8, 9.9], []])\n        regular = numpy.concatenate(chunked.chunks).tolist()\n        for start in [None] + list(range(-12, 12 + 1)):\n            for stop in [None] + list(range(-12, 12 + 1)):\n                for step in [None, 1, 2, 3, 4, 5, 9, 10, 11, -1, -2, -3, -4, -5, -9, -10, -11]:\n                    # print(start, stop, step)\n                    assert numpy.concatenate(chunked[start:stop:step].chunks).tolist() == regular[start:stop:step]\n\n    def test_chunked_iteration(self):\n        a = ChunkedArray([[], [0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []])\n        assert a.tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        a = ChunkedArray([[0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []])\n        assert a.tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        a = ChunkedArray([[], [0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9]])\n        assert a.tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        a = ChunkedArray([[]])\n        assert a.tolist() == []\n\n        a = ChunkedArray([])\n        assert a.tolist() == []\n\n    def test_chunked_dtype(self):\n        a = ChunkedArray([[], [0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []])\n        assert a.dtype == numpy.dtype(int)\n\n        a = ChunkedArray([[0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []])\n        assert a.dtype == numpy.dtype(int)\n\n        a = ChunkedArray([])\n        assert a.dtype == numpy.dtype(float)\n\n    def test_chunked_get(self):\n        a = ChunkedArray([[], [0, 1, 2, 3, 4], [5, 6], [], [7, 8, 9], []])\n        assert [a[i] for i in range(10)] == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        assert [a[i : i + 1].tolist() for i in range(10)] == [[0], [1], [2], [3], [4], [5], [6], [7], [8], [9]]\n        assert [a[i : i + 2].tolist() for i in range(10 - 1)] == [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]\n        assert [a[i : i + 3].tolist() for i in range(10 - 2)] == [[0, 1, 2], [1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7], [6, 7, 8], [7, 8, 9]]\n        assert [a[i : i + 4].tolist() for i in range(10 - 3)] == [[0, 1, 2, 3], [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7], [5, 6, 7, 8], [6, 7, 8, 9]]\n        assert [a[i : i + 4 : 2].tolist() for i in range(10 - 3)] == [[0, 2], [1, 3], [2, 4], [3, 5], [4, 6], [5, 7], [6, 8]]\n        assert [a[i : i + 4 : 3].tolist() for i in range(10 - 3)] == [[0, 3], [1, 4], [2, 5], [3, 6], [4, 7], [5, 8], [6, 9]]\n        assert [a[i + 4 : i : -1].tolist() for i in range(10 - 4)] == [[4, 3, 2, 1], [5, 4, 3, 2], [6, 5, 4, 3], [7, 6, 5, 4], [8, 7, 6, 5], [9, 8, 7, 6]]\n        assert [a[i + 4 : i : -2].tolist() for i in range(10 - 4)] == [[4, 2], [5, 3], [6, 4], [7, 5], [8, 6], [9, 7]]\n        assert [a[i + 4 : i : -3].tolist() for i in range(10 - 4)] == [[4, 1], [5, 2], [6, 3], [7, 4], [8, 5], [9, 6]]\n\n        assert a[4:].tolist() == [4, 5, 6, 7, 8, 9]\n        assert a[5:].tolist() == [5, 6, 7, 8, 9]\n        assert a[6:].tolist() == [6, 7, 8, 9]\n        assert a[7:].tolist() == [7, 8, 9]\n        assert a[8:].tolist() == [8, 9]\n        assert a[:4].tolist() == [0, 1, 2, 3]\n        assert a[:5].tolist() == [0, 1, 2, 3, 4]\n        assert a[:6].tolist() == [0, 1, 2, 3, 4, 5]\n        assert a[:7].tolist() == [0, 1, 2, 3, 4, 5, 6]\n        assert a[:8].tolist() == [0, 1, 2, 3, 4, 5, 6, 7]\n\n        assert a[4::2].tolist() == [4, 6, 8]\n        assert a[5::2].tolist() == [5, 7, 9]\n        assert a[6::2].tolist() == [6, 8]\n        assert a[7::2].tolist() == [7, 9]\n        assert a[8::2].tolist() == [8]\n        assert a[:4:2].tolist() == [0, 2]\n        assert a[:5:2].tolist() == [0, 2, 4]\n        assert a[:6:2].tolist() == [0, 2, 4]\n        assert a[:7:2].tolist() == [0, 2, 4, 6]\n        assert a[:8:2].tolist() == [0, 2, 4, 6]\n\n        assert a[4::-1].tolist() == [4, 3, 2, 1, 0]\n        assert a[5::-1].tolist() == [5, 4, 3, 2, 1, 0]\n        assert a[6::-1].tolist() == [6, 5, 4, 3, 2, 1, 0]\n        assert a[7::-1].tolist() == [7, 6, 5, 4, 3, 2, 1, 0]\n        assert a[8::-1].tolist() == [8, 7, 6, 5, 4, 3, 2, 1, 0]\n        assert a[:4:-1].tolist() == [9, 8, 7, 6, 5]\n        assert a[:5:-1].tolist() == [9, 8, 7, 6]\n        assert a[:6:-1].tolist() == [9, 8, 7]\n        assert a[:7:-1].tolist() == [9, 8]\n        assert a[:8:-1].tolist() == [9]\n\n        assert a[4::-2].tolist() == [4, 2, 0]\n        assert a[5::-2].tolist() == [5, 3, 1]\n        assert a[6::-2].tolist() == [6, 4, 2, 0]\n        assert a[7::-2].tolist() == [7, 5, 3, 1]\n        assert a[8::-2].tolist() == [8, 6, 4, 2, 0]\n        assert a[:4:-2].tolist() == [9, 7, 5]\n        assert a[:5:-2].tolist() == [9, 7]\n        assert a[:6:-2].tolist() == [9, 7]\n        assert a[:7:-2].tolist() == [9]\n        assert a[:8:-2].tolist() == [9]\n\n        assert a[[8, 6, 4, 5, 0]].tolist() == [8, 6, 4, 5, 0]\n        assert a[[6, 4, 5, 0]].tolist() == [6, 4, 5, 0]\n        assert a[[5, 6, 4, 5, 5, 5, 0]].tolist() == [5, 6, 4, 5, 5, 5, 0]\n        self.assertRaises(IndexError, lambda: a[[8, 6, 4, 5, 0, 99]])\n\n        assert a[[True, False, True, False, True, False, True, False, True, False]].tolist() == [0, 2, 4, 6, 8]\n        assert a[[False, False, False, False, False, False, False, False, False, False]].tolist() == []\n        assert a[[True, True, True, True, True, True, True, True, True, True]].tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        self.assertRaises(IndexError, lambda: a[[True, True, True, True, True, True, True, True, True, True, True]])\n        self.assertRaises(IndexError, lambda: a[[True, True, True, True, True, True, True, True, True]])\n\n    def test_chunked_get2d(self):\n        a = ChunkedArray([[], [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]], [[5, 5], [6, 6]], [], [[7, 7], [8, 8], [9, 9]], []])\n        assert [a[i].tolist() for i in range(10)] == [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]\n        assert a[4:].tolist() == [[4, 4], [5, 5], [6, 6], [7, 7], [8, 8], [9, 9]]\n        assert a[[8, 6, 4, 5, 0]].tolist() == [[8, 8], [6, 6], [4, 4], [5, 5], [0, 0]]\n        assert a[[True, False, True, False, True, False, True, False, True, False]].tolist() == [[0, 0], [2, 2], [4, 4], [6, 6], [8, 8]]\n\n        a = ChunkedArray([[], [[0.0, 0.0], [1.0, 1.1], [2.0, 2.2], [3.0, 3.3], [4.0, 4.4]], [[5.0, 5.5], [6.0, 6.6]], [], [[7.0, 7.7], [8.0, 8.8], [9.0, 9.9]], []])\n        assert [a[i, 0].tolist() for i in range(10)] == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert [a[i, 1].tolist() for i in range(10)] == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[4:, 0].tolist() == [4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n        assert a[4:, 1].tolist() == [4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[[8, 6, 4, 5, 0], 0].tolist() == [8.0, 6.0, 4.0, 5.0, 0.0]\n        assert a[[8, 6, 4, 5, 0], 1].tolist() == [8.8, 6.6, 4.4, 5.5, 0.0]\n        assert a[[True, False, True, False, True, False, True, False, True, False], 0].tolist() == [0.0, 2.0, 4.0, 6.0, 8.0]\n        assert a[[True, False, True, False, True, False, True, False, True, False], 1].tolist() == [0.0, 2.2, 4.4, 6.6, 8.8]\n\n    def test_chunked_flatten_len(self):\n        a = ChunkedArray([[[0, 1]], [[2, 3], [4, 5]], [[6, 7], [8, 9]]])\n        assert len(a) == 5\n        assert len(a.flatten()) == 10\n\n    def test_appendable_append(self):\n        a = AppendableArray(3, numpy.float64)\n        assert a.tolist() == []\n        assert len(a.chunks) == 0\n        assert a.offsets.tolist() == [0]\n\n        a.append(0.0)\n        assert a.tolist() == [0.0]\n        assert len(a.chunks) == 1\n        assert a.offsets.tolist() == [0, 1]\n\n        a.append(1.1)\n        assert a.tolist() == [0.0, 1.1]\n        assert len(a.chunks) == 1\n        assert a.offsets.tolist() == [0, 2]\n\n        a.append(2.2)\n        assert a.tolist() == [0.0, 1.1, 2.2]\n        assert len(a.chunks) == 1\n        assert a.offsets.tolist() == [0, 3]\n\n        a.append(3.3)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3]\n        assert len(a.chunks) == 2\n        assert a.offsets.tolist() == [0, 3, 4]\n\n        a.append(4.4)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4]\n        assert len(a.chunks) == 2\n        assert a.offsets.tolist() == [0, 3, 5]\n\n        a.append(5.5)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5]\n        assert len(a.chunks) == 2\n        assert a.offsets.tolist() == [0, 3, 6]\n\n        a.append(6.6)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6]\n        assert len(a.chunks) == 3\n        assert a.offsets.tolist() == [0, 3, 6, 7]\n\n        a.append(7.7)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n        assert len(a.chunks) == 3\n        assert a.offsets.tolist() == [0, 3, 6, 8]\n\n        a.append(8.8)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8]\n        assert len(a.chunks) == 3\n        assert a.offsets.tolist() == [0, 3, 6, 9]\n\n        a.append(9.9)\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert [a[i] for i in range(len(a))] == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert len(a.chunks) == 4\n        assert a.offsets.tolist() == [0, 3, 6, 9, 10]\n\n    def test_appendable_extend(self):\n        a = AppendableArray(3, numpy.float64)\n        assert a.tolist() == []\n        assert len(a.chunks) == 0\n        assert a.offsets.tolist() == [0]\n\n        a.extend([0.0, 1.1])\n        assert a.tolist() == [0.0, 1.1]\n        assert len(a.chunks) == 1\n        assert a.offsets.tolist() == [0, 2]\n\n        a.extend([2.2, 3.3])\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3]\n        assert len(a.chunks) == 2\n        assert a.offsets.tolist() == [0, 3, 4]\n\n        a.extend([4.4, 5.5])\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5]\n        assert len(a.chunks) == 2\n        assert a.offsets.tolist() == [0, 3, 6]\n\n        a.extend([6.6, 7.7])\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7]\n        assert len(a.chunks) == 3\n        assert a.offsets.tolist() == [0, 3, 6, 8]\n\n        a.extend([8.8, 9.9])\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert [a[i] for i in range(len(a))] == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert len(a.chunks) == 4\n        assert a.offsets.tolist() == [0, 3, 6, 9, 10]\n'"
tests/test_combine.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    ################### old tests\n\n    # def test_ChunkedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_AppendableArray(self):\n    #     pass\n\n    # def test_ChunkedArray_IndexedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_UnionArray(self):\n    #     pass\n\n    # def test_ChunkedArray_JaggedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_MaskedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_ChunkedArray_SparseArray(self):\n    #     pass\n\n    # def test_ChunkedArray_Table(self):\n    #     pass\n\n    # def test_ChunkedArray_VirtualArray(self):\n    #     pass\n\n    # def test_ChunkedArray_VirtualObjectArray(self):\n    #     pass\n\n    # def test_PartitionedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_AppendableArray(self):\n    #     pass\n\n    # def test_PartitionedArray_IndexedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_UnionArray(self):\n    #     pass\n\n    # def test_PartitionedArray_JaggedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_MaskedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_PartitionedArray_SparseArray(self):\n    #     pass\n\n    # def test_PartitionedArray_Table(self):\n    #     pass\n\n    # def test_PartitionedArray_VirtualArray(self):\n    #     pass\n\n    # def test_PartitionedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_AppendableArray_ChunkedArray(self):\n    #     pass\n\n    # def test_AppendableArray_PartitionedArray(self):\n    #     pass\n\n    # def test_AppendableArray_AppendableArray(self):\n    #     pass\n\n    # def test_AppendableArray_IndexedArray(self):\n    #     pass\n\n    # def test_AppendableArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_AppendableArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_AppendableArray_UnionArray(self):\n    #     pass\n\n    # def test_AppendableArray_JaggedArray(self):\n    #     pass\n\n    # def test_AppendableArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_AppendableArray_MaskedArray(self):\n    #     pass\n\n    # def test_AppendableArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_AppendableArray_SparseArray(self):\n    #     pass\n\n    # def test_AppendableArray_Table(self):\n    #     pass\n\n    # def test_AppendableArray_VirtualArray(self):\n    #     pass\n\n    # def test_AppendableArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_IndexedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_IndexedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_IndexedArray_AppendableArray(self):\n    #     pass\n\n    # def test_IndexedArray_IndexedArray(self):\n    #     pass\n\n    # def test_IndexedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_IndexedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_IndexedArray_UnionArray(self):\n    #     pass\n\n    # def test_IndexedArray_JaggedArray(self):\n    #     pass\n\n    # def test_IndexedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_IndexedArray_MaskedArray(self):\n    #     pass\n\n    # def test_IndexedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_IndexedArray_SparseArray(self):\n    #     pass\n\n    # def test_IndexedArray_Table(self):\n    #     pass\n\n    # def test_IndexedArray_VirtualArray(self):\n    #     pass\n\n    # def test_IndexedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_ByteIndexedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_AppendableArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_IndexedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_UnionArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_JaggedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_MaskedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_SparseArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_Table(self):\n    #     pass\n\n    # def test_ByteIndexedArray_VirtualArray(self):\n    #     pass\n\n    # def test_ByteIndexedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_IndexedMaskedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_AppendableArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_IndexedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_UnionArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_JaggedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_MaskedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_SparseArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_Table(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_VirtualArray(self):\n    #     pass\n\n    # def test_IndexedMaskedArray_VirtualObjectArray(self):\n    #     pass\n\n    # def test_UnionArray_ChunkedArray(self):\n    #     pass\n\n    # def test_UnionArray_PartitionedArray(self):\n    #     pass\n\n    # def test_UnionArray_AppendableArray(self):\n    #     pass\n\n    # def test_UnionArray_IndexedArray(self):\n    #     pass\n\n    # def test_UnionArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_UnionArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_UnionArray_UnionArray(self):\n    #     pass\n\n    # def test_UnionArray_JaggedArray(self):\n    #     pass\n\n    # def test_UnionArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_UnionArray_MaskedArray(self):\n    #     pass\n\n    # def test_UnionArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_UnionArray_SparseArray(self):\n    #     pass\n\n    # def test_UnionArray_Table(self):\n    #     pass\n\n    # def test_UnionArray_VirtualArray(self):\n    #     pass\n\n    # def test_UnionArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_JaggedArray_ChunkedArray(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], ChunkedArray([[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7, 8.8, 9.9]]))\n    #     assert a.tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n    #     assert a[2].tolist() == [3.3, 4.4]\n    #     assert a[2:4].tolist() == [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    # def test_JaggedArray_PartitionedArray(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], PartitionedArray([0, 4, 10], [[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7, 8.8, 9.9]]))\n    #     assert a.tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n    #     assert a[2].tolist() == [3.3, 4.4]\n    #     assert a[2:4].tolist() == [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    # def test_JaggedArray_AppendableArray(self):\n    #     pass\n\n    # def test_JaggedArray_IndexedArray(self):\n    #     a = JaggedArray([0, 3, 3], [3, 3, 5], IndexedArray([9, 8, 7, 4, 4], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [[9.9, 8.8, 7.7], [], [4.4, 4.4]]\n\n    # def test_JaggedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_JaggedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_JaggedArray_UnionArray(self):\n    #     pass\n\n    # def test_JaggedArray_JaggedArray(self):\n    #     a = JaggedArray([0, 2, 2], [2, 2, 4], JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [[[0.0, 1.1, 2.2], []], [], [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n\n    # def test_JaggedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_JaggedArray_MaskedArray(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], MaskedArray([False, False, True, True, False, False, False, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [[0.0, 1.1, None], [], [None, 4.4], [5.5, 6.6, 7.7, None, 9.9]]\n\n    # def test_JaggedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_JaggedArray_SparseArray(self):\n    #     pass\n\n    # def test_JaggedArray_Table(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], Table(10, one=[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], two=[0, 100, 200, 300, 400, 500, 600, 700, 800, 900]))\n    #     assert a.tolist() == [[{""one"": 0.0, ""two"": 0}, {""one"": 1.1, ""two"": 100}, {""one"": 2.2, ""two"": 200}], [], [{""one"": 3.3, ""two"": 300}, {""one"": 4.4, ""two"": 400}], [{""one"": 5.5, ""two"": 500}, {""one"": 6.6, ""two"": 600}, {""one"": 7.7, ""two"": 700}, {""one"": 8.8, ""two"": 800}, {""one"": 9.9, ""two"": 900}]]\n    #     assert a[""one""].tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n    #     assert a[""two""].tolist() == [[0, 100, 200], [], [300, 400], [500, 600, 700, 800, 900]]\n\n    # def test_JaggedArray_VirtualArray(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], VirtualArray(lambda: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    # def test_JaggedArray_VirtualObjectArray(self):\n    #     a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], VirtualObjectArray(str, [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [[""0.0"", ""1.1"", ""2.2""], [], [""3.3"", ""4.4""], [""5.5"", ""6.6"", ""7.7"", ""8.8"", ""9.9""]]\n    \n    # def test_ByteJaggedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_AppendableArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_IndexedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_UnionArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_JaggedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_MaskedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_SparseArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_Table(self):\n    #     pass\n\n    # def test_ByteJaggedArray_VirtualArray(self):\n    #     pass\n\n    # def test_ByteJaggedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_MaskedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_MaskedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_MaskedArray_AppendableArray(self):\n    #     pass\n\n    # def test_MaskedArray_IndexedArray(self):\n    #     pass\n\n    # def test_MaskedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_MaskedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_MaskedArray_UnionArray(self):\n    #     pass\n\n    # def test_MaskedArray_JaggedArray(self):\n    #     a = MaskedArray([True, False, False, True], JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [None, [], [3.3, 4.4], None]\n\n    # def test_MaskedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_MaskedArray_MaskedArray(self):\n    #     a = MaskedArray([False, False, False, False, False, True, True, True, True, True], MaskedArray([False, True, False, True, False, True, False, True, False, True], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n    #     assert a.tolist() == [0.0, None, 2.2, None, 4.4, None, None, None, None, None]\n\n    # def test_MaskedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_MaskedArray_SparseArray(self):\n    #     pass\n\n    # def test_MaskedArray_Table(self):\n    #     a = MaskedArray([False, True, False, True, False, True, False, True, False, True], Table(10, one=[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], two=[0, 100, 200, 300, 400, 500, 600, 700, 800, 900]))\n    #     assert a[2][""one""], 2 == 2\n    #     assert a[2][""two""] == 200\n    #     assert a.tolist() == [{""one"": 0.0, ""two"": 0}, None, {""one"": 2.2, ""two"": 200}, None, {""one"": 4.4, ""two"": 400}, None, {""one"": 6.6, ""two"": 600}, None, {""one"": 8.8, ""two"": 800}, None]\n\n    # def test_MaskedArray_VirtualArray(self):\n    #     pass\n\n    # def test_MaskedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_BitMaskedArray_ChunkedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_PartitionedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_AppendableArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_IndexedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_UnionArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_JaggedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_MaskedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_SparseArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_Table(self):\n    #     pass\n\n    # def test_BitMaskedArray_VirtualArray(self):\n    #     pass\n\n    # def test_BitMaskedArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_SparseArray_ChunkedArray(self):\n    #     pass\n\n    # def test_SparseArray_PartitionedArray(self):\n    #     pass\n\n    # def test_SparseArray_AppendableArray(self):\n    #     pass\n\n    # def test_SparseArray_IndexedArray(self):\n    #     pass\n\n    # def test_SparseArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_SparseArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_SparseArray_UnionArray(self):\n    #     pass\n\n    # def test_SparseArray_JaggedArray(self):\n    #     pass\n\n    # def test_SparseArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_SparseArray_MaskedArray(self):\n    #     pass\n\n    # def test_SparseArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_SparseArray_SparseArray(self):\n    #     pass\n\n    # def test_SparseArray_Table(self):\n    #     pass\n\n    # def test_SparseArray_VirtualArray(self):\n    #     pass\n\n    # def test_SparseArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_Table_ChunkedArray(self):\n    #     a = Table(10, one=ChunkedArray([[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7, 8.8, 9.9]]), two=ChunkedArray([[0, 100, 200, 300, 400, 500, 600], [700, 800, 900]]))\n    #     assert a.tolist() == [{""one"": 0.0, ""two"": 0}, {""one"": 1.1, ""two"": 100}, {""one"": 2.2, ""two"": 200}, {""one"": 3.3, ""two"": 300}, {""one"": 4.4, ""two"": 400}, {""one"": 5.5, ""two"": 500}, {""one"": 6.6, ""two"": 600}, {""one"": 7.7, ""two"": 700}, {""one"": 8.8, ""two"": 800}, {""one"": 9.9, ""two"": 900}]\n\n    # def test_Table_PartitionedArray(self):\n    #     a = Table(10, one=PartitionedArray([0, 4, 10], [[0.0, 1.1, 2.2, 3.3], [4.4, 5.5, 6.6, 7.7, 8.8, 9.9]]), two=PartitionedArray([0, 7, 10], [[0, 100, 200, 300, 400, 500, 600], [700, 800, 900]]))\n    #     assert a.tolist() == [{""one"": 0.0, ""two"": 0}, {""one"": 1.1, ""two"": 100}, {""one"": 2.2, ""two"": 200}, {""one"": 3.3, ""two"": 300}, {""one"": 4.4, ""two"": 400}, {""one"": 5.5, ""two"": 500}, {""one"": 6.6, ""two"": 600}, {""one"": 7.7, ""two"": 700}, {""one"": 8.8, ""two"": 800}, {""one"": 9.9, ""two"": 900}]\n\n    # def test_Table_AppendableArray(self):\n    #     pass\n\n    # def test_Table_IndexedArray(self):\n    #     a = Table(5, one=IndexedArray([8, 6, 4, 2, 0], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]), two=IndexedArray([0, 1, 2, 2, 1], [0, 100, 200]))\n    #     assert a.tolist() == [{""one"": 8.8, ""two"": 0}, {""one"": 6.6, ""two"": 100}, {""one"": 4.4, ""two"": 200}, {""one"": 2.2, ""two"": 200}, {""one"": 0.0, ""two"": 100}]\n\n    # def test_Table_ByteIndexedArray(self):\n    #     pass\n\n    # def test_Table_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_Table_UnionArray(self):\n    #     pass\n\n    # def test_Table_JaggedArray(self):\n    #     a = Table(4, one=JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]), two=[0, 100, 200, 300])\n    #     assert a.tolist() == [{""one"": [0.0, 1.1, 2.2], ""two"": 0}, {""one"": [], ""two"": 100}, {""one"": [3.3, 4.4], ""two"": 200}, {""one"": [5.5, 6.6, 7.7, 8.8, 9.9], ""two"": 300}]\n\n    # def test_Table_ByteJaggedArray(self):\n    #     pass\n\n    # def test_Table_MaskedArray(self):\n    #     pass\n\n    # def test_Table_BitMaskedArray(self):\n    #     pass\n\n    # def test_Table_SparseArray(self):\n    #     pass\n\n    # def test_Table_Table(self):\n    #     a = Table(5, one=[0.0, 1.1, 2.2, 3.3, 4.4], two=Table(5, x=[0, 100, 200, 300, 400], y=[False, True, False, True, False]))\n    #     assert a.tolist() == [{""one"": 0.0, ""two"": {""x"": 0, ""y"": False}}, {""one"": 1.1, ""two"": {""x"": 100, ""y"": True}}, {""one"": 2.2, ""two"": {""x"": 200, ""y"": False}}, {""one"": 3.3, ""two"": {""x"": 300, ""y"": True}}, {""one"": 4.4, ""two"": {""x"": 400, ""y"": False}}]\n\n    # def test_Table_VirtualArray(self):\n    #     pass\n\n    # def test_Table_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_VirtualArray_ChunkedArray(self):\n    #     pass\n\n    # def test_VirtualArray_PartitionedArray(self):\n    #     pass\n\n    # def test_VirtualArray_AppendableArray(self):\n    #     pass\n\n    # def test_VirtualArray_IndexedArray(self):\n    #     pass\n\n    # def test_VirtualArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_VirtualArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_VirtualArray_UnionArray(self):\n    #     pass\n\n    # def test_VirtualArray_JaggedArray(self):\n    #     pass\n\n    # def test_VirtualArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_VirtualArray_MaskedArray(self):\n    #     pass\n\n    # def test_VirtualArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_VirtualArray_SparseArray(self):\n    #     pass\n\n    # def test_VirtualArray_Table(self):\n    #     pass\n\n    # def test_VirtualArray_VirtualArray(self):\n    #     pass\n\n    # def test_VirtualArray_VirtualObjectArray(self):\n    #     pass\n    \n    # def test_VirtualObjectArray_ChunkedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_PartitionedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_AppendableArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_IndexedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_ByteIndexedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_IndexedMaskedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_UnionArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_JaggedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_ByteJaggedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_MaskedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_BitMaskedArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_SparseArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_Table(self):\n    #     pass\n\n    # def test_VirtualObjectArray_VirtualArray(self):\n    #     pass\n\n    # def test_VirtualObjectArray_VirtualObjectArray(self):\n    #     pass\n'"
tests/test_cpp.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2019, IRIS-HEP\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of the copyright holder nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nimport sys\n\nimport unittest\n\nimport numpy\nimport pytest\n\nimport awkward\nawkward_cpp = pytest.importorskip(""awkward.cpp"")\nfrom awkward.cpp import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_cpp_unbox(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        def test(x):\n            return 3.14\n        test(a)\n        test(a2)\n\n    def test_cpp_box(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        def test(x):\n            return x\n        assert test(a).tolist() == a.tolist()\n        assert test(a2).tolist() == a2.tolist()\n\n    def test_cpp_len(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 1], a)\n        def test1(x):\n            return len(x)\n        assert test1(a) == 3\n        assert test1(a2) == 2\n\n    def test_cpp_getitem_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        def test1(x, i, j):\n            return x[i][j]\n        assert test1(a, 0, 0) == 1.1\n        assert test1(a, 0, 1) == 2.2\n        assert test1(a, 0, 2) == 3.3\n        assert test1(a, 2, 0) == 4.4\n        assert test1(a, 2, 1) == 5.5\n        def test2(x, i):\n            return x[i]\n        assert test2(a, 0).tolist() == [1.1, 2.2, 3.3]\n        assert test2(a, 1).tolist() == []\n        assert test2(a, 2).tolist() == [4.4, 5.5]\n        assert test2(a2, 0).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test2(a2, 1).tolist() == []\n        assert test2(a2, 2).tolist() == [[4.4, 5.5]]\n        assert test2(a2, 0).content.tolist() == a.content.tolist()\n\n    def test_cpp_getitem_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)   # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        def test1(x, i, j):\n            return x[i:j]\n        assert test1(a, 0, 2).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test1(a, 1, 3).tolist() == [[], [4.4, 5.5]]\n        assert test1(a2, 0, 2).tolist() == [[[1.1, 2.2, 3.3], []], []]\n        assert test1(a2, 1, 3).tolist() == [[], [[4.4, 5.5]]]\n\n    def test_cpp_getitem_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a2 = JaggedArray(starts, stops, content)\n        index = numpy.array([2, 2, 0, 1])\n        def test1(x, i):\n            return x[i]\n        z = test1(a, index)\n        assert z.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z.content.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n        z2 = test1(a2, index)\n        assert z2.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z2.content.tolist() == [1.1, 2.2, 3.3, 999, 4.4, 5.5]\n        #def test2(x, i):\n        #    return x[i].compact()\n        #z = test2(a, index)\n        #assert z.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        #ssert z.content.tolist() == [4.4, 5.5, 4.4, 5.5, 1.1, 2.2, 3.3]\n        #z2 = test2(a2, index)\n        #assert z2.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        #assert z2.content.tolist() == [4.4, 5.5, 4.4, 5.5, 1.1, 2.2, 3.3]\n        #a3 = JaggedArray.fromcounts([2, 0, 1], a)\n        #assert test1(a3, index).tolist() == [[[4.4, 5.5]], [[4.4, 5.5]], [[1.1, 2.2, 3.3], []], []]\n\n    def test_cpp_getitem_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a2 = JaggedArray(starts, stops, content)\n        index = numpy.array([False, True, True])\n        def test1(x, i):\n            return x[i]\n        z = test1(a, index)\n        assert z.tolist() == [[], [4.4, 5.5]]\n        assert z.content.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n        z2 = test1(a2, index)\n        assert z2.tolist() == [[], [4.4, 5.5]]\n        assert z2.content.tolist() == [1.1, 2.2, 3.3, 999, 4.4, 5.5]\n        #def test2(x, i):\n        #    return x[i].compact()\n        #z = test2(a, index)\n        #assert z.tolist() == [[], [4.4, 5.5]]\n        #assert z.content.tolist() == [4.4, 5.5]\n        #z2 = test2(a2, index)\n        #assert z2.tolist() == [[], [4.4, 5.5]]\n        #assert z2.content.tolist() == [4.4, 5.5]\n        #a3 = JaggedArray.fromcounts([2, 0, 1], a)\n        #assert test1(a3, index).tolist() == [[], [[4.4, 5.5]]]\n\n    def test_cpp_getitem_tuple_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        def test1(x, i):\n            return x[i,]\n        assert test1(a, 2).tolist() == [4.4, 5.5]\n\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)  # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        def test2(x, i, j):\n            return x[i, j]\n        assert test2(a2, 0, 0).tolist() == [1.1, 2.2, 3.3]\n\n    def test_cpp_getitem_tuple_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)   # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        def test1(x, i, j):\n            return x[i:j,]\n        assert test1(a, 0, 2).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test1(a, 1, 3).tolist() == [[], [4.4, 5.5]]\n        assert test1(a2, 0, 2).tolist() == [[[1.1, 2.2, 3.3], []], []]\n        assert test1(a2, 1, 3).tolist() == [[], [[4.4, 5.5]]]\n\n        a3 = JaggedArray.fromcounts([2, 1], a)   # [[[1.1, 2.2, 3.3], []], [[4.4, 5.5]]]\n        assert a3[0:2, 0].tolist() == [[1.1, 2.2, 3.3], [4.4, 5.5]]\n        def test2(x, i, j, k):\n            return x[i:j, k]\n        assert test2(a3, 0, 2, 0).tolist() == [[1.1, 2.2, 3.3], [4.4, 5.5]]\n\n    def test_cpp_getitem_tuple_slice_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)\n        def test3(x, i, j, k):\n            return x[i:j, k]\n        assert test3(a, 0, 2, 1).tolist() == [2.2, 5.5]\n        assert test3(a2, 0, 2, 1).tolist() == [[4.4, 5.5], [8.8, 9.9]]\n\n    def test_cpp_getitem_tuple_slice_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)\n        def test3(x, i, j, k, l):\n            return x[i:j, k:l]\n        assert test3(a, 0, 2, -2, None).tolist() == [[2.2, 3.3], [4.4, 5.5]]\n        assert test3(a2, 0, 2, 1, 2).tolist() == [[[4.4, 5.5]], [[8.8, 9.9]]]\n\n        def test4(x, i, j, k, l):\n            return x[i:j, k:l:1]\n        assert test4(a, 0, 2, -2, None).tolist() == [[2.2, 3.3], [4.4, 5.5]]\n        assert test4(a2, 0, 2, 1, 2).tolist() == [[[4.4, 5.5]], [[8.8, 9.9]]]\n\n    def test_cpp_getitem_tuple_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)   # [[[1.1, 2.2, 3.3], [4.4, 5.5]], [[6.6, 7.7], [8.8, 9.9]]]\n        def test1(x, i, j):\n            return x[i, j]\n        assert test1(a, numpy.array([True, False, True, False]), 1).tolist() == [2.2, 7.7]\n        assert test1(a2, numpy.array([False, True]), 1).tolist() == [[8.8, 9.9]]\n\n    def test_cpp_getitem_tuple_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)   # [[[1.1, 2.2, 3.3], [4.4, 5.5]], [[6.6, 7.7], [8.8, 9.9]]]\n        def test1(x, i, j):\n            return x[i, j]\n        assert test1(a, numpy.array([2, 0]), 1).tolist() == [7.7, 2.2]\n        assert test1(a2, numpy.array([1, 0, 0]), 1).tolist() == [[8.8, 9.9], [4.4, 5.5], [4.4, 5.5]]\n\n    def test_cpp_getitem_jagged_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        def test1(x, i):\n            return x[i]\n        assert test1(a, JaggedArray.fromiter([[True, False, True], [], [False, True]])).tolist() == [[1.1, 3.3], [], [5.5]]\n        assert test1(a2, JaggedArray.fromiter([[True, False], [], [True]])).tolist() == [[[1.1, 2.2, 3.3]], [], [[4.4, 5.5]]]\n        assert test1(a2, JaggedArray.fromiter([[[True, False, True], []], [], [[False, True]]])).tolist() == [[[1.1, 3.3], []], [], [[5.5]]]\n\n    def test_cpp_getitem_jagged_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        def test1(x, i):\n            return x[i]\n        assert test1(a, JaggedArray.fromiter([[2, 0, 0], [], [1]])).tolist() == [[3.3, 1.1, 1.1], [], [5.5]]\n        assert test1(a2, JaggedArray.fromiter([[1, 0], [], [0]])).tolist() == [[[], [1.1, 2.2, 3.3]], [], [[4.4, 5.5]]]\n        assert test1(a2, JaggedArray.fromiter([[[2, 0, 0], []], [], [[1]]])).tolist() == [[[3.3, 1.1, 1.1], []], [], [[5.5]]]\n\n    def test_cpp_offsets2parents(self):\n        offsets = numpy.array([0, 2, 4, 4, 7], dtype=numpy.int64)\n        parents = JaggedArray.offsets2parents(offsets)\n        assert parents.tolist() == [0, 0, 1, 1, 3, 3, 3]\n\n    def test_cpp_counts2offsets(self):\n        counts = numpy.array([4, 0, 3, 4, 1], dtype=numpy.int64)\n        offsets = JaggedArray.counts2offsets(counts)\n        assert offsets.tolist() == [0, 4, 4, 7, 11, 12]\n\n    def test_cpp_startsstops2parents(self):\n        starts = numpy.array([0, 4, 5, 9], dtype=numpy.int64)\n        stops = numpy.array([1, 6, 7, 10], dtype=numpy.int64)\n        parents = JaggedArray.startsstops2parents(starts, stops)\n        assert parents.tolist() == [0, -1, -1, -1, 1, 2, 2, -1, -1, 3]\n\n    def test_cpp_parents2startsstops(self):\n        parents = numpy.array([-1, 0, 0, -1, 2, 2, 2, 3], dtype=numpy.int64)\n        startsstops = JaggedArray.parents2startsstops(parents)\n        starts = startsstops[0]\n        stops = startsstops[1]\n        assert starts.tolist() == [1, 0, 4, 7] and stops.tolist() == [3, 0, 7, 8]\n\n    def test_cpp_uniques2offsetsparents(self):\n        uniques = numpy.array([0, 3, 4, 6, 8, 8, 9], dtype=numpy.int64)\n        offsetsparents = JaggedArray.uniques2offsetsparents(uniques)\n        offsets = offsetsparents[0]\n        parents = offsetsparents[1]\n        assert offsets.tolist() == [0, 1, 2, 3, 4, 6, 7] and parents.tolist() == [0, 1, 2, 3, 4, 4, 5]\n\n    def test_cpp_init(self):\n        # This depends on all setters working,\n        # as well as str and getitem methods\n        a = numpy.array([1, 4, 1, 0])\n        b = numpy.array([2, 9, 5, 10])\n        c = numpy.arange(10, dtype=numpy.int16)\n        test = awkward.cpp.JaggedArray(a, b, c)\n        assert str(test) == ""[[1] [4 5 6 7 8] [1 2 3 4] [0 1 2 3 4 5 6 7 8 9]]""\n\n    def test_cpp_deepcopy(self):\n        a = JaggedArray.fromiter([[1, 5, 2], [], [-6.1]])\n        b = a.deepcopy()\n        assert a.tolist() == b.tolist()\n        assert a.__repr__() != b.__repr__()\n'"
tests/test_crosscut.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\nfrom awkward.type import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_crosscut_asdtype(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert a.astype(int).tolist() == [[0, 1, 2], [], [3, 4], [5, 6, 7, 8, 9]]\n\n        a = ChunkedArray([[], [0.0, 1.1, 2.2, 3.3, 4.4], [5.5, 6.6], [], [7.7, 8.8, 9.9], []])\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a.astype(int).tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        a = AppendableArray(3, numpy.float64)\n        a.append(0.0)\n        a.append(1.1)\n        a.append(2.2)\n        a.append(3.3)\n        assert a.offsets.tolist() == [0, 3, 4]\n        assert a.tolist() == [0.0, 1.1, 2.2, 3.3]\n        assert a.astype(int).tolist() == [0, 1, 2, 3]\n\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a.tolist() == [3.3, 2.2, 4.4, 2.2, 2.2, 4.4, 0.0]\n        assert a.astype(int).tolist() == [3, 2, 4, 2, 2, 4, 0]\n\n        a = SparseArray(10, [1, 3, 5, 7, 9], [100.0, 101.1, 102.2, 103.3, 104.4])\n        assert a.tolist() == [0.0, 100.0, 0.0, 101.1, 0.0, 102.2, 0.0, 103.3, 0.0, 104.4]\n        assert a.astype(int).tolist() == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a.astype(int).tolist() == [None, 1, None, 3, None, 5, None, 7, None, 9]\n\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=True)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a.astype(int).tolist() == [None, 1, None, 3, None, 5, None, 7, None, 9]\n\n        a = IndexedMaskedArray([-1, 0, -1, 1, -1, 2, -1, 4, -1, 3], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a.tolist() == [None, 0.0, None, 1.1, None, 2.2, None, 4.4, None, 3.3]\n        assert a.astype(int).tolist() == [None, 0, None, 1, None, 2, None, 4, None, 3]\n\n        class Point(object):\n            def __init__(self, array):\n                self.x, self.y, self.z = array\n            def __repr__(self):\n                return ""<Point {0} {1} {2}>"".format(self.x, self.y, self.z)\n            def __eq__(self, other):\n                return isinstance(other, Point) and self.x == other.x and self.y == other.y and self.z == other.z\n\n        a = ObjectArray([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]], Point)\n        assert a.tolist() == [Point([1.1, 2.2, 3.3]), Point([4.4, 5.5, 6.6]), Point([7.7, 8.8, 9.9])]\n        assert a.astype(int).tolist() == [Point([1, 2, 3]), Point([4, 5, 6]), Point([7, 8, 9])]\n\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a.tolist() == [{""0"": 0, ""1"": 0.0}, {""0"": 1, ""1"": 1.1}, {""0"": 2, ""1"": 2.2}, {""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}, {""0"": 5, ""1"": 5.5}, {""0"": 6, ""1"": 6.6}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}, {""0"": 9, ""1"": 9.9}]\n        assert a.astype(int).tolist() == [{""0"": 0, ""1"": 0}, {""0"": 1, ""1"": 1}, {""0"": 2, ""1"": 2}, {""0"": 3, ""1"": 3}, {""0"": 4, ""1"": 4}, {""0"": 5, ""1"": 5}, {""0"": 6, ""1"": 6}, {""0"": 7, ""1"": 7}, {""0"": 8, ""1"": 8}, {""0"": 9, ""1"": 9}]\n\n        a = UnionArray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]])\n        assert a.tolist() == [0.0, 100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert a.astype(int).tolist() == [0, 100, 2, 300, 4, 500, 6, 700, 8, 900]\n\n        a = VirtualArray(lambda: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.astype(int).tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n        a = VirtualArray(lambda: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.materialize()\n        assert a.astype(int).tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n    def test_crosscut_reduce(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, 38.5]\n\n        a = ChunkedArray([[], [0.0, 1.1, 2.2, 3.3, 4.4], [5.5, 6.6], [], [7.7, 8.8, 9.9], []])\n        assert a.sum() == 49.5\n        a = ChunkedArray([JaggedArray.fromiter([[0.0, 1.1, 2.2], [], [3.3, 4.4]]), JaggedArray.fromiter([]), JaggedArray.fromiter([[5.5, 6.6]]), JaggedArray.fromiter([[7.7, 8.8], [9.9]])])\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, 12.1, 16.5, 9.9]\n        a = JaggedArray.fromcounts([3, 0, 3, 1, 2, 1], ChunkedArray([[], [0.0, 1.1, 2.2, 3.3, 4.4], [5.5, 6.6], [], [7.7, 8.8, 9.9], []]))\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 13.2, 6.6, 16.5, 9.9]\n        a = ChunkedArray([Table.named(""tuple"", [0.0, 1.1, 2.2], [0, 100, 200]), Table.named(""tuple"", []), Table.named(""tuple"", [3.3, 4.4, 5.5], [300, 400, 500])])\n        assert a.sum().tolist() == {""0"": 16.5, ""1"": 1500}\n\n        a = AppendableArray(3, numpy.float64)\n        a.append(0.0)\n        a.append(1.1)\n        a.append(2.2)\n        a.append(3.3)\n        assert a.sum() == 6.6\n        a = AppendableArray(3, numpy.float64)\n        a.append(0.0)\n        a.append(1.1)\n        a.append(2.2)\n        a.append(3.3)\n        a = JaggedArray.fromcounts([2, 0, 2], a)\n        assert a.sum().tolist() == [1.1, 0.0, 5.5]\n\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a.sum() == 18.700000000000003\n        a = JaggedArray.fromcounts([3, 0, 2], IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4]))\n        assert a.sum().tolist() == [9.9, 0.0, 4.4]\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], JaggedArray.fromcounts([3, 0, 2, 1, 4], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert a.sum().tolist() == [5.5, 7.7, 33.0, 7.7, 7.7, 33.0, 3.3000000000000003]\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], Table.named(""tuple"", [0.0, 1.1, 2.2, 3.3, 4.4], [0, 100, 200, 300, 400]))\n        assert a.sum().tolist() == {""0"": 18.700000000000003, ""1"": 1700}\n\n        a = SparseArray(10, [1, 3, 5, 7, 9], [100.0, 101.1, 102.2, 103.3, 104.4])\n        assert a.sum() == 511.0\n\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        assert a.sum() == 27.5\n        a = JaggedArray.fromcounts([3, 0, 2, 1, 1, 3], MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True))\n        assert a.sum().tolist() == [1.1, 0.0, 3.3, 5.5, 0.0, 17.6]\n        a = MaskedArray([False, False, False, True, True, False], JaggedArray.fromcounts([3, 0, 2, 1, 0, 4], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]), maskedwhen=True)\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, None, None, 33.0]\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], Table.named(""tuple"", [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]), maskedwhen=True)\n        assert a.sum().tolist() == {""0"": 27.5, ""1"": 2500}\n\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=True)\n        assert a.sum() == 27.5\n        a = JaggedArray.fromcounts([3, 0, 2, 1, 1, 3], BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=True))\n        assert a.sum().tolist() == [1.1, 0.0, 3.3, 5.5, 0.0, 17.6]\n        a = BitMaskedArray.fromboolmask([False, False, False, True, True, False], JaggedArray.fromcounts([3, 0, 2, 1, 0, 4], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]), maskedwhen=True, lsborder=True)\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, None, None, 33.0]\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], Table.named(""tuple"", [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]), maskedwhen=True, lsborder=True)\n        assert a.sum().tolist() == {""0"": 27.5, ""1"": 2500}\n\n        a = IndexedMaskedArray([-1, 1, -1, 3, -1, 5, -1, 7, -1, 8], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 9.9])\n        assert a.sum() == 27.5\n        a = JaggedArray.fromcounts([3, 0, 2, 1, 1, 3], IndexedMaskedArray([-1, 1, -1, 3, -1, 5, -1, 7, -1, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert a.sum().tolist() == [1.1, 0.0, 3.3, 5.5, 0.0, 17.6]\n        a = IndexedMaskedArray([0, 1, 2, -1, -1, 5], JaggedArray.fromcounts([3, 0, 2, 1, 0, 4], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, None, None, 33.0]\n        a = IndexedMaskedArray([-1, 1, -1, 3, -1, 5, -1, 7, -1, 9], Table.named(""tuple"", [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]))\n        assert a.sum().tolist() == {""0"": 27.5, ""1"": 2500}\n\n        a = Table.named(""tuple"", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.sum().tolist() == {""0"": 45, ""1"": 49.50000000000001}\n        a = JaggedArray.fromcounts([3, 0, 2, 1, 4], Table.named(""tuple"", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert a.sum().tolist() == [(3, 3.3000000000000003), (0, 0.0), (7, 7.7), (5, 5.5), (30, 33.0)]\n\n        a = UnionArray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]])\n        assert a.sum() == 2522.0\n\n        a = VirtualArray(lambda: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.sum() == 49.50000000000001\n\n        a = VirtualArray(lambda: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.materialize()\n        assert a.sum() == 49.50000000000001\n'"
tests/test_generate.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport collections\nimport unittest\n\nimport awkward\n\nclass S0(object):\n    def __init__(self):\n        pass\n    def __eq__(self, other):\n        return isinstance(other, S0)\n\nclass S1(object):\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n    def __eq__(self, other):\n        return isinstance(other, S1) and self.a == other.a and self.b == other.b\n\nclass S2(object):\n    def __init__(self, a, b):\n        self.a, self.b = a, b\n    def __eq__(self, other):\n        return isinstance(other, S2) and self.a == other.a and self.b == other.b\n\nT0 = collections.namedtuple(""T0"", [])\nT1 = collections.namedtuple(""T1"", [""a"", ""b""])\nT2 = collections.namedtuple(""T2"", [""a"", ""b""])\n\nclass Test(unittest.TestCase):\n    def test_generate_runTest(self):\n        pass\n\n    def test_generate_empty(self):\n        x = []\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [None]\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [None, None, None]\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive(self):\n        x = [False, True, True]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, 3]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1.1, 2.2, 3.3]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1.1j, 2.2j, 3.3j]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, 3]\n        assert isinstance(awkward.fromiter(x).tolist()[0], int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, 3.3]\n        assert isinstance(awkward.fromiter(x).tolist()[0], float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings(self):\n        x = [b""one"", b""two"", b""three""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", ""two"", ""three""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_dictencoding(self):\n        x = [b""one"", b""two"", b""three""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", ""two"", ""three""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [b""one"", b""two"", b""three""]\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n\n        x = [""one"", ""two"", ""three""]\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=lambda x: True).tolist() == x\n\n    def test_generate_jagged(self):\n        x = [[]]\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [3.14], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[999], [], [999]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0], int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[999], [], [3.14]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0], float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_multijagged(self):\n        x = [[[]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[]], [], [[]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [[]], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [[], [], []], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[3.14]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[]], [], [[3.14]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[3.14]], [], [[]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [[1], [2], [3]], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[3.14]], [], [[3.14]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[999]], [], [[999]]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0][0], int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[999]], [], [[3.14]]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0][0], float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_table(self):\n        x = [{""a"": 1, ""b"": 1.1}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": 3.3}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": 3.3}]\n        assert isinstance(awkward.fromiter(x).tolist()[0][""a""], int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3.0, ""b"": 3.3}]\n        assert isinstance(awkward.fromiter(x).tolist()[0][""a""], float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": ""one""}, {""a"": 2, ""b"": ""two""}, {""a"": 3, ""b"": ""three""}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": b""one""}, {""a"": 2, ""b"": b""two""}, {""a"": 3, ""b"": b""three""}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": []}, {""a"": 2, ""b"": [2.2]}, {""a"": 3.0, ""b"": [3.3, 3.3]}]\n        assert isinstance(awkward.fromiter(x).tolist()[0][""a""], float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": {""x"": 1.1}}, {""a"": 2, ""b"": {""x"": 2.2}}, {""a"": 3, ""b"": {""x"": 3.3}}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        assert awkward.fromiter([{}]).tolist() == [None]\n        assert awkward.fromiter([{}, {}, {}]).tolist() == [None, None, None]\n        assert awkward.fromiter([{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {}]).tolist() == [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, None]\n        assert awkward.fromiter([None, {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {}]).tolist() == [None, {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, None]\n        assert awkward.fromiter([{""a"": 1, ""b"": 1.1}, None, {""a"": 2, ""b"": 2.2}, {}]).tolist() == [{""a"": 1, ""b"": 1.1}, None, {""a"": 2, ""b"": 2.2}, None]\n        assert awkward.fromiter([{""a"": 1, ""b"": 1.1}, {}, {""a"": 2, ""b"": 2.2}]).tolist() == [{""a"": 1, ""b"": 1.1}, None, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter([{}, {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]).tolist() == [None, {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]\n\n    def test_generate_objects(self):\n        x = [S1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, 3.3)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, 3.3)]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3.0, 3.3)]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, ""one""), S1(2, ""two""), S1(3, ""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, b""one""), S1(2, b""two""), S1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, []), S1(2, [2.2]), S1(3.0, [3.3, 3.3])]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, {""x"": 1.1}), S1(2, {""x"": 2.2}), S1(3, {""x"": 3.3})]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        assert awkward.fromiter([S0()]).tolist() == [S0()]\n        assert awkward.fromiter([S0(), S0(), S0()]).tolist() == [S0(), S0(), S0()]\n        assert awkward.fromiter([None, S0(), S0(), S0()]).tolist() == [None, S0(), S0(), S0()]\n        assert awkward.fromiter([S0(), None, S0(), S0()]).tolist() == [S0(), None, S0(), S0()]\n        assert awkward.fromiter([None, S0(), None, S0(), S0()]).tolist() == [None, S0(), None, S0(), S0()]\n\n    def test_generate_namedtuples(self):\n        x = [T1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, 3.3)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, 3.3)]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, int)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3.0, 3.3)]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, ""one""), T1(2, ""two""), T1(3, ""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, b""one""), T1(2, b""two""), T1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, []), T1(2, [2.2]), T1(3.0, [3.3, 3.3])]\n        assert isinstance(awkward.fromiter(x).tolist()[0].a, float)\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, {""x"": 1.1}), T1(2, {""x"": 2.2}), T1(3, {""x"": 3.3})]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        assert awkward.fromiter([T0()]).tolist() == [T0()]\n        assert awkward.fromiter([T0(), T0(), T0()]).tolist() == [T0(), T0(), T0()]\n        assert awkward.fromiter([None, T0(), T0(), T0()]).tolist() == [None, T0(), T0(), T0()]\n        assert awkward.fromiter([T0(), None, T0(), T0()]).tolist() == [T0(), None, T0(), T0()]\n        assert awkward.fromiter([None, T0(), None, T0(), T0()]).tolist() == [None, T0(), None, T0(), T0()]\n\n    def test_generate_primitive_primitive(self):\n        x = [1, 2, True]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [True, 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, True, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, True, False]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [True, 1, 2, False]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, True, 2, False]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [False, 1, 2, True]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [False, True, 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [False, 1, True, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, True, None]\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, True, None, 3]\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, True, None, False]\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive_strings(self):\n        x = [""one"", ""two"", 1]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", 1, ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, ""one"", 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive_strings_dictencoding(self):\n        x = [""one"", ""two"", 1]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [1, ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", 1, ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [1, 2, ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [1, ""one"", 2]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", 1, 2]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_primitive_jagged(self):\n        x = [1, 2, []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, [], 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, [3.14], 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[3.14], 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, [], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, [3.14], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, [], [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], 1, []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[3.14], 1, []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], 1, [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [], 1]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[3.14], [], 1]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [3.14], 1]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive_table(self):\n        x = [999, {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, 999, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, 999]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, {""a"": 999, ""b"": 3.14}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, {""a"": 999, ""b"": 3.14}, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 999, ""b"": 3.14}, 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive_objects(self):\n        x = [999, S1(1, 1.1), S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), 999, S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), 999]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, S1(999, 3.14)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, S1(999, 3.14), 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(999, 3.14), 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_primitive_namedtuples(self):\n        x = [999, T1(1, 1.1), T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), 999, T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), 999]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, 2, T1(999, 3.14)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [1, T1(999, 3.14), 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(999, 3.14), 1, 2]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_strings(self):\n        x = [""one"", b""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [b""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_strings_dictencoding(self):\n        x = [""one"", b""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [b""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_strings_jagged(self):\n        x = [""one"", ""two"", []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", ""two"", [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [], ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [3.14], ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[3.14], ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [1.1], []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [], [2.2]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", [1.1], [2.2]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], ""one"", []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[1.1], ""one"", []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], ""one"", [2.2]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[1.1], ""one"", [2.2]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [], ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[1.1], [], ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [2.2], ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[1.1], [2.2], ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_jagged_dictencoding(self):\n        x = [""one"", ""two"", []]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", ""two"", [3.14]]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [], ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [3.14], ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[], ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[3.14], ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [], []]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [1.1], []]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [], [2.2]]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", [1.1], [2.2]]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[], ""one"", []]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[1.1], ""one"", []]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[], ""one"", [2.2]]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[1.1], ""one"", [2.2]]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[], [], ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[1.1], [], ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[], [2.2], ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [[1.1], [2.2], ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_strings_table(self):\n        x = [""one"", {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, ""one"", {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", ""two"", {""a"": 1, ""b"": 1.1}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", {""a"": 1, ""b"": 1.1}, ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_table_dictencoding(self):\n        x = [""one"", {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, ""one"", {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", ""two"", {""a"": 1, ""b"": 1.1}]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", {""a"": 1, ""b"": 1.1}, ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_strings_objects(self):\n        x = [""one"", S1(1, 1.1), S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), ""one"", S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", ""two"", S1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", S1(1, 1.1), ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_objects_dictencoding(self):\n        x = [""one"", S1(1, 1.1), S1(2, 2.2)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [S1(1, 1.1), ""one"", S1(2, 2.2)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", ""two"", S1(1, 1.1)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", S1(1, 1.1), ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [S1(1, 1.1), ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_strings_namedtuples(self):\n        x = [""one"", T1(1, 1.1), T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), ""one"", T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), ""one""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", ""two"", T1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [""one"", T1(1, 1.1), ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), ""one"", ""two""]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_strings_namedtuples_dictencoding(self):\n        x = [""one"", T1(1, 1.1), T1(2, 2.2)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [T1(1, 1.1), ""one"", T1(2, 2.2)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), ""one""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", ""two"", T1(1, 1.1)]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [""one"", T1(1, 1.1), ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n        x = [T1(1, 1.1), ""one"", ""two""]\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x, dictencoding=True).tolist() == x\n\n    def test_generate_jagged_jagged(self):\n        x = [[[[[1]]]], [[[[2]]]]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[[[[1]]]], [[[[2]]]]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0][0][0][0], int)\n\n        x = [[[[[1]]]], [[[[2.2]]]]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0][0][0][0], float)\n\n        x = [[[[[1]]]], [[[[[2.2]]]]]]\n        assert isinstance(awkward.fromiter(x).tolist()[0][0][0][0][0], int)\n\n    def test_generate_jagged_table(self):\n        x = [[], {""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, [], {""a"": 2, ""b"": 2.2}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [3.14], {""a"": 1, ""b"": 1.1}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], {""a"": 1, ""b"": 1.1}, [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, [], [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_jagged_objects(self):\n        x = [[], S1(1, 1.1), S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), [], S1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [3.14], S1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], S1(1, 1.1), [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), [], [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_jagged_namedtuples(self):\n        x = [[], T1(1, 1.1), T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), [], T1(2, 2.2)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), []]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], [3.14], T1(1, 1.1)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [[], T1(1, 1.1), [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), [], [3.14]]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_table_table(self):\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""x"": 3, ""y"": 3.3}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_objects_objects(self):\n        x = [S1(1, 1.1), S1(2, 2.2), S2(3, 3.3)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_namedtuples_namedtuples(self):\n        x = [T1(1, 1.1), T1(2, 2.2), T2(3, 3.3)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_table_union(self):\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": True}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": ""three""}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": b""three""}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": b""three""}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": []}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": [3.14]}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [{""a"": 1, ""b"": 1.1}, {""a"": 2, ""b"": 2.2}, {""a"": 3, ""b"": {""x"": 999, ""y"": 3.14}}]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_objects_union(self):\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, True)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, ""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, [])]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, [3.14])]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [S1(1, 1.1), S1(2, 2.2), S1(3, S2(999, 3.14))]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n    def test_generate_namedtuples_union(self):\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, True)]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, ""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, b""three"")]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, [])]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, [3.14])]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n\n        x = [T1(1, 1.1), T1(2, 2.2), T1(3, T2(999, 3.14))]\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(1, None)\n        assert awkward.fromiter(x).tolist() == x\n        x.insert(0, None)\n        assert awkward.fromiter(x).tolist() == x\n'"
tests/test_hdf5.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport pytest\nimport numpy\n\nimport awkward\n\nh5py = pytest.importorskip(""h5py"")\n\narray_norm = [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\narray_int = [[1, 2, 3], [], [4, 5]]\narray_f32 = [numpy.array([1.3,3.2], dtype=numpy.float32), [], numpy.array([7.6], dtype=numpy.float32)]\narray_lg = [numpy.array([1,2,3])]*10000\n\n@pytest.mark.parametrize(""input_arr"", (array_norm, array_int, array_f32, array_lg))\ndef test_read_write_hdf(tmpdir, input_arr):\n    tmp_file = tmpdir / ""example.h5""\n\n    # Write\n    with h5py.File(str(tmp_file), ""w"") as hf:\n        a = awkward.JaggedArray.fromiter(input_arr)\n        ah5 = awkward.hdf5(hf)\n        ah5[""example""] = a\n\n    # Read\n    with h5py.File(str(tmp_file)) as hf:\n        ah5 = awkward.hdf5(hf)\n        b = ah5[""example""]\n\n    assert a.tolist() == b.tolist()\n'"
tests/test_indexed.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_indexed_nbytes(self):\n        assert isinstance(IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4]).nbytes, int)\n\n    def test_indexed_get(self):\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert [x for x in a] == [3.3, 2.2, 4.4, 2.2, 2.2, 4.4, 0.0]\n        assert [a[i] for i in range(len(a))] == [3.3, 2.2, 4.4, 2.2, 2.2, 4.4, 0.0]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[3.3], [2.2], [4.4], [2.2], [2.2], [4.4], [0.0]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[3.3, 2.2], [2.2, 4.4], [4.4, 2.2], [2.2, 2.2], [2.2, 4.4], [4.4, 0.0]]\n        assert a[:].tolist() == [3.3, 2.2, 4.4, 2.2, 2.2, 4.4, 0.0]\n        assert a[[6, 5, 4, 3, 2, 1, 0]].tolist() == [0.0, 4.4, 2.2, 2.2, 4.4, 2.2, 3.3]\n        assert a[[True, False, True, False, True, False, True]].tolist() == [3.3, 4.4, 2.2, 0.0]\n        assert a[[-1, -2, -3, -4, -5, -6, -7]].tolist() == [0.0, 4.4, 2.2, 2.2, 4.4, 2.2, 3.3]\n\n    def test_indexed_get2d_index(self):\n        a = IndexedArray([[3, 2], [4, 2], [2, 0]], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert [x.tolist() for x in a] == [[3.3, 2.2], [4.4, 2.2], [2.2, 0.0]]\n        assert [a[i].tolist() for i in range(len(a))] == [[3.3, 2.2], [4.4, 2.2], [2.2, 0.0]]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[[3.3, 2.2]], [[4.4, 2.2]], [[2.2, 0.0]]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[3.3, 2.2], [4.4, 2.2]], [[4.4, 2.2], [2.2, 0.0]]]\n        assert a[:].tolist() == [[3.3, 2.2], [4.4, 2.2], [2.2, 0.0]]\n        assert a[[1, 1, 0]].tolist() == [[4.4, 2.2], [4.4, 2.2], [3.3, 2.2]]\n        assert a[[True, False, True]].tolist() == [[3.3, 2.2], [2.2, 0.0]]\n        assert a[[-2, -2, -3]].tolist() == [[4.4, 2.2], [4.4, 2.2], [3.3, 2.2]]\n\n    def test_indexed_get2d_content(self):\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4]])\n        assert [x.tolist() for x in a] == [[3.3, 3.3], [2.2, 2.2], [4.4, 4.4], [2.2, 2.2], [2.2, 2.2], [4.4, 4.4], [0.0, 0.0]]\n        assert [a[i].tolist() for i in range(len(a))] == [[3.3, 3.3], [2.2, 2.2], [4.4, 4.4], [2.2, 2.2], [2.2, 2.2], [4.4, 4.4], [0.0, 0.0]]\n        assert a[:].tolist() == [[3.3, 3.3], [2.2, 2.2], [4.4, 4.4], [2.2, 2.2], [2.2, 2.2], [4.4, 4.4], [0.0, 0.0]]\n        assert a[[6, 5, 4, 3, 2, 1, 0]].tolist() == [[0.0, 0.0], [4.4, 4.4], [2.2, 2.2], [2.2, 2.2], [4.4, 4.4], [2.2, 2.2], [3.3, 3.3]]\n        assert a[[True, False, True, False, True, False, True]].tolist() == [[3.3, 3.3], [4.4, 4.4], [2.2, 2.2], [0.0, 0.0]]\n\n    def test_indexed_getstruct(self):\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], numpy.array([(0.0, 0.0), (1.1, 1.1), (2.2, 2.2), (3.3, 3.3), (4.4, 4.4)], dtype=[(""a"", float), (""b"", float)]))\n        assert [x.tolist() for x in a] == [(3.3, 3.3), (2.2, 2.2), (4.4, 4.4), (2.2, 2.2), (2.2, 2.2), (4.4, 4.4), (0.0, 0.0)]\n        assert [a[i].tolist() for i in range(len(a))] == [(3.3, 3.3), (2.2, 2.2), (4.4, 4.4), (2.2, 2.2), (2.2, 2.2), (4.4, 4.4), (0.0, 0.0)]\n        assert a[:].tolist() == [(3.3, 3.3), (2.2, 2.2), (4.4, 4.4), (2.2, 2.2), (2.2, 2.2), (4.4, 4.4), (0.0, 0.0)]\n        assert a[[6, 5, 4, 3, 2, 1, 0]].tolist() == [(0.0, 0.0), (4.4, 4.4), (2.2, 2.2), (2.2, 2.2), (4.4, 4.4), (2.2, 2.2), (3.3, 3.3)]\n        assert a[[True, False, True, False, True, False, True]].tolist() == [(3.3, 3.3), (4.4, 4.4), (2.2, 2.2), (0.0, 0.0)]\n\n    def test_indexed_getempty(self):\n        a = IndexedArray([], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a[:].tolist() == []\n\n    def test_indexed_indexed(self):\n        a = IndexedArray([6, 5, 4, 3, 2, 1, 0], IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4]))\n        assert [x for x in a] == [0.0, 4.4, 2.2, 2.2, 4.4, 2.2, 3.3]\n        assert [a[i] for i in range(len(a))] == [0.0, 4.4, 2.2, 2.2, 4.4, 2.2, 3.3]\n        assert a[:].tolist() == [0.0, 4.4, 2.2, 2.2, 4.4, 2.2, 3.3]\n\n        a = IndexedArray([6, 5, 4, 3, 6], IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4]))\n        assert [x for x in a] == [0.0, 4.4, 2.2, 2.2, 0.0]\n        assert [a[i] for i in range(len(a))] == [0.0, 4.4, 2.2, 2.2, 0.0]\n        assert a[:].tolist() == [0.0, 4.4, 2.2, 2.2, 0.0]\n\n    def test_indexed_ufunc(self):\n        a = IndexedArray([3, 2, 4, 2, 2, 4, 0], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert (a + 100).tolist() == [103.3, 102.2, 104.4, 102.2, 102.2, 104.4, 100.0]\n\n    def test_indexed_table(self):\n        a = IndexedArray([3, 2, 4, 0], Table(a=[0.0, 1.1, 2.2, 3.3, 4.4], b=[0, 1, 2, 3, 4]))\n        a[""c""] = numpy.array([""a"", ""b"", ""c"", ""d""])\n        assert a[""a""].tolist() == [3.3, 2.2, 4.4, 0.0]\n        assert a[""b""].tolist() == [3, 2, 4, 0]\n        assert a[""c""].tolist() == [""a"", ""b"", ""c"", ""d""]\n\n    def test_sparse_get(self):\n        a = SparseArray(10, [1, 3, 5, 7, 9], [100, 101, 102, 103, 104])\n\n        assert a.tolist() == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert [a[i].tolist() for i in range(len(a))] == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[0, 100], [100, 0], [0, 101], [101, 0], [0, 102], [102, 0], [0, 103], [103, 0], [0, 104]]\n\n        assert a[:].tolist() == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[1:].tolist() == [100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[2:].tolist() == [0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[2:-1].tolist() == [0, 101, 0, 102, 0, 103, 0]\n        assert a[2:-2].tolist() == [0, 101, 0, 102, 0, 103]\n        assert a[:-2].tolist() == [0, 100, 0, 101, 0, 102, 0, 103]\n        assert a[::2].tolist() == [0, 0, 0, 0, 0]\n        assert a[1::2].tolist() == [100, 101, 102, 103, 104]\n        assert a[2::2].tolist() == [0, 0, 0, 0]\n        assert a[3::2].tolist() == [101, 102, 103, 104]\n        assert a[::-1].tolist() == [104, 0, 103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-2::-1].tolist() == [0, 103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-3::-1].tolist() == [103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-3:0:-1].tolist() == [103, 0, 102, 0, 101, 0, 100]\n        assert a[-3:1:-1].tolist() == [103, 0, 102, 0, 101, 0]\n        assert a[::-2].tolist() == [104, 103, 102, 101, 100]\n        assert a[-1::-2].tolist() == [104, 103, 102, 101, 100]\n        assert a[-2::-2].tolist() == [0, 0, 0, 0, 0]\n        assert a[-3::-2].tolist() == [103, 102, 101, 100]\n        assert a[[1, 3, 5, 7, 9]].tolist() == [100, 101, 102, 103, 104]\n        assert a[[1, 3, 5, 7, 8, 9]].tolist() == [100, 101, 102, 103, 0, 104]\n        assert a[[1, 3, 5, 9, 7]].tolist() == [100, 101, 102, 104, 103]\n        assert a[[1, 3, 5, 9, 8, 7]].tolist() == [100, 101, 102, 104, 0, 103]\n        assert a[[False, True, False, True, False, True, False, True, False, True]].tolist() == [100, 101, 102, 103, 104]\n        assert a[[True, True, False, True, False, True, False, True, False, True]].tolist() == [0, 100, 101, 102, 103, 104]\n        assert a[[True, True, True, True, False, True, False, True, False, True]].tolist() == [0, 100, 0, 101, 102, 103, 104]\n\n        assert [a[1:][i].tolist() for i in range(9)] == [100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert [a[[1, 3, 5, 9, 8, 7]][i].tolist() for i in range(6)] == [100, 101, 102, 104, 0, 103]\n        assert [a[[True, True, True, True, False, True, False, True, False, True]][i].tolist() for i in range(7)] == [0, 100, 0, 101, 102, 103, 104]\n\n        assert a.dense.tolist() == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert [a.dense[i].tolist() for i in range(len(a))] == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert [a.dense[i : i + 1].tolist() for i in range(len(a))] == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a.dense[i : i + 2].tolist() for i in range(len(a) - 1)] == [[0, 100], [100, 0], [0, 101], [101, 0], [0, 102], [102, 0], [0, 103], [103, 0], [0, 104]]\n\n        assert a[:].dense.tolist() == [0, 100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[1:].dense.tolist() == [100, 0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[2:].dense.tolist() == [0, 101, 0, 102, 0, 103, 0, 104]\n        assert a[2:-1].dense.tolist() == [0, 101, 0, 102, 0, 103, 0]\n        assert a[2:-2].dense.tolist() == [0, 101, 0, 102, 0, 103]\n        assert a[:-2].dense.tolist() == [0, 100, 0, 101, 0, 102, 0, 103]\n        assert a[::2].dense.tolist() == [0, 0, 0, 0, 0]\n        assert a[1::2].dense.tolist() == [100, 101, 102, 103, 104]\n        assert a[2::2].dense.tolist() == [0, 0, 0, 0]\n        assert a[3::2].dense.tolist() == [101, 102, 103, 104]\n        assert a[::-1].dense.tolist() == [104, 0, 103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-2::-1].dense.tolist() == [0, 103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-3::-1].dense.tolist() == [103, 0, 102, 0, 101, 0, 100, 0]\n        assert a[-3:0:-1].dense.tolist() == [103, 0, 102, 0, 101, 0, 100]\n        assert a[-3:1:-1].dense.tolist() == [103, 0, 102, 0, 101, 0]\n        assert a[::-2].dense.tolist() == [104, 103, 102, 101, 100]\n        assert a[-1::-2].dense.tolist() == [104, 103, 102, 101, 100]\n        assert a[-2::-2].dense.tolist() == [0, 0, 0, 0, 0]\n        assert a[-3::-2].dense.tolist() == [103, 102, 101, 100]\n\n        assert [a[1:].dense[i].tolist() for i in range(9)] == [100, 0, 101, 0, 102, 0, 103, 0, 104]\n\n    def test_sparse_get2d_content(self):\n        a = SparseArray(10, [1, 3, 5, 7, 9], [[100], [101], [102], [103], [104]])\n\n        assert a.tolist() == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a[i].tolist() for i in range(len(a))] == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[[0]], [[100]], [[0]], [[101]], [[0]], [[102]], [[0]], [[103]], [[0]], [[104]]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[0], [100]], [[100], [0]], [[0], [101]], [[101], [0]], [[0], [102]], [[102], [0]], [[0], [103]], [[103], [0]], [[0], [104]]]\n\n        assert a[:].tolist() == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[1:].tolist() == [[100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[2:].tolist() == [[0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[2:-1].tolist() == [[0], [101], [0], [102], [0], [103], [0]]\n        assert a[2:-2].tolist() == [[0], [101], [0], [102], [0], [103]]\n        assert a[:-2].tolist() == [[0], [100], [0], [101], [0], [102], [0], [103]]\n        assert a[::2].tolist() == [[0], [0], [0], [0], [0]]\n        assert a[1::2].tolist() == [[100], [101], [102], [103], [104]]\n        assert a[2::2].tolist() == [[0], [0], [0], [0]]\n        assert a[3::2].tolist() == [[101], [102], [103], [104]]\n        assert a[::-1].tolist() == [[104], [0], [103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-2::-1].tolist() == [[0], [103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-3::-1].tolist() == [[103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-3:0:-1].tolist() == [[103], [0], [102], [0], [101], [0], [100]]\n        assert a[-3:1:-1].tolist() == [[103], [0], [102], [0], [101], [0]]\n        assert a[::-2].tolist() == [[104], [103], [102], [101], [100]]\n        assert a[-1::-2].tolist() == [[104], [103], [102], [101], [100]]\n        assert a[-2::-2].tolist() == [[0], [0], [0], [0], [0]]\n        assert a[-3::-2].tolist() == [[103], [102], [101], [100]]\n        assert a[[1, 3, 5, 7, 9]].tolist() == [[100], [101], [102], [103], [104]]\n        assert a[[1, 3, 5, 7, 8, 9]].tolist() == [[100], [101], [102], [103], [0], [104]]\n        assert a[[1, 3, 5, 9, 7]].tolist() == [[100], [101], [102], [104], [103]]\n        assert a[[1, 3, 5, 9, 8, 7]].tolist() == [[100], [101], [102], [104], [0], [103]]\n        assert a[[False, True, False, True, False, True, False, True, False, True]].tolist() == [[100], [101], [102], [103], [104]]\n        assert a[[True, True, False, True, False, True, False, True, False, True]].tolist() == [[0], [100], [101], [102], [103], [104]]\n        assert a[[True, True, True, True, False, True, False, True, False, True]].tolist() == [[0], [100], [0], [101], [102], [103], [104]]\n\n        assert [a[1:][i].tolist() for i in range(9)] == [[100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a[[1, 3, 5, 9, 8, 7]][i].tolist() for i in range(6)] == [[100], [101], [102], [104], [0], [103]]\n        assert [a[[True, True, True, True, False, True, False, True, False, True]][i].tolist() for i in range(7)] == [[0], [100], [0], [101], [102], [103], [104]]\n\n        assert a.dense.tolist() == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a.dense[i].tolist() for i in range(len(a))] == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert [a.dense[i : i + 1].tolist() for i in range(len(a))] == [[[0]], [[100]], [[0]], [[101]], [[0]], [[102]], [[0]], [[103]], [[0]], [[104]]]\n        assert [a.dense[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[0], [100]], [[100], [0]], [[0], [101]], [[101], [0]], [[0], [102]], [[102], [0]], [[0], [103]], [[103], [0]], [[0], [104]]]\n\n        assert a[:].dense.tolist() == [[0], [100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[1:].dense.tolist() == [[100], [0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[2:].dense.tolist() == [[0], [101], [0], [102], [0], [103], [0], [104]]\n        assert a[2:-1].dense.tolist() == [[0], [101], [0], [102], [0], [103], [0]]\n        assert a[2:-2].dense.tolist() == [[0], [101], [0], [102], [0], [103]]\n        assert a[:-2].dense.tolist() == [[0], [100], [0], [101], [0], [102], [0], [103]]\n        assert a[::2].dense.tolist() == [[0], [0], [0], [0], [0]]\n        assert a[1::2].dense.tolist() == [[100], [101], [102], [103], [104]]\n        assert a[2::2].dense.tolist() == [[0], [0], [0], [0]]\n        assert a[3::2].dense.tolist() == [[101], [102], [103], [104]]\n        assert a[::-1].dense.tolist() == [[104], [0], [103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-2::-1].dense.tolist() == [[0], [103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-3::-1].dense.tolist() == [[103], [0], [102], [0], [101], [0], [100], [0]]\n        assert a[-3:0:-1].dense.tolist() == [[103], [0], [102], [0], [101], [0], [100]]\n        assert a[-3:1:-1].dense.tolist() == [[103], [0], [102], [0], [101], [0]]\n        assert a[::-2].dense.tolist() == [[104], [103], [102], [101], [100]]\n        assert a[-1::-2].dense.tolist() == [[104], [103], [102], [101], [100]]\n        assert a[-2::-2].dense.tolist() == [[0], [0], [0], [0], [0]]\n        assert a[-3::-2].dense.tolist() == [[103], [102], [101], [100]]\n\n        assert [a[1:].dense[i].tolist() for i in range(9)] == [[100], [0], [101], [0], [102], [0], [103], [0], [104]]\n\n    def test_indexed_ufunc(self):\n        a = SparseArray(10, [1, 3, 5, 7, 9], [100, 101, 102, 103, 104])\n        assert (a + 100).tolist() == [100, 200, 100, 201, 100, 202, 100, 203, 100, 204]\n\n    def test_crossref(self):\n        a = IndexedArray([0], UnionArray.fromtags([1, 0, 1, 0, 1, 0, 0, 1], [numpy.array([1.1, 2.2, 3.3, 4.4]), JaggedArray([1, 3, 5, 8], [3, 5, 8, 8], [])]))\n        a.content.contents[1].content = a.content\n        assert a.tolist() == [[1.1, [2.2, [3.3, 4.4, []]]]]\n'"
tests/test_issues.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\nfrom awkward.type import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_issue49(self):\n        a = JaggedArray([2], [5], [1, 2, 3, 4, 5])\n        m = JaggedArray([0], [3], [False, False, True])\n        assert a[m].tolist() == [[5]]\n\n    def test_issue144(self):\n        x = fromiter([[], [0.5], [0.6], []])\n        isloose = fromiter([[], [False], [True], []])\n        assert x[isloose].tolist() == [[], [], [0.6], []]\n        assert x.sum().tolist() == [0.0, 0.5, 0.6, 0.0]\n\n    def test_issue163(self):\n        a = fromiter([[1, 3], [4, 5]])\n        b = a[a.counts > 10]\n        assert b[:,:1].tolist() == []\n\n    def test_issue_190(self):\n        a = JaggedArray.fromiter([[], []])\n        assert a.pad(1).tolist() == [[None], [None]]\n        assert a.pad(2).tolist() == [[None, None], [None, None]]\n        assert a.pad(3).tolist() == [[None, None, None], [None, None, None]]\n\n    def test_issue_208(self):\n        a = awkward.MaskedArray([True, False, False, True, False, True], awkward.fromiter([[1, 2, 3], [4, 5], [6], [7, 8], [10, 11, 12], [999]]))\n        assert a.flatten().tolist() == [None, 4, 5, 6, None, 10, 11, 12, None]\n        assert (a + 100).flatten().tolist() == [None, 104, 105, 106, None, 110, 111, 112, None]\n        a = awkward.MaskedArray([True, False, False, True, False, True], [1.1, 2.2, 3.3, 4.4, 5.5, 6.6])\n        assert a.flatten().tolist() == [None, 2.2, 3.3, None, 5.5, None]\n        assert (a + 100).flatten().tolist() == [None, 102.2, 103.3, None, 105.5, None]\n'"
tests/test_jagged.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nimport awkward\nfrom awkward import *\nfrom awkward.type import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_jagged_nbytes(self):\n        assert isinstance(JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).nbytes, int)\n\n    def test_jagged_init(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.tolist() == [[[0.0, 1.1, 2.2], []], [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.tolist() == [[[0.0], [1.1], [2.2]], [], [[3.3], [4.4]], [[5.5], [6.6], [7.7], [8.8], [9.9]]]\n\n        assert JaggedArray.fromiter([[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]).tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert JaggedArray.fromoffsets([0, 3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert JaggedArray.fromcounts([3, 0, 2, 5], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert JaggedArray.fromparents([0, 0, 0, 2, 2, 3, 3, 3, 3, 3], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert JaggedArray.fromuniques([9, 9, 9, 8, 8, 7, 7, 7, 7, 7], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).tolist() == [[0.0, 1.1, 2.2], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert JaggedArray.fromuniques([9, 9, 9, 8, 8, 7, 7, 7, 7, 7], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])._parents.tolist() == [0, 0, 0, 1, 1, 2, 2, 2, 2, 2]\n\n        a = JaggedArray([], [], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a[:].tolist() == []\n\n    def test_jagged_type(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.type == ArrayType(4, numpy.inf, float)\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.type == ArrayType(2, 2, numpy.inf, float)\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.type == ArrayType(4, numpy.inf, 1, float)\n\n    def test_jagged_fromlocalindex(self):\n        a = JaggedArray.fromlocalindex([0, 1, 0, 0, 0, 1, 2, 0, 1, 0], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        self.assertEqual(a.tolist(), [[0.0, 1.1], [2.2], [3.3], [4.4, 5.5, 6.6], [7.7, 8.8], [9.9]])\n        self.assertEqual(a.starts.tolist(), [0, 2, 3, 4, 7, 9])\n        self.assertEqual(a.stops.tolist(), [2, 3, 4, 7, 9, 10])\n\n    def test_jagged_tojagged(self):\n        a = JaggedArray.fromiter([[1], [2, 3], []])\n        assert a.tojagged(a).tolist() == a.tolist()\n        b = numpy.array([3,4,5])\n        assert a.tojagged(b+1).tolist() == JaggedArray.fromiter([[4], [5, 5], []]).tolist()\n        a = JaggedArray.fromiter([[]])\n        assert a.tojagged(a).tolist() == a.tolist()\n        a = JaggedArray.fromiter([[], []])\n        assert a.tojagged(a).tolist() == a.tolist()\n\n    def test_jagged_str(self):\n        pass\n\n    def test_jagged_tuple(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[2][1] == 4.4\n        assert a[2, 1] == 4.4\n        assert a[2:, 1].tolist() == [4.4, 6.6]\n        assert a[2:, -2].tolist() == [3.3, 8.8]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[1][1].tolist() == [5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[1][1][1] == 6.6\n        assert a[1, 1].tolist() == [5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[1, 1, 1] == 6.6\n        assert a[:, 1].tolist() == [[], [5.5, 6.6, 7.7, 8.8, 9.9]]\n        assert a[:, 1][1].tolist() == [5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[:, 0].tolist() == [[0.0, 1.1, 2.2], [3.3, 4.4]]\n        assert a[:, 0, 1].tolist() == [1.1, 4.4]\n        assert a[:, 0, 1, 1].tolist() == 4.4\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a[2][1].tolist() == [4.4]\n        assert a[2][1][0] == 4.4\n        assert a[2, 1].tolist() == [4.4]\n        assert a[2, 1, 0] == 4.4\n        assert a[2:, 1].tolist() == [[4.4], [6.6]]\n        assert a[2:, 1][1].tolist() == [6.6]\n        assert a[2:, 1, 1].tolist() == [6.6]\n        assert a[2:, 1, 1][0] == 6.6\n        assert a[2:, 1, 1, 0] == 6.6\n        assert a[2:, -2].tolist() == [[3.3], [8.8]]\n\n    def test_jagged_slice(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[1:-1].tolist() == [[], [3.3, 4.4]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[:].tolist() == [[[0.0, 1.1, 2.2], []], [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n        assert a[1:].tolist() == [[[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a[1:-1].tolist() == [[], [[3.3], [4.4]]]\n\n    def test_jagged_mask(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[[False, True, True, False]].tolist() == [[], [3.3, 4.4]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[[True, True]].tolist() == [[[0.0, 1.1, 2.2], []], [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n        assert a[[False, True]].tolist() == [[[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a[[False, True, True, False]].tolist() == [[], [[3.3], [4.4]]]\n\n    def test_jagged_fancy(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[[1, 2]].tolist() == [[], [3.3, 4.4]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a[[0, 1]].tolist() == [[[0.0, 1.1, 2.2], []], [[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n        assert a[[1]].tolist() == [[[3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a[[1, 2]].tolist() == [[], [[3.3], [4.4]]]\n\n    def test_jagged_subslice(self):\n        a = JaggedArray.fromiter([[], [100, 101, 102], [200, 201, 202, 203], [300, 301, 302, 303, 304], [], [500, 501], [600], []])\n        for start in None, 0, 1, 2, 3, 4, 5, -1, -2, -3, -4, -5, -6:\n            for stop in None, 0, 1, 2, 3, 4, 5, -1, -2, -3, -4, -5, -6:\n                for step in None, 1, 2, 3, 4, 5, -1, -2, -3, -4, -5:\n                    assert a[:, start:stop:step].tolist() == [x.tolist()[start:stop:step] for x in a]\n\n    def test_jagged_jagged(self):\n        a = JaggedArray.fromoffsets([0, 3, 3, 5], JaggedArray.fromoffsets([0, 3, 3, 8, 10, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert [a[i].tolist() for i in range(len(a))] == [[[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]], [], [[8.8, 9.9], []]]\n        assert [x.tolist() for x in a] == [[[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]], [], [[8.8, 9.9], []]]\n        assert [x.tolist() for x in a[:]] == [[[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]], [], [[8.8, 9.9], []]]\n        assert [x.tolist() for x in a[:-1]] == [[[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]], []]\n        assert [x.tolist() for x in a[[2, 1, 0]]] == [[[8.8, 9.9], []], [], [[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]]]\n        assert [x.tolist() for x in a[[True, True, False]]] == [[[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7]], []]\n        assert a[::2, 0].tolist() == [[0.0, 1.1, 2.2], [8.8, 9.9]]\n        assert a[::2, 1].tolist() == [[], []]\n        assert a[::2, 0, 1].tolist() == [1.1, 9.9]\n\n    def test_jagged_ufunc(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert (100 + a).tolist() == [[100.0, 101.1, 102.2], [], [103.3, 104.4], [105.5, 106.6, 107.7, 108.8, 109.9]]\n        assert (numpy.array([100, 200, 300, 400]) + a).tolist() == [[100.0, 101.1, 102.2], [], [303.3, 304.4], [405.5, 406.6, 407.7, 408.8, 409.9]]\n\n    def test_jagged_ufunc_object(self):\n        class Z(object):\n            def __init__(self, z):\n                try:\n                    self.z = list(z)\n                except TypeError:\n                    self.z = z\n            def __eq__(self, other):\n                return isinstance(other, Z) and self.z == other.z\n            def __ne__(self, other):\n                return not self.__eq__(other)\n            def __repr__(self):\n                return ""Z({0})"".format(self.z)\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert (awkward.ObjectArray([100, 200, 300, 400], Z) + a).tolist() == [Z([100., 101.1, 102.2]), Z([]), Z([303.3, 304.4]), Z([405.5, 406.6, 407.7, 408.8, 409.9])]\n\n        self.assertRaises(ValueError, lambda: ""yay"" if (a + [100, 200, 300, 400]) == [[100.0, 101.1, 102.2], [], [303.3, 304.4], [405.5, 406.6, 407.7, 408.8, 409.9]] else ""boo"")\n        self.assertRaises(ValueError, lambda: ""yay"" if (a + [100, 200, 300, 400]).content == [100.0, 101.1, 102.2, 303.3, 304.4, 405.5, 406.6, 407.7, 408.8, 409.9] else ""boo"")\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], awkward.ObjectArray([0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], Z))\n        assert a.tolist() == [[Z(0.0), Z(1.1), Z(2.2)], [], [Z(3.3), Z(4.4)], [Z(5.5), Z(6.6), Z(7.7), Z(8.8), Z(9.9)]]\n        assert (a + awkward.ObjectArray([100, 200, 300, 400], Z)).tolist() == [[Z(100.0), Z(101.1), Z(102.2)], [], [Z(303.3), Z(304.4)], [Z(405.5), Z(406.6), Z(407.7), Z(408.8), Z(409.9)]]\n\n    def test_jagged_ufunc_table(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert (awkward.Table(x=[100, 200, 300, 400], y=[1000, 2000, 3000, 4000]) + a).tolist() == [{""x"": [100.0, 101.1, 102.2], ""y"": [1000.0, 1001.1, 1002.2]}, {""x"": [], ""y"": []}, {""x"": [303.3, 304.4], ""y"": [3003.3, 3004.4]}, {""x"": [405.5, 406.6, 407.7, 408.8, 409.9], ""y"": [4005.5, 4006.6, 4007.7, 4008.8, 4009.9]}]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], awkward.Table(x=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], y=[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        assert (a + 1000).tolist() == [[{""x"": 1000, ""y"": 1000.0}, {""x"": 1001, ""y"": 1001.1}, {""x"": 1002, ""y"": 1002.2}], [], [{""x"": 1003, ""y"": 1003.3}, {""x"": 1004, ""y"": 1004.4}], [{""x"": 1005, ""y"": 1005.5}, {""x"": 1006, ""y"": 1006.6}, {""x"": 1007, ""y"": 1007.7}, {""x"": 1008, ""y"": 1008.8}, {""x"": 1009, ""y"": 1009.9}]]\n        assert (a + numpy.array([100, 200, 300, 400])).tolist() == [[{""x"": 100, ""y"": 100.0}, {""x"": 101, ""y"": 101.1}, {""x"": 102, ""y"": 102.2}], [], [{""x"": 303, ""y"": 303.3}, {""x"": 304, ""y"": 304.4}], [{""x"": 405, ""y"": 405.5}, {""x"": 406, ""y"": 406.6}, {""x"": 407, ""y"": 407.7}, {""x"": 408, ""y"": 408.8}, {""x"": 409, ""y"": 409.9}]]\n        assert (a + awkward.Table(x=[100, 200, 300, 400], y=[1000, 2000, 3000, 4000])).tolist() == [[{""x"": 100, ""y"": 1000.0}, {""x"": 101, ""y"": 1001.1}, {""x"": 102, ""y"": 1002.2}], [], [{""x"": 303, ""y"": 3003.3}, {""x"": 304, ""y"": 3004.4}], [{""x"": 405, ""y"": 4005.5}, {""x"": 406, ""y"": 4006.6}, {""x"": 407, ""y"": 4007.7}, {""x"": 408, ""y"": 4008.8}, {""x"": 409, ""y"": 4009.9}]]\n\n    def test_jagged_regular(self):\n        a = JaggedArray([0, 3, 6, 9], [3, 6, 9, 12], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9, 10.0, 11.0])\n        assert a.regular().tolist() == [[0.0, 1.1, 2.2], [3.3, 4.4, 5.5], [6.6, 7.7, 8.8], [9.9, 10.0, 11.0]]\n\n        a = JaggedArray([0, 3, 6, 9], [3, 6, 9, 12], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9], [10.0], [11.0]])\n        assert a.regular().tolist() == [[[0.0], [1.1], [2.2]], [[3.3], [4.4], [5.5]], [[6.6], [7.7], [8.8]], [[9.9], [10.0], [11.0]]]\n\n        a = JaggedArray([[0, 3], [6, 9]], [[3, 6], [9, 12]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9, 10.0, 11.0])\n        assert a.regular().tolist() == [[[0.0, 1.1, 2.2], [3.3, 4.4, 5.5]], [[6.6, 7.7, 8.8], [9.9, 10.0, 11.0]]]\n\n        a = JaggedArray([[0, 3], [6, 9]], [[3, 6], [9, 12]], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9], [10.0], [11.0]])\n        assert a.regular().tolist() == [[[[0.0], [1.1], [2.2]], [[3.3], [4.4], [5.5]]], [[[6.6], [7.7], [8.8]], [[9.9], [10.0], [11.0]]]]\n\n        a = JaggedArray([0, 3, 7, 10], [3, 6, 10, 13], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 999, 6.6, 7.7, 8.8, 9.9, 10.0, 11.0])\n        assert a.regular().tolist() == [[0.0, 1.1, 2.2], [3.3, 4.4, 5.5], [6.6, 7.7, 8.8], [9.9, 10.0, 11.0]]\n\n        a = JaggedArray([0, 3, 7, 10], [3, 6, 10, 13], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [999], [6.6], [7.7], [8.8], [9.9], [10.0], [11.0]])\n        assert a.regular().tolist() == [[[0.0], [1.1], [2.2]], [[3.3], [4.4], [5.5]], [[6.6], [7.7], [8.8]], [[9.9], [10.0], [11.0]]]\n\n        a = JaggedArray([[0, 3], [7, 10]], [[3, 6], [10, 13]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 999, 6.6, 7.7, 8.8, 9.9, 10.0, 11.0])\n        assert a.regular().tolist() == [[[0.0, 1.1, 2.2], [3.3, 4.4, 5.5]], [[6.6, 7.7, 8.8], [9.9, 10.0, 11.0]]]\n\n        a = JaggedArray([[0, 3], [7, 10]], [[3, 6], [10, 13]], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [999], [6.6], [7.7], [8.8], [9.9], [10.0], [11.0]])\n        assert a.regular().tolist() == [[[[0.0], [1.1], [2.2]], [[3.3], [4.4], [5.5]]], [[[6.6], [7.7], [8.8]], [[9.9], [10.0], [11.0]]]]\n\n    def test_jagged_cross(self):\n        for i in range(10):\n            for j in range(5):\n                a = JaggedArray.fromiter([[], [123], list(range(i)), []])\n                b = JaggedArray.fromiter([[], [456], list(range(j)), [999]])\n                c = a.cross(b)\n                assert len(c) == 4\n                assert len(c[0]) == 0\n                assert len(c[1]) == 1\n                assert len(c[2]) == i * j\n                assert len(c[3]) == 0\n                assert c[2][""0""].tolist() == numpy.repeat(range(i), j).tolist()\n                assert c[2][""1""].tolist() == numpy.tile(range(j), i).tolist()\n\n    def test_jagged_pairs(self):\n        for i in range(50):\n            a = JaggedArray.fromiter([[], [123], list(range(i)), []])\n            c = a.pairs()\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 1\n            assert len(c[2]) == i * (i + 1) // 2\n            assert len(c[3]) == 0\n            assert c[2][""0""].tolist() == sum([[x] * (i - x) for x in range(i)], [])\n            assert c[2][""1""].tolist() == sum([list(range(x, i)) for x in range(i)], [])\n\n    def test_jagged_distincts(self):\n        for i in range(50):\n            a = JaggedArray.fromiter([[], [123], list(range(i)), []])\n            c = a.distincts()\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 0\n            assert len(c[2]) == i * (i - 1) // 2\n            assert len(c[3]) == 0\n            left = sum([[x] * (i - x) for x in range(i)], [])\n            right = sum([list(range(x, i)) for x in range(i)], [])\n            assert c[2][""0""].tolist() == [x for x, y in zip(left, right) if x != y]\n            assert c[2][""1""].tolist() == [y for x, y in zip(left, right) if x != y]\n\n    def test_jagged_argchoose(self):\n        for i in range(50):\n            a = JaggedArray.fromiter([[], [1234], list(range(i)), []])\n            c = a.argchoose(2)\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 0\n            assert len(c[2]) == i*(i - 1)//2\n            assert len(c[3]) == 0\n            i0 = []\n            i1 = []\n            for k0 in range(i):\n                for k1 in range(k0):\n                    i0.append(k1)\n                    i1.append(k0)\n            assert c[2].i0.tolist() == i0\n            assert c[2].i1.tolist() == i1\n            c = a.argchoose(3)\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 0\n            assert len(c[2]) == i*(i - 1)*(i - 2)//6\n            assert len(c[3]) == 0\n            i0 = []\n            i1 = []\n            i2 = []\n            for k0 in range(i):\n                for k1 in range(k0):\n                    for k2 in range(k1):\n                        i0.append(k2)\n                        i1.append(k1)\n                        i2.append(k0)\n            assert c[2].i0.tolist() == i0\n            assert c[2].i1.tolist() == i1\n            assert c[2].i2.tolist() == i2\n            c = a.argchoose(4)\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 0\n            assert len(c[2]) == i*(i - 1)*(i - 2)*(i - 3)//24\n            assert len(c[3]) == 0\n            i0 = []\n            i1 = []\n            i2 = []\n            i3 = []\n            for k0 in range(i):\n                for k1 in range(k0):\n                    for k2 in range(k1):\n                        for k3 in range(k2):\n                            i0.append(k3)\n                            i1.append(k2)\n                            i2.append(k1)\n                            i3.append(k0)\n            assert c[2].i0.tolist() == i0\n            assert c[2].i1.tolist() == i1\n            assert c[2].i2.tolist() == i2\n            assert c[2].i3.tolist() == i3\n            if i > 20:\n                continue\n            c = a.argchoose(5)\n            assert len(c) == 4\n            assert len(c[0]) == 0\n            assert len(c[1]) == 0\n            assert len(c[2]) == i*(i - 1)*(i - 2)*(i - 3)*(i - 4)//120\n            assert len(c[3]) == 0\n            i0 = []\n            i1 = []\n            i2 = []\n            i3 = []\n            i4 = []\n            for k0 in range(i):\n                for k1 in range(k0):\n                    for k2 in range(k1):\n                        for k3 in range(k2):\n                            for k4 in range(k3):\n                                i0.append(k4)\n                                i1.append(k3)\n                                i2.append(k2)\n                                i3.append(k1)\n                                i4.append(k0)\n            assert c[2].i0.tolist() == i0\n            assert c[2].i1.tolist() == i1\n            assert c[2].i2.tolist() == i2\n            assert c[2].i3.tolist() == i3\n            assert c[2].i4.tolist() == i4\n\n    def test_jagged_cross_argnested(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        b = awkward.fromiter([[100, 200], [300], [400]])\n        c = awkward.fromiter([[999], [999], [999, 888]])\n\n        assert a.cross(b).tolist() == [[(1.1, 100), (1.1, 200), (2.2, 100), (2.2, 200), (3.3, 100), (3.3, 200)], [], [(4.4, 400), (5.5, 400)]]\n        assert a.argcross(b).tolist() == [[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)], [], [(0, 0), (1, 0)]]\n        assert a.cross(b, nested=True).tolist() == [[[(1.1, 100), (1.1, 200)], [(2.2, 100), (2.2, 200)], [(3.3, 100), (3.3, 200)]], [], [[(4.4, 400)], [(5.5, 400)]]]\n        assert a.argcross(b, nested=True).tolist() == [[[(0, 0), (0, 1)], [(1, 0), (1, 1)], [(2, 0), (2, 1)]], [], [[(0, 0)], [(1, 0)]]]\n\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[0] == [[[(ai, bi, ci) for ci in c[0]] for bi in b[0]] for ai in a[0]]\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[1] == [[[(ai, bi, ci) for ci in c[1]] for bi in b[1]] for ai in a[1]]\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[2] == [[[(ai, bi, ci) for ci in c[2]] for bi in b[2]] for ai in a[2]]\n\n        assert a.cross(b).cross(c).tolist() == [[(1.1, 100, 999), (1.1, 200, 999), (2.2, 100, 999), (2.2, 200, 999), (3.3, 100, 999), (3.3, 200, 999)], [], [(4.4, 400, 999), (4.4, 400, 888), (5.5, 400, 999), (5.5, 400, 888)]]\n        assert a.cross(b, nested=True).cross(c).tolist() == [[[(1.1, 100, 999), (1.1, 200, 999)], [(2.2, 100, 999), (2.2, 200, 999)], [(3.3, 100, 999), (3.3, 200, 999)]], [], [[(4.4, 400, 999), (4.4, 400, 888)], [(5.5, 400, 999), (5.5, 400, 888)]]]\n        assert a.cross(b).cross(c, nested=True).tolist() == [[[(1.1, 100, 999)], [(1.1, 200, 999)], [(2.2, 100, 999)], [(2.2, 200, 999)], [(3.3, 100, 999)], [(3.3, 200, 999)]], [], [[(4.4, 400, 999), (4.4, 400, 888)], [(5.5, 400, 999), (5.5, 400, 888)]]]\n\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        b = awkward.fromiter([[100, 200], [300], [400]])\n        c = awkward.fromiter([[999], [999], [999, 888, 777]])\n\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[0] == [[[(ai, bi, ci) for ci in c[0]] for bi in b[0]] for ai in a[0]]\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[1] == [[[(ai, bi, ci) for ci in c[1]] for bi in b[1]] for ai in a[1]]\n        assert a.cross(b, nested=True).cross(c, nested=True).tolist()[2] == [[[(ai, bi, ci) for ci in c[2]] for bi in b[2]] for ai in a[2]]\n\n        assert a.cross(b).cross(c).tolist() == [[(1.1, 100, 999), (1.1, 200, 999), (2.2, 100, 999), (2.2, 200, 999), (3.3, 100, 999), (3.3, 200, 999)], [], [(4.4, 400, 999), (4.4, 400, 888), (4.4, 400, 777), (5.5, 400, 999), (5.5, 400, 888), (5.5, 400, 777)]]\n        assert a.cross(b, nested=True).cross(c).tolist() == [[[(1.1, 100, 999), (1.1, 200, 999)], [(2.2, 100, 999), (2.2, 200, 999)], [(3.3, 100, 999), (3.3, 200, 999)]], [], [[(4.4, 400, 999), (4.4, 400, 888), (4.4, 400, 777)], [(5.5, 400, 999), (5.5, 400, 888), (5.5, 400, 777)]]]\n        assert a.cross(b).cross(c, nested=True).tolist() == [[[(1.1, 100, 999)], [(1.1, 200, 999)], [(2.2, 100, 999)], [(2.2, 200, 999)], [(3.3, 100, 999)], [(3.3, 200, 999)]], [], [[(4.4, 400, 999), (4.4, 400, 888), (4.4, 400, 777)], [(5.5, 400, 999), (5.5, 400, 888), (5.5, 400, 777)]]]\n\n    def test_jagged_pairs_argnested(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        assert a.pairs().tolist() == [[(1.1, 1.1), (1.1, 2.2), (1.1, 3.3), (2.2, 2.2), (2.2, 3.3), (3.3, 3.3)], [], [(4.4, 4.4), (4.4, 5.5), (5.5, 5.5)]]\n        assert a.argpairs().tolist() == [[(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)], [], [(0, 0), (0, 1), (1, 1)]]\n        assert a.pairs(nested=True).tolist() == [[[(1.1, 1.1), (1.1, 2.2), (1.1, 3.3)], [(2.2, 2.2), (2.2, 3.3)], [(3.3, 3.3)]], [], [[(4.4, 4.4), (4.4, 5.5)], [(5.5, 5.5)]]]\n        assert a.argpairs(nested=True).tolist() == [[[(0, 0), (0, 1), (0, 2)], [(1, 1), (1, 2)], [(2, 2)]], [], [[(0, 0), (0, 1)], [(1, 1)]]]\n\n    def test_jagged_distincts_argnested(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        assert a.distincts().tolist() == [[(1.1, 2.2), (1.1, 3.3), (2.2, 3.3)], [], [(4.4, 5.5)]]\n        assert a.argdistincts().tolist() == [[(0, 1), (0, 2), (1, 2)], [], [(0, 1)]]\n        assert a.distincts(nested=True).tolist() == [[[(1.1, 2.2), (1.1, 3.3)], [(2.2, 3.3)]], [], [[(4.4, 5.5)]]]\n        assert a.argdistincts(nested=True).tolist() == [[[(0, 1), (0, 2)], [(1, 2)]], [], [[(0, 1)]]]\n\n    def test_jagged_sum(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.sum().tolist() == [3.3000000000000003, 0.0, 7.7, 38.5]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.sum().tolist() == [[3.3000000000000003, 0.0], [7.7, 38.5]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.sum().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7], [8.8, 8.8], [9.9, 9.9]])\n\n        assert a.sum().tolist() == [[0.0, 2.2, 4.4], [], [6.6, 8.8], [11.0, 13.2, 15.4, 17.6, 19.8]]\n\n    def test_jagged_prod(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.prod().tolist() == [0.0, 1.0, 14.52, 24350.911200000002]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.prod().tolist() == [[0.0, 1.0], [14.52, 24350.911200000002]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.prod().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7], [8.8, 8.8], [9.9, 9.9]])\n        assert a.prod().tolist() == [[0.0, 1.2100000000000002, 4.840000000000001], [], [10.889999999999999, 19.360000000000003], [30.25, 43.559999999999995, 59.290000000000006, 77.44000000000001, 98.01]]\n\n    def test_jagged_argmin(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.argmin().tolist() == [[0], [], [0], [0]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.argmin().tolist() == [[[0], []], [[0], [0]]]\n\n    def test_jagged_argmax(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.argmax().tolist() == [[2], [], [1], [4]]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.argmax().tolist() == [[[2], []], [[1], [4]]]\n\n    def test_jagged_min(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.min().tolist() == [0.0, numpy.inf, 3.3, 5.5]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.min().tolist() == [[0.0, numpy.inf], [3.3, 5.5]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.min().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7], [8.8, 8.8], [9.9, 9.9]])\n        assert a.min().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    def test_jagged_max(self):\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.max().tolist() == [2.2, -numpy.inf, 4.4, 9.9]\n\n        a = JaggedArray([[0, 3], [3, 5]], [[3, 3], [5, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.max().tolist() == [[2.2, -numpy.inf], [4.4, 9.9]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0], [1.1], [2.2], [3.3], [4.4], [5.5], [6.6], [7.7], [8.8], [9.9]])\n        assert a.max().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n        a = JaggedArray([0, 3, 3, 5], [3, 3, 5, 10], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7], [8.8, 8.8], [9.9, 9.9]])\n        assert a.max().tolist() == [[0.0, 1.1, 2.2], [], [3.3, 4.4], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    def test_jagged_concatenate(self):\n        lst = [[1, 2, 3], [], [4, 5], [6, 7], [8], [], [9], [10, 11], [12]]\n        a_orig = JaggedArray.fromiter(lst)\n        a1 = JaggedArray.fromiter(lst[:3])\n        a2 = JaggedArray.fromiter(lst[3:6])\n        a3 = JaggedArray.fromiter(lst[6:])\n\n        a_instance_concat = a1.concatenate([a2, a3])\n        assert a_instance_concat.tolist() == a_orig.tolist()\n\n        a_class_concat = JaggedArray.concatenate([a1, a2, a3])\n        assert a_class_concat.tolist() == a_orig.tolist()\n\n    def test_jagged_concatenate_axis1(self):\n        a1 = JaggedArray([0, 0, 3, 3, 5], [0, 3, 3, 5, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        b1 = JaggedArray([0, 0, 5, 7, 7], [0, 5, 7, 7, 10], [6.5, 7.6, 8.7, 9.8, 10.9, 4.3, 5.4, 1., 2.1, 3.2])\n        c1 = a1.concatenate([b1], axis=1)\n        assert c1.tolist() == [[],[0.,1.1,2.2,6.5,7.6,8.7,9.8,10.9],[4.3,5.4],[3.3,4.4],[5.5,6.6,7.7,8.8,9.9,1.,2.1,3.2]]\n\n        # Check that concatenating boolean arrays does not accidently promote them to integers\n        a2 = JaggedArray([0], [3], [False, False, False])\n        b2 = JaggedArray([0], [3], [True, True, True])\n        c2 = a2.concatenate([b2], axis=1)\n        assert c2.content.dtype == numpy.dtype(bool)\n\n        # Test some masked arrays\n        a3 = a1[[True, True, True, False, True]]\n        b3 = b1[[True, True, True, True, False]]\n        c3 = a3.concatenate([b3], axis=1)\n        assert c3.tolist() == [[],[0.,1.1,2.2,6.5,7.6,8.7,9.8,10.9],[4.3,5.4],[5.5,6.6,7.7,8.8,9.9]]\n\n\n    def test_jagged_get(self):\n        a = JaggedArray.fromoffsets([0, 3, 3, 8, 10, 10], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert [a[i].tolist() for i in range(len(a))] == [[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7], [8.8, 9.9], []]\n        assert [x.tolist() for x in a] == [[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7], [8.8, 9.9], []]\n        assert [x.tolist() for x in a[:]] == [[0.0, 1.1, 2.2], [], [3.3, 4.4, 5.5, 6.6, 7.7], [8.8, 9.9], []]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[[0.0, 1.1, 2.2]], [[]], [[3.3, 4.4, 5.5, 6.6, 7.7]], [[8.8, 9.9]], [[]]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[0.0, 1.1, 2.2], []], [[], [3.3, 4.4, 5.5, 6.6, 7.7]], [[3.3, 4.4, 5.5, 6.6, 7.7], [8.8, 9.9]], [[8.8, 9.9], []]]\n        assert [x.tolist() for x in a[[2, 1, 0, -2]]] == [[3.3, 4.4, 5.5, 6.6, 7.7], [], [0.0, 1.1, 2.2], [8.8, 9.9]]\n        assert [x.tolist() for x in a[[True, False, True, False, True]]] == [[0.0, 1.1, 2.2], [3.3, 4.4, 5.5, 6.6, 7.7], []]\n\n    def test_jagged_get_startsstops(self):\n        a = JaggedArray([5, 2, 99, 1], [8, 7, 99, 3], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert [x.tolist() for x in a] == [[5.5, 6.6, 7.7], [2.2, 3.3, 4.4, 5.5, 6.6], [], [1.1, 2.2]]\n        assert [x.tolist() for x in a[:]] == [[5.5, 6.6, 7.7], [2.2, 3.3, 4.4, 5.5, 6.6], [], [1.1, 2.2]]\n\n    def test_jagged_get2d(self):\n        a = JaggedArray.fromoffsets([0, 3, 3, 8, 10, 10], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2], [3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7], [8.8, 8.8], [9.9, 9.9]])\n        assert [a[i].tolist() for i in range(len(a))] == [[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], [], [[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], [[8.8, 8.8], [9.9, 9.9]], []]\n        assert [x.tolist() for x in a] == [[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], [], [[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], [[8.8, 8.8], [9.9, 9.9]], []]\n        assert [x.tolist() for x in a[:]] == [[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], [], [[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], [[8.8, 8.8], [9.9, 9.9]], []]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]]], [[]], [[[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]]], [[[8.8, 8.8], [9.9, 9.9]]], [[]]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], []], [[], [[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]]], [[[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], [[8.8, 8.8], [9.9, 9.9]]], [[[8.8, 8.8], [9.9, 9.9]], []]]\n        assert [x.tolist() for x in a[[2, 1, 0, -2]]] == [[[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], [], [[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], [[8.8, 8.8], [9.9, 9.9]]]\n        assert [x.tolist() for x in a[[True, False, True, False, True]]] == [[[0.0, 0.0], [1.1, 1.1], [2.2, 2.2]], [[3.3, 3.3], [4.4, 4.4], [5.5, 5.5], [6.6, 6.6], [7.7, 7.7]], []]\n\n    def test_jagged_getstruct(self):\n        a = JaggedArray.fromoffsets([0, 3, 3, 8, 10, 10], numpy.array([(0.0, 0.0), (1.1, 1.1), (2.2, 2.2), (3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7), (8.8, 8.8), (9.9, 9.9)], dtype=[(""a"", float), (""b"", float)]))\n        assert [a[i].tolist() for i in range(len(a))] == [[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], [], [(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], [(8.8, 8.8), (9.9, 9.9)], []]\n        assert [x.tolist() for x in a] == [[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], [], [(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], [(8.8, 8.8), (9.9, 9.9)], []]\n        assert [x.tolist() for x in a[:]] == [[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], [], [(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], [(8.8, 8.8), (9.9, 9.9)], []]\n        assert [a[i : i + 1].tolist() for i in range(len(a))] == [[[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)]], [[]], [[(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)]], [[(8.8, 8.8), (9.9, 9.9)]], [[]]]\n        assert [a[i : i + 2].tolist() for i in range(len(a) - 1)] == [[[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], []], [[], [(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)]], [[(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], [(8.8, 8.8), (9.9, 9.9)]], [[(8.8, 8.8), (9.9, 9.9)], []]]\n        assert [x.tolist() for x in a[[2, 1, 0, -2]]] == [[(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], [], [(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], [(8.8, 8.8), (9.9, 9.9)]]\n        assert [x.tolist() for x in a[[True, False, True, False, True]]] == [[(0.0, 0.0), (1.1, 1.1), (2.2, 2.2)], [(3.3, 3.3), (4.4, 4.4), (5.5, 5.5), (6.6, 6.6), (7.7, 7.7)], []]\n\n    def test_jagged_zip(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        b = awkward.JaggedArray([1, 5, 5], [4, 5, 7], [999, 10, 20, 30, 999, 40, 50, 999])\n        c = numpy.array([100, 200, 300])\n        d = 1000\n        assert awkward.JaggedArray.zip(one=a, two=b).tolist() == [[{""one"": 1.1, ""two"": 10}, {""one"": 2.2, ""two"": 20}, {""one"": 3.3, ""two"": 30}], [], [{""one"": 4.4, ""two"": 40}, {""one"": 5.5, ""two"": 50}]]\n        assert awkward.JaggedArray.zip(one=b, two=a).tolist() == [[{""one"": 10, ""two"": 1.1}, {""one"": 20, ""two"": 2.2}, {""one"": 30, ""two"": 3.3}], [], [{""one"": 40, ""two"": 4.4}, {""one"": 50, ""two"": 5.5}]]\n        assert awkward.JaggedArray.zip(one=b, two=c).tolist() == [[{""one"": 10, ""two"": 100}, {""one"": 20, ""two"": 100}, {""one"": 30, ""two"": 100}], [], [{""one"": 40, ""two"": 300}, {""one"": 50, ""two"": 300}]]\n        assert awkward.JaggedArray.zip(one=b, two=d).tolist() == [[{""one"": 10, ""two"": 1000}, {""one"": 20, ""two"": 1000}, {""one"": 30, ""two"": 1000}], [], [{""one"": 40, ""two"": 1000}, {""one"": 50, ""two"": 1000}]]\n        assert a.zip(b).tolist() == [[(1.1, 10), (2.2, 20), (3.3, 30)], [], [(4.4, 40), (5.5, 50)]]\n        assert b.zip(a).tolist() == [[(10, 1.1), (20, 2.2), (30, 3.3)], [], [(40, 4.4), (50, 5.5)]]\n        assert b.zip(c).tolist() == [[(10, 100), (20, 100), (30, 100)], [], [(40, 300), (50, 300)]]\n        assert b.zip(d).tolist() == [[(10, 1000), (20, 1000), (30, 1000)], [], [(40, 1000), (50, 1000)]]\n\n    def test_jagged_structure1d(self):\n        a = awkward.JaggedArray([[0, 3, 3], [5, 8, 10]], [[3, 3, 5], [8, 10, 10]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.tolist() == a.structure1d().tolist()\n        a = awkward.JaggedArray([[[0], [3], [3]], [[5], [8], [10]]], [[[3], [3], [5]], [[8], [10], [10]]], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        assert a.tolist() == a.structure1d().tolist()\n\n    def test_jagged_pad(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        assert a.pad(4, clip=True).tolist() == [[1.1, 2.2, 3.3, None], [None, None, None, None], [4.4, 5.5, None, None]]\n        assert a.pad(4, numpy.ma.masked, clip=True).regular().tolist() == [[1.1, 2.2, 3.3, None], [None, None, None, None], [4.4, 5.5, None, None]]\n\n        assert a.pad(4).tolist() == [[1.1, 2.2, 3.3, None], [None, None, None, None], [4.4, 5.5, None, None]]\n        assert a.pad(4, numpy.ma.masked).regular().tolist() == [[1.1, 2.2, 3.3, None], [None, None, None, None], [4.4, 5.5, None, None]]\n\n        a = awkward.fromiter([[1.1, 2.2, 3.3, 4.4, 5.5], [], [6.6, 7.7, 8.8], [9.9]])\n        assert a.pad(3).tolist() == [[1.1, 2.2, 3.3, 4.4, 5.5], [None, None, None], [6.6, 7.7, 8.8], [9.9, None, None]]\n        assert a.pad(3, clip=True).tolist() == [[1.1, 2.2, 3.3], [None, None, None], [6.6, 7.7, 8.8], [9.9, None, None]]\n\n    def test_jagged_fillna(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        assert a.pad(4).fillna(999).tolist() == [[1.1, 2.2, 3.3, 999], [999, 999, 999, 999], [4.4, 5.5, 999, 999]]\n        assert a.pad(4, numpy.ma.masked).fillna(999).regular().tolist() == [[1.1, 2.2, 3.3, 999], [999, 999, 999, 999], [4.4, 5.5, 999, 999]]\n\n    def test_jagged_unzip(self):\n        a = fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        b = JaggedArray([1, 5, 5], [4, 5, 7], [999, 10, 20, 30, 999, 40, 50, 999])\n        c = numpy.array([100, 200, 300])\n        d = 1000\n\n        def check_2_tuple_contents(two_tuple, one, two):\n            assert type(two_tuple) is tuple\n            assert len(two_tuple) == 2\n            assert all((two_tuple[0] == one).flatten())\n            assert all((two_tuple[1] == two).flatten())\n\n        unzip_ab = a.zip(b).unzip()\n        unzip_ba = b.zip(a).unzip()\n        unzip_bc = b.zip(c).unzip()\n        unzip_bd = b.zip(d).unzip()\n\n        check_2_tuple_contents(unzip_ab, a, b)\n        check_2_tuple_contents(unzip_ba, b, a)\n        check_2_tuple_contents(unzip_bc, b, c)\n        check_2_tuple_contents(unzip_bd, b, d)\n\n    def test_jagged_boolean_indexing(self):\n        array1 = JaggedArray.fromcounts([1], [0])\n        array2 = JaggedArray.fromcounts([1], [0, 1])\n        indices1 = JaggedArray.fromcounts([1], [True])\n        indices2 = JaggedArray.fromcounts([1], [True, False])\n        assert all(array1[indices1] == array1[indices2])\n        assert all(array1[indices1] == array2[indices1])\n        assert all(array2[indices1] == array2[indices2])\n\n    def test_jagged_localindex(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3, 4.4, 5.5], [], [6.6, 7.7, 8.8], [9.9]])\n        assert a.localindex.tolist() == [[0, 1, 2, 3, 4], [], [0, 1, 2], [0]]\n        b = a[[False, True, False, True]]\n        assert b.localindex.tolist() == [[], [0]]\n\n    def test_jagged_parents(self):\n        a = awkward.fromiter([[1.1, 2.2, 3.3, 4.4, 5.5], [], [6.6, 7.7, 8.8], [9.9]])\n        assert a.parents.tolist() == [0, 0, 0, 0, 0, 2, 2, 2, 3]\n        b = a[[False, True, False, True]]\n        assert b.parents.tolist() == [-1, -1, -1, -1, -1, -1, -1, -1, 1]\n\n    def test_jagged_sort(self):\n        a = awkward.fromiter([[2.,3.,1.], [4., -numpy.inf, 5.], [numpy.inf, 4., numpy.nan, -numpy.inf], [numpy.nan], [3., None, 4., -1.]])\n        assert a.argsort().tolist() == [[1, 0, 2], [2, 0, 1], [0, 1, 3, 2], [0], [2, 0, 3]]\n        assert a.argsort(True).tolist() == [[2, 0, 1], [1, 0, 2], [3, 1, 0, 2], [0], [3, 0, 2]]\n\n    def test_jagged_setitem_bool_indexing(self):\n        a_normal = JaggedArray([0, 1, 1], [1, 1, 3], [1.1, 2.2, 3.3])\n        a_abnormal = JaggedArray([3, 4, 1], [4, 4, 3], [0.0, 2.2, 3.3, 1.1, 4.4])\n\n        b1 = fromiter([[True], [], [True, True]])\n        b2 = fromiter([[False], [], [True, True]])\n        b3 = fromiter([[False], [], [True, False]])\n\n        c1 = fromiter([[4.4], [], [5.5, 6.6]])\n        c2 = [7.7, 8.8]\n        c3 = 9.9\n\n        a_normal[b1] = c1\n        a_abnormal[b1] = c1\n        assert a_normal.tolist() == [[4.4], [], [5.5, 6.6]]\n        assert a_abnormal.tolist() == [[4.4], [], [5.5, 6.6]]\n        a_normal[b2] = c2\n        a_abnormal[b2] = c2\n        assert a_normal.tolist() == [[4.4], [], [7.7, 8.8]]\n        assert a_abnormal.tolist() == [[4.4], [], [7.7, 8.8]]\n        a_normal[b3] = c3\n        a_abnormal[b3] = c3\n        assert a_normal.tolist() == [[4.4], [], [9.9, 8.8]]\n        assert a_abnormal.tolist() == [[4.4], [], [9.9, 8.8]]\n\n    def test_jagged_setitem_integer_indexing(self):\n        a_normal = JaggedArray([0, 1, 1], [1, 1, 3], [1.1, 2.2, 3.3])\n        a_abnormal = JaggedArray([3, 4, 1], [4, 4, 3], [0.0, 2.2, 3.3, 1.1, 4.4])\n\n        i1 = fromiter([[0], [], [0, 1]])\n        i2 = fromiter([[], [], [0, 1]])\n        i3 = fromiter([[], [], [0]])\n\n        c1 = fromiter([[4.4], [], [5.5, 6.6]])\n        c2 = [7.7, 8.8]\n        c3 = 9.9\n\n        a_normal[i1] = c1\n        a_abnormal[i1] = c1\n        assert a_normal.tolist() == [[4.4], [], [5.5, 6.6]]\n        assert a_abnormal.tolist() == [[4.4], [], [5.5, 6.6]]\n        a_normal[i2] = c2\n        a_abnormal[i2] = c2\n        assert a_normal.tolist() == [[4.4], [], [7.7, 8.8]]\n        assert a_abnormal.tolist() == [[4.4], [], [7.7, 8.8]]\n        a_normal[i3] = c3\n        a_abnormal[i3] = c3\n        assert a_normal.tolist() == [[4.4], [], [9.9, 8.8]]\n        assert a_abnormal.tolist() == [[4.4], [], [9.9, 8.8]]\n'"
tests/test_likenumpy.py,2,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nimport awkward\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_likenumpy_slices(self):\n        print()\n\n        np = numpy.array([[1, 10, 100], [2, 20, 200], [3, 30, 300]])\n        aw = awkward.fromiter(np)\n\n        assert np.tolist() == aw.tolist()\n        assert np[:2].tolist() == aw[:2].tolist()\n        assert np[:2, :2].tolist() == aw[:2, :2].tolist()\n        assert np[:2, 2].tolist() == aw[:2, 2].tolist()\n        assert np[2, :2].tolist() == aw[2, :2].tolist()\n        assert np[:2, [0, 1]].tolist() == aw[:2, [0, 1]].tolist()\n        assert np[[0, 1], :2].tolist() == aw[[0, 1], :2].tolist()\n        assert np[:2, [0, 1, 2]].tolist() == aw[:2, [0, 1, 2]].tolist()\n        assert np[[0, 1, 2], :2].tolist() == aw[[0, 1, 2], :2].tolist()\n        assert np[[0, 1], [0, 1]].tolist() == aw[[0, 1], [0, 1]].tolist()\n        assert np[[0, 1, 2], [0, 1, 2]].tolist() == aw[[0, 1, 2], [0, 1, 2]].tolist()\n        assert np[:2, [True, False, True]].tolist() == aw[:2, [True, False, True]].tolist()\n        assert np[[True, False, True], :2].tolist() == aw[[True, False, True], :2].tolist()\n        assert np[[True, False, True], [True, False, True]].tolist() == aw[[True, False, True], [True, False, True]].tolist()\n\n        np = numpy.array([[[1, 10, 100], [2, 20, 200], [3, 30, 300]], [[4, 40, 400], [5, 50, 500], [6, 60, 600]], [[7, 70, 700], [8, 80, 800], [9, 90, 900]]])\n        aw = awkward.fromiter(np)\n\n        assert np.tolist() == aw.tolist()\n        assert np[:2].tolist() == aw[:2].tolist()\n        assert np[:2, :2].tolist() == aw[:2, :2].tolist()\n        assert np[:2, 2].tolist() == aw[:2, 2].tolist()\n        assert np[2, :2].tolist() == aw[2, :2].tolist()\n        assert np[:2, [0, 1]].tolist() == aw[:2, [0, 1]].tolist()\n        assert np[[0, 1], :2].tolist() == aw[[0, 1], :2].tolist()\n        assert np[:2, [0, 1, 2]].tolist() == aw[:2, [0, 1, 2]].tolist()\n        assert np[[0, 1, 2], :2].tolist() == aw[[0, 1, 2], :2].tolist()\n        assert np[[0, 1], [0, 1]].tolist() == aw[[0, 1], [0, 1]].tolist()\n        assert np[[0, 1, 2], [0, 1, 2]].tolist() == aw[[0, 1, 2], [0, 1, 2]].tolist()\n        assert np[:2, [True, False, True]].tolist() == aw[:2, [True, False, True]].tolist()\n        assert np[[True, False, True], :2].tolist() == aw[[True, False, True], :2].tolist()\n        assert np[[True, False, True], [True, False, True]].tolist() == aw[[True, False, True], [True, False, True]].tolist()\n\n        assert np[:2, :2, 0].tolist() == aw[:2, :2, 0].tolist()\n        assert np[:2, 2, 0].tolist() == aw[:2, 2, 0].tolist()\n        assert np[2, :2, 0].tolist() == aw[2, :2, 0].tolist()\n        assert np[:2, [0, 1], 0].tolist() == aw[:2, [0, 1], 0].tolist()\n        assert np[[0, 1], :2, 0].tolist() == aw[[0, 1], :2, 0].tolist()\n        assert np[:2, [0, 1, 2], 0].tolist() == aw[:2, [0, 1, 2], 0].tolist()\n        assert np[[0, 1, 2], :2, 0].tolist() == aw[[0, 1, 2], :2, 0].tolist()\n        assert np[[0, 1], [0, 1], 0].tolist() == aw[[0, 1], [0, 1], 0].tolist()\n        assert np[[0, 1, 2], [0, 1, 2], 0].tolist() == aw[[0, 1, 2], [0, 1, 2], 0].tolist()\n        assert np[:2, [True, False, True], 0].tolist() == aw[:2, [True, False, True], 0].tolist()\n        assert np[[True, False, True], :2, 0].tolist() == aw[[True, False, True], :2, 0].tolist()\n        assert np[[True, False, True], [True, False, True], 0].tolist() == aw[[True, False, True], [True, False, True], 0].tolist()\n\n        assert np[:2, :2, 1].tolist() == aw[:2, :2, 1].tolist()\n        assert np[:2, 2, 1].tolist() == aw[:2, 2, 1].tolist()\n        assert np[2, :2, 1].tolist() == aw[2, :2, 1].tolist()\n        assert np[:2, [0, 1], 1].tolist() == aw[:2, [0, 1], 1].tolist()\n        assert np[[0, 1], :2, 1].tolist() == aw[[0, 1], :2, 1].tolist()\n        assert np[:2, [0, 1, 2], 1].tolist() == aw[:2, [0, 1, 2], 1].tolist()\n        assert np[[0, 1, 2], :2, 1].tolist() == aw[[0, 1, 2], :2, 1].tolist()\n        assert np[[0, 1], [0, 1], 1].tolist() == aw[[0, 1], [0, 1], 1].tolist()\n        assert np[[0, 1, 2], [0, 1, 2], 1].tolist() == aw[[0, 1, 2], [0, 1, 2], 1].tolist()\n        assert np[:2, [True, False, True], 1].tolist() == aw[:2, [True, False, True], 1].tolist()\n        assert np[[True, False, True], :2, 1].tolist() == aw[[True, False, True], :2, 1].tolist()\n        assert np[[True, False, True], [True, False, True], 1].tolist() == aw[[True, False, True], [True, False, True], 1].tolist()\n'"
tests/test_masked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_masked_nbytes(self):\n        assert isinstance(MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True).nbytes, int)\n\n    def test_masked_get(self):\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n    def test_masked_get_flip(self):\n        a = MaskedArray([False, True, False, True, False, True, False, True, False, True], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=False)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n    def test_masked_ufunc(self):\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        b = MaskedArray([True, True, True, True, True, False, False, False, False, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        assert (a + b).tolist() == [None, None, None, None, None, 11.0, None, 15.4, None, 19.8]\n        assert (a + [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).tolist() == [None, 2.2, None, 6.6, None, 11.0, None, 15.4, None, 19.8]\n        assert (a + numpy.array([0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])).tolist() == [None, 2.2, None, 6.6, None, 11.0, None, 15.4, None, 19.8]\n        assert (a + IndexedMaskedArray([-1, -1, -1, 1, -1, 2, -1, 4, -1, 3], [0.0, 1.1, 2.2, 3.3, 4.4])).tolist() == [None, None, None, 4.4, None, 7.7, None, 12.100000000000001, None, 13.2]\n\n    def test_bitmasked_get(self):\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=True)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=False)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n    def test_bitmasked_get_flip(self):\n        a = BitMaskedArray.fromboolmask([False, True, False, True, False, True, False, True, False, True], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=False, lsborder=True)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n        a = BitMaskedArray.fromboolmask([False, True, False, True, False, True, False, True, False, True], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=False, lsborder=False)\n        assert a.tolist() == [None, 1.1, None, 3.3, None, 5.5, None, 7.7, None, 9.9]\n        assert a[0] is None\n        assert not a[1] is None\n        assert a[5:].tolist() == [5.5, None, 7.7, None, 9.9]\n        assert not a[5:][0] is None\n        assert a[5:][1] is None\n        assert a[[3, 2, 1]].tolist() == [3.3, None, 1.1]\n        assert a[[True, True, True, True, True, False, False, False, False, False]].tolist() == [None, 1.1, None, 3.3, None]\n\n    def test_bitmasked_arrow(self):\n        # Apache Arrow layout example\n        # https://github.com/apache/arrow/blob/master/format/Layout.md#null-bitmaps\n        a = BitMaskedArray.fromboolmask([True, True, False, True, False, True], [0, 1, 999, 2, 999, 3], maskedwhen=False, lsborder=True)\n        assert a.tolist() == [0, 1, None, 2, None, 3]\n\n        # extra gunk at the end of the array\n        a = BitMaskedArray.fromboolmask([True, True, False, True, False, True, True, True], [0, 1, 999, 2, 999, 3], maskedwhen=False, lsborder=True)\n        assert a.tolist() == [0, 1, None, 2, None, 3]\n\n        # opposite sign\n        a = BitMaskedArray.fromboolmask([True, True, False, True, False, True, False, False], [0, 1, 999, 2, 999, 3], maskedwhen=False, lsborder=True)\n        assert a.tolist() == [0, 1, None, 2, None, 3]\n\n        # doubled\n        a = BitMaskedArray.fromboolmask([True, True, False, True, False, True, True, True, False, True, False, True], [0, 1, 999, 2, 999, 3, 0, 1, 999, 2, 999, 3], maskedwhen=False, lsborder=True)\n        assert a.tolist() == [0, 1, None, 2, None, 3, 0, 1, None, 2, None, 3]\n\n    def test_indexedmasked_get(self):\n        a = IndexedMaskedArray([-1, 0, -1, 1, -1, 2, -1, 4, -1, 3], [0.0, 1.1, 2.2, 3.3, 4.4])\n        assert a.tolist() == [None, 0.0, None, 1.1, None, 2.2, None, 4.4, None, 3.3]\n        assert [a[i] for i in range(len(a))] == [None, 0.0, None, 1.1, None, 2.2, None, 4.4, None, 3.3]\n'"
tests/test_methods.py,9,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nfrom __future__ import division\n\nimport unittest\nimport numbers\nimport operator\nimport numpy as np\nimport awkward\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_method_mixin(self):\n        class TypeArrayMethods(awkward.Methods):\n            def _initObjectArray(self, table):\n                awkward.ObjectArray.__init__(self, table, lambda row: Type(row[""x""]))\n                self.content.rowname = ""Type""\n\n            @property\n            def x(self):\n                return self[""x""]\n\n            @x.setter\n            def x(self, value):\n                self[""x""] = value\n\n            def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n                if method != ""__call__"":\n                    raise NotImplemented\n\n                inputs = list(inputs)\n                for i in range(len(inputs)):\n                    if isinstance(inputs[i], awkward.util.numpy.ndarray) and inputs[i].dtype == awkward.util.numpy.dtype(object) and len(inputs[i]) > 0:\n                        idarray = awkward.util.numpy.frombuffer(inputs[i], dtype=awkward.util.numpy.uintp)\n                        if (idarray == idarray[0]).all():\n                            inputs[i] = inputs[i][0]\n\n                if ufunc is awkward.util.numpy.add or ufunc is awkward.util.numpy.subtract:\n                    if not all(isinstance(x, (TypeArrayMethods, TypeMethods)) for x in inputs):\n                        raise TypeError(""(arrays of) Type can only be added to/subtracted from other (arrays of) Type"")\n                    out = self.empty_like()\n                    out[""x""] = getattr(ufunc, method)(*[x.x for x in inputs], **kwargs)\n                    return out\n\n                else:\n                    return super(TypeArrayMethods, self).__array_ufunc__(ufunc, method, *inputs, **kwargs)\n\n        class TypeMethods(awkward.Methods):\n            _arraymethods = TypeArrayMethods\n\n            @property\n            def x(self):\n                return self._x\n\n            @x.setter\n            def x(self, value):\n                self._x = value\n\n            def _number_op(self, operator, scalar, reverse=False):\n                if not isinstance(scalar, (numbers.Number, awkward.util.numpy.number)):\n                    raise TypeError(""cannot {0} a Type with a {1}"".format(operator.__name__, type(scalar).__name__))\n                if reverse:\n                    return Type(operator(scalar, self.x))\n                else:\n                    return Type(operator(self.x, scalar))\n        \n            def _type_op(self, operator, other, reverse=False):\n                if isinstance(other, self._arraymethods):\n                    # Give precedence to reverse op, implemented using self._arraymethods.__array_ufunc__\n                    return NotImplemented\n                if not isinstance(other, self.__class__):\n                    raise TypeError(""cannot {0} a Type with a {1}"".format(operator.__name__, type(other).__name__))\n                if reverse:\n                    return Type(operator(other.x, self.x))\n                else:\n                    return Type(operator(self.x, other.x))\n\n            def __mul__(self, other):\n                return self._number_op(operator.mul, other)\n\n            def __rmul__(self, other):\n                return self._number_op(operator.mul, other, True)\n\n            def __add__(self, other):\n                return self._type_op(operator.add, other)\n\n            def __radd__(self, other):\n                return self._type_op(operator.add, other, True)\n\n        class TypeArray(TypeArrayMethods, awkward.ObjectArray):\n            def __init__(self, x):\n                self._initObjectArray(awkward.Table())\n                self[""x""] = x\n\n        class Type(TypeMethods):\n            def __init__(self, x):\n                self._x = x\n\n        counts = np.array([1, 4, 2, 0, 15])\n        x = np.arange(np.sum(counts))\n        array = TypeArray(x)\n        assert np.all(array.x == x)\n\n        assert type(3.*array) is type(array)\n        assert type(array*3.) is type(array)\n        assert np.all(3.*array == 3.*x)\n        assert np.all(array*3. == x*3.)\n\n        scalar = Type(3.)\n        assert type(array+scalar) is type(array)\n        assert type(scalar+array) is type(array)\n        assert np.all((array+scalar).x == x+3.)\n        assert np.all((scalar+array).x == 3.+x)\n\n        scalar2 = Type(4.)\n        assert (scalar+scalar2).x == 7.\n\n        JaggedTypeArray = awkward.Methods.mixin(TypeArrayMethods, awkward.JaggedArray)\n        jagged_array = JaggedTypeArray.fromcounts(counts, array)\n        assert np.all(jagged_array.x.flatten() == x)\n        assert np.all(jagged_array.pairs().i0.x.counts == counts*(counts+1)//2)\n'"
tests/test_numba.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2019, IRIS-HEP\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of the copyright holder nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nimport sys\n\nimport unittest\n\nimport numpy\nimport pytest\n\nimport awkward\nnumba = pytest.importorskip(""numba"")\nawkward_numba = pytest.importorskip(""awkward.numba"")\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_numba_unbox(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test(x):\n            return 3.14\n        test(a)\n        test(a2)\n\n    def test_numba_box(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test(x):\n            return x\n        assert test(a).tolist() == a.tolist()\n        assert test(a2).tolist() == a2.tolist()\n\n    def test_numba_init(self):\n        @numba.njit\n        def test(starts, stops, content):\n            return JaggedArray(starts, stops, content)\n        starts = numpy.array([0, 3, 3])\n        stops = numpy.array([3, 3, 5])\n        content = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5])\n        z = test(starts, stops, content)\n        assert z.tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        assert z.starts is starts\n        assert z.stops is stops\n        assert z.content is content\n        z = test(starts, stops, content)\n        assert z.tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        assert z.starts is starts\n        assert z.stops is stops\n        assert z.content is content\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        starts2 = numpy.array([0, 2, 2])\n        stops2 = numpy.array([2, 2, 3])\n        assert test(starts2, stops2, a).tolist() == [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n\n    def test_numba_new(self):\n        @numba.njit\n        def test(x, starts, stops, content):\n            return awkward_numba.array.jagged._JaggedArray_new(x, starts, stops, content, False)\n        starts = numpy.array([0, 3, 3])\n        stops = numpy.array([3, 3, 5])\n        content = numpy.array([1.1, 2.2, 3.3, 4.4, 5.5])\n        a = awkward_numba.JaggedArray.fromiter([[999.9], [3.14], [2.2, 2.2, 2.2]])\n        a2 = awkward_numba.JaggedArray.fromcounts([2, 0, 1], a)\n        z = test(a, starts, stops, content)\n        assert z.tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        assert isinstance(z, awkward_numba.JaggedArray)\n        assert type(z) is not awkward.JaggedArray\n        starts2 = numpy.array([0, 2, 2])\n        stops2 = numpy.array([2, 2, 3])\n        z2 = test(a2, starts2, stops2, z)\n        assert z2.tolist() == [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        assert isinstance(z2, awkward_numba.JaggedArray)\n        assert type(z2) is not awkward.JaggedArray\n\n    def test_numba_compact(self):\n        @numba.njit\n        def test(x):\n            return x.compact()\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a = JaggedArray(starts, stops, content)\n        a2 = JaggedArray([1, 0, 0], [3, 0, 1], a)\n        z = test(a)\n        assert z.tolist() == [[1.1, 2.2, 3.3], [], [4.4, 5.5]]\n        assert z.content.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n        assert z.iscompact\n        z2 = test(a2)\n        assert z2.tolist() == [[[], [4.4, 5.5]], [], [[1.1, 2.2, 3.3]]]\n        assert z2.content.tolist() == [[], [4.4, 5.5], [1.1, 2.2, 3.3]]\n        assert z2.iscompact\n\n    def test_numba_flatten(self):\n        @numba.njit\n        def test(x):\n            return x.flatten()\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a = JaggedArray(starts, stops, content)\n        z = test(a)\n        assert z.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n\n    def test_numba_len(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 1], a)\n        @numba.njit\n        def test1(x):\n            return len(x)\n        assert test1(a) == 3\n        assert test1(a2) == 2\n\n    def test_numba_getitem_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test1(x, i, j):\n            return x[i][j]\n        assert test1(a, 0, 0) == 1.1\n        assert test1(a, 0, 1) == 2.2\n        assert test1(a, 0, 2) == 3.3\n        assert test1(a, 2, 0) == 4.4\n        assert test1(a, 2, 1) == 5.5\n        @numba.njit\n        def test2(x, i):\n            return x[i]\n        assert test2(a, 0).tolist() == [1.1, 2.2, 3.3]\n        assert test2(a, 1).tolist() == []\n        assert test2(a, 2).tolist() == [4.4, 5.5]\n        assert test2(a2, 0).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test2(a2, 1).tolist() == []\n        assert test2(a2, 2).tolist() == [[4.4, 5.5]]\n        assert test2(a2, 0).content.tolist() == a.content.tolist()\n\n    def test_numba_getitem_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)   # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        @numba.njit\n        def test1(x, i, j):\n            return x[i:j]\n        assert test1(a, 0, 2).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test1(a, 1, 3).tolist() == [[], [4.4, 5.5]]\n        assert test1(a2, 0, 2).tolist() == [[[1.1, 2.2, 3.3], []], []]\n        assert test1(a2, 1, 3).tolist() == [[], [[4.4, 5.5]]]\n\n    def test_numba_getitem_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a2 = JaggedArray(starts, stops, content)\n        index = numpy.array([2, 2, 0, 1])\n        @numba.njit\n        def test1(x, i):\n            return x[i]\n        z = test1(a, index)\n        assert z.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z.content.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n        z2 = test1(a2, index)\n        assert z2.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z2.content.tolist() == [1.1, 2.2, 3.3, 999, 4.4, 5.5]\n        @numba.njit\n        def test2(x, i):\n            return x[i].compact()\n        z = test2(a, index)\n        assert z.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z.content.tolist() == [4.4, 5.5, 4.4, 5.5, 1.1, 2.2, 3.3]\n        z2 = test2(a2, index)\n        assert z2.tolist() == [[4.4, 5.5], [4.4, 5.5], [1.1, 2.2, 3.3], []]\n        assert z2.content.tolist() == [4.4, 5.5, 4.4, 5.5, 1.1, 2.2, 3.3]\n        a3 = JaggedArray.fromcounts([2, 0, 1], a)\n        assert test1(a3, index).tolist() == [[[4.4, 5.5]], [[4.4, 5.5]], [[1.1, 2.2, 3.3], []], []]\n\n    def test_numba_getitem_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        starts = numpy.array([0, 3, 4])\n        stops = numpy.array([3, 3, 6])\n        content = numpy.array([1.1, 2.2, 3.3, 999, 4.4, 5.5])\n        a2 = JaggedArray(starts, stops, content)\n        index = numpy.array([False, True, True])\n        @numba.njit\n        def test1(x, i):\n            return x[i]\n        z = test1(a, index)\n        assert z.tolist() == [[], [4.4, 5.5]]\n        assert z.content.tolist() == [1.1, 2.2, 3.3, 4.4, 5.5]\n        z2 = test1(a2, index)\n        assert z2.tolist() == [[], [4.4, 5.5]]\n        assert z2.content.tolist() == [1.1, 2.2, 3.3, 999, 4.4, 5.5]\n        @numba.njit\n        def test2(x, i):\n            return x[i].compact()\n        z = test2(a, index)\n        assert z.tolist() == [[], [4.4, 5.5]]\n        assert z.content.tolist() == [4.4, 5.5]\n        z2 = test2(a2, index)\n        assert z2.tolist() == [[], [4.4, 5.5]]\n        assert z2.content.tolist() == [4.4, 5.5]\n        a3 = JaggedArray.fromcounts([2, 0, 1], a)\n        assert test1(a3, index).tolist() == [[], [[4.4, 5.5]]]\n\n    def test_numba_getitem_tuple_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        @numba.njit\n        def test1(x, i):\n            return x[i,]\n        assert test1(a, 2).tolist() == [4.4, 5.5]\n\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)  # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        @numba.njit\n        def test2(x, i, j):\n            return x[i, j]\n        assert test2(a2, 0, 0).tolist() == [1.1, 2.2, 3.3]\n\n    def test_numba_getitem_tuple_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)   # [[[1.1, 2.2, 3.3], []], [], [[4.4, 5.5]]]\n        @numba.njit\n        def test1(x, i, j):\n            return x[i:j,]\n        assert test1(a, 0, 2).tolist() == [[1.1, 2.2, 3.3], []]\n        assert test1(a, 1, 3).tolist() == [[], [4.4, 5.5]]\n        assert test1(a2, 0, 2).tolist() == [[[1.1, 2.2, 3.3], []], []]\n        assert test1(a2, 1, 3).tolist() == [[], [[4.4, 5.5]]]\n\n        a3 = JaggedArray.fromcounts([2, 1], a)   # [[[1.1, 2.2, 3.3], []], [[4.4, 5.5]]]\n        assert a3[0:2, 0].tolist() == [[1.1, 2.2, 3.3], [4.4, 5.5]]\n        @numba.njit\n        def test2(x, i, j, k):\n            return x[i:j, k]\n        assert test2(a3, 0, 2, 0).tolist() == [[1.1, 2.2, 3.3], [4.4, 5.5]]\n\n    def test_numba_getitem_tuple_slice_integer(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)\n        @numba.njit\n        def test3(x, i, j, k):\n            return x[i:j, k]\n        assert test3(a, 0, 2, 1).tolist() == [2.2, 5.5]\n        assert test3(a2, 0, 2, 1).tolist() == [[4.4, 5.5], [8.8, 9.9]]\n\n    def test_numba_getitem_tuple_slice_slice(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)\n        @numba.njit\n        def test3(x, i, j, k, l):\n            return x[i:j, k:l]\n        assert test3(a, 0, 2, -2, None).tolist() == [[2.2, 3.3], [4.4, 5.5]]\n        assert test3(a2, 0, 2, 1, 2).tolist() == [[[4.4, 5.5]], [[8.8, 9.9]]]\n\n        @numba.njit\n        def test4(x, i, j, k, l):\n            return x[i:j, k:l:1]\n        assert test4(a, 0, 2, -2, None).tolist() == [[2.2, 3.3], [4.4, 5.5]]\n        assert test4(a2, 0, 2, 1, 2).tolist() == [[[4.4, 5.5]], [[8.8, 9.9]]]\n\n    def test_numba_getitem_tuple_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)   # [[[1.1, 2.2, 3.3], [4.4, 5.5]], [[6.6, 7.7], [8.8, 9.9]]]\n        @numba.njit\n        def test1(x, i, j):\n            return x[i, j]\n        assert test1(a, numpy.array([True, False, True, False]), 1).tolist() == [2.2, 7.7]\n        assert test1(a2, numpy.array([False, True]), 1).tolist() == [[8.8, 9.9]]\n\n    def test_numba_getitem_tuple_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [4.4, 5.5], [6.6, 7.7], [8.8, 9.9]])\n        a2 = JaggedArray.fromcounts([2, 2], a)   # [[[1.1, 2.2, 3.3], [4.4, 5.5]], [[6.6, 7.7], [8.8, 9.9]]]\n        @numba.njit\n        def test1(x, i, j):\n            return x[i, j]\n        assert test1(a, numpy.array([2, 0]), 1).tolist() == [7.7, 2.2]\n        assert test1(a2, numpy.array([1, 0, 0]), 1).tolist() == [[8.8, 9.9], [4.4, 5.5], [4.4, 5.5]]\n\n    def test_numba_getitem_tuple_slice_boolarray(self):\n        a = numpy.arange(36).reshape(4, 3, 3)\n        a2 = awkward.fromiter(a)\n        @numba.njit\n        def test1(x, i):\n            return x[1:3, i]\n        assert test1(a, numpy.array([True, False, True])).tolist() == [[[9, 10, 11], [15, 16, 17]], [[18, 19, 20], [24, 25, 26]]]\n        assert test1(a2, numpy.array([True, False, True])).tolist() == [[[9, 10, 11], [15, 16, 17]], [[18, 19, 20], [24, 25, 26]]]\n        @numba.njit\n        def test2(x, i, j):\n            return x[1:3, i, j]\n        assert test2.py_func(a, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[9, 16], [18, 25]]\n        assert test2(a2, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[9, 16], [18, 25]]\n        a = numpy.arange(27).reshape(3, 3, 3)\n        a2 = awkward.fromiter(a)\n        @numba.njit\n        def test3(x, i, j):\n            return x[i, j]\n        assert test3.py_func(a, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[0, 1, 2], [21, 22, 23]]\n        assert test3(a2, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[0, 1, 2], [21, 22, 23]]\n        @numba.njit\n        def test4(x, i, j):\n            return x[i, :, j]\n        assert test4.py_func(a, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[0, 3, 6], [19, 22, 25]]\n        assert test4(a2, numpy.array([True, False, True]), numpy.array([True, True, False])).tolist() == [[0, 3, 6], [19, 22, 25]]\n\n    def test_numba_getitem_tuple_slice_intarray(self):\n        a = numpy.arange(36).reshape(4, 3, 3)\n        a2 = awkward.fromiter(a)\n        @numba.njit\n        def test1(x, i):\n            return x[1:3, i]\n        assert test1(a, numpy.array([1, 0, 2])).tolist() == [[[12, 13, 14], [9, 10, 11], [15, 16, 17]], [[21, 22, 23], [18, 19, 20], [24, 25, 26]]]\n        assert test1(a2, numpy.array([1, 0, 2])).tolist() == [[[12, 13, 14], [9, 10, 11], [15, 16, 17]], [[21, 22, 23], [18, 19, 20], [24, 25, 26]]]\n\n    def test_numba_getitem_jagged_boolarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test1(x, i):\n            return x[i]\n        assert test1(a, awkward.fromiter([[True, False, True], [], [False, True]])).tolist() == [[1.1, 3.3], [], [5.5]]\n        assert test1(a2, awkward.fromiter([[True, False], [], [True]])).tolist() == [[[1.1, 2.2, 3.3]], [], [[4.4, 5.5]]]\n        assert test1(a2, awkward.fromiter([[[True, False, True], []], [], [[False, True]]])).tolist() == [[[1.1, 3.3], []], [], [[5.5]]]\n\n    def test_numba_getitem_jagged_intarray(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test1(x, i):\n            return x[i]\n        assert test1(a, awkward.fromiter([[2, 0, 0], [], [1]])).tolist() == [[3.3, 1.1, 1.1], [], [5.5]]\n        assert test1(a2, awkward.fromiter([[1, 0], [], [0]])).tolist() == [[[], [1.1, 2.2, 3.3]], [], [[4.4, 5.5]]]\n        assert test1(a2, awkward.fromiter([[[2, 0, 0], []], [], [[1]]])).tolist() == [[[3.3, 1.1, 1.1], []], [], [[5.5]]]\n\n    def test_numba_getiter(self):\n        a = JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = JaggedArray.fromcounts([2, 0, 1], a)\n        @numba.njit\n        def test1(x):\n            out = 0.0\n            for xi in x:\n                for xij in xi:\n                    out += xij\n            return out\n        assert test1(a) == 16.5\n        @numba.njit\n        def test2(x):\n            out = 0.0\n            for xi in x:\n                for xij in xi:\n                    for xijk in xij:\n                        out += xijk\n            return out\n        assert test2(a2) == 16.5\n\n    def test_numba_reducers(self):\n        a = awkward.numba.fromiter([[0, numpy.nan, 3.3], [], [4, 5]])\n        a2 = awkward.numba.JaggedArray.fromcounts([2, 0, 1], a)\n        assert numba.njit()(lambda x: x.any())(a).tolist() == [True, False, True]\n        assert numba.njit()(lambda x: x.any())(a2).tolist() == [[True, False], [], [True]]\n        assert numba.njit()(lambda x: x.all())(a).tolist() == [False, True, True]\n        assert numba.njit()(lambda x: x.all())(a2).tolist() == [[False, True], [], [True]]\n        assert numba.njit()(lambda x: x.count())(a).tolist() == [2, 0, 2]\n        assert numba.njit()(lambda x: x.count())(a2).tolist() == [[2, 0], [], [2]]\n        assert numba.njit()(lambda x: x.count_nonzero())(a).tolist() == [1, 0, 2]\n        assert numba.njit()(lambda x: x.count_nonzero())(a2).tolist() == [[1, 0], [], [2]]\n        assert numba.njit()(lambda x: x.sum())(a).tolist() == [3.3, 0.0, 9.0]\n        assert numba.njit()(lambda x: x.sum())(a2).tolist() == [[3.3, 0.0], [], [9.0]]\n        assert numba.njit()(lambda x: x.prod())(a).tolist() == [0.0, 1.0, 20.0]\n        assert numba.njit()(lambda x: x.prod())(a2).tolist() == [[0.0, 1.0], [], [20.0]]\n        assert numba.njit()(lambda x: x.min())(a).tolist() == [0.0, numpy.inf, 4.0]\n        assert numba.njit()(lambda x: x.min())(a2).tolist() == [[0.0, numpy.inf], [], [4.0]]\n        assert numba.njit()(lambda x: x.max())(a).tolist() == [3.3, -numpy.inf, 5.0]\n        assert numba.njit()(lambda x: x.max())(a2).tolist() == [[3.3, -numpy.inf], [], [5.0]]\n\n        a = awkward.numba.fromiter([[1, 2, 3], [], [4, 5]])\n        a2 = awkward.numba.JaggedArray.fromcounts([2, 0, 1], a)\n        assert numba.njit()(lambda x: x.any())(a).tolist() == [True, False, True]\n        assert numba.njit()(lambda x: x.any())(a2).tolist() == [[True, False], [], [True]]\n        assert numba.njit()(lambda x: x.all())(a).tolist() == [True, True, True]\n        assert numba.njit()(lambda x: x.all())(a2).tolist() == [[True, True], [], [True]]\n        assert numba.njit()(lambda x: x.count())(a).tolist() == [3, 0, 2]\n        assert numba.njit()(lambda x: x.count())(a2).tolist() == [[3, 0], [], [2]]\n        assert numba.njit()(lambda x: x.count_nonzero())(a).tolist() == [3, 0, 2]\n        assert numba.njit()(lambda x: x.count_nonzero())(a2).tolist() == [[3, 0], [], [2]]\n        assert numba.njit()(lambda x: x.sum())(a).tolist() == [6, 0, 9]\n        assert numba.njit()(lambda x: x.sum())(a2).tolist() == [[6, 0], [], [9]]\n        assert numba.njit()(lambda x: x.prod())(a).tolist() == [6, 1, 20]\n        assert numba.njit()(lambda x: x.prod())(a2).tolist() == [[6, 1], [], [20]]\n        assert numba.njit()(lambda x: x.min())(a).tolist() == [1, numpy.iinfo(numpy.int64).max, 4]\n        assert numba.njit()(lambda x: x.min())(a2).tolist() == [[1, numpy.iinfo(numpy.int64).max], [], [4]]\n        assert numba.njit()(lambda x: x.max())(a).tolist() == [3, numpy.iinfo(numpy.int64).min, 5]\n        assert numba.njit()(lambda x: x.max())(a2).tolist() == [[3, numpy.iinfo(numpy.int64).min], [], [5]]\n\n        a = awkward.numba.fromiter([[True, False, True], [], [False, True]])\n        a2 = awkward.numba.JaggedArray.fromcounts([2, 0, 1], a)\n        assert numba.njit()(lambda x: x.any())(a).tolist() == [True, False, True]\n        assert numba.njit()(lambda x: x.any())(a2).tolist() == [[True, False], [], [True]]\n        assert numba.njit()(lambda x: x.all())(a).tolist() == [False, True, False]\n        assert numba.njit()(lambda x: x.all())(a2).tolist() == [[False, True], [], [False]]\n        assert numba.njit()(lambda x: x.count())(a).tolist() == [3, 0, 2]\n        assert numba.njit()(lambda x: x.count())(a2).tolist() == [[3, 0], [], [2]]\n        assert numba.njit()(lambda x: x.count_nonzero())(a).tolist() == [2, 0, 1]\n        assert numba.njit()(lambda x: x.count_nonzero())(a2).tolist() == [[2, 0], [], [1]]\n        assert numba.njit()(lambda x: x.sum())(a).tolist() == [True, False, True]\n        assert numba.njit()(lambda x: x.sum())(a2).tolist() == [[True, False], [], [True]]\n        assert numba.njit()(lambda x: x.prod())(a).tolist() == [False, True, False]\n        assert numba.njit()(lambda x: x.prod())(a2).tolist() == [[False, True], [], [False]]\n        assert numba.njit()(lambda x: x.min())(a).tolist() == [False, True, False]\n        assert numba.njit()(lambda x: x.min())(a2).tolist() == [[False, True], [], [False]]\n        assert numba.njit()(lambda x: x.max())(a).tolist() == [True, False, True]\n        assert numba.njit()(lambda x: x.max())(a2).tolist() == [[True, False], [], [True]]\n'"
tests/test_objects.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport struct\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_object_nbytes(self):\n        class Point(object):\n            def __init__(self, array):\n                self.x, self.y, self.z = array\n            def __repr__(self):\n                return ""<Point {0} {1} {2}>"".format(self.x, self.y, self.z)\n            def __eq__(self, other):\n                return isinstance(other, Point) and self.x == other.x and self.y == other.y and self.z == other.z\n\n        assert isinstance(ObjectArray([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]], Point).nbytes, int)\n\n    def test_object_floats(self):\n        class Point(object):\n            def __init__(self, array):\n                self.x, self.y, self.z = array\n            def __repr__(self):\n                return ""<Point {0} {1} {2}>"".format(self.x, self.y, self.z)\n            def __eq__(self, other):\n                return isinstance(other, Point) and self.x == other.x and self.y == other.y and self.z == other.z\n\n        a = ObjectArray([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]], Point)\n        assert a[0] == Point([1.1, 2.2, 3.3])\n        assert a[1] == Point([4.4, 5.5, 6.6])\n        assert a[2] == Point([7.7, 8.8, 9.9])\n        assert a[:].tolist() == [Point([1.1, 2.2, 3.3]), Point([4.4, 5.5, 6.6]), Point([7.7, 8.8, 9.9])]\n        assert a[::2].tolist() == [Point([1.1, 2.2, 3.3]), Point([7.7, 8.8, 9.9])]\n        assert a[[True, False, True]].tolist() == [Point([1.1, 2.2, 3.3]), Point([7.7, 8.8, 9.9])]\n        assert a[[2, 0]].tolist() == [Point([7.7, 8.8, 9.9]), Point([1.1, 2.2, 3.3])]\n\n    def test_object_bytes(self):\n        class Point(object):\n            def __init__(self, bytes):\n                self.x, self.y, self.z = struct.unpack(""ddd"", bytes)\n            def __repr__(self):\n                return ""<Point {0} {1} {2}>"".format(self.x, self.y, self.z)\n            def __eq__(self, other):\n                return isinstance(other, Point) and self.x == other.x and self.y == other.y and self.z == other.z\n\n        a = ObjectArray(numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).view(""u1"").reshape(-1, 24), Point)\n        assert a[0] == Point(numpy.array([1.1, 2.2, 3.3]).tobytes())\n        assert a[1] == Point(numpy.array([4.4, 5.5, 6.6]).tobytes())\n        assert a[2] == Point(numpy.array([7.7, 8.8, 9.9]).tobytes())\n        assert a[:].tolist() == [Point(numpy.array([1.1, 2.2, 3.3]).tobytes()), Point(numpy.array([4.4, 5.5, 6.6]).tobytes()), Point(numpy.array([7.7, 8.8, 9.9]).tobytes())]\n        assert a[::2].tolist() == [Point(numpy.array([1.1, 2.2, 3.3]).tobytes()), Point(numpy.array([7.7, 8.8, 9.9]).tobytes())]\n        assert a[[True, False, True]].tolist() == [Point(numpy.array([1.1, 2.2, 3.3]).tobytes()), Point(numpy.array([7.7, 8.8, 9.9]).tobytes())]\n        assert a[[2, 0]].tolist() == [Point(numpy.array([7.7, 8.8, 9.9]).tobytes()), Point(numpy.array([1.1, 2.2, 3.3]).tobytes())]\n'"
tests/test_pandas.py,0,"b'import pytest\npandas = pytest.importorskip(""pandas"")\n\n\n@pytest.fixture\ndef awkward_pandas():\n    from awkward import pandas\n    return pandas\n\n\ndef test_import_pandas(awkward_pandas):\n    pass\n'"
tests/test_persist.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport pickle\nimport struct\nimport unittest\nimport zlib\n\nimport numpy\n\nfrom awkward import *\nfrom awkward.persist import *\nfrom awkward.type import *\n\ndef makearray():\n    return range(10)\n\nclass FloatPoint(object):\n    def __init__(self, array):\n        self.x, self.y, self.z = array\n    def __repr__(self):\n        return ""<FloatPoint {0} {1} {2}>"".format(self.x, self.y, self.z)\n    def __eq__(self, other):\n        return isinstance(other, FloatPoint) and self.x == other.x and self.y == other.y and self.z == other.z\n\nclass BytesPoint(object):\n    def __init__(self, bytes):\n        self.x, self.y, self.z = struct.unpack(""ddd"", bytes)\n    def __repr__(self):\n        return ""<BytesPoint {0} {1} {2}>"".format(self.x, self.y, self.z)\n    def __eq__(self, other):\n        return isinstance(other, BytesPoint) and self.x == other.x and self.y == other.y and self.z == other.z\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_pickle(self):\n        a = awkward.JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        b = pickle.loads(pickle.dumps(a))\n        assert a.tolist() == b.tolist()\n\n    def test_uncompressed_numpy(self):\n        storage = {}\n        a = numpy.arange(100, dtype="">u2"").reshape(-1, 5)\n        serialize(a, storage, compression=None)\n        b = deserialize(storage)\n        assert numpy.array_equal(a, b)\n        assert a.dtype == b.dtype\n        assert a.shape == b.shape\n\n    def test_compressed_numpy(self):\n        storage = {}\n        a = numpy.arange(100, dtype="">u2"").reshape(-1, 5)\n        serialize(a, storage, compression=zlib.compress)\n        b = deserialize(storage)\n        assert numpy.array_equal(a, b)\n        assert a.dtype == b.dtype\n        assert a.shape == b.shape\n\n    def test_crossref(self):\n        starts = [1, 0, 4, 0, 0]\n        stops  = [4, 0, 5, 0, 0]\n        a = awkward.JaggedArray(starts, stops, [])\n        a.content = a\n        a = awkward.IndexedArray([0, 4], a)\n        storage = {}\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_two_in_one(self):\n        storage = {}\n        a1 = awkward.JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        a2 = awkward.JaggedArray.fromiter([[], [1, 2], [3], []])\n        serialize(a1, storage, ""one"")\n        serialize(a2, storage, ""two"")\n        b1 = deserialize(storage, ""one"")\n        b2 = deserialize(storage, ""two"")\n        assert a1.tolist() == b1.tolist()\n        assert a2.tolist() == b2.tolist()\n\n    def test_ChunkedArray(self):\n        storage = {}\n        a = awkward.ChunkedArray([[0.0, 1.1, 2.2], [], [3.3, 4.4]])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_AppendableArray(self):\n        storage = {}\n        a = AppendableArray(3, numpy.float64)\n        a.append(0.0)\n        a.append(1.1)\n        a.append(2.2)\n        a.append(3.3)\n        a.append(4.4)\n        a.append(5.5)\n        a.append(6.6)\n        a.append(7.7)\n        a.append(8.8)\n        a.append(9.9)\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_IndexedArray(self):\n        storage = {}\n        a = awkward.IndexedArray([2, 3, 6, 3, 2, 2, 7], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_SparseArray(self):\n        storage = {}\n        a = SparseArray(10, [1, 3, 5, 7, 9], [100, 101, 102, 103, 104])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_JaggedArray(self):\n        storage = {}\n        a = awkward.JaggedArray([2, 1], [5, 2], [1.1, 2.2, 3.3, 4.4, 5.5])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_JaggedArray_fromcounts(self):\n        storage = {}\n        a = awkward.JaggedArray.fromiter([[1.1, 2.2, 3.3], [], [4.4, 5.5]])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_MaskedArray(self):\n        storage = {}\n        a = MaskedArray([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True)\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_BitMaskedArray(self):\n        storage = {}\n        a = BitMaskedArray.fromboolmask([True, False, True, False, True, False, True, False, True, False], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], maskedwhen=True, lsborder=True)\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n        \n    def test_IndexedMaskedArray(self):\n        storage = {}\n        a = IndexedMaskedArray([-1, 0, -1, 1, -1, 2, -1, 4, -1, 3], [0.0, 1.1, 2.2, 3.3, 4.4])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_ObjectArray(self):\n        storage = {}\n        a = ObjectArray([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]], FloatPoint)\n        serialize(a, storage)\n        b = deserialize(storage, whitelist=""*"")\n        assert a.tolist() == b.tolist()\n\n        storage = {}\n        a = ObjectArray([[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]], FloatPoint)\n        serialize(a, storage)\n        b = deserialize(storage, whitelist=whitelist + [[""tests.test_persist"", ""FloatPoint""]])\n        assert a.tolist() == b.tolist()\n\n        a = ObjectArray(numpy.array([1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).view(""u1"").reshape(-1, 24), BytesPoint)\n        serialize(a, storage)\n        b = deserialize(storage, whitelist=""*"")\n        assert a.tolist() == b.tolist()\n        \n    def test_Table(self):\n        storage = {}\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], stuff=[5, 4, 3, 2, 1])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n        storage = {}\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], stuff=[5, 4, 3, 2, 1])[5:]\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n        storage = {}\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], stuff=[5, 4, 3, 2, 1])[[True, False, False, True, False]]\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_UnionArray(self):\n        storage = {}\n        a = UnionArray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n        storage = {}\n        a = UnionArray.fromtags([0, 1, 1, 0, 0], [[100, 200, 300], [1.1, 2.2]])\n        serialize(a, storage)\n        b = deserialize(storage)\n        assert a.tolist() == b.tolist()\n\n    def test_VirtualArray(self):\n        storage = {}\n        a = awkward.VirtualArray(makearray)\n        serialize(a, storage)\n        cache = {}\n        b = deserialize(storage, cache=cache, whitelist=""*"")\n        assert a.tolist() == b.tolist()\n        assert len(cache) == 1\n\n        cache = {}\n        b = deserialize(storage, cache=cache, whitelist=whitelist + [[""tests.test_persist"", ""makearray""]])\n        assert a.tolist() == b.tolist()\n        assert len(cache) == 1\n\n        storage = {}\n        a = awkward.VirtualArray(makearray, persistentkey=""find-me-again"")\n        serialize(a, storage)\n        cache = {}\n        b = deserialize(storage, cache=cache, whitelist=""*"")\n        assert a.persistentkey == b.persistentkey\n        assert a.tolist() == b.tolist()\n        assert list(cache.keys()) == [""find-me-again""]\n\n        storage = {}\n        a = awkward.VirtualArray(makearray, type=ArrayType(10, numpy.dtype(int)))\n        serialize(a, storage)\n        b = deserialize(storage, whitelist=""*"")\n        assert a.type == b.type\n\n        storage = {}\n        a = awkward.VirtualArray(makearray, persistvirtual=False)\n        serialize(a, storage)\n        b = deserialize(storage, whitelist=""*"")\n        assert isinstance(b, numpy.ndarray)\n        assert a.tolist() == b.tolist()\n'"
tests/test_physics.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport pytest\nimport numpy\n\nimport awkward\n\nuproot_methods = pytest.importorskip(""uproot_methods"")\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_physics_jetcleaning(self):\n        jet_m   = awkward.fromiter([[60.0, 70.0, 80.0],       [],     [90.0, 100.0]])\n\n        jet_pt  = awkward.fromiter([[10.0, 20.0, 30.0],       [],     [40.0, 50.0]])\n        e_pt    = awkward.fromiter([[20.2, 50.5],             [50.5], [50.5]])\n\n        jet_eta = awkward.fromiter([[-3.0, -2.0, 2.0],        [],     [-1.0, 1.0]])\n        e_eta   = awkward.fromiter([[-2.2, 0.0],              [0.0],  [1.1]])\n\n        jet_phi = awkward.fromiter([[-1.5,  0.0, 1.5],        [],     [0.78, -0.78]])\n        e_phi   = awkward.fromiter([[ 0.1, 0.78],             [0.78], [-0.77]])\n\n        jets      = uproot_methods.TLorentzVectorArray.from_ptetaphim(jet_pt, jet_eta, jet_phi, jet_m)\n        electrons = uproot_methods.TLorentzVectorArray.from_ptetaphim(e_pt, e_eta, e_phi, 0.000511)\n\n        combinations = jets.cross(electrons, nested=True)\n\n        def delta_r(one, two):\n            return one.delta_r(two)\n\n        assert (~(delta_r(combinations.i0, combinations.i1) < 0.5).any()).tolist() == [[True, False, True], [], [True, False]]\n\n        (jets[~(delta_r(combinations.i0, combinations.i1) < 0.5).any()])\n\n    def test_physics_matching(self):\n        gen_pt   = awkward.fromiter([[10.0, 20.0, 30.0],       [],     [40.0, 50.0]])\n        reco_pt  = awkward.fromiter([[20.2, 10.1, 30.3, 50.5], [50.5], [50.5]])\n\n        gen_eta  = awkward.fromiter([[-3.0, -2.0, 2.0],        [],     [-1.0, 1.0]])\n        reco_eta = awkward.fromiter([[-2.2, -3.3, 2.2, 0.0],   [0.0],  [1.1]])\n\n        gen_phi  = awkward.fromiter([[-1.5,  0.0, 1.5],        [],     [0.78, -0.78]])\n        reco_phi = awkward.fromiter([[ 0.1, -1.4, 1.4, 0.78],  [0.78], [-0.77]])\n\n        gen  = uproot_methods.TLorentzVectorArray.from_ptetaphim(gen_pt, gen_eta, gen_phi, 0.2)\n        reco = uproot_methods.TLorentzVectorArray.from_ptetaphim(reco_pt, reco_eta, reco_phi, 0.2)\n\n        (""gen"", gen)\n        (""reco"", reco)\n\n        (""gen.cross(reco)"", gen.cross(reco))\n\n        pairing = gen.cross(reco, nested=True)\n        (""pairing = gen.cross(reco, nested=True)"", gen.cross(reco, nested=True))\n\n        metric = pairing.i0.delta_r(pairing.i1)\n        (""metric = pairing.i0.delta_r(pairing.i1)"", metric)\n\n        index_of_minimized = metric.argmin()\n        (""index_of_minimized = metric.argmin()"", index_of_minimized)\n        assert index_of_minimized.tolist() == [[[1], [0], [2]], [], [[0], [0]]]\n\n        (""metric[index_of_minimized]"", metric[index_of_minimized])\n\n        passes_cut = (metric[index_of_minimized] < 0.5)\n        (""passes_cut = (metric[index_of_minimized] < 0.5)"", passes_cut)\n        assert passes_cut.tolist() == [[[True], [True], [True]], [], [[False], [True]]]\n\n        best_pairings_that_pass_cut = pairing[index_of_minimized][passes_cut]\n        (""best_pairings_that_pass_cut = pairing[index_of_minimized][passes_cut]"", best_pairings_that_pass_cut)\n\n        genrecos = best_pairings_that_pass_cut.flatten(axis=1)\n        (""genrecos = best_pairings_that_pass_cut.flatten(axis=1)"", genrecos)\n\n        (""genrecos.counts"", genrecos.counts)\n        (""gen.counts"", gen.counts)\n        assert genrecos.counts.tolist() == [3, 0, 1]\n        assert gen.counts.tolist() == [3, 0, 2]\n\n        (""genrecos.i0.pt"", genrecos.i0.pt)\n        (""genrecos.i1.pt"", genrecos.i1.pt)\n\n    def test_jagged_tlorentzvectorarray_concatenate(self):\n\n        def make_jets_and_electrons():\n            jet_m   = awkward.fromiter([[60.0, 70.0, 80.0],       [],     [90.0, 100.0]])\n\n            jet_pt  = awkward.fromiter([[10.0, 20.0, 30.0],       [],     [40.0, 50.0]])\n            e_pt    = awkward.fromiter([[20.2, 50.5],             [50.5], [50.5]])\n\n            jet_eta = awkward.fromiter([[-3.0, -2.0, 2.0],        [],     [-1.0, 1.0]])\n            e_eta   = awkward.fromiter([[-2.2, 0.0],              [0.0],  [1.1]])\n\n            jet_phi = awkward.fromiter([[-1.5,  0.0, 1.5],        [],     [0.78, -0.78]])\n            e_phi   = awkward.fromiter([[ 0.1, 0.78],             [0.78], [-0.77]])\n\n            jets      = uproot_methods.TLorentzVectorArray.from_ptetaphim(jet_pt, jet_eta, jet_phi, jet_m)\n            electrons = uproot_methods.TLorentzVectorArray.from_ptetaphim(e_pt, e_eta, e_phi, 0.000511)\n\n            return jets, electrons\n\n        jets0, electrons0 = make_jets_and_electrons()\n        jets1, electrons1 = make_jets_and_electrons()\n        jets2, electrons2 = make_jets_and_electrons()\n\n        def delta_r(one, two):\n            return one.delta_r(two)\n\n        jets01 = jets0.concatenate([jets1], axis=1)\n        electrons01 = electrons0.concatenate([electrons1], axis=1)\n\n        jets = jets01.concatenate([jets2], axis=0)\n        electrons = electrons01.concatenate([electrons2], axis=0)\n\n        combinations = jets.cross(electrons, nested=True)\n\n        reflist = [[True, False, True, True, False, True], [], [True, False, True, False],\n                   [True, False, True], [], [True, False]]\n        assert (~(delta_r(combinations.i0, combinations.i1) < 0.5).any()).tolist() == reflist\n\n\nif __name__ == ""__main__"":\n\n    unittest.main(verbosity=2)\n'"
tests/test_table.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_table_nbytes(self):\n        assert isinstance(Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]).nbytes, int)\n\n    def test_table_get(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n\n        assert a.tolist() == [{""0"": 0, ""1"": 0.0}, {""0"": 1, ""1"": 1.1}, {""0"": 2, ""1"": 2.2}, {""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}, {""0"": 5, ""1"": 5.5}, {""0"": 6, ""1"": 6.6}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}, {""0"": 9, ""1"": 9.9}]\n        assert a[""0""].tolist() == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        assert a[""1""].tolist() == [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n        assert a[[""0""]].tolist() == [{""0"": 0}, {""0"": 1}, {""0"": 2}, {""0"": 3}, {""0"": 4}, {""0"": 5}, {""0"": 6}, {""0"": 7}, {""0"": 8}, {""0"": 9}]\n\n        assert a[5][""0""] == 5\n        assert a[""0""][5] == 5\n\n        assert a[5][""1""] == 5.5\n        assert a[""1""][5] == 5.5\n\n        assert a[5:][""0""][0] == 5\n        assert a[""0""][5:][0] == 5\n        assert a[5:][0][""0""] == 5\n\n        assert a[::-2][""0""][-1] == 1\n        assert a[""0""][::-2][-1] == 1\n        assert a[::-2][-1][""0""] == 1\n\n        assert a[[5, 3, 7, 5]][""0""].tolist() == [5, 3, 7, 5]\n        assert a[""0""][[5, 3, 7, 5]].tolist() == [5, 3, 7, 5]\n\n        assert a[""0""][[True, False, True, False, True, False, True, False, True, False]].tolist() == [0, 2, 4, 6, 8]\n        assert a[[True, False, True, False, True, False, True, False, True, False]][""0""].tolist() == [0, 2, 4, 6, 8]\n\n    def test_table_set(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        a[""stuff""] = [5, 4, 3, 2, 1]\n        assert a.tolist() == [{""0"": 0, ""1"": 0.0, ""stuff"": 5}, {""0"": 1, ""1"": 1.1, ""stuff"": 4}, {""0"": 2, ""1"": 2.2, ""stuff"": 3}, {""0"": 3, ""1"": 3.3, ""stuff"": 2}, {""0"": 4, ""1"": 4.4, ""stuff"": 1}]\n        a[[""x"", ""y""]] = Table(range(3), range(100))\n        assert a.tolist() == [{""0"": 0, ""1"": 0.0, ""stuff"": 5, ""x"": 0, ""y"": 0}, {""0"": 1, ""1"": 1.1, ""stuff"": 4, ""x"": 1, ""y"": 1}, {""0"": 2, ""1"": 2.2, ""stuff"": 3, ""x"": 2, ""y"": 2}]\n\n    def test_table_ufunc(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        b = a + 100\n        assert b.tolist() == [{""0"": 100, ""1"": 100.0}, {""0"": 101, ""1"": 101.1}, {""0"": 102, ""1"": 102.2}, {""0"": 103, ""1"": 103.3}, {""0"": 104, ""1"": 104.4}, {""0"": 105, ""1"": 105.5}, {""0"": 106, ""1"": 106.6}, {""0"": 107, ""1"": 107.7}, {""0"": 108, ""1"": 108.8}, {""0"": 109, ""1"": 109.9}]\n        c = a + b\n        assert c.tolist() == [{""0"": 100, ""1"": 100.0}, {""0"": 102, ""1"": 102.19999999999999}, {""0"": 104, ""1"": 104.4}, {""0"": 106, ""1"": 106.6}, {""0"": 108, ""1"": 108.80000000000001}, {""0"": 110, ""1"": 111.0}, {""0"": 112, ""1"": 113.19999999999999}, {""0"": 114, ""1"": 115.4}, {""0"": 116, ""1"": 117.6}, {""0"": 118, ""1"": 119.80000000000001}]\n\n    def test_table_slice_slice(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[::2][2:4].tolist() == [{""0"": 4, ""1"": 4.4}, {""0"": 6, ""1"": 6.6}]\n        assert a[::2][2:4][1].tolist() == {""0"": 6, ""1"": 6.6}\n        assert a[1::2][2:100].tolist() == [{""0"": 5, ""1"": 5.5}, {""0"": 7, ""1"": 7.7}, {""0"": 9, ""1"": 9.9}]\n        assert a[1::2][2:100][1].tolist() == {""0"": 7, ""1"": 7.7}\n        assert a[5:][2:4].tolist() == [{""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}]\n        assert a[5:][2:4][1].tolist() == {""0"": 8, ""1"": 8.8}\n        assert a[-5:][2:4].tolist() == [{""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}]\n        assert a[-5:][2:4][1].tolist() == {""0"": 8, ""1"": 8.8}\n        assert a[::2][-4:-2].tolist() == [{""0"": 2, ""1"": 2.2}, {""0"": 4, ""1"": 4.4}]\n        assert a[::2][-4:-2][1].tolist() == {""0"": 4, ""1"": 4.4}\n        assert a[::-2][2:4].tolist() == [{""0"": 5, ""1"": 5.5}, {""0"": 3, ""1"": 3.3}]\n        assert a[::-2][2:4][1].tolist() == {""0"": 3, ""1"": 3.3}\n        assert a[::-2][2:100].tolist() == [{""0"": 5, ""1"": 5.5}, {""0"": 3, ""1"": 3.3}, {""0"": 1, ""1"": 1.1}]\n        assert a[::-2][2:100][1].tolist() == {""0"": 3, ""1"": 3.3}\n        assert a[::-2][3::-1].tolist() == [{""0"": 3, ""1"": 3.3}, {""0"": 5, ""1"": 5.5}, {""0"": 7, ""1"": 7.7}, {""0"": 9, ""1"": 9.9}]\n        assert a[::-2][3::-1][-1].tolist() == {""0"": 9, ""1"": 9.9}\n\n    def test_table_slice_fancy(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[::2][[4, 3, 1, 1]].tolist() == [{""0"": 8, ""1"": 8.8}, {""0"": 6, ""1"": 6.6}, {""0"": 2, ""1"": 2.2}, {""0"": 2, ""1"": 2.2}]\n        assert a[::2][[4, 3, 1, 1]][1].tolist() == {""0"": 6, ""1"": 6.6}\n        assert a[-5::-1][[0, 1, 5]].tolist() == [{""0"": 5, ""1"": 5.5}, {""0"": 4, ""1"": 4.4}, {""0"": 0, ""1"": 0.0}]\n        assert a[-5::-1][[0, 1, 5]][1].tolist() == {""0"": 4, ""1"": 4.4}\n\n    def test_table_slice_mask(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[::2][[True, False, False, True, True]].tolist() == [{""0"": 0, ""1"": 0.0}, {""0"": 6, ""1"": 6.6}, {""0"": 8, ""1"": 8.8}]\n        assert a[::2][[True, False, False, True, True]][1].tolist() == {""0"": 6, ""1"": 6.6}\n        assert a[-5::-1][[True, True, False, False, False, True]].tolist() == [{""0"": 5, ""1"": 5.5}, {""0"": 4, ""1"": 4.4}, {""0"": 0, ""1"": 0.0}]\n        assert a[-5::-1][[True, True, False, False, False, True]][1].tolist() == {""0"": 4, ""1"": 4.4}\n\n    def test_table_fancy_slice(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[7, 3, 3, 4, 4][2:]].tolist() == [{""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}, {""0"": 4, ""1"": 4.4}]\n        assert a[[7, 3, 3, 4, 4][2:]][1].tolist() == {""0"": 4, ""1"": 4.4}\n\n    def test_table_fancy_fancy(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[7, 3, 3, 4, 4]][[-2, 2, 0]].tolist() == [{""0"": 4, ""1"": 4.4}, {""0"": 3, ""1"": 3.3}, {""0"": 7, ""1"": 7.7}]\n        assert a[[7, 3, 3, 4, 4]][[-2, 2, 0]][1].tolist() == {""0"": 3, ""1"": 3.3}\n\n    def test_table_fancy_mask(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[7, 3, 3, 4, 4]][[True, False, True, False, True]].tolist() == [{""0"": 7, ""1"": 7.7}, {""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}]\n        assert a[[7, 3, 3, 4, 4]][[True, False, True, False, True]][1].tolist() == {""0"": 3, ""1"": 3.3}\n\n    def test_table_mask_slice(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[True, True, False, False, False, False, False, True, True, True]][1:4].tolist() == [{""0"": 1, ""1"": 1.1}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}]\n        assert a[[True, True, False, False, False, False, False, True, True, True]][1:4][1].tolist() == {""0"": 7, ""1"": 7.7}\n\n    def test_table_mask_fancy(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[True, True, False, False, False, False, False, True, True, True]][[1, 2, 3]].tolist() == [{""0"": 1, ""1"": 1.1}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}]\n        assert a[[True, True, False, False, False, False, False, True, True, True]][[1, 2, 3]][1].tolist() == {""0"": 7, ""1"": 7.7}\n\n    def test_table_mask_mask(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert a[[True, True, False, False, False, False, False, True, True, True]][[False, True, True, True, False]].tolist() == [{""0"": 1, ""1"": 1.1}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}]\n        assert a[[True, True, False, False, False, False, False, True, True, True]][[False, True, True, True, False]][1].tolist() == {""0"": 7, ""1"": 7.7}\n\n    def test_indexed_table(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert IndexedArray([5, 3, 7, 5], a)[""1""].tolist() == [5.5, 3.3, 7.7, 5.5]\n\n    def test_masked_table(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert MaskedArray([False, True, True, True, True, False, False, False, False, True], a, maskedwhen=False)[""1""].tolist() == [None, 1.1, 2.2, 3.3, 4.4, None, None, None, None, 9.9]\n\n    def test_jagged_table(self):\n        a = Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        a.rowname = ""Row""\n        assert JaggedArray.fromoffsets([0, 3, 5, 5, 10], a).tolist() == [[{""0"": 0, ""1"": 0.0}, {""0"": 1, ""1"": 1.1}, {""0"": 2, ""1"": 2.2}], [{""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}], [], [{""0"": 5, ""1"": 5.5}, {""0"": 6, ""1"": 6.6}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}, {""0"": 9, ""1"": 9.9}]]\n        assert JaggedArray.fromoffsets([0, 3, 5, 5, 10], a)[""1""].tolist() == [[0.0, 1.1, 2.2], [3.3, 4.4], [], [5.5, 6.6, 7.7, 8.8, 9.9]]\n\n    def test_chunked_table(self):\n        a = Table([0, 1, 2, 3], [0.0, 1.1, 2.2, 3.3])\n        a.rowname = ""Row""\n        b = Table([4, 5, 6, 7, 8, 9], [4.4, 5.5, 6.6, 7.7, 8.8, 9.9])\n        b.rowname = ""Row""\n        c = ChunkedArray([a, b])\n        assert c[""1""][6] == 6.6\n\n    def test_virtual_table(self):\n        a = VirtualArray(lambda: Table([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]))\n        a.array.rowname = ""Row""\n        assert a.tolist() == [{""0"": 0, ""1"": 0.0}, {""0"": 1, ""1"": 1.1}, {""0"": 2, ""1"": 2.2}, {""0"": 3, ""1"": 3.3}, {""0"": 4, ""1"": 4.4}, {""0"": 5, ""1"": 5.5}, {""0"": 6, ""1"": 6.6}, {""0"": 7, ""1"": 7.7}, {""0"": 8, ""1"": 8.8}, {""0"": 9, ""1"": 9.9}]\n\n    def test_table_concatenate(self):\n        a = Table([0, 1, 2], [0.0, 1.1, 2.2])\n        b = Table([4, 5], [4.4, 5.5])\n        a.rowname = ""Row""\n        b.rowname = ""Row""\n\n        c = a.concatenate([b])\n\n        assert c.tolist() == [{""0"": 0, ""1"": 0.0}, {""0"": 1, ""1"": 1.1}, {""0"": 2, ""1"": 2.2},\n                              {""0"": 4, ""1"": 4.4}, {""0"": 5, ""1"": 5.5}, ]\n\n    def test_table_unzip(self):\n        left = [1, 2, 3, 4, 5]\n        right = [6, 7, 8, 9, 10]\n        table = Table.named(""tuple"", left, right)\n        unzip = table.unzip()\n        assert type(unzip) is tuple\n        assert len(unzip) == 2\n        assert all(unzip[0] == left)\n        assert all(unzip[1] == right)\n\n    def test_table_row_tuple_len(self):\n        a = Table([1], [2])\n        assert len(a[0]) == 2\n\n    def test_table_row_tuple_iteration(self):\n        rows = [[1, 2], [3, 4]]\n        columns = zip(*rows)\n        a = Table(*columns)\n        b = [[element for element in row] for row in a]\n        for row in b:\n            for element in row:\n                with self.assertRaises(TypeError, msg=\'Scalar row element should not have a length\'):\n                    len(element)\n                with self.assertRaises(TypeError, msg=\'Scalar row element should not be iterable\'):\n                    iter(element)\n        assert b == rows\n\n    def test_table_row_dict_len(self):\n        column_dict = {\'a\': [1], \'b\': [2]}\n        a = Table(column_dict)\n        assert len(a[0]) == 2\n\n    def test_table_row_dict_iteration(self):\n        column_dict = {\'a\': [1, 3], \'b\': [2, 4]}\n        a = Table(column_dict)\n        b = [{key: row[key] for key in row} for row in a]\n        assert b == [{\'a\': 1, \'b\': 2}, {\'a\': 3, \'b\': 4}]\n'"
tests/test_union.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport unittest\n\nimport numpy\n\nfrom awkward import *\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_union_nbytes(self):\n        assert isinstance(UnionArray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]]).nbytes, int)\n\n    def test_union_get(self):\n        a = UnionArray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [[0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9], [0, 100, 200, 300, 400, 500, 600, 700, 800, 900]])\n        assert a.tolist() == [0.0, 100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert [a[i] for i in range(len(a))] == [0.0, 100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert a[:].tolist() == [0.0, 100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert a[1:].tolist() == [100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert a[2:].tolist() == [2.2, 300, 4.4, 500, 6.6, 700, 8.8, 900]\n        assert a[:-1].tolist() == [0.0, 100, 2.2, 300, 4.4, 500, 6.6, 700, 8.8]\n        assert a[1:-2].tolist() == [100, 2.2, 300, 4.4, 500, 6.6, 700]\n        assert a[2:-2].tolist() == [2.2, 300, 4.4, 500, 6.6, 700]\n        assert [a[2:-2][i] for i in range(6)] == [2.2, 300, 4.4, 500, 6.6, 700]\n\n        assert a[[1, 2, 3, 8, 8, 1]].tolist() == [100, 2.2, 300, 8.8, 8.8, 100]\n        assert [a[[1, 2, 3, 8, 8, 1]][i] for i in range(6)] == [100, 2.2, 300, 8.8, 8.8, 100]\n\n        assert a[[False, True, True, True, False, True, False, False, False, False]].tolist() == [100, 2.2, 300, 500]\n        assert [a[[False, True, True, True, False, True, False, False, False, False]][i] for i in range(4)] == [100, 2.2, 300, 500]\n\n    def test_union_ufunc(self):\n        a = UnionArray.fromtags([0, 1, 1, 0, 0], [[100, 200, 300], [1.1, 2.2]])\n        b = UnionArray.fromtags([1, 1, 0, 1, 0], [[10.1, 20.2], [123, 456, 789]])\n        assert (a + a).tolist() == [200, 2.2, 4.4, 400, 600]\n        assert (a + b).tolist() == [223, 457.1, 12.3, 989, 320.2]\n'"
tests/test_virtual.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport struct\nimport unittest\n\nimport numpy\n\nfrom awkward import *\nimport awkward.type\n\nclass Test(unittest.TestCase):\n    def runTest(self):\n        pass\n\n    def test_virtual_nbytes(self):\n        assert isinstance(VirtualArray(lambda: [1, 2, 3]).nbytes, int)\n        assert VirtualArray(lambda: [1, 2, 3], nbytes=12345).nbytes == 12345\n\n    def test_virtual_nocache(self):\n        a = VirtualArray(lambda: [1, 2, 3])\n        assert not a.ismaterialized\n        assert numpy.array_equal(a[:], numpy.array([1, 2, 3]))\n        assert a.ismaterialized\n\n        a = VirtualArray(lambda: range(10))\n        assert not a.ismaterialized\n        assert numpy.array_equal(a[::2], numpy.array([0, 2, 4, 6, 8]))\n        assert a.ismaterialized\n\n        a = VirtualArray(lambda: range(10))\n        assert not a.ismaterialized\n        assert numpy.array_equal(a[[5, 3, 6, 0, 6]], numpy.array([5, 3, 6, 0, 6]))\n        assert a.ismaterialized\n\n        a = VirtualArray(lambda: range(10))\n        assert not a.ismaterialized\n        assert numpy.array_equal(a[[True, False, True, False, True, False, True, False, True, False]], numpy.array([0, 2, 4, 6, 8]))\n        assert a.ismaterialized\n\n    def test_virtual_transientcache(self):\n        cache = {}\n        a = VirtualArray(lambda: [1, 2, 3], cache=cache)\n        assert not a.ismaterialized\n        a[:]\n        assert a.ismaterialized\n        assert list(cache) == [a.TransientKey(id(a))]\n        assert list(cache) == [a.key]\n        assert numpy.array_equal(cache[a.key], numpy.array([1, 2, 3]))\n        del a\n\n    def test_virtual_persistentcache(self):\n        cache = {}\n        a = VirtualArray(lambda: [1, 2, 3], cache=cache, persistentkey=""find-me-again"")\n        assert not a.ismaterialized\n        a[:]\n        assert a.ismaterialized\n        assert list(cache) == [""find-me-again""]\n        assert list(cache) == [a.key]\n        assert numpy.array_equal(cache[a.key], numpy.array([1, 2, 3]))\n        del a\n\n    def test_virtual_dontmaterialize(self):\n        a = VirtualArray(lambda: [1, 2, 3], type=awkward.type.fromnumpy(3, int))\n        assert not a.ismaterialized\n        assert a.dtype == numpy.dtype(int)\n        assert a.shape == (3,)\n        assert len(a) == 3\n        assert a._array == None\n        assert not a.ismaterialized\n        assert numpy.array_equal(a[:], numpy.array([1, 2, 3]))\n        assert a.ismaterialized\n'"
awkward-cpp/awkward/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport distutils.version\n\nimport numpy\nif distutils.version.LooseVersion(numpy.__version__) < distutils.version.LooseVersion(""1.13.1""):\n    raise ImportError(""Numpy 1.13.1 or later required"")\n\nfrom awkward.array.base import AwkwardArray\nfrom awkward.array.chunked import ChunkedArray, AppendableArray\nfrom awkward.array.indexed import IndexedArray, SparseArray\nfrom awkward.array.jagged import JaggedArray\nfrom awkward.array.masked import MaskedArray, BitMaskedArray, IndexedMaskedArray\nfrom awkward.array.objects import Methods, ObjectArray, StringArray\nfrom awkward.array.table import Table\nfrom awkward.array.union import UnionArray\nfrom awkward.array.virtual import VirtualArray\n\ndef concatenate(arrays, axis=0):\n    return AwkwardArray.concatenate(arrays, axis=axis)\n\nfrom awkward.generate import fromiter\n\nfrom awkward.persist import serialize, deserialize, save, load, hdf5\n\nfrom awkward.arrow import toarrow, fromarrow, toparquet, fromparquet\nfrom awkward.util import topandas\n\n# convenient access to the version number\nfrom awkward.version import __version__\n\n__all__ = [""numpy"", ""AwkwardArray"", ""ChunkedArray"", ""AppendableArray"", ""IndexedArray"", ""SparseArray"", ""JaggedArray"", ""MaskedArray"", ""BitMaskedArray"", ""IndexedMaskedArray"", ""Methods"", ""ObjectArray"", ""Table"", ""UnionArray"", ""VirtualArray"", ""StringArray"", ""fromiter"", ""serialize"", ""deserialize"", ""save"", ""load"", ""hdf5"", ""toarrow"", ""fromarrow"", ""toparquet"", ""fromparquet"", ""topandas"", ""__version__""]\n\n__path__ = __import__(""pkgutil"").extend_path(__path__, __name__)\n'"
awkward-numba/awkward/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport distutils.version\n\nimport numpy\nif distutils.version.LooseVersion(numpy.__version__) < distutils.version.LooseVersion(""1.13.1""):\n    raise ImportError(""Numpy 1.13.1 or later required"")\n\nfrom awkward.array.base import AwkwardArray\nfrom awkward.array.chunked import ChunkedArray, AppendableArray\nfrom awkward.array.indexed import IndexedArray, SparseArray\nfrom awkward.array.jagged import JaggedArray\nfrom awkward.array.masked import MaskedArray, BitMaskedArray, IndexedMaskedArray\nfrom awkward.array.objects import Methods, ObjectArray, StringArray\nfrom awkward.array.table import Table\nfrom awkward.array.union import UnionArray\nfrom awkward.array.virtual import VirtualArray\n\ndef concatenate(arrays, axis=0):\n    return AwkwardArray.concatenate(arrays, axis=axis)\n\nfrom awkward.generate import fromiter\n\nfrom awkward.persist import serialize, deserialize, save, load, hdf5\n\nfrom awkward.arrow import toarrow, fromarrow, toparquet, fromparquet\nfrom awkward.util import topandas\n\n# convenient access to the version number\nfrom awkward.version import __version__\n\n__all__ = [""numpy"", ""AwkwardArray"", ""ChunkedArray"", ""AppendableArray"", ""IndexedArray"", ""SparseArray"", ""JaggedArray"", ""MaskedArray"", ""BitMaskedArray"", ""IndexedMaskedArray"", ""Methods"", ""ObjectArray"", ""Table"", ""UnionArray"", ""VirtualArray"", ""StringArray"", ""fromiter"", ""serialize"", ""deserialize"", ""save"", ""load"", ""hdf5"", ""toarrow"", ""fromarrow"", ""toparquet"", ""fromparquet"", ""topandas"", ""__version__""]\n\n__path__ = __import__(""pkgutil"").extend_path(__path__, __name__)\n'"
awkward/array/__init__.py,0,b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n'
awkward/array/base.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport types\nimport numbers\nimport re\nimport keyword\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nfrom awkward.util import bothmethod\n\nclass AwkwardArray(awkward.util.NDArrayOperatorsMixin):\n    """"""\n    AwkwardArray: abstract base class\n    """"""\n\n    allow_tonumpy = True\n    allow_iter = True\n    check_prop_valid = True\n    check_whole_valid = True\n\n    @property\n    def awkward(self):\n        return awkward\n\n    numpy = numpy\n    DEFAULTTYPE = numpy.dtype(numpy.float64)\n    CHARTYPE    = numpy.dtype(numpy.uint8)\n    INDEXTYPE   = numpy.dtype(numpy.int64)\n    TAGTYPE     = numpy.dtype(numpy.uint8)\n    MASKTYPE    = numpy.dtype(numpy.bool_)\n    BITMASKTYPE = numpy.dtype(numpy.uint8)\n    BOOLTYPE    = numpy.dtype(numpy.bool_)\n\n    def __init__(self, *args, **kwds):\n        raise TypeError(""{0} is an abstract base class; do not instantiate"".format(type(self)))\n\n    def __round__(self, n=0):\n        if n == 0:\n            return self.numpy.rint(self)\n        else:\n            factor = 10**n\n            return self.numpy.rint(self * factor) / factor\n\n    def _checktonumpy(self):\n        if not self.allow_tonumpy:\n            raise RuntimeError(""awkward.array.base.AwkwardArray.allow_tonumpy is False; refusing to convert to Numpy"")\n\n    def __array__(self, dtype=None):\n        self._checktonumpy()\n\n        if dtype is None:\n            dtype = self.dtype\n\n        out = self.numpy.empty(len(self), dtype=dtype)\n        for i, x in enumerate(self):\n            out[i] = x\n        return out\n\n    def __getstate__(self):\n        state = {}\n        awkward.persist.serialize(self, state)\n        return state\n\n    def __setstate__(self, state):\n        out = awkward.persist.deserialize(state)\n        self.__dict__.update(out.__dict__)\n        self.__class__ = out.__class__\n\n    def __reduce__(self):\n        state = {}\n        awkward.persist.serialize(self, state)\n        return (awkward.persist.deserialize, (state,))\n\n    def _checkiter(self):\n        if not self.allow_iter:\n            raise RuntimeError(""awkward.array.base.AwkwardArray.allow_iter is False; refusing to iterate"")\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        for i in range(len(self)):\n            yield self[i]\n\n    def __str__(self):\n        if len(self) <= 6:\n            return ""[{0}]"".format("" "".join(self._util_arraystr(x) for x in self.__iter__(checkiter=False)))\n\n        else:\n            first = self[:3]\n            if isinstance(first, AwkwardArray):\n                first = first.__iter__(checkiter=False)\n            last = self[-3:]\n            if isinstance(first, AwkwardArray):\n                last = last.__iter__(checkiter=False)\n\n            return ""[{0} ... {1}]"".format("" "".join(self._util_arraystr(x) for x in first), "" "".join(self._util_arraystr(x) for x in last))\n\n    def __repr__(self):\n        return ""<{0} {1} at 0x{2:012x}>"".format(self.__class__.__name__, str(self), id(self))\n\n    @property\n    def type(self):\n        return awkward.type.ArrayType(len(self), awkward.type._resolve(self._gettype({}), {}))\n\n    @property\n    def layout(self):\n        return awkward.type.Layout(self)\n\n    @property\n    def dtype(self):\n        return self.type.dtype\n\n    @property\n    def shape(self):\n        return self.type.shape\n\n    @property\n    def ndim(self):\n        return len(self.shape)\n\n    def _try_tolist(self, x):\n        try:\n            return x.tolist()\n        except AttributeError:\n            return x\n\n    def __bool__(self):\n        raise ValueError(""The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()"")\n\n    __nonzero__ = __bool__\n\n    @property\n    def size(self):\n        out = 1\n        for x in self.shape:\n            out *= x\n        return out\n\n    @property\n    def nbytes(self):\n        return self._getnbytes(set())\n\n    def tolist(self):\n        import awkward.array.table\n        out = []\n        for x in self:\n            if isinstance(x, awkward.array.table.Table.Row):\n                if x._table.istuple:\n                    out.append(tuple(self._try_tolist(x[n]) for n in x._table._contents))\n                else:\n                    out.append(dict((n, self._try_tolist(x[n])) for n in x._table._contents))\n            elif isinstance(x, self.numpy.ma.core.MaskedConstant):\n                out.append(None)\n            else:\n                out.append(self._try_tolist(x))\n        return out\n\n    def valid(self, exception=False, message=False):\n        try:\n            self._valid()\n        except Exception as err:\n            if exception:\n                raise err\n            elif message:\n                return ""{0}: {1}"".format(type(err), str(err))\n            else:\n                return False\n        else:\n            if message:\n                return None\n            else:\n                return True\n\n    def reduce(self, ufunc, identity):\n        return self._reduce(ufunc, identity, None)\n\n    def any(self):\n        return self._reduce(self.numpy.bitwise_or, False, self.BOOLTYPE)\n\n    def all(self):\n        return self._reduce(self.numpy.bitwise_and, True, self.BOOLTYPE)\n\n    def count(self):\n        return self._reduce(None, 0, None)\n\n    def count_nonzero(self):\n        return self._reduce(self.numpy.count_nonzero, 0, None)\n\n    def sum(self):\n        return self._reduce(self.numpy.add, 0, None)\n\n    def prod(self):\n        return self._reduce(self.numpy.multiply, 1, None)\n\n    def min(self):\n        return self._reduce(self.numpy.minimum, self.numpy.inf, None)\n\n    def max(self):\n        return self._reduce(self.numpy.maximum, -self.numpy.inf, None)\n\n    def moment(self, n, weight=None):\n        with self.numpy.errstate(invalid=""ignore""):\n            if weight is None:\n                return self.numpy.true_divide((self**n).sum(), self.count())\n            else:\n                return self.numpy.true_divide(((self * weight)**n).sum(), (self * 0 + weight).sum())\n\n    def mean(self, weight=None):\n        with self.numpy.errstate(invalid=""ignore""):\n            if weight is None:\n                return self.numpy.true_divide(self.sum(), self.count())\n            else:\n                return self.numpy.true_divide((self * weight).sum(), (self * 0 + weight).sum())\n\n    def var(self, weight=None, ddof=0):\n        with self.numpy.errstate(invalid=""ignore""):\n            if weight is None:\n                denom = self.count()\n                one = self.numpy.true_divide(self.sum(), denom)\n                two = self.numpy.true_divide((self**2).sum(), denom)\n            else:\n                denom (self * 0 + weight).sum()\n                one = self.numpy.true_divide((self * weight).sum(), denom)\n                two = self.numpy.true_divide(((self * weight)**2).sum(), denom)\n            if ddof != 0:\n                return (two - one**2) * denom / (denom - ddof)\n            else:\n                return two - one**2\n\n    def std(self, weight=None, ddof=0):\n        with self.numpy.errstate(invalid=""ignore""):\n            return self.numpy.sqrt(self.var(weight=weight, ddof=ddof))\n\n    def __getattr__(self, where):\n        if where in dir(super(AwkwardArray, self)):\n            return super(AwkwardArray, self).__getattribute__(where)\n        else:\n            if where in self.columns:\n                try:\n                    return self[where]\n                except Exception as err:\n                    raise AttributeError(""while trying to get column {0}, an exception occurred:\\n{1}: {2}"".format(repr(where), type(err), str(err)))\n            else:\n                raise AttributeError(""no column named {0}"".format(repr(where)))\n\n    def __dir__(self):\n        return sorted(set(dir(super(AwkwardArray, self)) + [x for x in self.columns if self._dir_pattern.match(x) and not keyword.iskeyword(x)]))\n    _dir_pattern = re.compile(r""^[a-zA-Z_]\\w*$"")\n\n    @property\n    def i0(self):\n        return self[""0""]\n\n    @property\n    def i1(self):\n        return self[""1""]\n\n    @property\n    def i2(self):\n        return self[""2""]\n\n    @property\n    def i3(self):\n        return self[""3""]\n\n    @property\n    def i4(self):\n        return self[""4""]\n\n    @property\n    def i5(self):\n        return self[""5""]\n\n    @property\n    def i6(self):\n        return self[""6""]\n\n    @property\n    def i7(self):\n        return self[""7""]\n\n    @property\n    def i8(self):\n        return self[""8""]\n\n    @property\n    def i9(self):\n        return self[""9""]\n\n    @property\n    def ChunkedArray(self):\n        import awkward.array.chunked\n        return awkward.array.chunked.ChunkedArray\n\n    @property\n    def AppendableArray(self):\n        import awkward.array.chunked\n        return awkward.array.chunked.AppendableArray\n\n    @property\n    def IndexedArray(self):\n        import awkward.array.indexed\n        return awkward.array.indexed.IndexedArray\n\n    @property\n    def SparseArray(self):\n        import awkward.array.indexed\n        return awkward.array.indexed.SparseArray\n\n    @property\n    def JaggedArray(self):\n        import awkward.array.jagged\n        return awkward.array.jagged.JaggedArray\n\n    @property\n    def MaskedArray(self):\n        import awkward.array.masked\n        return awkward.array.masked.MaskedArray\n\n    @property\n    def BitMaskedArray(self):\n        import awkward.array.masked\n        return awkward.array.masked.BitMaskedArray\n\n    @property\n    def IndexedMaskedArray(self):\n        import awkward.array.masked\n        return awkward.array.masked.IndexedMaskedArray\n\n    @property\n    def Methods(self):\n        import awkward.array.objects\n        return awkward.array.objects.Methods\n\n    @property\n    def ObjectArray(self):\n        import awkward.array.objects\n        return awkward.array.objects.ObjectArray\n\n    @property\n    def StringArray(self):\n        import awkward.array.objects\n        return awkward.array.objects.StringArray\n\n    @property\n    def Table(self):\n        import awkward.array.table\n        return awkward.array.table.Table\n\n    @property\n    def UnionArray(self):\n        import awkward.array.union\n        return awkward.array.union.UnionArray\n\n    @property\n    def VirtualArray(self):\n        import awkward.array.virtual\n        return awkward.array.virtual.VirtualArray\n\n    @classmethod\n    def _util_isinteger(cls, x):\n        return isinstance(x, (numbers.Integral, cls.numpy.integer)) and not isinstance(x, (bool, cls.numpy.bool_, cls.numpy.bool))\n\n    @classmethod\n    def _util_isintegertype(cls, x):\n        return issubclass(x, cls.numpy.integer) and not issubclass(x, (cls.numpy.bool_, cls.numpy.bool))\n\n    @classmethod\n    def _util_toarray(cls, value, defaultdtype, passthrough=None):\n        import awkward.array.base\n        if passthrough is None:\n            passthrough = (cls.numpy.ndarray, AwkwardArray)\n        if isinstance(value, passthrough):\n            return value\n        else:\n            try:\n                return cls.numpy.frombuffer(value, dtype=getattr(value, ""dtype"", defaultdtype)).reshape(getattr(value, ""shape"", -1))\n            except (AttributeError, TypeError):\n                if len(value) == 0:\n                    return cls.numpy.array(value, dtype=defaultdtype, copy=False)\n                else:\n                    return cls.numpy.array(value, copy=False)\n\n    @classmethod\n    def _util_arraystr_draw(cls, x):\n        if isinstance(x, tuple):\n            return ""("" + "", "".join(cls._util_arraystr_draw(y) for y in x) + "")""\n        elif isinstance(x, Iterable):\n            if len(x) > 6:\n                return ""["" + "" "".join(cls._util_arraystr_draw(y) for y in x[:3]) + "" ... "" + "" "".join(cls._util_arraystr_draw(y) for y in x[-3:]) + ""]""\n            else:\n                return ""["" + "" "".join(cls._util_arraystr_draw(y) for y in x) + ""]""\n        else:\n            return repr(x)\n\n    @classmethod\n    def _util_arraystr(cls, array):\n        if isinstance(array, cls.numpy.ndarray):\n            return cls._util_arraystr_draw(array)\n        elif isinstance(array, AwkwardArray):\n            return str(array).replace(""\\n"", """")\n        else:\n            return repr(array)\n\n    @classmethod\n    def _util_isnumpy(cls, dtype):\n        if isinstance(dtype, cls.numpy.dtype):\n            return True\n        else:\n            return dtype.isnumpy\n\n    @classmethod\n    def _util_deepcopy(cls, array):\n        if array is None:\n            return None\n        elif isinstance(array, cls.numpy.ndarray):\n            return array.copy()\n        else:\n            return array.deepcopy()\n\n    @classmethod\n    def _util_hasjagged(cls, array):\n        return isinstance(array, AwkwardArray) and array._hasjagged()\n\n    @classmethod\n    def _util_counts(cls, array):\n        if isinstance(array, AwkwardArray):\n            return array.counts\n        elif len(array.shape) == 1:\n            return cls.numpy.full(array.shape[0], -1, dtype=cls.INDEXTYPE)\n        else:\n            return cls.numpy.full(array.shape[0], array.shape[1], dtype=cls.INDEXTYPE)\n\n    @classmethod\n    def _util_boolmask(cls, array, maskedwhen):\n        if isinstance(array, AwkwardArray):\n            return array.boolmask(maskedwhen=maskedwhen)\n        elif isinstance(array, cls.numpy.ma.MaskedArray) and array.mask is not False:\n            if maskedwhen:\n                return array.mask\n            else:\n                return ~array.mask\n        else:\n            if maskedwhen:\n                return cls.numpy.zeros(len(array), dtype=cls.MASKTYPE)\n            else:\n                return cls.numpy.ones(len(array), dtype=cls.MASKTYPE)\n\n    @property\n    def ismasked(self):\n        return self.boolmask(maskedwhen=True)\n\n    @property\n    def isunmasked(self):\n        return self.boolmask(maskedwhen=False)\n\n    @classmethod\n    def _util_flattentuple(cls, array):\n        if isinstance(array, AwkwardArray):\n            return array.flattentuple()\n        else:\n            return array\n\n    @classmethod\n    def _util_flatten(cls, array, axis):\n        if isinstance(array, AwkwardArray):\n            return array.flatten(axis=axis)\n        else:\n            axis = min(axis, len(array.shape) - 1)\n            return array.reshape(array.shape[:axis] + (-1,) + array.shape[axis + 2:])\n\n    @classmethod\n    def _util_pad(cls, array, length, maskedwhen, clip, axis):\n        if isinstance(array, AwkwardArray):\n            return array.pad(length, maskedwhen=maskedwhen, clip=clip, axis=axis)\n\n        elif len(array.shape) == 1:\n            raise ValueError(""pad cannot be applied to scalars"")\n\n        elif length == 0 and clip:\n            if isinstance(maskedwhen, cls.numpy.ma.core.MaskedConstant):\n                return cls.JaggedArray.fget(None).fromoffsets([0], cls.numpy.ma.array([]))\n            else:\n                return cls.JaggedArray.fget(None).fromoffsets([0], cls.MaskedArray.fget(None)([], []))\n\n        elif array.shape[1] > length and clip:\n            offsets = cls.numpy.arange(0, length*(len(array) + 1), length, dtype=cls.INDEXTYPE)\n            content = array[(slice(None), slice(length)) + array.shape[2:]]\n            if isinstance(maskedwhen, cls.numpy.ma.core.MaskedConstant):\n                return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.numpy.ma.array(content.reshape((-1,) + array.shape[2:])))\n            else:\n                return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.MaskedArray.fget(None).fromcontent(content.reshape((-1,) + array.shape[2:]), maskedwhen=maskedwhen))\n\n        elif array.shape[1] >= length:\n            offsets = cls.numpy.arange(0, array.shape[1]*(len(array) + 1), array.shape[1], dtype=cls.INDEXTYPE)\n            if isinstance(maskedwhen, cls.numpy.ma.core.MaskedConstant):\n                return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.numpy.ma.array(array.reshape((-1,) + array.shape[2:])))\n            else:\n                return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.MaskedArray.fget(None).fromcontent(array.reshape((-1,) + array.shape[2:]), maskedwhen=maskedwhen))\n\n        else:\n            offsets = cls.numpy.arange(0, length*(len(array) + 1), length, dtype=cls.INDEXTYPE)\n            content = cls.numpy.empty(array.shape[:1] + (length,) + array.shape[2:], dtype=array.dtype)\n            content[:, :array.shape[1]] = array\n            if isinstance(maskedwhen, cls.numpy.ma.core.MaskedConstant):\n                mask = cls.numpy.ones(len(array), dtype=cls.MASKTYPE)\n                return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.numpy.ma.array(content.reshape((-1,) + array.shape[2:]), mask=mask))\n            if maskedwhen:\n                mask = cls.numpy.ones((len(array), length), dtype=cls.MASKTYPE)\n            else:\n                mask = cls.numpy.zeros((len(array), length), dtype=cls.MASKTYPE)\n            mask[:, :array.shape[1]] = not maskedwhen\n            return cls.JaggedArray.fget(None).fromoffsets(offsets, cls.MaskedArray.fget(None)(mask.reshape((-1,) + array.shape[2:]), content.reshape((-1,) + array.shape[2:]), maskedwhen=maskedwhen))\n\n    @classmethod\n    def _util_regular(cls, array):\n        if isinstance(array, AwkwardArray):\n            return array.regular()\n        else:\n            return array\n\n    @classmethod\n    def _util_reduce(cls, array, ufunc, identity, dtype):\n        if isinstance(array, AwkwardArray):\n            return array._reduce(ufunc, identity, dtype)\n\n        elif len(array) == 0:\n            if dtype is None:\n                dtype = array.dtype\n            return ufunc.reduce(cls.numpy.full((1,) + array.shape[1:], identity, dtype=dtype), axis=-1)\n\n        else:\n            original = array\n            if dtype is not None:\n                array = cls.numpy.array(array, dtype=dtype, copy=False)\n            if issubclass(array.dtype.type, (cls.numpy.floating, cls.numpy.complexfloating)):\n                mask = cls.numpy.isnan(array)\n                if mask.any():\n                    if array is original or not array.flags.owndata:\n                        array = array.copy()\n                    array[mask] = identity\n            return ufunc.reduce(array, axis=None)\n\n    @classmethod\n    def _util_concatenate(cls, arrays):\n        if all(isinstance(x, cls.numpy.ndarray) for x in arrays):\n            return cls.numpy.concatenate(arrays)\n        else:\n            return arrays[0].concatenate(arrays[1:])\n\n    @bothmethod\n    def concatenate(isclassmethod, cls_or_self, arrays, axis=0):\n        if len(arrays) < 1:\n            raise ValueError(""at least one array needed to concatenate"")\n\n        if isclassmethod:\n            cls = cls_or_self\n        else:\n            self = cls_or_self\n            cls = type(self)\n            arrays = (self,) + tuple(arrays)\n\n        def resolve(t):\n            for b in t.__bases__:\n                if issubclass(t, AwkwardArray):\n                    return resolve(b)\n            else:\n                return t\n\n        if all(type(x) == cls.numpy.ndarray for x in arrays):\n            return cls.numpy.concatenate(arrays, axis=axis)\n\n        if not all(resolve(type(x)) == resolve(type(arrays[0])) for x in arrays):\n            if axis == 0:\n                tags = cls.numpy.concatenate([cls.numpy.full(len(x), i, dtype=cls.TAGTYPE) for i, x in enumerate(arrays)])\n                return cls.UnionArray.fget(None).fromtags(tags, arrays)\n            else:\n                raise NotImplementedError(""axis > 0 for different types"")\n\n        for x in arrays:\n            x.valid()\n\n        if axis == 0:\n            return type(arrays[0])._concatenate_axis0(arrays)\n        elif axis == 1:\n            return type(arrays[0])._concatenate_axis1(arrays)\n        else:\n            raise NotImplementedError(""axis > 1"")\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        raise NotImplementedError(""{0}.concatenate with axis=0 not implemented"".format(cls.__name__))\n\n    @classmethod\n    def _concatenate_axis1(cls, arrays):\n        raise NotImplementedError(""{0}.concatenate with axis=1 not implemented"".format(cls.__name__))\n\n    @classmethod\n    def _util_isstringslice(cls, where):\n        if isinstance(where, awkward.util.string):\n            return True\n        elif isinstance(where, bytes):\n            raise TypeError(""column selection must be str, not bytes, in Python 3"")\n        elif isinstance(where, tuple):\n            return False\n        elif isinstance(where, (cls.numpy.ndarray, AwkwardArray)) and issubclass(where.dtype.type, (numpy.str, numpy.str_)):\n            return True\n        elif isinstance(where, (cls.numpy.ndarray, AwkwardArray)) and issubclass(where.dtype.type, (numpy.object, numpy.object_)) and not issubclass(where.dtype.type, (numpy.bool, numpy.bool_)):\n            return len(where) > 0 and all(isinstance(x, awkward.util.string) for x in where)\n        elif isinstance(where, (cls.numpy.ndarray, AwkwardArray)):\n            return False\n        try:\n            assert len(where) > 0 and all(isinstance(x, awkward.util.string) for x in where)\n        except (TypeError, AssertionError):\n            return False\n        else:\n            return True\n\n    @classmethod\n    def _util_iscomparison(cls, ufunc):\n        return (ufunc is cls.numpy.less or\n                ufunc is cls.numpy.less_equal or\n                ufunc is cls.numpy.equal or\n                ufunc is cls.numpy.not_equal or\n                ufunc is cls.numpy.greater or\n                ufunc is cls.numpy.greater_equal)\n\n    @classmethod\n    def _util_fillna(cls, array, value):\n        if isinstance(array, cls.numpy.ndarray):\n            data = cls.numpy.ma.getdata(array)\n            mask = cls.numpy.ma.getmask(array)\n            if mask is not cls.numpy.ma.nomask:\n                data[mask] = value\n            data[cls.numpy.isnan(data)] = value\n            return data\n        else:\n            return array.fillna(value)\n\n    @classmethod\n    def _util_columns_descend(cls, array, seen):\n        if isinstance(array, cls.numpy.ndarray):\n            if array.dtype.fields is None:\n                return []\n            else:\n                return list(array.dtype.fields)\n        else:\n            return array._util_columns(seen)\n\n    @property\n    def columns(self):\n        return self._util_columns(set())\n\n    @classmethod\n    def _util_rowname_descend(cls, array, seen):\n        if isinstance(array, cls.numpy.ndarray):\n            if array.dtype.fields is None:\n                raise TypeError(""not a Table, so there is no rowname"")\n            else:\n                return None\n        else:\n            return array._util_rowname(seen)\n\n    @property\n    def rowname(self):\n        return self._util_rowname(set())\n\n    @property\n    def istuple(self):\n        columns = self.columns\n        return self.rowname == ""tuple"" and columns == [str(x) for x in range(len(columns))]\n\n    def unzip(self):\n        return tuple(self[column_name] for column_name in self._util_columns(set()))\n\nclass AwkwardArrayWithContent(AwkwardArray):\n    """"""\n    AwkwardArrayWithContent: abstract base class\n    """"""\n\n    def __setitem__(self, where, what):\n        if isinstance(where, awkward.util.string):\n            self._content[where] = what\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for x, y in zip(where, what):\n                self._content[x] = y\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __delitem__(self, where):\n        if isinstance(where, awkward.util.string):\n            del self._content[where]\n        elif self._util_isstringslice(where):\n            for x in where:\n                del self._content[x]\n        else:\n            raise TypeError(""invalid index for removing column from Table: {0}"".format(where))\n\n    def _hasjagged(self):\n        return self._util_hasjagged(self._content)\n\n    def _util_columns(self, seen):\n        if id(self) in seen:\n            return []\n        seen.add(id(self))\n        return self._util_columns_descend(self._content, seen)\n\n    def _util_rowname(self, seen):\n        if id(self) in seen:\n            raise TypeError(""not a Table, so there is no rowname"")\n        seen.add(id(self))\n        return self._util_rowname_descend(self._content, seen)\n\n    def astype(self, dtype):\n        return self.copy(content=self._content.astype(dtype))\n\n    def fillna(self, value):\n        return self.copy(content=self._util_fillna(self._content, value))\n'"
awkward/array/chunked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.base\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nclass ChunkedArray(awkward.array.base.AwkwardArray):\n    """"""\n    ChunkedArray\n    """"""\n\n    def __init__(self, chunks, chunksizes=[]):\n        self.chunks = chunks\n        self.chunksizes = chunksizes\n\n    def copy(self, chunks=None, chunksizes=None):\n        out = self.__class__.__new__(self.__class__)\n        out._chunks = list(self._chunks)\n        out._chunksizes = list(self._chunksizes)\n        out._types = list(self._types)\n        out._offsets = self._offsets\n        if chunks is not None:\n            out.chunks = chunks\n            out._chunksizes = []\n        if chunksizes is not None:\n            out.chunksizes = chunksizes\n        return out\n\n    def deepcopy(self, chunks=None, chunksizes=None):\n        out = self.copy(chunks=chunks, chunksizes=chunksizes)\n        out._chunks = [self._util_deepcopy(out._chunks) for x in out._chunks]\n        return out\n\n    def _mine(self, overrides):\n        return {}\n\n    def empty_like(self, **overrides):\n        self.knowchunksizes()\n        self._valid()\n        mine = self._mine(overrides)\n        return self.copy([self.numpy.empty_like(x) if isinstance(x, self.numpy.ndarray) else x.empty_like(**overrides) for x in self._chunks], chunksizes=list(self._chunksizes), **mine)\n\n    def zeros_like(self, **overrides):\n        self.knowchunksizes()\n        self._valid()\n        mine = self._mine(overrides)\n        return self.copy([self.numpy.zeros_like(x) if isinstance(x, self.numpy.ndarray) else x.zeros_like(**overrides) for x in self._chunks], chunksizes=list(self._chunksizes), **mine)\n\n    def ones_like(self, **overrides):\n        self.knowchunksizes()\n        self._valid()\n        mine = self._mine(overrides)\n        return self.copy([self.numpy.ones_like(x) if isinstance(x, self.numpy.ndarray) else x.ones_like(**overrides) for x in self._chunks], chunksizes=list(self._chunksizes), **mine)\n\n    def __awkward_serialize__(self, serializer):\n        self.knowchunksizes()\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""ChunkedArray""],\n            dict(list=[\n                serializer(x, ""ChunkedArray.chunk"")\n                for c, x in zip(self._chunksizes, self._chunks)\n                if c > 0\n            ]),\n            serializer.encode_json([int(c) for c in self._chunksizes if c > 0]),\n        )\n\n    @property\n    def chunks(self):\n        return self._chunks\n\n    @chunks.setter\n    def chunks(self, value):\n        if self.check_prop_valid:\n            try:\n                iter(value)\n            except TypeError:\n                raise TypeError(""chunks must be iterable"")\n        self._chunks = [self._util_toarray(x, self.DEFAULTTYPE) for x in value]\n        self._types = [None] * len(self._chunks)\n\n    @property\n    def chunksizes(self):\n        return self._chunksizes\n\n    @chunksizes.setter\n    def chunksizes(self, value):\n        if self.check_prop_valid:\n            try:\n                if not all(self._util_isinteger(x) and x >= 0 for x in value):\n                    raise ValueError(""chunksizes must contain only non-negative integers"")\n            except TypeError:\n                raise TypeError(""chunksizes must be iterable"")\n        self._chunksizes = list(value)\n        self._offsets = None\n\n    @property\n    def offsets(self):\n        if self._offsets is None or len(self._offsets) != len(self._chunksizes) + 1:\n            self._offsets = self.JaggedArray.counts2offsets(self._chunksizes)\n        return self._offsets\n\n    @property\n    def chunksizesknown(self):\n        return len(self._chunksizes) == len(self._chunks)\n\n    @property\n    def typesknown(self):\n        return all(x is not None for x in self._types)\n\n    def knowchunksizes(self, until=None):\n        if until is None:\n            until = len(self._chunks)\n        until = min(until, len(self._chunks))\n        for i in range(len(self._chunksizes), until):\n            self._chunksizes.append(len(self._chunks[i]))\n            self._offsets = None\n\n    def knowtype(self, at):\n        if not 0 <= at < len(self._chunks):\n            raise ValueError(""cannot knowtype at chunkid {0} with {1} chunks"".format(at, len(self._chunks)))\n        chunk = self._chunks[at]\n        if len(chunk) == 0:\n            self._types[at] = ()\n        else:\n            self._types[at] = awkward.type.fromarray(chunk).to\n        return self._types[at]\n\n    def global2chunkid(self, index, return_normalized=False):\n        self._valid()\n\n        if self._util_isinteger(index):\n            original_index = index\n            if index < 0:\n                index += len(self)\n            if index < 0:\n                raise IndexError(""index {0} out of bounds for length {1}"".format(original_index, len(self)))\n\n            cumulative = self.offsets[-1]\n            while index >= cumulative:\n                if self.chunksizesknown:\n                    raise IndexError(""index {0} out of bounds for length {1}"".format(original_index, len(self)))\n                count = len(self._chunks[len(self._chunksizes)])\n                cumulative += count\n                self._chunksizes.append(count)\n\n            out = self.numpy.searchsorted(self.offsets, index, ""right"") - 1\n\n        else:\n            index = self.numpy.array(index, copy=False)\n            if len(index.shape) == 1 and self._util_isintegertype(index.dtype.type):\n                if len(index) == 0:\n                    out = self.numpy.empty(0, dtype=self.INDEXTYPE)\n\n                else:\n                    mask = (index < 0)\n                    if mask.any():\n                        index = self._util_deepcopy(index)\n                        index[mask] += len(self)\n                    if (index < 0).any():\n                        raise IndexError(""index out of bounds for length {0}"".format(len(self)))\n\n                    self.global2chunkid(index.max())    # make sure all the chunksizes we need are known\n                    out = self.numpy.searchsorted(self.offsets, index, ""right"") - 1\n\n            else:\n                raise TypeError(""global2chunkid requires an integer or an array of integers"")\n\n        if return_normalized:\n            return out, index\n        else:\n            return out\n\n    def global2local(self, index):\n        chunkid, index = self.global2chunkid(index, return_normalized=True)\n\n        if self._util_isinteger(index):\n            return self._chunks[chunkid], index - self.offsets[chunkid]\n        else:\n            return self.numpy.array(self._chunks, dtype=self.numpy.object)[chunkid], index - self.offsets[chunkid]\n\n    def local2global(self, index, chunkid):\n        if self._util_isinteger(chunkid):\n            self.knowchunksizes(chunkid + 1)\n            self._valid()\n            original_index = index\n            if index < 0:\n                index += self._chunksizes[chunkid]\n            if not 0 <= index < self._chunksizes[chunkid]:\n                raise IndexError(""local index {0} is out of bounds in chunk {1}, which has length {2}"".format(original_index, chunkid, self._chunksizes[chunkid]))\n            return self.offsets[chunkid] + index\n\n        else:\n            index = self.numpy.array(index, copy=False)\n            chunkid = self.numpy.array(chunkid, copy=False)\n            if len(index.shape) == 1 and self._util_isintegertype(index.dtype.type) and len(chunkid.shape) == 1 and self._util_isintegertype(chunkid.dtype.type):\n                if len(index) != len(chunkid):\n                    raise ValueError(""len(index) is {0} and len(chunkid) is {1}, but they should be equal"".format(len(index), len(chunkid)))\n\n                self.knowchunksizes(chunkid.max() + 1)\n                self._valid()\n                chunksizes = self.numpy.array(self._chunksizes, dtype=self.INDEXTYPE)\n                mask = (index < 0)\n                index[mask] += chunksizes[mask]\n                if not ((0 <= index) & (index < chunksizes)).all():\n                    raise IndexError(""some local indexes are out of bounds"")\n                return chunksizes[chunkid] + index\n\n            else:\n                raise TypeError(""local2global requires index and chunkid to be integers or arrays of integers"")\n\n    def _gettype(self, seen):\n        for tpe in self._types:\n            if tpe is not None and not (isinstance(tpe, tuple) and len(tpe) == 0):\n                break\n        else:\n            for i in range(len(self._types)):\n                tpe = self.knowtype(i)\n                if tpe is not None and not (isinstance(tpe, tuple) and len(tpe) == 0):\n                    break\n            else:\n                tpe = self.DEFAULTTYPE\n\n        for i in range(len(self._types)):\n            if self._types[i] is None or (isinstance(self._types[i], tuple) and len(self._types[i]) == 0) or self._types[i] is tpe:\n                pass\n            elif self._types[i] == tpe:       # valid if all chunks have the same high-level type\n                self._types[i] = tpe          # once checked, make them identically equal for faster checking next time\n            else:\n                raise TypeError(""chunks do not have matching types:\\n\\n{0}\\n\\nversus\\n\\n{1}"".format(awkward.type._str(tpe, indent=""    ""), awkward.type._str(self._types[i], indent=""    "")))\n\n        return tpe\n\n    def _util_layout(self, position, seen, lookup):\n        positions = []\n        for i, x in enumerate(self._chunks):\n            awkward.type.LayoutNode(x, position + (i,), seen, lookup)\n            positions.append(position + (i,))\n        return (awkward.type.LayoutArg(""chunks"", positions),\n                awkward.type.LayoutArg(""chunksizes"", list(self._chunksizes)))\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return sum(x.nbytes if isinstance(x, self.numpy.ndarray) else x._getnbytes(seen) for x in self._chunks)\n\n    def __len__(self):\n        self.knowchunksizes()\n        return self.offsets[-1]\n\n    def _slices(self):\n        # perhaps this should be a (public) @staticmethod that finds the largest possible slices to serve no more than one chunk each from a set of ChunkedArrays\n        self.knowchunksizes()\n        offsets = self.offsets\n        return [slice(start, stop) for start, stop in zip(offsets[:-1], offsets[1:])]\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if len(self._chunksizes) > len(self._chunks):\n                raise ValueError(""ChunkArray has more chunksizes than chunks"")\n            for i, count in enumerate(self._chunksizes):\n                if count != len(self._chunks[i]):\n                    raise ValueError(""count[{0}] does not agree with len(chunk[{0}])"".format(i))\n        self._gettype({})\n\n    def __str__(self):\n        if self.chunksizesknown:\n            return super(ChunkedArray, self).__str__()\n        else:\n            strs = [self._util_arraystr(x) for x in self[:7].__iter__(checkiter=False)]\n            if len(strs) < 7:\n                return super(ChunkedArray, self).__str__()\n            else:\n                return ""[{0} ...]"".format("" "".join(strs))\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        for i, chunk in enumerate(self._chunks):\n            if i >= len(self._chunksizes):\n                self._chunksizes.append(len(chunk))\n            for x in chunk[:self._chunksizes[i]]:\n                yield x\n\n    def __array__(self, *args, **kwargs):\n        self._checktonumpy()\n\n        if isinstance(self.type.to, self.numpy.dtype):\n            if len(self) == 0:\n                return self.numpy.empty(0, dtype=self.DEFAULTTYPE)\n            else:\n                out = self.numpy.empty(self.shape, dtype=self.dtype)\n                for chunk, slc in zip(self._chunks, self._slices()):\n                    out[slc] = chunk\n                return out\n        else:\n            return super(ChunkedArray, self).__array__(*args, **kwargs)\n\n    def __getitem__(self, where):\n        import awkward.array.virtual\n\n        self._valid()\n\n        if self._util_isstringslice(where):\n            chunks = []\n            chunksizes = []\n            for chunk in self._chunks:\n                chunks.append(chunk[where])\n                chunksizes.append(len(chunks[-1]))\n            if len(chunks) == 0:\n                return self.copy(chunks=chunks, chunksizes=chunksizes)\n            else:\n                return awkward.array.objects.Methods.maybemixin(type(chunks[0]), self.ChunkedArray)(chunks, chunksizes=chunksizes)\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if isinstance(head, ChunkedArray):\n            if not self._aligned(head):\n                raise ValueError(""A ChunkedArray can only be used as a slice of a ChunkedArray if they have the same chunk sizes"")\n            chunks = []\n            chunksizes = []\n            for c, h in zip(self.chunks, head.chunks):\n                if isinstance(c, awkward.array.virtual.VirtualArray):\n                    c = c.array\n                if isinstance(h, awkward.array.virtual.VirtualArray):\n                    h = h.array\n                chunks.append(c[(h,) + tail])\n                chunksizes.append(len(chunks[-1]))\n            return self.copy(chunks=chunks, chunksizes=chunksizes)\n\n        if self._util_isinteger(head):\n            chunk, localhead = self.global2local(head)\n            return chunk[(localhead,) + tail]\n\n        elif isinstance(head, slice):\n            if head.step == 0:\n                raise ValueError(""slice step cannot be zero"")\n            elif (head.start is None or head.start >= 0) and (head.stop is not None and head.stop >= 0) and (head.step is None or head.step > 0):\n                # case A\n                start, stop, step = head.start, head.stop, head.step\n                if start is None:\n                    start = 0\n                if step is None:\n                    step = 1\n            elif (head.start is not None and head.start >= 0) and (head.stop is None or head.stop >= 0) and (head.step is not None and head.step < 0):\n                # case B\n                start, stop, step = head.start, head.stop, head.step\n                if stop is None:\n                    stop = -1\n            else:\n                # case C (requires potentially expensive len(self))\n                start, stop, step = head.indices(len(self))\n\n            # if step > 0, stop can be len(self)\n            # if step < 0, stop can be -1 (not a Python ""negative index"", but an indicator to go all the way to 0)\n\n            if start == -1:\n                # case C start below 0\n                start_chunkid = -1\n            else:\n                try:\n                    start_chunkid = self.global2chunkid(start)\n                except IndexError:\n                    if start >= 0:\n                        # case A or B start was set beyond len(self), clamp it\n                        start, start_chunkid = len(self), len(self._chunks)\n                    if step < 0:\n                        start -= 1\n                        start_chunkid -= 1\n\n            if stop == -1:\n                # case B or C stop not set with step < 0; go all the way to 0\n                stop_chunkid = -1\n            else:\n                try:\n                    stop_chunkid = self.global2chunkid(stop)\n                except IndexError:\n                    # stop is at or beyond len(self), clamp it\n                    stop = len(self)\n                if step > 0:\n                    # we want the chunkid at or to the right of stop (no -1)\n                    stop_chunkid = min(self.numpy.searchsorted(self.offsets, stop, ""right""), len(self._chunks))\n                else:\n                    # we want the chunkid to the left of stop\n                    stop_chunkid = max(self.numpy.searchsorted(self.offsets, stop, ""right"") - 2, -1)\n\n            offsets = self.offsets\n            chunks = []\n            skip = 0\n            for chunkid in range(start_chunkid, stop_chunkid, 1 if step > 0 else -1):\n                # set the local_start\n                if chunkid == start_chunkid:\n                    local_start = start - offsets[chunkid]\n                else:\n                    if step > 0:\n                        local_start = skip\n                    else:\n                        local_start = self._chunksizes[chunkid] - 1 - skip\n\n                if local_start < 0:\n                    # skip is bigger than this entire chunk\n                    skip -= self._chunksizes[chunkid]\n                    continue\n\n                # set the local_stop and new skip\n                if chunkid == stop_chunkid - (1 if step > 0 else -1):\n                    if stop == -1:\n                        local_stop = None\n                    else:\n                        local_stop = stop - offsets[chunkid]\n                else:\n                    local_stop = None\n                    if step > 0:\n                        skip = (local_start - self._chunksizes[chunkid]) % step\n                    else:\n                        skip = (-1 - local_start) % -step\n\n                # add a sliced chunk\n                chunk = self._chunks[chunkid][(slice(local_start, local_stop, step),)]\n                if len(chunk) > 0:\n                    chunk = chunk[(slice(None),) + tail]\n                    if len(chunk) > 0:\n                        chunks.append(chunk)\n\n            if len(chunks) == 0 and len(self._chunks) > 0:\n                chunks.append(self._chunks[0][(slice(0, 0),) + tail])   # so that sliced.type == self.type\n\n            return self.copy(chunks=chunks)\n\n        else:\n            head = self.numpy.array(head, copy=False)\n            if len(head.shape) == 1 and self._util_isintegertype(head.dtype.type):\n                if len(head) == 0 and len(self._chunks) == 0:\n                    return self.copy(chunks=[])[tail]\n                elif len(head) == 0:\n                    return self.copy(chunks=[self._chunks[0][(slice(0, 0),) + tail]])\n\n                chunkid, head = self.global2chunkid(head, return_normalized=True)\n\n                diff = (chunkid[1:] - chunkid[:-1])\n                if (diff >= 0).all():\n                    diff2 = self.numpy.empty(len(chunkid), dtype=self.INDEXTYPE)\n                    diff2[0] = 1\n                    diff2[1:] = diff\n                    mask = (diff2 > 0)\n                    offsets = list(self.numpy.nonzero(mask)[0]) + [len(chunkid)]\n                    chunks = []\n                    for i, cid in enumerate(chunkid[mask]):\n                        localindex = head[offsets[i]:offsets[i + 1]] - self.offsets[cid]\n                        chunks.append(self._chunks[cid][localindex])\n                    return self.copy(chunks=chunks)\n\n                elif self._util_isnumpy(self.type):\n                    out = self.numpy.empty((len(head),) + self.type.shape[1:], dtype=self.type.dtype)\n                    self.knowchunksizes(chunkid.max() + 1)\n                    offsets = self.offsets\n\n                    for cid in self.numpy.unique(chunkid):\n                        mask = (chunkid == cid)\n                        out[mask] = self._chunks[cid][head[mask] - offsets[cid]]\n\n                    if tail == ():\n                        return out\n                    else:\n                        return out[(slice(None),) + tail]\n\n                elif tail == ():\n                    return self.IndexedArray(head, self)\n\n                else:\n                    raise NotImplementedError\n\n            elif len(head.shape) == 1 and issubclass(head.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                if len(self) != len(head):\n                    raise IndexError(""boolean index did not match indexed array along dimension 0; dimension is {0} but corresponding boolean dimension is {1}"".format(len(self), len(head)))\n\n                chunks = []\n                for chunk, slc in zip(self._chunks, self._slices()):\n                    x = chunk[head[slc]]\n                    if len(x) > 0:\n                        x = x[(slice(None),) + tail]\n                        if len(x) > 0:\n                            chunks.append(x)\n\n                return self.copy(chunks=chunks)\n\n            else:\n                raise TypeError(""cannot interpret shape {0}, dtype {1} as a fancy index or mask"".format(head.shape, head.dtype))\n\n    def _aligned(self, what):\n        self.knowchunksizes()\n        what.knowchunksizes()\n        return self._chunksizes == what._chunksizes\n\n    def __setitem__(self, where, what):\n        if isinstance(what, ChunkedArray) and self._aligned(what):\n            for i, (mine, theirs) in enumerate(zip(self._chunks, what._chunks)):\n                mine[where] = theirs\n                self._types[i] = mine.type.to\n        else:\n            raise ValueError(""only ChunkedArrays with the same chunk sizes can be assigned to columns of a ChunkedArray"")\n\n    def __delitem__(self, where):\n        if isinstance(where, awkward.util.string):\n            for chunk in self._chunks:\n                del chunk[where]\n        elif self._util_isstringslice(where):\n            for chunk in self._chunks:\n                for x in where:\n                    del chunk[x]\n        else:\n            raise TypeError(""invalid index for removing column from Table: {0}"".format(where))\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        first = None\n        rest = []\n        for x in inputs:\n            if isinstance(x, ChunkedArray):\n                x._valid()\n                if first is None:\n                    first = x\n                else:\n                    rest.append(x)\n\n        assert first is not None\n        if not all(first._aligned(x) for x in rest):\n            # FIXME: we may need to handle a more general case if ChunkedArrays are inside other awkward types\n            # perhaps split at the largest possible slices such that all of them are one chunk each, and then unpack the single chunk after slicing\n            raise ValueError(""ChunkedArrays can only be combined if they have the same chunk sizes"")\n\n        batches = []\n        for i, slc in enumerate(first._slices()):\n            batch = []\n            for x in inputs:\n                if isinstance(x, ChunkedArray):\n                    batch.append(x._chunks[i])\n                elif isinstance(x, (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                    batch.append(x[slc])\n                else:\n                    batch.append(x)\n            batches.append(batch)\n\n        out = None\n        chunks = {}\n        types = {}\n        for batch in batches:\n            result = getattr(ufunc, method)(*batch, **kwargs)\n\n            if isinstance(result, tuple):\n                if out is None:\n                    out = list(result)\n                for i, x in enumerate(result):\n                    if isinstance(x, (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                        if i not in chunks:\n                            chunks[i] = []\n                        chunks[i].append(x)\n                        types[i] = type(x)\n\n            elif method == ""at"":\n                pass\n\n            else:\n                if isinstance(result, (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                    if None not in chunks:\n                        chunks[None] = []\n                    chunks[None].append(result)\n                    types[None] = type(result)\n\n        if out is None:\n            if None in chunks:\n                return self.Methods.maybemixin(types[None], ChunkedArray)(chunks[None])\n            else:\n                return None\n        else:\n            for i in range(len(out)):\n                if i in chunks:\n                    out[i] = self.Methods.maybemixin(types[i], ChunkedArray)(chunks[i])\n            return tuple(out)\n\n    @property\n    def counts(self):\n        return self.numpy.concatenate([self._util_counts(x) for x in self._chunks])\n\n    def boolmask(self, maskedwhen=True):\n        return self.numpy.concatenate([self._util_boolmask(x, maskedwhen) for x in self._chunks])\n\n    def choose(self, n):\n        out = self.copy(chunks=[x.choose(n) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def argchoose(self, n):\n        out = self.copy(chunks=[x.argchoose(n) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def distincts(self, nested=False):\n        out = self.copy(chunks=[x.distincts(nested=nested) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def argdistincts(self, nested=False):\n        out = self.copy(chunks=[x.argdistincts(nested=nested) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def pairs(self, nested=False):\n        out = self.copy(chunks=[x.pairs(nested=nested) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def argpairs(self, nested=False):\n        out = self.copy(chunks=[x.argpairs(nested=nested) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def cross(self, other, nested=False):\n        if not isinstance(other, ChunkedArray) or not self._aligned(other):\n            raise ValueError(""A ChunkedArray can only be crossed with a ChunkedArray if they have the same chunk sizes"")\n        chunks = []\n        chunksizes = []\n        for c, h in zip(self.chunks, other.chunks):\n            if isinstance(c, awkward.array.virtual.VirtualArray):\n                c = c.array\n            if isinstance(h, awkward.array.virtual.VirtualArray):\n                h = h.array\n            chunks.append(c.cross(h, nested=nested))\n            chunksizes.append(len(chunks[-1]))\n        return self.copy(chunks=chunks, chunksizes=chunksizes)\n\n    def argcross(self, other, nested=False):\n        if not isinstance(other, ChunkedArray) or not self._aligned(other):\n            raise ValueError(""A ChunkedArray can only be crossed with a ChunkedArray if they have the same chunk sizes"")\n        chunks = []\n        chunksizes = []\n        for c, h in zip(self.chunks, other.chunks):\n            if isinstance(c, awkward.array.virtual.VirtualArray):\n                c = c.array\n            if isinstance(h, awkward.array.virtual.VirtualArray):\n                h = h.array\n            chunks.append(c.argcross(h, nested=nested))\n            chunksizes.append(len(chunks[-1]))\n        return self.copy(chunks=chunks, chunksizes=chunksizes)\n\n    def flattentuple(self):\n        return self.copy(chunks=[self._util_flattentuple(x) for x in self._chunks], chunksizes=self._chunksizes)\n\n    def flatten(self, axis=0):\n        out = self.copy(chunks=[self._util_flatten(x, axis) for x in self._chunks])\n        out.knowchunksizes()\n        return out\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self.copy(chunks=[self._util_pad(x, length, maskedwhen, clip, axis) for x in self._chunks], chunksizes=self.chunksizes)\n\n    def regular(self):\n        self._valid()\n        return self.numpy.concatenate([self._util_regular(x) for x in self._chunks])\n\n    def _hasjagged(self):\n        for chunkid in range(len(self._chunks)):\n            self.knowchunksizes(chunkid + 1)\n            if self._chunksizes[chunkid] > 0:\n                return self._util_hasjagged(self._chunks[chunkid])\n        else:\n            return False\n\n    def _reduce(self, ufunc, identity, dtype):\n        self.knowchunksizes()\n        self._valid()\n\n        if self._util_hasjagged(self):\n            chunks = []\n            for chunkid, chunk in enumerate(self._chunks):\n                this = chunk._reduce(ufunc, identity, dtype)\n                if len(this) > 0:\n                    chunks.append(this)\n            return self.copy(chunks=chunks)\n\n        out = None\n        for chunkid, chunk in enumerate(self._chunks):\n            if self._chunksizes[chunkid] > 0:\n                this = self._util_reduce(chunk[:self._chunksizes[chunkid]], ufunc, identity, dtype)\n                if out is None:\n                    out = this\n                else:\n                    out = ufunc(out, this)\n\n        if out is None:\n            if dtype is None:\n                return identity\n            else:\n                return dtype.type(identity)\n        else:\n            return out\n\n    def argmin(self):\n        if self._util_hasjagged(self):\n            return self.copy(chunks=[x.argmin() for x in self._chunks], chunksizes=self._chunksizes)\n        else:\n            indexes = [x.argmin() for x in self._chunks]\n            chunkid = self.numpy.argmin([x[i] for i, x in zip(indexes, self._chunks)])\n            self.knowchunksizes(chunkid)\n            return self.offsets[chunkid] + indexes[chunkid]\n\n    def argmax(self):\n        if self._util_hasjagged(self):\n            return self.copy(chunks=[x.argmax() for x in self._chunks], chunksizes=self._chunksizes)\n        else:\n            indexes = [x.argmax() for x in self._chunks]\n            chunkid = self.numpy.argmax([x[i] for i, x in zip(indexes, self._chunks)])\n            self.knowchunksizes(chunkid)\n            return self.offsets[chunkid] + indexes[chunkid]\n\n    def _prepare(self, ufunc, identity, dtype):\n        self.knowchunksizes()\n        out = None\n        pos = 0\n        for chunkid, chunk in enumerate(self._chunks):\n            if self._chunksizes[chunkid] > 0:\n                this = chunk[:self._chunksizes[chunkid]]\n                if out is None:\n                    if dtype is None and issubclass(this.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                        dtype = self.numpy.dtype(type(identity))\n                    if dtype is None:\n                        dtype = this.dtype\n                    out = self.numpy.empty((sum(self._chunksizes),) + this.shape[1:], dtype=dtype)\n\n                newpos = pos + this.shape[0]\n                out[pos:newpos] = this\n                pos = newpos\n\n        if out is None:\n            if dtype is None:\n                dtype = self.DEFAULTTYPE\n            return self.numpy.array([identity], dtype=dtype)\n        else:\n            return out\n\n    def _util_columns(self, seen):\n        if id(self) in seen:\n            return []\n        seen.add(id(self))\n        for chunkid in range(len(self._chunks)):\n            self.knowchunksizes(chunkid + 1)\n            if self._chunksizes[chunkid] > 0:\n                return self._util_columns_descend(self._chunks[chunkid], seen)\n        return []\n\n    def _util_rowname(self, seen):\n        if id(self) in seen:\n            raise TypeError(""not a Table, so there is no rowname"")\n        for chunkid in range(len(self._chunks)):\n            self.knowchunksizes(chunkid + 1)\n            if self._chunksizes[chunkid] > 0:\n                return self._util_rowname_descend(self._chunks[chunkid], seen)\n\n    def astype(self, dtype):\n        chunks = []\n        chunksizes = []\n        for i, chunk in enumerate(self._chunks):\n            if i >= len(self._chunksizes):\n                self._chunksizes.append(len(chunk))\n            chunks.append(chunk.astype(dtype))\n            chunksizes.append(self._chunksizes[i])\n        return self.copy(chunks=chunks, chunksizes=chunksizes)\n\n    def fillna(self, value):\n        chunks = []\n        chunksizes = []\n        for i, chunk in enumerate(self._chunks):\n            if i >= len(self._chunksizes):\n                self._chunksizes.append(len(chunk))\n            chunks.append(self._util_fillna(chunk, value))\n            chunksizes.append(self._chunksizes[i])\n        return self.copy(chunks=chunks, chunksizes=chunksizes)\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, ChunkedArray) for x in arrays)\n        if all(x.chunksizesknown for x in arrays):\n            chunksizes = [y for x in arrays for y in x._chunksizes]\n        else:\n            chunksizes = []\n        chunks = [y for x in arrays for y in x._chunks]\n        return cls(chunks, chunksizes)\n\n    _topandas_name = ""ChunkedSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            out._chunks = [x._topandas(seen) if isinstance(x, awkward.array.base.AwkwardArray) else x for x in out._chunks]\n            return out\n\nclass AppendableArray(ChunkedArray):\n    """"""\n    AppendableArray\n    """"""\n\n    def __init__(self, chunkshape, dtype, chunks=[]):\n        self.chunkshape = chunkshape\n        self.dtype = dtype\n        self.chunks = chunks\n\n    def copy(self, chunkshape=None, dtype=None, chunks=None):\n        out = self.__class__.__new__(self.__class__)\n        out._chunkshape = self._chunkshape\n        out._dtype = self._dtype\n        out._chunks = list(self._chunks)\n        if chunkshape is not None:\n            out._chunkshape = chunkshape\n        if dtype is not None:\n            out._dtype = dtype\n        if chunks is not None:\n            out.chunks = chunks\n        out._chunksizes = list(self._chunksizes)\n        out._types = list(self._types)\n        return out\n\n    def _mine(self, overrides):\n        mine = {}\n        mine[""chunkshape""] = overrides.pop(""chunkshape"", self._chunkshape)\n        mine[""dtype""] = overrides.pop(""dtype"", self._dtype)\n        return mine\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n\n        chunks = []\n        for c, x in zip(self._chunksizes, self._chunks):\n            if 0 < c < len(x):\n                chunks.append(x[:c])\n            elif 0 < c:\n                chunks.append(x)\n\n        return serializer.encode_call(\n            [""awkward"", ""AppendableArray""],\n            dict(tuple=[dict(json=int(x)) for x in self._chunkshape]),\n            serializer(self._dtype),\n            dict(list=[\n                serializer(x, ""AppendableArray.chunk"")\n                for x in chunks\n            ]),\n        )\n\n    @property\n    def chunkshape(self):\n        return self._chunkshape\n\n    @chunkshape.setter\n    def chunkshape(self, value):\n        if self._util_isinteger(value) and value > 0:\n            self._chunkshape = (value,)\n        else:\n            if self.check_prop_valid:\n                try:\n                    for x in value:\n                        assert self._util_isinteger(x) and x > 0\n                except TypeError:\n                    raise TypeError(""chunkshape must be a positive integer or a tuple of integers"")\n                except AssertionError:\n                    raise ValueError(""chunkshape must be a positive integer or tuple of positive integers"")\n                self._chunkshape = tuple(value)\n\n    @property\n    def dtype(self):\n        return self._dtype\n\n    @dtype.setter\n    def dtype(self, value):\n        self._dtype = self.numpy.dtype(value)\n\n    @property\n    def chunks(self):\n        return self._chunks\n\n    @chunks.setter\n    def chunks(self, value):\n        if self.check_prop_valid:\n            try:\n                iter(value)\n            except TypeError:\n                raise TypeError(""chunks must be iterable"")\n        chunks = [self._util_toarray(x, self.DEFAULTTYPE, self.numpy.ndarray) for x in value]\n        if self.check_prop_valid:\n            for chunk in chunks:\n                if chunk.dtype != self._dtype:\n                    raise ValueError(""cannot assign chunk with dtype ({0}) to an AppendableArray with dtype ({1})"".format(chunk.dtype, self._dtype))\n                if chunk.shape[1:] != self._chunkshape[1:]:\n                    raise ValueError(""cannot assign chunk with dimensionality ({0}) to an AppendableArray with dimensionality ({1}), where dimensionality is shape[1:]"".format(chunk.shape[1:], self._chunkshape[1:]))\n        self._chunks = chunks\n        self._chunksizes = [len(x) for x in self._chunks]\n        self._types = [None] * len(self._chunks)\n\n    @property\n    def chunksizes(self):\n        return self._chunksizes\n\n    @chunksizes.setter\n    def chunksizes(self, value):\n        raise AttributeError(""cannot assign to chunksizes in AppendableArray"")\n\n    def knowchunksizes(self, until=None):\n        pass\n\n    @property\n    def offsets(self):\n        return self.JaggedArray.counts2offsets(self._chunksizes)\n\n    def _gettype(self, seen):\n        return self._dtype\n\n    def _util_layout(self, position, seen, lookup):\n        positions = []\n        for i, x in enumerate(self._chunks):\n            awkward.type.LayoutNode(x, position + (i,), seen, lookup)\n            positions.append(position + (i,))\n        return (awkward.type.LayoutArg(""chunkshape"", self._chunkshape),\n                awkward.type.LayoutArg(""dtype"", self._dtype),\n                awkward.type.LayoutArg(""chunks"", positions))\n\n    def __len__(self):\n        return sum(self._chunksizes)\n\n    def _valid(self):\n        if self.check_whole_valid:\n            pass\n\n    def __setitem__(self, where, what):\n        raise TypeError(""array has no Table, cannot assign columns"")\n\n    def __delitem__(self, where):\n        raise TypeError(""array has no Table, cannot remove columns"")\n\n    def append(self, value):\n        if len(self._chunks) == 0 or self._chunksizes[-1] == len(self._chunks[-1]):\n            self._types.append(None)\n            self._chunksizes.append(0)\n            self._chunks.append(self.numpy.empty(self._chunkshape, dtype=self._dtype))\n\n        self._chunks[-1][self._chunksizes[-1]] = value\n        self._chunksizes[-1] += 1\n\n    def extend(self, values):\n        while len(values) > 0:\n            if len(self._chunks) == 0 or self._chunksizes[-1] == len(self._chunks[-1]):\n                self._types.append(None)\n                self._chunksizes.append(0)\n                self._chunks.append(self.numpy.empty(self._chunkshape, dtype=self._dtype))\n\n            howmany = min(len(values), len(self._chunks[-1]) - self._chunksizes[-1])\n            self._chunks[-1][self._chunksizes[-1] : self._chunksizes[-1] + howmany] = values[:howmany]\n            self._chunksizes[-1] += howmany\n            values = values[howmany:]\n\n    def _hasjagged(self):\n        return False\n\n    def astype(self, dtype):\n        chunks = []\n        for chunk in self._chunks:\n            chunks.append(chunk.astype(dtype))\n        return self.copy(dtype=self.numpy.dtype(dtype), chunks=chunks)\n\n    def fillna(self, value):\n        chunks = []\n        for chunk in self._chunks:\n            chunks.append(self._util_fillna(chunk, value))\n        return self.copy(chunks=chunks)\n'"
awkward/array/indexed.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport pickle\nimport numbers\n\nimport awkward.array.base\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nclass IndexedArray(awkward.array.base.AwkwardArrayWithContent):\n    """"""\n    IndexedArray\n    """"""\n\n    @classmethod\n    def invert(cls, permutation):\n        if permutation.size == 0:\n            return cls.numpy.zeros(0, dtype=cls.IndexedArray.fget(None).INDEXTYPE)\n        permutation = permutation.reshape(-1)\n        out = cls.numpy.zeros(permutation.max() + 1, dtype=cls.IndexedArray.fget(None).INDEXTYPE)\n        identity = cls.numpy.arange(len(permutation))\n        out[permutation] = identity\n        if not cls.numpy.array_equal(out[permutation], identity):\n            raise ValueError(""cannot invert index; it contains duplicates"")\n        return out\n\n    def __init__(self, index, content):\n        self.index = index\n        self.content = content\n\n    def copy(self, index=None, content=None):\n        out = self.__class__.__new__(self.__class__)\n        out._index = self._index\n        out._content = self._content\n        out._inverse = self._inverse\n        out._isvalid = self._isvalid\n        if index is not None:\n            out.index = index\n        if content is not None:\n            out.content = content\n        return out\n\n    def deepcopy(self, index=None, content=None):\n        out = self.copy(index=index, content=content)\n        out._index   = self._util_deepcopy(out._index)\n        out._content = self._util_deepcopy(out._content)\n        out._inverse = self._util_deepcopy(out._inverse)\n        return out\n\n    def empty_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.empty_like(self._content))\n        else:\n            return self.copy(content=self._content.empty_like(**overrides))\n\n    def zeros_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.zeros_like(self._content))\n        else:\n            return self.copy(content=self._content.zeros_like(**overrides))\n\n    def ones_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.ones_like(self._content))\n        else:\n            return self.copy(content=self._content.ones_like(**overrides))\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""IndexedArray""],\n            serializer(self._index, ""IndexedArray.index""),\n            serializer(self._content, ""IndexedArray.content""),\n        )\n\n    @property\n    def index(self):\n        return self._index\n\n    @index.setter\n    def index(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""index must have integer dtype"")\n            if (value < 0).any():\n                raise ValueError(""index must be a non-negative array"")\n        self._index = value\n        self._inverse = None\n        self._isvalid = False\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n        self._isvalid = False\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return self._index.nbytes + (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n\n    def __len__(self):\n        return len(self._index)\n\n    def _gettype(self, seen):\n        out = awkward.type._fromarray(self._content, seen)\n        for x in self._index.shape[:0:-1]:\n            out = awkward.type.ArrayType(x, out)\n        return out\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._index, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (1,), seen, lookup)\n        return (awkward.type.LayoutArg(""index"", position + (0,)),\n                awkward.type.LayoutArg(""content"", position + (1,)))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                if len(self._index) != 0 and self._index.reshape(-1).max() > len(self._content):\n                    raise ValueError(""maximum index ({0}) is beyond the length of the content ({1})"".format(self._index.reshape(-1).max(), len(self._content)))\n\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n        for i in self._index:\n            yield self._content[i]\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.IndexedArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[:len(self._index.shape)], where[len(self._index.shape):]\n\n        head = self._index[head]\n        if len(head.shape) != 0 and len(head) == 0:\n            return self.numpy.empty(0, dtype=self._content.dtype)[tail]\n        else:\n            return self._content[(head,) + tail]\n\n    def _invert(self, what):\n        if self._inverse is None:\n            self._inverse = self.invert(self._index)\n        return IndexedArray(self._inverse, what)\n\n    def __setitem__(self, where, what):\n        if what.shape[:len(self._index.shape)] != self._index.shape:\n            raise ValueError(""array to assign does not have the same starting shape as index"")\n\n        if isinstance(where, awkward.util.string):\n            self._content[where] = self._invert(what)\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for x, y in zip(where, what):\n                self._content[x] = self._invert(y)\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], IndexedArray):\n                inputs[i]._valid()\n                inputs[i] = inputs[i][:]\n\n        return getattr(ufunc, method)(*inputs, **kwargs)\n\n    @property\n    def counts(self):\n        self._valid()\n        return self._util_counts(self._content[self._index])\n\n    def boolmask(self, maskedwhen=True):\n        self._valid()\n        return self._util_boolmask(self._content[self._index], maskedwhen)\n\n    def choose(self, n):\n        self._valid()\n        return self._content[self._index].choose(n)\n\n    def argchoose(self, n):\n        self._valid()\n        return self._content[self._index].argchoose(n)\n\n    def distincts(self, nested=False):\n        self._valid()\n        return self._content[self._index].distincts(nested=nested)\n\n    def argdistincts(self, nested=False):\n        self._valid()\n        return self._content[self._index].argdistincts(nested=nested)\n\n    def pairs(self, nested=False):\n        self._valid()\n        return self._content[self._index].pairs(nested=nested)\n\n    def argpairs(self, nested=False):\n        self._valid()\n        return self._content[self._index].argpairs(nested=nested)\n\n    def cross(self, other, nested=False):\n        self._valid()\n        return self._content[self._index].cross(other, nested=nested)\n\n    def argcross(self, other, nested=False):\n        self._valid()\n        return self._content[self._index].argcross(other, nested=nested)\n\n    def flattentuple(self):\n        self._valid()\n        return self.copy(content=self._util_flattentuple(self._content))\n\n    def flatten(self, axis=0):\n        self._valid()\n        return self._util_flatten(self._content[self._index], axis)\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self._util_pad(self._content[self._index], length, maskedwhen, clip, axis)\n\n    def regular(self):\n        self._valid()\n        return self._util_regular(self._content[self._index])\n\n    def _reduce(self, ufunc, identity, dtype):\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content._reduce(ufunc, identity, dtype))\n\n        elif isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents={})\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)\n            return out._reduce(ufunc, identity, dtype)\n\n        else:\n            prepared = self._prepare(ufunc, identity, dtype)\n            if ufunc is None:\n                return (1 - self.numpy.isnan(prepared)).sum()\n            elif ufunc is self.numpy.count_nonzero:\n                return (1 - (prepared == 0)).sum()\n            if issubclass(prepared.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n                prepared = self.numpy.where(self.numpy.isnan(prepared), identity, prepared)\n            return ufunc.reduce(prepared)\n\n    def _prepare(self, ufunc, identity, dtype):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self._content[self._index]\n        else:\n            return self._content._prepare(ufunc, identity, dtype)[self._index]\n\n    def argmin(self):\n        return self._content[self._index].argmin()\n\n    def argmax(self):\n        return self._content[self._index].argmax()\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, IndexedArray) for x in arrays)\n\n        indexes = []\n        offset = 0\n        for x in arrays:\n            indexes.append(x._index + offset)\n            offset += len(x._content)\n        index = cls.numpy.concatenate(indexes)\n\n        content = awkward.array.base.AwkwardArray.concatenate([x._content for x in arrays], axis=0)\n\n        return cls(index, content)\n\n    _topandas_name = ""IndexedSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n\nclass SparseArray(awkward.array.base.AwkwardArrayWithContent):\n    """"""\n    SparseArray\n    """"""\n\n    # TODO for 1.0: replace length with an indexshape\n\n    def __init__(self, length, index, content, default=None):\n        self.length = length\n        self.index = index\n        self.content = content\n        self.default = default\n\n    def copy(self, length=None, index=None, content=None, default=None):\n        out = self.__class__.__new__(self.__class__)\n        out._length = self._length\n        out._index = self._index\n        out._content = self._content\n        out._default = self._default\n        out._inverse = self._inverse\n        out._isvalid = self._isvalid\n        if length is not None:\n            out.length = length\n        if index is not None:\n            out.index = index\n        if content is not None:\n            out.content = content\n        if default is not None:\n            out.default = default\n        return out\n\n    def deepcopy(self, length=None, index=None, content=None, default=None):\n        out = self.copy(length=length, index=index, content=content, default=default)\n        out._index = self._util_deepcopy(out._index)\n        out._content = self._util_deepcopy(out._content)\n        out._inverse = self._util_deepcopy(out._inverse)\n        return out\n\n    def empty_like(self, **overrides):\n        mine = {}\n        mine = overrides.pop(""length"", self._length)\n        mine = overrides.pop(""default"", self._default)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.empty_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.empty_like(**overrides), **mine)\n\n    def zeros_like(self, **overrides):\n        mine = {}\n        mine = overrides.pop(""length"", self._length)\n        mine = overrides.pop(""default"", self._default)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.zeros_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.zeros_like(**overrides), **mine)\n\n    def ones_like(self, **overrides):\n        mine = {}\n        mine = overrides.pop(""length"", self._length)\n        mine = overrides.pop(""default"", self._default)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.ones_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.ones_like(**overrides), **mine)\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""SparseArray""],\n            {""json"": int(self._length)},\n            serializer(self._index, ""SparseArray.index""),\n            serializer(self._content, ""SparseArray.content""),\n            serializer(self._default, ""SparseArray.default""),\n        )\n\n    @property\n    def length(self):\n        return self._length\n\n    @length.setter\n    def length(self, value):\n        if self.check_prop_valid:\n            if not self._util_isinteger(value):\n                raise TypeError(""length must be an integer"")\n            if value < 0:\n                raise ValueError(""length must be a non-negative integer"")\n        self._length = value\n\n    @property\n    def index(self):\n        return self._index\n\n    @index.setter\n    def index(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""index must have integer dtype"")\n            if len(value.shape) != 1:\n                raise ValueError(""index must be one-dimensional"")\n            if (value < 0).any():\n                raise ValueError(""index must be a non-negative array"")\n            if len(value) > 0 and not (value[1:] >= value[:-1]).all():\n                raise ValueError(""index must be monatonically increasing"")\n        self._index = value\n        self._inverse = None\n        self._isvalid = False\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n        self._isvalid = False\n\n    @property\n    def default(self):\n        import awkward.array.jagged\n\n        if self._default is None:\n            if isinstance(self._content, awkward.array.jagged.JaggedArray):\n                return self.JaggedArray([0], [0], self._content.content)\n            elif self._content.shape[1:] == ():\n                return self._content.dtype.type(0)\n            else:\n                return self.numpy.zeros(self._content.shape[1:], dtype=self._content.dtype)\n\n        else:\n            return self._default\n\n        self._isvalid = False\n\n    @default.setter\n    def default(self, value):\n        self._default = value\n\n    def _gettype(self, seen):\n        return awkward.type._fromarray(self._content, seen)\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._index, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (1,), seen, lookup)\n        return (awkward.type.LayoutArg(""length"", self._length),\n                awkward.type.LayoutArg(""index"", position + (0,)),\n                awkward.type.LayoutArg(""content"", position + (1,)),\n                awkward.type.LayoutArg(""default"", self._default))\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return self._index.nbytes + (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n\n    def __len__(self):\n        return self._length\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                if len(self._index) > len(self._content):\n                    raise ValueError(""length of index ({0}) must not be greater than the length of content ({1})"".format(len(self._index), len(self._content)))\n\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n\n        length = self._length\n        index = self._index\n        lenindex = len(self._index)\n        content = self._content\n        default = self.default\n\n        i = 0\n        j = self.numpy.searchsorted(index, 0, side=""left"")\n        while i != length:\n            if j == lenindex:\n                yield default\n            elif index[j] == i:\n                yield content[j]\n                while j != lenindex and index[j] == i:\n                    j += 1\n            else:\n                yield default\n            i += 1\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.SparseArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if self._util_isinteger(head):\n            original_head = head\n            if head < 0:\n                head += self._length\n            if not 0 <= head < self._length:\n                raise IndexError(""index {0} is out of bounds for size {1}"".format(original_head, length))\n\n            match = self.numpy.searchsorted(self._index, head, side=""left"")\n\n            if match < len(self._index) and self._index[match] == head:\n                return self._content[(match,) + tail]\n            elif tail == ():\n                return self.default\n            else:\n                return self.default[tail]\n\n        elif isinstance(head, slice):\n            start, stop, step = head.indices(self._length)\n\n            if step == 0:\n                raise ValueError(""slice step cannot be zero"")\n            elif step > 0:\n                mask = (self._index < stop)\n                mask &= (self._index >= start)\n                index = self._index - start\n            elif step < 0:\n                mask = (self._index > stop)\n                mask &= (self._index <= start)\n                index = start - self._index\n\n            if (step > 0 and stop - start > 0) or (step < 0 and stop - start < 0):\n                d, m = divmod(abs(start - stop), abs(step))\n                length = d + (1 if m != 0 else 0)\n            else:\n                length = 0\n\n            if abs(step) > 1:\n                index, remainder = self.numpy.divmod(index, abs(step))\n                mask[remainder != 0] = False\n\n            index = index[mask]\n            content = self._content[mask]\n            if step < 0:\n                index = index[::-1]\n                content = content[::-1]\n\n            return self.copy(length=length, index=index, content=content)[tail]\n\n        elif isinstance(head, SparseArray) and len(head.shape) == 1 and issubclass(head.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n            head._valid()\n            if self._length != head._length:\n                raise IndexError(""boolean index did not match indexed array along dimension 0; dimension is {0} but corresponding boolean dimension is {1}"".format(self._length, head._length))\n\n            # the new index is a cumsum (starting at zero) of the boolean values\n            index = self.numpy.cumsum(head._content)\n            length = index[-1]\n            index[1:] = index[:-1]\n            index[0] = 0\n\n            # find my sparse elements in the mask\'s sparse elements\n            match1 = self.numpy.searchsorted(head._index, self._index, side=""left"")\n            match1[match1 >= len(head._index)] = len(head._index) - 1\n            content = self._content[self.numpy.logical_and(head._index[match1] == self._index, head._content[match1])]\n\n            # find the mask\'s sparse elements in my sparse elements\n            match2 = self.numpy.searchsorted(self._index, head._index, side=""left"")\n            match2[match2 >= len(head._index)] = len(head._index) - 1\n            index = index[self.numpy.logical_and(self._index[match2] == head._index, head._content)]\n\n            return self.copy(length=length, index=index, content=content)\n\n        else:\n            head = self._util_toarray(head, self.INDEXTYPE)\n            if len(head.shape) == 1 and issubclass(head.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                if self._length != len(head):\n                    raise IndexError(""boolean index did not match indexed array along dimension 0; dimension is {0} but corresponding boolean dimension is {1}"".format(self._length, len(head)))\n\n                head = self.numpy.arange(self._length, dtype=self.INDEXTYPE)[head]\n\n            if len(head.shape) == 1 and self._util_isintegertype(head.dtype.type):\n                mask = (head < 0)\n                if mask.any():\n                    head[mask] += self._length\n                if (head < 0).any() or (head >= self._length).any():\n                    raise IndexError(""indexes out of bounds for size {0}"".format(self._length))\n\n                match = self.numpy.searchsorted(self._index, head, side=""left"")\n                match[match >= len(self._index)] = len(self._index) - 1\n                explicit = (self._index[match] == head)\n\n                tags = self.numpy.zeros(len(head), dtype=self.TAGTYPE)\n                index = self.numpy.zeros(len(head), dtype=self.INDEXTYPE)\n                tags[explicit] = 1\n                index[explicit] = self.numpy.arange(self.numpy.count_nonzero(explicit))\n\n                content = self._content[match[explicit]]\n                default = self.numpy.array([self.default])\n                return self.UnionArray(tags, index, [default, content])[tail]\n\n            else:\n                raise TypeError(""cannot interpret shape {0}, dtype {1} as a fancy index or mask"".format(head.shape, head.dtype))\n\n    def _getinverse(self):\n        if self._inverse is None:\n            self._inverse = self.numpy.searchsorted(self._index, self.numpy.arange(self._length, dtype=self.INDEXTYPE), side=""left"")\n            if len(self._index) > 0:\n                self._inverse[self._index[-1] + 1 :] = len(self._index) - 1\n        return self._inverse\n\n    @property\n    def dense(self):\n        self._valid()\n\n        if isinstance(self._content, self.numpy.ndarray):\n            out = self.numpy.full(self.shape, self.default, dtype=self.dtype)\n            if len(self._index) != 0:\n                mask = self.boolmask(maskedwhen=True)\n                out[mask] = self._content[self._inverse[mask]]\n            return out\n\n        else:\n            raise NotImplementedError(type(self._content))\n\n    def boolmask(self, maskedwhen=True):\n        self._valid()\n\n        if len(self._index) == 0:\n            return self.numpy.empty(0, dtype=self.numpy.bool_)\n\n        if maskedwhen:\n            return self._index[self._getinverse()] == self.numpy.arange(self._length, dtype=self.INDEXTYPE)\n        else:\n            return self._index[self._getinverse()] != self.numpy.arange(self._length, dtype=self.INDEXTYPE)\n\n    def _invert(self, what):\n        if len(what) != self._length:\n            raise ValueError(""cannot assign array of length {0} to sparse table of length {1}"".format(len(what), self._length))\n\n        test = what[self.boolmask(maskedwhen=False)].any()\n        while not isinstance(test, bool):\n            test = test.any()\n\n        if test:\n            raise ValueError(""cannot assign an array with non-zero elements in the undefined spots of a sparse table"")\n\n        return IndexedArray(self._inverse, what)\n\n    def __setitem__(self, where, what):\n        if isinstance(where, awkward.util.string):\n            self._content[where] = self._invert(what)\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for x, y in zip(where, what):\n                self._content[x] = self._invert(y)\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], SparseArray):\n                inputs[i]._valid()\n                inputs[i] = inputs[i].dense   # FIXME: can do better (optimization)\n\n        return getattr(ufunc, method)(*inputs, **kwargs)\n\n    @property\n    def counts(self):\n        self._valid()\n        content = self._util_counts(self._content)\n        try:\n            defaultlen = len(self.default)\n        except:\n            defaultlen = -1\n        out = self.numpy.full(self.shape, defaultlen, dtype=content.dtype)\n        if len(self._index) != 0:\n            mask = self.boolmask(maskedwhen=True)\n            out[mask] = content[self._inverse[mask]]\n        return out\n\n    def flattentuple(self):\n        self._valid()\n        return self.copy(content=self._util_flattentuple(self._content))\n\n    def flatten(self, axis=0):\n        self._valid()\n        out = self._util_flatten(self._content, axis)\n        out = self.numpy.full(self.shape, self.default, dtype=content.dtype)\n        if len(self._index) != 0:\n            mask = self.boolmask(maskedwhen=True)\n            out[mask] = content[self._inverse[mask]]\n        return out\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self._util_pad(self._content.dense, length, maskedwhen, clip, axis)\n\n    def regular(self):\n        self._valid()\n        content = self._util_regular(self._content)\n        out = self.numpy.full(self.shape, self.default, dtype=content.dtype)\n        if len(self._index) != 0:\n            mask = self.boolmask(maskedwhen=True)\n            out[mask] = content[self._inverse[mask]]\n        return out\n\n    def _reduce(self, ufunc, identity, dtype):\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content._reduce(ufunc, identity, dtype))\n\n        elif isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents={})\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)\n            return out._reduce(ufunc, identity, dtype)\n\n        else:\n            prepared = self._prepare(ufunc, identity, dtype)\n            if ufunc is None:\n                return (1 - self.numpy.isnan(prepared)).sum()\n            elif ufunc is self.numpy.count_nonzero:\n                return (1 - (prepared == 0)).sum()\n            if issubclass(prepared.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n                prepared = self.numpy.where(self.numpy.isnan(prepared), identity, prepared)\n            return ufunc.reduce(prepared)\n\n    def _prepare(self, ufunc, identity, dtype):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.dense\n        else:\n            return self.copy(content=self._content._prepare(ufunc, identity, dtype)).dense\n\n    def argmin(self):\n        return self.dense.argmin()\n\n    def argmax(self):\n        return self.dense.argmax()\n\n    _topandas_name = ""SparseSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n'"
awkward/array/jagged.py,21,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport functools\nimport math\nimport numbers\nimport operator\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport awkward.array.base\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nclass JaggedArray(awkward.array.base.AwkwardArrayWithContent):\n    """"""\n    JaggedArray\n    """"""\n\n    @classmethod\n    def offsetsaliased(cls, starts, stops):\n        return (isinstance(starts, cls.numpy.ndarray) and isinstance(stops, cls.numpy.ndarray) and\n                starts.base is not None and stops.base is not None and starts.base is stops.base and\n                starts.ctypes.data == starts.base.ctypes.data and\n                stops.ctypes.data == stops.base.ctypes.data + stops.dtype.itemsize and\n                len(starts) == len(starts.base) - 1 and\n                len(stops) == len(stops.base) - 1)\n\n    @classmethod\n    def counts2offsets(cls, counts):\n        offsets = cls.numpy.empty(len(counts) + 1, dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n        offsets[0] = 0\n        cls.numpy.cumsum(counts, out=offsets[1:])\n        return offsets\n\n    @classmethod\n    def offsets2parents(cls, offsets):\n        dtype = cls.JaggedArray.fget(None).INDEXTYPE\n        counts = cls.numpy.diff(cls.numpy.r_[dtype.type(0), offsets])  # numpy >= 1.16: diff prepend\n        indices = cls.numpy.arange(-1, len(offsets) - 1, dtype=dtype)\n        return cls.numpy.repeat(indices, awkward.util.windows_safe(counts))\n\n    @classmethod\n    def startsstops2parents(cls, starts, stops):\n        assert starts.shape == stops.shape\n        starts = starts.reshape(-1)  # flatten in case multi-d jagged\n        stops = stops.reshape(-1)\n        dtype = cls.JaggedArray.fget(None).INDEXTYPE\n        out = cls.numpy.full(stops.max(), -1, dtype=dtype)\n        indices = cls.numpy.arange(len(starts), dtype=dtype)\n        counts = stops - starts\n        parents = cls.numpy.repeat(indices, awkward.util.windows_safe(counts))\n        contiguous_offsets = cls.JaggedArray.fget(None).counts2offsets(counts)\n        content_indices = cls.numpy.arange(contiguous_offsets[-1])\n        content_indices -= cls.numpy.repeat(contiguous_offsets[:-1], awkward.util.windows_safe(counts))\n        content_indices += starts[parents]\n        cls.numpy.put(out, awkward.util.windows_safe(content_indices), parents)\n        return out\n\n    @classmethod\n    def parents2startsstops(cls, parents, length=None):\n        # FIXME for 1.0: use length to add empty lists at the end of the jagged array or truncate\n        # assumes that children are contiguous, but not necessarily in order or fully covering (allows empty lists)\n        tmp = cls.numpy.nonzero(parents[1:] != parents[:-1])[0] + 1\n        changes = cls.numpy.empty(len(tmp) + 2, dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n        changes[0] = 0\n        changes[-1] = len(parents)\n        changes[1:-1] = tmp\n\n        length = parents.max() + 1 if len(parents) > 0 else 0\n        starts = cls.numpy.zeros(length, dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n        counts = cls.numpy.zeros(length, dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n\n        where = parents[changes[:-1]]\n        real = (where >= 0)\n\n        starts[where[real]] = (changes[:-1])[real]\n        counts[where[real]] = (changes[1:] - changes[:-1])[real]\n\n        return starts, starts + counts\n\n    @classmethod\n    def uniques2offsetsparents(cls, uniques):\n        # assumes that children are contiguous, in order, and fully covering (can\'t have empty lists)\n        # values are ignored, apart from uniqueness\n        changes = cls.numpy.nonzero(uniques[1:] != uniques[:-1])[0] + 1\n\n        offsets = cls.numpy.empty(len(changes) + 2, dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n        offsets[0] = 0\n        offsets[-1] = len(uniques)\n        offsets[1:-1] = changes\n\n        parents = cls.numpy.zeros(len(uniques), dtype=cls.JaggedArray.fget(None).INDEXTYPE)\n        parents[changes] = 1\n        cls.numpy.cumsum(parents, out=parents)\n\n        return offsets, parents\n\n    def __init__(self, starts, stops, content):\n        if self.offsetsaliased(starts, stops):\n            self.content = content\n            self._starts, self._stops = starts, stops\n            self._offsets = starts.base\n            self._counts, self._parents = None, None\n            self._isvalid = False\n\n            if not self._util_isintegertype(self._offsets.dtype.type):\n                raise TypeError(""offsets must have integer dtype"")\n            if len(self._offsets.shape) != 1:\n                raise ValueError(""offsets must be a one-dimensional array"")\n            if len(self._offsets) == 0:\n                raise ValueError(""offsets must be a non-empty array"")\n            if (self._offsets < 0).any():\n                raise ValueError(""offsets must be a non-negative array"")\n\n        else:\n            self.starts = starts\n            self.stops = stops\n            self.content = content\n\n    @classmethod\n    def fromiter(cls, iterable):\n        import awkward.generate\n        if len(iterable) == 0:\n            return cls.JaggedArray.fget(None)([], [], [])\n        else:\n            return awkward.generate.fromiter(iterable, awkwardlib=cls.awkward.fget(None))\n\n    @classmethod\n    def fromoffsets(cls, offsets, content):\n        offsets = cls._util_toarray(offsets, cls.INDEXTYPE, cls.numpy.ndarray)\n        if hasattr(offsets.base, \'base\') and type(offsets.base.base).__module__ == ""pyarrow.lib"" and type(offsets.base.base).__name__ == ""Buffer"":\n            # special exception to prevent copy in awkward.fromarrow\n            pass\n        elif offsets.base is not None:\n            # We rely on the starts,stops slices to be views.\n            # If offsets is already a view, the base will not be offsets but its underlying base.\n            # Make a copy to prevent that\n            offsets = offsets.copy()\n        return cls(offsets[:-1], offsets[1:], content)\n\n    @classmethod\n    def fromcounts(cls, counts, content):\n        counts = cls._util_toarray(counts, cls.INDEXTYPE, cls.numpy.ndarray)\n        if not cls._util_isintegertype(counts.dtype.type):\n            raise TypeError(""counts must have integer dtype"")\n        if (counts < 0).any():\n            raise ValueError(""counts must be a non-negative array"")\n        offsets = cls.counts2offsets(counts.reshape(-1))\n        out = cls(offsets[:-1].reshape(counts.shape), offsets[1:].reshape(counts.shape), content)\n        out._offsets = offsets if len(counts.shape) == 1 else None\n        out._counts = counts\n        return out\n\n    @classmethod\n    def fromparents(cls, parents, content, length=None):\n        parents = cls._util_toarray(parents, cls.INDEXTYPE, cls.numpy.ndarray)\n        if not cls._util_isintegertype(parents.dtype.type):\n            raise TypeError(""parents must have integer dtype"")\n        if len(parents.shape) != 1 or len(parents) != len(content):\n            raise ValueError(""parents array must be one-dimensional with the same length as content"")\n        starts, stops = cls.parents2startsstops(parents, length=length)\n        out = cls(starts, stops, content)\n        out._parents = parents\n        return out\n\n    @classmethod\n    def fromuniques(cls, uniques, content):\n        uniques = cls._util_toarray(uniques, cls.INDEXTYPE, cls.numpy.ndarray)\n        if not cls._util_isintegertype(uniques.dtype.type):\n            raise TypeError(""uniques must have integer dtype"")\n        if len(uniques.shape) != 1 or len(uniques) != len(content):\n            raise ValueError(""uniques array must be one-dimensional with the same length as content"")\n        offsets, parents = cls.uniques2offsetsparents(uniques)\n        out = cls.fromoffsets(offsets, content)\n        out._parents = parents\n        return out\n\n    @classmethod\n    def fromlocalindex(cls, index, content, validate=True):\n        index = cls._util_toarray(index, cls.INDEXTYPE, (cls.numpy.ndarray, JaggedArray))\n        original_counts = None\n        if isinstance(index, JaggedArray):\n            if validate:\n                original_counts = index.counts\n            index = index.flatten()\n\n        if not cls._util_isintegertype(index.dtype.type):\n            raise TypeError(""localindex must have integer dtype"")\n        if len(index.shape) != 1 or len(index) != len(content):\n            raise ValueError(""localindex array must be one-dimensional with the same length as content"")\n\n        if validate:\n            if not ((index[1:] - index[:-1])[(index != 0)[1:]] == 1).all():\n                raise ValueError(""every localindex that is not zero must be one greater than the previous"")\n\n        starts = cls.numpy.nonzero(index == 0)[0]\n        offsets = cls.numpy.empty(len(starts) + 1, dtype=cls.INDEXTYPE)\n        offsets[:-1] = starts\n        offsets[-1] = len(index)\n        if original_counts is not None:\n            if not cls.numpy.array_equal(offsets[1:] - starts, original_counts):\n                raise ValueError(""jagged structure of index does not match jagged structure derived from localindex"")\n\n        return cls.fromoffsets(offsets, content)\n\n    @classmethod\n    def fromjagged(cls, jagged):\n        return cls(jagged._starts, jagged._stops, jagged._content)\n\n    @classmethod\n    def fromregular(cls, regular):\n        regular = cls._util_toarray(regular, cls.DEFAULTTYPE, cls.numpy.ndarray)\n        shape = regular.shape\n        if len(shape) <= 1:\n            raise ValueError(""regular array must have more than one dimension"")\n        out = regular.reshape(-1)\n        for x in shape[:0:-1]:\n            out = cls.fromfolding(out, x)\n        return out\n\n    @classmethod\n    def fromfolding(cls, content, size):\n        content = cls._util_toarray(content, cls.DEFAULTTYPE)\n        quotient = -(-len(content) // size)\n        offsets = cls.numpy.arange(0, quotient * size + 1, size, dtype=cls.INDEXTYPE)\n        if len(offsets) > 0:\n            offsets[-1] = len(content)\n        return cls.fromoffsets(offsets, content)\n\n    def copy(self, starts=None, stops=None, content=None):\n        out = self.__class__.__new__(self.__class__)\n        out._starts  = self._starts\n        out._stops   = self._stops\n        out._content = self._content\n        out._offsets = self._offsets\n        out._counts  = self._counts\n        out._parents = self._parents\n        out._isvalid = self._isvalid\n        if starts is not None:\n            out.starts = starts\n        if stops is not None:\n            out.stops = stops\n        if content is not None:\n            out.content = content\n        return out\n\n    def deepcopy(self, starts=None, stops=None, content=None):\n        out = self.copy(starts=starts, stops=stops, content=content)\n        out._starts  = self._util_deepcopy(out._starts)\n        out._stops   = self._util_deepcopy(out._stops)\n        out._content = self._util_deepcopy(out._content)\n        out._offsets = self._util_deepcopy(out._offsets)\n        out._counts  = self._util_deepcopy(out._counts)\n        out._parents = self._util_deepcopy(out._parents)\n        return out\n\n    def empty_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.empty_like(self._content))\n        else:\n            return self.copy(content=self._content.empty_like(**overrides))\n\n    def zeros_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.zeros_like(self._content))\n        else:\n            return self.copy(content=self._content.zeros_like(**overrides))\n\n    def ones_like(self, **overrides):\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.ones_like(self._content))\n        else:\n            return self.copy(content=self._content.ones_like(**overrides))\n\n    def __awkward_serialize__(self, serializer):\n        if self._canuseoffset() and len(self) > 0:\n            return serializer.encode_call(\n                [""awkward"", ""JaggedArray"", ""fromcounts""],\n                serializer(self.counts, ""JaggedArray.counts""),\n                serializer(self._content[self._starts[0]:self._stops[-1]], ""JaggedArray.content""),\n            )\n        else:\n            return serializer.encode_call(\n                [""awkward"", ""JaggedArray""],\n                serializer(self._starts, ""JaggedArray.starts""),\n                serializer(self._stops, ""JaggedArray.stops""),\n                serializer(self._content, ""JaggedArray.content""),\n            )\n\n    @property\n    def starts(self):\n        return self._starts\n\n    @starts.setter\n    def starts(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""starts must have integer dtype"")\n            if len(value.shape) == 0:\n                raise ValueError(""starts must have at least one dimension"")\n            if (value < 0).any():\n                raise ValueError(""starts must be a non-negative array"")\n        self._starts = value\n        self._offsets, self._counts, self._parents = None, None, None\n        self._isvalid = False\n\n    @property\n    def stops(self):\n        if len(self._stops) == len(self._starts):\n            return self._stops\n        else:\n            return self._stops[:len(self._starts)]\n\n    @stops.setter\n    def stops(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""stops must have integer dtype"")\n            if len(value.shape) == 0:\n                raise ValueError(""stops must have at least one dimension"")\n            if (value < 0).any():\n                raise ValueError(""stops must be a non-negative array"")\n        self._stops = value\n        self._offsets, self._counts, self._parents = None, None, None\n        self._isvalid = False\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n        self._isvalid = False\n\n    @property\n    def offsets(self):\n        if self._offsets is None:\n            self._valid()\n            if self.offsetsaliased(self._starts, self._stops):\n                self._offsets = self._starts.base\n            elif len(self._starts.shape) == 1 and self.numpy.array_equal(self._starts[1:], self._stops[:-1]):\n                if len(self._stops) == 0:\n                    return self.numpy.array([0], dtype=self.INDEXTYPE)\n                else:\n                    self._offsets = self.numpy.append(self._starts, self._stops[-1])\n            else:\n                raise ValueError(""starts and stops are not compatible with a single offsets array"")\n        return self._offsets\n\n    @offsets.setter\n    def offsets(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""offsets must have integer dtype"")\n            if len(value.shape) != 1 or (value < 0).any():\n                raise ValueError(""offsets must be a one-dimensional, non-negative array"")\n            if len(value) == 0:\n                raise ValueError(""offsets must be non-empty"")\n        self._starts = value[:-1]\n        self._stops = value[1:]\n        self._offsets = value\n        self._counts, self._parents = None, None\n        self._isvalid = False\n\n    @property\n    def counts(self):\n        if self._counts is None:\n            self._valid()\n            self._counts = self.stops - self._starts\n        return self._counts\n\n    @counts.setter\n    def counts(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""counts must have integer dtype"")\n            if len(value.shape) == 0:\n                raise ValueError(""counts must have at least one dimension"")\n            if (value < 0).any():\n                raise ValueError(""counts must be a non-negative array"")\n        offsets = self.counts2offsets(value.reshape(-1))\n        self._starts = offsets[:-1].reshape(value.shape)\n        self._stops = offsets[1:].reshape(value.shape)\n        self._offsets = offsets if len(value.shape) == 1 else None\n        self._counts = value\n        self._parents = None\n        self._isvalid = False\n\n    @property\n    def parents(self):\n        if self._parents is None:\n            self._valid()\n            if self._canuseoffset():\n                self._parents = self.offsets2parents(self.offsets)\n            else:\n                self._parents = self.startsstops2parents(self._starts, self._stops)\n        return self._parents\n\n    @parents.setter\n    def parents(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""parents must have integer dtype"")\n            if len(value.shape) == 0:\n                raise ValueError(""parents must have at least one dimension"")\n        self._starts, self._stops = self.parents2startsstops(value)\n        self._offsets, self._counts = None, None\n        self._parents = value\n\n    @property\n    def localindex(self):\n        if len(self) == 0:\n            return self.JaggedArray([], [], self.numpy.array([], dtype=self.INDEXTYPE))\n        elif self._canuseoffset():\n            out = self.numpy.arange(self.offsets[0], self.offsets[-1], dtype=self.INDEXTYPE)\n            out -= self.offsets[self.parents[self.parents >= 0]]\n            return self.JaggedArray.fromoffsets(self.offsets - self.offsets[0], out)\n        else:\n            counts = self.counts.reshape(-1)  # flatten in case multi-d jagged\n            offsets = self.counts2offsets(counts)\n            out = self.numpy.arange(offsets[-1], dtype=self.INDEXTYPE)\n            out -= self.numpy.repeat(offsets[:-1], awkward.util.windows_safe(counts))\n            return self.JaggedArray(offsets[:-1].reshape(self.shape), offsets[1:].reshape(self.shape), out)\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            if self.offsetsaliased(self._starts, self._stops):\n                return self._starts.base.nbytes + (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n            else:\n                return self._starts.nbytes + self._stops.nbytes + (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n\n    def __len__(self):\n        return len(self._starts)\n\n    def _gettype(self, seen):\n        return awkward.type.ArrayType(*(self._starts.shape[1:] + (self.numpy.inf, awkward.type._fromarray(self._content, seen))))\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._starts, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._stops, position + (1,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (2,), seen, lookup)\n        return (awkward.type.LayoutArg(""starts"", position + (0,)),\n                awkward.type.LayoutArg(""stops"", position + (1,)),\n                awkward.type.LayoutArg(""content"", position + (2,)))\n\n    def _valid(self):\n        if not self._isvalid:\n            if self.offsetsaliased(self._starts, self._stops):\n                self._offsets = self._starts.base\n                if self.check_whole_valid:\n                    if not (self._offsets[1:] >= self._offsets[:-1]).all():\n                        raise ValueError(""offsets must be monatonically increasing"")\n                    if self._offsets.max() > len(self._content):\n                        raise ValueError(""maximum offset {0} is beyond the length of the content ({1})"".format(self._offsets.max(), len(self._content)))\n\n            else:\n                if self.check_whole_valid:\n                    self._validstartsstops(self._starts, self._stops)\n                nonempty = (self._starts != self._stops)\n                starts = self._starts[nonempty].reshape(-1)\n                if self.check_whole_valid:\n                    if len(starts) != 0 and starts.reshape(-1).max() >= len(self._content):\n                        raise ValueError(""maximum start ({0}) is at or beyond the length of the content ({1})"".format(starts.reshape(-1).max(), len(self._content)))\n                stops = self._stops[nonempty].reshape(-1)\n                if self.check_whole_valid:\n                    if len(stops) != 0 and stops.reshape(-1).max() > len(self._content):\n                        raise ValueError(""maximum stop ({0}) is beyond the length of the content ({1})"".format(self._stops.reshape(-1).max(), len(self._content)))\n\n            self._isvalid = True\n\n    @classmethod\n    def _validstartsstops(cls, starts, stops):\n        if cls.check_whole_valid:\n            if len(starts) > len(stops):\n                raise ValueError(""starts must have the same (or shorter) length than stops"")\n            if starts.shape[1:] != stops.shape[1:]:\n                raise ValueError(""starts and stops must have the same dimensionality (shape[1:])"")\n            if not (stops[:len(starts)] >= starts).all():\n                raise ValueError(""stops must be greater than or equal to starts"")\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n        if len(self._starts.shape) != 1:\n            for x in super(JaggedArray, self).__iter__(checkiter=checkiter):\n                yield x\n        else:\n            stops = self._stops\n            content = self._content\n            for i, start in enumerate(self._starts):\n                yield content[start:stops[i]]\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.JaggedArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            out.__doc__ = content.__doc__\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[:len(self._starts.shape)], where[len(self._starts.shape):]\n\n        if len(head) == 1 and isinstance(head[0], JaggedArray):\n            head = head[0]\n\n            if isinstance(self._content, JaggedArray) and isinstance(head._content, JaggedArray):\n                return self.copy(content=self._content[head._content])\n\n            elif self._util_isintegertype(head._content.dtype.type):\n                if len(head.shape) == 1 and head._starts.shape != self._starts.shape:\n                    raise ValueError(""jagged array used as index has a different shape {0} from the jagged array it is selecting from {1}"".format(head._starts.shape, self._starts.shape))\n\n                headoffsets = self.counts2offsets(head.counts)\n                head = head._tojagged(headoffsets[:-1], headoffsets[1:], copy=False)\n\n                counts = head.tojagged(self.counts)._content\n\n                indexes = self.numpy.array(head._content[:headoffsets[-1]], dtype=self.INDEXTYPE, copy=True)\n\n                negatives = (indexes < 0)\n                indexes[negatives] += counts[negatives]\n\n                if not self.numpy.bitwise_and(0 <= indexes, indexes < counts).all():\n                    raise IndexError(""jagged array used as index contains out-of-bounds values"")\n\n                indexes += head.tojagged(self._starts)._content\n\n                return self.copy(starts=head._starts, stops=head._stops, content=self._content[indexes])\n\n            elif len(head.shape) == 1 and issubclass(head._content.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                try:\n                    offsets = self.offsets\n                    thyself = self\n\n                except ValueError:\n                    offsets = self.counts2offsets(self.counts.reshape(-1))\n                    thyself = self._tojagged(offsets[:-1], offsets[1:], copy=False)\n                    thyself._starts.shape = self._starts.shape\n                    thyself._stops.shape = self._stops.shape\n\n                head = head._tojagged(thyself._starts, thyself._stops, copy=False)\n                inthead = head.copy(content=head._content.astype(self.INDEXTYPE))\n                intheadsum = inthead.sum()\n\n                offsets = self.counts2offsets(intheadsum)\n\n                headcontent = self.numpy.array(head._content, dtype=self.BOOLTYPE)\n\n                headcontent_indices_to_ignore = self.numpy.resize(head.parents < 0, headcontent.shape)\n                headcontent_indices_to_ignore[len(head.parents):] = True\n                headcontent[headcontent_indices_to_ignore] = False\n\n                original_headcontent_length = len(headcontent)\n                headcontent = self.numpy.resize(headcontent, thyself._content.shape)\n                headcontent[original_headcontent_length:] = False\n\n                return self.copy(starts=offsets[:-1].reshape(intheadsum.shape), stops=offsets[1:].reshape(intheadsum.shape), content=thyself._content[headcontent])\n\n            elif head.shape == self.shape and issubclass(head._content.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                index = self.localindex + self.starts\n                flatindex = index.flatten()[head.flatten()]\n                return type(self).fromcounts(head.sum(), self._content[flatindex])\n\n            else:\n                raise TypeError(""jagged index must be boolean (mask) or integer (fancy indexing)"")\n\n        else:\n            starts = self._starts[head]\n            stops = self._stops[head]\n            if len(starts.shape) == len(stops.shape) == 0:\n                return self._content[starts:stops][tail]\n            else:\n                node = self.copy(starts=starts, stops=stops)\n\n        head = head[-1]\n\n        nslices = 0\n        while isinstance(node, JaggedArray) and len(tail) > 0:\n            wasslice = isinstance(head, slice)\n            head, tail = tail[0], tail[1:]\n\n            original_head = head\n            if self._util_isinteger(head):\n                stack = []\n                for x in range(nslices):\n                    stack.insert(0, node.counts)\n                    node = node.flatten()\n\n                if isinstance(node, JaggedArray):\n                    counts = node.stops - node._starts\n                    if head < 0:\n                        head = counts + head\n                    if not self.numpy.bitwise_and(0 <= head, head < counts).all():\n                        raise IndexError(""index {0} is out of bounds for jagged min size {1}"".format(original_head, counts.min()))\n                    node = node._content[node._starts + head]\n                else:\n                    node = node[:, head]\n\n                for oldcounts in stack:\n                    node = type(self).fromcounts(oldcounts, node)\n\n            elif isinstance(head, slice):\n                nslices += 1\n                if nslices >= 2:\n                    raise NotImplementedError(""this implementation cannot slice a JaggedArray in more than two dimensions"")\n\n                # If we sliced down to an empty jagged array, take a shortcut\n                if len(node) == 0:\n                    return node\n\n                counts = node.stops - node._starts\n                step = 1 if head.step is None else head.step\n\n                if step == 0:\n                    raise ValueError(""slice step cannot be zero"")\n\n                elif step > 0:\n                    if head.start is None:\n                        starts = self.numpy.zeros(counts.shape, dtype=self.INDEXTYPE)\n                    elif head.start >= 0:\n                        starts = self.numpy.minimum(counts, head.start)\n                    else:\n                        starts = self.numpy.maximum(0, self.numpy.minimum(counts, counts + head.start))\n\n                    if head.stop is None:\n                        stops = counts\n                    elif head.stop >= 0:\n                        stops = self.numpy.minimum(counts, head.stop)\n                    else:\n                        stops = self.numpy.maximum(0, self.numpy.minimum(counts, counts + head.stop))\n\n                    stops = self.numpy.maximum(starts, stops)\n\n                    start = starts.min()\n                    stop = stops.max()\n                    indexes = self.numpy.empty((len(node), abs(stop - start)), dtype=self.INDEXTYPE)\n                    indexes[:, :] = self.numpy.arange(start, stop)\n\n                    mask = indexes >= starts.reshape((len(node), 1))\n                    self.numpy.bitwise_and(mask, indexes < stops.reshape((len(node), 1)), out=mask)\n                    if step != 1:\n                        self.numpy.bitwise_and(mask, self.numpy.remainder(indexes - starts.reshape((len(node), 1)), step) == 0, out=mask)\n\n                else:\n                    if head.start is None:\n                        starts = counts - 1\n                    elif head.start >= 0:\n                        starts = self.numpy.minimum(counts - 1, head.start)\n                    else:\n                        starts = self.numpy.maximum(-1, self.numpy.minimum(counts - 1, counts + head.start))\n\n                    if head.stop is None:\n                        stops = self.numpy.full(counts.shape, -1, dtype=self.INDEXTYPE)\n                    elif head.stop >= 0:\n                        stops = self.numpy.minimum(counts - 1, head.stop)\n                    else:\n                        stops = self.numpy.maximum(-1, self.numpy.minimum(counts - 1, counts + head.stop))\n\n                    stops = self.numpy.minimum(starts, stops)\n\n                    start = starts.max()\n                    stop = stops.min()\n                    indexes = self.numpy.empty((len(node), abs(stop - start)), dtype=self.INDEXTYPE)\n                    indexes[:, :] = self.numpy.arange(start, stop, -1)\n\n                    mask = indexes <= starts.reshape((len(node), 1))\n                    self.numpy.bitwise_and(mask, indexes > stops.reshape((len(node), 1)), out=mask)\n                    if step != -1:\n                        self.numpy.bitwise_and(mask, self.numpy.remainder(indexes - starts.reshape((len(node), 1)), step) == 0, out=mask)\n\n                newcounts = self.numpy.count_nonzero(mask, axis=1)\n                newoffsets = self.counts2offsets(newcounts.reshape(-1))\n                newcontent = node._content[(indexes + node._starts.reshape((len(node), 1)))[mask]]\n\n                node = node.copy(starts=newoffsets[:-1], stops=newoffsets[1:], content=newcontent)\n\n            else:\n                head = self.numpy.array(head, copy=False)\n                if len(head.shape) == 1 and self._util_isintegertype(head.dtype.type):\n                    if wasslice:\n                        stack = []\n                        for x in range(nslices):\n                            stack.insert(0, node.counts)\n                            node = node.flatten()\n\n                        index = self.numpy.tile(head, len(node))\n                        mask = (index < 0)\n                        if mask.any():\n                            pluscounts = (index.reshape(-1, len(head)) + node.counts.reshape(-1, 1)).reshape(-1)\n                            index[mask] = pluscounts[mask]\n                        if (index < 0).any() or (index.reshape(-1, len(head)) >= node.counts.reshape(-1, 1)).any():\n                            raise IndexError(""index in jagged subdimension is out of bounds"")\n                        index = (index.reshape(-1, len(head)) + node._starts.reshape(-1, 1)).reshape(-1)\n                        node = node._content[index]\n                        if isinstance(node, JaggedArray):\n                            node._starts = node._starts.reshape(-1, len(head))\n                            node._stops = node._stops.reshape(-1, len(head))\n                        elif isinstance(node, self.numpy.ndarray):\n                            node = node.reshape(-1, len(head))\n                        else:\n                            raise NotImplementedError\n\n                        for oldcounts in stack:\n                            node = type(self).fromcounts(oldcounts, node)\n\n                    else:\n                        if len(node) != len(head):\n                            raise IndexError(""shape mismatch: indexing arrays could not be broadcast together with shapes {0} {1}"".format(len(node), len(head)))\n                        index = head.copy() if head is original_head else head\n                        mask = (index < 0)\n                        if mask.any():\n                            index[mask] += head.counts\n                        if (index < 0).any() or (index >= node.counts).any():\n                            raise IndexError(""index in jagged subdimension is out of bounds"")\n                        index += node._starts\n                        node = node._content[index]\n\n                elif len(head.shape) == 1 and issubclass(head.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                    if wasslice:\n                        stack = []\n                        for x in range(nslices):\n                            stack.insert(0, node.counts)\n                            node = node.flatten()\n\n                        if len(node) != 0 and not (node.counts == len(head)).all():\n                            raise IndexError(""jagged subdimension is not regular and cannot match boolean shape {0}"".format(len(head)))\n                        head = self.numpy.nonzero(head)[0]\n                        index = self.numpy.tile(head, len(node))\n                        index = (index.reshape(-1, len(node)) + node._starts.reshape(-1, 1)).reshape(-1)\n                        node = node._content[index]\n                        if isinstance(node, JaggedArray):\n                            node._starts = node._starts.reshape(-1, len(head))\n                            node._stops = node._stops.reshape(-1, len(head))\n                        elif isinstance(node, self.numpy.ndarray):\n                            node = node.reshape(-1, len(head))\n                        else:\n                            raise NotImplementedError\n\n                        for oldcounts in stack:\n                            node = type(self).fromcounts(oldcounts, node)\n\n                    else:\n                        index = self.numpy.nonzero(head)[0]\n                        if len(node) != len(index):\n                            raise IndexError(""shape mismatch: indexing arrays could not be broadcast together with shapes {0} {1}"".format(len(node), len(index)))\n                        index += node._starts\n                        node = node._content[index]\n\n                else:\n                    raise TypeError(""cannot interpret shape {0}, dtype {1} as a fancy index or mask"".format(head.shape, head.dtype))\n\n            if isinstance(node, self.numpy.ndarray) and len(node.shape) < sum(0 if isinstance(x, slice) else 1 for x in tail):\n                raise IndexError(""IndexError: too many indices for array"")\n\n        return node[tail]\n\n    def __setitem__(self, where, what):\n        if isinstance(where, awkward.util.string):\n            self._content[where] = self.tojagged(what)._content\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for x, y in zip(where, what):\n                self._content[x] = self.tojagged(y)._content\n\n        elif isinstance(where, JaggedArray):\n            if isinstance(what, JaggedArray):\n                what = what.flatten()\n\n            if len(where.shape) == 1:\n                if where._starts.shape != self._starts.shape:\n                    raise ValueError(""jagged array used as index has a different shape {0} from the jagged array it is selecting from {1}"".format(where._starts.shape, self._starts.shape))\n            elif where.shape != self.shape:\n                raise ValueError(""jagged array used as index has a different shape {0} from the jagged array it is selecting from {1}"".format(where._starts.shape, self._starts.shape))\n\n            if self._util_isintegertype(where._content.dtype.type):\n\n                whereoffsets = self.counts2offsets(where.counts)\n                where = where._tojagged(whereoffsets[:-1], whereoffsets[1:], copy=False)\n\n                counts = where.tojagged(self.counts)._content\n\n                indexes = self.numpy.array(where._content[:whereoffsets[-1]], copy=True)\n\n                negatives = (indexes < 0)\n                indexes[negatives] += counts[negatives]\n\n                if not self.numpy.bitwise_and(0 <= indexes, indexes < counts).all():\n                    raise IndexError(""jagged array used as index contains out-of-bounds values"")\n\n                indexes += where.tojagged(self._starts)._content\n\n                self._content[indexes] = what\n\n            elif issubclass(where._content.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                index = self.localindex + self.starts\n                flatindex = index.flatten()[where.flatten()]\n                self._content[flatindex] = what\n\n            else:\n                raise TypeError(""jagged index must be boolean (mask) or integer (fancy indexing)"")\n\n        else:\n            raise TypeError(""invalid index for assigning to JaggedArray: {0}"".format(where))\n\n    def tojagged(self, data):\n        if isinstance(data, JaggedArray):\n            selfcounts = self.stops - self._starts\n            datacounts = data.stops - data._starts\n            if not self.numpy.array_equal(selfcounts, datacounts):\n                raise ValueError(""cannot broadcast JaggedArray to match JaggedArray with a different counts"")\n            if len(self._starts) == 0:\n                return self.copy(content=data._content)\n\n            tmp = self.compact()\n            tmpparents = self.offsets2parents(tmp.offsets)\n\n            index = self.JaggedArray(tmp._starts, tmp._stops, (self.numpy.arange(tmp._stops[-1], dtype=self.INDEXTYPE) - tmp._starts[tmpparents]))\n\n            data = data.compact()\n            return self.copy(content=data._content[self.IndexedArray.invert((index + self._starts)._content)])\n\n        elif isinstance(data, awkward.array.base.AwkwardArray):\n            if len(self._starts) != len(data):\n                raise ValueError(""cannot broadcast AwkwardArray to match JaggedArray with a different length"")\n            if len(self._starts) == 0:\n                return self.copy(content=data)\n            out = self.copy(content=data[self.parents])\n            out._parents = self.parents\n            return out\n\n        elif isinstance(data, self.numpy.ndarray):\n            content = self.numpy.empty(len(self.parents), dtype=data.dtype)\n            if len(data.shape) == 0 or (len(data.shape) == 1 and data.shape[0] == 1):\n                content[:] = data\n            else:\n                good = (self.parents >= 0)\n                content[good] = data[self.parents[good]]\n            out = self.copy(content=content)\n            out._parents = self.parents\n            return out\n\n        elif isinstance(data, Iterable):\n            return self.tojagged(self.numpy.array(data))\n\n        else:\n            return self.tojagged(self.numpy.array([data]))\n\n    def _tojagged(self, starts=None, stops=None, copy=True):\n        if starts is None and stops is None:\n            if copy:\n                starts, stops = self._util_deepcopy(self._starts), self._util_deepcopy(self._stops)\n            else:\n                starts, stops = self._starts, self._stops\n\n        elif stops is None:\n            starts = self._util_toarray(starts, self.INDEXTYPE)\n            if len(self) != len(starts):\n                raise ValueError(""cannot fit JaggedArray of length {0} into starts of length {1}"".format(len(self), len(starts)))\n\n            stops = starts + self.counts\n\n            if (stops[:-1] > starts[1:]).any():\n                raise ValueError(""cannot fit contents of JaggedArray into the given starts array"")\n\n        elif starts is None:\n            stops = self._util_toarray(stops, self.INDEXTYPE)\n            if len(self) != len(stops):\n                raise ValueError(""cannot fit JaggedArray of length {0} into stops of length {1}"".format(len(self), len(stops)))\n\n            starts = stops - self.counts\n\n            if (stops[:-1] > starts[1:]).any():\n                raise ValueError(""cannot fit contents of JaggedArray into the given stops array"")\n\n        else:\n            if not self.numpy.array_equal(stops - starts, self.counts):\n                raise ValueError(""cannot fit contents of JaggedArray into the given starts and stops arrays"")\n\n        self._validstartsstops(starts, stops)\n\n        if not copy and starts is self._starts and stops is self._stops:\n            return self\n\n        elif (starts is self._starts or self.numpy.array_equal(starts, self._starts)) and (stops is self._stops or self.numpy.array_equal(stops, self._stops)):\n            return self.copy(starts=starts, stops=stops, content=(self._util_deepcopy(self._content) if copy else self._content))\n\n        else:\n            if self.offsetsaliased(starts, stops):\n                parents = self.offsets2parents(starts.base)\n            elif len(starts.shape) == 1 and self.numpy.array_equal(starts[1:], stops[:-1]):\n                if len(stops) == 0:\n                    offsets = self.numpy.array([0], dtype=self.INDEXTYPE)\n                else:\n                    offsets = self.numpy.append(starts, stops[-1])\n                parents = self.offsets2parents(offsets)\n            else:\n                parents = self.startsstops2parents(starts, stops)\n\n            good = (parents >= 0)\n            increase = self.numpy.arange(len(parents), dtype=self.INDEXTYPE)\n            increase[good] -= increase[starts[parents[good]]]\n            index = self._starts[parents]\n            index += increase\n            index *= good\n            out = self.copy(starts=starts, stops=stops, content=self._content[index])\n            out._parents = parents\n            return out\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        import awkward.array.objects\n        import awkward.array.table\n\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        starts, stops = None, None\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], JaggedArray):\n                try:\n                    offsets = inputs[i].offsets   # calls _valid()\n                except ValueError:\n                    counts = inputs[i].counts\n                    offsets = self.counts2offsets(counts.reshape(-1))\n                    starts, stops = offsets[:-1], offsets[1:]\n                    starts = starts.reshape(counts.shape)\n                    stops = stops.reshape(counts.shape)\n                else:\n                    starts, stops = offsets[:-1], offsets[1:]\n\n        assert starts is not None and stops is not None\n\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], JaggedArray):\n                inputs[i] = inputs[i]._tojagged(starts, stops, copy=False)\n\n            elif isinstance(inputs[i], (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                pass\n\n            else:\n                try:\n                    for first in inputs[i]:\n                        break\n                except TypeError:\n                    pass\n                else:\n                    if ""first"" not in locals() or isinstance(first, (numbers.Number, self.numpy.bool_, self.numpy.bool, self.numpy.number)):\n                        inputs[i] = self.numpy.array(inputs[i], copy=False)\n                    else:\n                        inputs[i] = self.JaggedArray.fromiter(inputs[i])\n\n        for jaggedarray in inputs:\n            if isinstance(jaggedarray, JaggedArray):\n                starts, stops, parents, good = jaggedarray._starts, jaggedarray._stops, None, None\n                break\n        else:\n            assert False\n\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], (self.numpy.ndarray, awkward.array.base.AwkwardArray)) and not isinstance(inputs[i], JaggedArray):\n                data = self._util_toarray(inputs[i], inputs[i].dtype)\n                if starts.shape != data.shape:\n                    raise ValueError(""cannot broadcast JaggedArray of shape {0} with array of shape {1}"".format(starts.shape, data.shape))\n\n                if parents is None:\n                    parents = jaggedarray.parents\n                    if self._canuseoffset() and len(jaggedarray.starts) > 0 and jaggedarray.starts[0] == 0:\n                        good = None\n                    else:\n                        good = (parents >= 0)\n\n                def recurse(x):\n                    if isinstance(x, awkward.array.objects.ObjectArray):\n                        return x.copy(content=recurse(x.content))\n\n                    elif isinstance(x, awkward.array.table.Table):\n                        content = x.empty_like()\n                        for n in x.columns:\n                            content[n] = recurse(x[n])\n                        return content\n\n                    elif good is None:\n                        if len(x.shape) == 0:\n                            content = self.numpy.full(len(parents), x, dtype=x.dtype)\n                        else:\n                            content = x.reshape(-1)[parents]\n                        return content\n\n                    else:\n                        content = self.numpy.empty(len(parents), dtype=x.dtype)\n                        if len(x.shape) == 0:\n                            content[good] = x\n                        else:\n                            content[good] = x.reshape(-1)[parents[good]]\n                        return content\n\n                content = recurse(data)\n\n                inputs[i] = self.JaggedArray(starts, stops, content)\n\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], JaggedArray):\n                inputs[i] = inputs[i].flatten()\n\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        counts = stops - starts\n        if isinstance(result, tuple):\n            return tuple(self.Methods.maybemixin(type(x), self.JaggedArray).fromcounts(counts, x) if isinstance(x, (self.numpy.ndarray, awkward.array.base.AwkwardArray)) else x for x in result)\n        elif method == ""at"":\n            return None\n        else:\n            return self.Methods.maybemixin(type(result), self.JaggedArray).fromcounts(counts, result)\n\n    def regular(self):\n        self._valid()\n\n        if len(self) > 0 and not (self.counts.reshape(-1)[0] == self.counts).all():\n            raise ValueError(""jagged array is not regular: different elements have different counts"")\n        count = self.counts.reshape(-1)[0]\n        content = self._util_regular(self._content)\n\n        if self._canuseoffset():\n            out = content[self._starts[0]:self._stops[-1]]\n            return out.reshape(self._starts.shape + (count,) + content.shape[1:])\n\n        else:\n            indexes = self.numpy.repeat(self._starts, awkward.util.windows_safe(count)).reshape(self._starts.shape + (count,))\n            indexes += self.numpy.arange(count)\n            return content[indexes]\n\n    def _argpairs(self):\n        self._valid()\n\n        counts = self.counts * (self.counts + 1) >> 1    # N * (N + 1) // 2\n\n        offsets = self.counts2offsets(counts)\n        indexes = self.numpy.arange(offsets[-1])\n        parents = self.offsets2parents(offsets)\n\n        n = self.counts[parents]\n        k = indexes - offsets[parents]\n        two_n_1 = (2*n + 1)\n        i = self.numpy.floor((two_n_1 - self.numpy.sqrt(two_n_1*two_n_1 - 8*k)) / 2).astype(self.INDEXTYPE)\n\n        starts_parents = self._starts[parents]\n\n        left = starts_parents + i\n        right = starts_parents + k - n*i + (i*(i + 1) >> 1)\n\n        out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", left, right))\n        out._parents = parents\n        return out\n\n    def _argdistincts(self, absolute):\n        counts_comb = self.counts*(self.counts - 1) // 2\n        offsets_comb = self.counts2offsets(counts_comb)\n        parents_comb = self.offsets2parents(offsets_comb)\n        local_indices = self.numpy.arange(offsets_comb[-1]) - offsets_comb[parents_comb]\n\n        ### Consider the double-loop:\n        #   for i in range(n):\n        #       for j in range(i + 1, n):\n        #           pairs.append((i, j))\n        # At the beginning the i-th iteration of the outer loop,\n        #   len(pairs) = L = (n - 1) + (n - 2) + ... + (n - i)\n        #                  = n*i - i*(i + 1)/2\n        #   => -i^2 + (2*n - 1)*i - 2*L = 0\n        # So the quadratic formula gives i as a function of L at that point:\n        #   i = [(2*n - 1) - sqrt((2*n - 1)^2 - 4*2*L)] / 2\n        # Since i(L) is monotone increasing, and won\'t reach i+1 until\n        # the next outer loop, the floor gives the i value inside the outer loop.\n        # To find j, we can subtract L from our local indices to get the index\n        # from zero of the inner loop, then add i + 1.\n\n        n = self.counts[parents_comb]\n        b = 2*n - 1\n        i = self.numpy.floor((b - self.numpy.sqrt(b*b - 8*local_indices)) / 2).astype(counts_comb.dtype)\n        j = local_indices + i*(i - b + 2) // 2 + 1\n\n        if absolute:\n            starts_parents = self._starts[parents_comb]\n            i += starts_parents\n            j += starts_parents\n\n        out = self.JaggedArray.fromoffsets(offsets_comb, self.Table.named(""tuple"", i, j))\n        out._parents = parents_comb\n        return out\n\n    def _argchoose(self, n, absolute):\n        np = self.numpy\n\n        def root2(a):\n            return np.floor((1+np.sqrt(8*a+1))/2).astype(self.INDEXTYPE)\n\n        def root3(a):\n            out = 2*np.ones(a.shape, dtype=self.INDEXTYPE)\n            mask = a > 0\n            rad = np.power(np.sqrt(3)*np.sqrt(243*a[mask]**2 - 1) + 27*a[mask], 1./3)\n            # 1e-12 to correct rounding error (good to 1000 choose 3)\n            out[mask] = np.floor(np.power(3, -2./3)*rad + np.power(3, -1./3)/rad + 1 + 1e-12)\n            return out\n\n        def root4(a):\n            # good to (at least) 100 choose 4\n            return np.floor((np.sqrt(4*np.sqrt(24*a + 1) + 5) + 3)/2).astype(self.INDEXTYPE)\n\n        if n > 5:\n            # Need to solve general polynomial \\prod_{i<=k} (n-i) / k! = a\n            # Not sure if possible, is the Galois group solvable for this class of polynomial?\n            # The first level is a freebie thanks to np.repeat()\n            # I think the next levels should be too, but could not quite make it work...\n            raise NotImplementedError\n        elif n == 5:\n            counts = self.counts*(self.counts - 1)*(self.counts - 2)*(self.counts - 3)*(self.counts - 4)//120\n        elif n == 4:\n            counts = self.counts*(self.counts - 1)*(self.counts - 2)*(self.counts - 3)//24\n        elif n == 3:\n            counts = self.counts*(self.counts - 1)*(self.counts - 2)//6\n        elif n == 2:\n            counts = self.counts*(self.counts - 1)//2\n        elif n <= 1:\n            raise ValueError(""Choosing 0 or 1 items is trivial"")\n\n        local = self.localindex.content\n        offsets = self.JaggedArray.counts2offsets(counts)\n        indices = np.arange(offsets[-1])\n        parents = self.JaggedArray.offsets2parents(offsets)\n\n        if n == 5:\n            k5 = indices - offsets[parents]\n            i5 = np.repeat(local, awkward.util.windows_safe(local*(local - 1)*(local - 2)*(local - 3)//24))\n            k4 = k5 - i5*(i5 - 1)*(i5 - 2)*(i5 - 3)*(i5 - 4)//120\n            i4 = root4(k4)\n            k3 = k4 - i4*(i4 - 1)*(i4 - 2)*(i4 - 3)//24\n            i3 = root3(k3)\n            k2 = k3 - i3*(i3 - 1)*(i3 - 2)//6\n            i2 = root2(k2)\n            k1 = k2 - i2*(i2 - 1)//2\n            i1 = k1\n            if absolute:\n                starts_parents = self.starts[parents]\n                for idx in [i1, i2, i3, i4, i5]:\n                    idx += starts_parents\n            out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", i1, i2, i3, i4, i5))\n        elif n == 4:\n            k4 = indices - offsets[parents]\n            i4 = np.repeat(local, awkward.util.windows_safe(local*(local - 1)*(local - 2)//6))\n            k3 = k4 - i4*(i4 - 1)*(i4 - 2)*(i4 - 3)//24\n            i3 = root3(k3)\n            k2 = k3 - i3*(i3 - 1)*(i3 - 2)//6\n            i2 = root2(k2)\n            k1 = k2 - i2*(i2 - 1)//2\n            i1 = k1\n            if absolute:\n                starts_parents = self.starts[parents]\n                for idx in [i1, i2, i3, i4]:\n                    idx += starts_parents\n            out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", i1, i2, i3, i4))\n        elif n == 3:\n            k3 = indices - offsets[parents]\n            i3 = np.repeat(local, awkward.util.windows_safe(local*(local - 1)//2))\n            k2 = k3 - i3*(i3 - 1)*(i3 - 2)//6\n            i2 = root2(k2)\n            k1 = k2 - i2*(i2 - 1)//2\n            i1 = k1\n            if absolute:\n                starts_parents = self.starts[parents]\n                for idx in [i1, i2, i3]:\n                    idx += starts_parents\n            out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", i1, i2, i3))\n        elif n == 2:\n            k2 = indices - offsets[parents]\n            i2 = np.repeat(local, awkward.util.windows_safe(local))\n            k1 = k2 - i2*(i2 - 1)//2\n            i1 = k1\n            if absolute:\n                starts_parents = self.starts[parents]\n                for idx in [i1, i2]:\n                    idx += starts_parents\n            out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", i1, i2))\n\n        return out\n\n    def argchoose(self, n):\n        """"""\n        Return all unique combinations (up to permutation) of n elements,\n        taken without replacement from the indices of the jagged dimension.\n        Combinations are ordered such that those of the first elements precede later ones,\n        e.g. for n=2: (0,1), (0,2), (1,2), (0,3), (1,3), (2,3), (0,4), ...\n        """"""\n        return self._argchoose(n, absolute=False)\n\n    def choose(self, n):\n        """"""\n        Return all unique combinations (up to permutation) of n elements,\n        taken without replacement from the contents of the jagged dimension.\n        Combinations are ordered such that those of the first elements precede later ones,\n        e.g. for n=2: (0,1), (0,2), (1,2), (0,3), (1,3), (2,3), (0,4), ...\n        """"""\n        args = self._argchoose(n, absolute=True)\n        columns = (self.content[args.content[c]] for c in args.columns)\n        out = self.JaggedArray.fromoffsets(args.offsets, self.Table.named(""tuple"", *columns).flattentuple())\n        return out\n\n    def argdistincts(self, nested=False):\n        """"""\n        Return all unique combinations (up to permutation) of two elements,\n        taken without replacement from the indices of the jagged dimension.\n        Combinations are ordered lexicographically.\n        nested: Return a doubly-jagged array where the first jagged dimension\n        matches the shape of this array\n        """"""\n        out = self._argdistincts(absolute=False)\n\n        if nested:\n            out = self.JaggedArray.fromcounts(self.numpy.maximum(0, self.counts - 1), self.JaggedArray.fromcounts(self.localindex[:, :0:-1].flatten(), out._content))\n\n        return out\n\n    def distincts(self, nested=False):\n        """"""\n        Return all unique combinations (up to permutation) of two elements,\n        taken without replacement from the contents of the jagged dimension.\n        Combinations are ordered lexicographically.\n        nested: Return a doubly-jagged array where the first jagged dimension\n        matches the shape of this array\n        """"""\n        argpairs = self._argdistincts(absolute=True)\n        left = argpairs._content[""0""]\n        right = argpairs._content[""1""]\n\n        out = self.JaggedArray.fromoffsets(argpairs.offsets, self.Table.named(""tuple"", self._content[left], self._content[right]).flattentuple())\n        out._parents = argpairs._parents\n\n        if nested:\n            out = self.JaggedArray.fromcounts(self.numpy.maximum(0, self.counts - 1), self.JaggedArray.fromcounts(self.localindex[:, :0:-1].flatten(), out._content))\n\n        return out\n\n    def argpairs(self, nested=False):\n        out = self._argpairs()\n        out[""0""] = out[""0""] - self._starts\n        out[""1""] = out[""1""] - self._starts\n\n        if nested:\n            out = self.JaggedArray.fromcounts(self.counts, self.JaggedArray.fromcounts((self.localindex[:, ::-1] + 1).flatten(), out._content))\n\n        return out\n\n    def pairs(self, nested=False):\n        argpairs = self._argpairs()\n        left = argpairs._content[""0""]\n        right = argpairs._content[""1""]\n\n        out = self.JaggedArray.fromoffsets(argpairs.offsets, self.Table.named(""tuple"", self._content[left], self._content[right]).flattentuple())\n        out._parents = argpairs._parents\n\n        if nested:\n            out = self.JaggedArray.fromcounts(self.counts, self.JaggedArray.fromcounts((self.localindex[:, ::-1] + 1).flatten(), out._content))\n\n        return out\n\n    def _argcross(self, other):\n        self._valid()\n\n        if not isinstance(other, JaggedArray):\n            raise TypeError(""both arrays must be JaggedArrays"")\n\n        if len(self) != len(other):\n            raise ValueError(""both JaggedArrays must have the same length"")\n\n        offsets = self.counts2offsets(self.counts * other.counts)\n        indexes = self.numpy.arange(offsets[-1], dtype=self.INDEXTYPE)\n        parents = self.offsets2parents(offsets)\n\n        ocp = other.counts[parents]\n        iop = indexes - offsets[parents]\n        iop_ocp = iop // ocp\n\n        left = self._starts[parents] + iop_ocp\n        right = other._starts[parents] + iop - ocp * iop_ocp\n\n        out = self.JaggedArray.fromoffsets(offsets, self.Table.named(""tuple"", left, right))\n        out._offsets = offsets\n        out._parents = parents\n        return out\n\n    def argcross(self, other, nested=False):\n        if isinstance(other, self.VirtualArray):\n            other = other.array\n        out = self._argcross(other)\n        out[""0""] = out[""0""] - self._starts\n        out[""1""] = out[""1""] - other._starts\n\n        if nested:\n            out = self.JaggedArray.fromcounts(self.counts, self.JaggedArray.fromcounts(self.tojagged(other.counts).flatten(), out._content))\n\n        return out\n\n    def cross(self, other, nested=False):\n        if isinstance(other, self.VirtualArray):\n            other = other.array\n        if hasattr(self, ""_nestedcross""):\n            thyself = self._nestedcross\n        else:\n            thyself = self\n\n        argcross = thyself._argcross(other)\n        left, right = argcross._content._contents.values()\n\n        out = self.JaggedArray.fromoffsets(argcross._offsets, self.Table.named(""tuple"", thyself._content[left], other._content[right]).flattentuple())\n        out._parents = argcross._parents\n        out._iscross = True\n\n        if nested:\n            old = out\n            out = self.JaggedArray.fromcounts(thyself.counts, self.JaggedArray.fromcounts(thyself.tojagged(other.counts).flatten(), out._content))\n            out._nestedcross = old\n\n        if hasattr(self, ""_nestedcross""):\n            counts = out.counts.copy()\n            mask = (self.counts != 0)\n            counts[mask] //= self.counts[mask]\n            old = out\n            out = self.JaggedArray.fromcounts(self.counts, self.JaggedArray.fromcounts(self.tojagged(counts).flatten(), out._content))\n            out._nestedcross = old\n\n        return out\n\n    def _canuseoffset(self):\n        self._valid()\n        return self.offsetsaliased(self._starts, self._stops) or (len(self._starts.shape) == 1 and self.numpy.array_equal(self._starts[1:], self.stops[:-1]))\n\n    @property\n    def iscompact(self):\n        if len(self._starts) == 0:\n            return True\n        else:\n            flatstarts = self._starts.reshape(-1)\n            flatstops = self.stops.reshape(-1)   # no underscore!\n            if not self.offsetsaliased(self._starts, self._stops) and not self.numpy.array_equal(flatstarts[1:], flatstops[:-1]):\n                return False\n            if not self._isvalid and not (flatstops >= flatstarts).all():\n                raise ValueError(""offsets must be monatonically increasing"")\n            return True\n\n    def compact(self):\n        if self.iscompact:\n            return self\n        else:\n            offsets = self.counts2offsets(self.counts.reshape(-1))\n            if len(self._starts.shape) == 1:\n                tmp = self\n            else:                                                # no underscore!\n                tmp = self.JaggedArray(self._starts.reshape(-1), self.stops.reshape(-1), self._content)\n            out = tmp._tojagged(offsets[:-1], offsets[1:], copy=False)\n            out.starts.shape = self._starts.shape\n            out.stops.shape = self._starts.shape  # intentional: self._stops can too long\n            return out\n\n    def flattentuple(self):\n        return self.copy(content=self._util_flattentuple(self._content))\n\n    def flatten(self, axis=0):\n        if not self._util_isinteger(axis) or axis < 0:\n            raise TypeError(""axis must be a non-negative integer (can\'t count from the end)"")\n\n        if axis > 1:\n            return self.copy(content=self._util_flatten(self._content, axis - 1))\n\n        elif axis == 1:\n            self = self.compact()\n            innercounts = self._util_counts(self._content)\n            if (innercounts < 0).any():\n                raise ValueError(""cannot flatten an array containing scalar values"")\n            counts = self.JaggedArray.fromcounts(self.counts, innercounts).sum()\n            return type(self).fromcounts(counts, self._util_flatten(self._content, axis - 1))\n\n        else:\n            if len(self) == 0:\n                return self._content[0:0]\n            elif self._canuseoffset():\n                return self._content[self._starts[0]:self._stops[-1]]\n            else:\n                offsets = self.counts2offsets(self.counts.reshape(-1))\n                if len(self._starts.shape) == 1:\n                    out = self\n                else:\n                    out = self.JaggedArray(self._starts.reshape(-1), self._stops.reshape(-1), self._content)\n                return out._tojagged(offsets[:-1], offsets[1:], copy=False)._content\n\n    def structure1d(self, levellimit=None):\n        if len(self._starts) > len(self._stops):\n            raise ValueError(""starts must have the same (or shorter) length than stops"")\n        if self._starts.shape[1:] != self._stops.shape[1:]:\n            raise ValueError(""starts and stops must have the same dimensionality (shape[1:])"")\n\n        if levellimit is None:\n            levellimit = -1\n\n        out = self\n        if levellimit != 0 and isinstance(self._content, awkward.array.base.AwkwardArray):\n            out = self.copy(content=self._content.structure1d(levellimit - 1))\n\n        while len(out._starts.shape) > 1:\n            last = out._starts.shape[-1]\n            length = functools.reduce(operator.mul, out._starts.shape[:-1], 1)\n            offsets = self.numpy.arange(0, (length + 1)*last, last)\n            outerstarts = offsets[:-1].reshape(out._starts.shape[:-2] + (-1,))\n            outerstops = offsets[1:].reshape(out._stops.shape[:-2] + (-1,))\n            innerstarts = out._starts.reshape(-1)\n            innerstops = out._stops.reshape(-1)\n            out = self.copy(starts=outerstarts, stops=outerstops, content=self.copy(starts=innerstarts, stops=innerstops, content=out._content))\n\n        return out\n\n    def _hasjagged(self):\n        return True\n\n    def _reduce(self, ufunc, identity, dtype):\n        import awkward.array.table\n        self._valid()\n\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content._reduce(ufunc, identity, dtype))\n\n        elif isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents=[])\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)._reduce(ufunc, identity, dtype)\n            return out\n\n        elif isinstance(self._content, awkward.array.base.AwkwardArray):\n            thyself = self.copy(content=self._content._prepare(ufunc, identity, dtype))\n\n        elif len(self._content.shape) > 1:\n            if ufunc is None:\n                ufunc = self.numpy.add\n                if issubclass(self._content.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n                    content = 1 - self.numpy.isnan(self._content).astype(self.INDEXTYPE)\n                else:\n                    content = self.numpy.ones(self._content.shape, dtype=self.INDEXTYPE)\n\n            elif ufunc is self.numpy.count_nonzero:\n                ufunc = self.numpy.add\n                content = 1 - (self._content == 0).astype(self.INDEXTYPE)\n\n            else:\n                content = self._content\n\n            if dtype is not None:\n                content = content.astype(dtype)\n\n            return self.copy(content=ufunc.reduce(content, axis=-1))\n\n        else:\n            thyself = self.copy()\n\n        if isinstance(thyself._content, awkward.array.table.Table):\n            out = thyself._content.copy(contents=[])\n            for n, x in thyself._content._contents.items():\n                out[n] = thyself.copy(content=x)._reduce(ufunc, identity, dtype)\n            return out\n\n        if len(thyself._starts.shape) > 1:\n            thyself._starts = thyself._starts.reshape(-1)\n            thyself._stops = thyself._stops.reshape(-1)\n\n        if not thyself._canuseoffset():\n            offsets = self.counts2offsets(thyself.counts)\n            thyself = thyself._tojagged(offsets[:-1], offsets[1:], copy=False)\n\n        content = thyself._content\n        if ufunc is None:\n            ufunc = self.numpy.add\n            if issubclass(content.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n                content = 1 - self.numpy.isnan(content).astype(self.INDEXTYPE)\n            else:\n                content = self.numpy.ones(content.shape, dtype=self.INDEXTYPE)\n\n        elif ufunc is self.numpy.count_nonzero:\n            ufunc = self.numpy.add\n            content = 1 - (content == 0).astype(self.INDEXTYPE)\n\n        elif issubclass(content.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n            mask = self.numpy.isnan(content)\n            if mask.any():\n                content = content.copy()\n                content[mask] = identity\n\n        if dtype is None and issubclass(content.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n            dtype = self.numpy.dtype(type(identity))\n        if dtype is None:\n            dtype = content.dtype\n        else:\n            content = content.astype(dtype)\n\n        if identity == self.numpy.inf:\n            if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                identity = True\n            elif self._util_isintegertype(dtype.type):\n                identity = self.numpy.iinfo(dtype.type).max\n\n        elif identity == -self.numpy.inf:\n            if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                identity = False\n            elif self._util_isintegertype(dtype.type):\n                identity = self.numpy.iinfo(dtype.type).min\n\n        out = self.numpy.empty(thyself._starts.shape[:1], dtype=dtype)\n\n        if len(out) != 0:\n            nonterminal = thyself.offsets[thyself.offsets < len(content)]\n\n            for axis in range(1, len(content.shape)):\n                content = ufunc.reduce(content, axis=axis)\n\n            out = ufunc.reduceat(content, awkward.util.windows_safe(nonterminal))[:len(out)]\n            if len(out) < len(thyself):\n                tmp = self.numpy.empty((len(thyself),) + out.shape[1:], dtype=out.dtype)\n                tmp[:len(out)] = out\n                out = tmp\n\n            out[thyself.starts == thyself.stops] = identity\n\n        return out.reshape(self._starts.shape)\n\n    def argmin(self):\n        self._valid()\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content.argmin())\n        else:\n            return self._argminmax(True)\n\n    def argmax(self):\n        self._valid()\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content.argmax())\n        else:\n            return self._argminmax(False)\n\n    def _argminmax(self, ismin):\n        if len(self._starts) == len(self._stops) == 0:\n            return self.copy(content=self.numpy.array([], dtype=self.INDEXTYPE))\n\n        if len(self._content.shape) != 1:\n            raise ValueError(""cannot compute arg{0} because content is not one-dimensional"".format(""min"" if ismin else ""max""))\n\n        if len(self._content) == 0:\n            return self.copy(content=self.numpy.array([], dtype=self.INDEXTYPE))\n\n        if ismin:\n            out = self.localindex[self.min() == self]\n        else:\n            out = self.localindex[self.max() == self]\n\n        # workaround for lack of general out[...,:1] support\n        nonempty = out.counts > 0\n        if self.offsetsaliased(out._starts, out._stops):\n            out.stops = out.stops.copy()\n        out.stops[nonempty] = out.starts[nonempty] + 1\n        return out\n\n    def argsort(self, ascending=False):\n        self._valid()\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content.argsort(ascending))\n        else:\n            return self._argsort(ascending)\n\n    def _argsort(self, ascending=False):\n        reducer = self.JaggedArray.min if ascending else self.JaggedArray.max\n        localindex = self.localindex\n        out = localindex.empty_like()\n        next_start = self.numpy.zeros_like(out.starts)\n        tmp = self.copy()\n        while tmp.content.size > 0:\n            best = reducer(tmp) == tmp\n            if self.numpy.isnan(tmp.content).all():\n                # put NaN last always\n                best = self.numpy.isnan(tmp)\n            argbest = localindex[best]\n            idx = out.starts + next_start + argbest.localindex\n            out._content[idx.flatten()] = argbest.content\n            next_start += argbest.counts\n            tmp = tmp[~best]\n            localindex = localindex[~best]\n\n        # If masked entries were present, they would be dropped by the __getitem__\n        # So we need to trim the size of the output array correspondingly\n        out.stops = out.starts + next_start\n        return out\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        starts = cls.numpy.concatenate([x._starts for x in arrays])\n        stops = cls.numpy.concatenate([x._stops for x in arrays])\n        content = cls._util_concatenate([x._content for x in arrays])\n\n        startsi = 0\n        contenti = 0\n        for i, array in enumerate(arrays):\n            if i != 0:\n                startsstart, startsstop = startsi, startsi + len(array._starts)\n                starts[startsstart:startsstop] += contenti\n                stops[startsstart:startsstop] += contenti\n            startsi += len(array._starts)\n            contenti += len(array._content)\n\n        return cls(starts, stops, content)\n\n    @classmethod\n    def _concatenate_axis1(cls, arrays):\n        import awkward.array.table\n\n        if len(arrays) == 0:\n            raise ValueError(""at least one array must be provided"")   # this can only happen in the classmethod case\n        if any(len(a) != len(arrays[0]) for a in arrays):\n            raise ValueError(""cannot concatenate JaggedArrays of different lengths with axis=1"")\n        if any(len(a.starts.shape) > 1 for a in arrays):\n            raise NotImplementedError\n\n        np = cls.numpy\n\n        flatarrays = [a.flatten() for a in arrays]\n        n_arrays = len(arrays)\n\n        if n_arrays > 0 and all(isinstance(a, awkward.array.table.Table) and set(cls._util_columns_descend(a, set())) == set(cls._util_columns_descend(flatarrays[0], set())) for a in flatarrays):\n            results = {}\n            for n in flatarrays[0].columns:\n                results[n] = cls._concatenate_axis1([a[n] for a in arrays])\n            return cls.zip(results)\n\n        # the first step is to get the starts and stops for the stacked structure\n        counts = np.vstack([a.counts for a in arrays])\n        flat_counts = counts.T.flatten()\n        offsets = cls.counts2offsets(flat_counts)\n        starts, stops = offsets[:-1], offsets[1:]\n\n        n_content = sum([len(a) for a in flatarrays])\n        content_type = type(flatarrays[0])\n\n        # get masks for each of the arrays so we can fill the stacked content array at the right indices\n        def get_mask(array_index):\n            working_array = np.zeros(n_content + 1, dtype=cls.INDEXTYPE)\n            starts_i = starts[i::n_arrays]\n            stops_i = stops[i::n_arrays]\n            not_empty = starts_i != stops_i\n            working_array[starts_i[not_empty]] += 1\n            working_array[stops_i[not_empty]] -= 1\n            mask = np.array(np.cumsum(working_array)[:-1], dtype=cls.MASKTYPE)\n            return mask\n\n        # find most general type with a tentative sum which implements the right type-promotion,\n        # except for booleans which would get promoted to integers when summing\n        def get_dtype(arrays):\n            ick = [x[0] for x in arrays if len(x) != 0]\n            if len(ick) == 0:\n                dtype = np.dtype(arrays[0].dtype)\n            else:\n                dtype = np.dtype(sum(ick), False)\n            allbools = not np.any([a.dtype != np.dtype(bool) for a in arrays])\n            dtype = np.dtype(bool) if allbools else dtype\n            return dtype\n\n        if content_type == np.ndarray:\n            content = np.zeros(n_content, dtype=get_dtype(flatarrays))\n            for i in range(n_arrays):\n                content[get_mask(i)] = flatarrays[i]\n\n        elif issubclass(type(flatarrays[0]), awkward.array.objects.ObjectArray) and isinstance(flatarrays[0]._content, awkward.array.table.Table):\n            tablecontent = OrderedDict()\n            tables = [a._content for a in flatarrays]\n\n            # make sure all tables have the same columns\n            for i in range(len(tables) - 1):\n                if set(tables[i]._contents) != set(tables[i+1]._contents):\n                    raise ValueError(""cannot concatenate Tables with different fields"")\n\n            # create empty arrays  for each column with the most general dtype\n            for n in tables[0]._contents:\n                dtype = get_dtype([t[n] for t in tables])\n                tablecontent[n] = np.zeros(n_content, dtype=dtype)\n\n            for i in range(n_arrays):\n                mask = get_mask(i)\n                for n in tables[0]._contents:\n                    tablecontent[n][mask] = tables[i][n]\n\n            content = flatarrays[0].copy(content=awkward.array.table.Table(**tablecontent))\n\n        else:\n            raise NotImplementedError(""concatenate with axis=1 is not implemented for these types"")\n\n        return arrays[0].__class__(starts[::n_arrays], stops[n_arrays-1::n_arrays], content)\n\n    @awkward.util.bothmethod\n    def zip(isclassmethod, cls_or_self, columns1={}, *columns2, **columns3):\n        if isclassmethod:\n            cls = cls_or_self\n        else:\n            self = cls_or_self\n            cls = self.__class__\n            if not (isinstance(columns1, dict) and len(columns1) == 0):\n                columns2 = (columns1,) + columns2\n            columns1 = self\n\n        first = None\n        def ready(x):\n            starts, stops = x._starts.reshape(-1), x._stops.reshape(-1)\n            if (x._canuseoffset() and len(starts) != 0 and starts[0] == 0) or (len(starts) != 0 and len(stops) != 0 and len(stops) >= len(starts) and starts[0] == 0 and stops[len(starts) - 1] >= starts[len(starts) - 1] and (starts[1:] == stops[:-1]).all()):\n                return x\n            else:\n                offsets = x.counts2offsets(stops - starts)\n                starts, stops = offsets[:-1], offsets[1:]\n                starts = starts.reshape((-1,) + x._starts.shape[1:])\n                stops = stops.reshape((-1,) + x._stops.shape[1:])\n                return x._tojagged(starts, stops, copy=False)\n\n        if isinstance(columns1, JaggedArray):\n            columns1 = first = ready(columns1)\n\n        if isinstance(columns1, dict):\n            for n in columns1:\n                x = columns1[n]\n                if isinstance(x, JaggedArray):\n                    if first is None:\n                        columns1[n] = first = ready(x)\n                    else:\n                        columns1[n] = x._tojagged(first._starts, first._stops, copy=False)\n\n        columns2 = list(columns2)\n        for i in range(len(columns2)):\n            x = columns2[i]\n            if isinstance(x, JaggedArray):\n                if first is None:\n                    columns2[i] = first = ready(x)\n                else:\n                    columns2[i] = x._tojagged(first._starts, first._stops, copy=False)\n\n        for n in columns3:\n            x = columns3[n]\n            if isinstance(x, JaggedArray):\n                if first is None:\n                    columns3[n] = first = ready(x)\n                else:\n                    columns3[n] = x._tojagged(first._starts, first._stops, copy=False)\n\n        if first is None:\n            raise TypeError(""at least one argument in JaggedArray.zip must be a JaggedArray"")\n\n        if isclassmethod:\n            numpy = cls.numpy\n        else:\n            numpy = first.numpy\n\n        if isinstance(columns1, JaggedArray):\n            columns1 = columns1._content\n        elif isinstance(columns1, dict):\n            for n in columns1:\n                x = columns1[n]\n                if isinstance(x, JaggedArray):\n                    columns1[n] = x._content\n                elif isinstance(x, Iterable):\n                    columns1[n] = first.tojagged(x)._content\n                elif isinstance(x, (numbers.Number, numpy.number, numpy.bool, numpy.bool_)):\n                    columns1[n] = JaggedArray(first._starts, first._stops, numpy.full(first._stops.max(), columns1, dtype=type(columns1)))._content\n                else:\n                    raise TypeError(""unrecognized type for JaggedArray.zip: {0}"".format(type(x)))\n        elif isinstance(columns1, Iterable):\n            columns1 = first.tojagged(columns1)._content\n        elif isinstance(columns1, (numbers.Number, numpy.number, numpy.bool, numpy.bool_)):\n            columns1 = JaggedArray(first._starts, first._stops, numpy.full(first._stops.max(), columns1, dtype=type(columns1)))._content\n        else:\n            raise TypeError(""unrecognized type for JaggedArray.zip: {0}"".format(type(columns1)))\n\n        for i in range(len(columns2)):\n            x = columns2[i]\n            if isinstance(x, JaggedArray):\n                columns2[i] = x._content\n            elif not isinstance(x, dict) and isinstance(x, Iterable):\n                columns2[i] = first.tojagged(x)._content\n            elif isinstance(x, (numbers.Number, numpy.number, numpy.bool, numpy.bool_)):\n                columns2[i] = JaggedArray(first._starts, first._stops, numpy.full(first._stops.max(), x, dtype=type(x)))._content\n            else:\n                raise TypeError(""unrecognized type for JaggedArray.zip: {0}"".format(type(x)))\n\n        for n in columns3:\n            x = columns3[n]\n            if isinstance(x, JaggedArray):\n                columns3[n] = x._content\n            elif not isinstance(x, dict) and isinstance(x, Iterable):\n                columns3[n] = first.tojagged(x)._content\n            elif isinstance(x, (numbers.Number, numpy.number, numpy.bool, numpy.bool_)):\n                columns3[n] = JaggedArray(first._starts, first._stops, numpy.full(first._stops.max(), x, dtype=type(x)))._content\n            else:\n                raise TypeError(""unrecognized type for JaggedArray.zip: {0}"".format(type(x)))\n\n        if isclassmethod:\n            if isinstance(columns1, dict) or len(columns3) > 0:\n                table = cls.Table.fget(None)(columns1, *columns2, **columns3)\n            else:\n                table = cls.Table.fget(None).named(""tuple"", columns1, *columns2)\n            return cls.JaggedArray.fget(None)(first._starts, first._stops, table)\n        else:\n            if isinstance(columns1, dict) or len(columns3) > 0:\n                table = first.Table(columns1, *columns2, **columns3)\n            else:\n                table = first.Table.named(""tuple"", columns1, *columns2)\n            return first.JaggedArray(first._starts, first._stops, table)\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        if not self._util_isinteger(axis) or axis < 0:\n            raise TypeError(""axis must be a non-negative integer (can\'t count from the end)"")\n\n        if axis > 0:\n            return type(self).fromcounts(self.counts, self._util_pad(self._content, length, maskedwhen, clip, axis - 1))\n\n        flatstarts = self._starts.reshape(-1)\n\n        if len(self._content) == 0:\n            offsets = self.numpy.arange(0, length*len(flatstarts) + 1, length)\n            starts, stops = offsets[:-1], offsets[1:]\n            content = self.IndexedMaskedArray(self.numpy.full(length*len(flatstarts), -1, dtype=self.INDEXTYPE), self._content, maskedwhen=-1)\n            return self.copy(starts=starts.reshape(self._starts.shape), stops=stops.reshape(self._starts.shape), content=content)\n\n        if clip:\n            almostflat = self._starts.reshape(-1, 1)\n            index = self.numpy.arange(length, dtype=self.INDEXTYPE) + almostflat\n            localindex = index - almostflat\n            index = index.reshape(-1)\n            comparator = self.counts.reshape(-1, 1)\n            offsets = self.numpy.arange(0, length*len(flatstarts) + 1, length, dtype=self.INDEXTYPE)\n\n        else:\n            counts = self.numpy.maximum(self.counts.reshape(-1), length)\n            offsets = self.counts2offsets(counts)\n            parents = self.offsets2parents(offsets)\n            localindex = self.numpy.arange(len(parents), dtype=self.INDEXTYPE) - offsets[:-1][parents]\n            index = localindex + flatstarts[parents]\n            comparator = self.counts.reshape(-1)[parents]\n\n        if isinstance(maskedwhen, self.numpy.ma.core.MaskedConstant):\n            if not isinstance(self._content, self.numpy.ndarray):\n                raise TypeError(""numpy.ma.masked can only be used if JaggedArray.content is a Numpy array"")\n            mask = (localindex >= comparator).reshape(-1)\n        elif maskedwhen:\n            mask = (localindex >= comparator).reshape(-1)\n        else:\n            mask = (localindex < comparator).reshape(-1)\n\n        index[index >= len(self._content)] = -1\n        content = self._content[index]\n\n        starts = offsets[:-1].reshape((-1,) + self._starts.shape[1:])\n        stops = offsets[1:].reshape((-1,) + self._starts.shape[1:])\n\n        if isinstance(maskedwhen, self.numpy.ma.core.MaskedConstant):\n            return self.copy(starts=starts, stops=stops, content=self.numpy.ma.MaskedArray(content, mask))\n        else:\n            return self.copy(starts=starts, stops=stops, content=self.MaskedArray(mask, content, maskedwhen=maskedwhen))\n\n    def boolmask(self, maskedwhen=True):\n        if maskedwhen:\n            return self.numpy.zeros(len(self), dtype=self.MASKTYPE)\n        else:\n            return self.numpy.ones(len(self), dtype=self.MASKTYPE)\n\n    _topandas_name = ""JaggedSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n'"
awkward/array/masked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport collections\nimport numbers\n\nimport awkward.array.base\nimport awkward.type\nimport awkward.util\n\nclass MaskedArray(awkward.array.base.AwkwardArrayWithContent):\n    """"""\n    MaskedArray\n    """"""\n\n    masked = None\n\n    def __init__(self, mask, content, maskedwhen=True):\n        self.mask = mask\n        self.content = content\n        self.maskedwhen = maskedwhen\n\n    @classmethod\n    def fromcontent(cls, content, maskedwhen=True):\n        if maskedwhen:\n            mask = cls.numpy.zeros(len(content), dtype=cls.MASKTYPE)\n        else:\n            mask = cls.numpy.ones(len(content), dtype=cls.MASKTYPE)\n        return cls(mask, content, maskedwhen=maskedwhen)\n\n    def copy(self, mask=None, content=None, maskedwhen=None):\n        out = self.__class__.__new__(self.__class__)\n        out._mask = self._mask\n        out._content = self._content\n        out._maskedwhen = self._maskedwhen\n        out._isvalid = self._isvalid\n        if mask is not None:\n            out.mask = mask\n        if content is not None:\n            out.content = content\n        if maskedwhen is not None:\n            out.maskedwhen = maskedwhen\n        return out\n\n    def deepcopy(self, mask=None, content=None):\n        out = self.copy(mask=mask, content=content)\n        out._mask = self._util_deepcopy(out._mask)\n        out._content = self._util_deepcopy(out._content)\n        return out\n\n    def _mine(self, overrides):\n        mine = {}\n        mine[""maskedwhen""] = overrides.pop(""maskedwhen"", self._maskedwhen)\n        return mine\n\n    def empty_like(self, **overrides):\n        mine = self._mine(overrides)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.empty_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.empty_like(**overrides), **mine)\n\n    def zeros_like(self, **overrides):\n        mine = self._mine(overrides)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.zeros_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.zeros_like(**overrides), **mine)\n\n    def ones_like(self, **overrides):\n        mine = self._mine(overrides)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.ones_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.ones_like(**overrides), **mine)\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""MaskedArray""],\n            serializer(self._mask, ""MaskedArray.mask""),\n            serializer(self._content, ""MaskedArray.content""),\n            {""json"": bool(self._maskedwhen)},\n        )\n\n    @property\n    def mask(self):\n        return self._mask\n\n    @mask.setter\n    def mask(self, value):\n        value = self._util_toarray(value, self.MASKTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if len(value.shape) != 1:\n                raise ValueError(""mask must have 1-dimensional shape"")\n        if not issubclass(value.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n            value = (value != 0)\n        self._mask = value\n        self._isvalid = False\n\n    def boolmask(self, maskedwhen=None):\n        if maskedwhen is None:\n            maskedwhen = self._maskedwhen\n        if maskedwhen == self._maskedwhen:\n            return self._mask\n        else:\n            return self.numpy.logical_not(self._mask)\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n        self._isvalid = False\n\n    @property\n    def maskedwhen(self):\n        return self._maskedwhen\n\n    @maskedwhen.setter\n    def maskedwhen(self, value):\n        self._maskedwhen = bool(value)\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return self._mask.nbytes + (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n\n    def __len__(self):\n        return len(self._mask)\n\n    def _gettype(self, seen):\n        return awkward.type.OptionType(awkward.type._fromarray(self._content, seen))\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._mask, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (1,), seen, lookup)\n        return (awkward.type.LayoutArg(""mask"", position + (0,)),\n                awkward.type.LayoutArg(""content"", position + (1,)),\n                awkward.type.LayoutArg(""maskedwhen"", self._maskedwhen))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                if len(self._mask) > len(self._content):\n                    raise ValueError(""mask length ({0}) must be the same as (or shorter than) the content length ({1})"".format(len(self._mask), len(self._content)))\n\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n\n        mask = self._mask\n        lenmask = len(mask)\n        content = self._content\n        maskedwhen = self._maskedwhen\n        masked = self.masked\n\n        i = 0\n        while i < lenmask:\n            if mask[i] == maskedwhen:\n                yield masked\n            else:\n                yield content[i]\n            i += 1\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.MaskedArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if self._util_isinteger(head):\n            if self._mask[head] == self._maskedwhen:\n                if tail != ():\n                    raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n                return self.masked\n            else:\n                return self._content[:len(self._mask)][(head,) + tail]\n\n        else:\n            mask = self._mask[head]\n            if tail != () and ((self._maskedwhen and mask.any()) or (not self._maskedwhen and not mask.all())):\n                raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n            else:\n                return self.copy(mask=mask, content=self._content[:len(self._mask)][(head,) + tail])\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        tokeep = None\n        for x in inputs:\n            if isinstance(x, MaskedArray):\n                x._valid()\n                if tokeep is None:\n                    tokeep = x.boolmask(maskedwhen=False)\n                else:\n                    tokeep = tokeep & x.boolmask(maskedwhen=False)\n\n        assert tokeep is not None\n\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], IndexedMaskedArray):\n                inputs[i] = inputs[i]._content[inputs[i]._mask[tokeep]]\n            elif isinstance(inputs[i], MaskedArray):\n                inputs[i] = inputs[i]._content[tokeep]\n            elif isinstance(inputs[i], (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                inputs[i] = inputs[i][tokeep]\n            else:\n                try:\n                    for first in inputs[i]:\n                        break\n                except TypeError:\n                    pass\n                else:\n                    inputs[i] = self.numpy.array(inputs[i], copy=False)[tokeep]\n\n        # compute only the non-masked elements\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        # put the masked out values back\n        index = self.numpy.full(len(tokeep), -1, dtype=self.INDEXTYPE)\n        index[tokeep] = self.numpy.arange(self.numpy.count_nonzero(tokeep))\n\n        if isinstance(result, tuple):\n            return tuple(self.Methods.maybemixin(type(x), IndexedMaskedArray)(index, x, maskedwhen=-1) if isinstance(x, (self.numpy.ndarray, awkward.array.base.AwkwardArray)) else x for x in result)\n        elif method == ""at"":\n            return None\n        else:\n            return self.Methods.maybemixin(type(result), IndexedMaskedArray)(index, result, maskedwhen=-1)\n\n    @property\n    def counts(self):\n        self._valid()\n        content = self._util_counts(self._content)\n        out = self.numpy.full(self.shape, -1, dtype=content.dtype)\n        mask = self.boolmask(maskedwhen=False)\n        out[mask] = content[mask]\n        return out\n\n    def choose(self, n):\n        return self.copy(content=self._content.choose(n))\n\n    def argchoose(self, n):\n        return self.copy(content=self._content.argchoose(n))\n\n    def distincts(self, nested=False):\n        return self.copy(content=self._content.distincts(nested=nested))\n\n    def argdistincts(self, nested=False):\n        return self.copy(content=self._content.argdistincts(nested=nested))\n\n    def pairs(self, nested=False):\n        return self.copy(content=self._content.pairs(nested=nested))\n\n    def argpairs(self, nested=False):\n        return self.copy(content=self._content.argpairs(nested=nested))\n\n    def cross(self, other, nested=False):\n        return self.copy(content=self._content.cross(other, nested=nested))\n\n    def argcross(self, other, nested=False):\n        return self.copy(content=self._content.argcross(other, nested=nested))\n\n    def flattentuple(self):\n        return self.copy(content=self._util_flattentuple(self._content))\n\n    def flatten(self, axis=0):\n        mask = self.boolmask(maskedwhen=False)\n        goodcontent = self._content[mask]\n        content = self._util_flatten(goodcontent, axis)\n        counts = self._util_counts(goodcontent)\n        counts[counts < 0] = 1\n        augcounts = self.numpy.ones(len(self), dtype=self.INDEXTYPE)\n        augcounts[mask] = counts\n        augparents = self.JaggedArray.offsets2parents(self.JaggedArray.counts2offsets(augcounts))\n        augmask = mask[augparents]\n        index = self.numpy.cumsum(augmask) - 1\n        index[~augmask] = -1\n        return self.IndexedMaskedArray(index, content)\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self.copy(content=self._util_pad(self._content, length, maskedwhen, clip, axis))\n\n    def regular(self):\n        self._valid()\n        out = self._util_regular(self._content).astype(self.numpy.float64)\n        out[self.boolmask(maskedwhen=True)] = float(""nan"")\n        return out\n\n    def indexed(self):\n        maskindex = self.numpy.arange(len(self), dtype=self.INDEXTYPE)\n        maskindex[self.boolmask(maskedwhen=True)] = -1\n        return IndexedMaskedArray(maskindex, self._content, maskedwhen=-1)\n\n    def _reduce(self, ufunc, identity, dtype):\n        if self._util_hasjagged(self._content):\n            return self.copy(content=self._content._reduce(ufunc, identity, dtype))\n\n        elif isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents={})\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)\n            return out._reduce(ufunc, identity, dtype)\n\n        else:\n            prepared = self._prepare(ufunc, identity, dtype)\n            if ufunc is None:\n                return (1 - self.numpy.isnan(prepared)).sum()\n            elif ufunc is self.numpy.count_nonzero:\n                return (1 - (prepared == 0)).sum()\n            if issubclass(prepared.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n                prepared = self.numpy.where(self.numpy.isnan(prepared), identity, prepared)\n            return ufunc.reduce(prepared)\n\n    def _prepare(self, ufunc, identity, dtype):\n        if isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents={})\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)._prepare(ufunc, identity, dtype)\n            return out\n\n        if isinstance(self._content, self.numpy.ndarray):\n            if dtype is None and issubclass(self._content.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                dtype = self.numpy.dtype(type(identity))\n            if ufunc is None:\n                content = self.numpy.zeros(self._content.shape, dtype=self.numpy.float32)\n                content[self.numpy.isnan(self._content)] = self.numpy.nan\n            elif ufunc is self.numpy.count_nonzero:\n                content = self.numpy.ones(self._content.shape, dtype=self.numpy.int8)\n                content[self.numpy.isnan(self._content)] = 0\n                content[self._content == 0] = 0\n            elif dtype is None:\n                content = self._content\n            else:\n                content = self._content.astype(dtype)\n        else:\n            content = self._content._prepare(ufunc, identity, dtype)\n\n        if content is self._content or not content.flags.owndata:\n            content = content.copy()\n\n        if ufunc is None:\n            content[self.ismasked] = self.numpy.nan\n\n        else:\n            dtype = content.dtype\n\n            if identity == self.numpy.inf:\n                if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                    identity = True\n                elif self._util_isintegertype(dtype.type):\n                    identity = self.numpy.iinfo(dtype.type).max\n            elif identity == -self.numpy.inf:\n                if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                    identity = False\n                elif self._util_isintegertype(dtype.type):\n                    identity = self.numpy.iinfo(dtype.type).min\n\n            content[self.ismasked] = identity\n\n        return content\n\n    def argmin(self):\n        if self._util_hasjagged(self):\n            return self.copy(content=self._content.argmin())\n        else:\n            index = self._content[self.isunmasked()].argmin()\n            return self.numpy.searchsorted(self.numpy.cumsum(self.ismasked()), index, side=""right"")\n\n    def argmax(self):\n        if self._util_hasjagged(self):\n            return self.copy(content=self._content.argmax())\n        else:\n            index = self._content[self.isunmasked()].argmax()\n            return self.numpy.searchsorted(self.numpy.cumsum(self.ismasked()), index, side=""right"")\n\n    def fillna(self, value):\n        out = self._util_fillna(self._content, value)\n        if not isinstance(out, self.numpy.ndarray):\n            out = self.numpy.array(out)\n        out[self.boolmask(maskedwhen=True)] = value\n        return out\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, MaskedArray) for x in arrays)\n        mask = cls.numpy.concatenate([x.boolmask(maskedwhen=True) for x in arrays])\n        content = awkward.array.base.AwkwardArray.concatenate([x._content for x in arrays])\n        return cls(mask, content, maskedwhen=True)\n\n    _topandas_name = ""MaskedSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n\nclass BitMaskedArray(MaskedArray):\n    """"""\n    BitMaskedArray\n    """"""\n\n    # TODO for 1.0: need a maskshape parameter to apply length and multidimensional shape to the output\n\n    def __init__(self, mask, content, maskedwhen=True, lsborder=False):\n        super(BitMaskedArray, self).__init__(mask, content, maskedwhen=maskedwhen)\n        self.lsborder = lsborder\n\n    @classmethod\n    def fromcontent(cls, content, maskedwhen=True, lsborder=False):\n        if maskedwhen:\n            mask = cls.numpy.zeros(cls._ceildiv8(len(content)), dtype=cls.BITMASKTYPE)\n        else:\n            mask = cls.numpy.ones(cls._ceildiv8(len(content)), dtype=cls.BITMASKTYPE)\n        return cls(mask, content, maskedwhen=maskedwhen, lsborder=lsborder)\n\n    @classmethod\n    def fromboolmask(cls, mask, content, maskedwhen=True, lsborder=False):\n        return cls(cls.bool2bit(mask, lsborder=lsborder), content, maskedwhen=maskedwhen, lsborder=lsborder)\n\n    def copy(self, mask=None, content=None, maskedwhen=None, lsborder=None):\n        out = super(BitMaskedArray, self).copy(mask=mask, content=content, maskedwhen=maskedwhen)\n        out._lsborder = self._lsborder\n        if lsborder is not None:\n            out._lsborder = lsborder\n        return out\n\n    def _mine(self, overrides):\n        mine = {}\n        mine[""maskedwhen""] = overrides.pop(""maskedwhen"", self._maskedwhen)\n        mine[""lsborder""] = overrides.pop(""lsborder"", self._lsborder)\n        return mine\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""BitMaskedArray""],\n            serializer(self._mask, ""BitMaskedArray.mask""),\n            serializer(self._content, ""BitMaskedArray.content""),\n            {""json"": bool(self._maskedwhen)},\n            {""json"": bool(self._lsborder)},\n        )\n\n    @property\n    def mask(self):\n        return self._mask\n\n    @mask.setter\n    def mask(self, value):\n        value = self._util_toarray(value, self.BITMASKTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if len(value.shape) != 1:\n                raise ValueError(""mask must have 1-dimensional shape"")\n        self._mask = value.view(self.BITMASKTYPE)\n        self._isvalid = False\n\n    def __len__(self):\n        return len(self._content)\n\n    @staticmethod\n    def _ceildiv8(x):\n        return -(-x >> 3)   # this is int(math.ceil(x / 8))\n\n    @classmethod\n    def bit2bool(cls, bitmask, lsborder=False):\n        out = cls.numpy.unpackbits(bitmask)\n        if lsborder:\n            out = out.reshape(-1, 8)[:,::-1].reshape(-1)\n        return out.view(cls.MASKTYPE)\n\n    @classmethod\n    def bool2bit(cls, boolmask, lsborder=False):\n        boolmask = cls._util_toarray(boolmask, cls.MaskedArray.fget(None).MASKTYPE, cls.numpy.ndarray)\n        if len(boolmask.shape) != 1:\n            raise ValueError(""boolmask must have 1-dimensional shape"")\n        if not issubclass(boolmask.dtype.type, (cls.numpy.bool_, cls.numpy.bool)):\n            boolmask = (boolmask != 0)\n\n        if lsborder:\n            # maybe pad the length for reshape\n            length = cls._ceildiv8(len(boolmask)) * 8\n            if length != len(boolmask):\n                out = cls.numpy.empty(length, dtype=boolmask.dtype)\n                out[:len(boolmask)] = boolmask\n            else:\n                out = boolmask\n\n            # reverse the order in groups of 8\n            out = out.reshape(-1, 8)[:,::-1].reshape(-1)\n\n        else:\n            # numpy.packbits encodes as msb (most significant bit); already in the right order\n            out = boolmask\n\n        return cls.numpy.packbits(out)\n\n    def boolmask(self, maskedwhen=None):\n        if maskedwhen is None:\n            maskedwhen = self._maskedwhen\n        if maskedwhen == self._maskedwhen:\n            bitmask = self._mask\n        else:\n            bitmask = self.numpy.bitwise_not(self._mask)\n        return self.bit2bool(bitmask, lsborder=self._lsborder)[:len(self._content)]\n\n    @property\n    def lsborder(self):\n        return self._lsborder\n\n    @lsborder.setter\n    def lsborder(self, value):\n        self._lsborder = bool(value)\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._mask, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (1,), seen, lookup)\n        return (awkward.type.LayoutArg(""mask"", position + (0,)),\n                awkward.type.LayoutArg(""content"", position + (1,)),\n                awkward.type.LayoutArg(""maskedwhen"", self._maskedwhen),\n                awkward.type.LayoutArg(""lsborder"", self._lsborder))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n\n        one = self.numpy.uint8(1)\n        zero = self.numpy.uint8(0)\n        mask = self._mask\n        content = self._content\n        lencontent = len(content)\n        maskedwhen = self._maskedwhen\n        masked = self.masked\n\n        if self._lsborder:\n            byte = i = 0\n            bit = start = self.numpy.uint8(1)\n            while i < lencontent:\n                if ((mask[byte] & bit) != 0) == self._maskedwhen:\n                    yield masked\n                else:\n                    yield content[i]\n                bit <<= one\n                if bit == zero:\n                    bit = start\n                    byte += 1\n                i += 1\n\n        else:\n            byte = i = 0\n            bit = start = self.numpy.uint8(128)\n            while i < lencontent:\n                if ((mask[byte] & bit) != 0) == self._maskedwhen:\n                    yield masked\n                else:\n                    yield content[i]\n                bit >>= one\n                if bit == zero:\n                    bit = start\n                    byte += 1\n                i += 1\n\n    def _maskat(self, where):\n        bytepos = self.numpy.right_shift(where, 3)    # where // 8\n        bitpos  = where - 8*bytepos                           # where % 8\n\n        if self._lsborder:\n            bitmask = self.numpy.left_shift(1, bitpos)\n        else:\n            bitmask = self.numpy.right_shift(128, bitpos)\n\n        if isinstance(bitmask, self.numpy.ndarray):\n            bitmask = bitmask.astype(self.BITMASKTYPE)\n        else:\n            bitmask = self.BITMASKTYPE.type(bitmask)\n\n        return bytepos, bitmask\n\n    def _maskwhere(self, where):\n        if self._util_isinteger(where):\n            bytepos, bitmask = self._maskat(where)\n            return self.numpy.bitwise_and(self._mask[bytepos], bitmask) != 0\n\n        elif isinstance(where, slice):\n            # assumes a small slice; for a big slice, it could be faster to unpack the whole mask\n            return self._maskwhere(self.numpy.arange(*where.indices(len(self._content))))\n\n        else:\n            where = self.numpy.array(where, copy=False)\n            if len(where.shape) == 1 and self._util_isintegertype(where.dtype.type):\n                byteposes, bitmasks = self._maskat(where)\n                self.numpy.bitwise_and(bitmasks, self._mask[byteposes], bitmasks)\n                return bitmasks.astype(self.numpy.bool_)\n\n            elif len(where.shape) == 1 and issubclass(where.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                # scales with the size of the mask anyway, so go ahead and unpack the whole mask\n                unpacked = self.numpy.unpackbits(self._mask).view(self.MASKTYPE)\n\n                if self._lsborder:\n                    unpacked = unpacked.reshape(-1, 8)[:,::-1].reshape(-1)[:len(where)]\n                else:\n                    unpacked = unpacked[:len(where)]\n\n                return unpacked[where]\n\n            else:\n                raise TypeError(""cannot interpret shape {0}, dtype {1} as a fancy index or mask"".format(where.shape, where.dtype))\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.BitMaskedArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if self._util_isinteger(head):\n            if self._maskwhere(head) == self._maskedwhen:\n                if tail != ():\n                    raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n                return self.masked\n            else:\n                return self._content[(head,) + tail]\n\n        else:\n            mask = self._maskwhere(head)\n            if tail != () and ((self._maskedwhen and mask.any()) or (not self._maskedwhen and not mask.all())):\n                raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n            else:\n                return self.copy(mask=self.bool2bit(mask, lsborder=self._lsborder), content=self._content[(head,) + tail], lsborder=self._lsborder)\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        raise NotImplementedError(""concatenate not implemented for BitMaskedArray"")\n\nclass IndexedMaskedArray(MaskedArray):\n    """"""\n    IndexedMaskedArray\n    """"""\n\n    # TODO for 1.0: remove maskedwhen and instead check for any negative value (can\'t be allowed to inherit methods that assume self.maskedwhen!)\n\n    def __init__(self, mask, content, maskedwhen=-1):\n        super(IndexedMaskedArray, self).__init__(mask, content, maskedwhen=maskedwhen)\n        self._isvalid = False\n\n    @classmethod\n    def fromcontent(cls, content, maskedwhen=-1):\n        mask = cls.numpy.arange(len(content), dtype=cls.INDEXTYPE)\n        return cls(mask, content, maskedwhen=maskedwhen)\n\n    def copy(self, mask=None, content=None, maskedwhen=None):\n        out = self.__class__.__new__(self.__class__)\n        out._mask = self._mask\n        out._content = self._content\n        out._maskedwhen = self._maskedwhen\n        out._isvalid = self._isvalid\n        if mask is not None:\n            out._mask = mask\n        if content is not None:\n            out._content = content\n        if maskedwhen is not None:\n            out._maskedwhen = maskedwhen\n        return out\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""IndexedMaskedArray""],\n            serializer(self._mask, ""IndexedMaskedArray.mask""),\n            serializer(self._content, ""IndexedMaskedArray.content""),\n            {""json"": int(self._maskedwhen)},\n        )\n\n    @property\n    def mask(self):\n        return self._mask\n\n    @mask.setter\n    def mask(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""starts must have integer dtype"")\n            if len(value.shape) != 1:\n                raise ValueError(""mask must have 1-dimensional shape"")\n        self._mask = value\n        self._isvalid = False\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n        self._isvalid = False\n\n    @property\n    def maskedwhen(self):\n        return self._maskedwhen\n\n    @maskedwhen.setter\n    def maskedwhen(self, value):\n        if self.check_prop_valid:\n            if not self._util_isinteger(value):\n                raise TypeError(""maskedwhen must be an integer for IndexedMaskedArray"")\n        self._maskedwhen = value\n\n    def boolmask(self, maskedwhen=True):\n        if maskedwhen is None:\n            raise TypeError(""maskedwhen must be True or False"")\n        if maskedwhen:\n            return self._mask == self._maskedwhen\n        else:\n            return self._mask != self._maskedwhen\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._mask, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._content, position + (1,), seen, lookup)\n        return (awkward.type.LayoutArg(""mask"", position + (0,)),\n                awkward.type.LayoutArg(""content"", position + (1,)),\n                awkward.type.LayoutArg(""maskedwhen"", self._maskedwhen))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                if len(self._mask) != 0:\n                    if self._mask.max() > len(self._content):\n                        raise ValueError(""maximum mask-index ({0}) is beyond the length of the content ({1})"".format(self._mask.max(), len(self._content)))\n                    if (self._mask[self._mask != self._maskedwhen] < 0).any():\n                        raise ValueError(""mask-index has negative values (other than maskedwhen)"")\n\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n\n        mask = self._mask\n        lenmask = len(mask)\n        content = self._content\n        maskedwhen = self._maskedwhen\n        masked = self.masked\n\n        i = 0\n        while i < lenmask:\n            maskindex = mask[i]\n            if maskindex == maskedwhen:\n                yield masked\n            else:\n                yield content[maskindex]\n            i += 1\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            content = self._content[where]\n            cls = awkward.array.objects.Methods.maybemixin(type(content), self.IndexedMaskedArray)\n            out = cls.__new__(cls)\n            out.__dict__.update(self.__dict__)\n            out._content = content\n            return out\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if self._util_isinteger(head):\n            maskindex = self._mask[head]\n            if maskindex == self._maskedwhen:\n                if tail != ():\n                    raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n                return self.masked\n            else:\n                return self._content[(maskindex,) + tail]\n\n        else:\n            maskindex = self._mask[head]\n            if tail != () and (maskindex == self._maskedwhen).any():\n                raise ValueError(""masked element ({0}) is not subscriptable"".format(self.masked))\n            else:\n                return self.copy(mask=maskindex)\n\n    @property\n    def counts(self):\n        self._valid()\n        out = self._util_counts(self._content)[self._index]\n        out[self.boolmask(maskedwhen=True)] = -1\n        return out\n\n    def flatten(self, axis=0):\n        mask = self.boolmask(maskedwhen=False)\n        goodcontent = self._content[self._mask[self._mask >= 0]]\n        content = self._util_flatten(goodcontent, axis)\n        counts = self._util_counts(goodcontent)\n        counts[counts < 0] = 1\n        augcounts = self.numpy.ones(len(self), dtype=self.INDEXTYPE)\n        augcounts[mask] = counts\n        augparents = self.JaggedArray.offsets2parents(self.JaggedArray.counts2offsets(augcounts))\n        augmask = mask[augparents]\n        index = self.numpy.cumsum(augmask) - 1\n        index[~augmask] = -1\n        return self.IndexedMaskedArray(index, content)\n\n    def regular(self):\n        self._valid()\n        out = self._util_regular(self._content).astype(self.numpy.float64)[self._index]\n        out[self.boolmask(maskedwhen=True)] = float(""nan"")\n        return out\n\n    def indexed(self):\n        return self\n\n    def _prepare(self, ufunc, identity, dtype):\n        if isinstance(self._content, awkward.array.table.Table):\n            out = self._content.copy(contents={})\n            for n, x in self._content._contents.items():\n                out[n] = self.copy(content=x)._prepare(ufunc, identity, dtype)\n            return out\n\n        if isinstance(self._content, self.numpy.ndarray):\n            if dtype is None and issubclass(self._content.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                dtype = self.numpy.dtype(type(identity))\n            if dtype is None:\n                content = self._content\n            else:\n                content = self._content.astype(dtype)\n        else:\n            content = self._content._prepare(ufunc, identity, dtype)\n\n        if identity == self.numpy.inf:\n            if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                identity = True\n            elif self._util_isintegertype(dtype.type):\n                identity = self.numpy.iinfo(dtype.type).max\n\n        elif identity == -self.numpy.inf:\n            if issubclass(dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                identity = False\n            elif self._util_isintegertype(dtype.type):\n                identity = self.numpy.iinfo(dtype.type).min\n\n        out = self.numpy.full(self._mask.shape + content.shape[1:], identity, dtype=content.dtype)\n        out[self.isunmasked] = content[self.mask[self.mask >= 0]]\n        return out\n\n    def argmin(self):\n        if self._util_hasjagged(self):\n            return self.copy(content=self._content.argmin())\n        else:\n            index = self._content[self._mask[self.isunmasked()]].argmin()\n            return self.numpy.searchsorted(self.numpy.cumsum(self.ismasked()), index, side=""right"")\n\n    def argmax(self):\n        if self._util_hasjagged(self):\n            return self.copy(content=self._content.argmax())\n        else:\n            index = self._content[self._mask[self.isunmasked()]].argmax()\n            return self.numpy.searchsorted(self.numpy.cumsum(self.ismasked()), index, side=""right"")\n\n    def fillna(self, value):\n        out = self._util_fillna(self._content, value)\n        if not isinstance(out, self.numpy.ndarray):\n            out = self.numpy.array(out)\n        out = self.numpy.append(out, value)\n        if (self.mask < -1).any():\n            mask = self.mask.copy()\n            mask[mask < -1] = -1\n        else:\n            mask = self.mask\n        return out[mask]\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, IndexedMaskedArray) for x in arrays)\n\n        indexes = []\n        offset = 0\n        for x in arrays:\n            tmp = x._index.copy()\n            tmp[tmp >= 0] += offset\n            indexes.append(tmp)\n            offset += len(x._content)\n        index = cls.numpy.concatenate(indexes)\n\n        content = awkward.array.base.AwkwardArray.concatenate([x._content for x in arrays], axis=0)\n\n        return cls(index, content, maskedwhen=maskedwhen)\n'"
awkward/array/objects.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport codecs\nimport importlib\n\nimport awkward.array.base\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nclass Methods(object):\n    """"""\n    Methods: abstract mix-in\n    """"""\n\n    @staticmethod\n    def mixin(methods, awkwardtype):\n        assert not issubclass(methods, awkward.array.base.AwkwardArray)\n        assert not issubclass(awkwardtype, Methods)\n        return type(awkwardtype.__name__ + ""Methods"", (methods, awkwardtype), {})\n\n    @staticmethod\n    def maybemixin(sample, awkwardtype):\n        if issubclass(sample, Methods):\n            assert issubclass(sample, awkward.array.base.AwkwardArray)\n            allbases = tuple(x for x in sample.__bases__ if not issubclass(x, awkward.array.base.AwkwardArray)) + (awkwardtype,)\n            return type(awkwardtype.__name__ + ""Methods"", allbases, {})\n        else:\n            return awkwardtype\n\nclass ObjectArray(awkward.array.base.AwkwardArrayWithContent):\n    """"""\n    ObjectArray\n    """"""\n\n    def __init__(self, content, generator, args=(), kwargs={}):\n        self.content = content\n        self.generator = generator\n        self.args = args\n        self.kwargs = kwargs\n\n    def copy(self, content=None, generator=None, args=None, kwargs=None):\n        out = self.__class__.__new__(self.__class__)\n        out._content = self._content\n        out._generator = self._generator\n        out._args = self._args\n        out._kwargs = self._kwargs\n        if content is not None:\n            out.content = content\n        if generator is not None:\n            out.generator = generator\n        if args is not None:\n            out.args = args\n        if kwargs is not None:\n            out.kwargs = kwargs\n        return out\n\n    def deepcopy(self, content=None, generator=None, args=None, kwargs=None):\n        out = self.copy(content=content, generator=generator, args=args, kwargs=kwargs)\n        out._content = self._util_deepcopy(out._content)\n        return out\n\n    def empty_like(self, **overrides):\n        mine = {}\n        mine[""generator""] = overrides.pop(""generator"", self._generator)\n        mine[""args""] = overrides.pop(""args"", self._args)\n        mine[""kwargs""] = overrides.pop(""kwargs"", self._kwargs)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.empty_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.empty_like(**overrides), **mine)\n\n    def zeros_like(self, **overrides):\n        mine = {}\n        mine[""generator""] = overrides.pop(""generator"", self._generator)\n        mine[""args""] = overrides.pop(""args"", self._args)\n        mine[""kwargs""] = overrides.pop(""kwargs"", self._kwargs)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.zeros_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.zeros_like(**overrides), **mine)\n\n    def ones_like(self, **overrides):\n        mine = {}\n        mine[""generator""] = overrides.pop(""generator"", self._generator)\n        mine[""args""] = overrides.pop(""args"", self._args)\n        mine[""kwargs""] = overrides.pop(""kwargs"", self._kwargs)\n        if isinstance(self._content, self.numpy.ndarray):\n            return self.copy(content=self.numpy.ones_like(self._content), **mine)\n        else:\n            return self.copy(content=self._content.ones_like(**overrides), **mine)\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        return serializer.encode_call(\n            [""awkward"", ""ObjectArray""],\n            serializer(self._content, ""ObjectArray.content""),\n            serializer(self._generator, ""ObjectArray.generator""),\n            {""tuple"": [\n                serializer(x, ""ObjectArray.args"") for x in self._args\n            ]},\n            {""dict"": {\n                n: serializer(x, ""ObjectArray.kwargs"")\n                for n, x in self._kwargs.items()\n            }},\n        )\n\n    @property\n    def content(self):\n        return self._content\n\n    @content.setter\n    def content(self, value):\n        self._content = self._util_toarray(value, self.DEFAULTTYPE)\n\n    @property\n    def generator(self):\n        return self._generator\n\n    @generator.setter\n    def generator(self, value):\n        if self.check_prop_valid:\n            if not callable(value):\n                raise TypeError(""generator must be a callable (of one argument: the array slice)"")\n        self._generator = value\n\n    @property\n    def args(self):\n        return self._args\n\n    @args.setter\n    def args(self, value):\n        if not isinstance(value, tuple):\n            value = (value,)\n        self._args = value\n\n    @property\n    def kwargs(self):\n        return self._kwargs\n\n    @kwargs.setter\n    def kwargs(self, value):\n        if self.check_prop_valid:\n            if not isinstance(value, dict):\n                raise TypeError(""kwargs must be a dict"")\n        self._kwargs = dict(value)\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return (self._content.nbytes if isinstance(self._content, self.numpy.ndarray) else self._content._getnbytes(seen))\n\n    def __len__(self):\n        return len(self._content)\n\n    def _gettype(self, seen):\n        return self._generator\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._content, position + (0,), seen, lookup)\n        return (awkward.type.LayoutArg(""content"", position + (0,)),\n                awkward.type.LayoutArg(""generator"", self._generator),\n                awkward.type.LayoutArg(""args"", self._args),\n                awkward.type.LayoutArg(""kwargs"", self._kwargs))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            pass\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        for x in self._content:\n            yield self.generator(x, *self._args, **self._kwargs)\n\n    def __getitem__(self, where):\n        if self._util_isstringslice(where):\n            return self._content[where]\n\n        if isinstance(where, tuple) and where == ():\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        content = self._content[head]\n        if self._util_isinteger(head):\n            if isinstance(tail, tuple) and tail == ():\n                return self.generator(content, *self._args, **self._kwargs)\n            else:\n                return self.generator(content, *self._args, **self._kwargs)[tail]\n\n        elif isinstance(tail, tuple) and tail == ():\n            return self.copy(content=content)\n\n        else:\n            return [x[tail] for x in content]   # FIXME: in self.copy(content=content), right?\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        contents = []\n        for x in inputs:\n            if isinstance(x, ObjectArray):\n                x._valid()\n                contents.append(x._content)\n            else:\n                contents.append(x)\n\n        result = getattr(ufunc, method)(*contents, **kwargs)\n\n        if self._util_iscomparison(ufunc):\n            return result\n        else:\n            return self.copy(content=result)\n\n    def _hasjagged(self):\n        return False\n\n    @property\n    def counts(self):\n        return self._util_counts(self._content)\n\n    def boolmask(self, maskedwhen=True):\n        return self._util_boolmask(self._content, maskedwhen)\n\n    def choose(self, n):\n        raise TypeError(""cannot call choose on ObjectArray"")\n\n    def argchoose(self, n):\n        raise TypeError(""cannot call argchoose on ObjectArray"")\n\n    def distincts(self, nested=False):\n        raise TypeError(""cannot call distincts on ObjectArray"")\n\n    def argdistincts(self, nested=False):\n        raise TypeError(""cannot call argdistincts on ObjectArray"")\n\n    def pairs(self, nested=False):\n        raise TypeError(""cannot call pairs on ObjectArray"")\n\n    def argpairs(self, nested=False):\n        raise TypeError(""cannot call argpairs on ObjectArray"")\n\n    def cross(self, other, nested=False):\n        raise TypeError(""cannot call cross on ObjectArray"")\n\n    def argcross(self, other, nested=False):\n        raise TypeError(""cannot call argcross on ObjectArray"")\n\n    def flattentuple(self):\n        return self.copy(content=self._util_flattentuple(self._content))\n\n    def flatten(self, axis=0):\n        return self.copy(content=self._util_flatten(self._content, axis))\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self.copy(content=self._util_pad(self._content, length, maskedwhen, clip, axis))\n\n    def regular(self):\n        return self.numpy.array(self)\n\n    def _reduce(self, ufunc, identity, dtype):\n        raise TypeError(""cannot call reducer on ObjectArray"")\n\n    def _prepare(self, ufunc, identity, dtype):\n        raise TypeError(""cannot call reducer on ObjectArray"")\n\n    def argmin(self):\n        raise TypeError(""cannot call argmin on ObjectArray"")\n\n    def argmax(self):\n        raise TypeError(""cannot call argmax on ObjectArray"")\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        out = arrays[0].copy(content=[])\n        out._content = arrays[0]._content.__class__.concatenate([a._content for a in arrays])\n        return out\n\n    _topandas_name = ""ObjectSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n\n####################################################################### strings\n\nclass StringMethods(object):\n    """"""\n    StringMethods\n    """"""\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            raise NotImplemented\n\n        if ufunc is self.numpy.equal or ufunc is self.numpy.not_equal:\n            if len(inputs) < 2:\n                raise ValueError(""invalid number of arguments"")\n            left, right = inputs[0], inputs[1]\n\n            if isinstance(left, (str, bytes)):\n                left = self.StringArray.fromstr(len(right), left)\n            elif isinstance(left, self.numpy.ndarray) and (left.dtype.kind == ""U"" or left.dtype.kind == ""S""):\n                left = self.StringArray.fromnumpy(left)\n            elif isinstance(left, self.numpy.ndarray) and left.dtype == self.numpy.dtype(object):\n                left = self.StringArray.fromiter(left)\n            elif not isinstance(left, StringMethods):\n                return self.numpy.zeros(len(right), dtype=self.BOOLTYPE)\n\n            if isinstance(right, (str, bytes)):\n                right = self.StringArray.fromstr(len(left), right)\n            elif isinstance(right, self.numpy.ndarray) and (right.dtype.kind == ""U"" or right.dtype.kind == ""S""):\n                right = self.StringArray.fromnumpy(right)\n            elif isinstance(right, self.numpy.ndarray) and right.dtype == self.numpy.dtype(object):\n                right = self.StringArray.fromiter(right)\n            elif not isinstance(right, StringMethods):\n                return self.numpy.zeros(len(left), dtype=self.BOOLTYPE)\n\n            left = self.JaggedArray(left.starts, left.stops, left.content)\n            right = self.JaggedArray(right.starts, right.stops, right.content)\n\n            maybeequal = (left.counts == right.counts)\n\n            leftmask = left[maybeequal]\n            rightmask = right[maybeequal]\n\n            reallyequal = (leftmask == rightmask).count_nonzero() == leftmask.counts\n\n            out = self.numpy.zeros(len(left), dtype=self.BOOLTYPE)\n            out[maybeequal] = reallyequal\n\n            if ufunc is self.numpy.equal:\n                return out\n            else:\n                return self.numpy.logical_not(out)\n\n        else:\n            return super(StringMethods, self).__array_ufunc__(ufunc, method, *inputs, **kwargs)\n\ndef tostring(x, decoder):\n    if decoder is None:\n        return x.tostring()\n    else:\n        return decoder(x, errors=""replace"")[0]\n\nclass StringArray(StringMethods, ObjectArray):\n    """"""\n    StringArray\n    """"""\n\n    def __init__(self, starts, stops, content, encoding=""utf-8""):\n        self._content = self.JaggedArray(starts, stops, content)\n        self._generator = tostring\n        self._kwargs = {}\n        self.encoding = encoding\n\n    @classmethod\n    def fromstr(cls, length, string, encoding=""utf-8""):   # FIXME: infer encoding from string\n        if encoding is not None:\n            encoder = codecs.getencoder(encoding)\n            string = encoder(string)[0]\n        content = cls.numpy.empty(length * len(string), dtype=cls.CHARTYPE)\n        for i, x in string:\n            content[0::length] = ord(x)                   # FIXME: use numpy.tile!\n        counts = cls.numpy.empty(length, dtype=cls.INDEXTYPE)\n        counts[:] = length\n        return cls.fromcounts(counts, content, encoding)\n\n    @classmethod\n    def fromnumpy(cls, array):\n        if array.dtype.kind == ""S"":\n            encoding = None\n        elif array.dtype.kind == ""U"":\n            encoding = ""utf-32le""\n        else:\n            raise TypeError(""not a string array"")\n\n        starts = cls.numpy.arange(                   0,  len(array)      * array.dtype.itemsize, array.dtype.itemsize)\n        stops  = cls.numpy.arange(array.dtype.itemsize, (len(array) + 1) * array.dtype.itemsize, array.dtype.itemsize)\n        content = array.view(cls.CHARTYPE)\n\n        shorter = cls.numpy.ones(len(array), dtype=cls.BOOLTYPE)\n        if array.dtype.kind == ""S"":\n            for checkat in range(array.dtype.itemsize - 1, -1, -1):\n                shorter &= (content[checkat::array.dtype.itemsize] == 0)\n                stops[shorter] -= 1\n                if not shorter.any():\n                    break\n\n        elif array.dtype.kind == ""U"":\n            content2 = content.view(cls.numpy.uint32)\n            itemsize2 = array.dtype.itemsize >> 2                 # itemsize // 4\n            for checkat in range(itemsize2 - 1, -1, -1):\n                shorter &= (content2[checkat::itemsize2] == 0)    # all four bytes are zero\n                stops[shorter] -= 4\n                if not shorter.any():\n                    break\n\n        out = cls.__new__(cls)\n        out._content = cls.JaggedArray.fget(None)(starts, stops, content)\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    @classmethod\n    def fromiter(cls, iterable, encoding=""utf-8""):\n        if encoding is None:\n            encoded = iterable\n        else:\n            encoder = codecs.getencoder(encoding)\n            encoded = [encoder(x)[0] for x in iterable]\n        counts = [len(x) for x in encoded]\n        content = cls.numpy.empty(sum(counts), dtype=cls.CHARTYPE)\n        i = 0\n        for x in encoded:\n            content[i : i + len(x)] = cls.numpy.frombuffer(x, dtype=cls.CHARTYPE)\n            i += len(x)\n        return cls.fromcounts(counts, content, encoding)\n\n    @classmethod\n    def fromoffsets(cls, offsets, content, encoding=""utf-8""):\n        out = cls.__new__(cls)\n        out._content = cls.JaggedArray.fget(None).fromoffsets(offsets, content)\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    @classmethod\n    def fromcounts(cls, counts, content, encoding=""utf-8""):\n        out = cls.__new__(cls)\n        out._content = cls.JaggedArray.fget(None).fromcounts(counts, content)\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    @classmethod\n    def fromparents(cls, parents, content, encoding=""utf-8""):\n        out = cls.__new__(cls)\n        out._content = cls.JaggedArray.fget(None).fromparents(parents, content)\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    @classmethod\n    def fromuniques(cls, uniques, content, encoding=""utf-8""):\n        out = cls.__new__(cls)\n        out._content = cls.JaggedArray.fget(None).fromuniques(uniques, content)\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    @classmethod\n    def fromjagged(cls, jagged, encoding=""utf-8""):\n        if awkward.type.fromarray(jagged.content).to != cls.CHARTYPE:\n            raise TypeError(""jagged array must have CHARTYPE ({0})"".format(str(cls.CHARTYPE)))\n        out = cls.__new__(cls)\n        out._content = jagged\n        out._generator = tostring\n        out._kwargs = {}\n        out.encoding = encoding\n        return out\n\n    def copy(self, starts=None, stops=None, content=None, encoding=None):\n        out = self.__class__.__new__(self.__class__)\n        out._content = self.JaggedArray(self.starts, self.stops, self.content)\n        out._generator = self._generator\n        out._args = self._args\n        out._kwargs = self._kwargs\n        out._encoding = self._encoding\n        if starts is not None:\n            out.starts = starts\n        if stops is not None:\n            out.stops = stops\n        if content is not None:\n            out.content = content\n        if encoding is not None:\n            out.encoding = encoding\n        return out\n\n    def deepcopy(self, starts=None, stops=None, content=None, encoding=None):\n        out = self.copy(starts=starts, stops=stops, content=content, encoding=encoding)\n        out._content._starts = self._util_deepcopy(out._content._starts)\n        out._content._stops = self._util_deepcopy(out._content._stops)\n        out._content._content = self._util_deepcopy(out._content._content)\n        return out\n\n    def empty_like(self, **overrides):\n        mine = {}\n        mine[""encoding""] = overrides.pop(""encoding"", self._encoding)\n        jagged = self._content.empty_like(**overrides)\n        return self.copy(jagged.starts, jagged.stops, jagged.content, **mine)\n\n    def zeros_like(self, **overrides):\n        mine = {}\n        mine[""encoding""] = overrides.pop(""encoding"", self._encoding)\n        jagged = self._content.zeros_like(**overrides)\n        return self.copy(jagged.starts, jagged.stops, jagged.content, **mine)\n\n    def ones_like(self, **overrides):\n        mine = {}\n        mine[""encoding""] = overrides.pop(""encoding"", self._encoding)\n        jagged = self._content.ones_like(**overrides)\n        return self.copy(jagged.starts, jagged.stops, jagged.content, **mine)\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        if self._content.offsetsaliased(self.starts, self.stops) and len(self.starts) > 0 and self.starts[0] == 0:\n            return serializer.encode_call(\n                [""awkward"", ""StringArray"", ""fromcounts""],\n                serializer(self.counts, ""StringArray.counts""),\n                serializer(self.content, ""StringArray.content""),\n                serializer(self._encoding),\n            )\n        else:\n            return serializer.encode_call(\n                [""awkward"", ""StringArray""],\n                serializer(self.starts, ""StringArray.starts""),\n                serializer(self.stops, ""StringArray.stops""),\n                serializer(self.content, ""StringArray.content""),\n                serializer(self._encoding),\n            )\n\n    @property\n    def starts(self):\n        return self._content.starts\n\n    @starts.setter\n    def starts(self, value):\n        self._content.starts = value\n\n    @property\n    def stops(self):\n        return self._content.stops\n\n    @stops.setter\n    def stops(self, value):\n        self._content.stops = value\n\n    @property\n    def content(self):\n        return self._content.content\n\n    @content.setter\n    def content(self, value):\n        self._content.content = value\n\n    @property\n    def args(self):\n        return self._args\n\n    @property\n    def kwargs(self):\n        return {}\n\n    @property\n    def encoding(self):\n        return self._encoding\n\n    @encoding.setter\n    def encoding(self, value):\n        if value is None:\n            decodefcn = None\n        else:\n            decodefcn = codecs.getdecoder(value)\n        self._encoding = value\n        self._args = (decodefcn,)\n\n    @property\n    def offsets(self):\n        return self._content.offsets\n\n    @property\n    def counts(self):\n        return self._content.counts\n\n    @property\n    def parents(self):\n        return self._content.parents\n\n    @property\n    def index(self):\n        return self._content.index\n\n    def _gettype(self, seen):\n        if self._encoding is None:\n            return bytes\n        else:\n            return str\n\n    def __getitem__(self, where):\n        if self._util_isstringslice(where):\n            raise IndexError(""cannot index StringArray with string or sequence of strings"")\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if self._util_isinteger(head):\n            return super(StringArray, self).__getitem__(where)\n\n        elif tail == ():\n            out = self._content[where]\n            return self.__class__(out.starts, out.stops, out.content, self.encoding)\n\n        else:\n            out = self._content[where]\n            return self.__class__(out.starts, out.stops, out.content, self.encoding)\n\n    def regular(self):\n        self._valid()\n        return self.numpy.array(self)\n\n    @property\n    def iscompact(self):\n        return self._content.iscompact\n\n    def compact(self):\n        return self.fromjagged(self._content.compact(), self.encoding)\n\n    def flatten(self, axis=0):\n        import awkward.array.jagged\n        content = self._util_flatten(self._content, axis)\n        if isinstance(content, awkward.array.jagged.JaggedArray):\n            return self.fromjagged(content, self._encoding)\n        else:\n            return self.fromjagged(self.JaggedArray.fromcounts([len(content)], content))\n\n    def pad(self, length, maskedwhen=None, clip=False, axis=0):\n        if not self._util_isinteger(axis) or axis < 0:\n            raise TypeError(""axis must be a non-negative integer (can\'t count from the end)"")\n\n        if axis > 0:\n            raise ValueError(""axis too deep for StringArray"")\n\n        if maskedwhen is None:\n            maskedwhen = ord(b"" "")\n        elif not isinstance(maskedwhen, bytes) or not len(maskedwhen) == 1:\n            raise TypeError(""to pad a StringArray, set maskedwhen to a one-character bytestring, such as b\' \'"")\n        else:\n            maskedwhen = ord(maskedwhen)\n        import awkward.array.jagged\n        import awkward.array.masked\n        padded = self._util_pad(self._content, length, True, clip)\n        assert isinstance(padded, awkward.array.jagged.JaggedArray)\n        assert isinstance(padded.content, awkward.array.masked.MaskedArray)\n        if padded.content.content is self._content.content:\n            chars = padded.content.content.copy()\n        else:\n            chars = padded.content.content\n        chars[padded.content.mask] = maskedwhen\n        padded.content = chars\n        return self.fromjagged(padded, self._encoding)\n\n    # @awkward.util.bothmethod\n    # def concatenate(isclassmethod, cls_or_self, arrays, axis=0):\n    #     if isclassmethod:\n    #         cls = cls_or_self\n    #         if not all(isinstance(x, StringArray) for x in arrays):\n    #             raise TypeError(""cannot concatenate non-StringArrays with StringArray.concatenate"")\n    #     else:\n    #         self = cls_or_self\n    #         cls = self.__class__\n    #         if not isinstance(self, StringArray) or not all(isinstance(x, StringArray) for x in arrays):\n    #             raise TypeError(""cannot concatenate non-StringArrays with StringArrays.concatenate"")\n    #         arrays = (self,) + tuple(arrays)\n    #\n    #     jagged = self.JaggedArray.concatenate([x._content for x in arrays], axis=axis)\n    #     return self.fromjagged(jagged, self.encoding)\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, StringArray) for x in arrays)\n        return cls.fromjagged(cls.JaggedArray.fget(None)._concatenate_axis0([x._content for x in arrays]), encoding=arrays[0]._encoding)\n\n    @classmethod\n    def _concatenate_axis1(cls, arrays):\n        assert all(isinstance(x, StringArray) for x in arrays)\n        tmp = cls.JaggedArray.fget(None)._concatenate_axis1([x._content for x in arrays])\n        tmp._content = tmp._content.astype(cls.CHARTYPE)\n        return cls.fromjagged(tmp, encoding=arrays[0]._encoding)\n\n    def fillna(self, value):\n        return self\n\n    _topandas_name = ""StringSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            if isinstance(self._content, awkward.array.base.AwkwardArray):\n                out._content = out._content._topandas(seen)\n            return out\n'"
awkward/array/table.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport numbers\nimport re\nimport types\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward.array.base\nimport awkward.type\nimport awkward.util\n\nclass Table(awkward.array.base.AwkwardArray):\n    """"""\n    Table\n    """"""\n\n    ##################### class Row\n\n    class Row(awkward.util.NDArrayOperatorsMixin):\n        """"""\n        Table.Row\n        """"""\n\n        __slots__ = [""_table"", ""_index""]\n\n        def __init__(self, table, index):\n            self._table = table\n            self._index = index\n\n        def __repr__(self):\n            if self._table.istuple:\n                return ""({0})"".format("", "".join(str(self[n]) for n in self._table._contents))\n            elif getattr(self._table, ""_showdict"", False):\n                return ""<{0} {{{1}}}>"".format(self._table._rowname, "", "".join(""{0}: {1}"".format(repr(n), str(self[n])) for n in self._table._contents))\n            else:\n                return ""<{0} {1}>"".format(self._table._rowname, self._index + self._table.rowstart)\n\n        def __contains__(self, name):\n            return name in self._table._contents\n\n        def tolist(self):\n            if self._table.istuple:\n                return tuple(self._table._try_tolist(self[n]) for n in self._table._contents)\n            else:\n                return dict((n, self._table._try_tolist(x[self._index])) for n, x in self._table._contents.items())\n\n        def __len__(self):\n            if self._table.rowname == \'tuple\':\n                i = 0\n                while str(i) in self._table._contents:\n                    i += 1\n                return i\n            else:\n                return len(self._table._contents)\n\n        def __iter__(self, checkiter=True):\n            if checkiter:\n                self._table._checkiter()\n            if self._table.rowname == \'tuple\':\n                i = 0\n                while str(i) in self._table._contents:\n                    yield self._table._contents[str(i)][self._index]\n                    i += 1\n            else:\n                for i in self._table._contents:\n                    yield i\n\n        def __getitem__(self, where):\n            if isinstance(where, awkward.util.string):\n                try:\n                    return self._table._contents[where][self._index]\n                except KeyError:\n                    raise ValueError(""no column named {0}"".format(repr(where)))\n\n            elif self._util_isstringslice(where):\n                contents = OrderedDict()\n                for n in where:\n                    try:\n                        contents[n] = self._table._contents[n]\n                    except KeyError:\n                        raise ValueError(""no column named {0}"".format(repr(n)))\n                table = self._table.copy(contents=contents)\n                return table.Row(table, self._index)\n\n            else:\n                index = self._index\n                if not isinstance(index, tuple):\n                    index = (index,)\n                if not isinstance(where, tuple):\n                    where = (where,)\n                return self._table.Row(table, index + where)\n\n        def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n            if ""out"" in kwargs:\n                raise NotImplementedError(""in-place operations not supported"")\n\n            if method != ""__call__"":\n                return NotImplemented\n\n            torow = not any(not isinstance(x, Table.Row) and isinstance(x, Iterable) for x in inputs)\n\n            inputs = list(inputs)\n            for i in range(len(inputs)):\n                if isinstance(inputs[i], Table.Row):\n                    inputs[i] = inputs[i]._table[inputs[i]._index : inputs[i]._index + 1]\n\n            result = getattr(ufunc, method)(*inputs, **kwargs)\n\n            if torow:\n                if isinstance(result, tuple):\n                    out = []\n                    for x in result:\n                        if isinstance(x, Table):\n                            out.append(awkward.array.objects.Methods.maybemixin(type(x), self._table.Table.Row)(x, 0))\n                            out[-1]._table._showdict = True\n                        else:\n                            out.append(x)\n                    return tuple(out)\n                elif method == ""at"":\n                    return None\n                else:\n                    out = awkward.array.objects.Methods.maybemixin(type(result), self._table.Table.Row)(result, 0)\n                    out._table._showdict = True\n                    return out\n\n            else:\n                return result\n\n        def __eq__(self, other):\n            if not isinstance(other, Table.Row):\n                return False\n            elif self._table is other._table and self._index == other._index:\n                return True\n            else:\n                return set(self._table._contents) == set(other._table._contents) and all(self._table._contents[n][self._index] == other._table._contents[n][other._index] for n in self._table._contents)\n\n        def __ne__(self, other):\n            return not self.__eq__(other)\n\n        def __getattr__(self, where):\n            if where in super(Table.Row, self).__dir__():\n                return super(Table.Row, self).__getattribute__(where)\n            else:\n                if where in self.columns:\n                    try:\n                        return self[where]\n                    except Exception as err:\n                        raise AttributeError(""while trying to get column {0}, an exception occurred:\\n{1}: {2}"".format(repr(where), type(err), str(err)))\n                else:\n                    raise AttributeError(""no column named {0}"".format(repr(where)))\n\n        def __dir__(self):\n            return sorted(set(super(Table.Row, self).__dir__() + [x for x in self.columns if self._dir_pattern.match(x) and not keyword.iskeyword(x)]))\n        _dir_pattern = re.compile(r""^[a-zA-Z_]\\w*$"")\n\n        @property\n        def columns(self):\n            return self._table.columns\n\n        @property\n        def i0(self):\n            return self[""0""]\n\n        @property\n        def i1(self):\n            return self[""1""]\n\n        @property\n        def i2(self):\n            return self[""2""]\n\n        @property\n        def i3(self):\n            return self[""3""]\n\n        @property\n        def i4(self):\n            return self[""4""]\n\n        @property\n        def i5(self):\n            return self[""5""]\n\n        @property\n        def i6(self):\n            return self[""6""]\n\n        @property\n        def i7(self):\n            return self[""7""]\n\n        @property\n        def i8(self):\n            return self[""8""]\n\n        @property\n        def i9(self):\n            return self[""9""]\n\n    ##################### class Table\n\n    def __init__(self, columns1={}, *columns2, **columns3):\n        self._view = None\n        self._base = None\n        self.rowname = ""Row"" if isinstance(columns1, dict) or len(columns3) > 0 else ""tuple""\n        self.rowstart = None\n        self._contents = OrderedDict()\n\n        seen = set()\n        if isinstance(columns1, dict):\n            for n, x in columns1.items():\n                if n in seen:\n                    raise ValueError(""column {0} occurs more than once"".format(repr(n)))\n                seen.add(n)\n\n                self[n] = x\n\n            if len(columns2) != 0:\n                raise TypeError(""only one positional argument when first argument is a dict"")\n\n        else:\n            self[""0""] = columns1\n            for i, x in enumerate(columns2):\n                self[str(i + 1)] = x\n\n        seen.update(self._contents)\n\n        for n, x in columns3.items():\n            if n in seen:\n                raise ValueError(""column {0} occurs more than once"".format(repr(n)))\n            seen.add(n)\n\n            self[n] = x\n\n    def tolist(self):\n        return list(x.tolist() for x in self)\n\n    @classmethod\n    def named(cls, rowname, columns1={}, *columns2, **columns3):\n        out = cls(columns1, *columns2, **columns3)\n        out.rowname = rowname\n        return out\n\n    @property\n    def rowname(self):\n        return self._rowname\n\n    @rowname.setter\n    def rowname(self, value):\n        if self.check_prop_valid:\n            if not isinstance(value, awkward.util.string):\n                raise TypeError(""rowname must be a string"")\n        self._rowname = value\n\n    def _util_rowname(self, seen):\n        return self._rowname\n\n    @property\n    def rowstart(self):\n        if self._rowstart is not None:\n            return self._rowstart\n        elif self._base is not None:\n            return self._base.rowstart\n        else:\n            return 0\n\n    @rowstart.setter\n    def rowstart(self, value):\n        if self.check_prop_valid:\n            if value is not None and not isinstance(value, (numbers.Integral, numpy.integer)):\n                raise TypeError(""rowstart must be None or an integer"")\n        self._rowstart = value\n\n    @classmethod\n    def fromrec(cls, recarray):\n        if not isinstance(recarray, cls.numpy.ndarray) or recarray.dtype.names is None:\n            raise TypeError(""recarray must be a Numpy structured array"")\n        out = cls()\n        for n in recarray.dtype.names:\n            out[n] = recarray[n]\n        return out\n\n    @classmethod\n    def frompairs(cls, pairs, rowstart=0):\n        out = cls()\n        for n, x in pairs:\n            out[n] = x\n        out._rowstart = rowstart\n        return out\n\n    @classmethod\n    def fromview(cls, view, base):\n        if view is None:\n            return base\n\n        elif isinstance(view, tuple) and len(view) == 3 and all(cls._util_isinteger(x) for x in view):\n            start, step, length = view\n            out = base.copy()\n            out._view = int(start), int(step), int(length)\n            out._base = base\n            out._rowstart = None\n            return out\n\n        elif isinstance(view, cls.numpy.ndarray) and cls._util_isintegertype(view.dtype.type):\n            out = base.copy()\n            out._view = view\n            out._base = base\n            out._rowstart = None\n            return out\n\n        else:\n            raise TypeError(""view must be None, a 3-tuple of integers, or a Numpy array of integers"")\n\n    def copy(self, contents=None):\n        out = self.__class__.__new__(self.__class__)\n        out._view = self._view\n        out._base = self._base\n        out._rowstart = self._rowstart\n        out._rowname = self._rowname\n        out._contents = self._contents\n        if contents is not None and isinstance(contents, dict):\n            out._contents = OrderedDict(contents.items())\n        elif contents is not None:\n            out._contents = OrderedDict(contents)\n        else:\n            out._contents = OrderedDict(self._contents.items())\n        return out\n\n    def deepcopy(self, contents=None):\n        out = self.copy(contents=contents)\n        out._contents = OrderedDict([(n, self._util_deepcopy(x[out._index()])) for n, x in out._contents.items()])\n        out._view = None\n        out._base = None\n        out._rowstart = None\n        return out\n\n    def empty_like(self, **overrides):\n        out = self.__class__.__new__(self.__class__)\n        out._view = None\n        out._base = None\n        out._rowstart = None\n        out._rowname = self._rowname\n        out._contents = OrderedDict()\n        return out\n\n    def zeros_like(self, **overrides):\n        out = self.empty_like(**overrides)\n        for n, x in self._contents.items():\n            if isinstance(x, self.numpy.ndarray):\n                out[n] = self.numpy.zeros_like(x)\n            else:\n                out[n] = x.zeros_like(**overrides)\n        return out\n\n    def ones_like(self, **overrides):\n        out = self.empty_like(**overrides)\n        for n, x in self._contents.items():\n            if isinstance(x, self.numpy.ndarray):\n                out[n] = self.numpy.ones_like(x)\n            else:\n                out[n] = x.ones_like(**overrides)\n        return out\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        out = serializer.encode_call(\n            [""awkward"", ""Table"", ""frompairs""],\n            {""pairs"": [\n                [n, serializer(x, ""Table.contents"")]\n                for n, x in self._contents.items()\n            ]},\n            {""json"": self.rowstart}\n        )\n        if isinstance(self._view, tuple):\n            start, step, length = self._view\n            out = serializer.encode_call(\n                [""awkward"", ""Table"", ""fromview""],\n                {""tuple"": [\n                    {""json"": start},\n                    {""json"": step},\n                    {""json"": length},\n                ]},\n                out,\n            )\n\n        elif isinstance(self._view, self.numpy.ndarray):\n            out = serializer.encode_call(\n                [""awkward"", ""Table"", ""fromview""],\n                serializer(self._view, ""Table.view""),\n                out\n            )\n\n        return out\n\n    @property\n    def base(self):\n        return self._base\n\n    @property\n    def contents(self):\n        return self._contents\n\n    @contents.setter\n    def contents(self, value):\n        if self.check_prop_valid:\n            if not isinstance(value, dict) or not all(isinstance(n, awkward.util.string) for n in value):\n                raise TypeError(""contents must be a dict from strings to arrays"")\n        for n in list(value):\n            value[n] = self._util_toarray(value[n], self.DEFAULTTYPE)\n        self._contents = value\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return sum(x.nbytes if isinstance(x, self.numpy.ndarray) else x._getnbytes(seen) for x in self._contents.values())\n\n    def __len__(self):\n        return self._length()\n\n    def _gettype(self, seen):\n        out = awkward.type.TableType()\n        for n, x in self._contents.items():\n            out[n] = awkward.type._fromarray(x, seen)\n        return out\n\n    def _util_layout(self, position, seen, lookup):\n        args = ()\n        for i, (n, x) in enumerate(self._contents.items()):\n            awkward.type.LayoutNode(x, position + (i,), seen, lookup)\n            args = args + (awkward.type.LayoutArg(n, position + (i,)),)\n        return args\n\n    def _length(self):\n        if self._view is None:\n            if len(self._contents) == 0:\n                return 0\n            else:\n                return min([len(x) for x in self._contents.values()])\n\n        elif isinstance(self._view, tuple):\n            start, step, length = self._view\n            return length\n\n        else:\n            return len(self._view)\n\n    def _index(self):\n        if self._view is None:\n            return slice(self._length())\n\n        elif isinstance(self._view, tuple):\n            start, step, length = self._view\n            stop = start + step*length\n            if stop < 0:\n                stop = None\n            return slice(start, stop, step)\n\n        else:\n            return self._view\n\n    def _newslice(self, head):\n        if self._util_isinteger(head):\n            original_head = head\n\n            if self._view is None:\n                length = self._length()\n                if head < 0:\n                    head += length\n                if not 0 <= head < length:\n                    raise IndexError(""index {0} out of bounds for length {1}"".format(original_head, length))\n                return head\n\n            elif isinstance(self._view, tuple):\n                mystart, mystep, mylength = self._view\n                if head < 0:\n                    head += mylength\n                if not 0 <= head < mylength:\n                    raise IndexError(""index {0} out of bounds for length {1}"".format(original_head, mylength))\n                return mystart + mystep*head\n\n            else:\n                length = len(self._view)\n                if head < 0:\n                    head += length\n                if not 0 <= head < length:\n                    raise IndexError(""index {0} out of bounds for length {1}"".format(original_head, length))\n                return self._view[head]\n\n        elif isinstance(head, slice):\n            if self._view is None or isinstance(self._view, tuple):\n                start, stop, step = head.indices(self._length())\n                if step == 0:\n                    raise ValueError(""slice step cannot be zero"")\n                if (step > 0 and stop - start > 0) or (step < 0 and stop - start < 0):\n                    d, m = divmod(abs(start - stop), abs(step))\n                    length = d + (1 if m != 0 else 0)\n                else:\n                    length = 0\n\n            if self._view is None:\n                return start, step, length\n\n            elif isinstance(self._view, tuple):\n                mystart, mystep, mylength = self._view\n                if step > 0:\n                    skip = start\n                else:\n                    skip = mylength - 1 - start\n                return mystart + mystep*start, mystep*step, min(mylength - skip, length)\n\n            else:\n                return self._view[head]\n\n        else:\n            head = self._util_toarray(head, self.INDEXTYPE)\n            if self._util_isintegertype(head.dtype.type):\n                length = self._length()\n                negative = (head < 0)\n                if negative.any():\n                    head[negative] += length\n                if not self.numpy.bitwise_and(0 <= head, head < length).all():\n                    raise IndexError(""some indexes out of bounds for length {0}"".format(length))\n\n                if self._view is None:\n                    return head\n\n                elif isinstance(self._view, tuple):\n                    mystart, mystep, mylength = self._view\n                    return self.numpy.arange(mystart, mystart + mystep*mylength, mystep)[head]\n\n                else:\n                    return self._view[head]\n\n            elif issubclass(head.dtype.type, (self.numpy.bool, self.numpy.bool_)):\n                length = self._length()\n                if len(head) != length:\n                    raise IndexError(""boolean index of length {0} does not fit array of length {1}"".format(len(head), length))\n\n                if self._view is None:\n                    return self.numpy.arange(length)[head]\n\n                elif isinstance(self._view, tuple):\n                    mystart, mystep, mylength = self._view\n                    return self.numpy.arange(mystart, mystart + mystep*mylength, mystep)[head]\n\n                else:\n                    return self._view[head]\n\n            else:\n                raise TypeError(""cannot interpret dtype {0} as a fancy index or mask"".format(head.dtype))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            pass\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n\n        if self._view is None:\n            length = self._length()\n            i = 0\n            while i < length:\n                yield self.Row(self, i)\n                i += 1\n\n        elif isinstance(self._view, tuple):\n            mystart, mystep, mylength = self._view\n            i = 0\n            while i < mylength:\n                yield self.Row(self, mystart + i*mystep)\n                i += 1\n        else:\n            for i in self._view:\n                yield self.Row(self, i)\n\n    def __getitem__(self, where):\n        if self._util_isstringslice(where):\n            if isinstance(where, awkward.util.string):\n                if self._view is None:\n                    try:\n                        return self._contents[where]\n                    except KeyError:\n                        raise ValueError(""no column named {0}"".format(repr(where)))\n                else:\n                    index = self._index()\n                    try:\n                        return self._contents[where][index]\n                    except KeyError:\n                        raise ValueError(""no column named {0}"".format(repr(where)))\n            else:\n                contents = OrderedDict()\n                for n in where:\n                    try:\n                        contents[n] = self._contents[n]\n                    except KeyError:\n                        raise ValueError(""no column named {0}"".format(repr(n)))\n                return self.copy(contents=contents)\n\n        if isinstance(where, tuple) and where == ():\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[0], where[1:]\n\n        if tail != ():\n            raise NotImplementedError(""multidimensional index through a Table (TODO: needed for [0, n) -> [0, m) -> \\""table\\"" -> ...)"")\n\n        newslice = self._newslice(head)\n\n        if self._util_isinteger(newslice):\n            return self.Row(self, newslice)\n\n        else:\n            out = self.copy(contents=self._contents)\n            out._view = newslice\n            out._base = self\n            out._rowstart = None\n            return out\n\n    def __setitem__(self, where, what):\n        if self._view is not None:\n            raise ValueError(""new columns can only be attached to the original Table, not a view (try table.base[\'col\'] = array)"")\n\n        if isinstance(where, awkward.util.string):\n            try:\n                len(what)\n            except TypeError:\n                what = self.numpy.full(len(self), what)\n            self._contents[where] = self._util_toarray(what, self.DEFAULTTYPE)\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for x, y in zip(where, what):\n                try:\n                    len(y)\n                except TypeError:\n                    y = self.numpy.full(len(self), y)\n                self._contents[x] = self._util_toarray(y, self.DEFAULTTYPE)\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __delitem__(self, where):\n        if self._view is not None:\n            raise ValueError(""columns can only be removed from the original Table, not a view (try del table.base[\'col\'])"")\n\n        if isinstance(where, awkward.util.string):\n            del self._contents[where]\n        elif self._util_isstringslice(where):\n            for x in where:\n                del self._contents[x]\n        else:\n            raise TypeError(""invalid index for removing column from Table: {0}"".format(where))\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        inputsdict = None\n        for x in inputs:\n            if isinstance(x, Table):\n                x._valid()\n\n                if inputsdict is None:\n                    inputsdict = OrderedDict([(n, []) for n in x._contents])\n                    table = x\n                elif set(inputsdict) != set(x._contents):\n                    raise ValueError(""Tables have different sets of columns"")\n\n        assert inputsdict is not None\n\n        for x in inputs:\n            if isinstance(x, Table):\n                for n, y in x._contents.items():\n                    inputsdict[n].append(y[x._index()])\n            else:\n                for n in inputsdict:\n                    inputsdict[n].append(x)\n\n        newcolumns = {}\n        tuplelen = None\n        for n, x in inputsdict.items():\n            newcolumns[n] = getattr(ufunc, method)(*x, **kwargs)\n\n            if tuplelen is None:\n                if isinstance(x, tuple):\n                    tuplelen = len(x)\n                else:\n                    tuplelen = False\n            elif isinstance(x, tuple) != tuplelen:\n                raise AssertionError(""ufuncs return tuples of different lengths or some tuples and some non-tuples"")\n\n        assert len(newcolumns) != 0\n        assert tuplelen is not None\n\n        if self._util_iscomparison(ufunc):\n            out = None\n            for x in newcolumns.values():\n                assert isinstance(x, self.numpy.ndarray)\n                assert issubclass(x.dtype.type, (self.numpy.bool_, self.numpy.bool))\n                if out is None:\n                    out = x\n                else:\n                    out = self.numpy.bitwise_and(out, x, out=out)\n            assert out is not None\n            return out\n\n        if method == ""at"":\n            return None\n\n        if tuplelen is False:\n            out = table.empty_like()\n            for n in inputsdict:\n                out[n] = newcolumns[n]\n            return out\n\n        else:\n            out = [table.empty_like() for i in range(tuplelen)]\n            for n in inputsdict:\n                for i in range(tuplelen):\n                    out[i][n] = newcolumns[n]\n            return tuple(out)\n\n    @property\n    def counts(self):\n        return self.numpy.full(len(self), -1, dtype=self.INDEXTYPE)\n\n    def boolmask(self, maskedwhen=True):\n        if maskedwhen:\n            return self.numpy.zeros(len(self), dtype=self.MASKTYPE)\n        else:\n            return self.numpy.ones(len(self), dtype=self.MASKTYPE)\n\n    def choose(self, n):\n        raise TypeError(""cannot call choose on a Table"")\n\n    def argchoose(self, n):\n        raise TypeError(""cannot call argchoose on a Table"")\n\n    def distincts(self, nested=False):\n        raise TypeError(""cannot call distincts on a Table"")\n\n    def argdistincts(self, nested=False):\n        raise TypeError(""cannot call argdistincts on a Table"")\n\n    def pairs(self, nested=False):\n        raise TypeError(""cannot call pairs on a Table"")\n\n    def argpairs(self, nested=False):\n        raise TypeError(""cannot call argpairs on a Table"")\n\n    def cross(self, other, nested=False):\n        raise TypeError(""cannot call cross on a Table"")\n\n    def argcross(self, other, nested=False):\n        raise TypeError(""cannot call argcross on a Table"")\n\n    def flatten(self, axis=0):\n        raise ValueError(""cannot flatten through a Table"")\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        out = self.copy(contents={})\n        for n, x in self._contents.items():\n            out[n] = self._util_pad(x, length, maskedwhen, clip, axis)\n        return out\n\n    def regular(self):\n        self._valid()\n        pairs = [(n, self._util_regular(x)) for n, x in self.items()]\n        out = self.numpy.empty(len(self), [(n, x.dtype, x.shape[1:]) for n, x in pairs])\n        for n, x in pairs:\n            out[n] = x\n        return out\n\n    def flattentuple(self):\n        out = self.copy()\n        out._contents = OrderedDict([(n, x.flattentuple() if isinstance(x, Table) else x) for n, x in out._contents.items()])\n\n        if self.istuple:\n            contents = OrderedDict()\n            for n, x in out._contents.items():\n                if isinstance(x, Table) and x.istuple:\n                    if x._view is None:\n                        view = slice(x._length())\n\n                    elif isinstance(x._view, tuple):\n                        start, step, length = x._view\n                        stop = start + step*length\n                        if stop < 0:\n                            stop = None\n                        view = slice(start, stop, step)\n\n                    else:\n                        view = x._view\n\n                    for y in x._contents.values():\n                        contents[str(len(contents))] = y[view]\n\n                else:\n                    contents[str(len(contents))] = x\n\n            out._contents = contents\n\n        return out\n\n    def _hasjagged(self):\n        num = sum(1 if self._util_hasjagged(x) else 0 for x in self._contents.values())\n        if num == 0:\n            return False\n        elif num == len(self._contents):\n            return True\n        else:\n            raise ValueError(""some Table columns are jagged and others are not"")\n\n    def _reduce(self, ufunc, identity, dtype):\n        if self._hasjagged():\n            out = self.copy(contents={})\n            for n, x in self._contents.items():\n                out[n] = self._util_reduce(x, ufunc, identity, dtype)\n            return out\n\n        else:\n            out = self.Table.named({\n                self.numpy.bitwise_or: ""any"",\n                self.numpy.bitwise_and: ""all"",\n                None: ""count"",\n                self.numpy.count_nonzero: ""count_nonzero"",\n                self.numpy.add: ""sum"",\n                self.numpy.multiply: ""prod"",\n                self.numpy.minimum: ""min"",\n                self.numpy.maximum: ""max""\n                }[ufunc])\n            out._showdict = True\n            for n in self._contents:\n                x = self._contents[n][self._index()]\n                out[n] = self.numpy.array([self._util_reduce(x, ufunc, identity, dtype)])\n            return out.Row(out, 0)\n\n    def _prepare(self, ufunc, identity, dtype):\n        out = self.copy(contents={})\n        for n, x in self._contents.items():\n            if isinstance(x, self.numpy.ndarray):\n                if dtype is None and issubclass(x.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                    dtype = self.numpy.dtype(type(identity))\n                if dtype is not None:\n                    x = x.astype(dtype)\n            else:\n                x = x._prepare(ufunc, identity, dtype)\n            out[n] = x\n        return out\n\n    def argmin(self):\n        raise TypeError(""cannot call argmin on Table"")\n\n    def argmax(self):\n        raise TypeError(""cannot call argmax on Table"")\n\n    def _util_columns(self, seen):\n        if id(self) in seen:\n            return []\n        seen.add(id(self))\n        return list(self._contents)\n\n    def astype(self, dtype):\n        out = self.copy(contents={})\n        for n, x in self._contents.items():\n            out[n] = x.astype(dtype)\n        return out\n\n    def fillna(self, value):\n        out = self.copy(contents={})\n        for n, x in self._contents.items():\n            out[n] = self._util_fillna(x, value)\n        return out\n\n    @classmethod\n    def _concatenate_axis0(cls, tables):\n        for i in range(len(tables)-1):\n            if set(tables[i]._contents) != set(tables[i+1]._contents):\n                raise ValueError(""cannot concatenate Tables with different fields"")\n\n        out = tables[0].deepcopy(contents=OrderedDict())\n\n        for n in tables[0]._contents:\n            content_type = type(tables[0]._contents[n])\n            if content_type == cls.numpy.ndarray:\n                concatenate = cls.numpy.concatenate\n            else:\n                concatenate = content_type.concatenate\n\n            out._contents[n] = concatenate([t[n] for t in tables], axis=0)\n\n        out._valid()\n        return out\n\n    _topandas_name = ""TableSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            out._contents = OrderedDict((n, x._topandas(seen) if isinstance(x, awkward.array.base.AwkwardArray) else x) for n, x in out._contents.items())\n            return out\n'"
awkward/array/union.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.base\nimport awkward.type\nimport awkward.util\n\nclass UnionArray(awkward.array.base.AwkwardArray):\n    """"""\n    UnionArray\n    """"""\n\n    def __init__(self, tags, index, contents):\n        self.tags = tags\n        self.index = index\n        self.contents = contents\n\n    @classmethod\n    def fromtags(cls, tags, contents):\n        out = cls.__new__(cls)\n        out.tags = tags\n        out.contents = contents\n\n        if len(out._tags.reshape(-1)) > 0 and out._tags.reshape(-1).max() >= len(out._contents):\n            raise ValueError(""maximum tag is {0} but there are only {1} contents arrays"".format(out._tags.reshape(-1).max(), len(out._contents)))\n\n        index = cls.numpy.full(out._tags.shape, -1, dtype=cls.INDEXTYPE)\n        for tag, content in enumerate(out._contents):\n            mask = (out._tags == tag)\n            index[mask] = cls.numpy.arange(cls.numpy.count_nonzero(mask))\n\n        out.index = index\n        return out\n\n    def copy(self, tags=None, index=None, contents=None):\n        out = self.__class__.__new__(self.__class__)\n        out._tags = self._tags\n        out._index = self._index\n        out._contents = self._contents\n        out._dtype = self._dtype\n        out._isvalid = self._isvalid\n        if tags is not None:\n            out.tags = tags\n        if index is not None:\n            out.index = index\n        if contents is not None:\n            out.contents = contents\n        return out\n\n    def deepcopy(self, tags=None, index=None, contents=None):\n        out = self.copy(tags=tags, index=index, contents=contents)\n        out._tags = self._util_deepcopy(out._tags)\n        out._index = self._util_deepcopy(out._index)\n        out._contents = [self._util_deepcopy(x) for x in out._contents]\n        return out\n\n    def empty_like(self, **overrides):\n        return self.copy(contents=[self.numpy.empty_like(x) if isinstance(x, self.numpy.ndarray) else x.empty_like(**overrides) for x in self._contents])\n\n    def zeros_like(self, **overrides):\n        return self.copy(contents=[self.numpy.zeros_like(x) if isinstance(x, self.numpy.ndarray) else x.zeros_like(**overrides) for x in self._contents])\n\n    def ones_like(self, **overrides):\n        return self.copy(contents=[self.numpy.ones_like(x) if isinstance(x, self.numpy.ndarray) else x.ones_like(**overrides) for x in self._contents])\n\n    @property\n    def issequential(self):\n        self._valid()\n        for tag in self.numpy.unique(self._tags):\n            mask = self._tags == tag\n            if not self.numpy.array_equal(self._index[mask], self.numpy.arange(self.numpy.count_nonzero(mask))):\n                return False\n        return True\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n        if self.issequential:\n            return serializer.encode_call(\n                [""awkward"", ""UnionArray"", ""fromtags""],\n                serializer(self._tags, ""UnionArray.tags""),\n                {""list"": [\n                    serializer(x, ""UnionArray.contents"")\n                    for x in self._contents\n                ]},\n            )\n\n        else:\n            return serializer.encode_call(\n                [""awkward"", ""UnionArray""],\n                serializer(self._tags, ""UnionArray.tags""),\n                serializer(self._index, ""UnionArray.index""),\n                {""list"": [\n                    serializer(x, ""UnionArray.contents"")\n                    for x in self._contents\n                ]}\n            )\n\n    @property\n    def tags(self):\n        return self._tags\n\n    @tags.setter\n    def tags(self, value):\n        value = self._util_toarray(value, self.TAGTYPE, self.numpy.ndarray)\n        tagsmax = value.max()\n        if tagsmax <= self.numpy.iinfo(self.TAGTYPE).max:\n            value = value.astype(self.TAGTYPE)\n        elif tagsmax <= self.numpy.iinfo(self.numpy.uint8).max:\n            value = value.astype(self.numpy.uint8)\n        elif tagsmax <= self.numpy.iinfo(self.numpy.uint16).max:\n            value = value.astype(self.numpy.uint16)\n        elif tagsmax <= self.numpy.iinfo(self.numpy.uint32).max:\n            value = value.astype(self.numpy.uint32)\n        elif tagsmax <= self.numpy.iinfo(self.numpy.uint64).max:\n            value = value.astype(self.numpy.uint64)\n        else:\n            raise ValueError(""maximum tag must be at most {0}"".format(self.numpy.iinfo(self.numpy.uint64).max))\n\n        if self.check_prop_valid:\n            if len(value) == 0:\n                raise ValueError(""tags must be non-empty"")\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""tags must have integer dtype"")\n            if (value < 0).any():\n                raise ValueError(""tags must be a non-negative array"")\n        self._tags = value\n        self._isvalid = False\n\n    @property\n    def index(self):\n        return self._index\n\n    @index.setter\n    def index(self, value):\n        value = self._util_toarray(value, self.INDEXTYPE, self.numpy.ndarray)\n        if self.check_prop_valid:\n            if not self._util_isintegertype(value.dtype.type):\n                raise TypeError(""index must have integer dtype"")\n            if (value < 0).any():\n                raise ValueError(""index must be a non-negative array"")\n        self._index = value\n        self._isvalid = False\n\n    @property\n    def contents(self):\n        return self._contents\n\n    @contents.setter\n    def contents(self, value):\n        if self.check_prop_valid:\n            try:\n                iter(value)\n            except TypeError:\n                raise TypeError(""contents must be iterable"")\n        value = tuple(self._util_toarray(x, self.DEFAULTTYPE) for x in value)\n        if self.check_prop_valid:\n            if len(value) == 0:\n                raise ValueError(""contents must be non-empty"")\n        self._contents = value\n        self._dtype = None\n        self._isvalid = False\n\n    @classmethod\n    def uniondtype(cls, arrays):\n        if all(issubclass(x.dtype.type, (cls.numpy.bool_, cls.numpy.bool)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.bool_)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.int8)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.int8)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.uint8)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.uint8)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.int8, cls.numpy.uint8, cls.numpy.int16)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.int16)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.uint8, cls.numpy.uint16)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.uint16)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.int8, cls.numpy.uint8, cls.numpy.int16, cls.numpy.uint16, cls.numpy.int32)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.int32)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.uint8, cls.numpy.uint16, cls.numpy.uint32)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.uint32)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.int8, cls.numpy.uint8, cls.numpy.int16, cls.numpy.uint16, cls.numpy.int32, cls.numpy.uint32, cls.numpy.int64)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.int64)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.uint8, cls.numpy.uint16, cls.numpy.uint32, cls.numpy.uint64)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.uint64)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.float16)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.float16)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.float16, cls.numpy.float32)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.float32)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.float16, cls.numpy.float32, cls.numpy.float64)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.float64)\n\n        elif hasattr(cls.numpy, ""float128"") and all(issubclass(x.dtype.type, (cls.numpy.float16, cls.numpy.float32, cls.numpy.float64, cls.numpy.float128)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.float128)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.integer, cls.numpy.floating)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.float64)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.complex64)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.complex64)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.complex64, cls.numpy.complex128)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.complex128)\n\n        elif hasattr(cls.numpy, ""complex256"") and all(issubclass(x.dtype.type, (cls.numpy.complex64, cls.numpy.complex128, cls.numpy.complex256)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.complex256)\n\n        elif all(issubclass(x.dtype.type, (cls.numpy.integer, cls.numpy.floating, cls.numpy.complexfloating)) for x in arrays):\n            return cls.numpy.dtype(cls.numpy.complex128)\n\n        else:\n            return cls.numpy.dtype(cls.numpy.object_)\n\n    @property\n    def dtype(self):\n        if self._dtype is None:\n            self._dtype = self.uniondtype(self._contents)\n        return self._dtype\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            return sum(x.nbytes if isinstance(x, self.numpy.ndarray) else x._getnbytes(seen) for x in self._contents)\n\n    def __len__(self):\n        return len(self._tags)\n\n    def _gettype(self, seen):\n        out = awkward.type.UnionType()\n        for x in self._contents:\n            out.append(awkward.type._fromarray(x, seen))\n        for x in self._tags.shape[:0:-1]:\n            out = awkward.type.ArrayType(x, out)\n        return out\n\n    def _util_layout(self, position, seen, lookup):\n        awkward.type.LayoutNode(self._tags, position + (0,), seen, lookup)\n        awkward.type.LayoutNode(self._index, position + (1,), seen, lookup)\n        positions = []\n        for i, x in enumerate(self._contents):\n            awkward.type.LayoutNode(x, position + (2 + i,), seen, lookup)\n            positions.append(position + (2 + i,))\n        return (awkward.type.LayoutArg(""tags"", position + (0,)),\n                awkward.type.LayoutArg(""index"", position + (1,)),\n                awkward.type.LayoutArg(""contents"", positions))\n\n    def _valid(self):\n        if self.check_whole_valid:\n            if not self._isvalid:\n                if len(self._tags.shape) > len(self._index.shape):\n                    raise ValueError(""tags length ({0}) must be less than or equal to index length ({1})"".format(len(self._tags.shape), len(self._index.shape)))\n\n                if self._tags.shape[1:] != self._index.shape[1:]:\n                    raise ValueError(""tags dimensionality ({0}) must be equal to index dimensionality ({1})"".format(self._tags.shape[1:], self._index.shape[1:]))\n\n                if len(self._tags.reshape(-1)) > 0 and self._tags.reshape(-1).max() >= len(self._contents):\n                    raise ValueError(""maximum tag is {0} but there are only {1} contents arrays"".format(self._tags.reshape(-1).max(), len(self._contents)))\n\n                index = self._index[:len(self._tags)]\n                for tag in self.numpy.unique(self._tags):\n                    maxindex = index[self._tags == tag].reshape(-1).max()\n                    if maxindex >= len(self._contents[tag]):\n                        raise ValueError(""maximum index ({0}) must be less than the length of all contents arrays ({1})"".format(maxindex, len(self._contents[tag])))\n\n                self._isvalid = True\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        self._valid()\n\n        tags = self._tags\n        lentags = len(self._tags)\n        index = self._index\n        contents = self._contents\n\n        i = 0\n        while i < lentags:\n            yield contents[tags[i]][index[i]]\n            i += 1\n\n    def __getitem__(self, where):\n        self._valid()\n\n        if self._util_isstringslice(where):\n            contents = []\n            for tag in self.numpy.unique(self._tags):\n                contents.append(self._contents[tag][where])\n            # TODO: think about inheriting methods from contents[where]; all satisfying tags would have to have the same methods before promoting the output (generalized maybemixin?)\n            if len(contents) == 0:\n                return self.copy(contents=[self._contents[0][where]])\n            else:\n                return self.copy(contents=contents)\n\n        if isinstance(where, tuple) and len(where) == 0:\n            return self\n        if not isinstance(where, tuple):\n            where = (where,)\n        head, tail = where[:len(self._tags.shape)], where[len(self._tags.shape):]\n\n        tags = self._tags[head]\n        index = self._index[:len(self._tags)][head]\n\n        if len(tags.shape) == len(index.shape) == 0:\n            return self._contents[tags][(index,) + tail]\n        else:\n            if len(tags) == 0:\n                return self._contents[0][(index,) + tail]\n            elif (tags == tags[0]).all():\n                return self._contents[tags[0]][(index,) + tail]\n            else:\n                return self.copy(tags=tags, index=index)\n\n    def __setitem__(self, where, what):\n        if what.shape[:len(self._tags.shape)] != self._tags.shape:\n            raise ValueError(""array to assign does not have the same starting shape as tags"")\n\n        if isinstance(where, awkward.util.string):\n            for tag in self.numpy.unique(self._tags):\n                inverseindex = self.IndexedArray.invert(self._index[:len(self._tags)][self._tags == tag])\n                self._contents[tag][where] = self.IndexedArray(inverseindex, what)\n\n        elif self._util_isstringslice(where):\n            what = what.unzip()\n            if len(where) != len(what):\n                raise ValueError(""number of keys ({0}) does not match number of provided arrays ({1})"".format(len(where), len(what)))\n            for tag in self.numpy.unique(self._tags):\n                inverseindex = self.IndexedArray.invert(self._index[:len(self._tags)][self._tags == tag])\n                for x, y in zip(where, what):\n                    self._contents[tag][x] = self.IndexedArray(inverseindex, y)\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __delitem__(self, where):\n        if isinstance(where, awkward.util.string):\n            for tag in self.numpy.unique(self._tags):\n                del self._contents[tag][where]\n\n        elif self._util_isstringslice(where):\n            for tag in self.numpy.unique(self._tags):\n                for x in where:\n                    del self._contents[tag][x]\n\n        else:\n            raise TypeError(""invalid index for assigning column to Table: {0}"".format(where))\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        tags = []\n        for x in inputs:\n            if isinstance(x, UnionArray):\n                x._valid()\n                tags.append(x._tags)\n        assert len(tags) > 0\n\n        if any(x.shape != tags[0].shape for x in tags[1:]):\n            raise ValueError(""cannot {0} UnionArrays because tag shapes differ"".format(ufunc))\n\n        combos = self.numpy.stack(tags, axis=-1).view([(str(i), x.dtype) for i, x in enumerate(tags)]).reshape(tags[0].shape)\n\n        outtags = self.numpy.empty(tags[0].shape, dtype=self.TAGTYPE)\n        outindex = self.numpy.empty(tags[0].shape, dtype=self.INDEXTYPE)\n\n        out = None\n        contents = {}\n        types = {}\n        for outtag, combo in enumerate(self.numpy.unique(combos)):\n            mask = (combos == combo)\n            outtags[mask] = outtag\n            outindex[mask] = self.numpy.arange(self.numpy.count_nonzero(mask))\n\n            result = getattr(ufunc, method)(*[x[mask] if isinstance(x, UnionArray) else x for x in inputs], **kwargs)\n\n            if isinstance(result, tuple):\n                if out is None:\n                    out = list(result)\n                for i, x in enumerate(result):\n                    if isinstance(x, (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                        if i not in contents:\n                            contents[i] = []\n                        contents[i].append(x)\n                        types[i] = type(x)\n\n            elif method == ""at"":\n                pass\n\n            else:\n                if isinstance(result, (self.numpy.ndarray, awkward.array.base.AwkwardArray)):\n                    if None not in contents:\n                        contents[None] = []\n                    contents[None].append(result)\n                    types[None] = type(result)\n\n        if out is None:\n            if None in contents:\n                return self.Methods.maybemixin(types[None], UnionArray)(outtags, outindex, contents[None])\n            else:\n                return None\n        else:\n            for i in range(len(out)):\n                if i in contents:\n                    out[i] = self.Methods.maybemixin(types[i], UnionArray)(outtags, outindex, contents[i])\n            return tuple(out)\n\n    @property\n    def counts(self):\n        self._valid()\n        arrays = [self._util_counts(x) for x in self._contents]\n        out = self.numpy.empty(len(self), self.uniondtype(arrays))\n        for tag, array in enumerate(arrays):\n            mask = (self._tags == tag)\n            out[mask] = array[self._index[mask]]\n        return out\n\n    def boolmask(self, maskedwhen=True):\n        self._valid()\n        arrays = [self._util_boolmask(x, maskedwhen) for x in self._contents]\n        out = self.numpy.empty(len(self), self.MASKTYPE)\n        for tag, array in enumerate(arrays):\n            mask = (self._tags == tag)\n            out[mask] = array[self._index[mask]]\n        return out\n\n    def choose(self, n):\n        raise NotImplementedError(""choose not yet implemented for UnionArray"")\n\n    def argchoose(self, n):\n        raise NotImplementedError(""argchoose not yet implemented for UnionArray"")\n\n    def distincts(self, nested=False):\n        raise NotImplementedError(""distincts not yet implemented for UnionArray"")\n\n    def argdistincts(self, nested=False):\n        raise NotImplementedError(""argdistincts not yet implemented for UnionArray"")\n\n    def pairs(self, nested=False):\n        raise NotImplementedError(""pairs not yet implemented for UnionArray"")\n\n    def argpairs(self, nested=False):\n        raise NotImplementedError(""argpairs not yet implemented for UnionArray"")\n\n    def cross(self, other, nested=False):\n        raise NotImplementedError(""cross not yet implemented for UnionArray"")\n\n    def argcross(self, other, nested=False):\n        raise NotImplementedError(""argcross not yet implemented for UnionArray"")\n\n    def flattentuple(self):\n        return self.copy(contents=[self._util_flattentuple(x) for x in self._contents])\n\n    def flatten(self, axis=0):\n        raise NotImplementedError(""flatten not yet implemented for UnionArray"")\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        self._valid()\n        return self.copy(contents=[self._util_pad(x, length, maskedwhen, clip, axis) for x in self._contents])\n\n    def regular(self):\n        self._valid()\n        arrays = [self._util_regular(x) for x in self._contents]\n        out = self.numpy.empty(len(self), self.uniondtype(arrays))\n        for tag, array in enumerate(arrays):\n            mask = (self._tags == tag)\n            out[mask] = array[self._index[mask]]\n        return out\n\n    def _hasjagged(self):\n        num = sum(1 if self._util_hasjagged(x) else 0 for x in self._contents)\n        if num == 0:\n            return False\n        elif num == len(self._contents):\n            return True\n        else:\n            raise ValueError(""some UnionArray possibilities are jagged and others are not"")\n\n    def _reduce(self, ufunc, identity, dtype):\n        prepared = self._prepare(ufunc, identity, dtype)\n        if ufunc is None:\n            return (1 - self.numpy.isnan(prepared)).sum()\n        elif ufunc is self.numpy.count_nonzero:\n            return (1 - (prepared == 0)).sum()\n        if issubclass(prepared.dtype.type, (self.numpy.floating, self.numpy.complexfloating)):\n            prepared = self.numpy.where(self.numpy.isnan(prepared), identity, prepared)\n        return ufunc.reduce(prepared)\n\n    def _prepare(self, ufunc, identity, dtype):\n        if dtype is None and issubclass(self.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n            dtype = self.numpy.dtype(type(identity))\n        if dtype is None:\n            dtype = self.dtype\n\n        out = None\n        index = self._index[:len(self._tags)]\n        for tag, content in enumerate(self._contents):\n            if not isinstance(content, self.numpy.ndarray):\n                content = content._prepare(ufunc, identity, dtype)\n\n            if not isinstance(content, self.numpy.ndarray):\n                raise TypeError(""cannot reduce a UnionArray of non-primitive type"")\n\n            mask = (self._tags == tag)\n            c = content[index[mask]]\n\n            if out is None:\n                out = self.numpy.full(self._tags.shape[:1] + c.shape[1:], identity, dtype=dtype)\n            out[mask] = c\n\n        return out\n\n    def argmin(self):\n        raise NotImplementedError(""argmin not yet implemented for UnionArray"")\n\n    def argmax(self):\n        raise NotImplementedError(""argmax not yet implemented for UnionArray"")\n\n    def _util_columns(self, seen):\n        if id(self) in seen:\n            return []\n        seen.add(id(self))\n        out = None\n        for content in self._contents:\n            tmp = self._util_columns_descend(content, seen)\n            if out is None:\n                out = tmp\n            else:\n                out = out + [x for x in tmp if x not in out]\n        if out is None:\n            return []\n        else:\n            return out\n\n    def _util_rowname(self, seen):\n        if id(self) in seen:\n            raise TypeError(""not a Table, so there is no rowname"")\n        seen.add(id(self))\n        out = None\n        for content in self._contents:\n            tmp = self._util_rowname_descend(content, seen)\n        if out is None:\n            out = tmp\n        elif out != tmp:\n            raise TypeError(""union of multiple Tables with different names, so there is no single rowname"")\n        if out is None:\n            raise TypeError(""not a Table, so there is no rowname"")\n        else:\n            return out\n\n    def astype(self, dtype):\n        return self.copy(contents=[x.astype(dtype) for x in self._contents])\n\n    def fillna(self, value):\n        return self.copy(contents=[self._util_fillna(x, value) for x in self._contents])\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, UnionArray) for x in arrays)\n        tags = cls.numpy.concatenate([cls.numpy.full(len(x), i, dtype=cls.TAGTYPE) for i, x in enumerate(arrays)])\n        return cls.UnionArray.fget(None).fromtags(tags, arrays)\n\n    _topandas_name = ""UnionSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.copy()\n            out.__class__ = awkward.pandas.mixin(type(self))\n            out._contents = [x._topandas(seen) if isinstance(x, awkward.array.base.AwkwardArray) else x for x in out._contents]\n            return out\n'"
awkward/array/virtual.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport importlib\nfrom collections import OrderedDict\n\nimport awkward.array.base\nimport awkward.persist\nimport awkward.type\nimport awkward.util\n\nclass VirtualArray(awkward.array.base.AwkwardArray):\n    """"""\n    VirtualArray\n    """"""\n\n    class TransientKey(object):\n        def __init__(self, id):\n            self._id = id\n        def __repr__(self):\n            return ""<VirtualArray.TransientKey {0}>"".format(repr(self._id))\n        def __str__(self):\n            return ""_"" + repr(self._id)\n        def __hash__(self):\n            return hash((VirtualArray.TransientKey, self._id))\n        def __eq__(self, other):\n            return isinstance(other, VirtualArray.TransientKey) and self._id == other._id\n        def __ne__(self, other):\n            return not self.__eq__(other)\n        def __getstate__(self):\n            raise RuntimeError(""VirtualArray.TransientKeys are not unique across processes, and hence should not be serialized"")\n\n    def __init__(self, generator, args=(), kwargs={}, cache=None, persistentkey=None, type=None, nbytes=None, persistvirtual=True):\n        self.generator = generator\n        self.args = args\n        self.kwargs = kwargs\n        self.cache = cache\n        self.persistentkey = persistentkey\n        self.type = type\n        self.nbytes = nbytes\n        self.persistvirtual = persistvirtual\n        self._array = None if cache is None else self.key\n        self._setitem = None\n        self._delitem = None\n\n    def copy(self, generator=None, args=None, kwargs=None, cache=None, persistentkey=None, type=None, nbytes=None, persistvirtual=None):\n        # FIXME: arguments through **kwargs because undef is different from None (None has meaning for some of them)\n        out = self.__class__.__new__(self.__class__)\n        out._generator = self._generator\n        out._args = self._args\n        out._kwargs = self._kwargs\n        out._cache = self._cache\n        out._persistentkey = self._persistentkey\n        out._type = self._type\n        out._nbytes = self._nbytes\n        out._persistvirtual = self._persistvirtual\n        out._array = self._array\n        if self._setitem is None:\n            out._setitem = None\n        else:\n            out._setitem = OrderedDict(self._setitem.items())\n        if self._delitem is None:\n            out._delitem = None\n        else:\n            out._delitem = list(self._delitem)\n        if generator is not None:\n            out.generator = generator\n        if args is not None:\n            out.args = args\n        if kwargs is not None:\n            out.kwargs = kwargs\n        if cache is not None:\n            out.cache = cache\n        if persistentkey is not None:\n            out.persistentkey = persistentkey\n        if type is not None:\n            out.type = type\n        if nbytes is not None:\n            out.nbytes = nbytes\n        if persistvirtual is not None:\n            out.persistvirtual = persistvirtual\n        return out\n\n    def deepcopy(self, generator=None, args=None, kwargs=None, cache=None, persistentkey=None, type=None, nbytes=None, persistvirtual=None):\n        out = self.copy(generator=generator, args=args, kwargs=kwargs, cache=cache, persistentkey=persistentkey, type=type, nbytes=nbytes, persistvirtual=persistvirtual)\n        out._array = self._util_deepcopy(out._array)\n        if out._setitem is not None:\n            for n in list(out._setitem):\n                out._setitem[n] = self._util_deepcopy(out._setitem[n])\n        return out\n\n    def empty_like(self, **overrides):\n        if isinstance(self.array, self.numpy.ndarray):\n            return self.numpy.empty_like(self.array)\n        else:\n            return self.array.empty_like(**overrides)\n\n    def zeros_like(self, **overrides):\n        if isinstance(self.array, self.numpy.ndarray):\n            return self.numpy.zeros_like(self.array)\n        else:\n            return self.array.zeros_like(**overrides)\n\n    def ones_like(self, **overrides):\n        if isinstance(self.array, self.numpy.ndarray):\n            return self.numpy.ones_like(self.array)\n        else:\n            return self.array.ones_like(**overrides)\n\n    def __awkward_serialize__(self, serializer):\n        self._valid()\n\n        if self._persistvirtual:\n            out = serializer.encode_call(\n                [""awkward"", ""VirtualArray""],\n                serializer(self._generator, ""VirtualArray.generator""),\n                {""tuple"": [\n                    serializer(x, ""VirtualArray.args"")\n                    for x in self._args\n                ]},\n                {""dict"": {\n                    n: serializer(x, ""VirtualArray.kwargs"")\n                    for n, x in self._kwargs.items()\n                }}\n            )\n            out[""cacheable""] = True\n            others = {}\n            if self._persistentkey is not None:\n                others[""persistentkey""] = serializer(self._persistentkey)\n\n            if self._type is not None:\n                others[""type""] = serializer.encode_call(\n                    [""awkward.persist"", ""json2type""],\n                    {""json"": awkward.persist.type2json(self._type)},\n                )\n                others[""type""][""whitelistable""] = True\n            if others:\n                out[""kwargs""] = others\n        else:\n            out = serializer(self.array, ""VirtualArray.array"")\n            out.pop(""id"")\n\n        return out\n\n    @property\n    def generator(self):\n        return self._generator\n\n    @generator.setter\n    def generator(self, value):\n        if self.check_prop_valid:\n            if not callable(value):\n                raise TypeError(""generator must be a callable"")\n        self._generator = value\n\n\n    @property\n    def args(self):\n        return self._args\n\n    @args.setter\n    def args(self, value):\n        if not isinstance(value, tuple):\n            value = (value,)\n        self._args = value\n\n    @property\n    def kwargs(self):\n        return self._kwargs\n\n    @kwargs.setter\n    def kwargs(self, value):\n        if self.check_prop_valid:\n            if not isinstance(value, dict):\n                raise TypeError(""kwargs must be a dict"")\n        self._kwargs = dict(value)\n\n    @property\n    def cache(self):\n        return self._cache\n\n    @cache.setter\n    def cache(self, value):\n        if self.check_prop_valid:\n            if not value is None and not (callable(getattr(value, ""__getitem__"", None)) and callable(getattr(value, ""__setitem__"", None)) and callable(getattr(value, ""__delitem__"", None))):\n                raise TypeError(""cache must be None, a dict, or have __getitem__/__setitem__/__delitem__ methods"")\n        self._cache = value\n\n    @property\n    def persistentkey(self):\n        return self._persistentkey\n\n    @persistentkey.setter\n    def persistentkey(self, value):\n        if self.check_prop_valid:\n            if value is not None and not isinstance(value, awkward.util.string):\n                raise TypeError(""persistentkey must be None or a string"")\n        self._persistentkey = value\n\n    @property\n    def persistvirtual(self):\n        return self._persistvirtual\n\n    @persistvirtual.setter\n    def persistvirtual(self, value):\n        if self.check_prop_valid:\n            if not isinstance(value, (bool, self.numpy.bool_, self.numpy.bool)):\n                raise TypeError(""persistvirtual must be boolean"")\n        self._persistvirtual = bool(value)\n\n    def _gettype(self, seen):\n        if self._type is None or self.ismaterialized:\n            return awkward.type._fromarray(self.array, seen)\n        else:\n            return self._type.to\n\n    def _util_layout(self, position, seen, lookup):\n        args = (awkward.type.LayoutArg(""generator"", self._generator),\n                awkward.type.LayoutArg(""args"", self._args),\n                awkward.type.LayoutArg(""kwargs"", dict(self._kwargs)))\n        if self.ismaterialized:\n            awkward.type.LayoutNode(self.array, position + (0,), seen, lookup)\n            args = args + (awkward.type.LayoutArg(""array"", position + (0,)),)\n        return args\n\n    @property\n    def type(self):\n        if self._type is None or self.ismaterialized:\n            return awkward.type.ArrayType(len(self.array), awkward.type._resolve(awkward.type._fromarray(self.array, {}), {}))\n        else:\n            return self._type\n\n    @type.setter\n    def type(self, value):\n        if self.check_prop_valid:\n            if value is not None and not isinstance(value, awkward.type.ArrayType):\n                raise TypeError(""type must be None or an awkward type (to set Numpy parameters, use awkward.util.fromnumpy(shape, dtype, masked=False))"")\n        self._type = value\n\n    def _getnbytes(self, seen):\n        if id(self) in seen:\n            return 0\n        else:\n            seen.add(id(self))\n            if self._nbytes is None or self.ismaterialized:\n                array = self.array\n                return (array.nbytes if isinstance(array, self.numpy.ndarray) else array._getnbytes(seen))\n            else:\n                return self._nbytes\n\n    @property\n    def nbytes(self):\n        return self._getnbytes(set())\n\n    @nbytes.setter\n    def nbytes(self, value):\n        if self.check_prop_valid:\n            if value is not None:\n                if not self._util_isinteger(value):\n                    raise TypeError(""nbytes must be an integer or None"")\n                if value < 0:\n                    raise ValueError(""nbytes must be a non-negative integer or None"")\n            self._nbytes = value\n\n    def __len__(self):\n        return self.shape[0]\n\n    def _valid(self):\n        if self.check_whole_valid:\n            pass\n\n    @property\n    def key(self):\n        if self._persistentkey is not None:\n            return self._persistentkey\n        else:\n            return self.TransientKey(id(self))\n\n    @property\n    def array(self):\n        # Normal states:\n        #   (1) no cache and _array is None: make a new one\n        #   (2) no cache and _array is an array: return _array\n        #   (3) have a cache and _array is None: make a new one (filling cache)\n        #   (4) have a cache and _array is a key and cache[key] was evicted: make a new one (filling cache)\n        #   (5) have a cache and _array is a key and cache[key] exists: return cache[key]\n        #\n        # Abnormal states (user manually changed cache after materialization):\n        #   (6) no cache and _array is a key (user removed _cache): make a new one\n        #   (7) have a cache and _array is an array (user added _cache): fill cache and return _array\n\n        if self._array is None:\n            # states (1) and (3)\n            return self.materialize()\n\n        elif self._cache is None:\n            if isinstance(self._array, (VirtualArray.TransientKey, awkward.util.string)):\n                # abnormal state (6)\n                return self.materialize()\n            else:\n                # state (2)\n                return self._array\n\n        else:\n            if isinstance(self._array, (VirtualArray.TransientKey, awkward.util.string)):\n                try:\n                    # state (5)\n                    return self._cache[self._array]\n                except KeyError:\n                    # state (4), taking any error in __getitem__ as evidence that it was evicted\n                    return self.materialize()\n            else:\n                # abnormal state (7)\n                self._cache[self.key] = self._array\n                return self._array\n\n    @property\n    def ismaterialized(self):\n        if self._cache is None:\n            return isinstance(self._array, (self.numpy.ndarray, awkward.array.base.AwkwardArray))\n        else:\n            return self._array is not None and self._array in self._cache\n\n    def materialize(self):\n        array = self._util_toarray(self._generator(*self._args, **self._kwargs), self.DEFAULTTYPE)\n        if self._setitem is not None:\n            for n, x in self._setitem.items():\n                array[n] = x\n        if self._delitem is not None:\n            for n in self._delitem:\n                del array[n]\n\n        if self._type is not None:\n            materializedtype = awkward.type.fromarray(array)\n            if ((isinstance(self._type, awkward.type.Type) and not self._type._eq(materializedtype, set(), ignoremask=True)) or\n                (not isinstance(self._type, awkward.type.Type) and not self._type == materializedtype)):\n                raise TypeError(""materialized array has type\\n\\n{0}\\n\\nexpected type\\n\\n{1}"".format(awkward.type._str(awkward.type.fromarray(array), indent=""    ""), awkward.type._str(self._type, indent=""    "")))\n\n        if self._cache is None:\n            # states (1), (2), and (6)\n            self._array = array\n        else:\n            # states (3) and (4)\n            self._array = self.key\n            self._cache[self._array] = array\n\n        return array\n\n    def __del__(self):\n        # TransientKeys are based on runtime ids, which Python may reuse after an object is garbage collected\n        # they *MUST* be removed from the cache to avoid confusion; persistentkeys can (and should) stay in\n        if getattr(self, ""_cache"", None) is not None and isinstance(self._array, VirtualArray.TransientKey):\n            try:\n                del self._cache[self._array]\n            except:\n                pass\n\n    def __iter__(self, checkiter=True):\n        if checkiter:\n            self._checkiter()\n        return iter(self.array)\n\n    def __array__(self, *args, **kwargs):\n        self._checktonumpy()\n        return self.numpy.array(self.array, *args, **kwargs)\n\n    def __getitem__(self, where):\n        return self.array[where]\n\n    def __setitem__(self, where, what):\n        self.array[where] = what\n        if self._type is not None:\n            self._type = awkward.type.fromarray(self.array)\n        if self._setitem is None:\n            self._setitem = OrderedDict()\n        self._setitem[where] = what\n\n    def __delitem__(self, where):\n        del self.array[where]\n        if self._type is not None:\n            self._type = awkward.type.fromarray(self.array)\n        if self._setitem is not None and where in self._setitem:\n            del self._setitem\n        if self._delitem is None:\n            self._delitem = []\n        if where not in self._delitem:\n            self._delitem.append(where)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n\n        if method != ""__call__"":\n            return NotImplemented\n\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], VirtualArray):\n                inputs[i]._valid()\n                inputs[i] = inputs[i].array\n\n        return getattr(ufunc, method)(*inputs, **kwargs)\n\n    @property\n    def counts(self):\n        return self._util_counts(self.array)\n\n    def boolmask(self, maskedwhen=True):\n        return self._util_boolmask(self.array, maskedwhen)\n\n    def choose(self, n):\n        return self.array.choose(n)\n\n    def argchoose(self, n):\n        return self.array.argchoose(n)\n\n    def distincts(self, nested=False):\n        return self.array.distincts(nested=nested)\n\n    def argdistincts(self, nested=False):\n        return self.array.argdistincts(nested=nested)\n\n    def pairs(self, nested=False):\n        return self.array.pairs(nested=nested)\n\n    def argpairs(self, nested=False):\n        return self.array.argpairs(nested=nested)\n\n    def cross(self, other, nested=False):\n        return self.array.cross(other, nested=nested)\n\n    def argcross(self, other, nested=False):\n        return self.array.argcross(other, nested=nested)\n\n    def flattentuple(self):\n        return self._util_flattentuple(self.array)\n\n    def flatten(self, axis=0):\n        return self._util_flatten(self.array, axis)\n\n    def pad(self, length, maskedwhen=True, clip=False, axis=0):\n        return self._util_pad(self.array, length, maskedwhen, clip, axis)\n\n    def regular(self):\n        return self._util_regular(self.array)\n\n    def _hasjagged(self):\n        return self._util_hasjagged(self.array)\n\n    def _reduce(self, ufunc, identity, dtype):\n        return self._util_reduce(self.array, ufunc, identity, dtype)\n\n    def _prepare(self, ufunc, identity, dtype):\n        array = self.array\n        if isinstance(array, self.numpy.ndarray):\n            if dtype is None and issubclass(array.dtype.type, (self.numpy.bool_, self.numpy.bool)):\n                dtype = self.numpy.dtype(type(identity))\n            if dtype is None:\n                return array\n            else:\n                return array.astype(dtype)\n        else:\n            return array._prepare(ufunc, identity, dtype)\n\n    def argmin(self):\n        return self.array.argmin()\n\n    def argmax(self):\n        return self.array.argmax()\n\n    def _util_columns(self, seen):\n        if id(self) in seen:\n            return []\n        seen.add(id(self))\n        return self._util_columns_descend(self.array, seen)\n\n    def _util_rowname(self, seen):\n        if id(self) in seen:\n            raise TypeError(""not a Table, so there is no rowname"")\n        seen.add(id(self))\n        return self._util_rowname_descend(self.array, seen)\n\n    def astype(self, dtype):\n        return self.array.astype(dtype)\n\n    def fillna(self, value):\n        return self._util_fillna(self.array, value)\n\n    @classmethod\n    def _concatenate_axis0(cls, arrays):\n        assert all(isinstance(x, VirtualArray) for x in arrays)\n        return awkward.array.base.AwkwardArray.concatenate([x.array for x in arrays], axis=0)\n\n    @classmethod\n    def _concatenate_axis1(cls, arrays):\n        assert all(isinstance(x, VirtualArray) for x in arrays)\n        return awkward.array.base.AwkwardArray.concatenate([x.array for x in arrays], axis=1)\n\n    @staticmethod\n    def _topandas_doit(virtualarray):\n        return virtualarray.array._topandas()\n\n    _topandas_name = ""VirtualSeries""\n\n    def _topandas(self, seen):\n        import awkward.pandas\n        if id(self) in seen:\n            return seen[id(self)]\n        else:\n            out = seen[id(self)] = self.VirtualArray(self._topandas_doit, (self,), cache=self.cache, persistentkey=self.persistentkey, type=self.type, nbytes=self.nbytes, persistvirtual=self.persistvirtual)\n            out.__class__ = awkward.pandas.mixin(type(self))\n            return out\n'"
binder/awkward/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport distutils.version\n\nimport numpy\nif distutils.version.LooseVersion(numpy.__version__) < distutils.version.LooseVersion(""1.13.1""):\n    raise ImportError(""Numpy 1.13.1 or later required"")\n\nfrom awkward.array.base import AwkwardArray\nfrom awkward.array.chunked import ChunkedArray, AppendableArray\nfrom awkward.array.indexed import IndexedArray, SparseArray\nfrom awkward.array.jagged import JaggedArray\nfrom awkward.array.masked import MaskedArray, BitMaskedArray, IndexedMaskedArray\nfrom awkward.array.objects import Methods, ObjectArray, StringArray\nfrom awkward.array.table import Table\nfrom awkward.array.union import UnionArray\nfrom awkward.array.virtual import VirtualArray\n\ndef concatenate(arrays, axis=0):\n    return AwkwardArray.concatenate(arrays, axis=axis)\n\nfrom awkward.generate import fromiter\n\nfrom awkward.persist import serialize, deserialize, save, load, hdf5\n\nfrom awkward.arrow import toarrow, fromarrow, toparquet, fromparquet\nfrom awkward.util import topandas\n\n# convenient access to the version number\nfrom awkward.version import __version__\n\n__all__ = [""numpy"", ""AwkwardArray"", ""ChunkedArray"", ""AppendableArray"", ""IndexedArray"", ""SparseArray"", ""JaggedArray"", ""MaskedArray"", ""BitMaskedArray"", ""IndexedMaskedArray"", ""Methods"", ""ObjectArray"", ""Table"", ""UnionArray"", ""VirtualArray"", ""StringArray"", ""fromiter"", ""serialize"", ""deserialize"", ""save"", ""load"", ""hdf5"", ""toarrow"", ""fromarrow"", ""toparquet"", ""fromparquet"", ""topandas"", ""__version__""]\n\n__path__ = __import__(""pkgutil"").extend_path(__path__, __name__)\n'"
binder/awkward/arrow.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport codecs\nimport json\n\nimport numpy\n\nimport awkward.array.base\nimport awkward.array.chunked\nimport awkward.array.indexed\nimport awkward.array.jagged\nimport awkward.array.masked\nimport awkward.array.objects\nimport awkward.array.table\nimport awkward.array.virtual\nimport awkward.type\nimport awkward.util\n\n################################################################################ type conversions\n\ndef schema2type(schema):\n    import pyarrow\n\n    def recurse(tpe, nullable):\n        if isinstance(tpe, pyarrow.lib.DictionaryType):\n            out = recurse(tpe.dictionary.type, nullable)\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.StructType):\n            out = None\n            for i in range(tpe.num_children):\n                x = awkward.type.ArrayType(tpe[i].name, recurse(tpe[i].type, tpe[i].nullable))\n                if out is None:\n                    out = x\n                else:\n                    out = out & x\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.ListType):\n            out = awkward.type.ArrayType(float(""inf""), recurse(tpe.value_type, nullable))\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType):\n            out = None\n            for i in range(tpe.num_children):\n                x = recurse(tpe[i].type, nullable)\n                if out is None:\n                    out = x\n                else:\n                    out = out | x\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif tpe == pyarrow.string():\n            if nullable:\n                return awkward.type.OptionType(str)\n            else:\n                return str\n\n        elif tpe == pyarrow.binary():\n            if nullable:\n                return awkward.type.OptionType(bytes)\n            else:\n                return bytes\n\n        elif tpe == pyarrow.bool_():\n            out = awkward.numpy.dtype(bool)\n            if nullable:\n                return awkward.type.OptionType(out)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.DataType):\n            if nullable:\n                return awkward.type.OptionType(tpe.to_pandas_dtype())\n            else:\n                return tpe.to_pandas_dtype()\n\n        else:\n            raise NotImplementedError(repr(tpe))\n\n    out = None\n    for name in schema.names:\n        field = schema.field_by_name(name)\n        mytype = awkward.type.ArrayType(name, recurse(field.type, field.nullable))\n        if out is None:\n            out = mytype\n        else:\n            out = out & mytype\n\n    return out\n\n################################################################################ value conversions\n\n# we need an opt-out of the large indices in certain cases, otherwise use by default\ndef toarrow(obj):\n    import pyarrow\n\n    def recurse(obj, mask):\n        if isinstance(obj, numpy.ndarray):\n            return pyarrow.array(obj, mask=mask)\n\n        elif isinstance(obj, awkward.array.chunked.ChunkedArray):   # includes AppendableArray\n            raise TypeError(""only top-level ChunkedArrays can be converted to Arrow (as RecordBatches)"")\n\n        elif isinstance(obj, awkward.array.indexed.IndexedArray):\n            if mask is None:\n                return pyarrow.DictionaryArray.from_arrays(obj.index, recurse(obj.content, mask))\n            else:\n                return recurse(obj.content[obj.index], mask)\n\n        elif isinstance(obj, awkward.array.indexed.SparseArray):\n            return recurse(obj.dense, mask)\n\n        elif isinstance(obj, awkward.array.jagged.JaggedArray):\n            obj = obj.compact()\n            if mask is not None:\n                mask = obj.tojagged(mask).flatten()\n            arrow_type = pyarrow.ListArray\n            # 64bit offsets not yet completely golden in arrow\n            # if hasattr(pyarrow, \'LargeListArray\') and obj.starts.itemsize > 4:\n            #     arrow_type = pyarrow.LargeListArray\n            return arrow_type.from_arrays(obj.offsets, recurse(obj.content, mask))\n\n        elif isinstance(obj, awkward.array.masked.IndexedMaskedArray):\n            thismask = obj.boolmask(maskedwhen=True)\n            if mask is not None:\n                thismask = mask | thismask\n            if len(obj.content) == 0:\n                content = obj.numpy.empty(len(obj.mask), dtype=obj.DEFAULTTYPE)\n            else:\n                content = obj.content[obj.mask]\n            return recurse(content, thismask)\n\n        elif isinstance(obj, awkward.array.masked.MaskedArray):   # includes BitMaskedArray\n            thismask = obj.boolmask(maskedwhen=True)\n            if mask is not None:\n                thismask = mask | thismask\n            return recurse(obj.content, thismask)\n\n        elif isinstance(obj, awkward.array.objects.StringArray):\n            if obj.encoding is None and hasattr(pyarrow.BinaryArray, \'from_buffers\'):\n                arrow_type = pyarrow.BinaryArray\n                arrow_offset_type = pyarrow.binary()\n                # 64bit offsets not yet completely golden in arrow\n                # if hasattr(pyarrow, \'LargeBinaryArray\') and obj.starts.itemsize > 4:\n                #     arrow_type = pyarrow.LargeBinaryArray\n                #     arrow_offset_type = pyarrow.large_binary()\n                convert = lambda length, offsets, content: arrow_type.from_buffers(arrow_offset_type, length, [None, offsets, content])\n            elif codecs.lookup(obj.encoding) is codecs.lookup(""utf-8"") or obj.encoding is None:\n                arrow_type = pyarrow.StringArray\n                # if hasattr(pyarrow, \'LargeStringArray\') and obj.starts.itemsize > 4:\n                #     arrow_type = pyarrow.LargeStringArray\n                convert = lambda length, offsets, content: arrow_type.from_buffers(length, offsets, content)\n            else:\n                raise ValueError(""only encoding=None or encoding=\'utf-8\' can be converted to Arrow"")\n\n            obj = obj.compact()\n            offsets = obj.offsets\n            if offsets.dtype != numpy.dtype(numpy.int32):\n                offsets = offsets.astype(numpy.int32)\n\n            return convert(len(offsets) - 1, pyarrow.py_buffer(offsets), pyarrow.py_buffer(obj.content))\n\n        elif isinstance(obj, awkward.array.objects.ObjectArray):\n            # throw away Python object interpretation, which Arrow can\'t handle while being multilingual\n            return recurse(obj.content, mask)\n\n        elif isinstance(obj, awkward.array.table.Table):\n            return pyarrow.StructArray.from_arrays([recurse(x, mask) for x in obj.contents.values()], list(obj.contents))\n\n        elif isinstance(obj, awkward.array.union.UnionArray):\n            contents = []\n            for i, x in enumerate(obj.contents):\n                if mask is None:\n                    thismask = None\n                else:\n                    thistags = (obj.tags == i)\n                    thismask = obj.numpy.empty(len(x), dtype=obj.MASKTYPE)\n                    thismask[obj.index[thistags]] = mask[thistags]    # hmm... obj.index could have repeats; the Arrow mask in that case would not be well-defined...\n                contents.append(recurse(x, thismask))\n\n            return pyarrow.UnionArray.from_dense(pyarrow.array(obj.tags.astype(numpy.int8)), pyarrow.array(obj.index.astype(numpy.int32)), contents)\n\n        elif isinstance(obj, awkward.array.virtual.VirtualArray):\n            return recurse(obj.array, mask)\n\n        else:\n            raise TypeError(""cannot convert type {0} to Arrow"".format(type(obj)))\n\n    if isinstance(obj, awkward.array.chunked.ChunkedArray):   # includes AppendableArray\n        batches = []\n        for chunk in obj.chunks:\n            arr = toarrow(chunk)\n            if isinstance(arr, pyarrow.Table):\n                batches.extend(arr.to_batches())\n            else:\n                batches.append(pyarrow.RecordBatch.from_arrays([arr], [""""]))\n        return pyarrow.Table.from_batches(batches)\n\n    elif isinstance(obj, awkward.array.masked.IndexedMaskedArray) and isinstance(obj.content, awkward.array.table.Table):\n        mask = obj.boolmask(maskedwhen=True)\n        if len(obj.content) == 0:\n            content = obj.numpy.empty(len(obj.mask), dtype=obj.DEFAULTTYPE)\n        else:\n            content = obj.content[obj.mask]\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, mask) for x in obj.content.contents.values()], list(obj.content.contents))])\n\n    elif isinstance(obj, awkward.array.masked.MaskedArray) and isinstance(obj.content, awkward.array.table.Table):   # includes BitMaskedArray\n        mask = obj.boolmask(maskedwhen=True)\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, mask) for x in obj.content.contents.values()], list(obj.content.contents))])\n\n    elif isinstance(obj, awkward.array.table.Table):\n        return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([recurse(x, None) for x in obj.contents.values()], list(obj.contents))])\n\n    else:\n        return recurse(obj, None)\n\ndef fromarrow(obj, awkwardlib=None):\n    import pyarrow\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    ARROW_BITMASKTYPE = awkwardlib.numpy.uint8\n    ARROW_INDEXTYPE = awkwardlib.numpy.int32\n    ARROW_LARGEINDEXTYPE = awkwardlib.numpy.int64\n    ARROW_TAGTYPE = awkwardlib.numpy.uint8\n    ARROW_CHARTYPE = awkwardlib.numpy.uint8\n\n    def popbuffers(array, tpe, buffers, length):\n        if isinstance(tpe, pyarrow.lib.DictionaryType):\n            index = popbuffers(None if array is None else array.indices, tpe.index_type, buffers, length)\n            if hasattr(tpe, ""dictionary""):\n                content = fromarrow(tpe.dictionary)\n            elif array is not None:\n                content = fromarrow(array.dictionary)\n            else:\n                raise NotImplementedError(""no way to access Arrow dictionary inside of UnionArray"")\n            if isinstance(index, awkwardlib.BitMaskedArray):\n                return awkwardlib.BitMaskedArray(index.mask, awkwardlib.IndexedArray(index.content, content), maskedwhen=index.maskedwhen, lsborder=index.lsborder)\n            else:\n                return awkwardlib.IndexedArray(index, content)\n\n        elif isinstance(tpe, pyarrow.lib.StructType):\n            assert getattr(tpe, ""num_buffers"", 1) == 1\n            mask = buffers.pop(0)\n            pairs = []\n            for i in range(tpe.num_children):\n                pairs.append((tpe[i].name, popbuffers(None if array is None else array.field(tpe[i].name), tpe[i].type, buffers, length)))\n            out = awkwardlib.Table.frompairs(pairs, 0)   # FIXME: better rowstart\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.ListType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = popbuffers(None if array is None else array.flatten(), tpe.value_type, buffers, offsets[-1])\n            out = awkwardlib.JaggedArray.fromoffsets(offsets, content)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n                \n        elif hasattr(pyarrow.lib, \'LargeListType\') and isinstance(tpe, pyarrow.lib.LargeListType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = popbuffers(None if array is None else array.flatten(), tpe.value_type, buffers, offsets[-1])\n            out = awkwardlib.JaggedArray.fromoffsets(offsets, content)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""sparse"":\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            tags = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_TAGTYPE)[:length]\n            assert buffers.pop(0) is None\n            index = awkwardlib.numpy.arange(len(tags), dtype=ARROW_INDEXTYPE)\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i][-1] + 1\n                except IndexError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these[-1] + 1]\n            out = awkwardlib.UnionArray(tags, index, contents)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.UnionType) and tpe.mode == ""dense"":\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            tags = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_TAGTYPE)[:length]\n            index = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length]\n            contents = []\n            for i in range(tpe.num_children):\n                try:\n                    sublength = index[tags == i].max() + 1\n                except ValueError:\n                    sublength = 0\n                contents.append(popbuffers(None, tpe[i].type, buffers, sublength))\n            for i in range(len(contents)):\n                these = index[tags == i]\n                if len(these) == 0:\n                    contents[i] = contents[i][0:0]\n                else:\n                    contents[i] = contents[i][: these.max() + 1]\n            out = awkwardlib.UnionArray(tags, index, contents)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.string():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=""utf-8"")\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n                \n        elif tpe == pyarrow.large_string():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=""utf-8"")\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.binary():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_INDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=None)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n        \n        elif tpe == pyarrow.large_binary():\n            assert getattr(tpe, ""num_buffers"", 3) == 3\n            mask = buffers.pop(0)\n            offsets = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_LARGEINDEXTYPE)[:length + 1]\n            content = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)[:offsets[-1]]\n            out = awkwardlib.StringArray.fromoffsets(offsets, content[:offsets[-1]], encoding=None)\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif tpe == pyarrow.bool_():\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            out = awkwardlib.numpy.unpackbits(awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=ARROW_CHARTYPE)).view(awkwardlib.MaskedArray.BOOLTYPE)\n            out = out.reshape(-1, 8)[:,::-1].reshape(-1)[:length]    # lsborder=True\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        elif isinstance(tpe, pyarrow.lib.DataType):\n            assert getattr(tpe, ""num_buffers"", 2) == 2\n            mask = buffers.pop(0)\n            out = awkwardlib.numpy.frombuffer(buffers.pop(0), dtype=tpe.to_pandas_dtype())[:length]\n            if mask is not None:\n                mask = awkwardlib.numpy.frombuffer(mask, dtype=ARROW_BITMASKTYPE)\n                return awkwardlib.BitMaskedArray(mask, out, maskedwhen=False, lsborder=True)\n            else:\n                return out\n\n        else:\n            raise NotImplementedError(repr(tpe))\n\n    if isinstance(obj, pyarrow.lib.Array):\n        buffers = obj.buffers()\n        out = popbuffers(obj, obj.type, buffers, len(obj))\n        assert len(buffers) == 0\n        return out\n\n    elif isinstance(obj, pyarrow.lib.ChunkedArray):\n        chunks = [x for x in obj.chunks if len(x) > 0]\n        if len(chunks) == 1:\n            return fromarrow(chunks[0])\n        else:\n            return awkwardlib.ChunkedArray([fromarrow(x) for x in chunks], chunksizes=[len(x) for x in chunks])\n\n    elif isinstance(obj, pyarrow.lib.RecordBatch):\n        out = awkwardlib.Table()\n        for n, x in zip(obj.schema.names, obj.columns):\n            out[n] = fromarrow(x)\n        return out\n\n    elif isinstance(obj, pyarrow.lib.Table):\n        chunks = []\n        chunksizes = []\n        for batch in obj.to_batches():\n            chunk = fromarrow(batch)\n            if len(chunk) > 0:\n                chunks.append(chunk)\n                chunksizes.append(len(chunk))\n        if len(chunks) == 1:\n            return chunks[0]\n        else:\n            return awkwardlib.ChunkedArray(chunks, chunksizes=chunksizes)\n\n    else:\n        raise NotImplementedError(type(obj))\n\n################################################################################ Parquet file handling\n\ndef toparquet(where, obj, **options):\n    import pyarrow.parquet\n\n    options[""where""] = where\n\n    def convert(obj, message):\n        if isinstance(obj, (awkward.array.base.AwkwardArray, numpy.ndarray)):\n            out = toarrow(obj)\n            if isinstance(out, pyarrow.Table):\n                return out\n            else:\n                return pyarrow.Table.from_batches([pyarrow.RecordBatch.from_arrays([out], [""""])])\n        else:\n            raise TypeError(message)\n\n    if isinstance(obj, awkward.array.chunked.ChunkedArray):\n        obj = iter(obj.chunks)\n        try:\n            awkitem = next(obj)\n        except StopIteration:\n            raise ValueError(""iterable is empty"")\n\n        arritem = convert(awkitem, None)\n        if ""schema"" not in options:\n            options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n\n        try:\n            while True:\n                try:\n                    awkitem = next(obj)\n                except StopIteration:\n                    break\n                else:\n                    writer.write_table(convert(awkitem, None))\n        finally:\n            writer.close()\n\n    elif isinstance(obj, (awkward.array.base.AwkwardArray, numpy.ndarray)):\n        arritem = convert(obj, None)\n        options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n        writer.close()\n\n    else:\n        try:\n            obj = iter(obj)\n        except TypeError:\n            raise TypeError(""cannot write {0} to Parquet file"".format(type(obj)))\n        try:\n            awkitem = next(obj)\n        except StopIteration:\n            raise ValueError(""iterable is empty"")\n\n        arritem = convert(awkitem, ""cannot write iterator of {0} to Parquet file"".format(type(awkitem)))\n        if ""schema"" not in options:\n            options[""schema""] = arritem.schema\n        writer = pyarrow.parquet.ParquetWriter(**options)\n        writer.write_table(arritem)\n\n        try:\n            while True:\n                try:\n                    awkitem = next(obj)\n                except StopIteration:\n                    break\n                else:\n                    writer.write_table(convert(awkitem, ""cannot write iterator of {0} to Parquet file"".format(type(awkitem))))\n        finally:\n            writer.close()\n\nclass _ParquetFile(object):\n    def __init__(self, file, metadata=None, common_metadata=None):\n        self.file = file\n        self.metadata = metadata\n        self.common_metadata = common_metadata\n        self._init()\n\n    def _init(self):\n        import pyarrow.parquet\n        self.parquetfile = pyarrow.parquet.ParquetFile(self.file, metadata=self.metadata, common_metadata=self.common_metadata)\n        self.type = schema2type(self.parquetfile.schema.to_arrow_schema())\n\n    def __getstate__(self):\n        return {""file"": self.file, ""metadata"": self.metadata, ""common_metadata"": self.common_metadata}\n\n    def __setstate__(self, state):\n        self.file = state[""file""]\n        self.metadata = state[""metadata""]\n        self.common_metadata = state[""common_metadata""]\n        self._init()\n\n    def __call__(self, rowgroup, column):\n        return fromarrow(self.parquetfile.read_row_group(rowgroup, columns=[column]))[column]\n\n    def tojson(self):\n        json.dumps([self.file, self.metadata, self.common_metadata])\n        return {""file"": self.file, ""metadata"": self.metadata, ""common_metadata"": self.common_metadata}\n\n    @classmethod\n    def fromjson(cls, state):\n        return cls(state[""file""], metadata=state[""metadata""], common_metadata=state[""common_metadata""])\n\ndef fromparquet(file, awkwardlib=None, cache=None, persistvirtual=False, metadata=None, common_metadata=None):\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    parquetfile = _ParquetFile(file, metadata=metadata, common_metadata=common_metadata)\n    columns = parquetfile.type.columns\n\n    chunks = []\n    chunksizes = []\n    for i in range(parquetfile.parquetfile.num_row_groups):\n        numrows = parquetfile.parquetfile.metadata.row_group(i).num_rows\n        if numrows > 0:\n            if columns == [""""]:\n                chunk = awkwardlib.VirtualArray(parquetfile, (i, """"), cache=cache, type=awkwardlib.type.ArrayType(numrows, parquetfile.type[""""]), persistvirtual=persistvirtual)\n            else:\n                chunk = awkwardlib.Table()\n                for n in columns:\n                    q = awkwardlib.VirtualArray(parquetfile, (i, n), cache=cache, type=awkwardlib.type.ArrayType(numrows, parquetfile.type[n]), persistvirtual=persistvirtual)\n                    chunk.contents[n] = q\n\n            chunks.append(chunk)\n            chunksizes.append(numrows)\n\n    return awkwardlib.ChunkedArray(chunks, chunksizes)\n'"
binder/awkward/generate.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport codecs\nimport collections\nimport numbers\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\n\nimport awkward.type\nimport awkward.util\n\ndef typeof(obj):\n    if obj is None:\n        return None\n\n    elif isinstance(obj, (bool, numpy.bool_, numpy.bool)):\n        return BoolFillable\n    elif isinstance(obj, (numbers.Number, awkward.numpy.number)):\n        return NumberFillable\n    elif isinstance(obj, bytes):\n        return BytesFillable\n    elif isinstance(obj, awkward.util.string):\n        return StringFillable\n\n    elif isinstance(obj, dict):\n        if any(not isinstance(x, str) for x in obj):\n            raise TypeError(""only dicts with str-typed keys may be converted"")\n        if len(obj) == 0:\n            return None\n        else:\n            return set(obj)\n\n    elif isinstance(obj, tuple) and hasattr(obj, ""_fields"") and obj._fields is type(obj)._fields:\n        return obj._fields, type(obj)\n\n    elif isinstance(obj, Iterable):\n        return JaggedFillable\n\n    else:\n        return set(n for n in obj.__dict__ if not n.startswith(""_"")), type(obj)\n\nclass Fillable(object):\n    def __init__(self, awkwardlib):\n        self.awkwardlib = awkwardlib\n\n    @staticmethod\n    def make(tpe, awkwardlib):\n        if tpe is None:\n            return MaskedFillable(UnknownFillable(awkwardlib), 0, awkwardlib)\n\n        elif isinstance(tpe, type):\n            return tpe(awkwardlib)\n\n        elif isinstance(tpe, set):\n            return TableFillable(tpe, awkwardlib)\n\n        elif isinstance(tpe, tuple) and len(tpe) == 2 and isinstance(tpe[0], set):\n            if len(tpe[0]) == 0:\n                return ObjectFillable(JaggedFillable(awkwardlib), tpe[1], awkwardlib)\n            else:\n                return ObjectFillable(TableFillable(tpe[0], awkwardlib), tpe[1], awkwardlib)\n\n        elif isinstance(tpe, tuple) and len(tpe) == 2 and isinstance(tpe[0], tuple):\n            if len(tpe[0]) == 0:\n                return NamedTupleFillable(JaggedFillable(awkwardlib), tpe[1], awkwardlib)\n            else:\n                return NamedTupleFillable(TableFillable(tpe[0], awkwardlib), tpe[1], awkwardlib)\n\n        else:\n            raise AssertionError(tpe)\n\n    def matches(self, tpe):\n        return type(self) is tpe\n\nclass UnknownFillable(Fillable):\n    __slots__ = [""count"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.count = 0\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return self.count\n\n    def clear(self):\n        self.count = 0\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            self.count += 1\n            return self\n\n        else:\n            fillable = Fillable.make(tpe, self.awkwardlib)\n            if self.count == 0:\n                return fillable.append(obj, tpe)\n            else:\n                return MaskedFillable(fillable.append(obj, tpe), self.count, self.awkwardlib)\n\n    def finalize(self, **options):\n        maskedwhen = options.get(""maskedwhen"", True)\n        if self.count == 0:\n            return self.awkwardlib.numpy.empty(0, dtype=self.awkwardlib.JaggedArray.DEFAULTTYPE)\n        else:\n            if maskedwhen:\n                mask = self.awkwardlib.numpy.ones(self.count, dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n            else:\n                mask = self.awkwardlib.numpy.zeros(self.count, dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n            return self.awkwardlib.MaskedArray(mask, mask, maskedwhen=maskedwhen)\n\nclass SimpleFillable(Fillable):\n    __slots__ = [""data"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.data = []\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.data)\n\n    def clear(self):\n        self.data = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            self.data.append(obj)\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\nclass BoolFillable(SimpleFillable):\n    def finalize(self, **options):\n        return self.awkwardlib.numpy.array(self.data, dtype=self.awkwardlib.JaggedArray.BOOLTYPE)\n\nclass NumberFillable(SimpleFillable):\n    def finalize(self, **options):\n        return self.awkwardlib.numpy.array(self.data)\n\nclass BytesFillable(SimpleFillable):\n    def finalize(self, **options):\n        dictencoding = options.get(""dictencoding"", False)\n        if (callable(dictencoding) and dictencoding(self.data)) or (not callable(dictencoding) and dictencoding):\n            dictionary, index = self.awkwardlib.numpy.unique(self.data, return_inverse=True)\n            return self.awkwardlib.IndexedArray(index, self.awkwardlib.StringArray.fromiter(dictionary, encoding=None))\n        else:\n            return self.awkwardlib.StringArray.fromiter(self.data, encoding=None)\n\nclass StringFillable(SimpleFillable):\n    def finalize(self, **options):\n        dictencoding = options.get(""dictencoding"", False)\n        if (callable(dictencoding) and dictencoding(self.data)) or (not callable(dictencoding) and dictencoding):\n            dictionary, index = self.awkwardlib.numpy.unique(self.data, return_inverse=True)\n            return self.awkwardlib.IndexedArray(index, self.awkwardlib.StringArray.fromiter(dictionary, encoding=""utf-8""))\n        else:\n            return self.awkwardlib.StringArray.fromiter(self.data, encoding=""utf-8"")\n\nclass JaggedFillable(Fillable):\n    __slots__ = [""content"", ""offsets"", ""awkwardlib""]\n\n    def __init__(self, awkwardlib):\n        self.content = UnknownFillable(awkwardlib)\n        self.offsets = [0]\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.offsets) - 1\n\n    def clear(self):\n        self.content.clear()\n        self.offsets = [0]\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            for x in obj:\n                self.content = self.content.append(x, typeof(x))\n            self.offsets.append(len(self.content))\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        return self.awkwardlib.JaggedArray.fromoffsets(self.offsets, self.content.finalize(**options))\n\nclass TableFillable(Fillable):\n    __slots__ = [""fields"", ""contents"", ""count"", ""awkwardlib""]\n\n    def __init__(self, fields, awkwardlib):\n        assert len(fields) > 0\n        self.fields = fields\n        self.contents = {n: UnknownFillable(awkwardlib) for n in fields}\n        self.count = 0\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return self.count\n\n    def clear(self):\n        for content in self.contents.values():\n            content.clear()\n        self.count = 0\n\n    def matches(self, tpe):\n        return self.fields == tpe\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            for n in self.fields:\n                x = obj[n]\n                self.contents[n] = self.contents[n].append(x, typeof(x))\n            self.count += 1\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        return self.awkwardlib.Table.frompairs([(n, self.contents[n].finalize(**options)) for n in sorted(self.fields)], 0)\n\nclass ObjectFillable(Fillable):\n    __slots__ = [""content"", ""cls"", ""awkwardlib""]\n\n    def __init__(self, content, cls, awkwardlib):\n        self.content = content\n        self.cls = cls\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.content)\n\n    def clear(self):\n        self.content.clear()\n\n    def matches(self, tpe):\n        return isinstance(tpe, tuple) and len(tpe) == 2 and tpe[1] is self.cls and (len(tpe[0]) == 0 or self.content.matches(tpe[0]))\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            if len(tpe[0]) == 0:\n                self.content.append([], JaggedFillable)\n            else:\n                self.content.append(obj.__dict__, tpe[0])\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        def make(x):\n            out = self.cls.__new__(self.cls)\n            out.__dict__.update(x.tolist())\n            return out\n\n        return self.awkwardlib.ObjectArray(self.content.finalize(**options), make)\n\nclass NamedTupleFillable(ObjectFillable):\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        if self.matches(tpe):\n            if len(tpe[0]) == 0:\n                self.content.append([], JaggedFillable)\n            else:\n                self.content.append({n: x for n, x in zip(obj._fields, obj)}, tpe[0])\n            return self\n\n        else:\n            return UnionFillable(self, self.awkwardlib).append(obj, tpe)\n\n    def finalize(self, **options):\n        def make(x):\n            asdict = x.tolist()\n            return self.cls(*[asdict[n] for n in self.cls._fields])\n\n        return self.awkwardlib.ObjectArray(self.content.finalize(**options), make)\n\nclass MaskedFillable(Fillable):\n    __slots__ = [""content"", ""nullpos"", ""awkwardlib""]\n\n    def __init__(self, content, count, awkwardlib):\n        self.content = content\n        self.nullpos = list(range(count))\n        self.awkwardlib = awkwardlib\n\n    def matches(self, tpe):\n        return tpe is None\n\n    def __len__(self):\n        return len(self.content) + len(self.nullpos)\n\n    def clear(self):\n        self.content.clear()\n        self.nullpos = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            self.nullpos.append(len(self))\n        else:\n            self.content = self.content.append(obj, tpe)\n        return self\n\n    def finalize(self, **options):\n        maskedwhen = options.get(""maskedwhen"", True)\n\n        if isinstance(self.content, (TableFillable, ObjectFillable, UnionFillable)):\n            index = self.awkwardlib.numpy.zeros(len(self), dtype=self.awkwardlib.IndexedMaskedArray.INDEXTYPE)\n            index[self.nullpos] = -1\n            index[index == 0] = awkward.numpy.arange(len(self.content))\n\n            return self.awkwardlib.IndexedMaskedArray(index, self.content.finalize(**options))\n\n        valid = self.awkwardlib.numpy.ones(len(self), dtype=self.awkwardlib.MaskedArray.MASKTYPE)\n        valid[self.nullpos] = False\n\n        if isinstance(self.content, (BoolFillable, NumberFillable)):\n            compact = self.content.finalize(**options)\n            expanded = self.awkwardlib.numpy.empty(len(self), dtype=compact.dtype)\n            expanded[valid] = compact\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        elif isinstance(self.content, (BytesFillable, StringFillable)):\n            compact = self.content.finalize(**options)\n\n            if isinstance(compact, self.awkwardlib.IndexedArray):\n                index = self.awkwardlib.numpy.zeros(len(self), dtype=compact.index.dtype)\n                index[valid] = compact.index\n                expanded = self.awkwardlib.IndexedArray(index, compact.content)\n            else:\n                counts = self.awkwardlib.numpy.zeros(len(self), dtype=compact.counts.dtype)\n                counts[valid] = compact.counts\n                expanded = self.awkwardlib.StringArray.fromcounts(counts, compact.content, encoding=compact.encoding)\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        elif isinstance(self.content, JaggedFillable):\n            compact = self.content.finalize(**options)\n            counts = self.awkwardlib.numpy.zeros(len(self), dtype=compact.counts.dtype)\n            counts[valid] = compact.counts\n            expanded = self.awkwardlib.JaggedArray.fromcounts(counts, compact.content)\n\n            if maskedwhen:\n                return self.awkwardlib.MaskedArray(~valid, expanded, maskedwhen=maskedwhen)\n            else:\n                return self.awkwardlib.MaskedArray(valid, expanded, maskedwhen=maskedwhen)\n\n        else:\n            raise AssertionError(self.content)\n\nclass UnionFillable(Fillable):\n    __slots__ = [""contents"", ""tags"", ""index"", ""awkwardlib""]\n\n    def __init__(self, content, awkwardlib):\n        self.contents = [content]\n        self.tags = [0] * len(content)\n        self.index = list(range(len(content)))\n        self.awkwardlib = awkwardlib\n\n    def __len__(self):\n        return len(self.tags)\n\n    def clear(self):\n        for content in self.contents:\n            content.clear()\n        self.tags = []\n        self.index = []\n\n    def append(self, obj, tpe):\n        if tpe is None:\n            return MaskedFillable(self, 0, self.awkwardlib).append(obj, tpe)\n\n        else:\n            for tag, content in enumerate(self.contents):\n                if content.matches(tpe):\n                    self.tags.append(tag)\n                    self.index.append(len(content))\n                    content.append(obj, tpe)\n                    break\n\n            else:\n                fillable = Fillable.make(tpe, self.awkwardlib)\n                self.tags.append(len(self.contents))\n                self.index.append(len(fillable))\n                self.contents.append(fillable.append(obj, tpe))\n\n            return self\n\n    def finalize(self, **options):\n        return self.awkwardlib.UnionArray(self.tags, self.index, [x.finalize(**options) for x in self.contents])\n\ndef _checkoptions(options):\n    unrecognized = set(options).difference([""dictencoding"", ""maskedwhen""])\n    if len(unrecognized) != 0:\n        raise TypeError(""unrecognized options: {0}"".format("", "".join(sorted(unrecognized))))\n\ndef fromiter(iterable, awkwardlib=None, **options):\n    _checkoptions(options)\n\n    awkwardlib = awkward.util.awkwardlib(awkwardlib)\n    fillable = UnknownFillable(awkwardlib)\n\n    for obj in iterable:\n        fillable = fillable.append(obj, typeof(obj))\n\n    return fillable.finalize(**options)\n'"
binder/awkward/pandas.py,0,"b' #!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nfrom __future__ import absolute_import\nimport pandas\nimport pandas.api.extensions\n\nimport awkward.array\n\ndef delegated_method(method, index, name, *args, **kwargs):\n    return pandas.Series\n\nclass Delegated(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, type=None):\n        index = object.__getattribute__(obj, ""_index"")\n        name = object.__getattribute__(obj, ""_name"")\n        result = self._get_result(obj)\n        return pandas.Series(result, index, name=name)\n\nclass DelegatedProperty(Delegated):\n    def _get_result(self, obj, type=None):\n        return getattr(object.__getattribute__(obj, ""_data""), self.name)\n\nclass DelegatedMethod(Delegated):\n    def __get__(self, obj, type=None):\n        index = object.__getattribute__(obj, ""_index"")\n        name = object.__getattribute__(bj, ""_name"")\n        method = getattr(object.__getattribute__(obj, ""_data""), self.name)\n        return delegated_method(method, index, name)\n\nclass AwkwardSeriesDtype(pandas.api.extensions.ExtensionDtype):\n    name = ""awkward""\n    type = awkward.array.base.AwkwardArray\n    kind = ""O""\n\n    @classmethod\n    def construct_from_string(cls, string):\n        if string == cls.name:\n            return cls()\n        else:\n            raise TypeError(""Cannot construct a \'{}\' from \'{}\'"".format(cls, string))\n\n@pandas.api.extensions.register_series_accessor(""awkward"")\nclass AwkwardAccessor(object):\n    def __init__(self, pandas_obj):\n        self._validate(pandas_obj)\n\n        self._data = pandas_obj.values\n        self._index = pandas_obj.index\n        self._name = pandas_obj.name\n\n    @staticmethod\n    def _validate(obj):\n        if not is_awkward_type(obj):\n            raise AttributeError(""Cannot use \'awkward\' accessor on objects of dtype \'{}\'."".format(obj.dtype))\n\ndef is_awkward_type(obj):\n    t = getattr(obj, ""dtype"", obj)\n    try:\n        return isinstance(t, AwkwardSeriesDtype) or issubclass(t, AwkwardSeriesDtype)\n    except Exception:\n        return False\n\nclass AwkwardSeries(object):\n    @property\n    def dtype(self):\n        return AwkwardSeriesDtype()\n\n    @staticmethod\n    def _findclass(cls):\n        for base in cls.__bases__:\n            if issubclass(base, awkward.array.base.AwkwardArray):\n                if not issubclass(base, AwkwardSeries):\n                    return base\n                else:\n                    out = AwkwardSeries._findclass(base)\n                    if out is not None:\n                        return out\n        return None\n\n    def __array__(self, dtype=None):\n        cls = self._findclass(type(self))\n\n        if dtype is None:\n            dtype = cls.dtype.fget(self)\n\n        return cls.__array__(self, dtype=dtype)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        out = self._findclass(type(self)).__array_ufunc__(self, ufunc, method, *inputs, **kwargs)\n        return out.pandas\n\n    def isna(self):\n        return self.numpy.zeros(self.shape, dtype=self.BOOLTYPE)\n\n    @classmethod\n    def _concat_same_type(cls, to_concat):\n        return cls.concatenate(to_concat)\n\n    @property\n    def ChunkedArray(self):\n        return mixin(self._findclass(type(self)).ChunkedArray.fget(self))\n\n    @property\n    def AppendableArray(self):\n        return mixin(self._findclass(type(self)).AppendableArray.fget(self))\n\n    @property\n    def IndexedArray(self):\n        return mixin(self._findclass(type(self)).IndexedArray.fget(self))\n\n    @property\n    def SparseArray(self):\n        return mixin(self._findclass(type(self)).SparseArray.fget(self))\n\n    @property\n    def JaggedArray(self):\n        return mixin(self._findclass(type(self)).JaggedArray.fget(self))\n\n    @property\n    def MaskedArray(self):\n        return mixin(self._findclass(type(self)).MaskedArray.fget(self))\n\n    @property\n    def BitMaskedArray(self):\n        return mixin(self._findclass(type(self)).BitMaskedArray.fget(self))\n\n    @property\n    def IndexedMaskedArray(self):\n        return mixin(self._findclass(type(self)).IndexedMaskedArray.fget(self))\n\n    @property\n    def ObjectArray(self):\n        return mixin(self._findclass(type(self)).ObjectArray.fget(self))\n\n    @property\n    def StringArray(self):\n        return mixin(self._findclass(type(self)).StringArray.fget(self))\n\n    @property\n    def Table(self):\n        return mixin(self._findclass(type(self)).Table.fget(self))\n\n    @property\n    def UnionArray(self):\n        return mixin(self._findclass(type(self)).UnionArray.fget(self))\n\n    @property\n    def VirtualArray(self):\n        return mixin(self._findclass(type(self)).VirtualArray.fget(self))\n\ndef mixin(tpe):\n    return type(tpe._topandas_name, (AwkwardSeries, tpe, pandas.api.extensions.ExtensionArray), {})\n'"
binder/awkward/persist.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport base64\nimport fnmatch\nimport importlib\nimport json\nimport numbers\nimport os\nimport pickle\nimport types\nimport zipfile\nimport zlib\nfrom itertools import count\ntry:\n    from collections.abc import Mapping, MutableMapping\nexcept ImportError:\n    from collections import Mapping, MutableMapping\n\nimport numpy\n\nimport awkward.type\nimport awkward.version\n\ncompression = [\n        {""minsize"": 8192, ""types"": [numpy.bool_, numpy.bool, numpy.integer], ""contexts"": ""*"", ""pair"": (zlib.compress, (""zlib"", ""decompress""))},\n    ]\n\nwhitelist = [\n        [""numpy"", ""frombuffer""],\n        [""zlib"", ""decompress""],\n        [""lzma"", ""decompress""],\n        [""backports.lzma"", ""decompress""],\n        [""lz4.block"", ""decompress""],\n        [""awkward"", ""*Array""],\n        [""awkward"", ""Table""],\n        [""awkward"", ""numpy"", ""frombuffer""],\n        [""awkward.util"", ""frombuffer""],\n        [""awkward.persist""],\n        [""awkward.arrow"", ""_ParquetFile"", ""fromjson""],\n        [""uproot_methods.classes.*""],\n        [""uproot_methods.profiles.*""],\n        [""uproot.tree"", ""_LazyFiles""],\n        [""uproot.tree"", ""_LazyTree""],\n        [""uproot.tree"", ""_LazyBranch""],\n    ]\n\ndef frompython(obj):\n    return base64.b64encode(pickle.dumps(obj)).decode(""ascii"")\n\ndef topython(string):\n    return pickle.loads(base64.b64decode(string.encode(""ascii"")))\n\ndef spec2function(obj, awkwardlib=""awkward"", whitelist=whitelist):\n    for white in whitelist:\n        for n, p in zip(obj, white):\n            if not fnmatch.fnmatchcase(n, p):\n                break\n        else:\n            if obj[0] == ""awkward"":\n                obj = [awkwardlib] + obj[1:]\n            gen, genname = importlib.import_module(obj[0]), obj[1:]\n            if not isinstance(gen, types.ModuleType):\n                raise TypeError(""first item of a function description must be a module"")\n            if genname[:1] == [""numpy""]:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n            while len(genname) > 0:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n                if isinstance(gen, types.ModuleType):\n                    raise TypeError(""non-first items of a function description must not be a module"")\n            break\n    else:\n        raise RuntimeError(""callable not in whitelist; add it by passing a whitelist argument:\\n\\n    whitelist = awkward.persist.whitelist + [{0}]"".format(repr(obj)))\n    return gen\n\ndef dtype2json(obj):\n    if obj.subdtype is not None:\n        dt, sh = obj.subdtype\n        return (dtype2json(dt), sh)\n    elif obj.names is not None:\n        return [(n, dtype2json(obj[n])) for n in obj.names]\n    else:\n        return str(obj)\n\ndef json2dtype(obj):\n    def recurse(obj):\n        if isinstance(obj, (list, tuple)) and len(obj) > 0 and (isinstance(obj[-1], numbers.Integral) or isinstance(obj[0], str) or (isinstance(obj[-1], (list, tuple)) and all(isinstance(x, numbers.Integral) for x in obj[-1]))):\n            return tuple(recurse(x) for x in obj)\n        elif isinstance(obj, (list, tuple)):\n            return [recurse(x) for x in obj]\n        else:\n            return obj\n    return numpy.dtype(recurse(obj))\n\ndef type2json(obj):\n    if isinstance(obj, awkward.type.Type):\n        labeled = obj._labeled()\n    else:\n        labeled = []\n\n    seen = set()\n\n    def takes(n):\n        if n == float(""inf""):\n            return ""inf""\n        else:\n            return int(n)\n\n    def recurse(obj):\n        if isinstance(obj, awkward.type.Type):\n            if id(obj) in seen:\n                for i, x in enumerate(labeled):\n                    if obj is x:\n                        return {""ref"": ""T{0}"".format(i)}\n\n            else:\n                seen.add(id(obj))\n                if isinstance(obj, awkward.type.ArrayType):\n                    out = {""takes"": takes(obj._takes), ""to"": recurse(obj._to)}\n\n                elif isinstance(obj, awkward.type.TableType):\n                    out = {""fields"": [[n, recurse(x)] for n, x in obj._fields.items()]}\n\n                elif isinstance(obj, awkward.type.UnionType):\n                    out = {""possibilities"": [recurse(x) for x in obj._possibilities]}\n\n                elif isinstance(obj, awkward.type.OptionType):\n                    out = {""type"": recurse(obj._type)}\n\n                for i, x in enumerate(labeled):\n                    if obj is x:\n                        return {""set"": ""T{0}"".format(i), ""as"": out}\n                else:\n                    return out\n\n        elif isinstance(obj, numpy.dtype):\n            return {""dtype"": dtype2json(obj)}\n\n        elif callable(obj):\n            if obj.__module__ == ""__main__"":\n                raise TypeError(""cannot persist object type: its generator is defined in __main__, which won\'t be available in a subsequent session"")\n            if hasattr(obj, ""__qualname__""):\n                spec = [obj.__module__] + obj.__qualname__.split(""."")\n            else:\n                spec = [obj.__module__, obj.__name__]\n\n            gen, genname = importlib.import_module(spec[0]), spec[1:]\n            while len(genname) > 0:\n                gen, genname = getattr(gen, genname[0]), genname[1:]\n            if gen is not obj:\n                raise TypeError(""cannot persist object type: its generator cannot be found via its __name__ (Python 2) or __qualname__ (Python 3)"")\n\n            return {""function"": spec}\n\n        else:\n            raise TypeError(""only awkward.type.Type, numpy.dtype, and callables are types"")\n\n    return recurse(obj)\n\ndef json2type(obj, whitelist=whitelist):\n    labels = {}\n\n    def takes(n):\n        if n == ""inf"":\n            return float(""inf"")\n        else:\n            return n\n\n    def recurse(obj):\n        if not isinstance(obj, dict):\n            raise TypeError(""json2type is expecting a JSON object, found: {0}"".format(repr(obj)))\n\n        if ""set"" in obj:\n            placeholder = labels[obj[""set""]] = awkward.type.Placeholder()\n            placeholder.value = recurse(obj[""as""])\n            return placeholder\n\n        elif ""ref"" in obj:\n            return labels[obj[""ref""]]\n\n        elif ""takes"" in obj and ""to"" in obj:\n            return awkward.type.ArrayType(takes(obj[""takes""]), recurse(obj[""to""]))\n\n        elif ""fields"" in obj:\n            out = awkward.type.TableType()\n            for n, x in obj[""fields""]:\n                out[n] = recurse(x)\n            return out\n\n        elif ""possibilities"" in obj:\n            return awkward.type.UnionType(*[recurse(x) for x in obj[""possibilities""]])\n\n        elif ""type"" in obj:\n            return awkward.type.OptionType(recurse(obj[""type""]))\n\n        elif ""dtype"" in obj:\n            return json2dtype(obj[""dtype""])\n\n        elif ""function"" in obj:\n            return spec2function(obj[""function""], whitelist=whitelist)\n\n        else:\n            raise ValueError(""unexpected set of keys in JSON: {0}"".format("", "".join(repr(x) for x in obj)))\n\n    return awkward.type._resolve(recurse(obj), {})\n\ndef jsonable(obj):\n    if obj is None:\n        return obj\n\n    elif isinstance(obj, dict) and all(isinstance(n, str) for n in obj):\n        return {n: jsonable(x) for n, x in obj.items()}\n\n    elif isinstance(obj, list):\n        return [jsonable(x) for x in obj]\n\n    elif isinstance(obj, str):\n        return str(obj)\n\n    elif isinstance(obj, (bool, numpy.bool_, numpy.bool)):\n        return bool(obj)      # policy: eliminate Numpy types\n\n    elif isinstance(obj, (numbers.Integral, numpy.integer)):\n        return int(obj)       # policy: eliminate Numpy types\n\n    elif isinstance(obj, (numbers.Real, numpy.floating)) and numpy.isfinite(obj):\n        return float(obj)     # policy: eliminate Numpy types\n\n    else:\n        raise TypeError(""object cannot be losslessly serialized as JSON"")\n\nclass ObjRef(object):\n    def __init__(self, idgen=None):\n        if idgen:\n            self.idgen = iter(idgen)\n        self._i2r = {}\n        self._r2o = {}\n\n    def nextid(self):\n        return next(self.idgen)\n\n    def __contains__(self, obj):\n        return id(obj) in self._i2r\n\n    def __setitem__(self, obj, ref):\n        self._i2r[id(obj)] = ref\n        self._r2o[ref] = obj\n\n    def __getitem__(self, obj):\n        if obj not in self:\n            self[obj] = self.nextid()\n        return self._i2r[id(obj)]\n\n    def __delitem__(self, obj):\n        assert obj in self\n        del self._r2o[self._i2r[id(obj)]]\n        del self._i2r[id(obj)]\n\n    def get(self, obj, default=None):\n        return self[obj] if obj in self else default\n\n    def obj(self, ref):\n        if ref in self._r2o:\n            return self._r2o[ref]\n        else:\n            return awkward.array.virtual.VirtualArray(lambda: self._r2o[ref])\n\nclass Serializer(object):\n    def __init__(self, storage, prefix="""", suffix="""", schemasuffix=""""):\n        self.storage = storage\n        self.suffix = suffix\n        self.prefix = prefix\n        self.schemasuffix = schemasuffix\n        self.seen = ObjRef(idgen=count())\n\n    def store(self, name, obj):\n        schema = {""awkward"": awkward.version.__version__, ""schema"": self(obj)}\n        if self.prefix != """":\n            schema[""prefix""] = self.prefix\n\n        schema = self._finalize_schema(schema) or schema\n\n        self.storage[name + self.schemasuffix] = self._encode_schema(schema)\n        return schema\n\n    def load(self, *args, **kwargs):\n        return deserialize(*args, storage=self.storage, seen=self.seen, **kwargs)\n\n    def encode_call(self, *args, **kwargs):\n        func, args = args[0], args[1:]\n        out = {""call"": self._obj2spec(func) if callable(func) else tuple(func)}\n        if args:\n            out[""args""] = list(args)\n        if kwargs:\n            out[""kwargs""] = kwargs\n        return out\n\n    def encode_json(self, obj):\n        return {""json"": jsonable(obj)}\n\n    def encode_python(self, obj):\n        return {""python"": frompython(obj)}\n\n    @classmethod\n    def _encode_primitive(cls, obj):\n        if isinstance(obj, numpy.dtype):\n            return {""dtype"": dtype2json(obj)}\n\n    @classmethod\n    def _obj2spec(cls, obj, test=True):\n        if hasattr(obj, ""__qualname__""):\n            spec = [obj.__module__] + obj.__qualname__.split(""."")\n        else:\n            spec = [obj.__module__, obj.__name__]\n\n        if test:\n            val = importlib.import_module(spec[0])\n            for key in spec[1:]:\n                val = getattr(val, key)\n            assert val == obj\n\n        return spec\n\n    def _encode_complex(self, obj, context):\n        if callable(getattr(obj, ""__awkward_serialize__"", None)):\n            return obj.__awkward_serialize__(self)\n\n        if hasattr(obj, ""tojson"") and hasattr(type(obj), ""fromjson""):\n            try:\n                return self.encode_call(self._obj2spec(type(obj).fromjson), self.encode_json(obj.tojson()))\n            except:\n                pass\n\n        if isinstance(obj, numpy.ndarray):\n            return self._encode_numpy(obj, context)\n\n        if hasattr(obj, ""__module__"") and (hasattr(obj, ""__qualname__"") or hasattr(obj, ""__name__"")) and obj.__module__ != ""__main__"":\n            try:\n                return {""function"": self._obj2spec(obj)}\n            except:\n                pass\n\n        try:\n            return self.encode_json(obj)\n        except TypeError:\n            pass\n\n        try:\n            return self.encode_python(obj)\n        except:\n            pass\n\n    def _encode_numpy(self, obj, context):\n        key = str(self.seen[obj]) + self.suffix\n        self.storage[self.prefix + key] = obj\n        return {""read"": key}\n\n    def _encode_schema(self, schema):\n        return json.dumps(schema).encode(""ascii"")\n\n    def _finalize_schema(self, schema):\n        pass\n\n    def __call__(self, obj, context=""""):\n        out = self._encode_primitive(obj)\n\n        if out is not None:\n            return out\n\n        if obj in self.seen:\n            return {""ref"": self.seen[obj]}\n        else:\n            ident = self.seen[obj]\n\n        out = self._encode_complex(obj, context)\n        if out is None:\n            raise TypeError(""failed to encode {0} (type: {1})"".format(repr(obj), type(obj)))\n\n        if ""id"" in out:\n            if out[""id""] is False:\n                del self.seen[obj]\n            elif out[""id""] != self.seen[obj]:\n                raise RuntimeError(""unexpected id change"")\n        else:\n            out[""id""] = ident\n\n        return out\n\n    def fill(self, obj, context, prefix, suffix, schemasuffix, storage, compression, **kwargs):\n        assert self.prefix == prefix\n        assert self.suffix == suffix\n        assert self.schemasuffix == schemasuffix\n        assert self.storage == storage\n        assert self.compression == compression\n        return self(obj, context=context)\n\nclass BlobSerializer(Serializer):\n    class CompressPolicy(object):\n        enc2dec = {\n            zlib.compress: (""zlib"", ""decompress""),\n        }\n\n        @classmethod\n        def parse(cls, x):\n            if isinstance(x, cls):\n                return x\n            elif isinstance(x, dict):\n                return cls(**x)\n            elif callable(x):\n                return cls(enc=x)\n            elif len(x) == 2 and callable(x[0]):\n                return cls(enc=x[0], dec=x[1])\n            else:\n                raise TypeError(""can\'t parse compression policy {0}"".format(x))\n\n        def __init__(self, pair=None, enc=None, dec=None, minsize=0, types=object, contexts=""*""):\n            if pair is not None:\n                enc, dec = pair\n            if dec is None:\n                dec = self.enc2dec[enc]\n            if isinstance(types, list):\n                types = tuple(types)\n            elif not isinstance(types, tuple):\n                types = types,\n            if isinstance(contexts, list):\n                contexts = tuple(contexts)\n            elif not isinstance(contexts, tuple):\n                contexts = contexts,\n            assert callable(enc)\n            assert isinstance(dec, tuple)\n            assert 0 <= minsize\n            self.enc = enc\n            self.dec = dec\n            self.minsize = minsize\n            self.types = types\n            self.contexts = contexts\n\n        @property\n        def pair(self):\n            return (self.enc, self.dec)\n\n        def test(self, obj, context):\n            return (obj.nbytes >= self.minsize and issubclass(obj.dtype.type, tuple(self.types)) and any(fnmatch.fnmatchcase(context, p) for p in self.contexts))\n\n    @classmethod\n    def _parse_compression(cls, comp):\n        if comp is None or comp is False:\n            comp = []\n        elif comp is True:\n            comp = [{""minsize"": 0, ""types"": object, ""contexts"": ""*"", ""pair"": (zlib.compress, (""zlib"", ""decompress""))}]\n        elif not isinstance(comp, (list, tuple)):\n            comp = [comp]\n\n        return list(map(cls.CompressPolicy.parse, comp))\n\n    def __init__(self, *args, **kwargs):\n        self.compression = self._parse_compression(kwargs.pop(""compression"", compression))\n        super(BlobSerializer, self).__init__(*args, **kwargs)\n\n    def _put_raw(self, data, ref=None):\n        if ref is None:\n            ref = data\n        key = str(self.seen[ref]) + self.suffix\n        self.storage[self.prefix + key] = data\n        return dict(read=key)\n\n    def _encode_numpy(self, obj, context):\n        if obj.ndim > 1:\n            dtype = numpy.dtype((obj.dtype, obj.shape[1:]))\n        else:\n            dtype = obj.dtype\n\n        buf = None\n        for policy in self._parse_compression(self.compression):\n            if policy.test(obj, context):\n                buf = self.encode_call(policy.dec, self._put_raw(policy.enc(obj.ravel()), ref=obj))\n                break\n        else:\n            buf = self._put_raw(obj.ravel(), ref=obj)\n\n        return self.encode_call([""awkward"", ""numpy"", ""frombuffer""], buf, self(dtype), self(obj.shape[0]))\n\ndef serialize(obj, storage, name="""", delimiter=""-"", **kwargs):\n    if delimiter is None:\n        delimiter = """"\n    if name:\n        kwargs.setdefault(""prefix"", name + delimiter)\n    return BlobSerializer(storage, **kwargs).store(name, obj)\n\ndef deserialize(storage, name="""", awkwardlib=""awkward"", whitelist=whitelist, cache=None, seen=None):\n    import awkward.array.virtual\n\n    schema = storage[name]\n    if isinstance(schema, numpy.ndarray):\n        schema = schema.tostring()\n    if isinstance(schema, bytes):\n        schema = schema.decode(""ascii"")\n    schema = json.loads(schema)\n\n    if ""awkward"" not in schema:\n        raise ValueError(""JSON object is not an awkward-array schema (missing \'awkward\' field)"")\n\n    prefix = schema.get(""prefix"", """")\n    if seen is None:\n        seen = ObjRef()\n\n    if isinstance(whitelist, str):\n        whitelist = [whitelist]\n    elif len(whitelist) > 0 and isinstance(whitelist[0], str):\n        whitelist = [whitelist]\n\n    def unfill(schema):\n        if isinstance(schema, dict):\n            if ""call"" in schema and isinstance(schema[""call""], list) and len(schema[""call""]) > 0:\n                gen = spec2function(schema[""call""], awkwardlib=awkwardlib, whitelist=whitelist)\n                args = [unfill(x) for x in schema.get(""args"", [])]\n\n                kwargs = {}\n                if schema.get(""cacheable"", False):\n                    kwargs[""cache""] = cache\n                if schema.get(""whitelistable"", False):\n                    kwargs[""whitelist""] = whitelist\n                if ""kwargs"" in schema:\n                    kwargs.update({n: unfill(x) for n, x in schema[""kwargs""].items()})\n\n                out = gen(*args, **kwargs)\n\n            elif ""read"" in schema:\n                if schema.get(""absolute"", False):\n                    out = storage[schema[""read""]]\n                else:\n                    out = storage[prefix + schema[""read""]]\n\n            elif ""list"" in schema:\n                out = [unfill(x) for x in schema[""list""]]\n\n            elif ""tuple"" in schema:\n                out = tuple(unfill(x) for x in schema[""tuple""])\n\n            elif ""dict"" in schema:\n                out = {n: unfill(x) for n, x in schema[""dict""].items()}\n\n            elif ""pairs"" in schema:\n                out = [(n, unfill(x)) for n, x in schema[""pairs""]]\n\n            elif ""dtype"" in schema:\n                out = json2dtype(schema[""dtype""])\n\n            elif ""function"" in schema:\n                out = spec2function(schema[""function""], awkwardlib=awkwardlib, whitelist=whitelist)\n\n            elif ""json"" in schema:\n                out = schema[""json""]\n\n            elif ""python"" in schema:\n                out = topython(schema[""python""])\n\n            elif ""ref"" in schema:\n                out = seen.obj(schema[""ref""])\n\n            else:\n                raise ValueError(""unrecognized JSON object with fields {0}"".format("", "".join(repr(x) for x in schema)))\n\n            if ""id"" in schema:\n                seen[out] = schema[""id""]\n            return out\n\n        elif isinstance(schema, list):\n            raise ValueError(""unrecognized JSON list with length {0}"".format(len(schema)))\n\n        else:\n            raise ValueError(""unrecognized JSON object: {0}"".format(repr(schema)))\n\n    return unfill(schema[""schema""])\n\ndef keys(storage, name="""", subschemas=True):\n    schema = storage[name]\n    if isinstance(schema, numpy.ndarray):\n        schema = schema.tostring()\n    if isinstance(schema, bytes):\n        schema = schema.decode(""ascii"")\n    schema = json.loads(schema)\n\n    prefix = schema.get(""prefix"", """")\n\n    def recurse(schema):\n        if isinstance(schema, dict):\n            if ""call"" in schema and isinstance(schema[""call""], list) and len(schema[""call""]) > 0:\n                for x in schema.get(""args"", []):\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""kwargs"", {}).values():\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""*"", []):\n                    for y in recurse(x):\n                        yield y\n                for x in schema.get(""**"", {}).values():\n                    for y in recurse(x):\n                        yield y\n\n            elif ""read"" in schema:\n                if schema.get(""absolute"", False):\n                    yield schema[""read""]\n                else:\n                    yield prefix + schema[""read""]\n\n            elif ""list"" in schema:\n                for x in schema[""list""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""tuple"" in schema:\n                for x in schema[""tuple""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""dict"" in schema:\n                for x in schema[""dict""].values():\n                    for y in recurse(x):\n                        yield y\n\n            elif ""pairs"" in schema:\n                for n, x in schema[""pairs""]:\n                    for y in recurse(x):\n                        yield y\n\n            elif ""dtype"" in schema:\n                pass\n\n            elif ""function"" in schema:\n                pass\n\n            elif ""json"" in schema:\n                pass\n\n            elif ""python"" in schema:\n                pass\n\n            elif ""ref"" in schema:\n                pass\n\n    yield name\n    for x in recurse(schema[""schema""]):\n        yield x\n\ndef save(file, array, name=None, mode=""a"", **options):\n    if isinstance(array, dict):\n        arrays = array\n    else:\n        arrays = {"""": array}\n\n    if name is not None:\n        arrays = {name + n: x for n, x in arrays.items()}\n\n    arraynames = list(arrays)\n    for i in range(len(arraynames)):\n        for j in range(i + 1, len(arraynames)):\n            if arraynames[i].startswith(arraynames[j]) or arraynames[j].startswith(arraynames[i]):\n                raise KeyError(""cannot write both {0} and {1} to zipfile because one is a prefix of the other"", repr(arraynames[i]), repr(arraynames[j]))\n\n    if isinstance(file, getattr(os, ""PathLike"", ())):\n        file = os.fspath(file)\n    elif hasattr(file, ""__fspath__""):\n        file = file.__fspath__()\n    elif file.__class__.__module__ == ""pathlib"":\n        import pathlib\n        if isinstance(file, pathlib.Path):\n             file = str(file)\n\n    if isinstance(file, str) and not file.endswith("".awkd""):\n        file = file + "".awkd""\n\n    alloptions = {""delimiter"": ""-"", ""suffix"": "".raw"", ""schemasuffix"": "".json"", ""compression"": compression}\n    alloptions.update(options)\n    options = alloptions\n\n    class Wrap(object):\n        def __init__(self, f):\n            self.f = f\n        def __setitem__(self, where, what):\n            if isinstance(what, numpy.ndarray):\n                what = what.tostring()\n            self.f.writestr(where, what, compress_type=zipfile.ZIP_STORED)\n\n    with zipfile.ZipFile(file, mode=mode, compression=zipfile.ZIP_STORED) as f:\n        namelist = f.namelist()\n        for name in arraynames:\n            if any(n.startswith(name) for n in namelist):\n                raise KeyError(""cannot add {0} to zipfile because the following already exist: {1}"".format(repr(name), "", "".join(repr(n) for n in namelist if n.startswith(name))))\n\n        wrapped = Wrap(f)\n        for name, array in arrays.items():\n            serialize(array, wrapped, name=name, **options)\n\ndef load(file, **options):\n    f = Load(file, **options)\n    if list(f) == [""""]:\n        out = f[""""]\n        f.close()\n        return out\n    else:\n        return f\n\nclass Load(Mapping):\n    def __init__(self, file, **options):\n        class Wrap(object):\n            def __init__(self):\n                self.f = zipfile.ZipFile(file, mode=""r"")\n            def __getitem__(self, where):\n                return self.f.read(where)\n\n        self._file = Wrap()\n\n        alloptions = {""schemasuffix"": "".json"", ""awkwardlib"": ""awkward"", ""whitelist"": whitelist, ""cache"": None}\n        alloptions.update(options)\n        self.schemasuffix = alloptions.pop(""schemasuffix"")\n        self.options = alloptions\n\n    def __getitem__(self, where):\n        return deserialize(self._file, name=where + self.schemasuffix, awkwardlib=self.options[""awkwardlib""], whitelist=self.options[""whitelist""], cache=self.options[""cache""])\n\n    def __iter__(self):\n        for n in self._file.f.namelist():\n            if n.endswith("".json""):\n                yield n[:-5]\n\n    def __len__(self):\n        count = 0\n        for n in self._file.f.namelist():\n            if n.endswith("".json""):\n                count += 1\n        return count\n\n    def __repr__(self):\n        return ""<awkward.load ({0} members)>"".format(len(self))\n\n    def close(self):\n        self._file.f.close()\n\n    def __del__(self):\n        self.close()\n\n    def __enter__(self, *args, **kwds):\n        return self\n\n    def __exit__(self, *args, **kwds):\n        self.close()\n\nclass hdf5(MutableMapping):\n    def __init__(self, group, **options):\n        alloptions = {""compression"": compression, ""awkwardlib"": ""awkward"", ""whitelist"": whitelist, ""cache"": None}\n        alloptions.update(options)\n        self.options = alloptions\n        self.options[""delimiter""] = ""/""\n        self.options[""schemasuffix""] = ""/schema.json""\n\n        class Wrap(object):\n            def __init__(self):\n                self.g = group\n            def __getitem__(self, where):\n                return self.g[where][()]\n            def __setitem__(self, where, what):\n                self.g[where] = numpy.frombuffer(what, dtype=numpy.uint8)\n\n        self._group = Wrap()\n\n    def __getitem__(self, where):\n        return deserialize(self._group, name=where + self.options[""schemasuffix""], awkwardlib=self.options[""awkwardlib""], whitelist=self.options[""whitelist""], cache=self.options[""cache""])\n\n    def __setitem__(self, where, what):\n        options = dict(self.options)\n        if ""awkwardlib"" in options:\n            del options[""awkwardlib""]\n        if ""whitelist"" in options:\n            del options[""whitelist""]\n        if ""cache"" in options:\n            del options[""cache""]\n        self._group.g.create_group(where)\n        serialize(what, self._group, name=where, **options)\n\n    def __delitem__(self, where):\n        for subname in keys(self._group, name=where + self.options[""schemasuffix""]):\n            del self._group.g[subname]\n        del self._group.g[where]\n\n    def __iter__(self):\n        schemaname = self.options[""schemasuffix""].split(""/"")[-1]\n        for subname in self._group.g:\n            if schemaname in self._group.g[subname]:\n                yield subname\n\n    def __len__(self):\n        schemaname = self.options[""schemasuffix""].split(""/"")[-1]\n        count = 0\n        for subname in self._group.g:\n            if schemaname in self._group.g[subname]:\n                count += 1\n        return count\n\n    def __repr__(self):\n        return ""<awkward.hdf5 {0} ({1} members)>"".format(repr(self._group.g.name), len(self))\n'"
binder/awkward/type.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport math\nimport numbers\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Mapping\nexcept ImportError:\n    from collections import Mapping\n\nimport numpy\n\nimport awkward.util\n\ndef _str(tpe, indent=""""):\n    if isinstance(tpe, Type):\n        return tpe.__str__(indent=indent)\n    else:\n        return indent + str(tpe)\n\nclass Type(object):\n    check = True\n\n    def hascolumn(self, name):\n        return self._hascolumn(name, set())\n\n    @property\n    def isnumpy(self):\n        return self._isnumpy(set())\n\n    def __or__(self, other):\n        out = UnionType.__new__(UnionType)\n\n        if isinstance(self, UnionType) and isinstance(other, UnionType):\n            out._possibilities = self._possibilities + other._possibilities\n        elif isinstance(self, UnionType):\n            out._possibilities = self._possibilities + [other]\n        elif isinstance(other, UnionType):\n            out._possibilities = [self] + other._possibilities\n        else:\n            out._possibilities = [self, other]\n\n        return out\n\n    def _labeled(self):\n        seen = set()\n        labeled = []\n        def find(x):\n            if isinstance(x, Type):\n                if id(x) not in seen:\n                    seen.add(id(x))\n                    if isinstance(x, ArrayType):\n                        find(x._to)\n                    elif isinstance(x, TableType):\n                        for y in x._fields.values():\n                            find(y)\n                    elif isinstance(x, UnionType):\n                        for y in x._possibilities:\n                            find(y)\n                    elif isinstance(x, OptionType):\n                        find(x._type)\n                else:\n                    labeled.append(x)\n        find(self)\n        return labeled\n\n    def __repr__(self):\n        return self._repr(self._labeled(), set())\n\n    def _repr(self, labeled, seen):\n        if id(self) in seen:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    return ""T{0}"".format(i)\n        else:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    out = ""T{0} := "".format(i)\n                    break\n            else:\n                out = """"\n            seen.add(id(self))\n            return out + self._subrepr(labeled, seen)\n\n    def __str__(self, indent=""""):\n        return self._str(self._labeled(), set(), indent)\n\n    def _str(self, labeled, seen, indent):\n        if id(self) in seen:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    return indent + ""T{0}"".format(i)\n            raise AssertionError(""{0} not in {1}"".format(id(self), seen))\n        else:\n            for i, x in enumerate(labeled):\n                if self is x:\n                    out = indent + ""T{0} := "".format(i)\n                    break\n            else:\n                out = """"\n            seen.add(id(self))\n            return out + self._substr(labeled, seen, indent + ("" "" * len(out)))\n\n    @staticmethod\n    def _copy(x, seen):\n        if id(x) in seen:\n            return seen[id(x)]\n\n        elif isinstance(x, ArrayType):\n            seen[id(x)] = ArrayType.__new__(ArrayType)\n            seen[id(x)]._takes = x.takes\n            seen[id(x)]._to = Type._copy(x.to, seen)\n            return seen[id(x)]\n\n        elif isinstance(x, TableType):\n            seen[id(x)] = TableType.__new__(TableType)\n            seen[id(x)]._fields = OrderedDict()\n            for n, y in x._fields.items():\n                seen[id(x)]._fields[n] = Type._copy(y, seen)\n            return seen[id(x)]\n\n        elif isinstance(x, UnionType):\n            seen[id(x)] = UnionType.__new__(UnionType)\n            seen[id(x)]._possibilities = []\n            for y in x._possibilities:\n                seen[id(x)]._possibilities.append(Type._copy(y, seen))\n            return seen[id(x)]\n\n        elif isinstance(x, OptionType):\n            seen[id(x)] = OptionType.__new__(OptionType)\n            seen[id(x)]._type = Type._copy(x._type, seen)\n            return seen[id(x)]\n\n        else:\n            return x\n\n    @staticmethod\n    def _canonical(x, seen):\n        if id(x) not in seen:\n            # apply string-integer commutation so that TableTypes are nested as deeply as possible\n            if isinstance(x, TableType) and len(x._fields) > 0 and all(isinstance(y, ArrayType) for y in x._fields.values()):\n                newtable = TableType.__new__(TableType)\n                newtable._fields = OrderedDict()\n                first = None\n                for n, y in x._fields.items():\n                    if first is None:\n                        first = y._takes\n                    elif first != y._takes or math.isinf(y._takes):\n                        break\n                    newtable._fields[n] = y._to\n                else:\n                    x = ArrayType.__new__(ArrayType)\n                    x._takes = first\n                    x._to = newtable\n\n            # apply union(X, union(Y)) == union(X, Y)\n            if isinstance(x, UnionType) and any(isinstance(y, UnionType) for y in x._possibilities):\n                possibilities = []\n                for y in x._possibilities:\n                    if isinstance(y, UnionType):\n                        possibilities.extend(y._possibilities)\n                    else:\n                        possibilities.append(y)\n                x = UnionType.__new__(UnionType)\n                x._possibilities = possibilities\n\n            # apply optional(optional(X)) == optional(X)\n            if isinstance(x, OptionType) and isinstance(x._type, OptionType):\n                x = x._type\n\n            seen.add(id(x))\n            if isinstance(x, ArrayType):\n                x._to = Type._canonical(x._to, seen)\n            elif isinstance(x, TableType):\n                for n in x._fields:\n                    x._fields[n] = Type._canonical(x._fields[n], seen)\n            elif isinstance(x, UnionType):\n                for i in range(len(x._possibilities)):\n                    x._possibilities[i] = Type._canonical(x._possibilities[i], seen)\n            elif isinstance(x, OptionType):\n                x._type = Type._canonical(x._type, seen)\n\n        return x\n\n    def __eq__(self, other):\n        if not isinstance(other, Type):\n            return False\n        else:\n            one = Type._canonical(Type._copy(self, {}), set())\n            two = Type._canonical(Type._copy(other, {}), set())\n            return one._eq(two, set(), ignoremask=False)\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    @staticmethod\n    def _eq2(one, two, seen, ignoremask=False):\n        if isinstance(one, Type):\n            return one._eq(two, seen, ignoremask=ignoremask)\n        elif one == two:\n            return True\n        elif callable(one) and callable(two):\n            return True\n        else:\n            return False\n\n    @staticmethod\n    def _finaltype(x):\n        if isinstance(x, type) and issubclass(x, (numbers.Number, numpy.generic)):\n            return numpy.dtype(x)\n        elif isinstance(x, (awkward.util.unicode, bytes)):\n            return numpy.dtype(x)\n        else:\n            return x\n\nclass ArrayType(Type):\n    def __init__(self, *args):\n        if len(args) < 2:\n            raise ValueError(""type specification missing"")\n\n        elif isinstance(args[0], awkward.util.string):\n            self.__class__ = TableType\n            self._fields = OrderedDict()\n            if len(args) == 2:\n                self[args[0]] = args[1]\n            else:\n                self[args[0]] = ArrayType(*args[1:])\n\n        else:\n            self.takes = args[0]\n            if len(args) == 2:\n                self.to = args[1]\n            else:\n                self.to = ArrayType(*args[1:])\n\n    @property\n    def takes(self):\n        return self._takes\n\n    @takes.setter\n    def takes(self, value):\n        if value == numpy.inf or (isinstance(value, (numbers.Integral, numpy.integer)) and value >= 0):\n            self._takes = value\n        else:\n            raise ValueError(""{0} is not allowed in type specification"".format(value))\n\n    @property\n    def to(self):\n        return self._to\n\n    @to.setter\n    def to(self, value):\n        if isinstance(value, Type):\n            self._to = value\n        else:\n            self._to = self._finaltype(value)\n\n    @property\n    def shape(self):\n        if self._takes == numpy.inf:\n            return ()\n\n        elif isinstance(self._to, (Type, numpy.dtype)):\n            return (self._takes,) + self._to.shape\n\n        else:\n            return (self._takes,)\n\n    @property\n    def dtype(self):\n        if self._takes == numpy.inf:\n            return numpy.dtype(object)\n\n        elif isinstance(self._to, Type):\n            return self._to.dtype\n\n        elif isinstance(self._to, numpy.dtype):\n            if self._to.subdtype is None:\n                return self._to\n            else:\n                return self._to.subdtype[0]\n\n        else:\n            return numpy.dtype(object)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if self._takes == numpy.inf:\n            return False\n        elif isinstance(self._to, numpy.dtype):\n            return True\n        else:\n            return self._to._isnumpy(seen)\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if isinstance(self._to, numpy.dtype) and self._to.names is None:\n            return False\n        elif isinstance(self._to, numpy.dtype):\n            return name in self._to.names\n        elif isinstance(self._to, Type):\n            return self._to._hascolumn(name, seen)\n        else:\n            return False\n\n    def _subrepr(self, labeled, seen):\n        if isinstance(self._to, Type):\n            to = self._to._repr(labeled, seen)\n            if to.startswith(""ArrayType("") and to.endswith("")""):\n                to = to[10:-1]\n            return ""ArrayType({0}, {1})"".format(repr(self._takes), to)\n        else:\n            return ""ArrayType({0}, {1})"".format(repr(self._takes), repr(self._to))\n\n    def _substr(self, labeled, seen, indent):\n        takes = ""[0, {0}) -> "".format(self._takes)\n        if isinstance(self._to, Type):\n            to = self._to._str(labeled, seen, indent + ("" "" * len(takes))).lstrip("" "")\n        else:\n            to = str(self._to)\n        return takes + to\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, ArrayType) and self._takes == other._takes:\n                return self._eq2(self._to, other._to, seen, ignoremask=ignoremask)\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((ArrayType, self._takes, self._to))\n\nclass TableType(Type):\n    def __init__(self, **fields):\n        self._fields = OrderedDict()\n        for n, x in fields.items():\n            self._fields[n] = x\n\n    @property\n    def shape(self):\n        return ()\n\n    @property\n    def dtype(self):\n        out = []\n        for n, x in self._fields.items():\n            if x.shape != ():\n                raise TypeError(""Table with non-primitive fields has no Numpy dtype"")\n            elif isinstance(x, numpy.dtype):\n                out.append((n, x))\n            else:\n                out.append((n, x.dtype))\n        return numpy.dtype(out)\n\n    @property\n    def columns(self):\n        return list(self._fields)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        for x in self._fields.values():\n            if isinstance(x, numpy.dtype):\n                return True\n            elif not isinstance(x, OptionType) and x._isnumpy(seen):\n                return x.shape != ()\n            else:\n                return False\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        return name in self._fields\n\n    def __getitem__(self, key):\n        return self._fields[key]\n\n    def __setitem__(self, key, value):\n        if isinstance(value, Type):\n            self._fields[key] = value\n        else:\n            self._fields[key] = self._finaltype(value)\n\n    def __delitem__(self, key):\n        del self._fields[key]\n\n    def __and__(self, other):\n        out = TableType.__new__(TableType)\n        out._fields = OrderedDict(list(self._fields.items()) + list(other._fields.items()))\n        return out\n\n    def _subrepr(self, labeled, seen):\n        return ""TableType({0})"".format("", "".join(""{0}={1}"".format(n, x._repr(labeled, seen) if isinstance(x, Type) else repr(x)) for n, x in self._fields.items()))\n\n    def _substr(self, labeled, seen, indent):\n        width = max(len(repr(n)) for n in self._fields.keys())\n        subindent = indent + ("" "" * width) + ""    ""\n        out = []\n        for n, x in self._fields.items():\n            if isinstance(x, Type):\n                to = x._str(labeled, seen, subindent).lstrip("" "")\n            else:\n                to = str(x)\n            out.append((""{0}{1:%ds} -> {2}"" % width).format(indent, repr(n), to))\n        return ""\\n"".join(out).lstrip("" "")\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, TableType) and sorted(self._fields) == sorted(other._fields):\n                for n in self._fields:\n                    if not self._eq2(self._fields[n], other._fields[n], seen, ignoremask=ignoremask):\n                        return False\n                else:\n                    return True    # nothing failed in the loop over fields\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((TableType, tuple((n, self._fields[n]) for n in sorted(self._fields))))\n\nclass UnionType(Type):\n    def __init__(self, *possibilities):\n        self._possibilities = []\n        for x in possibilities:\n            self.append(x)\n\n    @property\n    def shape(self):\n        raise TypeError(""Union has no Numpy dtype"")\n\n    @property\n    def dtype(self):\n        raise TypeError(""Union has no Numpy dtype"")\n\n    def _isnumpy(self, seen):\n        return False\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        for x in self._possibilities:\n            if isinstance(x, numpy.dtype) and x.names is not None and name in x.names:\n                return True\n            elif isinstance(x, Type) and x._hascolumn(name, seen):\n                return True\n        else:\n            return False\n\n    def __len__(self):\n        return len(self._possibilities)\n\n    def __getitem__(self, index):\n        return self._possibilities[index]\n\n    def __setitem__(self, index, value):\n        if isinstance(value, Type):\n            self._possibilities[index] = value\n        else:\n            self._possibilities[index] = self._finaltype(value)\n\n    def __delitem__(self, index):\n        del self._possibilities[index]\n\n    def append(self, value):\n        if isinstance(value, Type):\n            self._possibilities.append(value)\n        else:\n            self._possibilities.append(self._finaltype(value))\n\n    def _subrepr(self, labeled, seen):\n        return ""UnionType({0})"".format("", "".join(x._repr(labeled, seen) if isinstance(x, Type) else repr(x) for x in self._possibilities))\n\n    def _substr(self, labeled, seen, indent):\n        subs = [x._str(labeled, seen, indent + "" "") if isinstance(x, Type) else str(x) for x in self._possibilities]\n        def lstrip(x):\n            if x.startswith(indent + "" ""):\n                return x[len(indent) + 1:]\n            else:\n                return x\n        width = max(len(lstrip(y)) for x in subs for y in x.split(""\\n""))\n        out = [x + "" "" * (width - len(lstrip(x.split(""\\n"")[-1]))) for x in subs]\n        return ""("" + ("" |\\n"" + indent + "" "").join(out) + "" )""\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, UnionType) and len(self._possibilities) == len(other._possibilities):\n                for x, y in zip(sorted(self._possibilities), sorted(self._possibilities)):\n                    if not self._eq2(x, y, seen, ignoremask=ignoremask):\n                        return False\n                else:\n                    return True    # nothing failed in the loop over possibilities\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((UnionType, tuple(self._possibilities)))\n\nclass OptionType(Type):\n    def __init__(self, type):\n        self.type = type\n\n    @property\n    def type(self):\n        return self._type\n\n    @type.setter\n    def type(self, value):\n        if isinstance(value, Type):\n            self._type = value\n        else:\n            self._type = self._finaltype(value)\n\n    @property\n    def shape(self):\n        if isinstance(self._type, (Type, numpy.dtype)):\n            return self._type.shape\n        else:\n            return ()\n\n    @property\n    def dtype(self):\n        if isinstance(self._type, Type):\n            return self._type.dtype\n\n        elif isinstance(self._type, numpy.dtype):\n            if self._type.subdtype is None:\n                return self._type\n            else:\n                return self._type.subdtype[0]\n\n        else:\n            return numpy.dtype(object)\n\n    def _isnumpy(self, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        if isinstance(self._type, numpy.dtype):\n            return True\n        else:\n            return self._type._isnumpy(seen)\n\n    def _hascolumn(self, name, seen):\n        if id(self) in seen:\n            return False\n        seen.add(id(self))\n        return self._type._hascolumn(name, seen)\n\n    def _subrepr(self, labeled, seen):\n        return ""OptionType({0})"".format(self._type._repr(labeled, seen) if isinstance(self._type, Type) else repr(self._type))\n\n    def _substr(self, labeled, seen, indent):\n        if isinstance(self._type, Type):\n            type = self._type._str(labeled, seen, indent + ""  "").lstrip("" "")\n        else:\n            type = str(self._type)\n        return ""?({0})"".format(type)\n\n    def _eq(self, other, seen, ignoremask=False):\n        if not self.check:\n            return True\n        if self is other:\n            return True\n        elif id(self) in seen:\n            return False\n        else:\n            seen.add(id(self))\n            if isinstance(other, OptionType):\n                if self._eq2(self._type, other._type, seen, ignoremask=ignoremask):\n                    return True\n            if ignoremask:    # applied asymmetrically; only the left can ignore mask\n                return self._eq2(self._type, other, seen, ignoremask=ignoremask)\n            else:\n                return False\n\n    def __hash__(self):\n        return hash((OptionType, self._type))\n\n###############################################################################\n\ndef fromnumpy(shape, dtype, masked=False):\n    if not isinstance(shape, tuple):\n        shape = (shape,)\n    if not isinstance(dtype, numpy.dtype):\n        dtype = numpy.dtype(dtype)\n\n    if masked:\n        return OptionType(fromnumpy(shape, dtype))\n    elif dtype.subdtype is not None:\n        dt, sh = dtype.subdtype\n        return fromnumpy(shape + sh, dt)\n    else:\n        return ArrayType(*(shape + (dtype,)))\n\ndef fromarray(array):\n    return ArrayType(len(array), _resolve(_fromarray(array, {}), {}))\n\ndef _fromarray(array, seen):\n    if id(array) not in seen:\n        seen[id(array)] = placeholder = Placeholder()\n\n        if isinstance(array, numpy.ndarray):\n            if array.dtype.names is None:\n                out = array.dtype\n\n            else:\n                out = TableType.__new__(TableType)\n                out._fields = OrderedDict()\n                for n in array.dtype.names:\n                    out[n] = array.dtype[n]\n\n            for x in array.shape[:0:-1]:\n                out = ArrayType(x, out)\n            if isinstance(array, numpy.ma.MaskedArray):\n                out = OptionType(out)\n\n            placeholder.value = out\n\n        else:\n            placeholder.value = array._gettype(seen)\n\n    return seen[id(array)]\n\nclass Placeholder(Type):\n    def __init__(self, value=None):\n        self.value = value\n\n    def _subrepr(self, labeled, seen):\n        return ""Placeholder({0})"".format(self.value._repr(labeled, seen) if isinstance(self.value, Type) else repr(self.value))\n\ndef _resolve(tpe, seen):\n    while isinstance(tpe, Placeholder):\n        tpe = tpe.value\n\n    assert tpe is not None\n\n    if id(tpe) not in seen:\n        if isinstance(tpe, ArrayType):\n            seen[id(tpe)] = ArrayType.__new__(ArrayType)\n            seen[id(tpe)]._takes = tpe.takes\n            seen[id(tpe)]._to = _resolve(tpe._to, seen)\n\n        elif isinstance(tpe, TableType):\n            seen[id(tpe)] = TableType.__new__(TableType)\n            seen[id(tpe)]._fields = OrderedDict()\n            for n, y in tpe._fields.items():\n                seen[id(tpe)]._fields[n] = _resolve(y, seen)\n\n        elif isinstance(tpe, UnionType):\n            seen[id(tpe)] = UnionType.__new__(UnionType)\n            seen[id(tpe)]._possibilities = []\n            for y in tpe._possibilities:\n                seen[id(tpe)]._possibilities.append(_resolve(y, seen))\n\n        elif isinstance(tpe, OptionType):\n            seen[id(tpe)] = OptionType.__new__(OptionType)\n            seen[id(tpe)]._type = _resolve(tpe._type, seen)\n\n        else:\n            seen[id(tpe)] = tpe\n\n    return seen[id(tpe)]\n\n###############################################################################\n\nclass Layout(Mapping):\n    def __init__(self, array):\n        self.lookup = {}\n        self.top = LayoutNode(array, Position(), {}, self.lookup)\n\n    @staticmethod\n    def keystr(x):\n        return ""()"" if len(x) == 0 else "", "".join(repr(i) for i in x)\n\n    @staticmethod\n    def valstr(x):\n        if isinstance(x, Position):\n            return ""layout["" + (""()"" if len(x) == 0 else "", "".join(repr(i) for i in x)) + ""]""\n        elif isinstance(x, type):\n            return x.__name__\n        else:\n            return str(x)\n\n    def __repr__(self):\n        out = ["" layout ""]\n        longest = max(6, max([len(self.keystr(i)) for i in self.lookup]))\n        for i in sorted(self.lookup):\n            x = self.lookup[i]\n            indent = ""  "" * len(i)\n            if x.args is None:\n                out.append((""[{0:>%ds}] {1}-> {2}"" % longest).format(self.keystr(i), indent, self.valstr(x.cls)))\n            else:\n                out.append((""[{0:>%ds}] {1}{2}({3})"" % longest).format(self.keystr(i), indent, self.valstr(x.cls), "", "".join(str(y) for y in x.args)))\n        return ""\\n"".join(out)\n\n    def __iter__(self):\n        return (i for i in sorted(self.lookup))\n\n    def __getitem__(self, where):\n        if not isinstance(where, tuple):\n            where = (where,)\n        return self.lookup[where]\n\n    def __len__(self):\n        return len(self.lookup)\n\nclass LayoutNode(object):\n    def __init__(self, array, position, seen, lookup):\n        import awkward.array.base\n        self.array = array\n        self.position = position\n        lookup[position] = self\n        self.args = None\n        if id(array) in seen:\n            self.cls = seen[id(array)]\n        else:\n            self.cls = type(array)\n            seen[id(array)] = position\n            if isinstance(array, awkward.array.base.AwkwardArray):\n                self.args = array._util_layout(position, seen, lookup)\n            else:\n                self.args = (LayoutArg(""shape"", array.shape), LayoutArg(""dtype"", array.dtype))\n\n    def __repr__(self):\n        if self.args is None:\n            return ""<LayoutNode [{0}] -> {1}>"".format(Layout.keystr(self.position), Layout.valstr(self.cls))\n        return ""<LayoutNode [{0}] {1}>"".format(self.position, self.cls.__name__)\n\nclass Position(tuple):\n    def __add__(self, other):\n        return Position(super(Position, self).__add__(other))\n\nclass LayoutArg(object):\n    def __init__(self, name, value):\n        self.name = name\n        self.value = value\n\n    def __repr__(self):\n        return ""LayoutArg({0}, {1})"".format(repr(self.name), repr(self.value))\n\n    def __str__(self):\n        if isinstance(self.value, list):\n            return self.name + ""=["" + "", "".join(Layout.valstr(x) for x in self.value) + ""]""\n        elif self.name == ""shape"":\n            return ""shape={0}"".format(self.value[0] if len(self.value) == 1 else self.value)\n        elif self.name == ""dtype"":\n            return ""dtype={0}"".format(repr(self.value))\n        else:\n            return ""{0}={1}"".format(str(self.name), Layout.valstr(self.value))\n'"
binder/awkward/util.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport itertools\nimport importlib\nimport sys\nimport os\nfrom collections import OrderedDict\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nfrom functools import wraps\n\nimport numpy\n\nif sys.version_info[0] <= 2:\n    izip = itertools.izip\n    string = basestring\n    unicode = unicode\nelse:\n    izip = zip\n    string = str\n    unicode = str\n\nfrombuffer = numpy.frombuffer\n\ndef toarray(value, defaultdtype, passthrough=None):\n    import awkward.array.base\n    return awkward.array.base.AwkwardArray._util_toarray(value, defaultdtype, passthrough=passthrough)\n\ndef awkwardlib(awkwardlib):\n    if awkwardlib is None:\n        import awkward\n        return awkward\n    elif isinstance(awkwardlib, str):\n        return importlib.import_module(awkwardlib)\n    else:\n        return awkwardlib\n\nclass bothmethod(object):\n    def __init__(self, fcn):\n        self.fcn = fcn\n    def __get__(self, ins, typ):\n        if ins is None:\n            return lambda *args, **kwargs: self.fcn(True, typ, *args, **kwargs)\n        else:\n            return lambda *args, **kwargs: self.fcn(False, ins, *args, **kwargs)\n\n# numpy on windows has some strange behavior with dtypes of certain functions\n# requiring us to cast down to int32 for (at least): ufunc.reduceat, repeat\ndef windows_safe(array):\n    if os.name == ""nt"":\n        return array.astype(numpy.int32)\n    return array\n\n################################################################ wrappers (used to be in uproot-methods)\n\ndef _normalize_arrays(cls, arrays):\n    length = None\n    for i in range(len(arrays)):\n        if isinstance(arrays[i], Iterable):\n            if length is None:\n                length = len(arrays[i])\n                break\n    if length is None:\n        raise TypeError(""cannot construct an array if all arguments are scalar"")\n\n    arrays = list(arrays)\n    jaggedtype = [cls.awkward.JaggedArray] * len(arrays)\n    starts, stops = None, None\n    for i in range(len(arrays)):\n        if starts is None and isinstance(arrays[i], cls.awkward.JaggedArray):\n            starts, stops = arrays[i].starts, arrays[i].stops\n\n        if isinstance(arrays[i], cls.awkward.JaggedArray):\n            jaggedtype[i] = type(arrays[i])\n\n        if not isinstance(arrays[i], Iterable):\n            arrays[i] = cls.awkward.numpy.full(length, arrays[i])\n\n        arrays[i] = cls.awkward.util.toarray(arrays[i], cls.awkward.numpy.float64)\n\n    if starts is None:\n        return arrays\n\n    for i in range(len(arrays)):\n        if not isinstance(arrays[i], cls.awkward.JaggedArray) or not (cls.awkward.numpy.array_equal(starts, arrays[i].starts) and cls.awkward.numpy.array_equal(stops, arrays[i].stops)):\n            content = cls.awkward.numpy.zeros(stops.max(), dtype=cls.awkward.numpy.float64)\n            arrays[i] = jaggedtype[i](starts, stops, content) + arrays[i]    # invoke jagged broadcasting to align arrays\n\n    return arrays\n\ndef unwrap_jagged(cls, awkcls, arrays):\n    if not isinstance(arrays[0], cls.awkward.JaggedArray):\n        return lambda x: x, arrays\n\n    counts = arrays[0].counts.reshape(-1)\n    offsets = awkcls.counts2offsets(counts)\n    starts, stops = offsets[:-1], offsets[1:]\n    starts = starts.reshape(arrays[0].starts.shape[:-1] + (-1,))\n    stops = stops.reshape(arrays[0].stops.shape[:-1] + (-1,))\n    wrap, arrays = unwrap_jagged(cls, awkcls, [x.flatten() for x in arrays])\n    return lambda x: awkcls(starts, stops, wrap(x)), arrays\n\ndef wrapjaggedmethod(awkcls):\n    def wrapjagged_decorator(func):\n        @wraps(func)\n        def func_wrapper(cls, *arrays):\n            wrap, arrays = unwrap_jagged(cls, awkcls, _normalize_arrays(cls, arrays))\n            return wrap(func(cls, *arrays))\n        return func_wrapper\n    return wrapjagged_decorator\n\n################################################################ array helpers\n\ntry:\n    NDArrayOperatorsMixin = numpy.lib.mixins.NDArrayOperatorsMixin\n\nexcept AttributeError:\n    from numpy.core import umath as um\n\n    def _disables_array_ufunc(obj):\n        """"""True when __array_ufunc__ is set to None.""""""\n        try:\n            return obj.__array_ufunc__ is None\n        except AttributeError:\n            return False\n\n    def _binary_method(ufunc, name):\n        """"""Implement a forward binary method with a ufunc, e.g., __add__.""""""\n        def func(self, other):\n            if _disables_array_ufunc(other):\n                return NotImplemented\n            return ufunc(self, other)\n        func.__name__ = \'__{}__\'.format(name)\n        return func\n\n    def _reflected_binary_method(ufunc, name):\n        """"""Implement a reflected binary method with a ufunc, e.g., __radd__.""""""\n        def func(self, other):\n            if _disables_array_ufunc(other):\n                return NotImplemented\n            return ufunc(other, self)\n        func.__name__ = \'__r{}__\'.format(name)\n        return func\n\n    def _inplace_binary_method(ufunc, name):\n        """"""Implement an in-place binary method with a ufunc, e.g., __iadd__.""""""\n        def func(self, other):\n            return ufunc(self, other, out=(self,))\n        func.__name__ = \'__i{}__\'.format(name)\n        return func\n\n    def _numeric_methods(ufunc, name):\n        """"""Implement forward, reflected and inplace binary methods with a ufunc.""""""\n        return (_binary_method(ufunc, name),\n                _reflected_binary_method(ufunc, name),\n                _inplace_binary_method(ufunc, name))\n\n    def _unary_method(ufunc, name):\n        """"""Implement a unary special method with a ufunc.""""""\n        def func(self):\n            return ufunc(self)\n        func.__name__ = \'__{}__\'.format(name)\n        return func\n\n    class NDArrayOperatorsMixin(object):\n        __lt__ = _binary_method(um.less, \'lt\')\n        __le__ = _binary_method(um.less_equal, \'le\')\n        __eq__ = _binary_method(um.equal, \'eq\')\n        __ne__ = _binary_method(um.not_equal, \'ne\')\n        __gt__ = _binary_method(um.greater, \'gt\')\n        __ge__ = _binary_method(um.greater_equal, \'ge\')\n\n        # numeric methods\n        __add__, __radd__, __iadd__ = _numeric_methods(um.add, \'add\')\n        __sub__, __rsub__, __isub__ = _numeric_methods(um.subtract, \'sub\')\n        __mul__, __rmul__, __imul__ = _numeric_methods(um.multiply, \'mul\')\n        if sys.version_info.major < 3:\n            # Python 3 uses only __truediv__ and __floordiv__\n            __div__, __rdiv__, __idiv__ = _numeric_methods(um.divide, \'div\')\n        __truediv__, __rtruediv__, __itruediv__ = _numeric_methods(\n            um.true_divide, \'truediv\')\n        __floordiv__, __rfloordiv__, __ifloordiv__ = _numeric_methods(\n            um.floor_divide, \'floordiv\')\n        __mod__, __rmod__, __imod__ = _numeric_methods(um.remainder, \'mod\')\n        if hasattr(um, ""divmod""):\n            __divmod__ = _binary_method(um.divmod, \'divmod\')\n            __rdivmod__ = _reflected_binary_method(um.divmod, \'divmod\')\n        # __idivmod__ does not exist\n        # TODO: handle the optional third argument for __pow__?\n        __pow__, __rpow__, __ipow__ = _numeric_methods(um.power, \'pow\')\n        __lshift__, __rlshift__, __ilshift__ = _numeric_methods(\n            um.left_shift, \'lshift\')\n        __rshift__, __rrshift__, __irshift__ = _numeric_methods(\n            um.right_shift, \'rshift\')\n        __and__, __rand__, __iand__ = _numeric_methods(um.bitwise_and, \'and\')\n        __xor__, __rxor__, __ixor__ = _numeric_methods(um.bitwise_xor, \'xor\')\n        __or__, __ror__, __ior__ = _numeric_methods(um.bitwise_or, \'or\')\n\n        # unary methods\n        __neg__ = _unary_method(um.negative, \'neg\')\n        if hasattr(um, ""positive""):\n            __pos__ = _unary_method(um.positive, \'pos\')\n            __abs__ = _unary_method(um.absolute, \'abs\')\n            __invert__ = _unary_method(um.invert, \'invert\')\n\n################################################################ conversion of arrays to Pandas\n\ndef topandas(array, flatten=False):\n    import pandas\n    import awkward.array.base\n\n    if isinstance(array, awkward.array.base.AwkwardArray):\n        if flatten:\n            return topandas_flatten(array)\n        else:\n            out = array._topandas({})\n            if len(out.columns) == 0:\n                return pandas.Series(out)\n            else:\n                return pandas.DataFrame({n: out[n] for n in out.columns}, columns=out.columns)\n    else:\n        out = numpy.array(array, copy=False)\n        if out.dtype.fields is None:\n            return pandas.Series(out)\n        else:\n            return pandas.DataFrame(out)\n\ndef topandas_flatten(array):\n    import numpy\n    import pandas\n\n    import awkward.array.base\n    import awkward.array.chunked\n    import awkward.array.jagged\n    import awkward.array.objects\n    import awkward.array.table\n    import awkward.array.virtual\n    import awkward.type\n\n    if isinstance(array, awkward.array.base.AwkwardArray):\n        numpy = array.numpy\n        JaggedArray = array.JaggedArray\n        Table = array.Table\n    else:\n        JaggedArray = awkward.array.jagged.JaggedArray\n        Table = awkward.array.table.Table\n\n    def unwrap(a):\n        if isinstance(a, awkward.array.chunked.ChunkedArray):\n            chunks = [unwrap(x) for x in a.chunks]\n            if any(isinstance(x, awkward.array.jagged.JaggedArray) for x in chunks):\n                return awkward.array.jagged.JaggedArray.concatenate(chunks)\n            else:\n                return numpy.concatenate([x.regular() for x in chunks])\n        elif isinstance(a, awkward.array.virtual.VirtualArray):\n            return a.array\n        else:\n            return a\n\n    globalindex = [None]\n    localindex = []\n    columns = []\n    def recurse(array, tpe, cols, seriously):\n        if isinstance(tpe, awkward.type.TableType):\n            starts, stops = None, None\n            out, deferred, unflattened = None, {}, None\n\n            for n in tpe.columns:\n                if not isinstance(n, str):\n                    raise ValueError(""column names must be strings"")\n\n                arrayn = unwrap(array[n])\n                tpen = tpe[n]\n                colsn = cols + (n,) if seriously else cols\n\n                if isinstance(arrayn, awkward.array.objects.ObjectArray) and not isinstance(arrayn, awkward.array.objects.StringArray):\n                    arrayn = arrayn.content\n                if not isinstance(tpen, (numpy.dtype, str, bytes, awkward.type.Type)):\n                    tpen = awkward.type.fromarray(arrayn).to\n                if isinstance(tpen, numpy.dtype):\n                    columns.append(colsn)\n                    tmp = arrayn\n\n                elif isinstance(tpen, type) and issubclass(tpen, (str, bytes)):\n                    columns.append(colsn)\n                    tmp = arrayn\n\n                elif isinstance(tpen, awkward.type.ArrayType) and tpen.takes == numpy.inf:\n                    tmp = JaggedArray(arrayn.starts, arrayn.stops, recurse(arrayn.content, tpen.to, colsn, True))\n\n                elif isinstance(tpen, awkward.type.TableType):\n                    tmp = recurse(arrayn, tpen, colsn, True)\n\n                elif isinstance(tpen, awkward.type.OptionType) and isinstance(arrayn.content, numpy.ndarray):\n                    columns.append(colsn)\n                    tmp = numpy.ma.MaskedArray(arrayn.content, arrayn.boolmask(maskedwhen=True))\n\n                else:\n                    raise ValueError(""this array has unflattenable substructure:\\n\\n{0}"".format(str(tpen)))\n\n                if isinstance(tmp, awkward.array.jagged.JaggedArray):\n                    if isinstance(tmp.content, awkward.array.jagged.JaggedArray):\n                        unflattened = tmp\n                        tmp = tmp.flatten(axis=1)\n\n                    if starts is None:\n                        starts, stops = tmp.starts, tmp.stops\n                    elif not numpy.array_equal(starts, tmp.starts) or not numpy.array_equal(stops, tmp.stops):\n                        raise ValueError(""this array has more than one jagged array structure"")\n                    if out is None:\n                        out = JaggedArray(starts, stops, Table({n: tmp.content}))\n                    else:\n                        out[n] = tmp\n\n                else:\n                    deferred[n] = tmp\n\n            if out is None:\n                out = Table()\n\n            for n, x in deferred.items():\n                out[n] = x\n\n            m = """"\n            while m in tpe.columns:\n                m = m + "" ""\n            out[m] = numpy.arange(len(out))\n            globalindex[0] = out[m].flatten()\n\n            for n in tpe.columns:\n                arrayn = unwrap(array[n])\n                if isinstance(arrayn, awkward.array.jagged.JaggedArray):\n                    if unflattened is None:\n                        localindex.insert(0, out[n].localindex.flatten())\n                    else:\n                        oldloc = unflattened.content.localindex\n                        tab = JaggedArray(oldloc.starts, oldloc.stops, Table({""oldloc"": oldloc.content}))\n                        tab[""newloc""] = arrayn.localindex.flatten()\n                        localindex.insert(0, tab[""newloc""].flatten())\n                    break\n\n            return out[tpe.columns]\n\n        else:\n            return recurse(Table({"""": array}), awkward.type.TableType(**{"""": tpe}), cols, False)[""""]\n\n    tmp = recurse(array, awkward.type.fromarray(array).to, (), True)\n    if isinstance(tmp, awkward.array.jagged.JaggedArray):\n        tmp = tmp.flatten()\n\n    deepest = max(len(x) for x in columns)\n\n    out = {}\n    for i, col in enumerate(columns):\n        x = tmp\n        for c in col:\n            x = x[c]\n        columns[i] = col + ("""",) * (deepest - len(col))\n        out[columns[i]] = x\n\n    index = globalindex + localindex\n    if len(index) == 1:\n        index = pandas.Index(index[0])\n    else:\n        index = pandas.MultiIndex.from_arrays(index)\n\n    if len(columns) == 1 and deepest == 0:\n        return pandas.Series(out[()], index=index)\n    else:\n        return pandas.DataFrame(data=out, index=index, columns=pandas.MultiIndex.from_tuples(columns))\n'"
binder/awkward/version.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport re\n\n__version__ = ""0.12.21""\nversion = __version__\nversion_info = tuple(re.split(r""[-\\.]"", __version__))\n\ndel re\n'"
tests/generate/makearrow.py,0,"b'#!/usr/bin/env python\n\nimport pandas\nimport awkward\nimport pyarrow\n\nexoplanets = pandas.read_csv(""/home/pivarski/talks/2019-05-28-lpchats-numpy-uproot-awkward/data/nasa-exoplanets.csv"")\nexoplanets.index = pandas.MultiIndex.from_arrays([exoplanets[""pl_hostname""], exoplanets[""pl_letter""]])\nexoplanets.index.names = [""star"", ""planet""]\n\ndf = exoplanets[[""ra"", ""dec"", ""st_dist"", ""st_mass"", ""st_rad"", ""pl_orbsmax"", ""pl_orbeccen"", ""pl_orbper"", ""pl_bmassj"", ""pl_radj""]]\ndf.columns = pandas.MultiIndex.from_arrays([[""star""] * 5 + [""planet""] * 5,\n    [""right asc. (deg)"", ""declination (deg)"", ""distance (pc)"", ""mass (solar)"", ""radius (solar)"", ""orbit (AU)"", ""eccen."", ""period (days)"", ""mass (Jupiter)"", ""radius (Jupiter)""]])\n\nstardicts = []\nfor (starname, planetname), row in df.iterrows():\n    if len(stardicts) == 0 or stardicts[-1][""name""] != starname:\n        stardicts.append({""name"": starname,\n                          ""ra"": row[""star"", ""right asc. (deg)""],\n                          ""dec"": row[""star"", ""declination (deg)""],\n                          ""dist"": row[""star"", ""distance (pc)""],\n                          ""mass"": row[""star"", ""mass (solar)""],\n                          ""radius"": row[""star"", ""radius (solar)""],\n                          ""planets"": []})\n    stardicts[-1][""planets""].append({""name"": planetname,\n                                     ""orbit"": row[""planet"", ""orbit (AU)""],\n                                     ""eccen"": row[""planet"", ""eccen.""],\n                                     ""period"": row[""planet"", ""period (days)""],\n                                     ""mass"": row[""planet"", ""mass (Jupiter)""],\n                                     ""radius"": row[""planet"", ""radius (Jupiter)""]})\n\nstars = awkward.fromiter(stardicts)\narrowstars = awkward.toarrow(stars)\n\nwith open(""exoplanets.arrow"", ""wb"") as sink:\n    writer = pyarrow.RecordBatchFileWriter(sink, arrowstars.schema)\n    for batch in arrowstars.to_batches():\n        writer.write_batch(batch)\n    writer.close()\n\n# to read it back again:\nawkward.fromarrow(pyarrow.ipc.open_file(open(""exoplanets.arrow"", ""rb"")).get_batch(0))\n'"
awkward-cpp/awkward/cpp/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport numpy\n\n# the following commented out lines allow JaggedArrayCpp to inherit from awkward-array\n#from awkward.cpp.array.base import CppMethods\n#from awkward.cpp.array.jagged import JaggedArrayCpp as JaggedArray\n\n#__all__ = [""CppMethods"", ""JaggedArray""]\n\nfrom awkward.cpp.array.array_impl import JaggedArray as JaggedArray\n\n__all__ = [""JaggedArray""]\n'"
awkward-numba/awkward/numba/__init__.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport numpy\n\nfrom awkward.numba.array.base import NumbaMethods\nfrom awkward.numba.array.chunked import ChunkedArrayNumba as ChunkedArray\nfrom awkward.numba.array.chunked import AppendableArrayNumba as AppendableArray\nfrom awkward.numba.array.indexed import IndexedArrayNumba as IndexedArray\nfrom awkward.numba.array.indexed import SparseArrayNumba as SparseArray\nfrom awkward.numba.array.jagged import JaggedArrayNumba as JaggedArray\nfrom awkward.numba.array.masked import MaskedArrayNumba as MaskedArray\nfrom awkward.numba.array.masked import BitMaskedArrayNumba as BitMaskedArray\nfrom awkward.numba.array.masked import IndexedMaskedArrayNumba as IndexedMaskedArray\nfrom awkward.numba.array.objects import MethodsNumba as Methods\nfrom awkward.numba.array.objects import ObjectArrayNumba as ObjectArray\nfrom awkward.numba.array.objects import StringArrayNumba as StringArray\nfrom awkward.numba.array.table import TableNumba as Table\nfrom awkward.numba.array.union import UnionArrayNumba as UnionArray\nfrom awkward.numba.array.virtual import VirtualArrayNumba as VirtualArray\n\nimport awkward.generate\ndef fromiter(iterable, awkwardlib=None, **options):\n    if awkwardlib is None:\n        awkwardlib = ""awkward.numba""\n    return awkward.generate.fromiter(iterable, awkwardlib=awkwardlib, **options)\n\n# convenient access to the version number\nfrom awkward.version import __version__\n\n__all__ = [""numpy"", ""AwkwardArray"", ""ChunkedArray"", ""AppendableArray"", ""IndexedArray"", ""SparseArray"", ""JaggedArray"", ""MaskedArray"", ""BitMaskedArray"", ""IndexedMaskedArray"", ""Methods"", ""ObjectArray"", ""Table"", ""UnionArray"", ""VirtualArray"", ""StringArray"", ""fromiter"", ""__version__""]\n'"
awkward-cpp/awkward/cpp/array/__init__.py,0,b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n'
awkward-cpp/awkward/cpp/array/base.py,0,b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nclass CppMethods(object):\n    @property\n    def awkward(self):\n        import awkward.cpp\n        return awkward.cpp\n\n    @property\n    def JaggedArray(self):\n        import awkward.cpp.array.jagged\n        return awkward.cpp.array.jagged.JaggedArrayCpp\n'
awkward-cpp/awkward/cpp/array/jagged.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\n######################################################################## Numba-accelerated interface\n\nimport awkward.array.base\nimport awkward.array.jagged\nfrom .base import CppMethods\nfrom .array_impl import JaggedArray\n\nclass JaggedArrayCpp(CppMethods, JaggedArray, awkward.array.jagged.JaggedArray):\n    pass\n'"
awkward-numba/awkward/numba/array/__init__.py,0,b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n'
awkward-numba/awkward/numba/array/base.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport operator\n\nimport numpy\nimport numba\n\nclass NumbaMethods(object):\n    NUMBA_DEFAULTTYPE = numba.from_dtype(numpy.float64)\n    NUMBA_CHARTYPE    = numba.from_dtype(numpy.uint8)\n    NUMBA_INDEXTYPE   = numba.from_dtype(numpy.int64)\n    NUMBA_TAGTYPE     = numba.from_dtype(numpy.uint8)\n    NUMBA_MASKTYPE    = numba.from_dtype(numpy.bool_)\n    NUMBA_BITMASKTYPE = numba.from_dtype(numpy.uint8)\n    NUMBA_BOOLTYPE    = numba.from_dtype(numpy.bool_)\n\n    @property\n    def awkward(self):\n        import awkward.numba\n        return awkward.numba\n\n    @property\n    def ChunkedArray(self):\n        import awkward.numba.array.chunked\n        return awkward.numba.array.chunked.ChunkedArrayNumba\n\n    @property\n    def AppendableArray(self):\n        import awkward.numba.array.chunked\n        return awkward.numba.array.chunked.AppendableArrayNumba\n\n    @property\n    def IndexedArray(self):\n        import awkward.numba.array.indexed\n        return awkward.numba.array.indexed.IndexedArrayNumba\n\n    @property\n    def SparseArray(self):\n        import awkward.numba.array.indexed\n        return awkward.numba.array.indexed.SparseArrayNumba\n\n    @property\n    def JaggedArray(self):\n        import awkward.numba.array.jagged\n        return awkward.numba.array.jagged.JaggedArrayNumba\n\n    @property\n    def MaskedArray(self):\n        import awkward.numba.array.masked\n        return awkward.numba.array.masked.MaskedArrayNumba\n\n    @property\n    def BitMaskedArray(self):\n        import awkward.numba.array.masked\n        return awkward.numba.array.masked.BitMaskedArrayNumba\n\n    @property\n    def IndexedMaskedArray(self):\n        import awkward.numba.array.masked\n        return awkward.numba.array.masked.IndexedMaskedArrayNumba\n\n    @property\n    def Methods(self):\n        import awkward.numba.array.objects\n        return awkward.numba.array.objects.MethodsNumba\n\n    @property\n    def ObjectArray(self):\n        import awkward.numba.array.objects\n        return awkward.numba.array.objects.ObjectArrayNumba\n\n    @property\n    def StringArray(self):\n        import awkward.numba.array.objects\n        return awkward.numba.array.objects.StringArrayNumba\n\n    @property\n    def Table(self):\n        import awkward.numba.array.table\n        return awkward.numba.array.table.TableNumba\n\n    @property\n    def UnionArray(self):\n        import awkward.numba.array.union\n        return awkward.numba.array.union.UnionArrayNumba\n\n    @property\n    def VirtualArray(self):\n        import awkward.numba.array.virtual\n        return awkward.numba.array.virtual.VirtualArrayNumba\n\nclass AwkwardArrayType(numba.types.Type):\n    pass\n\n######################################################################## getitem\n\n@numba.typing.templates.infer_global(len)\nclass _AwkwardArrayType_type_len(numba.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if len(args) == 1 and len(kwargs) == 0:\n            arraytype, = args\n            if isinstance(arraytype, AwkwardArrayType):\n                return numba.typing.templates.signature(numba.types.intp, arraytype)\n\n@numba.typing.templates.infer_global(operator.getitem)\nclass _AwkwardArrayType_type_getitem(numba.typing.templates.AbstractTemplate):\n    def generic(self, args, kwargs):\n        if len(args) == 2 and len(kwargs) == 0:\n            arraytype, wheretype = args\n            if isinstance(arraytype, AwkwardArrayType):\n                original_wheretype = wheretype\n                if not isinstance(wheretype, numba.types.BaseTuple):\n                    wheretype = numba.types.Tuple((wheretype,))\n                if len(wheretype.types) == 0:\n                    return arraytype\n\n                if any(isinstance(x, numba.types.Array) and x.ndim == 1 for x in wheretype.types):\n                    wheretype = numba.types.Tuple(tuple(numba.types.Array(x, 1, ""C"") if isinstance(x, numba.types.Integer) else x for x in wheretype))\n\n                return numba.typing.templates.signature(arraytype.getitem(wheretype), arraytype, original_wheretype)\n\n######################################################################## iteration\n\n@numba.typing.templates.infer\nclass _AwkwardArrayType_type_getiter(numba.typing.templates.AbstractTemplate):\n    key = ""getiter""\n    def generic(self, args, kwargs):\n        if len(args) == 1 and len(kwargs) == 0:\n            arraytype, = args\n            if isinstance(arraytype, AwkwardArrayType):\n                return numba.typing.templates.signature(AwkwardArrayIteratorType(arraytype), arraytype)\n\nclass AwkwardArrayIteratorType(numba.types.common.SimpleIteratorType):\n    def __init__(self, arraytype):\n        self.arraytype = arraytype\n        super(AwkwardArrayIteratorType, self).__init__(""iter({0})"".format(self.arraytype.name), self.arraytype.contenttype)\n\n@numba.datamodel.registry.register_default(AwkwardArrayIteratorType)\nclass AwkwardArrayIteratorModel(numba.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [(""index"", numba.types.EphemeralPointer(numba.types.int64)),\n                   (""array"", fe_type.arraytype)]\n        super(AwkwardArrayIteratorModel, self).__init__(dmm, fe_type, members)\n\n@numba.extending.lower_builtin(""getiter"", AwkwardArrayType)\ndef _AwkwardArray_lower_getiter(context, builder, sig, args):\n    arraytype, = sig.args\n    arrayval, = args\n\n    iterator = context.make_helper(builder, sig.return_type)\n    iterator.index = numba.cgutils.alloca_once_value(builder, context.get_constant(numba.types.int64, 0))\n    iterator.array = arrayval\n\n    if context.enable_nrt:\n        context.nrt.incref(builder, arraytype, arrayval)\n\n    return numba.targets.imputils.impl_ret_new_ref(context, builder, sig.return_type, iterator._getvalue())\n\n@numba.extending.lower_builtin(""iternext"", AwkwardArrayIteratorType)\n@numba.targets.imputils.iternext_impl\ndef _AwkwardArray_lower_iternext(context, builder, sig, args, result):\n    iteratortype, = sig.args\n    iteratorval, = args\n\n    iterator = context.make_helper(builder, iteratortype, value=iteratorval)\n    array = numba.cgutils.create_struct_proxy(iteratortype.arraytype)(context, builder, value=iterator.array)\n\n    index = builder.load(iterator.index)\n    is_valid = builder.icmp_signed(""<"", index, iteratortype.arraytype.len_impl(context, builder, numba.types.intp(iteratortype.arraytype), (iterator.array,)))\n    result.set_valid(is_valid)\n\n    with builder.if_then(is_valid, likely=True):\n        result.yield_(iteratortype.arraytype.getitem_impl(context, builder, iteratortype.yield_type(iteratortype.arraytype, numba.types.int64), (iterator.array, index)))\n        nextindex = numba.cgutils.increment_index(builder, index)\n        builder.store(nextindex, iterator.index)\n\n######################################################################## utilities\n\ndef clsrepr(cls):\n    import awkward.array\n    if any(cls is x for x in (awkward.array.base.AwkwardArray,\n                              awkward.array.chunked.ChunkedArray,\n                              awkward.array.chunked.AppendableArray,\n                              awkward.array.indexed.IndexedArray,\n                              awkward.array.indexed.SparseArray,\n                              awkward.array.jagged.JaggedArray,\n                              awkward.array.masked.MaskedArray,\n                              awkward.array.masked.BitMaskedArray,\n                              awkward.array.masked.IndexedMaskedArray,\n                              awkward.array.objects.Methods,\n                              awkward.array.objects.ObjectArray,\n                              awkward.array.objects.StringArray,\n                              awkward.array.table.Table,\n                              awkward.array.union.UnionArray,\n                              awkward.array.virtual.VirtualArray)):\n        return cls.__name__\n    else:\n        bases = "", "".join(clsrepr(x) for x in cls.__bases__ if x is not object)\n        if len(bases) != 0:\n            bases = ""<"" + bases + "">""\n        return ""{0}.{1}{2}"".format(cls.__module__, cls.__name__, bases)\n\ndef sliceval2(context, builder, start, stop):\n    out = context.make_helper(builder, numba.types.slice2_type)\n    out.start = start\n    out.stop = stop\n    out.step = context.get_constant(numba.types.intp, 1)\n    return out._getvalue()\n\ndef sliceval3(context, builder, start, stop, step):\n    out = context.make_helper(builder, numba.types.slice3_type)\n    out.start = start\n    out.stop = stop\n    out.step = step\n    return out._getvalue()\n\nISADVANCED = numba.types.Array(numba.types.int64, 1, ""C"")\nNOTADVANCED = numba.types.none\n'"
awkward-numba/awkward/numba/array/chunked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.chunked\nfrom .base import NumbaMethods\n\nclass ChunkedArrayNumba(NumbaMethods, awkward.array.chunked.ChunkedArray):\n    pass\n\nclass AppendableArrayNumba(NumbaMethods, awkward.array.chunked.AppendableArray):\n    pass\n'"
awkward-numba/awkward/numba/array/indexed.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.indexed\nfrom .base import NumbaMethods\n\nclass IndexedArrayNumba(NumbaMethods, awkward.array.indexed.IndexedArray):\n    pass\n\nclass SparseArrayNumba(NumbaMethods, awkward.array.indexed.SparseArray):\n    pass\n'"
awkward-numba/awkward/numba/array/jagged.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport operator\nimport math\ntry:\n    from collections.abc import Iterable\nexcept ImportError:\n    from collections import Iterable\n\nimport numpy\nimport numba\nimport numba.typing.arraydecl\n\nimport awkward.array.base\nimport awkward.array.jagged\nfrom .base import NumbaMethods\nfrom .base import AwkwardArrayType\nfrom .base import clsrepr\nfrom .base import ISADVANCED\nfrom .base import NOTADVANCED\nfrom .base import sliceval2\nfrom .base import sliceval3\n\n######################################################################## Numba-accelerated interface\n\nclass JaggedArrayNumba(NumbaMethods, awkward.array.jagged.JaggedArray):\n    # @classmethod\n    # def offsetsaliased(cls, starts, stops):\n    ### base implementation is fine and don\'t need in Numba\n\n    @classmethod\n    def counts2offsets(cls, counts):\n        return cls._counts2offsets(counts)\n\n    @staticmethod\n    @numba.njit\n    def _counts2offsets(counts):\n        offsets = numpy.empty(len(counts) + 1, dtype=numpy.int64)\n        offsets[0] = 0\n        for i in range(len(counts)):\n            offsets[i + 1] = offsets[i] + counts[i]\n        return offsets\n\n    @classmethod\n    def offsets2parents(cls, offsets):\n        return cls._offsets2parents(offsets)\n\n    @staticmethod\n    @numba.njit\n    def _offsets2parents(offsets):\n        if len(offsets) == 0:\n            raise ValueError(""offsets must have at least one element"")\n        parents = numpy.empty(offsets[-1], dtype=numpy.int64)\n        j = 0\n        k = -1\n        for i in offsets:\n            while j < i:\n                parents[j] = k\n                j += 1\n            k += 1\n        return parents\n\n    @classmethod\n    def startsstops2parents(cls, starts, stops):\n        return cls._startsstops2parents(starts, stops)\n\n    @staticmethod\n    @numba.njit\n    def _startsstops2parents(starts, stops):\n        out = numpy.full(stops.max(), -1, numpy.int64)\n        for i in range(len(starts)):\n            out[starts[i]:stops[i]] = i\n        return out\n\n    @classmethod\n    def parents2startsstops(cls, parents, length=None):\n        if length is None:\n            length = parents.max() + 1\n        return cls._parents2startsstops(parents, length)\n\n    @staticmethod\n    @numba.njit\n    def _parents2startsstops(parents, length):\n        starts = numpy.zeros(length, numpy.int64)\n        stops = numpy.zeros(length, numpy.int64)\n\n        last = -1\n        for k in range(len(parents)):\n            this = parents[k]\n            if last != this:\n                if last >= 0 and last < length:\n                    stops[last] = k\n                if this >= 0 and this < length:\n                    starts[this] = k\n            last = this\n\n        if last != -1:\n            stops[last] = len(parents)\n\n        return starts, stops\n\n    # @classmethod\n    # def uniques2offsetsparents(cls, uniques):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def __init__(self, starts, stops, content):\n    ### base implementation is fine and already exposed in Numba\n\n    @classmethod\n    def fromiter(cls, iterable):\n        import awkward.numba\n        return awkward.numba.fromiter(iterable)\n\n    # @classmethod\n    # def fromoffsets(cls, offsets, content):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromcounts(cls, counts, content):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromparents(cls, parents, content, length=None):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromuniques(cls, uniques, content):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromindex(cls, index, content, validate=True):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromjagged(cls, jagged):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromregular(cls, regular):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @classmethod\n    # def fromfolding(cls, content, size):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def copy(self, starts=None, stops=None, content=None):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def deepcopy(self, starts=None, stops=None, content=None):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def empty_like(self, **overrides):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def zeros_like(self, **overrides):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def ones_like(self, **overrides):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def __awkward_persist__(self, ident, fill, prefix, suffix, schemasuffix, storage, compression, **kwargs):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def starts(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @starts.setter\n    # def starts(self, value):\n    ### base implementation is fine and don\'t need in Numba\n        \n    # @property\n    # def stops(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @stops.setter\n    # def stops(self, value):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def content(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @content.setter\n    # def content(self, value):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def offsets(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @offsets.setter\n    # def offsets(self, value):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def counts(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @counts.setter\n    # def counts(self, value):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def parents(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # @parents.setter\n    # def parents(self, value):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def index(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # def __len__(self):\n    ### base implementation is fine and already exposed in Numba\n\n    # def _gettype(self, seen):\n    ### base implementation is fine and don\'t need in Numba\n\n    def _valid(self):\n        pass             # do validation in place from now on\n\n    # @staticmethod\n    # def _validstartsstops(starts, stops):\n    ### base implementation is fine and don\'t need in Numba\n\n    # def __iter__(self, checkiter=True):\n    ### base implementation is fine and already exposed in Numba\n\n    def __getitem__(self, where):\n        if not isinstance(where, tuple):\n            where = (where,)\n        if len(where) == 0:\n            return self\n\n        newwhere = ()\n        for x in where:\n            if isinstance(x, Iterable) and not isinstance(x, (numpy.ndarray, awkward.array.base.AwkwardArray)):\n                newwhere = newwhere + (numpy.array(x),)\n            else:\n                newwhere = newwhere + (x,)\n\n        if len(newwhere) == 1:\n            newwhere = newwhere[0]\n            \n        return self._getitem_impl(newwhere)\n\n    @numba.njit\n    def _getitem_impl(self, newwhere):\n        return self[newwhere]\n\n    # def __setitem__(self, where, what):\n\n    @numba.generated_jit(nopython=True)\n    def tojagged(self, data):\n        assert not isinstance(data, JaggedArrayType)\n\n        if isinstance(data, AwkwardArrayType):\n            def impl(self, data):\n                if len(self.starts) != len(data):\n                    raise ValueError(""cannot broadcast AwkwardArray to match JaggedArray with a different length"")\n                if len(self.starts.shape) != 1:\n                    raise ValueError(""cannot broadcast AwkwardArray to match JaggedArray that has len(starts.shape) != 1; call jagged.structure1d() first"")\n                index = numpy.empty(len(self.content), numpy.int64)\n                for i in range(len(self.starts)):\n                    index[self.starts[i]:self.stops[i]] = i\n                return _JaggedArray_new(self, self.starts, self.stops, data[index], self.iscompact)\n            return impl\n\n        elif isinstance(data, numba.types.Array):\n            def impl(self, data):\n                if self.starts.shape != data.shape:\n                    raise ValueError(""cannot broadcast Numpy array to match a JaggedArray with a different length (or more generally, starts.shape)"")\n                content = numpy.empty(len(self.content), data.dtype)\n                flatstarts = self.starts.reshape(-1)\n                flatstops = self.stops.reshape(-1)\n                flatdata = data.reshape(-1)\n                for i in range(len(flatstarts)):\n                    content[flatstarts[i]:flatstops[i]] = flatdata[i]\n                return _JaggedArray_new(self, self.starts, self.stops, content, self.iscompact)\n            return impl\n\n        else:\n            def impl(self, data):\n                content = numpy.full(len(self.content), data)\n                return _JaggedArray_new(self, self.starts, self.stops, content, self.iscompact)\n            return impl\n\n    # def _tojagged(self, starts=None, stops=None, copy=True):\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        if ""out"" in kwargs:\n            raise NotImplementedError(""in-place operations not supported"")\n        if method != ""__call__"":\n            return NotImplemented\n\n        first = None\n        inputs = list(inputs)\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], awkward.array.jagged.JaggedArray):\n                inputs[i] = inputs[i].compact()\n                shift = inputs[i].starts[0]\n                if shift != 0:\n                    inputs[i] = inputs[i].copy(inputs[i].starts - shift, inputs[i].stops - shift, inputs[i].content[shift:])\n                if first is None:\n                    first = inputs[i]\n                elif first.starts[0] != inputs[i].starts[0] or not numpy.array_equal(first.stops, inputs[i].stops):\n                    raise ValueError(""JaggedArrays in Numpy ufunc have incompatible structure"")\n\n        assert first is not None\n\n        for i in range(len(inputs)):\n            if isinstance(inputs[i], awkward.array.jagged.JaggedArray):\n                pass\n            elif isinstance(inputs[i], awkward.array.base.AwkwardArray):\n                inputs[i] = first.tojagged(inputs[i])\n            elif isinstance(inputs[i], Iterable):\n                inputs[i] = first.tojagged(numpy.array(inputs[i], copy=False))\n            else:\n                inputs[i] = first.tojagged(inputs[i])\n\n        for i in range(len(inputs)):\n            inputs[i] = inputs[i]._content\n\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        if isinstance(result, tuple):\n            return tuple(self.Methods.maybemixin(type(x), self.JaggedArray)(first.starts, first.stops, x) if isinstance(x, (numpy.ndarray, awkward.array.base.AwkwardArray)) else x for x in result)\n        else:\n            return self.Methods.maybemixin(type(result), self.JaggedArray)(first.starts, first.stops, result)\n\n    @numba.njit\n    def regular(self):\n        return self.regular()\n\n    ### FIXME: this whole section can\'t be done until we have Tables\n\n    # def _argpairs(self):\n\n    # def _argdistincts(self, absolute):\n\n    # def argdistincts(self, nested=False):\n\n    # def distincts(self, nested=False):\n\n    # def argpairs(self, nested=False):\n\n    # def pairs(self, nested=False):\n\n    # def _argcross(self, other):\n\n    # def argcross(self, other, nested=False):\n\n    # def cross(self, other, nested=False):\n\n    # def _canuseoffset(self):\n    ### base implementation is fine and don\'t need in Numba\n\n    # @property\n    # def iscompact(self):\n    ### base implementation is fine and already exposed in Numba\n\n    @numba.njit\n    def compact(self):\n        return self.compact()\n\n    def flatten(self, axis=0):\n        if not self._util_isinteger(axis) or axis < 0:\n            raise TypeError(""axis must be a non-negative integer (can\'t count from the end)"")\n        if axis > 0:\n            if isinstance(self._content, JaggedArray):\n                counts = self.JaggedArray.fromcounts(self.counts, self._content.counts).sum()\n                return self.JaggedArray.fromcounts(counts, self._content.flatten(axis=axis - 1))\n\n        if len(self) == 0:\n            return self._content[0:0]\n        elif self.iscompact:\n            return self._content[self._starts[0]:self.stops[-1]]  # no underscore in stops\n        else:\n            out = self.compact()\n            return out._content[out._starts[0]:out.stops[0]]      # no underscore in stops\n\n    # def structure1d(self, levellimit=None):\n    ### base implementation is fine and can\'t(?) be exposed in Numba (type manipulation is hard!)\n\n    # def _hasjagged(self):\n    ### base implementation is fine\n\n    # def _reduce(self, ufunc, identity, dtype):\n\n    @numba.njit\n    def argmin(self):\n        return self.argmin()\n\n    @numba.njit\n    def argmax(self):\n        return self.argmax()\n\n    def _argminmax(self, ismin):\n        raise RuntimeError(""helper function not needed in JaggedArrayNumba"")\n\n    def _argminmax_general(self, ismin):\n        raise RuntimeError(""helper function not needed in JaggedArrayNumba"")\n\n    # def _concatenate_axis0(isclassmethod, cls_or_self, arrays):\n    #     if isinstance(arrays, (numpy.ndarray, awkward.array.base.AwkwardArray)):\n    #         arrays = (arrays,)\n    #     else:\n    #         arrays = tuple(arrays)\n    #     if isclassmethod:\n    #         cls = cls_or_self\n    #         if not all(isinstance(x, awkward.array.jagged.JaggedArray) for x in arrays):\n    #             raise TypeError(""cannot concatenate non-JaggedArrays with JaggedArray.concatenate"")\n    #     else:\n    #         self = cls_or_self\n    #         cls = self.__class__\n    #         if not isinstance(self, awkward.array.jagged.JaggedArray) or not all(isinstance(x, awkward.array.jagged.JaggedArray) for x in arrays):\n    #             raise TypeError(""cannot concatenate non-JaggedArrays with JaggedArray.concatenate"")\n    #         arrays = (self,) + arrays\n    #     if len(arrays) == 0:\n    #         raise TypeError(""concatenate requires at least one array"")\n    #     return _JaggedArray_concatenate_njit(arrays, axis)\n    ### FIXME: left unfinished\n\n    # @awkward.util.bothmethod\n    # def zip(isclassmethod, cls_or_self, columns1={}, *columns2, **columns3):\n    ### FIXME: can\'t do this one until we have Tables\n\n    # def pad(self, length, maskedwhen=True, clip=False):\n\n######################################################################## register types in Numba\n\n@numba.extending.typeof_impl.register(awkward.array.jagged.JaggedArray)\ndef _JaggedArray_typeof(val, c):\n    return JaggedArrayType(numba.typeof(val.starts), numba.typeof(val.stops), numba.typeof(val.content), special=type(val))\n\nclass JaggedArrayType(AwkwardArrayType):\n    def __init__(self, startstype, stopstype, contenttype, special=awkward.array.jagged.JaggedArray):\n        super(JaggedArrayType, self).__init__(name=""JaggedArrayType({0}, {1}, {2}{3})"".format(startstype.name, stopstype.name, contenttype.name, """" if special is awkward.array.jagged.JaggedArray else clsrepr(special)))\n        if startstype.ndim != stopstype.ndim:\n            raise ValueError(""JaggedArray.starts must have the same number of dimensions as JaggedArray.stops"")\n        if startstype.ndim == 0:\n            raise ValueError(""JaggedArray.starts and JaggedArray.stops must have at least one dimension"")\n        self.startstype = startstype\n        self.stopstype = stopstype\n        self.contenttype = contenttype\n        self.special = special\n\n    def getitem(self, wheretype):\n        if self.startstype.ndim > 1 and not any(isinstance(x, (numba.types.Array, JaggedArrayType)) for x in wheretype.types[:self.startstype.ndim]):\n            headtype = numba.types.Tuple(wheretype.types[:self.startstype.ndim])\n            tailtype = numba.types.Tuple(wheretype.types[self.startstype.ndim:])\n\n            outstartstype = numba.typing.arraydecl.get_array_index_type(self.startstype, headtype).result\n            outstopstype = numba.typing.arraydecl.get_array_index_type(self.stopstype, headtype).result\n            if isinstance(self.contenttype, JaggedArrayType):\n                outcontenttype = self.contenttype.getitem(tailtype)\n            else:\n                outcontenttype = numba.typing.arraydecl.get_array_index_type(self.contenttype, tailtype).result\n\n            assert isinstance(outstartstype, numba.types.Array) == isinstance(outstopstype, numba.types.Array)\n            if isinstance(outstartstype, numba.types.Array):\n                return JaggedArrayType(outstartstype, outstopstype, outcontenttype, special=self.special)\n            else:\n                return outcontenttype\n\n        else:\n            headtype = wheretype.types[0]\n            tailtype = numba.types.Tuple(wheretype.types[1:])\n\n            if isinstance(headtype, JaggedArrayType) and len(tailtype.types) == 0:\n                return _JaggedArray_typer_getitem_jagged(self, headtype)\n\n            else:\n                fake = _JaggedArray_typer_getitem(JaggedArrayType(JaggedArrayNumba.NUMBA_INDEXTYPE[:], JaggedArrayNumba.NUMBA_INDEXTYPE[:], self), wheretype, NOTADVANCED)\n                if isinstance(fake, numba.types.Array):\n                    return fake.dtype\n                else:\n                    return fake.contenttype\n\n    @property\n    def len_impl(self):\n        return _JaggedArray_lower_len\n\n    @property\n    def getitem_impl(self):\n        return lambda context, builder, sig, args: _JaggedArray_lower_getitem_integer(context, builder, sig, args, checkvalid=False)\n\ndef _JaggedArray_typer_getitem_jagged(arraytype, headtype):\n    if isinstance(headtype.contenttype, JaggedArrayType):\n        if not isinstance(arraytype.contenttype, JaggedArrayType):\n            raise TypeError(""index (in square brackets) is more deeply jagged than array (before square brackets)"")\n        contenttype = _JaggedArray_typer_getitem_jagged(arraytype.contenttype, headtype.contenttype)\n    elif isinstance(headtype.contenttype, numba.types.Array) and headtype.contenttype.ndim == 1 and isinstance(headtype.contenttype.dtype, (numba.types.Boolean, numba.types.Integer)):\n        contenttype = arraytype.contenttype\n    else:\n        raise TypeError(""jagged indexing must be boolean or integers with 1-dimensional content"")\n\n    return JaggedArrayType(arraytype.startstype, arraytype.stopstype, contenttype, special=arraytype.special)\n\ndef _JaggedArray_typer_getitem(arraytype, wheretype, advancedtype):\n    if len(wheretype.types) == 0:\n        return arraytype\n\n    if arraytype.startstype.ndim != 1 or arraytype.stopstype.ndim != 1:\n        raise NotImplementedError(""multidimensional starts and stops not supported; call jagged.structure1d() first"")\n\n    isarray = (isinstance(wheretype.types[0], numba.types.Array) and wheretype.types[0].ndim == 1)\n\n    contenttype = _JaggedArray_typer_getitem(arraytype.contenttype, numba.types.Tuple(wheretype.types[1:]), ISADVANCED if isarray else advancedtype)\n\n    if isinstance(wheretype.types[0], numba.types.Integer) or (isarray and advancedtype == ISADVANCED):\n        return contenttype\n    elif isinstance(wheretype.types[0], numba.types.SliceType) or (isarray and advancedtype == NOTADVANCED):\n        return JaggedArrayType(arraytype.startstype, arraytype.stopstype, contenttype, special=arraytype.special)\n    elif isinstance(wheretype.types[0], JaggedArrayType):\n        raise TypeError(""cannot use jagged indexing in a tuple"")\n    else:\n        raise TypeError(""cannot be used for indexing: {0}"".format(wheretype.types[0]))\n\ndef _JaggedArray_getitem_next(array, where):\n    pass\n\n@numba.extending.type_callable(_JaggedArray_getitem_next)\ndef _JaggedArray_type_getitem_next(context):\n    return _JaggedArray_typer_getitem\n\n######################################################################## model and boxing\n\n@numba.extending.register_model(JaggedArrayType)\nclass JaggedArrayModel(numba.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [(""starts"", fe_type.startstype),\n                   (""stops"", fe_type.stopstype),\n                   (""content"", fe_type.contenttype),\n                   (""iscompact"", JaggedArrayNumba.NUMBA_BOOLTYPE)]\n        super(JaggedArrayModel, self).__init__(dmm, fe_type, members)\n\nnumba.extending.make_attribute_wrapper(JaggedArrayType, ""starts"", ""starts"")\nnumba.extending.make_attribute_wrapper(JaggedArrayType, ""stops"", ""stops"")\nnumba.extending.make_attribute_wrapper(JaggedArrayType, ""content"", ""content"")\nnumba.extending.make_attribute_wrapper(JaggedArrayType, ""iscompact"", ""iscompact"")\n\n@numba.extending.unbox(JaggedArrayType)\ndef _JaggedArray_unbox(typ, obj, c):\n    starts_obj = c.pyapi.object_getattr_string(obj, ""starts"")\n    stops_obj = c.pyapi.object_getattr_string(obj, ""stops"")\n    content_obj = c.pyapi.object_getattr_string(obj, ""content"")\n    iscompact_obj = c.pyapi.object_getattr_string(obj, ""iscompact"")\n\n    array = numba.cgutils.create_struct_proxy(typ)(c.context, c.builder)\n    array.starts = c.pyapi.to_native_value(typ.startstype, starts_obj).value\n    array.stops = c.pyapi.to_native_value(typ.stopstype, stops_obj).value\n    array.content = c.pyapi.to_native_value(typ.contenttype, content_obj).value\n    array.iscompact = c.pyapi.to_native_value(JaggedArrayNumba.NUMBA_BOOLTYPE, iscompact_obj).value\n\n    c.pyapi.decref(starts_obj)\n    c.pyapi.decref(stops_obj)\n    c.pyapi.decref(content_obj)\n    c.pyapi.decref(iscompact_obj)\n\n    is_error = numba.cgutils.is_not_null(c.builder, c.pyapi.err_occurred())\n    return numba.extending.NativeValue(array._getvalue(), is_error)\n\n@numba.extending.box(JaggedArrayType)\ndef _JaggedArray_box(typ, val, c):\n    array = numba.cgutils.create_struct_proxy(typ)(c.context, c.builder, value=val)\n    starts_obj = c.pyapi.from_native_value(typ.startstype, array.starts, c.env_manager)\n    stops_obj = c.pyapi.from_native_value(typ.stopstype, array.stops, c.env_manager)\n    content_obj = c.pyapi.from_native_value(typ.contenttype, array.content, c.env_manager)\n\n    cls = c.pyapi.unserialize(c.pyapi.serialize_object(typ.special))\n    out = c.pyapi.call_function_objargs(cls, (starts_obj, stops_obj, content_obj))\n\n    c.pyapi.decref(starts_obj)\n    c.pyapi.decref(stops_obj)\n    c.pyapi.decref(content_obj)\n\n    return out\n\n@numba.extending.type_callable(awkward.array.jagged.JaggedArray)\ndef _JaggedArray_type_init(context):\n    def typer(startstype, stopstype, contenttype):\n        if isinstance(startstype, numba.types.Array) and isinstance(stopstype, numba.types.Array) and isinstance(contenttype, (numba.types.Array, AwkwardArrayType)):\n            return JaggedArrayType(startstype, stopstype, contenttype, special=awkward.array.jagged.JaggedArray)\n    return typer\n\n@numba.extending.type_callable(JaggedArrayNumba)\ndef _JaggedArray_type_init(context):\n    def typer(startstype, stopstype, contenttype):\n        if isinstance(startstype, numba.types.Array) and isinstance(stopstype, numba.types.Array) and isinstance(contenttype, (numba.types.Array, AwkwardArrayType)):\n            return JaggedArrayType(startstype, stopstype, contenttype, special=JaggedArrayNumba)\n    return typer\n\n@numba.extending.lower_builtin(awkward.array.jagged.JaggedArray, numba.types.Array, numba.types.Array, numba.types.Array)\n@numba.extending.lower_builtin(awkward.array.jagged.JaggedArray, numba.types.Array, numba.types.Array, AwkwardArrayType)\n@numba.extending.lower_builtin(JaggedArrayNumba, numba.types.Array, numba.types.Array, numba.types.Array)\n@numba.extending.lower_builtin(JaggedArrayNumba, numba.types.Array, numba.types.Array, AwkwardArrayType)\ndef _JaggedArray_init_array(context, builder, sig, args):\n    startstype, stopstype, contenttype = sig.args\n    startsval, stopsval, contentval = args\n\n    if context.enable_nrt:\n        context.nrt.incref(builder, startstype, startsval)\n        context.nrt.incref(builder, stopstype, stopsval)\n        context.nrt.incref(builder, contenttype, contentval)\n\n    array = numba.cgutils.create_struct_proxy(sig.return_type)(context, builder)\n    array.starts = startsval\n    array.stops = stopsval\n    array.content = contentval\n    array.iscompact = context.get_constant(JaggedArrayNumba.NUMBA_BOOLTYPE, False)   # unless you reproduce that logic here or call out to Python\n    return array._getvalue()\n\ndef _JaggedArray_new(array, starts, stops, content, iscompact):\n    pass\n\n@numba.extending.type_callable(_JaggedArray_new)\ndef _JaggedArray_type_new(context):\n    def typer(arraytype, startstype, stopstype, contenttype, iscompacttype):\n        return JaggedArrayType(startstype, stopstype, contenttype, special=arraytype.special)\n    return typer\n\n@numba.extending.lower_builtin(_JaggedArray_new, JaggedArrayType, numba.types.Array, numba.types.Array, numba.types.Array, numba.types.Boolean)\n@numba.extending.lower_builtin(_JaggedArray_new, JaggedArrayType, numba.types.Array, numba.types.Array, AwkwardArrayType, numba.types.Boolean)\ndef _JaggedArray_lower_new(context, builder, sig, args):\n    arraytype, startstype, stopstype, contenttype, iscompacttype = sig.args\n    arrayval, startsval, stopsval, contentval, iscompactval = args\n\n    if context.enable_nrt:\n        context.nrt.incref(builder, startstype, startsval)\n        context.nrt.incref(builder, stopstype, stopsval)\n        context.nrt.incref(builder, contenttype, contentval)\n\n    array = numba.cgutils.create_struct_proxy(sig.return_type)(context, builder)\n    array.starts = startsval\n    array.stops = stopsval\n    array.content = contentval\n    array.iscompact = iscompactval\n    return array._getvalue()\n\n######################################################################## utilities\n\ndef _check_startstop_contentlen(context, builder, starttype, startval, stoptype, stopval, contenttype, contentval):\n    if isinstance(contenttype, numba.types.Array):\n        contentlen = numba.targets.arrayobj.array_len(context, builder, numba.types.intp(contenttype), (contentval,))\n    else:\n        contentlen = _JaggedArray_lower_len(context, builder, numba.types.intp(contenttype), (contentval,))\n\n    with builder.if_then(builder.or_(builder.or_(builder.icmp_signed(""<"", startval, context.get_constant(starttype, 0)),\n                                                 builder.icmp_signed(""<"", stopval, context.get_constant(stoptype, 0))),\n                                     builder.or_(builder.icmp_signed("">="", startval, contentlen),\n                                                 builder.icmp_signed("">"", stopval, contentlen))),\n                         likely=False):\n        context.call_conv.return_user_exc(builder, ValueError, (""JaggedArray.starts or JaggedArray.stops is beyond the range of JaggedArray.content"",))\n\n######################################################################## lowered len\n\n@numba.extending.lower_builtin(len, JaggedArrayType)\ndef _JaggedArray_lower_len(context, builder, sig, args):\n    arraytype, = sig.args\n    arrayval, = args\n\n    array = numba.cgutils.create_struct_proxy(arraytype)(context, builder, value=arrayval)\n\n    return numba.targets.arrayobj.array_len(context, builder, numba.types.intp(arraytype.startstype), (array.starts,))\n\n######################################################################## lowered getitem\n\n@numba.extending.lower_builtin(operator.getitem, JaggedArrayType, numba.types.Integer)\ndef _JaggedArray_lower_getitem_integer(context, builder, sig, args, checkvalid=True):\n    arraytype, wheretype = sig.args\n    arrayval, whereval = args\n\n    array = numba.cgutils.create_struct_proxy(arraytype)(context, builder, value=arrayval)\n\n    startstype = arraytype.startstype\n    stopstype = arraytype.stopstype\n    contenttype = arraytype.contenttype\n\n    if startstype.ndim == 1:\n        start = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, startstype.dtype(startstype, wheretype), (array.starts, whereval))\n        stop = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, stopstype.dtype(stopstype, wheretype), (array.stops, whereval))\n\n        if checkvalid:\n            _check_startstop_contentlen(context, builder, startstype.dtype, start, stopstype.dtype, stop, contenttype, array.content)\n\n        if isinstance(contenttype, numba.types.Array):\n            return numba.targets.arrayobj.getitem_arraynd_intp(context, builder, contenttype(contenttype, numba.types.slice2_type), (array.content, sliceval2(context, builder, start, stop)))\n        else:\n            return _JaggedArray_lower_getitem_slice(context, builder, contenttype(contenttype, numba.types.slice2_type), (array.content, sliceval2(context, builder, start, stop)))\n\n    else:\n        outstartstype = numba.types.Array(startstype.dtype, startstype.ndim - 1, startstype.layout)\n        outstopstype = numba.types.Array(stopstype.dtype, stopstype.ndim - 1, stopstype.layout)\n\n        starts = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, outstartstype(startstype, wheretype), (array.starts, whereval))\n        stops = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, outstopstype(stopstype, wheretype), (array.stops, whereval))\n\n        outtype = JaggedArrayType(outstartstype, outstopstype, contenttype, special=arraytype.special)\n        return _JaggedArray_lower_new(context, builder, outtype(arraytype, outstartstype, outstopstype, contenttype, JaggedArrayNumba.NUMBA_BOOLTYPE), (arrayval, starts, stops, array.content, array.iscompact))\n\n@numba.extending.lower_builtin(operator.getitem, JaggedArrayType, numba.types.SliceType)\ndef _JaggedArray_lower_getitem_slice(context, builder, sig, args):\n    arraytype, wheretype = sig.args\n    arrayval, whereval = args\n\n    array = numba.cgutils.create_struct_proxy(arraytype)(context, builder, value=arrayval)\n\n    startstype = arraytype.startstype\n    starts = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, startstype(startstype, wheretype), (array.starts, whereval))\n\n    stopstype = arraytype.stopstype\n    stops = numba.targets.arrayobj.getitem_arraynd_intp(context, builder, stopstype(stopstype, wheretype), (array.stops, whereval))\n\n    slice = context.make_helper(builder, wheretype, value=whereval)\n    iscompact = builder.and_(array.iscompact,\n                             builder.or_(builder.icmp_signed(""=="", slice.step, context.get_constant(numba.types.intp, 1)),\n                                         builder.icmp_signed(""=="", slice.step, context.get_constant(numba.types.intp, numba.types.intp.maxval))))\n\n    contenttype = arraytype.contenttype\n    return _JaggedArray_lower_new(context, builder, arraytype(arraytype, startstype, stopstype, contenttype, JaggedArrayNumba.NUMBA_BOOLTYPE), (arrayval, starts, stops, array.content, iscompact))\n\n@numba.extending.lower_builtin(operator.getitem, JaggedArrayType, numba.types.Array)\ndef _JaggedArray_lower_getitem_array(context, builder, sig, args):\n    arraytype, wheretype = sig.args\n    arrayval, whereval = args\n\n    array = numba.cgutils.create_struct_proxy(arraytype)(context, builder, value=arrayval)\n\n    startstype = arraytype.startstype\n    starts = numba.targets.arrayobj.fancy_getitem_array(context, builder, startstype(startstype, wheretype), (array.starts, whereval))\n\n    stopstype = arraytype.stopstype\n    stops = numba.targets.arrayobj.fancy_getitem_array(context, builder, stopstype(stopstype, wheretype), (array.stops, whereval))\n\n    contenttype = arraytype.contenttype\n    return _JaggedArray_lower_new(context, builder, arraytype(arraytype, startstype, stopstype, contenttype, JaggedArrayNumba.NUMBA_BOOLTYPE), (arrayval, starts, stops, array.content, context.get_constant(JaggedArrayNumba.NUMBA_BOOLTYPE, False)))\n\n@numba.extending.lower_builtin(operator.getitem, JaggedArrayType, JaggedArrayType)\ndef _JaggedArray_lower_getitem_jaggedarray(context, builder, sig, args):\n    arraytype, wheretype = sig.args\n\n    if isinstance(wheretype, JaggedArrayType) and isinstance(wheretype.contenttype, JaggedArrayType):\n        def getitem(array, where):\n            return _JaggedArray_new(array, array.starts, array.stops, array.content[where.content], True)\n\n    elif isinstance(wheretype, JaggedArrayType) and isinstance(wheretype.contenttype.dtype, numba.types.Boolean) and isinstance(arraytype.contenttype, numba.types.Array):\n        def getitem(array, where):\n            if len(array) != len(where):\n                raise IndexError(""jagged index must have the same (outer) length as the JaggedArray it indexes"")\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            offsets[0] = 0\n            content = numpy.empty(where.content.astype(numpy.int64).sum(), array.content.dtype)\n            k = 0\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                wherei = where[i]\n                if len(wherei) > length:\n                    raise IndexError(""jagged index is out of bounds in JaggedArray"")\n\n                for j in range(len(wherei)):\n                    if wherei[j]:\n                        content[k] = array.content[array.starts[i] + j]\n                        k += 1\n                offsets[i + 1] = k\n\n            starts = offsets[:-1]\n            stops = offsets[1:]\n            return _JaggedArray_new(array, starts, stops, content, True)\n\n    elif isinstance(wheretype, JaggedArrayType) and isinstance(wheretype.contenttype.dtype, numba.types.Boolean):\n        def getitem(array, where):\n            if len(array) != len(where):\n                raise IndexError(""jagged index must have the same (outer) length as the JaggedArray it indexes"")\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            offsets[0] = 0\n            index = numpy.empty(len(where.content), numpy.int64)\n            k = 0\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                wherei = where[i]\n                if len(wherei) > length:\n                    raise IndexError(""jagged index is out of bounds in JaggedArray"")\n\n                for j in range(len(wherei)):\n                    if wherei[j]:\n                        index[k] = array.starts[i] + j\n                        k += 1\n                offsets[i + 1] = k\n\n            starts = offsets[:-1]\n            stops = offsets[1:]\n            return _JaggedArray_new(array, starts, stops, array.content[index[:k]], True)\n\n    elif isinstance(wheretype, JaggedArrayType) and isinstance(wheretype.contenttype.dtype, numba.types.Integer) and isinstance(arraytype.contenttype, numba.types.Array):\n        def getitem(array, where):\n            if len(array) != len(where):\n                raise IndexError(""jagged index must have the same (outer) length as the JaggedArray it indexes"")\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            offsets[0] = 0\n            content = numpy.empty(len(where.content), array.content.dtype)\n            k = 0\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                wherei = where[i]\n\n                for j in range(len(wherei)):\n                    norm = wherei[j]\n                    if norm < 0:\n                        norm += length\n                    if norm < 0 or norm >= length:\n                        raise IndexError(""jagged index is out of bounds in JaggedArray"")\n                    content[k] = array.content[array.starts[i] + norm]\n                    k += 1\n                offsets[i + 1] = k\n\n            starts = offsets[:-1]\n            stops = offsets[1:]\n            return _JaggedArray_new(array, starts, stops, content, True)\n\n    elif isinstance(wheretype, JaggedArrayType) and isinstance(wheretype.contenttype.dtype, numba.types.Integer):\n        def getitem(array, where):\n            if len(array) != len(where):\n                raise IndexError(""jagged index must have the same (outer) length as the JaggedArray it indexes"")\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            offsets[0] = 0\n            index = numpy.empty(len(where.content), numpy.int64)\n            k = 0\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                wherei = where[i]\n\n                for j in range(len(wherei)):\n                    norm = wherei[j]\n                    if norm < 0:\n                        norm += length\n                    if norm < 0 or norm >= length:\n                        raise IndexError(""jagged index is out of bounds in JaggedArray"")\n                    index[k] = array.starts[i] + norm\n                    k += 1\n                offsets[i + 1] = k\n\n            starts = offsets[:-1]\n            stops = offsets[1:]\n            return _JaggedArray_new(array, starts, stops, array.content[index], True)\n\n    else:\n        raise AssertionError(where)\n\n    return context.compile_internal(builder, getitem, sig, args)\n\n@numba.extending.lower_builtin(operator.getitem, JaggedArrayType, numba.types.BaseTuple)\ndef _JaggedArray_lower_getitem_enter(context, builder, sig, args):\n    arraytype, wheretype = sig.args\n    arrayval, whereval = args\n\n    if len(wheretype.types) == 1:\n        if isinstance(wheretype.types[0], numba.types.Integer):\n            getitem = _JaggedArray_lower_getitem_integer\n        elif isinstance(wheretype.types[0], numba.types.SliceType):\n            getitem = _JaggedArray_lower_getitem_slice\n        elif isinstance(wheretype.types[0], numba.types.Array):\n            getitem = _JaggedArray_lower_getitem_array\n        return getitem(context, builder, sig.return_type(arraytype, wheretype.types[0]), (arrayval, builder.extract_value(whereval, 0)))\n\n    if any(isinstance(x, numba.types.Array) for x in wheretype.types):\n        arraylen = numba.cgutils.alloca_once_value(builder, context.get_constant(JaggedArrayNumba.NUMBA_INDEXTYPE, 0))\n        for i, whereitemtype in enumerate(wheretype.types):\n            if isinstance(whereitemtype, numba.types.Array):\n                if isinstance(whereitemtype.dtype, numba.types.Boolean):\n                    enter_arraylen = lambda whereitem, arraylen: max(arraylen, whereitem.astype(numpy.int64).sum())\n                else:\n                    enter_arraylen = lambda whereitem, arraylen: max(arraylen, len(whereitem))\n\n                whereitemval = builder.extract_value(whereval, i)\n                arraylenval = context.compile_internal(builder, enter_arraylen, JaggedArrayNumba.NUMBA_INDEXTYPE(whereitemtype, JaggedArrayNumba.NUMBA_INDEXTYPE), (whereitemval, builder.load(arraylen)))\n                builder.store(arraylenval, arraylen)\n\n        arraylenval = builder.load(arraylen)\n        newwheretype = []\n        newwherevals = []\n        for i, old in enumerate(wheretype.types):\n            if isinstance(old, numba.types.Array) and isinstance(old.dtype, numba.types.Boolean):\n                toadvanced = lambda whereitem, arraylen: numpy.where(whereitem)[0]\n            elif isinstance(old, numba.types.Array):\n                toadvanced = lambda whereitem, arraylen: numpy.full(arraylen, whereitem[0], numpy.int64) if len(whereitem) == 1 else whereitem\n            elif isinstance(old, numba.types.Integer):\n                toadvanced = lambda whereitem, arraylen: numpy.full(arraylen, whereitem, numpy.int64)\n            else:\n                toadvanced = None\n\n            whereitemval = builder.extract_value(whereval, i)\n            if toadvanced is None:\n                newwheretype.append(old)\n                newwherevals.append(whereitemval)\n            else:\n                new = numba.types.Array(JaggedArrayNumba.NUMBA_INDEXTYPE, 1, ""C"") if isinstance(old, (numba.types.Array, numba.types.Integer)) else old\n                newwheretype.append(new)\n                newwherevals.append(context.compile_internal(builder, toadvanced, new(old, JaggedArrayNumba.NUMBA_INDEXTYPE), (whereitemval, arraylenval)))\n\n        wheretype = numba.types.Tuple(tuple(newwheretype))\n        whereval = context.make_tuple(builder, wheretype, tuple(newwherevals))\n\n    def fake1(array, where):\n        return _JaggedArray_getitem_next(awkward.array.jagged.JaggedArray(numpy.array([0], numpy.int64), numpy.array([len(array)], numpy.int64), array), where, None)[0]\n\n    def fake2(array, where):\n        out = _JaggedArray_getitem_next(awkward.array.jagged.JaggedArray(numpy.array([0], numpy.int64), numpy.array([len(array)], numpy.int64), array), where, None)\n        return out.content[out.starts[0]:out.stops[-1]]\n\n    fake = fake1 if all(isinstance(x, numba.types.Integer) for x in wheretype.types) else fake2\n    return context.compile_internal(builder, fake, sig.return_type(arraytype, wheretype), (arrayval, whereval))\n\n@numba.generated_jit(nopython=True)\ndef _JaggedArray_getitem_enter_toadvanced(whereitem, arraylen):\n    if isinstance(whereitem, numba.types.Array) and isinstance(whereitem.dtype, numba.types.Boolean):\n        return lambda whereitem, arraylen: numpy.nonzero(whereitem)[0]\n    elif isinstance(whereitem, numba.types.Array):\n        return lambda whereitem, arraylen: numpy.full(arraylen, whereitem[0], numpy.int64) if len(whereitem) == 1 else whereitem\n    elif isinstance(whereitem, numba.types.Integer):\n        return lambda whereitem, arraylen: numpy.full(arraylen, whereitem, numpy.int64)\n    else:\n        return lambda whereitem, arraylen: whereitem\n\n@numba.extending.lower_builtin(_JaggedArray_getitem_next, numba.types.Array, numba.types.BaseTuple, numba.types.NoneType)\n@numba.extending.lower_builtin(_JaggedArray_getitem_next, JaggedArrayType, numba.types.BaseTuple, numba.types.NoneType)\n@numba.extending.lower_builtin(_JaggedArray_getitem_next, numba.types.Array, numba.types.BaseTuple, numba.types.Array)\n@numba.extending.lower_builtin(_JaggedArray_getitem_next, JaggedArrayType, numba.types.BaseTuple, numba.types.Array)\ndef _JaggedArray_lower_getitem_next(context, builder, sig, args):\n    arraytype, wheretype, advancedtype = sig.args\n    arrayval, whereval, advancedval = args\n\n    if len(wheretype.types) == 0:\n        if context.enable_nrt:\n            context.nrt.incref(builder, arraytype, arrayval)\n        return arrayval\n\n    headtype = wheretype.types[0]\n    tailtype = numba.types.Tuple(wheretype.types[1:])\n    headval = numba.targets.tupleobj.static_getitem_tuple(context, builder, headtype(wheretype, JaggedArrayNumba.NUMBA_INDEXTYPE), (whereval, 0))\n    tailval = numba.targets.tupleobj.static_getitem_tuple(context, builder, tailtype(wheretype, numba.types.slice2_type), (whereval, slice(1, None)))\n\n    if isinstance(headtype, numba.types.Integer):\n        if isinstance(arraytype.contenttype, numba.types.Array):\n            def getitem(array, head, tail, advanced):\n                content = numpy.empty(len(array.starts), array.content.dtype)\n                for i in range(len(array.starts)):\n                    norm = head\n                    if norm < 0:\n                        norm += array.stops[i] - array.starts[i]\n                    j = array.starts[i] + norm\n                    if j >= array.stops[i]:\n                        raise ValueError(""integer index is beyond the range of one of the JaggedArray starts/stops pairs"")\n                    content[i] = array.content[j]\n                return _JaggedArray_getitem_next(content, tail, advanced)\n\n        else:\n            def getitem(array, head, tail, advanced):\n                index = numpy.empty(len(array.starts), numpy.int64)\n                for i in range(len(array.starts)):\n                    norm = head\n                    if norm < 0:\n                        norm += array.stops[i] - array.starts[i]\n                    j = array.starts[i] + norm\n                    if j >= array.stops[i]:\n                        raise ValueError(""integer index is beyond the range of one of the JaggedArray starts/stops pairs"")\n                    index[i] = j\n                return _JaggedArray_getitem_next(array.content[index], tail, advanced)\n\n    elif isinstance(headtype, numba.types.SliceType) and headtype.members == 2 and advancedtype == NOTADVANCED and not any(isinstance(x, numba.types.Array) for x in tailtype):\n        intp_maxval = numba.types.intp.maxval\n\n        def getitem(array, head, tail, advanced):\n            if (head.start == 0 or head.start == intp_maxval) and head.stop == intp_maxval:\n                next = _JaggedArray_getitem_next(array.content, tail, advanced)\n                return _JaggedArray_new(array, array.starts, array.stops, next, array.iscompact)\n\n            starts = numpy.empty(len(array.starts), numpy.int64)\n            stops = numpy.empty(len(array.starts), numpy.int64)\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                a = head.start\n                b = head.stop\n\n                if a == intp_maxval:\n                    a = 0\n                elif a < 0:\n                    a += length\n                if b == intp_maxval:\n                    b = length\n                elif b < 0:\n                    b += length\n\n                if b <= a:\n                    a = 0\n                    b = 0\n                if a < 0:\n                    a = 0\n                elif a > length:\n                    a = length\n                if b < 0:\n                    b = 0\n                elif b > length:\n                    b = length\n\n                starts[i] = array.starts[i] + a\n                stops[i] = array.starts[i] + b\n\n            next = _JaggedArray_getitem_next(array.content, tail, advanced)\n            return _JaggedArray_new(array, starts, stops, next, False)\n\n    elif isinstance(headtype, numba.types.SliceType):\n        intp_maxval = numba.types.intp.maxval\n\n        def getitem(array, head, tail, advanced):\n            if head.step == 0:\n                raise ValueError(""slice step cannot be zero"")\n\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            offsets[0] = 0\n            index = numpy.empty(len(array.content), numpy.int64)\n            k = 0\n            for i in range(len(array.starts)):\n                length = array.stops[i] - array.starts[i]\n                a = head.start\n                b = head.stop\n                c = head.step\n                if c == intp_maxval:\n                    c = 1\n\n                if a == intp_maxval and c > 0:\n                    a = 0\n                elif a == intp_maxval:\n                    a = length - 1\n                elif a < 0:\n                    a += length\n\n                if b == intp_maxval and c > 0:\n                    b = length\n                elif b == intp_maxval:\n                    b = -1\n                elif b < 0:\n                    b += length\n\n                if c > 0:\n                    if b <= a:\n                        a = 0\n                        b = 0\n                    if a < 0:\n                        a = 0\n                    elif a > length:\n                        a = length\n                    if b < 0:\n                        b = 0\n                    elif b > length:\n                        b = length\n                else:\n                    if a <= b:\n                        a = 0\n                        b = 0\n                    if a < -1:\n                        a = -1\n                    elif a >= length:\n                        a = length - 1\n                    if b < -1:\n                        b = -1\n                    elif b >= length:\n                        b = length - 1\n\n                for j in range(a, b, c):\n                    index[k] = array.starts[i] + j\n                    k += 1\n                offsets[i + 1] = k\n\n            starts = offsets[:-1]\n            stops = offsets[1:]\n            next = _JaggedArray_getitem_next(array.content[index[:k]], tail, _spread_advanced(starts, stops, advanced))\n            return _JaggedArray_new(array, starts, stops, next, True)\n\n    elif isinstance(headtype, numba.types.Array):\n        if advancedtype == NOTADVANCED:\n            def getitem(array, head, tail, advanced):\n                offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n                offsets[0] = 0\n                index = numpy.empty(len(head)*len(array.starts), numpy.int64)\n                nextadvanced = numpy.empty(len(index), numpy.int64)\n\n                k = 0\n                for i in range(len(array.starts)):\n                    length = array.stops[i] - array.starts[i]\n\n                    for j in range(len(head)):\n                        norm = head[j]\n                        if norm < 0:\n                            norm += length\n                        if norm < 0 or norm >= length:\n                            raise IndexError(""advanced index is out of bounds in JaggedArray"")\n                        index[k] = array.starts[i] + norm\n                        nextadvanced[k] = j\n                        k += 1\n                    offsets[i + 1] = k\n\n                starts = offsets[:-1]\n                stops = offsets[1:]\n                next = _JaggedArray_getitem_next(array.content[index], tail, nextadvanced)\n                return _JaggedArray_new(array, starts, stops, next, True)\n\n        else:\n            def getitem(array, head, tail, advanced):\n                index = numpy.empty(len(array.starts), numpy.int64)\n                nextadvanced = numpy.empty(len(index), numpy.int64)\n\n                for i in range(len(advanced)):\n                    length = array.stops[i] - array.starts[i]\n                    if advanced[i] >= len(head):\n                        raise IndexError(""advanced index lengths do not match"")\n                    norm = head[advanced[i]]\n                    if norm < 0:\n                        norm += length\n                    if norm < 0 or norm >= length:\n                        raise IndexError(""advanced index is out of bounds in JaggedArray"")\n                    index[i] = array.starts[i] + norm\n                    nextadvanced[i] = i\n\n                next = _JaggedArray_getitem_next(array.content[index], tail, nextadvanced)\n                return next\n\n    else:\n        raise AssertionError(head)\n\n    sig = sig.return_type(arraytype, headtype, tailtype, advancedtype)\n    args = (arrayval, headval, tailval, advancedval)\n    return context.compile_internal(builder, getitem, sig, args)\n\n@numba.generated_jit(nopython=True)\ndef _spread_advanced(starts, stops, advanced):\n    if isinstance(advanced, numba.types.NoneType):\n        return lambda starts, stops, advanced: advanced\n    else:\n        def impl(starts, stops, advanced):\n            counts = stops - starts\n            nextadvanced = numpy.empty(counts.sum(), numpy.int64)\n            k = 0\n            for i in range(len(counts)):\n                length = counts[i]\n                nextadvanced[k : k + counts[i]] = advanced[i]\n                k += length\n            return nextadvanced\n        return impl\n\n######################################################################## overloading ufuncs\n\n### See numba.typing.npydecl for typing, and then maybe lower as usual?\n\n### @numba.extending.lower_builtin(numpy.add, JaggedArrayType, JaggedArrayType)\n### @numba.extending.lower_builtin(numpy.add, JaggedArrayType, numba.types.Array)\n### @numba.extending.lower_builtin(numpy.add, numba.types.Array, JaggedArrayType)\n### ???\n\n\n\n\n\n\n######################################################################## other lowered methods in Numba, including reducers\n\n@numba.typing.templates.infer_getattr\nclass _JaggedArrayType_type_methods(numba.typing.templates.AttributeTemplate):\n    key = JaggedArrayType\n\n    def resolve_reducer(self, arraytype, args, kwargs, endtype):\n        if len(args) == 0 and len(kwargs) == 0:\n            if isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, JaggedArrayType):\n                contenttype = self.resolve_reducer(arraytype.contenttype, args, kwargs, endtype)\n                return JaggedArrayType(arraytype.startstype, arraytype.stopstype, contenttype.return_type, special=JaggedArrayNumba)()\n            elif isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, numba.types.Array):\n                if endtype is None:\n                    endtype = arraytype.contenttype.dtype\n                return numba.types.Array(endtype, 1, arraytype.contenttype.layout)()\n\n    @numba.typing.templates.bound_function(""any"")\n    def resolve_any(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, JaggedArrayNumba.NUMBA_BOOLTYPE)\n\n    @numba.typing.templates.bound_function(""all"")\n    def resolve_all(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, JaggedArrayNumba.NUMBA_BOOLTYPE)\n\n    @numba.typing.templates.bound_function(""count"")\n    def resolve_count(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, JaggedArrayNumba.NUMBA_INDEXTYPE)\n\n    @numba.typing.templates.bound_function(""count_nonzero"")\n    def resolve_count_nonzero(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, JaggedArrayNumba.NUMBA_INDEXTYPE)\n\n    @numba.typing.templates.bound_function(""sum"")\n    def resolve_sum(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, None)\n\n    @numba.typing.templates.bound_function(""prod"")\n    def resolve_prod(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, None)\n\n    @numba.typing.templates.bound_function(""min"")\n    def resolve_min(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, None)\n\n    @numba.typing.templates.bound_function(""max"")\n    def resolve_max(self, arraytype, args, kwargs):\n        return self.resolve_reducer(arraytype, args, kwargs, None)\n\n#     @numba.typing.templates.bound_function(""structure1d"")\n#     def resolve_structure1d(self, arraytype, args, kwargs):\n#         if len(args) == 0:\n#             return arraytype()\n#         elif len(args) == 1 and isinstance(args[0], numba.types.NoneType):\n#             return arraytype(args[0])\n#         elif len(args) == 1 and isinstance(args[0], numba.types.Integer):\n#             return arraytype(args[0])\n\n# @numba.extending.lower_builtin(""structure1d"", JaggedArrayType)\n# def _JaggedArray_lower_structure1d_1(context, builder, sig, args):\n#     arraytype, = sig.args\n#     arrayval, = args\n#     return _JaggedArray_lower_structure1d_3(context, builder, sig.return_type(arraytype, JaggedArrayNumba.NUMBA_INDEXTYPE), (arrayval, context.get_constant(JaggedArrayNumba.NUMBA_INDEXTYPE, -1),))\n\ndef _JaggedArray_lower_reduce_descend(which, context, builder, sig, args):\n    arraytype, = sig.args\n    arrayval, = args\n    array = numba.cgutils.create_struct_proxy(arraytype)(context, builder, value=arrayval)\n    content = which(context, builder, sig.return_type.contenttype(arraytype.contenttype), (array.content,))\n    return _JaggedArray_lower_new(context, builder, sig.return_type(arraytype, arraytype.startstype, arraytype.stopstype, sig.return_type.contenttype, JaggedArrayNumba.NUMBA_BOOLTYPE), (arrayval, array.starts, array.stops, content, array.iscompact))\n\n@numba.extending.lower_builtin(""any"", JaggedArrayType)\ndef _JaggedArray_lower_any(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_any, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, numpy.bool_)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = False\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]) and array.content[j] != 0:\n                    flatout[i] = True\n                    break\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""all"", JaggedArrayType)\ndef _JaggedArray_lower_all(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_all, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, numpy.bool_)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = True\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]) and array.content[j] == 0:\n                    flatout[i] = False\n                    break\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""count"", JaggedArrayType)\ndef _JaggedArray_lower_count(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_count, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, numpy.int64)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = 0\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]):\n                    flatout[i] += 1\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""count_nonzero"", JaggedArrayType)\ndef _JaggedArray_lower_count_nonzero(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_count_nonzero, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, numpy.int64)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = 0\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]) and array.content[j] != 0:\n                    flatout[i] += 1\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""sum"", JaggedArrayType)\ndef _JaggedArray_lower_sum(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_sum, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, array.content.dtype)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = 0\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]):\n                    flatout[i] += array.content[j]\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""prod"", JaggedArrayType)\ndef _JaggedArray_lower_prod(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_prod, context, builder, sig, args)\n    def run(array):\n        out = numpy.empty(array.starts.shape, array.content.dtype)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = 1\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]):\n                    flatout[i] *= array.content[j]\n        return out\n    return context.compile_internal(builder, run, sig, args)\n\n@numba.extending.lower_builtin(""min"", JaggedArrayType)\ndef _JaggedArray_lower_min(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_min, context, builder, sig, args)\n    def run(array, identity):\n        out = numpy.empty(array.starts.shape, array.content.dtype)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = identity\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]) and array.content[j] < flatout[i]:\n                    flatout[i] = array.content[j]\n        return out\n    datatype = sig.args[0].contenttype.dtype\n    if isinstance(datatype, numba.types.Boolean):\n        identity = True\n    elif isinstance(datatype, numba.types.Integer):\n        identity = datatype.maxval\n    else:\n        identity = numpy.inf\n        datatype = numba.types.float64\n    return context.compile_internal(builder, run, sig.return_type(sig.args[0], datatype), (args[0], context.get_constant(datatype, identity)))\n\n@numba.extending.lower_builtin(""max"", JaggedArrayType)\ndef _JaggedArray_lower_max(context, builder, sig, args):\n    if isinstance(sig.args[0].contenttype, JaggedArrayType):\n        return _JaggedArray_lower_reduce_descend(_JaggedArray_lower_max, context, builder, sig, args)\n    def run(array, identity):\n        out = numpy.empty(array.starts.shape, array.content.dtype)\n        flatout = out.reshape(-1)\n        flatstarts = array.starts.reshape(-1)\n        flatstops = array.stops.reshape(-1)\n        for i in range(len(flatstarts)):\n            flatout[i] = identity\n            for j in range(flatstarts[i], flatstops[i]):\n                if not math.isnan(array.content[j]) and array.content[j] > flatout[i]:\n                    flatout[i] = array.content[j]\n        return out\n    datatype = sig.args[0].contenttype.dtype\n    if isinstance(datatype, numba.types.Boolean):\n        identity = False\n    elif isinstance(datatype, numba.types.Integer):\n        identity = datatype.minval\n    else:\n        identity = -numpy.inf\n        datatype = numba.types.float64\n    return context.compile_internal(builder, run, sig.return_type(sig.args[0], datatype), (args[0], context.get_constant(datatype, identity)))\n\n@numba.extending.overload_attribute(JaggedArrayType, ""offsets"")\ndef _JaggedArray_offsets(arraytype):\n    if arraytype.startstype.ndim == 1:\n        def impl(array):\n            offsets = numpy.empty(len(array.starts) + 1, numpy.int64)\n            if len(array.starts) == 0:\n                offsets[0] = 0\n                return offsets\n            offsets = array.starts[0]\n            for i in range(1, len(array.starts)):\n                if array.starts[i + 1] != array.stops[i]:\n                    raise ValueError(""starts and stops are not compatible with a single offsets array; call jagged.compact() first"")\n                offsets[i] = array.stops[i]\n            return offsets\n        return impl\n    else:\n        raise TypeError(""len(starts.shape) must be 1 to compute offsets; call jagged.structure1d() first"")\n\n@numba.extending.overload_attribute(JaggedArrayType, ""counts"")\ndef _JaggedArray_counts(arraytype):\n    def impl(array):\n        return array.stops - array.starts\n    return impl\n\n@numba.extending.overload_attribute(JaggedArrayType, ""parents"")\ndef _JaggedArray_parents(arraytype):\n    def impl(array):\n        out = numpy.full(array.stops.max(), -1, numpy.int64)\n        for i in range(len(array.starts)):\n            out[array.starts[i]:array.stops[i]] = i\n        return out\n    return impl\n\n@numba.extending.overload_attribute(JaggedArrayType, ""index"")\ndef _JaggedArray_index(arraytype):\n    def impl(array):\n        out = numpy.full(array.stops.max(), -1, numpy.int64)\n        for i in range(len(array.starts)):\n            for j in range(array.starts[i], array.stops[i]):\n                out[j] = j - array.starts[i]\n        return JaggedArray(array.starts, array.stops, out, array.iscompact)\n\n@numba.extending.overload_method(JaggedArrayType, ""regular"")\ndef _JaggedArray_regular(arraytype):\n    if not isinstance(arraytype.contenttype, numba.types.Array):\n        raise TypeError(""JaggedArray.content must be a Numpy array to use jagged.regular()"")\n    def impl(array):\n        count = -1\n        for i in range(len(array.starts)):\n            if count == -1:\n                count = array.stops[i] - array.starts[i]\n            elif count != array.stops[i] - array.starts[i]:\n                raise ValueError(""JaggedArray is not regular: different elements have different counts"")\n        return array.content.reshape(array.starts.shape + (count,))\n    return impl\n\n@numba.extending.overload_method(JaggedArrayType, ""compact"")\ndef _JaggedArray_compact(arraytype):\n    if isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, AwkwardArrayType):\n        def impl(array):\n            if array.iscompact:\n                return array\n            if len(array.starts) == 0:\n                return _JaggedArray_new(array, array.starts, array.stops[0:0], array.content[0:0], True)\n\n            if array.starts.shape != array.stops.shape:\n                raise ValueError(""JaggedArray.starts must have the same shape as JaggedArray.stops"")\n            flatstarts = array.starts.reshape(-1)\n            flatstops = array.stops.reshape(-1)\n\n            offsets = numpy.empty(len(flatstarts) + 1, flatstarts.dtype)\n            offsets[0] = 0\n            for i in range(len(flatstarts)):\n                count = flatstops[i] - flatstarts[i]\n                if count < 0:\n                    raise ValueError(""JaggedArray.stops[i] must be greater than or equal to JaggedArray.starts[i] for all i"")\n                offsets[i + 1] = offsets[i] + count\n\n            index = numpy.empty(offsets[-1], numpy.int64)\n            k = 0\n            for i in range(len(flatstarts)):\n                for j in range(flatstarts[i], flatstops[i]):\n                    index[k] = j\n                    k += 1\n\n            starts = offsets[:-1].reshape(array.starts.shape)\n            stops = offsets[1:].reshape(array.starts.shape)    # intentional\n            content = array.content[index]\n            return _JaggedArray_new(array, starts, stops, content, True)\n\n        return impl\n\n    elif isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, numba.types.Array):\n        def impl(array):\n            if array.iscompact:\n                return array\n            if len(array.starts) == 0:\n                return _JaggedArray_new(array, array.starts, array.stops[0:0], array.content[0:0], True)\n\n            if array.starts.shape != array.stops.shape:\n                raise ValueError(""JaggedArray.starts must have the same shape as JaggedArray.stops"")\n            flatstarts = array.starts.ravel()\n            flatstops = array.stops.ravel()\n\n            offsets = numpy.empty(len(flatstarts) + 1, flatstarts.dtype)\n            offsets[0] = 0\n            for i in range(len(flatstarts)):\n                count = flatstops[i] - flatstarts[i]\n                if count < 0:\n                    raise ValueError(""JaggedArray.stops[i] must be greater than or equal to JaggedArray.starts[i] for all i"")\n                offsets[i + 1] = offsets[i] + count\n\n            content = numpy.empty(offsets[-1], array.content.dtype)\n            k = 0\n            for i in range(len(flatstarts)):\n                for j in range(flatstarts[i], flatstops[i]):\n                    content[k] = array.content[j]\n                    k += 1\n\n            starts = offsets[:-1].reshape(array.starts.shape)\n            stops = offsets[1:].reshape(array.starts.shape)    # intentional\n            return _JaggedArray_new(array, starts, stops, content, True)\n\n        return impl\n\n@numba.extending.overload_method(JaggedArrayType, ""flatten"")\ndef _JaggedArray_flatten(arraytype):\n    if isinstance(arraytype, JaggedArrayType):\n        def impl(array):\n            if len(array.starts) == 0:\n                return array.content[0:0]\n            else:\n                a = array.compact()\n                return a.content[a.starts[0]:a.stops[-1]]\n        return impl\n\n@numba.extending.overload_method(JaggedArrayType, ""argmin"")\ndef _JaggedArray_argmin(arraytype):\n    if isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, AwkwardArrayType):\n        def impl(array):\n            return _JaggedArray_new(array, array.starts, array.stops, _JaggedArray_argmin(array.content), array.iscompact)\n        return impl\n    elif isinstance(arraytype, JaggedArrayType):\n        def impl(array):\n            return _JaggedArray_argminmax(array, True)\n        return impl\n\n@numba.extending.overload_method(JaggedArrayType, ""argmax"")\ndef _JaggedArray_argmax(arraytype):\n    if isinstance(arraytype, JaggedArrayType) and isinstance(arraytype.contenttype, AwkwardArrayType):\n        def impl(array):\n            return _JaggedArray_new(array, array.starts, array.stops, _JaggedArray_argmax(array.content), array.iscompact)\n        return impl\n    elif isinstance(arraytype, JaggedArrayType):\n        def impl(array):\n            return _JaggedArray_argminmax(array, False)\n        return impl\n    \n@numba.njit\ndef _JaggedArray_argminmax(array, ismin):\n    if len(array.content.shape) != 1:\n        raise NotImplementedError(""content is not one-dimensional"")\n\n    flatstarts = array.starts.reshape(-1)\n    flatstops = array.stops.reshape(-1)\n\n    offsets = numpy.empty(len(flatstarts) + 1, numpy.int64)\n    offsets[0] = 0\n    for i in range(len(flatstarts)):\n        if flatstarts[i] == flatstops[i]:\n            offsets[i + 1] = offsets[i]\n        else:\n            offsets[i + 1] = offsets[i] + 1\n\n    starts = offsets[:-1].reshape(array.starts.shape)\n    stops = offsets[1:].reshape(array.stops.shape)\n\n    output = numpy.empty(offsets[-1], dtype=numpy.int64)\n\n    if ismin:\n        k = 0\n        for i in range(len(flatstarts)):\n            if flatstops[i] != flatstarts[i]:\n                best = array.content[flatstarts[i]]\n                bestj = 0\n                for j in range(flatstarts[i] + 1, flatstops[i]):\n                    if array.content[j] < best:\n                        best = array.content[j]\n                        bestj = j - flatstarts[i]\n                output[k] = bestj\n                k += 1\n\n    else:\n        k = 0\n        for i in range(len(flatstarts)):\n            if flatstops[i] != flatstarts[i]:\n                best = array.content[flatstarts[i]]\n                bestj = 0\n                for j in range(flatstarts[i] + 1, flatstops[i]):\n                    if array.content[j] > best:\n                        best = array.content[j]\n                        bestj = j - flatstarts[i]\n                output[k] = bestj\n                k += 1\n\n    return _JaggedArray_new(array, starts, stops, output, True)\n\n@numba.njit\ndef _JaggedArray_concatenate_njit(arrays, axis):\n    return _JaggedArray_concatenate(arrays, axis)\n\ndef _JaggedArray_concatenate(arrays, axis):\n    pass\n\n@numba.extending.type_callable(_JaggedArray_concatenate)\ndef _JaggedArray_concatenate(context):\n    return None\n\n@numba.extending.lower_builtin(_JaggedArray_concatenate, numba.types.Tuple, numba.types.Integer)\ndef _JaggedArray_lower_concatenate(context, builder, sig, args):\n    raise NotImplementedError\n'"
awkward-numba/awkward/numba/array/masked.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.masked\nfrom .base import NumbaMethods\n\nclass MaskedArrayNumba(NumbaMethods, awkward.array.masked.MaskedArray):\n    pass\n\nclass BitMaskedArrayNumba(NumbaMethods, awkward.array.masked.BitMaskedArray):\n    pass\n\nclass IndexedMaskedArrayNumba(NumbaMethods, awkward.array.masked.IndexedMaskedArray):\n    pass\n'"
awkward-numba/awkward/numba/array/objects.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.objects\nfrom .base import NumbaMethods\n\nclass MethodsNumba(NumbaMethods, awkward.array.objects.Methods):\n    pass\n\nclass ObjectArrayNumba(NumbaMethods, awkward.array.objects.ObjectArray):\n    pass\n\nclass StringArrayNumba(NumbaMethods, awkward.array.objects.StringArray):\n    pass\n'"
awkward-numba/awkward/numba/array/table.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport re\nfrom collections import OrderedDict\n\nimport numpy\nimport numba\n\nimport awkward.array.table\nfrom .base import NumbaMethods\nfrom .base import AwkwardArrayType\nfrom .base import clsrepr\nfrom .base import sliceval2\nfrom .base import sliceval3\n\nclass TableNumba(NumbaMethods, awkward.array.table.Table):\n    class Row(awkward.array.table.Table.Row):\n        pass\n\n        # def __init__(self, table, index):\n\n        # def __repr__(self):\n\n        # def __contains__(self, name):\n\n        # def tolist(self):\n\n        # def __len__(self):\n\n        # def __iter__(self, checkiter=True):\n\n        # def __getitem__(self, where):\n\n        # def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n\n        # def __eq__(self, other):\n\n        # def __ne__(self, other):\n\n        # @property\n        # def i0(self):\n\n        # @property\n        # def i1(self):\n\n        # @property\n        # def i2(self):\n\n        # @property\n        # def i3(self):\n\n        # @property\n        # def i4(self):\n\n        # @property\n        # def i5(self):\n\n        # @property\n        # def i6(self):\n\n        # @property\n        # def i7(self):\n\n        # @property\n        # def i8(self):\n\n        # @property\n        # def i9(self):\n\n    # def __init__(self, columns1={}, *columns2, **columns3):\n\n    # def tolist(self):\n\n    # @classmethod\n    # def named(cls, rowname, columns1={}, *columns2, **columns3):\n\n    # @property\n    # def rowname(self):\n\n    # @rowname.setter\n    # def rowname(self, value):\n\n    # @classmethod\n    # def fromrec(cls, recarray):\n\n    # @classmethod\n    # def frompairs(cls, pairs):\n\n    # @classmethod\n    # def fromview(cls, view, base):\n\n    # def copy(self, contents=None):\n\n    # def deepcopy(self, contents=None):\n\n    # def empty_like(self, **overrides):\n\n    # def zeros_like(self, **overrides):\n\n    # def ones_like(self, **overrides):\n\n    # def __awkward_persist__(self, ident, fill, prefix, suffix, schemasuffix, storage, compression, **kwargs):\n\n    # @property\n    # def base(self):\n\n    # @property\n    # def contents(self):\n\n    # @contents.setter\n    # def contents(self, value):\n\n    # def __len__(self):\n\n    # def _gettype(self, seen):\n\n    # def _length(self):\n\n    # def _index(self):\n\n    # def _newslice(self, head):\n\n    # def _valid(self):\n\n    # def __iter__(self, checkiter=True):\n\n    # def __getitem__(self, where):\n\n    # def __setitem__(self, where, what):\n\n    # def __delitem__(self, where):\n\n    # def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n\n    # @property\n    # def istuple(self):\n\n    # def flattentuple(self):\n\n    # def _hasjagged(self):\n\n    # def _reduce(self, ufunc, identity, dtype, regularaxis):\n\n    # @property\n    # def columns(self):\n\n    # def astype(self, dtype):\n\n######################################################################## register types in Numba\n\n@numba.extending.typeof_impl.register(awkward.array.table.Table)\ndef _Table_typeof(val, c):\n    return TableType(val.rowname, OrderedDict((n, numba.typeof(x)) for n, x in val.contents.items()), special=type(val), specialrow=type(val).Row)\n\nclass TableType(AwkwardArrayType):\n    class RowType(numba.types.Type):\n        def __init__(self, rowname, types, special=awkward.array.table.Table.Row):\n            super(RowType, self).__init__(name=""RowType({0}, {{{1}}}{2})"".format(repr(rowname), "", "".join(""{0}: {1}"".format(repr(n), t) for n, t in types.items()), """" if special is awkward.array.table.Table.Row else clsrepr(special)))\n            self.rowname = rowname\n            self.types = types\n            self.special = special\n\n    @property\n    def rowtype(self):\n        return TableType.RowType(self.rowname, self.types, special=self.specialrow)\n\n    def __init__(self, rowname, types, special=awkward.array.table.Table, specialrow=awkward.array.table.Table.Row):\n        super(TableType, self).__init__(name=""TableType({0}, {{{1}}}{2}{3})"".format(repr(rowname), "", "".join(""{0}: {1}"".format(repr(n), t) for n, t in types.items()), """" if special is awkward.array.table.Table else clsrepr(special), """" if specialrow is awkward.array.table.Table.Row else clsrepr(specialrow)))\n        self.rowname = rowname\n        self.types = types\n        self.special = special\n        self.specialrow = specialrow\n\n    def getitem(self, wheretype):\n        if isinstance(wheretype, numba.types.StringLiteral):\n            if wheretype.literal_value in self.types:\n                return self.types[wheretype.literal_value]\n            else:\n                raise TypeError(""{0} is not a column of Table"".format(repr(wheretype.literal_value)))\n\n        # elif literal list/tuple of strings\n\n        else:\n            return TableType(self.rowname, OrderedDict((n, x.getitem(wheretype)) for n, x in self.types.items()), special=self.special, specialrow=self.specialrow)\n\n######################################################################## model and boxing\n\n# don\'t start non-fieldnames with ""f""\ndef _safename(name):\n    return ""f"" + _safename._pattern.sub(lambda bad: ""_"" + """".join(""{0:02x}"".format(ord(x)) for x in bad.group(0)) + ""_"", name)\n_safename._pattern = re.compile(""[^a-zA-Z0-9]+"")\n\n@numba.extending.register_model(TableType)\nclass TableModel(numba.datamodel.models.StructModel):\n    def __init__(self, dmm, fe_type):\n        members = [(_safename(n), x) for n, x in fe_type.types.items()]\n        super(TableModel, self).__init__(dmm, fe_type, members)\n\n@numba.extending.unbox(TableType)\ndef _TableType_unbox(typ, obj, c):\n    key_objs = [HERE]\n    value_objs = [c.pyapi.object_getitem(obj, n) for n in key_objs]\n'"
awkward-numba/awkward/numba/array/union.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.union\nfrom .base import NumbaMethods\n\nclass UnionArrayNumba(NumbaMethods, awkward.array.union.UnionArray):\n    pass\n'"
awkward-numba/awkward/numba/array/virtual.py,0,"b'#!/usr/bin/env python\n\n# BSD 3-Clause License; see https://github.com/scikit-hep/awkward-array/blob/master/LICENSE\n\nimport awkward.array.virtual\nfrom .base import NumbaMethods\n\nclass VirtualArrayNumba(NumbaMethods, awkward.array.virtual.VirtualArray):\n    pass\n'"
