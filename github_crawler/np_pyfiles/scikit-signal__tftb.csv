file_path,api_count,code
setup.py,0,"b'import builtins\nfrom setuptools import setup, find_packages\n\n\nbuiltins.__TFTB__SETUP__ = True\n\n# Setuptools config\nNAME = ""tftb""\nDESCRIPTION = ""Python module for time-frequency analysis.""\nwith open(\'README.md\') as f:\n    LONG_DESCRIPTION = f.read()\nMAINTAINER = \'Jaidev Deshpande\'\nMAINTAINER_EMAIL = \'deshpande.jaidev@gmail.com\'\nURL = ""https://github.com/scikit-signal/tftb""\nDOWNLOAD_URL = \'https://pypi.org/project/tftb/#files\'\nLICENSE = \'new BSD\'\nPROJECT_URLS = {\n    \'Bug Tracker\': \'https://github.com/scikit-signal/tftb/issues\',\n    \'Documentation\': \'https://tftb.readthedocs.io\',\n    \'Source Code\': \'https://github.com/scikit-signal/tftb\'\n}\n\n# Requirements\ninstall_requires = [\n    \'numpy\',\n    \'scipy\',\n    \'matplotlib\'\n]\n\n# Setup\nimport tftb  # NOQA: E402\nsetup(\n    name=NAME,\n    maintainer=MAINTAINER,\n    maintainer_email=MAINTAINER_EMAIL,\n    description=DESCRIPTION,\n    license=LICENSE,\n    url=URL,\n    download_url=DOWNLOAD_URL,\n    version=tftb.__version__,\n    long_description=LONG_DESCRIPTION,\n    packages=find_packages(),\n    install_requires=install_requires\n)\n'"
doc/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# pytftb documentation build configuration file, created by\n# sphinx-quickstart on Tue Jun  9 21:32:46 2015.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath(\'.\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.doctest\',\n    \'sphinx.ext.intersphinx\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.coverage\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.ifconfig\',\n    \'sphinx.ext.viewcode\',\n    \'matplotlib.sphinxext.plot_directive\',\n    \'sphinx_gallery.gen_gallery\'\n]\nsphinx_gallery_conf = {\n    # path to your examples scripts\n    \'examples_dirs\' : \'./_gallery\',\n    # path where to save gallery generated examples\n    \'gallery_dirs\'  : \'auto_examples\',\n    \'backreferences_dir\': ""backreferences"",\n    ""doc_module"": (""tftb"")}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'pytftb\'\ncopyright = \'2015, Jaidev Deshpande\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'0.0.1\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'0.0.1\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'alabaster\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n   \'**\': [\'navigation.html\', \'localtoc.html\', \'sourcelink.html\', \'searchbox.html\'],\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pytftbdoc\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n  (\'index\', \'pytftb.tex\', \'pytftb Documentation\',\n   \'Jaidev Deshpande\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\'index\', \'pytftb\', \'pytftb Documentation\',\n     [\'Jaidev Deshpande\'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  (\'index\', \'pytftb\', \'pytftb Documentation\',\n   \'Jaidev Deshpande\', \'pytftb\', \'One line description of project.\',\n   \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'http://docs.python.org/\': None}\n\ndef skip(app, what, name, obj, skip, options):\n    if name == ""__init__"":\n        return False\n    return skip\n\ndef setup(app):\n    app.connect(""autodoc-skip-member"", skip)\n'"
tftb/__init__.py,0,"b'import sys\n\n__version__ = \'0.1.1\'\n\ntry:\n    __TFTB__SETUP__\nexcept NameError:\n    __TFTB__SETUP__ = False\n\nif __TFTB__SETUP__:\n    sys.stderr.write(\'Partial import of tftb during the build process.\\n\')\nelse:\n    from tftb import generators, processing, utils\n    __all__ = [""generators"", ""processing"", ""utils""]\n'"
tftb/utils.py,26,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Miscellaneous utilities.""""""\n\nimport numpy as np\n\n\ndef is_linear(x, decimals=5):\n    """"""\n    Check if an array is linear.\n\n    :param x: Array to be checked for linearity.\n    :param decimals: decimal places upto which the derivative of the array\n        should be rounded off (default=5)\n    :type x: numpy.ndarray\n    :type decimals: int\n    :return: If the array is linear\n    :rtype: boolean\n    :Example:\n    >>> import numpy as np\n    >>> x = np.linspace(0, 2 * np.pi, 100)\n    >>> is_linear(x)\n    True\n    >>> is_linear(np.sin(x))\n    False\n    """"""\n    derivative = np.diff(x)\n    derivative = np.around(derivative, decimals)\n    return np.unique(derivative).shape[0] == 1\n\n\ndef izak(x):\n    """"""Inverse Zak transform.""""""\n    if x.ndim == 2:\n        n, m = x.shape\n    else:\n        n, m = x.shape[0], 1\n    sig = np.zeros((n * m, ), dtype=complex)\n    for im in range(m):\n        sig[im + np.arange(n) * m] = np.sqrt(n) * np.fft.ifft(x[:, im], axis=0)\n    return sig\n\n\ndef nextpow2(n):\n    """"""\n    Compute the integer exponent of the next higher power of 2.\n\n    :param n: Number whose next higest power of 2 needs to be computed.\n    :type n: int, np.ndarray\n    :rtype: int, np.ndarray\n    :Example:\n    >>> from __future__ import print_function\n    >>> import numpy as np\n    >>> x = np.arange(1, 9)\n    >>> print(nextpow2(x))\n    [ 0.  1.  2.  2.  3.  3.  3.  3.]\n    """"""\n    m_f = np.log2(n)\n    m_i = np.ceil(m_f)\n    return m_i\n\n\ndef divider(N):\n    """"""\n    Compute two factors of N such that they are as close as possible to sqrt(N).\n\n    :param N: Number to be divided.\n    :type N: int\n    :return: A tuple of two integers such that their product is `N` and they\n        are the closest possible to :math:`\\sqrt(N)`  # NOQA: W605\n    :rtype: tuple(int)\n    :Example:\n    >>> from __future__ import print_function\n    >>> print(divider(256))\n    (16.0, 16.0)\n    >>> print(divider(10))\n    (2.0, 5.0)\n    >>> print(divider(101))\n    (1.0, 101.0)\n    """"""\n    n = np.floor(np.sqrt(N))\n    while True:\n        old = n\n        m = np.ceil(N / float(n))\n        n = np.floor(N / float(m))\n        if n == old:\n            break\n    return n, m\n\n\ndef nearest_odd(N):\n    """"""\n    Get the nearest odd number for each value of N.\n\n    :param N: int / sequence of ints\n    :return: int / sequence of ints\n    :Example:\n    >>> from __future__ import print_function\n    >>> print(nearest_odd(range(1, 11)))\n    [  1.   3.   3.   5.   5.   7.   7.   9.   9.  11.]\n    >>> nearest_odd(0)\n    1\n    >>> nearest_odd(3)\n    3.0\n    """"""\n    if hasattr(N, ""__iter__""):\n        N = np.array(N)\n        y = np.floor(N)\n        y[np.remainder(y, 2) == 0] = np.ceil(N[np.remainder(y, 2) == 0])\n        y[np.remainder(y, 2) == 0] += 1\n        return y\n    if N % 2 == 0:\n        return N + 1\n    elif np.floor(N) % 2 == 0:\n        return np.ceil(N)\n    elif np.floor(N) % 2 != 0:\n        return np.floor(N)\n    return N\n\n\ndef modulo(x, N):\n    """"""\n    Compute the congruence of each element of x modulo N.\n\n    :type x: array-like\n    :type N: int\n    :return: array-like\n    :Example:\n    >>> from __future__ import print_function\n    >>> print(modulo(range(1, 11), 2))\n    [1 2 1 2 1 2 1 2 1 2]\n    """"""\n    if any(np.isreal(x)):\n        y = np.mod(x, N)\n        y[y == 0] = N\n    else:\n        y = np.mod(np.real(x), N) + 1j * np.mod(np.imag(x), N)\n    return y\n'"
doc/_gallery/plot_1_3_1_chirp.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===========================\nLinear Frequency Modulation\n===========================\n\nThis example shows how PyTFTB is used to generate a signal with linear\nfrequency modulation. Such a signal is also called a `chirp\n<https://en.wikipedia.org/wiki/Chirp>`_.\n\nFigure 1.1 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate a chirp signal\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\n\nsignal, _ = fmlin(n_points, fmin, fmax)\nplt.plot(np.real(signal))\nplt.xlim(0, n_points)\nplt.title(\'Linear Frequency Modulation\')\nplt.ylabel(\'Real Part\')\nplt.xlabel(\'Time\')\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_1_3_1_chirp_spectrum.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================\nEnergy Spectral Density of a Chirp\n==================================\n\nConstruct a chirp and plot its `energy spectral density\n<https://en.wikipedia.org/wiki/Spectral_density#Energy_spectral_density>`_.\n\nFigure 1.2 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\nsignal, _ = fmlin(n_points, fmin, fmax)\n\n# Plot the energy spectrum of the chirp\n\ndsp1 = np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\nplt.plot(np.arange(-64, 64, dtype=float) / 128.0, dsp1)\nplt.xlim(-0.5, 0.5)\nplt.title(\'Spectrum\')\nplt.ylabel(\'Squared modulus\')\nplt.xlabel(\'Normalized Frequency\')\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_1_3_1_chirp_wv.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================\nWigner-Ville Distribution of a Chirp\n====================================\n\nConstruct a chirp signal and visualize its `Wigner-Ville distribution\n<https://en.wikipedia.org/wiki/Wigner_distribution_function>`_.\n\nFigure 1.3 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.cohen import WignerVilleDistribution\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\nsignal, _ = fmlin(n_points, fmin, fmax)\n\n# Wigner-Ville distribution of the chirp.\n\nwvd = WignerVilleDistribution(signal)\nwvd.run()\nwvd.plot(kind=\'contour\', extent=[0, n_points, fmin, fmax])\n'"
doc/_gallery/plot_1_3_1_noisy_chirp.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n========================\nGenerating a Noisy Chirp\n========================\n\nThis example shows how to generate a chirp signal, with some analytical\ngaussian noise, and the usage of the :ref:`sigmerge` function to combine them.\n\nFigure 1.4 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, sigmerge, noisecg\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate a chirp signal\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\n\nsignal, _ = fmlin(n_points, fmin, fmax)\n\n# Noisy chirp\n\nnoisy_signal = sigmerge(signal, noisecg(128), 0)\nplt.plot(np.real(noisy_signal))\nplt.xlim(0, 128)\nplt.title(\'Noisy chirp\')\nplt.ylabel(\'Real Part\')\nplt.xlabel(\'Time\')\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_1_3_1_noisy_chirp_spectrum.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n================================\nEnergy Spectrum of a Noisy Chirp\n================================\n\nGenerate a noisy chirp and plot its energy spectrum.\n\nFigure 1.5 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, sigmerge, noisecg\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Generate a chirp signal\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\n\nsignal, _ = fmlin(n_points, fmin, fmax)\n\n# Noisy chirp\n\nnoisy_signal = sigmerge(signal, noisecg(128), 0)\n\n# Enery spectrum of the noisy chirp.\n\ndsp1 = np.fft.fftshift(np.abs(np.fft.fft(noisy_signal)) ** 2)\nplt.plot(np.arange(-64, 64, dtype=float) / 128.0, dsp1)\nplt.xlim(-0.5, 0.5)\nplt.title(\'Spectrum of Noisy Chirp\')\nplt.ylabel(\'Squared modulus\')\nplt.xlabel(\'Normalized Frequency\')\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_1_3_1_noisy_chirp_wv.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==========================================\nWigner-Ville Distribution of a Noisy Chirp\n==========================================\n\nGenerate a noisy chirp and visualize its Wigner-Ville spectrum.\n\nFigure 1.6 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, sigmerge, noisecg\nfrom tftb.processing.cohen import WignerVilleDistribution\n\n# Generate a chirp signal\n\nn_points = 128\nfmin, fmax = 0.0, 0.5\n\nsignal, _ = fmlin(n_points, fmin, fmax)\n\n# Noisy chirp\n\nnoisy_signal = sigmerge(signal, noisecg(128), 0)\n\n\n# Wigner-Ville spectrum of noisy chirp.\n\nwvd = WignerVilleDistribution(noisy_signal)\nwvd.run()\nwvd.plot(kind=\'contour\')\n'"
doc/_gallery/plot_1_3_3_transient.py,5,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================\nSpectrum of a Noisy Transient Signal\n====================================\n\nThis example shows how to generate a noisy transient signal with the following\ncharacteristics:\n\n    * One-sided exponential amplitude modulation (See :ref:`amexpos`)\n    * Constant frequency modulation (See :ref:`fmconst`)\n    * -5 dB complex gaussian noise (See :ref:`noisecg` and :ref:`sigmerge`)\n\nAnd how to plot its energy spectrum.\n\nFigure 1.10 of the tutorial.\n""""""\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import amexpos, fmconst, sigmerge, noisecg\n\n# Generate a noisy transient signal.\ntranssig = amexpos(64, kind=\'unilateral\') * fmconst(64)[0]\nsignal = np.hstack((np.zeros((100,)), transsig, np.zeros((92,))))\nsignal = sigmerge(signal, noisecg(256), -5)\nfig, ax = plt.subplots(2, 1)\nax1, ax2 = ax\nax1.plot(np.real(signal))\nax1.grid()\nax1.set_title(\'Noisy Transient Signal\')\nax1.set_xlabel(\'Time\')\nax1.set_xlim((0, 256))\nax1.set_ylim((np.real(signal).max(), np.real(signal.min())))\n\n# Energy spectrum of the signal\ndsp = np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\nax2.plot(np.arange(-128, 128, dtype=float) / 256, dsp)\nax2.set_title(\'Energy spectrum of noisy transient signal\')\nax2.set_xlabel(\'Normalized frequency\')\nax2.grid()\nax2.set_xlim(-0.5, 0.5)\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\n'"
doc/_gallery/plot_1_3_3_transient_spectrogram.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=======================================\nSpectrogram of a Noisy Transient Signal\n=======================================\n\nThis example demonstrates the simple use of a Spectrogram to localize a signal\nin time and frequency. The transient signal appears at the normalized frequency\n0.25 and between time points 125 and 160.\n\nFigure 1.11 from the tutorial.\n""""""\n\n\nimport numpy as np\nfrom scipy.signal import hamming\nfrom tftb.generators import amexpos, fmconst, sigmerge, noisecg\nfrom tftb.processing.cohen import Spectrogram\n\n# Generate a noisy transient signal.\ntranssig = amexpos(64, kind=\'unilateral\') * fmconst(64)[0]\nsignal = np.hstack((np.zeros((100,)), transsig, np.zeros((92,))))\nsignal = sigmerge(signal, noisecg(256), -5)\n\nfwindow = hamming(65)\nspec = Spectrogram(signal, n_fbins=128, fwindow=fwindow)\nspec.run()\nspec.plot(kind=""contour"", threshold=0.1, show_tf=False)\n'"
doc/_gallery/plot_2_2_1_time_freq_localization.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===============================================\nTime and Frequency Localization Characteristics\n===============================================\n\nGenerate a signal that has localized characteristics in both time and frequency\nand compute the following estimates:\n\n    * time center\n    * time duration\n    * frequency center\n    * frequency spreading\n\nExample 2.1 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, amgauss\nfrom tftb.processing import loctime, locfreq\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# generate signal\nsignal = fmlin(256)[0] * amgauss(256)\nplt.subplot(211), plt.plot(np.real(signal))\nplt.xlim(0, 256)\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Signal\')\nplt.grid()\nfsig = np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\nplt.subplot(212), plt.plot(np.linspace(0, 0.5, 256), fsig)\nplt.xlabel(\'Normalized frequency\')\nplt.ylabel(\'Squared modulus\')\nplt.title(\'Spectrum\')\nplt.grid()\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n\n\ntm, T = loctime(signal)\nprint(""Time Center: {}"".format(tm))\nprint(""Time Duration: {}"".format(T))\nnum, B = locfreq(signal)\nprint(""Frequency Center: {}"".format(num))\nprint(""Frequency Spreading: {}"".format(B))\n'"
doc/_gallery/plot_2_2_2_heisenberg_gabor_inequality.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==========================\nHeisenbeg-Gabor Inequality\n==========================\n\nThis example demonstrates the `Heisenberg-Gabor inequality\n<https://en.wikipedia.org/wiki/Uncertainty_principle#Signal_processing>`_.\n\nSimply put, the inequality states that the time-bandwidth product of a signal\nis lower bound by some constant (in this case normalized to unity). This means\nthat a signal cannot have arbitrarily high precision in time and frequency\nsimultaneously.\n\nFigure 2.2 from the tutorial.\n\n""""""\n\nfrom tftb.generators import amgauss\nfrom tftb.processing import loctime, locfreq\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# generate signal\nsignal = amgauss(256)\nplt.subplot(211), plt.plot(np.real(signal))\nplt.xlim(0, 256)\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Signal\')\nplt.grid()\nfsig = np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\nplt.subplot(212), plt.plot(np.linspace(0, 0.5, 256), fsig)\nplt.xlabel(\'Normalized frequency\')\nplt.ylabel(\'Squared modulus\')\nplt.title(\'Spectrum\')\nplt.grid()\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n\ntm, T = loctime(signal)\nprint(""Time Center: {}"".format(tm))\nprint(""Time Duration: {}"".format(T))\nfm, B = locfreq(signal)\nprint(""Frequency Center: {}"".format(fm))\nprint(""Frequency Spreading: {}"".format(B))\nprint(""Time-bandwidth product: {}"".format(T * B))\n'"
doc/_gallery/plot_2_3_instantaneous_frequency.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==============================================\nEstimate the Instantaneous Freuqncy of a Chirp\n==============================================\n\nConstruct a chirp and estimate its `instantaneous\nfrequency <https://en.wikipedia.org/wiki/Instantaneous_phase#Instantaneous_frequency>`_.\n\nFigure 2.3 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing import plotifl, inst_freq\n# TODO: There doesn\'t have to be something called `plotifl`. Put this into a\n# separate visualization module.\nimport numpy as np\n\n\nsignal, _ = fmlin(256)\ntime_samples = np.arange(3, 257)\nifr = inst_freq(signal)[0]\nplotifl(time_samples, ifr)\n'"
doc/_gallery/plot_2_4_group_delay.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=================================\nGroup Delay Estimation of a Chirp\n=================================\n\nConstuct a chirp and estimates its `group delay\n<https://en.wikipedia.org/wiki/Group_delay_and_phase_delay>`_.\n\nFigure 2.4 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing import group_delay\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsignal, _ = fmlin(256)\nfnorm = np.linspace(0, .5, 10)\ngd = group_delay(signal, fnorm)\nplt.plot(gd, fnorm)\nplt.grid(True)\nplt.xlim(0, 256)\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\nplt.title(\'Group Delay Estimation\')\nplt.show()\n'"
doc/_gallery/plot_2_4_grp_delay_inst_freq_comprison.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=====================================================\nComparison of Instantaneous Frequency and Group Delay\n=====================================================\n\nInstantaneous frequency and group delay are very closely related. The former is\nthe frequency of a signal at a given instant, and the latter is the time delay\nof frequency components. As this example shows, they coincide with each other\nfor a given signal when the time bandwidth product of the signal is\nsufficiently high.\n\nFigure 2.5 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import amgauss, fmlin\nfrom tftb.processing import loctime, locfreq, inst_freq, group_delay\n\ntime_instants = np.arange(2, 256)\nsig1 = amgauss(256, 128, 90) * fmlin(256)[0]\ntm, T1 = loctime(sig1)\nfm, B1 = locfreq(sig1)\nifr1 = inst_freq(sig1, time_instants)[0]\nf1 = np.linspace(0, 0.5 - 1.0 / 256, 256)\ngd1 = group_delay(sig1, f1)\n\nplt.subplot(211)\nplt.plot(time_instants, ifr1, \'*\', label=\'inst_freq\')\nplt.plot(gd1, f1, \'-\', label=\'group delay\')\nplt.xlim(0, 256)\nplt.grid(True)\nplt.legend()\nplt.title(""Time-Bandwidth product: {0}"".format(T1 * B1))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\n\n\nsig2 = amgauss(256, 128, 30) * fmlin(256, 0.2, 0.4)[0]\ntm, T2 = loctime(sig2)\nfm, B2 = locfreq(sig2)\nifr2 = inst_freq(sig2, time_instants)[0]\nf2 = np.linspace(0.02, 0.4, 256)\ngd2 = group_delay(sig2, f2)\n\n\nplt.subplot(212)\nplt.plot(time_instants, ifr2, \'*\', label=\'inst_freq\')\nplt.plot(gd2, f2, \'-\', label=\'group delay\')\nplt.ylim(0.2, 0.4)\nplt.xlim(0, 256)\nplt.grid(True)\nplt.legend()\nplt.title(""Time-Bandwidth product: {0}"".format(T2 * B2))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\n'"
doc/_gallery/plot_2_6_monocomp_nonstat_colored_gaussian_noise.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=========================\nNoisy Monocomponent Chirp\n=========================\n\nThis example demonstrates the construction of a monocomponent signal with\nlinear frequency modulation and colored Gaussian noise.\n\nFigure 2.9 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, amgauss, noisecg, sigmerge\nfrom numpy import real\nimport matplotlib.pyplot as plt\n\nfm, _ = fmlin(256)\nam = amgauss(256)\nsignal = fm * am\n\nnoise = noisecg(256, .8)\nsign = sigmerge(signal, noise, -10)\n\nplt.plot(real(sign))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Gaussian transient signal embedded in -10 dB colored Gaussian noise\')\nplt.xlim(0, 256)\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_2_6_monocomp_nonstat_constfreq_expamp.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================================================================================================\nMonocomponent Nonstationary Signal with Constant Frequency Modulation and One-Sided Exponential Amplitude Modulation\n====================================================================================================================\n\nGenerate a monocomponent nonstationary signal with constant frequency\nmodulation and one-sided exponential amplitude modulation.\n\nFigure 2.7 from the tutorial.\n""""""\n\nfrom tftb.generators import fmconst, amexpos\nimport matplotlib.pyplot as plt\nfrom numpy import real\n\nfm, _ = fmconst(256, 0.2)\nam = amexpos(256, 100, kind=\'unilateral\')\nsignal = am * fm\n\nplt.plot(real(signal))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Constant Frequency, One-sided Exponential Amplitude\')\nplt.xlim(0, 256)\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_2_6_monocomp_nonstat_doppler.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==============\nDoppler Signal\n==============\n\nGenerate a Doppler Signal.\n\nFigure 2.8 from the tutorial.\n""""""\n\nfrom tftb.generators import doppler\nfrom numpy import real\nimport matplotlib.pyplot as plt\n\nfm, am, _ = doppler(256.0, 200.0, 4000.0 / 60.0, 10.0, 50.0)\nsignal = am * fm\n\nplt.plot(real(signal))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Doppler\')\nplt.xlim(0, 256)\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_2_6_monocomp_nonstat_linfreq_gaussamp.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================================\nLinear Frequency and Gaussian Amplitude Modulation\n==================================================\n\nGenerate a mono-component nonstationary signal with linear frequency\nmodulation and Gaussian amplitude modulation.\n\n""""""\n\nfrom tftb.generators import fmlin, amgauss\nfrom numpy import real\nimport matplotlib.pyplot as plt\n\n\nfm, _ = fmlin(256)\nam = amgauss(256)\nsignal = fm * am\nplt.plot(real(signal))\nplt.xlabel(\'Time\')\nplt.ylabel(\'Real part\')\nplt.title(\'Linear Frequency, Gaussian Amplitude\')\nplt.xlim(0, 256)\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_2_7_multicomp_nonstat_instfreq_grpdlay.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=============================================================================================\nInstantatneous Frequency and Group Delay Estimation of a Multi-Component Nonstationary Signal\n=============================================================================================\n\nFigure 2.10 from the tutorial.\n""""""\n\n#  N=128; x1=fmlin(N,0,0.2); x2=fmlin(N,0.3,0.5);\n#  x=x1+x2;\n#  ifr=instfreq(x); subplot(211); plot(ifr);\n#  fn=0:0.01:0.5; gd=sgrpdlay(x,fn);\n#  subplot(212); plot(gd,fn);\nfrom tftb.generators import fmlin\nfrom tftb.processing import inst_freq, group_delay\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN = 128\nx1, _ = fmlin(N, 0, 0.2)\nx2, _ = fmlin(N, 0.3, 0.5)\nx = x1 + x2\nifr = inst_freq(x)[0]\nfn = np.arange(0.51, step=0.01)\ngd = group_delay(x, fn)\n\nplt.subplot(211)\nplt.plot(ifr)\nplt.xlim(1, N)\nplt.grid(True)\nplt.title(\'Instantaneous Frequency\')\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\n\nplt.subplot(212)\nplt.plot(gd, fn)\nplt.xlim(1, N)\nplt.grid(True)\nplt.title(\'Group Delay\')\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\n'"
doc/_gallery/plot_2_7_multicomp_nonstat_stft.py,8,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n======================================================================\nShort time Fourier transform of a multi-component nonstationary signal\n======================================================================\n\nCompute and visualize the `STFT <https://en.wikipedia.org/wiki/Short-time_Fourier_transform>`_ of a multi component nonstationary signal.\n\nFigure 2.11 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.linear import ShortTimeFourierTransform\nimport matplotlib.pyplot as plt\nfrom scipy.signal import hamming\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\n\nN = 128\nx1, _ = fmlin(N, 0, 0.2)\nx2, _ = fmlin(N, 0.3, 0.5)\nx = x1 + x2\n\nn_fbins = 128\nwindow = hamming(33)\ntfr, _, _ = ShortTimeFourierTransform(x, timestamps=None, n_fbins=n_fbins,\n                                      fwindow=window).run()\ntfr = tfr[:64, :]\nthreshold = np.amax(np.abs(tfr)) * 0.05\ntfr[np.abs(tfr) <= threshold] = 0.0 + 1j * 0.0\ntfr = np.abs(tfr) ** 2\nt = np.arange(tfr.shape[1])\nf = np.linspace(0, 0.5, tfr.shape[0])\n\nT, F = np.meshgrid(t, f)\n\nfig, axScatter = plt.subplots(figsize=(10, 8))\naxScatter.contour(T, F, tfr, 5)\naxScatter.grid(True)\naxScatter.set_title(\'Squared modulus of STFT\')\naxScatter.set_ylabel(\'Frequency\')\naxScatter.yaxis.set_label_position(""right"")\naxScatter.set_xlabel(\'Time\')\ndivider = make_axes_locatable(axScatter)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(x))\naxTime.set_xticklabels([])\naxTime.set_xlim(0, N)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\naxFreq.plot((abs(np.fft.fftshift(np.fft.fft(x))) ** 2)[::-1][:64], f[:64])\naxFreq.set_yticklabels([])\naxFreq.set_xticklabels([])\naxFreq.invert_xaxis()\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.grid(True)\nplt.show()\n'"
doc/_gallery/plot_3_1_2_spectrum.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================\nEnergy Spectrum of an Audio Signal\n==================================\n\nFigure 3.3 from the tutorial.\n""""""\n\nfrom os.path import dirname, abspath, join\nfrom scipy.io import loadmat\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nDATA_PATH = join(abspath(dirname(""__file__"")), ""data"", ""gabor.mat"")\nsignal = loadmat(DATA_PATH)[\'gabor\'].ravel()\ntime = np.arange(338)\ndsp = np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\nfreq = np.arange(-169, 169, dtype=float) / 338 * 1000\n\nplt.subplot(211)\nplt.plot(time, signal)\nplt.grid(True)\nplt.xlim(0, time.max())\nplt.xlabel(\'Time (ms)\')\n\nplt.subplot(212)\nplt.plot(dsp)\nplt.grid(True)\nplt.title(\'Spectrum\')\nplt.xlabel(\'Frequency (Hz)\')\n\nplt.subplots_adjust(hspace=0.5)\n\nplt.show()\n'"
doc/_gallery/plot_3_1_2_stft.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=======================\nSTFT of an Audio Signal\n=======================\n\nFigure 3.4 from the tutorial.\n""""""\n\nfrom os.path import dirname, abspath, join\nfrom scipy.io import loadmat\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nDATA_PATH = join(abspath(dirname(""__file__"")), ""data"", ""gabor.mat"")\nsignal = loadmat(DATA_PATH)[\'gabor\'].ravel()\ntfr = loadmat(DATA_PATH)[\'tfr\']\ntime = np.arange(338)\nfreq = np.arange(128, dtype=float) / 256.0 * 1000\n\nplt.contour(time, freq, tfr)\nplt.grid(True)\nplt.xlabel(\'Time  [ms]\')\nplt.ylabel(\'Frequency  [Hz]\')\nplt.title(\'Squared modulus of the STFT of the word GABOR\')\nplt.show()\n'"
doc/_gallery/plot_3_1_4_atoms_hamming_stft.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n============================================================\nSTFT of Gaussian Wave Packets with a Hamming Analysis Window\n============================================================\n\nThis example demonstrates the construction of a signal containing two transient\ncomponents, having the same Gaussian amplitude modulation and the same\nfrequency, but different time centers. It also shows the effect of a Hamming\nwindow function when used with th STFT.\n\nFigure 3.7 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import atoms\nfrom scipy.signal import hamming\nfrom tftb.processing.linear import ShortTimeFourierTransform\n\ncoords = np.array([[45, .25, 32, 1], [85, .25, 32, 1]])\nsig = atoms(128, coords)\nx = np.real(sig)\nwindow = hamming(65)\nstft = ShortTimeFourierTransform(sig, n_fbins=128, fwindow=window)\nstft.run()\nstft.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_1_4_atoms_short_hamming_stft.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n================================================\nTime-frequency Resolution: Short Analysis Window\n================================================\n\nThis example shows the effect of an analysis window which is short in time on\nthe time-frequency resolution. Specifically, smaller windows have good time\nresolutions but poor frequency resolutions.\n\nFigure 3.8 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import atoms\nfrom scipy.signal import hamming\nfrom tftb.processing.linear import ShortTimeFourierTransform\n\ncoords = np.array([[45, .25, 32, 1], [85, .25, 32, 1]])\nsig = atoms(128, coords)\nx = np.real(sig)\nwindow = hamming(17)\nstft = ShortTimeFourierTransform(sig, n_fbins=128, fwindow=window)\nstft.run()\nstft.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_1_4_frequency_resolution.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n================================================\nTime-frequency Resolution: Long Analysis Window\n================================================\n\nThis example shows the effect of an analysis window which is long in time on\nthe time-frequency resolution. Specifically, longer windows have good frequency\nresolutions but poor time resolutions.\n\nFigure 3.6 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.processing.linear import ShortTimeFourierTransform\nfrom tftb.generators import fmlin, amgauss\nimport matplotlib.pyplot as plt\n\nx = np.real(amgauss(128) * fmlin(128)[0])\nwindow = np.ones((128,))\nstft = ShortTimeFourierTransform(x, n_fbins=128, fwindow=window)\nstft.run()\nstft.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_1_4_time_resolution.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=====================\nIdeal time resolution\n=====================\n\nThis example demonstrates that only the shortest possible window can provide\nideal resolution in time.\n\nFigure 3.5 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.processing.linear import ShortTimeFourierTransform\nfrom tftb.generators import fmlin, amgauss\nfrom matplotlib.pyplot import cm\n\nx = np.real(amgauss(128) * fmlin(128)[0])\nwindow = np.array([1])\nstft = ShortTimeFourierTransform(x, n_fbins=128, fwindow=window)\ntfr, _, _ = stft.run()\n\nstft.plot(show_tf=True, cmap=cm.gray)\n'"
doc/_gallery/plot_3_3_2_biorthonormal_window.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=============================\nBiorthonormal Window Function\n=============================\n\nFigure 3.10 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.linear import gabor\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN1 = 256\nNg = 33\nQ = 1\nsig = fmlin(N1)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, Ng) ** 2)\nwindow = window / np.linalg.norm(window)\ntfr, dgr, h = gabor(sig, 16, Q, window)\nplt.plot(h)\nplt.ylim(top=0.5)\nplt.xlim(right=255)\nplt.title(\'Biorthonormal Window\')\nplt.grid()\nplt.show()\n'"
doc/_gallery/plot_3_3_2_biorthonormal_window_gabor.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===============================\nGabor Representation of a Chirp\n===============================\n\nFigure 3.11 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.linear import gabor\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN1 = 256\nNg = 33\nQ = 1\nsig = fmlin(N1)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, Ng) ** 2)\nwindow = window / np.linalg.norm(window)\ntfr, dgr, h = gabor(sig, 16, Q, window)\n\nplt.imshow(np.flipud(tfr)[8:, :], aspect=\'auto\', extent=[0, 16, 0, 0.5],\n           interpolation=\'none\')\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized frequency\')\nplt.title(\'Squared modulus of the Gabor coefficients\')\nplt.show()\n'"
doc/_gallery/plot_3_3_2_biorthonormal_window_oversampled.py,5,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=================================================\nGabor Representation of a Chirp with Oversampling\n=================================================\n\nFigure 3.13 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.linear import gabor\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nN1 = 256\nNg = 33\nQ = 4\nsig = fmlin(N1)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, Ng) ** 2)\nwindow = window / np.linalg.norm(window)\ntfr, dgr, h = gabor(sig, 32, Q, window)\ntime = np.arange(256)\nfreq = np.linspace(0, 0.5, 128)\nplt.imshow(np.flipud(tfr)[8:, :], aspect=\'auto\', extent=[0, 32, 0, 0.5],\n           interpolation=\'none\')\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized frequency\')\nplt.title(\'Squared modulus of the Gabor coefficients\')\nplt.show()\n'"
doc/_gallery/plot_3_4_1_chirps_spectrogram_long_gaussian.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===================================================================\nSpectrogram of Parallel Chirps with a Long Gaussian Analysis Window\n===================================================================\n\nThis example visualizes the spectrogram of two ""parallel"" chirps, using a\nGaussian window function that has a long length, relative to the length of a\nsignal. The two chirps can be made out, but interference can also be seen along\nthe time axis, since time resolution is compromised.\n\nFigure 3.16 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.cohen import Spectrogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsig = fmlin(128, 0, 0.4)[0] + fmlin(128, 0.1, 0.5)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, 63) ** 2)\nspec = Spectrogram(sig, fwindow=window, n_fbins=128)\nspec.run()\nspec.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_4_1_chirps_spectrogram_short_gaussian.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================================================\nSpectrogram of Parallel Chirps with Short Gaussian Analysis Window\n==================================================================\n\nThis example visualizes the spectrogram of two ""parallel"" chirps, using a\nGaussian window function that has a short length, relative to the length of a\nsignal. The two chirps can be made out, but interference can also be seen along\nthe frequency axis, since frequency resolution is compromised.\n\nFigure 3.15 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.cohen import Spectrogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsig = fmlin(128, 0, 0.4)[0] + fmlin(128, 0.1, 0.5)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, 23) ** 2)\nspec = Spectrogram(sig, fwindow=window, n_fbins=128)\nspec.run()\nspec.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_4_1_distant_components_long_gaussian.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===================================================\nDistant Chirps with a Long Gaussian Analysis Window\n===================================================\n\nThis example visualizes a spectrogram of two chirp signals which are well\nseparated in frequency ranges. A longer Gaussian analysis window suffices here\nto see the separation of frequencies, since the variation in frequencies is\nrelatively slow.\n\nFigure 3.18 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.cohen import Spectrogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsig = fmlin(128, 0, 0.3)[0] + fmlin(128, 0.2, 0.5)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, 63) ** 2)\nspec = Spectrogram(sig, fwindow=window, n_fbins=128)\nspec.run()\nspec.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_4_1_distant_components_short_gaussian.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================================\nDistant Chirps with a Short Gaussian Analysis Window\n====================================================\n\nFigure 3.17 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing.cohen import Spectrogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsig = fmlin(128, 0, 0.3)[0] + fmlin(128, 0.2, 0.5)[0]\nwindow = np.exp(np.log(0.005) * np.linspace(-1, 1, 23) ** 2)\nspec = Spectrogram(sig, fwindow=window, n_fbins=128)\nspec.run()\nspec.plot(show_tf=True, cmap=plt.cm.gray)\n'"
doc/_gallery/plot_3_4_2_morlet_scalogram_complex_sinusoids.py,7,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===========================================\nMorlet Scalogram of a Multicomponent Signal\n===========================================\n\nThis example demonstrates the visualization of the Morlet scalogram of a signal\ncontaining two complex sinusoids. In a scalogram, the frequency resolution\nvaries on the scale of the signal. Here, the frequency resolution decreases at\nhigher frequencies (lower scale).\n\nFigure 3.20 from the tutorial.\n""""""\n\nfrom tftb.processing import Scalogram\nfrom tftb.generators import fmconst\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\n\nsig2 = fmconst(128, .15)[0] + fmconst(128, .35)[0]\ntfr, t, freqs, _ = Scalogram(sig2, time_instants=np.arange(1, 129), waveparams=6,\n                         fmin=0.05, fmax=0.45, n_voices=128).run()\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\nt, f = np.meshgrid(t, freqs)\n\nfig, axContour = plt.subplots(figsize=(10, 8))\naxContour.contour(t, f, tfr)\naxContour.grid(True)\naxContour.set_title(""Morlet scalogram"")\naxContour.set_ylabel(\'Frequency\')\naxContour.yaxis.set_label_position(\'right\')\naxContour.set_xlabel(\'Time\')\n\ndivider = make_axes_locatable(axContour)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(sig2))\naxTime.set_xticklabels([])\naxTime.set_xlim(0, 128)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\nfreq_y = np.linspace(0, 0.5, sig2.shape[0] / 2)\nfreq_x = (abs(np.fft.fftshift(np.fft.fft(sig2))) ** 2)[::-1][:64]\naxFreq.plot(freq_x, freq_y)\naxFreq.set_ylim(0.05, 0.45)\naxFreq.set_yticklabels([])\naxFreq.set_xticklabels([])\naxFreq.grid(True)\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.invert_xaxis()\naxFreq.grid(True)\nplt.show()\n'"
doc/_gallery/plot_3_4_2_morlet_scalogram_dirac_impulse.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===================================\nMorlet Scalogram of a Dirac Impulse\n===================================\n\nThis example plots the scalogram of a Dirac impulse functions. This shows the\nbehaviour of the scalograms as the scale (or inversely, the frequency) changes.\nit is well localized for small scales (large frequencies), and less localized\nas the scale increases (as the frequency decreases).\n\nFigure 3.19 from the tutorial.\n""""""\n\nfrom tftb.generators import anapulse\nfrom tftb.processing import Scalogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsig1 = anapulse(128)\ntfr, t, f, _ = Scalogram(sig1, waveparams=6, fmin=0.05, fmax=0.45,\n                         n_voices=128).run()\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\nt, f = np.meshgrid(t, f)\nplt.contour(t, f, tfr, 20)\nplt.grid()\nplt.title(\'Morlet Scalogram of a Dirac Impluse\')\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\nplt.show()\n'"
doc/_gallery/plot_4_1_1_doppler_wigner_ville.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=============================================\nWigner-Ville Distribution of a Doppler Signal\n=============================================\n\nThis example shows the Wigner-Ville distribution of a Doppler signal. The\nsignal steadily rises and falls, but there are many interference terms present\nin the time-friequency plane, due to the bilinearity of the signal.\n\nFigure 4.2 from the tutorial.\n""""""\n\nfrom tftb.generators import doppler\nfrom tftb.processing import WignerVilleDistribution\n\nfm, am, iflaw = doppler(256, 50.0, 13.0, 10.0, 200.0)\nsig = am * fm\ndist = WignerVilleDistribution(sig)\ntfr, times, freqs = dist.run()\ndist.plot(show_tf=True, kind=""contour"", scale=""log"")\n'"
doc/_gallery/plot_4_1_1_pwv_atoms.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================================\nPseudo Wigner-Ville Distribution of Gaussian Atoms\n==================================================\n\nThis example shows the Pseudo Wigner-Ville distribution of four Gaussian atoms\nlocated at the corners of a rectangle in the time-frequency plane. The\n`PseudoWignerVilleDistribution` class uses frequency smoothing, which\nattenuates the interferences oscillating along the time axis.\n\nFigure 4.5 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import atoms\nfrom tftb.processing import PseudoWignerVilleDistribution\n\nx = np.array([[32, .15, 20, 1],\n             [96, .15, 20, 1],\n             [32, .35, 20, 1],\n             [96, .35, 20, 1]])\ng = atoms(128, x)\nt = np.linspace(0, 1, 128)\nspec = PseudoWignerVilleDistribution(g, timestamps=t)\nspec.run()\nspec.plot(kind=""contour"", scale=""log"", show_tf=True)\n'"
doc/_gallery/plot_4_1_1_wv_analytic_signal.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================================\nWigner Ville Distribution of Analytic Gaussian Atoms\n====================================================\n\nThis example shows the WVD of and analytic Gaussian atom. As seen in Figure\n4.6, the WVD of a real valued signal may present interference terms and\nspectral aliasing. One of the ways to fix this is to use an analytic signal,\nwhich divides the spectral domain into two parts: real and imaginary. Thus, the\nnumber of interference terms is also halved. Secondly, analytic signals have no\nnegative components, so the terms present in the negative half plane also\nvanish.\n\nFigure 4.7 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import atoms\nfrom tftb.processing import WignerVilleDistribution\n\nx = np.array([[32, .15, 20, 1],\n             [96, .32, 20, 1]])\ng = atoms(128, x)\nspec = WignerVilleDistribution(g)\nspec.run()\nspec.plot(show_tf=True, kind=""contour"", scale=""log"")\n'"
doc/_gallery/plot_4_1_1_wv_atoms.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===========================================\nWigner-Ville Distribution of Gaussian Atoms\n===========================================\n\nThis example shows the WV distribution of four Gaussian atoms, each localized\nat the corner of a rectangle in the time-frequency plane. The distribution does\nshow the four signal terms, as well as six interference terms.\n\nFigure 4.4 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import atoms\nfrom tftb.processing import WignerVilleDistribution\n\nx = np.array([[32, .15, 20, 1],\n             [96, .15, 20, 1],\n             [32, .35, 20, 1],\n             [96, .35, 20, 1]])\ng = atoms(128, x)\nspec = WignerVilleDistribution(g)\nspec.run()\nspec.plot(kind=""contour"", show_tf=True, scale=""log"")\n'"
doc/_gallery/plot_4_1_1_wv_real_signal.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n================================================================================\nSampling Effects on the Wigner-Ville Distribution of a Real Valued Gaussian Atom\n================================================================================\n\nThis example shows the Wigner-Ville distribution of a real valued Gaussian\natom. If a signal is sampled at the Nyquist rate, the WVD is affected by\nspectral aliasing and many additional interferences. To fix this, either the\nsignal may be oversampled, or an analytical signal may be used.\n\nFigure 4.6 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import atoms\nfrom tftb.processing import WignerVilleDistribution\n\nx = np.array([[32, .15, 20, 1],\n             [96, .32, 20, 1]])\ng = atoms(128, x)\nspec = WignerVilleDistribution(np.real(g))\nspec.run()\nspec.plot(kind=""contour"", show_tf=True, scale=""log"")\n'"
doc/_gallery/plot_4_1_1_wv_wireframe.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================\nWigner-Ville distribution of a Chirp\n====================================\n\nThis example shows the wireframe plot of the Wigner-Ville distribution of a\nchirp. The WV distribution can take negative values, and has almost perfect\nlocalization in the time-frequency plane.\n\nFigure 4.1 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin\nfrom tftb.processing import WignerVilleDistribution\n\nsig = fmlin(256)[0]\ntfr = WignerVilleDistribution(sig)\ntfr.run()\ntfr.plot(threshold=0.0, kind=\'wireframe\')\n'"
doc/_gallery/plot_4_1_2_sin_gauss_pwv.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==========================================================================\nPseudo-Wigner-Ville Distribution of a Gaussian Atom and a Complex Sinusoid\n==========================================================================\n\nThis example demonstrates the pseudo Wigner Ville distribution of a signal\ncomposed from a Gaussian atom and a complex sinusoid with constant frequency\nmodulation. Note that the frequency resolution is relatively worse than that of\nthe Wigner-Ville representation, and the interferences have not been resolved\nproperly.\n\nFigure 4.9 from the tutorial.\n""""""\n\nfrom tftb.generators import fmconst, amgauss\nfrom tftb.processing import PseudoWignerVilleDistribution\nimport numpy as np\n\nt = np.linspace(0, 1, 128)\nsig = fmconst(128, 0.15)[0] + amgauss(128) * fmconst(128, 0.4)[0]\ntfr = PseudoWignerVilleDistribution(sig, timestamps=t)\ntfr.run()\ntfr.plot(show_tf=True, kind=""contour"")\n'"
doc/_gallery/plot_4_1_2_sin_gauss_wv.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===================================================================\nWigner Ville distribution of a Gaussian Atom and a Complex Sinusoid\n===================================================================\n\nThis example demonstrates the Wigner Ville distribution of a signal\ncomposed from a Gaussian atom and a complex sinusoid with constant frequency\nmodulation. Although the representation does isolate the atom and the sinusoid\nas independent phenomena in the signal, it also produces some interference\nbetween them.\n\nFigure 4.8 from the tutorial.\n""""""\n\nfrom tftb.generators import fmconst, amgauss\nfrom tftb.processing import WignerVilleDistribution\n\nsig = fmconst(128, 0.15)[0] + amgauss(128) * fmconst(128, 0.4)[0]\ntfr = WignerVilleDistribution(sig)\ntfr.run()\ntfr.plot(show_tf=True, kind=\'contour\')\n'"
doc/_gallery/plot_4_1_3_chirps_ambifunb.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==============================================================\nNarrow Band Ambiguity Function of Chirps with Different Slopes\n==============================================================\n\nThis example demonstrates the narrow band ambiguity function (AF) of a signal\ncomposed of two chirps with Gaussian amplitude modulation but havind linear\nfrequency modulations with different slopes. Note that the AF interference\nterms are located away from the origin.\n\nFigure 4.13 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, amgauss\nfrom tftb.processing.ambiguity import narrow_band\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn_points = 64\nsig1 = fmlin(n_points, 0.2, 0.5)[0] * amgauss(n_points)\nsig2 = fmlin(n_points, 0.3, 0)[0] * amgauss(n_points)\nsig = np.hstack((sig1, sig2))\n\ntfr, x, y = narrow_band(sig)\nplt.contour(2 * x, y, np.abs(tfr) ** 2, 16)\nplt.title(\'Narrow Band ambiguity function\')\nplt.xlabel(\'Delay\')\nplt.ylabel(\'Doppler\')\nplt.grid(True)\nplt.show()\n'"
doc/_gallery/plot_4_1_3_chirps_wvd.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=========================================================\nWigner-Ville Distribution of Chirps with Different Slopes\n=========================================================\n\nThis example demonstrates the Wigner-Ville distribution of a signal\ncomposed of two chirps with Gaussian amplitude modulation but havind linear\nfrequency modulations with different slopes. Note that the AF interference\nterms are located away from the origin. We can see the two distint signal\nterms, but there is some interference around the middle.\n\nFigure 4.12 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, amgauss\nfrom tftb.processing import WignerVilleDistribution\nimport numpy as np\n\nn_points = 64\nsig1 = fmlin(n_points, 0.2, 0.5)[0] * amgauss(n_points)\nsig2 = fmlin(n_points, 0.3, 0)[0] * amgauss(n_points)\nsig = np.hstack((sig1, sig2))\n\ntfr = WignerVilleDistribution(sig)\ntfr.run()\ntfr.plot(kind=\'contour\', show_tf=True)\n'"
doc/_gallery/plot_4_1_4_margenau_hill.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n============================================================\nMargenau-Hill Representation of Chirps with Different Slopes\n============================================================\n\nThis example demonstrates the Margenau-Hill distribution of a signal\ncomposed of two chirps with Gaussian amplitude modulation but havind linear\nfrequency modulations with different slopes. This distribution too, like the\nWigner-Ville distribution, spearates the signal terms, but produces\ninterferences such that they appear diagonally opposite their corresponding\nsignals.\n\nFigure 4.14 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import atoms\nfrom tftb.processing import MargenauHillDistribution\n\n\nsig = atoms(128, np.array([[32, 0.15, 20, 1], [96, 0.32, 20, 1]]))\ntfr = MargenauHillDistribution(sig)\ntfr.run()\ntfr.plot(show_tf=True, kind=\'contour\', sqmod=False, threshold=0,\n         contour_y=np.linspace(0, 0.5, tfr.tfr.shape[0] / 2))\n'"
doc/_gallery/plot_4_2_2_bertrand_hyperbolic_gd.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n========================================================\nBertrand Distribution of a Hyperbolic Group Delay Signal\n========================================================\n\nThis example shows the Bertrand distribution of a signal with hyperbolic group\ndelay. The distribution is well localized around the hyperbola, but not\nperfectly. The Bertrand distribution operates only on a part of the frequency\nrange between two bounds :math:`f_{min}` and :math:`f_{max}`.\n\nFigure 4.21 from the tutorial.\n""""""\n\nfrom tftb.processing.affine import BertrandDistribution\nfrom tftb.generators import gdpower\n\n\nsig = gdpower(128)[0]\nbert = BertrandDistribution(sig, fmin=0.01, fmax=0.22)\nbert.run()\nbert.plot()\n'"
doc/_gallery/plot_4_2_2_dflandrin_hyperbolic_gd.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==========================================================\nD-Flandrin Distribution of a Hyperbolic Group Delay Signal\n==========================================================\n\nThis example shows the D-Flandrin distribution of a signal having hyperbolic\ngroup delay. This is the only type of distribution that almost perfectly\nlocalizes signals having a group delay in :math:`1 / \\sqrt{\\\\nu}`\n\nFigure 4.22 from the tutorial.\n""""""\n\nfrom tftb.processing import DFlandrinDistribution\nfrom tftb.generators import gdpower\n\nsig = gdpower(128, 1.0 / 2)[0]\nspec = DFlandrinDistribution(sig, fmin=0.01, fmax=0.22, n_voices=128)\nspec.run()\nspec.plot()\n'"
doc/_gallery/plot_4_2_2_morlet_scalogram_atoms.py,7,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==================================\nMorlet Scalogram of Gaussian Atoms\n==================================\n\nThis example demonstrates the effect of frequency-dependent smoothing that is\naccomplished in a Morlet scalogram. Note that the localization at lower\nfrequencies is much better.\n\nFigure 4.18 from the tutorial.\n\n""""""\n\nfrom tftb.processing import Scalogram\nfrom tftb.generators import atoms\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\n\nsig = atoms(128, np.array([[38, 0.1, 32, 1], [96, 0.35, 32, 1]]))\ntfr, t, freqs, _ = Scalogram(sig, fmin=0.05, fmax=0.45,\n                             time_instants=np.arange(1, 129)).run()\nt, f = np.meshgrid(t, freqs)\n\nfig, axContour = plt.subplots()\naxContour.contour(t, f, tfr)\naxContour.grid(True)\naxContour.set_title(""Morlet scalogram of complex sinusoids"")\naxContour.set_ylabel(\'Frequency\')\naxContour.yaxis.set_label_position(\'right\')\naxContour.set_xlabel(\'Time\')\n\ndivider = make_axes_locatable(axContour)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(sig))\naxTime.set_xticklabels([])\naxTime.set_xlim(0, 128)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\nfreq_y = np.linspace(0, 0.5, sig.shape[0] / 2)\nfreq_x = (abs(np.fft.fftshift(np.fft.fft(sig))) ** 2)[::-1][:64]\nix = np.logical_and(freq_y >= 0.05, freq_y <= 0.45)\naxFreq.plot(freq_x[ix], freq_y[ix])\n# axFreq.set_ylim(0.05, 0.45)\naxFreq.set_yticklabels([])\naxFreq.set_xticklabels([])\naxFreq.grid(True)\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.invert_xaxis()\naxFreq.grid(True)\nplt.show()\n'"
doc/_gallery/plot_4_2_2_unterberger_hyperbolic_gd.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===========================================================\nUnterberger distribution of a hyperbolic group delay signal\n===========================================================\n\nThe active Unterberger distribution is the only localized bi-frequency kernel\ndistribution which localizes perfectly signals having a group delay in\n:math:`1/\\\\nu^{2}`\n\nFigure 4.23 from the tutorial.\n""""""\n\nfrom tftb.processing import UnterbergerDistribution\nfrom tftb.generators import gdpower\n\nsig = gdpower(128, -1)[0]\ndist = UnterbergerDistribution(sig, fmin=0.01, fmax=0.22, n_voices=172)\ndist.run()\ndist.plot()\n'"
doc/_gallery/plot_4_2_3_impulse_wv.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=====================================================\nWigner-Ville Distribution of a Dirac Impulse Function\n=====================================================\n\nThis example demonstrates the Wigner-Ville distribution of a Dirac impulse\nfunction, and shows the limitations of the WV distribution when applied to\nbroadband signals.\n\nFigure 4.24 from the tutorial.\n""""""\n\nfrom tftb.generators import anapulse\nfrom tftb.processing import WignerVilleDistribution\n\nsig = anapulse(128)\nwvd = WignerVilleDistribution(sig)\nwvd.run()\nwvd.plot(kind=""contour"", scale=""log"")\n'"
doc/_gallery/plot_4_2_3_wideband_ambiguity.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==============================================\nWideband Ambiguity Function of an Altes Signal\n==============================================\n\nFor wideband signals, the narrow band ambiguity function is not appropriate for\nwideband signals. So we consider a wide band ambiguity function. This function\nis equivalent to the wavelet transform of a signal whose mother wavelet is the\nsignal itself.\n\nFigure 4.25 from the tutorial.\n\n""""""\n\nfrom tftb.generators import altes\nfrom tftb.processing.ambiguity import wide_band\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nsignal = altes(128, 0.1, 0.45)\nwaf, tau, theta = wide_band(signal, 0.1, 0.35, 64)\nplt.contour(tau, theta, np.abs(waf) ** 2)\nplt.xlabel(""Delay"")\nplt.ylabel(""Log(Scale)"")\nplt.title(""Wide Band Ambiguity Function"")\nplt.show()\n'"
doc/_gallery/plot_4_3_2_reassigned_spectrogram.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n========================================================\nComparison of a Spectrogram and a Reassigned Spectrogram\n========================================================\n\nThis example compares the spectrogram and the reassigned spectrogram of a\nhybrid signal (containing sinusoidal, constant and linear frequency\nmodulations), against its ideal time-frequency characteristics.\n\nFigure 4.34 from the tutorial.\n""""""\n\nfrom tftb.generators import fmsin, fmhyp\nfrom tftb.processing import ideal_tfr, reassigned_spectrogram, Spectrogram\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nn_points = 128\nsig1, if1 = fmsin(n_points, 0.15, 0.45, 100, 1, 0.4, -1)\nsig2, if2 = fmhyp(n_points, [1, .5], [32, 0.05])\nsig = sig1 + sig2\nideal, t, f = ideal_tfr(np.vstack((if1, if2)))\n_, re_spec, _ = reassigned_spectrogram(sig)\nspec, t3, f3 = Spectrogram(sig).run()\n\n# Ideal tfr\nplt.subplot(221)\nplt.contour(t, f, ideal, 1)\nplt.grid(True)\nplt.gca().set_xticklabels([])\nplt.title(""Ideal time-frequency distro"")\nplt.ylabel(\'Normalized Frequency\')\n\n# Spectrogram\nplt.subplot(222)\nplt.contour(t3, f3[:64], spec[:64, :])\nplt.grid(True)\nplt.gca().set_xticklabels([])\nplt.title(""Spectrogram"")\n\n# Reassigned Spectrogram\nplt.subplot(212)\nf = np.linspace(0, 0.5, 64)\nplt.contour(np.arange(128), f, re_spec[:64, :])\nplt.grid(True)\nplt.title(""Reassigned Spectrogram"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequency\')\n\nplt.show()\n'"
doc/_gallery/plot_4_3_6_friedman_instfreq_density.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n======================================================\nFriedman\'s Instantaneous Frequency Density Calculation\n======================================================\n\nThis example uses Friedman\'s method to calculate the instantaneous frequency\ndensity of a hybrid signal. The method consists of computing the histograms of\nfrequency displacements of the spectrogram of the signal.\n\nFigure 4.38 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import fmlin, fmsin, fmconst\nfrom tftb.processing.reassigned import pseudo_wigner_ville\nfrom tftb.processing.postprocessing import friedman_density\n\nsig1, if1 = fmsin(60, 0.16, 0.35, 50, 1, 0.35, 1)\nsig2, if2 = fmlin(60, 0.3, 0.1)\nsig3, if3 = fmconst(60, 0.4)\nsig = np.hstack((sig1, np.zeros((8,)), sig2 + sig3))\n\nt = np.arange(1, 128, step=2)\ntfr, rtfr, hat = pseudo_wigner_ville(sig, timestamps=t)\ntifd = friedman_density(tfr, hat, t)\nf = np.linspace(0, 0.5, tifd.shape[0])\n\nplt.contour(t, f, tifd, 4)\nplt.grid(True)\nplt.title(""Friedman\'s instantaenous frequency density"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Frequency\')\nplt.show()\n'"
doc/_gallery/plot_5_4_2_hough_noisy_chirp.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=================================\nWigner-Hough Transform of a Chirp\n=================================\n\nThis example demonstrates the use of the Hough transform to extract the\nestimates of a chirp signal from its Wigner Ville distribution.\n\nFigure 5.4 from the tutorial.\n""""""\n\nimport numpy as np\nfrom tftb.generators import noisecg, sigmerge, fmlin\nfrom tftb.processing.cohen import WignerVilleDistribution\nfrom tftb.processing.postprocessing import hough_transform\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.mplot3d import Axes3D\n\nN = 64\nsig = sigmerge(fmlin(N, 0, 0.3)[0], noisecg(N), 1)\ntfr, _, _ = WignerVilleDistribution(sig).run()\n\nht, rho, theta = hough_transform(tfr, N, N)\ntheta, rho = np.meshgrid(theta, rho)\nfig = plt.figure()\nax = fig.gca(projection=\'3d\')\nax.plot_wireframe(theta, rho, ht)\nax.set_xlabel(\'Theta\')\nax.set_ylabel(\'Rho\')\nplt.show()\n'"
doc/_gallery/plot_5_4_2_hough_simultaneous_chirp.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n=================================================\nHough-Wigner Transform of Two Simultaneous Chirps\n=================================================\n\nCompute the Hough transform of the Wigner-Ville distribution of a signal\ncomposed of two chirps. Two peaks corresponding to the two chirps can be seen.\n\nFigure 5.6 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, sigmerge\nfrom tftb.processing.cohen import WignerVilleDistribution\nfrom tftb.processing.postprocessing import hough_transform\nimport numpy as np\nfrom mpl_toolkits.mplot3d import Axes3D\nimport matplotlib.pyplot as plt\n\nN = 64\nsig = sigmerge(fmlin(N, 0, 0.4)[0], fmlin(N, 0.3, 0.5)[0], 1)\ntfr, _, _ = WignerVilleDistribution(sig).run()\n\nht, rho, theta = hough_transform(tfr, N, N)\ntheta, rho = np.meshgrid(theta, rho)\nfig = plt.figure()\nax = fig.gca(projection=\'3d\')\nax.plot_wireframe(theta, rho, ht)\nax.set_xlabel(\'Theta\')\nax.set_ylabel(\'Rho\')\nplt.show()\n'"
doc/_gallery/plot_5_4_2_wv_noisy_chirp.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n==========================================\nWigner-Ville Distribution of a Noisy Chirp\n==========================================\n\nThis example shows the Wigner-Ville distribution of a noisy chirp signal. The\nlinear frequency increase is undetectable in the time domain, but a straight\nline can be seen in the distribution.\n\nFigure 5.3 from the tutorial.\n""""""\n\nfrom tftb.generators import noisecg, sigmerge, fmlin\nfrom tftb.processing.cohen import WignerVilleDistribution\n\nN = 64\nsig = sigmerge(fmlin(N, 0, 0.3)[0], noisecg(N), 1)\nwvd = WignerVilleDistribution(sig)\nwvd.run()\nwvd.plot(kind=\'contour\', show_tf=True, sqmod=True)\n'"
doc/_gallery/plot_5_4_2_wv_simultaneous_chirp.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n====================================================\nWigner Ville Distribution of Two Simultaneous Chirps\n====================================================\n\nThe signal to be analyzed contains two linear frequency modulations, each with\na different slope. Note the interference between them.\n\nFigure 5.5 from the tutorial.\n""""""\n\nfrom tftb.generators import fmlin, sigmerge\nfrom tftb.processing.cohen import WignerVilleDistribution\n\nN = 64\nsig = sigmerge(fmlin(N, 0, 0.4)[0], fmlin(N, 0.3, 0.5)[0], 1)\ntfr = WignerVilleDistribution(sig)\ntfr.run()\ntfr.plot(kind=\'contour\', sqmod=True, show_tf=True)\n'"
doc/misc_plots/nonstationary_phase_plot.py,1,"b'from tftb.generators import fmlin, amgauss\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ny_nonstat, _ = fmlin(2048)  # Already analytic, no need of Hilbert transorm\ny_nonstat *= amgauss(2048)\nplt.plot(np.real(y_nonstat), np.imag(y_nonstat))\nplt.xlabel(""Real part"")\nplt.ylabel(""Imaginary part"")\nplt.show()\n'"
doc/misc_plots/stationary_phase_plot.py,4,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import hilbert\n\nfs = 32768\nts = np.linspace(0, 1, fs)\ny1 = np.sin(2 * np.pi * 697 * ts)\ny2 = np.sin(2 * np.pi * 1336 * ts)\ny = (y1 + y2) / 2\n\n\ny = y[:int(fs / 16)]\ny_analytic = hilbert(y)\nplt.plot(np.real(y_analytic), np.imag(y_analytic))\nplt.xlabel(""Real part"")\nplt.ylabel(""Imaginary part"")\nplt.show()\n'"
doc/misc_plots/touchtone.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Cube26 product code\n#\n# (C) Copyright 2015 Cube26 Software Pvt Ltd\n# All right reserved.\n#\n# This file is confidential and NOT open source.  Do not distribute.\n#\n\n""""""\n\n""""""\nimport numpy as np\nimport matplotlib.pyplot as plt\nfs = 32768\nts = np.linspace(0, 1, fs)\ny1 = np.sin(2 * np.pi * 697 * ts)\ny2 = np.sin(2 * np.pi * 1336 * ts)\ny = (y1 + y2) / 2\nplt.plot(ts, y)\nplt.xlim(0, 0.1)\nplt.show()\n'"
doc/misc_plots/touchtone_mean_convolve.py,6,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Cube26 product code\n#\n# (C) Copyright 2015 Cube26 Software Pvt Ltd\n# All right reserved.\n#\n# This file is confidential and NOT open source.  Do not distribute.\n#\n\n""""""\n\n""""""\nimport numpy as np\nimport matplotlib.pyplot as plt\nfs = 32768\nts = np.linspace(0, 1, fs)\ny1 = np.sin(2 * np.pi * 697 * ts)\ny2 = np.sin(2 * np.pi * 1336 * ts)\ny = (y1 + y2) / 2\n\nY = np.fft.fft(y)\nfreqs = np.arange(fs)\nplt.plot(freqs, np.abs(Y))\nplt.show()\n'"
doc/misc_plots/uncertainty_example_plot.py,2,"b'import numpy as np\nimport matplotlib.pyplot as plt\nf1, f2 = 500, 1000\nt1, t2 = 0.192, 0.196\nf_sample = 8000\nn_points = 2048\nts = np.arange(n_points, dtype=float) / f_sample\nsignal = np.sin(2 * np.pi * f1 * ts) + np.sin(2 * np.pi * f2 * ts)\nsignal[int(t1 * f_sample) - 1] += 3\nsignal[int(t2 * f_sample) - 1] += 3\nplt.plot(ts, signal)\nplt.show()\n'"
doc/misc_plots/uncertainty_stft.py,3,"b'import numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.processing import ShortTimeFourierTransform\nf1, f2 = 500, 1000\nt1, t2 = 0.192, 0.196\nf_sample = 8000\nn_points = 2048\nts = np.arange(n_points, dtype=float) / f_sample\nsignal = np.sin(2 * np.pi * f1 * ts) + np.sin(2 * np.pi * f2 * ts)\nsignal[int(t1 * f_sample) - 1] += 3\nsignal[int(t2 * f_sample) - 1] += 3\n\nwlengths = [2, 4, 8, 16]\nnf = [(w * 0.001 * f_sample) + 1 for w in wlengths]\nfig = plt.figure()\nextent = [0, ts.max(), 0, 2000]\nfor i, wlen in enumerate(wlengths):\n    window = np.ones((int(nf[i]),), dtype=float)\n    stft = ShortTimeFourierTransform(signal, fwindow=window)\n    stft.run()\n    ax = fig.add_subplot(4, 1, i + 1)\n    stft.plot(ax=ax, default_annotation=False, show=False,\n              extent=extent)\n    ax.set_yticklabels([])\n    if i != 3:\n        ax.set_xticklabels([])\n    ax.set_title(""window duration = {} ms"".format(wlen))\nplt.subplots_adjust(hspace=0.5)\nplt.show()\n'"
tftb/generators/__init__.py,0,"b""from .amplitude_modulated import amexpos, amgauss, amrect, amtriang\nfrom .frequency_modulated import (fmconst, fmhyp, fmlin, fmodany, fmpar,\n                                  fmpower, fmsin)\nfrom .utils import sigmerge, scale\nfrom .noise import dopnoise, noisecg, noisecu\nfrom .analytic_signals import (anaask, anabpsk, anafsk, anapulse, anaqpsk,\n                               anasing, anastep)\nfrom .misc import doppler, gdpower, klauder, mexhat, altes, atoms\n\n__all__ = ['amexpos', 'amgauss', 'amrect', 'amtriang', 'fmconst', 'fmhyp',\n           'fmlin', 'fmodany', 'fmpar', 'fmpower', 'fmsin', 'sigmerge',\n           'scale', 'dopnoise', 'noisecg', 'noisecu', 'anaask', 'anabpsk',\n           'anafsk', 'anapulse', 'anaqpsk', 'anasing', 'anastep',\n           'doppler', 'gdpower', 'klauder', 'mexhat', 'altes', 'atoms']\n"""
tftb/generators/amplitude_modulated.py,12,"b'import numpy as np\nfrom math import sqrt\n\n\ndef amgauss(n_points, t0=None, spread=None):\n    """"""Generate a Gaussian amplitude modulated signal.\n\n    :param n_points: Number of points in the output.\n    :param t0: Center of the Gaussian function. (default: t0 / 2)\n    :param spread: Standard deviation of the Gaussian. (default 2 *\n        sqrt(n_points)\n    :type n_points: int\n    :type t0: float\n    :type spread: float\n    :return: Gaussian function centered at time ``t0``.\n    :rtype: numpy.ndarray\n    :Example:\n    >>> x = amgauss(160)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amgauss1.py\n    >>> x = amgauss(160, 90)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amgauss2.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n\n    if spread is None:\n        spread = 2 * sqrt(n_points)\n\n    if n_points <= 0:\n        raise TypeError(""n_points should be >= 0"")\n    else:\n        tmt0 = np.arange(1, n_points + 1, dtype=float) - t0\n        y = np.exp(-((tmt0 / spread) ** 2) * np.pi)\n        return y\n\n\ndef amexpos(n_points, t0=None, spread=None, kind=""bilateral""):\n    """"""Exponential amplitude modulation.\n\n    `amexpos` generates an exponential amplitude modulation starting at time\n    `t0` and spread proportioanl to `spread`.\n\n    :param n_points: Number of points.\n    :param kind: ""bilateral"" (default) or ""unilateral""\n    :param t0: Time center.\n    :param spread: Standard deviation.\n    :type n_points: int\n    :type kind: str\n    :type t0: float\n    :type spread: float\n    :return: exponential function\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x = amexpos(160)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amexpos_bilateral.py\n    >>> x = amexpos(160, kind=\'unilateral\')\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amexpos_unilateral.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n    if spread is None:\n        spread = 2 * sqrt(n_points)\n\n    if n_points <= 0:\n        raise TypeError\n    else:\n        tmt0 = np.arange(n_points) - t0\n        if kind == ""bilateral"":\n            y = np.exp(-sqrt(2 * np.pi) * np.abs(tmt0) / spread)\n        else:\n            y = np.exp(-sqrt(np.pi) * tmt0 / spread) * (tmt0 >= 0.0)\n        return y\n\n\ndef amrect(n_points, t0=None, spread=None):\n    """"""Generate a rectangular amplitude modulation.\n\n    :param n_points: Number of points in the function.\n    :param t0: Time center\n    :param spread: standard deviation of the function.\n    :type n_points: int\n    :type t0: float\n    :type spread: float\n    :return: A rectangular amplitude modulator.\n    :rtype: numpy.ndarray.\n    :Examples:\n    >>> x = amrect(160, 90, 40.0)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amrect1.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n    if spread is None:\n        spread = 2 * sqrt(n_points)\n\n    if n_points <= 0:\n        raise TypeError\n    else:\n        tmt0 = np.arange(n_points) - t0\n        y = np.abs(tmt0) <= 0.5 * spread * sqrt(3.0 / np.pi)\n        return y\n\n\ndef amtriang(n_points, t0=None, spread=None):\n    """"""Generate a triangular amplitude modulation.\n\n    :param n_points: Number of points in the function.\n    :param t0: Time center\n    :param spread: standard deviation of the function.\n    :type n_points: int\n    :type t0: float\n    :type spread: float\n    :return: A triangular amplitude modulator.\n    :rtype: numpy.ndarray.\n    :Examples:\n    >>> x = amtriang(160)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/amplitude_modulated/amtriang1.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n    if spread is None:\n        spread = 2 * sqrt(n_points)\n\n    if n_points <= 0:\n        raise TypeError\n    else:\n        tmt0 = np.arange(n_points) - t0\n        L = sqrt(10.0 / np.pi) * spread / 2.0\n        t = np.amin(np.c_[L + tmt0, L - tmt0], axis=1)\n        t = np.c_[t, np.zeros(t.shape)]\n        y = np.amax(t, axis=1) / L\n\n        return y\n\n\nif __name__ == \'__main__\':\n    amgauss(128)\n    amexpos(128)\n    amrect(128)\n    amtriang(128)\n'"
tftb/generators/analytic_signals.py,28,"b'import numpy as np\nfrom numpy import pi\nfrom scipy.signal import hilbert\nfrom tftb.generators import fmconst\n\n\ndef anaask(n_points, n_comp=None, f0=0.25):\n    """"""Generate an amplitude shift (ASK) keying signal.\n\n    :param n_points: number of points.\n    :param n_comp: number of points of each component.\n    :param f0: normalized frequency.\n    :type n_points: int\n    :type n_comp: int\n    :type f0: float\n    :return: Tuple containing the modulated signal and the amplitude modulation.\n    :rtype: tuple(numpy.ndarray)\n    :Examples:\n    >>> x, am = anaask(512, 64, 0.05)\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(am)      #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anaask.py\n    """"""\n    if n_comp is None:\n        n_comp = round(n_points / 2.0)\n    if (f0 < 0) or (f0 > 0.5):\n        raise TypeError(""f0 must be between 0 and 0.5"")\n    m = int(np.ceil(n_points / n_comp))\n    jumps = np.random.rand(m)\n    am = np.repeat(jumps, n_comp)[:n_points]\n    fm, _ = fmconst(n_points, f0, 1)\n    y = am * fm\n    return y, am\n\n\ndef anabpsk(n_points, n_comp=None, f0=0.25):\n    """"""Binary phase shift keying (BPSK) signal.\n\n    :param n_points: number of points.\n    :param n_comp: number of points in each component.\n    :param f0: normalized frequency.\n    :type n_points: int\n    :type n_comp: int\n    :type f0: float\n    :return: BPSK signal\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x, am = anabpsk(300, 30, 0.1)\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(am)      #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anabpsk.py\n    """"""\n    if n_comp is None:\n        n_comp = round(n_points / 5.0)\n    if (f0 < 0) or (f0 > 0.5):\n        raise TypeError(""f0 must be between 0 and 0.5"")\n    m = int(np.ceil(n_points / n_comp))\n    jumps = 2.0 * np.round(np.random.rand(m)) - 1\n    am = np.repeat(jumps, n_comp)[:n_points]\n    y = am * fmconst(n_points, f0, 1)[0]\n    return y, am\n\n\ndef anafsk(n_points, n_comp=None, Nbf=4):\n    """"""Frequency shift keying (FSK) signal.\n\n    :param n_points: number of points.\n    :param n_comp: number of points in each components.\n    :param Nbf: number of distinct frequencies.\n    :type n_points: int\n    :type n_comp: int\n    :type Nbf: int\n    :return: FSK signal.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x, am = anafsk(512, 54.0, 5.0)\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(am)      #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anafsk.py\n    """"""\n    if n_comp is None:\n        n_comp = int(round(n_points / 5.0))\n    m = np.ceil(n_points / n_comp)\n    m = int(np.ceil(n_points / n_comp))\n    freqs = 0.25 + 0.25 * (np.floor(Nbf * np.random.rand(m, 1)) / Nbf - (Nbf - 1) / (2 * Nbf))\n    iflaw = np.repeat(freqs, n_comp).ravel()\n    y = np.exp(1j * 2 * pi * np.cumsum(iflaw))\n    return y, iflaw\n\n\ndef anapulse(n_points, ti=None):\n    """"""Analytic projection of unit amplitude impulse signal.\n\n    :param n_points: Number of points.\n    :param ti: time position of the impulse.\n    :type n_points: int\n    :type ti: float\n    :return: analytic impulse signal.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x = 2.5 * anapulse(512, 301)\n    >>> plot(real(x)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anapulse.py\n    """"""\n    if ti is None:\n        ti = np.round(n_points / 2)\n    t = np.arange(n_points)\n    x = t == ti\n    y = hilbert(x.astype(float))\n    return y\n\n\ndef anaqpsk(n_points, n_comp=None, f0=0.25):\n    """"""Quaternary Phase Shift Keying (QPSK) signal.\n\n    :param n_points: number of points.\n    :param n_comp: number of points in each component.\n    :param f0: normalized frequency\n    :type n_points: int\n    :type n_comp: int\n    :type f0: float\n    :return: complex phase modulated signal of normalized frequency f0 and\n        initial phase.\n    :rtype: tuple\n    :Examples:\n    >>> x, phase = anaqpsk(512, 64.0, 0.05)\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(phase)   #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anaqpsk.py\n    """"""\n    if n_comp is None:\n        n_comp = round(n_points / 5.0)\n    if (f0 < 0) or (f0 > 0.5):\n        raise TypeError(""f0 must be between 0 and 0.5"")\n    m = int(np.ceil(n_points / n_comp))\n    jumps = np.floor(4 * np.random.rand(m))\n    jumps[jumps == 4] = 3\n    pm0 = (np.pi * np.repeat(jumps, n_comp) / 2).ravel()\n    tm = np.arange(n_points) - 1\n    pm = 2 * np.pi * f0 * tm + pm0\n    y = np.exp(1j * pm)\n    return y, pm0\n\n\ndef anasing(n_points, t0=None, h=0.0):\n    """"""Lipschitz singularity.\n    Refer to the wiki page on `Lipschitz condition`, good test case.\n\n    :param n_points: number of points in time.\n    :param t0: time localization of singularity\n    :param h: strength of the singularity\n    :type n_points: int\n    :type t0: float\n    :type h: float\n    :return: N-point Lipschitz singularity centered around t0\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x = anasing(128)\n    >>> plot(real(x)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anasing.py\n    """"""\n    if t0 is None:\n        t0 = n_points / 2.0\n    if h <= 0:\n        start, end = 1.0 / n_points, 0.5 - 1.0 / n_points\n        N = end / start\n        f = np.linspace(start, end, N)\n        y = np.zeros((int(n_points / 2.0),), dtype=complex)\n        y[1:int(n_points / 2)] = (f ** (-1 - h)) * np.exp(-1j * 2 * pi * f * (t0 - 1))\n        x = np.real(np.fft.ifft(y, n_points))\n        x = x / x.max()\n        x = x - np.sign(x.min()) * np.abs(x.min())\n    else:\n        t = np.arange(n_points)\n        x = np.abs(t - t0) ** h\n        x = x.max() - x\n    x = hilbert(x)\n    return x\n\n\ndef anastep(n_points, ti=None):\n    """"""Analytic projection of unit step signal.\n\n    :param n_points: Number of points.\n    :param ti: starting position of unit step.\n    :type n_points: int\n    :type ti: float\n    :return: output signal\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x = anastep(256, 128)\n    >>> plot(real(x)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/analytic_signals/anastep.py\n    """"""\n    if ti is None:\n        ti = np.round(n_points / 2)\n    t = np.arange(n_points)\n    x = t > ti\n    y = hilbert(x.astype(float))\n    return y\n\n\nif __name__ == \'__main__\':\n    anaask(128)\n    anabpsk(128, 128)\n    anafsk(128)\n    anapulse(128)\n    anasing(128)\n    anastep(128)\n'"
tftb/generators/frequency_modulated.py,35,"b'import numpy as np\nfrom numpy import pi\nimport warnings\n\n\ndef fmconst(n_points, fnorm=0.25, t0=None):\n    """"""\n    Generate a signal with constant frequency modulation.\n\n    :param n_points: number of points\n    :param fnorm: normalized frequency\n    :param t0: time center\n    :type n_points: int\n    :type fnorm: float\n    :type t0: float\n    :return: frequency modulation signal with frequency fnorm\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> from tftb.generators import amgauss\n    >>> z = amgauss(128, 50, 30) * fmconst(128, 0.05, 50)[0]\n    >>> plot(real(z)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmconst.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n\n    if n_points <= 0:\n        raise TypeError\n    elif abs(fnorm) > 0.5:\n        raise TypeError\n    else:\n        tmt0 = np.arange(n_points) - t0\n        y = np.exp(1j * 2.0 * np.pi * fnorm * tmt0)\n        y = y / np.real(y[int(t0)])\n        iflaw = fnorm * np.ones((n_points,))\n        return y, iflaw\n\n\ndef fmhyp(n_points, p1, p2):\n    """"""Signal with hyperbolic frequency modulation.\n\n    :param n_points: number of points.\n    :param p1, p2: coefficients of the hyperbolic function.\n    :type n_points: int\n    :type p1: float\n    :type p2: float\n    :return: vector containing the modulated signal samples.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> signal, iflaw = fmhyp(128, (1, 0.5), (32, 0.1))\n    >>> subplot(211), plot(real(signal)) #doctest: +SKIP\n    >>> subplot(212), plot(iflaw)        #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmhyp.py\n    """"""\n    c = (p2[1] - p1[1]) / (1.0 / p2[0] - 1 / p1[0])\n    f0 = p1[1] - c / p1[0]\n\n    t = np.arange(1, n_points + 1)\n    phi = 2 * np.pi * (f0 * t + c * np.log(np.abs(t)))\n    iflaw = (f0 + c / np.abs(t))\n\n    a, b = iflaw < 0, iflaw > 0.5\n    aliasing = np.logical_or(a, b)\n    if np.any(aliasing):\n        msg = ""Signal may be undersampled or may have negative frequencies.""\n        warnings.warn(msg, UserWarning)\n\n    x = np.exp(1j * phi)\n\n    return x, iflaw\n\n\ndef fmlin(n_points, fnormi=0.0, fnormf=0.5, t0=None):\n    """"""\n    Generate a signal with linear frequency modulation.\n\n    :param n_points: number of points\n    :param fnormi: initial normalized frequency\n    :param fnormf: final normalized frequency\n    :param t0: time center\n    :type n_points: int\n    :type fnormi: float\n    :type fnormf: float\n    :type t0: float\n    :return: The modulated signal, and the instantaneous amplitude law.\n    :rtype: tuple(array-like)\n    :Examples:\n    >>> from tftb.generators import amgauss\n    >>> z = amgauss(128, 50, 40) * fmlin(128, 0.05, 0.3, 50)[0]\n    >>> plot(real(z)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmlin.py\n    """"""\n    if t0 is None:\n        t0 = round(n_points / 2.0)\n\n    if n_points <= 0:\n        raise TypeError\n\n    elif (abs(fnormi) > 0.5) or (abs(fnormf) > 0.5):\n        raise TypeError\n\n    else:\n        y = np.arange(1, n_points + 1)\n        y = fnormi * (y - t0) + ((fnormf - fnormi) / (2.0 * (n_points - 1))) * \\\n            ((y - 1) ** 2 - (t0 - 1) ** 2)\n        y = np.exp(1j * 2.0 * np.pi * y)\n        y = y / y[int(t0) - 1]\n        iflaw = np.linspace(fnormi, fnormf, n_points)\n        return y, iflaw\n\n\ndef fmodany(iflaw, t0=1):\n    """"""Arbitrary frequency modulation.\n\n    :param iflaw: Vector of instantaneous frequency law samples.\n    :param t0: time center\n    :type iflaw: numpy.ndarray\n    :type t0: float\n    :return: output signal\n    :rtype:\n    :Examples:\n    >>> from tftb.generators import fmlin\n    >>> import numpy as np\n    >>> y1, ifl1 = fmlin(100)  # A linear instantaneous frequency law.\n    >>> y2, ifl2 = fmsin(100)  # A sinusoidal instantaneous frequency law.\n    >>> iflaw = np.append(ifl1, ifl2)  # combination of the two\n    >>> sig = fmodany(iflaw)\n    >>> subplot(211), plot(real(sig)) #doctest: +SKIP\n    >>> subplot(212), plot(iflaw)     #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmodany.py\n    """"""\n    if len(iflaw.shape) > 1:\n        if iflaw.shape[1] != 1:\n            raise TypeError(""iflaw should be a column vector."")\n\n    elif np.amax(np.abs(iflaw)) > 0.5:\n        raise TypeError(""Elements of iflaw should be within -0.5 and 0.5"")\n\n    if (t0 > iflaw.shape[0]) or (t0 == 0):\n        raise TypeError(""T0 should be between 1 and len(iflaw)"")\n\n    y = np.exp(1j * 2.0 * pi * np.cumsum(iflaw))\n    y = y * np.conjugate(y[t0])\n    return y\n\n\ndef fmpar(n_points, coefficients):\n    """"""Parabolic frequency modulated signal.\n\n    :param n_points: number of points\n    :param coefficients: coefficients of the parabolic function.\n    :type n_points: int\n    :type coefficients: tuple\n    :return: Signal with parabolic frequency modulation law.\n    :rtype: tuple\n    :Examples:\n    >>> x, iflaw = fmpar(128, (0.4, -0.0112, 8.6806e-05))\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(iflaw)   #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmpar.py\n    """"""\n    a0, a1, a2 = coefficients\n    t = np.arange(n_points)\n    phi = 2 * np.pi * (a0 * t + (a1 / 2 * t) ** 2 + (a2 / 3 * t) ** 3)\n    iflaw = a0 + a1 * t + a2 * (t ** 2)\n    a, b = iflaw < 0, iflaw > 0.5\n    aliasing = np.logical_or(a, b)\n    if np.any(aliasing):\n        msg = ""Signal may be undersampled or may have negative frequencies.""\n        warnings.warn(msg, UserWarning)\n    x = np.exp(1j * phi)\n    return x, iflaw\n\n\ndef fmpower(n_points, k, coefficients):\n    """"""Generate signal with power law frequency modulation.\n\n    :param n_points: number of points.\n    :param k: degree of power law.\n    :param p1, p2: coefficients of the power law.\n    :type n_points: int\n    :type k: int\n    :type p1: float\n    :type p2: float\n    :return: vector of modulated signal samples.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x, iflaw = fmpower(128, 0.5, (1, 0.5, 100, 0.1))\n    >>> subplot(211), plot(real(x)) #doctest: +SKIP\n    >>> subplot(212), plot(iflaw)   #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmpower.py\n    """"""\n    if len(coefficients) == 2:\n        f0, c = coefficients\n    elif len(coefficients) > 2:\n        p1 = coefficients[:2]\n        p2 = coefficients[2:]\n        c = (p2[1] - p1[1]) / (1.0 / (p2[0] ** k) - 1.0 / (p1[0] ** k))\n        f0 = p1[1] - c / (p1[0] ** k)\n    t = np.arange(n_points)\n    phi = 2 * np.pi * (f0 * t + c / (1 - k) * np.abs(t) ** (1 - k))\n    iflaw = (f0 + c * np.abs(t) ** (-k))\n    a, b = iflaw < 0, iflaw > 0.5\n    aliasing = np.logical_or(a, b)\n    if np.any(aliasing):\n        msg = ""Signal may be undersampled or may have negative frequencies.""\n        warnings.warn(msg, UserWarning)\n\n    x = np.exp(1j * phi)\n    return x, iflaw\n\n\ndef fmsin(n_points, fnormin=0.05, fnormax=0.45, period=None, t0=None,\n          fnorm0=None, pm1=1):\n    """"""Sinusodial frequency modulation.\n\n    :param n_points: number of points\n    :param fnormin: smallest normalized frequency\n    :param fnormax: highest normalized frequency\n    :param period: period of sinusoidal fm\n    :param t0: time reference\n    :param fnorm0: normalized frequency at time t0\n    :param pm1: frequency direction at t0\n    :type n_points: int\n    :type fnormin: float\n    :type fnormax: float\n    :type period: int\n    :type t0: float\n    :type fnorm0: float\n    :type pm1: int\n    :return: output signal\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> z = fmsin(140, period=100, t0=20, fnorm0=0.3, pm1=-1)\n    >>> plot(real(z)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/frequency_modulated/fmsin.py\n    """"""\n    if period is None:\n        period = n_points\n    if t0 is None:\n        t0 = n_points / 2.0\n    if fnorm0 is None:\n        fnorm0 = 0.5 * (fnormin + fnormax)\n\n    fnormid = 0.5 * (fnormax + fnormin)\n    delta = 0.5 * (fnormax - fnormin)\n    phi = -pm1 * np.arccos((fnorm0 - fnormid) / delta)\n    t = np.arange(n_points) - t0\n    phase = 2 * pi * fnormid * t + delta * period * (np.sin(2 * pi * t / period + phi)) -\\\n        np.sin(phi)\n    y = np.exp(1j * phase)\n    iflaw = fnormid + delta * np.cos(2 * pi * t / period + phi)\n    return y, iflaw\n\n\nif __name__ == \'__main__\':\n    fmconst(128)\n    fmhyp(128, (1, 0.5), (32, 0.1))\n    fmlin(128)\n    fmodany(np.random.rand(128) - 0.5)\n    fmpar(128, (0.4, -0.0112, 8.6806e-05))\n    fmpower(128, 0.5, (1, 0.5, 100, 0.1))\n    fmsin(128)\n'"
tftb/generators/misc.py,45,"b'import numpy as np\nfrom numpy import pi\nfrom math import sqrt\nfrom tftb.generators.amplitude_modulated import amgauss\nfrom tftb.generators.frequency_modulated import fmconst\n\n\ndef altes(n_points, fmin=0.05, fmax=0.5, alpha=300):\n    """"""Generate the Altes signal in time domain.\n\n    :param n_points: Number of points in time.\n    :param fmin: Lower frequency bound.\n    :param fmax: Higher frequency bound.\n    :param alpha: Attenuation factor of the envelope.\n    :type n_points: int\n    :type fmin: float\n    :type fmax: float\n    :type alpha: float\n    :return: Time vector containing the Altes signal samples.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> x = altes(128, 0.1, 0.45)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/misc/altes.py\n    """"""\n    g = np.exp((np.log(fmax / fmin)) ** 2 / (8 * np.log(alpha)))\n    nu0 = np.sqrt(fmin * fmax)\n    beta = np.sqrt(2 * np.log(g) * np.log(alpha))\n    t0 = n_points / (np.exp(beta) - np.exp(-beta))\n    t1 = t0 * np.exp(-beta)\n    t2 = t0 * np.exp(beta)\n    b = -t0 * nu0 * g * np.log(g)\n    t = np.linspace(t1, t2, n_points + 1)[:n_points]\n    x = np.exp(-(np.log(t / t0) ** 2) / (2 * np.log(g))) * \\\n        np.cos(2 * pi * b * np.log(t / t0) / np.log(g))\n    x = x / np.linalg.norm(x)\n    return x\n\n\ndef atoms(n_points, coordinates):\n    """"""Compute linear combination of elementary Gaussian atoms.\n\n    :param n_points: Number of points in a signal\n    :param coordinates: matrix of time-frequency centers\n    :type n_points: int\n    :type coordinates: array-like\n    :return: signal\n    :rtype: array-like\n    :Examples:\n    >>> import numpy as np\n    >>> coordinates = np.array([[32.0, 0.3, 32.0, 1.0], [0.15, 0.15, 48.0, 1.22]])\n    >>> sig = atoms(128, coordinates)\n    >>> plot(real(sig)) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/misc/atoms.py\n    """"""\n    if coordinates.ndim == 1:\n        coordinates = coordinates.reshape((coordinates.shape[0], 1))\n    signal = np.zeros((n_points,), dtype=complex)\n    n_atoms = coordinates.shape[0]\n    for k in range(n_atoms):\n        t0 = round(np.max((np.min((coordinates[k, 0], n_points)), 1)))\n        f0 = np.max((np.min((coordinates[k, 1], 0.5)), 0.0))\n        T = coordinates[k, 2]\n        A = coordinates[k, 3]\n        signal += A * amgauss(n_points, t0, T) * fmconst(n_points, f0, t0)[0]\n    return signal\n\n\ndef doppler(n_points, s_freq, f0, distance, v_target, t0=None, v_wave=340.0):\n    """"""Generate complex Doppler signal\n\n    :param n_points: Number of points\n    :param s_freq: Sampling frequency\n    :param f0: Target frequency\n    :param distance: distance from line to observer\n    :param v_target: Target velocity\n    :param t0: Time center\n    :param v_wave: wave velocity.\n    :type n_points: int\n    :type s_freq: float\n    :type f0: float\n    :type distance: float\n    :type v_target: float\n    :type t0: float\n    :type v_wave: float\n    :return: Tuple containing output frequency modulator, output amplitude \\\n        modulator, output instantaneous frequency law.\n    :rtype: tuple\n    :Example:\n    >>> fm, am, iflaw = doppler(512, 200.0, 65.0, 10.0, 50.0)\n    >>> subplot(211), plot(real(am * fm)) #doctest: +SKIP\n    >>> subplot(211), plot(iflaw)         #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/misc/doppler.py\n    """"""\n    if t0 is None:\n        t0 = n_points / 2\n\n    if distance <= 0.0:\n        raise TypeError(""distance must be strictly positive."")\n    elif s_freq < 0.0:\n        raise TypeError(""Sampling frequency must be positive."")\n    elif (t0 < 1) or (t0 > n_points):\n        raise TypeError(""T0 must be between 1 and n_points"")\n    elif (f0 < 0) or (f0 > s_freq / 2):\n        raise TypeError(""F0 must be between 0 and s_freq/2"")\n    elif v_target < 0:\n        raise TypeError(""v_target must be positive"")\n\n    tmt0 = (np.arange(1, n_points + 1) - t0) / s_freq\n    dist = np.sqrt(distance ** 2 + (v_target * tmt0) ** 2)\n    fm = np.exp(1j * 2 * pi * f0 * (tmt0 - dist / v_wave))\n    if np.abs(f0) < np.spacing(1):\n        am = 0\n    else:\n        am = 1. / np.sqrt(dist)\n    iflaw = (1 - v_target ** 2 * tmt0 / dist / v_wave) * f0 / s_freq\n    return fm, am, iflaw\n\n\ndef klauder(n_points, attenuation=10.0, f0=0.2):\n    """"""Klauder wavelet in time domain.\n\n    :param n_points: Number of points in time.\n    :param attenuation: attenuation factor of the envelope.\n    :param f0: central frequency of the wavelet.\n    :type n_points: int\n    :type attenuation: float\n    :type f0: float\n    :return: Time row vector containing klauder samples.\n    :rtype: numpy.ndarray\n    :Example:\n    >>> x = klauder(128)\n    >>> plot(x) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/misc/klauder.py\n    """"""\n\n    assert n_points > 0\n    assert ((f0 < 0.5) and (f0 > 0))\n\n    f = np.linspace(0., 0.5, int(n_points / 2 + 1))\n    mod = np.exp(-2. * np.pi * attenuation * f) * f ** (2. * np.pi * attenuation * f0 - 0.5)\n    wave = mod\n    wave[0] = 0\n    a, b = wave[:int(n_points / 2)], wave[1:int(n_points / 2 + 1)][::-1]\n    wave = np.hstack((a, b))\n    wavet = np.fft.ifft(wave)\n    wavet = np.fft.fftshift(wavet)\n    x = np.real(wavet) / np.linalg.norm(wavet)\n    return x\n\n\ndef mexhat(nu=0.05):\n    """"""Mexican hat wavelet in time domain.\n\n    :param nu: Central normalized frequency of the wavelet. Must be a real \\\n        number between 0 and 0.5\n    :type nu: float\n    :return: time vector containing mexhat samples.\n    :rtype: numpy.ndarray\n    :Example:\n    >>> plot(mexhat()) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/misc/mexhat.py\n    """"""\n    assert (nu <= 0.5) and (nu >= 0)\n    n_points = 1.5\n    alpha = np.pi ** 2 * nu ** 2\n    n = np.ceil(n_points / nu)\n    t = np.arange(-n, n + 1, step=1)\n    h = nu * sqrt(pi) / 2 * np.exp(-alpha * t ** 2) * (1 - 2 * alpha * t ** 2)\n    return h\n\n\ndef gdpower(n_points, degree=0.0, rate=1.0):\n    """"""Generate a signal with a power law group delay.\n\n    :param n_points: Number of points in time.\n    :param degree: degree of the power law.\n    :param rate: rate-coefficient of the power law GD.\n    :type n_points: int\n    :type degree: float\n    :type rate: float\n    :return: Tuple of time row containing modulated samples, group delay, \\\n            frequency bins.\n    :rtype: tuple\n    """"""\n    n_points = int(n_points)\n    degree = float(degree)\n    rate = float(rate)\n    t0 = 0\n    lnu = int(np.ceil(n_points / 2.0))\n    nu = np.linspace(0, 0.5, lnu + 1)\n    nu = nu[1:]\n    am = nu ** ((degree - 2.0) / 6.0)\n\n    if rate == 0.:\n        raise TypeError(""rate must be non-zero"")\n\n    tfx = np.zeros((n_points,), dtype=complex)\n\n    if (degree < 1.) and (degree != 0):\n        d = float(n_points) ** (degree * rate)\n        t0 = n_points / 10.0\n        tfx[:lnu] = np.exp(-1.0j * 2. * pi * (t0 * nu + d * nu ** degree / degree)) * am\n        x = np.fft.ifft(tfx)\n    elif degree == 0:\n        d = rate\n        t0 = n_points / 10.0\n        tfx[:lnu] = np.exp(-1j * 2 * np.pi * (t0 * nu + d * np.log(nu))) * am\n        x = np.fft.ifft(tfx)\n    elif degree == 1.:\n        from tftb.generators.analytic_signals import anapulse\n        t0 = n_points\n        x = anapulse(n_points, t0)\n    elif degree > 1.:\n        d = n_points * 2. ** (degree - 1.) * rate\n        tfx[:lnu] = np.exp(-1.0j * 2.0 * pi * (t0 * nu + d * nu ** degree / degree)) * am\n        x = np.fft.ifft(tfx)\n    else:\n        t0 = n_points / 10\n        d = n_points * 2.0 ** (degree - 1.0) * rate\n        tfx[:lnu] = np.exp(-1j * 2 * pi * (t0 * nu + d * np.log(nu))) * am\n        x = np.fft.ifft(tfx)\n\n    if degree != 1.0:\n        gpd = t0 + np.abs(np.sign(rate) - 1.0) / 2.0 * (n_points + 1.0) + d * nu ** (degree - 1.0)\n    else:\n        gpd = t0 * np.ones((n_points / 2.0,))\n\n    x = x - x.mean()\n    x = x / np.linalg.norm(x)\n\n    return x, gpd, nu\n\n\nif __name__ == ""__main__"":\n    altes(128)\n    coordinates = np.array([[32.0, 0.3, 32.0, 1.0],\n                            [0.15, 0.15, 48.0, 1.22]])\n    atoms(128, coordinates)\n    doppler(128, 200.0, 65.0, 10.0, 50.0)\n    klauder(128)\n    mexhat()\n    gdpower(128)\n'"
tftb/generators/noise.py,20,"b'import numpy as np\nfrom tftb.utils import nextpow2\nfrom scipy.signal import hilbert\n\n\ndef noisecu(n_points):\n    """"""Compute analytic complex uniform white noise.\n\n    :param n_points: Length of the noise signal.\n    :type n_points: int\n    :return: analytic complex uniform white noise signal of length N\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> import matplotlib.pyplot as plt\n    >>> import numpy as np\n    >>> noise = noisecu(512)\n    >>> print(""%.2f"" % abs((noise ** 2).mean()))\n    0.00\n    >>> print(""%.1f"" % np.std(noise) ** 2)\n    1.0\n    >>> plt.subplot(211), plt.plot(real(noise))                                #doctest: +SKIP\n    >>> plt.subplot(212),  #doctest: +SKIP\n    >>> plt.plot(linspace(-0.5, 0.5, 512), abs(fftshift(fft(noise))) ** 2) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/noise/noisecu.py\n    """"""\n    if n_points <= 2:\n        noise = (np.random.rand(n_points, 1) - 0.5 + 1j * (np.random.rand(n_points, 1) - 0.5)) * \\\n            np.sqrt(6)\n    else:\n        noise = np.random.rand(2 ** int(nextpow2(n_points)),) - 0.5\n        noise = hilbert(noise) / noise.std() / np.sqrt(2)\n        inds = noise.shape[0] - np.arange(n_points - 1, -1, step=-1) - 1\n        noise = noise[inds]\n    return noise\n\n\ndef noisecg(n_points, a1=None, a2=None):\n    """"""\n    Generate analytic complex gaussian noise with mean 0.0 and variance 1.0.\n\n    :param n_points: Length of the desired output signal.\n    :param a1:\n        Coefficients of the filter through which the noise is passed.\n    :param a2:\n        Coefficients of the filter through which the noise is passed.\n    :type n_points: int\n    :type a1: float\n    :type a2: float\n    :return: Analytic complex Gaussian noise of length n_points.\n    :rtype: numpy.ndarray\n    :Examples:\n    >>> import matplotlib.pyplot as plt\n    >>> import numpy as np\n    >>> noise = noisecg(512)\n    >>> print(""%.1f"" % abs((noise ** 2).mean()))\n    0.0\n    >>> print(""%.1f"" % np.std(noise) ** 2)\n    1.0\n    >>> plt.subplot(211), plt.plot(real(noise))                                #doctest: +SKIP\n    >>> plt.subplot(212), #doctest: +SKIP\n    >>> plt.plot(linspace(-0.5, 0.5, 512), abs(fftshift(fft(noise))) ** 2) #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/noise/noisecg.py\n    """"""\n    assert n_points > 0\n    if n_points <= 2:\n        noise = (np.random.randn(n_points, 1.) + 1j * np.random.randn(n_points, 1.)) / np.sqrt(2.)\n    else:\n        noise = np.random.normal(size=int(2. ** nextpow2(float(n_points)),))\n        noise = hilbert(noise) / noise.std() / np.sqrt(2.)\n        noise = noise[len(noise) - np.arange(n_points - 1, -1, -1) - 1]\n    return noise\n\n\ndef dopnoise(n_points, s_freq, f_target, distance, v_target,\n             time_center=None, c=340):\n    """"""Generate complex noisy doppler signal, normalized to have unit energy.\n\n    :param n_points: Number of points.\n    :param s_freq: Sampling frequency.\n    :param f_target: Frequency of target.\n    :param distance: Distnace from line to observer.\n    :param v_target: velocity of target relative to observer.\n    :param time_center: Time center. (Default n_points / 2)\n    :param c: Wave velocity (Default 340 m/s)\n    :type n_points: int\n    :type s_freq: float\n    :type f_target: float\n    :type distance: float\n    :type v_target: float\n    :type time_center: float\n    :type c: float\n    :return: tuple (output signal, instantaneous frequency law.)\n    :rtype: tuple(array-like)\n    :Example:\n    >>> import numpy as np\n    >>> from tftb.processing import inst_freq\n    >>> z, iflaw = dopnoise(500, 200.0, 60.0, 10.0, 70.0, 128.0)\n    >>> subplot(211), plot(real(z))                #doctest: +SKIP\n    >>> ifl = inst_freq(z, np.arange(11, 479), 10)\n    >>> subplot(212), plot(iflaw, \'r\', ifl, \'g\')   #doctest: +SKIP\n\n    .. plot:: docstring_plots/generators/noise/dopnoise.py\n    """"""\n    if time_center is None:\n        time_center = np.floor(n_points / 2.0)\n\n    r = 0.9\n    rr = r ** 2\n    r2 = 2 * r\n    vv = v_target ** 2\n    x = np.random.randn(2 * n_points,)\n    tmt0 = (np.arange(1, 2 * n_points + 1, dtype=float) - time_center - n_points) / s_freq\n    dist = np.sqrt(distance ** 2 + (v_target * tmt0) ** 2)\n    iflaw = (1 - vv * tmt0 / dist / c) * f_target / s_freq\n    y = np.zeros((2 * n_points,))\n    for t in range(2, 2 * n_points):\n        y[t] = x[t] - rr * (x[t - 2] + y[t - 2]) + r2 * np.cos(2.0 * np.pi * iflaw[t]) * y[t - 1]\n    y = hilbert(y[(n_points + 1): (2 * n_points + 1)]) /\\\n        np.sqrt(dist[(n_points + 1): (2 * n_points + 1)])\n    y = y / np.sqrt(np.sum(np.abs(y) ** 2))\n    iflaw = iflaw[(n_points + 1):(2 * n_points + 1)]\n    return y, iflaw\n\n\nif __name__ == ""__main__"":\n    n = noisecg(128)\n'"
tftb/generators/utils.py,27,"b'import numpy as np\nfrom scipy.signal import hilbert\nfrom scipy.integrate import trapz\n# from tftb.utils import nextpow2\n\n\ndef sigmerge(x1, x2, ratio=0.0):\n    """"""\n    Add two signals with a specific energy ratio in decibels.\n\n    :param x1: 1D numpy.ndarray\n    :param x2: 1D numpy.ndarray\n    :param ratio: Energy ratio in decibels.\n    :type x1: numpy.ndarray\n    :type x2: numpy.ndarray\n    :type ratio: float\n    :return: The merged signal\n    :rtype: numpy.ndarray\n    """"""\n    assert x1.ndim == 1\n    assert x2.ndim == 1\n    assert type(ratio) in (float, int)\n    ex1 = np.mean(np.abs(x1) ** 2)\n    ex2 = np.mean(np.abs(x2) ** 2)\n    h = np.sqrt(ex1 / (ex2 * 10 ** (ratio / 10.0)))\n    sig = x1 + h * x2\n    return sig\n\n\ndef scale(X, a, fmin, fmax, N):\n    """"""Scale a signal with the Mellin transform.\n\n    :param X: signal to be scaled.\n    :param a: scale factor\n    :param fmin: lower frequency bound\n    :param fmax: higher frequency bound\n    :param N: number of analyzed voices\n    :type X: array-like\n    :type a: float\n    :type fmin: float\n    :type fmax: float\n    :type N: int\n    :return: A-scaled version of X.\n    :rtype: array-like\n    """"""\n    Z = hilbert(np.real(X))\n    T = X.shape[0]\n    M = (T + np.remainder(T, 2)) / 2\n\n    # B = fmax - fmin\n    # R = B / ((fmin + fmax) / 2)\n    # Nq = np.ceil((B * T * (1 + 2.0 / R)) * np.log())\n    # Nmin = Nq - np.remainder(Nq, 2)\n    # Ndflt = 2 ** nextpow2(Nmin)\n\n    # Geometric sampling of the analyzed spectrum\n    k = np.arange(N)\n    q = (fmax / float(fmin)) ** (1.0 / (N - 1.0))\n    geo_f = fmin * np.exp((k - 1) * np.log(q))\n    t = np.arange(X.shape[0]) - M - 1\n    tfmatx = np.exp(-2 * 1j * np.dot(t.reshape(128, 1), geo_f.reshape(1, 128)) * np.pi)\n    ZS = np.dot(Z, tfmatx)\n    ZS = np.hstack((ZS, np.zeros((N,))))\n\n    # Mellin transform computation of the analyzed signal\n    p = np.arange(2 * N)\n    MS = np.fft.fftshift(np.fft.ifft(ZS, axis=0))\n    beta = (p / float(N) - 1.0) / (2 * np.log(q))\n\n    # Inverse mellin and fourier transform.\n    Mmax = np.amax(np.ceil(X.shape[0] / 2.0 * a))\n    if isinstance(a, np.ndarray):\n        S = np.zeros((2 * Mmax, a.shape[0]), dtype=complex)\n    else:\n        S = np.zeros((2 * Mmax,), dtype=complex)\n        ptr = 0\n        DMS = np.exp(-2 * np.pi * 1j * beta * np.log(a)) * MS\n        DS = np.fft.fft(np.fft.fftshift(DMS), axis=0)\n        Mcurrent = np.ceil(a * X.shape[0] / 2)\n        t = np.arange(-Mcurrent, Mcurrent) - 1\n        itfmatx = np.exp(2 * 1j * np.pi * np.dot(t.reshape((256, 1)),\n                                                 geo_f.reshape((1, 128))))\n        dilate_sig = np.zeros((2 * Mcurrent,), dtype=complex)\n        for kk in range(2 * int(Mcurrent)):\n            dilate_sig[kk] = trapz(itfmatx[kk, :] * DS[:N], geo_f)\n        S[(Mmax - Mcurrent):(Mmax + Mcurrent)] = dilate_sig\n        ptr += 1\n\n    S = S * np.linalg.norm(X) / np.linalg.norm(S)\n    return S\n\n\nif __name__ == \'__main__\':\n    from tftb.generators import altes\n    sig = altes(256, 0.1, 0.45, 10000)\n'"
tftb/processing/__init__.py,0,"b""from tftb.processing.time_domain import loctime\nfrom tftb.processing.freq_domain import locfreq, inst_freq, group_delay\nfrom tftb.processing.plotifl import plotifl\nfrom tftb.processing.cohen import (\n    WignerVilleDistribution, PseudoWignerVilleDistribution,\n    smoothed_pseudo_wigner_ville, MargenauHillDistribution, Spectrogram)\nfrom tftb.processing.reassigned import spectrogram as reassigned_spectrogram\nfrom tftb.processing.reassigned import smoothed_pseudo_wigner_ville as \\\n    reassigned_smoothed_pseudo_wigner_ville\nfrom tftb.processing.postprocessing import ideal_tfr, renyi_information\nfrom tftb.processing.affine import (\n    Scalogram, BertrandDistribution, DFlandrinDistribution, UnterbergerDistribution)\nfrom tftb.processing.linear import ShortTimeFourierTransform\n\n__all__ = ['loctime', 'locfreq', 'inst_freq', 'group_delay', 'plotifl',\n           'WignerVilleDistribution', 'PseudoWignerVilleDistribution',\n           'smoothed_pseudo_wigner_ville', 'MargenauHillDistribution', 'Spectrogram',\n           'reassigned_spectrogram', 'reassigned_smoothed_pseudo_wigner_ville',\n           'ideal_tfr', 'renyi_information', 'Scalogram', 'BertrandDistribution',\n           'DFlandrinDistribution', 'UnterbergerDistribution', 'ShortTimeFourierTransform']\n"""
tftb/processing/affine.py,196,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nBilinear Time-Frequency Processing in the Affine Class.\n""""""\n\nimport numpy as np\nfrom scipy.signal import hilbert\nfrom scipy.optimize import brenth, newton\nfrom scipy.interpolate import splrep, splev\nfrom tftb.generators import mexhat, scale\nfrom tftb.processing.utils import integrate_2d\nfrom tftb.processing.base import BaseTFRepresentation\nfrom tftb.utils import nextpow2\n\n\nclass AffineDistribution(BaseTFRepresentation):\n\n    isaffine = True\n\n    def __init__(self, signal, fmin=None, fmax=None, **kwargs):\n        super(AffineDistribution, self).__init__(signal, **kwargs)\n        if signal.ndim == 2:\n            self.kind = ""cross""\n            self.x1, self.x2 = self.signal[:, 0].copy(), self.signal[:, 1].copy()\n        else:\n            self.kind = ""auto""\n            self.x1 = self.x2 = self.signal.copy()\n        self.s1 = np.real(self.x1)\n        self.s2 = np.real(self.x2)\n        self.m = (self.signal.shape[0] + (self.signal.shape[0] % 2)) // 2\n        if (fmin is None) or (fmax is None):\n            stf1 = np.fft.fft(\n                np.fft.fftshift(self.s1[self.ts.min(): self.ts.max() + 1])\n            )\n            stf2 = np.fft.fft(\n                np.fft.fftshift(self.s2[self.ts.min(): self.ts.max() + 1])\n            )\n            nstf = stf1.shape[0]\n            sp1 = np.abs(stf1[: int(np.round(nstf / 2))]) ** 2\n            sp2 = np.abs(stf2[: int(np.round(nstf / 2))]) ** 2\n            maxsp1 = sp1.max()\n            maxsp2 = sp2.max()\n            f = np.linspace(0, 0.5, np.round(nstf / 2) + 1)\n            if fmin is None:\n                mask = sp1 > maxsp1 / 100\n                indmin = np.arange(mask.shape[0], dtype=int)[mask.astype(bool)].min()\n                fmin = max([0.01, 0.05 * np.floor(f[indmin] / 0.05)])\n            if fmax is None:\n                mask = sp2 > maxsp2 / 100\n                indmax = np.arange(mask.shape[0], dtype=int)[mask.astype(bool)].max()\n                fmax = 0.05 * np.ceil(f[indmax] / 0.05)\n        self.fmax, self.fmin = fmax, fmin\n        self.bw = fmax - fmin\n        self.R = self.bw / (fmin + fmax) * 2\n\n    def _get_nvoices(self):\n        q = (\n            self.bw\n            * self.T\n            * (1 + 2 / self.R)\n            * np.log((1 + self.R / 2) / (1 - self.R / 2))\n        )\n        nq = np.ceil(q / 2)\n        nmin = nq - nq % 2\n        ndflt = 2 ** nextpow2(nmin)\n        self.n_voices = int(ndflt)\n\n    def _normalize(self):\n        SP1 = np.fft.fft(hilbert(self.s1), axis=0)\n        SP2 = np.fft.fft(hilbert(self.s2), axis=0)\n        indmin = 1 + int(np.round(self.fmin * (self.ts.shape[0] - 2)))\n        indmax = 1 + int(np.round(self.fmax * (self.ts.shape[0] - 2)))\n        sp1_ana = SP1[(indmin - 1): indmax]\n        sp2_ana = SP2[(indmin - 1): indmax]\n        return sp1_ana, sp2_ana\n\n    def _geometric_sample(self):\n        k = np.arange(1, self.n_voices + 1)\n        self.q = (self.fmax / self.fmin) ** (1 / (self.n_voices - 1))\n        t = np.arange(1, self.signal.shape[0] + 1) - self.m - 1\n        geo_f = self.fmin * np.exp((k - 1) * np.log(self.q))\n        self.geo_f = geo_f\n        tfmatx = np.exp(-2j * np.dot(t.reshape(-1, 1), geo_f.reshape(1, -1)) * np.pi)\n        S1 = np.dot(self.s1.reshape(1, self.s1.shape[0]), tfmatx)\n        S2 = np.dot(self.s2.reshape(1, self.s2.shape[0]), tfmatx)\n        S1 = np.append(S1, np.zeros((self.n_voices, )))\n        S2 = np.append(S2, np.zeros((self.n_voices, )))\n        return S1, S2\n\n    def _mellin_transform(self, S1, S2):\n        p = np.arange(2 * self.n_voices)\n        mellin1 = np.fft.fftshift(np.fft.ifft(S1))\n        mellin2 = np.fft.fftshift(np.fft.ifft(S2))\n        umin = -self.umax\n        du = np.abs(self.umax - umin) / (2 * self.m1)\n        u = np.linspace(umin, self.umax - du, (self.umax - umin) / du)\n        u[int(self.m1)] = 0\n        self.u = u\n        beta = (p / float(self.n_voices) - 1) / (2 * np.log(self.q))\n        return beta, mellin1, mellin2\n\n    def plot(self, kind=""contour"", show_tf=True, threshold=0.05, **kwargs):\n        _thresh = np.amax(self.tfr) * threshold\n        self.tfr[self.tfr <= _thresh] = 0\n        freq_y = kwargs.pop(\n            ""freq_y"", np.linspace(self.fmin, self.fmax, self.signal.shape[0] / 2)\n        )\n\n        super(AffineDistribution, self).plot(\n            kind=kind, show_tf=show_tf, freq_y=freq_y, **kwargs\n        )\n\n    def _get_interpolated_tf(self, tffr):\n        tfr = np.zeros((self.n_voices, self.ts.shape[0]))\n        ts2 = (self.signal.shape[0] - 1) / 2\n        gamma = np.linspace(\n            -self.geo_f[self.n_voices - 1] * ts2,\n            self.geo_f[self.n_voices - 1] * ts2,\n            2 * self.m1,\n        )\n        for i in range(self.n_voices):\n            condition = np.logical_and(\n                gamma >= -self.geo_f[i] * ts2, gamma <= self.geo_f[i] * ts2\n            )\n            ind = np.nonzero(np.ravel(condition))[0]\n            x = gamma[ind]\n            y = tffr[i, ind]\n            xi = (self.ts - ts2) * self.geo_f[i]\n            tck = splrep(x, y)\n            tfr[i, :] = splev(xi, tck).ravel()\n        t = self.ts\n        f = self.geo_f.ravel()\n        self.freqs = f\n        sp1_ana, sp2_ana = self._normalize()\n        if self.kind == ""auto"":\n            multiplier = np.linalg.norm(sp1_ana) ** 2\n        else:\n            multiplier = np.dot(sp1_ana, sp2_ana)\n        tfr = tfr * multiplier / integrate_2d(tfr, t, f) / self.n_voices\n        self.tfr = tfr\n        return tfr, t, f\n\n    def run(self):\n        raise NotImplementedError\n\n\nclass Scalogram(AffineDistribution):\n    """"""Morlet Scalogram.\n    """"""\n\n    name = ""scalogram""\n    isaffine = False\n\n    def __init__(\n        self, signal, fmin=None, fmax=None, n_voices=None, waveparams=None, **kwargs\n    ):\n        super(Scalogram, self).__init__(signal, fmin=fmin, fmax=fmax)\n        if waveparams is None:\n            waveparams = np.sqrt(signal.shape[0])\n        if n_voices is None:\n            n_voices = self.signal.shape[0]\n        self.n_voices = n_voices\n        self.waveparams = waveparams\n        s_centered = np.real(self.signal) - np.real(self.signal).mean()\n        self.z = hilbert(s_centered)\n        self.tfr = self.tfr.astype(complex)\n\n    def run(self):\n        f = np.logspace(np.log10(self.fmin), np.log10(self.fmax), self.n_voices)\n        a = np.logspace(\n            np.log10(self.fmax / float(self.fmin)), np.log10(1), self.n_voices\n        )\n        wt = np.zeros((self.n_voices, self.ts.shape[0]), dtype=complex)\n        if self.waveparams > 0:\n            for ptr in range(self.n_voices):\n                nha = self.waveparams * a[ptr]\n                tha = np.arange(-int(np.round(nha)), int(np.round(nha)) + 1)\n                x = np.exp(-(2 * np.log(10) / (nha ** 2)) * tha ** 2)\n                y = np.exp(1j * 2 * np.pi * f[ptr] * tha)\n                ha = x * y\n                detail = np.convolve(self.z, ha) / np.sqrt(a[ptr])\n                ix = np.arange(\n                    int(np.round(nha)),\n                    detail.shape[0] - int(np.round(nha)) + 1,\n                    dtype=int,\n                )\n                wt[ptr, :] = detail[self.ts]\n                detail = detail[ix]\n                self.tfr[ptr, :] = detail[self.ts] * np.conj(detail[self.ts])\n        elif self.waveparams == 0:\n            for ptr in range(self.n_voices):\n                ha = mexhat(f[ptr])\n                nha = (ha.shape[0] - 1) / 2\n                detail = np.convolve(self.z, ha) / np.sqrt(a[ptr])\n                ix = np.arange(\n                    int(np.round(nha)) + 1, detail.shape[0] - int(np.round(nha)) + 1\n                )\n                detail = detail[ix]\n                wt[ptr, :] = detail[self.ts]\n                self.tfr[ptr, :] = detail[self.ts] * np.conj(detail[self.ts])\n        elif isinstance(self.waveparams, np.ndarray):\n            rwav, cwav = self.waveparams.shape\n            if cwav > rwav:\n                self.waveparams = self.waveparams.T\n            wavef = np.fft.fft(self.waveparams, axis=0)\n            nwave = self.waveparams.shape[0]\n            f0 = wavef[\n                np.abs(wavef[: nwave / 2]) == np.amax(np.abs(wavef[: nwave / 2]))\n            ]\n            f0 = ((f0 - 1) * (1 / nwave)).mean()\n            a = np.logspace(\n                np.log10(f0 / float(self.fmin)),\n                np.log10(f0 / float(self.fmax)),\n                self.n_voices,\n            )\n            B = 0.99\n            R = B / (1.001 / 2)\n            nscale = max(\n                [\n                    128,\n                    np.round(\n                        (B * nwave * (1 + 2 / R) * np.log((1 + R / 2) / (1 - R / 2)))\n                        / 2\n                    ),\n                ]\n            )\n            wts = scale(self.waveparams, a, self.fmin, self.fmax, nscale)\n            for ptr in range(self.n_voices):\n                ha = wts[ptr, :]\n                nha = ha.shape[0] / 2\n                detail = np.convolve(self.z, ha) / np.sqrt(a[ptr])\n                detail = detail[int(np.floor(nha)): (detail.shape[0] - np.round(nha))]\n                wt[ptr, :] = detail[self.ts]\n                self.tfr[ptr, :] = detail[self.ts] * np.conj(detail[self.ts])\n\n        # Normalization\n        SP = np.fft.fft(self.z, axis=0)\n        indmin = 1 + int(np.round(self.fmin * (self.signal.shape[0] - 2)))\n        indmax = 1 + int(np.round(self.fmax * (self.signal.shape[0] - 2)))\n        SPana = SP[indmin: (indmax + 1)]\n        self.tfr = np.real(self.tfr)\n        self.tfr *= (np.linalg.norm(SPana) ** 2) / integrate_2d(self.tfr, self.ts, f)\n        self.tfr /= self.n_voices\n        return self.tfr, self.ts, f, wt\n\n\nclass UnterbergerDistribution(AffineDistribution):\n\n    name = ""unterberger""\n\n    def __init__(self, signal, form=""A"", fmin=None, fmax=None, n_voices=None, **kwargs):\n        self.form = form\n        super(UnterbergerDistribution, self).__init__(\n            signal, fmin=fmin, fmax=fmax, n_voices=n_voices, **kwargs\n        )\n\n        def umaxunt(x):\n            a = np.sqrt(1 + (x / 2) ** 2)\n            return (a + (x / 2)) / (a - (x / 2)) - self.fmax / self.fmin\n\n        self.umax = newton(umaxunt, 0)\n        self.m = (self.signal.shape[0] + (self.signal.shape[0] % 2)) // 2\n        teq = self.m / (self.fmax * self.umax)\n        if teq < 2 * self.m:\n            m0 = int(np.round((2 * self.m ** 2) / teq - self.m)) + 1\n            m1 = self.m + m0\n            self.T = 2 * (self.m + m0) - 1\n        else:\n            m0 = 0\n            m1 = self.m\n        self.m1 = int(np.round(m1))\n        if n_voices is None:\n            self._get_nvoices()\n        else:\n            self.n_voices = n_voices\n\n    def run(self):\n        S1, S2 = self._geometric_sample()\n        beta, mellin1, mellin2 = self._mellin_transform(S1, S2)\n        # Computation for lambda dilations/compressions\n        waf = np.zeros((2 * self.m1, self.n_voices), dtype=complex)\n        _x = -(2 * 1j * np.pi * beta + 0.5)\n        for n in range(1, 2 * self.m1 + 1):\n            _y = np.log(np.sqrt(1 + (self.u[n - 1] / 2) ** 2) - self.u[n - 1] / 2)\n            mx1 = np.exp(_x * _y) * mellin1\n            _y = np.log(np.sqrt(1 + (self.u[n - 1] / 2) ** 2) + self.u[n - 1] / 2)\n            mx2 = np.exp(_x * _y) * mellin2\n            fx1 = np.fft.fft(np.fft.fftshift(mx1))[: self.n_voices]\n            fx2 = np.fft.fft(np.fft.fftshift(mx2))[: self.n_voices]\n            waf[n - 1, :] = fx1 * np.conj(fx2)\n            if self.form != ""A"":\n                waf[n - 1, :] *= 1 / np.sqrt(1 + (self.u[n] / 2) ** 2)\n        waf = np.vstack((waf[self.m1: (2 * self.m1), :], waf[: self.m1, :]))\n        waf *= np.repeat(\n            self.geo_f.reshape((1, self.geo_f.shape[0])), 2 * self.m1, axis=0\n        )\n        tffr = np.fft.ifft(waf, axis=0)\n        tffr = np.real(\n            np.rot90(\n                np.vstack((tffr[self.m1: (2 * self.m1 + 1), :], tffr[: self.m1, :])),\n                k=-1,\n            )\n        )\n        # conversion from tff to tf using 1d interpolation\n        tfr = np.zeros((self.n_voices, self.ts.shape[0]))\n        ts2 = (self.signal.shape[0] - 1) / 2\n        gamma = np.linspace(\n            -self.geo_f[self.n_voices - 1] * ts2,\n            self.geo_f[self.n_voices - 1] * ts2,\n            2 * self.m1,\n        )\n        for i in range(self.n_voices):\n            condition = np.logical_and(\n                gamma >= -self.geo_f[i] * ts2, gamma <= self.geo_f[i] * ts2\n            )\n            ind = np.nonzero(np.ravel(condition))[0]\n            x = gamma[ind]\n            y = tffr[i, ind]\n            xi = (self.ts - ts2 - 1) * self.geo_f[i]\n            tck = splrep(x, y)\n            tfr[i, :] = splev(xi, tck).ravel()\n        t = self.ts\n        f = self.freqs = self.geo_f[: self.n_voices].ravel()\n        sp1_ana, sp2_ana = self._normalize()\n\n        if self.kind == ""auto"":\n            multiplier = np.linalg.norm(sp1_ana) ** 2\n        else:\n            multiplier = np.dot(sp1_ana, sp2_ana)\n\n        tfr = tfr * multiplier / integrate_2d(tfr, t, f) / self.n_voices\n        self.tfr = tfr\n        return tfr, t, f\n\n\nclass DFlandrinDistribution(AffineDistribution):\n\n    name = ""d-flandrin""\n\n    def __init__(self, signal, fmin=None, fmax=None, n_voices=None, **kwargs):\n        super(DFlandrinDistribution, self).__init__(\n            signal, fmin=fmin, fmax=fmax, n_voices=n_voices, **kwargs\n        )\n        self.umax = umaxdfla_solve(self.fmax / self.fmin)\n        teq = self.m / (self.fmax * self.umax)\n        if teq < 2 * self.m:\n            m0 = int(round((2 * self.m ** 2) / teq - self.m)) + 1\n            self.T = 2 * (self.m + m0) - 1\n        else:\n            m0 = 0\n        self.m1 = int(np.round(self.m + m0))\n        if n_voices is None:\n            self._get_nvoices()\n        else:\n            self.n_voices = n_voices\n\n    def run(self):\n        S1, S2 = self._geometric_sample()\n        beta, mellin1, mellin2 = self._mellin_transform(S1, S2)\n        # Computation of Lambda dilations/compressions\n        waf = np.zeros((2 * self.m1, self.n_voices), dtype=complex)\n        for n in range(1, 2 * self.m1 + 1):\n            mx1 = (\n                np.exp(\n                    -(2 * 1j * np.pi * beta + 0.5) * 2 * np.log(1 - self.u[n - 1] / 4)\n                )\n                * mellin1\n            )\n            mx2 = (\n                np.exp(\n                    -(2 * 1j * np.pi * beta + 0.5) * 2 * np.log(1 + self.u[n - 1] / 4)\n                )\n                * mellin2\n            )\n            fx1 = np.fft.fft(np.fft.fftshift(mx1))[: self.n_voices]\n            fx2 = np.fft.fft(np.fft.fftshift(mx2))[: self.n_voices]\n            waf[n - 1, :] = fx1 * np.conj(fx2)\n        waf = np.vstack((waf[self.m1: (2 * self.m1), :], waf[: self.m1, :]))\n        waf *= np.repeat(\n            self.geo_f.reshape((1, self.geo_f.shape[0])), 2 * self.m1, axis=0\n        )\n        tffr = np.fft.ifft(waf, axis=0)\n        tffr = np.real(\n            np.rot90(\n                np.vstack((tffr[self.m1: (2 * self.m1 + 1), :], tffr[: self.m1, :])),\n                k=-1,\n            )\n        )\n        # conversion from tff to tf using 1d interpolation\n        return self._get_interpolated_tf(tffr)\n\n\nclass BertrandDistribution(AffineDistribution):\n\n    name = ""bertrand""\n\n    def __init__(self, signal, fmin=None, fmax=None, n_voices=None, **kwargs):\n        super(BertrandDistribution, self).__init__(\n            signal, fmin=fmin, fmax=fmax, n_voices=n_voices, **kwargs\n        )\n        umaxbert = lambda x: np.exp(x) - self.fmax / self.fmin\n        self.umax = brenth(umaxbert, 0, 4)\n        teq = self.m / (self.fmax * self.umax)\n        if teq < self.signal.shape[0]:\n            m0 = int(np.round((2 * self.m ** 2) / teq - self.m)) + 1\n            m1 = self.m + m0\n            self.T = 2 * m1 - 1\n        else:\n            m0 = 0\n            m1 = self.m\n        self.m1 = m1\n        if n_voices is None:\n            self._get_nvoices()\n        else:\n            self.n_voices = n_voices\n\n    def run(self):\n        S1, S2 = self._geometric_sample()\n        beta, mellin1, mellin2 = self._mellin_transform(S1, S2)\n        # Computation of P0(t. f, f)\n        waf = np.zeros((2 * int(self.m1), self.n_voices), dtype=complex)\n        for n in np.hstack(\n            (np.arange(1, self.m1 + 1), np.arange(self.m1 + 2, 2 * self.m1 + 1))\n        ):\n            mx1 = (\n                np.exp(\n                    (-2 * 1j * np.pi * beta + 0.5)\n                    * np.log(\n                        (self.u[n - 1] / 2)\n                        * np.exp(-self.u[n - 1] / 2)\n                        / np.sinh(self.u[n - 1] / 2)\n                    )\n                )\n                * mellin1\n            )\n            mx2 = (\n                np.exp(\n                    (-2 * 1j * np.pi * beta + 0.5)\n                    * np.log(\n                        (self.u[n - 1] / 2)\n                        * np.exp(self.u[n - 1] / 2)\n                        / np.sinh(self.u[n - 1] / 2)\n                    )\n                )\n                * mellin2\n            )\n            fx1 = np.fft.fft(np.fft.fftshift(mx1))[: self.n_voices]\n            fx2 = np.fft.fft(np.fft.fftshift(mx2))[: self.n_voices]\n            waf[n - 1, :] = fx1 * np.conj(fx2)\n        waf[self.m1, :] = S1[: self.n_voices] * np.conj(S2[: self.n_voices])\n        waf = np.vstack((waf[self.m1: (2 * self.m1), :], waf[: self.m1, :]))\n        waf *= np.repeat(\n            self.geo_f.reshape((1, self.geo_f.shape[0])), 2 * self.m1, axis=0\n        )\n        tffr = np.fft.ifft(waf, axis=0)\n        tffr = np.real(\n            np.rot90(\n                np.vstack((tffr[self.m1: (2 * self.m1 + 1), :], tffr[: self.m1, :])),\n                k=-1,\n            )\n        )\n        # conversion from tff to tf using 1d interpolation\n        return self._get_interpolated_tf(tffr)\n\n\ndef lambdak(u, k):\n    method_lookup = {""bertrand"": 0, ""unterberger"": -1, ""d_flandrin"": 0.5, ""aspwv"": 2}\n    k = method_lookup[k]\n    if k not in (0, 1):\n        y = k * (np.exp(-u) - 1) / (np.exp(-k * u) - 1)\n        y = y ** (1 / (k - 1))\n    elif k == 1:\n        y = np.exp(1 + u * np.exp(-u) / (np.exp(-u) - 1))\n    elif k == 0:\n        if u == 0:\n            return 1\n        y = -u / (np.exp(-u) - 1)\n    return y\n\n\ndef smoothed_pseudo_wigner(\n    signal,\n    timestamps=None,\n    K=""bertrand"",\n    nh0=None,\n    ng0=0,\n    fmin=None,\n    fmax=None,\n    n_voices=None,\n):\n    """"""smoothed_pseudo_wigner\n\n   :param signal:\n   :param timestamps:\n   :param K:\n   :param nh0:\n   :param ng0:\n   :param fmin:\n   :param fmax:\n   :param n_voices:\n   :type signal:\n   :type timestamps:\n   :type K:\n   :type nh0:\n   :type ng0:\n   :type fmin:\n   :type fmax:\n   :type n_voices:\n   :return:\n   :rtype:\n    """"""\n    xrow = signal.shape[0]\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if nh0 is None:\n        nh0 = np.sqrt(signal.shape[0])\n\n    tcol = timestamps.shape[0]\n    mt = signal.shape[0]\n\n    x1 = x2 = signal.copy()\n    s1 = np.real(x1)\n    s2 = np.real(x2)\n    m = (mt + np.remainder(mt, 2)) / 2\n\n    if (fmin is None) or (fmax is None):\n        stf1 = np.fft.fft(np.fft.fftshift(s1[timestamps.min(): timestamps.max() + 1]))\n        stf2 = np.fft.fft(np.fft.fftshift(s2[timestamps.min(): timestamps.max() + 1]))\n        nstf = stf1.shape[0]\n        sp1 = np.abs(stf1[: int(np.round(nstf / 2))]) ** 2\n        sp2 = np.abs(stf2[: int(np.round(nstf / 2))]) ** 2\n        maxsp1 = sp1.max()\n        maxsp2 = sp2.max()\n        f = np.linspace(0, 0.5, np.round(nstf / 2) + 1)[: int(np.round(nstf / 2))]\n        if fmin is None:\n            mask = sp1 > maxsp1 / 100\n            indmin = np.arange(mask.shape[0], dtype=int)[mask.astype(bool)].min()\n            fmin = max([0.01, 0.05 * np.floor(f[indmin] / 0.05)])\n        if fmax is None:\n            mask = sp2 > maxsp2 / 100\n            indmax = np.arange(mask.shape[0], dtype=int)[mask.astype(bool)].max()\n            fmax = 0.05 * np.ceil(f[indmax] / 0.05)\n\n    B = fmax - fmin\n    R = B / ((fmin + fmax) / 2)\n    ratio = fmax / fmin\n    umax = np.log(ratio)\n    teq = nh0 / (fmax * umax)\n    if teq > 2 * nh0:\n        m0 = (2 * nh0 ** 2) / teq - nh0 + 1\n    else:\n        m0 = 0\n    mu = np.round(nh0 + m0)\n    T = 2 * mu - 1\n\n    if n_voices is None:\n        nq = np.ceil((B * T * (1 + 2 / R) * np.log((1 + R / 2) / (1 - R / 2))) / 2)\n        nmin = nq - nq % 2\n        ndflt = 2 ** nextpow2(nmin)\n        n_voices = int(ndflt)\n\n    k = np.arange(1, n_voices + 1)\n    q = ratio ** (1 / (n_voices - 1))\n    a = np.exp((k - 1) * np.log(q))\n    geo_f = fmin * a\n\n    # Wavelet decomposition computation\n    matxte1 = np.zeros((n_voices, tcol), dtype=complex)\n    matxte2 = np.zeros((n_voices, tcol), dtype=complex)\n    _, _, _, wt1 = Scalogram(\n        s1,\n        time_instants=timestamps,\n        waveparams=nh0,\n        fmin=fmin,\n        fmax=fmax,\n        n_voices=n_voices,\n    ).run()\n    _, _, _, wt2 = Scalogram(\n        s2,\n        time_instants=timestamps,\n        waveparams=nh0,\n        fmin=fmin,\n        fmax=fmax,\n        n_voices=n_voices,\n    ).run()\n    for ptr in range(n_voices):\n        matxte1[ptr, :] = wt1[ptr, :] * np.sqrt(a[n_voices - ptr - 1])\n        matxte2[ptr, :] = wt2[ptr, :] * np.sqrt(a[n_voices - ptr - 1])\n\n    umin = -umax\n    u = np.linspace(umin, umax, 2 * mu + 1)\n    u = u[: (2 * mu)]\n    u[mu] = 0\n    p = np.arange(2 * n_voices)\n    beta = (p / float(n_voices) - 1) / (2 * np.log(q))\n    l1 = l2 = np.zeros((2 * mu, 2 * n_voices), dtype=complex)\n    for m in range(l1.shape[0]):\n        l1[m, :] = np.exp(-2 * np.pi * 1j * beta * np.log(lambdak(u[m], K)))\n        l2[m, :] = np.exp(-2 * np.pi * 1j * beta * np.log(lambdak(-u[m], K)))\n\n    # Calculate time smoothing window\n    if ng0 == 0:\n        G = np.ones((2 * mu))\n    else:\n        a_t = 3\n        sigma_t = ng0 * fmax / np.sqrt(2 * a_t * np.log(10))\n        a_u = 2 * np.pi ** 2 * sigma_t ** 2 * umax ** 2 / np.log(10)\n        G = np.exp(-(a_u * np.log(10) / mu ** 2) * np.arange(-mu, mu) ** 2)\n\n    waf = np.zeros((2 * mu, n_voices))\n    tfr = np.zeros((n_voices, tcol))\n    S1 = S2 = np.zeros((2 * n_voices, ), dtype=complex)\n    mx1 = mx2 = np.zeros((2 * n_voices, 2 * mu))\n\n    for ti in range(tcol):\n        S1[:n_voices] = matxte1[:, ti]\n        mellin1 = np.fft.fftshift(np.fft.ifft(S1))\n        mx1 = l1 * mellin1.reshape(1, mellin1.shape[0]).repeat(2 * mu, 0)\n        mx1 = np.fft.fft(mx1, axis=0)\n        tx1 = mx1[:n_voices, :].T\n\n        S2[:n_voices] = matxte2[:, ti]\n        mellin2 = np.fft.fftshift(np.fft.ifft(S2))\n        mx2 = l2 * mellin2.reshape(1, mellin2.shape[0]).repeat(2 * mu, 0)\n        mx2 = np.fft.fft(mx2, axis=0)\n        tx2 = mx2[:n_voices, :].T\n        waf = np.real(tx1 * np.conj(tx2)) * G.reshape(G.shape[0], 1).repeat(\n            n_voices, axis=1\n        )\n        tfr[:, ti] = np.sum(waf) * geo_f\n\n    t = timestamps\n    f = geo_f\n\n    # Normalization\n    sp1 = np.fft.fft(hilbert(s1))\n    sp2 = np.fft.fft(hilbert(s2))\n    indmin = 1 + int(np.round(fmin * (xrow - 2)))\n    indmax = 1 + int(np.round(fmax * (xrow - 2)))\n    sp1_ana = sp1[indmin: (indmax + 1)]\n    sp2_ana = sp2[indmin: (indmax + 1)]\n    xx = np.dot(np.real(sp1_ana), np.real(sp2_ana))\n    xx += np.dot(np.imag(sp1_ana), np.imag(sp2_ana))\n    tfr = tfr * xx / integrate_2d(tfr, t, f) / n_voices\n    return tfr, t, f\n\n\ndef umaxdfla_solve(ratio):\n    coeffs = [(1 - ratio) / 16, (1 + ratio) / 2, 1 - ratio]\n    roots = np.roots(coeffs)\n    return np.min(np.abs(roots - 0))\n\n\nif __name__ == ""__main__"":\n    from tftb.generators import altes\n    import matplotlib.pyplot as plt\n\n    sig = altes(64, 0.1, 0.45)\n    tfr, timestamps, frequencies = smoothed_pseudo_wigner(sig)\n    tfr = np.abs(tfr) ** 2\n    threshold = np.amax(tfr) * 0.05\n    tfr[tfr <= threshold] = 0\n    plt.imshow(tfr, aspect=""auto"", origin=""bottomleft"", extent=[0, 64, 0, 0.5])\n    plt.show()\n'"
tftb/processing/ambiguity.py,47,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nAmbiguity functions.\n""""""\n\nimport numpy as np\nfrom scipy.signal import hilbert\nfrom tftb.utils import nextpow2\n\n\ndef wide_band(signal, fmin=None, fmax=None, N=None):\n    if 1 in signal.shape:\n        signal = signal.ravel()\n    elif signal.ndim != 1:\n        raise ValueError(""The input signal should be one dimensional."")\n    s_ana = hilbert(np.real(signal))\n    nx = signal.shape[0]\n    m = int(np.round(nx / 2.0))\n    t = np.arange(nx) - m\n    tmin = 0\n    tmax = nx - 1\n    T = tmax - tmin\n\n    # determine default values for fmin, fmax\n    if (fmin is None) or (fmax is None):\n        STF = np.fft.fftshift(s_ana)\n        sp = np.abs(STF[:m]) ** 2\n        maxsp = np.amax(sp)\n        f = np.linspace(0, 0.5, m + 1)\n        f = f[:m]\n        indmin = np.nonzero(sp > maxsp / 100.0)[0].min()\n        indmax = np.nonzero(sp > maxsp / 100.0)[0].max()\n        if fmin is None:\n            fmin = max([0.01, 0.05 * np.fix(f[indmin] / 0.05)])\n        if fmax is None:\n            fmax = 0.05 * np.ceil(f[indmax] / 0.05)\n    B = fmax - fmin\n    R = B / ((fmin + fmax) / 2.0)\n    nq = np.ceil((B * T * (1 + 2.0 / R) * np.log((1 + R / 2.0) / (1 - R / 2.0))) / 2.0)\n    nmin = nq - (nq % 2)\n    if N is None:\n        N = int(2 ** (nextpow2(nmin)))\n\n    # geometric sampling for the analyzed spectrum\n    k = np.arange(1, N + 1)\n    q = (fmax / fmin) ** (1.0 / (N - 1))\n    geo_f = fmin * (np.exp((k - 1) * np.log(q)))\n    tfmatx = -2j * np.dot(t.reshape(-1, 1), geo_f.reshape(1, -1)) * np.pi\n    tfmatx = np.exp(tfmatx)\n    S = np.dot(s_ana.reshape(1, -1), tfmatx)\n    S = np.tile(S, (nx, 1))\n    Sb = S * tfmatx\n\n    tau = t\n    S = np.c_[S, np.zeros((nx, N))].T\n    Sb = np.c_[Sb, np.zeros((nx, N))].T\n\n    # mellin transform computation of the analyzed signal\n    p = np.arange(2 * N)\n    coef = np.exp(p / 2.0 * np.log(q))\n    mellinS = np.fft.fftshift(np.fft.ifft(S[:, 0] * coef))\n    mellinS = np.tile(mellinS, (nx, 1)).T\n\n    mellinSb = np.zeros((2 * N, nx), dtype=complex)\n    for i in range(nx):\n        mellinSb[:, i] = np.fft.fftshift(np.fft.ifft(Sb[:, i] * coef))\n\n    k = np.arange(1, 2 * N + 1)\n    scale = np.logspace(np.log10(fmin / fmax), np.log10(fmax / fmin), N)\n    theta = np.log(scale)\n    mellinSSb = mellinS * np.conj(mellinSb)\n\n    waf = np.fft.ifft(mellinSSb, N, axis=0)\n    no2 = int((N + N % 2) / 2.0)\n    waf = np.r_[waf[no2:(N + 1), :], waf[:no2, :]]\n\n    # normalization\n    s = np.real(s_ana)\n    SP = np.fft.fft(hilbert(s))\n    indmin = int(1 + np.round(fmin * (nx - 2)))\n    indmax = int(1 + np.round(fmax * (nx - 2)))\n    sp_ana = SP[(indmin - 1):indmax]\n    waf *= (np.linalg.norm(sp_ana) ** 2) / waf[no2 - 1, m - 1] / N\n\n    return waf, tau, theta\n\n\ndef narrow_band(signal, lag=None, n_fbins=None):\n    """"""Narrow band ambiguity function.\n\n    :param signal: Signal to be analyzed.\n    :param lag: vector of lag values.\n    :param n_fbins: number of frequency bins\n    :type signal: array-like\n    :type lag: array-like\n    :type n_fbins: int\n    :return: Doppler lag representation\n    :rtype: array-like\n    """"""\n\n    n = signal.shape[0]\n    if lag is None:\n        if n % 2 == 0:\n            tau_start, tau_end = -n / 2 + 1, n / 2\n        else:\n            tau_start, tau_end = -(n - 1) / 2, (n + 1) / 2\n        lag = np.arange(tau_start, tau_end)\n    taucol = lag.shape[0]\n\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n\n    naf = np.zeros((n_fbins, taucol), dtype=complex)\n    for icol in range(taucol):\n        taui = int(lag[icol])\n        t = np.arange(abs(taui), n - abs(taui)).astype(int)\n        naf[t, icol] = signal[t + taui] * np.conj(signal[t - taui])\n    naf = np.fft.fft(naf, axis=0)\n\n    _ix1 = np.arange((n_fbins + (n_fbins % 2)) // 2, n_fbins)\n    _ix2 = np.arange((n_fbins + (n_fbins % 2)) // 2)\n\n    _xi1 = -(n_fbins - (n_fbins % 2)) // 2\n    _xi2 = ((n_fbins + (n_fbins % 2)) // 2 - 1)\n    xi = np.arange(_xi1, _xi2 + 1, dtype=float) / n_fbins\n    naf = naf[np.hstack((_ix1, _ix2)), :]\n    return naf, lag, xi\n\n\nif __name__ == \'__main__\':\n    from tftb.generators.misc import altes\n    sig = altes(128, 0.1, 0.45)\n    waf, tau, theta = wide_band(sig)\n    from matplotlib.pyplot import contour, show\n    contour(tau, theta, np.abs(waf) ** 2)\n    show()\n'"
tftb/processing/base.py,30,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nBase time-frequency representation class.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\nclass BaseTFRepresentation(object):\n\n    isaffine = False\n\n    def __init__(self, signal, **kwargs):\n        """"""Create a base time-frequency representation object.\n\n        :param signal: Signal to be analyzed.\n        :param **kwargs: Other arguments required for performing the analysis.\n        :type signal: array-like\n        :return: BaseTFRepresentation object\n        :rtype:\n        """"""\n        if (signal.ndim == 2) and (1 in signal.shape):\n            signal = signal.ravel()\n        self.signal = signal\n        timestamps = kwargs.get(\'timestamps\')\n        if timestamps is None:\n            timestamps = np.arange(signal.shape[0])\n        self.ts = self.timestamps = timestamps\n        n_fbins = kwargs.get(\'n_fbins\')\n        if n_fbins is None:\n            n_fbins = signal.shape[0]\n        self.n_fbins = n_fbins\n        fwindow = kwargs.get(\'fwindow\')\n        if fwindow is None:\n            fwindow = self._make_window()\n        self.fwindow = fwindow\n        if self.n_fbins % 2 == 0:\n            freqs = np.hstack((np.arange(self.n_fbins / 2),\n                               np.arange(-self.n_fbins / 2, 0)))\n        else:\n            freqs = np.hstack((np.arange((self.n_fbins - 1) / 2),\n                               np.arange(-(self.n_fbins - 1) / 2, 0)))\n        self.freqs = freqs.astype(float) / self.n_fbins\n        self.tfr = np.zeros((self.n_fbins, self.ts.shape[0]), dtype=complex)\n\n    def _get_spectrum(self):\n        if not self.isaffine:\n            return np.fft.fftshift(np.abs(np.fft.fft(self.signal)) ** 2)\n        nf2 = self.tfr.shape[0]\n        spec = np.abs(np.fft.fft(self.signal[self.ts.min():(self.ts.max() + 1)],\n                                 2 * nf2)) ** 2\n        return spec[:nf2]\n\n    def _make_window(self):\n        """"""Make a Hamming window function.\n\n        The window function has a length equal to quarter of the length of the\n        input signal.\n        :return: Hamming window function.\n        :rtype: array-like\n        """"""\n\n        h = np.floor(self.n_fbins / 4.0)\n        h += 1 - np.remainder(h, 2)\n        from scipy import hamming\n        fwindow = hamming(int(h))\n        # No need to normalize the window\n        # fwindow = fwindow / np.linalg.norm(fwindow)\n        return fwindow\n\n    def _plot_tfr(self, ax, kind, extent, contour_x=None, contour_y=None,\n                  levels=None, show_tf=True, cmap=plt.cm.gray):\n        if kind == ""cmap"":\n            ax.imshow(self.tfr, cmap=cmap, origin=""bottomleft"", extent=extent,\n                      aspect=\'auto\')\n        elif kind == ""contour"":\n            if contour_x is None:\n                contour_x = self.ts\n            if contour_y is None:\n                if show_tf:\n                    if self.isaffine:\n                        contour_y = np.linspace(self.fmin, self.fmax, self.n_voices)\n                    else:\n                        contour_y = np.linspace(0, 0.5, self.signal.shape[0])\n                else:\n                    contour_y = np.linspace(0, 0.5, self.tfr.shape[0])\n            contour_x, contour_y = np.meshgrid(contour_x, contour_y)\n            if levels is not None:\n                ax.contour(contour_x, contour_y, self.tfr, levels)\n            else:\n                if self.isaffine:\n                    maxi = np.amax(self.tfr)\n                    mini = max(np.amin(self.tfr), maxi * self._viz_threshold)\n                    levels = np.linspace(mini, maxi, 65)\n                    ax.contour(contour_x, contour_y, self.tfr, levels=levels)\n                else:\n                    ax.contour(contour_x, contour_y, self.tfr)\n\n    def _annotate_tfr(self, ax):\n        ax.grid(True)\n        ax.set_xlabel(""Time"")\n        ax.set_ylabel(""Normalized Frequency"")\n        ax.set_title(self.name.upper())\n        ax.yaxis.set_label_position(""right"")\n\n    def _plot_signal(self, ax):\n        ax.plot(np.real(self.signal))\n\n    def _annotate_signal(self, ax):\n        ax.set_xticklabels([])\n        ax.set_xlim(0, self.signal.shape[0])\n        ax.set_ylabel(\'Real part\')\n        ax.set_title(\'Signal in time\')\n        ax.grid(True)\n\n    def _plot_spectrum(self, ax, freq_x, freq_y):\n        k = int(np.floor(self.signal.shape[0] / 2.0))\n        if freq_x is None:\n            freq_x = self._get_spectrum()[::-1][:k]\n        if freq_y is None:\n            if self.isaffine:\n                freq_y = self.freqs\n            else:\n                freq_y = np.arange(k)\n        ax.plot(freq_x, freq_y)\n        if not self.isaffine:\n            ax.set_ylim(0, freq_y.shape[0] - 1)\n        else:\n            ax.set_ylim(freq_y[0], freq_y[-1])\n\n    def _annotate_spectrum(self, ax):\n        ax.set_ylabel(\'Spectrum\')\n        ax.set_yticklabels([])\n        ax.set_xticklabels([])\n        ax.grid(True)\n        if not self.isaffine:\n            ax.invert_xaxis()\n            ax.invert_yaxis()\n\n    def plot(self, ax=None, kind=\'cmap\', show=True, default_annotation=True,\n             show_tf=False, scale=""linear"", threshold=0.05, **kwargs):\n        """"""Visualize the time frequency representation.\n\n        :param ax: Axes object to draw the plot on.\n        :param kind: One of ""cmap"" (default), ""contour"".\n        :param show: Whether to call ``plt.show()``.\n        :param default_annotation: Whether to make default annotations for the\n            plot. Default annotations consist of setting the X and Y axis labels to\n            ""Time"" and ""Normalized Frequency"" respectively, and setting the title\n            to the name of the particular time-frequency distribution.\n        :param show_tf: Whether to show the signal and it\'s spectrum alongwith\n            the plot. In this is True, the ``ax`` argument is ignored.\n        :param **kwargs: Parameters to be passed to the plotting function.\n        :type ax: matplotlib.axes.Axes object\n        :type kind: str\n        :type show: bool\n        :type default_annotation: bool\n        :return: None\n        :rtype: None\n        """"""\n        self._viz_threshold = threshold\n\n        extent = kwargs.pop(\'extent\', None)\n        if extent is None:\n            extent = [self.ts.min(), self.ts.max(), self.freqs.min(),\n                      self.freqs.max()]\n        contour_x = kwargs.pop(\'contour_x\', None)\n        contour_y = kwargs.pop(\'contour_y\', None)\n        levels = kwargs.pop(\'levels\', None)\n        freq_x = kwargs.pop(\'freq_x\', None)\n        freq_y = kwargs.pop(\'freq_y\', None)\n        cmap = kwargs.pop(""cmap"", plt.cm.gray)\n\n        if show_tf:\n            fig, axTF = plt.subplots(figsize=(10, 8))\n            self._plot_tfr(axTF, kind, extent, contour_x, contour_y, levels,\n                           show_tf, cmap=cmap)\n            from mpl_toolkits.axes_grid1 import make_axes_locatable\n            divider = make_axes_locatable(axTF)\n\n            axTime = divider.append_axes(""top"", 1.2, pad=0.5)\n            self._plot_signal(axTime)\n\n            axSpec = divider.append_axes(""left"", 1.2, pad=0.5)\n            self._plot_spectrum(axSpec, freq_x, freq_y)\n\n            if default_annotation:\n                self._annotate_tfr(axTF)\n                self._annotate_signal(axTime)\n                self._annotate_spectrum(axSpec)\n        else:\n            if (ax is None) and (kind != ""surf""):\n                fig = plt.figure()\n                ax = fig.add_subplot(111)\n            if kind == ""cmap"":\n                ax.imshow(self.tfr,\n                          aspect=\'auto\', origin=\'bottomleft\', extent=extent,\n                          **kwargs)\n            elif kind == ""surf"":\n                from mpl_toolkits.mplot3d import Axes3D\n                fig = plt.figure()\n                ax = fig.gca(projection=""3d"")\n                x = np.arange(self.signal.shape[0])\n                y = np.linspace(0, 0.5, self.signal.shape[0])\n                X, Y = np.meshgrid(x, y)\n                ax.plot_surface(X, Y, np.abs(self.tfr), cmap=plt.cm.jet)\n                if default_annotation:\n                    ax.set_zlabel(""Amplitude"")\n            elif kind == ""wireframe"":\n                from mpl_toolkits.mplot3d import Axes3D  # NOQA\n                ax = fig.gca(projection=""3d"")\n                x = np.arange(self.signal.shape[0])\n                y = np.linspace(0, 0.5, self.signal.shape[0])\n                X, Y = np.meshgrid(x, y)\n                ax.plot_wireframe(X, Y, np.abs(self.tfr), cmap=plt.cm.jet,\n                                  rstride=3, cstride=3)\n            else:\n                t, f = np.meshgrid(self.ts, np.linspace(0, 0.5, self.tfr.shape[0]))\n                ax.contour(t, f, self.tfr, **kwargs)\n            if default_annotation:\n                grid = kwargs.get(\'grid\', True)\n                ax.grid(grid)\n                ax.set_xlabel(""Time"")\n                ax.set_ylabel(""Normalized Frequency"")\n                ax.set_title(self.name.upper())\n        if show:\n            plt.show()\n'"
tftb/processing/cohen.py,80,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nBilinear Time-Frequency Processing in the Cohen\xe2\x80\x99s Class.\n""""""\n\nimport numpy as np\nfrom tftb.processing.linear import ShortTimeFourierTransform\nfrom tftb.processing.base import BaseTFRepresentation\n\n\nclass Spectrogram(ShortTimeFourierTransform):\n\n    name = ""spectrogram""\n\n    def run(self):\n        lh = (self.fwindow.shape[0] - 1) // 2\n        rangemin = min([round(self.n_fbins / 2.0) - 1, lh])\n        starts = -np.min(np.c_[rangemin * np.ones(self.ts.shape), self.ts - 1],\n                         axis=1).astype(int)\n        ends = np.min(np.c_[rangemin * np.ones(self.ts.shape),\n                      self.signal.shape[0] - self.ts], axis=1).astype(int)\n        conj_fwindow = np.conj(self.fwindow)\n        for icol in range(self.tfr.shape[1]):\n            ti = self.ts[icol]\n            start = starts[icol]\n            end = ends[icol]\n            tau = np.arange(start, end + 1).astype(int)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins)\n            self.tfr[indices.astype(int), icol] = self.signal[ti + tau - 1] * \\\n                conj_fwindow[lh + tau] / np.linalg.norm(self.fwindow[lh + tau])\n        self.tfr = np.abs(np.fft.fft(self.tfr, axis=0)) ** 2\n        return self.tfr, self.ts, self.freqs\n\n    def plot(self, kind=\'cmap\', **kwargs):\n        thresh = kwargs.pop(""threshold"", 0.0)\n        super(Spectrogram, self).plot(kind=kind, sqmod=False, threshold=thresh,\n                                      **kwargs)\n\n\nclass PageRepresentation(BaseTFRepresentation):\n\n    name = ""page representation""\n\n    def run(self):\n        for icol in range(self.ts.shape[0]):\n            ti = self.ts[icol]\n            tau = np.arange(-min([self.n_fbins - ti,\n                                  self.signal.shape[0] - ti]), ti)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins)\n            self.tfr[indices, icol] = np.dot(self.signal[ti],\n                                             np.conj(self.signal[ti - tau - 1]))\n        self.tfr = np.real(np.fft.fft(self.tfr, axis=0))\n        return self.tfr, self.ts, self.freqs\n\n    def plot(self, kind=\'cmap\', threshold=0.05, sqmod=True, **kwargs):\n        self.tfr = self.tfr[:(self.tfr.shape[0] / 2), :]\n        self.tfr = np.abs(self.tfr) ** 2\n        _threshold = np.amax(self.tfr) * threshold\n        self.tfr[self.tfr <= _threshold] = 0.0\n        super(PageRepresentation, self).plot(kind=kind, **kwargs)\n\n\nclass PseudoPageRepresentation(PageRepresentation):\n\n    name = ""pseudo page""\n\n    def _make_window(self):\n        hlength = np.floor(self.n_fbins / 4.0)\n        if hlength % 2 == 0:\n            hlength += 1\n        from scipy.signal import hamming\n        fwindow = hamming(hlength)\n        lh = (fwindow.shape[0] - 1) / 2\n        return fwindow / fwindow[lh]\n\n    def run(self):\n        lh = (self.fwindow.shape[0] - 1) / 2\n        for icol in range(self.ts.shape[0]):\n            tau = np.arange(min([self.n_fbins - 1, lh, icol - 1]) + 1)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins) + 1\n            self.tfr[indices, icol] = self.fwindow[lh + tau] * \\\n                self.signal[icol] * np.conj(self.signal[icol - tau])\n        self.tfr = np.real(np.fft.fft(self.tfr, axis=0))\n        return self.tfr, self.ts, self.freqs\n\n\nclass MargenauHillDistribution(BaseTFRepresentation):\n\n    name = ""margenau-hill""\n\n    def run(self):\n        for icol in range(self.ts.shape[0]):\n            ti = self.ts[icol]\n            tau = np.arange(-min((self.n_fbins - ti,\n                                  self.signal.shape[0] - ti)) + 1, ti)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins)\n            self.tfr[indices, icol] = self.signal[ti] * \\\n                np.conj(self.signal[ti - tau])\n\n        self.tfr = np.real(np.fft.fft(self.tfr, axis=0))\n        return self.tfr, self.ts, self.freqs\n\n    def plot(self, kind=\'cmap\', threshold=0.05, sqmod=True, **kwargs):\n        self.tfr = self.tfr[:(self.tfr.shape[0] // 2), :]\n        if sqmod:\n            self.tfr = np.abs(self.tfr) ** 2\n        _threshold = np.amax(self.tfr) * threshold\n        self.tfr[self.tfr <= _threshold] = 0.0\n        extent = [0, self.ts.max(), 0, 0.5]\n        super(MargenauHillDistribution, self).plot(kind=kind, extent=extent, **kwargs)\n\n\nclass PseudoMargenauHillDistribution(MargenauHillDistribution):\n\n    name = ""pseudo margenau-hill""\n\n    def _make_window(self):\n        hlength = np.floor(self.n_fbins / 4.0)\n        if hlength % 2 == 0:\n            hlength += 1\n        from scipy.signal import hamming\n        fwindow = hamming(hlength)\n        lh = (fwindow.shape[0] - 1) / 2\n        return fwindow / fwindow[lh]\n\n    def run(self):\n        lh = (self.fwindow.shape[0] - 1) / 2\n        xrow = self.signal.shape[0]\n        for icol in range(self.ts.shape[0]):\n            start = min([np.round(self.n_fbins / 2.0) - 1, lh, xrow - icol])\n            end = min([np.round(self.n_fbins / 2.0) - 1, lh, icol - 1])\n            tau = np.arange(-start, end + 1)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins)\n            self.tfr[indices, icol] = self.fwindow[lh + tau] * self.signal[icol] * \\\n                np.conj(self.signal[icol - tau - 1])\n        self.tfr = np.fft.fft(self.tfr, axis=0)\n        return self.tfr, self.ts, self.freqs\n\n\nclass WignerVilleDistribution(BaseTFRepresentation):\n\n    name = ""wigner-ville""\n\n    def run(self):\n        tausec = round(self.n_fbins / 2.0)\n        winlength = tausec - 1\n        taulens = np.min(np.c_[np.arange(self.signal.shape[0]),\n                               self.signal.shape[0] - np.arange(self.signal.shape[0]) - 1,\n                         winlength * np.ones(self.ts.shape)], axis=1)\n        conj_signal = np.conj(self.signal)\n        for icol in range(self.ts.shape[0]):\n            taumax = taulens[icol]\n            tau = np.arange(-taumax, taumax + 1).astype(int)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins).astype(int)\n            self.tfr[indices, icol] = self.signal[icol + tau] * \\\n                conj_signal[icol - tau]\n            if (icol <= self.signal.shape[0] - tausec) and (icol >= tausec + 1):\n                self.tfr[tausec, icol] = self.signal[icol + tausec, 0] * \\\n                    np.conj(self.signal[icol - tausec, 0]) + \\\n                    self.signal[icol - tausec, 0] * conj_signal[icol + tausec, 0]\n        self.tfr = np.fft.fft(self.tfr, axis=0)\n        self.tfr = np.real(self.tfr)\n        self.freqs = 0.5 * np.arange(self.n_fbins, dtype=float) / self.n_fbins\n        return self.tfr, self.ts, self.freqs\n\n    def plot(self, kind=\'cmap\', threshold=0.05, sqmod=False, **kwargs):\n        scale = kwargs.pop(""scale"", ""linear"")\n        if scale == ""log"":\n            maxi = np.amax(self.tfr)\n            mini = max(np.amin(self.tfr), maxi * threshold)\n            levels = np.logspace(np.log10(mini), np.log10(maxi), 65)\n            kwargs[\'levels\'] = levels\n        if sqmod:\n            self.tfr = np.abs(self.tfr) ** 2\n        else:\n            self.tfr = np.abs(self.tfr)\n        _threshold = np.amax(self.tfr) * threshold\n        self.tfr[self.tfr <= _threshold] = 0.0\n        super(WignerVilleDistribution, self).plot(kind=kind, threshold=threshold,\n                                                  **kwargs)\n\n\nclass PseudoWignerVilleDistribution(WignerVilleDistribution):\n\n    name = ""pseudo winger-ville""\n\n    def run(self):\n        lh = (self.fwindow.shape[0] - 1) // 2\n        for icol in range(self.ts.shape[0]):\n            taumaxvals = (icol, self.signal.shape[0] - icol - 1,\n                          np.round(self.n_fbins / 2.0), lh)\n            taumax = np.min(taumaxvals)\n            tau = np.arange(-taumax, taumax + 1).astype(int)\n            indices = np.remainder(self.n_fbins + tau, self.n_fbins).astype(int)\n            self.tfr[indices, icol] = self.fwindow[lh + tau] * self.signal[icol + tau] * \\\n                np.conj(self.signal[icol - tau])\n            tau = np.round(self.n_fbins / 2.0)\n            if (icol <= self.signal.shape[0] - tau) and (icol >= tau + 1) and (tau <= lh):\n                self.tfr[int(tau), icol] = self.fwindow[lh + tau] * \\\n                    self.signal[icol + tau, 0] * np.conj(self.signal[icol - tau, 0]) + \\\n                    self.fwindow[lh - tau] * self.signal[icol - tau, 0] * \\\n                    np.conj(self.signal[icol + tau, 0])\n                self.tfr[int(tau), icol] *= 0.5\n\n        self.tfr = np.fft.fft(self.tfr, axis=0)\n        return np.real(self.tfr), self.ts, self.freqs\n\n    def plot(self, **kwargs):\n        if ""kind"" not in kwargs:\n            kwargs[\'kind\'] = ""contour""\n        super(PseudoWignerVilleDistribution, self).plot(**kwargs)\n\n\ndef smoothed_pseudo_wigner_ville(signal, timestamps=None, freq_bins=None,\n                                 twindow=None, fwindow=None):\n    """"""Smoothed Pseudo Wigner-Ville time-frequency distribution.\n    :param signal: signal to be analyzed\n    :param timestamps: time instants of the signal\n    :param freq_bins: number of frequency bins\n    :param twindow: time smoothing window\n    :param fwindow: frequency smoothing window\n    :type signal: array-like\n    :type timestamps: array-like\n    :type freq_bins: int\n    :type twindow: array-like\n    :type fwindow: array-like\n    :return: Smoothed pseudo Wigner Ville distribution\n    :rtype: array-like\n    """"""\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if freq_bins is None:\n        freq_bins = signal.shape[0]\n\n    if fwindow is None:\n        winlength = np.floor(freq_bins / 4.0)\n        winlength = winlength + 1 - np.remainder(winlength, 2)\n        from scipy.signal import hamming\n        fwindow = hamming(int(winlength))\n    elif fwindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing fwindow must have an odd length.\')\n\n    if twindow is None:\n        timelength = np.floor(freq_bins / 10.0)\n        timelength += 1 - np.remainder(timelength, 2)\n        from scipy.signal import hamming\n        twindow = hamming(int(timelength))\n    elif twindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing fwindow must have an odd length.\')\n\n    tfr = np.zeros((freq_bins, timestamps.shape[0]), dtype=complex)\n    lg = (twindow.shape[0] - 1) / 2\n    lh = (fwindow.shape[0] - 1) / 2\n    for icol in range(timestamps.shape[0]):\n        ti = timestamps[icol]\n        taumax = min([ti + lg - 1, signal.shape[0] - ti + lg,\n                      np.round(freq_bins / 2.0) - 1, lh])\n        points = np.arange(-min([lg, signal.shape[0] - ti]),\n                           min([lg, ti - 1]) + 1).astype(int)\n        lg_points = (lg + points).astype(int)\n        g2 = twindow[lg_points]\n        g2 = g2 / np.sum(g2)\n        signal_idx = (ti - points - 1).astype(int)\n        tfr[0, icol] = np.sum(g2 * signal[signal_idx] * np.conj(signal[signal_idx]))\n        for tau in range(int(taumax)):\n            points = np.arange(-min([lg, signal.shape[0] - ti - tau]),\n                               min([lg, ti - 1 - tau]) + 1)\n            lg_points = (lg + points).astype(int)\n            g2 = twindow[lg_points]\n            g2 = g2 / np.sum(g2)\n            idx1 = (ti + tau - points - 1).astype(int)\n            idx2 = (ti - tau - points - 1).astype(int)\n            R = np.sum(g2 * signal[idx1] * np.conj(signal[idx2]))\n            tfr[1 + tau, icol] = fwindow[(lh + tau + 1).astype(int)] * R\n            R = np.sum(g2 * signal[idx2] * np.conj(signal[idx1]))\n            tfr[freq_bins - tau - 1, icol] = fwindow[(lh - tau + 1).astype(int)] * R\n        tau = np.round(freq_bins / 2.0)\n        if (ti <= signal.shape[0] - tau) and (ti >= tau + 1) and (tau <= lh):\n            points = np.arange(-min([lg, signal.shape[0] - ti - tau]),\n                               min([lg, ti - 1 - tau]) + 1)\n            lg_points = (lg + 1 + points).astype(int)\n            g2 = twindow[lg_points]\n            g2 = g2 / np.sum(g2)\n            idx1 = (ti + tau - points).astype(int)\n            idx2 = (ti - tau - points).astype(int)\n            _x = np.sum(g2 * signal[idx1] * np.conj(signal[idx2]))\n            _x *= fwindow[(lh + tau + 1).astype(int)]\n            _y = np.sum(g2 * signal[idx2] * np.conj(signal[idx1]))\n            _y *= fwindow[(lh - tau + 1).astype(int)]\n            tfr[tau, icol] = (_x + _y) * 0.5\n    tfr = np.fft.fft(tfr, axis=0)\n    return np.real(tfr)\n\n\nif __name__ == \'__main__\':\n    from tftb.generators import anapulse\n    sig = anapulse(128)\n    t = np.linspace(0, 1, 128)\n    spec = WignerVilleDistribution(sig, timestamps=t)\n    spec.run()\n    spec.plot(kind=""contour"", scale=""log"")\n'"
tftb/processing/freq_domain.py,22,"b'import numpy as np\nfrom scipy import angle\n\n\ndef locfreq(signal):\n    """"""\n    Compute the frequency localization characteristics.\n\n    :param sig: input signal\n    :type sig: numpy.ndarray\n    :return: average normalized frequency center, frequency spreading\n    :rtype: tuple\n    :Example:\n    >>> from tftb.generators import amgauss\n    >>> z = amgauss(160, 80, 50)\n    >>> fm, B = locfreq(z)\n    >>> print(""%.3g"" % fm)\n    -9.18e-14\n    >>> print(""%.4g"" % B)\n    0.02\n    """"""\n    if signal.ndim > 1:\n        if 1 not in signal.shape:\n            raise TypeError\n        else:\n            signal = signal.ravel()\n    no2r = np.round(signal.shape[0] / 2.0)\n    no2f = np.floor(signal.shape[0] / 2.0)\n    sig = np.fft.fft(signal)\n    sig = np.abs(sig) ** 2\n    sig = sig / sig.mean()\n    freqs = np.hstack((np.arange(no2f), np.arange(-no2r, 0))) / signal.shape[0]\n    fm = np.mean(freqs * sig)\n    bw = 2 * np.sqrt(np.pi * np.mean(((freqs - fm) ** 2) * sig))\n    return fm, bw\n\n\ndef inst_freq(x, t=None, L=1):\n    """"""\n    Compute the instantaneous frequency of an analytic signal at specific\n    time instants using the trapezoidal integration rule.\n\n    :param x: The input analytic signal\n    :param t: The time instants at which to calculate the instantaneous frequencies.\n    :param L: Non default values are currently not supported.\n        If L is 1, the normalized instantaneous frequency is computed. If L > 1,\n        the maximum likelihood estimate of the instantaneous frequency of the\n        deterministic part of the signal.\n    :type x: numpy.ndarray\n    :type t: numpy.ndarray\n    :type L: int\n    :return: instantaneous frequencies of the input signal.\n    :rtype: numpy.ndarray\n    :Example:\n    >>> from tftb.generators import fmsin\n    >>> x = fmsin(70, 0.05, 0.35, 25)[0]\n    >>> instf, timestamps = inst_freq(x)\n    >>> plot(timestamps, instf) #doctest: +SKIP\n\n    .. plot:: docstring_plots/processing/freq_domain/inst_freq.py\n    """"""\n    if x.ndim != 1:\n        if 1 not in x.shape:\n            raise TypeError(""Input should be a one dimensional array."")\n        else:\n            x = x.ravel()\n    if t is not None:\n        if t.ndim != 1:\n            if 1 not in t.shape:\n                raise TypeError(""Time instants should be a one dimensional ""\n                                ""array."")\n            else:\n                t = t.ravel()\n    else:\n        t = np.arange(2, len(x))\n\n    fnorm = 0.5 * (angle(-x[t] * np.conj(x[t - 2])) + np.pi) / (2 * np.pi)\n    return fnorm, t\n\n\ndef group_delay(x, fnorm=None):\n    """"""\n    Compute the group delay of a signal at normalized frequencies.\n\n    :param x: time domain signal\n    :param fnorm: normalized frequency at which to calculate the group delay.\n    :type x: numpy.ndarray\n    :type fnorm: float\n    :return: group delay\n    :rtype: numpy.ndarray\n    :Example:\n    >>> import numpy as np\n    >>> from tftb.generators import amgauss, fmlin\n    >>> x = amgauss(128, 64.0, 30) * fmlin(128, 0.1, 0.4)[0]\n    >>> fnorm = np.arange(0.1, 0.38, step=0.04)\n    >>> gd = group_delay(x, fnorm)\n    >>> plot(gd, fnorm) #doctest: +SKIP\n\n    .. plot:: docstring_plots/processing/freq_domain/group_delay.py\n    """"""\n    if x.ndim != 1:\n        if 1 not in x.shape:\n            raise TypeError\n        else:\n            x = x.ravel()\n\n    if fnorm is None:\n        numerator = np.fft.fft(x * np.arange(1, x.shape[0] + 1))\n        denominator = np.fft.fft(x)\n        window = np.real(numerator / denominator) >= 1\n        ratio = np.real(numerator / denominator) * window.astype(int)\n        ratio = ratio * (np.real(numerator / denominator) <= (len(x) + 3)).astype(int)\n        gd = np.fft.fftshift(ratio)\n    else:\n        exponent = np.exp(-1j * 2.0 * np.pi * fnorm.reshape(len(fnorm), 1) * np.arange(len(x)))\n        numerator = np.dot(exponent, (x * np.arange(1, x.shape[0] + 1)))\n        denominator = np.dot(exponent, x)\n        window = np.real(numerator / denominator) >= 1\n        ratio = np.real(numerator / denominator) * window.astype(int)\n        gd = ratio * (np.real(numerator / denominator) <= (len(x) + 3)).astype(int)\n    return gd\n'"
tftb/processing/linear.py,32,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nLinear Time Frequency Processing.\n""""""\n\nimport numpy as np\nfrom tftb.processing.base import BaseTFRepresentation\nfrom tftb.utils import nearest_odd, divider, modulo, izak\n\n\nclass ShortTimeFourierTransform(BaseTFRepresentation):\n    """"""Short time Fourier transform.""""""\n\n    name = ""stft""\n\n    def __init__(self, signal, timestamps=None, n_fbins=None, fwindow=None):\n        """"""Create a ShortTimeFourierTransform object.\n\n        :param signal: Signal to be analyzed.\n        :param timestamps: Time instants of the signal (default:\n            ``np.arange(len(signal))``)\n        :param n_fbins: Number of frequency bins (default: ``len(signal)``)\n        :param fwindow: Frequency smoothing window (default: Hamming window of\n            length ``len(signal) / 4``)\n        :type signal: array-like\n        :type timestamps: array-like\n        :type n_fbins: int\n        :type fwindow: array-like\n        :return: ShortTimeFourierTransform object\n        :Example:\n\n        >>> from tftb.generators import fmconst\n        >>> sig = np.r_[fmconst(128, 0.2)[0], fmconst(128, 0.4)[0]]\n        >>> stft = ShortTimeFourierTransform(sig)\n        >>> tfr, t, f = stft.run()\n        >>> stft.plot() #doctest: +SKIP\n\n        .. plot:: docstring_plots/processing/stft.py\n        """"""\n        super(ShortTimeFourierTransform, self).__init__(signal=signal,\n                                                        n_fbins=n_fbins,\n                                                        timestamps=timestamps,\n                                                        fwindow=fwindow)\n\n    def run(self):\n        r""""""Compute the STFT according to:\n\n        .. math:: X[m, w] = \\sum_{n=-\\infty}^{\\infty}x[n]w[n - m]e^{-j\\omega n}\n\n        Where :math:`w` is a Hamming window.""""""\n        lh = (self.fwindow.shape[0] - 1) // 2\n        rangemin = min([round(self.n_fbins / 2.0), lh])\n        starts = -np.min(np.c_[rangemin * np.ones(self.ts.shape),\n                               np.arange(self.ts.shape[0]) - 1],\n                         axis=1).astype(int)\n        ends = np.min(np.c_[rangemin * np.ones(self.ts.shape),\n                            self.signal.shape[0] - np.arange(self.ts.shape[0])],\n                      axis=1).astype(int)\n        conj_fwindow = np.conj(self.fwindow)\n        for icol in range(self.tfr.shape[1]):\n            start = starts[icol]\n            end = ends[icol]\n            tau = np.arange(start, end + 1).astype(int)\n            index = np.remainder(self.n_fbins + tau, self.n_fbins)\n            self.tfr[index, icol] = self.signal[(icol + tau - 1).astype(int)] * \\\n                conj_fwindow[(lh + tau).astype(int)]\n        self.tfr = np.fft.fft(self.tfr, axis=0)\n        return self.tfr, self.ts, self.freqs\n\n    def plot(self, ax=None, kind=\'cmap\', sqmod=True, threshold=0.05, **kwargs):\n        """"""Display the spectrogram of an STFT.\n\n        :param ax: axes object to draw the plot on. If None(default), one will\n            be created.\n        :param kind: Choice of visualization type, either ""cmap""(default) or ""contour"".\n        :param sqmod: Whether to take squared modulus of TFR before plotting.\n            (Default: True)\n        :param threshold: Percentage of the maximum value of the TFR, below\n            which all values are set to zero before plotting.\n        :param **kwargs: parameters passed to the plotting function.\n        :type ax: matplotlib.axes.Axes object\n        :type kind: str\n        :type sqmod: bool\n        :type threshold: float\n        :return: None\n        :rtype: None\n        """"""\n        self.tfr = self.tfr[:int(self.n_fbins / 2.0), :]\n        self.freqs = self.freqs[:int(self.n_fbins / 2.0)]\n        if sqmod:\n            self.tfr = np.abs(self.tfr) ** 2\n        _threshold = np.amax(self.tfr) * threshold\n        self.tfr[self.tfr <= _threshold] = 0.0\n        super(ShortTimeFourierTransform, self).plot(ax=ax, kind=kind,\n                                                    threshold=threshold,\n                                                    **kwargs)\n\n\ndef gabor(signal, n_coeff=None, q_oversample=None, window=None):\n    """"""Compute the Gabor representation of a signal.\n\n    :param signal: Singal to be analyzed.\n    :param n_coeff: number of Gabor coefficients in time.\n    :param q_oversample: Degree of oversampling\n    :param window: Synthesis window\n    :type signal: array-like\n    :type n_coeff: integer\n    :type q_oversample: int\n    :type window: array-like\n    :return: Tuple of Gabor coefficients, biorthogonal window associated with the synthesis window.\n    :rtype: tuple\n    """"""\n    if n_coeff is None:\n        n_coeff = divider(signal.shape[0])\n    if q_oversample is None:\n        q_oversample = divider(n_coeff)\n    if window is None:\n        window = np.exp(np.log(0.005) * np.linspace(-1, 1, nearest_odd(n_coeff)) ** 2)\n        window = window / np.linalg.norm(window)\n    m = int(q_oversample * signal.shape[0] / float(n_coeff))\n    mb = int(signal.shape[0] / float(n_coeff))\n    nb = int(signal.shape[0] / float(m))\n\n    # Zak transform?\n    nh = window.shape[0]\n    if nh % 2 == 0:\n        raise ValueError(""The window function should have an odd length."")\n    alpha = np.round((2 * signal.shape[0] / float(n_coeff) - 1 - nh) / (2 * q_oversample))\n    hn1 = np.zeros((signal.shape[0],))\n    start = np.round(((signal.shape[0] - (nh - 1))) / 2) - alpha\n    end = np.round((signal.shape[0] + nh - 1) / 2) - alpha\n    hn1[np.arange(start - 1, end).astype(int)] = window\n\n    msig = hn1.reshape(int(nb), int(m), order=\'F\')\n    dzth = np.fft.fft(msig.T, axis=0) / np.sqrt(m)\n    mzh = np.zeros((m, mb))\n    x = np.arange(1, m + 1, dtype=float)\n    for l in range(q_oversample):\n        mod = modulo(x - l * m / q_oversample, m).astype(int)\n        mzh += np.abs(dzth[mod - 1, :]) ** 2\n\n    mzh[mzh < np.spacing(1)] = 1\n\n    # Za transform of biorthogonal dual frame window gam\n    dztgam = dzth / mzh\n    gam = np.real(izak(dztgam)) / signal.shape[0]\n\n    # Computation of Gabor coefficient of dual frame window.\n    dgrn1 = np.zeros((signal.shape[0], n_coeff), dtype=complex)\n    k = np.arange(1, signal.shape[0] + 1)\n    for n in range(n_coeff):\n        index = modulo(k - n * m / q_oversample, signal.shape[0]).astype(int) - 1\n        dgrn1[:, n] = np.fft.fft(signal * np.fft.fftshift(gam[index]), axis=0)\n    dgr = dgrn1[np.arange(signal.shape[0], step=nb).astype(int), :]\n    tfr = np.abs(dgr) ** 2\n    return tfr, dgr, gam\n\n\nif __name__ == \'__main__\':\n    from tftb.generators import fmconst\n    import matplotlib.pyplot as plt\n    sig = np.r_[fmconst(128, 0.2)[0], fmconst(128, 0.4)[0]]\n    ts = np.linspace(0, 1, 256)\n    tfr = ShortTimeFourierTransform(sig, timestamps=ts)\n    tfr.run()\n    tfr.plot(show_tf=True, cmap=plt.cm.viridis)\n'"
tftb/processing/plotifl.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.processing.freq_domain import inst_freq\nfrom tftb.generators import fmlin\n\n\ndef plotifl(time_instants, iflaws, signal=None, **kwargs):\n    """"""Plot normalized instantaneous frequency laws.\n\n    :param time_instants: timestamps of the signal\n    :param iflaws: instantaneous freqency law(s) of the signal.\n    :param signal: if provided, display it.\n    :type time_instants: array-like\n    :type iflaws: array-like\n    :type signal: array-like\n    :return: None\n    """"""\n    indices = np.logical_not(np.isnan(iflaws))\n    minif = np.amin(iflaws[indices])\n    fig = plt.figure()\n    if signal is not None:\n        axsig = fig.add_subplot(211)\n        axsig.set_position([0.10, 0.69, 0.80, 0.25])\n        plt.sca(axsig)\n        plt.plot(time_instants, np.real(signal))\n        plt.title(\'Signal\')\n        plt.grid(True)\n        plt.xlim(time_instants.min(), time_instants.max())\n        axtfr = fig.add_subplot(212)\n        axtfr.set_position([0.10, 0.21, 0.80, 0.45])\n        plt.sca(axtfr)\n    plt.plot(time_instants, iflaws)\n    plt.xlim(time_instants.min(), time_instants.max())\n    plt.grid(kwargs.get(\'grid\', True))\n    if minif >= 0:\n        plt.ylim(0, 0.5)\n    else:\n        plt.ylim(-0.5, 0.5)\n    plt.xlabel(\'Time\')\n    plt.ylabel(\'Normalized frequency\')\n    plt.title(\'Instantaneous frequency law(s)\')\n    plt.show()\n\n\nif __name__ == \'__main__\':\n    signal, _ = fmlin(256)\n    time_samples = np.arange(3, 257)\n    ifr = inst_freq(signal)\n    plotifl(time_samples, ifr)\n'"
tftb/processing/postprocessing.py,50,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nPostprocessing functions.\n""""""\n\nimport numpy as np\nfrom tftb.processing.utils import integrate_2d\n\n\ndef hough_transform(image, m=None, n=None):\n    """"""hough_transform\n\n    :param image:\n    :param m:\n    :param n:\n    :type image:\n    :type m:\n    :type n:\n    :return:\n    :rtype:\n    """"""\n    xmax, ymax = image.shape\n    if m is None:\n        m = xmax\n    if n is None:\n        n = ymax\n\n    rhomax = np.sqrt((xmax ** 2) + (ymax ** 2)) / 2.0\n    deltar = rhomax / (m - 1.0)\n    deltat = 2 * np.pi / n\n\n    ht = np.zeros((m, n))\n    imax = np.amax(image)\n\n    if xmax % 2 != 0:\n        xc = (xmax + 1) // 2\n        xf = xc - 1\n    else:\n        xc = xf = xmax // 2\n    x0 = 1 - xc\n\n    if ymax % 2 != 0:\n        yc = (ymax + 1) // 2\n        yf = yc - 1\n    else:\n        yc = yf = ymax // 2\n    y0 = 1 - yc\n\n    for x in range(x0, xf + 1):\n        for y in range(y0, yf + 1):\n            if np.abs(image[x + xc - 1, y + yc - 1]) > imax / 20.0:\n                for theta in np.linspace(0, 2 * np.pi - deltat, n):\n                    rho = x * np.cos(theta) - y * np.sin(theta)\n                    if (rho >= 0) and (rho <= rhomax):\n                        ht[int(np.round(rho / deltar)),\n                           int(np.round(theta / deltat))] += image[x + xc - 1,\n                                                                   y + yc - 1]\n    rho = np.linspace(0, rhomax, n)\n    theta = np.linspace(0, 2 * np.pi - deltat, n)\n    return ht, rho, theta\n\n\ndef renyi_information(tfr, timestamps=None, freq=None, alpha=3.0):\n    """"""renyi_information\n\n    :param tfr:\n    :param timestamps:\n    :param freq:\n    :param alpha:\n    :type tfr:\n    :type timestamps:\n    :type freq:\n    :type alpha:\n    :return:\n    :rtype:\n    """"""\n    if alpha == 1 and tfr.min().min() < 0:\n        raise ValueError(""Distribution with negative values not allowed."")\n    m, n = tfr.shape\n    if timestamps is None:\n        timestamps = np.arange(n) + 1\n    elif np.allclose(timestamps, np.arange(n)):\n        timestamps += 1\n    if freq is None:\n        freq = np.arange(m)\n    freq.sort()\n    tfr = tfr / integrate_2d(tfr, timestamps, freq)\n    if alpha == 1:\n        R = -integrate_2d(tfr * np.log2(tfr + np.spacing(1)), timestamps, freq)\n    else:\n        R = np.log2(integrate_2d(tfr ** alpha, timestamps, freq) + np.spacing(1))\n        R = R / (1 - alpha)\n    return R\n\n\ndef ideal_tfr(iflaws, timestamps=None, n_fbins=None):\n    """"""ideal_tfr\n\n    :param iflaws:\n    :param timestamps:\n    :param n_fbins:\n    :type iflaws:\n    :type timestamps:\n    :type n_fbins:\n    :return:\n    :rtype:\n    """"""\n    ifrow = iflaws.shape[0]\n    if timestamps is None:\n        timestamps = np.arange(iflaws[0, :].shape[0])\n    if n_fbins is None:\n        n_fbins = iflaws[0, :].shape[0]\n\n    tcol = timestamps.shape[0]\n\n    tfr = np.zeros((n_fbins, tcol))\n    for icol in range(tcol):\n        ti = timestamps[icol]\n        for fi in range(ifrow):\n            if np.isnan(iflaws[fi, ti]):\n                tfr[ti, fi] = np.nan\n            else:\n                tfr[int(np.round(iflaws[fi, ti] * 2 * (n_fbins - 1))), icol] = 1\n    freqs = np.arange(n_fbins, dtype=float) / n_fbins * 0.5\n    return tfr, timestamps, freqs\n\n\ndef friedman_density(tfr, re_mat, timestamps=None):\n    """"""friedman_density\n\n    :param tfr:\n    :param re_mat:\n    :param timestamps:\n    :type tfr:\n    :type re_mat:\n    :type timestamps:\n    :return:\n    :rtype:\n    """"""\n    tfrrow, tfrcol = tfr.shape\n    if timestamps is None:\n        timestamps = np.arange(tfrcol)\n\n    tifd = np.zeros((tfrrow, tfrcol))\n    bins = 0.5 + np.arange(tfrrow)\n    bin_edges = np.r_[-np.Inf, 0.5 * (bins[:-1] + bins[1:]), np.Inf]\n    threshold = np.sum(np.sum(tfr)) * 0.5 / tfr.size\n\n    for j in range(tfrcol):\n        indices = tfr[:, j] > threshold\n        if np.any(indices):\n            occurences, _ = np.histogram(np.real(re_mat[indices, j]), bin_edges)\n            tifd[:, j] = occurences\n    tifd = tifd / np.sum(np.sum(tifd))\n    return tifd\n\n\ndef ridges(tfr, re_mat, timestamps=None, method=\'rsp\'):\n    """"""ridges\n\n    :param tfr:\n    :param re_mat:\n    :param timestamps:\n    :param method:\n    :type tfr:\n    :type re_mat:\n    :type timestamps:\n    :type method:\n    :return:\n    :rtype:\n    """"""\n    method = method.lower()\n    tfrrow, tfrcol = tfr.shape\n    if timestamps is None:\n        timestamps = np.arange(tfrcol)\n\n    n_fbins = tfrrow\n    freqs = np.arange(n_fbins)\n    threshold = np.sum(np.sum(tfr)) * 0.5 / tfr.size\n\n    if method in (\'rpwv\', \'rpmh\'):\n        for icol in range(tfrcol):\n            ti = timestamps[icol]\n            indices = np.logical_and(tfr[:, icol] > threshold,\n                                     re_mat[:, icol] - freqs == 0)\n            if np.any(indices):\n                time_points = np.ones((indices.sum(),)) * ti\n                freq_points = np.arange(indices.shape[0])[indices] / (2.0 * n_fbins)\n    elif method == ""rspwv"":\n        for icol in range(tfrcol):\n            ti = timestamps[icol]\n            condt1 = np.real(re_mat[:, icol]) - freqs == 0\n            condt2 = np.imag(re_mat[:, icol]) - icol == 0\n            condt3 = tfr[:, icol] > threshold\n            indices = np.logical_and(condt1, condt2, condt3)\n            if np.any(indices):\n                time_points = np.ones((indices.sum(),)) * ti\n                freq_points = np.arange(indices.shape[0])[indices] / (2.0 * n_fbins)\n    elif method in (""rsp"", ""type1""):\n        for icol in range(tfrcol):\n            ti = timestamps[icol]\n            condt1 = np.real(re_mat[:, icol]) - freqs == 0\n            condt2 = np.imag(re_mat[:, icol]) - icol == 0\n            condt3 = tfr[:, icol] > threshold\n            indices = np.logical_and(condt1, condt2, condt3)\n            if np.any(indices):\n                time_points = np.ones((indices.sum(),)) * ti\n                freq_points = np.arange(indices.shape[0])[indices] / n_fbins\n    else:\n        raise ValueError(""Unknown time frequency representation."")\n    return time_points, freq_points\n\n\nif __name__ == \'__main__\':\n    from tftb.generators import atoms\n    from tftb.processing import Spectrogram\n    s = atoms(64, np.array([[32, 0.3, 16, 1]]))\n    spec = Spectrogram(s)\n    tfr, t, f = spec.run()\n    print(renyi_information(tfr, t, f, 3))\n'"
tftb/processing/reassigned.py,156,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Reassigned TF processing.""""""\n\nimport numpy as np\nimport scipy.signal as ssig\nfrom tftb.processing.utils import derive_window\n\n\ndef pseudo_wigner_ville(signal, timestamps=None, n_fbins=None, fwindow=None):\n    """"""pseudo_wigner_ville\n\n    :param signal:\n    :param timestamps:\n    :param n_fbins:\n    :param fwindow:\n    :type signal:\n    :type timestamps:\n    :type n_fbins:\n    :type fwindow:\n:return:\n:rtype:\n    """"""\n    xrow = signal.shape[0]\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    tcol = timestamps.shape[0]\n\n    if fwindow is None:\n        hlength = np.floor(n_fbins / 4.0)\n        if hlength % 2 == 0:\n            hlength += 1\n        fwindow = ssig.hamming(int(hlength))\n    elif fwindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing fwindow must have an odd length.\')\n    lh = (fwindow.shape[0] - 1) // 2\n    fwindow = fwindow / fwindow[lh]\n\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tf2 = np.zeros((n_fbins, tcol), dtype=complex)\n    dh = derive_window(fwindow)\n    for icol in range(tcol):\n        ti = timestamps[icol]\n        taumax = min([ti - 1, xrow - ti, np.round(n_fbins / 2.0) - 1, lh])\n        tau = np.arange(-taumax, taumax + 1)\n        indices = np.remainder(n_fbins + tau, n_fbins) + 1\n        tfr[indices - 1, icol] = fwindow[lh + tau] * signal[ti + tau - 1] * \\\n            np.conj(signal[ti - tau - 1])\n        tf2[indices - 1, icol] = dh[lh + tau] * signal[ti + tau - 1] * \\\n            np.conj(signal[ti - tau - 1])\n        tau = np.round(n_fbins / 2)\n        if (ti <= (xrow - tau)) and (ti > (tau + 1)) and (tau <= lh):\n            _x = fwindow[lh + 1 + tau] * signal[ti + tau] * np.conj(signal[ti - tau])\n            _y = fwindow[lh + 1 - tau] * signal[ti - tau] * np.conj(signal[ti + tau])\n            tfr[tau + 1, icol] = (_x + _y) * 0.5\n            _x = dh[lh + 1 + tau] * signal[ti + tau] * np.conj(signal[ti - tau])\n            _y = dh[lh + 1 - tau] * signal[ti - tau] * np.conj(signal[ti + tau])\n            tf2[tau + 1, icol] = (_x + _y) * 0.5\n    tfr = np.real(np.fft.fft(tfr, axis=0))\n    tf2 = np.imag(np.fft.fft(tf2, axis=0))\n    tfr = tfr.ravel()\n    tf2 = tf2.ravel()\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] *= n_fbins / tfr[no_warn_mask] / (2 * np.pi)\n    tf2[no_warn_mask] = np.round(tf2[no_warn_mask])\n    tfr = tfr.reshape(n_fbins, tcol)\n    tf2 = tf2.reshape(n_fbins, tcol)\n\n    rtfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tmin = timestamps.min()\n    tmax = timestamps.max()\n    threshold = 1.0e-6 * (np.abs(signal[tmin:(tmax + 1)]) ** 2).mean()\n\n    for icol in range(tcol):\n        for jcol in range(n_fbins):\n            if np.abs(tfr[jcol, icol]) > threshold:\n                jcolhat = jcol - int(tf2[jcol, icol])\n                jcolhat = (((jcolhat - 1) % n_fbins) + n_fbins) % n_fbins\n                jcolhat += 1\n                rtfr[jcolhat - 1, icol] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat\n            else:\n                tf2[jcol, icol] = np.inf\n                rtfr[jcol, icol] += tfr[jcol, icol]\n\n    return tfr, rtfr, tf2\n\n\ndef pseudo_margenau_hill(signal, timestamps=None, n_fbins=None, fwindow=None):\n    """"""pseudo_margenau_hill\n\n    :param signal:\n    :param timestamps:\n    :param n_fbins:\n    :param fwindow:\n    :type signal:\n    :type timestamps:\n    :type n_fbins:\n    :type fwindow:\n:return:\n:rtype:\n    """"""\n    xrow = signal.shape[0]\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    tcol = timestamps.shape[0]\n\n    if fwindow is None:\n        hlength = np.floor(n_fbins / 4.0)\n        if hlength % 2 == 0:\n            hlength += 1\n        fwindow = ssig.hamming(hlength)\n    elif fwindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing fwindow must have an odd length.\')\n    lh = (fwindow.shape[0] - 1) / 2\n    fwindow = fwindow / fwindow[lh]\n\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tf2 = np.zeros((n_fbins, tcol), dtype=complex)\n    dh = derive_window(fwindow)\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    for icol in range(tcol):\n        ti = timestamps[icol]\n        start = min([np.round(n_fbins / 2.0) - 1, lh, xrow - ti])\n        end = min([np.round(n_fbins / 2.0) - 1, lh, ti - 1])\n        tau = np.arange(-start, end + 1)\n        indices = np.remainder(n_fbins + tau, n_fbins)\n        tfr[indices, icol] = fwindow[lh + tau] * signal[ti - 1] * \\\n            np.conj(signal[ti - tau - 1])\n        tf2[indices, icol] = dh[lh + tau] * signal[ti - 1] * \\\n            np.conj(signal[ti - tau - 1])\n\n    tfr = np.fft.fft(tfr, axis=0)\n    tf2 = np.fft.fft(tf2, axis=0)\n    tfr = tfr.ravel()\n    tf2 = tf2.ravel()\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] *= n_fbins / tfr[no_warn_mask] / (2 * np.pi)\n    tf2[no_warn_mask] = np.round(tf2[no_warn_mask])\n    tfr = np.real(tfr)\n    tf2 = np.imag(tf2)\n    tfr = tfr.reshape(n_fbins, tcol)\n    tf2 = tf2.reshape(n_fbins, tcol)\n\n    rtfr = np.zeros((n_fbins, tcol), dtype=complex)\n    threshold = 1.0e-6 * (np.abs(signal) ** 2).mean()\n\n    for icol in range(tcol):\n        for jcol in range(n_fbins):\n            if np.abs(tfr[jcol, icol]) > threshold:\n                jcolhat = jcol - tf2[jcol, icol]\n                jcolhat = (((jcolhat - 1) % n_fbins) + n_fbins) % n_fbins\n                jcolhat += 1\n                rtfr[jcolhat - 1, icol] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat\n            else:\n                tf2[jcol, icol] = np.inf\n                rtfr[jcol, icol] += tfr[jcol, icol]\n\n    return tfr, rtfr, tf2\n\n\ndef pseudo_page(signal, timestamps=None, n_fbins=None, fwindow=None):\n    """"""pseudo_page\n\n    :param signal:\n    :param timestamps:\n    :param n_fbins:\n    :param fwindow:\n    :type signal:\n    :type timestamps:\n    :type n_fbins:\n    :type fwindow:\n:return:\n:rtype:\n    """"""\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    tcol = timestamps.shape[0]\n\n    if fwindow is None:\n        hlength = np.floor(n_fbins / 4.0)\n        if hlength % 2 == 0:\n            hlength += 1\n        fwindow = ssig.hamming(hlength)\n    elif fwindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing fwindow must have an odd length.\')\n    lh = (fwindow.shape[0] - 1) / 2\n    fwindow = fwindow / fwindow[lh]\n\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tf2 = np.zeros((n_fbins, tcol), dtype=complex)\n    dh = derive_window(fwindow)\n\n    for icol in range(tcol):\n        tau = np.arange(min([n_fbins - 1, lh, icol - 1]) + 1)\n        indices = np.remainder(n_fbins + tau, n_fbins) + 1\n        tfr[indices, icol] = fwindow[lh + tau] * signal[icol] * \\\n            np.conj(signal[icol - tau])\n        tf2[indices, icol] = dh[lh + tau] * signal[icol] * \\\n            np.conj(signal[icol - tau])\n        tf2[0, icol] += signal[icol] * np.conj(signal[icol])\n\n    tfr = np.fft.fft(tfr, axis=0)\n    tf2 = np.fft.fft(tf2, axis=0)\n    tfr = tfr.ravel()\n    tf2 = tf2.ravel()\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] *= n_fbins / tfr[no_warn_mask] / (2 * np.pi)\n    tf2[no_warn_mask] = np.round(tf2[no_warn_mask])\n    tfr = np.real(tfr)\n    tf2 = np.imag(tf2)\n    tfr = tfr.reshape(n_fbins, tcol)\n    tf2 = tf2.reshape(n_fbins, tcol)\n\n    rtfr = np.zeros((n_fbins, tcol), dtype=complex)\n    threshold = 1.0e-6 * (np.abs(signal) ** 2).mean()\n\n    for icol in range(tcol):\n        for jcol in range(n_fbins):\n            if np.abs(tfr[jcol, icol]) > threshold:\n                jcolhat = jcol - tf2[jcol, icol]\n                jcolhat = (((jcolhat - 1) % n_fbins) + n_fbins) % n_fbins\n                jcolhat += 1\n                rtfr[jcolhat - 1, icol] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat\n            else:\n                tf2[jcol, icol] = np.inf\n                rtfr[jcol, icol] += tfr[jcol, icol]\n\n    return tfr, rtfr, tf2\n\n\ndef morlet_scalogram(signal, timestamps=None, n_fbins=None, tbp=0.25):\n    """"""morlet_scalogram\n\n    :param signal:\n    :param timestamps:\n    :param n_fbins:\n    :param tbp:\n    :type signal:\n    :type timestamps:\n    :type n_fbins:\n    :type tbp:\n:return:\n:rtype:\n    """"""\n    xrow = signal.shape[0]\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    k = 0.001\n    tcol = timestamps.shape[0]\n    deltat = timestamps[1:] - timestamps[:-1]\n    if deltat.min() != deltat.max():\n        raise ValueError(""Time instants must be regularly sampled."")\n    else:\n        dt = deltat.min()\n\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tf2 = np.zeros((n_fbins, tcol), dtype=complex)\n    M = np.ceil(tbp * n_fbins * np.sqrt(2 * np.log(1 / k)))\n    tau = np.arange(M + int(np.round(n_fbins / 2)) + 1)\n    hstar = np.exp(-(tau / (n_fbins * tbp)) ** 2 / 2.0) * \\\n        np.exp(-1j * 2 * np.pi * tau / n_fbins)\n    thstar = tau * hstar\n\n    for m in range(1, n_fbins // 2):\n        factor = np.sqrt(m / (tbp * n_fbins))\n        for icol in range(tcol):\n            ti = timestamps[icol]\n            tau_neg = np.arange(1, min([np.ceil(M / m), ti - 1]) + 1).astype(int)\n            tau_pos = np.arange(min([np.ceil(M / m), xrow - ti]) + 1).astype(int)\n            # positive frequencies\n            tfr[m, icol] = np.dot(hstar[m * tau_pos - 1],\n                                  signal[ti + tau_pos - 1])\n            tf2[m, icol] = np.dot(thstar[m * tau_pos - 1],\n                                  signal[ti + tau_pos - 1])\n            if tau_neg.shape[0] > 0:\n                tfr[m, icol] += np.dot(np.conj(hstar[tau_neg * m]),\n                                       signal[ti - tau_neg])\n                tf2[m, icol] -= np.dot(np.conj(thstar[tau_neg * m]),\n                                       signal[ti - tau_neg])\n            # negative frequencies\n            tfr[n_fbins - m, icol] = np.dot(np.conj(hstar[tau_pos * m - 1]),\n                                            signal[ti + tau_pos - 1])\n            tf2[n_fbins - m, icol] = np.dot(np.conj(thstar[tau_pos * m - 1]),\n                                            signal[ti + tau_pos - 1])\n            if tau_neg.shape[0] > 0:\n                tfr[n_fbins - m, icol] += np.dot(hstar[tau_neg * m],\n                                                 signal[ti - tau_neg])\n                tf2[n_fbins - m, icol] -= np.dot(thstar[tau_neg * m],\n                                                 signal[ti - tau_neg])\n        tfr[m, :] *= factor\n        tf2[m, :] *= factor / m\n        tfr[n_fbins - m, :] *= factor\n        tf2[n_fbins - m, :] *= factor / m\n\n    m = int(np.round(n_fbins / 2.0))\n    factor = np.sqrt(m / (tbp * n_fbins))\n    for icol in range(tcol):\n        ti = timestamps[icol]\n        tau_neg = np.arange(1, min([np.ceil(M / m), ti - 1]) + 1).astype(int)\n        tau_pos = np.arange(min([np.ceil(M / m), xrow - ti]) + 1).astype(int)\n        tau_pos -= 1\n        tau_neg -= 1\n\n        tfr[m, icol] = np.dot(hstar[m * tau_pos], signal[ti + tau_pos])\n        tf2[m, icol] = np.dot(thstar[m * tau_pos], signal[ti + tau_pos])\n        if tau_neg.shape[0] > 0:\n            tfr[m, icol] += np.dot(np.conj(hstar[tau_neg * m]),\n                                   signal[ti - tau_neg])\n            tf2[m, icol] -= np.dot(np.conj(thstar[tau_neg * m]),\n                                   signal[ti - tau_neg])\n    tfr[m, :] *= factor\n    tf2[m, :] *= factor / m\n\n    tfr, tf2 = tfr.ravel(), tf2.ravel()\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] = tf2[no_warn_mask] / tfr[no_warn_mask]\n    tfr = np.abs(tfr) ** 2\n    tfr = tfr.reshape(n_fbins, tcol)\n    tf2 = tf2.reshape(n_fbins, tcol).astype(complex)\n\n    rtfr = np.zeros((n_fbins, tcol), dtype=complex)\n    ex = np.mean(np.abs(signal) ** 2)\n    threshold = ex * 1.0e-6\n    factor = 2 * np.pi * n_fbins * (tbp ** 2)\n    for icol in range(tcol):\n        for jcol in range(n_fbins):\n            if tfr[jcol, icol] > threshold:\n                icolhat = icol + np.round(np.real(tf2[jcol, icol] / dt))\n                icolhat = min([max([icolhat, 1]), tcol])\n                m = np.remainder(jcol + np.round(n_fbins / 2.0) - 2,\n                                 n_fbins)\n                m -= np.round(n_fbins / 2.0) + 1\n                jcolhat = jcol + np.round(np.imag((m ** 2) * tf2[jcol, icol] / factor))\n                jcolhat = ((((jcolhat - 1) % n_fbins) + n_fbins) % n_fbins) + 1\n                rtfr[jcolhat - 1, icolhat - 1] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat + 1j * icolhat\n            else:\n                tf2[jcol, icol] = np.inf * (1 + 1j)\n                rtfr[jcol, icol] += tfr[jcol, icol]\n\n    return tfr, rtfr, tf2\n\n\ndef smoothed_pseudo_wigner_ville(signal, timestamps=None, n_fbins=None,\n                                 twindow=None, fwindow=None):\n    """"""smoothed_pseudo_wigner_ville\n\n    :param signal:\n    :param timestamps:\n    :param n_fbins:\n    :param twindow:\n    :param fwindow:\n    :type signal:\n    :type timestamps:\n    :type n_fbins:\n    :type twindow:\n    :type fwindow:\n:return:\n:rtype:\n    """"""\n    xrow = signal.shape[0]\n\n    if timestamps is None:\n        timestamps = np.arange(signal.shape[0])\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    if fwindow is None:\n        hlength = np.floor(n_fbins / 4.0)\n        hlength += 1 - (hlength % 2)\n        fwindow = ssig.hamming(hlength)\n    elif fwindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing window must have an odd length.\')\n    lh = (fwindow.shape[0] - 1) / 2\n\n    if twindow is None:\n        glength = np.floor(n_fbins / 4.0)\n        glength += 1 - (glength % 2)\n        twindow = ssig.hamming(glength)\n    elif twindow.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing window must have an odd length.\')\n    lg = (twindow.shape[0] - 1) / 2\n\n    tcol = timestamps.shape[0]\n    deltat = timestamps[1:] - timestamps[:-1]\n    if deltat.min() != deltat.max():\n        raise ValueError(""Time instants must be regularly sampled."")\n    else:\n        dt = deltat.min()\n\n    tfr = np.zeros((n_fbins, tcol), dtype=complex)\n    tf2 = np.zeros((n_fbins, tcol), dtype=complex)\n    tf3 = np.zeros((n_fbins, tcol), dtype=complex)\n    dh = derive_window(fwindow)\n\n    for icol in range(tcol):\n        ti = timestamps[icol]\n        taumax = min([ti + lg - 1, xrow - ti + lg, np.round(n_fbins / 2.0) - 1,\n                      lh])\n        points = np.arange(-min([lg, xrow - ti]), min([lg, ti - 1]) + 1)\n        g2 = twindow[lg + points]\n        g2 = g2 / g2.sum()\n        tg2 = g2 * points\n        xx = signal[ti - 1 - points] * np.conj(signal[ti - 1 - points])\n        tfr[0, icol] = (g2 * xx).sum()\n        tf2[0, icol] = (tg2 * xx).sum()\n        tf3[0, icol] = dh[lh + 1] * tfr[0, icol]\n\n        for tau in range(int(taumax)):\n            points = np.arange(-min([lg, xrow - ti - tau]),\n                               min([lg, ti - tau - 1]) + 1)\n            g2 = twindow[lg + points]\n            g2 = g2 / g2.sum()\n            tg2 = g2 * points\n            xx = signal[ti + tau - 1 - points] * np.conj(signal[ti - tau - 1 - points])\n            tfr[tau, icol] = (g2 * xx).sum() * fwindow[lh + tau]\n            tf2[tau, icol] = fwindow[lh + tau] * (tg2 * xx).sum()\n            tf3[tau, icol] = dh[lh + tau] * (g2 * xx).sum()\n            tfr[n_fbins - tau - 1, icol] = (g2 * np.conj(xx)).sum() * fwindow[lh - tau]\n            tf2[n_fbins - tau - 1, icol] = (tg2 * np.conj(xx)).sum() * fwindow[lh - tau]\n            tf3[n_fbins - tau - 1, icol] = dh[lh - tau] * (g2 * np.conj(xx)).sum()\n\n    tfr = np.real(np.fft.fft(tfr, axis=0)).ravel()\n    tf2 = np.real(np.fft.fft(tf2, axis=0)).ravel()\n    tf3 = np.imag(np.fft.fft(tf3, axis=0)).ravel()\n\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] = np.round(tf2[no_warn_mask] / tfr[no_warn_mask] / dt)\n    tf3[no_warn_mask] = np.round(\n        n_fbins * tf3[no_warn_mask] / tfr[no_warn_mask] / (2 * np.pi))\n    tfr, tf2, tf3 = [x.reshape(n_fbins, tcol).astype(complex) for x in (tfr, tf2, tf3)]\n    tf3 = np.real(tf3)\n\n    rtfr = np.zeros((n_fbins, tcol), dtype=complex)\n    ex = np.mean(np.abs(signal) ** 2)\n    threshold = ex * 1.0e-6\n\n    for icol in range(tcol):\n        for jcol in range(n_fbins):\n            if np.abs(tfr[jcol, icol]) > threshold:\n                icolhat = min(max([icol - tf2[jcol, icol], 1]), tcol)\n                jcolhat = jcol - tf3[jcol, icol]\n                jcolhat = (((int(jcolhat) - 1) % n_fbins) + n_fbins) % n_fbins + 1\n                rtfr[jcol, icol] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat + 1j * icolhat\n            else:\n                tf2[jcol, icol] = np.inf * (1 + 1j)\n                rtfr[jcol, icol] += tfr[jcol, icol]\n\n    return tfr, rtfr, tf2\n\n\ndef spectrogram(signal, time_samples=None, n_fbins=None, window=None):\n    """"""Compute the spectrogram and reassigned spectrogram.\n\n    :param signal: signal to be analzsed\n    :param time_samples: time instants (default: np.arange(len(signal)))\n    :param n_fbins: number of frequency bins (default: len(signal))\n    :param window: frequency smoothing window (default: Hamming with \\\n        size=len(signal)/4)\n    :type signal: array-like\n    :type time_samples: array-like\n    :type n_fbins: int\n    :type window: array-like\n    :return: spectrogram, reassigned specstrogram and matrix of reassignment\n    vectors\n    :rtype: tuple(array-like)\n    """"""\n\n    if time_samples is None:\n        time_samples = np.arange(signal.shape[0])\n    elif np.unique(np.diff(time_samples)).shape[0] > 1:\n        raise ValueError(\'Time instants must be regularly sampled.\')\n    if n_fbins is None:\n        n_fbins = signal.shape[0]\n    if window is None:\n        wlength = int(np.floor(signal.shape[0] / 4.0))\n        wlength += 1 - np.remainder(wlength, 2)\n        window = ssig.hamming(wlength)\n    elif window.shape[0] % 2 == 0:\n        raise ValueError(\'The smoothing window must have an odd length.\')\n\n    tfr = np.zeros((n_fbins, time_samples.shape[0]), dtype=complex)\n    tf2 = np.zeros((n_fbins, time_samples.shape[0]), dtype=complex)\n    tf3 = np.zeros((n_fbins, time_samples.shape[0]), dtype=complex)\n    lh = (window.shape[0] - 1) // 2\n    th = window * np.arange(-lh, lh + 1)\n    dwin = derive_window(window)\n\n    for icol in range(time_samples.shape[0]):\n        ti = time_samples[icol]\n        tau = np.arange(-np.min([np.round(n_fbins / 2) - 1, lh, ti]),\n                        np.min([np.round(n_fbins / 2) - 1, lh,\n                                signal.shape[0] - ti]) + 1).astype(int)\n        indices = np.remainder(n_fbins + tau, n_fbins)\n        norm_h = np.linalg.norm(window[lh + tau], ord=2)\n        tfr[indices, icol] = signal[ti + tau - 1] * np.conj(window[lh + tau]) / norm_h\n        tf2[indices, icol] = signal[ti + tau - 1] * np.conj(th[lh + tau]) / norm_h\n        tf3[indices, icol] = signal[ti + tau - 1] * np.conj(dwin[lh + tau]) / norm_h\n\n    tfr = np.fft.fft(tfr, axis=0).ravel()\n    tf2 = np.fft.fft(tf2, axis=0).ravel()\n    tf3 = np.fft.fft(tf3, axis=0).ravel()\n\n    no_warn_mask = tfr != 0\n    tf2[no_warn_mask] = np.round(np.real(tf2[no_warn_mask] / tfr[no_warn_mask]))\n    tf3[no_warn_mask] = np.round(\n        np.imag(n_fbins * tf3[no_warn_mask] / tfr[no_warn_mask] / (2 * np.pi)))\n\n    tfr = np.abs(tfr) ** 2\n    tfr = tfr.reshape(n_fbins, time_samples.shape[0])\n    tf2 = tf2.reshape(n_fbins, time_samples.shape[0])\n    tf3 = tf3.reshape(n_fbins, time_samples.shape[0])\n    tf3 = np.real(tf3)\n\n    rtfr = np.zeros((n_fbins, time_samples.shape[0]), dtype=complex)\n    ix = np.arange(time_samples.min(), time_samples.max() + 1) - 1\n    threshold = 1e-6 * np.mean(np.abs(signal[ix])**2)\n    for icol in range(time_samples.shape[0]):\n        for jcol in range(n_fbins):\n            if np.abs(tfr[jcol, icol]) > threshold:\n                icolhat = icol + tf2[jcol, icol]\n                icolhat = np.min([np.max([icolhat, 1]), time_samples.shape[0]])\n                jcolhat = jcol - tf3[jcol, icol]\n                jcolhat = (((jcolhat - 1) % n_fbins) + n_fbins) % n_fbins\n                rtfr[int(jcolhat), int(icolhat) - 1] += tfr[jcol, icol]\n                tf2[jcol, icol] = jcolhat + 1j * icolhat\n            else:\n                tf2[jcol, icol] = np.inf\n                rtfr[jcol, icol] += tfr[jcol, icol]\n    return tfr, rtfr, tf2\n\n\nif __name__ == \'__main__\':\n    from tftb.generators import fmlin\n    import matplotlib.pyplot as plt\n    ts = np.arange(128, step=2)\n    sig = fmlin(128, 0.1, 0.4)[0]\n    fwindow = ssig.kaiser(17, beta=3 * np.pi)\n    _, rtfr, _ = pseudo_wigner_ville(sig, timestamps=ts, n_fbins=64,\n                                     fwindow=fwindow)\n    rtfr = np.abs(rtfr) ** 2\n    threshold = np.amax(rtfr) * 0.05\n    rtfr[rtfr <= threshold] = 0.0\n    plt.imshow(rtfr[:64, :], aspect=\'auto\', origin=""bottomleft"",\n               extent=[0, 128, 0, 0.5])\n    plt.show()\n'"
tftb/processing/time_domain.py,4,"b'import numpy as np\n\n\ndef loctime(sig):\n    """"""\n    Compute the time localization characteristics.\n\n    :param sig: input signal\n    :type sig: numpy.ndarray\n    :return: Average time center and time spreading\n    :rtype: tuple\n    :Example:\n    >>> from tftb.generators import amgauss\n    >>> x = amgauss(160, 80.0, 50.0)\n    >>> tm, T = loctime(x)\n    >>> print(""%.2f"" % tm)\n    79.00\n    >>> print(""%.2f"" % T)\n    50.00\n    """"""\n    if sig.ndim > 2:\n        if 1 not in sig.shape:\n            raise TypeError\n        else:\n            sig = sig.ravel()\n    sig2 = np.abs(sig**2)\n    sig2 = sig2 / sig2.mean()\n    t = np.arange(len(sig))\n    tm = np.mean(t * sig2)\n    T = 2 * np.sqrt(np.pi * np.mean(((t - tm)**2) * sig2))\n    return tm, T\n'"
tftb/processing/utils.py,7,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Miscellaneous processing utilities.""""""\n\nimport numpy as np\n\n\ndef get_spectrum(signal):\n    return np.fft.fftshift(np.abs(np.fft.fft(signal)) ** 2)\n\n\ndef integrate_2d(mat, x=None, y=None):\n    """"""integrate_2d\n\n    :param mat:\n    :param x:\n    :param y:\n    :type mat:\n    :type x:\n    :type y:\n:return:\n:rtype:\n    :Example:\n    >>> from __future__ import print_function\n    >>> from tftb.generators import altes\n    >>> from tftb.processing import Scalogram\n    >>> x = altes(256, 0.1, 0.45, 10000)\n    >>> tfr, t, f, _ = Scalogram(x).run()\n    >>> print(""%.3f"" % integrate_2d(tfr, t, f))\n    2.000\n    """"""\n    m, n = mat.shape\n    if x is None:\n        x = np.arange(n)\n    if y is None:\n        y = np.arange(m)\n\n    mat = (mat.sum(1) - mat[:, 0] / 2.0 - mat[:, n - 1] / 2.0) * (x[1] - x[0])\n    dmat = mat[:(m - 1)] + mat[1:]\n    dy = (y[1:] - y[:(m - 1)]) / 2.0\n    return np.sum(dmat * dy)\n\n\ndef derive_window(window):\n    """"""Calculate derivative of a window function.\n\n    :param window: Window function to be differentiated. This is expected to be\n    a standard window function with an odd length.\n    :type window: array-like\n    :return: Derivative of the input window\n    :rtype: array-like\n    :Example:\n    >>> from scipy.signal import hanning\n    >>> import matplotlib.pyplot as plt                   #doctest: +SKIP\n    >>> window = hanning(210)\n    >>> derivation = derive_window(window)\n    >>> plt.subplot(211), plt.plot(window)                #doctest: +SKIP\n    >>> plt.subplot(212), plt.plot(derivation) #doctest: +SKIP\n\n    .. plot:: docstring_plots/processing/utils/derive_window.py\n    """"""\n    lh = (window.shape[0] - 1) / 2.0\n    step_height = (window[0] + window[-1]) / 2.0\n    ramp = (window[0] - window[-1]) / (window.shape[0] - 1)\n    base = np.arange(-lh, lh + 1)\n    base = window - step_height - ramp * base\n    base = np.hstack((np.array([0]), base, np.array([0])))\n    dw = (base[2:(window.shape[0] + 2)] - base[:window.shape[0]]) / 2.0 + ramp\n    dw[0] += step_height\n    dw[-1] -= step_height\n    return dw\n\n\nif __name__ == \'__main__\':\n    x = np.arange(1, 16).reshape(5, 3)\n    print(integrate_2d(x))\n'"
tftb/tests/__init__.py,0,b''
tftb/tests/test_base.py,20,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Base class for tests.""""""\n\nimport unittest\nimport numpy as np\nfrom scipy import angle\nfrom tftb.utils import is_linear\nfrom skimage.measure import compare_ssim\n\n\nclass TestBase(unittest.TestCase):\n\n    def assert_is_linear(self, signal, decimals=5):\n        """"""Assert that the signal is linear.""""""\n        self.assertTrue(is_linear(signal, decimals=decimals))\n\n    def assert_is_analytic(self, signal, amlaw=None):\n        """"""Assert that signal is analytic.""""""\n        omega = angle(signal)\n        if amlaw is not None:\n            recons = np.exp(1j * omega) * amlaw\n        else:\n            recons = np.exp(1j * omega)\n        real_identical = np.allclose(np.real(recons), np.real(signal))\n        imag_identical = np.allclose(np.imag(recons), np.imag(signal))\n        if not (imag_identical and real_identical):\n            raise AssertionError(""Signal is not analytic."")\n\n    def assert_is_concave(self, signal):\n        second_derivative = np.diff(np.diff(signal))\n        if not np.all(second_derivative < 0):\n            raise AssertionError(""Signal is not concave."")\n\n    def assert_is_convex(self, signal):\n        second_derivative = np.diff(np.diff(signal))\n        if not np.all(second_derivative > 0):\n            raise AssertionError(""Signal is not convex."")\n\n    def assert_is_monotonic_increasing(self, signal):\n        derivative = np.diff(signal)\n        if not np.all(derivative >= 0):\n            raise AssertionError(""Signal is not monotonically increasing."")\n\n    def assert_is_monotonic_decreasing(self, signal):\n        derivative = np.diff(signal)\n        if not np.all(derivative <= 0):\n            raise AssertionError(""Signal is not monotonically decreasing."")\n\n    def assert_is_hermitian(self, x):\n        """"""Assert that the input is a Hermitian matrix.""""""\n        conj_trans = np.conj(x).T\n        np.testing.assert_allclose(x, conj_trans)\n\n    def assert_tfr_equal(self, x, y, sqmod=True, threshold=0.05, tol=0.99):\n        """"""Assert that TFRs x and y are qualitatively equivalent.""""""\n        if sqmod:\n            x = np.abs(x) ** 2\n            y = np.abs(y) ** 2\n        x_thresh = np.amax(x) * threshold\n        x[x <= x_thresh] = 0.0\n        y_thresh = np.amax(y) * threshold\n        y[y <= y_thresh] = 0.0\n        x = np.ascontiguousarray(x)\n        y = np.ascontiguousarray(y)\n        similarity = compare_ssim(x, y)\n        self.assertTrue(similarity >= tol)\n'"
tftb/tests/test_utils.py,17,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.utils\n""""""\n\nimport unittest\nimport numpy as np\nfrom tftb import utils\n\n\nclass TestUtils(unittest.TestCase):\n\n    def test_is_linear(self):\n        """"""Test the is_linear function.""""""\n        x = np.arange(10)\n        self.assertTrue(utils.is_linear(x))\n        x = np.sin(x)\n        self.assertFalse(utils.is_linear(x))\n\n    def test_nextpow2(self):\n        """"""Test the nextpow2 function.""""""\n        self.assertEqual(utils.nextpow2(2), 1)\n        self.assertEqual(utils.nextpow2(17), 5)\n        import warnings\n        with warnings.catch_warnings(record=True) as catcher:\n            utils.nextpow2(-3)\n            self.assertEqual(len(catcher), 1)\n            self.assertTrue(catcher[-1].category, RuntimeWarning)\n\n    def test_divider(self):\n        """"""Test the divider function.""""""\n        self.assertSequenceEqual(utils.divider(4), (2, 2))\n        self.assertSequenceEqual(utils.divider(17), (1, 17))\n        self.assertSequenceEqual(utils.divider(60), (6, 10))\n        x = np.arange(1, 101)\n        lowers = np.zeros(x.shape)\n        uppers = np.zeros(x.shape)\n        for i, num in enumerate(x):\n            a, b = utils.divider(num)\n            lowers[i] = a\n            uppers[i] = b\n        perfect_squares = np.arange(1, 11) ** 2\n        np.testing.assert_allclose(perfect_squares, x[lowers == uppers])\n\n    def test_nearest_odd(self):\n        """"""Test the nearest_odd function.""""""\n        self.assertEqual(utils.nearest_odd(0), 1)\n        self.assertEqual(utils.nearest_odd(2), 3)\n        self.assertEqual(utils.nearest_odd(-0.00001), -1)\n\n    def test_modulo(self):\n        """"""Test the modulo function.""""""\n        x = np.arange(1, 11)\n        np.testing.assert_allclose(utils.modulo(x, 1), np.ones(x.shape))\n        np.testing.assert_allclose(utils.modulo(x, 2),\n                                   np.array([1, 2, 1, 2, 1, 2, 1, 2, 1, 2]))\n        np.testing.assert_allclose(utils.modulo(x, 3),\n                                   np.array([1, 2, 3, 1, 2, 3, 1, 2, 3, 1]))\n        np.testing.assert_allclose(utils.modulo(x, 4),\n                                   np.array([1, 2, 3, 4, 1, 2, 3, 4, 1, 2]))\n        np.testing.assert_allclose(utils.modulo(x, 5),\n                                   np.array([1, 2, 3, 4, 5, 1, 2, 3, 4, 5]))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
doc/_gallery/noplot/noplot_4_1_2_sin_gauss_spwv.py,8,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nExample from section 4.1.2 of the tutorials.\n\nFigure 4.10 from the tutorial.\n""""""\n\nfrom tftb.generators import fmconst, amgauss\nfrom tftb.processing import smoothed_pseudo_wigner_ville\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nfrom scipy.signal import kaiser, hamming\n\ntwindow = kaiser(13, 3 * np.pi)\nfwindow = kaiser(33, 3 * np.pi)\ntwindow = hamming(13)\nfwindow = hamming(33)\n\nsig = fmconst(128, 0.15)[0] + amgauss(128) * fmconst(128, 0.4)[0]\ntfr = smoothed_pseudo_wigner_ville(sig, twindow=twindow, fwindow=fwindow,\n                                   freq_bins=128)\nthreshold = np.abs(tfr) * 0.05\ntfr[np.abs(tfr) <= threshold] = 0.0\n\nfig, axImage = plt.subplots()\naxImage.contour(np.abs(tfr), extent=[0, 128, 0, 0.5], levels=list(range(5)))\naxImage.grid(True)\naxImage.set_title(""Wigner Ville distribution"")\naxImage.set_ylabel(\'Frequency\')\naxImage.set_xlabel(\'Time\')\n\ndivider = make_axes_locatable(axImage)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(sig))\naxTime.set_xlim(0, 128)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\nspectrum = abs(np.fft.fftshift(np.fft.fft(sig)) ** 2)[64:]\naxFreq.plot(spectrum, np.arange(spectrum.shape[0]))\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.grid(True)\nplt.show()\n'"
doc/_gallery/noplot/noplot_4_3_5_morlet_scalogram_spectrogram.py,13,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nComparison of the Spectrogram and the morlet scalogram with their reassinged\ncounterparts.\n\nFigure 4.36 from the tutorial\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import fmsin, fmlin, fmconst\nfrom tftb.processing.cohen import Spectrogram\nfrom tftb.processing.reassigned import spectrogram as re_spectrogram\nfrom tftb.processing.reassigned import morlet_scalogram as re_morlet_scalogram\nfrom tftb.processing import ideal_tfr\n\nsig1, if1 = fmsin(60, 0.16, 0.35, 50, 1, 0.35, 1)\nsig2, if2 = fmlin(60, 0.3, 0.1)\nsig3, if3 = fmconst(60, 0.4)\n\nsig = np.hstack((sig1, np.zeros((8,)), sig2 + sig3))\niflaw = np.zeros((2, 128))\niflaw[0, :] = np.hstack((if1, np.nan * np.ones((8,)), if2))\niflaw[1, :] = np.hstack((np.nan * np.ones((68,)), if3))\n\ntfr, t, f = ideal_tfr(iflaw)\nplt.figure(figsize=(10, 8))\nplt.subplot(221)\nplt.contour(t, f, tfr, 1)\nplt.grid(True)\nplt.gca().set_xticklabels([])\nplt.title(""Ideal instantaneous frequencies"")\nplt.ylabel(\'Normalized Frequencies\')\n\ntfr, _, _ = Spectrogram(sig).run()\nthreshold = np.amax(np.abs(tfr)) * 0.05\ntfr[np.abs(tfr) <= threshold] = 0.0\nplt.subplot(222)\nplt.imshow(np.abs(tfr)[:64, :], extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.gca().set_xticklabels([])\nplt.gca().set_yticklabels([])\nplt.title(""Spectrogram"")\n\n_, tfr, _ = re_spectrogram(sig)\ntfr = tfr[:64, :]\nthreshold = np.amax(np.abs(tfr) ** 2) * 0.05\ntfr[np.abs(tfr) ** 2 <= threshold] = 0.0\nplt.subplot(223)\nplt.imshow(np.abs(tfr) ** 2, extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""Reassigned spectrogram"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequencies\')\n\n_, rtfr, _ = re_morlet_scalogram(sig)\nrtfr = rtfr[:64, :]\nthreshold = np.amax(np.abs(rtfr) ** 2) * 0.05\nrtfr[np.abs(rtfr) ** 2 <= threshold] = 0.0\nplt.subplot(224)\nplt.imshow(np.abs(rtfr) ** 2, extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.gca().set_yticklabels([])\nplt.grid(True)\nplt.title(""Reassigned Morlet Scalogram"")\nplt.xlabel(\'Time\')\n\nplt.show()\n'"
doc/_gallery/noplot/noplot_4_3_5_page_margenau_hill.py,12,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nComparison of the pseudo Page and the pseudo Margenau-Hill distributions with\ntheir reassinged counterparts.\n\nFigure 4.37 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import fmsin, fmlin, fmconst\nfrom tftb.processing.cohen import PseudoPageRepresentation, PseudoMargenauHillDistribution\nfrom tftb.processing.reassigned import pseudo_page as re_pseudo_page\nfrom tftb.processing.reassigned import pseudo_margenau_hill as re_pseudo_margenau_hill\n\nsig1, if1 = fmsin(60, 0.16, 0.35, 50, 1, 0.35, 1)\nsig2, if2 = fmlin(60, 0.3, 0.1)\nsig3, if3 = fmconst(60, 0.4)\n\nsig = np.hstack((sig1, np.zeros((8,)), sig2 + sig3))\niflaw = np.zeros((2, 128))\niflaw[0, :] = np.hstack((if1, np.nan * np.ones((8,)), if2))\niflaw[1, :] = np.hstack((np.nan * np.ones((68,)), if3))\n\ntfr, t, f = PseudoPageRepresentation(sig).run()\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\n\nplt.figure(figsize=(10, 8))\nplt.subplot(221)\nplt.imshow(tfr[:64, :], extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.gca().set_xticklabels([])\nplt.grid(True)\nplt.title(""Pseudo Page distribution"")\nplt.ylabel(\'Normalized Frequencies\')\n\n_, tfr, _ = re_pseudo_page(sig)\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\nplt.subplot(222)\nplt.imshow(tfr[:64, :], extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""Reassigned Pseudo Page distribution"")\nplt.gca().set_xticklabels([])\nplt.gca().set_yticklabels([])\n\ntfr, _, _ = PseudoMargenauHillDistribution(sig).run()\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\nplt.subplot(223)\nplt.imshow(tfr[:64, :], extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""Pseudo Margenau Hill distribution"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequencies\')\n\n_, rtfr, _ = re_pseudo_margenau_hill(sig)\ntfr = np.abs(tfr) ** 2\nthreshold = np.amax(tfr) * 0.05\ntfr[tfr <= threshold] = 0.0\nplt.subplot(224)\nplt.imshow(tfr[:64, :], extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.gca().set_yticklabels([])\nplt.grid(True)\nplt.title(""Reassigned Pseudo Margenau Hill distribution"")\nplt.xlabel(\'Time\')\n\nplt.show()\n'"
doc/_gallery/noplot/noplot_4_3_5_wv_smoothed_reassigned.py,13,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nComparison of the Wigner Ville distribution with its smoothed and reassinged\ncounterparts.\n\nFigure 4.35 from the tutorial.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import fmsin, fmlin, fmconst\nfrom tftb.processing import (ideal_tfr, WignerVilleDistribution,\n        smoothed_pseudo_wigner_ville, reassigned_smoothed_pseudo_wigner_ville)\n\nsig1, if1 = fmsin(60, 0.16, 0.35, 50, 1, 0.35, 1)\nsig2, if2 = fmlin(60, 0.3, 0.1)\nsig3, if3 = fmconst(60, 0.4)\n\nsig = np.hstack((sig1, np.zeros((8,)), sig2 + sig3))\niflaw = np.zeros((2, 128))\niflaw[0, :] = np.hstack((if1, np.nan * np.ones((8,)), if2))\niflaw[1, :] = np.hstack((np.nan * np.ones((68,)), if3))\n\ntfr, t, f = ideal_tfr(iflaw)\n\nplt.figure(figsize=(10, 8))\nplt.subplot(221)\nplt.contour(t, f, tfr, 1)\nplt.gca().set_xticklabels([])\nplt.grid(True)\nplt.title(""Ideal instantaneous frequencies"")\nplt.ylabel(\'Normalized Frequencies\')\n\ntfr = WignerVilleDistribution(sig).run()[0]\nthreshold = np.amax(np.abs(tfr) ** 2) * 0.05\ntfr[np.abs(tfr) ** 2 <= threshold] = 0.0\nplt.subplot(222)\nplt.imshow(np.abs(tfr) ** 2, extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""WV distro"")\nplt.gca().set_xticklabels([])\nplt.gca().set_yticklabels([])\n\ntfr = smoothed_pseudo_wigner_ville(sig)\nthreshold = np.amax(np.abs(tfr) ** 2) * 0.05\ntfr[np.abs(tfr) ** 2 <= threshold] = 0.0\nplt.subplot(223)\nplt.imshow(np.abs(tfr) ** 2, extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""Smoothed Pseudo WV distro"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Normalized Frequencies\')\n\n_, rtfr, _ = reassigned_smoothed_pseudo_wigner_ville(sig)\nthreshold = np.amax(np.abs(rtfr) ** 2) * 0.05\nrtfr[np.abs(rtfr) ** 2 <= threshold] = 0.0\nplt.subplot(224)\nplt.imshow(np.abs(rtfr) ** 2, extent=[0, 128, 0, 0.5], aspect=\'auto\', origin=\'bottomleft\')\nplt.grid(True)\nplt.title(""Reassigned Smoothed Pseudo WV distro"")\nplt.xlabel(\'Time\')\nplt.gca().set_yticklabels([])\n\nplt.show()\n'"
doc/_gallery/noplot/noplot_5_3_renyi_information.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nExamples showing Renyi information measurement.\n""""""\n\nimport numpy as np\nfrom scipy.io import loadmat\nfrom tftb.generators import atoms\nfrom tftb.processing import renyi_information\nfrom tftb.processing.cohen import WignerVilleDistribution\n\nsig = atoms(128, np.array([[64, 0.25, 20, 1]]))\ntfr, t, f = WignerVilleDistribution(sig).run()\nideal = loadmat(""/tmp/foo.mat"")\nprint(renyi_information(tfr, t, f))  # -0.2075\n\nsig = atoms(128, np.array([[32, 0.25, 20, 1], [96, 0.25, 20, 1]]))\ntfr, t, f = WignerVilleDistribution(sig).run()\nprint(renyi_information(tfr, t, f))  # 0.77\n\nsig = atoms(128, np.array([[32, 0.15, 20, 1], [96, 0.15, 20, 1],\n                           [32, 0.35, 20, 1], [96, 0.35, 20, 1]]))\ntfr, t, f = WignerVilleDistribution(sig).run()\nprint(renyi_information(tfr, t, f))  # 1.8029\n'"
doc/_gallery/noplot/noplot_5_5_scalogram_singularity.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nMorlet Scalograms of Lipschitz singularities.\n\nFigure 5.7 from the tutorial\n""""""\n\nfrom tftb.processing import scalogram\nfrom tftb.generators import anasing\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\n\n\nsig = anasing(64)\n\ntfr, t, f, _ = scalogram(sig, waveparams=4, fmin=0.01, fmax=0.5, n_voices=256)\n\nt, f = np.meshgrid(t, f)\n\nfig, axContour = plt.subplots()\naxContour.contour(t, f, tfr, 10)\naxContour.grid(True)\naxContour.set_title(""Morlet Scalogram of Lipschitz singularity"")\naxContour.set_ylabel(\'Frequency\')\naxContour.set_xlabel(\'Time\')\n\ndivider = make_axes_locatable(axContour)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(sig))\naxTime.set_xlim(0, 64)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\naxFreq.plot((abs(np.fft.fftshift(np.fft.fft(sig))) ** 2)[::-1],\n            np.arange(sig.shape[0]))\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.grid(True)\nplt.show()\nplt.show()\n'"
doc/_gallery/noplot/noplot_5_5_scalogram_singularity_strength.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n===========================================\nMorlet Scalogram of a Lipschitz Singularity\n===========================================\n\nThe time localization of the Lipschitz function can be seen at smaller scales.\n\nFigure 5.8 from the tutorial.\n""""""\n\nfrom tftb.processing import scalogram\nfrom tftb.generators import anasing\nimport numpy as np\nfrom mpl_toolkits.axes_grid1 import make_axes_locatable\nimport matplotlib.pyplot as plt\n\n\nsig = anasing(64, 32, -0.5)\n\ntfr, t, f, _ = scalogram(sig, waveparams=4, fmin=0.01, fmax=0.5, n_voices=256)\n\nt, f = np.meshgrid(t, f)\n\nfig, axContour = plt.subplots()\naxContour.contour(t, f, tfr, 10)\naxContour.grid(True)\naxContour.set_title(""Morlet Scalogram of Lipschitz singularity"")\naxContour.set_ylabel(\'Frequency\')\naxContour.set_xlabel(\'Time\')\n\ndivider = make_axes_locatable(axContour)\naxTime = divider.append_axes(""top"", 1.2, pad=0.5)\naxFreq = divider.append_axes(""left"", 1.2, pad=0.5)\naxTime.plot(np.real(sig))\naxTime.set_xlim(0, 64)\naxTime.set_ylabel(\'Real part\')\naxTime.set_title(\'Signal in time\')\naxTime.grid(True)\naxFreq.plot((abs(np.fft.fftshift(np.fft.fft(sig))) ** 2)[::-1],\n            np.arange(sig.shape[0]))\naxFreq.set_ylabel(\'Spectrum\')\naxFreq.grid(True)\nplt.show()\nplt.show()\n'"
doc/docstring_plots/processing/stft.py,1,"b'from tftb.processing.linear import ShortTimeFourierTransform\nfrom tftb.generators import fmconst\nimport numpy as np\nsig = np.r_[fmconst(128, 0.2)[0], fmconst(128, 0.4)[0]]\ntfr = ShortTimeFourierTransform(sig)\ntfr.run()\ntfr.plot()\n'"
tftb/generators/tests/__init__.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for the generatos module.\n""""""\n'"
tftb/generators/tests/test_amplitude_modulations.py,5,"b'import unittest\nimport numpy as np\nfrom numpy import pi\nfrom scipy.signal import argrelmax\nfrom tftb.tests.test_base import TestBase\nimport tftb.generators.amplitude_modulated as am\n\n\nclass TestAmplitudeModulated(TestBase):\n\n    def test_amgauss(self):\n        """"""Test if the gaussian amplitude modulator works correctly.""""""\n        time_center = 63\n        n_points = 128\n        spread = 10\n        signal = am.amgauss(n_points, time_center, spread)\n        # parameters of the underlying gaussian function of the form\n        # f(x) = a * exp( (-(x - b) **2) / (2 * (c ** 2)))\n        a, b, c = 1, time_center, spread / np.sqrt(2 * pi)\n        # Integral of a Gaussian is a * c * sqrt( 2 * pi)\n        integral = a * c * np.sqrt(2 * pi)\n        self.assertAlmostEqual(integral, signal.sum())\n\n        # Other miscellaneous properties of a Gaussian\n        maximum = argrelmax(signal)\n        self.assertEqual(len(maximum), 1)\n        self.assertEqual(maximum[0][0], time_center - 1)\n        self.assertAlmostEqual(signal[time_center - 1], 1.0)\n\n        self.assert_is_monotonic_increasing(signal[:(time_center - 1)])\n        self.assert_is_monotonic_decreasing(signal[(time_center - 1):])\n\n        infpl1 = np.floor(b - c).astype(int) - 1\n        infpl2 = np.floor(b + c).astype(int)\n        self.assert_is_convex(signal[:infpl1])\n        self.assert_is_concave(signal[infpl1:infpl2])\n        self.assert_is_convex(signal[infpl2:])\n\n    def test_amexpos(self):\n        """"""Test exponential amplitude modulation.""""""\n        n_points, center, spread = 128, 63, 10.0\n        one_sided = am.amexpos(n_points, center, spread, kind=""unilateral"")\n        self.assertEqual(one_sided.max(), 1.0)\n        self.assert_is_monotonic_decreasing(one_sided[center:])\n        two_sided = am.amexpos(n_points, center, spread)\n        self.assertEqual(two_sided.max(), 1.0)\n        self.assert_is_monotonic_decreasing(two_sided[center:])\n        self.assert_is_monotonic_increasing(two_sided[:center])\n\n    def test_amrect(self):\n        """"""Test rectangular amplitude modulation.""""""\n        n_points, center, spread = 128, 63, 10.0\n        signal = am.amrect(n_points, center, spread)\n        self.assertEqual(signal.max(), 1.0)\n        self.assertEqual(signal[center], 1.0)\n        np.testing.assert_allclose(np.unique(signal), [0., 1.0])\n\n    def test_amtriang(self):\n        """"""Test triangular amplitude modulation.""""""\n        n_points, center, spread = 128, 63, 10.0\n        signal = am.amtriang(n_points, center, spread)\n        self.assertEqual(signal.max(), 1.0)\n        self.assertEqual(signal[center], 1.0)\n        self.assert_is_monotonic_decreasing(signal[center:])\n        self.assert_is_monotonic_increasing(signal[:center])\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
tftb/generators/tests/test_analytic_signals.py,11,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Tests for the analytic_signals module.""""""\n\n\nimport unittest\nimport numpy as np\nfrom scipy import angle, unwrap\nfrom scipy.stats import mode\nfrom tftb.tests.test_base import TestBase\nfrom tftb.generators import analytic_signals as ana\n\n\nclass TestAnalyticSignals(TestBase):\n\n    def test_anaask(self):\n        """"""Test analytic ASK signal.""""""\n        signal, amlaw = ana.anaask(512, 64, 0.05)\n        self.assert_is_analytic(signal, amlaw)\n        np.testing.assert_allclose(np.abs(signal), amlaw)\n\n    def test_anabpsk(self):\n        """"""Test analytic BPSK signal.""""""\n        signal, amlaw = ana.anabpsk(300, 30, 0.1)\n        self.assertCountEqual(np.unique(amlaw), [-1, 1])\n        self.assert_is_analytic(signal)\n\n    def test_anafsk(self):\n        """"""Test analytic phase shift keying.""""""\n        signal, iflaw = ana.anafsk(512, 64, 3)\n        self.assert_is_analytic(signal)\n\n    def test_anapulse(self):\n        """"""Test analytic unit impulse.""""""\n        signal = ana.anapulse(512, 301)\n        recons = np.zeros((512,))\n        recons[301] = 1\n        np.testing.assert_allclose(recons, np.real(signal), rtol=1e-5,\n                                   atol=1e-5)\n\n    def test_anaqpsk(self):\n        """"""Test quaternary PSK signal.""""""\n        signal, phases = ana.anaqpsk(512, 64, 0.25)\n        self.assert_is_analytic(signal)\n        # Count discontinuities in the signal and the phases and assert that\n        # they appear in the same locations\n        uphase = unwrap(angle(signal))\n        dphase = np.diff(uphase)\n        base_value = mode(dphase)[0][0]\n        signal_phase_change = np.abs(dphase - base_value) > 0.0001\n        ideal_phase_change = np.diff(phases) != 0\n        np.testing.assert_allclose(signal_phase_change, ideal_phase_change)\n\n    def test_anastep(self):\n        """"""Test analytic unit step signal.""""""\n        signal = ana.anastep(256, 128)\n        recons = np.zeros((256,), dtype=float)\n        recons[129:] = 1.0\n        np.testing.assert_allclose(recons, np.real(signal), rtol=1e-5,\n                                   atol=1e-5)\n\n    def test_anasing(self):\n        """"""Test the analytic singularity signal.""""""\n        signal = ana.anasing(128)\n        self.assert_is_analytic(signal, amlaw=np.abs(signal))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/generators/tests/test_frequency_modulations.py,16,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Tests for the frequency_modulated module.""""""\n\nimport unittest\nimport numpy as np\nfrom tftb.tests.test_base import TestBase\nfrom tftb.generators import frequency_modulated as fm\n\n\nclass TestFrequencyModulated(TestBase):\n    """"""Tests for the frequency_modulated module.""""""\n\n    def test_fmconst(self):\n        """"""Test constant frequency modulation.""""""\n        n_points, fnorm, center = 129, 0.5, 64\n        signal, iflaw = fm.fmconst(n_points, fnorm, center)\n        real = np.real(signal)\n        np.testing.assert_allclose(iflaw.ravel(), fnorm * np.ones((n_points,)))\n        omega = np.arccos(real)[1:] / (2 * np.pi) / np.arange(n_points)[1:]\n        self.assertEqual(omega.max(), fnorm)\n        self.assert_is_analytic(signal)\n\n    def test_fmhyp(self):\n        """"""Test hyperbolic frequency modulation.""""""\n        n_points, p1, p2 = 128, (1, 0.5), (32, 0.1)\n        signal, iflaw = fm.fmhyp(n_points, p1, p2)\n        self.assertEqual(iflaw[p2[0] - 1], p2[1])\n        self.assert_is_analytic(signal)\n\n    def test_fmlin(self):\n        """"""Test linear frequency modulation.""""""\n        n_points, init_freq, final_freq, center = 128, 0.05, 0.3, 50\n        signal, iflaw = fm.fmlin(n_points, init_freq, final_freq, center)\n        np.testing.assert_allclose(iflaw,\n                                   np.linspace(init_freq, final_freq,\n                                               n_points))\n        self.assert_is_analytic(signal)\n\n    def test_fmodany(self):\n        """"""Test arbitrary modulation.""""""\n        iflaw = np.pad(np.ones((32,)), pad_width=(48, 48), mode=\'constant\',\n                       constant_values=0)\n        signal = fm.fmodany(iflaw / 2.0)\n        self.assert_is_analytic(signal)\n        np.testing.assert_allclose(np.real(signal)[:48],\n                                   np.ones((48,)))\n        np.testing.assert_allclose(np.real(signal)[-48:],\n                                   np.ones((48,)))\n        x = fm.fmconst(32, 0.5, 1)[0]\n        np.testing.assert_allclose(np.real(x), np.real(signal)[48:48 + 32])\n\n    def test_fmpar(self):\n        """"""Test parabolic frequency modulation.""""""\n        coeffs = (0.4, -0.0112, 8.6806e-05)\n        n_points = 128\n        signal, iflaw = fm.fmpar(n_points, coeffs)\n        a, b, c = coeffs\n        xx = np.arange(n_points)\n        parabola = a + b * xx + c * (xx ** 2)\n        np.testing.assert_allclose(parabola, iflaw, rtol=1e-3, atol=1e-3)\n        self.assert_is_analytic(signal)\n\n    def test_fmpower(self):\n        """"""Test power law frequency modulation.""""""\n        n_points = 128\n        degree = 0.5\n        coefficients = 1, 0.5, 100, 0.1\n        signal, iflaw = fm.fmpower(n_points, degree, coefficients)\n        self.assertAlmostEqual(iflaw[coefficients[2]], coefficients[3],\n                               places=1)\n        self.assert_is_analytic(signal)\n\n    def test_fmsin(self):\n        """"""Test sinusoidal frequency modulation.""""""\n        n_points = 140\n        min_freq, max_freq = 0.05, 0.45\n        period = 100\n        center = 20\n        center_freq = 0.3\n        freq_dir = -1\n        signal, iflaw = fm.fmsin(n_points, min_freq, max_freq, period, center,\n                                 center_freq, freq_dir)\n        self.assert_is_analytic(signal)\n        xx = np.arange(n_points) - center - 4\n        f_sample = 1.0 / period\n        yy = freq_dir * np.sin(2 * np.pi * f_sample * xx)\n        yy = ((max_freq - min_freq) / 2) * yy + (max_freq + min_freq) / 2\n        np.testing.assert_allclose(yy, iflaw, rtol=1e-3, atol=1e-3)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/generators/tests/test_misc.py,11,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Tests for the generators.misc module.""""""\n\nimport unittest\nfrom tftb.tests.test_base import TestBase\nfrom tftb.generators import misc\nfrom tftb.processing.utils import derive_window\nimport numpy as np\nfrom scipy.signal import argrelmax, argrelmin, hanning\n\n\nclass TestMisc(TestBase):\n\n    def test_window_derivative(self):\n        """"""Test if the derivative of a window function is calculated\n        properly.""""""\n        window = hanning(210)\n        derivative = derive_window(window)\n        ix_win_maxima = np.argmax(window)\n        self.assertAlmostEqual(derivative[ix_win_maxima], 0.0, places=3)\n\n    def test_altes(self):\n        """"""Test the altes signal generation.""""""\n        ideal = np.array([0.00200822, -0.21928398, 0.66719239, 0.66719239,\n                          -0.17666382, -0.17009953, -0.038399, -0.00083597])\n        actual = misc.altes(8, 0.1, 0.5)\n        np.testing.assert_allclose(ideal, actual, atol=1e-8, rtol=1e-8)\n\n    def test_doppler(self):\n        """"""Test the doppler signal generation.""""""\n        fm, am, iflaw = misc.doppler(512, 200.0, 65, 10, 50)\n        self.assert_is_monotonic_decreasing(iflaw)\n\n    def test_klauder(self):\n        """"""Test the klauder wavelet generation.""""""\n        ideal = np.array([0.14899879, -0.16633309, -0.42806931, 0.16605633,\n                          0.70769336, 0.16605633, -0.42806931, -0.16633309])\n        actual = misc.klauder(8)\n        np.testing.assert_allclose(ideal, actual, atol=1e-8, rtol=1e-8)\n\n    def test_mexhat(self):\n        """"""Test the mexhat wavelet generation.""""""\n        ideal = np.array([-4.36444274e-09, -4.29488427e-04, -1.47862882e-01,\n                          4.43113463e-01, -1.47862882e-01, -4.29488427e-04,\n                          -4.36444274e-09])\n        actual = misc.mexhat(0.5)\n        np.testing.assert_allclose(ideal, actual, atol=1e-9, rtol=1e-9)\n        maxima = argrelmax(actual)\n        self.assertEqual(maxima[0].shape[0], 1)\n        self.assertEqual(maxima[0][0], 3)\n        minima = argrelmin(actual)\n        self.assertCountEqual(minima[0], (2, 4))\n\n    def test_gdpower(self):\n        """"""Test the gdpower generation.""""""\n        ideal_sig = np.array([0.08540661 + 0.05077147j, 0.16735776 + 0.11542816j,\n                              -0.08825763 + 0.17010894j, 0.04412953 - 0.01981114j,\n                              -0.04981628 + 0.34985966j, -0.56798889 - 0.07983783j,\n                              0.05266730 - 0.57074006j, 0.35650159 - 0.01577918j])\n        ideal_f = np.array([0.125, 0.25, 0.375, 0.5])\n        ideal_gpd = np.array([8.8, 6.45685425, 5.41880215, 4.8])\n        ideals = (ideal_sig, ideal_gpd, ideal_f)\n        actuals = misc.gdpower(len(ideal_sig), 0.5)\n        for i, ideal in enumerate(ideals):\n            actual = actuals[i]\n            np.testing.assert_allclose(ideal, actual, atol=1e-7, rtol=1e-7)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/generators/tests/test_noise.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Tests for the generators.noise module.""""""\n\nimport unittest\nimport numpy as np\nfrom tftb.tests.test_base import TestBase\nfrom tftb.generators import noise\n\n\nclass TestNoise(TestBase):\n\n    def test_noisecu(self):\n        """"""Test uniform white noise generation.""""""\n        x = noise.noisecu(128)\n        self.assertAlmostEqual(x.std() ** 2, 1, places=1)\n\n    def test_noisecg(self):\n        """"""Test Gaussian white noise generation.""""""\n        x = noise.noisecg(128)\n        self.assertAlmostEqual(x.std() ** 2, 1, places=1)\n\n    def test_dopnoise(self):\n        """"""Test doppler noise generation""""""\n        signal, iflaw = noise.dopnoise(500, 200, 60, 10, 70, 128)\n        energy = np.sum(np.abs(signal) ** 2)\n        self.assertAlmostEqual(energy, 1, 3)\n        self.assert_is_monotonic_decreasing(iflaw)\n        signal, iflaw = noise.dopnoise(500, 200, 60, 10, 70)\n        energy = np.sum(np.abs(signal) ** 2)\n        self.assertAlmostEqual(energy, 1, 3)\n        self.assert_is_monotonic_decreasing(iflaw)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/generators/tests/test_utils.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.generators.utils\n""""""\n\nimport unittest\nimport numpy as np\n\nfrom tftb.generators import utils, fmlin\n\n\nclass TestUtils(unittest.TestCase):\n\n    def test_sigmerge(self):\n        """"""Test merging of signals with a given SNR.""""""\n        signal = fmlin(128)[0]\n        noise = np.random.randn(128,)\n        gamma = 0.1\n        x = utils.sigmerge(signal, noise, gamma)\n        h_est = np.linalg.norm(signal) / np.linalg.norm(noise) * 10 ** (-gamma / 20)\n        x_hat = signal + h_est * noise\n        np.testing.assert_allclose(x, x_hat)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/__init__.py,0,b''
tftb/processing/tests/test_ambiguity.py,5,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.processing.ambiguity\n""""""\n\nimport unittest\nimport numpy as np\n\nfrom tftb.generators import fmlin, amgauss, altes\nfrom tftb.processing import ambiguity\nfrom tftb.tests.test_base import TestBase\n\n\nclass TestWideBand(TestBase):\n    """"""Tests for the wide band ambiguity function.""""""\n    def setUp(self):\n        self.signal = altes(128, 0.1, 0.45)\n        self.tfr, self.tau, self.theta = ambiguity.wide_band(self.signal)\n\n    def test_max_value(self):\n        """"""Test if the maximum value of the ambiguity function occurs at the\n        origin""""""\n        max_ix = np.argmax(np.abs(self.tfr))\n        self.assertAlmostEqual(float(self.tfr.size) / max_ix, 2, places=1)\n\n\nclass TestNarrowBand(TestBase):\n    """"""Tests for the narrow band ambiguity function""""""\n\n    def setUp(self):\n        x = fmlin(64, 0.2, 0.5)[0] * amgauss(64)\n        y = fmlin(64, 0.3, 0)[0] * amgauss(64)\n        self.signal = np.hstack((x, y))\n        self.tfr, self.lag, self.doppler = ambiguity.narrow_band(self.signal)\n\n    def test_max_value(self):\n        """"""Test if the maximum value of the ambiguity function occurs at the\n        origin""""""\n        xorg, yorg = map(lambda x: int(x / 2), self.tfr.shape)\n        abs_mat = np.abs(self.tfr) ** 2\n        max_val = abs_mat[xorg, yorg]\n        for i in range(abs_mat.shape[0]):\n            for j in range(abs_mat.shape[1]):\n                self.assertTrue(abs_mat[i, j] <= max_val)\n\n    def test_volume_invariance(self):\n        """"""Test the volume invariance property of the narrow band ambiguity\n        function.""""""\n        volume = np.abs(self.tfr[self.doppler == 0, self.lag == 0]) ** 2\n        volume_integral = (np.abs(self.tfr) ** 2).sum().sum()\n        self.assertAlmostEqual(volume[0],\n                               volume_integral / (self.signal.shape[0] / 2))\n\n    @unittest.skip(""Not quite ready yet."")\n    def test_symmetry(self):\n        """"""Test the symmetry property of the narrow band ambiguity function.""""""\n        tfr = self.tfr[1:, :]\n        self.assert_is_hermitian(tfr)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_cohen.py,27,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.processing.cohen\n""""""\n\nimport unittest\nimport numpy as np\nfrom scipy.signal import kaiser\nfrom tftb.processing import cohen\nfrom tftb.generators import fmsin, fmlin\nfrom tftb.tests.test_base import TestBase\n\n\nclass TestCohen(TestBase):\n\n    def test_page_reality(self):\n        """"""Test the reality property of the Page distribution.""""""\n        signal, _ = fmsin(128)\n        signal = signal / 128.0\n        tfr, _, _ = cohen.PageRepresentation(signal).run()\n        self.assertTrue(np.all(np.isreal(tfr)))\n\n    def test_spectrogram_time_invariance(self):\n        """"""Test the time invariance property of the spectrogram.""""""\n        signal, _ = fmlin(128, 0.1, 0.4)\n        window = kaiser(17, 3 * np.pi)\n        tfr, ts, freqs = cohen.Spectrogram(signal, n_fbins=64, fwindow=window).run()\n        shift = 64\n        timeshifted_signal = np.roll(signal, shift)\n        timeshifted_tfr, _, _ = cohen.Spectrogram(timeshifted_signal, n_fbins=64,\n                                                  fwindow=window).run()\n        rolled_tfr = np.roll(tfr, shift, axis=1)\n        # the time invariance property holds mostly qualitatively. The shifted\n        # TFR is not numerically indentical to the rolled TFR, having\n        # differences at the edges; so clip with two TFRs where there are\n        # discontinuities in the TFR.\n        edge = 10\n        xx = np.c_[timeshifted_tfr[:, edge:(shift - edge)],\n                   timeshifted_tfr[:, (shift + edge):-edge]]\n        yy = np.c_[rolled_tfr[:, edge:(shift - edge)],\n                   rolled_tfr[:, (shift + edge):-edge]]\n        np.testing.assert_allclose(xx, yy)\n\n    def test_spectrogram_non_negativity(self):\n        """"""Test that the spectrogram is non negative.""""""\n        signal, _ = fmlin(128, 0.1, 0.4)\n        window = kaiser(17, 3 * np.pi)\n        tfr, _, _ = cohen.Spectrogram(signal, n_fbins=64, fwindow=window).run()\n        self.assertTrue(np.all(tfr >= 0))\n\n    def test_spectrogram_energy_conservation(self):\n        """"""Test the energy conservation property of the spectrogram.""""""\n        signal, _ = fmlin(128, 0.1, 0.4)\n        window = kaiser(17, 3 * np.pi)\n        tfr, ts, freqs = cohen.Spectrogram(signal, n_fbins=64, fwindow=window).run()\n        e_sig = (np.abs(signal) ** 2).sum()\n        self.assertAlmostEqual(tfr.sum().sum() / 64, e_sig)\n\n    def test_spectrogram_reality(self):\n        """"""Test the reality property of the spectrogram.""""""\n        signal, _ = fmlin(128, 0.1, 0.4)\n        window = kaiser(17, 3 * np.pi)\n        tfr, _, _ = cohen.Spectrogram(signal, n_fbins=64, fwindow=window).run()\n        self.assertTrue(np.all(np.isreal(tfr)))\n\n    def test_spectrogram_linearity(self):\n        """"""Test the linearity property of the spectrogram.""""""\n        signal, _ = fmlin(128, 0.1, 0.4)\n        window = kaiser(17, 3 * np.pi)\n        tfr1, _, _ = cohen.Spectrogram(signal, n_fbins=64,\n                                       fwindow=window).run()\n        tfr2, _, _ = cohen.Spectrogram(signal * 2, n_fbins=64,\n                                       fwindow=window).run()\n        x = np.sum(np.sum(tfr2))\n        y = np.sum(np.sum(tfr1))\n        self.assertEqual(x / y, 4)\n\n    def test_wigner_ville_energy(self):\n        """"""Test the energy property of the Wigner Ville representation.""""""\n        signal, _ = fmsin(128)\n        signal = signal / 128.0\n        tfr, _, _ = cohen.WignerVilleDistribution(signal).run()\n        x = np.sum(np.sum(tfr))\n        y = np.sum(np.abs(signal) ** 2) * 128\n        self.assertEqual(x, y)\n\n    def test_wigner_ville_projection(self):\n        """"""Test the projection property of the Wigner Ville representation.""""""\n        signal, _ = fmsin(128)\n        tfr, _, _ = cohen.WignerVilleDistribution(signal).run()\n        x = np.abs(signal) ** 2\n        y = np.sum(tfr, axis=0) / 128\n        np.testing.assert_allclose(x, y)\n\n    def test_reality(self):\n        """"""Test the reality property of the Wigner Ville representation.""""""\n        signal, _ = fmsin(128)\n        tfr, _, _ = cohen.WignerVilleDistribution(signal).run()\n        self.assertTrue(np.all(np.isreal(tfr)))\n\n    def test_wigner_ville_regionprops(self):\n        """"""Test the regional property of the Wigner Ville representation.""""""\n        signal, _ = fmsin(128)\n        signal[64:] = 0\n        tfr, _, _ = cohen.WignerVilleDistribution(signal).run()\n        self.assertTrue(np.all(tfr[:, 64:] == 0))\n\n        signal, _ = fmsin(128)\n        signal[:64] = 0\n        tfr, _, _ = cohen.WignerVilleDistribution(signal).run()\n        self.assertTrue(np.all(tfr[:, :64] == 0))\n\n    def test_pseudo_wv_energy(self):\n        """"""Test the energy property of the pseudo WV representation.""""""\n        signal, _ = fmsin(128)\n        signal = signal / 128.0\n        tfr, _, _ = cohen.PseudoWignerVilleDistribution(signal).run()\n        x = np.sum(np.sum(tfr))\n        y = np.sum(np.abs(signal) ** 2) * 128\n        self.assertAlmostEqual(x, y, places=3)\n\n    def test_pseudo_wv_reality(self):\n        """"""Test the reality property of the pseudo WV representation.""""""\n        signal, _ = fmsin(128)\n        tfr, _, _ = cohen.PseudoWignerVilleDistribution(signal).run()\n        self.assertTrue(np.all(np.isreal(tfr)))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_freq_domain.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""Tests for frequency domain processing functions.""""""\n\n\nimport unittest\nimport numpy as np\nfrom tftb.processing import freq_domain as fproc\nfrom tftb.generators import frequency_modulated as fm\nfrom tftb.generators import amplitude_modulated as am\nfrom tftb.tests.test_base import TestBase\n\n\nclass TestFrequencyDomainProcessing(TestBase):\n\n    def test_instfreq(self):\n        """"""Test instantaneous frequency calculation.""""""\n        signal, _ = fm.fmlin(128, 0.05, 0.3, 50)\n        ifreq = fproc.inst_freq(signal)[0]\n        self.assertAlmostEqual(ifreq.min(), 0.05, places=2)\n        self.assertAlmostEqual(ifreq.max(), 0.3, places=2)\n        self.assert_is_linear(ifreq)\n\n    def test_locfreq(self):\n        """"""Test calculation of localized frequency characteristics.""""""\n        signal, _ = fm.fmlin(128, 0.05, 0.3, 50)\n        input_avg_freq = (0.05 + 0.3) / 2.0\n        avg_norm_freq, bandwidth = fproc.locfreq(signal)\n        self.assertAlmostEqual(avg_norm_freq, input_avg_freq, places=2)\n\n    def test_group_delay(self):\n        """"""Test Group delay calculation.""""""\n        n_points = 128\n        signal = am.amgauss(n_points, 64, 30) * fm.fmlin(n_points, 0.1, 0.4)[0]\n        fnorm = np.arange(0.1, 0.38, step=0.04)\n        grp_dlay = fproc.group_delay(signal, fnorm)\n        self.assert_is_linear(grp_dlay, 0)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_linear.py,9,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.processing.linear\n""""""\n\nfrom tftb.processing import linear\nfrom tftb.generators import fmlin\nfrom tftb.tests.test_base import TestBase\nimport numpy as np\nimport unittest\n\n\nclass TestLinear(TestBase):\n\n    def test_stft_linearity(self):\n        """"""Test the linearity property of the Fourier transform.""""""\n        x = fmlin(128, 0.0, 0.2)[0]\n        y = fmlin(128, 0.3, 0.5)[0]\n        h = x + y\n        tfr, _, _ = linear.ShortTimeFourierTransform(h).run()\n        tfrx, _, _ = linear.ShortTimeFourierTransform(x).run()\n        tfry, _, _ = linear.ShortTimeFourierTransform(y).run()\n        np.testing.assert_allclose(tfr, tfrx + tfry)\n\n    @unittest.skip(""Known failure."")\n    def test_stft_translation(self):\n        """"""Test the time-shift property of the Fourier transform.""""""\n        x = fmlin(128, 0.0, 0.2)[0]\n        tfrx, _, freqs = linear.ShortTimeFourierTransform(x).run()\n        x_shifted = np.roll(x, 64)\n        tfrxs, _, _ = linear.ShortTimeFourierTransform(x_shifted).run()\n        f_mul = np.exp(-1j * 2 * np.pi * 64 * freqs)\n        np.testing.assert_allclose(tfrxs, f_mul * tfrx)\n\n    def test_stft_modulation(self):\n        """"""Test the modulation / frequency shifting property of STFT.""""""\n        x = fmlin(128, 0.0, 0.2)[0]\n        tfrx, _, _ = linear.ShortTimeFourierTransform(x).run()\n        f_0 = 0.3\n        h = np.exp(1j * 2 * np.pi * f_0 * np.arange(128)) * x\n        tfrh, _, _ = linear.ShortTimeFourierTransform(h).run()\n        tfrx_shifted = np.roll(tfrx, int(np.ceil(128 * 0.3)), axis=0)\n        self.assert_tfr_equal(tfrx_shifted, tfrh, tol=0.95)\n\n    @unittest.skip(""Known failure"")\n    def test_stft_conjugation(self):\n        x = fmlin(128, 0, 0.2)[0]\n        h = np.conjugate(x)\n        lhs, _, _ = linear.ShortTimeFourierTransform(h).run()\n        rhs, _, _ = linear.ShortTimeFourierTransform(x[::-1]).run()\n        rhs = np.conjugate(rhs)\n        np.testing.assert_allclose(lhs, rhs)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_postprocessing.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.processing.postprocessing\n""""""\n\nfrom tftb.tests.test_base import TestBase\nfrom tftb.generators import atoms, fmlin\nfrom tftb.processing import WignerVilleDistribution\nfrom tftb.processing import postprocessing as pproc\nfrom skimage.transform import hough_line_peaks, hough_line\nimport numpy as np\nimport unittest\n\n\nclass TestPostprocessing(TestBase):\n\n    def test_renyi_information(self):\n        """"""Check if Renyi entropy computation is correct.""""""\n        sig = atoms(128, np.array([[64., 0.25, 20., 1.]]))\n        tfr, _, _ = WignerVilleDistribution(sig).run()\n        R1 = pproc.renyi_information(tfr)\n        sig = atoms(128, np.array([[32., 0.25, 20., 1.],\n                                   [96., 0.25, 20., 1.]]))\n        tfr, _, _ = WignerVilleDistribution(sig).run()\n        R2 = pproc.renyi_information(tfr)\n        self.assertAlmostEqual(R2 - R1, 0.98, places=1)\n\n    def test_ideal_tfr(self):\n        """"""Test if the ideal TFR can be found using the instantaneous frequency\n        laws.""""""\n        _, iflaw1 = fmlin(128, 0.0, 0.2)\n        _, iflaw2 = fmlin(128, 0.3, 0.5)\n        iflaws = np.c_[iflaw1, iflaw2].T\n        tfr, _, _ = pproc.ideal_tfr(iflaws)\n        tfr[tfr == 1] = 255\n        tfr = tfr.astype(np.uint8)\n        hspace, angles, dists = hough_line(tfr)\n        for x in hough_line_peaks(hspace, angles, dists):\n            self.assertEqual(len(x), 2)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_time_domain.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport unittest\nfrom tftb.processing import time_domain as tmd\nfrom tftb.generators import amplitude_modulated as am\nfrom tftb.tests.test_base import TestBase\n\n\nclass TestTimeDomainProcessors(TestBase):\n\n    def test_loctime(self):\n        """"""Test computation of localized time characteristics.""""""\n        signal = am.amgauss(160, 80, 50)\n        tm, T = tmd.loctime(signal)\n        self.assertAlmostEqual(tm, 79, places=6)\n        self.assertAlmostEqual(T, 50, places=4)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
tftb/processing/tests/test_utils.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\nTests for tftb.processing.utils\n""""""\n\nimport unittest\nimport numpy as np\nfrom tftb.processing import utils\n\n\nclass TestUtils(unittest.TestCase):\n\n    def test_derive_window(self):\n        """"""Test derivative of window function.""""""\n        from scipy.signal import gaussian\n        g = gaussian(129, 10)\n        dwindow = utils.derive_window(g)\n        self.assertEqual(dwindow[64], 0)\n        self.assertTrue(np.all(dwindow[:64] >= 0))\n        self.assertTrue(np.all(dwindow[64:] <= 0))\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
doc/docstring_plots/generators/amplitude_modulated/amexpos_bilateral.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amexpos\nimport matplotlib.pyplot as plt\n\nx = amexpos(160)\nplt.plot(x)\nplt.grid()\nplt.title(""Two sided exponential amplitude modulation"")\nplt.show()\n'"
doc/docstring_plots/generators/amplitude_modulated/amexpos_unilateral.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amexpos\nimport matplotlib.pyplot as plt\n\nx = amexpos(160, kind=\'unilateral\')\nplt.plot(x)\nplt.grid()\nplt.title(""One sided exponential amplitude modulation"")\nplt.show()\n'"
doc/docstring_plots/generators/amplitude_modulated/amgauss1.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amgauss\nimport matplotlib.pyplot as plt\n\nx = amgauss(160)\nplt.plot(x)\nplt.grid()\nplt.title(\'Gaussian Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/amplitude_modulated/amgauss2.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amgauss\nimport matplotlib.pyplot as plt\n\nx = amgauss(160, 90)\nplt.plot(x)\nplt.grid()\nplt.title(\'Gaussian Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/amplitude_modulated/amgauss3.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amgauss\nimport matplotlib.pyplot as plt\n\nx = amgauss(160, 90, 40.0)\nplt.plot(x)\nplt.grid()\nplt.title(\'Gaussian Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/amplitude_modulated/amrect1.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amrect\nimport matplotlib.pyplot as plt\n\nx = amrect(160, 90, 40.0)\nplt.plot(x)\nplt.grid()\nplt.title(\'Rectangular Amplitude Modulation.\')\nplt.show()\n\n'"
doc/docstring_plots/generators/amplitude_modulated/amtriang1.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import amtriang\nimport matplotlib.pyplot as plt\n\nx = amtriang(160)\nplt.plot(x)\nplt.title(\'Triangular Amplitude Modulation\')\nplt.grid()\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anaask.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anaask\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx, am = anaask(512, 64, 0.05)\nplt.subplot(211), plt.plot(np.real(x))\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Analytic ASK signal\')\nplt.subplot(212), plt.plot(am)\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anabpsk.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anabpsk\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx, am = anabpsk(300, 30, 0.1)\nplt.subplot(211), plt.plot(np.real(x))\nplt.grid()\nplt.title(\'Analytic BPSK signal\')\nplt.subplot(212), plt.plot(am)\nplt.grid()\nplt.title(\'Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anafsk.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anafsk\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx, am = anafsk(512, 54.0, 5.0)\nplt.subplot(211), plt.plot(np.real(x))\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Analytic FSK signal\')\nplt.subplot(212), plt.plot(am)\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Amplitude Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anapulse.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anapulse\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = 2.5 * anapulse(512, 301)\nplt.plot(np.real(x))\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Analytic Dirac Impulse\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anaqpsk.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anaqpsk\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx, am = anaqpsk(512, 64.0, 0.05)\nplt.subplot(211), plt.plot(np.real(x))\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Analytic QPSK signal\')\nplt.subplot(212), plt.plot(am)\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Phase\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anasing.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anasing\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = anasing(128)\nplt.plot(np.real(x))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Lipschitz Singularity\')\nplt.show()\n'"
doc/docstring_plots/generators/analytic_signals/anastep.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import anastep\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = anastep(256, 128)\nplt.plot(np.real(x))\nplt.xlim(0, 256)\nplt.grid()\nplt.title(\'Analytic Step Signal\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmconst.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amgauss, fmconst\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nz = amgauss(128, 50.0, 30.0) * fmconst(128, 0.05, 50)[0]\nplt.plot(np.real(z))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Constant Frequency Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmhyp.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n""""""\n\n""""""\n\nfrom tftb.generators import fmhyp\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nsignal, iflaw = fmhyp(128, (1, 0.5), (32, 0.1))\nplt.subplot(211), plt.plot(np.real(signal))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Hyperbolic Frequency Modulation\')\nplt.subplot(212), plt.plot(iflaw)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Instantaneous Frequency\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmlin.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import amgauss, fmlin\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nz = amgauss(128, 50.0, 30.0) * fmlin(128, 0.05, 0.3, 50)[0]\nplt.plot(np.real(z))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Linear Frequency Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmodany.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n""""""\n\n""""""\n\nfrom tftb.generators import fmlin, fmodany, fmsin\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ny1, ifl1 = fmlin(100)\ny2, ifl2 = fmsin(100)\niflaw = np.append(ifl1, ifl2)\nsig = fmodany(iflaw)\n\nplt.subplot(211), plt.plot(np.real(sig))\nplt.grid()\nplt.title(\'Linear and Sinusoidal modulated signal\')\nplt.subplot(212), plt.plot(iflaw)\nplt.grid()\nplt.title(\'Instantaneous frequency\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmpar.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import fmpar\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nz, iflaw = fmpar(128, (0.4, -0.0112, 8.6806e-05))\nplt.subplot(211), plt.plot(np.real(z))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Parabolic Frequency Modulation\')\nplt.subplot(212), plt.plot(iflaw)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Instantaneous Frequency\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmpower.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import fmpower\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nz, iflaw = fmpower(128, 0.5, (1, 0.5, 100, 0.1))\nplt.subplot(211), plt.plot(np.real(z))\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Power Law Modulation\')\nplt.subplot(212), plt.plot(iflaw)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Instantaneous Frequency\')\nplt.show()\n'"
doc/docstring_plots/generators/frequency_modulated/fmsin.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators import fmsin\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nz = fmsin(140, period=100, t0=20.0, fnorm0=0.3, pm1=-1)[0]\nplt.plot(np.real(z))\nplt.grid()\nplt.title(\'Sinusoidal Frequency Modulation\')\nplt.show()\n'"
doc/docstring_plots/generators/misc/altes.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nfrom tftb.generators.misc import altes\nimport matplotlib.pyplot as plt\n\nx = altes(128, 0.1, 0.45)\nplt.plot(x)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(""Altes signal"")\nplt.show()\n'"
doc/docstring_plots/generators/misc/atoms.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators.misc import atoms\n\ncoordinates = np.array([[32.0, 0.3, 32.0, 1.0],\n                        [56.0, 0.15, 48.0, 1.22]])\nsig = atoms(128, coordinates)\nplt.plot(np.real(sig))\nplt.grid()\nplt.xlim(xmax=128)\nplt.title(\'Gaussian Atoms\')\nplt.show()\n'"
doc/docstring_plots/generators/misc/doppler.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import doppler\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfm, am, iflaw = doppler(512, 200.0, 65.0, 10.0, 50.0)\nplt.subplot(211), plt.plot(np.real(am * fm))\nplt.title(\'Doppler\')\nplt.grid()\nplt.xlim(0, 512)\nplt.subplot(212), plt.plot(iflaw)\nplt.title(\'Instantaneous Freqeuncy\')\nplt.grid()\nplt.xlim(0, 512)\n\nplt.show()\n'"
doc/docstring_plots/generators/misc/klauder.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nimport matplotlib.pyplot as plt\nfrom tftb.generators import klauder\n\nx = klauder(128)\nplt.plot(x)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Klauder Wavelet\')\nplt.show()\n'"
doc/docstring_plots/generators/misc/mexhat.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import mexhat\nimport matplotlib.pyplot as plt\n\nplt.plot(mexhat())\nplt.grid()\nplt.title(\'Mexican Hat Wavelet\')\nplt.show()\n'"
doc/docstring_plots/generators/noise/dopnoise.py,2,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import dopnoise\nfrom tftb.processing.freq_domain import inst_freq\n\nz, iflaw = dopnoise(500, 200.0, 60.0, 10.0, 70.0, 128.0)\nplt.subplot(211), plt.plot(np.real(z))\nplt.grid()\nplt.title(\'Complex noisy Doppler signal\')\nplt.xlim(0, 500)\nifl, t = inst_freq(z, np.arange(11, 479), 10)\nplt.subplot(212)\nplt.plot(iflaw, \'r\', label=\'actual\')\nplt.plot(t, ifl, \'g\', label=\'estimated\')\nplt.xlim(0, 500)\nplt.legend()\nplt.grid()\nplt.title(\'Instantaneous frequency\')\nplt.show()\n'"
doc/docstring_plots/generators/noise/noisecg.py,3,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tftb.generators import noisecg\n\nnoise = noisecg(512)\nprint(noise.mean())\nprint(noise.std() ** 2)\nplt.subplot(211), plt.plot(np.real(noise))\nplt.xlim(0, 512)\nplt.grid()\nplt.title(\'Analytic complex Gaussian noise.\')\nplt.subplot(212), plt.plot(np.linspace(-0.5, 0.5, 512),\n                           abs(np.fft.fftshift(np.fft.fft(noise))) ** 2)\nplt.grid()\nplt.title(\'Energy spectrum\')\nplt.xlim(-0.5, 0.5)\nplt.show()\n'"
doc/docstring_plots/generators/noise/noisecu.py,4,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nfrom tftb.generators import noisecu\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nnoise = noisecu(512)\nprint(np.real(noise.mean()))\nprint(noise.std() ** 2)\n\nplt.subplot(211), plt.plot(np.real(noise))\nplt.title(\'Analytic complex white noise\')\nplt.xlim(0, 512)\nplt.grid()\nplt.subplot(212), plt.plot(np.linspace(-0.5, 0.5, 512),\n                           np.abs(np.fft.fftshift(np.fft.fft(noise))) ** 2)\nplt.title(\'Energy spectrum\')\nplt.xlabel(\'Normalized Frequency\')\nplt.xlim(-0.5, 0.5)\nplt.grid()\nplt.show()\n'"
doc/docstring_plots/processing/freq_domain/group_delay.py,1,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom tftb.generators import amgauss, fmlin\nfrom tftb.processing import group_delay\n\nx = amgauss(128, 64.0, 30) * fmlin(128, 0.1, 0.4)[0]\nfnorm = np.arange(0.1, 0.38, step=0.04)\ngd = group_delay(x, fnorm)\nplt.plot(gd, fnorm)\nplt.xlim(0, 128)\nplt.grid()\nplt.title(\'Group delay estimation of linear chirp\')\nplt.xlabel(\'Group delay\')\nplt.ylabel(\'Normalized frequency\')\nplt.show()\n'"
doc/docstring_plots/processing/freq_domain/inst_freq.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\n\nimport matplotlib.pyplot as plt\nfrom tftb.processing import inst_freq\nfrom tftb.generators import fmsin\n\nx = fmsin(70, 0.05, 0.35, 25)[0]\ninstf, timestamps = inst_freq(x)\nplt.plot(timestamps, instf)\nplt.xlim(0, 70)\nplt.grid()\nplt.title(""Instantaneous frequency estimation"")\nplt.xlabel(\'Time\')\nplt.ylabel(\'Frequency\')\nplt.show()\n'"
doc/docstring_plots/processing/utils/derive_window.py,0,"b'#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n# Copyright \xc2\xa9 2015 jaidev <jaidev@newton>\n#\n# Distributed under terms of the MIT license.\n\n""""""\n\n""""""\n\nimport matplotlib.pyplot as plt\nfrom scipy.signal import hanning\nfrom tftb.processing.utils import derive_window\n\nwindow = hanning(210)\nplt.subplot(211), plt.plot(window)\nplt.xlim(0, 210)\nplt.grid()\nplt.title(\'Hanning window\')\nplt.subplot(212), plt.plot(derive_window(window))\nplt.xlim(0, 210)\nplt.grid()\nplt.title(\'Approximate derivative\')\nplt.show()\n'"
