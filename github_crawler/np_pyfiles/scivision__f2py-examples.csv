file_path,api_count,code
f2py_demo.py,2,"b'#!/usr/bin/env python\n""""""\ndemo of need to use INTENT() in the Fortran code with f2py\nas current versions of f2py assume INTENT(IN), which is an obvious\nissue for getting results back to Python!\n\nNote: imports from f2py will always be ALL lowercase!\n""""""\nimport numpy as np\nfrom pyprod import prod\n\n\nx = 3\ny = 2\n# %%\nzint = prod.prodintent(x, y)\nassert zint == x * y\nassert isinstance(zint, float)  # the Fortran code casts to float\n# %%\nznoint = 12345.0\nznointent = prod.prodnointent(x, y, znoint)\nassert znointent is None\n# unmodified due to f2py intent(in) by default\nassert np.isclose(znoint, 12345.0)\n# %%\nzpure = prod.prodpure(x, y)\nassert zpure == x * y\n# %%\n# MUST be an ndarray e.g. 0d ndarray for scalar case!\nzinout = np.array(23456.0)\nprod.prodinout(x, y, zinout)\nassert zinout == x * y\n\nprint(\'x =\', x)\nprint(\'y =\', y)\nprint(\'x * y =\', zint)\nprint(\'Your system did this in Python using Fortran-compiled library\')\n'"
floatPrecision.py,9,"b'#!/usr/bin/env python\n""""""\nDemonstrates limits of IEEE754 floating point precision\n\nsee Wikipedia ""unit in the last place"" ""machine epsilon""\n""Machine epsilon is defined as the smallest number that, when added to one, yields a result different from one.""\n\nCompare with:\n\nMatlab/Octave\n-------------\n>> eps(double(1)) =>    2.2204e-16\n\n>> eps(single(1)) =>    1.1921e-07\n\nhttps://blogs.mathworks.com/cleve/2017/05/22/quadruple-precision-128-bit-floating-point-arithmetic/\n\nMatlab and Octave can support quad precision using external libraries, with great slowdowns in computing.\nI would consider Fortran for a project needing quad precision\n\nFortran\n-------\n bits of precision for 32-bit float          24\n machine epsilon: 32-bit float   1.19209290E-07\n bits of precision for 64-bit float          53\n machine epsilon: 64-bit float   2.2204460492503131E-016\n bits of precision for 128-bit float         113\n machine epsilon: 128-bit float   1.92592994438723585305597794258492732E-0034\n\n\nHalf precision:\n---------------\nGCC: currently only on ARM\nhttps://gcc.gnu.org/onlinedocs/gcc/Half-Precision.html\nMatlab: via external libraries.\nPython: Numpy\n""""""\nimport numpy as np\n\n# %% half prec\nph = 0\nh = np.float16(1)\n\nwhile h != h + np.float16(1):\n    h *= np.float16(2)\n    ph += 1\n\neps16 = 2 ** (-(ph - 1))\nprint(\'bits of precision for 16-bit float\', ph)\nprint(\'machine epsilon: 16-bit float\', eps16)\n\n# %% single prec\nps = 0\ns = np.float32(1)\n\nwhile s != s + np.float32(1):\n    s *= np.float32(2)\n    ps += 1\n\neps32 = 2 ** (-(ps - 1))\nprint(\'bits of precision for 32-bit float\', ps)\nprint(\'machine epsilon: 32-bit float\', eps32)\n# %% double prec\npd = 0\nd = 1.0\n\nwhile d != d + 1:\n    d *= 2.0\n    pd += 1\n\neps64 = 2 ** (-(pd - 1))\nprint(\'bits of precision for 64-bit float\', pd)\nprint(\'machine epsilon: 64-bit float\', eps64)\n# %% quad prec\n""""""\ncaveats on Numpy ""long double"":\nhttps://docs.scipy.org/doc/numpy-dev/user/basics.types.html#extended-precision\n""""""\npq = 0\nq = np.float128(1.0)\n\nwhile q != q + np.float128(1):\n    q *= np.float128(2.0)\n    pq += 1\n\neps128 = 2 ** (-(pq - 1))\nprint(\'bits of precision for long double\', pq)\nprint(\'machine epsilon: long double\', eps128)\n'"
setup.py,0,"b""#!/usr/bin/env python\nimport setuptools  # noqa: F401\nfrom numpy.distutils.core import setup, Extension\n\n\nsetup(ext_modules=[Extension(name='pyprod', sources=['prod.f90']), Extension(name='badprec', sources=['badprec.f90'])])\n"""
tests/test_all.py,1,"b""#!/usr/bin/env python\nimport numpy as np\nfrom pyprod import prod\nimport pytest\nfrom pytest import approx\n\n\ndef test_main():\n    x = 3\n    y = 2\n    # %%\n    zint = prod.prodintent(x, y)\n    assert zint == x * y\n    assert isinstance(zint, float)  # f2py casts int => float\n    # %%\n    znoint = 12345.0\n    znointent = prod.prodnointent(x, y, znoint)\n    assert znointent is None\n    # unmodified due to f2py intent(in) by default\n    assert znoint == approx(12345.0)\n    # %%\n    zpure = prod.prodpure(x, y)\n    assert zpure == x * y\n    # %%\n    # MUST be an ndarray e.g. 0d ndarray for scalar case!\n    zinout = np.array(23456.0)\n    prod.prodinout(x, y, zinout)\n    assert zinout == x * y\n\n\nif __name__ == '__main__':\n    pytest.main(['-v', __file__])\n"""
