file_path,api_count,code
setup.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom setuptools import setup, find_packages  # Always prefer setuptools over distutils\nfrom codecs import open  # To use a consistent encoding\nfrom os import path\nimport io\n\nhere = path.abspath(path.dirname(__file__))\n\nNAME = \'pandas_degreedays\'\nwith io.open(path.join(here, NAME, \'version.py\'), \'rt\', encoding=\'UTF-8\') as f:\n    exec(f.read())\n\nsetup(\n    name=NAME,\n\n    # Versions should comply with PEP440.  For a discussion on single-sourcing\n    # the version across setup.py and the project code, see\n    # https://packaging.python.org/en/latest/development.html#single-sourcing-the-version\n    #version=\'0.0.2\',\n    version=__version__,\n\n    description=\'Pandas degree days\',\n    long_description_markdown_filename=\'README.md\',\n\n    # The project\'s main homepage.\n    url=__url__,\n\n    # Author details\n    author=__author__,\n    author_email=__email__,\n\n    # Choose your license\n    license=__license__,\n\n    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        \'Development Status :: 3 - Alpha\',\n\n        # Indicate who your project is intended for\n        \'Environment :: Console\',\n        #\'Topic :: Software Development :: Build Tools\',\n        \'Intended Audience :: Science/Research\',\n        \'Operating System :: OS Independent\',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        \'Programming Language :: Cython\',\n\n        \'Programming Language :: Python\',\n        #\'Programming Language :: Python :: 2\',\n        #\'Programming Language :: Python :: 2.6\',\n        \'Programming Language :: Python :: 2.7\',\n        #\'Programming Language :: Python :: 3\',\n        #\'Programming Language :: Python :: 3.2\',\n        \'Programming Language :: Python :: 3.3\',\n        \'Programming Language :: Python :: 3.4\',\n\n        \'Topic :: Scientific/Engineering\',\n\n        # Pick your license as you wish (should match ""license"" above)\n        \'License :: OSI Approved :: BSD License\',\n\n    ],\n\n    # What does your project relate to?\n    keywords=\'pandas data weather temperature degree days\',\n\n    # You can just specify the packages manually here if your project is\n    # simple. Or you can use find_packages().\n    packages=find_packages(exclude=[\'contrib\', \'docs\', \'tests*\']),\n\n    # List run-time dependencies here.  These will be installed by pip when your\n    # project is installed. For an analysis of ""install_requires"" vs pip\'s\n    # requirements files see:\n    # https://packaging.python.org/en/latest/technical.html#install-requires-vs-requirements-files\n    install_requires=[\'pandas\', \'six\'],\n\n    # List additional groups of dependencies here (e.g. development dependencies).\n    # You can install these using the following syntax, for example:\n    # $ pip install -e .[dev,test]\n    extras_require = {\n        \'dev\': [\'check-manifest\', \'nose\'],\n        \'test\': [\'coverage\', \'nose\'],\n    },\n\n    # If there are data files included in your packages that need to be\n    # installed, specify them here.  If using Python 2.6 or less, then these\n    # have to be included in MANIFEST.in as well.\n    #package_data={\n    #    \'sample\': [],\n    #},\n\n    # Although \'package_data\' is the preferred approach, in some case you may\n    # need to place data files outside of your packages.\n    # see http://docs.python.org/3.4/distutils/setupscript.html#installing-additional-files\n    # In this case, \'data_file\' will be installed into \'<sys.prefix>/my_data\'\n    #data_files=[(\'my_data\', [\'data/data_file\'])],\n\n    # To provide executable scripts, use entry points in preference to the\n    # ""scripts"" keyword. Entry points provide cross-platform support and allow\n    # pip to create the appropriate form of executable for the target platform.\n    entry_points={\n        \'console_scripts\': [\n            \'sample=sample:main\',\n        ],\n    },\n)\n\n'"
pandas_degreedays/__init__.py,4,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nCalculating Degree days\n\nTref= reference temperature (18\xc2\xb0 usually),\nTn = minimum temperature,\nTx= maximum temperature\n\nA Degree Day (DD) is calculated from extreme weather temperatures of the place and the D-day:\n* Tn : minimum temperature of D-day measured at 2 meters above ground level (under shelter)\nbetween D-1 (previous day) 6PM to D-day 6PM (UTC).\n* Tx : maximum temperature of D-day measured at 2 meters above ground level (under shelter)\nbetween D-day 6AM to D+1 (next day) \xc3\xa0 6AM (UTC).\n* Tref : reference temperature threshold chosen.\n* Mean = (Tn + Tx) / 2 : Average temperature of the day\n\nRef: http://climatheque.meteo.fr/Docs/DJC-methode.pdf\n\n""""""\n\nimport datetime\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport logging\nimport traceback\n\nfrom .version import __author__, __copyright__, __credits__, \\\n    __license__, __version__, __maintainer__, __email__, __status__, __url__\n\n# Meteo\ndef hdd_meteo(Tn, Tx, Tref=18):\n    """"""\n    Returns Heating Degree Days (meteo method)\n\n    >>> hdd_meteo(10, 20, 18)\n    3\n\n    >>> hdd_meteo(10, 30, 18)\n    0\n    """"""\n    Tavg = (Tn + Tx) / 2\n    if Tref<=Tavg:\n        return(0)\n    else: # Tref>Tavg\n        return(Tref-Tavg)\n\ndef cdd_meteo(Tn, Tx, Tref=18):\n    """"""\n    Returns Cooling Degree Days (meteo method)\n\n    >>> cdd_meteo(10, 20, 18)\n    0\n\n    >>> cdd_meteo(10, 30, 18)\n    2\n    """"""\n    Tavg = (Tn + Tx) / 2\n    if Tref>=Tavg:\n        return(0)\n    else: # Tref<Tavg\n        return(Tavg-Tref)\n\n# Degree Days - standard method (energy professionals method)\ndef hdd(Tn, Tx, Tref=18):\n    """"""\n    Returns Heating Degree Days (energy professionals method)\n\n    >>> hdd(5, 15, 18)\n    8\n\n    >>> hdd(20, 30, 18)\n    0\n\n    >>> hdd(10, 20, 18)\n    3.328\n    """"""\n    Tavg = (Tn + Tx) / 2\n    if Tref>Tx:\n        return(Tref-Tavg)\n    elif Tref<=Tn:\n        return(0)\n    else: # Tn<Tref and Tref<=Tx:\n        return((Tref-Tn)*(0.08+0.42*(Tref-Tn)/(Tx-Tn)))\n\ndef cdd(Tn, Tx, Tref=18):\n    """"""\n    Returns Cooling Degree Days (energy professionals method)\n\n    >>> cdd(5, 15, 18)\n    0\n\n    >>> cdd(20, 30, 18)\n    7\n\n    >>> cdd(10, 20, 18)\n    0.32799999999999996\n    """"""\n    Tavg = (Tn + Tx) / 2\n    if Tref>Tx:\n        return(0)\n    elif Tref<=Tn:\n        return(Tavg-Tref)\n    else: # Tn<Tref and Tref<=Tx\n        return((Tx-Tref)*(0.08+0.42*(Tx-Tref)/(Tx-Tn)))\n\n\ndef degreedays_date(dt):\n    """"""\n    Returns date from a datetime\n\n    >>> dt = datetime.datetime(year=2014, month=11, day=1, hour=12, minute=0)\n    >>> degreedays_date_Tn(dt)\n    datetime.date(2014, 11, 1)\n    """"""\n    return(dt.date())\n\n\ndef degreedays_date_Tn(dt): # Tn = Tmin\n    """"""\n    Returns date from a datetime for Tmin\n\n    Before 6PM\n    >>> dt = datetime.datetime(year=2014, month=11, day=1, hour=12, minute=0)\n    >>> degreedays_date_Tn(dt)\n    datetime.date(2014, 11, 1)\n\n    After 6PM (next day)\n    >>> dt = datetime.datetime(year=2014, month=11, day=1, hour=19, minute=0)\n    >>> degreedays_date_Tn(dt)\n    datetime.date(2014, 11, 2)\n    """"""\n    if dt.hour<18:\n        return(dt.date())\n    else:\n        dt2 = dt + datetime.timedelta(days=1) # after 6PM next day returned as date\n        return(dt2.date())\n\ndef degreedays_date_Tx(dt): # Tx = Tmax\n    """"""\n    Returns date from a datetime for Tmax\n\n    Avant 6h (jour pr\xc3\xa9c\xc3\xa9dent)\n    >>> dt = datetime.datetime(year=2014, month=11, day=2, hour=5, minute=0)\n    >>> degreedays_date_Tx(dt)\n    datetime.date(2014, 11, 1)\n\n    Apr\xc3\xa8s 6h\n    >>> dt = datetime.datetime(year=2014, month=11, day=1, hour=7, minute=0)\n    >>> degreedays_date_Tx(dt)\n    datetime.date(2014, 11, 1)\n\n    """"""\n    if dt.hour<6:\n        dt2 = dt - datetime.timedelta(days=1) # before 6PM previous day is returned\n        return(dt2.date())\n    else:\n        return(dt.date())\n\ndef inter_lin_nan(ts, rule):\n    """"""\n    Re-sampling using rule (eg \'1H\')\n    interpolates linearly NaN\n    of time series ts\n    """"""\n    ts = ts.resample(rule)\n    mask = np.isnan(ts)\n    # interpolling missing values\n    ts[mask] = np.interp(np.flatnonzero(mask), np.flatnonzero(~mask), ts[~mask])\n    return(ts)\n\ndef calc_dates_currentday(ts):\n    """"""\n    Calculating dates from current day\n\n    Returns a dataframe with datetime as index\n    a column with temperature values\n    two columns for dates to calculate degree days\n        D_MAX for maximum temperature = current day\n        D_MIN for minimum temperature = current day\n    """"""\n    df_temp = pd.DataFrame(data=ts, index=ts.index)\n    df_temp[""D_MAX""] = df_temp.index.map(degreedays_date) # calculating date\n    df_temp[""D_MIN""] = df_temp.index.map(degreedays_date) # calculating date\n    return(df_temp)\n\ndef calc_dates_6hours(ts):\n    """"""\n    Calculating dates for the determination of Tmax and Tmin\n\n    Returns a dataframe with datetime as index\n    a column with temperature values\n    two columns for dates to calculate degree days\n        D_MAX for maximum temperature\n        D_MIN for minimum temperature\n    """"""\n    df_temp = pd.DataFrame(data=ts, index=ts.index)\n    df_temp[""D_MAX""] = df_temp.index.map(degreedays_date_Tx) # calculating date for Tmax\n    df_temp[""D_MIN""] = df_temp.index.map(degreedays_date_Tn) # calculating date for Tmin\n    return(df_temp)\n\ndef yearly_month_ref(dt, month, year=1970):\n    """"""\n    Returns reference year (1970 or 1971) given a datetime and a month as start\n    """"""\n    if dt.month>=month:\n        return(year)\n    else:\n        return(year+1)\n\n#def yearly_month(dt, month=10):\ndef yearly_month(dt, month):\n    """"""\n    Returns year given a datetime and a month as start\n    """"""\n    if dt.month>=month:\n        return(dt.year)\n    else:\n        return(dt.year-1)\n\ndef yearly(dt):\n    """"""\n    Returns year given a datetime\n    """"""\n    return(dt.year)\n\ndef monthly(dt):\n    """"""\n    Returns (year, month)\n    """"""\n    return(dt.year, dt.month)\n\ndef weekly(dt):\n    """"""\n    Returns (year, week_number)\n    """"""\n    return(dt.isocalendar()[0:2])\n\ndef calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=\'yearly\'):\n    """"""\n    Calculating degree days from time series with temperature values: ts_temp\n    method: \'meteo\' or \'pro\'\n    typ: \'heating\' or \'cooling\'\n\n    Returns a dataframe with date (day) as index\n    columns:\n        Tmin\n        Tmax\n        Tref\n        Tavg\n        DD\n        DD_cum\n    """"""\n\n    #assert(isinstance(ts_temp, pd.Series))\n\n    lst_allowed_degreedays_method = [\'meteo\', \'pro\']\n    lst_allowed_degreedays_typ = [\'heating\', \'cooling\']\n\n    d_func = {\n        \'meteo\': {\n            \'heating\': hdd_meteo, # cooling degree day - meteo method\n            \'cooling\': cdd_meteo, # heating degree day - meteo method\n        },\n        \'pro\': {\n            \'heating\': hdd, # heating degree day - pro method\n            \'cooling\': cdd, # cooling degree day - pro method\n        }\n    }\n\n    if method in lst_allowed_degreedays_method:\n        df_temp = calc_dates_6hours(ts_temp)\n\n        ts_temp_min = df_temp.groupby(\'D_MIN\')[ts_temp.name].min()\n        ts_temp_min.name = ""Tmin""\n        ts_temp_min.index.name = ""DATE""\n        ts_temp_min = ts_temp_min[:-1] # remove last day (next day for Tmin)\n        #ts_temp_min[-1] = np.nan\n\n        ts_temp_max= df_temp.groupby(\'D_MAX\')[ts_temp.name].max()\n        ts_temp_max.name = ""Tmax""\n        ts_temp_max.index.name = ts_temp_min.index.name\n        ts_temp_max = ts_temp_max[1:] # remove first day (previous day for Tmax)\n        #ts_temp_max[1] = np.nan\n\n        df_degreedays = pd.concat([ts_temp_min, ts_temp_max], axis=1)\n\n        df_degreedays = df_degreedays[1:-1] # remove last day (next day for Tmin)\n        # remove first day (previous day for Tmax)\n\n        # daily average temperature\n        #df_degreedays[\'Tavg\'] = ts_temp.resample(\'1D\', how=\'mean\')\n\n        # daily average temperature between Tmin and Tmax\n        df_degreedays[\'Tavg\'] = (df_degreedays[\'Tmin\'] + df_degreedays[\'Tmax\']) / 2\n        df_degreedays[\'Tref\'] = Tref # reference temperature\n\n        f_calc_dju = d_func[method][typ] # choosing function to apply\n        # inside dictionary according computing method (meteo or pro)\n        # and type of calculation of degree days (heating or cooling)\n\n        df_degreedays[\'DD\'] = df_degreedays.apply(lambda row: f_calc_dju(row[\'Tmin\'], row[\'Tmax\'], Tref), axis=1) # applying function to dataframe\n\n        df_degreedays.index = pd.to_datetime(df_degreedays.index)\n        df_degreedays.index.name = \'date\'\n        #print(df_degreedays.index)\n        #print(type(df_degreedays.index[0]))\n        df_degreedays = df_degreedays.resample(\'1D\')\n\n        d_groups = {\n            \'yearly\': yearly,\n            \'yearly10\': lambda dt: yearly_month(dt, 10),\n            \'monthly\': monthly,\n            \'weekly\': weekly,\n        }\n\n        if group is not None:\n            if callable(group):\n                group_col = \'func\'\n                df_degreedays[group_col] = df_degreedays.index.map(group)\n            else:\n                group_col = str(group)\n                f_group_col = d_groups[group]\n                df_degreedays[group_col] = df_degreedays.index.map(f_group_col)\n            df_degreedays[\'DD_cum\'] = df_degreedays.groupby(group_col)[\'DD\'].cumsum()\n        else:\n            df_degreedays[\'DD_cum\'] = df_degreedays[\'DD\'].cumsum()\n\n        return(df_degreedays)\n\n    else:\n        raise(NotImplementedError(""Methode %s non disponible"" % method))\n\ndef plot_temp(ts_temp, df_degreedays):\n    """"""\n    plot temperature (time serie), temperature (min/max)\n    degree days and cumulated degree days\n    ts_temp is an hourly time serie\n    df_degreedays is a daily dataframe\n    """"""\n    fig, axes = plt.subplots(nrows=4, ncols=1)\n    ts_temp.resample(\'1H\').plot(ax=axes[0])\n    df_degreedays[[\'Tmin\', \'Tavg\', \'Tmax\', \'Tref\']].plot(ax=axes[1], legend=False)\n    df_degreedays[\'DD\'].plot(ax=axes[2])\n    #df_degreedays[[\'DJU\', \'DJU_7\']].plot(ax=axes[2])\n    df_degreedays[\'DD_cum\'].plot(ax=axes[3])\n\nif __name__ == ""__main__"":\n    # To run doctest (unit tests inside docstrings)\n    # run python filename.py -v\n    import doctest\n    doctest.testmod()'"
pandas_degreedays/version.py,0,"b'__author__ = ""Sebastien Celles""\n__copyright__ = ""Copyright 2014, celles.net""\n__credits__ = [""Sebastien Celles""]\n__license__ = ""BSD""\n__version__ = ""0.0.6""\n__maintainer__ = ""Sebastien Celles""\n__email__ = ""s.celles@gmail.com""\n__status__ = ""Development""\n__url__ = \'https://github.com/scls19fr/pandas_degreedays\'\n'"
sample/calc_degreedays_from_excel.py,1,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nReading XLS file with temperature (sample)\nCalculating degree days\nPlotting\n""""""\n\nimport click\n\nimport os\nimport datetime\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as dates\n\nfrom pandas_degreedays import calculate_dd, inter_lin_nan, plot_temp\nfrom pandas_degreedays import yearly_month, yearly_month_ref\n\n@click.command()\n@click.option(\'--filename\', default=\'temperature_sample.xls\', help=u""Filename of input file"")\n@click.option(\'--col_dt\', default=\'datetime\', help=u""Name of column for datetime (index)"")\n@click.option(\'--col_temp\', default=\'temp\', help=u""Name of column for temp"")\n@click.option(\'--method\', default=\'pro\', help=u""Degree days method (\'pro\' or \'meteo\')"")\n@click.option(\'--typ\', default=\'heating\', help=u""Degree days type (\'heating\' or \'cooling\')"")\n@click.option(\'--tref\', default=18.0, help=u""Reference temperature to calculate degree days"")\n@click.option(\'--groupname\', default=\'yearly\', help=u""Grouping period (\'yearly\', \'monthly\')"")\n@click.option(\'--groupstartmonth\', default=10, help=u""Starting month for yearly grouping"")\ndef main(filename, col_dt, col_temp, method, typ, tref, groupname, groupstartmonth):\n    basepath = os.path.dirname(__file__)\n    filename = os.path.join(basepath, filename)\n    #filename=\'sample/temperature_sample.xls\'\n    #col_dt = \'datetime\'\n    #col_temp = \'temp\'\n    df_temp = pd.read_excel(filename)\n    df_temp = df_temp.set_index(col_dt)\n    ts_temp = df_temp[col_temp] # get serie from DataFrame\n    #df_temp = df_temp.set_index(\'datetime\')\n    #ts_temp = df_temp[\'temp\']\n\n    ts_temp = inter_lin_nan(ts_temp, \'1H\') # interpolates linearly NaN\n\n    print(ts_temp) # display serie (time serie of temperature values)\n    #print(ts_temp.dtypes)\n    #print(ts_temp.index)\n\n    # calculates and display degree days\n    #df_degreedays = calculate_dd(ts_temp, method=method, typ=typ, Tref=tref, group=groupname)\n    #df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=\'monthly\')\n    #df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=\'yearly\')\n    month = groupstartmonth\n    #groupname = \'yearly10\'\n    groupname = \'func\'\n    #df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=groupname)\n    df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=lambda dt: yearly_month(dt, month))\n    #print(df_degreedays)\n\n    #df_degreedays[\'DD_7\'] = pd.rolling_mean(df_degreedays[\'DD\'], 7)\n\n    plot_temp(ts_temp, df_degreedays)\n    plt.show()\n\n    #import calendar\n    df_degreedays = df_degreedays.reset_index()\n    df_degreedays[\'year_ref\'] = df_degreedays[\'date\'].map(lambda dt: yearly_month_ref(dt, month, 1970))\n    #df_degreedays[\'duration\'] = df_degreedays[\'date\'].map(lambda dt: datetime.datetime(1970, dt.month, dt.day))\n    df_degreedays[\'duration\'] = df_degreedays.apply(lambda row: datetime.datetime(row[\'year_ref\'], row[\'date\'].month, row[\'date\'].day), axis=1)\n    #df_degreedays[\'duration\'] = (df_degreedays[\'date\'] - df_degreedays[groupname].map(lambda year: datetime.datetime(year, month, 1))).map(lambda td: td.astype(\'timedelta64[D]\')/np.timedelta64(1, \'D\'))\n    df_degreedays_yearly = pd.pivot_table(df_degreedays, values=\'DD_cum\', index=\'duration\', columns=groupname)\n\n    #fig, ax = plt.subplots()\n    #ax.xaxis.grid(True, which=""major"")\n    #ax.yaxis.grid()\n    #ax.xaxis.set_major_locator(dates.MonthLocator(range(1, 13), bymonthday=1, interval=1))\n    #ax.xaxis.set_major_formatter(dates.DateFormatter(""%b""))\n    #df_degreedays_yearly.plot()\n    #df_degreedays_yearly.plot(ax=ax)\n    #plt.show()\n    fig, ax = plt.subplots()\n    for i, year in enumerate(df_degreedays_yearly.columns):\n        ax.plot_date(df_degreedays_yearly.index.to_pydatetime(), df_degreedays_yearly[year], \'-\', label=df_degreedays_yearly.columns[i])\n    ax.legend(bbox_to_anchor=[0.25, 0.95])\n    ax.xaxis.grid(True, which=""major"")\n    ax.yaxis.grid()\n    ax.xaxis.set_major_locator(dates.MonthLocator(range(1, 13), bymonthday=1, interval=1))\n    ax.xaxis.set_major_formatter(dates.DateFormatter(""%b""))\n    plt.show()\n    \nif __name__ == ""__main__"":\n    main()\n'"
sample/calc_degreedays_from_openweathermap.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nFetch temperature from OpenWeatherMap.org API\nCalculating degree days\nPlotting\n""""""\nimport click\n\nfrom pandas_degreedays import calculate_dd, inter_lin_nan, plot_temp\nfrom pandas_degreedays.provider import TemperatureProvider\nimport datetime\nimport os\nimport logging\nimport logging.config\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef temp_from_openweathermap(api_key, lon, lat, start_date, end_date, column):\n    cache_name = \'cache-openweathermap\'\n    ow = OpenWeatherMapRequests(api_key=api_key, cache_name=cache_name, expire_after=None) # no expiration for history\n\n    stations = ow.find_stations_near(lon=lon, lat=lat, cnt=1)\n    logging.info(""\\n%s"" % stations)\n    station_id = stations.iloc[0][\'station.id\']\n\n    data = ow.get_historic_weather(station_id, start_date, end_date)\n    logging.info(""\\n%s"" % data)\n\n    ts_temp = data[column] # get serie from DataFrame\n\n    return(ts_temp)\n\n@click.command()\n@click.option(\'--provider\', default=\'OpenWeatherMap\', help=u""Temperature data provider"")\n@click.option(\'--api_key\', default=\'\', help=u""API Key for Wunderground"")\n@click.option(\'--lon\', default=0.34189, help=u""Longitude"")\n@click.option(\'--lat\', default=46.5798114, help=u""Latitude"")\n@click.option(\'--range\', default=\'\', help=u""Date range (YYYYMMDD:YYYYMMDD) or date (YYYYMMDD) or \'\' (current weather)"")\n@click.option(\'--column\', default=\'main.temp.ma\', help=u""Temperature column"")\ndef main(provider, api_key, lon, lat, range, column):\n    if range==\'\':\n        dt = datetime.datetime.utcnow()\n        #dt = datetime.datetime.fromordinal(dt.toordinal())\n        dt = datetime.datetime(year=dt.year, month=dt.month, day=dt.day) # yesterday 00:00\n        dt = dt - datetime.timedelta(days=1)\n        end_date = dt\n        start_date = end_date - datetime.timedelta(days=int(365*2.5))\n    else:\n        range = range.split(\':\')\n        range = map(pd.to_datetime, range)\n        if len(range)==1:\n            raise(NotImplementedError)\n        start_date = range[0]\n        end_date = range[1]\n\n    temp_provider = TemperatureProvider(provider, api_key=api_key)\n    ts_temp = temp_provider.get_from_coordinates(lon, lat, start_date, end_date, column)\n\n    #ts_temp = temp_from_openweathermap(api_key, lon, lat, start_date, end_date, column)\n\n    ts_temp = inter_lin_nan(ts_temp, \'1H\') # interpolates linearly NaN\n\n    print(ts_temp) # display serie (time serie of temperature values)\n    #print(ts_temp.dtypes)\n    #print(ts_temp.index)\n\n    # calculates and display degree days\n    df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=\'yearly\')\n    #df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=\'yearly10\')\n    #df_degreedays = calculate_dd(ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0, group=lambda dt: yearly_month(dt, 8))\n\n    print(df_degreedays)\n\n    #df_degreedays[\'DD_7\'] = pd.rolling_mean(df_degreedays[\'DD\'], 7)\n\n    plot_temp(ts_temp, df_degreedays)\n    plt.show()\n\nif __name__ == ""__main__"":\n    basepath = os.path.dirname(__file__)\n    logging.config.fileConfig(os.path.join(basepath, ""logging.conf""))\n    logger = logging.getLogger(""simpleExample"")\n    main()\n'"
tests/test_degreedays.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport datetime\n\nimport pandas_degreedays\nfrom pandas_degreedays import *\nimport six\n\ndef test_version():\n    """"""Test version""""""\n    version = pandas_degreedays.__version__\n    isinstance(version, six.string_types)\n\ndef test_degreedays_date_Tmin_before_6PM():\n    """"""Tmin: BEFORE 6PM""""""\n    dt = datetime.datetime(year=2014, month=11, day=1, hour=12, minute=0)\n    d = degreedays_date_Tn(dt)\n    d2 = dt.date()\n    assert(d == d2)\n\ndef test_degreedays_date_Tmin_after_6PM():\n    """"""Tmin: AFTER 6PM""""""\n    dt = datetime.datetime(year=2014, month=11, day=1, hour=18, minute=0)\n    d = degreedays_date_Tn(dt)\n    dt2 = dt + datetime.timedelta(days=1)\n    d2 = dt2.date()\n    assert(d == d2)\n\ndef test_degreedays_date_Tmax_before_6AM():\n    """"""Tmin: BEFORE 6AM""""""\n    dt = datetime.datetime(year=2014, month=11, day=1, hour=5, minute=0)\n    d = degreedays_date_Tx(dt)\n    dt2 = dt - datetime.timedelta(days=1)\n    d2 = dt2.date()\n    assert(d == d2)\n\ndef test_degreedays_date_Tmin_after_6AM():\n    """"""Tmin: AFTER 6AM""""""\n    dt = datetime.datetime(year=2014, month=11, day=1, hour=7, minute=0)\n    d = degreedays_date_Tx(dt)\n    d2 = dt.date()\n    assert(d == d2)\n\ndef test_degreedays():\n    """"""Calculating degree days""""""\n    assert(hdd_meteo(10, 20, 18)==3)\n    assert(hdd_meteo(10, 30, 18)==0)\n    assert(cdd_meteo(10, 20, 18)==0)\n    assert(cdd_meteo(10, 30, 18)==2)\n    assert(hdd(5, 15, 18)==8)\n    assert(hdd(20, 30, 18)==0)\n    assert(hdd(10, 20, 18)==3.328)\n    assert(cdd(5, 15, 18)==0)\n    assert(cdd(20, 30, 18)==7)\n    assert(cdd(10, 20, 18)==0.32799999999999996)\n\ndef test_sample():\n    """"""Reading XLS file with temperature as time serie\n    and calculate degree days""""""\n    filename = os.path.join(\'sample\', \'temperature_sample.xls\')\n    df_temp = pd.read_excel(filename)\n    df_temp = df_temp.set_index(\'datetime\')\n    ts_temp = df_temp[\'temp\']\n    df_degreedays = calculate_dd(ts_temp=ts_temp, method=\'pro\', typ=\'heating\', Tref=18.0)\n    isinstance(df_degreedays, pd.DataFrame)\n'"
pandas_degreedays/provider/__init__.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport logging\nimport traceback\n\nclass TemperatureProviderFactory(object):\n    """"""\n    TemperatureProviderFactory\n\n    Factory of TemperatureProvider\n\n    Only ONE factory need to be defined : TEMPERATURE_PROVIDER_FACTORY\n\n    Additional TemperatureProvider can be add using:\n\n    TEMPERATURE_PROVIDER_FACTORY.add(\'temperatureprovidername\', TemperatureProviderClassName)\n    """"""\n    def __init__(self):\n        self._d_factory = {}\n\n        # === OpenWeatherMap ===\n        try:\n            from pandas_degreedays.provider.openweathermap import TemperatureProviderOpenWeatherMap\n            self.add(\'OpenWeatherMap\', TemperatureProviderOpenWeatherMap)\n            self.add(\'owm\', TemperatureProviderOpenWeatherMap)\n        except:\n            logging.error(traceback.format_exc())\n\n    def add(self, name, cls):\n        """"""\n        Adds (register) a TemperatureProvider class using a name\n        """"""\n        self._d_factory[name.lower()] = cls\n\n    def factory(self, name, *args, **kwargs):\n        """"""\n        Returns a TemperatureProvider (factory) using a name and arguments\n        """"""\n        try:\n            return(self._d_factory[name.lower()](*args, **kwargs))\n        except:\n            logging.error(traceback.format_exc())\n            raise(NotImplementedError(""TemperatureProvider \'%s\' not implemented - should be in %s"" % (name, self._d_factory.keys())))\n\nTEMPERATURE_PROVIDER_FACTORY = TemperatureProviderFactory()\n\ndef TemperatureProvider(name, *args, **kwargs):\n    """"""\n    Creates a TemperatureProvider to fetch temperature from a number of online sources.\n\n    Currently supports \n        * [OpenWeatherMap.org](http://www.openweathermap.org/) using \n\n    Parameters\n    ----------\n\n    :param name: data source\n    :type name: str\n\n        * ""OpenWeatherMap"" (can also be simply ""owm"")\n    """"""\n\n    return(TEMPERATURE_PROVIDER_FACTORY.factory(name, *args, **kwargs))\n'"
pandas_degreedays/provider/base.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\n    pandas_degreedays.provider.base\n    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    Implements TemperatureProviderBase base class for TemperatureProviders\n""""""\n\nclass TemperatureProviderBase(object):\n    def __init__(self, *args, **kwargs):\n        self.init(*args, **kwargs)\n'"
pandas_degreedays/provider/openweathermap.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom pandas_degreedays.provider.base import TemperatureProviderBase\nfrom openweathermap_requests import OpenWeatherMapRequests\nimport logging\n\nclass TemperatureProviderOpenWeatherMap(TemperatureProviderBase):\n    def init(self, *args, **kwargs):\n        try:\n            self.api_key = kwargs[\'api_key\']\n        except:\n            self.api_key = None\n\n    def get_from_coordinates(self, lon, lat, start_date, end_date, column=\'main.temp.ma\'):\n        cache_name = \'cache-openweathermap\'\n        ow = OpenWeatherMapRequests(api_key=self.api_key, cache_name=cache_name, expire_after=None) # no expiration for history\n\n        stations = ow.find_stations_near(lon=lon, lat=lat, cnt=1)\n        logging.info(""\\n%s"" % stations)\n        station_id = stations.iloc[0][\'station.id\']\n\n        data = ow.get_historic_weather(station_id, start_date, end_date)\n        logging.info(""\\n%s"" % data)\n\n        ts_temp = data[column] # get serie from DataFrame\n\n        return(ts_temp)\n\n    def get_from_place(self, place, start_date, end_date, column=\'main.temp.ma\'):\n        cache_name = \'cache-openweathermap\'\n        ow = OpenWeatherMapRequests(api_key=self.api_key, cache_name=cache_name, expire_after=None) # no expiration for history\n\n        data = ow.get_historic_weather(place, start_date, end_date)\n        logging.info(""\\n%s"" % data)\n\n        ts_temp = data[column] # get serie from DataFrame\n\n        return(ts_temp)\n'"
