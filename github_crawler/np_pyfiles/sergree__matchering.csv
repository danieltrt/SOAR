file_path,api_count,code
setup.py,0,"b""from setuptools import setup, find_packages\n\nwith open('requirements.txt') as f:\n    requirements = f.read().splitlines()\n\nwith open('README.md', 'r') as fh:\n    long_description = fh.read()\n\nsetup(\n    name='matchering',\n    version='2.0.2',\n    author='Sergree',\n    author_email='wokashi.rg@gmail.com',\n    description='Audio Matching and Mastering Python Library',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    install_requires=requirements,\n    license='GPLv3',\n    url='https://github.com/sergree/matchering',\n    packages=find_packages(include=['matchering', 'matchering.*']),\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n        'Programming Language :: Python :: 3.7',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3 :: Only',\n        'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',\n        'Operating System :: OS Independent',\n        'Intended Audience :: Developers',\n        'Intended Audience :: End Users/Desktop',\n        'Intended Audience :: Other Audience',\n        'Natural Language :: English',\n        'Topic :: Artistic Software',\n        'Topic :: Multimedia',\n        'Topic :: Multimedia :: Sound/Audio',\n        'Topic :: Multimedia :: Sound/Audio :: Analysis',\n        'Topic :: Multimedia :: Sound/Audio :: Conversion',\n        'Topic :: Utilities'\n    ],\n    python_requires='>=3.6',\n)\n"""
examples/advanced_results.py,0,"b""import matchering as mg\n\n# Let's keep info and warning outputs here, muting out the debug ones\nmg.log(info_handler=print, warning_handler=print)\n\nmg.process(\n    target='my_song.wav',\n    reference='some_popular_song.wav',\n    # pcm16 and pcm24 are just basic shortcuts\n    # You can also use the Result class to make some advanced results\n    results=[\n        # Basic WAV 16-bit, match + master\n        mg.pcm16('my_song_master_16bit.wav'),\n\n        # FLAC 24-bit, match only (no limiter), normalized to -0.01 dB\n        # Recommendations for adjusting the amplitude will be displayed in the debug print if it is enabled\n        mg.Result(\n            'custom_result_24bit_no_limiter.flac',\n            subtype='PCM_24',\n            use_limiter=False\n        ),\n\n        # AIFF 32-bit float, match only (no limiter), non-normalized\n        # Can exceed 0 dB without clipping\n        # So you can directly feed it to some VST limiter in your DAW\n        mg.Result(\n            'custom_result_32bit_no_limiter_non-normalized.aiff',\n            subtype='FLOAT',\n            use_limiter=False,\n            normalize=False\n        )\n\n        # More available formats and subtypes:\n        # https://pysoundfile.readthedocs.io/en/latest/#soundfile.available_formats\n        # https://pysoundfile.readthedocs.io/en/latest/#soundfile.available_subtypes\n    ]\n)\n"""
examples/advanced_text_output.py,0,"b""import matchering as mg\n\nfrom datetime import datetime\n\n\n# Let's define a basic text output function that will also output the current datetime\ndef my_print(text):\n    print(f'{datetime.now()}: {text}')\n\n\n# The information output will be marked with a prefix\ndef info(text):\n    my_print(f'INFO: {text}')\n\n\n# The warning output will be highlighted with exclamation marks on both sides\ndef warning(text):\n    my_print('!' * 20)\n    my_print(f'! WARNING: {text}')\n    my_print('!' * 20)\n\n\n# Set new handlers\nmg.log(\n    warning_handler=warning,\n    info_handler=info,\n    debug_handler=my_print\n)\n\nmg.process(\n    target='my_song.wav',\n    reference='some_popular_song.wav',\n    results=[\n        mg.pcm16('my_song_master_16bit.wav'),\n        mg.pcm24('my_song_master_24bit.wav'),\n    ]\n)\n\n# These settings will result in the following text output:\n# ...\n# 2020-01-11 11:03:29.225821: INFO: Loading and analysis\n# 2020-01-11 11:03:29.225821: Loading the TARGET file: 'my_song.wav'...\n# 2020-01-11 11:03:29.396622: The TARGET file is loaded\n# 2020-01-11 11:03:29.396622: TARGET audio length: 22932000 samples (0:08:40)\n# 2020-01-11 11:03:30.528787: !!!!!!!!!!!!!!!!!!!!\n# 2020-01-11 11:03:30.528787: ! WARNING: The applied limiter is detected in the TARGET file...\n# 2020-01-11 11:03:30.528787: !!!!!!!!!!!!!!!!!!!!\n# 2020-01-11 11:03:30.528787: Loading the REFERENCE file: 'some_popular_song.wav'...\n# ...\n\n# You can bind any function that takes a string as input. It may not necessarily be the print().\n# Just bind this to some database via a connector or ORM, or, for example, use a logging module, as done here:\n# https://github.com/sergree/matchering-cli\n"""
examples/basic.py,0,"b'import matchering as mg\n\n# Sending all log messages to the default print function\n# Just delete the following line to work silently\nmg.log(print)\n\nmg.process(\n    # The track you want to master\n    target=\'my_song.wav\',\n    # Some ""wet"" reference track\n    reference=\'some_popular_song.wav\',\n    # Where and how to save your results\n    results=[\n        mg.pcm16(\'my_song_master_16bit.wav\'),\n        mg.pcm24(\'my_song_master_24bit.wav\'),\n    ]\n)\n'"
examples/edited_config.py,0,"b""import matchering as mg\n\n# Let's completely disable any text output here\n# mg.log(print)\n\nmg.process(\n    target='my_song.wav',\n    reference='some_popular_song.wav',\n    results=[\n        mg.pcm16('my_song_master_16bit.wav'),\n        mg.pcm24('my_song_master_24bit.wav'),\n    ],\n    # Create a custom Config instance to edit matchering configuration\n    # Think twice before you change something here\n    config=mg.Config(\n        # Increase the maximum length to 30 minutes from the default value of 15\n        max_length=30 * 60,\n        # Increase the internal and resulting sample rate to 96 kHz from the default value of 44.1 kHz\n        internal_sample_rate=96000,\n        # Change the threshold value (float, not dB) from the default value of 0.9981 (-0.01 dB)\n        threshold=0.7079,  # -3 dB\n        # Change the temp folder to work with ffmpeg\n        temp_folder='/tmp',\n        # Lower the preview length to 15 seconds from the default value of 30\n        preview_size=15,\n        # Allow matchering to accept the same files (useless in fact)\n        allow_equality=True\n        # Etc...\n        # The remaining parameters will be filled with default values\n        # Examine defaults.py to find other parameters\n    )\n)\n"""
examples/with_preview.py,0,"b""import matchering as mg\n\n# Let's keep only warning outputs here, muting everything else\nmg.log(warning_handler=print)\n\nmg.process(\n    target='my_song.wav',\n    reference='some_popular_song.wav',\n    results=[\n        mg.pcm16('my_song_master_16bit.wav'),\n        mg.pcm24('my_song_master_24bit.wav'),\n    ],\n    # These two lines will allow you to create two 30-second FLAC files with the loudest parts of:\n    # 'my_song.wav' and 'my_song_master_16bit.wav'\n    # Use them to quickly compare the target audio with the resulting audio\n    preview_target=mg.pcm16('preview_my_song.flac'),\n    preview_result=mg.pcm16('preview_my_song_master.flac')\n)\n"""
matchering/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering\n~~~~~~~~~~~~~~~~~~~\n\nAudio Matching and Mastering Python Library\n\n:copyright: (C) 2016-2020 Sergree\n:license: GPLv3, see LICENSE for more details.\n\n""""""\n\n__title__ = \'matchering\'\n\n__author__ = \'Sergree\'\n__credits__ = [\'Sergey Grishakov\', \'Igor Isaev\', \'Chin Yun Yu\', \'Elizaveta Grishakova\']\n__maintainer__ = \'Sergree\'\n__email__ = \'wokashi.rg@gmail.com\'\n__license__ = \'GPLv3\'\n__copyright__ = \'Copyright (C) 2016-2020 Sergree\'\n\n__version__ = \'2.0.2\'\n\nfrom .log.handlers import set_handlers as log\nfrom .results import Result, pcm16, pcm24\nfrom .defaults import Config\nfrom .core import process\nfrom .loader import load\nfrom .checker import check\n'"
matchering/checker.py,10,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nfrom resampy import resample\n\nfrom .log import Code, warning, info, debug, ModuleError\nfrom . import Config\nfrom .dsp import size, is_mono, is_stereo, mono_to_stereo, count_max_peaks\nfrom .utils import time_str\n\n\ndef __check_sample_rate(\n        array: np.ndarray,\n        sample_rate: int,\n        required_sample_rate: int,\n        name: str,\n        log_handler,\n        log_code: Code\n) -> (np.ndarray, int):\n    if sample_rate != required_sample_rate:\n        debug(f\'Resampling {name} audio from {sample_rate} Hz to {required_sample_rate} Hz...\')\n        array = resample(array, sample_rate, required_sample_rate, axis=0)\n        log_handler(log_code)\n    return array, required_sample_rate\n\n\ndef __check_length(\n        array: np.ndarray,\n        sample_rate: int,\n        max_length: int,\n        min_length: int,\n        name: str,\n        error_code_max: Code,\n        error_code_min: Code\n) -> None:\n    length = size(array)\n    debug(f\'{name} audio length: {length} samples ({time_str(length, sample_rate)})\')\n    if length > max_length:\n        raise ModuleError(error_code_max)\n    elif length < min_length:\n        raise ModuleError(error_code_min)\n\n\ndef __check_channels(\n        array: np.ndarray,\n        info_code_mono: Code,\n        error_code_not_stereo: Code\n) -> np.ndarray:\n    if is_mono(array):\n        info(info_code_mono)\n        array = mono_to_stereo(array)\n    elif not is_stereo(array):\n        raise ModuleError(error_code_not_stereo)\n    return array\n\n\ndef __check_clipping_limiting(\n        array: np.ndarray,\n        clipping_samples_threshold: int,\n        limited_samples_threshold: int,\n        warning_code_clipping: Code,\n        warning_code_limiting: Code\n) -> None:\n    max_value, max_count = count_max_peaks(array)\n    if max_count > clipping_samples_threshold:\n        if np.isclose(max_value, 1.):\n            warning(warning_code_clipping)\n        elif max_count > limited_samples_threshold:\n            warning(warning_code_limiting)\n\n\ndef check(array: np.ndarray, sample_rate: int, config: Config, name: str) -> (np.ndarray, int):\n    name = name.upper()\n\n    __check_length(\n        array,\n        sample_rate,\n        config.max_length * sample_rate,\n        config.fft_size * sample_rate // config.internal_sample_rate,\n        name,\n        Code.ERROR_TARGET_LENGTH_IS_EXCEEDED if name == \'TARGET\'\n        else Code.ERROR_REFERENCE_LENGTH_LENGTH_IS_EXCEEDED,\n        Code.ERROR_TARGET_LENGTH_IS_TOO_SMALL if name == \'TARGET\'\n        else Code.ERROR_REFERENCE_LENGTH_LENGTH_TOO_SMALL\n    )\n\n    array = __check_channels(\n        array,\n        Code.INFO_TARGET_IS_MONO if name == \'TARGET\' else Code.INFO_REFERENCE_IS_MONO,\n        Code.ERROR_TARGET_NUM_OF_CHANNELS_IS_EXCEEDED if name == \'TARGET\'\n        else Code.ERROR_REFERENCE_NUM_OF_CHANNELS_IS_EXCEEDED\n    )\n\n    array, sample_rate = __check_sample_rate(\n        array,\n        sample_rate,\n        config.internal_sample_rate,\n        name,\n        warning if name == \'TARGET\' else info,\n        Code.WARNING_TARGET_IS_RESAMPLED if name == \'TARGET\'\n        else Code.INFO_REFERENCE_IS_RESAMPLED\n    )\n\n    if name == \'TARGET\':\n        __check_clipping_limiting(\n            array,\n            config.clipping_samples_threshold,\n            config.limited_samples_threshold,\n            Code.WARNING_TARGET_IS_CLIPPING,\n            Code.WARNING_TARGET_LIMITER_IS_APPLIED\n        )\n\n    return array, sample_rate\n\n\ndef check_equality(target: np.ndarray, reference: np.ndarray) -> None:\n    if target.shape == reference.shape and np.allclose(target, reference):\n        raise ModuleError(Code.ERROR_TARGET_EQUALS_REFERENCE)\n'"
matchering/core.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nfrom .log import Code, info, debug, debug_line, ModuleError\nfrom . import Config, Result\nfrom .loader import load\nfrom .stages import main\nfrom .saver import save\nfrom .preview_creator import create_preview\nfrom .utils import get_temp_folder\nfrom .checker import check, check_equality\nfrom .dsp import channel_count, size\n\n\ndef process(\n        target: str,\n        reference: str,\n        results: list,\n        config: Config = Config(),\n        preview_target: Result = None,\n        preview_result: Result = None\n):\n    debug(\'Please give us a star to help the project: https://github.com/sergree/matchering\')\n    debug_line()\n    info(Code.INFO_LOADING)\n\n    if not results:\n        raise RuntimeError(f\'The result list is empty\')\n\n    # Get a temporary folder for converting mp3\'s\n    temp_folder = config.temp_folder if config.temp_folder else get_temp_folder(results)\n\n    # Load the target\n    target, target_sample_rate = load(target, \'target\', temp_folder)\n    # Analyze the target\n    target, target_sample_rate = check(target, target_sample_rate, config, \'target\')\n\n    # Load the reference\n    reference, reference_sample_rate = load(reference, \'reference\', temp_folder)\n    # Analyze the reference\n    reference, reference_sample_rate = check(reference, reference_sample_rate, config, \'reference\')\n\n    # Analyze the target and the reference together\n    if not config.allow_equality:\n        check_equality(target, reference)\n\n    # Validation of the most important conditions\n    if not (target_sample_rate == reference_sample_rate == config.internal_sample_rate)\\\n            or not (channel_count(target) == channel_count(reference) == 2)\\\n            or not (size(target) > config.fft_size and size(reference) > config.fft_size):\n        raise ModuleError(Code.ERROR_VALIDATION)\n\n    # Process\n    result, result_no_limiter, result_no_limiter_normalized = main(\n        target,\n        reference,\n        config,\n        need_default=any(rr.use_limiter for rr in results),\n        need_no_limiter=any(not rr.use_limiter and not rr.normalize for rr in results),\n        need_no_limiter_normalized=any(not rr.use_limiter and rr.normalize for rr in results),\n    )\n\n    del reference\n    if not (preview_target or preview_result):\n        del target\n\n    debug_line()\n    info(Code.INFO_EXPORTING)\n\n    # Save\n    for required_result in results:\n        if required_result.use_limiter:\n            correct_result = result\n        else:\n            if required_result.normalize:\n                correct_result = result_no_limiter_normalized\n            else:\n                correct_result = result_no_limiter\n        save(required_result.file, correct_result, config.internal_sample_rate, required_result.subtype)\n\n    # Creating a preview (if needed)\n    if preview_target or preview_result:\n        result = next(item for item in [result, result_no_limiter, result_no_limiter_normalized] if item is not None)\n        create_preview(target, result, config, preview_target, preview_result)\n\n    debug_line()\n    info(Code.INFO_COMPLETED)\n'"
matchering/defaults.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport math\nfrom .log import debug\n\n\nclass LimiterConfig:\n    def __init__(\n            self,\n            attack: float = 1,\n            hold: float = 1,\n            release: float = 3000,\n            attack_filter_coefficient: float = -2,\n            hold_filter_order: int = 1,\n            hold_filter_coefficient: float = 7,\n            release_filter_order: int = 1,\n            release_filter_coefficient: float = 800\n    ):\n        assert attack > 0\n        self.attack = attack\n\n        assert hold > 0\n        self.hold = hold\n\n        assert release > 0\n        self.release = release\n\n        self.attack_filter_coefficient = attack_filter_coefficient\n\n        assert hold_filter_order > 0\n        assert isinstance(hold_filter_order, int)\n        self.hold_filter_order = hold_filter_order\n\n        self.hold_filter_coefficient = hold_filter_coefficient\n\n        assert release_filter_order > 0\n        assert isinstance(release_filter_order, int)\n        self.release_filter_order = release_filter_order\n\n        self.release_filter_coefficient = release_filter_coefficient\n\n\nclass Config:\n    def __init__(\n            self,\n            internal_sample_rate: int = 44100,\n            max_length: float = 15 * 60,\n            max_piece_size: float = 15,\n            threshold: float = (2 ** 15 - 61) / 2 ** 15,\n            min_value: float = 1e-6,\n            fft_size: int = 4096,\n            lin_log_oversampling: int = 4,\n            rms_correction_steps: int = 4,\n            clipping_samples_threshold: int = 8,\n            limited_samples_threshold: int = 128,\n            allow_equality: bool = False,\n            lowess_frac: float = 0.0375,\n            lowess_it: int = 0,\n            lowess_delta: float = 0.001,\n            preview_size: float = 30,\n            preview_analysis_step: float = 5,\n            preview_fade_size: float = 1,\n            preview_fade_coefficient: float = 8,\n            temp_folder: str = None,\n            limiter: LimiterConfig = LimiterConfig(),\n    ):\n        assert internal_sample_rate > 0\n        assert isinstance(internal_sample_rate, int)\n        if internal_sample_rate != 44100:\n            debug(\'Using an internal sample rate other than 44100 has not been tested properly! \'\n                  \'Use it at your own risk!\')\n        self.internal_sample_rate = internal_sample_rate\n\n        assert max_length > 0\n        assert max_length > fft_size / internal_sample_rate\n        self.max_length = max_length\n\n        assert threshold > min_value\n        assert threshold < 1\n        self.threshold = threshold\n\n        assert min_value > 0\n        assert min_value < 0.1\n        self.min_value = min_value\n\n        assert max_piece_size > 0\n        assert max_piece_size > fft_size / internal_sample_rate\n        assert max_piece_size < max_length\n        self.max_piece_size = max_piece_size * internal_sample_rate\n\n        assert fft_size > 1\n        assert math.log2(fft_size).is_integer()\n        self.fft_size = fft_size\n\n        assert lin_log_oversampling > 0\n        assert isinstance(lin_log_oversampling, int)\n        self.lin_log_oversampling = lin_log_oversampling\n\n        assert rms_correction_steps >= 0\n        assert isinstance(rms_correction_steps, int)\n        self.rms_correction_steps = rms_correction_steps\n\n        assert clipping_samples_threshold >= 0\n        assert limited_samples_threshold > 0\n        assert limited_samples_threshold > clipping_samples_threshold\n        assert isinstance(clipping_samples_threshold, int)\n        assert isinstance(limited_samples_threshold, int)\n        self.clipping_samples_threshold = clipping_samples_threshold\n        self.limited_samples_threshold = limited_samples_threshold\n\n        assert isinstance(allow_equality, bool)\n        self.allow_equality = allow_equality\n\n        assert lowess_frac > 0\n        assert lowess_it >= 0\n        assert lowess_delta >= 0\n        assert isinstance(lowess_it, int)\n        self.lowess_frac = lowess_frac\n        self.lowess_it = lowess_it\n        self.lowess_delta = lowess_delta\n\n        assert preview_size > 5\n        assert preview_analysis_step > 1\n        assert preview_fade_size > 0\n        assert preview_fade_coefficient >= 2\n        self.preview_size = preview_size * internal_sample_rate\n        self.preview_analysis_step = preview_analysis_step * internal_sample_rate\n        self.preview_fade_size = preview_fade_size * internal_sample_rate\n        self.preview_fade_coefficient = preview_fade_coefficient\n\n        assert temp_folder is None or isinstance(temp_folder, str)\n        self.temp_folder = temp_folder\n\n        assert isinstance(limiter, LimiterConfig)\n        self.limiter = limiter\n'"
matchering/dsp.py,47,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nimport statsmodels.api as sm\n\n\ndef size(array: np.ndarray) -> int:\n    return array.shape[0]\n\n\ndef channel_count(array: np.ndarray) -> int:\n    return array.shape[1]\n\n\ndef is_mono(array: np.ndarray) -> bool:\n    return array.shape[1] == 1\n\n\ndef is_stereo(array: np.ndarray) -> bool:\n    return array.shape[1] == 2\n\n\ndef is_1d(array: np.ndarray) -> bool:\n    return len(array.shape) == 1\n\n\ndef mono_to_stereo(array: np.ndarray) -> np.ndarray:\n    return np.repeat(array, repeats=2, axis=1)\n\n\ndef count_max_peaks(array: np.ndarray) -> (float, int):\n    max_value = np.abs(array).max()\n    max_count = np.count_nonzero(\n        np.logical_or(\n            np.isclose(array, max_value),\n            np.isclose(array, -max_value)\n        )\n    )\n    return max_value, max_count\n\n\ndef lr_to_ms(array: np.ndarray) -> (np.ndarray, np.ndarray):\n    array = np.copy(array)\n    array[:, 0] += array[:, 1]\n    array[:, 0] *= 0.5\n    mid = np.copy(array[:, 0])\n    array[:, 0] -= array[:, 1]\n    side = np.copy(array[:, 0])\n    return mid, side\n\n\ndef ms_to_lr(mid_array: np.ndarray, side_array: np.ndarray) -> np.ndarray:\n    return np.vstack((mid_array + side_array, mid_array - side_array)).T\n\n\ndef unfold(array: np.ndarray, piece_size: int, divisions: int) -> np.ndarray:\n    # (len(array),) -> (divisions, piece_size)\n    return array[:piece_size * divisions].reshape(-1, piece_size)\n\n\ndef rms(array: np.ndarray) -> float:\n    return np.sqrt(array @ array / array.shape[0])\n\n\ndef batch_rms(array: np.ndarray) -> np.ndarray:\n    piece_size = array.shape[1]\n    # (divisions, piece_size) -> (divisions, 1, piece_size)\n    multiplicand = array[:, None, :]\n    # (divisions, piece_size) -> (divisions, piece_size, 1)\n    multiplier = array[..., None]\n    return np.sqrt(np.squeeze(multiplicand @ multiplier, axis=(1, 2)) / piece_size)\n\n\ndef amplify(array: np.ndarray, gain: float) -> np.ndarray:\n    return array * gain\n\n\ndef normalize(\n        array: np.ndarray,\n        threshold: float,\n        epsilon: float,\n        normalize_clipped: bool\n) -> (np.ndarray, float):\n    coefficient = 1.\n    max_value = np.abs(array).max()\n    if max_value < threshold or normalize_clipped:\n        coefficient = max(epsilon, max_value / threshold)\n    return array / coefficient, coefficient\n\n\ndef smooth_lowess(\n        array: np.ndarray,\n        frac: float,\n        it: int,\n        delta: float\n) -> np.ndarray:\n    return sm.nonparametric.lowess(\n        array,\n        np.linspace(0, 1, len(array)),\n        frac=frac,\n        it=it,\n        delta=delta\n    )[:, 1]\n\n\ndef clip(\n        array: np.ndarray,\n        to: float = 1\n) -> np.ndarray:\n    return np.clip(array, -to, to)\n\n\ndef flip(array: np.ndarray) -> np.ndarray:\n    return 1. - array\n\n\ndef rectify(\n        array: np.ndarray,\n        threshold: float\n) -> np.ndarray:\n    rectified = np.abs(array).max(1)\n    rectified[rectified <= threshold] = threshold\n    rectified /= threshold\n    return rectified\n\n\ndef max_mix(*args) -> np.ndarray:\n    return np.maximum.reduce(args)\n\n\ndef strided_app_2d(matrix: np.ndarray, batch_size: int, step: int) -> np.ndarray:\n    matrix_length = matrix.shape[0]\n    matrix_width = matrix.shape[1]\n    if batch_size > matrix_length:\n        return np.expand_dims(matrix, axis=0)\n    batch_count = ((matrix_length - batch_size) // step) + 1\n    stride_length, stride_width = matrix.strides\n    return np.lib.stride_tricks.as_strided(\n        matrix,\n        shape=(batch_count, batch_size, matrix_width),\n        strides=(step * stride_length, stride_length, stride_width)\n    )\n\n\ndef batch_rms_2d(array: np.ndarray) -> np.ndarray:\n    return batch_rms(array.reshape(array.shape[0], array.shape[1] * array.shape[2]))\n\n\ndef fade(array: np.ndarray, fade_size: int) -> np.ndarray:\n    array = np.copy(array)\n    fade_in = np.linspace(0, 1, fade_size)\n    fade_out = fade_in[::-1]\n    array[:fade_size].T[:] *= fade_in\n    array[size(array) - fade_size:].T[:] *= fade_out\n    return array\n'"
matchering/loader.py,2,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport os\nimport numpy as np\nimport soundfile as sf\nimport subprocess\n\nfrom .log import Code, warning, info, debug, ModuleError\nfrom .utils import random_file\n\n\ndef load(file: str, file_type: str, temp_folder: str) -> (np.ndarray, int):\n    file_type = file_type.upper()\n    sound, sample_rate = None, None\n    debug(f\'Loading the {file_type} file: \\\'{file}\\\'...\')\n    try:\n        sound, sample_rate = sf.read(file, always_2d=True)\n    except RuntimeError as e:\n        debug(e)\n        if \'unknown format\' in str(e):\n            sound, sample_rate = __load_with_ffmpeg(file, file_type, temp_folder)\n    if sound is None or sample_rate is None:\n        if file_type == \'TARGET\':\n            raise ModuleError(Code.ERROR_TARGET_LOADING)\n        else:\n            raise ModuleError(Code.ERROR_REFERENCE_LOADING)\n    debug(f\'The {file_type} file is loaded\')\n    return sound, sample_rate\n\n\ndef __load_with_ffmpeg(file: str, file_type: str, temp_folder: str) -> (np.ndarray, int):\n    sound, sample_rate = None, None\n    debug(f\'Trying to load \\\'{file}\\\' with ffmpeg...\')\n    temp_file = os.path.join(temp_folder, random_file(prefix=\'temp\'))\n    with open(os.devnull, \'w\') as devnull:\n        try:\n            subprocess.check_call(\n                [\n                    \'ffmpeg\',\n                    \'-i\',\n                    file,\n                    temp_file\n                ],\n                stdout=devnull,\n                stderr=devnull\n            )\n            sound, sample_rate = sf.read(temp_file, always_2d=True)\n            if file_type == \'TARGET\':\n                warning(Code.WARNING_TARGET_IS_LOSSY)\n            else:\n                info(Code.INFO_REFERENCE_IS_LOSSY)\n            os.remove(temp_file)\n        except FileNotFoundError:\n            debug(\'ffmpeg is not found in the system! \'\n                  \'Download, install and add it to PATH: https://www.ffmpeg.org/download.html\')\n        except subprocess.CalledProcessError:\n            debug(f\'ffmpeg cannot convert \\\'{file}\\\' to .wav!\')\n    return sound, sample_rate\n'"
matchering/preview_creator.py,3,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\n\nfrom .log import Code, info, debug, debug_line\nfrom .dsp import size, strided_app_2d, batch_rms_2d, fade, clip\nfrom . import Config, Result\nfrom .saver import save\nfrom .utils import time_str\n\n\ndef create_preview(\n        target: np.ndarray,\n        result: np.ndarray,\n        config: Config,\n        preview_target: Result,\n        preview_result: Result\n) -> None:\n    debug_line()\n    info(Code.INFO_MAKING_PREVIEWS)\n\n    target = clip(target, config.threshold)\n\n    debug(f\'The maximum duration of the preview is {config.preview_size / config.internal_sample_rate} seconds, \'\n          f\'with the analysis step of {config.preview_analysis_step / config.internal_sample_rate} seconds\')\n\n    target_pieces = strided_app_2d(target, config.preview_size, config.preview_analysis_step)\n    result_pieces = strided_app_2d(result, config.preview_size, config.preview_analysis_step)\n\n    result_loudest_piece_idx = np.argmax(batch_rms_2d(result_pieces))\n\n    target_piece = target_pieces[result_loudest_piece_idx].copy()\n    result_piece = result_pieces[result_loudest_piece_idx].copy()\n\n    del target, target_pieces, result_pieces\n\n    debug_sample_begin = config.preview_analysis_step * int(result_loudest_piece_idx)\n    debug_sample_end = debug_sample_begin + size(result_piece)\n    debug(f\'The best part to preview: \'\n          f\'{time_str(debug_sample_begin, config.internal_sample_rate)} \'\n          f\'- {time_str(debug_sample_end, config.internal_sample_rate)}\')\n\n    if size(result) != size(result_piece):\n        fade_size = min(config.preview_fade_size, size(result_piece) // config.preview_fade_coefficient)\n        target_piece, result_piece = fade(target_piece, fade_size), fade(result_piece, fade_size)\n\n    if preview_target:\n        save(preview_target.file, target_piece, config.internal_sample_rate, preview_target.subtype, \'target preview\')\n\n    if preview_result:\n        save(preview_result.file, result_piece, config.internal_sample_rate, preview_result.subtype, \'result preview\')\n'"
matchering/results.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport os\nimport soundfile as sf\n\n\nclass Result:\n    def __init__(\n            self,\n            file: str,\n            subtype: str,\n            use_limiter: bool = True,\n            normalize: bool = True\n    ):\n        _, file_ext = os.path.splitext(file)\n        file_ext = file_ext[1:].upper()\n        if not sf.check_format(file_ext):\n            raise TypeError(f\'{file_ext} format is not supported\')\n        if not sf.check_format(file_ext, subtype):\n            raise TypeError(f\'{file_ext} format does not have {subtype} subtype\')\n        self.file = file\n        self.subtype = subtype\n        self.use_limiter = use_limiter\n        self.normalize = normalize\n\n\ndef pcm16(file: str) -> Result:\n    return Result(file, \'PCM_16\')\n\n\ndef pcm24(file: str) -> Result:\n    return Result(file, \'PCM_24\')\n'"
matchering/saver.py,1,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nimport soundfile as sf\n\nfrom .log import debug\n\n\ndef save(\n        file: str,\n        result: np.ndarray,\n        sample_rate: int,\n        subtype: str,\n        name: str = \'result\'\n) -> None:\n    name = name.upper()\n    debug(f\'Saving the {name} {sample_rate} Hz Stereo {subtype} to: \\\'{file}\\\'...\')\n    sf.write(file, result, sample_rate, subtype)\n    debug(f\'\\\'{file}\\\' is saved\')\n'"
matchering/stages.py,19,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nfrom .log import Code, info, debug, debug_line\nfrom . import Config\nfrom .utils import to_db\nfrom .dsp import amplify, normalize, clip\nfrom .stage_helpers import normalize_reference, analyze_levels, get_fir, \\\n    convolve, get_average_rms, get_lpis_and_match_rms, get_rms_c_and_amplify_pair\nfrom .limiter import limit\n\n\ndef __match_levels(\n        target: np.ndarray,\n        reference: np.ndarray,\n        config: Config\n) -> (np.ndarray, np.ndarray, float, np.ndarray, np.ndarray, np.ndarray, np.ndarray, float, float):\n    debug_line()\n    info(Code.INFO_MATCHING_LEVELS)\n\n    debug(f\'The maximum size of the analyzed piece: {config.max_piece_size} samples \'\n          f\'or {config.max_piece_size / config.internal_sample_rate:.2f} seconds\')\n\n    reference, final_amplitude_coefficient = normalize_reference(reference, config)\n\n    target_mid, target_side,\\\n        target_mid_loudest_pieces, target_side_loudest_pieces,\\\n        target_match_rms, target_divisions, target_piece_size\\\n        = analyze_levels(target, \'target\', config)\n\n    reference_mid, reference_side,\\\n        reference_mid_loudest_pieces, reference_side_loudest_pieces,\\\n        reference_match_rms, *_\\\n        = analyze_levels(reference, \'reference\', config)\n\n    rms_coefficient, target_mid, target_side = get_rms_c_and_amplify_pair(\n        target_mid, target_side,\n        target_match_rms, reference_match_rms,\n        config.min_value, \'target\'\n    )\n\n    debug(\'Modifying the amplitudes of the extracted loudest TARGET pieces...\')\n    target_mid_loudest_pieces = amplify(target_mid_loudest_pieces, rms_coefficient)\n    target_side_loudest_pieces = amplify(target_side_loudest_pieces, rms_coefficient)\n\n    return target_mid, target_side, final_amplitude_coefficient,\\\n        target_mid_loudest_pieces, target_side_loudest_pieces,\\\n        reference_mid_loudest_pieces, reference_side_loudest_pieces,\\\n        target_divisions, target_piece_size, reference_match_rms\n\n\ndef __match_frequencies(\n        target_mid: np.ndarray,\n        target_side: np.ndarray,\n        target_mid_loudest_pieces: np.ndarray,\n        reference_mid_loudest_pieces: np.ndarray,\n        target_side_loudest_pieces: np.ndarray,\n        reference_side_loudest_pieces: np.ndarray,\n        config: Config\n) -> (np.ndarray, np.ndarray):\n    debug_line()\n    info(Code.INFO_MATCHING_FREQS)\n\n    mid_fir = get_fir(\n        target_mid_loudest_pieces, reference_mid_loudest_pieces,\n        \'mid\',\n        config\n    )\n    side_fir = get_fir(\n        target_side_loudest_pieces, reference_side_loudest_pieces,\n        \'side\',\n        config\n    )\n\n    del target_mid_loudest_pieces, reference_mid_loudest_pieces, \\\n        target_side_loudest_pieces, reference_side_loudest_pieces\n\n    result, result_mid = convolve(target_mid, mid_fir, target_side, side_fir)\n\n    return result, result_mid\n\n\ndef __correct_levels(\n        result: np.ndarray,\n        result_mid: np.ndarray,\n        target_divisions: int,\n        target_piece_size: int,\n        reference_match_rms: float,\n        config: Config\n) -> np.ndarray:\n    debug_line()\n    info(Code.INFO_CORRECTING_LEVELS)\n\n    for step in range(1, config.rms_correction_steps + 1):\n        debug(f\'Applying RMS correction #{step}...\')\n        result_mid_clipped = clip(result_mid)\n\n        _, clipped_rmses, clipped_average_rms = get_average_rms(\n            result_mid_clipped,\n            target_piece_size,\n            target_divisions,\n            \'result\'\n        )\n\n        _, result_mid_clipped_match_rms = get_lpis_and_match_rms(clipped_rmses, clipped_average_rms)\n\n        rms_coefficient, result_mid, result = get_rms_c_and_amplify_pair(\n            result_mid, result,\n            result_mid_clipped_match_rms, reference_match_rms,\n            config.min_value, \'result\'\n        )\n\n    return result\n\n\ndef __finalize(\n    result_no_limiter: np.ndarray,\n    final_amplitude_coefficient: float,\n    need_default: bool,\n    need_no_limiter: bool,\n    need_no_limiter_normalized: bool,\n    config: Config\n) -> (np.ndarray, np.ndarray, np.ndarray):\n    debug_line()\n    info(Code.INFO_FINALIZING)\n\n    result_no_limiter_normalized = None\n    if need_no_limiter_normalized:\n        result_no_limiter_normalized, coefficient = normalize(\n            result_no_limiter,\n            config.threshold,\n            config.min_value,\n            normalize_clipped=True\n        )\n        debug(f\'The amplitude of the normalized RESULT should be adjusted by {to_db(coefficient)}\')\n        if not np.isclose(final_amplitude_coefficient, 1.):\n            debug(f\'And by {to_db(final_amplitude_coefficient)} after applying some brickwall limiter to it\')\n\n    result = None\n    if need_default:\n        result = limit(result_no_limiter, config)\n        result = amplify(result, final_amplitude_coefficient)\n\n    result_no_limiter = result_no_limiter if need_no_limiter else None\n\n    return result, result_no_limiter, result_no_limiter_normalized\n\n\ndef main(\n        target: np.ndarray,\n        reference: np.ndarray,\n        config: Config,\n        need_default: bool = True,\n        need_no_limiter: bool = False,\n        need_no_limiter_normalized: bool = False\n) -> (np.ndarray, np.ndarray, np.ndarray):\n    target_mid, target_side, final_amplitude_coefficient,\\\n        target_mid_loudest_pieces, target_side_loudest_pieces,\\\n        reference_mid_loudest_pieces, reference_side_loudest_pieces,\\\n        target_divisions, target_piece_size, reference_match_rms\\\n        = __match_levels(target, reference, config)\n\n    del target, reference\n\n    result_no_limiter, result_no_limiter_mid = __match_frequencies(\n        target_mid, target_side,\n        target_mid_loudest_pieces, reference_mid_loudest_pieces,\n        target_side_loudest_pieces, reference_side_loudest_pieces,\n        config\n    )\n\n    del target_mid, target_side,\\\n        target_mid_loudest_pieces, reference_mid_loudest_pieces,\\\n        target_side_loudest_pieces, reference_side_loudest_pieces\n\n    result_no_limiter = __correct_levels(\n        result_no_limiter, result_no_limiter_mid,\n        target_divisions, target_piece_size,\n        reference_match_rms,\n        config\n    )\n\n    del result_no_limiter_mid\n\n    result, result_no_limiter, result_no_limiter_normalized = __finalize(\n        result_no_limiter, final_amplitude_coefficient,\n        need_default, need_no_limiter, need_no_limiter_normalized,\n        config\n    )\n\n    return result, result_no_limiter, result_no_limiter_normalized\n'"
matchering/utils.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport os\nimport random\nimport string\nimport math\nfrom datetime import timedelta\n\n\ndef get_temp_folder(results: list) -> str:\n    first_result_file = results[0].file\n    return os.path.dirname(os.path.abspath(first_result_file))\n\n\ndef random_str(size: int = 16) -> str:\n    return \'\'.join(random.choices(string.ascii_lowercase + string.digits, k=size))\n\n\ndef random_file(prefix: str = \'\', extension: str = \'wav\') -> str:\n    prefix = f\'{prefix}-\' if prefix else prefix\n    return f\'{prefix}{random_str()}.{extension}\'\n\n\ndef __to_db_int(value: float) -> float:\n    return 20 * math.log10(value)\n\n\ndef to_db(value: float) -> str:\n    return f\'{__to_db_int(value):.4f} dB\'\n\n\ndef ms_to_samples(value: float, sample_rate: int) -> int:\n    return int(sample_rate * value * 1e-3)\n\n\ndef make_odd(value: int) -> int:\n    return value + 1 if not value & 1 else value\n\n\ndef time_str(length, sample_rate) -> str:\n    return str(timedelta(seconds=length // sample_rate))\n'"
matchering/limiter/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering Hyrax Limiter\n~~~~~~~~~~~~~~~~~~~~~\n\nInternal Matchering brickwall limiter based on the use of time constant and Butterworth filters with sliding Windows.\n\n:copyright: (C) 2016-2020 Sergree\n:license: GPLv3, see LICENSE for more details.\n\n""""""\n\nfrom .hyrax import limit\n'"
matchering/limiter/hyrax.py,14,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nimport math\nfrom scipy import signal\nfrom scipy.ndimage.filters import maximum_filter1d\n\nfrom .. import Config\nfrom ..log import debug\nfrom ..dsp import rectify, flip, max_mix\nfrom ..utils import make_odd, ms_to_samples\n\n\ndef __sliding_window_fast(\n        array: np.ndarray,\n        window_size: int,\n        mode: str = \'attack\'\n) -> np.ndarray:\n    if mode == \'attack\':\n        window_size = make_odd(window_size)\n        return maximum_filter1d(array, size=(2 * window_size - 1))\n    half_window_size = (window_size - 1) // 2\n    array = np.pad(array, (half_window_size, 0))\n    return maximum_filter1d(array, size=window_size)[:-half_window_size]\n\n\ndef __process_attack(\n        array: np.ndarray,\n        config: Config\n) -> (np.ndarray, np.ndarray):\n    attack = ms_to_samples(config.limiter.attack, config.internal_sample_rate)\n\n    slided_input = __sliding_window_fast(array, attack, mode=\'attack\')\n\n    coef = math.exp(config.limiter.attack_filter_coefficient / attack)\n    b = [1 - coef]\n    a = [1, -coef]\n    output = signal.filtfilt(b, a, slided_input)\n\n    return output, slided_input\n\n\ndef __process_release(\n        array: np.ndarray,\n        config: Config\n) -> np.ndarray:\n    hold = ms_to_samples(config.limiter.hold, config.internal_sample_rate)\n\n    slided_input = __sliding_window_fast(array, hold, mode=\'hold\')\n\n    b, a = signal.butter(\n        config.limiter.hold_filter_order,\n        config.limiter.hold_filter_coefficient,\n        fs=config.internal_sample_rate\n    )\n    hold_output = signal.lfilter(b, a, slided_input)\n\n    b, a = signal.butter(\n        config.limiter.release_filter_order,\n        config.limiter.release_filter_coefficient / config.limiter.release,\n        fs=config.internal_sample_rate\n    )\n    release_output = signal.lfilter(b, a, np.maximum(slided_input, hold_output))\n\n    return np.maximum(hold_output, release_output)\n\n\ndef limit(\n        array: np.ndarray,\n        config: Config\n) -> np.ndarray:\n\n    debug(\'The limiter is started. Preparing the gain envelope...\')\n    rectified = rectify(array, config.threshold)\n\n    if np.all(np.isclose(rectified, 1.)):\n        debug(\'The limiter is not needed!\')\n        return array\n\n    gain_hard_clip = flip(1. / rectified)\n    debug(\'Modifying the gain envelope: attack stage...\')\n    gain_attack, gain_hard_clip_slided = __process_attack(np.copy(gain_hard_clip), config)\n\n    debug(\'Modifying the gain envelope: hold / release stage...\')\n    gain_release = __process_release(np.copy(gain_hard_clip_slided), config)\n\n    debug(\'Finalizing the gain envelope...\')\n    gain = flip(max_mix(gain_hard_clip, gain_attack, gain_release))\n\n    return array * gain[:, None]\n\n'"
matchering/log/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering Log\n~~~~~~~~~~~~~~~~~~~~~\n\nInternal Matchering logging module that can be bound to any text stream.\n\n:copyright: (C) 2016-2020 Sergree\n:license: GPLv3, see LICENSE for more details.\n\n""""""\n\nfrom .codes import Code\nfrom .handlers import warning, info, debug, debug_line\nfrom .exceptions import ModuleError\n'"
matchering/log/codes.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nfrom enum import IntEnum\n\n\nclass Code(IntEnum):\n    INFO_UPLOADING = 2001\n    INFO_WAITING = 2002\n    INFO_LOADING = 2003\n    INFO_MATCHING_LEVELS = 2004\n    INFO_MATCHING_FREQS = 2005\n    INFO_CORRECTING_LEVELS = 2006\n    INFO_FINALIZING = 2007\n    INFO_EXPORTING = 2008\n    INFO_MAKING_PREVIEWS = 2009\n    INFO_COMPLETED = 2010\n\n    INFO_TARGET_IS_MONO = 2101\n    INFO_REFERENCE_IS_MONO = 2201\n    INFO_REFERENCE_IS_RESAMPLED = 2202\n    INFO_REFERENCE_IS_LOSSY = 2203\n\n    WARNING_TARGET_IS_CLIPPING = 3001\n    WARNING_TARGET_LIMITER_IS_APPLIED = 3002\n    WARNING_TARGET_IS_RESAMPLED = 3003\n    WARNING_TARGET_IS_LOSSY = 3004\n\n    ERROR_TARGET_LOADING = 4001\n    ERROR_TARGET_LENGTH_IS_EXCEEDED = 4002\n    ERROR_TARGET_LENGTH_IS_TOO_SMALL = 4003\n    ERROR_TARGET_NUM_OF_CHANNELS_IS_EXCEEDED = 4004\n    ERROR_TARGET_EQUALS_REFERENCE = 4005\n\n    ERROR_REFERENCE_LOADING = 4101\n    ERROR_REFERENCE_LENGTH_LENGTH_IS_EXCEEDED = 4102\n    ERROR_REFERENCE_LENGTH_LENGTH_TOO_SMALL = 4103\n    ERROR_REFERENCE_NUM_OF_CHANNELS_IS_EXCEEDED = 4104\n\n    ERROR_UNKNOWN = 4201\n    ERROR_VALIDATION = 4202\n'"
matchering/log/exceptions.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nfrom .explanations import get_explanation_handler\nfrom .codes import Code\n\n\nclass ModuleError(Exception):\n    def __init__(self, code: Code):\n        Exception.__init__(self, get_explanation_handler(show_codes=True)(code))\n'"
matchering/log/explanations.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nfrom .codes import Code\n\n\ndef __default(code: Code) -> str:\n    return __en[code]\n\n\ndef __verbose(code: Code) -> str:\n    return f\'{code}: {__en[code]}\'\n\n\ndef get_explanation_handler(show_codes: bool = False):\n    return __verbose if show_codes else __default\n\n\n__en = {\n    Code.INFO_UPLOADING: \'Uploading files\',\n    Code.INFO_WAITING: \'Queued for processing\',\n    Code.INFO_LOADING: \'Loading and analysis\',\n    Code.INFO_MATCHING_LEVELS: \'Matching levels\',\n    Code.INFO_MATCHING_FREQS: \'Matching frequencies\',\n    Code.INFO_CORRECTING_LEVELS: \'Correcting levels\',\n    Code.INFO_FINALIZING: \'Final processing and saving\',\n    Code.INFO_EXPORTING: \'Exporting various audio formats\',\n    Code.INFO_MAKING_PREVIEWS: \'Making previews\',\n    Code.INFO_COMPLETED: \'The task is completed\',\n\n    Code.INFO_TARGET_IS_MONO: \'The TARGET audio is mono. Converting it to stereo...\',\n    Code.INFO_REFERENCE_IS_MONO: \'The REFERENCE audio is mono. Converting it to stereo...\',\n    Code.INFO_REFERENCE_IS_RESAMPLED: \'The REFERENCE audio was resampled\',\n    Code.INFO_REFERENCE_IS_LOSSY: \'Presumably the REFERENCE audio format is lossy\',\n\n    Code.WARNING_TARGET_IS_CLIPPING: \'Audio clipping is detected in the TARGET file. \'\n                                     \'It is highly recommended to use the non-clipping version\',\n    Code.WARNING_TARGET_LIMITER_IS_APPLIED: \'The applied limiter is detected in the TARGET file. \'\n                                            \'It is highly recommended to use the version without a limiter\',\n    Code.WARNING_TARGET_IS_RESAMPLED: \'The TARGET audio sample rate and internal sample rate were different. \'\n                                      \'The TARGET audio was resampled\',\n    Code.WARNING_TARGET_IS_LOSSY: \'Presumably the TARGET audio format is lossy. \'\n                                  \'It is highly recommended to use lossless audio formats (WAV, FLAC, AIFF)\',\n\n    Code.ERROR_TARGET_LOADING: \'Audio stream error in the TARGET file\',\n    Code.ERROR_TARGET_LENGTH_IS_EXCEEDED: \'Track length is exceeded in the TARGET file\',\n    Code.ERROR_TARGET_LENGTH_IS_TOO_SMALL: \'The track length is too small in the TARGET file\',\n    Code.ERROR_TARGET_NUM_OF_CHANNELS_IS_EXCEEDED: \'The number of channels exceeded in the TARGET file\',\n    Code.ERROR_TARGET_EQUALS_REFERENCE: \'The TARGET and REFERENCE files are the same. \'\n                                        \'They must be different so that Matchering makes sense\',\n\n    Code.ERROR_REFERENCE_LOADING: \'Audio stream error in the REFERENCE file\',\n    Code.ERROR_REFERENCE_LENGTH_LENGTH_IS_EXCEEDED: \'Track length is exceeded in the REFERENCE file\',\n    Code.ERROR_REFERENCE_LENGTH_LENGTH_TOO_SMALL: \'The track length is too small in the REFERENCE file\',\n    Code.ERROR_REFERENCE_NUM_OF_CHANNELS_IS_EXCEEDED: \'The number of channels exceeded in the REFERENCE file\',\n\n    Code.ERROR_UNKNOWN: \'Unknown error\',\n    Code.ERROR_VALIDATION: \'Validation failed! Please let the developers know about this error!\'\n}\n'"
matchering/log/handlers.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nfrom .explanations import get_explanation_handler\n\n\nclass __LogHandlers:\n    @staticmethod\n    def __dummy(*args, **kwargs):\n        pass\n\n    warning_handler = __dummy\n    info_handler = __dummy\n    debug_handler = __dummy\n    explanation_handler = __dummy\n\n    @staticmethod\n    def __check_empty(explicit_handler, default_handler):\n        return explicit_handler if explicit_handler else default_handler\n\n    @classmethod\n    def set_handlers(\n            cls,\n            default_handler=None,\n            warning_handler=None,\n            info_handler=None,\n            debug_handler=None,\n            show_codes=False\n    ):\n        default_handler = cls.__check_empty(default_handler, cls.__dummy)\n        cls.warning_handler = cls.__check_empty(warning_handler, default_handler)\n        cls.info_handler = cls.__check_empty(info_handler, default_handler)\n        cls.debug_handler = cls.__check_empty(debug_handler, default_handler)\n        cls.explanation_handler = get_explanation_handler(show_codes=show_codes)\n\n\ndef set_handlers(\n        default_handler=None,\n        warning_handler=None,\n        info_handler=None,\n        debug_handler=None,\n        show_codes=False\n):\n    __LogHandlers.set_handlers(\n        default_handler=default_handler,\n        warning_handler=warning_handler,\n        info_handler=info_handler,\n        debug_handler=debug_handler,\n        show_codes=show_codes\n    )\n\n\ndef warning(*args, **kwargs):\n    __LogHandlers.warning_handler(__LogHandlers.explanation_handler(*args, **kwargs))\n\n\ndef info(*args, **kwargs):\n    __LogHandlers.info_handler(__LogHandlers.explanation_handler(*args, **kwargs))\n\n\ndef debug(*args, **kwargs):\n    __LogHandlers.debug_handler(*args, **kwargs)\n\n\ndef debug_line():\n    debug(\'-\' * 40)\n'"
matchering/stage_helpers/__init__.py,0,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering Stages\n~~~~~~~~~~~~~~~~~~~~~\n\nInternal Matchering processing stage helpers.\n\n:copyright: (C) 2016-2020 Sergree\n:license: GPLv3, see LICENSE for more details.\n\n""""""\n\nfrom .match_levels import normalize_reference, analyze_levels, get_average_rms, \\\n    get_lpis_and_match_rms, get_rms_c_and_amplify_pair\nfrom .match_frequencies import get_fir, convolve\n'"
matchering/stage_helpers/match_frequencies.py,19,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\nfrom time import time\nfrom scipy import signal, interpolate\n\nfrom ..log import debug\nfrom .. import Config\nfrom ..dsp import ms_to_lr, smooth_lowess\n\n\ndef __average_fft(\n        loudest_pieces: np.ndarray,\n        sample_rate: int,\n        fft_size: int\n) -> np.ndarray:\n    *_, specs = signal.stft(\n        loudest_pieces,\n        sample_rate,\n        window=\'boxcar\',\n        nperseg=fft_size,\n        noverlap=0,\n        boundary=None,\n        padded=False\n    )\n    return np.abs(specs).mean((0, 2))\n\n\ndef __smooth_exponentially(\n        matching_fft: np.ndarray,\n        config: Config\n) -> np.ndarray:\n    grid_linear = config.internal_sample_rate * 0.5 * np.linspace(\n        0,\n        1,\n        config.fft_size // 2 + 1\n    )\n\n    grid_logarithmic = config.internal_sample_rate * 0.5 * np.logspace(\n        np.log10(4 / config.fft_size),\n        0,\n        (config.fft_size // 2) * config.lin_log_oversampling + 1\n    )\n\n    interpolator = interpolate.interp1d(grid_linear, matching_fft, \'cubic\')\n    matching_fft_log = interpolator(grid_logarithmic)\n\n    matching_fft_log_filtered = smooth_lowess(\n        matching_fft_log,\n        config.lowess_frac,\n        config.lowess_it,\n        config.lowess_delta\n    )\n\n    interpolator = interpolate.interp1d(grid_logarithmic, matching_fft_log_filtered, \'cubic\', fill_value=\'extrapolate\')\n    matching_fft_filtered = interpolator(grid_linear)\n\n    matching_fft_filtered[0] = 0\n    matching_fft_filtered[1] = matching_fft[1]\n\n    return matching_fft_filtered\n\n\ndef get_fir(\n        target_loudest_pieces: np.ndarray,\n        reference_loudest_pieces: np.ndarray,\n        name: str,\n        config: Config\n) -> np.ndarray:\n    debug(f\'Calculating the {name} FIR for the matching EQ...\')\n\n    target_average_fft = __average_fft(target_loudest_pieces, config.internal_sample_rate, config.fft_size)\n    reference_average_fft = __average_fft(reference_loudest_pieces, config.internal_sample_rate, config.fft_size)\n\n    np.maximum(config.min_value, target_average_fft, out=target_average_fft)\n    matching_fft = reference_average_fft / target_average_fft\n\n    matching_fft_filtered = __smooth_exponentially(matching_fft, config)\n\n    fir = np.fft.irfft(matching_fft_filtered)\n    fir = np.fft.ifftshift(fir) * signal.windows.hann(len(fir))\n\n    return fir\n\n\ndef convolve(\n        target_mid: np.ndarray,\n        mid_fir: np.ndarray,\n        target_side: np.ndarray,\n        side_fir: np.ndarray\n) -> (np.ndarray, np.ndarray):\n    debug(\'Convolving the TARGET audio with calculated FIRs...\')\n    timer = time()\n    result_mid = signal.fftconvolve(target_mid, mid_fir, \'same\')\n    result_side = signal.fftconvolve(target_side, side_fir, \'same\')\n    debug(f\'The convolution is done in {time() - timer:.2f} seconds\')\n\n    debug(\'Converting MS to LR...\')\n    result = ms_to_lr(result_mid, result_side)\n\n    return result, result_mid\n'"
matchering/stage_helpers/match_levels.py,18,"b'# -*- coding: utf-8 -*-\n\n""""""\nMatchering - Audio Matching and Mastering Python Library\nCopyright (C) 2016-2020 Sergree\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see <https://www.gnu.org/licenses/>.\n""""""\n\nimport numpy as np\n\nfrom ..log import debug\nfrom .. import Config\nfrom ..utils import to_db\nfrom ..dsp import lr_to_ms, size, unfold, batch_rms, rms, amplify, normalize\n\n\ndef normalize_reference(\n        reference: np.ndarray,\n        config: Config\n) -> (np.ndarray, float):\n    debug(\'Normalizing the REFERENCE...\')\n\n    reference, final_amplitude_coefficient = normalize(\n        reference,\n        config.threshold,\n        config.min_value,\n        normalize_clipped=False\n    )\n\n    if np.isclose(final_amplitude_coefficient, 1.):\n        debug(\'The REFERENCE was not changed. There is no final amplitude coefficient\')\n    else:\n        debug(f\'The REFERENCE was normalized. \'\n              f\'Final amplitude coefficient for the TARGET audio is: {to_db(final_amplitude_coefficient)}\')\n\n    return reference, final_amplitude_coefficient\n\n\ndef __calculate_piece_sizes(\n        array: np.ndarray,\n        max_piece_size: int,\n        name: str,\n        sample_rate: int\n) -> (int, int, int):\n    array_size = size(array)\n    divisions = int(array_size / max_piece_size) + 1\n    debug(f\'The {name} will be didived into {divisions} pieces\')\n\n    piece_size = int(array_size / divisions)\n    debug(f\'One piece of the {name} has a length of {piece_size} samples or {piece_size / sample_rate:.2f} seconds\')\n\n    return array_size, divisions, piece_size\n\n\ndef get_lpis_and_match_rms(\n        rmses: np.ndarray,\n        average_rms: float\n) -> (np.ndarray, float):\n    loudest_piece_idxs = np.where(rmses >= average_rms)\n\n    loudest_rmses = rmses[loudest_piece_idxs]\n    match_rms = rms(loudest_rmses)\n    debug(f\'The current average RMS value in the loudest pieces is {to_db(match_rms)}\')\n\n    return loudest_piece_idxs, match_rms\n\n\ndef __extract_loudest_pieces(\n        rmses: np.ndarray,\n        average_rms: float,\n        unfolded_mid: np.ndarray,\n        unfolded_side: np.ndarray,\n        name: str\n) -> (np.ndarray, np.ndarray, float):\n    debug(f\'Extracting the loudest pieces of the {name} audio \'\n          f\'with the RMS value more than average {to_db(average_rms)}...\')\n    loudest_piece_idxs, match_rms = get_lpis_and_match_rms(rmses, average_rms)\n\n    mid_loudest_pieces = unfolded_mid[loudest_piece_idxs]\n    side_loudest_pieces = unfolded_side[loudest_piece_idxs]\n\n    return mid_loudest_pieces, side_loudest_pieces, match_rms\n\n\ndef get_average_rms(\n        array: np.ndarray,\n        piece_size: int,\n        divisions: int,\n        name: str\n) -> (np.ndarray, np.ndarray, float):\n    name = name.upper()\n    unfolded_array = unfold(array, piece_size, divisions)\n\n    debug(f\'Calculating RMSes of the {name} pieces...\')\n    rmses = batch_rms(unfolded_array)\n    average_rms = rms(rmses)\n\n    return unfolded_array, rmses, average_rms\n\n\ndef __calculate_rms_coefficient(\n        array_match_rms: float,\n        reference_match_rms: float,\n        epsilon: float\n) -> float:\n    rms_coefficient = reference_match_rms / max(epsilon, array_match_rms)\n    debug(f\'The RMS coefficient is: {to_db(rms_coefficient)}\')\n    return rms_coefficient\n\n\ndef get_rms_c_and_amplify_pair(\n        array_main: np.ndarray,\n        array_additional: np.ndarray,\n        array_main_match_rms: float,\n        reference_match_rms: float,\n        epsilon: float,\n        name: str\n) -> (float, np.ndarray, np.ndarray):\n    name = name.upper()\n    rms_coefficient = __calculate_rms_coefficient(array_main_match_rms, reference_match_rms, epsilon)\n\n    debug(f\'Modifying the amplitudes of the {name} audio...\')\n    array_main = amplify(array_main, rms_coefficient)\n    array_additional = amplify(array_additional, rms_coefficient)\n\n    return rms_coefficient, array_main, array_additional\n\n\ndef analyze_levels(\n        array: np.ndarray,\n        name: str,\n        config: Config\n) -> (np.ndarray, np.ndarray, np.ndarray, np.ndarray, float, float, float):\n    name = name.upper()\n    debug(f\'Calculating mid and side channels of the {name}...\')\n    mid, side = lr_to_ms(array)\n    del array\n\n    array_size, divisions, piece_size = __calculate_piece_sizes(\n        mid,\n        config.max_piece_size,\n        name,\n        config.internal_sample_rate\n    )\n\n    unfolded_mid, rmses, average_rms = get_average_rms(mid, piece_size, divisions, name)\n    unfolded_side = unfold(side, piece_size, divisions)\n\n    mid_loudest_pieces, side_loudest_pieces, match_rms = __extract_loudest_pieces(\n        rmses,\n        average_rms,\n        unfolded_mid,\n        unfolded_side,\n        name\n    )\n\n    return mid, side, mid_loudest_pieces, side_loudest_pieces, match_rms, divisions, piece_size\n'"
