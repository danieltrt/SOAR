file_path,api_count,code
automated_test.py,52,"b'import pytest\n\nimport cc3d\nimport numpy as np\n\nTEST_TYPES = [\n  np.int8, np.int16, np.int32, np.int64,\n  np.uint8, np.uint16, np.uint32, np.uint64,\n]\n\nOUT_TYPES = [ np.uint16, np.uint32, np.uint64 ]\n\ndef gt_c2f(gt):\n  f_gt = np.copy(gt)\n  mx = np.max(gt) + 1\n  f_gt[ f_gt == 2 ] = mx\n  f_gt[ f_gt == 3 ] = 2\n  f_gt[ f_gt == mx ] = 3\n  return f_gt\n\n@pytest.mark.parametrize(""dtype"", TEST_TYPES)\n@pytest.mark.parametrize(""out_dtype"", OUT_TYPES)\ndef test_2d_square(out_dtype, dtype):\n  def test(order, ground_truth):\n    input_labels = np.zeros( (16,16), dtype=dtype, order=order )\n    input_labels[:8,:8] = 8\n    input_labels[8:,:8] = 9\n    input_labels[:8,8:] = 10\n    input_labels[8:,8:] = 11\n\n    output_labels = cc3d.connected_components(input_labels, out_dtype=out_dtype).astype(dtype)\n    \n    print(order)\n    print(output_labels)\n\n    assert np.all(output_labels == ground_truth.astype(dtype))\n\n  ground_truth = np.array([\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4],\n  ])\n\n  test(\'C\', ground_truth)\n  test(\'F\', ground_truth.T)\n\n@pytest.mark.parametrize(""dtype"", TEST_TYPES)\n@pytest.mark.parametrize(""out_dtype"", OUT_TYPES)\ndef test_2d_rectangle(out_dtype, dtype):\n  def test(order, ground_truth):\n    input_labels = np.zeros( (16,13,1), dtype=dtype, order=order )\n    input_labels[:8,:8,:] = 8\n    input_labels[8:,:8,:] = 9\n    input_labels[:8,8:,:] = 10\n    input_labels[8:,8:,:] = 11\n\n    output_labels = cc3d.connected_components(input_labels, out_dtype=out_dtype).astype(dtype)\n    print(output_labels.shape)\n    output_labels = output_labels[:,:,0]\n\n    print(output_labels)\n\n    assert np.all(output_labels == ground_truth.astype(dtype))\n\n  ground_truth = np.array([\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4],\n  ])\n\n  test(\'C\', ground_truth)\n  test(\'F\', gt_c2f(ground_truth))\n\n@pytest.mark.parametrize(""dtype"", TEST_TYPES)\ndef test_2d_cross(dtype):\n  def test(order, ground_truth):\n    input_labels = np.zeros( (17,17), dtype=dtype, order=order)\n    input_labels[:] = 1\n    input_labels[:,8] = 0\n    input_labels[8,:] = 0\n\n    output_labels = cc3d.connected_components(input_labels).astype(dtype)\n    print(output_labels)\n\n    assert np.all(output_labels == ground_truth)\n\n    input_labels[9:,9:] = 2\n    output_labels = cc3d.connected_components(input_labels).astype(dtype)\n    output_labels = output_labels[:,:]\n    assert np.all(output_labels == ground_truth)\n\n  ground_truth = np.array([\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 2, 2, 2],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n    [3, 3, 3, 3, 3, 3, 3, 3, 0, 4, 4, 4, 4, 4, 4, 4, 4],\n  ], dtype=np.uint32)\n\n  test(\'C\', ground_truth)\n  test(\'F\', gt_c2f(ground_truth))\n\n\ndef test_2d_diagonals():\n  input_labels = np.array([\n    [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],\n  ], dtype=np.uint32)\n\n  ground_truth = np.array([\n    [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 0, 1, 0, 0, 3, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n    [0, 2, 0, 0, 1, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0],\n    [2, 0, 2, 0, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 4, 4, 0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 6, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0],\n    [0, 5, 0, 0, 0, 6, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0],\n  ], dtype=np.uint32)\n\n  output_labels = cc3d.connected_components(input_labels)\n  print(output_labels)\n  assert np.all(output_labels == ground_truth)\n\ndef test_2d_cross_with_intruder():\n  def test(order, ground_truth):\n    input_labels = np.zeros( (5,5), dtype=np.uint8, order=order)\n    input_labels[:] = 1\n    input_labels[:,2] = 0\n    input_labels[2,:] = 0\n    input_labels[3:,3:] = 2\n    input_labels[3,3] = 1\n\n    output_labels = cc3d.connected_components(input_labels).astype(np.uint8)\n    assert np.all(output_labels == ground_truth)\n\n  ground_truth = np.array([\n    [1, 1, 0, 2, 2],\n    [1, 1, 0, 2, 2],\n    [0, 0, 0, 0, 0],\n    [3, 3, 0, 4, 5],\n    [3, 3, 0, 5, 5],\n  ], dtype=np.uint8)\n\n  test(""C"", ground_truth)\n  test(""F"", gt_c2f(ground_truth))\n\n@pytest.mark.parametrize(""order"", (\'C\', \'F\'))\ndef test_3d_all_different(order):\n  input_labels = np.arange(0, 100 * 99 * 98).astype(np.uint32)\n  input_labels = input_labels.reshape((100,99,98), order=order)\n\n  output_labels = cc3d.connected_components(input_labels)\n\n  assert np.unique(output_labels).shape[0] == 100*99*98\n  assert output_labels.shape == (100, 99, 98)\n\ndef test_3d_cross():\n  def test(order, ground_truth):\n    print(order)\n    for dtype in TEST_TYPES:\n      print(dtype)\n      input_labels = np.zeros( (7,7,7), dtype=dtype, order=order )\n      input_labels[:] = 1\n      input_labels[:,3,:] = 0\n      input_labels[:,:,3] = 0\n\n      output_labels = cc3d.connected_components(input_labels).astype(dtype)\n      print(output_labels)\n      assert np.all(output_labels == ground_truth)\n\n      input_labels[:,4:,4:] = 2\n      output_labels = cc3d.connected_components(input_labels).astype(dtype)\n      assert np.all(output_labels == ground_truth)\n\n  ground_truth = np.array([\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4]]], dtype=np.uint32)\n\n  test(\'C\', ground_truth)\n  test(\'F\', gt_c2f(ground_truth))\n\ndef test_3d_cross_asymmetrical():\n  def test(order, ground_truth):\n    print(order)\n    for dtype in TEST_TYPES:\n      print(dtype)\n      input_labels = np.zeros( (7,7,8), dtype=dtype, order=order )\n      input_labels[:] = 1\n      input_labels[:,3,:] = 0\n      input_labels[:,:,3] = 0\n\n      output_labels = cc3d.connected_components(input_labels).astype(dtype)\n      print(output_labels)\n      assert np.all(output_labels == ground_truth)\n\n      input_labels[:,4:,4:] = 2\n      output_labels = cc3d.connected_components(input_labels).astype(dtype)\n      assert np.all(output_labels == ground_truth)\n\n  ground_truth = np.array([\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n     [[1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [1, 1, 1, 0, 2, 2, 2, 2],\n      [0, 0, 0, 0, 0, 0, 0, 0],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4],\n      [3, 3, 3, 0, 4, 4, 4, 4]],\n\n    ], dtype=np.uint32)\n\n  test(\'C\', ground_truth)\n  test(\'F\', gt_c2f(ground_truth))\n\n@pytest.mark.skipif(platform=\'win32\')\n@pytest.mark.xfail(raises=MemoryError, reason=""Some build tools don\'t have enough memory for this."")\ndef test_512_cube_no_segfault_no_jitsu(): \n  input_labels = np.arange(0, 512 ** 3).astype(np.uint64).reshape((512,512,512))\n  output_labels = cc3d.connected_components(input_labels)\n\ndef test_max_labels_nonsensical():\n  input_labels = np.arange(0, 64 ** 3).astype(np.uint64).reshape((64,64,64))\n  real_labels = cc3d.connected_components(input_labels, max_labels=64*64*64)\n  zero_labels = cc3d.connected_components(input_labels, max_labels=0)\n  negative_labels = cc3d.connected_components(input_labels, max_labels=-50)\n\n  assert np.all(real_labels == zero_labels)\n  assert np.all(real_labels == negative_labels)\n\n@pytest.mark.parametrize(""out_dtype"", OUT_TYPES)\ndef test_compare_scipy_26(out_dtype):\n  import scipy.ndimage.measurements\n\n  sx, sy, sz = 128, 128, 128\n  labels = np.random.randint(0,2, (sx,sy,sz), dtype=np.bool)\n\n  structure = [\n    [[1,1,1], [1,1,1], [1,1,1]],\n    [[1,1,1], [1,1,1], [1,1,1]],\n    [[1,1,1], [1,1,1], [1,1,1]]\n  ]\n\n  cc3d_labels = cc3d.connected_components(labels, connectivity=26, out_dtype=out_dtype)\n  scipy_labels, wow = scipy.ndimage.measurements.label(labels, structure=structure)\n\n  print(cc3d_labels)\n  print(scipy_labels)\n\n  assert np.all(cc3d_labels == scipy_labels)\n\ndef test_compare_scipy_18():\n  import scipy.ndimage.measurements\n\n  sx, sy, sz = 256, 256, 256\n  labels = np.random.randint(0,2, (sx,sy,sz), dtype=np.bool)\n\n  structure = [\n    [[0,1,0], [1,1,1], [0,1,0]],\n    [[1,1,1], [1,1,1], [1,1,1]],\n    [[0,1,0], [1,1,1], [0,1,0]]\n  ]\n\n  cc3d_labels = cc3d.connected_components(labels, connectivity=18)\n  scipy_labels, wow = scipy.ndimage.measurements.label(labels, structure=structure)\n\n  print(cc3d_labels)\n  print(scipy_labels)\n\n  assert np.all(cc3d_labels == scipy_labels)\n\n\ndef test_compare_scipy_6():\n  import scipy.ndimage.measurements\n\n  sx, sy, sz = 256, 256, 256\n  labels = np.random.randint(0,2, (sx,sy,sz), dtype=np.bool)\n\n  cc3d_labels = cc3d.connected_components(labels, connectivity=6)\n  scipy_labels, wow = scipy.ndimage.measurements.label(labels)\n\n  print(cc3d_labels)\n  print(scipy_labels)\n\n  assert np.all(cc3d_labels == scipy_labels)\n\n\n# def test_sixty_four_bit():\n#   input_labels = np.ones((1626,1626,1626), dtype=np.uint8)\n#   cc3d.connected_components(input_labels, max_labels=0)  \n\ndef test_region_graph_26():\n  labels = np.zeros( (10, 10, 10), dtype=np.uint32 )\n\n  labels[5,5,5] = 1\n  labels[6,6,6] = 2\n  labels[4,4,6] = 3\n  labels[4,6,6] = 4\n  labels[6,4,6] = 5\n\n  labels[4,4,4] = 6\n  labels[4,6,4] = 7\n  labels[6,4,4] = 8\n  labels[6,6,4] = 9\n\n  # not connected to anything else\n  labels[1,:,:] = 10\n\n  res = cc3d.region_graph(labels, connectivity=26)\n  assert res == set([ (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9) ])\n\n  res = cc3d.region_graph(labels, connectivity=18)\n  assert res == set()\n\n  res = cc3d.region_graph(labels, connectivity=6)\n  assert res == set()\n\ndef test_region_graph_18():\n  labels = np.zeros( (10, 10, 10), dtype=np.uint32 )\n\n  labels[5,5,5] = 1\n  labels[5,6,6] = 2\n  labels[5,4,6] = 3\n  labels[6,5,6] = 4\n  labels[4,5,6] = 5\n\n  labels[5,4,4] = 6\n  labels[5,6,4] = 7\n  labels[6,5,4] = 8\n  labels[4,5,4] = 9\n\n  # not connected to anything else\n  labels[1,:,:] = 10\n\n  res = cc3d.region_graph(labels, connectivity=26)\n  assert res == set([ \n    (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), \n    (2,4), (2,5), (3,4), (3,5),\n    (6,8), (6,9), (7,8), (7,9),\n  ])\n\n  res = cc3d.region_graph(labels, connectivity=18)\n  assert res == set([ \n    (1,2), (1,3), (1,4), (1,5), (1,6), (1,7), (1,8), (1,9), \n    (2,4), (2,5), (3,4), (3,5),\n    (6,8), (6,9), (7,8), (7,9),\n  ])\n\n  res = cc3d.region_graph(labels, connectivity=6)\n  assert res == set()\n\n\ndef test_region_graph_6():\n  labels = np.zeros( (10, 10, 10), dtype=np.uint32 )\n\n  labels[5,5,5] = 1\n\n  labels[5,5,6] = 2\n  labels[5,5,4] = 3\n\n  labels[4,5,5] = 4\n  labels[6,5,5] = 5\n\n  labels[5,4,5] = 6\n  labels[5,6,5] = 7\n\n  # not connected to anything else\n  labels[1,:,:] = 10\n\n  res = cc3d.region_graph(labels, connectivity=26)\n  assert res == set([ \n    (1,2), (1,3), (1,4), (1,5), (1,6), (1,7),\n    (2,4), (2,5), (2,6), (2,7),\n    (3,4), (3,5), (3,6), (3,7),\n    (4,6), (4,7),\n    (5,6), (5,7)\n  ])\n\n  res = cc3d.region_graph(labels, connectivity=18)\n  assert res == set([ \n    (1,2), (1,3), (1,4), (1,5), (1,6), (1,7),\n    (2,4), (2,5), (2,6), (2,7),\n    (3,4), (3,5), (3,6), (3,7),\n    (4,6), (4,7),\n    (5,6), (5,7)\n  ])\n\n  res = cc3d.region_graph(labels, connectivity=6)\n  assert res == set([\n    (1,2), (1,3), (1,4), (1,5), (1,6), (1,7)\n  ])\n'"
perf.py,3,"b'import cc3d\nfrom tqdm import tqdm\nimport scipy.ndimage.measurements\nimport numpy as np\n\nimport fastremap\n\ndef cc3d_test(labels):\n  labels, remap = fastremap.renumber(labels)\n  res = cc3d.connected_components(labels)\n  N = np.max(labels)\n  for segid in tqdm(range(1, N+1)):\n    extracted = (res == segid)\n\ndef ndimage_test(labels):\n  s = [\n    [[1,1,1], [1,1,1], [1,1,1]],\n    [[1,1,1], [1,1,1], [1,1,1]],\n    [[1,1,1], [1,1,1], [1,1,1]]\n  ]\n\n  uniques = np.unique(labels)[1:]\n  for segid in tqdm(uniques):\n    extracted = (labels == segid)\n    res, N = scipy.ndimage.measurements.label(extracted, structure=s)\n    for ccid in tqdm(range(1,N+1)):\n      extracted = (res == ccid)\n\n\nlabels = np.random.randint(0,100, (512,512,512), dtype=np.uint8)\n\nndimage_test(labels)\n# cc3d_test(labels)'"
setup.py,1,"b'import os\nimport setuptools\nimport sys\n\njoin = os.path.join\n\n# NOTE: If cc3d.cpp does not exist:\n# cython -3 --fast-fail -v --cplus cc3d.pyx\n\nimport numpy as np\n\nextra_compile_args = [\n  \'-std=c++11\', \'-O3\', \'-ffast-math\'\n]\nif sys.platform == \'darwin\':\n  extra_compile_args += [ \'-stdlib=libc++\', \'-mmacosx-version-min=10.9\' ]\n\nsetuptools.setup(\n  setup_requires=[\'pbr\', \'numpy\'],\n  install_requires=[\'numpy\'],\n  extras_require={\n    \':python_version == ""2.7""\': [\'futures\'],\n    \':python_version == ""2.6""\': [\'futures\'],\n  },\n  ext_modules=[\n    setuptools.Extension(\n      \'cc3d\',\n      sources=[ \'cc3d.cpp\' ],\n      language=\'c++\',\n      include_dirs=[ np.get_include() ],\n      extra_compile_args=extra_compile_args,\n    )\n  ],\n  pbr=True)\n\n\n\n\n\n'"
manual_testing/test.py,8,"b'import cc3d\nimport numpy as np\nimport scipy.ndimage\n\nfrom cloudvolume.lib import save_images\nfrom cloudvolume import CloudVolume, view\nimport time\n\nfrom PIL import Image\n\ndef twod():\n  img = Image.open(\'test2d.png\')\n  return np.array(img)[:,:,0].T\n\ndef threed():\n  labels = np.zeros( (480, 480, 3), dtype=np.uint8)\n  tmp = Image.open(\'test3d-1.png\')\n  labels[:,:,0] = np.array(tmp)[:,:,0].T\n  tmp = Image.open(\'test3d-2.png\')\n  labels[:,:,1] = np.array(tmp)[:,:,0].T\n  tmp = Image.open(\'test3d-3.png\')\n  labels[:,:,2] = np.array(tmp)[:,:,0].T\n  return labels\n\n\nlabels = twod()\n# labels = threed()\n\nprint(np.max(labels))\nlabels = np.asfortranarray(labels)\n\nstart = time.time()\n# labels = scipy.ndimage.measurements.label(labels)[0]\nlabels = cc3d.connected_components(labels)\nprint(time.time() - start, ""sec"")\n\nprint(np.unique(labels).shape)\n\nview(labels, segmentation=True)\n\n'"
