file_path,api_count,code
python/automated_test.py,93,"b'import pytest\n\nimport edt\nimport numpy as np\nfrom scipy import ndimage\n\nINTEGER_TYPES = [\n  np.uint8, np.uint16, np.uint32, np.uint64,\n]\n\nTYPES_NO_BOOL = INTEGER_TYPES + [ np.float32 ]\n\nTYPES = TYPES_NO_BOOL + [ np.bool ]\n\ndef test_one_d_simple():\n  for parallel in (1,2):\n    for dtype in TYPES:\n      print(dtype)\n      labels = np.array([ 0 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)\n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == labels)\n\n      labels = np.array([ 1 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)\n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == np.array([ np.inf ]))\n\n      labels = np.array([ 0, 1 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)\n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == labels)\n\n      labels = np.array([ 1, 0 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)\n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == labels)\n\n      labels = np.array([ 0, 1, 0 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)  \n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == labels)  \n\n      labels = np.array([ 0, 1, 1, 0 ], dtype=dtype)\n      result = edt.edt(labels, black_border=True, parallel=parallel)\n      assert np.all(result == labels)  \n\n      result = edt.edt(labels, black_border=False, parallel=parallel)\n      assert np.all(result == labels)  \n\ndef test_one_d_black_border():\n  def cmp(labels, ans, types=TYPES, anisotropy=1.0):\n    for dtype in types:\n      print(dtype)\n      labels = np.array(labels, dtype=dtype)\n      ans = np.array(ans, dtype=np.float32)\n      result = edt.edtsq(labels, anisotropy=anisotropy, black_border=True)\n      assert np.all(result == ans)  \n\n  cmp([], [])\n\n  cmp([1], [1])\n\n  cmp([5], [1])\n\n  cmp(\n    [ 0, 1, 1, 1, 0 ],\n    [ 0, 1, 4, 1, 0 ]\n  )\n\n  cmp(\n    [ 1, 1, 1, 1 ],\n    [ 1, 4, 4, 1 ]\n  )\n\n  cmp(\n    [ 1, 1, 1, 1 ],\n    [ 4, 16, 16, 4 ],\n    anisotropy=2.0\n  )\n\n  cmp(\n    [ 1, 1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 1, 1, 1, 1, 3 ],\n    [ 1, 4, 9, 4, 1, 0, 1, 4, 9, 4, 1, 1, 4, 4, 1, 1 ],\n    types=TYPES_NO_BOOL,\n  )\n\ndef test_one_d():\n  def cmp(labels, ans, types=TYPES, anisotropy=1.0):\n    for dtype in types:\n      print(dtype)\n      labels = np.array(labels, dtype=dtype)\n      ans = np.array(ans, dtype=np.float32)\n      result = edt.edtsq(labels, anisotropy=anisotropy, black_border=False)\n      assert np.all(result == ans)  \n\n  inf = np.inf\n\n  cmp([], [])\n\n  cmp([1], [inf])\n\n  cmp([5], [inf])\n\n  cmp(\n    [ 0, 1, 1, 1, 0 ],\n    [ 0, 1, 4, 1, 0 ]\n  )\n\n  cmp(\n    [ 0, 1, 1, 1,  1 ],\n    [ 0, 1, 4, 9, 16 ]\n  )\n\n  cmp(\n    [  1, 1, 1, 1, 0 ],\n    [ 16, 9, 4, 1, 0 ]\n  )\n\n  cmp(\n    [ 1, 1, 1, 1 ],\n    [ inf, inf, inf, inf ]\n  )\n\n  cmp(\n    [ 1, 1, 1, 1 ],\n    [ inf, inf, inf, inf ],\n    anisotropy=2.0\n  )\n\n  cmp(\n    [  1,  1, 1, 1, 1, 0, 2, 2, 2, 2, 2, 1, 1, 1, 1, 3 ],\n    [ 25, 16, 9, 4, 1, 0, 1, 4, 9, 4, 1, 1, 4, 4, 1, 1 ],\n    types=TYPES_NO_BOOL,\n  )\n\ndef test_1d_scipy_comparison():\n  for _ in range(20):\n    randos = np.random.randint(0, 2, size=(100), dtype=np.uint32)\n    labels = np.zeros( (randos.shape[0] + 2,), dtype=np.uint32)\n    # Scipy requires zero borders\n    labels[1:-1] = randos\n\n    print(""INPUT"")\n    print(labels)\n\n    print(""MLAEDT"")\n    mlaedt_result_bb = edt.edt(labels, black_border=True)\n    mlaedt_result = edt.edt(labels, black_border=True)\n    print(mlaedt_result)\n\n    print(""SCIPY"")\n    scipy_result = ndimage.distance_transform_edt(labels)\n    print(scipy_result)\n\n    assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n    assert np.all( np.abs(scipy_result - mlaedt_result_bb) < 0.000001 )\n\ndef test_1d_scipy_comparison_no_border():\n  for _ in range(20):\n    randos = np.random.randint(0, 2, size=(100), dtype=np.uint32)\n    labels = np.zeros( (randos.shape[0] + 2,), dtype=np.uint32)\n\n    print(""INPUT"")\n    print(labels)\n\n    print(""MLAEDT"")\n    mlaedt_result = edt.edt(labels, black_border=False)\n    print(mlaedt_result)\n\n    print(""SCIPY"")\n    scipy_result = ndimage.distance_transform_edt(labels)\n    print(scipy_result)\n\n    assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n\ndef test_two_d_ident_no_border():  \n  def cmp(labels, ans, types=TYPES, anisotropy=(1.0, 1.0)):\n    for dtype in types:\n      print(dtype)\n      labels = np.array(labels, dtype=dtype)\n      ans = np.array(ans, dtype=np.float32)\n      result = edt.edtsq(labels, anisotropy=anisotropy, black_border=False)\n      assert np.all(result == ans)  \n\n  I = np.inf\n\n  cmp([[]], [[]])\n  cmp([[0]], [[0]])\n  cmp([[1]], [[I]])\n  cmp([[1, 0], [0, 1]], [[1, 0], [0, 1]])\n\n  cmp([[1, 1], [1, 1]], [[I, I], [I, I]])\n\n  cmp(\n    [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], \n    [[I, I, I, I, I], [I, I, I, I, I]]\n  )\n\n\ndef test_two_d_ident_black_border():  \n  def cmp(labels, ans, types=TYPES, anisotropy=(1.0, 1.0)):\n    for dtype in types:\n      print(dtype)\n      labels = np.array(labels, dtype=dtype)\n      ans = np.array(ans, dtype=np.float32)\n      result = edt.edtsq(labels, anisotropy=anisotropy, black_border=True)\n      assert np.all(result == ans)  \n\n  cmp([[]], [[]])\n  cmp([[0]], [[0]])\n  cmp([[1]], [[1]])\n  cmp([[1, 1], [1, 1]], [[1, 1], [1, 1]])\n  cmp([[1, 0], [0, 1]], [[1, 0], [0, 1]])\n  \n  cmp(\n    [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], \n    [[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]]\n  )\n\ndef test_two_d():  \n  def cmp(labels, ans, types=TYPES, anisotropy=(1.0, 1.0)):\n    for parallel in (1,2):\n      for dtype in types:\n        print(dtype)\n        labels = np.array(labels, dtype=dtype)\n        ans = np.array(ans, dtype=np.float32)\n        result = edt.edtsq(\n          labels, anisotropy=anisotropy, \n          black_border=True, parallel=parallel\n        )\n        print(result)\n        assert np.all(result == ans)  \n\n  cmp(\n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ], \n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 1 ], \n      [ 1, 4, 9, 4, 1 ], \n      [ 1, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ]\n  )\n\n  cmp(\n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ], \n    [\n      [  25,  25,  25,  25,  25 ], \n      [  36, 100, 100, 100,  36 ], \n      [  36, 144, 225, 144,  36 ], \n      [  36, 100, 100, 100,  36 ], \n      [  25,  25,  25,  25,  25 ], \n    ],\n    anisotropy=(5.0, 6.0)\n  )\n\n  cmp(\n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 0, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ], \n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 2, 1, 2, 1 ], \n      [ 1, 1, 0, 1, 1 ], \n      [ 1, 2, 1, 2, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ]\n  )\n\n  cmp(\n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 2, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ], \n    [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 2, 1, 2, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 2, 1, 2, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ],\n    types=TYPES_NO_BOOL\n  )\n  \n  cmp(\n    [\n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 2, 2, 2, 2, 2, 2 ], \n      [ 2, 2, 2, 2, 2, 2 ], \n      [ 2, 2, 2, 2, 2, 2 ], \n    ], \n    [\n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ],\n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ], \n    ],\n    types=TYPES_NO_BOOL\n  )\n\n  labels = np.ones( (6, 5), dtype=np.uint32)\n  labels[3:,:] = 2 # rows 3-6 = 2\n\n  cmp(labels, [\n      [ 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1 ],\n      [ 1, 1, 1, 1, 1 ],\n      [ 1, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1 ], \n    ],\n    types=TYPES_NO_BOOL\n  )\n\n  labels = np.ones( (5, 6), dtype=np.uint32)\n  labels[3:,:] = 2 # rows 4-5 = 2\n\n  cmp(labels, \n    [\n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 4, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1 ],\n      [ 1, 1, 1, 1, 1, 1 ], \n    ],\n    types=TYPES_NO_BOOL\n  )\n\n  labels = np.ones( (7, 7), dtype=np.uint32)\n  labels[0,:] = 0 \n  labels[1:3,:] = 1 \n  labels[3:,:] = 2 \n  labels[5,5] = 3\n\n  cmp(labels, \n    [\n      [ 0, 0, 0, 0, 0, 0, 0 ], \n      [ 1, 1, 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1, 1 ], \n      [ 1, 4, 4, 4, 2, 1, 1 ], \n      [ 1, 4, 4, 4, 1, 1, 1 ], \n      [ 1, 1, 1, 1, 1, 1, 1 ], \n    ],\n    types=TYPES_NO_BOOL\n  )\n\ndef test_2d_scipy_comparison_black_border():\n  for dtype in INTEGER_TYPES:\n    print(dtype)\n    randos = np.random.randint(0, 2, size=(3, 3), dtype=dtype)\n    labels = np.zeros( (randos.shape[0] + 2, randos.shape[1] + 2), dtype=dtype)\n    # Scipy requires zero borders\n    labels[1:-1,1:-1] = randos\n\n    print(""INPUT"")\n    print(labels)\n\n    print(""MLAEDT"")\n    mlaedt_result = edt.edt(labels, black_border=False)\n    # mlaedt_result_bb = edt.edt(labels, black_border=True)\n    print(mlaedt_result)\n\n    print(""SCIPY"")\n    scipy_result = ndimage.distance_transform_edt(labels)\n    print(scipy_result)\n\n    assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n    # assert np.all( np.abs(scipy_result - mlaedt_result_bb) < 0.000001 )\n\ndef test_2d_scipy_comparison():\n  for _ in range(20):\n    for parallel in (1,2):\n      for dtype in (np.uint32, np.bool):\n        randos = np.random.randint(0, 2, size=(5, 5), dtype=dtype)\n        labels = np.zeros( (randos.shape[0] + 2, randos.shape[1] + 2), dtype=dtype)\n\n        print(""INPUT"")\n        print(labels)\n\n        print(""MLAEDT"")\n        mlaedt_result = edt.edt(labels, black_border=False, parallel=parallel)\n        print(mlaedt_result)\n\n        print(""SCIPY"")\n        scipy_result = ndimage.distance_transform_edt(labels)\n        print(scipy_result)\n\n        assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n\ndef test_three_d():  \n  def cmp(labels, ans, types=TYPES, anisotropy=(1.0, 1.0, 1.0)):\n    for parallel in (1,2):\n      for dtype in types:\n        print(dtype, anisotropy)\n        labels = np.array(labels, dtype=dtype)\n        ans = np.array(ans, dtype=np.float32)\n        print(labels)\n        print(ans)\n        result = edt.edtsq(\n          labels, anisotropy=anisotropy, \n          black_border=True, order=\'C\', \n          parallel=parallel\n        )\n        assert np.all(result.T == ans) # written in human understandable order so needs transpose \n\n  cmp([[[]]], [[[]]])\n  cmp([[[0]]], [[[0]]])\n  cmp([[[1]]], [[[1]]])\n  cmp([[[5]]], [[[1]]])\n\n  cmp([\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n  ], \n  [\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 4, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n  ])\n\n\n  cmp([\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n  ], \n  [\n    [\n      [16, 16, 16], \n      [16, 16, 16],\n      [16, 16, 16]\n    ],\n    [\n      [16, 16, 16], \n      [16, 64, 16],\n      [16, 16, 16]\n    ],\n    [\n      [16, 16, 16], \n      [16, 16, 16],\n      [16, 16, 16]\n    ],\n  ], anisotropy=(4,4,4))\n\n  cmp([\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n    [\n      [1, 1, 1], \n      [1, 1, 1],\n      [1, 1, 1]\n    ],\n  ], \n  [\n    [\n      [25, 25, 25], \n      [25, 25, 25],\n      [25, 25, 25]\n    ],\n    [\n      [36, 36, 36], \n      [36,100, 36],\n      [36, 36, 36]\n    ],\n    [\n      [25, 25, 25], \n      [25, 25, 25],\n      [25, 25, 25]\n    ],\n  ], anisotropy=(6,6,5))\n\ndef test_3d_scipy_comparison():\n  for _ in range(20):\n    for parallel in (1,2):\n      for dtype in (np.uint32, np.bool):\n        for order in (\'C\', \'F\'):\n          randos = np.random.randint(0, 2, size=(100, 100, 100), dtype=dtype)\n          labels = np.zeros( (randos.shape[0] + 2, randos.shape[1] + 2, randos.shape[2] + 2), dtype=dtype, order=order)\n          # Scipy requires zero borders\n          labels[1:-1,1:-1,1:-1] = randos\n\n          print(""INPUT"")\n          print(labels)\n\n          print(""MLAEDT"")\n          mlaedt_result = edt.edt(labels, black_border=False, order=order, parallel=parallel)\n          print(mlaedt_result)\n\n          print(""SCIPY"")\n          scipy_result = ndimage.distance_transform_edt(labels)\n          print(scipy_result)\n\n          print(""DIFF"")\n          print(np.abs(scipy_result == mlaedt_result))\n          print(np.max(np.abs(scipy_result - mlaedt_result)))\n\n          assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n\ndef test_non_mutation_2d():\n  """"""\n  This example helped debug the error \n  caused by reading/writing to the same array.\n  """"""\n  x = np.array(\n  [\n   [  True, False,  True,  True,  ],\n   [ False,  True,  True,  True,  ],\n   [ False,  True,  True,  True,  ],\n   [  True,  True,  True,  True,  ],\n   [ False,  True,  True,  True,  ],], dtype=np.bool)\n \n  compare_scipy_edt(x)\n\ndef test_dots(numdots=5, N=100, radius=20):\n  img = np.zeros((N, N), dtype=np.bool)\n  locations=np.random.randint(0, N-1, size=(numdots, 2), dtype=np.int)\n  xx,yy = np.meshgrid(range(N), range(N), indexing=\'xy\')\n\n  for loc in locations:\n    dx = xx - loc[0]\n    dy = yy - loc[1]\n    d = np.sqrt(dx ** 2 + dy ** 2)\n    img[d <= radius] = True\n\n  img[ :, 0] = 0\n  img[ 0, :] = 0\n  img[-1, :] = 0\n  img[ :,-1] = 0\n\n  compare_scipy_edt(img)\n\ndef compare_scipy_edt(labels):\n  print(""INPUT"", labels.shape)\n  print(labels)\n\n  print(""MLAEDT"")\n  mlaedt_result = edt.edt(labels, black_border=False)\n  print(mlaedt_result)\n\n  print(""SCIPY"")\n  scipy_result = ndimage.distance_transform_edt(labels)\n  print(scipy_result)\n\n  print(""DIFF"")\n  print(np.abs(scipy_result - mlaedt_result) < 0.000001)\n  print(""MAX Diff"")\n  print(np.max(np.abs(scipy_result - mlaedt_result)))\n\n  assert np.all( np.abs(scipy_result - mlaedt_result) < 0.000001 )\n\ndef test_2d_even_anisotropy():\n  labels = np.zeros( (15,15), dtype=np.bool, order=\'F\')\n  labels[2:12, 2:12] = True\n  img = edt.edt(labels, anisotropy=(1,1), order=\'F\')\n  for i in range(1, 150):\n    w = float(i)\n    aimg = edt.edt(labels, anisotropy=(w, w))\n    assert np.all(w * img == aimg)\n\ndef test_3d_even_anisotropy():\n  labels = np.zeros( (15,15,15), dtype=np.bool, order=\'F\')\n  labels[2:12, 2:12, 5:10] = True\n  img = edt.edt(labels, anisotropy=(1,1,1))\n  for parallel in (1,2):\n    for i in range(1, 150):\n      w = float(i)\n      aimg = edt.edt(labels, anisotropy=(w, w, w), parallel=parallel)\n      assert np.all(w * img == aimg)\n\ndef test_2d_lopsided():\n  def gen(x, y, order):\n    x = np.zeros((x, y), dtype=np.uint32, order=order)\n    x[0:25,5:50] = 3\n    x[25:50,5:50] = 1\n    x[60:110,5:50] = 2\n    return x\n\n  sizes = [\n    (150, 150),\n    (150,  75),\n    (75,  150),\n  ]\n\n  for size in sizes:\n    cres = edt.edt(gen(size[0], size[1], \'C\'), order=\'C\')\n    fres = edt.edt(gen(size[0], size[1], \'F\'), order=\'F\')\n\n    print(size)\n    assert np.all(cres[:] == fres[:])\n\ndef test_2d_lopsided_anisotropic():\n  def gen(x, y, order):\n    x = np.zeros((x, y), dtype=np.uint32, order=order)\n    x[0:25,5:50] = 3\n    x[25:50,5:50] = 1\n    x[60:110,5:50] = 2\n    return x\n\n  sizes = [\n    (150, 150),\n    (150,  75),\n    ( 75, 150),\n  ]\n\n  for size in sizes:\n    cres = edt.edt(gen(size[0], size[1], \'C\'), anisotropy=(2,3), order=\'C\')\n    fres = edt.edt(gen(size[0], size[1], \'F\'), anisotropy=(2,3), order=\'F\')\n\n    print(size)\n    assert np.all(cres[:] == fres[:])\n\ndef test_3d_lopsided():\n  def gen(x, y, z, order):\n    x = np.zeros((x, y, z), dtype=np.uint32, order=order)\n    x[ 0:25,  5:50, 0:25] = 3\n    x[25:50,  5:50, 0:25] = 1\n    x[60:110, 5:50, 0:25] = 2\n    return x\n\n  sizes = [\n    (150, 150, 150),\n    (150,  75,  23),\n    (75,  150,  37),\n  ]\n\n  for size in sizes:\n    cres = edt.edt(gen(size[0], size[1], size[2], \'C\'), order=\'C\')\n    fres = edt.edt(gen(size[0], size[1], size[2], \'F\'), order=\'F\')\n\n    print(size)\n    assert np.all(cres == fres)\n\ndef test_3d_high_anisotropy():\n  shape = (256, 256, 256)\n  anisotropy = (1000000, 1200000, 40)\n\n  labels = np.ones( shape, dtype=np.uint8)\n  labels[0, 0, 0] = 0\n  labels[-1, -1, -1] = 0\n\n  resedt = edt.edt(labels, anisotropy=anisotropy, black_border=False)\n\n  mx = np.max(resedt)\n  assert np.isfinite(mx)\n  assert mx <= (1e6 * 256) ** 2 + (1e6 * 256) ** 2 + (666 * 256) ** 2\n\n  resscipy = ndimage.distance_transform_edt(labels, sampling=anisotropy)\n  resscipy[ resscipy == 0 ] = 1\n  resedt[ resedt == 0 ] = 1\n  ratio = np.abs(resscipy / resedt)\n  assert np.all(ratio < 1.000001) and np.all(ratio > 0.999999)\n\ndef test_all_inf():\n  shape = (128, 128, 128)\n  labels = np.ones( shape, dtype=np.uint8)\n  res = edt.edt(labels, black_border=False, anisotropy=(1,1,1))\n  assert np.all(res == np.inf)\n\ndef test_numpy_anisotropy():\n  labels = np.zeros(shape=(128, 128, 128), dtype=np.uint32)\n  labels[1:-1,1:-1,1:-1] = 1\n\n  resolution = np.array([4,4,40])\n  res = edt.edtsq(labels, anisotropy=resolution)\n\n\n\n'"
python/memtest.py,1,"b'import numpy as np\nimport edt\n\nx = np.ones((512,512,512), dtype=np.uint8)\n\nfor i in range(10):\n  ex = edt.edt(x, parallel=4)\n\nprint(""done."")'"
python/perf.py,2,"b""import time\n\nimport numpy as np\nfrom scipy import ndimage\n\nimport edt\n\nlabels = np.ones(shape=(512, 512, 512), dtype=np.uint32)\n\nstart = time.time()\nres = edt.edtsq(labels, anisotropy=(1,1,1))\nprint('Multi-label EDT: ', time.time() - start, ' sec.')\n\nbinlabels = labels.astype(np.bool)\n\nstart = time.time()\nres = edt.edtsq(binlabels, anisotropy=(1,1,1))\nprint('Binary EDT: ', time.time() - start, ' sec.')\n\nstart = time.time()\nndimage.distance_transform_edt(labels)\nprint('ndimage EDT: ', time.time() - start, ' sec.')\n\n"""
python/setup.py,1,"b'import setuptools\nimport sys\n\nimport numpy as np\n\n# NOTE: If edt.cpp does not exist:\n# cython -3 --fast-fail -v --cplus edt.pyx\n\nextra_compile_args = [\n  \'-std=c++11\', \'-O3\', \'-ffast-math\', \'-pthread\'\n]\nif sys.platform == \'darwin\':\n  extra_compile_args += [ \'-stdlib=libc++\', \'-mmacosx-version-min=10.9\' ]\n\nsetuptools.setup(\n  setup_requires=[\'pbr\'],\n  extras_require={\n    \':python_version == ""2.7""\': [\'futures\'],\n    \':python_version == ""2.6""\': [\'futures\'],\n  },\n  ext_modules=[\n    setuptools.Extension(\n      \'edt\',\n      sources=[ \'edt.cpp\' ],\n      language=\'c++\',\n      include_dirs=[ np.get_include() ],\n      extra_compile_args=extra_compile_args,\n    ),\n  ],\n  long_description_content_type=\'text/markdown\',\n  pbr=True)'"
