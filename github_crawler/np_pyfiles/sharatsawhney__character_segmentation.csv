file_path,api_count,code
cls.py,0,"b""from keras.preprocessing.image import ImageDataGenerator\nfrom keras.models import Sequential\nfrom keras.layers import Conv2D, MaxPooling2D\nfrom keras.layers import Activation, Dropout, Flatten, Dense\nfrom keras import backend as K\n\n\n# dimensions of our images.\nimg_width, img_height = 150, 150\n\ntrain_data_dir = 'database'\nvalidation_data_dir = 'data/validation'\nnb_train_samples = 7705\nnb_validation_samples = 800\nepochs = 50\nbatch_size = 16\n\nif K.image_data_format() == 'channels_first':\n    input_shape = (3, img_width, img_height)\nelse:\n    input_shape = (img_width, img_height, 3)\n\nmodel = Sequential()\nmodel.add(Conv2D(32, (3, 3), input_shape=input_shape))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(32, (3, 3)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Conv2D(64, (3, 3)))\nmodel.add(Activation('relu'))\nmodel.add(MaxPooling2D(pool_size=(2, 2)))\n\nmodel.add(Flatten())\nmodel.add(Dense(64))\nmodel.add(Activation('relu'))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(1))\nmodel.add(Activation('sigmoid'))\n\nmodel.compile(loss='binary_crossentropy',\n              optimizer='rmsprop',\n              metrics=['accuracy'])\n\n# this is the augmentation configuration we will use for training\ntrain_datagen = ImageDataGenerator(\n    rescale=1. / 255,\n    shear_range=0.2,\n    zoom_range=0.2,\n    horizontal_flip=True)\n\n# this is the augmentation configuration we will use for testing:\n# only rescaling\ntest_datagen = ImageDataGenerator(rescale=1. / 255)\n\ntrain_generator = train_datagen.flow_from_directory(\n    train_data_dir,\n    target_size=(img_width, img_height),\n    batch_size=batch_size,\n    class_mode='binary')\n\nvalidation_generator = test_datagen.flow_from_directory(\n    validation_data_dir,\n    target_size=(img_width, img_height),\n    batch_size=batch_size,\n    class_mode='binary')\n\nmodel.fit_generator(\n    train_generator,\n    steps_per_epoch=nb_train_samples // batch_size,\n    epochs=epochs,\n    validation_data=validation_generator,\n    validation_steps=nb_validation_samples // batch_size)\n\nmodel.save_weights('first_try.h5')"""
main.py,10,"b'import cv2 \nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\nnp.set_printoptions(threshold=np.nan)\n\n\ndef showimages():\n    cv2.imshow(""Source Image"", src_img)\n    cv2.imshow(""Binary Image"", bin_img)\n    cv2.imshow(""Threshold Image"", final_thr)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n\n\ndef line_array(array):\n    list_x_upper = []\n    list_x_lower = []\n    for y in range(5, len(array)-5):\n        s_a, s_p = strtline(y, array)\n        e_a, e_p = endline(y, array)\n        print(str(s_a) + \',\' + str(s_p) + \',\' + str(e_a) + \',\' + str(e_p) + \',\' + str(y))\n        if s_a>=7 and s_p>=5:\n            list_x_upper.append(y)\n        # bin_img[y][:] = 255\n        if e_a>=5 and e_p>=7:\n            list_x_lower.append(y)\n            # bin_img[y][:] = 255\n    return list_x_upper, list_x_lower\n\ndef strtline(y, array):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y+10]:\n        if i > 3:\n            count_ahead+= 1  \n    for i in array[y-10:y]:\n        if i == 0:\n            count_prev += 1  \n    return count_ahead, count_prev\n\ndef endline(y, array):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y+10]:\n        if i==0:\n            count_ahead+= 1  \n    for i in array[y-10:y]:\n        if i >3:\n            count_prev += 1  \n    return count_ahead, count_prev\n\ndef endline_word(y, array, a):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y+2*a]:\n        if i < 2:\n            count_ahead+= 1  \n    for i in array[y-a:y]:\n        if i > 2:\n            count_prev += 1  \n    return count_prev ,count_ahead\n\ndef end_line_array(array, a):\n    list_endlines = []\n    for y in range(len(array)):\n        e_p, e_a = endline_word(y, array, a)\n        #print(e_p, e_a)\n        if e_a >= int(0.8*a) and e_p >= int(0.7*a):\n            list_endlines.append(y)\n    return list_endlines\n\ndef refine_endword(array):\n    refine_list = []\n    for y in range(len(array)-1):\n        if array[y]+1 < array[y+1]:\n            refine_list.append(array[y])\n    refine_list.append(array[-1])\n    return refine_list\n\n\ndef refine_array(array_upper, array_lower):\n    upperlines = []\n    lowerlines = []\n    for y in range(len(array_upper)-1):\n        if array_upper[y] + 5 < array_upper[y+1]:\n            upperlines.append(array_upper[y]-10)\n    for y in range(len(array_lower)-1):\n        if array_lower[y] + 5 < array_lower[y+1]:\n            lowerlines.append(array_lower[y]+10)\n\n    upperlines.append(array_upper[-1]-10)\n    lowerlines.append(array_lower[-1]+10)\n    \n    return upperlines, lowerlines\n\ndef letter_width(contours):\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x,y,w,h = cv2.boundingRect(cnt)\n            letter_width_sum += w\n            count += 1\n\n    return letter_width_sum/count\n\n\ndef end_wrd_dtct(final_local, i, bin_img, mean_lttr_width):\n    count_y = np.zeros(shape = width)\n    for x in range(width):\n        for y in range(final_local[i],final_local[i+1]):\n            if bin_img[y][x] == 255:\n                count_y[x] += 1\n    #end_lines = end_line_array(count_y, int(mean_lttr_width))\n    #endlines = refine_endword(end_lines)\n    #print(i)\n    \'\'\'for x in range(len(count_y)):\n        if max(count_y[0:x+1]) >= 3 and max(count_y[x:]) >= 3 and (20-np.count_nonzero(count_y[x-10:x+10])) > 6:\n            print(x)\'\'\'\n\n    chalu_img, contours, hierarchy = cv2.findContours(lines_img[i], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x, y, w, h = cv2.boundingRect(cnt)\n            letter_width_sum += w\n            count += 1\n    if count != 0 :\n        mean_width = letter_width_sum / count\n    else:\n        mean_width = 0\n    #print(mean_width)\n    spaces = []\n    line_end = []\n    for x in range(len(count_y)):\n        number = int(0.5*int(mean_width)) - np.count_nonzero(count_y[x-int(0.25*int(mean_width)):x+int(0.25*int(mean_width))])\n        if max(count_y[0:x + 1]) >= 3 and number >= 0.4*int(mean_width):\n            spaces.append(x)\n        if max(count_y[x:]) <= 2:\n            line_end.append(x)\n    true_line_end = min(line_end) + 10\n    #spaces = refine_endword(spaces)\n    #print(spaces)\n    #print(true_line_end)\n    reti = []\n    final_spaces = []\n    for j in range(len(spaces)):\n        if spaces[j] < true_line_end:\n            if spaces[j] == spaces[j-1] + 1:\n                reti.append(spaces[j-1])\n            elif spaces[j] != spaces[j-1] + 1 and spaces[j-1] == spaces[j-2] +1:\n                reti.append(spaces[j-1])\n                retiavg = int(sum(reti)/len(reti))\n                final_spaces.append(retiavg)\n                reti = []\n            elif spaces[j] != spaces[j-1] + 1 and spaces[j-1] != spaces[j-2] +1 and spaces[j] != spaces[j+1] -1:\n                final_spaces.append(spaces[j])\n        elif spaces[j] == true_line_end:\n            final_spaces.append(true_line_end)\n    #print(final_spaces)\n    for x in final_spaces:\n        final_thr[final_local[i]:final_local[i+1], x] = 255\n    return final_spaces\n\n\ndef letter_seg(lines_img, x_lines, i):\n    copy_img = lines_img[i].copy()\n    x_linescopy = x_lines[i].copy()\n    \n    letter_img = []\n    letter_k = []\n    \n    chalu_img, contours, hierarchy = cv2.findContours(copy_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)   \n    for cnt in contours:\n        if cv2.contourArea(cnt) > 5:\n            x,y,w,h = cv2.boundingRect(cnt)\n            # letter_img.append(lines_img[i][y:y+h, x:x+w])\n            letter_k.append((x,y,w,h))\n\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x, y, w, h = cv2.boundingRect(cnt)\n            letter_width_sum += h\n            count += 1\n\n    #mean_height = letter_width_sum/count\n\n    letter = sorted(letter_k, key=lambda student: student[0])\n\n    for e in range(len(letter)):\n        if e < len(letter)-1:\n            if abs(letter[e][0] - letter[e+1][0]) <= 2:\n                x,y,w,h = letter[e]\n                x2,y2,w2,h2 = letter[e+1]\n                if h >= h2:\n                    letter[e] = (x,y2,w,h+h2)\n                    letter.pop(e+1)\n                elif h < h2:\n                    letter[e+1] = (x2,y,w2,h+h2)\n                    letter.pop(e)\n\n    for e in range(len(letter)):\n        letter_img_tmp = lines_img[i][letter[e][1]-0:letter[e][1]+letter[e][3]+0,letter[e][0]-0:letter[e][0]+letter[e][2]+0]\n        letter_img_tmp = cv2.resize(letter_img_tmp, dsize=(28, 28), interpolation=cv2.INTER_AREA)\n        width = letter_img_tmp.shape[1]\n        height = letter_img_tmp.shape[0]\n        count_y = np.zeros(shape=(width))\n        for x in range(width):\n            for y in range(height):\n                if letter_img_tmp[y][x] == 255:\n                    count_y[x] = count_y[x] +1\n        print(count_y)\n        max_list = []\n        for z in range(len(count_y)):\n            if z>=5 and z<= len(count_y)-6:\n                if max(count_y[z-5:z+6]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n            elif z<5:\n                if max(count_y[0:z+6]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n            elif z > len(count_y)-6:\n                if max(count_y[z-5:len(count_y)-1]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n        print(max_list)\n        rem_list = []\n        final_max_list = []\n        for z in range(len(max_list)):\n            if z > 0:\n                if max_list[z]-max_list[z-1] <= 3:\n                    rem_list.append(z-1)\n        for z in range(len(max_list)):\n            if z not in rem_list:\n                final_max_list.append(max_list[z])\n        print(final_max_list)\n        if len(final_max_list) <= 1:\n            print(False)\n        else:\n            max_len = len(final_max_list) - 1\n            for j in range(max_len):\n                list = count_y[final_max_list[j]:final_max_list[j+1]]\n                min_list = sorted(list)[:3]\n                avg = sum(min_list)/len(min_list)\n                print(avg)\n\n\n\n    x_linescopy.pop(0)\n    word = 1\n    letter_index = 0\n    for e in range(len(letter)):\n        #print(str(letter[e][0]) + \',\' + str(letter[e][1]) + \',\' + str(letter[e][2]) + \',\' + str(letter[e][3]) + \',\' + str(e))\n        if(letter[e][0]<x_linescopy[0]):\n            letter_index += 1\n            letter_img_tmp = lines_img[i][letter[e][1]-0:letter[e][1]+letter[e][3]+5,letter[e][0]-2:letter[e][0]+letter[e][2]+2]\n            letter_img = cv2.resize(letter_img_tmp, dsize =(28, 28), interpolation = cv2.INTER_AREA)\n            cv2.imwrite(\'./segmented_img/img1/\'+str(i+1)+\'_\'+str(word)+\'_\'+str(letter_index)+\'.jpg\', 255-letter_img)\n        else:\n            x_linescopy.pop(0)\n            word += 1\n            letter_index = 1\n            letter_img_tmp = lines_img[i][letter[e][1]-0:letter[e][1]+letter[e][3]+5,letter[e][0]-2:letter[e][0]+letter[e][2]+2]\n            letter_img = cv2.resize(letter_img_tmp, dsize =(28, 28), interpolation = cv2.INTER_AREA)\n            cv2.imwrite(\'./segmented_img/img1/\'+str(i+1)+\'_\'+str(word)+\'_\'+str(letter_index)+\'.jpg\', 255-letter_img)\n            # print(letter[e][0],x_linescopy[0], word)\n\n\nprint(""\\n........Program Initiated.......\\n"")\nsrc_img= cv2.imread(\'./data/a1.jpg\', 1)\ncopy = src_img.copy()\nheight = src_img.shape[0]\nwidth = src_img.shape[1]\n\nprint(""\\n Resizing Image........"")\nsrc_img = cv2.resize(copy, dsize =(1320, int(1320*height/width)), interpolation = cv2.INTER_AREA)\n\nheight = src_img.shape[0]\nwidth = src_img.shape[1]\n\nprint(""#---------Image Info:--------#"")\nprint(""\\tHeight ="",height,""\\n\\tWidth ="",width)\nprint(""#----------------------------#"")\n\ngrey_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2GRAY)\n\nprint(""Applying Adaptive Threshold with kernel :- 21 X 21"")\nbin_img = cv2.adaptiveThreshold(grey_img,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,21,20)\ncoords = np.column_stack(np.where(bin_img > 0))\nangle = cv2.minAreaRect(coords)[-1]\nif angle < -45:\n    angle = -(90 + angle)\nelse:\n    angle = -angle\nh = bin_img.shape[0]\nw = bin_img.shape[1]\ncenter = (w//2,h//2)\nangle = 0\nM = cv2.getRotationMatrix2D(center,angle,1.0)\nbin_img = cv2.warpAffine(bin_img,M,(w,h),\n                         flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)\n\nbin_img1 = bin_img.copy()\nbin_img2 = bin_img.copy()\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))\nkernel1 = np.array([[1,0,1],[0,1,0],[1,0,1]], dtype = np.uint8)\n# final_thr = cv2.morphologyEx(bin_img, cv2.MORPH_OPEN, kernel)\n# final_thr = cv2.dilate(bin_img,kernel1,iterations = 1)\nprint(""Noise Removal From Image........."")\nfinal_thr = cv2.morphologyEx(bin_img, cv2.MORPH_CLOSE, kernel)\ncontr_retrival = final_thr.copy()\n\n\nprint(""Beginning Character Segmentation.............."")\ncount_x = np.zeros(shape= (height))\nfor y in range(height):\n    for x in range(width):\n        if bin_img[y][x] == 255 :\n            count_x[y] = count_x[y]+1\n\nlocal_minima = []\nfor y in range(len(count_x)):\n    if y >= 10 and y <= len(count_x)-11:\n        arr1 = count_x[y-10:y+10]\n    elif y < 10:\n        arr1 = count_x[0:y+10]\n    else:\n        arr1 = count_x[y-10:len(count_x)-1]\n    if min(arr1) == count_x[y]:\n        local_minima.append(y)\n\nfinal_local = []\ninit = []\nend = []\nfor z in range(len(local_minima)):\n    if z != 0 and z!= len(local_minima)-1:\n        if local_minima[z] != (local_minima[z-1] +1) and local_minima[z] != (local_minima[z+1] -1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] != (local_minima[z-1] + 1) and local_minima[z] == (local_minima[z+1] -1):\n            init.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z-1] + 1) and local_minima[z] != (local_minima[z+1] -1):\n            end.append(local_minima[z])\n    elif z == 0:\n        if local_minima[z] != (local_minima[z+1]-1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z+1]-1):\n            init.append(local_minima[z])\n    elif z == len(local_minima)-1:\n        if local_minima[z] != (local_minima[z-1]+1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z-1]+1):\n            end.append(local_minima[z])\nfor j in range(len(init)):\n    mid = (init[j] + end[j])/2\n    if (mid % 1) != 0:\n        mid = mid+0.5\n    final_local.append(int(mid))\n\nfinal_local = sorted(final_local)\n\nno_of_lines = len(final_local) - 1\n\nprint(""\\nGiven Text has   # "",no_of_lines, "" #   no. of lines"")\n\nlines_img = []\n\nfor i in range(no_of_lines):\n    lines_img.append(bin_img2[final_local[i]:final_local[i+1], :])\n\ncontr_img, contours, hierarchy = cv2.findContours(contr_retrival,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)\nfinal_contr = np.zeros((final_thr.shape[0],final_thr.shape[1],3), dtype = np.uint8)\ncv2.drawContours(src_img, contours, -1, (0,255,0), 1)\n\nmean_lttr_width = letter_width(contours)\nprint(""\\nAverage Width of Each Letter:- "", mean_lttr_width)\n\n\nx_lines = []\n\nfor i in range(len(lines_img)):\n    x_lines.append(end_wrd_dtct(final_local, i, bin_img, mean_lttr_width))\n\nfor i in range(len(x_lines)):\n    x_lines[i].append(width)\n\nprint(x_lines)\n#-------------/Word Detection-----------------#\n\n#-------------Letter Segmentation-------------#\n\ncv2.waitKey(0)\nfor i in range(no_of_lines):\n    letter_seg(lines_img, x_lines, i)   \n\n\nchr_img = bin_img1.copy()\n\ncontr_img, contours, hierarchy = cv2.findContours(chr_img,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)\n# print(len(contours))\n# final_contr = np.zeros((final_thr.shape[0],final_thr.shape[1],3), dtype = np.uint8)\n# cv2.drawContours(src_img, contours, -1, (0,255,0), 1)\n\nfor cnt in contours:\n    if cv2.contourArea(cnt) > 20:\n        x,y,w,h = cv2.boundingRect(cnt)\n        cv2.rectangle(src_img,(x,y),(x+w,y+h),(0,255,0),2)\n\n\nshowimages()\n'"
mainr.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport os\n\nnp.set_printoptions(threshold=np.nan)\n\n\ndef showimages():\n    cv2.imshow(""Source Image"", src_img)\n    cv2.imshow(""Binary Image"", bin_img)\n    cv2.imshow(""Threshold Image"", final_thr)\n    cv2.waitKey(0)\n    cv2.destroyAllWindows()\n\n\ndef line_array(array):\n    list_x_upper = []\n    list_x_lower = []\n    for y in range(5, len(array) - 5):\n        s_a, s_p = strtline(y, array)\n        e_a, e_p = endline(y, array)\n        print(str(s_a) + \',\' + str(s_p) + \',\' + str(e_a) + \',\' + str(e_p) + \',\' + str(y))\n        if s_a >= 7 and s_p >= 5:\n            list_x_upper.append(y)\n        # bin_img[y][:] = 255\n        if e_a >= 5 and e_p >= 7:\n            list_x_lower.append(y)\n            # bin_img[y][:] = 255\n    return list_x_upper, list_x_lower\n\n\ndef strtline(y, array):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y + 10]:\n        if i > 3:\n            count_ahead += 1\n    for i in array[y - 10:y]:\n        if i == 0:\n            count_prev += 1\n    return count_ahead, count_prev\n\n\ndef endline(y, array):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y + 10]:\n        if i == 0:\n            count_ahead += 1\n    for i in array[y - 10:y]:\n        if i > 3:\n            count_prev += 1\n    return count_ahead, count_prev\n\n\ndef endline_word(y, array, a):\n    count_ahead = 0\n    count_prev = 0\n    for i in array[y:y + 2 * a]:\n        if i < 2:\n            count_ahead += 1\n    for i in array[y - a:y]:\n        if i > 2:\n            count_prev += 1\n    return count_prev, count_ahead\n\n\ndef end_line_array(array, a):\n    list_endlines = []\n    for y in range(len(array)):\n        e_p, e_a = endline_word(y, array, a)\n        # print(e_p, e_a)\n        if e_a >= int(0.8 * a) and e_p >= int(0.7 * a):\n            list_endlines.append(y)\n    return list_endlines\n\n\ndef refine_endword(array):\n    refine_list = []\n    for y in range(len(array) - 1):\n        if array[y] + 1 < array[y + 1]:\n            refine_list.append(array[y])\n    refine_list.append(array[-1])\n    return refine_list\n\n\ndef refine_array(array_upper, array_lower):\n    upperlines = []\n    lowerlines = []\n    for y in range(len(array_upper) - 1):\n        if array_upper[y] + 5 < array_upper[y + 1]:\n            upperlines.append(array_upper[y] - 10)\n    for y in range(len(array_lower) - 1):\n        if array_lower[y] + 5 < array_lower[y + 1]:\n            lowerlines.append(array_lower[y] + 10)\n\n    upperlines.append(array_upper[-1] - 10)\n    lowerlines.append(array_lower[-1] + 10)\n\n    return upperlines, lowerlines\n\n\ndef letter_width(contours):\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x, y, w, h = cv2.boundingRect(cnt)\n            letter_width_sum += w\n            count += 1\n\n    return letter_width_sum / count\n\n\ndef end_wrd_dtct(final_local, i, bin_img, mean_lttr_width):\n    count_y = np.zeros(shape=width)\n    for x in range(width):\n        for y in range(final_local[i], final_local[i + 1]):\n            if bin_img[y][x] == 255:\n                count_y[x] += 1\n    # end_lines = end_line_array(count_y, int(mean_lttr_width))\n    # endlines = refine_endword(end_lines)\n    # print(i)\n    \'\'\'for x in range(len(count_y)):\n        if max(count_y[0:x+1]) >= 3 and max(count_y[x:]) >= 3 and (20-np.count_nonzero(count_y[x-10:x+10])) > 6:\n            print(x)\'\'\'\n\n    chalu_img, contours, hierarchy = cv2.findContours(lines_img[i], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x, y, w, h = cv2.boundingRect(cnt)\n            letter_width_sum += w\n            count += 1\n    if count != 0:\n        mean_width = letter_width_sum / count\n    else:\n        mean_width = 0\n    # print(mean_width)\n    spaces = []\n    line_end = []\n    for x in range(len(count_y)):\n        number = int(0.5 * int(mean_width)) - np.count_nonzero(\n            count_y[x - int(0.25 * int(mean_width)):x + int(0.25 * int(mean_width))])\n        if max(count_y[0:x + 1]) >= 3 and number >= 0.4 * int(mean_width):\n            spaces.append(x)\n        if max(count_y[x:]) <= 2:\n            line_end.append(x)\n    true_line_end = min(line_end) + 10\n    # spaces = refine_endword(spaces)\n    # print(spaces)\n    # print(true_line_end)\n    reti = []\n    final_spaces = []\n    for j in range(len(spaces)):\n        if spaces[j] < true_line_end:\n            if spaces[j] == spaces[j - 1] + 1:\n                reti.append(spaces[j - 1])\n            elif spaces[j] != spaces[j - 1] + 1 and spaces[j - 1] == spaces[j - 2] + 1:\n                reti.append(spaces[j - 1])\n                retiavg = int(sum(reti) / len(reti))\n                final_spaces.append(retiavg)\n                reti = []\n            elif spaces[j] != spaces[j - 1] + 1 and spaces[j - 1] != spaces[j - 2] + 1 and spaces[j] != spaces[\n                j + 1] - 1:\n                final_spaces.append(spaces[j])\n        elif spaces[j] == true_line_end:\n            final_spaces.append(true_line_end)\n    # print(final_spaces)\n    for x in final_spaces:\n        final_thr[final_local[i]:final_local[i + 1], x] = 255\n    return final_spaces\n\n\ndef letter_seg(lines_img, x_lines, i):\n    copy_img = lines_img[i].copy()\n    x_linescopy = x_lines[i].copy()\n\n    letter_img = []\n    letter_k = []\n\n    chalu_img, contours, hierarchy = cv2.findContours(copy_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 0:\n            x, y, w, h = cv2.boundingRect(cnt)\n            # letter_img.append(lines_img[i][y:y+h, x:x+w])\n            letter_k.append((x, y, w, h))\n\n    letter_width_sum = 0\n    count = 0\n    for cnt in contours:\n        if cv2.contourArea(cnt) > 20:\n            x, y, w, h = cv2.boundingRect(cnt)\n            letter_width_sum += h\n            count += 1\n\n    # mean_height = letter_width_sum/count\n\n    letter = sorted(letter_k, key=lambda student: student[0])\n\n    for e in range(len(letter)):\n        if e < len(letter) - 1:\n            if letter[e+1][0] <= letter[e][0] <= letter[e+1][0]+letter[e+1][2] or letter[e][0] <= letter[e+1][0] <= letter[e][0]+letter[e][2]: #abs(letter[e][0] - letter[e + 1][0]) <= 10:\n                x, y, w, h = letter[e]\n                x2, y2, w2, h2 = letter[e + 1]\n                if h >= h2:\n                    letter[e] = (x, y2, w, h + h2)\n                    letter.pop(e + 1)\n                elif h < h2:\n                    letter[e + 1] = (x2, y, w2, h + h2)\n                    letter.pop(e)\n\n    for e in range(len(letter)):\n        letter_img_tmp = lines_img[i][letter[e][1] - 0:letter[e][1] + letter[e][3] + 0,\n                         letter[e][0] - 0:letter[e][0] + letter[e][2] + 0]\n        letter_img_tmp = cv2.resize(letter_img_tmp, dsize=(28, 28), interpolation=cv2.INTER_AREA)\n        width = letter_img_tmp.shape[1]\n        height = letter_img_tmp.shape[0]\n        count_y = np.zeros(shape=(width))\n        for x in range(width):\n            for y in range(height):\n                if letter_img_tmp[y][x] == 255:\n                    count_y[x] = count_y[x] + 1\n        #print(count_y)\n        max_list = []\n        for z in range(len(count_y)):\n            if z >= 5 and z <= len(count_y) - 6:\n                if max(count_y[z - 5:z + 6]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n            elif z < 5:\n                if max(count_y[0:z + 6]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n            elif z > len(count_y) - 6:\n                if max(count_y[z - 5:len(count_y) - 1]) == count_y[z] and count_y[z] >= 2:\n                    max_list.append(z)\n        #print(max_list)\n        rem_list = []\n        final_max_list = []\n        for z in range(len(max_list)):\n            if z > 0:\n                if max_list[z] - max_list[z - 1] <= 3:\n                    rem_list.append(z - 1)\n        for z in range(len(max_list)):\n            if z not in rem_list:\n                final_max_list.append(max_list[z])\n        #print(final_max_list)\n        \'\'\'if len(final_max_list) <= 1:\n            print(False)\n        else:\n            max_len = len(final_max_list) - 1\n            for j in range(max_len):\n                list = count_y[final_max_list[j]:final_max_list[j + 1]]\n                min_list = sorted(list)[:3]\n                avg = sum(min_list) / len(min_list)\n                print(avg)\'\'\'\n\n    x_linescopy.pop(0)\n    word = 1\n    letter_index = 0\n    for e in range(len(letter)):\n        print(str(letter[e][0]) + \',\' + str(letter[e][1]) + \',\' + str(letter[e][2]) + \',\' + str(letter[e][3]) + \',\' + str(e))\n        if (letter[e][0] < x_linescopy[0]):\n            letter_index += 1\n            letter_img_tmp = lines_img[i][letter[e][1] - 0:letter[e][1] + letter[e][3] + 5,\n                             letter[e][0] - 2:letter[e][0] + letter[e][2] + 2]\n            letter_img = cv2.resize(letter_img_tmp, dsize=(28, 28), interpolation=cv2.INTER_AREA)\n            cv2.imwrite(\'./segmented_img/\' + font + \'/\' + font + str(i + 1) + \'_\' + str(word) + \'_\' + str(letter_index) + \'.jpg\',\n                        255 - letter_img)\n        else:\n            x_linescopy.pop(0)\n            word += 1\n            letter_index = 1\n            letter_img_tmp = lines_img[i][letter[e][1] - 0:letter[e][1] + letter[e][3] + 5,\n                             letter[e][0] - 2:letter[e][0] + letter[e][2] + 2]\n            letter_img = cv2.resize(letter_img_tmp, dsize=(28, 28), interpolation=cv2.INTER_AREA)\n            cv2.imwrite(\'./segmented_img/\' + font + \'/\' + font + str(i + 1) + \'_\' + str(word) + \'_\' + str(letter_index) + \'.jpg\',\n                        255 - letter_img)\n            # print(letter[e][0],x_linescopy[0], word)\n\n\nprint(""\\n........Program Initiated.......\\n"")\nfont = ""text""\nos.mkdir(\'segmented_img/\' + font)\nsrc_img = cv2.imread(font + \'.png\', 1)\ncopy = src_img.copy()\nheight = src_img.shape[0]\nwidth = src_img.shape[1]\n\nprint(""\\n Resizing Image........"")\nsrc_img = cv2.resize(copy, dsize=(1320, int(1320 * height / width)), interpolation=cv2.INTER_AREA)\n\nheight = src_img.shape[0]\nwidth = src_img.shape[1]\n\nprint(""#---------Image Info:--------#"")\nprint(""\\tHeight ="", height, ""\\n\\tWidth ="", width)\nprint(""#----------------------------#"")\n\ngrey_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2GRAY)\n\nprint(""Applying Adaptive Threshold with kernel :- 21 X 21"")\nbin_img = cv2.adaptiveThreshold(grey_img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, 21, 20)\ncoords = np.column_stack(np.where(bin_img > 0))\nangle = cv2.minAreaRect(coords)[-1]\nif angle < -45:\n    angle = -(90 + angle)\nelse:\n    angle = -angle\nh = bin_img.shape[0]\nw = bin_img.shape[1]\ncenter = (w // 2, h // 2)\nM = cv2.getRotationMatrix2D(center, angle, 1.0)\nbin_img = cv2.warpAffine(bin_img, M, (w, h),\n                         flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)\n\nbin_img1 = bin_img.copy()\nbin_img2 = bin_img.copy()\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))\nkernel1 = np.array([[1, 0, 1], [0, 1, 0], [1, 0, 1]], dtype=np.uint8)\n# final_thr = cv2.morphologyEx(bin_img, cv2.MORPH_OPEN, kernel)\n# final_thr = cv2.dilate(bin_img,kernel1,iterations = 1)\nprint(""Noise Removal From Image........."")\nfinal_thr = cv2.morphologyEx(bin_img, cv2.MORPH_CLOSE, kernel)\ncontr_retrival = final_thr.copy()\n\nprint(""Beginning Character Segmentation.............."")\ncount_x = np.zeros(shape=(height))\nfor y in range(height):\n    for x in range(width):\n        if bin_img[y][x] == 255:\n            count_x[y] = count_x[y] + 1\n\nlocal_minima = []\nfor y in range(len(count_x)):\n    if y >= 40 and y <= len(count_x) - 41:\n        arr1 = count_x[y - 40:y + 40]\n    elif y < 40:\n        arr1 = count_x[0:y + 40]\n    else:\n        arr1 = count_x[y - 40:len(count_x) - 1]\n    if min(arr1) == count_x[y]:\n        local_minima.append(y)\n\nfinal_local = []\ninit = []\nend = []\nfor z in range(len(local_minima)):\n    if z != 0 and z != len(local_minima) - 1:\n        if local_minima[z] != (local_minima[z - 1] + 1) and local_minima[z] != (local_minima[z + 1] - 1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] != (local_minima[z - 1] + 1) and local_minima[z] == (local_minima[z + 1] - 1):\n            init.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z - 1] + 1) and local_minima[z] != (local_minima[z + 1] - 1):\n            end.append(local_minima[z])\n    elif z == 0:\n        if local_minima[z] != (local_minima[z + 1] - 1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z + 1] - 1):\n            init.append(local_minima[z])\n    elif z == len(local_minima) - 1:\n        if local_minima[z] != (local_minima[z - 1] + 1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z - 1] + 1):\n            end.append(local_minima[z])\nfor j in range(len(init)):\n    mid = (init[j] + end[j]) / 2\n    if (mid % 1) != 0:\n        mid = mid + 0.5\n    final_local.append(int(mid))\n\nfinal_local = sorted(final_local)\n\nno_of_lines = len(final_local) - 1\n\nprint(""\\nGiven Text has   # "", no_of_lines, "" #   no. of lines"")\n\nlines_img = []\n\nfor i in range(no_of_lines):\n    lines_img.append(bin_img2[final_local[i]:final_local[i + 1], :])\n\ncontr_img, contours, hierarchy = cv2.findContours(contr_retrival, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\nfinal_contr = np.zeros((final_thr.shape[0], final_thr.shape[1], 3), dtype=np.uint8)\ncv2.drawContours(src_img, contours, -1, (0, 255, 0), 1)\n\nmean_lttr_width = letter_width(contours)\nprint(""\\nAverage Width of Each Letter:- "", mean_lttr_width)\n\nx_lines = []\n\nfor i in range(len(lines_img)):\n    x_lines.append(end_wrd_dtct(final_local, i, bin_img, mean_lttr_width))\n\nfor i in range(len(x_lines)):\n    x_lines[i].append(width)\n\nprint(x_lines)\n# -------------/Word Detection-----------------#\n\n# -------------Letter Segmentation-------------#\n\ncv2.waitKey(0)\nfor i in range(no_of_lines):\n    letter_seg(lines_img, x_lines, i)\n\nchr_img = bin_img1.copy()\n\ncontr_img, contours, hierarchy = cv2.findContours(chr_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n# print(len(contours))\n# final_contr = np.zeros((final_thr.shape[0],final_thr.shape[1],3), dtype = np.uint8)\n# cv2.drawContours(src_img, contours, -1, (0,255,0), 1)\n\nfor cnt in contours:\n    if cv2.contourArea(cnt) > 0:\n        x, y, w, h = cv2.boundingRect(cnt)\n        cv2.rectangle(src_img, (x, y), (x + w, y + h), (0, 255, 0), 2)\n\n\nshowimages()'"
test.py,3,"b""import cv2\nimport numpy as np\n\nimg = cv2.imread('data/vedantu-1.png',1)\nheight = img.shape[0]\nwidth = img.shape[1]\nsrc_img = cv2.resize(img, dsize =(1320, int(1320*height/width)), interpolation = cv2.INTER_AREA)\nheight = src_img.shape[0]\nwidth = src_img.shape[1]\ngrey_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2GRAY)\nbin_img = cv2.adaptiveThreshold(grey_img,255,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY_INV,21,20)\ncoords = np.column_stack(np.where(bin_img > 0))\nangle = cv2.minAreaRect(coords)[-1]\nif angle < -45:\n    angle = -(90 + angle)\nelse:\n    angle = -angle\nh = bin_img.shape[0]\nw = bin_img.shape[1]\ncenter = (w//2,h//2)\nM = cv2.getRotationMatrix2D(center,angle,1.0)\nbin_img = cv2.warpAffine(bin_img,M,(w,h),\n                         flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)\n\n\nkernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3))\nkernel1 = np.array([[1,0,1],[0,1,0],[1,0,1]], dtype = np.uint8)\nfinal_thr = cv2.morphologyEx(bin_img, cv2.MORPH_CLOSE, kernel)\n\n\ncount_x = np.zeros(shape= (height))\nfor y in range(height):\n    for x in range(width):\n        if bin_img[y][x] == 255 :\n            count_x[y] = count_x[y]+1\n\nlocal_minima = []\nfor y in range(len(count_x)):\n    if y >= 10 and y <= len(count_x)-11:\n        arr1 = count_x[y-10:y+10]\n    elif y < 10:\n        arr1 = count_x[0:y+10]\n    else:\n        arr1 = count_x[y-10:len(count_x)-1]\n    if min(arr1) == count_x[y]:\n        local_minima.append(y)\n\nfinal_local = []\ninit = []\nend = []\nfor z in range(len(local_minima)):\n    if z != 0 and z!= len(local_minima)-1:\n        if local_minima[z] != (local_minima[z-1] +1) and local_minima[z] != (local_minima[z+1] -1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] != (local_minima[z-1] + 1) and local_minima[z] == (local_minima[z+1] -1):\n            init.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z-1] + 1) and local_minima[z] != (local_minima[z+1] -1):\n            end.append(local_minima[z])\n    elif z == 0:\n        if local_minima[z] != (local_minima[z+1]-1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z+1]-1):\n            init.append(local_minima[z])\n    elif z == len(local_minima)-1:\n        if local_minima[z] != (local_minima[z-1]+1):\n            final_local.append(local_minima[z])\n        elif local_minima[z] == (local_minima[z-1]+1):\n            end.append(local_minima[z])\nfor j in range(len(init)):\n    mid = (init[j] + end[j])/2\n    if (mid % 1) != 0:\n        mid = mid+0.5\n    final_local.append(int(mid))\n\nfinal_local = sorted(final_local)\n\nno_of_lines = len(final_local) - 1\nlines_img = []\n\nfor i in range(no_of_lines):\n    lines_img.append(bin_img[final_local[i]:final_local[i+1], :])\n    cv2.imshow('img',bin_img[final_local[i]:final_local[i+1], :])\n    cv2.waitKey(0)\n"""
word.py,0,"b""from wordsegment import load, segment\n\nload()\nstring = 'TUTORIALSHEET#61.Aconfinedquiferis25mthickand2kmwide.Twoobservationwellslocated2kmapart' \\\n         'inthedirectionofflowindicatehydraulicheadof45and39.5m.Ifthecoefficientofpermeability' \\\n         'oftheaquiferis30m/day,calculate(i)totaldailyflowthroughtheaquifer,and(ii)piezometricheadatan' \\\n         'observationwelllocatedat300mfromtheupstreamwell.'\nprint(segment(string))"""
