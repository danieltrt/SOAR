file_path,api_count,code
cloudrun/main.py,2,"b""import os\nimport io\nimport json\nimport tempfile\nimport base64\nimport logging\nimport functools\nfrom urllib.parse import urlparse\n\nimport numpy as np\nimport requests\n\nfrom PIL import Image\nfrom joblib import Memory\nfrom flask import Flask, request\n\nimport firebase_admin\nfrom firebase_admin import credentials\nfrom firebase_admin import firestore\nfrom google.cloud import storage\n\nPROFILE_URL = os.environ['PROFILE_URL']\nGAMES_URL = os.environ['GAMES_URL']\nMEDIA_URL = os.environ['MEDIA_URL']\n\n# credentials.ApplicationDefault(), {'projectId': os.environ['GCP_PROJECT'],}\nfirebase_admin.initialize_app()\n\napp = Flask(__name__)\n\ndb = firebase_admin.firestore.client()\nmemory = Memory(tempfile.gettempdir(), verbose=0)\nsession = requests.Session()\nstorage_client = storage.Client()\nbucket = storage_client.get_bucket(os.environ['BUCKET'])\n\n\ndef get_steam_id(uid):\n  logging.info(f'fetching steam_id of the user {uid}')\n  try:\n    return int(uid)\n  except ValueError:\n    pass\n  response = session.get(PROFILE_URL.format(uid))\n  response.raise_for_status()\n  return response.json()['response']['steamid']\n\n\ndef get_games(sid):\n  response = session.get(GAMES_URL.format(sid))\n  response.raise_for_status()\n  result = response.json()['response']['games']\n  return sorted(result, key=lambda g: g['playtime_forever'], reverse=True)\n\n\n@memory.cache\ndef download(url):\n  try:\n    image = Image.open(\n      io.BytesIO(session.get(url).content))\n    return np.asarray(image.convert('RGB'))\n  except (OSError, IOError):\n    logging.warning(f'failed to download or invalid image at {url}')\n\n\ndef generate(array, columns=10):\n  length, height, width, intensity = array.shape\n  rows = length // columns\n  return Image.fromarray(\n    array.reshape(rows, columns, height, width, intensity)\n      .swapaxes(1, 2)\n      .reshape(height * rows, width * columns, intensity))\n\n\n@app.route('/', methods=['POST'])\ndef index():\n  message = request.get_json()['message']\n\n  data = json.loads(\n    base64.b64decode(message['data']).decode('utf-8'))\n  uid = data['uid']\n  reference = db.collection('users').document(uid)\n\n  try:\n    sid = str(get_steam_id(uid))\n    maximum = 8192\n    games = [n for n in get_games(sid) if n['img_logo_url']][:maximum]\n    build_url = lambda entry: MEDIA_URL.format(entry['appid'], entry['img_logo_url'])\n    fetch = lambda game: functools.reduce(lambda g, f: f(g), [build_url, download], game)\n    arr = np.array([g for g in map(fetch, games) if g is not None])\n  except (KeyError, requests.exceptions.HTTPError):\n    reference.set({'error': 'private profile or not found.'})\n    return ('', 204)\n\n  try:\n    buffer = io.BytesIO()\n    columns = 10\n    nearest = lambda x, n: x - (x % n)\n    limit = nearest(len(arr), columns)\n    generate(arr[:limit], columns).save(buffer, 'JPEG', quality=90)\n  except ValueError:\n    reference.set({'error': 'internal error or insufficient amount of games to generate the image.'})\n    return ('', 204)\n\n  filepath = f'{sid[-1:]}/{sid}.jpg'\n  blob = bucket.blob(filepath)\n  blob.upload_from_string(buffer.getvalue(), content_type='image/jpeg')\n  blob.make_public()\n  reference.set({'url': 'https://gcs.steamosaic.com/%s' % (filepath)})\n\n  return ('', 204)"""
