file_path,api_count,code
setup.py,0,"b'import sys\nfrom setuptools import setup, find_packages\nfrom setuptools.command.test import test as TestCommand\n\n__version__ = ""unknown""\n\n# ""import"" __version__\nfor line in open(""micarray/__init__.py""):\n    if line.startswith(""__version__""):\n        exec(line)\n        break\n\n\n# See http://pytest.org/latest/goodpractises.html\nclass PyTest(TestCommand):\n    user_options = [(\'pytest-args=\', \'a\', ""Arguments to pass to py.test"")]\n\n    def initialize_options(self):\n        TestCommand.initialize_options(self)\n        self.pytest_args = []\n\n    def finalize_options(self):\n        TestCommand.finalize_options(self)\n        self.test_args = []\n        self.test_suite = True\n\n    def run_tests(self):\n        # import here, cause outside the eggs aren\'t loaded\n        import pytest\n        errno = pytest.main(self.pytest_args)\n        sys.exit(errno)\n\n\nsetup(\n    name=""sfa-numpy"",\n    version=__version__,\n    packages=find_packages(),\n    install_requires=[\n        \'numpy!=1.11.0\',  # https://github.com/sfstoolbox/sfs-python/issues/11\n        \'scipy\',\n    ],\n\n    author=""SFA Toolbox Developers"",\n    author_email=""sfstoolbox@gmail.com"",\n    description=""Sound Field Analysis Toolbox"",\n    long_description=open(\'README.rst\').read(),\n    license=""MIT"",\n    keywords=""acoustics sound-field-analysis beamforming"".split(),\n    url=""https://github.com/spatialaudio/sfa-numpy"",\n    platforms=\'any\',\n    classifiers=[\n        ""Development Status :: 3 - Alpha"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: OS Independent"",\n        ""Programming Language :: Python"",\n        ""Topic :: Scientific/Engineering"",\n    ],\n\n    tests_require=[\'pytest\'],\n    cmdclass={\'test\': PyTest},\n    zip_safe=True,\n)\n'"
doc/conf.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# SFA documentation build configuration file, created by\n# sphinx-quickstart on Tue Nov  4 14:01:37 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\nfrom subprocess import check_output\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'..\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \'1.3\'  # for sphinx.ext.napoleon\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.mathjax\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.napoleon\',  # support for NumPy-style docstrings\n    \'sphinx.ext.intersphinx\',\n    \'matplotlib.sphinxext.plot_directive\',\n]\n\nautoclass_content = \'init\'\nautodoc_member_order = \'bysource\'\nautodoc_default_flags = [\'members\', \'undoc-members\']\n\nnapoleon_google_docstring = False\nnapoleon_numpy_docstring = True\nnapoleon_include_private_with_doc = False\nnapoleon_include_special_with_doc = False\nnapoleon_use_admonition_for_examples = False\nnapoleon_use_admonition_for_notes = False\nnapoleon_use_admonition_for_references = False\nnapoleon_use_ivar = False\nnapoleon_use_param = False\nnapoleon_use_rtype = False\n\nintersphinx_mapping = {\n    \'python\': (\'https://docs.python.org/3/\', None),\n    \'numpy\': (\'https://docs.scipy.org/doc/numpy/\', None),\n    \'scipy\': (\'https://docs.scipy.org/doc/scipy/reference/\', None),\n    \'matplotlib\': (\'http://matplotlib.org/\', None),\n}\n\nplot_include_source = True\nplot_html_show_source_link = False\nplot_html_show_formats = False\nplot_pre_code = """"\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix of source filenames.\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nauthors = \'SFA Toolbox Developers\'\nproject = \'Sound Field Analysis Toolbox\'\ncopyright = \'2017, \' + authors\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\n#version = \'0.0.0\'\n# The full version, including alpha/beta/rc tags.\ntry:\n    release = check_output([\'git\', \'describe\', \'--tags\', \'--always\'])\n    release = release.decode().strip()\nexcept Exception:\n    release = \'<unknown>\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\'_build\']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = \'any\'\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \'collapse_navigation\': False,\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\nhtml_title = project + "", version "" + release\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\nhtml_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'SFA\'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n\'papersize\': \'a4paper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n\n\'printindex\': \'\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [(\'index\', \'SFA.tex\', project, authors, \'howto\')]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\nlatex_show_urls = \'footnote\'\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\nlatex_domain_indices = False\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\n#man_pages = [(\'index\', \'sfs\', project, [authors], 1)]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\n#texinfo_documents = [\n#  (\'index\', \'SFS\', project, project, \'SFS\', \'Sound Field Synthesis Toolbox.\',\n#   \'Miscellaneous\'),\n#]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n\n\n# -- Options for epub output ----------------------------------------------\n\nepub_author = authors\n'"
examples/modal_beamforming_open_circular_array.py,11,"b'""""""\n    Compute the plane wave decomposition for an incident broadband plane wave\n    on an open circular array using a modal beamformer of finite order.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport micarray\nfrom micarray.util import db\n\nNsf = 50  # order of the incident sound field\nN = 30  # order of modal beamformer/microphone array\npw_angle = 1.23 * np.pi  # incidence angle of plane wave\npol_pwd = np.linspace(0, 2*np.pi, 180, endpoint=False)  # angles for plane wave decomposition\nk = np.linspace(0, 20, 100)  # wavenumber vector\nr = 1  # radius of array\n\n# get uniform grid (microphone positions) of order N\npol, weights = micarray.modal.angular.grid_equal_polar_angle(N)\n\n# pressure on the surface of an open cylinder for an incident plane wave\nBn = micarray.modal.radial.circular_pw(Nsf, k, r, setup=\'open\')\nD = micarray.modal.radial.circ_diagonal_mode_mat(Bn)\nPsi_p = micarray.modal.angular.cht_matrix(Nsf, pol)\nPsi_pw = micarray.modal.angular.cht_matrix(Nsf, pw_angle)\np = np.matmul(np.matmul(Psi_p, D), np.conj(Psi_pw.T))\np = np.squeeze(p)\n\n# incident plane wave exhibiting infinite spatial bandwidth\n# p = np.exp(1j * k[:, np.newaxis]*r * np.cos(pol - pw_angle))\n\n# plane wave decomposition using modal beamforming\nBn = micarray.modal.radial.circular_pw(N, k, r, setup=\'open\')\nDn, _ = micarray.modal.radial.regularize(1/Bn, 3000, \'softclip\')\nD = micarray.modal.radial.circ_diagonal_mode_mat(Dn)\nPsi_p = micarray.modal.angular.cht_matrix(N, pol, weights)\nPsi_q = micarray.modal.angular.cht_matrix(N, pol_pwd)\nA_pwd = np.matmul(np.matmul(Psi_q, D), np.conj(Psi_p.T))\nq_pwd = np.squeeze(np.matmul(A_pwd, np.expand_dims(p, 2)))\nq_pwd_t = np.fft.fftshift(np.fft.irfft(q_pwd, axis=0), axes=0)\n\n# visualize plane wave decomposition (aka beampattern)\nplt.figure()\nplt.pcolormesh(k, pol_pwd/np.pi, db(q_pwd.T), vmin=-40)\nplt.colorbar()\nplt.xlabel(r\'$kr$\')\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (frequency domain)\')\nplt.savefig(\'modal_beamforming_open_circular_array_fd.png\')\n\nplt.figure()\nplt.pcolormesh(range(2*len(k)-2), pol_pwd/np.pi, db(q_pwd_t.T), vmin=-40)\nplt.colorbar()\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (time domain)\')\nplt.savefig(\'modal_beamforming_open_circular_array_td.png\')\n'"
examples/modal_beamforming_open_spherical_array.py,13,"b'""""""\n    Compute the plane wave decomposition for an incident broadband plane wave\n    on an open spherical array using a modal beamformer of finite order.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport micarray\n\nN = 20  # order of modal beamformer/microphone array\npw_angle = (np.pi, np.pi/2)  # incidence angle of plane wave\nazi_pwd = np.linspace(0, 2*np.pi, 91, endpoint=False)  # angles for plane wave decomposition\nk = np.linspace(0, 20, 100)  # wavenumber vector\nr = 1  # radius of array\n\n\ndef dot_product_sph(v, u):\n    # evaluate dot-product between u and v in spherical coordinates\n    return (np.cos(v[0])*np.sin(v[1])*np.cos(u[0])*np.sin(u[1]) +\n            np.sin(v[0])*np.sin(v[1])*np.sin(u[0])*np.sin(u[1]) +\n            np.cos(v[1])*np.cos(u[1]))\n\n\n# get quadrature grid (microphone positions) of order N\nazi, colat, weights = micarray.modal.angular.grid_gauss(N)\n# get spherical harmonics matrix for sensors\nY_p = micarray.modal.angular.sht_matrix(N, azi, colat, weights)\n# get spherical harmonics matrix for a source ensemble of azimuthal plane waves\nY_q = micarray.modal.angular.sht_matrix(N, azi_pwd, np.pi/2)\n# get radial filters\nbn = micarray.modal.radial.spherical_pw(N, k, r, setup=\'open\')\ndn, _ = micarray.modal.radial.regularize(1/bn, 100, \'softclip\')\nD = micarray.modal.radial.diagonal_mode_mat(dn)\n\n# compute microphone signals for an incident broad-band plane wave\np = np.exp(1j * k[:, np.newaxis]*r * dot_product_sph((azi, colat), pw_angle))\n# compute the plane wave dcomposition\nA_pwd = np.matmul(np.matmul(Y_q, D), np.conj(Y_p.T))\nq_pwd = np.squeeze(np.matmul(A_pwd, np.expand_dims(p, 2)))\nq_pwd_t = np.fft.fftshift(np.fft.irfft(q_pwd, axis=0), axes=0)\n\n# visualize plane wave decomposition (aka beampattern)\nplt.figure()\nplt.pcolormesh(k, azi_pwd/np.pi, 20*np.log10(np.abs(q_pwd.T)), vmin=-40)\nplt.colorbar()\nplt.xlabel(r\'$kr$\')\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (frequency domain)\')\nplt.savefig(\'modal_beamforming_open_spherical_array_fd.png\')\n\nplt.figure()\nplt.pcolormesh(range(2*len(k)-2), azi_pwd/np.pi, 20*np.log10(np.abs(q_pwd_t.T)), vmin=-40)\nplt.colorbar()\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (time domain)\')\nplt.savefig(\'modal_beamforming_open_spherical_array_td.png\')\n'"
examples/modal_beamforming_rigid_circular_array.py,10,"b'""""""\n    Compute the plane wave decomposition for an incident broadband plane wave\n    on a rigid circular array using a modal beamformer of finite order.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport micarray\nfrom micarray.util import db\n\nNsf = 50  # order of the incident sound field\nN = 30  # order of modal beamformer/microphone array\npw_angle = 1 * np.pi  # incidence angle of plane wave\npol_pwd = np.linspace(0, 2*np.pi, 180, endpoint=False)  # angles for PWD\nk = np.linspace(0, 20, 100)  # wavenumber vector\nr = 1  # radius of array\n\n# get uniform grid (microphone positions) of order N\npol, weights = micarray.modal.angular.grid_equal_polar_angle(N)\n\n# pressure on the surface of a rigid cylinder for an incident plane wave\nBn = micarray.modal.radial.circular_pw(Nsf, k, r, setup=\'rigid\')\nD = micarray.modal.radial.circ_diagonal_mode_mat(Bn)\nPsi_p = micarray.modal.angular.cht_matrix(Nsf, pol)\nPsi_pw = micarray.modal.angular.cht_matrix(Nsf, pw_angle)\np = np.matmul(np.matmul(Psi_p, D), np.conj(Psi_pw.T))\np = np.squeeze(p)\n\n# plane wave decomposition using modal beamforming\nPsi_p = micarray.modal.angular.cht_matrix(N, pol, weights)\nPsi_q = micarray.modal.angular.cht_matrix(N, pol_pwd)\nBn = micarray.modal.radial.circular_pw(N, k, r, setup=\'rigid\')\nDn, _ = micarray.modal.radial.regularize(1/Bn, 100, \'softclip\')\nD = micarray.modal.radial.circ_diagonal_mode_mat(Dn)\nA_pwd = np.matmul(np.matmul(Psi_q, D), np.conj(Psi_p.T))\nq_pwd = np.squeeze(np.matmul(A_pwd, np.expand_dims(p, 2)))\nq_pwd_t = np.fft.fftshift(np.fft.irfft(q_pwd, axis=0), axes=0)\n\n# visualize plane wave decomposition (aka beampattern)\nplt.figure()\nplt.pcolormesh(k, pol_pwd/np.pi, db(q_pwd.T), vmin=-40)\nplt.colorbar()\nplt.xlabel(r\'$kr$\')\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (frequency domain)\')\nplt.savefig(\'modal_beamforming_rigid_circular_array_fd.png\')\n\nplt.figure()\nplt.pcolormesh(range(2*len(k)-2), pol_pwd/np.pi, db(q_pwd_t.T), vmin=-40)\nplt.colorbar()\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (time domain)\')\nplt.savefig(\'modal_beamforming_rigid_circular_array_td.png\')\n'"
examples/modal_beamforming_rigid_spherical_array.py,13,"b'""""""\n    Compute the plane wave decomposition for an incident broadband plane wave\n    on an rigid spherical array using a modal beamformer of finite order.\n""""""\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport micarray\n\nN = 20  # order of modal beamformer/microphone array\nazi_pw = np.pi  # incidence angle of plane wave\nazi_pwd = np.linspace(0, 2*np.pi, 91, endpoint=False)  # angles for plane wave decomposition\nk = np.linspace(0, 20, 100)  # wavenumber\nr = 1  # radius of array\n\n\n# get quadrature grid (microphone positions) of order N\nazi, colat, weights = micarray.modal.angular.grid_gauss(N)\n\n# pressure on the surface of a rigid sphere for an incident plane wave\nbn = micarray.modal.radial.spherical_pw(N, k, r, setup=\'rigid\')\nD = micarray.modal.radial.diagonal_mode_mat(bn)\nY_p = micarray.modal.angular.sht_matrix(N, azi, colat)\nY_pw = micarray.modal.angular.sht_matrix(N, azi_pw, np.pi/2)\np = np.matmul(np.matmul(Y_p, D), np.conj(Y_pw.T))\np = np.squeeze(p)\n\n# plane wave decomposition using modal beamforming\nY_p = micarray.modal.angular.sht_matrix(N, azi, colat, weights)\n# get SHT matrix for a source ensemble of azimuthal plane waves\nazi_pwd = np.linspace(0, 2*np.pi, 91, endpoint=False)\nY_q = micarray.modal.angular.sht_matrix(N, azi_pwd, np.pi/2)\n# get radial filters\nbn = micarray.modal.radial.spherical_pw(N, k, r, setup=\'rigid\')\ndn, _ = micarray.modal.radial.regularize(1/bn, 100, \'softclip\')\nD = micarray.modal.radial.diagonal_mode_mat(dn)\n# compute the PWD\nA_mb = np.matmul(np.matmul(Y_q, D), np.conj(Y_p.T))\nq_mb = np.squeeze(np.matmul(A_mb, np.expand_dims(p, 2)))\nq_mb_t = np.fft.fftshift(np.fft.irfft(q_mb, axis=0), axes=0)\n\n\n# visualize plane wave decomposition (aka beampattern)\nplt.figure()\nplt.pcolormesh(k*r, azi_pwd/np.pi, 20*np.log10(np.abs(q_mb.T)), vmin=-40)\nplt.colorbar()\nplt.xlabel(r\'$kr$\')\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (frequency domain)\')\nplt.savefig(\'modal_beamforming_rigid_spherical_array_fd.png\')\n\nplt.figure()\nplt.pcolormesh(range(2*len(k)-2), azi_pwd/np.pi, 20*np.log10(np.abs(q_mb_t.T)), vmin=-40)\nplt.colorbar()\nplt.ylabel(r\'$\\phi / \\pi$\')\nplt.title(\'Plane wave docomposition by modal beamformer (time domain)\')\nplt.savefig(\'modal_beamforming_rigid_spherical_array_td.png\')\n'"
micarray/__init__.py,0,"b'""""""Sound Field Analysis Toolbox.\n""""""\n__version__ = ""0.0.1""\n\nfrom . import modal\nfrom . import util\n'"
micarray/util.py,9,"b'import numpy as np\nfrom scipy import linalg\n\n\ndef norm_of_columns(A, p=2):\n    """"""Vector p-norm of each column of a matrix.\n\n    Parameters\n    ----------\n    A : array_like\n        Input matrix.\n    p : int, optional\n        p-th norm.\n\n    Returns\n    -------\n    array_like\n        p-norm of each column of A.\n    """"""\n    _, N = A.shape\n    return np.asarray([linalg.norm(A[:, j], ord=p) for j in range(N)])\n\n\ndef coherence_of_columns(A):\n    """"""Mutual coherence of columns of A.\n\n    Parameters\n    ----------\n    A : array_like\n        Input matrix.\n    p : int, optional\n        p-th norm.\n\n    Returns\n    -------\n    array_like\n        Mutual coherence of columns of A.\n    """"""\n    A = np.asmatrix(A)\n    _, N = A.shape\n    A = A * np.asmatrix(np.diag(1/norm_of_columns(A)))\n    Gram_A = A.H*A\n    for j in range(N):\n        Gram_A[j, j] = 0\n    return np.max(np.abs(Gram_A))\n\n\ndef asarray_1d(a, **kwargs):\n    """"""Squeeze the input and check if the result is one-dimensional.\n\n    Returns *a* converted to a `numpy.ndarray` and stripped of\n    all singleton dimensions.  Scalars are ""upgraded"" to 1D arrays.\n    The result must have exactly one dimension.\n    If not, an error is raised.\n\n    """"""\n    result = np.squeeze(np.asarray(a, **kwargs))\n    if result.ndim == 0:\n        result = result.reshape((1,))\n    elif result.ndim > 1:\n        raise ValueError(""array must be one-dimensional"")\n    return result\n\n\ndef matdiagmul(A, b):\n    """"""Efficient multiplication of  matrix and diagonal matrix .\n\n    Returns the multiplication of a matrix *A* and a diagonal matrix. The\n    diagonal matrix is given by the vector *b* containing its elements on\n    the main diagonal.  If *b* is a matrix, it is treated as a stack of vectors\n    residing in the last index and broadcast accordingly.\n\n    Parameters\n    ----------\n    A : array_like\n        Input matrix.\n    b : array_like\n        Main diagonal elements or stack of main diagonal elements.\n\n    Returns\n    -------\n    array_like\n        Result of matrix multiplication.\n    """"""\n    if len(b.shape) == 1:\n        b = b[np.newaxis, :]\n    K, N = b.shape\n    M, N = A.shape\n\n    C = np.zeros([K, M, N], dtype=A.dtype)\n    for k in range(K):\n        C[k, :, :] = A * b[k, :]\n    return C\n\n\ndef db(x, power=False):\n    """"""Convert *x* to decibel.\n\n    Parameters\n    ----------\n    x : array_like\n        Input data.  Values of 0 lead to negative infinity.\n    power : bool, optional\n        If ``power=False`` (the default), *x* is squared before\n        conversion.\n\n    """"""\n    with np.errstate(divide=\'ignore\'):\n        return 10 if power else 20 * np.log10(np.abs(x))\n'"
micarray/modal/__init__.py,0,"b'""""""\nSubmodules for modal beamforming\n""""""\n\nfrom . import angular\nfrom . import radial\n'"
micarray/modal/angular.py,27,"b'from __future__ import division\nimport numpy as np\nfrom scipy import special\nfrom .. import util\nfrom warnings import warn\ntry:\n    import quadpy  # only for grid_lebedev()\nexcept ImportError:\n    pass\n\n\ndef sht_matrix(N, azi, colat, weights=None):\n    r""""""Matrix of spherical harmonics up to order N for given angles.\n\n    Computes a matrix of spherical harmonics up to order :math:`N`\n    for the given angles/grid.\n\n    .. math::\n\n        \\mathbf{Y} = \\left[ \\begin{array}{cccccc}\n        Y_0^0(\\theta[0], \\phi[0]) & Y_1^{-1}(\\theta[0], \\phi[0]) & Y_1^0(\\theta[0], \\phi[0]) & Y_1^1(\\theta[0], \\phi[0]) & \\dots & Y_N^N(\\theta[0], \\phi[0])  \\\\\n        Y_0^0(\\theta[1], \\phi[1]) & Y_1^{-1}(\\theta[1], \\phi[1]) & Y_1^0(\\theta[1], \\phi[1]) & Y_1^1(\\theta[1], \\phi[1]) & \\dots & Y_N^N(\\theta[1], \\phi[1])  \\\\\n        \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n        Y_0^0(\\theta[Q-1], \\phi[Q-1]) & Y_1^{-1}(\\theta[Q-1], \\phi[Q-1]) & Y_1^0(\\theta[Q-1], \\phi[Q-1]) & Y_1^1(\\theta[Q-1], \\phi[Q-1]) & \\dots & Y_N^N(\\theta[Q-1], \\phi[Q-1])\n        \\end{array} \\right]\n\n    where\n\n    .. math::\n\n        Y_n^m(\\theta, \\phi) = \\sqrt{\\frac{2n + 1}{4 \\pi} \\frac{(n-m)!}{(n+m)!}} P_n^m(\\cos \\theta) e^{i m \\phi}\n\n\n    (Note: :math:`\\mathbf{Y}` is interpreted as the inverse transform (or synthesis)\n    matrix in examples and documentation.)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    azi : (Q,) array_like\n        Azimuth.\n    colat : (Q,) array_like\n        Colatitude.\n    weights : (Q,) array_like, optional\n        Quadrature weights.\n\n    Returns\n    -------\n    Ymn : (Q, (N+1)**2) numpy.ndarray\n        Matrix of spherical harmonics.\n\n    """"""\n    azi = util.asarray_1d(azi)\n    colat = util.asarray_1d(colat)\n    if azi.ndim == 0:\n        Q = 1\n    else:\n        Q = len(azi)\n    if weights is None:\n        weights = np.ones(Q)\n    Ymn = np.zeros([Q, (N+1)**2], dtype=complex)\n    i = 0\n    for n in range(N+1):\n        for m in range(-n, n+1):\n            Ymn[:, i] = weights * special.sph_harm(m, n, azi, colat)\n            i += 1\n    return Ymn\n\n\ndef Legendre_matrix(N, ctheta):\n    r""""""Matrix of weighted Legendre Polynominals.\n\n    Computes a matrix of weighted Legendre polynominals up to order N for\n    the given angles\n\n    .. math::\n\n        L_n(\\theta) = \\frac{2n+1}{4 \\pi} P_n(\\theta)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    ctheta : (Q,) array_like\n        Angles.\n\n    Returns\n    -------\n    Lmn : ((N+1), Q) numpy.ndarray\n        Matrix containing Legendre polynominals.\n    """"""\n    if ctheta.ndim == 0:\n        M = 1\n    else:\n        M = len(ctheta)\n    Lmn = np.zeros([N+1, M], dtype=complex)\n    for n in range(N+1):\n        Lmn[n, :] = (2*n+1)/(4*np.pi) * np.polyval(special.legendre(n), ctheta)\n\n    return Lmn\n\n\ndef cht_matrix(N, pol, weights=None):\n    r""""""Matrix of circular harmonics up to order N for given angles.\n\n    Computes a matrix of circular harmonics up to order :math:`N`\n    for the given angles/grid.\n\n    .. math::\n        \\Psi = \\left[ \\begin{array}{ccccccc}\n        1 & e^{i\\varphi[0]} & \\cdots & e^{iN\\varphi[0]} & e^{-iN\\varphi[0]} & \\cdots & e^{-i\\varphi[0]} \\\\\n        1 & e^{i\\varphi[1]} & \\cdots & e^{iN\\varphi[1]} & e^{-iN\\varphi[1]} & \\cdots & e^{-i\\varphi[1]} \\\\\n        \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n        1 & e^{i\\varphi[Q-1]} & \\cdots & e^{iN\\varphi[Q-1]} & e^{-iN\\varphi[Q-1]} & \\cdots & e^{-i\\varphi[Q-1]}\n        \\end{array} \\right]\n\n    (Note: :math:`\\Psi` is interpreted as the inverse transform (or synthesis)\n    matrix in examples and documentation.)\n\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    pol : (Q,) array_like\n        Polar angle.\n    weights : (Q,) array_like, optional\n        Weights.\n\n    Returns\n    -------\n    Psi : (Q, 2N+1) numpy.ndarray\n        Matrix of circular harmonics.\n\n    """"""\n    pol = util.asarray_1d(pol)\n    if pol.ndim == 0:\n        Q = 1\n    else:\n        Q = len(pol)\n    if weights is None:\n        weights = np.ones(Q)\n    Psi = np.zeros([Q, (2*N+1)], dtype=complex)\n    order = np.roll(np.arange(-N, N+1), -N)\n    for i, n in enumerate(order):\n        Psi[:, i] = weights * np.exp(1j * n * pol)\n    return Psi\n\n\ndef grid_equal_angle(n):\n    """"""Equi-angular sampling points on a sphere.\n\n    According to (cf. Rafaely book, sec.3.2)\n\n    Parameters\n    ----------\n    n : int\n        Maximum order.\n\n    Returns\n    -------\n    azi : array_like\n        Azimuth.\n    colat : array_like\n        Colatitude.\n    weights : array_like\n        Quadrature weights.\n    """"""\n    azi = np.linspace(0, 2*np.pi, 2*n+2, endpoint=False)\n    colat, d_colat = np.linspace(0, np.pi, 2*n+2, endpoint=False, retstep=True)\n    colat += d_colat/2\n\n    weights = np.zeros_like(colat)\n    p = np.arange(1, 2*n+2, 2)\n    for i, theta in enumerate(colat):\n        weights[i] = 2*np.pi/(n+1) * np.sin(theta) * np.sum(np.sin(p*theta)/p)\n\n    azi = np.tile(azi, 2*n+2)\n    colat = np.repeat(colat, 2*n+2)\n    weights = np.repeat(weights, 2*n+2)\n    weights /= n+1     # sum(weights) == 4pi\n    return azi, colat, weights\n\n\ndef grid_gauss(n):\n    """""" Gauss-Legendre sampling points on sphere.\n\n    According to (cf. Rafaely book, sec.3.3)\n\n    Parameters\n    ----------\n    n : int\n        Maximum order.\n\n    Returns\n    -------\n    azi : array_like\n        Azimuth.\n    colat : array_like\n        Colatitude.\n    weights : array_like\n        Quadrature weights.\n    """"""\n    azi = np.linspace(0, 2*np.pi, 2*n+2, endpoint=False)\n    x, weights = np.polynomial.legendre.leggauss(n+1)\n    colat = np.arccos(x)\n    azi = np.tile(azi, n+1)\n    colat = np.repeat(colat, 2*n+2)\n    weights = np.repeat(weights, 2*n+2)\n    weights *= np.pi / (n+1)      # sum(weights) == 4pi\n    return azi, colat, weights\n\n\ndef grid_equal_polar_angle(n):\n    """"""Equi-angular sampling points on a circle.\n\n    Parameters\n    ----------\n    n : int\n        Maximum order\n\n    Returns\n    -------\n    pol : array_like\n        Polar angle.\n    weights : array_like\n        Weights.\n    """"""\n    num_mic = 2*n+1\n    pol = np.linspace(0, 2*np.pi, num=num_mic, endpoint=False)\n    weights = 1/num_mic * np.ones(num_mic)\n    return pol, weights\n\n\ndef grid_lebedev(n):\n    """"""Lebedev sampling points on sphere.\n\n    (Maximum n is 65. We use what is available in quadpy, some n may not be\n    tight, others produce negative weights.\n\n    Parameters\n    ----------\n    n : int\n        Maximum order.\n\n    Returns\n    -------\n    azi : array_like\n        Azimuth.\n    colat : array_like\n        Colatitude.\n    weights : array_like\n        Quadrature weights.\n\n    """"""\n    def available_quadrature(d):\n        """"""Get smallest availabe quadrature of of degree d.\n\n        see:\n        https://people.sc.fsu.edu/~jburkardt/datasets/sphere_lebedev_rule/sphere_lebedev_rule.html\n        """"""\n        l = list(range(1, 32, 2)) + list(range(35, 132, 6))\n        matches = [x for x in l if x >= d]\n        return matches[0]\n\n    if n > 65:\n        raise ValueError(""Maximum available Lebedev grid order is 65. ""\n                         ""(requested: {})"".format(n))\n\n    # this needs https://pypi.python.org/pypi/quadpy\n    q = quadpy.sphere.Lebedev(degree=available_quadrature(2*n))\n    if np.any(q.weights < 0):\n        warn(""Lebedev grid of order {} has negative weights."".format(n))\n    azi = q.azimuthal_polar[:, 0]\n    colat = q.azimuthal_polar[:, 1]\n    return azi, colat, 4*np.pi*q.weights\n'"
micarray/modal/radial.py,49,"b'from __future__ import division\nimport numpy as np\nfrom scipy import special\nfrom .. import util\nfrom functools import wraps\nfrom warnings import warn\n\n\ndef _replace_zeros_of_radial_function_decorator(f):\n    """"""Apply replace_zeros_of_radial_function() to output of function f.\n\n    Also add argument flag \'replace_zeros\' to f.\n\n    CAVEAT:\n    replace_zeros_of_radial_function() needs wavenumbers k or kr.\n    These are taken from argument list of f,  either by key or using the 2nd\n    positional argument !\n    """"""\n    @wraps(f)\n    def wrapper(*args, replace_zeros=True, **kwargs):\n        if \'kr\' in kwargs:\n            kr = kwargs[\'kr\']\n        elif \'k\' in kwargs:\n            # The exact values in kr do not matter, only order is important.\n            # So it\'s okay to use k instead.\n            kr = kwargs[\'k\']\n        else:\n            kr = args[1]  # ATTENTION: hinges on positional argument order!\n        if replace_zeros:\n            return replace_zeros_of_radial_function(f(*args, **kwargs), kr)\n        else:\n            return f(*args, **kwargs)\n    return wrapper\n\n\n@_replace_zeros_of_radial_function_decorator\ndef spherical_pw(N, k, r, setup):\n    r""""""Radial coefficients for a plane wave.\n\n    Computes the radial component of the spherical harmonics expansion of a\n    plane wave impinging on a spherical array.\n\n    .. math::\n\n        \\mathring{P}_n(k) = 4 \\pi i^n b_n(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    k : (M,) array_like\n        Wavenumber.\n    r : float\n        Radius of microphone array.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n    """"""\n    kr = util.asarray_1d(k*r)\n    n = np.arange(N+1)\n\n    bn = weights(N, kr, setup)\n    return 4*np.pi * (1j)**n * bn\n\n\n@_replace_zeros_of_radial_function_decorator\ndef spherical_ps(N, k, r, rs, setup):\n    r""""""Radial coefficients for a point source.\n\n    Computes the radial component of the spherical harmonics expansion of a\n    point source impinging on a spherical array.\n\n    .. math::\n\n        \\mathring{P}_n(k) = 4 \\pi (-i) k h_n^{(2)}(k r_s) b_n(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    k : (M,) array_like\n        Wavenumber.\n    r : float\n        Radius of microphone array.\n    rs : float\n        Distance of source.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n    """"""\n    k = util.asarray_1d(k)\n    krs = k*rs\n    n = np.arange(N+1)\n\n    bn = weights(N, k*r, setup)\n    if len(k) == 1:\n        bn = bn[np.newaxis, :]\n\n    for i, x in enumerate(krs):\n        hn = special.spherical_jn(n, x) - 1j * special.spherical_yn(n, x)\n        bn[i, :] = bn[i, :] * 4*np.pi * (-1j) * hn * k[i]\n\n    return np.squeeze(bn)\n\n\ndef weights(N, kr, setup):\n    r""""""Radial weighing functions.\n\n    Computes the radial weighting functions for diferent array types\n    (cf. eq.(2.62), Rafaely 2015).\n\n    For instance for an rigid array\n\n    .. math::\n\n        b_n(kr) = j_n(kr) - \\frac{j_n^\\prime(kr)}{h_n^{(2)\\prime}(kr)}h_n^{(2)}(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    kr : (M,) array_like\n        Wavenumber * radius.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n\n    """"""\n    kr = util.asarray_1d(kr)\n    n = np.arange(N+1)\n    bns = np.zeros((len(kr), N+1), dtype=complex)\n    for i, x in enumerate(kr):\n        jn = special.spherical_jn(n, x)\n        if setup == \'open\':\n            bn = jn\n        elif setup == \'card\':\n            bn = jn - 1j * special.spherical_jn(n, x, derivative=True)\n        elif setup == \'rigid\':\n            if x == 0:\n                # hn(x)/hn\'(x) -> 0 for x -> 0\n                bn = jn\n            else:\n                jnd = special.spherical_jn(n, x, derivative=True)\n                hn = jn - 1j * special.spherical_yn(n, x)\n                hnd = jnd - 1j * special.spherical_yn(n, x, derivative=True)\n                bn = jn - jnd/hnd*hn\n        else:\n            raise ValueError(\'setup must be either: open, card or rigid\')\n        bns[i, :] = bn\n    return np.squeeze(bns)\n\n\ndef replace_zeros_of_radial_function(A, kr):\n    """"""\n    Replace zero entries A[i, j] == 0 with A[l, j] != 0.\n\n    where kr[l] is (the wavenumber) nearest to kr[i].\n\n    (This function may be used to fix ""forbidden frequencies"" in radial\n    filters before inversion.)\n\n    Parameters\n    ----------\n    A : (K, N) ndarray\n    kr : (K,) array_like\n\n    Returns\n    -------\n    (K, N) ndarray\n\n    """"""\n    kr = util.asarray_1d(kr)\n\n    if len(A.shape) == 1 and A.shape[0] == len(kr):\n        # single column (mode) is fine.\n        A = A[:, np.newaxis]\n    elif len(A.shape) == 1 and len(kr) == 1:\n        # single wavenumber is also fine.\n        A = A[np.newaxis, :]\n    if A.shape[0] != len(kr):\n        raise ValueError(""A and kr must have same len > 1,""\n                         "" but have {} and {}"".format(A.shape[0], len(kr)))\n\n    kr, idx, inv_idx = np.unique(kr, True, True)\n    A = A[idx, :]\n    zeros = np.abs(A) < 1e-300\n\n    for i, j in zip(*np.where(zeros)):\n        # for each zero value...\n        kr_tmp = kr.astype(float)\n        l = i\n        while zeros[l, j]:\n            # ...try to find replacement value\n            kr_tmp[l] = np.inf\n            l = np.argmin(np.abs(kr_tmp - kr[i]))\n            if np.isinf(kr_tmp[l]):\n                raise ValueError(""Could not replace zero value in A."")\n        A[i, j] = A[l, j]\n\n    A = A[inv_idx, :]\n    return np.squeeze(A)\n\n\ndef regularize(dn, a0, method):\n    """"""Regularization (amplitude limitation) of radial filters.\n\n    Amplitude limitation of radial filter coefficients, methods according\n    to (cf. Rettberg, Spors : DAGA 2014)\n\n    Parameters\n    ----------\n    dn : numpy.ndarray\n        Values to be regularized\n    a0 : float\n        Parameter for regularization (not required for all methods)\n    method : {\'none\', \'discard\', \'softclip\', \'Tikh\', \'wng\'}\n        Method used for regularization/amplitude limitation\n        (none, discard, hardclip, Tikhonov, White Noise Gain).\n\n    Returns\n    -------\n    dn : numpy.ndarray\n        Regularized values.\n    hn : array_like\n\n    """"""\n\n    idx = np.abs(dn) > a0\n\n    if method == \'none\':\n        hn = np.ones_like(dn)\n    elif method == \'discard\':\n        hn = np.ones_like(dn)\n        hn[idx] = 0\n    elif method == \'hardclip\':\n        hn = np.ones_like(dn)\n        hn[idx] = a0 / np.abs(dn[idx])\n    elif method == \'softclip\':\n        scaling = np.pi / 2\n        hn = a0 / abs(dn)\n        hn = 2 / np.pi * np.arctan(scaling * hn)\n    elif method == \'Tikh\':\n        a0 = np.sqrt(a0 / 2)\n        alpha = (1 - np.sqrt(1 - 1/(a0**2))) / (1 + np.sqrt(1 - 1/(a0**2)))\n        hn = 1 / (1 + alpha**2 * np.abs(dn)**2)\n#        hn = 1 / (1 + alpha**2 * np.abs(dn))\n    elif method == \'wng\':\n        hn = 1/(np.abs(dn)**2)\n#        hn = hn/np.max(hn)\n    else:\n        raise ValueError(\'method must be either: none, \' +\n                         \'discard, hardclip, softclip, Tikh or wng\')\n    dn = dn * hn\n    return dn, hn\n\n\ndef diagonal_mode_mat(bk):\n    """"""Diagonal matrix of radial coefficients for all modes/wavenumbers.\n\n    Parameters\n    ----------\n    bk : (M, N+1) numpy.ndarray\n        Vector containing values for all wavenumbers :math:`M` and modes up to\n        order :math:`N`\n\n    Returns\n    -------\n    Bk : (M, (N+1)**2, (N+1)**2) numpy.ndarray\n        Multidimensional array containing diagnonal matrices with input\n        vector on main diagonal.\n    """"""\n    bk = repeat_n_m(bk)\n    if len(bk.shape) == 1:\n        bk = bk[np.newaxis, :]\n    K, N = bk.shape\n    Bk = np.zeros([K, N, N], dtype=complex)\n    for k in range(K):\n        Bk[k, :, :] = np.diag(bk[k, :])\n    return np.squeeze(Bk)\n\n\ndef repeat_n_m(v):\n    """"""Repeat elements in a vector .\n\n    Returns a vector with the elements of the vector *v* repeated *n* times,\n    where *n* denotes the position of the element in *v*. The function can\n    be used to order the coefficients in the vector according to the order of\n    spherical harmonics. If *v* is a matrix, it is treated as a stack of\n    vectors residing in the last index and broadcast accordingly.\n\n    Parameters\n    ----------\n    v : (,N+1) numpy.ndarray\n        Input vector or stack of input vectors.\n\n    Returns\n    -------\n     : (,(N+1)**2) numpy.ndarray\n        Vector or stack of vectors containing repetated values.\n    """"""\n    krlist = [np.tile(v, (2*i+1, 1)).T for i, v in enumerate(v.T.tolist())]\n    return np.squeeze(np.concatenate(krlist, axis=-1))\n\n\n@_replace_zeros_of_radial_function_decorator\ndef circular_pw(N, k, r, setup):\n    r""""""Radial coefficients for a plane wave.\n\n    Computes the radial component of the circular harmonics expansion of a\n    plane wave impinging on a circular array.\n\n    .. math::\n\n        \\mathring{P}_n(k) = i^n b_n(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    k : (M,) array_like\n        Wavenumber.\n    r : float\n        Radius of microphone array.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, 2*N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n    """"""\n    kr = util.asarray_1d(k*r)\n    n = np.roll(np.arange(-N, N+1), -N)\n\n    bn = circ_radial_weights(N, kr, setup)\n    return 1j**n * bn\n\n\n@_replace_zeros_of_radial_function_decorator\ndef circular_ls(N, k, r, rs, setup):\n    r""""""Radial coefficients for a line source.\n\n    Computes the radial component of the circular harmonics expansion of a\n    line source impinging on a circular array.\n\n    .. math::\n\n        \\mathring{P}_n(k) = \\frac{-i}{4} H_n^{(2)}(k r_s) b_n(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    k : (M,) array_like\n        Wavenumber.\n    r : float\n        Radius of microphone array.\n    rs : float\n        Distance of source.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, 2*N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n    """"""\n    k = util.asarray_1d(k)\n    krs = k*rs\n    n = np.roll(np.arange(-N, N+1), -N)\n\n    bn = circ_radial_weights(N, k*r, setup)\n    if len(k) == 1:\n        bn = bn[np.newaxis, :]\n    for i, x in enumerate(krs):\n        Hn = special.hankel2(n, x)\n        bn[i, :] = bn[i, :] * Hn\n    return -1j/4 * np.squeeze(bn)\n\n\ndef circ_radial_weights(N, kr, setup):\n    r""""""Radial weighing functions.\n\n    Computes the radial weighting functions for diferent array types\n\n    For instance for an rigid array\n\n    .. math::\n\n        b_n(kr) = J_n(kr) - \\frac{J_n^\\prime(kr)}{H_n^{(2)\\prime}(kr)}H_n^{(2)}(kr)\n\n    Parameters\n    ----------\n    N : int\n        Maximum order.\n    kr : (M,) array_like\n        Wavenumber * radius.\n    setup : {\'open\', \'card\', \'rigid\'}\n        Array configuration (open, cardioids, rigid).\n\n    Returns\n    -------\n    bn : (M, 2*N+1) numpy.ndarray\n        Radial weights for all orders up to N and the given wavenumbers.\n\n    """"""\n    kr = util.asarray_1d(kr)\n    n = np.arange(N+1)\n    Bns = np.zeros((len(kr), N+1), dtype=complex)\n    for i, x in enumerate(kr):\n        Jn = special.jv(n, x)\n        if setup == \'open\':\n            bn = Jn\n        elif setup == \'card\':\n            bn = Jn - 1j * special.jvp(n, x, n=1)\n        elif setup == \'rigid\':\n            if x == 0:\n                # Hn(x)/Hn\'(x) -> 0 for x -> 0\n                bn = Jn\n            else:\n                Jnd = special.jvp(n, x, n=1)\n                Hn = special.hankel2(n, x)\n                Hnd = special.h2vp(n, x)\n                bn = Jn - Jnd/Hnd*Hn\n        else:\n            raise ValueError(\'setup must be either: open, card or rigid\')\n        Bns[i, :] = bn\n    Bns = np.concatenate((Bns, (Bns*(-1)**np.arange(N+1))[:, :0:-1]), axis=-1)\n    return np.squeeze(Bns)\n\n\ndef circ_diagonal_mode_mat(bk):\n    """"""Diagonal matrix of radial coefficients for all modes/wavenumbers.\n\n    Parameters\n    ----------\n    bk : (M, N+1) numpy.ndarray\n        Vector containing values for all wavenumbers :math:`M` and modes up to\n        order :math:`N`\n\n    Returns\n    -------\n    Bk : (M, 2*N+1, 2*N+1) numpy.ndarray\n        Multidimensional array containing diagnonal matrices with input\n        vector on main diagonal.\n    """"""\n    if len(bk.shape) == 1:\n        bk = bk[np.newaxis, :]\n    K, N = bk.shape\n    Bk = np.zeros([K, N, N], dtype=complex)\n    for k in range(K):\n        Bk[k, :, :] = np.diag(bk[k, :])\n    return np.squeeze(Bk)\n'"
