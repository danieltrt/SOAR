file_path,api_count,code
setup.py,0,"b""from setuptools import setup, find_packages\nfrom os import path\nfrom io import open\n\nhere = path.abspath(path.dirname(__file__))\n\nwith open(path.join(here, 'README.md'), encoding='utf-8') as f:\n    long_description = f.read()\n\nwith open(path.join(here, 'sspipe', 'version.py')) as f:\n    exec(f.read())\n    \nsetup(\n    name='sspipe',\n    version=__version__,\n    description='Simple Smart Pipe Operator',\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    url='https://sspipe.github.io/',\n    project_urls={\n        'Source': 'https://github.com/sspipe/sspipe',\n    },\n    author='Mohammad Hossein Sekhavat',\n    author_email='sekhavat17@gmail.com',\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Intended Audience :: Developers',\n        'Topic :: Software Development :: Build Tools',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: Python :: 3',\n    ],\n    keywords='pipe helper tool magrittr data science',\n    packages=find_packages(exclude=[]),\n    extras_require={\n        'dev': ['check-manifest'],\n        'test': ['coverage'],\n    },\n    install_requires=[\n        'pipe==1.5.0',\n    ]\n)\n"""
sspipe/__init__.py,0,"b'from .facade import p, px\nfrom .version import __version__\nfrom .patch import patch_all\nfrom .pipe import Pipe\n\nunpipe = Pipe.unpipe\n\npatch_all()\ndel patch_all\n'"
sspipe/compatibility.py,0,"b'import functools\nfrom sspipe.pipe import Pipe\n\n\ndef convert_pipe(original_pipe):\n    @functools.wraps(original_pipe)\n    def method(self, *args, **kwargs):\n        args = (Pipe.unpipe(arg) if isinstance(arg, Pipe) else arg for arg in args)\n        kwargs = {k: Pipe.unpipe(v) if isinstance(v, Pipe) else v for k, v in kwargs.items()}\n        return Pipe(original_pipe(*args, **kwargs).function)\n\n    return method\n'"
sspipe/facade.py,0,"b'from __future__ import absolute_import\nimport pipe\nfrom sspipe.compatibility import convert_pipe\nfrom sspipe.pipe import Pipe\n\n\nclass Facade():\n    def __call__(self, func, *args, **kwargs):\n        """"""\n        >>> from sspipe import p\n        >>> 1 | p(\'{}\'.format)\n        \'1\'\n        >>> 1 | p(\'{}{}\'.format, 2)\n        \'12\'\n        >>> 1 | p(\'{}{}{x}\'.format, 2, x=3)\n        \'123\'\n        """"""\n        if isinstance(func, (list, tuple, dict, set)):\n            if args or kwargs:\n                raise RuntimeError(\'You should pass no extra args to Pipe if its first input is list or tuple\')\n            return Pipe.collection(func)\n        if not args and not kwargs:\n            return Pipe(func)\n        elif func in (map, filter):\n            if len(args) == 1:\n                f, x = args[0], px\n            elif len(args) == 2:\n                f, x = args\n            else:\n                raise RuntimeError(\'You should pass only one function/pipe to p(map) and p(filter)\')\n            if kwargs:\n                raise RuntimeError(\'You should pass no kwargs to p(map) and p(filter)\')\n            return Pipe.partial(func, Pipe.unpipe(f), x)\n        elif any(\n            isinstance(arg, Pipe) for arg in args\n        ) or any(\n            isinstance(arg, Pipe) for arg in kwargs.values()\n        ) or isinstance(func, Pipe):\n            return Pipe.partial(func, *args, **kwargs)\n        else:\n            return Pipe(lambda x: func(x, *args, **kwargs))\n\n\nfor helper in pipe.__all__:\n    if helper != \'Pipe\':\n        setattr(Facade, helper, convert_pipe(getattr(pipe, helper)))\n\np = Facade()\npx = Pipe(lambda x: x)\n'"
sspipe/patch.py,0,"b""import functools\n\nfrom sspipe.pipe import Pipe\n\n\ndef _patch_cls_method(cls, method):\n    original = getattr(cls, method)\n\n    @functools.wraps(original)\n    def wrapper(self, x, *args, **kwargs):\n        if isinstance(x, Pipe):\n            return NotImplemented\n        return original(self, x, *args, **kwargs)\n\n    setattr(cls, method, wrapper)\n\n\ndef patch_cls_operator(cls):\n    _patch_cls_method(cls, '__or__')\n    if hasattr(cls, '__ior__'):\n        _patch_cls_method(cls, '__ior__')\n\n\ndef patch_all():\n    try:\n        import pandas\n\n        patch_cls_operator(pandas.Series)\n        patch_cls_operator(pandas.DataFrame)\n        patch_cls_operator(pandas.Index)\n    except ImportError:\n        pass\n\n    try:\n        import torch\n\n        patch_cls_operator(torch.Tensor)\n    except ImportError:\n        pass\n"""
sspipe/pipe.py,0,"b'import operator\n\nFALLBACK_RTRUEDIV_TYPES = (type(dict().keys()), type(dict().values()), type(dict().items()))\n\n\ndef _resolve(pipe, x):\n    while isinstance(pipe, Pipe):\n        pipe = pipe._____func___(x)\n    return pipe\n\n\nclass Pipe(object):\n    """"""\n    >>> [lambda : \'{}\'] | (Pipe(lambda x: x)[0]().format(2) | Pipe(int)**3)\n    8\n    """"""\n    __slots__ = (\'_____func___\',)\n\n    def __init__(self, func):\n        self._____func___ = func\n\n    def __ror__(self, other):\n        ret = _resolve(self, other)\n        return ret\n\n    def __or__(self, other):\n        if isinstance(other, Pipe):\n            return Pipe(lambda x: _resolve(other, _resolve(self, x)))\n\n        return Pipe(lambda x: _resolve(self, x) | other)\n\n    def __rtruediv__(self, other):\n        if isinstance(other, FALLBACK_RTRUEDIV_TYPES):\n            return _resolve(self, other)\n\n        return Pipe(lambda x: _resolve(other, x) / _resolve(self, x))\n\n    def __getattr__(self, item):\n        return Pipe.partial(getattr, self, item)\n\n    def __call__(self, *args, **kwargs):\n        return Pipe.partial(self, *args, **kwargs)\n\n    def __getitem__(self, item):\n        if isinstance(item, tuple) and len(item) < 20:  # do not iterate over too large tuples!\n            item = Pipe.collection(item)\n        return Pipe.partial(operator.getitem, self, item)\n\n    __array_priority__ = -10\n\n    @staticmethod\n    def __array_ufunc__(func, method, *args, **kwargs):\n        import numpy\n        if callable(method) and args[0] == \'__call__\':\n            if method is numpy.bitwise_or:\n                if isinstance(args[1], Pipe):\n                    return Pipe.partial(_resolve, args[2], args[1])\n                else:\n                    return _resolve(args[2], args[1])\n            return Pipe.partial(method, *args[1:], **kwargs)\n        elif method == \'__call__\':\n            if func.name == \'bitwise_or\':\n                if isinstance(args[0], Pipe):\n                    return Pipe.partial(_resolve, args[1], args[0])\n                else:\n                    return _resolve(args[1], args[0])\n            return Pipe.partial(func, *args, **kwargs)\n        return NotImplemented\n\n    @staticmethod\n    def unpipe(pipe):\n        if isinstance(pipe, Pipe):\n            return pipe._____func___\n        else:\n            return pipe\n\n    @staticmethod\n    def partial(func, *args, **kwargs):\n        # Code duplication in this function is intentional to increase performance.\n        if isinstance(func, Pipe):\n            if kwargs:\n                def _resolve_function_call(x):\n                    resolved_func = _resolve(func, x)\n                    resolved_args = (_resolve(arg, x) for arg in args)\n                    resolved_kwargs = {k: _resolve(v, x) for k, v in kwargs.items()}\n                    return resolved_func(*resolved_args, **resolved_kwargs)\n            else:\n                def _resolve_function_call(x):\n                    resolved_func = _resolve(func, x)\n                    resolved_args = (_resolve(arg, x) for arg in args)\n                    return resolved_func(*resolved_args)\n\n            return Pipe(_resolve_function_call)\n        else:\n            if kwargs:\n                def _resolve_function_call(x):\n                    resolved_args = (_resolve(arg, x) for arg in args)\n                    resolved_kwargs = {k: _resolve(v, x) for k, v in kwargs.items()}\n                    return func(*resolved_args, **resolved_kwargs)\n            else:\n                def _resolve_function_call(x):\n                    resolved_args = (_resolve(arg, x) for arg in args)\n                    return func(*resolved_args)\n\n            return Pipe(_resolve_function_call)\n\n    @staticmethod\n    def collection(items):\n        if isinstance(items, dict):\n            def _resolve_collection_creation(x):\n                resolved_items = {_resolve(key, x): _resolve(val, x) for key, val in items.items()}\n                return dict(resolved_items)\n        else:\n            def _resolve_collection_creation(x):\n                resolved_items = (_resolve(item, x) for item in items)\n                return type(items)(resolved_items)\n\n        return Pipe(_resolve_collection_creation)\n\n\ndef _override_operator(op, impl):\n    def __operator__(*args):\n        return Pipe.partial(impl, *args)\n\n    setattr(Pipe, op, __operator__)\n\n\ndef _reverse_args(func):\n    def wrapper(*args):\n        return func(*args[::-1])\n\n    return wrapper\n\n\nfor _op in [\n    \'len\', \'abs\',\n    \'contains\', \'await\',\n    \'lt\', \'le\', \'gt\', \'ge\', \'eq\', \'ne\',\n    \'xor\', \'and\',\n    \'rxor\', \'rand\',\n    \'rshift\', \'lshift\',\n    \'rrshift\', \'rlshift\',\n    \'add\', \'sub\', \'mul\', \'matmul\', \'pow\',\n    \'radd\', \'rsub\', \'rmul\', \'rmatmul\', \'rpow\',\n    \'truediv\', \'floordiv\', \'mod\',\n    \'rfloordiv\', \'rmod\',  # skipped rtruediv because it is implemented in Pipe class\n    \'pos\', \'neg\', \'invert\',\n    ]:\n    _name = \'__{}__\'.format(_op)\n\n    if _op in [\'and\', \'rand\']:\n        _impl = operator.and_\n    elif _op == \'len\':\n        _impl = len\n    elif _op == \'await\':\n        async def _impl(x):\n            return await x\n    else:\n        try:\n            _impl = getattr(operator, _op)\n        except AttributeError:  # radd, rrshift, rsub, rmul, ...\n            _op = _op[1:]  # remove the first \'r\' letter\n            _impl = _reverse_args(getattr(operator, _op))\n\n    _override_operator(_name, _impl)\n'"
sspipe/version.py,0,"b'__version__ = ""0.1.14""\n'"
tests/test_chain.py,0,"b'import functools\n\nfrom sspipe import p, px\n\n\ndef test_plmap():\n    def plmap(func):\n        return p(lambda x: map(func, x)) | p(list)\n\n    result = [1, 2] | plmap(lambda x: x + 1)\n    print(result)\n    assert result == [2, 3]\n'"
tests/test_collection_creation.py,0,"b'from sspipe import p, px\n\n\ndef test_list_creation():\n    assert (2 | p([1, px, px + 1])) == [1, 2, 3]\n\n\ndef test_tuple_creation():\n    assert (2 | p((1, px, px + 1))) == (1, 2, 3)\n\n\ndef test_set_creation():\n    assert (2 | p({1, px, px + 1})) == {1, 2, 3}\n\n\ndef test_dict_creation():\n    assert (2 | p({1: px, px: 3, px + 1: px + 2, 4: 5})) == {i: i + 1 for i in range(1, 5)}\n'"
tests/test_compatibility.py,0,"b'from sspipe import p, px\n\n\ndef test_simple():\n    assert range(3) | p.select(lambda x: x + 1) | p(list) | (px == [1, 2, 3])\n\n\ndef test_integration_with_px():\n    assert range(3) | p.select(px + 1) | p(list) | (px == [1, 2, 3])\n'"
tests/test_deep.py,0,"b'from sspipe import p, px\n\n\ndef test_simple():\n    def f(x, y):\n        return x * y\n\n    result = 1 | p(f, px + 1, px + 2)\n    assert result == 6\n\n\ndef test_plmap():\n    result = [1, 2] | p(map, lambda x: x+1, px) | p(list)\n    assert result == [2, 3]\n'"
tests/test_facade.py,0,"b""from sspipe import p, px\n\n\ndef test_normal_args():\n    assert (1 | p('{}{}{x}'.format, 2, x=3)) == '123'\n\n\ndef test_pipe_args():\n    def f(x, y):\n        return x * y\n\n    assert (1 | p(f, px + 1, px + 2)) == 6\n\ndef test_map_filter():\n    assert range(3) | p(filter, px % 2 == 0) | p(map, px + 1) | p(list) | (px == [1, 3])\n    # pass"""
tests/test_fallback_or.py,0,"b""from sspipe import p, px\n\n\ndef test_divide_fallback():\n    assert (dict(x=2, y=3).keys() / p(list) | p(set)) == {'x', 'y'}\n    assert (dict(x=2, y=3).values() / p(list) | p(set)) == {2, 3}\n\n"""
tests/test_numpy.py,6,"b'from sspipe import p, px\nimport numpy as np\n\n\ndef test_scalar_rhs():\n    assert np.int32(1) | p(lambda x: x + 1) | (px == 2)\n\n\ndef test_scalar_lhs():\n    assert 2 | px + np.int32(1)\n\n\ndef test_rhs():\n    assert np.array([1, 2]) | p(lambda x: x.sum()) | (px == 3)\n\n\ndef test_rhs_px():\n    assert np.array([1, 2]) | (px.sum() == 3)\n\n\ndef test_lhs():\n    assert 2 | p(np.log2) | (px == 1)\n\n\ndef test_lhs_px():\n    assert 2 | np.power(px, px + 1) | (px == 8)\n'"
tests/test_pandas.py,0,"b""import pandas as pd\nfrom sspipe import p, px\n\n\ndef test_px_slice():\n    df = pd.DataFrame(dict(x=[1, 2, 0], y=[3, 4, 5]))\n    assert (df | px[(px.x > 1) & (px.x < px.y)].y.sum()) == 4\n\n\ndef test_dataframe():\n    df = {'x': [0, 1, 2], 'y': [3, 4, 5]} | p(pd.DataFrame)\n    assert df.shape == (3, 2)\n\n    df = [{'x': 0, 'y': 3}, {'x': 1, 'y': 4}, {'x': 2, 'y': 5}] | p(pd.DataFrame)\n    assert df.shape == (3, 2)\n\n\ndef test_loc_tuple():\n    df = (\n        {'x': [0, 1, 2], 'y': [3, 4, 5]}\n        | p(pd.DataFrame)\n        | px.loc[px.x > 1, ['y']]\n    )\n    assert pd.DataFrame({'y': [5]}, index=[2]).equals(df)\n"""
tests/test_patch.py,0,"b""from sspipe import p, px\nimport pandas as pd\n\n\ndef test_pd_series():\n    result = pd.Series([1, 2]) | p(list)\n    assert result == [1, 2]\n\n\ndef test_pd_dataframe():\n    result = pd.DataFrame({'x': [1, 2], 'y': [3, 4]}) | px.size\n    assert result == 4\n\n\ndef test_pd_index():\n    result = pd.date_range('2017', '2018') | px.size\n    assert result == 366\n"""
tests/test_pipe_operators.py,0,"b""from sspipe import p, px\n\npinc = p(lambda x: x + 1)\npcdr = p(lambda x: x[1:])\n\n\ndef test_level1():\n    cases = [\n        [True, 1 not in [1, 2] | pcdr],\n        [True, 2 | pinc > 2],\n        [False, 2 | pinc < 3],\n        [1, 2 | pinc & 5],\n        [7, 2 | (pinc | 4)],\n        [1 | pinc + 2, 4],\n        # TODO: write test for rest\n    ]\n    for expected, result in cases:\n        assert expected == result\n\n\ndef test_level2():\n    result = 1 | (px == px)\n    assert result == True\n\n\ndef test_divide():\n    pipeline = 1 / px\n    assert (2 | pipeline) == 0.5\n\n    pipeline = (px + 1) / (px + 2)\n    assert (2 | pipeline) == 0.75\n\n\ndef test_reverse():\n    assert (1 | 2 + px) == 3\n    assert (1 | 2 << px) == 4\n\n\ndef test_order():\n    assert ('a' | px + 'b') == 'ab'\n    assert ('a' | 'b' + px) == 'ba'\n"""
tests/test_unpipe.py,0,"b'from sspipe import p, px, unpipe\n\ndef test_unpipe_active():\n    a_pipe = px + 1 | px * 5\n    func = unpipe(a_pipe)\n    assert func(0) == 5\n\ndef test_unpipe_passive():\n    func = lambda x: (x + 1) * 5\n    func = unpipe(func)\n    assert func(0) == 5\n    '"
