file_path,api_count,code
benchmarks/bench-switch.py,5,"b'from __future__ import print_function\n\nimport eigenpy\nimport numpy as np\n\nimport time\nimport timeit\n\nfrom IPython import get_ipython\nipython = get_ipython()\n\nquat = eigenpy.Quaternion()\na = [0., 0., 0.]\n\ncmd1 = ""timeit np.array(a)""\nprint(""\\n"")\nprint(cmd1)\nipython.magic(cmd1)\nprint(""\\n"")\n\ncmd2 = ""timeit np.matrix(a)""\nprint(cmd2)\nipython.magic(cmd2)\nprint(""\\n"")\n\neigenpy.switchToNumpyMatrix()\nprint(""----------------------"")\nprint(""switch to numpy matrix"")\nprint(""----------------------"")\nprint(""\\n"")\n\ncmd3 = ""timeit quat.coeffs()""\nprint(cmd3)\nipython.magic(cmd3)\nprint(""\\n"")\n\neigenpy.switchToNumpyArray()\nprint(""---------------------"")\nprint(""switch to numpy array"")\nprint(""---------------------"")\nprint(""\\n"")\n\ncmd4 = ""timeit quat.coeffs()""\nprint(cmd4)\nipython.magic(cmd4)\nprint(""\\n"")\n\ncmd5 = ""timeit np.asmatrix(quat.coeffs())""\nprint(cmd5)\nipython.magic(cmd5)\nprint(""\\n"")\n\na_matrix = np.matrix(a);\ncmd6 = ""timeit np.asarray(a_matrix)""\nprint(cmd6)\nipython.magic(cmd6)\nprint(""\\n"")\n'"
python/eigenpy/__init__.py,0,"b'#\n# Copyright (c) 2017-2019 CNRS INRIA\n#\n# This file is part of eigenpy\n# eigenpy is free software: you can redistribute it\n# and/or modify it under the terms of the GNU Lesser General Public\n# License as published by the Free Software Foundation, either version\n# 3 of the License, or (at your option) any later version.\n# Pinocchio is distributed in the hope that it will be\n# useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n# General Lesser Public License for more details. You should have\n# received a copy of the GNU Lesser General Public License along with\n# eigenpy If not, see\n# <http://www.gnu.org/licenses/>.\n\nfrom .eigenpy import *\nfrom .eigenpy import __version__, __raw_version__\n'"
unittest/python/test_LDLT.py,3,"b'import eigenpy\neigenpy.switchToNumpyArray()\n\nimport numpy as np\nimport numpy.linalg as la\n\ndim = 100\nA = np.random.rand(dim,dim)\n\nA = (A + A.T)*0.5 + np.diag(10. + np.random.rand(dim))\n\nldlt = eigenpy.LDLT(A)\n\nL = ldlt.matrixL() \nD = ldlt.vectorD() \nP = ldlt.transpositionsP() \n\nassert eigenpy.is_approx(np.transpose(P).dot(L.dot(np.diag(D).dot(np.transpose(L).dot(P)))),A)\n'"
unittest/python/test_LLT.py,3,"b'import eigenpy\neigenpy.switchToNumpyArray()\n\nimport numpy as np\nimport numpy.linalg as la\n\ndim = 100\nA = np.random.rand(dim,dim)\n\nA = (A + A.T)*0.5 + np.diag(10. + np.random.rand(dim))\n\nllt = eigenpy.LLT(A)\n\nL = llt.matrixL() \n\nassert eigenpy.is_approx(L.dot(np.transpose(L)),A)\n'"
unittest/python/test_complex.py,8,"b'from __future__ import print_function\n\nimport numpy as np\nfrom complex import *\n\nswitchToNumpyArray()\n\nrows = 10\ncols = 20\n\ndef test(dtype):\n  Z = np.zeros((rows,cols),dtype=dtype)\n  Z.real = np.random.rand(rows,cols)\n  Z.imag = np.random.rand(rows,cols)\n\n  Z_real = real(Z)\n  assert (Z_real == Z.real).all()\n  Z_imag = imag(Z)\n  assert (Z_imag == Z.imag).all()\n\n  Y = np.ones((rows,cols))\n  Y_complex = ascomplex(Y)\n  assert (Y_complex.real == Y).all()\n  assert (Y_complex.imag == np.zeros((rows,cols))).all()\n\n# Float\ntest(np.csingle)\n# Double\ntest(np.cdouble)\n# Long Double\ntest(np.clongdouble)\n'"
unittest/python/test_dimensions.py,0,"b'from __future__ import print_function\n\nimport eigenpy\nimport numpy as np\n\nquat = eigenpy.Quaternion()\n# By default, we convert as numpy.matrix\neigenpy.switchToNumpyMatrix()\ncoeffs_vector = quat.coeffs() \nassert len(coeffs_vector.shape) == 2\n\n# Switch to numpy.array\neigenpy.switchToNumpyArray()\ncoeffs_vector = quat.coeffs() \nassert len(coeffs_vector.shape) == 1\n'"
unittest/python/test_eigen_ref.py,2,"b'import numpy as np\nfrom eigen_ref import *\n\ndef test(mat):\n\n  printMatrix(mat)\n  fill(mat,1.)\n  printMatrix(mat)\n  assert np.array_equal(mat,np.full(mat.shape,1.))\n\nrows = 10\ncols = 30\n\nmat = np.array(np.zeros((rows,cols)))\n\ntest(mat)\n'"
unittest/python/test_eigen_solver.py,3,"b'import eigenpy\neigenpy.switchToNumpyArray()\n\nimport numpy as np\nimport numpy.linalg as la\n\ndim = 100\nA = np.random.rand(dim,dim)\n\nes = eigenpy.EigenSolver(A)\n\nV = es.eigenvectors()\nD = es.eigenvalues()\n\nassert eigenpy.is_approx(A.dot(V).real,V.dot(np.diag(D)).real)\nassert eigenpy.is_approx(A.dot(V).imag,V.dot(np.diag(D)).imag)\n'"
unittest/python/test_geometry.py,10,"b'from __future__ import print_function\n\nfrom geometry import *\nimport numpy as np\nfrom numpy import cos,sin\n\nverbose = True\n\ndef isapprox(a,b,epsilon=1e-6):\n    if issubclass(a.__class__,np.ndarray) and issubclass(b.__class__,np.ndarray):\n        return np.allclose(a,b,epsilon)\n    else:\n        return abs(a-b)<epsilon\n\n# --- Quaternion ---------------------------------------------------------------\nq = Quaternion(1,2,3,4)\nq.normalize()\nassert(isapprox(np.linalg.norm(q.coeffs()),q.norm()))\nassert(isapprox(np.linalg.norm(q.coeffs()),1))\n\nr = AngleAxis(q)\nq2 = Quaternion(r)\nassert(q==q)\nassert(isapprox(q.coeffs(),q2.coeffs()))\nassert(q2.isApprox(q2))\nassert(q2.isApprox(q2,1e-2))\n\nRq = q.matrix()\nRr = r.matrix()\nassert(isapprox(Rq.dot(Rq.T),np.eye(3)))\nassert(isapprox(Rr,Rq))\n\nqR = Quaternion(Rr)\nassert(q.isApprox(qR))\nassert(isapprox(q.coeffs(),qR.coeffs()))\n\nassert(isapprox(qR[3],1./np.sqrt(30)))\ntry:\n   qR[5]\n   print(""Error, this message should not appear."")\nexcept RuntimeError as e:\n  if verbose: print(""As expected, catched exception: "",e)\n\n# --- Angle Vector ------------------------------------------------\nr = AngleAxis(.1,np.array([1,0,0],np.double))\nif verbose: print(""Rx(.1) = \\n\\n"",r.matrix(),""\\n"")\nassert( isapprox(r.matrix()[2,2],cos(r.angle)))\nassert( isapprox(r.axis,np.array([1.,0,0])) )\nassert( isapprox(r.angle,0.1) )\nassert(r.isApprox(r))\nassert(r.isApprox(r,1e-2))\n\nr.axis = np.array([0,1,0],np.double).T\nassert( isapprox(r.matrix()[0,0],cos(r.angle)))\n\nri = r.inverse()\nassert( isapprox(ri.angle,-.1) )\n\nR = r.matrix()\nr2 = AngleAxis(np.dot(R,R))\nassert( isapprox(r2.angle,r.angle*2) )\n\n# --- USER FUNCTIONS -----------------------------------------------------------\nro = testOutAngleAxis()\nassert(ro.__class__ == AngleAxis)\nres = testInAngleAxis(r)\nassert( res==r.angle )\n\nqo = testOutQuaternion()\nassert(qo.__class__ == Quaternion)\nres = testInQuaternion(q)\nassert(q.norm() == res)\n'"
unittest/python/test_matrix.py,23,"b'from __future__ import print_function\n\nimport numpy as np\nimport matrix as eigenpy\n\nverbose = True\n\nif verbose: print(""===> From empty MatrixXd to Py"")\nM = eigenpy.emptyMatrix()\nassert M.shape == (0,0)\n\nif verbose: print(""===> From empty VectorXd to Py"")\nv = eigenpy.emptyVector()\nassert v.shape == (0,)\n\nif verbose: print(""===> From MatrixXd to Py"")\nM = eigenpy.naturals(3,3,verbose)\nMcheck = np.reshape(np.array(range(9),np.double),[3,3])\nassert np.array_equal(Mcheck,M)\n\nif verbose: print(""===> From Matrix3d to Py"")\nM33= eigenpy.naturals33(verbose)\nassert np.array_equal(Mcheck,M33)\n\nif verbose: print(""===> From VectorXd to Py"")\nv = eigenpy.naturalsX(3,verbose)\nvcheck = np.array(range(3),np.double).T\nassert np.array_equal(vcheck ,v)\n\nif verbose: print(""===> From Py to Eigen::MatrixXd"")\nif verbose: print(""===> From Py to Eigen::MatrixXd"")\nif verbose: print(""===> From Py to Eigen::MatrixXd"")\nMref = np.reshape(np.array(range(64),np.double),[8,8])\n\n# Test base function\nMref_from_base = eigenpy.base(Mref)\nassert( np.array_equal(Mref,Mref_from_base) );\n\nif verbose: print(""===> Matrix 8x8"")\nM = Mref\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block 0:3x0:3"")\nM = Mref[0:3,0:3]\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block 1:3x1:3"")\nM = Mref[1:3,1:3]\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block 1:5:2x1:5:2"")\nM = Mref[1:5:2,1:5:2]\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block 1:8:3x1:5"")\nM = Mref[1:8:3,1:5]\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block transpose 1:8:3x1:6:2"")\nM = Mref[1:8:3,0:6:2].T\nassert( np.array_equal(M,eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block Vector 1x0:6:2"")\nM = Mref[1:2,0:6:2]\nassert( np.array_equal(M.squeeze(),eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block Vector 1x0:6:2 tanspose"")\nM = Mref[1:2,0:6:2].T\nassert( np.array_equal(M.squeeze(),eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block Vector 0:6:2x1"")\nM = Mref[0:6:2,1:2]\nassert( np.array_equal(M.squeeze(),eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> Block Vector 0:6:2x1 tanspose"")\nM = Mref[0:6:2,1:2].T\nassert( np.array_equal(M.squeeze(),eigenpy.reflex(M,verbose)) );\n\nif verbose: print(""===> From Py to Eigen::VectorXd"")\nif verbose: print(""===> From Py to Eigen::VectorXd"")\nif verbose: print(""===> From Py to Eigen::VectorXd"")\n\nif verbose: print(""===> Block Vector 0:6:2x1 1 dim"")\nM = Mref[0:6:2,1].T\n# TODO\n# assert( np.array_equal(M.T,eigenpy.reflexV(M,verbose)) );\n\nif verbose: print(""===> Block Vector 0:6:2x1"")\nM = Mref[0:6:2,1:2]\nassert( np.array_equal(M.squeeze(),eigenpy.reflexV(M,verbose)) );\n\nif verbose: print(""===> Block Vector 0:6:2x1 transpose"")\nM = Mref[0:6:2,1:2].T\n# TODO\n# assert( np.array_equal(M.T,eigenpy.reflexV(M,verbose)) );\n\nif verbose: print(""===> From Py to Eigen::Matrix3d"")\nif verbose: print(""===> From Py to Eigen::Matrix3d"")\nif verbose: print(""===> From Py to Eigen::Matrix3d"")\n\nif verbose: print(""===> Block Vector 0:3x0:6:2 "")\nM = Mref[0:3,0:6:2]\nassert( np.array_equal(M,eigenpy.reflex33(M,verbose)) );\n\nif verbose: print(""===> Block Vector 0:3x0:6:2 T"")\nM = Mref[0:3,0:6].T\n# TODO\n# try:\n    # assert( np.array_equal(M,eigenpy.reflex33(M,verbose)) );\n# except eigenpy.Exception as e:\n    # if verbose: print(""As expected, got the following /ROW/ error:"", e.message)\n\nif verbose: print(""===> From Py to Eigen::Vector3d"")\nif verbose: print(""===> From Py to Eigen::Vector3d"")\nif verbose: print(""===> From Py to Eigen::Vector3d"")\n\n# TODO\n# M = Mref[0:3,1:2]\n# assert( np.array_equal(M,eigenpy.reflex3(M,verbose)) );\n\nvalue = 2.\nmat1x1 = eigenpy.matrix1x1(value)\nassert(mat1x1.size == 1)\nassert(mat1x1[0,0] == value)\n\nvec1x1 = eigenpy.vector1x1(value)\nassert(vec1x1.size == 1)\nassert(vec1x1[0] == value)\n\n# test registration of matrix6\nmat6 = eigenpy.matrix6(0.)\nassert(mat6.size == 36)\n'"
unittest/python/test_return_by_ref.py,10,"b'import return_by_ref\nfrom return_by_ref import Matrix, RowMatrix, Vector\nimport numpy as np\n\ndef test_shared(mat):\n\n  m_ref = mat.ref()\n  m_ref.fill(0)\n  m_copy = mat.copy()\n  assert np.array_equal(m_ref,m_copy)\n\n  m_const_ref = mat.const_ref()\n  assert np.array_equal(m_const_ref,m_copy)\n  assert np.array_equal(m_const_ref,m_ref)\n\n  m_ref.fill(1)\n  assert not np.array_equal(m_ref,m_copy)\n  assert np.array_equal(m_const_ref,m_ref)\n\n  try:\n    m_const_ref.fill(2)\n    assert False\n  except:\n    assert True\n\ndef test_not_shared(mat):\n\n  m_ref = mat.ref()\n  m_ref.fill(100.)\n  m_copy = mat.copy()\n  assert not np.array_equal(m_ref,m_copy)\n\n  m_const_ref = mat.const_ref()\n  assert np.array_equal(m_const_ref,m_copy)\n  assert not np.array_equal(m_const_ref,m_ref)\n\n  m_ref.fill(10.)\n  assert not np.array_equal(m_ref,m_copy)\n  assert not np.array_equal(m_const_ref,m_ref)\n\n  try:\n    m_const_ref.fill(2)\n    assert True\n  except:\n    assert False\n\nrows = 10\ncols = 30\n\nmat = Matrix(rows,cols)\nrow_mat = RowMatrix(rows,cols)\nvec = Vector(rows,1)\n\ntest_shared(mat)\ntest_shared(row_mat)\ntest_shared(vec)\n\nreturn_by_ref.sharedMemory(False)\ntest_not_shared(mat)\ntest_not_shared(row_mat)\ntest_not_shared(vec)\n\n\n'"
unittest/python/test_self_adjoint_eigen_solver.py,2,"b'import eigenpy\neigenpy.switchToNumpyArray()\n\nimport numpy as np\nimport numpy.linalg as la\n\ndim = 100\nA = np.random.rand(dim,dim)\nA = (A + A.T)*0.5\n\nes = eigenpy.SelfAdjointEigenSolver(A)\n\nV = es.eigenvectors()\nD = es.eigenvalues()\n\nassert eigenpy.is_approx(A.dot(V),V.dot(np.diag(D)),1e-6)\n'"
unittest/python/test_switch.py,4,"b'from __future__ import print_function\n\nimport eigenpy\nimport numpy as np\n\neigenpy.switchToNumpyMatrix()\nquat = eigenpy.Quaternion()\n# By default, we convert as numpy.matrix\ncoeffs_vector = quat.coeffs() \nprint(type(coeffs_vector))\n\nassert isinstance(coeffs_vector,np.matrixlib.defmatrix.matrix)\nassert eigenpy.getNumpyType() == np.matrix\n\n# Switch to numpy.array\neigenpy.switchToNumpyArray()\ncoeffs_array = quat.coeffs()\nprint(type(coeffs_array))\n\nassert isinstance(coeffs_vector,np.ndarray)\nassert eigenpy.getNumpyType() == np.ndarray\n'"
unittest/python/test_user_type.py,0,"b""import user_type\n\nrows = 10\ncols = 20\n\ndef test(mat):\n  mat.fill(mat.dtype.type(10.))\n  mat_copy = mat.copy()\n  assert (mat == mat_copy).all()\n  assert not (mat != mat_copy).all()\n\n  mat_op = mat + mat\n  mat_op = mat.copy(order='F') + mat.copy(order='C')\n  \n  mat_op = mat - mat\n  mat_op = mat * mat\n  mat_op = mat.dot(mat.T)\n  mat_op = mat / mat\n\n  mat_op = -mat;\n\n  assert (mat >= mat).all()\n  assert (mat <= mat).all()\n  assert not (mat > mat).all()\n  assert not (mat < mat).all()\n\nmat = user_type.create_double(rows,cols)\ntest(mat)\n\nmat = user_type.create_float(rows,cols)\ntest(mat)\n"""
unittest/python/test_version.py,0,"b'from __future__ import print_function\n\nimport eigenpy\n\nassert eigenpy.checkVersionAtLeast(0,0,0)\nassert eigenpy.__version__ != """"\nassert eigenpy.__raw_version__ != """"\n'"
