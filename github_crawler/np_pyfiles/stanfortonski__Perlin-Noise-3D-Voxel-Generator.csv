file_path,api_count,code
executable.py,0,"b""import glfw, glm, math\nfrom OpenGL.GL import *\nfrom engine.base.program import getLinkedProgram\nfrom engine.renderable.model import Model\nfrom engine.buffer.texture import *\nfrom engine.buffer.hdrbuffer import HDRbuffer\nfrom engine.buffer.blurbuffer import Blurbuffer\nfrom engine.effect.shadow import Shadow\nfrom engine.effect.bloom import Bloom\nfrom engine.generator import generateVoxelPositions\nfrom engine.camera import Camera\nfrom engine.config import config\n\ncube, hdrbuffer, blurbuffer, lastPosX, lastPosY = None, None, None, None, None\nfirstTime = True\nwidth, height = config['window_width'], config['window_height']\ncamera = Camera(glm.vec3(config['world_width']/2, config['world_height']+1, config['world_depth']/2))\n\ndef main():\n    global hdrbuffer, blurbuffer, cube\n\n    if not glfw.init():\n        print('Failed to initialize GLFW.')\n        return\n    \n    glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3)\n    glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3)\n    glfw.window_hint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)\n    glfw.window_hint(glfw.OPENGL_FORWARD_COMPAT, GL_TRUE)\n    glfw.window_hint(glfw.SAMPLES, config['sampling_level'])\n    \n    if config['fullscreen']:\n        global width, height\n        mode = glfw.get_video_mode(glfw.get_primary_monitor())\n        width, height = mode.size.width, mode.size.height\n        window = glfw.create_window(mode.size.width, mode.size.height, config['app_name'], glfw.get_primary_monitor(), None)\n    else:\n        window = glfw.create_window(width, height, config['app_name'], None, None)\n    if not window:\n        print('Failed to create GLFW Window.')\n        glfw.terminate()\n        return\n\n    glfw.make_context_current(window)\n    glfw.set_input_mode(window, glfw.CURSOR, glfw.CURSOR_DISABLED)\n    glfw.set_framebuffer_size_callback(window, resizeCallback)\n    glfw.set_cursor_pos_callback(window, mouseMove)\n    glfw.set_key_callback(window, keyCallback)\n\n    glEnable(GL_DEPTH_TEST)\n    glEnable(GL_MULTISAMPLE)\n    glEnable(GL_CULL_FACE)\n    glCullFace(GL_BACK) \n\n    program = getLinkedProgram('resources/shaders/vert.vs', 'resources/shaders/frag.fs')\n    depthProgram = getLinkedProgram('resources/shaders/shadow_depth.vs', 'resources/shaders/shadow_depth.fs')\n    blurProgram = getLinkedProgram('resources/shaders/blur.vs', 'resources/shaders/blur.fs')\n    hdrProgram = getLinkedProgram('resources/shaders/hdr.vs', 'resources/shaders/hdr.fs')\n\n    blurProgram.use()\n    blurProgram.setInt('image', 0)\n\n    hdrProgram.use()\n    hdrProgram.setInt('sceneMap', 0)\n    hdrProgram.setInt('bloomMap', 1)\n\n    hdrbuffer = HDRbuffer()\n    hdrbuffer.create(width, height)\n    blurbuffer = Blurbuffer()\n    blurbuffer.create(width, height)\n\n    bloom = Bloom(hdrbuffer, hdrProgram, blurbuffer, blurProgram)\n\n    lightPos = glm.vec3(10, 100, 0)\n    perspective = glm.perspective(45, width/height, config['near_plane'], config['far_plane'])\n\n    shadow = Shadow(lightPos, config['near_plane'], config['far_plane'])\n    shadow.create(config['shadow_width'], config['shadow_height'])\n\n    cube = Model('resources/models/cube.json')\n    texture = loadTexture2D('resources/textures/diffuse.jpg')\n    normal = loadTexture2D('resources/textures/normal.jpg')\n    specular = loadTexture2D('resources/textures/specular.jpg')\n    depth = loadTexture2D('resources/textures/depth.jpg')\n    \n    blockPositions = generateVoxelPositions(config['world_width'], config['world_height'], config['world_width'])\n    cube.setMultiplePositions(blockPositions)\n    blockPositions.clear()\n\n    lastTime = glfw.get_time()\n    while not glfw.window_should_close(window):\n        if config['debug_mode']:\n            print(glGetError())\n\n        currentTime = glfw.get_time()\n        deltaTime = currentTime - lastTime\n        lastTime = currentTime\n\n        lightPos.x = config['world_width']/2\n        lightPos.z = math.sin(currentTime*0.1) * config['world_depth']*2\n        lightPos.y = config['world_height']*2\n        shadow.updateMatrix(lightPos, config['near_plane'], config['far_plane'])\n\n        moveInput(window, deltaTime)\n\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n        glClearColor(0.1, 0.2, 0.8, 1)\n\n        shadow.castShadow(depthProgram)\n        cube.drawMultiple(depthProgram)\n        shadow.endCastShadow(program)\n\n        hdrbuffer.bind()\n        glViewport(0, 0, width, height)\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n\n        program.use()\n        program.setMat4('viewProject', perspective * camera.getViewMatrix())\n        program.setVec3('viewPos', camera.position)\n        program.setVec3('lightPos', lightPos)\n\n        glActiveTexture(GL_TEXTURE1)\n        program.setInt('mat.diffuseMap', 1)\n        texture.bind()\n\n        glActiveTexture(GL_TEXTURE2)\n        program.setInt('mat.normalMap', 2)\n        normal.bind()\n\n        glActiveTexture(GL_TEXTURE3)\n        program.setInt('mat.specularMap', 3)\n        specular.bind()\n\n        glActiveTexture(GL_TEXTURE4)\n        program.setInt('mat.depthMap', 4)\n        depth.bind()\n        program.setFloat('mat.shininess', 128)\n        program.setFloat('mat.heightScale', 0.12)\n        \n        cube.drawMultiple(program)\n        hdrbuffer.unbind()\n        hdrbuffer.finalize()\n\n        bloom.drawProcessedScene()\n\n        glfw.poll_events()\n        glfw.swap_buffers(window)\n\n    glfw.terminate()\n\ndef resizeCallback(window, w, h):\n    if h > 0:\n        global width, height, hdrbuffer, blurbuffer\n        width, height = w, h\n        perspective = glm.perspective(45, width/height, config['near_plane'], config['far_plane'])\n        hdrbuffer.delete()\n        hdrbuffer.create(width, height)\n        blurbuffer.delete()\n        blurbuffer.create(width, height)\n\ndef keyCallback(window, key, scancode, action, mods):\n    if key == glfw.KEY_ESCAPE and action == glfw.PRESS:\n        glfw.set_window_should_close(window, glfw.TRUE)\n    if key == glfw.KEY_G and action == glfw.PRESS:\n        global cube\n        positions = generateVoxelPositions(config['world_width'], config['world_height'], config['world_width'])\n        cube.setMultiplePositions(positions)\n\ndef mouseMove(win, posX, posY):\n    global firstTime, camera, lastPosX, lastPosY\n    if firstTime:\n        lastPosX = posX\n        lastPosY = posY\n        firstTime = False\n\n    camera.rotate(posX - lastPosX, lastPosY - posY)\n    lastPosX = posX\n    lastPosY = posY\n\ndef moveInput(win, time):\n    if glfw.get_key(win, glfw.KEY_W) == glfw.PRESS:\n        camera.moveTop(time)\n    if glfw.get_key(win, glfw.KEY_S) == glfw.PRESS:\n        camera.moveBottom(time)\n    if glfw.get_key(win, glfw.KEY_A) == glfw.PRESS:\n        camera.moveLeft(time)\n    if glfw.get_key(win, glfw.KEY_D) == glfw.PRESS:\n        camera.moveRight(time)\n\nif __name__ == '__main__':\n    main()"""
engine/__init__.py,0,b''
engine/camera.py,0,"b'import math, glm\n\nclass Camera:\n    def __init__(self, position):\n        self.position = position\n        self.up = glm.vec3(0, 1, 0)\n        self.worldUp = glm.vec3(0, 1, 0)\n        self.pitch = 0\n        self.yaw = 0\n        self.speed = 20\n        self.sensitivity = 0.25\n        self.updateVectors()\n\n    def moveRight(self, time):\n        self.position += self.right * (self.speed * time)\n  \n    def moveLeft(self, time):\n        self.position -= self.right * (self.speed * time)\n\n    def moveTop(self, time):\n        self.position += self.direction * (self.speed * time)\n\n    def moveBottom(self, time):\n        self.position -= self.direction * (self.speed * time)\n\n    def rotate(self, offsetX, offsetY):\n        self.yaw += offsetX * self.sensitivity\n        self.pitch += offsetY * self.sensitivity\n        if self.pitch > 89:\n            self.pitch = 89\n        elif self.pitch < -89:\n            self.pitch = -89\n        self.updateVectors()\n    \n    def updateVectors(self):\n        x = math.cos(glm.radians(self.yaw)) * math.cos(glm.radians(self.pitch))\n        y = math.sin(glm.radians(self.pitch))\n        z = math.sin(glm.radians(self.yaw)) * math.cos(glm.radians(self.pitch))\n        front = glm.vec3(x, y, z)\n        self.direction = glm.normalize(front)\n        self.right = glm.normalize(glm.cross(self.direction, self.worldUp))\n        self.up = glm.normalize(glm.cross(self.right, self.direction))\n\n    def getViewMatrix(self):\n        return glm.lookAt(self.position, self.position + self.direction, self.up)'"
engine/config.py,0,"b""import json\n\nwith open('config.json') as file:\n    config = json.load(file)"""
engine/generator.py,0,"b'import glm, random\n\ndef generateVoxelPositions(width, height, depth):\n    blockSize = 1.0\n    noiseScale = 20.0\n    amplitude = 20.0\n    offset = random.randrange(0, 1000000)\n    data = []\n    for x in range(width):\n        for y in range(height):\n            for z in range(depth):\n                noise = glm.perlin(glm.vec3(x/noiseScale + offset, y/noiseScale + offset, z/noiseScale + offset)) * amplitude\n                if noise >= 0.5:\n                    data.append([x*blockSize, y*blockSize, z*blockSize])\n    return data'"
tests/bloomhdr_test.py,0,"b""import sys, unittest, glfw, glm\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.hdrbuffer import HDRbuffer\nfrom engine.buffer.blurbuffer import Blurbuffer\nfrom engine.effect.bloom import Bloom\nfrom engine.renderable.model import Model\nfrom engine.base.shader import Shader\nfrom engine.base.program import *\nimport helper\n\nclass BloomHDRTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n        cls.model = Model('resources/models/monkey.json')\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testBloomHDRRendering(self):\n        hdrbuffer = HDRbuffer()\n        hdrbuffer.create(800, 600)\n\n        blurbuffer = Blurbuffer()\n        blurbuffer.create(800, 600)\n\n        program = getLinkedProgram('resources/shaders/bloomhdr_test.vs', 'resources/shaders/bloomhdr_test.fs')\n        blurProgram = getLinkedProgram('resources/shaders/blur.vs', 'resources/shaders/blur.fs')\n        hdrProgram = getLinkedProgram('resources/shaders/hdr.vs', 'resources/shaders/hdr.fs')\n\n        program.use()\n        program.setMat4('viewProject', helper.getViewProject())\n        program.setVec3('viewPos', glm.vec3(0, 0, -5))\n        program.setVec3('lightPos', glm.vec3(0, 5, 0))\n\n        blurProgram.use()\n        blurProgram.setInt('image', 0)\n\n        hdrProgram.use()\n        hdrProgram.setInt('sceneMap', 0)\n        hdrProgram.setInt('bloomMap', 1)\n\n        bloom = Bloom(hdrbuffer, hdrProgram, blurbuffer, blurProgram)\n\n        while not glfw.window_should_close(self.window):\n            glClear(GL_COLOR_BUFFER_BIT)\n            glClearColor(0.0, 0.0, 0.0, 0.0)\n            \n            hdrbuffer.bind()\n            self.model.draw(program)\n            hdrbuffer.unbind()\n            hdrbuffer.finalize()\n\n            bloom.drawProcessedScene()\n\n            glfw.poll_events()\n            glfw.swap_buffers(self.window)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/blurbuffer_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.blurbuffer import Blurbuffer\nimport helper\n\nclass BlurbufferTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testBlurbuffer(self):\n        blurbuffer = Blurbuffer()\n        blurbuffer.create(100,100)\n\n        self.assertEqual(blurbuffer.FBOs[0], 1)\n        self.assertEqual(blurbuffer.FBOs[1], 2)\n        self.assertEqual(blurbuffer.colorBuffers[0], 1)\n        self.assertEqual(blurbuffer.colorBuffers[1], 2)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/camera_test.py,0,"b""import sys, unittest, glfw, glm\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.camera import Camera\nimport helper\n\nclass CameraTest(unittest.TestCase):\n    def setUp(self):\n        self.camera = Camera(glm.vec3(0, 0, 0))\n        self.camera.speed = 2\n        self.camera.sensitivity = 2\n        self.projection = helper.getProjection()\n\n    def testMoveTop(self):\n        self.camera.moveTop(1)\n        self.camera.updateVectors()\n\n        expectedPos = self.camera.direction * 2\n        self.assertEqual(expectedPos, self.camera.position)\n\n    def testMoveBottom(self): \n        self.camera.moveBottom(1)\n        self.camera.updateVectors()\n\n        expectedPos = -self.camera.direction * 2\n        self.assertEqual(expectedPos, self.camera.position)\n\n    def testMoveleft(self): \n        self.camera.moveLeft(1)\n        self.camera.updateVectors()\n\n        expectedPos = -self.camera.right * 2\n        self.assertEqual(expectedPos, self.camera.position)\n\n    def testMoveRight(self): \n        self.camera.moveRight(1)\n        self.camera.updateVectors()\n\n        expectedPos = self.camera.right * 2\n        self.assertEqual(expectedPos, self.camera.position)\n\n    def testRotateX(self):\n        self.camera.rotate(3, 0)\n        self.camera.updateVectors()\n        self.assertEqual(6, self.camera.yaw)\n\n    def testRotateY(self):\n        self.camera.rotate(0, 3)\n        self.camera.updateVectors()\n        self.assertEqual(6, self.camera.pitch)\n\n        self.camera.rotate(0, 100)\n        self.camera.updateVectors()\n        self.assertEqual(89, self.camera.pitch)\n\n        self.camera.rotate(0, -100)\n        self.camera.updateVectors()\n        self.assertEqual(-89, self.camera.pitch)\n        \n\nif __name__ == '__main__':\n    unittest.main()"""
tests/depthbuffer_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.depthbuffer import Depthbuffer\nimport helper\n\nclass DepthbufferTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n       cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testDepthbuffer(self):\n        width, height = 101, 102\n        buffer = Depthbuffer()\n        buffer.create(width, height)\n\n        self.assertEqual(buffer.getId(), 1)\n        self.assertEqual(buffer.type, GL_TEXTURE_2D)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/framebuffer_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.framebuffer import Framebuffer\nfrom engine.buffer.depthbuffer import Depthbuffer\nimport helper\n\nclass FramebufferTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testFramebuffer(self):\n        self.framebuffer = Framebuffer()\n        self.framebuffer.bind()\n        depthbuffer = Depthbuffer()\n        depthbuffer.create(100, 100)\n        depthbuffer.attach()\n        self.framebuffer.checkComplete()\n        self.assertEqual(self.framebuffer.getId(), 1)\n\n    def testFramebuffer(self):\n        self.framebuffer = Framebuffer()\n        self.framebuffer.bind()\n        self.assertRaises(RuntimeError, self.framebuffer.checkComplete)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/hdrbuffer_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.hdrbuffer import HDRbuffer\nimport helper\n\nclass HDRbufferTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n       cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testHDRbuffer(self):\n        width, height = 101, 102\n        hdrbuffer = HDRbuffer()\n        hdrbuffer.create(width, height)\n\n        self.assertEqual(hdrbuffer.hdrFBO.getId(), 1)\n        self.assertEqual(hdrbuffer.rboDepth, 1)\n        self.assertEqual(hdrbuffer.colorBuffers[0], 1)\n        self.assertEqual(hdrbuffer.colorBuffers[1], 2)\n        self.assertEqual(hdrbuffer.width, width)\n        self.assertEqual(hdrbuffer.height, height)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/helper.py,0,"b""from OpenGL.GL import *\nfrom engine.base.shader import Shader\nfrom engine.base.program import Program\nimport glfw, glm\n\nwidth, height = 800, 600\n\ndef initAndGetWindow():\n    \n    glfw.init()\n    glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3)\n    glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3)\n    glfw.window_hint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)\n    glfw.window_hint(glfw.OPENGL_FORWARD_COMPAT, GL_TRUE)\n    window = glfw.create_window(width, height, 'OpenGL Test', None, None)\n    glfw.make_context_current(window)\n    return window\n\ndef getViewProject():\n    return getProjection() * getView()\n\ndef getProjection():\n    return glm.perspective(45, width/height, 0.1, 100)\n\ndef getView():\n    return glm.lookAt(glm.vec3(0, 0, -5), glm.vec3(0, 0, 0), glm.vec3(0, 1, 0))"""
tests/loadtexture2d_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.texture import Texture\nfrom engine.buffer.texture import loadTexture2D\nimport helper\n\nclass LoadTextureTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testLoadTexture(self):\n        texture = loadTexture2D('resources/textures/wall.jpg')\n        self.assertEqual(texture.getId(), 1)\n        self.assertEqual(texture.type, GL_TEXTURE_2D)\n\n    def testLoadTextureNotExists(self):\n        try:\n            texture = loadTexture2D('resources/textures/not-exists.jpg')\n            self.assertTrue(False)\n        except:\n            self.assertTrue(True)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/mesh_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.renderable.mesh import Mesh\nimport helper\n\nclass MeshTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testMeshInit(self):\n        data = {\n            'vertices': [1, 2, 3],\n            'faces': [[1]],\n            'normals': [1, 2, 3],\n            'texturecoords': [1, 1, 1],\n            'tangents': [1, 1, 1]\n        }\n\n        mesh = Mesh(data)\n        self.assertEqual(mesh.VAO, 1)\n        self.assertEqual(mesh.EBO, 1)\n        self.assertEqual(mesh.VBO, 2)\n        self.assertEqual(mesh.VBO_N, 3)\n        self.assertEqual(mesh.VBO_TEX, 4)\n        self.assertEqual(mesh.VBO_TAN, 5)\n        self.assertEqual(mesh.VBO_POS, 6)\n        \n\nif __name__ == '__main__':\n    unittest.main()"""
tests/model_test.py,0,"b""import sys, unittest, glfw, glm\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.renderable.model import Model\nfrom engine.base.program import *\nimport helper\n\nclass ModelTest(unittest.TestCase):\n    def setUp(self):\n        self.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testModelLoading(self):\n        model = Model('resources/models/monkey.json')\n        self.assertEqual(len(model.meshes), 1)\n\n    def testNoExistsModel(self):\n        try:\n            model = Model('resources/models/not.json')\n            self.assertTrue(False)\n        except RuntimeError:\n            self.assertTrue(True)\n\n    def testDraw(self):\n        program = getLinkedProgram('resources/shaders/test_vert.vs', 'resources/shaders/test_frag.fs')\n        program.use()\n        program.setMat4('viewProject', helper.getViewProject())\n        model = Model('resources/models/monkey.json')\n        while not glfw.window_should_close(self.window):\n            glClear(GL_COLOR_BUFFER_BIT)\n            glClearColor(0.0, 0.0, 0.0, 0.0)\n            model.draw(program)\n            glfw.poll_events()\n            glfw.swap_buffers(self.window)\n            \n    def testDrawMultiple(self):\n        program = getLinkedProgram('resources/shaders/test_vert.vs', 'resources/shaders/test_frag.fs')\n        program.use()\n        program.setMat4('viewProject', helper.getViewProject())\n        model = Model('resources/models/monkey.json')\n        model.setMultiplePositions([[0, 0, 0], [1, 1, 1]])\n        while not glfw.window_should_close(self.window):\n            glClear(GL_COLOR_BUFFER_BIT)\n            glClearColor(0.0, 0.0, 0.0, 0.0)\n            model.drawMultiple(program)\n            glfw.poll_events()\n            glfw.swap_buffers(self.window)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/program_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.base.shader import Shader\nfrom engine.base.program import *\nimport helper\n\nclass ProgramTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testLinking(self):\n        try:\n            program = Program()\n            program.attachShader(Shader('resources/shaders/test_vert.vs', GL_VERTEX_SHADER))\n            program.attachShader(Shader('resources/shaders/test_frag.fs', GL_FRAGMENT_SHADER))\n            program.link()\n            self.assertEqual(program.getId(), 1)\n        except RuntimeError:\n            self.assertTrue(False)\n\n    def testLinked(self):\n        try:\n            program = getLinkedProgram('resources/shaders/test_vert.vs', 'resources/shaders/test_frag.fs')\n            self.assertEqual(program.getId(), 1)\n        except RuntimeError:\n            self.assertTrue(False)\n\n    def testErrorCompile(self):\n        try:\n            program = Program()\n            program.attachShader(Shader('resources/shaders/test_vert.vs', GL_VERTEX_SHADER))\n            program.attachShader(Shader('resources/shaders/error.fs', GL_FRAGMENT_SHADER))\n            program.link()\n            self.assertTrue(False)\n        except RuntimeError:\n            self.assertTrue(True)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/shader_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.base.shader import Shader\nimport helper\n\nclass ShaderTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testCompile(self):\n        shader = Shader('resources/shaders/test_vert.vs', GL_VERTEX_SHADER)\n        shader.compile()\n        self.assertEqual(shader.getId(), 1)\n\n    def testShaderFileNotExist(self):\n        try:\n            shader = Shader('resources/shaders/not_exist.vs', GL_VERTEX_SHADER)\n            self.assertTrue(False)\n        except RuntimeError:\n            self.assertTrue(True)\n\n    def testCompileError(self):\n        shader = Shader('resources/shaders/error.fs', GL_FRAGMENT_SHADER)\n        self.assertRaises(RuntimeError, shader.compile)\n        \nif __name__ == '__main__':\n    unittest.main()"""
tests/shadow_test.py,0,"b""import sys, unittest, glfw, glm\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.effect.shadow import Shadow\nfrom engine.renderable.model import Model\nfrom engine.base.shader import Shader\nfrom engine.base.program import *\nimport helper\n\nclass BloomHDRTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n        cls.model = Model('resources/models/monkey.json')\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testBloomHDRRendering(self):\n        program = getLinkedProgram('resources/shaders/shadow_test.vs', 'resources/shaders/shadow_test.fs')\n        depthProgram = getLinkedProgram('resources/shaders/shadow_depth.vs', 'resources/shaders/shadow_depth.fs')\n\n        lightPos = glm.vec3(0, 5, 1)\n\n        program.use()\n        program.setMat4('viewProject', helper.getViewProject())\n        program.setVec3('viewPos', glm.vec3(0, 0, -5))\n        program.setVec3('lightPos', lightPos)\n\n        self.model.setMultiplePositions([[0, 1, 0], [0, -1, 0]])\n\n        shadow = Shadow(lightPos, 0.1, 100)\n        shadow.create(512, 512)\n\n        while not glfw.window_should_close(self.window):\n            glClear(GL_COLOR_BUFFER_BIT)\n            glClearColor(0.0, 0.0, 0.0, 0.0)\n            \n            shadow.castShadow(depthProgram)\n            self.model.drawMultiple(depthProgram)\n            shadow.endCastShadow(program)\n\n            glViewport(0, 0, 800, 600)\n            self.model.drawMultiple(program)\n            \n            glfw.poll_events()\n            glfw.swap_buffers(self.window)\n\nif __name__ == '__main__':\n    unittest.main()"""
tests/texture_test.py,0,"b""import sys, unittest, glfw\nsys.path.insert(0, '..')\nfrom OpenGL.GL import *\nfrom engine.buffer.texture import Texture\nimport helper\n\nclass TextureTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.window = helper.initAndGetWindow()\n\n    @classmethod\n    def tearDownClass(cls):\n        glfw.terminate()\n\n    def testTexture(self):\n        texture = Texture(GL_TEXTURE_2D)\n        self.assertEqual(texture.getId(), 1)\n\n    def testTextureDelete(self):\n        texture = Texture(GL_TEXTURE_2D)\n        try:\n            texture.delete()\n            self.assertEqual(texture.getId(), 0)\n        except:\n            self.assertTrue(True)\n\nif __name__ == '__main__':\n    unittest.main()"""
engine/base/__init__.py,0,b''
engine/base/program.py,0,"b""import glm\nfrom engine.base.shader import Shader\nfrom OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\n\nclass Program:\n    def __init__(self):\n        self.__programId = 0\n        self.shaders = []\n\n    def attachShader(self, shader):\n        self.shaders.append(shader)\n\n    def link(self):\n        self.__programId = glCreateProgram()\n        for shader in self.shaders:\n            shader.compile()\n            glAttachShader(self.__programId, shader.getId())\n\n        glLinkProgram(self.__programId)\n\n        for shader in self.shaders:\n            shader.delete()\n        self.shaders.clear()\n\n        if glGetProgramiv(self.__programId, GL_LINK_STATUS) != GL_TRUE:\n            info = glGetProgramInfoLog(self.__programId)\n            self.delete()\n            raise RuntimeError(f'Error in program linking: {info}')\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteProgram(self.__programId)\n            self.__programId = 0\n        except NullFunctionError:\n            pass\n\n    def use(self):\n        glUseProgram(self.__programId)\n\n    def getId(self):\n        return self.__programId\n\n    def getAttribLocation(self, name):\n        return glGetAttribLocation(self.__programId, name)\n\n    def getUniformLocation(self, name):\n        return glGetUniformLocation(self.__programId, name)\n\n    def setInt(self, name, value):\n        glUniform1i(self.getUniformLocation(name), value)\n\n    def setFloat(self, name, value):\n        glUniform1f(self.getUniformLocation(name), value)\n\n    def setVec2(self, name, vec):\n        glUniform2fv(self.getUniformLocation(name), 1, glm.value_ptr(vec))\n\n    def setVec3(self, name, vec):\n        glUniform3fv(self.getUniformLocation(name), 1, glm.value_ptr(vec))\n\n    def setVec4(self, name, vec):\n        glUniform4fv(self.getUniformLocation(name), 1, glm.value_ptr(vec))\n\n    def setMat2(self, name, mat):\n        glUniformMatrix2fv(self.getUniformLocation(name), 1, GL_FALSE, glm.value_ptr(mat))\n\n    def setMat3(self, name, mat):\n        glUniformMatrix3fv(self.getUniformLocation(name), 1, GL_FALSE, glm.value_ptr(mat))\n\n    def setMat4(self, name, mat):\n        glUniformMatrix4fv(self.getUniformLocation(name), 1, GL_FALSE, glm.value_ptr(mat))\n\ndef getLinkedProgram(vertPath, fragPath):\n    program = Program()\n    program.attachShader(Shader(vertPath, GL_VERTEX_SHADER))\n    program.attachShader(Shader(fragPath, GL_FRAGMENT_SHADER))\n    program.link()\n    return program"""
engine/base/shader.py,0,"b""import os\nfrom OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\n\nclass Shader:\n    def __init__(self, sourcePath, shaderType):\n        self.__shaderId = 0\n        if not os.path.exists(sourcePath):\n            raise RuntimeError(f'Shader source file {sourcePath} does not exists.')\n        self.__sourcePath = sourcePath\n        self.shaderType = shaderType\n\n    def compile(self):\n        self.__shaderId = glCreateShader(self.shaderType)\n        glShaderSource(self.__shaderId, self.__loadSource())\n        glCompileShader(self.__shaderId)\n        if glGetShaderiv(self.__shaderId, GL_COMPILE_STATUS) != GL_TRUE:\n            info = glGetShaderInfoLog(self.__shaderId)\n            raise RuntimeError(f'Shader compilation failed:\\n{info}')\n\n    def __loadSource(self):\n        with open(self.__sourcePath) as file:\n            source = file.read()\n        return source\n\n    def getId(self):\n        return self.__shaderId\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteShader(self.__shaderId)\n            self.__shaderId = 0\n        except NullFunctionError:\n            pass\n"""
engine/buffer/__init__.py,0,b''
engine/buffer/blurbuffer.py,0,"b""from OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\nfrom engine.buffer.framebuffer import Framebuffer\n  \nclass Blurbuffer:\n    def create(self, width, height):\n        self.FBOs = glGenFramebuffers(2)\n        self.colorBuffers = glGenTextures(2)\n        for i in range(2):\n            glBindFramebuffer(GL_FRAMEBUFFER, self.FBOs[i])\n            glBindTexture(GL_TEXTURE_2D, self.colorBuffers[i])\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, width, height, 0, GL_RGB, GL_FLOAT, None)\n            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, self.colorBuffers[i], 0)\n\n        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE:\n            raise RuntimeError('Error when creating Blur Framebuffers.')\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteFramebuffers(2, self.FBOs)\n            glDeleteTextures(2, self.colorBuffers)\n            self.colorBuffers = 0\n        except NullFunctionError:\n            pass"""
engine/buffer/depthbuffer.py,0,"b'from OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\nfrom engine.buffer.texture import Texture\n\nclass Depthbuffer(Texture):\n    def __init__(self):\n        super().__init__(GL_TEXTURE_2D)\n\n    def create(self, width, height):\n        self.bind()\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, None)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER)\n        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER)\n        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, [1.0, 1.0, 1.0, 1.0])\n        self.unbind()\n\n    def attach(self):\n        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, self.getId(), 0)\n        glDrawBuffer(GL_NONE)\n        glReadBuffer(GL_NONE)'"
engine/buffer/framebuffer.py,0,"b""from OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\n\nclass Framebuffer:\n    def __init__(self):\n        self.FBO = glGenFramebuffers(1)\n        \n    def checkComplete(self):\n        if glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE:\n            raise RuntimeError('Error when creating Framebuffer.')\n        self.unbind()\n\n    def getId(self):\n        return self.FBO\n\n    def bind(self):\n        glBindFramebuffer(GL_FRAMEBUFFER, self.FBO)\n\n    def unbind(self):\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\n    \n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteFramebuffers(1, self.FBO)\n            self.FBO = 0\n        except (NullFunctionError, TypeError):\n            pass\n"""
engine/buffer/hdrbuffer.py,0,"b""from OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\nfrom engine.buffer.framebuffer import Framebuffer\nfrom engine.config import config\n\nclass HDRbuffer:\n    def create(self, width, height):\n        self.width = width\n        self.height = height\n        self.__createFBO()\n        self.__createMultisampleFBO()\n       \n    def __createFBO(self):\n        self.hdrFBO = Framebuffer()\n        self.hdrFBO.bind()\n        self.colorBuffers = glGenTextures(2)\n        for i in range(2):\n            glBindTexture(GL_TEXTURE_2D, self.colorBuffers[i])\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, self.width, self.height, 0, GL_RGB, GL_FLOAT, None)\n            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, self.colorBuffers[i], 0)\n\n        self.rboDepth = glGenRenderbuffers(1)\n        glBindRenderbuffer(GL_RENDERBUFFER, self.rboDepth)\n        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, self.width, self.height)\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, self.rboDepth)\n        glDrawBuffers(2, [GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1])\n        self.hdrFBO.checkComplete()\n\n    def __createMultisampleFBO(self):\n        self.__hdrFBO_MS = Framebuffer()\n        self.__hdrFBO_MS.bind()\n        self.__colorBuffersMS = glGenTextures(2)\n        for i in range(2):\n            glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, self.__colorBuffersMS[i])\n            glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, config['sampling_level'], GL_RGB16F, self.width, self.height, GL_TRUE)\n            glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D_MULTISAMPLE, self.__colorBuffersMS[i], 0)\n\n        self.__rboDepthMS = glGenRenderbuffers(1)\n        glBindRenderbuffer(GL_RENDERBUFFER, self.__rboDepthMS)\n        glRenderbufferStorageMultisample(GL_RENDERBUFFER, config['sampling_level'], GL_DEPTH_COMPONENT, self.width, self.height)\n        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, self.__rboDepthMS)\n        glDrawBuffers(2, [GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1])\n        self.__hdrFBO_MS.checkComplete()\n\n    def bind(self):\n        self.__hdrFBO_MS.bind()\n\n    def finalize(self):\n        glBindFramebuffer(GL_READ_FRAMEBUFFER, self.__hdrFBO_MS.getId())\n        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, self.hdrFBO.getId())\n        for i in range(2):\n            glReadBuffer(GL_COLOR_ATTACHMENT0 + i)\n            glDrawBuffer(GL_COLOR_ATTACHMENT0 + i)\n            glBlitFramebuffer(0, 0, self.width, self.height, 0, 0, self.width, self.height, GL_COLOR_BUFFER_BIT, GL_NEAREST)\n        glBindFramebuffer(GL_READ_FRAMEBUFFER, 0)\n        glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0)\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\n\n    def unbind(self):\n        self.__hdrFBO_MS.unbind()\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        self.hdrFBO.delete()\n        self.__hdrFBO_MS.delete()\n        try:\n            glDeleteRenderbuffers(1, self.rboDepth)\n            glDeleteRenderbuffers(1, self.rboDepthMS)\n            glDeleteTextures(2, self.colorBuffers)\n            glDeleteTextures(2, self.__colorBuffersMS)\n            self.colorBuffers, self.__colorBuffersMS = 0, 0\n            self.rboDepth, self.rboDepthMS = 0, 0\n        except (NullFunctionError, TypeError):\n            pass"""
engine/buffer/texture.py,0,"b""from OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\nfrom PIL import Image\n\nclass Texture:\n    def __init__(self, type):\n        self.type = type\n        self.texture = glGenTextures(1)\n\n    def getId(self):\n        return self.texture\n\n    def bind(self):\n        glBindTexture(self.type, self.texture)\n\n    def unbind(self):\n        glBindTexture(self.type, 0)\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteTextures(1, self.texture)\n            self.texture = 0\n        except (NullFunctionError, TypeError):\n            pass\n\ndef loadTexture2D(path):\n    texture = Texture(GL_TEXTURE_2D)\n    texture.bind()\n\n    image = Image.open(path)\n    image = image.transpose(Image.FLIP_TOP_BOTTOM)\n    imgData = image.convert('RGBA').tobytes()\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image.width, image.height, 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData)\n\n    glGenerateMipmap(GL_TEXTURE_2D)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR)\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    return texture"""
engine/effect/__init__.py,0,b''
engine/effect/bloom.py,0,"b""from OpenGL.GL import *\nfrom engine.renderable.quad import Quad\n\nclass Bloom:\n    def __init__(self, hdrbuffer, hdrProgram, blurbuffer, blurProgram):\n        self.hdrbuffer = hdrbuffer\n        self.hdrProgram = hdrProgram\n        self.blurbuffer = blurbuffer\n        self.blurProgram = blurProgram\n        self.quad = Quad()\n\n    def drawProcessedScene(self):\n        horizontal, firstIteration = True, True\n        horizontalVal, NhorizontalVal = 1, 0\n        self.blurProgram.use()\n        for i in range(10):\n            if horizontal:\n                horizontalVal, NhorizontalVal = 1, 0\n            else:\n                horizontalVal, NhorizontalVal = 0, 1\n\n            self.blurProgram.setInt('horizontal', horizontal)\n            glBindFramebuffer(GL_FRAMEBUFFER, self.blurbuffer.FBOs[horizontalVal])\n            glActiveTexture(GL_TEXTURE0)\n            if firstIteration:\n                glBindTexture(GL_TEXTURE_2D, self.hdrbuffer.colorBuffers[1])\n                firstIteration = False\n            else:\n                glBindTexture(GL_TEXTURE_2D, self.blurbuffer.colorBuffers[NhorizontalVal])\n                firstIteration = False\n                \n            horizontal = not horizontal\n            self.quad.draw()\n\n        glBindFramebuffer(GL_FRAMEBUFFER, 0)\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n        self.hdrProgram.use()\n        glActiveTexture(GL_TEXTURE0)\n        glBindTexture(GL_TEXTURE_2D, self.hdrbuffer.colorBuffers[0])\n        glActiveTexture(GL_TEXTURE1)\n        glBindTexture(GL_TEXTURE_2D, self.blurbuffer.colorBuffers[NhorizontalVal])\n        self.quad.draw()"""
engine/effect/shadow.py,0,"b""import glm\nfrom OpenGL.GL import *\nfrom engine.buffer.depthbuffer import Depthbuffer\nfrom engine.buffer.framebuffer import Framebuffer\n\nclass Shadow:\n    def __init__(self, lightPos, nearPlane, farPlane):\n        self.updateMatrix(lightPos, nearPlane, farPlane)\n    \n    def updateMatrix(self, lightPos, nearPlane, farPlane):\n        lightProjection = glm.ortho(-10, 10, -10, 10, nearPlane, farPlane)\n        lightView = glm.lookAt(lightPos, glm.vec3(0), glm.vec3(0, 1, 0))\n        self.lightSpaceMatrix = lightProjection * lightView\n\n    def create(self, width, height):\n        self.width = width\n        self.height = height\n        self.depthbuffer = Depthbuffer()\n        self.framebuffer = Framebuffer()\n        self.framebuffer.bind()\n        self.depthbuffer.create(width, height)\n        self.depthbuffer.attach()\n        self.framebuffer.checkComplete()\n\n    def castShadow(self, depthProgram):\n        glDisable(GL_CULL_FACE)\n        depthProgram.use()\n        depthProgram.setMat4('lightSpaceMatrix', self.lightSpaceMatrix)\n        glViewport(0, 0, self.width, self.height)\n        self.framebuffer.bind()\n        glClear(GL_DEPTH_BUFFER_BIT)\n        \n    def endCastShadow(self, program):\n        self.framebuffer.unbind()\n        program.use()\n        program.setMat4('lightSpaceMatrix', self.lightSpaceMatrix)\n        program.setInt('shadowMap', 10)\n        glActiveTexture(GL_TEXTURE10)\n        self.depthbuffer.bind()\n        glEnable(GL_CULL_FACE)\n\n    def delete(self):\n        self.framebuffer.delete()\n        self.depthbuffer.delete()"""
engine/renderable/__init__.py,0,b''
engine/renderable/mesh.py,7,"b""import numpy as np\nfrom OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\n\nclass Mesh:\n    def __init__(self, data):\n        indicesList = self.__getIndicesList(data['faces'])\n        self.__indicesLen = len(indicesList)\n        indicesData = np.array(indicesList, dtype=np.uint32)\n        vertexData = np.array(data['vertices'], dtype=np.float32)\n        normalData = np.array(data['normals'], dtype=np.float32)\n        texCoordsData = np.array(data['texturecoords'], dtype=np.float32)\n        tangentData = np.array(data['tangents'], dtype=np.float32)\n        \n        self.VAO = glGenVertexArrays(1)\n        glBindVertexArray(self.VAO)\n\n        self.EBO = glGenBuffers(1)\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.EBO)\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesData, GL_STATIC_DRAW)\n\n        self.VBO = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO)\n        glBufferData(GL_ARRAY_BUFFER, vertexData, GL_STATIC_DRAW)\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n        glEnableVertexAttribArray(0)\n\n        self.VBO_N = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO_N)\n        glBufferData(GL_ARRAY_BUFFER, normalData, GL_STATIC_DRAW)\n        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, None)\n        glEnableVertexAttribArray(1)\n\n        self.VBO_TEX = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO_TEX)\n        glBufferData(GL_ARRAY_BUFFER, texCoordsData, GL_STATIC_DRAW)\n        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 0, None)\n        glEnableVertexAttribArray(2)\n\n        self.VBO_TAN = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO_TAN)\n        glBufferData(GL_ARRAY_BUFFER, tangentData, GL_STATIC_DRAW)\n        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, 0, None)\n        glEnableVertexAttribArray(3)\n\n        self.VBO_POS = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO_POS)\n        data = np.array([[0, 0, 0]], dtype=np.float32)\n        glBufferData(GL_ARRAY_BUFFER, data, GL_DYNAMIC_DRAW)\n        glVertexAttribPointer(4, 3, GL_FLOAT, GL_FALSE, 0, None)\n        glEnableVertexAttribArray(4)\n        self.positionsLen = 1\n\n        glVertexAttribDivisor(0, 0)\n        glVertexAttribDivisor(1, 0)\n        glVertexAttribDivisor(2, 0)\n        glVertexAttribDivisor(3, 0)\n        glVertexAttribDivisor(4, 1)\n\n        glBindBuffer(GL_ARRAY_BUFFER, 0)\n        glBindVertexArray(0)\n\n    def __getIndicesList(self, assimpIndices):\n        indicesList = []\n        for face in assimpIndices:\n            for indice in face:\n                indicesList.append(indice)\n        return indicesList\n\n    def setMultiplePositions(self, positions):\n        data = np.array(positions, dtype=np.float32)\n        glBindVertexArray(self.VAO)\n        glBindBuffer(GL_ARRAY_BUFFER, self.VBO_POS)\n        glBufferData(GL_ARRAY_BUFFER, data, GL_DYNAMIC_DRAW)\n        glBindVertexArray(0)\n        self.positionsLen = len(positions)\n\n    def draw(self, program):\n        glBindVertexArray(self.VAO)\n        glDrawElements(GL_TRIANGLES, self.__indicesLen, GL_UNSIGNED_INT, None)\n\n    def drawMultiple(self, program):\n        glBindVertexArray(self.VAO)\n        glDrawElementsInstanced(GL_TRIANGLES, self.__indicesLen, GL_UNSIGNED_INT, None, self.positionsLen)\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteVertexArrays(1, self.VAO)\n            glDeleteBuffers(1, self.VBO)\n            glDeleteBuffers(1, self.VBO_N)\n            glDeleteBuffers(1, self.VBO_TEX)\n            glDeleteBuffers(1, self.VBO_TAN)\n            glDeleteBuffers(1, self.EBO)\n            glDeleteBuffers(1, self.VBO_POS)\n            self.VAO, self.VBO, self.VBO_N, self.VBO_TEX, self.VBO_TAN, self.EBO, self.VBO_POS = 0, 0, 0, 0, 0, 0, 0\n        except (NullFunctionError, TypeError):\n            pass \n"""
engine/renderable/model.py,0,"b""import os, json, glm\nimport numpy as np\nfrom OpenGL.GL import *\nfrom engine.renderable.mesh import Mesh \n\nclass Model:\n    def __init__(self, path):\n        self.meshes = []\n        if not os.path.exists(path):\n            raise RuntimeError(f'Model source file {path} does not exists.')\n        self.path = path\n        self.model = glm.mat4()\n        data = self.__loadAndGetData()\n        for meshData in data['meshes']:\n            self.meshes.append(Mesh(meshData))\n\n    def __loadAndGetData(self):\n        data = None\n        with open(self.path) as file:\n            data = json.load(file)\n        return data\n\n    def setMultiplePositions(self, positions):\n        for mesh in self.meshes:\n            mesh.setMultiplePositions(positions)\n\n    def draw(self, program):\n        program.use()\n        program.setMat4('model', self.model)\n        for mesh in self.meshes:\n            mesh.draw(program)\n\n    def drawMultiple(self, program):\n        program.use()\n        program.setMat4('model', self.model)\n        for mesh in self.meshes:\n            mesh.drawMultiple(program)\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        self.meshes.clear()"""
engine/renderable/quad.py,4,"b'import numpy as np\nfrom OpenGL.GL import *\nfrom OpenGL.error import NullFunctionError\n\nclass Quad:\n    def __init__(self):\n        quadVertices = np.array([\n            -1,  1, 0, 0, 1,\n            -1, -1, 0, 0, 0,\n            1,  1, 0, 1, 1,\n            1, -1, 0, 1, 0,\n        ], dtype=np.float32)\n\n        self.quadVAO = glGenVertexArrays(1)\n        self.quadVBO = glGenBuffers(1)\n        glBindVertexArray(self.quadVAO)\n        glBindBuffer(GL_ARRAY_BUFFER, self.quadVBO)\n        glBufferData(GL_ARRAY_BUFFER, quadVertices, GL_STATIC_DRAW)\n        stride = np.dtype(np.float32).itemsize * 5\n        offset = ctypes.c_void_p(np.dtype(np.float32).itemsize * 3)\n        glEnableVertexAttribArray(0)\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, None)\n        glEnableVertexAttribArray(1)\n        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, offset)\n        glBindVertexArray(0)\n\n    def draw(self):\n        glDisable(GL_DEPTH_TEST)\n        glBindVertexArray(self.quadVAO)\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\n        glEnable(GL_DEPTH_TEST)\n\n    def __del__(self):\n        self.delete()\n\n    def delete(self):\n        try:\n            glDeleteVertexArrays(1, self.quadVAO)\n            glDeleteBuffers(1, self.quadVBO)\n            self.quadVAO, self.quadVBO = 0, 0\n        except (NullFunctionError, TypeError):\n            pass'"
