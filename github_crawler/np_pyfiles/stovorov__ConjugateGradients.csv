file_path,api_count,code
scripts/ConjugateGradients/__init__.py,0,b''
scripts/ConjugateGradients/demo.py,4,"b'""""""Reference script for implementation of Conjugate Gradient method.""""""\n\nfrom random import uniform\nfrom typing import cast\n\nfrom scripts.ConjugateGradients.test_matrices import TestMatrices\nfrom scripts.ConjugateGradients.utils import get_solver\n\nimport numpy as np\n\n\ndef main():\n    """"""This is ``main`` script function - implemented only to test algorithm.""""""\n\n    matrix_size = 100\n    # patterns are: quadratic, rectangular, arrow, noise, curve\n    # pattern=\'qra\' means that testing matrix will be composition of quadratic, rectangular and arrow patterns\n    a_matrix = TestMatrices.get_random_test_matrix(matrix_size, pattern=\'q\')\n    x_vec = np.vstack([1 for _ in range(matrix_size)])\n    b_vec = np.vstack([uniform(0, 1) for _ in range(matrix_size)])\n    cg_solver_cls = cast(callable, get_solver(\'CG\'))\n    pcg_solver_cls = cast(callable, get_solver(\'PCG\'))\n    cg_solver = cg_solver_cls(a_matrix, b_vec, x_vec)\n    results_cg = cg_solver.solve()\n    residual1 = results_cg[1]\n    cg_solver.show_convergence_profile()\n\n    pcg_solver = pcg_solver_cls(a_matrix, b_vec, x_vec)\n    results_pcg = pcg_solver.solve()\n    residual2 = results_pcg[1]\n\n    print(\'CG solved in {0} iterations with residual lin norm = {1:.8f}\'.format(cg_solver.finished_iter, np.linalg.norm(residual1)))\n    print(\'PCG (Jacobi) solved in {0} iterations with residual lin norm = {1:.8f}\'.format(pcg_solver.finished_iter, np.linalg.norm(residual2)))\n\n    cg_solver_cls.compare_convergence_profiles(cg_solver, pcg_solver)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
scripts/ConjugateGradients/test_matrices.py,27,"b'""""""Test matrices""""""\nimport random\nimport re\n\nfrom numpy.ma import ceil, sqrt\nfrom numpy.ma import floor\n\nimport numpy as np\nfrom scipy.sparse.csr import csr_matrix\n\n\nclass TestMatrices:\n    """"""Test matrices generating methods.""""""\n\n    @classmethod\n    def get_diagonal_matrix(cls, size: int = 50) -> np.matrix:\n        """"""Return size by size test diagonal matrix.""""""\n        diagonal = np.diagflat([1] * size)\n        return np.matrix(diagonal)\n\n    @classmethod\n    def get_diagonal_matrix_csr(cls, size: int = 50) -> csr_matrix:\n        """"""Return diagonal matrix in CSR format.""""""\n        return csr_matrix(cls.get_diagonal_matrix(size=size))\n\n    @classmethod\n    def get_matrix_three_diagonal(cls, size: int = 50) -> np.matrix:\n        """"""Return size by size test 3 diagonal matrix.""""""\n        upper_diagonal = np.diagflat([1] * (size - 1), 1)\n        lower_diagonal = np.diagflat([1] * (size - 1), -1)\n        diagonal = np.diagflat([10] * size)\n        return np.matrix(lower_diagonal + diagonal + upper_diagonal)\n\n    @classmethod\n    def get_matrix_three_diagonal_csr(cls, size: int = 50) -> csr_matrix:\n        """"""Return three diagonal test matrix in csr format.""""""\n        return csr_matrix(cls.get_matrix_three_diagonal(size=size))\n\n    @staticmethod\n    def _curve_mask(size: int):\n        """"""Return curved mask for random matrix""""""\n        mask = np.zeros((size, size))\n        prev = 0\n        for ind in range(size):\n            _y = size - int(round(float(sqrt(pow(size, 2) - pow(ind, 2)))))\n            mask[ind, int(ceil(_y/2))] = 1\n            mask[int(ceil(_y/2)), ind] = 1\n            mask[ind, _y] = 1\n            mask[_y, ind] = 1\n            for _i in range(prev, _y):\n                mask[ind, _i] = 1\n                mask[_i, ind] = 1\n                mask[ind, int(ceil(_i/2))] = 1\n                mask[int(ceil(_i/2)), ind] = 1\n            if ind == size - 1:\n                for _i in range(prev, size):\n                    mask[ind, _i] = 1\n                    mask[_i, ind] = 1\n            prev = _y\n            mask[ind, ind] = 1\n        return mask\n\n    @staticmethod\n    def _get_arrow_mask(size: int) -> np.matrix:\n        """"""Return arrow-like mask for random matrix""""""\n        mask = np.zeros((size, size))\n        for ind in range(size):\n            mask[ind, ind] = 1\n            if ind > 0:\n                length = random.randint(1, int(np.log(ind) * 2) + 1) * random.randint(0, 1)    # pylint: disable=no-member\n                if ind - length > 0:\n                    mask[ind-length:ind, ind] = 1\n                    mask[ind, ind-length:ind] = 1\n        return mask\n\n    @staticmethod\n    def _get_noise_mask(size: int) -> np.matrix:\n        """"""Return random noise""""""\n        density = 0.1\n        mask = np.zeros((size, size))\n        for ind in np.random.choice(size-1, int(floor(size * density))):        # pylint: disable=no-member\n            how_many_elmns = random.randint(1, int(sqrt(ind)) + 1)\n            for var in range(1, how_many_elmns):                                # pylint: disable=unused-variable\n                if random.randint(0, 1):\n                    length = random.randint(1, int(sqrt(size * density)))\n                    rnd_from = random.randint(1, ind) - length\n                    rnd_to = rnd_from + length\n                    mask[rnd_from:rnd_to, ind] = 1\n                    mask[ind, rnd_from:rnd_to] = 1\n        return mask\n\n    @staticmethod\n    def _get_quadratic_mask(size: int) -> np.matrix:\n        """"""Return mask for triangle test matrix.""""""\n        mask = np.zeros((size, size))\n        offset = int(floor(size/150))   # add extra diagonal for each 150elements grown size\n        # lets add some randomly distributed diagonals\n        extra_diagonals = [x for x in range(1, offset) if random.randint(0, 1)]\n        for ind in range(size):\n            mask[ind, ind] = 1\n            mask[ind, int(ceil(ind/2))] = 1\n            mask[int(ceil(ind/2)), ind] = 1\n            mask[ind, int(ceil(ind/4))] = 1\n            mask[int(ceil(ind/4)), ind] = 1\n            # will add extra diagonals randomly\n            for add in extra_diagonals:\n                if ind + add < size:\n                    mask[ind + add, ind] = 1\n                    mask[ind + add, int(ceil(ind/2))] = 1\n                    mask[int(ceil(ind/2)), ind + add] = 1\n                    mask[ind + add, int(ceil(ind/4))] = 1\n                    mask[int(ceil(ind/4)), ind + add] = 1\n                if ind - add >= 0:\n                    mask[ind - add, ind] = 1\n                    mask[ind - add, int(ceil(ind/2))] = 1\n                    mask[int(ceil(ind/2)), ind - add] = 1\n                    mask[ind - add, int(ceil(ind/4))] = 1\n                    mask[int(ceil(ind/4)), ind - add] = 1\n        for splitter in range(int(np.sqrt(size))):\n            matrix_splitter = ceil(float(pow(2, splitter + 1)))\n            split_value = size - int(size/matrix_splitter)\n            for ind in range(split_value, size):\n                for add in [0] + extra_diagonals:\n                    if split_value + add < size:\n                        mask[ind, split_value + add] = 1\n                        mask[split_value + add, ind] = 1\n        return mask\n\n    @staticmethod\n    def _get_rectangle_mask(size: int) -> np.matrix:    # pylint: disable=too-many-branches\n        """"""Return mask for rectangle test matrix.""""""\n        mask = np.zeros((size, size))\n        rnd = lambda: random.randint(0, 1)\n        for ind in range(size):\n            if ind < 3 * int(size/4):\n                for _y in range(0, int(size/4)):\n                    val = rnd() * rnd() * rnd()\n                    mask[ind, size - _y - 1] = val\n                    mask[size - _y - 1, ind] = val\n                if ind < int(size/8):\n                    for _y in range(0, int(size/8)):\n                        if _y > ind:\n                            # probability of heaving 1 is 0.5 * 0.5\n                            val = rnd() * rnd()\n                            mask[ind, _y] = val\n                            mask[_y, ind] = val\n                elif ind < int(size/4):\n                    for _y in range(int(size/8), int(size/4)):\n                        if _y > ind:\n                            val = rnd() * rnd()\n                            mask[ind, _y] = val\n                            mask[_y, ind] = val\n                elif ind < int(size/2):\n                    for _y in range(int(size/4), int(size/2)):\n                        if _y > ind:\n                            val = rnd() * rnd() * rnd()\n                            mask[ind, _y] = val\n                            mask[_y, ind] = val\n                elif ind < 5*int(size/8):\n                    for _y in range(int(size/2), 5*int(size/8)):\n                        if _y > ind:\n                            val = rnd() * rnd()\n                            mask[ind, _y] = val\n                            mask[_y, ind] = val\n            elif ind > size - int(size/8):\n                for _y in range(0, int(size/8)):\n                    val = rnd() * rnd()\n                    if size - _y - 1 < ind:\n                        mask[ind, size - _y - 1] = val\n                        mask[size - _y - 1, ind] = val\n            mask[ind, ind] = 1\n        return mask\n\n    @classmethod\n    def get_random_test_matrix(cls, size: int = 50, pattern: str = \'q\') -> np.matrix:\n        """"""Return positively defined matrix used for testing purposes.\n\n        Matrix will be positively define if its eigenvalues are positive, to achieve this it can be stated that:\n        A = Q\'DQ, where Q is random matrix, D diagonal matrix with positive elements on its diagonal.\n\n        :param size: represents size of matrix which as to be returned\n        :param pattern: represents pattern of random generated matrix e.g. quadratic, arrow, curve, rectangle, noise\n        :returns: generated matrix\n        """"""\n        rand_matrix = np.matrix(np.random.rand(size, size))    # pylint: disable=no-member\n        # consider making it diagonally dominant\n        d_matrix = np.diagflat([1] * size)\n        q_matrix = rand_matrix.T * d_matrix * rand_matrix\n        # log used to reduce growth of values when size gets greater\n        q_matrix = q_matrix / np.log(q_matrix.size)     # pylint: disable=no-member\n        shapes = {\'q\': cls._get_quadratic_mask,\n                  \'r\': cls._get_rectangle_mask,\n                  \'c\': cls._curve_mask,\n                  \'a\': cls._get_arrow_mask,\n                  \'n\': cls._get_noise_mask}\n        if re.match(r\'[qrcan]\', pattern):\n            mask = np.zeros((size, size))\n            for key in pattern:\n                # mypy: begin ignore\n                mask = np.logical_or(shapes[key](size), mask)    # pylint: disable=no-member\n                # mypy: end ignore\n            return np.multiply(q_matrix, mask)\n        else:\n            raise NotImplementedError\n\n    @classmethod\n    def get_random_test_matrix_csr(cls, size: int = 50, pattern: str = \'q\') -> csr_matrix:\n        """"""Return random test matrix in csr format.""""""\n        return csr_matrix(cls.get_random_test_matrix(size=size, pattern=pattern))\n'"
scripts/ConjugateGradients/utils.py,4,"b'""""""Miscellaneous functions""""""\nfrom typing import List, Tuple, Callable\n\nfrom scripts.ConjugateGradients.Solvers.CG.cg_solver import ConjugateGradientSolver\nfrom scripts.ConjugateGradients.Solvers.PCG.pcg_solver import PreConditionedConjugateGradientSolver\n\nimport numpy as np\nfrom scipy.sparse.csr import csr_matrix\nimport matplotlib\nimport matplotlib.pyplot as plt\n\n\nclass CSRMatrix:\n    """"""Wrap over standard csr_matrix scipy object for easier data manipulation.""""""\n\n    def __init__(self, m_matrix: np.matrix) -> None:\n        self._m_matrix = csr_matrix(m_matrix)\n\n    @property\n    def shape(self) -> Tuple[int, int]:\n        """"""Return tuple with shape.""""""\n        return self._m_matrix.shape\n\n    @property\n    def rows_i(self) -> List:\n        """"""Return list containing matrix rows indexes.""""""\n        return self._m_matrix.indptr\n\n    @property\n    def column_j(self) -> List:\n        """"""Return list containing matrix columns indexes.""""""\n        return self._m_matrix.indices\n\n    @property\n    def values(self) -> List:\n        """"""Return list containing matrix values.""""""\n        return list(self._m_matrix.data)\n\n    @property\n    def nnz(self) -> int:\n        """"""Return number of non-zero elements.""""""\n        return self._m_matrix.nnz\n\n\ndef get_solver(name: str = None) -> Callable:\n    """"""Return solver based on name.""""""\n    if not name or name == \'CG\':\n        return ConjugateGradientSolver\n    if name == \'PCG\':\n        return PreConditionedConjugateGradientSolver\n    raise NotImplementedError(\'Provided name for solver is wrong.\')\n\n\ndef view_matrix(mat: np.matrix) -> None:\n    """"""Print matrix graphical representation.""""""\n    masked = np.ma.masked_where(mat == -1, mat)\n    cmap = matplotlib.cm.viridis    # pylint: disable=no-member\n    cmap.set_under(color=\'white\')\n    plt.imshow(masked, interpolation=\'nearest\', cmap=cmap, vmin=0.0000001)\n    plt.colorbar()\n    plt.title(\'Matrix\')\n    plt.show()\n\n\ndef save_csr_matrix_to_file(matrix: np.matrix, filename: str):\n    """"""Save CSR matrix to txt file""""""\n    _matrix = CSRMatrix(matrix)\n    if _matrix.shape[0] != _matrix.shape[1]:\n        raise TypeError(\'Sorry - only size x size matrices!\')\n    with open(filename, \'w+\') as fil:\n        # save line with number of elements, matrix size and rows number\n        fil.write(\'{} {} {}\\n\'.format(_matrix.shape[0], _matrix.nnz, len(_matrix.rows_i)))\n        if len(_matrix.rows_i) < len(_matrix.column_j):\n            for ind in range(len(_matrix.column_j)):\n                if ind < len(_matrix.rows_i):\n                    fil.write(\'{} {} {}\\n\'.format(_matrix.values[ind], _matrix.column_j[ind], _matrix.rows_i[ind]))\n                else:\n                    fil.write(\'{} {}\\n\'.format(_matrix.values[ind], _matrix.column_j[ind]))\n        else:\n            for ind in range(len(_matrix.rows_i)):\n                if ind < len(_matrix.column_j):\n                    fil.write(\'{} {} {}\\n\'.format(_matrix.values[ind], _matrix.column_j[ind], _matrix.rows_i[ind]))\n                else:\n                    fil.write(\'{} {} {}\\n\'.format(\'-\', \'-\', _matrix.rows_i[ind]))\n'"
scripts/ConjugateGradients/Solvers/common.py,5,"b'""""""Stores implementation of IterativeSolver abstract class.""""""\n\nfrom abc import ABCMeta, abstractmethod\nfrom typing import Tuple, List\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\nclass IterativeSolver(metaclass=ABCMeta):\n    """"""Represents Iterative Solver interface.""""""\n    tolerance = 1e-5\n\n    def __init__(self, a_matrix: np.matrix, b_vec: np.vstack, x_vec: np.vstack, max_iter: int = 200) -> None:\n        """"""Initialize solver\n\n        :param a_matrix: Matrix for which we search solution.\n        :param b_vec: Vector for which we search solution.\n        :param x_vec: result vector\n        :param max_iter:\n\n        """"""\n        self.name = \'\'\n        if not self._is_pos_def:\n            raise TypeError(\'Provided matrix is not positively defined.\')\n        self.a_matrix = a_matrix\n        self.b_vec = b_vec\n        self.x_vec = x_vec\n        self.max_iter = max_iter\n        self._finished_iter = 0\n        self.residual_values = []   # type: list\n\n    @property\n    def finished_iter(self) -> int:\n        """"""Return number of solver\'s iterations""""""\n        return self._finished_iter\n\n    def _register_residual(self, conv: np.matrix) -> None:\n        """"""Register residual value for particular iteration.""""""\n        self.residual_values.append(np.linalg.norm(conv))\n\n    def _is_pos_def(self) -> bool:\n        """"""Check if matrix is positively defined using eigenvalues.""""""\n        return np.all(np.linalg.eigvals(self.a_matrix) > 0)\n\n    def get_convergence_profile(self) -> List:\n        """"""Return convergence profile.""""""\n        return self.residual_values\n\n    def show_convergence_profile(self) -> None:\n        """"""Show plot with convergence profile - normalised residual vector vs iteration.""""""\n        y_es = self.get_convergence_profile()\n        x_es = [i for i in range(len(y_es))]\n        plt.title(self.name + \' method convergence profile\')\n        plt.ylabel(\'Convergence (residual norm)\')\n        plt.xlabel(\'Iterations\')\n        plt.plot(x_es, y_es, \'b--\')\n        plt.legend([\'Total iter = \' + str(self.finished_iter)])\n        plt.show()\n\n    @staticmethod\n    def compare_convergence_profiles(*args: \'IterativeSolver\') -> None:\n        """"""Show plot with multiple convergence profiles.""""""\n        _to_print = []\n        _legend = []\n        plot_lines = [\'-\', \'--\', \'*\', \'^\']\n        plot_colors = [\'b\', \'r\', \'g\', \'y\']\n        for ind, solver in enumerate(args):\n            _y = solver.get_convergence_profile()\n            _x = [i for i in range(len(_y))]\n            try:\n                line_color = plot_colors[ind] + plot_lines[ind]\n            except IndexError:\n                line_color = \'\'\n            _to_print.append((_x, _y, line_color))\n            _legend.append(\'{} iter = {}\'.format(solver.name, solver.finished_iter))\n        plt.title(\'Convergence profiles comparison\')\n        plt.ylabel(\'Convergence (residual norm)\')\n        plt.xlabel(\'Iterations\')\n        plt.plot(*[item for sublist in _to_print for item in sublist])\n        plt.legend(_legend)\n        plt.show()\n\n    @abstractmethod\n    def solve(self) -> Tuple[np.matrix, int]:\n        """"""Solve system of linear equations.""""""\n        raise NotImplementedError\n'"
scripts/tests/Solvers/test_solvers.py,4,"b'""""""Tests for ConjugateGradients solvers.""""""\n\nimport pytest\nfrom scripts.ConjugateGradients.utils import get_solver\nfrom scripts.ConjugateGradients.test_matrices import TestMatrices\n\nimport numpy as np\n\n\n@pytest.fixture\ndef test_matrix():\n    matrix_size = 100\n    a_matrix = TestMatrices.get_diagonal_matrix(matrix_size) * 10\n    x_vec = np.vstack([1 for x in range(matrix_size)])\n    b_vec = np.vstack([0 for x in range(matrix_size)])\n    return a_matrix, x_vec, b_vec\n\n\ndef test_cg(test_matrix):\n    a_matrix, x_vec, b_vec = test_matrix\n    Solver = get_solver()\n    solver = Solver(a_matrix, x_vec, b_vec)\n    results = solver.solve()\n    assert 0.99999 < np.linalg.norm(results[0]) < 1.0001\n\n\ndef test_pcg_jacobi(test_matrix):\n    a_matrix, x_vec, b_vec = test_matrix\n    Solver = get_solver(\'PCG\')\n    solver = Solver(a_matrix, x_vec, b_vec)\n    results = solver.solve()\n    assert 0.99999 < np.linalg.norm(results[0]) < 1.0001\n'"
scripts/ConjugateGradients/Solvers/CG/cg_solver.py,2,"b'""""""\nContains implementation of Conjugate Gradient Method solver.\nFor more information search:\nhttps://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf\n""""""\n\nimport copy\nfrom typing import Tuple\nfrom scripts.ConjugateGradients.Solvers.common import IterativeSolver\n\nimport numpy as np\n\n\nclass ConjugateGradientSolver(IterativeSolver):\n    """"""Implements Conjugate Gradient method to solve system of linear equations.""""""\n\n    def __init__(self, *args, **kwargs):\n        """"""Initialize CG solver object.""""""\n        super(ConjugateGradientSolver, self).__init__(*args, **kwargs)\n        self.name = \'CG\'\n\n    def solve(self) -> Tuple[np.matrix, np.matrix]:\n        """"""Solve system of linear equations.""""""\n        i = 0\n        x_vec = copy.deepcopy(self.x_vec)\n        residual = self.b_vec - self.a_matrix * x_vec\n        div = residual\n        delta_new = residual.T * residual\n\n        while i < self.max_iter and np.linalg.norm(residual) > self.tolerance:\n            q_vec = self.a_matrix * div\n            alpha = float(delta_new/(div.T*q_vec))\n            # numpy has some problems with casting when using += notation...\n            x_vec = x_vec + alpha*div\n            residual = residual - alpha*q_vec\n            delta_old = delta_new\n            delta_new = residual.T*residual\n            beta = delta_new/delta_old\n            div = residual + float(beta)*div\n            self._register_residual(residual)\n            i += 1\n        self._finished_iter = i     # pylint: disable=attribute-defined-outside-init\n        return x_vec, residual\n'"
scripts/ConjugateGradients/Solvers/PCG/pcg_solver.py,2,"b'""""""\nContains implementation of Conjugate Gradient Method solver.\nFor more information search:\nhttps://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf\n""""""\n\nimport copy\nfrom typing import Tuple\nfrom scripts.ConjugateGradients.Solvers.PCG.preconditioners import jacobi, get_preconditioner\nfrom scripts.ConjugateGradients.Solvers.common import IterativeSolver\n\nimport numpy as np\n\n\nclass PreConditionedConjugateGradientSolver(IterativeSolver):\n    """"""Implements Preconditioned Conjugate Gradient method to solve system of linear equations.""""""\n\n    def __init__(self, *args, preconditioner: str = None, **kwargs) -> None:\n        """"""Initialize PCG solver object, sets default pre-conditioner.""""""\n        super(PreConditionedConjugateGradientSolver, self).__init__(*args, **kwargs)\n        self.preconditioner = jacobi if not preconditioner else get_preconditioner(preconditioner)\n        self.name = \'PCG {}\'.format(self.preconditioner.__name__)\n\n    def solve(self) -> Tuple[np.matrix, np.matrix]:\n        """"""Solve system of linear equations.""""""\n        i = 0\n        x_vec = copy.deepcopy(self.x_vec)\n        residual = self.b_vec - self.a_matrix * x_vec\n        div = self.preconditioner(self.a_matrix, residual)\n        delta_new = residual.T * div\n\n        while i < self.max_iter and np.linalg.norm(residual) > self.tolerance:\n            q_vec = self.a_matrix * div\n            alpha = float(delta_new/(div.T*q_vec))\n            # numpy has some problems with casting when using += notation...\n            x_vec = x_vec + alpha*div\n            residual = residual - alpha*q_vec\n            s_pre = self.preconditioner(self.a_matrix, residual)\n            delta_old = delta_new\n            delta_new = residual.T*s_pre\n            beta = delta_new/delta_old\n            div = s_pre + float(beta)*div\n            self._register_residual(residual)\n            i += 1\n        self._finished_iter = i     # pylint: disable=attribute-defined-outside-init\n        return x_vec, residual\n'"
scripts/ConjugateGradients/Solvers/PCG/preconditioners.py,4,"b'""""""Contains implementations of pre-conditioners for PCG method.""""""\n\nfrom typing import Callable\nimport numpy as np\n\n\ndef get_preconditioner(name: str) -> Callable:\n    """"""Return pre-conditioner based on name.""""""\n    if name == \'jacobi\':\n        return jacobi\n    raise KeyError(\'No pre-conditioner for provided name = {}\'.format(name))\n\n\ndef jacobi(a_matrix: np.matrix, residual: np.matrix) -> np.matrix:\n    """"""Return vector(np.matrix) obtained by multiplication of inverted a_matrix argument diagonal by residual vector.""""""\n    _to_return = {}  # type: dict\n    if \'inverted\' not in _to_return:\n        # we want to calculate matrix inversion only once...\n        _to_return[\'inverted\'] = np.linalg.inv(np.diag(np.diag(a_matrix)))\n    return np.matrix(_to_return[\'inverted\'] * residual)\n'"
