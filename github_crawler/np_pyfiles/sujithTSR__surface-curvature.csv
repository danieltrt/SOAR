file_path,api_count,code
surface.py,42,"b'import pylab\nimport scipy\nfrom mpl_toolkits.mplot3d import Axes3D\nimport scipy.ndimage as nd\nimport numpy as np\ndef surface_curvature(X,Y,Z):\n\n\t(lr,lb)=X.shape\n\n\tprint(lr)\n\t#print(""awfshss-------------"")\n\tprint(lb)\n#First Derivatives\n\tXv,Xu=np.gradient(X)\n\tYv,Yu=np.gradient(Y)\n\tZv,Zu=np.gradient(Z)\n#\tprint(Xu)\n\n#Second Derivatives\n\tXuv,Xuu=np.gradient(Xu)\n\tYuv,Yuu=np.gradient(Yu)\n\tZuv,Zuu=np.gradient(Zu)   \n\n\tXvv,Xuv=np.gradient(Xv)\n\tYvv,Yuv=np.gradient(Yv)\n\tZvv,Zuv=np.gradient(Zv) \n\n#2D to 1D conversion \n#Reshape to 1D vectors\n\tXu=np.reshape(Xu,lr*lb)\n\tYu=np.reshape(Yu,lr*lb)\n\tZu=np.reshape(Zu,lr*lb)\n\tXv=np.reshape(Xv,lr*lb)\n\tYv=np.reshape(Yv,lr*lb)\n\tZv=np.reshape(Zv,lr*lb)\n\tXuu=np.reshape(Xuu,lr*lb)\n\tYuu=np.reshape(Yuu,lr*lb)\n\tZuu=np.reshape(Zuu,lr*lb)\n\tXuv=np.reshape(Xuv,lr*lb)\n\tYuv=np.reshape(Yuv,lr*lb)\n\tZuv=np.reshape(Zuv,lr*lb)\n\tXvv=np.reshape(Xvv,lr*lb)\n\tYvv=np.reshape(Yvv,lr*lb)\n\tZvv=np.reshape(Zvv,lr*lb)\n\n\tXu=np.c_[Xu, Yu, Zu]\n\tXv=np.c_[Xv, Yv, Zv]\n\tXuu=np.c_[Xuu, Yuu, Zuu]\n\tXuv=np.c_[Xuv, Yuv, Zuv]\n\tXvv=np.c_[Xvv, Yvv, Zvv]\n\n#% First fundamental Coeffecients of the surface (E,F,G)\n\t\n\tE=np.einsum(\'ij,ij->i\', Xu, Xu) \n\tF=np.einsum(\'ij,ij->i\', Xu, Xv) \n\tG=np.einsum(\'ij,ij->i\', Xv, Xv) \n\n\tm=np.cross(Xu,Xv,axisa=1, axisb=1) \n\tp=np.sqrt(np.einsum(\'ij,ij->i\', m, m)) \n\tn=m/np.c_[p,p,p]\n# n is the normal\n#% Second fundamental Coeffecients of the surface (L,M,N), (e,f,g)\n\tL= np.einsum(\'ij,ij->i\', Xuu, n) #e\n\tM= np.einsum(\'ij,ij->i\', Xuv, n) #f\n\tN= np.einsum(\'ij,ij->i\', Xvv, n) #g\n\n# Alternative formula for gaussian curvature in wiki \n# K = det(second fundamental) / det(first fundamental)\n#% Gaussian Curvature\n\tK=(L*N-M**2)/(E*G-F**2)\n\tK=np.reshape(K,lr*lb)\n#\tprint(K.size)\n#wiki trace of (second fundamental)(first fundamental inverse)\n#% Mean Curvature\n\tH = ((E*N + G*L - 2*F*M)/((E*G - F**2)))/2\n\tprint(H.shape)\n\tH = np.reshape(H,lr*lb)\n#\tprint(H.size)\n\n#% Principle Curvatures\n\tPmax = H + np.sqrt(H**2 - K)\n\tPmin = H - np.sqrt(H**2 - K)\n#[Pmax, Pmin]\n\tPrinciple = [Pmax,Pmin]\n\treturn Principle\n\n\ndef fun(x,y):\n\treturn x**2+y**2\nx = scipy.linspace(-1,1,20)\ny = scipy.linspace(-1,1,20)\n[x,y]=scipy.meshgrid(x,y)\n\nz = (x**3 +y**2 +x*y)\n#s = nd.gaussian_filter(z,10)\ntemp1 = surface_curvature(x,y,z)\nprint(""maximum curvatures"")\nprint(temp1[0])\nprint(""minimum curvatures"")\nprint(temp1[1])\nfig = pylab.figure()\nax = Axes3D(fig)\n\nax.plot_surface(x,y,z)\npylab.show()\n'"
