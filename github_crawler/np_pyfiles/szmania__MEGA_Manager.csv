file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\nwith open(\'megamanager/version.py\') as f: exec(f.read())\n\nsetup(\n    name=\'megamanager\',\n\n    version=__version__,\n    description=\'Multiple MEGA.co.nz account manager that has synchronization and compression capabilities. \',\n    url=\'https://github.com/szmania/MEGA_Manager\',\n    author=\'Curtis Szmania\',\n    author_email=\'szmania@yahoo.com\',\n\n    license=\'GNU General Public License v3.0\',\n\n    classifiers=[\n        \'Development Status :: 3 - Alpha\',\n        \'Intended Audience :: Developers\',\n        \'License :: OSI Approved :: GNU General Public License v3 (GPLv3)\',\n        \'Programming Language :: Python :: 2\',\n    ],\n\n    keywords=[\'megamanager\', \'mega\', \'mega.co.nz\', \'mega.nz\', \'cloud\'\n              \'compression\'],\n\n    packages=[""megamanager""],\n\n    install_requires=[\'numpy\', \'psutil\'],\n    entry_points={\n        \'console_scripts\': [\n            \'megamanager = megamanager.__main__:main\',\n        ],\n    },\n)\n'"
megamanager/__init__.py,0,"b'from .account import Account\nfrom .mega_manager import MegaManager\nfrom .path_mapping import PathMapping\nfrom .syncprofile import SyncProfile\n# from tools.compressImages.compressImages import CompressImage, DeleteBackupImage\n# from tools import CompressImage, DeleteBackupImage\nfrom .version import *\n'"
megamanager/__main__.py,0,"b'\nfrom argparse import ArgumentParser\nfrom mega_manager import MegaManager\nfrom os import path, sep\n# from mega_manager import MEGA_MANAGER_CONFIG_FILE_PATH, MegaManager\n\nHOME_DIRECTORY = path.expanduser(""~"")\nMEGA_MANAGER_CONFIG_DIR = ""{HOME_DIRECTORY}{sep}.mega_manager"".format(HOME_DIRECTORY=HOME_DIRECTORY, sep=sep)\nMEGA_MANAGER_CONFIG_FILE_PATH = ""{MEGA_MANAGER_CONFIG_DIR}{sep}mega_manager.cfg"".format(MEGA_MANAGER_CONFIG_DIR=MEGA_MANAGER_CONFIG_DIR,\n                                                                                        sep=sep)\n\ndef get_args():\n    """"""\n    Get arguments from command line, and returns them as dictionary.\n\n    Returns:\n        Dictionary: Dictionary of arguments for MEGA Manager.\n    """"""\n\n    parser = ArgumentParser(description=\'MEGA Manager is a MEGA cloud storage management and optimization application.\')\n\n    parser.add_argument(\'--compress\', dest=\'compress_all\', action=\'store_true\', default=False,\n                        help=\'If true, this will compress local image and video files.\')\n\n    parser.add_argument(\'--compress-images\', dest=\'compress_images\', action=\'store_true\', default=False,\n                        help=\'If true, this will compress local image files.\')\n\n    parser.add_argument(\'--compress-videos\', dest=\'compress_videos\', action=\'store_true\', default=False,\n                        help=\'If true, this will compress local video files.\')\n\n    parser.add_argument(\'--config\', dest=\'mega_manager_config_path\', default=MEGA_MANAGER_CONFIG_FILE_PATH,\n                        help=\'Set MEGA Manager config file location. Default: ""{}""\'.format(MEGA_MANAGER_CONFIG_FILE_PATH))\n\n    parser.add_argument(\'--download\', dest=\'download\', action=\'store_true\', default=False,\n                        help=\'If true, items will be downloaded from MEGA\')\n\n    parser.add_argument(\'--download-speed\', dest=\'mega_download_speed\', type=int, default=None,\n                        help=\'Total download speed limit in kilobytes.\')\n\n    parser.add_argument(\'--log\', dest=\'log_level\', default=None,\n                        help=\'Set logging level\')\n\n    parser.add_argument(\'--profile-output-data\', dest=\'mega_manager_output_profile_data_path\', action=\'store_true\', default=False,\n                        help=\'If true, this will output all profile data to standard output.\')\n\n    parser.add_argument(\'--remove-oldest-file-version\', dest=\'remove_oldest_file_version\', action=\'store_true\', default=False,\n                        help=\'If true, this will remove outdated files locally or remotely that are older than their \'\n                             \'local/remote counterpart (syncing action).\')\n\n    parser.add_argument(\'--remove-remote\', dest=\'remove_remote\', action=\'store_true\', default=False,\n                        help=\'If true, this will allow for remote files to be removed if no corresponding \'\n                             \'local file exists.\')\n\n    parser.add_argument(\'--sync\', dest=\'sync\', action=\'store_true\', default=False,\n                        help=\'If true, local and remote files for accoutns will be synced. Equivalent to \'\n                             \'using arguments ""--download"", ""--removeLocal"", ""--removeRemote"" and ""--upload"" \'\n                             \'all at once.\')\n\n    parser.add_argument(\'--upload\', dest=\'upload\', action=\'store_true\', default=False,\n                        help=\'If true, items will be uploaded to MEGA\')\n\n    parser.add_argument(\'--upload-speed\', dest=\'mega_upload_speed\', type=int, default=None,\n                        help=\'Total upload speed limit in kilobytes.\')\n\n    args = parser.parse_args()\n    return args.__dict__\n\n\ndef main():\n\n    kwargs = get_args()\n\n    megaObj = MegaManager(**kwargs)\n\n    megaObj.run()\n\n\nif __name__ == ""__main__"":\n\n    main()'"
megamanager/account.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 7/2/2017\n# Initial Creation.\n# MEGA account class. Used for MEGA account details.\n###\n\nfrom logging import getLogger\nfrom libs.lib import Lib\n\n__author__ = \'szmania\'\n\n\nclass Account(object):\n    def __init__(self, username, password, log_level=\'DEBUG\'):\n        """"""\n        Library for ffmpeg converter and encoder interaction.\n\n        Args:\n            username (str): MEGA account user name\n            password (str): MEGA account password\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n\n        self.__username = username\n        self.__password = password\n        self.__log_level = log_level\n        \n        self.__freeSpace = None\n        self.__totalSpace = None\n        self.__usedSpace = None\n\n        self.__lib = Lib(log_level=log_level)\n\n    @property\n    def freeSpace(self):\n        """"""\n        Getter for MEGA account free space.\n\n        Returns:\n            String: Returns MEGA account free space\n        """"""\n\n        logger = getLogger(\'Account.free_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__freeSpace\n\n    @freeSpace.setter\n    def freeSpace(self, value):\n        """"""\n        Setter for MEGA account free space.\n\n        Args:\n            value (str): value to set account free space to.\n        """"""\n\n        logger = getLogger(\'Account.free_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__freeSpace = value\n\n    @property\n    def totalSpace(self):\n        """"""\n        Getter for MEGA account total space.\n\n        Returns:\n            String: Returns MEGA account total space\n        """"""\n\n        logger = getLogger(\'Account.total_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__totalSpace\n\n    @totalSpace.setter\n    def totalSpace(self, value):\n        """"""\n        Setter for MEGA account free space.\n\n        Args:\n            value (str): value to set account total space to.\n        """"""\n\n        logger = getLogger(\'Account.total_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__totalSpace = value\n\n\n    @property\n    def usedSpace(self):\n        """"""\n        Getter for MEGA account used space.\n\n        Returns:\n            String: Returns MEGA account used space\n        """"""\n\n        logger = getLogger(\'Account.used_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__usedSpace\n\n    @usedSpace.setter\n    def usedSpace(self, value):\n        """"""\n        Setter for MEGA account used space.\n\n        Args:\n            value (str): value to set account used space to.\n        """"""\n\n        logger = getLogger(\'Account.used_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__usedSpace = value\n\n    @property\n    def password(self):\n        """"""\n        Getter for MEGA account password.\n\n        Returns:\n            String: Returns MEGA account password\n        """"""\n\n        logger = getLogger(\'Account.password\')\n        logger.setLevel(self.__log_level)\n\n        return self.__password\n\n    @password.setter\n    def password(self, value):\n        """"""\n        Setter for MEGA account password.\n\n        Args:\n            value (str): value to set password to.\n        """"""\n\n        logger = getLogger(\'Account.password\')\n        logger.setLevel(self.__log_level)\n\n        self.__password = value\n\n    @property\n    def username(self):\n        """"""\n        Getter for MEGA account username.\n\n        Returns:\n            String: Returns MEGA account username\n        """"""\n\n        logger = getLogger(\'Account.username\')\n        logger.setLevel(self.__log_level)\n\n        return self.__username\n\n    @username.setter\n    def username(self, value):\n        """"""\n        Setter for MEGA account username.\n\n        Args:\n            value (str): value to set username to.\n        """"""\n\n        logger = getLogger(\'Account.username\')\n        logger.setLevel(self.__log_level)\n\n        self.__username = value\n\n'"
megamanager/mega_manager.py,0,"b'###\n# Created by: Curtis Szmania\n# Date: 10/1/2015\n# Initial Creation\n###\n# Modified by: Curtis Szmania\n# Date: 5/21/2017\n# Pep8 compliant.\n###\nfrom ast import literal_eval\nfrom datetime import datetime\nfrom configparser import ConfigParser\nfrom logging import DEBUG, getLogger, FileHandler, Formatter, StreamHandler\nfrom libs.lib import Lib\nfrom libs.compress_images_lib import CompressImages_Lib\nfrom libs.ffmpeg_lib import FFMPEG_Lib\nfrom libs.mega_tools_lib import MegaTools_Lib\nfrom os import path, remove, sep, walk\nfrom path_mapping import PathMapping\nfrom platform import system\nfrom random import shuffle\nfrom re import findall, IGNORECASE, match, search, sub\nfrom string import Formatter as string_formatter\nfrom syncprofile import SyncProfile\nfrom sys import stdout\nimport sys\nfrom threading import Thread\nfrom time import sleep, time\n\n\nreload(sys)\nsys.setdefaultencoding(\'utf-8\')\n\n__author__ = \'szmania\'\n\nHOME_DIRECTORY = path.expanduser(""~"")\n\n\n# MEGAMANAGER_CONFIG = \'megaManager.cfg\'\n\n# MEGA_ACCOUNTS_DATA = ""megaAccounts_DATA.txt""\n# MEGA_TOOLS_PATH = \'\'\n# MEGA_ACCOUNTS = \'\'\n# LOCAL_ROOT = \'\'\n# REMOTE_ROOT = \'\'\n\n# COMPRESSION_IMAGE_EXTENSIONS = [\'jpg\', \'jpeg\', \'png\']\n# COMPRESSION_VIDEO_EXTENSIONS = [\'avi\', \'flv\', \'m4v\', \'mkv\', \'mp4\', \'mpeg\', \'mpg\', \'wmv\']\n# IMAGE_TEMP_FILE_EXTENSIONS = [\'compressimages-backup\']\n\n# COMPRESSION_FFMPEG_VIDEO_PRESET = \'medium\'\n\n# HOME_DIRECTORY = path.expanduser(""~"")\n# TEMP_LOGFILE_PATH = gettempdir() + \'{sep}megaManager_error_files_{randint}.tmp\'.format(sep=sep,\n#                                                                                        randint=randint(0, 9999999999))\n\n\n# MEGA_MANAGER_CONFIG_DIR = HOME_DIRECTORY + ""{sep}.mega_manager"".format(sep=sep)\n# MEGA_MANAGER_CONFIG_DIR_DATA = MEGA_MANAGER_CONFIG_DIR + \'{sep}data\'.format(sep=sep)\n# MEGA_MANAGER_CONFIG_FILE_PATH = MEGA_MANAGER_CONFIG_DIR + ""{sep}mega_manager.cfg"".format(sep=sep)\n\n# COMPRESSED_IMAGES_FILE = MEGA_MANAGER_CONFIG_DIR_DATA + ""{sep}compressed_images.npy"".format(sep=sep)\n# UNABLE_TO_COMPRESS_IMAGES_FILE = MEGA_MANAGER_CONFIG_DIR_DATA + ""{sep}unable_to_compress_images.npy"".format(sep=sep)\n# COMPRESSED_VIDEOS_FILE = MEGA_MANAGER_CONFIG_DIR_DATA + ""{sep}compressed_videos.npy"".format(sep=sep)\n# UNABLE_TO_COMPRESS_VIDEOS_FILE = MEGA_MANAGER_CONFIG_DIR_DATA + ""{sep}unable_to_compress_videos.npy"".format(sep=sep)\n# REMOVED_REMOTE_FILES = MEGA_MANAGER_CONFIG_DIR_DATA + \'{sep}removed_remote_files.npy\'.format(sep=sep)\n\n# LOGFILE_STDOUT = MEGA_MANAGER_CONFIG_DIR + \'{sep}logs{sep}mega_stdout.log\'.format(sep=sep)\n# LOGFILE_STDERR = MEGA_MANAGER_CONFIG_DIR + \'{sep}logs{sep}mega_stderr.log\'.format(sep=sep)\n# MEGAMANAGER_LOGFILEPATH = MEGA_MANAGER_CONFIG_DIR + \'{sep}logs{sep}mega_manager_log.log\'.format(sep=sep)\n\n# MEGA_TOOLS_DIR = \'tools\\\\megaTools_1_1_98\'\n# FFMPEG_EXE_PATH = \'tools{sep}ffmpeg{sep}ffmpeg.exe\'.format(sep=sep)\n\n# PROCESS_SET_PRIORITY_TIMEOUT = 60\n\n# SCRIPT_DIR = path.dirname(path.realpath(__file__))\n# SLEEP_TIME_BETWEEN_RUNS_SECONDS = 300  # 5 minutes\nWORKING_DIR = path.dirname(path.realpath(__file__))\n\n\nclass MegaManager(object):\n    def __init__(self, **kwargs):\n        self.__threads = []\n        self.__download = None\n        self.__sync = None\n        self.__upload = None\n        self.__local_is_truth = None\n        self.__remove_outdated = None\n        self.__compress_all = None\n        self.__compress_images = None\n        self.__compress_videos = None\n        self.__log_level = None\n\n        self.__compressed_image_files = set()\n        self.__compressed_video_files = set()\n        self.__unable_to_compress_image_files = set()\n        self.__unable_to_compress_video_files = set()\n        self.__removed_remote_files = set()\n\n        self.__sleep_time_between_runs_seconds = None\n\n        self.__mega_manager_config_dir_path = None\n        self.__mega_manager_config_dir_data_path = None\n        self.__mega_manager_log_path = None\n        self.__mega_manager_output_profile_data_path = None\n        self.__compressed_images_file_path = None\n        self.__compressed_videos_file_path = None\n        self.__compression_image_extensions = []\n        self.__compression_video_extensions = []\n        self.__image_temp_file_extensions = []\n        self.__compression_ffmpeg_video_preset = None\n        # self.__megaManager_configPath = MEGAMANAGER_CONFIG\n        self.__removed_remote_files_path = None\n        self.__unable_to_compress_images_file_path = None\n        self.__unable_to_compress_videos_file_path = None\n        self.__process_set_priority_timeout = None\n        self.__megatools_process_priority_class = None\n        self.__megatools_log_path = None\n        self.__mega_download_speed = None\n        self.__mega_upload_speed = None\n        self.__ffmpeg_process_priority_class = None\n        self.__ffmpeg_log_path = None\n        self.__ffmpeg_threads = None\n\n        # self.__mega_tools_dir = MEGA_TOOLS_DIR\n        # self.__ffmpeg_exe_path = FFMPEG_EXE_PATH\n\n        self.__sync_profiles = []\n\n        self._setup(kwargs=kwargs)\n\n    def _assign_attributes(self, **kwargs):\n        """"""\n        Assign argumetns to class attributes.\n\n        Args:\n            kwargs (dict):  Dictionary of arguments.\n        """"""\n\n        for key, value in kwargs.items():\n            if value:\n                setattr(self, \'_MegaManager__%s\' % key, value)\n\n    def _compress_image_file(self, file_path):\n        """"""\n        Compress given image file path.\n\n        Args:\n            file_path: Path to image file to compress.\n\n        Returns:\n            Boolean: Whether compression operation was successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._compress_image_file\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Compressing image file: ""{}""\'.format(file_path))\n        compressed = self.__compress_images_lib.compress_image_file(file_path=file_path,\n                                                                    jpeg_compression_quality_percentage=\n                                                                    self.__compression_jpeg_quality_percentage,\n                                                                    delete_backup=True,\n                                                                    delete_corrupt_images=True)\n        if compressed:\n            logger.debug(\' Image file compressed successfully ""%s""!\' % file_path)\n            file_md5_hash = self.__lib.get_file_md5_hash(file_path)\n            self.__compressed_image_files.add(file_md5_hash)\n            self.__lib.dump_set_into_numpy_file(item_set=self.__compressed_image_files,\n                                                file_path=self.__compressed_images_file_path)\n            return True\n\n        else:\n            logger.debug(\' Error, image file could not be compressed ""%s""!\' % file_path)\n            file_md5_hash = self.__lib.get_file_md5_hash(file_path)\n            self.__unable_to_compress_image_files.add(file_md5_hash)\n            self.__lib.dump_set_into_numpy_file(item_set=self.__unable_to_compress_image_files,\n                                                file_path=self.__unable_to_compress_images_file_path)\n            return False\n\n    def _compress_image_files(self, local_root):\n        """"""\n        Find image files to compress.\n\n        Args:\n            local_root (str): Local path to search for image files to compress\n\n        Returns:\n            Boolean: Returns whether operation was successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._compress_image_files\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Compressing image files.\')\n\n        try:\n            if path.exists(local_root):\n                local_files = [path.join(full_path, name) for full_path, subdirs, files in walk(local_root) for name in files]\n                # local_files = [path.join(local_root, f) for f in listdir(local_root) if path.isfile(path.join(local_root, f))]\n            else:\n                raise PathMappingDoesNotExist(\' Path mapping does not exist: {}\'.format(local_root))\n\n            if local_files:\n                for local_file_path in local_files:\n                    local_file_ext = local_file_path.split(\'.\')[-1]\n                    if local_file_ext in self.__image_temp_file_extensions or search(\'^.*\\.megatmp\\..*$\', local_file_path):\n                        logger.warning(\' File ""{}"" is temporary file. Deleting.\'.format(local_file_path))\n                        self.__lib.delete_local_file(local_file_path)\n                        continue\n\n                    for compress_image_ext in self.__compression_image_extensions:\n                        if match(local_file_ext, compress_image_ext, IGNORECASE) and path.isfile(local_file_path):\n                            file_md5_hash = self.__lib.get_file_md5_hash(local_file_path)\n                            if (file_md5_hash not in self.__compressed_image_files) \\\n                                    and (file_md5_hash not in self.__unable_to_compress_image_files):\n                                self._compress_image_file(file_path=local_file_path)\n\n            return True\n\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _compress_video_file(self, file_path):\n        """"""\n        Compress given video file path.\n\n        Args:\n            file_path: Path to video file to compress.\n\n        Returns:\n            Boolean: Whether compression operation was successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._compress_video_file\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Compressing video file: ""{}""\'.format(file_path))\n        temp_file_path = file_path.rsplit(""."", 1)[0] + \'_NEW.mp4\'\n\n        result = self.__ffmpeg_lib.compress_video_file(source_path=file_path, target_path=temp_file_path,\n                                                       compression_preset=self.__compression_ffmpeg_video_preset,\n                                                       ffmpeg_threads=self.__ffmpeg_threads, overwrite=True,\n                                                       process_priority_class=self.__ffmpeg_process_priority_class,\n                                                       process_set_priority_timeout=self.__process_set_priority_timeout)\n\n        self._compress_video_file_teardown(result, file_path, temp_file_path)\n        return result\n\n    def _compress_video_file_setup(self, file_path, temp_file_path):\n        """"""\n        Setup for compress video file.\n\n        Args:\n            file_path (str): File path to compress.\n            temp_file_path (str): Temporary file path.\n        """"""\n        logger = getLogger(\'MegaManager._compress_video_file_setup\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Video file compression setup.\')\n\n        if path.exists(temp_file_path):\n            self.__lib.delete_local_file(file_path=temp_file_path)\n\n        for ext in self.__compression_video_extensions:\n            possible_prev_file_path = file_path.rsplit(""."", 1)[0] + ext\n            if path.exists(possible_prev_file_path):\n                self.__lib.delete_local_file(file_path=possible_prev_file_path)\n\n    def _compress_video_file_teardown(self, result, file_path, temp_file_path):\n        """"""\n        Teardown for compress video file.\n\n        Args:\n            result (bool): Result of video file compression.\n            file_path (str): File path to compress.\n            temp_file_path (str): Temporary file path.\n        """"""\n        logger = getLogger(\'MegaManager._compress_video_file_teardown\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Video file compression teardown.\')\n\n        if result and path.exists(temp_file_path):\n\n            if path.exists(file_path):\n                self.__lib.delete_local_file(file_path=file_path)\n\n            new_file_path = sub(\'_NEW\', \'\', temp_file_path)\n            if path.exists(new_file_path):\n                self.__lib.delete_local_file(file_path=new_file_path)\n\n            if not self.__lib.rename_file(old_name=temp_file_path, new_name=new_file_path):\n                self.__lib.delete_local_file(file_path=temp_file_path)\n\n            logger.debug(\' Video file compressed successfully ""%s"" into ""%s""!\' % (\n                file_path, new_file_path))\n            file_md5_hash = self.__lib.get_file_md5_hash(new_file_path)\n            self.__compressed_video_files.add(file_md5_hash)\n            self.__lib.dump_set_into_numpy_file(item_set=self.__compressed_video_files, file_path=self.__compressed_videos_file_path)\n\n        elif path.exists(temp_file_path):\n            logger.debug(\' Error, video file could not be compressed ""%s""!\' % file_path)\n            logger.debug(\' Deleting temporary file ""%s""!\' % temp_file_path)\n            self.__lib.delete_local_file(file_path=temp_file_path)\n\n        else:\n            logger.debug(\' Error, video file could not be compressed ""%s""!\' % file_path)\n            file_md5_hash = self.__lib.get_file_md5_hash(file_path)\n            self.__unable_to_compress_video_files.add(file_md5_hash)\n            self.__lib.dump_set_into_numpy_file(item_set=self.__unable_to_compress_video_files,\n                                                file_path=self.__unable_to_compress_videos_file_path)\n\n        logger.debug(\' Successfully completed video file compression teardown.\')\n\n    def _compress_video_files(self, local_root):\n        """"""\n        Find video files to compress.\n\n        Args:\n            local_root (str): Local path to search for image files to compress\n\n        Returns:\n            Boolean: Whether operation is successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._compress_video_files\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Finding video files to compress in: ""{}""\'.format(local_root))\n\n        try:\n            if path.exists(local_root):\n                local_files = [path.join(full_path, name) for full_path, subdirs, files in walk(local_root) for name in files]\n                if local_files:\n                    for local_file_path in local_files:\n                        if local_file_path.endswith(\'_NEW.mp4\') or search(\'^.*\\.megatmp\\..*$\', local_file_path):\n                            logger.warning(\' File ""{}"" is a temporary file. Deleting.\'.format(local_file_path))\n                            self.__lib.delete_local_file(local_file_path)\n                            continue\n\n                        local_file_ext = local_file_path.split(\'.\')[-1]\n                        # local_file_ext = path.splitext(local_file_path)[1]\n                        for compress_video_ext in self.__compression_video_extensions:\n                            if match(local_file_ext, compress_video_ext, IGNORECASE):\n                                file_md5_hash = self.__lib.get_file_md5_hash(local_file_path)\n                                if (file_md5_hash not in self.__compressed_video_files) \\\n                                    and (file_md5_hash not in self.__unable_to_compress_video_files):\n\n                                    self._compress_video_file(file_path=local_file_path)\n                else:\n                    logger.warning(\' No files found in path: ""{}""\'.format(local_root))\n\n                logger.debug(\' Success, finished finding video files to compress in: ""{}""\'.format(local_root))\n                return True\n            else:\n                raise PathMappingDoesNotExist(\' Path mapping does not exist: ""{}""\'.format(local_root))\n\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_get_profile_data(self, profile):\n        """"""\n        Create thread to create profiles data file.\n\n        Args:\n            profile (Profile): Profile object\n\n        Returns:\n            Boolean: Whether operation was successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_get_profile_data\')\n        logger.setLevel(self.__log_level)\n\n        # logger.debug(\' Creating thread to create ""%s"" file.\' % self.__mega_accounts_output_path)\n\n        try:\n            t = Thread(target=self._get_profile_data, args=(profile,),\n                       name=\'thread_get_profile_data_{}\'.format(profile.profile_name))\n            self.__threads.append(t)\n            t.start()\n            return True\n        except Exception as e:\n            logger.warning(\'Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_download(self, profile):\n        """"""\n        Create thread to download files.\n\n        Args:\n            profile (Profile): Profile object\n\n        Returns:\n            Boolean: Whether operation was successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_download\')\n        logger.setLevel(self.__log_level)\n\n        try:\n            logger.debug(\' Creating thread to download files from MEGA account profile {}.\'.format(profile.profile_name))\n\n            t = Thread(target=self._thread_download_profile_files, args=(profile,),\n                       name=\'thread_download_{}\'.format(profile.profile_name))\n            self.__threads.append(t)\n            t.start()\n            return True\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_upload(self, profile):\n        """"""\n        Create thread to upload files.\n\n        Args:\n            profile (Profile): Profile object\n\n        Returns:\n            Boolean: Whether operation was successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_upload\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Creating thread to upload files to MEGA accounts.\')\n\n        try:\n            t = Thread(target=self._thread_upload_profile_files, args=(profile, ),\n                       name=\'thread_upload_{}\'.format(profile.profile_name))\n            self.__threads.append(t)\n            t.start()\n            return True\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_remove_remote_files_that_dont_exist_locally(self, profile):\n        """"""\n        Create threads to remove remote files that don\'t exist locally.\n\n        Args:\n            profile (Profile): Profile object\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._create_thread_remove_remote_files_that_dont_exist_locally\')\n        logger.setLevel(self.__log_level)\n        try:\n            logger.debug(\' Creating thread to remove remote files that dont exist locally for profile {}.\'.format(\n                profile.profile_name))\n            t_remove_remote_files_dont_exist_locally = Thread(target=self._thread_remove_remote_files_that_dont_exist_locally,\n                                                              args=(profile,),\n                                             name=\'thread_remove_remote_files_dont_exist_locally_{}\'.format(\n                                                 profile.profile_name))\n            self.__threads.append(t_remove_remote_files_dont_exist_locally)\n            t_remove_remote_files_dont_exist_locally.start()\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_compress_image_files(self, sync_profiles):\n        """"""\n        Create thread to compress image files.\n\n        Args:\n            sync_profiles (SyncProfile): SyncProfiles objects\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_compress_image_files\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Creating thread to compress local image files\')\n\n        try:\n            t_compress = Thread(target=self._thread_sync_profiles_image_compression, args=(sync_profiles,), name=\'thread_compress_images\')\n            self.__threads.append(t_compress)\n            t_compress.start()\n            return True\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_compress_video_files(self, sync_profiles):\n        """"""\n        Create thread to compress video files.\n\n        Args:\n            sync_profiles (SyncProfile): SyncProfile objects\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_compress_video_files\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Creating thread to compress local video files.\')\n\n        try:\n            t_compress = Thread(target=self._thread_sync_profiles_video_compression, args=(sync_profiles,), name=\'thread_compress_videos\')\n            self.__threads.append(t_compress)\n            t_compress.start()\n            return True\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _create_thread_output_profile_data(self, profile):\n        """"""\n        Create thread to output profile data\n\n        Args:\n            profile (Profile): Profile object\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._create_thread_output_profile_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Creating thread to output profile data for {}\'.format(profile.profile_name))\n\n        try:\n            t_output = Thread(target=self._thread_output_profile_data, args=(profile,), name=\'thread_output_profile_data_{}\'.format(profile.profile_name))\n            self.__threads.append(t_output)\n            t_output.start()\n            return True\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _export_accounts_details_dict(self):\n        """"""\n        Dump self.__accounts_details_dict to file.\n\n        """"""\n\n        logger = getLogger(\'MegaManager._export_accounts_details_dict\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Exporting config data to MEGA Manager config file.\')\n\n        # with open(self.__mega_accounts_output_path, ""w"") as outs:\n        #     for username in sorted(self.__accounts_details_dict):\n        #         accountObj = self.__accounts_details_dict[username]\n        #         lines = []\n        #         line = \'Total Space: \' + str(accountObj.remote_total_space)\n        #         lines.append(line)\n        #         line = \'Used Space: \' + str(accountObj.remote_used_space)\n        #         lines.append(line)\n        #         line = \'Free Space: \' + str(accountObj.remote_free_space)\n        #         lines.append(line)\n        #         outs.write(lines)\n        # outs.close()\n\n    def _export_config_file_data(self, config_parser):\n        """"""\n        Export config file data.\n\n        Args:\n            config_parser (ConfigParser): Config parser object of config file.\n\n        """"""\n\n        logger = getLogger(\'MegaManager._export_config_file_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Exporting config data to MEGA Manager config file.\')\n        try:\n            with open(self.__mega_manager_config_path, \'w\') as config_file:\n                config_parser.write(config_file)\n            # with open(self.__mega_manager_config_path, ""w"") as outs:\n            #     outs.write(\'MEGA_TOOLS_DIR=%s\' % str(self.__mega_tools_dir))\n            #     outs.write(\'FFMPEG_EXE_PATH=%s\' % str(self.__ffmpeg_exe_path))\n            #     outs.write(\'SLEEP_TIME_BETWEEN_RUNS_SECONDS=%s\' % str(self.__sleep_time_between_runs_seconds))\n            #\n            #     profileCount = 0\n            #     for profile in self.__sync_profiles:\n            #         profileCount += 1\n            #         outs.write(\'[Profile%d]\' % profileCount)\n            #         outs.write(\'ProfileName=%s\' % str(profile.profile_name))\n            #         outs.write(\'Username=%s\' % str(profile.account.username))\n            #         outs.write(\'Password=%s\' % str(profile.account.password))\n            #\n            #         pathMappingsCount = 0\n            #         for pathMapping in profile.path_mappings:\n            #             pathMappingsCount += 1\n            #             outs.write(\'LocalPath%d=%s\' % (pathMappingsCount, str(pathMapping.local_path)))\n            #             outs.write(\'RemotePath%d=%s\' % (pathMappingsCount, str(pathMapping.remotPath)))\n            #\n            # outs.close()\n            return True\n        except Exception as e:\n            logger.error(\' Exception: %s\' % str(e))\n            return False\n\n\n    def _get_accounts_user_pass(self, file):\n        """"""\n        Get username and password from file with lines of ""<username> - <password>""\n\n        Args:\n            file (str): file in format with lines:\n\n                ""<username> - <password>""\n                ""<username2> - <password2>""\n\n            Where <username> is account username and <password> is account password.\n\n        Returns:\n            Returns list of dictionaries holding user and pass.\n        """"""\n\n        logger = getLogger(\'MegaManager._get_accounts_user_pass\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting usernames and passwords.\')\n\n        foundUserPass = []\n\n        try:\n            with open(file, ""r"") as ins:\n                for line in ins:\n                    dict = {}\n                    if len(findall(\'-\', line)) > 0 and len(findall(\'@\', line)) > 0:\n                        username = sub(\'\\\\n\', \'\', sub(\' - .*\', \'\', line))\n                        password = sub(\'\\\\n\', \'\', sub(\'.* - \', \'\', line))\n\n                        dict[\'user\'] = username\n                        dict[\'pass\'] = password\n                        foundUserPass.append(dict)\n            ins.close()\n        except Exception as e:\n            logger.warning(\' Exception: %s\' % str(e))\n\n        return foundUserPass\n\n    def _get_profile_data(self, profile):\n        """"""\n        Create self.__mega_accounts_output_path file. File that has all fetched data of accounts and local and remote spaces of each account.\n\n        Args:\n            profile (Profile): Profile object\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._get_profile_data\')\n        logger.setLevel(self.__log_level)\n\n        # logger.debug(\' Creating MEGA accounts output file.\')\n\n        try:\n            # self.__accounts_details_dict = {}\n            # with open(self.__mega_accounts_output_path, ""w"") as outs:\n            # for profile in self.__sync_profiles:\n            logger.debug(\' Creating thread to gather details for profile ""%s"".\' % profile.profile_name)\n\n            self._get_profile_details(profile=profile)\n            # t_megaFile = Thread(target=self._get_profile_details, args=(profile, ),\n            #                     name=\'thread_get_profile_data_%s\' % profile.profile_name)\n            # t_megaFile.start()\n            # self.__threads.append(t_megaFile)\n\n            # outs.close()\n            return True\n        except (Exception, KeyboardInterrupt)as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            # if path.exists(self.__mega_accounts_output_path + \'.old\'):\n            #     copyfile(self.__mega_accounts_output_path + \'.old\', self.__mega_accounts_output_path)\n            return False\n\n    def _get_profile_details(self, profile):\n        """"""\n        Creats dictionary of account data (remote size, local size, etc...) for self.__mega_accounts_output_path file.\n\n        Args:\n            profile (SyncProfile): Profile to get data for.\n        """"""\n\n        self._update_account_remote_details(account=profile.account)\n\n    def _get_remote_file_modified_date(self, username, password, localFilePath, localRoot, remoteRoot):\n        """"""\n        Get remote file modified date of equivalent local file path\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            localFilePath (str): Local file path of remote file size to get\n            localRoot (str): Local root path of local account files to map with remote root.\n            remoteRoot (str): Remote root path of remote accounts to map with local root.\n\n        Returns:\n             Tuple: Remote file modified data and remote file path\n        """"""\n\n        logger = getLogger(\'MegaManager.-get_remote_file_modified_date\')\n        logger.setLevel(self.__log_level)\n\n        remotePath = self.__lib.get_remote_path_from_local_path(localPath=localFilePath, localRoot=localRoot,\n                                                                remoteRoot=remoteRoot)\n        if remotePath:\n            return self.__mega_tools_lib.get_remote_file_modified_date(username=username, password=password,\n                                                                       remotePath=remotePath)\n        logger.warning(\' Remote file path could not be gotten.\')\n        return None\n\n    def _get_remote_files_that_dont_exist_locally(self, username, password, local_root, remote_root):\n        """"""\n        Get remote files that don\'t exist locally.\n\n        Args:\n            username (str): username of account to upload to\n            password (str): Password of account to upload to\n            local_root (str): Local path to download file to\n            remote_root (str): Remote path of file to download\n\n        Returns:\n            list of remote files that don\'t exist locally\n        """"""\n\n        logger = getLogger(\'MegaManager._get_remote_files_that_dont_exist_locally\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting remote files that do not exist locally on %s - %s.\' % (username, password))\n\n        remote_files = self.__mega_tools_lib.get_remote_file_paths_recursively(username=username, password=password,\n                                                                               remote_path=remote_root,\n                                                                               process_priority_class=self.__megatools_process_priority_class,\n                                                                               process_set_priority_timeout=self.__process_set_priority_timeout)\n        dont_exist_locally = []\n        try:\n            if remote_files:\n                for remote_file_path in remote_files:\n                    file_sub_path = sub(remote_root, \'\', remote_file_path)\n                    local_file_path = local_root + file_sub_path.replace(\'/\', \'{sep}\'.format(sep=sep))\n\n                    if not path.exists(local_file_path):\n                        found = False\n                        for not_exist_local_file_path in dont_exist_locally:\n                            if local_file_path in not_exist_local_file_path:\n                                found = True\n                                break\n                        if not found:\n                            dont_exist_locally.append(remote_file_path)\n\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n        finally:\n            return dont_exist_locally\n\n    def _import_config_file_data(self, ignore_config_actions):\n        """"""\n        Load config file data.\n\n        Args:\n            ignore_config_actions (bool): Whether to ignore config file OPTIONS section\n\n        Returns:\n            ConfigParser: Config parser object.\n        """"""\n        print(\' Loading MEGA Manager config file.\')\n\n        config_parser = ConfigParser()\n        try:\n            print(\' Loading config file: {}\'.format(self.__mega_manager_config_path))\n            if path.exists(self.__mega_manager_config_path):\n                config_parser.read(self.__mega_manager_config_path)\n            else:\n                raise Exception(\'Config file not found!\')\n        except Exception as e:\n            print(\' Exception: {}\'.format(e))\n            raise e\n\n        self._import_config_file_properties(config_parser=config_parser, ignore_config_actions=ignore_config_actions)\n        self._import_config_mega_profile_data(config_parser=config_parser)\n        print(\' Successfully imported sections from config file: {}\'.format(config_parser.sections()))\n        return config_parser\n\n\n    def _import_config_mega_profile_data(self, config_parser):\n        """"""\n        Load config profile data.\n\n        Args:\n            config_parser (object): ConfigParser object.\n        """"""\n        print(\' Loading MEGA profile data.\')\n        try:\n            sync_profile_obj = None\n            for section in config_parser:\n                profile_name = None\n                username = None\n                password = None\n                sync_profiles = []\n                if section.startswith(\'PROFILE_\'):\n                    profile_name = config_parser[section][\'profile_name\']\n                    username = config_parser[section][\'username\']\n                    password = config_parser[section][\'password\']\n                    path_mappings = []\n\n                    for entry in config_parser[section]:\n                        local_path = None\n                        remote_path = None\n                        path_mapping_entry = None\n                        if entry.startswith(\'local_path_\'):\n                            local_path = config_parser[section][entry]\n                            remote_path = config_parser[section][entry.replace(\'local_path_\',\'remote_path_\')]\n                            path_mapping_entry = PathMapping(local_path=local_path, remote_path=remote_path, log_level=self.__log_level)\n                            path_mappings.append(path_mapping_entry)\n                    sync_profile_obj = SyncProfile(profile_name=profile_name, username=username, password=password,\n                                                   path_mappings=path_mappings)\n                    self.__sync_profiles.append(sync_profile_obj)\n        except Exception as e:\n            print(\' Exception: {}\'.format(e))\n            raise e\n\n        print(\' Successfully loaded MEGA profile data from config.\')\n        return sync_profile_obj\n\n    def _import_config_file_properties(self, config_parser, ignore_config_actions):\n        """"""\n        Import config file data properties sections.\n\n        Args:\n            config_parser (ConfigParser): Config parser object.\n            ignore_config_actions (bool): Whether to ignore config file OPTIONS section\n\n        """"""\n        print(\' Loading MEGA Manager config file properties data.\')\n        config_key_values = {}\n        for section in config_parser.sections():\n            if not section.startswith(\'PROFILE_\') and (not ignore_config_actions or (ignore_config_actions and not section == \'ACTIONS\')):\n                for key, value in (config_parser[section].items()):\n                    try:\n                        placeholders_in_str = {}\n                        format_placeholders = [fn for _, fn, _, _ in string_formatter().parse(value) if fn is not None]\n                        found = False\n                        for format_placeholder in format_placeholders:\n                            if format_placeholder.lower() in config_key_values:\n                                found = True\n                                placeholders_in_str[format_placeholder] = config_key_values[format_placeholder.lower()].replace(\'""\',\'\')\n                        if \'sep\' in format_placeholders:\n                            found = True\n                            placeholders_in_str[\'sep\'] = sep\n                        if \'HOME_DIRECTORY\' in format_placeholders:\n                            found = True\n                            placeholders_in_str[\'HOME_DIRECTORY\'] = HOME_DIRECTORY.replace(\'""\',\'\')\n                        if found:\n                            value = value.format(**placeholders_in_str)\n                        setattr(self, \'_MegaManager__{}\'.format(key.lower()), literal_eval(value))\n                        config_key_values[key] = value\n                    except Exception as e:\n                        print(\' Exception: {}\'.format(e))\n                        raise e\n\n        print(\' Successfully loaded MEGA Manager config file properties data.\')\n\n    def _remove_outdated_files(self, username, password, local_root, remote_root):\n        """"""\n        Remove old versions of files.\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            local_root (str): Local path to download file to\n            remote_root (str): Remote path of file to download\n\n        Returns:\n            Boolean: Whether operation was successful or not.\n        """"""\n        logger = getLogger(\'MegaManager.remove_outdated_files\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Removing outdated files for username ""{}""\'.format(username))\n\n        try:\n            lines = self.__mega_tools_lib.get_remote_file_data_recursively(username=username, password=password,\n                                                                           remote_path=remote_root, remove_blank_lines=True)\n            if lines:\n                for line in lines:\n                    logger.debug(\' Processing line ""%s""\' % line)\n                    remote_file_type = self.__mega_tools_lib.get_file_type_from_megals_line_data(line=line)\n\n                    if remote_file_type == \'0\':\n                        remote_file_path = self.__mega_tools_lib.get_file_path_from_megals_line_data(line=line)\n                        remote_file_size = self.__mega_tools_lib.get_file_size_from_megals_line_data(line=line)\n                        remote_file_modified_date = self.__mega_tools_lib.get_file_date_from_megals_line_data(line=line)\n                        remote_file_modified_date_dt = datetime.strptime(remote_file_modified_date, \'%Y-%m-%d %H:%M:%S\')\n                        remote_root = remote_root.replace(\'/\', \'{sep}\'.format(sep=sep))\n                        local_root = local_root\n                        conv_remote_file_path = remote_file_path.replace(\'/\', \'{sep}\'.format(sep=sep))\n                        local_file_path = conv_remote_file_path.replace(remote_root, local_root)\n\n                        if path.exists(local_file_path):\n                            logger.debug(\' Local file exists. Determining if local file outdated compared to remote counterpart: ""%s""\' % local_file_path)\n                            local_file_size = path.getsize(local_file_path)\n\n                            if search(\'^.*\\.megatmp\\..*$\', local_file_path):\n                                logger.warning(\' File ""{}"" is temporary file. Deleting.\'.format(local_file_path))\n                                self.__lib.delete_local_file(local_file_path)\n                                continue\n\n                            local_file_modified_date = self.__lib.convert_epoch_to_mega_time(path.getmtime(local_file_path))\n                            local_file_modified_date_dt = datetime.strptime(local_file_modified_date, \'%Y-%m-%d %H:%M:%S\')\n\n                            if local_file_size != int(remote_file_size):\n                                if local_file_modified_date_dt > remote_file_modified_date_dt:\n                                    # local file is newer.\n                                    logger.debug(\' Local file is newer. Deleting remote file ""%s""\' % remote_file_path)\n\n                                    self.__mega_tools_lib.remove_remote_path(username=username, password=password,\n                                                                             remote_file_path=remote_file_path,\n                                                                             process_priority_class=self.__megatools_process_priority_class,\n                                                                             process_set_priority_timeout=self.__process_set_priority_timeout)\n                                    logger.debug(\' Success, removed local incomplete file ""{}""\'.format(local_file_path))\n\n                                else:\n                                    # remote file is newer\n                                    logger.debug(\' Remote file is newer. Deleting local file ""%s""\' % local_file_path)\n\n                                    for retry in range(100):\n                                        try:\n                                            remove(local_file_path)\n                                            logger.debug(\' Success, removed local incomplete file ""{}""\'.format(local_file_path))\n                                            break\n                                        except Exception as e:\n                                            logger.exception(\' Remove failed for remote file, ""{}"" retrying...\'.format(e))\n                        else:\n                            logger.debug(\' Local file does NOT exist: ""%s""\' % local_file_path)\n                    else:\n                        logger.debug(\' Remote location is not a file: ""{}""\'.format(line))\n            else:\n                logger.debug(\' No file list retrieved from MEGA for account ""{}""\'.format(username))\n\n            logger.debug(\' Finished removing outdated files for username ""{}""\'.format(username))\n            return True\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _remove_outdated_local_remote_files(self, profile):\n        """"""\n        Remove outdated local and remote files\n\n        Args:\n            profile (Profile): Profile object\n        """"""\n        logger = getLogger(\'MegaManager._remove_outdated_local_remote_files\')\n        logger.setLevel(self.__log_level)\n\n        try:\n            profile_name = profile.profile_name\n            logger.debug(\' Removing outdated files for {}\'.format(profile_name))\n            username = profile.account.username\n            password = profile.account.password\n\n            for pathMapping in profile.path_mappings:\n                local_path = pathMapping.local_path\n                remote_path = pathMapping.remote_path\n                self._remove_outdated_files(username=username, password=password, local_root=local_path,\n                                            remote_root=remote_path)\n        except Exception as e:\n            logger.error(\'Exception: {}\'.format(e))\n\n    def _remove_remote_files_that_dont_exist_locally(self, username, password, local_root, remote_root):\n        """"""\n        Remove remote files that don\'t exist locally.\n\n        Args:\n            username (str): username of account to upload to\n            password (str): Password of account to upload to\n            local_root (str): Local path to download file to\n            remote_root (str): Remote path of file to download\n\n        Returns:\n            Boolean: Whether operation is successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._remove_remote_files_that_dont_exist_locally\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Removing remote files that do not exist locally for account: ""{}""\'.format(username))\n        dont_exist_locally = self._get_remote_files_that_dont_exist_locally(username=username, password=password,\n                                                                            local_root=local_root, remote_root=remote_root)\n        try:\n            for file_path in dont_exist_locally:\n                file_md5_hash = self.__lib.get_file_md5_hash(file_path)\n                self.__removed_remote_files.add(file_md5_hash)\n                self.__mega_tools_lib.remove_remote_path(username=username, password=password,\n                                                         remote_file_path=file_path,\n                                                         process_priority_class=self.__megatools_process_priority_class,\n                                                         process_set_priority_timeout=self.__process_set_priority_timeout)\n                self.__lib.dump_set_into_numpy_file(item_set=self.__removed_remote_files,\n                                                    file_path=self.__removed_remote_files_path)\n            return True\n\n        except Exception as e:\n            logger.error(\'Exception: {}\'.format(e))\n            return False\n\n    def _remove_temp_files(self):\n        """"""\n        Remove MEGA Manager temporary files.\n\n        Returns:\n            Bool: Whether successful or not.\n        """"""\n        logger = getLogger(\'MegaManager._remove_temp_files\')\n        logger.setLevel(self.__log_level)\n\n        logger.info(\' Removing temporary files!\')\n        try:\n            # dir = self.__mega_manager_config_dir_data_path\n            # files = listdir(dir)\n            #\n            # for file in files:\n            #     if file.endswith(\'.npy\'):\n            #         file_path = dir + \'{sep}\'.format(sep=sep) + file\n            #         self.__lib.delete_local_file(file_path=file_path)\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _setup(self, kwargs):\n        """"""\n        Setup MegaManager applicaiton.\n\n        Args:\n            kwargs (dict): Mega_Manager keyword arguments.\n        """"""\n\n        try:\n            self.__mega_manager_config_path = kwargs[\'mega_manager_config_path\']\n            ignore_config_actions = False\n            for key, value in kwargs.items():\n                if value == True:\n                    ignore_config_actions = True\n            self.__config_parser = self._import_config_file_data(ignore_config_actions=ignore_config_actions)\n            self._assign_attributes(**kwargs)\n            self.__lib = Lib(log_level=self.__log_level)\n            self._setup_logger(log_file_path=self.__mega_manager_log_path)\n\n            self.__compress_images_lib = CompressImages_Lib(log_level=self.__log_level)\n            self.__ffmpeg_lib = FFMPEG_Lib(log_file_path=self.__ffmpeg_log_path, log_level=self.__log_level)\n            self.__mega_tools_lib = MegaTools_Lib(log_file_path=self.__megatools_log_path, down_speed_limit=self.__mega_download_speed, up_speed_limit=self.__mega_upload_speed, log_level=self.__log_level)\n\n            self.__removed_remote_files = self.__lib.load_numpy_file_as_set(file_path=self.__removed_remote_files_path)\n            self.__compressed_video_files = self.__lib.load_numpy_file_as_set(file_path=self.__compressed_videos_file_path)\n            self.__unable_to_compress_video_files = self.__lib.load_numpy_file_as_set(\n                file_path=self.__unable_to_compress_videos_file_path)\n            self.__compressed_image_files = self.__lib.load_numpy_file_as_set(file_path=self.__compressed_images_file_path)\n            self.__unable_to_compress_image_files = self.__lib.load_numpy_file_as_set(\n                file_path=self.__unable_to_compress_images_file_path)\n\n        except Exception as e:\n            print(\' Exception: \' + str(e))\n            self._teardown()\n\n    def _setup_logger(self, log_file_path):\n        """"""\n        Logger setup.\n\n        Args:\n            log_file_path (str):  Log file path.\n        """"""\n        print(\' Setting up logger using log file: {}\'.format(log_file_path))\n        if path.exists(log_file_path):\n            try:\n                remove(log_file_path)\n            except Exception as e:\n                print(\' Exception: %s\' % str(e))\n                pass\n\n        root = getLogger()\n        root.setLevel(DEBUG)\n\n        self.__handler = FileHandler(log_file_path)\n        formatter = Formatter(\'%(asctime)s:%(levelname)s:%(name)s:%(message)s\')\n        # formatter = logging.Formatter(fmt=\'%(message)s\', datefmt=\'\')\n        self.__handler.setLevel(DEBUG)\n        self.__handler.setFormatter(formatter)\n\n        ch = StreamHandler(stdout)\n        ch.setLevel(self.__log_level)\n        ch.setFormatter(formatter)\n\n        root.addHandler(self.__handler)\n        root.addHandler(ch)\n\n        logger = getLogger(\'MegaManager._setup_logger\')\n        logger.setLevel(self.__log_level)\n        logger.info(\' Logging to %s\' % self.__mega_manager_log_path)\n\n    def _teardown(self):\n        """"""\n        Tearing down of MEGA Manager.\n        """"""\n\n        logger = getLogger(\'MegaManager._teardown\')\n        logger.setLevel(self.__log_level)\n\n        logger.info(\' Tearing down megaManager!\')\n        try:\n            if self.__sync:\n                self.__lib.dump_set_into_numpy_file(item_set=self.__removed_remote_files,\n                                                    file_path=self.__removed_remote_files_path, )\n            if self.__compress_images:\n                self.__lib.dump_set_into_numpy_file(item_set=self.__compressed_image_files,\n                                                    file_path=self.__compressed_images_file_path, )\n                self.__lib.dump_set_into_numpy_file(item_set=self.__unable_to_compress_image_files,\n                                                    file_path=self.__unable_to_compress_images_file_path)\n            if self.__compress_videos:\n                self.__lib.dump_set_into_numpy_file(item_set=self.__compressed_video_files,\n                                                    file_path=self.__compressed_videos_file_path, )\n                self.__lib.dump_set_into_numpy_file(item_set=self.__unable_to_compress_video_files,\n                                                    file_path=self.__unable_to_compress_videos_file_path)\n\n            self._remove_temp_files()\n\n            megacopy_process_name = \'megacopy.exe\' if system() == \'Windows\' else \'megacopy\'\n            self.__lib.kill_running_processes_with_name(megacopy_process_name)\n            megals_process_name = \'megals.exe\' if system() == \'Windows\' else \'megals\'\n            self.__lib.kill_running_processes_with_name(megals_process_name)\n            megadf_process_name = \'megadf.exe\' if system() == \'Windows\' else \'megadf\'\n            self.__lib.kill_running_processes_with_name(megadf_process_name)\n            megarm_process_name = \'megarm.exe\' if system() == \'Windows\' else \'megarm\'\n            self.__lib.kill_running_processes_with_name(megarm_process_name)\n            megamkdir_process_name = \'megamkdir.exe\' if system() == \'Windows\' else \'megamkdir\'\n            self.__lib.kill_running_processes_with_name(megamkdir_process_name)\n            ffmpeg_process_name = \'ffmpeg.exe\' if system() == \'Windows\' else \'ffmpeg\'\n            self.__lib.kill_running_processes_with_name(ffmpeg_process_name)\n\n            logger.info(\' Tear down successful!\')\n        except Exception as e:\n            logger.warning(\' Exception: %s\' % str(e))\n            pass\n\n    def _thread_download_profile_files(self, profile):\n        """"""\n        Download files from profile.\n\n        Args:\n            profile (Profile): Profile object\n\n        Returns:\n            Boolean: Whether operation was successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._thread_download_profile_files\')\n        logger.setLevel(self.__log_level)\n\n        for pathMapping in profile.path_mappings:\n            self.__mega_tools_lib.download_all_files_from_account(username=profile.account.username,\n                                                                password=profile.account.password,\n                                                                local_root=pathMapping.local_path,\n                                                                remote_root=pathMapping.remote_path,\n                                                                process_set_priority_timeout=self.__process_set_priority_timeout)\n\n            # self.__mega_tools_lib.download_all_files_from_account(account[\'user\'], account[\'pass\'], self.__local_root, self.__remote_root)\n\n\n    def _thread_output_profile_data(self, profile):\n        """"""\n        Output profile data to standard output.\n\n        Args:\n            profile (Profile): Profile object\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._thead_output_profile_data\')\n        logger.setLevel(self.__log_level)\n\n        try:\n            print(\'\')\n            print(\'\')\n            print(\'Profile Data Output:\')\n            print((\'\\tProfile Name: {}\').format(profile.profile_name))\n            print((\'\\tLocal Used Space: {}\').format(profile.local_used_space))\n            print((\'\\tRemote Free Space: {}\').format(profile.remote_free_space))\n            print((\'\\tRemote Total Space: {}\').format(profile.remote_total_space))\n            print((\'\\tRemote Used Space: {}\').format(profile.remote_used_space))\n            print((\'\\tAccount Username: {}\').format(profile.account.username))\n            print((\'\\tAccount Password: {}\').format(profile.account.password))\n            print(\'\')\n\n        except Exception as e:\n            logger.warning(\'Exception: {}\'.format(e))\n\n    def _thread_remove_remote_files_that_dont_exist_locally(self, profile):\n        """"""\n        Get remote files that don\'t exist locally.\n\n        Args:\n            profile (SyncProfile): Profile to remove remote files that dont exist locally.\n\n        Returns:\n            Boolean: whether operation is successful or not\n        """"""\n\n        logger = getLogger(\'MegaManager._thread_remove_remote_files_that_dont_exist_locally\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Removing files that do not exist locally for profile: ""{}""\'.format(profile.profile_name))\n        for path_mapping in profile.path_mappings:\n            local_root = path_mapping.local_path\n            remote_root = path_mapping.remote_path\n            username = profile.account.username\n            password = profile.account.password\n            self._remove_outdated_files(username=username, password=password, local_root=local_root, remote_root=remote_root)\n            self._remove_remote_files_that_dont_exist_locally(username=username, password=password, local_root=local_root,\n                                                              remote_root=remote_root)\n\n    def _thread_sync_profiles_image_compression(self, sync_profiles):\n        """"""\n        Compress image.\n\n        Args:\n            sync_profiles (SyncProfile): syncProfile objects\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._thread_sync_profiles_image_compression\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Compressing local image files\')\n\n        try:\n            for profile in sync_profiles:\n                for path_mapping in profile.path_mappings:\n                    logger.debug(\' Compressing image files for profile: ""{}""\'.format(profile.profile_name))\n                    self._compress_image_files(local_root=path_mapping.local_path)\n            return True\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _thread_sync_profiles_video_compression(self, syncProfiles):\n        """"""\n        Compress video.\n\n        Args:\n            syncProfiles (SyncProfile): syncProfile objects\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._thread_syncprofiles_video_compression\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Compressing local video files\')\n        try:\n            for profile in syncProfiles:\n                for pathMapping in profile.path_mappings:\n                    self._compress_video_files(local_root=pathMapping.local_path)\n            return True\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n            return False\n\n    def _thread_upload_profile_files(self, profile):\n        """"""\n        Upload to all MEGA profile accounts.\n\n        Args:\n            profile (Profile): Profile object\n\n        Retruns:\n            Boolean: Whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaManager._thead_download_profile_files\')\n        logger.setLevel(self.__log_level)\n\n        try:\n            for pathMapping in profile.path_mappings:\n                self.__mega_tools_lib.upload_to_account(username=profile.account.username, password=profile.account.password,\n                                                        local_root=pathMapping.local_path,\n                                                        remote_root=pathMapping.remote_path,\n                                                        process_priority_class=self.__megatools_process_priority_class,\n                                                        process_set_priority_timeout=self.__process_set_priority_timeout)\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n\n    def _update_account_remote_details(self, account):\n        """"""\n        Gather data for account (remote used space, remote free space, remote total space, etc...).\n\n        Args:\n            account (Account): Account object to gather data for.\n\n        Returns:\n            Account: account object with remote data updated\n        """"""\n\n        logger = getLogger(\'MegaManager._update_account_remote_details\')\n        logger.setLevel(self.__log_level)\n\n        username = account.username\n        password = account.password\n\n        account.total_space = self.__mega_tools_lib.get_account_total_space(username=username, password=password)\n\n        account.free_space = self.__mega_tools_lib.get_account_free_space(username=username, password=password)\n\n        account.used_space = self.__mega_tools_lib.get_account_used_space(username=username, password=password)\n\n        # accountDetails.append(\'REMOTE SIZE: \' + used_space)\n        #\n        # subDirs = self.__mega_tools_lib.get_remote_subdir_names_only(username=username, password=password, remote_path=self.__remote_root)\n        #\n        # directoryLines = []\n        # totalLocalSize = 0\n        #\n        # if subDirs:\n        #     for line in subDirs:\n        #         localDirSize = 0\n        #         localDirPath = self.__local_root + \'\\\\\' + line\n        #\n        #         if path.exists(localDirPath) and not line == \'\':\n        #             for r, d, f in walk(localDirPath):\n        #                 for file in f:\n        #                     filePath = path.join(r, file)\n        #                     if path.exists(filePath):\n        #                         localDirSize = localDirSize + path.getsize(filePath)\n        #\n        #             totalLocalSize = totalLocalSize + localDirSize\n        #             remoteDirSize = self.__mega_tools_lib.get_remote_dir_size(username, password, localDirPath,\n        #                                                                  localRoot=self.__local_root,\n        #                                                                  remoteRoot=self.__remote_root)\n        #\n        #             directoryLines.append(line +\n        #                                   \' (%s remote, %s local)\\n\' % (self.__lib.get_mb_size_from_bytes(int(remoteDirSize)), self.__lib.get_mb_size_from_bytes(int(localDirSize))))\n        #\n        #         elif not line == \'\':\n        #             directoryLines.append(line + \' (%s remote, NONE local)\\n\' % (self.__lib.get_mb_size_from_bytes(int(remoteDirSize))))\n        #\n        #     accountDetails.append(\'LOCAL SIZE: %s \\n\' % self.__lib.get_mb_size_from_bytes(totalLocalSize))\n        #\n        #     for line in directoryLines:\n        #         accountDetails.append(line)\n        #     accountDetails.append(\'\\n\')\n        #     accountDetails.append(\'\\n\')\n        #\n        #     self.__accounts_details_dict[username] = accountDetails\n\n        return account\n\n    def _update_profile_remote_details(self, profile):\n        """"""\n        Gather data for profile (remote size, local size, etc...) for self.__mega_accounts_output_path file.\n\n        Args:\n            profile (SyncProfile): profile object to gather data for.\n\n        Returns:\n            SyncProfile: profile object with remote data updated\n        """"""\n\n        logger = getLogger(\'MegaManager._update_profile_remote_details\')\n        logger.setLevel(self.__log_level)\n\n        username = profile.account.username\n        password = profile.account.password\n        totalRemoteSize = 0\n\n        for pathMapping in profile.path_mappings:\n            remotePath = pathMapping.remotepath\n            remotePaths = self.__mega_tools_lib.get_remote_file_paths_recursively(username=username, password=password,\n                                                                                  remote_path=remotePath,\n                                                                                  process_priority_class=self.__megatools_process_priority_class,\n                                                                                  process_set_priority_timeout=self.__process_set_priority_timeout)\n\n            pathMappingRemoteSize = 0\n            for path in remotePaths:\n                pathMappingRemoteSize += self.__mega_tools_lib.get_remote_file_size(username=username, password=password, remotePath=path)\n\n            pathMapping.remote_path_used_space = pathMappingRemoteSize\n            totalRemoteSize += pathMappingRemoteSize\n        return profile\n\n    def _wait_for_threads_to_finish(self, threads=None, timeout=9999999):\n        """"""\n        Wait for threads to finish.\n\n        Args:\n            timeout (int): Maximum time in seconds to wait for threads.\n        """"""\n        logger = getLogger(\'MegaManager._wait_for_threads_to_finish\')\n        logger.setLevel(self.__log_level)\n\n        threads = threads if threads else self.__threads\n        logger.debug(\' Waiting for threads to finish: {}\'.format(threads))\n        start_time = time()\n\n        while len(threads) > 0:\n            if not time() - start_time > timeout:\n                for thread in threads:\n                    if not thread.isAlive():\n                        threads.remove(thread)\n                        logger.info(\' Thread ""%s"" finished!\' % thread.name)\n                        logger.debug(\' Threads left: %d\' % len(threads))\n            else:\n                logger.debug(\' Waiting for threads to complete TIMED OUT! Timeout %d (seconds)\' % timeout)\n                return\n\n    def get_mega_manager_log_file(self):\n        """"""\n        Returns Mega Manager logging file path.\n\n        Returns:\n             Mega Manager logging file path.\n        """"""\n        \n        return self.__mega_manager_log_path\n\n    def run(self):\n        """"""\n        Run MegaManager tasks.\n\n        Returns:\n            Integer: Returns 0 for successful or 1 for unsuccessful.\n        """"""\n\n        logger = getLogger(\'MegaManager.run\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Running MEGA Manager.\')\n\n        result = 0\n        try:\n            while True:\n                sync_profiles_randomized = self.__sync_profiles[:]\n                shuffle(sync_profiles_randomized)\n                if self.__compress_all:\n                    self._create_thread_compress_image_files(sync_profiles=sync_profiles_randomized)\n                    self._create_thread_compress_video_files(sync_profiles=sync_profiles_randomized)\n                elif self.__compress_images:\n                    self._create_thread_compress_image_files(sync_profiles=sync_profiles_randomized)\n                elif self.__compress_videos:\n                    self._create_thread_compress_video_files(sync_profiles=sync_profiles_randomized)\n\n                non_profile_threads = list(self.__threads)\n                for profile in sync_profiles_randomized:\n\n                    if self.__mega_manager_output_profile_data_path:\n                        self._create_thread_output_profile_data(profile=profile)\n\n                    # if self.__remove_outdated:\n                    #     self._remove_outdated_local_remote_files(profile=profile)\n\n                    if self.__sync:\n                        if self.__local_is_truth:\n                            self._thread_remove_remote_files_that_dont_exist_locally(profile=profile)\n                        else:\n                            self._create_thread_remove_remote_files_that_dont_exist_locally(profile=profile)\n                        # self._thread_download_profile_files(profile=profile)\n                        self._create_thread_download(profile=profile)\n                        # self._thread_upload_profile_files(profile=profile)\n                        self._create_thread_upload(profile=profile)\n                        # self._remove_outdated_local_remote_files(profile=profile)\n\n                    # if self.__download:\n                    #     # self._thread_download_profile_files(profile=profile)\n                    #     self._create_thread_download(profile=profile)\n                    # if self.__upload:\n                    #     # self._thread_upload_profile_files(profile=profile)\n                    #     self._create_thread_upload(profile=profile)\n                    # if self.__remove_remote:\n                    #     self._create_thread_remove_remote_files_that_dont_exist_locally(profile=profile)\n\n                    profile_threads = [item for item in self.__threads if item not in non_profile_threads]\n                    self._wait_for_threads_to_finish(threads=profile_threads)\n\n                self._wait_for_threads_to_finish()\n                logger.debug(\' Sleeping {} seconds before next run.\'.format(self.__sleep_time_between_runs_seconds))\n                sleep(self.__sleep_time_between_runs_seconds)\n\n        except Exception as e:\n            logger.debug(\' Exception: \' + str(e))\n            result = 1\n        finally:\n            self._teardown()\n            return result\n\n\nclass PathMappingDoesNotExist(Exception):\n    pass\n\ndef main():\n    pass\n\n\nif __name__ == ""__main__"":\n    main()\n\n\n'"
megamanager/path_mapping.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 7/2/2017\n# Initial Creation.\n# Path Mapping class. Used for path mappings.\n###\n\nfrom account import Account\nfrom logging import getLogger\n\n__author__ = \'szmania\'\n\n\nclass PathMapping(Account):\n    def __init__(self, local_path, remote_path, log_level=\'DEBUG\'):\n        """"""\n        Class used to keep track of local and remote path mappings. This correlates local locations with remote locations,\n        for syncing purposes.\n\n        Args:\n            local_path (str): Local path of path mapping.\n            remote_path (str): Remote path of path mapping.\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n\n\n        self.__local_path = local_path\n        self.__remote_path = remote_path\n        self.__log_level = log_level\n\n        self.__local_path_free_space = None\n        self.__local_path_used_space = None\n        self.__remote_path_used_space = None\n\n    @property\n    def local_path(self):\n        """"""\n        Getter for MEGA local path.\n\n        Returns:\n            String: Returns local path\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_path\')\n        logger.setLevel(self.__log_level)\n\n        return self.__local_path\n\n    @local_path.setter\n    def local_path(self, value):\n        """"""\n        Setter for local path.\n\n        Args:\n            value (str): value to set local path to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_path\')\n        logger.setLevel(self.__log_level)\n\n        self.__local_path = value\n\n    @property\n    def local_path_free_space(self):\n        """"""\n        Getter for MEGA local path free space.\n\n        Returns:\n            String: Returns local path free space\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_path_free_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__local_path_free_space\n\n    @local_path_free_space.setter\n    def local_path_free_space(self, value):\n        """"""\n        Setter for local path free space.\n\n        Args:\n            value (str): value to set local path free space to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_path_free_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__local_path_free_space = value\n\n    @property\n    def local_path_used_space(self):\n        """"""\n        Getter for local path used space.\n\n        Returns:\n            String: Returns local path used space\n        """"""\n\n        logger = getLogger(\'SyncProfile.localRoot_usedSpace\')\n        logger.setLevel(self.__log_level)\n\n        return self.__local_path_used_space\n\n    @local_path_used_space.setter\n    def local_path_used_space(self, value):\n        """"""\n        Setter for local path used space.\n\n        Args:\n            value (str): value to set local path used space to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_path_used_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__local_path_used_space = value\n\n    @property\n    def remote_path(self):\n        """"""\n        Getter for remote path.\n\n        Returns:\n            String: Returns remote path\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_path\')\n        logger.setLevel(self.__log_level)\n\n        return self.__remote_path\n\n    @remote_path.setter\n    def remote_path(self, value):\n        """"""\n        Setter for remote path.\n\n        Args:\n            value (str): value to set remote path to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_path\')\n        logger.setLevel(self.__log_level)\n\n        self.__remote_path = value\n\n\n    @property\n    def remote_path_used_space(self):\n        """"""\n        Getter for remote path used space.\n\n        Returns:\n            String: Returns remote path used space\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_path_used_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__remote_path_used_space\n\n    @remote_path_used_space.setter\n    def remote_path_used_space(self, value):\n        """"""\n        Setter for remote path used space.\n\n        Args:\n            value (str): value to set remote path used space to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_path_used_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__remote_path_used_space = value\n\n\n'"
megamanager/syncprofile.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 7/2/2017\n# Initial Creation.\n# Sync Profile class. Used for sync profile data.\n###\n\nfrom account import Account\nfrom logging import getLogger\nfrom path_mapping import PathMapping\n\n__author__ = \'szmania\'\n\n\nclass SyncProfile(object):\n    def __init__(self, username, password, path_mappings, profile_name=None, log_level=\'DEBUG\'):\n        """"""\n        Library for ffmpeg converter and encoder interaction.\n\n        Args:\n            username (str): MEGA account user name\n            password (str): MEGA account password\n            path_mappings (list): dictionary of local and remote path mappings.\n            profile_name (str): Unique profile name\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n\n\n        self.__profile_name = profile_name if profile_name is not None else username\n        self.__path_mappings = path_mappings\n        self.__log_level = log_level\n\n        self.__local_used_space = None\n        # self.__remote_freeSpace = None\n        # self.__remote_totalSpace = None\n        # self.__remote_usedSpace = None\n\n        # self.__account = super(SyncProfile, self).__init__(self, username=username, password=password, log_level=log_level)\n        self.__account = Account(username=username, password=password, log_level=log_level)\n\n        # pass\n\n    @property\n    def account(self):\n        """"""\n        Getter for MEGA profile account.\n\n        Returns:\n            Account: Returns MEGA profile account\n        """"""\n\n        logger = getLogger(\'SyncProfile.account\')\n        logger.setLevel(self.__log_level)\n\n        return self.__account\n\n    @account.setter\n    def account(self, value):\n        """"""\n        Setter for MEGA profile account.\n\n        Args:\n            value (str): value to set profile account to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.account\')\n        logger.setLevel(self.__log_level)\n\n        self.__account = value\n\n    @property\n    def local_used_space(self):\n        """"""\n        Getter for MEGA profile local used space.\n\n        Returns:\n            String: Returns MEGA profile local used space\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_used_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__local_used_space\n\n    @local_used_space.setter\n    def local_used_space(self, value):\n        """"""\n        Setter for MEGA profile local used space.\n\n        Args:\n            value (str): value to set profile local used space to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.local_used_space\')\n        logger.setLevel(self.__log_level)\n\n        self.__local_used_space = value\n\n    @property\n    def path_mappings(self):\n        """"""\n        Getter for MEGA profile path mappings.\n\n        Returns:\n            Account: Returns MEGA profile path mappings list of PathMapping objects\n        """"""\n\n        logger = getLogger(\'SyncProfile.path_mappings\')\n        logger.setLevel(self.__log_level)\n\n        return self.__path_mappings\n\n    @path_mappings.setter\n    def path_mappings(self, value):\n        """"""\n        Setter for MEGA profile path_mappings.\n\n        Args:\n            value (list): list of PathMapping objects to set to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.path_mappings\')\n        logger.setLevel(self.__log_level)\n\n        self.__path_mappings = value\n\n    @property\n    def profile_name(self):\n        """"""\n        Getter for profile name.\n\n        Returns:\n            String: Returns profile name\n        """"""\n\n        logger = getLogger(\'SyncProfile.profile_name\')\n        logger.setLevel(self.__log_level)\n\n        return self.__profile_name\n\n    @profile_name.setter\n    def profile_name(self, value):\n        """"""\n        Setter for profile name.\n\n        Args:\n            value (str): value to set profile name to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.profile_name\')\n        logger.setLevel(self.__log_level)\n\n        self.__profile_name = value\n\n    @property\n    def remote_free_space(self):\n        """"""\n        Getter for MEGA profile remote free space.\n\n        Returns:\n            String: Returns MEGA profile remote free space\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_free_space\')\n        logger.setLevel(self.__log_level)\n        return self.__account.freeSpace\n        # return self.__remote_freeSpace\n\n    # @remote_free_space.setter\n    # def remote_free_space(self, value):\n    #     """"""\n    #     Setter for MEGA profile remote free space.\n    #\n    #     Args:\n    #         value (str): value to set profile remote free space to.\n    #     """"""\n    #\n    #     logger = getLogger(\'SyncProfile.remote_free_space\')\n    #     logger.setLevel(self.__log_level)\n    #\n    #     self.__remote_freeSpace = value\n\n    @property\n    def remote_total_space(self):\n        """"""\n        Getter for MEGA profile remote total space.\n\n        Returns:\n            String: Returns MEGA profile remote total space\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_total_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__account.totalSpace\n        # return self.__remote_totalSpace\n\n    # @remote_total_space.setter\n    # def remote_total_space(self, value):\n    #     """"""\n    #     Setter for MEGA profile remote total space.\n    #\n    #     Args:\n    #         value (str): value to set profile remote total space to.\n    #     """"""\n    #\n    #     logger = getLogger(\'SyncProfile.remote_total_space\')\n    #     logger.setLevel(self.__log_level)\n    #\n    #     self.__remote_totalSpace = value\n\n    @property\n    def remote_used_space(self):\n        """"""\n        Getter for MEGA profile remote used space.\n\n        Returns:\n            String: Returns MEGA profile remote  used space\n        """"""\n\n        logger = getLogger(\'SyncProfile.remote_used_space\')\n        logger.setLevel(self.__log_level)\n\n        return self.__account.usedSpace\n        # return self.__remote_usedSpace\n\n    # @remote_used_space.setter\n    # def remote_used_space(self, value):\n    #     """"""\n    #     Setter for MEGA profile remote used space.\n    #\n    #     Args:\n    #         value (str): value to set profile remote used space to.\n    #     """"""\n    #\n    #     logger = getLogger(\'SyncProfile.remote_used_space\')\n    #     logger.setLevel(self.__log_level)\n    #\n    #     self.__remote_usedSpace = value\n\n    def add_path_mapping(self, localRoot, remoteRoot):\n        """"""\n        Add path mapping to profile path mappings list.\n\n        Args:\n            localRoot (str): Local root of pair.\n            remoteRoot (str): Remote root of pair.\n        """"""\n\n        logger = getLogger(\'SyncProfile.add_path_mapping\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Adding path mapping to profile.\')\n\n        try:\n            pathMapObj = PathMapping(local_path=localRoot, remote_path=remoteRoot)\n            self.__path_mappings[self.get_path_mappings_count()] = pathMapObj\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: %s\' % str(e))\n            return False\n\n    def get_path_mapping(self, index=None):\n        """"""\n        Getter for profile path mapping at given index.\n\n        Args:\n            index (int): index of path mapping to get.\n\n        Returns:\n            PathMapping: Returns PathMapping object.\n        """"""\n\n        logger = getLogger(\'SyncProfile.get_path_mapping\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Returning path mapping at index %d.\' % index)\n\n        if index:\n            if not index + 1 > len(self.__path_mappings):\n                return self.__path_mappings[index]\n            else:\n                logger.error(\' Error, given index of ""%d"" is larger than path mappings list for profile.\' % index)\n                return None\n        else:\n            if len(self.__path_mappings) > 0:\n                logger.debug(\' No index given. Returning first item.\')\n                return self.__path_mappings[0].remote_path\n            else:\n                logger.error(\' Error, no path mapping exist for this profile!\')\n                return None\n\n    def get_path_mapping_local_path(self, index=None):\n        """"""\n        Getter for profile local root path.\n\n        Args:\n            index (int): index of path mapping to get local root of.\n        \n        Returns:\n            String: Returns local root path.\n        """"""\n\n        logger = getLogger(\'SyncProfile.get_path_mapping_local_path\')\n        logger.setLevel(self.__log_level)\n        \n        logger.debug(\' Returning path mapping local root path.\')\n        \n        if index:\n            if not index + 1 > len(self.__path_mappings):\n                return self.__path_mappings[index].local_path\n            else:\n                logger.error(\' Error, given index of ""%d"" is larger than path mappings list for profile.\' % index)\n                return None\n        else:\n            if len(self.__path_mappings) > 0:\n                logger.debug(\' No index given. Returning first item.\')\n                return self.__path_mappings[0].local_path\n            else:\n                logger.error(\' Error, no path mappings exist for this profile!\')\n                return None\n\n    def get_path_mapping_remote_path(self, index=None):\n        """"""\n        Getter for profile remote root path.\n\n        Args:\n            index (int): index of path mapping to get remote root of.\n\n        Returns:\n            String: Returns remote root path.\n        """"""\n\n        logger = getLogger(\'SyncProfile.get_path_mapping_remote_path\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Returning path mapping remote root path.\')\n\n        if index:\n            if not index + 1 > len(self.__path_mappings):\n                return self.__path_mappings[index].remote_path\n            else:\n                logger.error(\' Error, given index of ""%d"" is larger than path mappings list for profile.\' % index)\n                return None\n        else:\n            if len(self.__path_mappings) > 0:\n                logger.debug(\' No index given. Returning first item.\')\n                return self.__path_mappings[0].remote_path\n            else:\n                logger.error(\' Error, no path mappings exist for this profile!\')\n                return None\n\n    def get_path_mappings_count(self):\n        """"""\n        Return path mappings list size.\n\n        Returns:\n            integer: size of path mappings list.\n        """"""\n\n        logger = getLogger(\'SyncProfile.get_path_mappings_count\')\n        logger.setLevel(self.__log_level)\n\n        return len(self.__path_mappings)\n\n    def set_path_mapping_local_path(self, value, index=None):\n        """"""\n        Setter for profile local root path.\n\n        Args:\n            index (int): index of path mapping to set local root of.\n            value (str): value to set local root to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.set_path_mapping_local_path\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Setting path mapping local root path.\')\n\n        # if index:\n        if not index + 1 > len(self.__path_mappings):\n            self.__path_mappings[index].local_path = value\n            return True\n        else:\n            logger.error(\' Error, given index of ""%d"" is larger than path mappings list for profile.\' % index)\n            return False\n\n    def set_path_mapping_remote_root(self, index, value):\n        """"""\n        Setter for profile remote root path.\n\n        Args:\n            index (int): index of path mapping to set remote root of.\n            value (str): value to set remote root to.\n        """"""\n\n        logger = getLogger(\'SyncProfile.set_path_mapping_remote_root\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Setting path mapping remote root path.\')\n\n        if not index + 1 > len(self.__path_mappings):\n            self.__path_mappings[index].remote_path = value\n            return True\n        else:\n            logger.error(\' Error, given index of ""%d"" is larger than path mappings list for profile.\' % index)\n            return False\n\n    \n                \n\n'"
megamanager/version.py,0,"b'__version__ = ""0.0.2""\n'"
megamanager/libs/__init__.py,0,b'# from .compress_images_lib import CompressImages_Lib\n# from .lib import Lib\n# from .ffmpeg_lib import FFMPEG_Lib\n# from .mega_tools_lib import MegaTools_Lib\n'
megamanager/libs/compress_images_lib.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 6/5/2017\n# Initial Creation.\n###\nfrom lib import Lib\nfrom logging import getLogger\nfrom os import path\nfrom re import IGNORECASE, match\nfrom tools.compressImages import CompressImage, DeleteBackupImage\n# from tools import CompressImage, DeleteBackupImage\n\n__author__ = \'szmania\'\n\n\nclass CompressImages_Lib(object):\n    def __init__(self, log_level=\'DEBUG\'):\n        """"""\n        Library for compressImages.py interaction.\n\n        Args:\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n\n        self.__log_level = log_level\n\n        self.__compress_images_obj = CompressImage()\n        self.__deleteBackupImageObj = DeleteBackupImage()\n        self.__lib = Lib(log_level=self.__log_level)\n\n    def compress_image_file(self, file_path, jpeg_compression_quality_percentage, delete_backup=False,\n                            delete_corrupt_images=False):\n        """"""\n        Compress images file.\n\n        Args:\n            file_path (str): File path of image to compress.\n            jpeg_compression_quality_percentage (int): Quality percentage compression for jpeg files.\n            delete_backup (bool): Delete backup image file.\n            delete_corrupt_images (bool): Delete backup image file.\n\n        Returns:\n            Boolean: whether compression operation was successful or not.\n        """"""\n\n        logger = getLogger(\'CompressImages_Lib.compress_image_file\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Compressing image file: ""%s""\' % file_path)\n        results = []\n        file_ext = file_path.split(\'.\')[-1]\n        compressed_any_image = self.__compress_images_obj.processfile(filename=file_path)\n        results.append(compressed_any_image)\n\n        if match(\'jpe{0,1}g\', file_ext, IGNORECASE):\n            jpeg_compressed = self.compress_jpeg_image_file(file_path=file_path,\n                                                            quality_percentage=jpeg_compression_quality_percentage)\n\n            if delete_corrupt_images and not jpeg_compressed:\n                logger.debug(\' Deleting CORRUPT JPEG or JPG image file: ""{}""\'.format(file_path))\n                self.__lib.delete_local_file(file_path=file_path)\n\n            results.append(jpeg_compressed)\n\n        if delete_backup:\n            compress_path_backup = file_path + \'.compressimages-backup\'\n            if path.exists(compress_path_backup):\n                logger.debug(\' Removing backup image file ""{}""!\'.format(compress_path_backup))\n                self.__lib.delete_local_file(file_path=compress_path_backup)\n\n        if True in results:\n            logger.debug(\' Success, image file ""%s"" compressed successfully.\' % file_path)\n            return True\n\n        logger.debug(\' Error, image file ""%s"" NOT compressed successfully!\' % file_path)\n        return False\n\n    def compress_jpeg_image_file(self, file_path, quality_percentage):\n        """"""\n        Compress images file.\n\n        Args:\n            file_path (str): File path of image to compress.\n            quality_percentage (int): Percentage to set output jpeg file.\n\n        Returns:\n            Boolean: whether compression operation was successful or not.\n        """"""\n\n        logger = getLogger(\'CompressImages_Lib.compress_jpeg_image_file\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Compressing JPEG or JPG image file ""%s"".\' % file_path)\n        compressed = False\n        skipped = False\n        result = None\n        try:\n            result = self.__lib.exec_cmd_and_return_output(command=\'jpegoptim --max={quality_percentage} ""{file_path}""\'.format(\n                quality_percentage=quality_percentage, file_path=file_path))\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n        if \'optimized\' in result[0]:\n            logger.debug(\' Success, JPEG or JPG image file ""%s"" compressed successfully.\' % file_path)\n            return True\n        elif \'skipped\' in result[0]:\n            logger.debug(\' JPEG or JPG file already optimized! File was skipped: ""{}""\'.format(file_path))\n            return True\n        else:\n            logger.debug(\' Error, JPEG or JPG image file ""%s"" NOT compressed successfully!\' % file_path)\n            return False\n\n\n    def delete_backups_in_dir(self, dirPath):\n        """"""\n        Delete backup files in directory\n\n        Args:\n            dirPath (str): Directory path of image backups to delete\n\n        Returns:\n             Boolean: whether compression operation was successful or not.\n        """"""\n\n        logger = getLogger(\'CompressImages_Lib.delete_backups_in_dir\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Deleting compression file backups in dirPath ""%s"".\' % dirPath)\n\n        result = self.__deleteBackupImageObj.processdir(path=dirPath)\n\n        if result:\n            logger.debug(\' Success, could remove backup image compression files in direcotry ""%s""\' % dirPath)\n            return True\n        else:\n            logger.error(\' Error, could NOT remove backup image compression files in direcotry ""%s""\' % dirPath)\n            return False\n'"
megamanager/libs/ffmpeg_lib.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 6/5/2017\n# Initial Creation.\n###\n\nfrom .lib import Lib\nfrom logging import getLogger\nfrom os import path, remove, sep\nfrom platform import system\n\n__author__ = \'szmania\'\n\nHOME_DIRECTORY = ""~""\nMEGA_MANAGER_CONFIG_DIR = ""{HOME_DIRECTORY}{sep}.mega_manager"".format(HOME_DIRECTORY=HOME_DIRECTORY, sep=sep)\nFFMPEG_LOG_PATH = ""{MEGA_MANAGER_CONFIG_DIR}{sep}logs{sep}ffmpeg.log"".format(MEGA_MANAGER_CONFIG_DIR=MEGA_MANAGER_CONFIG_DIR,\n                                                                             sep=sep)\n\n\n\nclass FFMPEG_Lib(object):\n    def __init__(self, log_level=\'DEBUG\', log_file_path=FFMPEG_LOG_PATH):\n        """"""\n        Library for ffmpeg converter and encoder interaction.\n\n        Args:\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n            log_file_path (str): Log file path for ffmpeg.\n\n        """"""\n\n        self.__log_level = log_level\n        self.__ffmpeg_log = log_file_path\n        self.__lib = Lib(log_level=log_level)\n\n    def compress_video_file(self, source_path, target_path, compression_preset=""medium"", ffmpeg_threads=1, overwrite=False,\n                            process_priority_class=""NORMAL_PRIORITY_CLASS"", process_set_priority_timeout=60):\n        """"""\n        Compress video file.\n\n        Args:\n            source_path (str): File path of video to __compress_all.\n            target_path (str): File path of video to be compressed into.\n            compression_preset (str): Compression preset. ie: ""fast"" or ""slow""\n            ffmpeg_threads (int): Number of threads to use when running ffmpeg.\n            overwrite (bool): Overwrite target file if it exists.\n            process_priority_class (str): Priority level to set for process. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            subprocess object:\n        """"""\n    \n        logger = getLogger(\'FFMPEG_Lib.compress_video_file\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Compressing video file: ""%s""\' % source_path)\n\n        if overwrite:\n            logger.debug(\' Overwrite set to ""True"". Removing target file: ""%s""\' % target_path)\n            if path.exists(target_path):\n                try:\n                    remove(target_path)\n                except Exception as e:\n                    print(\' Exception: %s\' % str(e))\n                    pass\n\n        cmd = \'ffmpeg -i ""{source_path}"" -vf ""scale=\\\'if(gte(iw,720), 720, iw)\\\':-2"" -preset {preset} \' \\\n              \'-threads {ffmpeg_threads} -max_muxing_queue_size 9999 ""{target_path}""\'.format(\n            source_path=source_path, preset=compression_preset, ffmpeg_threads=ffmpeg_threads, target_path=target_path)\n\n        process_name = \'ffmpeg.exe\' if system() == \'Windows\' else \'ffmpeg\'\n        result = self.__lib.exec_cmd(command=cmd, no_window=True, output_file=self.__ffmpeg_log, process_priority_class=process_priority_class,\n                                     process_name=process_name, process_set_priority_timeout=process_set_priority_timeout)\n\n        if result:\n            logger.debug(\' Success, could compress video file ""%s"" to ""%s"".\' % (source_path, target_path))\n        else:\n            logger.error(\' Error, could NOT compress video file ""%s""!\' % source_path)\n        return result\n\n'"
megamanager/libs/lib.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 5/31/2017\n# Initial Creation.\n###\n\nfrom hashlib import md5\nfrom logging import getLogger\nfrom numpy import array, load, save\nfrom os import chdir, kill, listdir, path, remove, rename, sep\nfrom platform import system\nimport psutil\nfrom re import split, sub\nfrom signal import SIGTERM\nimport shlex\nfrom subprocess import call, PIPE, Popen\nfrom threading import Thread\nfrom time import localtime, sleep, strftime, time\n\n__author__ = \'szmania\'\n\n\nclass Lib(object):\n    def __init__(self, log_level=\'DEBUG\'):\n        """"""\n        MegaManager library.\n\n        Args:\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n\n        self.__log_level = log_level\n\n\n    def _find_procs_by_name(self, name, timeout=None):\n        """"""\n        Return a list of processes matching \'name\'\n        Args:\n            name (str): Process name to find.\n            timeout (int): timeout in seconds to wait for process to start.\n\n        Returns:\n            List: Processes matching name.\n        """"""\n        logger = getLogger(\'Lib._find_procs_by_name\')\n        logger.setLevel(self.__log_level)\n\n        found_procs = []\n        time_started = time()\n        try:\n            while True:\n                for p in psutil.process_iter():\n                    if p.name() == name:\n                        found_procs.append(p)\n\n                now = time()\n                if len(found_procs) > 0:\n                    logger.debug(\' Success, found process ""{}""\'.format(name))\n                    break\n                elif now - time_started > timeout:\n                    raise ProcessNameNotFound\n            return found_procs\n\n        except ProcessNameNotFound as e:\n            logger.warning(\' ProcessNameNotFound Exception: Process name ""{}"" not found!\'.format(name))\n            pass\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            pass\n\n        return found_procs\n\n    def _set_priority_once_proc_starts(self, process_name, priority_class, process_set_priority_timeout):\n        """"""\n        Wait for process to start then set priority.\n        Args:\n            process_name (str): Process name to set priority.\n            priority_class (str): priority level. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n\n        """"""\n        logger = getLogger(\'Lib._set_priority_once_proc_starts\')\n        logger.setLevel(self.__log_level)\n\n        sleep(1)\n        t = Thread(target=self._thread_set_priority_once_proc_starts, args=(process_name, priority_class,\n                                                                            process_set_priority_timeout, ),\n                   name=\'thread_set_priority_{}\'.format(process_name))\n        t.start()\n\n    def _set_proc_priority(self, proc, priority_class):\n        """"""\n        Set process priority.\n        Args:\n            proc: psutils process object.\n            priority_class (str): Priority level. ie: ""BELOW_NORMAL_PRIORITY_CLASS""\n\n        Returns:\n            Boolean: Whether successful or not.\n        """"""\n        logger = getLogger(\'Lib._set_proc_priority\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Setting process ""{}"" to priority class ""{}""\'.format(proc.name(), priority_class))\n\n        try:\n            if priority_class == \'IDLE_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.IDLE_PRIORITY_CLASS)\n                else:\n                    proc.nice(-20)\n            elif priority_class == \'BELOW_NORMAL_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.BELOW_NORMAL_PRIORITY_CLASS)\n                else:\n                    proc.nice(-10)\n            elif priority_class == \'NORMAL_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.NORMAL_PRIORITY_CLASS)\n                else:\n                    proc.nice(0)\n            elif priority_class == \'ABOVE_NORMAL_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.ABOVE_NORMAL_PRIORITY_CLASS)\n                else:\n                    proc.nice(5)\n            elif priority_class == \'HIGH_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.HIGH_PRIORITY_CLASS)\n                else:\n                    proc.nice(10)\n            elif priority_class == \'REALTIME_PRIORITY_CLASS\':\n                if system() == \'Windows\':\n                    proc.nice(psutil.REALTIME_PRIORITY_CLASS)\n                else:\n                    proc.nice(20)\n            else:\n                logger.warning(\'Error, invalid priority class: {}\'.format(priority_class))\n                return False\n\n            logger.debug(\' Success, set process priority_class to ""{}""\'.format(priority_class))\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def _thread_set_priority_once_proc_starts(self, process_name, priority_class, process_set_priority_timeout):\n        """"""\n        Wait for process to start then set priority.\n        Args:\n            process_name (str): Process name to set priority.\n            priority_class (): priority level. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        """"""\n        logger = getLogger(\'Lib._thread_set_priority_once_proc_starts\')\n        logger.setLevel(self.__log_level)\n\n        procs = self._find_procs_by_name(name=process_name, timeout=process_set_priority_timeout)\n\n        for proc in procs:\n            self._set_proc_priority(proc=proc, priority_class=priority_class)\n\n    def convert_epoch_to_mega_time(self, epoch_time):\n        """"""\n        Convert epoch time to time format used by MEGA.\n            ie: 1247547145.65 to \'2017-08-18 22:37:50\'\n\n        Args:\n            epoch_time (str): Epoch time to convert.\n\n        Returns:\n            datetime: Converted datetime object. ie: \'%Y-%m-%d %H:%M:%S\'\n        """"""\n        return strftime(\'%Y-%m-%d %H:%M:%S\', localtime(epoch_time))\n\n    def delete_local_file(self, file_path):\n        """"""\n        Delete local file.\n\n        Args:\n            file_path (str): File path to delete.\n\n        Returns:\n            Boolean: boolean of whether successful or not\n        """"""\n        logger = getLogger(\'Lib.delete_local_file\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Deleting local file: {}\'.format(file_path))\n\n        if path.exists(file_path):\n            for retry in range(100):\n                try:\n                    remove(file_path)\n                    logger.debug(\' File deleted!\')\n                    return True\n\n                except Exception as e:\n                    logger.exception(\' Exception: {}\'.format(e))\n                    logger.debug(\' Removing of file ""{}"" FAILED, retrying...\'.format(file_path))\n        else:\n            logger.error(\' Cannot delete! Path does not exist: ""{}""\'.format(file_path))\n\n        return False\n\n    def dump_set_into_numpy_file(self, item_set, file_path):\n        """"""\n        Dump set into file for each item on a new line.\n\n        Args:\n            item_set (set): Set to dump into file.\n            file_path (str): File to dump to.\n\n        Returns:\n            Boolean: boolean of whether successful or not\n        """"""\n    \n        logger = getLogger(\'MegaManager_lib.dump_set_into_numpy_file\')\n        logger.setLevel(self.__log_level)\n    \n        logger.debug(\' Dumping set into ""%s"".\' % file_path)\n\n        try:\n            np_list = array(list(item_set))\n            # savez_compressed(file_path, list=npList)\n            # savez(file_path, list=npList)\n            save(file_path, np_list)\n            return True\n        except Exception as e:\n            logger.debug(\' Exception: %s\' % str(e))\n            return False\n\n    def exec_cmd(self, command, working_dir=None, no_window=False, output_file=None, process_name=None,\n                 process_priority_class=None, process_set_priority_timeout=60):\n        """"""\n        Execute given command.\n\n        Args:\n            command (str): Command to execute.\n            working_dir (str): Working directory.\n            no_window (bool): No window will be created if true.\n            output_file (str): file path to output program output to.\n            process_name (str): Process name to set priority level.\n            process_priority_class (str): Priority level to set process to. ie: ""BELOW_NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            subprocess object\n        """"""\n        logger = getLogger(\'Lib.exec_cmd\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Executing command: ""%s""\' % command)\n\n        try:\n            if output_file:\n                out_file = open(output_file, \'a\')\n            else:\n                out_file = None\n\n            if working_dir:\n                chdir(working_dir)\n\n            if process_priority_class:\n                self._set_priority_once_proc_starts(process_name=process_name, priority_class=process_priority_class,\n                                                    process_set_priority_timeout=process_set_priority_timeout)\n\n            if no_window and system() == \'Windows\':\n                CREATE_NO_WINDOW = 0x08000000\n                exit_code = call(shlex.split(command), stdout=out_file, stderr=out_file, creationflags=CREATE_NO_WINDOW)\n\n            else:\n                exit_code = call(shlex.split(command),  stdout=out_file, stderr=out_file)\n\n            if exit_code == 0:\n                logger.debug(\' Successfully executed command ""%s"".\' % command)\n                return True\n\n        except Exception as e:\n            logger.warning(\' Exception: {}\'.format(e))\n\n        logger.warning(\' Error when running command ""%s"".\' % command)\n        return False\n\n    def exec_cmd_and_return_output(self, command, working_dir=None, output_file=None):\n        """"""\n        Execute given command and return stdout and stderr.\n\n        Args:\n            command (str): Command to execute.\n            working_dir (str): Working directory.\n            output_file (str): File to pipe process output to.\n\n        Returns:\n            Tuple: of stdout and stderr.\n        """"""\n        logger = getLogger(\'MegaTools_Lib.exec_cmd_and_return_output\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Executing command: ""%s""\' % command)\n\n        out = None\n        err = None\n        if working_dir:\n            chdir(working_dir)\n\n        try:\n            # out = check_output(shlex.split(command), stderr=STDOUT)\n            proc = Popen(shlex.split(command), stdout=PIPE, stderr=PIPE)\n            (out, err) = proc.communicate()\n            if output_file:\n                out_file = open(output_file, \'a\')\n                out_file.write(out)\n        except Exception as e:\n            logger.warning(\' Exception: %s\' % str(e))\n            return None, None\n        return out, err\n\n    def get_file_md5_hash(self, file_path):\n        """"""\n        Gets file md5 hash.\n\n        ArgsL\n            file_path (str): File path to get md5 has of.\n\n        Returns:\n             Str: md5 hash of file.\n        """"""\n        logger = getLogger(\'Lib.get_file_md5_hash\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Getting md5 hash of file: ""{}""\'.format(file_path))\n\n        try:\n            # test = md5(file_path).hexdigest()\n            # hash_md5 = md5()\n            # with open(file_path, ""rb"") as f:\n            #     for chunk in iter(lambda: f.read(4096), b""""):\n            #         hash_md5.update(chunk)\n            file_md5_hash = md5(file_path).hexdigest()\n            logger.debug(\' md5 hash of file is: ""{}""\'.format(file_md5_hash))\n            return file_md5_hash\n        except Exception as e:\n            logger.debug(\' Exception: %s\' % str(e))\n            return False\n\n    def get_mb_size_from_bytes(self, bytes):\n        """"""\n        Convert bytes to size in MegaBytes.\n\n        Args:\n            bytes (int): Size in bytes.\n\n        Returns:\n            string: Size in MegaBytes converted from bytes.\n        """"""\n    \n        logger = getLogger(\'Lib.get_mb_size_from_bytes\')\n        logger.setLevel(self.__log_level)\n    \n        logger.debug(\' Converting kilobytes to megabytes.\')\n    \n        result = \'\'\n        if bytes < 1000:\n            result = \'%i\' % bytes + \'B\'\n        elif 1000 <= bytes < 1000000:\n            result = \'%.1f\' % float(bytes / 1000) + \'KB\'\n        elif 1000000 <= bytes < 1000000000:\n            result = \'%.1f\' % float(bytes / 1000000) + \'MB\'\n        elif 1000000000 <= bytes < 1000000000000:\n            result = \'%.1f\' % float(bytes / 1000000000) + \'GB\'\n        elif 1000000000000 <= bytes:\n            result = \'%.1f\' % float(bytes / 1000000000000) + \'TB\'\n    \n        return result\n\n    def get_remote_path_from_local_path(self, localPath, localRoot=""{sep}"".format(sep=sep), remoteRoot=""\\\\""):\n        """"""\n        Get remote path given local path.\n\n        Args:\n            localPath (str): Local path.\n            localRoot (str): Local root\n            remoteRoot (str): Remote root.\n        Returns:\n            string: Remote path.\n        """"""\n\n        logger = getLogger(\'Lib.get_remote_path_from_local_path\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting remote path from local path\')\n\n        localRoot_adj = sub(\'\\\\\\\\\', \'/\', localRoot)\n        localFilePath_adj = sub(\'\\\\\\\\\', \'/\', localPath)\n        postfix = split(localRoot_adj, localFilePath_adj)\n\n        if len(postfix) > 1:\n            subPath = postfix[1]\n\n            logger.debug(\' Success, could get remote path from local path.\')\n            return remoteRoot + subPath\n        else:\n            logger.debug(\' Error, could NOT get remote path from local path!\')\n            return None\n\n    def get_sleep_time(self):\n            """"""\n            Get time in seconds to sleep. Function is used to pace program speed during iterations.\n    \n            :return: Time in seconds to sleep as integer.\n            """"""\n    \n            logger = getLogger(\'megaManager_lib.get_sleep_time\')\n            logger.setLevel(self.__log_level)\n    \n            sleepTime = 0\n    \n            return sleepTime\n\n    def get_items_in_list_with_sub_string(self, list, sub_string):\n        """"""\n        Return sub list of list that contain substring.\n\n        :param list: List to find substrings in.\n        :type list: List.\n        :param sub_string: Substring to find.\n        :type sub_string: String.\n\n        :return: List of items that contain subString.\n        """"""\n\n        logger = getLogger(\'Lib.get_items_in_list_with_sub_string\')\n        logger.setLevel(self.__log_level)\n\n        subList = []\n        for item in list:\n            if sub_string in item:\n                subList.append(item)\n        return subList\n\n    def kill_running_processes_with_name(self, proc_name):\n        """"""\n        Kill processes with name.\n\n        Args:\n            proc_name (str): Process name.\n\n        :return:\n        """"""\n    \n        logger = getLogger(\'megaManager_lib.kill_running_processes_with_name\')\n        logger.setLevel(self.__log_level)\n    \n        logger.info(\' Killing processes with name ""%s""\' % proc_name)\n        try:\n            # p = Popen([\'ps\', \'-a\'], stdout=PIPE)\n            p = Popen([\'tasklist\', \'/v\'], stdout=PIPE)\n            out, err = p.communicate()\n\n            for line in out.splitlines():\n                if line.startswith(proc_name):\n                    pid = int(line.split()[1])\n                    kill(pid, SIGTERM)\n\n            logger.debug(\' Success, all ""%s"" processes have been killed.\' % proc_name)\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def load_numpy_file_as_set(self, file_path):\n        """"""\n        Load file as set splitting each line into a new item.\n\n        Args:\n            file_path (str): File to lead.\n\n        Returns:\n            Lines in file as a set.\n        """"""\n        logger = getLogger(\'Lib.load_numpy_file_as_set\')\n        logger.setLevel(self.__log_level)\n\n        items = set()\n        if path.isfile(file_path):\n            logger.debug(\' Loading file as set: {}\'.format(file_path))\n\n            try:\n                data = load(file=file_path, allow_pickle=False)\n                items = set(data.tolist())\n            except Exception as e:\n                logger.debug(\' Exception: %s\' % str(e))\n            finally:\n                return items\n\n        else:\n            logger.debug(\' Filepath ""%s"" does NOT exist. Using empty set.\' % file_path)\n            return items\n\n    def rename_file(self, old_name, new_name):\n        """"""\n        Renames file.\n\n        Args:\n            old_name (str): Old file name.\n            new_name (str): New file name.\n\n        Returns:\n            bool: Whether successful or not.\n        """"""\n        logger = getLogger(\'Lib.rename_file\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Renaming file ""{}"" to ""{}.""\'.format(old_name, new_name))\n        for retry in range(100):\n            try:\n                rename(old_name, new_name)\n                logger.debug(\' Rename succeeded!\')\n                return True\n\n            except Exception as e:\n                logger.error(\' Exception: {}\'.format(e))\n                logger.debug("" Rename failed, retrying..."")\n                if \'Cannot create a file when that file already exists\' in e:\n                    self.delete_local_file(file_path=new_name)\n        return False\n\n    def size_of_dir(self, dir_path):\n        """"""\n        Walks through the directory, getting the cumulative size of the directory\n    \n        :param dir_path: Directory to walk through to get size.\n        :type dir_path: String.\n    \n        :return: Size in bytes as integer.\n        """"""\n    \n        logger = getLogger(\'Lib.size_of_dir\')\n        logger.setLevel(self.__log_level)\n    \n        logger.debug(\' Getting size of directory ""%s""\' % dir_path)\n    \n        sum = 0\n        for file in listdir(dir_path):\n            sum += path.getsize(dir_path + \'{sep}\'.format(sep=sep) + file)\n        return sum\n\n\n\nclass ProcessNameNotFound(Exception):\n    pass'"
megamanager/libs/mega_tools_lib.py,0,"b'##\n# Created by: Curtis Szmania\n# Date: 5/31/2017\n# Initial Creation.\n###\n\nfrom .lib import Lib\nfrom logging import getLogger\nfrom os import linesep, path, sep\nfrom platform import system\nfrom re import findall, split, sub\n\n__author__ = \'szmania\'\n\nHOME_DIRECTORY = ""~""\nMEGA_MANAGER_CONFIG_DIR = ""{HOME_DIRECTORY}{sep}.mega_manager"".format(HOME_DIRECTORY=HOME_DIRECTORY, sep=sep)\nMEGATOOLS_LOG_PATH = ""{MEGA_MANAGER_CONFIG_DIR}{sep}logs{sep}mega_tools.log"".format(\n    MEGA_MANAGER_CONFIG_DIR=MEGA_MANAGER_CONFIG_DIR,\n    sep=sep)\n\n\nclass MegaTools_Lib(object):\n    def __init__(self, down_speed_limit=None, up_speed_limit=None, log_level=\'DEBUG\', log_file_path=MEGATOOLS_LOG_PATH):\n        """"""\n        Library for interaction with MegaTools. A tool suite for MEGA.\n\n        Args:\n            log_file_path (str): Log file path for MEGATools\n            down_speed_limit (int): Max download speed limit.\n            up_speed_limit (int): Max upload speed limit.\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n        """"""\n        self.__mega_tools_log = log_file_path\n        self.__downSpeedLimit = down_speed_limit\n        self.__up_speed_limit = up_speed_limit\n        self.__log_level = log_level\n\n        self.__lib = Lib(log_level=log_level)\n\n    def create_remote_dir(self, username, password, remote_path, process_priority_class, process_set_priority_timeout):\n        """"""\n        Create remote MEGA directory\n\n        Args:\n            username (str): username of account to __download file from\n            password (str): password of account to __download file from\n            remote_path (str): Path to remote directory.\n            process_priority_class (str): Priority level to set process to. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            Bool: Whether successful or not.\n        """"""\n        logger = getLogger(\'MegaTools_Lib.create_remote_dir\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Creating remote directory for account ""{}"" in MEGA: ""{}""\'.format(username, remote_path))\n        try:\n            cmd = \'megamkdir -u {} -p {} ""{}""\'.format(username, password, remote_path)\n\n            process_name = \'megamkdir.exe\' if system() == \'Windows\' else \'megamkdir\'\n            result = self.__lib.exec_cmd(command=cmd, no_window=True, output_file=self.__mega_tools_log,\n                                         process_name=process_name, process_priority_class=process_priority_class,\n                                         process_set_priority_timeout=process_set_priority_timeout)\n            # result = self.__lib.exec_cmd(command=cmd, working_dir=self.__mega_tools_dir, noWindow=True,\n            #                              output_file=self.__mega_tools_log)\n            if not result:\n                logger.debug(\' Error, could not make directory ""{}"" for account ""{}""!\'.format(remote_path, username))\n                return False\n\n            logger.debug(\' Success, could make directory ""{}"" for account ""{}""!\'.format(remote_path, username))\n            return True\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def download_all_files_from_account(self, username, password, local_root, remote_root, process_set_priority_timeout):\n        """"""\n        Download all account files.\n\n        Args:\n            username (str): username of account to __download file from\n            password (str): password of account to __download file from\n            local_root (str): Local path to __download file to\n            remote_root (str): Remote path of file to __download\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.download_all_files_from_account\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' MEGA downloading directory from account ""%s"" from ""%s"" to ""%s""\' % (username, local_root, remote_root))\n\n        if self.__downSpeedLimit:\n            cmd = \'megacopy --download -u %s -p %s --limit-speed %d --local ""%s"" --remote ""%s""\' % (\n                username, password, self.__downSpeedLimit, local_root, remote_root)\n\n        else:\n            cmd = \'megacopy --download -u %s -p %s --local ""%s"" --remote ""%s""\' % (\n                username, password, local_root, remote_root)\n\n        process_name = \'megacopy.exe\' if system() == \'Windows\' else \'megacopy\'\n        result = self.__lib.exec_cmd(command=cmd, no_window=True, output_file=self.__mega_tools_log,\n                                     process_priority_class=\'NORMAL_PRIORITY_CLASS\', process_name=process_name,\n                                     process_set_priority_timeout=process_set_priority_timeout)\n\n        if result:\n            logger.debug(\' Success, downloadeded all files from account.\')\n            return True\n        else:\n            logger.debug(\' Error, could not download all files from account!\')\n            return False\n\n    def download_file(self, username, password, localFilePath, remoteFilePath):\n        """"""\n        Download a remote file from MEGA account.\n\n        Args:\n            username (str): username of account to __download file from\n            password (str): password of account to __download file from\n            localFilePath (str): Location to __download file to.\n            remoteFilePath (str): Location to __download file from.\n\n        Returns:\n            bool: whether successful download or not\n        """"""\n\n        logger = getLogger(\'MegaManager._download_file\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' MEGA downloading file from account ""%s"" - ""%s"" to ""%s""\' % (username, password, localFilePath))\n\n        cmd = \'megaget -u %s -p %s --path ""%s"" ""%s""\' % (username, password, localFilePath, remoteFilePath)\n        process_name = \'megaget.exe\' if system() == \'Windows\' else \'megaget\'\n        result = self.__lib.exec_cmd(command=cmd, no_window=True, output_file=self.__mega_tools_log,\n                                     process_priority_class=\'NORMAL_PRIORITY_CLASS\', process_name=process_name,\n                                     process_set_priority_timeout=self.__process_set_priority_timeout)\n\n        if result:\n            logger.debug(\' Successfully downloaded file.\')\n            return True\n        else:\n            logger.debug(\' Error when trying to download file.\')\n            return False\n\n    def get_file_date_from_megals_line_data(self, line):\n        """"""\n        Extract file date from megals line data output.\n        example input:\n        udtDgR7I    Xz2tWWB5Dmo 0    4405067776 2013-04-10 19:16:02 /Root/bigfile\n\n        Args:\n            line (str): line to extract file date from.\n\n        Returns:\n            string: File date as string. ie: ""2013-04-10 19:16:02""\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_file_date_from_megals_line_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting file date from ""%s""\' % line)\n\n        line_split = line.split()\n\n        if len(line_split) > 2:\n            remoteFileModifiedDate = line_split[4]\n            remoteFileModifiedTime = line_split[5]\n\n            remoteFileModifiedDate_time = \'%s %s\' % (remoteFileModifiedDate, remoteFileModifiedTime)\n\n            logger.debug(\' Success, could find remote file modified date.\')\n            return remoteFileModifiedDate_time\n\n        logger.warning(\' Error, could NOT find remote file modified date!\')\n        return None\n\n    def get_file_extension_from_megals_line_data(self, line):\n        """"""\n        Extract file extension from megals line data output.\n        example input:\n        udtDgR7I    Xz2tWWB5Dmo 0    4405067776 2013-04-10 19:16:02 /Root/bigfile.jpg\n\n        Args:\n            line (str): line to extract file extension from.\n\n        Returns:\n            string: File extension. ie: ""jpg""\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_file_extension_from_megals_line_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting file extension from ""%s""\' % line)\n        fileExt = None\n        try:\n            fileExt = path.splitext(split(\':\\d{2} \', line)[1])[1]\n        except Exception as e:\n            logger.error(\'Exception: %s\' % str(e))\n        finally:\n            return fileExt\n\n    def get_file_path_from_megals_line_data(self, line):\n        """"""\n        Extract file path from megals line data output.\n        example input:\n        udtDgR7I    Xz2tWWB5Dmo 0    4405067776 2013-04-10 19:16:02 /Root/bigfile\n\n        Args:\n            line (str): line to extract file path from.\n\n        Returns:\n            string: File path. ie: ""/Root"".\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_file_path_from_megals_line_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting file path from ""%s""\' % line)\n        remote_filePath = None\n        try:\n            remote_filePath = split(\':\\d{2} \', line)[1]\n        except Exception as e:\n            logger.error(\'Exception: %s\' % str(e))\n        finally:\n            return remote_filePath\n\n    def get_file_size_from_megals_line_data(self, line):\n        """"""\n        Extract file size from megals line data output.\n        example input:\n        udtDgR7I    Xz2tWWB5Dmo 0    4405067776 2013-04-10 19:16:02 /Root/bigfile\n\n        Args:\n            line (str): Line to extract file path from.\n\n        Returns:\n            string: File size. ie: ""4405067776"".\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_file_size_from_megals_line_data\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Getting file size from ""%s""\' % line)\n\n        line_split = line.split()\n        if len(line_split) > 2:\n            remoteFileSize = line_split[3]\n            logger.debug(\' Success, remote file size of line ""%s"" is ""%s""\' % (line, remoteFileSize))\n            return remoteFileSize\n        else:\n            logger.error(\' Error, could not get remote file size from line ""%s""\' % line)\n            return None\n\n    def get_file_type_from_megals_line_data(self, line):\n        """"""\n        Extract file type from megals line data output.\n        example input:\n        udtDgR7I    Xz2tWWB5Dmo 0    4405067776 2013-04-10 19:16:02 /Root/bigfile\n\n        Args:\n            line (str): line to extract file type from.\n\n        Returns:\n            string: File type as integer. 0 = file, 1 = directory, 2 = MEGA account system file ie: ""/Root"".\n        """"""\n        logger = getLogger(\'MegaTools_Lib.get_file_type_from_megals_line_data\')\n        logger.setLevel(self.__log_level)\n        logger.debug(\' Getting file type from ""%s""\' % line)\n\n        remote_type = None\n        try:\n            remote_type = line.split()[2]\n        except Exception as e:\n            logger.error(\'Exception: %s\' % str(e))\n        finally:\n            return remote_type\n\n    def get_account_free_space(self, username, password):\n        """"""\n        Get account free space in gigabytes\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n\n        Returns:\n             int: Free space of account in gigabytes.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_account_used_space\')\n        logger.setLevel(self.__log_level)\n\n        # chdir(\'%s\' % self.__mega_tools_dir)\n\n        cmd = \'megadf --free -h --gb -u %s -p %s\' % (username, password)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        if err:\n            logger.info(str(err))\n\n        if not out == \'\':\n            freeSpace = sub(\'\\r\', \'\', out).rstrip()\n            logger.debug(\' Success, could get account free space.\')\n            return freeSpace\n        logger.debug(\' Error, could NOT get account free space!\')\n        return 0\n\n    def get_account_used_space(self, username, password):\n        """"""\n        Get account used space in gigabytes\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n\n        Returns:\n             int: Used space of account in gigabytes.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_account_used_space\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megadf --used -h --gb -u %s -p %s\' % (username, password)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        if err:\n            logger.info(str(err))\n\n        if not out == \'\':\n            usedSpace = sub(\'\\r\', \'\', out).rstrip()\n            logger.debug(\' Success, could get account free space.\')\n            return usedSpace\n        logger.debug(\' Error, could NOT get account free space!\')\n        return None\n\n    def get_account_total_space(self, username, password):\n        """"""\n        Get account total space in gigabytes\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n\n        Returns:\n             int: Total space of account in gigabytes.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_account_total_space\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megadf --total -h --gb -u %s -p %s\' % (username, password)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        if err:\n            logger.info(str(err))\n\n        if not out == \'\':\n            totalSpace = sub(\'\\r\', \'\', out).rstrip()\n            logger.debug(\' Success, could get account total space.\')\n            return totalSpace\n        logger.debug(\' Error, could NOT get account total space!\')\n        return None\n\n    def get_remote_dir_size(self, username, password, localDirPath, localRoot, remoteRoot):\n        """"""\n        Get remote directory sizes of equivalent local file path\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            localDirPath (str): Local directory path of remote file size to get\n            localRoot (str): Local root path of local account files to map with remote root.\n            remoteRoot (str): Remote root path of remote accounts to map with local root.\n\n        Returns:\n             tuple: Remote directory size and remote directory path\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_dir_size\')\n        logger.setLevel(self.__log_level)\n\n        remotePath = self.__lib.get_remote_path_from_local_path(localPath=localDirPath, localRoot=localRoot,\n                                                                remoteRoot=remoteRoot)\n\n        if remotePath:\n\n            cmd = \'megals -lR -u %s -p %s ""%s""\' % (username, password, remotePath)\n            out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n            lines = out.split(linesep)\n            totalRemoteDirSize = 0\n            for line in lines:\n                line_split = line.split()\n                if len(line_split) > 2:\n                    remoteFileSize = line_split[3]\n                    if remoteFileSize.isdigit():\n                        totalRemoteDirSize = totalRemoteDirSize + int(remoteFileSize)\n\n            logger.debug(\' Success, could get remote directory size.\')\n            return totalRemoteDirSize\n\n        logger.debug(\' Error, could NOT get remote directory size!\')\n        return None\n\n    def get_remote_dirs(self, username, password, remote_path):\n        """"""\n        Get remote directories\n\n        Args:\n            username (str): username of account to get remote directories from\n            password (str): password of account to get remote directories from\n            remote_path (str): Remote root path of remote accounts to map with local root.\n\n        Returns:\n            list: returns list of directories\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_dirs\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Get remote directories.\')\n\n        cmd = [\'start\', \'/B\', \'megals\', \'-u\', \'%s\' % username, \'-p\', \'%s\' % password, \'""%s""\' % remote_path]\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        dirs = out.split(linesep)\n        dirList = []\n\n        for dir in dirs:\n            dirName = sub(\'%s\' % remote_path, \'\', dir)\n            if not dirName == \'\':\n                dirList.append(sub(\'/\', \'\', dirName))\n\n        return dirList\n\n    def get_remote_file_data_recursively(self, username, password, remote_path=\'/\', remove_blank_lines=False):\n        """"""\n        Get all remote file data as list. This includes file path, modified date/time, file size, file type (file or dir),\n\n        Args:\n            username (str): username of MEGA account.\n            password (str): password of MEGA account.\n            remote_path (str): root path to get remote files from.\n            remove_blank_lines (bool): If set to true output list will not contain empty strings.\n        Returns:\n            List: list of remote file data in given remote_path.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_file_data_recursively\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megals -lR -u %s -p %s ""%s""\' % (username, password, remote_path)\n\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd, output_file=self.__mega_tools_log)\n\n        if not err:\n            if not out == \'\':\n                lines = out.split(linesep)\n                if remove_blank_lines:\n                    lines = list(filter(None, lines))  # fastest\n                logger.debug(\' Success, could get remote file data recursievly.\')\n                return lines\n\n        logger.warning(str(err))\n        return None\n\n    def get_remote_file_modified_date(self, username, password, remotePath):\n        """"""\n        Get remote file modified date of equivalent local file path\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            remotePath (str): Remote file path of remote file size to get\n\n        Returns:\n             Tuple: Remote file modified data and remote file path\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_file_modified_date\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megals -ln -u %s -p %s ""%s""\' % (username, password, remotePath)\n        out, err = self.__lib.exec_cmd_and_return_output(cmd)\n        line_split = out.split()\n\n        if len(line_split) > 2:\n            remoteFileModifiedDate = line_split[4]\n            remoteFileModifiedTime = line_split[5]\n\n            remoteFileModifiedDate_time = \'%s %s\' % (remoteFileModifiedDate, remoteFileModifiedTime)\n\n            logger.debug(\' Success, could find remote file modified date.\')\n            return remoteFileModifiedDate_time\n\n        logger.warning(\' Error, could NOT find remote file modified date!\')\n        return None\n\n    def get_remote_file_size(self, username, password, remotePath=\'/\'):\n        """"""\n        Get remote file size in bytes of given remote path.\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            remotePath (str): remote path of file to get size for\n\n        Returns:\n             int: remote file size\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_file_size\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megals -ln -u %s -p %s ""%s""\' % (username, password, remotePath)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        line_split = out.split()\n        if len(line_split) > 2:\n            remoteFileSize = line_split[3]\n            logger.debug(\' Success, remote file size for path ""%s"" is ""%s""\' % (remotePath, remoteFileSize))\n            return int(remoteFileSize)\n        else:\n            logger.error(\' Error, could not get remote file size of path ""%s""\' % remotePath)\n            return None\n\n\n    def get_remote_file_size_from_local_path(self, username, password, localFilePath, localRoot, remoteRoot):\n        """"""\n        Get remote file sizes of equivalent local file path\n\n        Args:\n            username (str): username for MEGA account\n            password (str): password for MEGA account\n            localFilePath (str): Local file path of remote file size to get\n            localRoot (str): Local root path of local account files to map with remote root.\n            remoteRoot (str): Remote root path of remote accounts to map with local root.s\n\n        Returns:\n             int: remote file size\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_file_size_from_local_path\')\n        logger.setLevel(self.__log_level)\n\n        remotePath = self.__lib.get_remote_path_from_local_path(localPath=localFilePath, localRoot=localRoot,\n                                                                remoteRoot=remoteRoot)\n        if remotePath:\n            remoteFileSize = self.get_remote_file_size(username=username, password=password, remotePath=remotePath)\n            return remoteFileSize\n\n        return None\n\n    def get_remote_file_paths_recursively(self, username, password, remote_path=\'/\', process_priority_class=None,\n                                          process_set_priority_timeout=60):\n        """"""\n        Get remote files list.\n\n        Args:\n            username (str): username of MEGA account.\n            password (str): password of MEGA account.\n            remote_path (str): root path to get remote files from.\n            process_priority_class (str): Priority level to set process to. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            List: list of remote files in given remote_path.\n        """"""\n        logger = getLogger(\'MegaTools_Lib.get_remote_file_paths_recursively\')\n        logger.setLevel(self.__log_level)\n\n        cmd = \'megals -R -u %s -p %s ""%s""\' % (username, password, remote_path)\n\n        # out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd, output_file=self.__mega_tools_log)\n\n        if not err:\n            if not out == \'\':\n                lines = out.split(linesep)\n                remote_files = []\n                for line in lines:\n                    if not line == \'\' and len(findall(""\\?"", line)) == 0:\n                        remote_files.append(line)\n                logger.debug(\' Success, could get remote file paths.\')\n                return remote_files\n\n        self.create_remote_dir(username=username, password=password, remote_path=remote_path,\n                               process_priority_class=process_priority_class, process_set_priority_timeout=process_set_priority_timeout)\n        logger.warning(\' Warning: {}\'.format(err))\n        logger.warning(\' Error in megals output. Returning ""None"".\')\n        return None\n\n    def get_remote_subdir_names_only(self, username, password, remote_path):\n        """"""\n        Get remote sub directory names only.\n        Only the subdirectories immediately under remote_path are gotten.\n\n        Args:\n            username (str): username of account to get remote directories from\n            password (str): password of account to get remote directories from\n            remote_path (str): Remote root path of remote accounts to map with local root.\n\n        Returns:\n            list: sub directory names.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.get_remote_subdir_names_only\')\n        logger.setLevel(self.__log_level)\n\n        remote_root = remote_path + \'/\'\n        cmd = \'start /B megals -n -u %s -p %s ""%s""\' % (username, password, remote_root)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd)\n\n        if not err:\n            if not out == \'\':\n                lines = out.split(linesep)\n                logger.debug(\' Success, could get remote sub directory names.\')\n                return lines\n\n        logger.warning(str(err))\n        return None\n\n    def is_remote_dir(self, username, password, remote_dir_path):\n        """"""\n        Determines if remote path is an existing remote direcotry.\n\n        Args:\n            username (str): MEGA profile username.\n            password (str): MEGA profile password.\n            remote_dir_path (str): MEGA profile remote directory path to check for existance.\n\n        Returns:\n            Bool: Whether true or not.\n        """"""\n        logger = getLogger(\'MegaTools_Lib.is_remote_dir\')\n        logger.setLevel(self.__log_level)\n        logger.info(\' Determining if remote directory path exists: ""{}""\'.format(remote_dir_path))\n        remote_dirs = self.get_remote_dirs(username=username, password=password, remote_path=remote_dir_path)\n        if len(remote_dirs) < 1:\n            logger.info(\' Remote directory path does NOT exist! ""{}""\'.format(remote_dir_path))\n            return False\n        logger.info(\' Remote directory path does exist: ""{}""\'.format(remote_dir_path))\n        return True\n\n    def is_temp_mega_file(self, file_path):\n        """"""\n        Determines if file is temp MEGA file.\n\n        Args:\n            file_path (str): File path.\n\n        Returns:\n            Bool: Whether successful or not.\n        """"""\n        logger = getLogger(\'MegaTools_Lib.remove_temp_mega_files\')\n        logger.setLevel(self.__log_level)\n        logger.info(\' Determining if file is temp mega file: ""{}""\'.format(file_path))\n        try:\n            if len(findall(\'^.*\\.megatmp\\..*$\', file_path)) > 0:\n                logger.info(\' File is temp mega file: ""{}""\'.format(file_path))\n                return True\n\n            logger.info(\' File is NOT temp mega file: ""{}""\'.format(file_path))\n            return False\n\n        except Exception as e:\n            logger.error(\' Exception: {}\'.format(e))\n            return False\n\n    def remove_remote_path(self, username, password, remote_file_path, process_priority_class=""NORMAL_PRIORITY_CLASS"", process_set_priority_timeout=60):\n        """"""\n        Remove remote file or directory.\n\n        Args:\n            username (str): username of account to upload to\n            password (str): password of account to upload to\n            remote_file_path (str): remote file path to remove.\n            process_priority_class (str): Priority level to set for process. ie: ""NORMAL_PRIORITY_CLASS"".\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            boolean: whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.remove_remote_path\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' %s - %s: Removing remote file ""%s"".\' % (username, password, remote_file_path))\n\n        cmd = \'megarm -u %s -p %s ""%s""\' % (username, password, remote_file_path)\n\n        process_name = \'megarm.exe\' if system() == \'Windows\' else \'megarm\'\n        result = self.__lib.exec_cmd(command=cmd, process_name=process_name, process_priority_class=process_priority_class,\n                                     process_set_priority_timeout=process_set_priority_timeout)\n\n        if result:\n            logger.debug(\' Success, could remove remote file: ""{}""\'.format(remote_file_path))\n            return True\n        else:\n            logger.debug(\' Error, could NOT remove remote file! ""{}""\'.format(remote_file_path))\n            return False\n\n    def upload_local_dir(self, username, password, local_dir, remote_path, process_priority_class=None,\n                                          process_set_priority_timeout=60):\n        """"""\n        Upload directory.\n\n            username (str): username of account to upload to\n            password (str): password of account to upload to\n            local_dir (str): Local directory to upload\n            remote_path (str): Remote directory to upload to\n            process_priority_class (str): Priority level to set process to. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            boolean: whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.upload_local_dir\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\'%s - %s: Uploading files in directory ""%s""\' % (username, password, local_dir))\n\n        if not self.is_remote_dir(username=username, password=password, remote_dir_path=remote_path):\n            self.create_remote_dir(username=username, password=password, remote_path=remote_path,\n                                   process_priority_class=process_priority_class,\n                                   process_set_priority_timeout=process_set_priority_timeout)\n\n        if self.__up_speed_limit:\n            cmd = \'megacopy -u %s -p %s --limit-speed %d --local ""%s"" --remote ""%s""\' % (username, password,\n                                                                                        self.__up_speed_limit, local_dir, remote_path)\n        else:\n            cmd = \'megacopy -u %s -p %s --local ""%s"" --remote ""%s""\' % (username, password, local_dir, remote_path)\n\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd, output_file=self.__mega_tools_log)\n\n        if out and not err:\n            logger.debug(\' Success, uploaded local directory: {}\'.format(local_dir))\n            return True\n\n        logger.warning(\' Warning: {}\'.format(err))\n        return False\n\n    def upload_to_account(self, username, password, local_root, remote_root, process_priority_class=None,\n                                          process_set_priority_timeout=60):\n        """"""\n        Upload all files to account.\n\n        Args:\n            username (str): username of account to __upload to\n            password (str): password of account to __upload to\n            local_root (str): Local root path of local account files to map with remote root.\n            remote_root (str): Remote root path of remote accounts to map with local root.\n            process_priority_class (str): Priority level to set process to. ie: ""NORMAL_PRIORITY_CLASS""\n            process_set_priority_timeout (int): Timeout in seconds to wait for process to start after setting priority.\n\n        Returns:\n            boolean: whether successful or not.\n        """"""\n\n        logger = getLogger(\'MegaTools_Lib.upload_to_account\')\n        logger.setLevel(self.__log_level)\n\n        logger.debug(\' Starting uploading for %s - %s\' % (username, password))\n\n        self.upload_local_dir(username=username, password=password, local_dir=local_root, remote_path=remote_root,\n                              process_priority_class=process_priority_class,\n                              process_set_priority_timeout=process_set_priority_timeout)\n\n        localRoot_adj = sub(\'\\\\\\\\\', \'/\', local_root)\n\n        cmd = \'megals -ln -u %s -p %s ""%s""\' % (username, password, remote_root)\n        out, err = self.__lib.exec_cmd_and_return_output(command=cmd, output_file=self.__mega_tools_log)\n\n        if not err:\n            lines = out.split(linesep)\n            for line in lines:\n                if not line == \'\':\n                    if len(split(\':\\d{2} \', line)) > 1:\n                        remote_filePath = split(\':\\d{2} \', line)[1]\n                        dir_subPath = sub(remote_root, \'\', remote_filePath)\n                        local_dir = localRoot_adj + \'/\' + dir_subPath\n                        remote_dir = remote_root + \'/\' + dir_subPath\n                        if path.exists(local_dir):\n                            self.upload_local_dir(username, password, local_dir, remote_dir)\n\n            logger.debug(\'Success, could upload files to account.\')\n            return True\n\n        logger.warning(str(err))\n        logger.debug(\' Error, could NOT upload files to account!\')\n        return False\n\n\nclass MegaToolsFile(object):\n    def __init__(self, file_details, log_level=\'DEBUG\', log_file_path=MEGATOOLS_LOG_PATH):\n        """"""\n        Class for Mega Tools files and extracting data about file given mega tools file output using ""megals --long"".\n        For more info: https://megatools.megous.com/man/megals.html\n\n        Args:\n            file_details(str): File details line as shown using ""megals --long"".\n                ie: 2FFSiaKZ    Xz2tWWB5Dmo 0          2686 2013-04-15 08:33:47 /Root/directory/file.txt\n            log_level (str): Logging level setting ie: ""DEBUG"" or ""WARN""\n            log_file_path (str): MEGATools log file path.\n\n        """"""\n        self.__log_level = log_level\n        self.__mega_tools_file_log = log_file_path\n\n\n\n'"
megamanager/tools/__init__.py,0,"b'# from .compressImages import CompressImage, DeleteBackupImage\n'"
megamanager/tools/compressImages/__init__.py,0,"b'from .compressImages import CompressImage, DeleteBackupImage\n'"
megamanager/tools/compressImages/compressImages.py,0,"b'#!/usr/bin/env python\n# Copyright (c) 2015, Softwariness.com\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of Softwariness.com nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nfrom PIL import Image, ImageFile\nfrom sys import exit, stderr\nfrom os.path import getsize, isfile, isdir, join\nfrom os import remove, rename, walk, stat\nfrom stat import S_IWRITE\nfrom shutil import move\nfrom argparse import ArgumentParser\nfrom abc import ABCMeta, abstractmethod\n\nclass ProcessBase:\n    """"""Abstract base class for file processors.""""""\n    __metaclass__ = ABCMeta\n\n    def __init__(self):\n        self.extensions = []\n        self.backupextension = \'compressimages-backup\'\n\n    @abstractmethod\n    def processfile(self, filename):\n        """"""Abstract method which carries out the process on the specified file.\n        Returns True if successful, False otherwise.""""""\n        pass\n\n    def processdir(self, path):\n        """"""Recursively processes files in the specified directory matching\n        the self.extensions list (case-insensitively).""""""\n\n        filecount = 0 # Number of files successfully updated\n\n        for root, dirs, files in walk(path):\n            for file in files:\n                # Check file extensions against allowed list\n                lowercasefile = file.lower()\n                matches = False\n                for ext in self.extensions:\n                    if lowercasefile.endswith(\'.\' + ext):\n                        matches = True\n                        break\n                if matches:\n                    # File has eligible extension, so process\n                    fullpath = join(root, file)\n                    if self.processfile(fullpath):\n                        filecount = filecount + 1\n        return filecount\n\nclass CompressImage(ProcessBase):\n    """"""Processor which attempts to reduce image file size.""""""\n    def __init__(self):\n        ProcessBase.__init__(self)\n        self.extensions = [\'jpg\', \'jpeg\', \'png\']\n\n    def processfile(self, filename):\n        """"""Renames the specified image to a backup path,\n        and writes out the image again with optimal settings.""""""\n        try:\n            # Skip read-only files\n            if (not stat(filename)[0] & S_IWRITE):\n                print \'Ignoring read-only file ""\' + filename + \'"".\'\n                return False\n            \n            # Create a backup\n            backupname = filename + \'.\' + self.backupextension\n\n            if isfile(backupname):\n                print \'Ignoring file ""\' + filename + \'"" for which existing backup file is present.\'\n                return False\n\n            rename(filename, backupname)\n        except Exception as e:\n            stderr.write(\'Skipping file ""\' + filename + \'"" for which backup cannot be made: \' + str(e) + \'\\n\')\n            return False\n\n        ok = False\n\n        try:\n            # Open the image\n            with open(backupname, \'rb\') as file:\n                img = Image.open(file)\n\n                # Check that it\'s a supported format\n                format = str(img.format)\n                if format != \'PNG\' and format != \'JPEG\':\n                    print \'Ignoring file ""\' + filename + \'"" with unsupported format \' + format\n                    return False\n\n                # This line avoids problems that can arise saving larger JPEG files with PIL\n                ImageFile.MAXBLOCK = img.size[0] * img.size[1]\n                \n                # The \'quality\' option is ignored for PNG files\n                img.save(filename, quality=90, optimize=True)\n\n            # Check that we\'ve actually made it smaller\n            origsize = getsize(backupname)\n            newsize = getsize(filename)\n\n            if newsize >= origsize:\n                print \'Cannot further compress ""\' + filename + \'"".\'\n                return False\n\n            # Successful compression\n            ok = True\n        except Exception as e:\n            stderr.write(\'Failure whilst processing ""\' + filename + \'"": \' + str(e) + \'\\n\')\n        finally:\n            if not ok:\n                try:\n                    move(backupname, filename)\n                except Exception as e:\n                    stderr.write(\'ERROR: could not restore backup file for ""\' + filename + \'"": \' + str(e) + \'\\n\')\n\n        return ok\n\nclass RestoreBackupImage(ProcessBase):\n    """"""Processor which restores image from backup.""""""\n\n    def __init__(self):\n        ProcessBase.__init__(self)\n        self.extensions = [self.backupextension]\n\n    def processfile(self, filename):\n        """"""Moves the backup file back to its original name.""""""\n        try:\n            move(filename, filename[: -(len(self.backupextension) + 1)])\n            return True\n        except Exception as e:\n            stderr.write(\'Failed to restore backup file ""\' + filename + \'"": \' + str(e) + \'\\n\')\n            return False\n\nclass DeleteBackupImage(ProcessBase):\n    """"""Processor which deletes backup image.""""""\n\n    def __init__(self):\n        ProcessBase.__init__(self)\n        self.extensions = [self.backupextension]\n\n    def processfile(self, filename):\n        """"""Deletes the specified file.""""""\n        try:\n            remove(filename)\n            return True\n        except Exception as e:\n            stderr.write(\'Failed to delete backup file ""\' + filename + \'"": \' + str(e) + \'\\n\')\n            return False\n\nif __name__ == ""__main__"":\n    # Argument parsing\n    modecompress = \'__compress_all\'\n    moderestorebackup = \'restorebackup\'\n    modedeletebackup = \'deletebackup\'\n    parser = ArgumentParser(description=\'Reduce file size of PNG and JPEG images.\')\n    parser.add_argument(\n        \'path\',\n         help=\'File or directory name\')\n    parser.add_argument(\n        \'--mode\', dest=\'mode\', default=modecompress,\n        choices=[modecompress, moderestorebackup, modedeletebackup],\n        help=\'Mode to run with (default: \' + modecompress + \'). \'\n            + modecompress + \': Compress the image(s). \'\n            + moderestorebackup + \': Restore the backup images (valid for directory path only). \'\n            + modedeletebackup + \': Delete the backup images (valid for directory path only).\')\n\n    args = parser.parse_args()\n\n    # Construct processor requested mode\n    if args.mode == modecompress:\n        processor = CompressImage()\n    elif args.mode == moderestorebackup:\n        processor = RestoreBackupImage()\n    elif args.mode == modedeletebackup:\n        processor = DeleteBackupImage()\n\n    # Run according to whether path is a file or a directory\n    if isfile(args.path):\n        if args.mode != modecompress:\n            stderr.write(\'Mode ""\' + args.mode + \'"" supported on directories only.\\n\')\n            exit(1)\n        processor.processfile(args.path)\n    elif isdir(args.path):\n        filecount = processor.processdir(args.path)\n        print \'\\nSuccessfully updated file count: \' + str(filecount)\n    else:\n        stderr.write(\'Invalid path ""\' + args.path + \'""\\n\')\n        exit(1)\n'"
