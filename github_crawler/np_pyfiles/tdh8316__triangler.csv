file_path,api_count,code
setup.py,0,"b'from setuptools import setup\n\nwith open(""README.md"") as fh:\n    long_description = fh.read()\n\nsetup(\n    name=""triangler"",\n    version=""0.3"",\n    packages=[""triangler""],\n    url=""https://github.com/tdh8316/triangler"",\n    license=""MIT License"",\n    author=""Donghyeok Tak"",\n    author_email=""tdh8316@naver.com"",\n    description=""Convert images to Low-Poly art using Delaunay triangulation."",\n    long_description=long_description,\n    long_description_content_type=""text/markdown"",\n    install_requires=[\n        ""matplotlib"",\n        ""scikit-image"",\n        ""numpy==1.17.2"",\n        ""scipy==1.4.1"",\n        ""numba"",\n        ""imageio"",\n    ],\n    python_requires="">=3.6"",\n    classifiers=[\n        ""Programming Language :: Python :: 3"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: OS Independent"",\n    ],\n)\n'"
examples/example.py,0,"b'from skimage.io import imread\n\nimport triangler\n\nimport matplotlib.pyplot as plt\n\n# Read image from disk\nimg = imread(""IMAGE_PATH.jpg"")\n\n# Create Triangler instance\nt = triangler.Triangler(sample_method=triangler.SampleMethod.POISSON_DISK)\n\nprint(""Converting... "")\n# Convert\nimg_tri = t.convert(img)\nprint(""[Done]"")\n\n_, axes = plt.subplots(1, 2, figsize=(16, 16))\naxes[0].imshow(img)\naxes[1].imshow(img_tri)\nplt.show()\n'"
triangler/__init__.py,1,"b'import warnings as _warnings\nfrom time import time as _time\n\nimport numpy as _np\n\nfrom triangler.color import ColorMethod\nfrom triangler.edges import EdgeMethod\nfrom triangler.mod import Triangler\nfrom triangler.sampling import SampleMethod\n\n_np.random.seed(int(_time()))\n_warnings.filterwarnings(""ignore"")\n'"
triangler/__main__.py,0,"b'from triangler import cmd\n\nif __name__ == ""__main__"":\n    cmd.main()\n'"
triangler/cmd.py,0,"b'import logging\nimport multiprocessing\nimport sys\nfrom argparse import ArgumentParser, ArgumentDefaultsHelpFormatter\nfrom typing import List\n\nfrom triangler import Triangler\nfrom triangler.color import ColorMethod\nfrom triangler.edges import EdgeMethod\nfrom triangler.sampling import SampleMethod\n\n\n# noinspection PyProtectedMember\ndef main() -> None:\n    parser = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)\n\n    parser.add_argument(""images"", help=""Source files"", nargs=""+"", type=str)\n    parser.add_argument(\n        ""-o"", ""--output"", help=""Destination file"", nargs=""+"", type=str, default=None\n    )\n    parser.add_argument(\n        ""-s"",\n        ""--sample"",\n        help=""Sampling method for candidate points."",\n        type=str.upper,\n        default=""THRESHOLD"",\n        choices=SampleMethod._member_names_,\n    )\n    parser.add_argument(\n        ""-e"",\n        ""--edge"",\n        help=""Pre-processing method to use."",\n        type=str.upper,\n        default=""SOBEL"",\n        choices=EdgeMethod._member_names_,\n    )\n    parser.add_argument(\n        ""-b"",\n        ""--blur"",\n        help=""Blur radius for approximate canny edge detector."",\n        type=int,\n        default=2,\n        required=False,\n    )\n    parser.add_argument(\n        ""-c"",\n        ""--color"",\n        help=""Coloring method for rendering."",\n        type=str.upper,\n        default=""CENTROID"",\n        choices=ColorMethod._member_names_,\n    )\n    parser.add_argument(\n        ""-p"", ""--points"", help=""Points threshold."", type=int, default=1024\n    )\n    parser.add_argument(\n        ""-l"",\n        ""--reduce"",\n        help=""Apply pyramid reduce to result image"",\n        action=""store_true"",\n    )\n\n    parser.add_argument(\n        ""-v"", ""--verbose"", help=""Set logger level as DEBUG"", action=""store_true""\n    )\n\n    args = parser.parse_args()\n\n    # Set logger\n    logging.basicConfig(\n        level=logging.DEBUG if args.verbose else logging.WARNING,\n        format=""[%(asctime)s][%(levelname)s] in %(funcName)s(): %(message)s"",\n        datefmt=""%Y-%m-%d %H:%M:%S"",\n        stream=sys.stdout,\n    )\n\n    logging.info(""Options:{}"".format(args))\n\n    if hasattr(args, ""output"") and isinstance(args.output, list):\n        if len(args.images) != len(args.output):\n            raise IndexError(\n                ""The number of input images and output targets are not matched.""\n            )\n\n    _e = EdgeMethod[args.edge.upper()]\n\n    if _e is EdgeMethod.CANNY and args.blur < 0:\n        raise ValueError(""Blur value must be positive integer."")\n\n    # TODO: Recognize wildcard\n\n    t = Triangler(\n        edge_method=_e,\n        color_method=ColorMethod[args.color.upper()],\n        sample_method=SampleMethod[args.sample.upper()],\n        points=args.points,\n        blur=args.blur,\n        pyramid_reduce=args.reduce,\n    )\n\n    # Use multiprocessing to process multiple files at the same time\n    _processes: List[multiprocessing.Process] = []\n    for index, image in enumerate(args.images):\n        _process = multiprocessing.Process(\n            target=t.save,\n            args=(\n                image,\n                None if not isinstance(args.output, list) else args.output[index],\n            ),\n            kwargs={""print_log"": True},\n        )\n        _process.daemon = True\n        _processes.append(_process)\n        _process.start()\n\n    for process in _processes:\n        process.join()\n'"
triangler/color.py,0,b'import enum\n\n\nclass ColorMethod(enum.Enum):\n    MEAN = enum.auto()\n    CENTROID = enum.auto()\n'
triangler/edges.py,18,"b'import enum\nfrom enum import Enum\nfrom typing import Union\n\nimport numba\nimport numpy as np\nimport skimage.restoration\nfrom numpy.core.multiarray import ndarray\nfrom scipy.signal import convolve2d\nfrom skimage import img_as_float64, img_as_ubyte\nfrom skimage.color import rgb2gray, rgb2lab\nfrom skimage.filters import scharr, gaussian\nfrom skimage.filters.rank import entropy\nfrom skimage.morphology import disk, dilation\n\nfrom triangler.sampling import (\n    SampleMethod,\n    poisson_disk_sample,\n    threshold_sample,\n)\n\n\nclass EdgeMethod(Enum):\n    CANNY = enum.auto()\n    ENTROPY = enum.auto()\n    SOBEL = enum.auto()\n\n\nclass EdgePoints(object):\n    __slots__ = [""width"", ""height"", ""edge_detector"", ""num_of_points"", ""edge_method""]\n\n    def __init__(self, img: ndarray, n: int, edge: EdgeMethod):\n        self.width = img.shape[0]\n        self.height = img.shape[1]\n\n        self.edge_detector: EdgeDetectors = EdgeDetectors(img)\n\n        self.num_of_points = n\n\n        self.edge_method: EdgeMethod = edge\n\n    def get_edge_points(self, sampling: SampleMethod, blur: int = None) -> ndarray:\n        """"""\n        Retrieves the triangle points using Sobel | Canny | Threshold Edge Detection\n        """"""\n        if self.edge_method is EdgeMethod.CANNY:\n            if blur is None:\n                raise ValueError(\n                    ""To use Canny Edge Detector, you must call this method with (SampleMethod, int)""\n                )\n            edges = self.edge_detector.canny(blur)\n        elif self.edge_method is EdgeMethod.ENTROPY:\n            edges = self.edge_detector.entropy()\n        elif self.edge_method is EdgeMethod.SOBEL:\n            edges = self.edge_detector.sobel()\n        else:\n            raise ValueError(\n                ""Unexpected edge processing method: {}\\n""\n                ""use {} instead: {}"".format(\n                    self.edge_method, SampleMethod.__name__, SampleMethod.__members__\n                )\n            )\n\n        if sampling is SampleMethod.POISSON_DISK:\n            sample_points = poisson_disk_sample(self.num_of_points, edges)\n        elif sampling is SampleMethod.THRESHOLD:\n            sample_points = threshold_sample(self.num_of_points, edges, 0.2)\n        else:\n            raise ValueError(\n                ""Unexpected sampling method: {}\\n""\n                ""use {} instead: {}"".format(\n                    sampling, SampleMethod.__name__, SampleMethod.__members__\n                )\n            )\n\n        corners = np.array(\n            [\n                [0, 0],\n                [0, self.height - 1],\n                [self.width - 1, 0],\n                [self.width - 1, self.height - 1],\n            ]\n        )\n        return np.append(sample_points, corners, axis=0)\n\n\nclass EdgeDetectors(object):\n    __slots__ = [""img""]\n\n    def __init__(self, img: ndarray):\n        self.img: ndarray = img\n\n    @numba.jit(parallel=True, fastmath=True)\n    def sobel(self) -> ndarray:\n        _img_as_float = self.img.astype(np.float)\n        c: Union[int, float]\n        _, _, c = _img_as_float.shape\n        _img = (\n            0.2126 * _img_as_float[:, :, 0]\n            + 0.7152 * _img_as_float[:, :, 1]\n            + 0.0722 * _img_as_float[:, :, 2]\n            if c > 1\n            else _img_as_float\n        )\n\n        kh = np.array(\n            [\n                [-1, -2, 0, 2, 1],\n                [-4, -8, 0, 8, 4],\n                [-6, -12, 0, 12, 6],\n                [-4, -8, 0, 8, 4],\n                [-1, -2, 0, 2, 1],\n            ],\n            dtype=np.float,\n        )\n        kv = np.array(\n            [\n                [1, 4, 6, 4, 1],\n                [2, 8, 12, 8, 2],\n                [0, 0, 0, 0, 0],\n                [-2, -8, -12, -8, -2],\n                [-1, -4, -6, -4, -1],\n            ],\n            dtype=np.float,\n        )\n\n        gx = convolve2d(_img, kh, mode=""same"", boundary=""symm"")\n        gy = convolve2d(_img, kv, mode=""same"", boundary=""symm"")\n\n        g = np.sqrt(gx * gx + gy * gy)\n        g *= 255.0 / np.max(g)\n\n        return g\n\n    @numba.jit(fastmath=True)\n    def entropy(self, bal=0.1) -> ndarray:\n        dn_img = skimage.restoration.denoise_tv_bregman(self.img, 0.1)\n        img_gray = rgb2gray(dn_img)\n        img_lab = rgb2lab(dn_img)\n\n        entropy_img = gaussian(\n            img_as_float64(dilation(entropy(img_as_ubyte(img_gray), disk(5)), disk(5)))\n        )\n        edges_img = dilation(\n            np.mean(\n                np.array([scharr(img_lab[:, :, channel]) for channel in range(3)]),\n                axis=0,\n            ),\n            disk(3),\n        )\n\n        weight = (bal * entropy_img) + ((1 - bal) * edges_img)\n        weight /= np.mean(weight)\n        weight /= np.amax(weight)\n\n        return weight\n\n    @numba.jit(parallel=True, fastmath=True)\n    def canny(self, blur: int) -> ndarray:\n        # gray_img = rgb2gray(self.img)\n        # return cv2.Canny(gray_img, self.threshold, self.threshold*3)\n\n        threshold = 3 / 256\n        gray_img = rgb2gray(self.img)\n        blur_filt = np.ones(shape=(2 * blur + 1, 2 * blur + 1)) / ((2 * blur + 1) ** 2)\n        blurred = convolve2d(gray_img, blur_filt, mode=""same"", boundary=""symm"")\n        edge_filt = np.array([[1, 1, 1], [1, -8, 1], [1, 1, 1]])\n        edge = convolve2d(blurred, edge_filt, mode=""same"", boundary=""symm"")\n        for idx, val in np.ndenumerate(edge):\n            if val < threshold:\n                edge[idx] = 0\n        dense_filt = np.ones((3, 3))\n        dense = convolve2d(edge, dense_filt, mode=""same"", boundary=""symm"")\n        dense /= np.amax(dense)\n\n        return dense\n'"
triangler/mod.py,0,"b'from datetime import datetime\nfrom typing import Union\n\nfrom numpy.core.multiarray import ndarray\nfrom skimage.io import imread\nfrom skimage.io import imsave\n\nfrom triangler.color import ColorMethod\nfrom triangler.edges import EdgeMethod\nfrom triangler.process import process\nfrom triangler.sampling import SampleMethod\n\n\nclass Triangler(object):\n    """"""\n    Triangler wrapper\n    """"""\n\n    def __init__(\n        self,\n        edge_method: EdgeMethod = EdgeMethod.SOBEL,\n        sample_method: SampleMethod = SampleMethod.THRESHOLD,\n        color_method: ColorMethod = ColorMethod.CENTROID,\n        points: int = 1000,\n        blur: int = 2,\n        pyramid_reduce: bool = True,\n    ):\n        """"""\n        :param edge_method: Edge detecting method\n        :param sample_method: Sampling method\n        :param color_method: Color transfer method\n        :param points: The number of sampling points\n        :param blur: Not required if you don\'t use Canny Edge Detecting\n        :param pyramid_reduce: Use pyramid reduce\n        """"""\n        self.edge_method: EdgeMethod = edge_method\n        self.sample_method: SampleMethod = sample_method\n        self.color_method: ColorMethod = color_method\n        self.points: int = points\n        self.blur: int = blur\n        self.pyramid_reduce: bool = pyramid_reduce\n\n    def convert(self, source: Union[str, ndarray]) -> ndarray:\n        """"""\n        Return converted image as array\n        :param source: An image you\'d like to convert.\n        :return:\n        """"""\n        _type = type(source)\n        if _type not in (str, ndarray):\n            raise TypeError(""Supported type: str, ndarray but {}"".format(_type))\n\n        if _type is str:\n            source = imread(source)\n\n        return process(\n            img=source,\n            coloring=self.color_method,\n            sampling=self.sample_method,\n            edging=self.edge_method,\n            points=self.points,\n            blur=self.blur,\n            reduce=self.pyramid_reduce,\n        )\n\n    def save(self, source: Union[str, ndarray], output: str = None, **kwargs) -> None:\n        """"""\n        Convert and save the result as image\n        :param source: An image you\'d like to convert.\n        :param output: The name of the result image file.\n        :return:\n        """"""\n        _is_source_string: bool = isinstance(source, str)\n        _out = output or (\n            ""Triangler_{}.jpg"".format(datetime.now().strftime(""%H-%M-%b-%d-%G""))\n            if not _is_source_string\n            else (str().join(source.split(""."")[:-1]) + ""_tri."" + source.split(""."")[-1])\n        )\n        if kwargs[""print_log""]:\n            print(\n                ""Converting {}{}..."".format(\n                    """" if not _is_source_string else (source + "" -> ""), _out\n                )\n            )\n        imsave(\n            _out, self.convert(source),\n        )\n\n        if kwargs[""print_log""]:\n            print(""Saved {}"".format(_out))\n'"
triangler/process.py,5,"b'from typing import Union\n\nimport numba\nimport numpy as np\nfrom numpy.core.multiarray import ndarray\nfrom scipy.spatial import Delaunay\nfrom skimage.draw import polygon\nfrom skimage.io import imread\nfrom skimage.transform import pyramid_reduce\n\nfrom triangler.color import ColorMethod\nfrom triangler.edges import EdgePoints, EdgeMethod\nfrom triangler.sampling import SampleMethod\n\n\n@numba.jit(fastmath=True, parallel=True)\ndef process(\n    img: Union[ndarray, str],\n    coloring: ColorMethod,\n    sampling: SampleMethod,\n    edging: EdgeMethod,\n    points: int,\n    blur: int,\n    reduce: bool,\n) -> np.array:\n    if isinstance(img, str):\n        img = imread(img)\n    sample_points: ndarray = EdgePoints(img, points, edging).get_edge_points(\n        sampling=sampling, blur=blur,\n    )\n    triangulated: Delaunay = Delaunay(sample_points)\n\n    # noinspection PyUnresolvedReferences\n    triangles = sample_points[triangulated.simplices]\n\n    res = np.empty(\n        shape=(2 * img.shape[0], 2 * img.shape[1], img.shape[2]), dtype=np.uint8\n    )\n\n    if coloring is ColorMethod.CENTROID:\n        for triangle in triangles:\n            i, j = polygon(2 * triangle[:, 0], 2 * triangle[:, 1], res.shape)\n            res[i, j] = img[tuple(np.mean(triangle, axis=0, dtype=np.int32))]\n    elif coloring is ColorMethod.MEAN:\n        for triangle in triangles:\n            i, j = polygon(2 * triangle[:, 0], 2 * triangle[:, 1], res.shape)\n            res[i, j] = np.mean(\n                img[polygon(triangle[:, 0], triangle[:, 1], img.shape)], axis=0\n            )\n    else:\n        raise ValueError(\n            ""Unexpected coloring method: {}\\n""\n            ""use {} instead: {}"".format(\n                coloring, ColorMethod.__name__, ColorMethod.__members__\n            )\n        )\n\n    return pyramid_reduce(res, multichannel=True) if reduce else res\n'"
triangler/sampling.py,21,"b'""""""\nBased on: https://github.com/pmaldonado/PyTri/blob/master/delaunay.py#L56\n""""""\n\nimport enum\nfrom typing import Tuple\n\nimport numba\nimport numpy as np\nimport scipy.spatial\n\n\nclass SampleMethod(enum.Enum):\n    POISSON_DISK = enum.auto()\n    THRESHOLD = enum.auto()\n\n\ndef in_bounds(point: Tuple[int, int], width: int, height: int) -> bool:\n    return 0 <= point[0] < width and 0 <= point[1] < height\n\n\ndef has_neighbor(\n    new_point: Tuple[int, int], rads: np.ndarray, tree: scipy.spatial.KDTree\n) -> bool:\n    return len(tree.query_ball_point(new_point, rads[new_point])) > 0\n\n\n@numba.jit(fastmath=True, parallel=True)\ndef poisson_disk_sample(n: int, weights: np.array) -> np.ndarray:\n    """"""\n    Performs weighted poisson disk sampling over a region.\n    Algorithm based on\n    https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf\n    Weighted approach inspired by\n    https://codegolf.stackexchange.com/questions/50299/draw-an-image-as-a-voronoi-map\n    Parameters\n    ----------\n    n : int\n        The number of points to sample.\n    weights : np.array\n        Weights of grid to sample over. Assumes weights are normalized.\n\n    Returns\n    -------\n    list :\n        List of sampled points\n    """"""\n    width: int = weights.shape[0]\n    height: int = weights.shape[1]\n\n    max_rad: int = int(min(width, height) / 4)\n    avg_rad = np.sqrt(\n        (height * width) / ((1 / np.log10(width * height) / 2) * n * np.pi)\n    )\n\n    weights /= np.mean(weights)\n    rads = np.clip(avg_rad / (weights + 0.01), avg_rad / 4, max_rad)\n\n    first = (np.random.randint(width), np.random.randint(height))\n    queue = [first]\n    sample_points = [first]\n    tree = scipy.spatial.KDTree(sample_points)\n\n    while queue and len(sample_points) < n:\n        idx = np.random.randint(len(queue))\n        point = queue[idx]\n\n        success = False\n        for _ in numba.prange(16):\n            new_point = get_point_near(point, rads, max_rad)\n\n            if in_bounds(new_point, width=width, height=height) and not has_neighbor(\n                new_point, rads, tree\n            ):\n                queue.append(new_point)\n                sample_points.append(new_point)\n                tree = scipy.spatial.KDTree(sample_points)\n                success = True\n                break\n\n        if not success:\n            queue.pop(idx)\n\n    return np.array(list(sample_points))\n\n\n@numba.jit(parallel=True, nopython=True)\ndef get_point_near(\n    point: Tuple[int, int], rads: np.array, max_rad: int\n) -> Tuple[int, int]:\n    """"""\n    Randomly samples an annulus near a given point using a uniform\n    distribution.\n    Parameters\n    ----------\n    point : (int, int)\n        The point to sample nearby.\n    rads : np.array\n        The lower bound for the np.random search.\n    max_rad : int\n        The upper bound for the np.random search.\n\n    Returns\n    -------\n    (int, int) :\n        The nearby point.\n    """"""\n    rad = np.random.uniform(rads[point], max_rad)\n    theta = np.random.uniform(0, 2 * np.pi)\n    new_point = (point[0] + rad * np.cos(theta), point[1] + rad * np.sin(theta))\n    return int(new_point[0]), int(new_point[1])\n\n\n@numba.jit(parallel=True, nopython=True)\ndef threshold_sample(n, weights, threshold):\n    """"""\n    Sample the weighted points uniformly above a certain threshold.\n    Parameters\n    ----------\n    n : int\n        The number of points to sample.\n    weights : np.array\n        Weights of grid to sample over. Assumes weights are normalized.\n    threshold : float\n        The threshold to ignore points\n    Returns\n    -------\n    list :\n        The list of points to triangulate.\n    """"""\n    candidates = np.array(\n        [idx for idx, weight in np.ndenumerate(weights) if weight >= threshold]\n    )\n    if candidates.shape[0] < n:\n        n = candidates.shape[0]\n\n    return candidates[np.random.choice(candidates.shape[0], size=n, replace=False)]\n'"
