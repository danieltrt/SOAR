file_path,api_count,code
TestModels/GameOfLife1D.py,8,"b'"""""" A 1D CA model in ASCII """"""\n\nimport random\n\nimport numpy as np\nimport pylab as pl\n\n\ndef getNewState(previousNeighboursState):\n    newState = \'0\'\n\n    beforeCharacter = previousNeighboursState[0]\n    selfCharacter = previousNeighboursState[1]\n    afterCharacter = previousNeighboursState[2]\n\n    newState = selfCharacter\n\n    if selfCharacter == \'0\':  # If Normal and there is an infected close, be Susceptible\n        if beforeCharacter == \'2\' or afterCharacter == \'2\':\n            newState = \'1\'\n    else:\n        if selfCharacter == \'1\':  # if Susceptible, calculate the probability to be Infected\n            #betaChance = (2 - np.random.normal(0.5, 1.0)) # NORMAL\n            #betaChance = (2 - np.random.uniform()) # UNIFORM\n            betaChance = (2 - (np.random.poisson(5) % 10) * 0.1)  # POISSON\n            if 0 < betaChance < beta:\n                newState = \'2\'\n            else:\n                newState = \'0\'\n        else:\n            if selfCharacter == \'2\':  # if Infected, calculate the probability to be Susceptible \'to recover\'\n                #gammaChance = (1 - np.random.normal(0.5, 1.0)) # NORMAL\n                #gammaChance = (1 - np.random.uniform()) # UNIFORM\n                gammaChance = (1 - (np.random.poisson(5) % 10) * 0.1) # POISSON\n\n                if gamma > gammaChance > 0:\n                    newState = \'1\'\n\n    return newState\n\n\nbeta = 1.4247 # Chance to get S from neighbouring I\ngamma = 0.14286 # Chance to get from I to R (or normal in our case)\nsusceptibleCharacter = \'S\'\ninfectedCharacter =\'I\'\nnormalCharacter = \' \'\nmaxgenerations = 200\ncellcount = 30\noffendvalue = \'0\'\n\nt_start = 0.0\nt_end = maxgenerations\nt_inc = 1\nt_range = np.arange(t_start, t_end + t_start, t_inc)\n\nuniverse = \'\'.join(random.choice(\'000000002\') for i in range(cellcount))\n\nInitSusceptibles = 0.0\nInitInfected = universe.count(\'2\')\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0]\n\nRES = [InitVariables]\n \nfor i in range(maxgenerations):\n    print(""Generation %3i:  %s"" % ( i,\n          universe.replace(\'0\', normalCharacter).replace(\'1\', susceptibleCharacter).replace(\'2\', infectedCharacter )))\n\n    RES.append([universe.count(\'0\'), universe.count(\'1\'), universe.count(\'2\'), i])\n\n    universe = offendvalue + universe + offendvalue\n    universe = \'\'.join(\n        getNewState(\n            universe[i:i+3]\n        ) for i in range(cellcount)\n    )\n\n\nRES = np.array(RES)\n\n# Ploting\npl.subplot(3, 1, 1)\npl.plot(RES[:, 3], RES[:, 2],  \'-r\', label=\'Infected\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Infected and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 2)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 3)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 2], \'-b\', label=\'Infected\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Infected\')\npl.xlabel(\'Susceptibles\')\npl.ylabel(\'Infected\')\n\npl.show()\n'"
TestModels/GameOfLife2D.py,8,"b'"""""" A Test 2D CA model """"""\n\nimport random\n\nimport numpy as np\nimport pylab as pl\n\n\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter, infectedCharacter):\n    """"""\n    Print the current generation.\n    :param currentTimeStep:\n    :param cellCountX:\n    :param cellCountY:\n    :param normalCharacter:\n    :param susceptibleCharacter:\n    :param infectedCharacter:\n    :return:\n    """"""\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', normalCharacter + "" "").replace(\'1\', susceptibleCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "")))\n\n\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n    """"""\n    Calculate the new state of the cell based on Van Neumann neighborhood.\n    :param currentRowNeighbours:\n    :param upperRowNeighbours:\n    :param lowerRowNeighbours:\n    :return:\n    """"""\n    newState = \'0\'\n\n    leftCharacter = currentRowNeighbours[0]\n    selfCharacter = currentRowNeighbours[1]\n    rightCharacter = currentRowNeighbours[2]\n\n    upperLeftCharacter = upperRowNeighbours[0]\n    upperCenterCharacter = upperRowNeighbours[1]\n    upperRightCharacter = upperRowNeighbours[2]\n\n    lowerLeftCharacter = lowerRowNeighbours[0]\n    lowerCenterCharacter = lowerRowNeighbours[1]\n    lowerRightCharacter = lowerRowNeighbours[2]\n\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If Normal and there is an Infected close, be Susceptible\n        if leftCharacter == \'2\' or rightCharacter == \'2\' or\\\n            upperLeftCharacter == \'2\' or upperRightCharacter == \'2\' or upperCenterCharacter == \'2\'\\\n                or lowerLeftCharacter == \'2\' or lowerRightCharacter == \'2\' or lowerCenterCharacter == \'2\':\n            newState = \'1\'\n    else:\n        if selfCharacter == \'1\': # if Susceptible, calculate the probability to be Infected\n            #betaChance = (2 - np.random.normal(0.5, 1.0)) # NORMAL\n            betaChance = (2 - np.random.uniform()) # UNIFORM\n            #betaChance = (2 - (np.random.poisson(2) % 10) * 0.1) # POISSON\n            if betaChance > 0 and betaChance < beta:\n                newState = \'2\'\n            else:\n                newState = \'0\'\n        else:\n            if selfCharacter == \'2\': # if Infected, calculate the probability to be Susceptible \'to recover\'\n                #gammaChance = (1 - np.random.normal(0.5, 1.0)) # NORMAL\n                gammaChance = (1 - np.random.uniform()) # UNIFORM\n                #gammaChance = (1 - (np.random.poisson(2) % 10) * 0.1) # POISSON\n\n                if gammaChance < gamma and gammaChance > 0:\n                    newState = \'1\'\n\n    return newState\n\n\n# SIS Model Parameters\nbeta = 1.4247  # Chance to get S from neighbouring I\ngamma = 0.14286  # Chance to get from I to R (or normal in our case)\nsimulationIterations = 100\ncellCountX = 33\ncellCountY = 33\n\n# Init values\nsusceptibleCharacter = \'S\'\ninfectedCharacter =\'I\'\nnormalCharacter = \'_\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    universe = \'\'.join(random.choice(\'000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0]\n\nRES = [InitVariables]\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep == 1:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter, infectedCharacter)\n    #print ""TimeStep %3i:  "" % currentTimeStep\n    #rowLabel = ""  ""\n    #for l in range(cellCountX):\n    #    rowLabel += str(l) + "" ""\n    #print rowLabel\n    #for currentRow in range(cellCountY):\n    #    print ""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', normalCharacter + "" "").replace(\'1\', susceptibleCharacter + "" "").\n    # print\n    #                     replace(\'2\', infectedCharacter + "" ""))\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n    RES.append([zeroCount, oneCount, twoCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    for currentRow in range(cellCountY):\n        oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n            upperRowNeighbours = \'000\'\n            lowerRowNeighbours = \'000\'\n            currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn+3]\n            if (currentRow - 1) >= 0:\n                upperRowNeighbours = oldUniverseList[currentRow-1][currentColumn:currentColumn+3]\n            if (currentRow + 1) < cellCountY:\n                lowerRowNeighbours = oldUniverseList[currentRow+1][currentColumn:currentColumn+3]\n\n            newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n            universeList[currentRow] = newUniverseRow\n\n#print RES\nRES = np.array(RES)\n\n#Ploting\npl.subplot(3, 1, 1)\npl.plot(RES[:, 3], RES[:, 2],  \'-r\', label=\'Infected\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Infected and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 2)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 3)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 2], \'-b\', label=\'Infected\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Infected\')\npl.xlabel(\'Susceptibles\')\npl.ylabel(\'Infected\')\n\npl.show()'"
TestModels/GameOfLife2DHex.py,8,"b'"""""" An ascii 2D CA model for SEIRS without mortality or birth """"""\n\nimport random\n\nimport numpy as np\nimport pylab as pl\n\n\ndef printGenerationUniverseHex(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter,\n                               infectedCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""   ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        cellGap = \'\'\n        if currentRow % 2 == 1:\n            cellGap = \'  \'\n        print(""%s%s  %s"" % (currentRow, cellGap,\n                            universeList[currentRow].replace(\'0\', normalCharacter + "" "").replace(\'1\',\n                                                                                                 susceptibleCharacter + "" "").\n                            replace(\'2\', infectedCharacter + "" "")))\n\n\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter,\n                            infectedCharacter):\n    """"""\n    Print the current generation.\n    :param currentTimeStep:\n    :param cellCountX:\n    :param cellCountY:\n    :param normalCharacter:\n    :param susceptibleCharacter:\n    :param infectedCharacter:\n    :return:\n    """"""\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', normalCharacter + "" "").replace(\'1\',\n                                                                                                          susceptibleCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "")))\n\n\n# This method calculates the new state of the cell based on Von Neumann HEX neighborhood\ndef getNewState2DHex(selfCharacter, hexNeighbours):\n    newState = \'0\'\n    newState = selfCharacter\n\n    if selfCharacter == \'0\':  # If Normal and there is an Infected close, be Susceptible\n        if hexNeighbours.count(\'2\') > 0:\n            newState = \'1\'\n    else:\n        if selfCharacter == \'1\':  # if Susceptible, calculate the probability to be Infected\n            # betaChance = (2 - np.random.normal(0.5, 1.0)) # NORMAL\n            # betaChance = (2 - np.random.uniform()) # UNIFORM\n            betaChance = (2 - (np.random.poisson(1) % 10) * 0.1)  # POISSON\n            if 0 < betaChance < beta:\n                newState = \'2\'\n            else:\n                newState = \'0\'\n        else:\n            if selfCharacter == \'2\':  # if Infected, calculate the probability to be Susceptible \'to recover\'\n                # gammaChance = (1 - np.random.normal(0.5, 1.0)) # NORMAL\n                # gammaChance = (1 - np.random.uniform()) # UNIFORM\n                gammaChance = (1 - (np.random.poisson(1) % 10) * 0.1)  # POISSON\n\n                if gammaChance < gamma and gammaChance > 0:\n                    newState = \'1\'\n\n    return newState\n\n\n# SIS Model Parameters\nbeta = 1.4247  # Chance to get S from neighbouring I\ngamma = 0.14286  # Chance to get from I to R (or normal in our case)\nsimulationIterations = 100\ncellCountX = 33\ncellCountY = 33\n\n# Init values\nsusceptibleCharacter = \'S\'\ninfectedCharacter = \'I\'\nnormalCharacter = \'_\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    universe = \'\'.join(random.choice(\'000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0]\n\nRES = [InitVariables]\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 4:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter,\n                                infectedCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n    RES.append([zeroCount, oneCount, twoCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    for currentRow in range(cellCountY):\n        oldUniverseList.append(universeList[currentRow])\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n\n            # HEX\n            hexNeighbours = list(""000000"")  # list of characters\n\n            # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n            if (currentRow - 1) >= 0:  # CELL 2\n                hexNeighbours[2] = oldUniverseList[currentRow - 1][currentColumn]\n            if (currentRow + 1) < cellCountY:  # CELL 3\n                hexNeighbours[3] = oldUniverseList[currentRow + 1][currentColumn]\n\n            if (currentColumn % 2 == 0):\n                if (currentColumn - 1) >= 0:  # CELL 1 EVEN\n                    hexNeighbours[1] = oldUniverseList[currentRow][currentColumn - 1]\n                    if (currentRow - 1) >= 0:  # CELL 0 EVEN\n                        hexNeighbours[0] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                if (currentColumn + 1) < cellCountX:  # CELL 5 EVEN\n                    hexNeighbours[5] = oldUniverseList[currentRow][currentColumn + 1]\n                    if (currentRow - 1) >= 0:  # CELL 4 EVEN\n                        hexNeighbours[4] = oldUniverseList[currentRow - 1][currentColumn + 1]\n            else:\n                # Make string of ODD neighbours - Check ranges\n                if (currentColumn - 1) >= 0:  # CELL 0 ODD\n                    hexNeighbours[0] = oldUniverseList[currentRow][currentColumn - 1]\n                    if (currentRow - 1) >= 0:  # CELL 1 ODD\n                        hexNeighbours[1] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                if (currentColumn + 1) < cellCountX:  # CELL 4 ODD\n                    hexNeighbours[4] = oldUniverseList[currentRow][currentColumn + 1]\n                    if (currentRow + 1) < cellCountY:  # CELL 5 ODD\n                        hexNeighbours[5] = oldUniverseList[currentRow + 1][currentColumn + 1]\n\n            # Get the new state by sending the currentCell value + string of all neighbours\n            hexNeighbours = """".join(hexNeighbours)  # join the characters into 1 string\n            newUniverseRow += getNewState2DHex(oldUniverseList[currentRow][currentColumn], hexNeighbours)\n            universeList[currentRow] = newUniverseRow\n\n# print RES\nRES = np.array(RES)\n\n# Ploting\npl.subplot(3, 1, 1)\npl.plot(RES[:, 3], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Infected and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 2)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(3, 1, 3)\npl.plot(RES[:, 3], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 3], RES[:, 2], \'-b\', label=\'Infected\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Infected\')\npl.xlabel(\'Susceptibles\')\npl.ylabel(\'Infected\')\n\npl.show()\n'"
TestModels/GameOfLife2DSIR.py,11,"b'"""""" A test 2D CA model for SIR without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\n\n\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter,\n                            infectedCharacter, recoveredCharacter):\n    """"""\n    Print the current generation.\n    :param currentTimeStep:\n    :param cellCountX:\n    :param cellCountY:\n    :param normalCharacter:\n    :param susceptibleCharacter:\n    :param infectedCharacter:\n    :param recoveredCharacter:\n    :return:\n    """"""\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', normalCharacter + "" "").replace(\'1\',\n                                                                                                          susceptibleCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\n\'\'\' This method calculates the new state of the cell based on Von Neumann neighborhood \'\'\'\n\n\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n    newState = \'0\'\n\n    leftCharacter = currentRowNeighbours[0]\n    selfCharacter = currentRowNeighbours[1]\n    rightCharacter = currentRowNeighbours[2]\n\n    upperLeftCharacter = upperRowNeighbours[0]\n    upperCenterCharacter = upperRowNeighbours[1]\n    upperRightCharacter = upperRowNeighbours[2]\n\n    lowerLeftCharacter = lowerRowNeighbours[0]\n    lowerCenterCharacter = lowerRowNeighbours[1]\n    lowerRightCharacter = lowerRowNeighbours[2]\n\n    newState = selfCharacter\n\n    if selfCharacter == \'0\':  # If Normal and there is an Infected close, be Susceptible\n        if leftCharacter == \'2\' or rightCharacter == \'2\' or \\\n                upperLeftCharacter == \'2\' or upperRightCharacter == \'2\' or upperCenterCharacter == \'2\' \\\n                or lowerLeftCharacter == \'2\' or lowerRightCharacter == \'2\' or lowerCenterCharacter == \'2\':\n            newState = \'1\'\n    elif selfCharacter == \'1\':  # if Susceptible, calculate the probability to be Infected\n        # betaChance = (2 - np.random.normal(0.5, 1.0)) # NORMAL\n        betaChance = (2 - np.random.uniform())  # UNIFORM\n        # betaChance = (2 - (np.random.poisson(2) % 10) * 0.1) # POISSON\n        if betaChance > 0 and betaChance < beta:\n            newState = \'2\'\n        else:\n            newState = \'0\'\n    elif selfCharacter == \'2\':  # if Infected, calculate the probability to be Recovered \'to recover\'\n        gammaChance = (1 - np.random.normal(0.5, 1.0))  # NORMAL\n        # gammaChance = (1 - np.random.uniform()) # UNIFORM\n        # gammaChance = (1 - (np.random.poisson(2) % 10) * 0.1) # POISSON\n\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'3\'\n    elif selfCharacter == \'3\':  # Recovered, immune for a while\n        rhoChance = (1 - np.random.normal(0.5, 1.0))  # NORMAL\n        # rhoChance = (1 - np.random.uniform()) # UNIFORM\n        # rhoChance = (1 - (np.random.poisson(2) % 10) * 0.1) # POISSON\n\n        if rhoChance < rho and rhoChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\n# SIS Model Parameters\nbeta = 1.2247  # Chance to get S from neighbouring I\ngamma = 0.015  # Chance to get from I to R (or normal in our case)\nrho = 0.0  # Chance ot get from R to normal (Loss of immunity rate)\nsimulationIterations = 300\ncellCountX = 10\ncellCountY = 10\n\n# Init values\nsusceptibleCharacter = \'S\'\nrecoveredCharacter = \'R\'\ninfectedCharacter = \'I\'\nnormalCharacter = \'_\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    universe = \'\'.join(random.choice(\'000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 4:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, normalCharacter, susceptibleCharacter,\n                                infectedCharacter, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n        threeCount += universeList[currentRow].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    for currentRow in range(cellCountY):\n        oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n            upperRowNeighbours = \'000\'\n            lowerRowNeighbours = \'000\'\n            currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn + 3]\n            if (currentRow - 1) >= 0:\n                upperRowNeighbours = oldUniverseList[currentRow - 1][currentColumn:currentColumn + 3]\n            if (currentRow + 1) < cellCountY:\n                lowerRowNeighbours = oldUniverseList[currentRow + 1][currentColumn:currentColumn + 3]\n\n            newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n            universeList[currentRow] = newUniverseRow\n\n# print RES\nRES = np.array(RES)\n\n# Ploting\npl.subplot(4, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Infected and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(4, 1, 2)\npl.plot(RES[:, 4], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(4, 1, 3)\npl.plot(RES[:, 4], RES[:, 1], \'-r\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 2], \'-b\', label=\'Infected\')\npl.legend(loc=0)\npl.title(\'Susceptibles and Infected\')\npl.xlabel(\'Susceptibles\')\npl.ylabel(\'Infected\')\n\npl.subplot(4, 1, 4)\npl.plot(RES[:, 4], RES[:, 3], \'-r\', label=\'Recovered\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Normal\')\npl.legend(loc=0)\npl.title(\'Recovered and Normal\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.show()\n'"
TestModels/__init__.py,0,"b""__author__ = 'madks_000'\n"""
Various/Distributions.py,10,"b'"""""" Distribution function checking script """"""\n\nimport matplotlib.pyplot as plt\nfrom noise import pnoise1\n\ns = []\n\n\n# sigmaChance = np.random.uniform() # UNIFORM\n# sigmaChance = np.random.normal(.5, .1) # NORMAL\n# sigmaChance = np.random.poisson(2) * .1 # POISSON\n# sigmaChance = (np.random.binomial(20, .5, 100) % 10) * 0.1 # BINOMIAL\n\n# UNIFORM\n# for i in range(1000):\n#    s.append(np.random.uniform())\n\n# POISSON\n# s = np.random.poisson(2, 10000) * 0.1\n\n# NORMAL\n# for i in range(10000):\n#    s = abs(np.random.normal(.5, .1, 1000)) # NORMAL\n\n# BINOMIAL\n# s = (np.random.binomial(20, .5, 100) % 10) * 0.1\n\n# MONTE CARLO METHOD\n# def monteCarlo():\n#     r1 = 0.0\n#     while(True):\n#         # Pick a random value.\n#         r1 = np.random.uniform()\n#         if np.random.uniform() < r1:\n#             return r1\n# for i in range(10000):\n#    s.append(monteCarlo())\n\n# PERLIN NOISE 1 to -1\ndef perlinNoiseNumber(maxTimeStep, timeStep, octaves=1, timeSpan=30):\n    base = 0.5\n    x = float(timeStep) * timeSpan / maxTimeStep - 0.5 * timeSpan\n    y = pnoise1(x + base, octaves)\n    return y\n\n\nmaxTimeStep = 10000  # Smoothness\nfor timeStep in range(maxTimeStep):\n    y = perlinNoiseNumber(maxTimeStep, timeStep)\n    s.append(y)\n\nprint(s)\n\n# Plot s in time series\nplt.plot(s)\nplt.ylabel(\'Time series\')\nplt.show()\n\n# Plot Histogram\ncount, bins, ignored = plt.hist(s, 14, density=True)\nplt.show()\n'"
Various/DrawHexagon.py,0,"b'"""""" A very plain script that prints a Hexagon in a 2D grid """"""\n\n# Import a library of functions called \'pygame\'\nimport pygame\n\n\ndef drawSquare(screen, currentColour, currentColumn, cellSize, currentRow):\n    pygame.draw.rect(screen, currentColour, [currentColumn * cellSize, currentRow * cellSize, (currentColumn + 1)\n                                             * cellSize, (currentRow + 1) * cellSize])\n\n\ndef drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow):\n    minX = currentColumn * cellSize\n    maxX = (currentColumn + 1) * cellSize\n    minY = currentRow * cellSize\n    maxY = (currentRow + 1) * cellSize\n    quarterLength = (maxY - minY) / 4\n\n    spacing = (2 * quarterLength)\n\n    if currentColumn > 1:\n        minX -= spacing * int(currentColumn / 2)\n        maxX -= spacing * int(currentColumn / 2)\n\n    if currentColumn % 2 == 1:\n        minX -= quarterLength\n        maxX -= quarterLength\n        minY += spacing\n        maxY += spacing\n\n    center = [minX + 2 * quarterLength, minY + 2 * quarterLength]\n    a = [minX + quarterLength, minY]\n    b = [minX + 3 * quarterLength, minY]\n    d = [maxX, minY + 2 * quarterLength]\n    e = [minX + 3 * quarterLength, maxY]\n    f = [minX + quarterLength, maxY]\n    g = [minX, minY + 2 * quarterLength]\n\n    pygame.draw.polygon(screen, currentColour, [center, a, b])\n    pygame.draw.polygon(screen, currentColour, [center, b, d])\n    pygame.draw.polygon(screen, currentColour, [center, d, e])\n    pygame.draw.polygon(screen, currentColour, [center, e, f])\n    pygame.draw.polygon(screen, currentColour, [center, f, g])\n    pygame.draw.polygon(screen, currentColour, [center, g, a])\n\n\ndef drawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries):\n    # Initialize the game engine\n    pygame.init()\n\n    # Define the colors we will use in RGB format\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    BLUE = (0, 0, 255)\n    GREEN = (0, 255, 0)\n    YELLOW = (255, 255, 0)\n    RED = (255, 0, 0)\n    ORANGE = (255, 165, 0)\n\n    # Set the height and width of the screen\n    screenHeight = 800\n    screenWidth = 800\n\n    cellSize = screenHeight / cellCountX\n    if hexagonLayout:\n        screenHeight *= 0.85\n        screenWidth *= 1.04\n\n    size = [int(screenHeight), int(screenWidth)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    # Loop until the user clicks the close button.\n    clock = pygame.time.Clock()\n\n    # while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60  # desired max. framerate in frames per second.\n    playtime = 0\n    cycletime = 0\n    interval = .15  # .15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    # for currentStep in range(simulationIterations):\n    currentTimeStep = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0  # seconds passed since last frame (float)\n        playtime += seconds\n        cycletime += seconds\n        if cycletime > interval:\n\n            if currentTimeStep >= simulationIterations:\n                currentTimeStep = 0\n            else:\n                currentTimeStep += 1\n            # pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % currentTimeStep)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycletime = 0\n\n            currentColour = BLACK\n            for currentRow in range(cellCountY):  # Draw a solid rectangle\n                for currentColumn in range(cellCountX):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if currentTimeStep > 0 and currentTimeStep < simulationIterations:\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'0\':\n                            currentColour = BLUE\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'1\':\n                            currentColour = YELLOW\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'2\':\n                            currentColour = RED\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'3\':\n                            currentColour = GREEN\n\n                        if hexagonLayout:\n                            drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow)\n                        else:\n                            drawSquare(screen, currentColour, currentColumn, cellSize, currentRow)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        # pygame.time.delay(1)\n        # time.sleep(3)\n\n\n\'\'\' Print the current generation \'\'\'\n\n\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter,\n                            infectedCharacter, recoveredCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', susceptibleCharacter + "" "").replace(\'1\',\n                                                                                                               exposedCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\nhexagonLayout = True\nsimulationIterations = 6\n# cellCountX = 5\n# cellCountY = 5\ncellCountX = 10\ncellCountY = 6\n\n# drawGenerationUniverse(cellCountX, cellCountY, [[\'00020\',\'00020\',\'00020\',\'00020\',\'00020\'],[\'00020\',\'00020\',\'00020\',\'00020\',\'00000\'],\n#                               [\'02020\',\'00020\',\'00020\',\'00020\',\'00000\'], [\'02020\',\'00020\',\'00000\',\'00020\',\'00000\']] )\n\ndrawGenerationUniverse(cellCountX, cellCountY,\n                       [[\'0000000000\', \'0000000000\', \'0002000000\', \'0000000000\', \'0000000000\', \'0000000000\'],\n                        [\'0000000000\', \'0000000000\', \'0002000000\', \'0000000000\', \'0000000000\', \'0000000000\'],\n                        [\'0000000000\', \'0000000000\', \'0000000000\', \'0000000000\', \'0000000000\', \'0000000000\'],\n                        [\'0000000000\', \'2000000000\', \'0200000000\', \'0000000000\', \'0000000000\', \'0000000000\'],\n                        [\'0000000000\', \'2000000000\', \'0200000000\', \'0000000000\', \'0000000000\', \'0000000000\'],\n                        [\'0000000000\', \'0000000000\', \'0200000000\', \'0000000000\', \'0000000000\', \'0000000000\']])\n'"
Various/__init__.py,0,"b""__author__ = 'madks_000'\n"""
WorkingModels/CoupledLattice.py,16,"b'####################################################################\n###    This is the PYTHON version of program 7.3 from page 256 of  #\n### ""Modeling Infectious Disease in humans and animals""            #\n### by Keeling & Rohani.\t\t\t\t\t\t\t\t\t\t   #\n###\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   #\n### It is the SIR epidemic on an nxn lattice with coupling (rho)   #\n### to 4 nearest neighbour. nI defines the number of lattice sites #\n### (chosen randomly) that start with some infection.              #\n####################################################################\n\n###################################\n### Written by Ilias Soumpasis    #\n### ilias.soumpasis@ucd.ie (work) #\n### ilias.soumpasis@gmail.com\t  #\n###################################\n\nimport scipy.integrate as spi\nimport numpy as np\nimport pylab as pl\nimport time\nimport cv2\nimport os\n\nimport matplotlib.cm as cm\n\n# Select if you want to make a video (faster way)\nvideo = 1\n# or just0in-time plotting\n# video = 0\nt = time.time()\n\nn = 25\nbeta = 1  # .42\ngamma = 0  # 0.14\nmu = 0.0001\nrho = 0.1\nX0 = 0.1\nnI = 4.\nN0 = 1.0\nnu = mu\ntimestep = 1.\nND = MaxTime = 500  # 2910\nC = np.arange(0.0, 1.0, 0.001)\nX = X0 * np.ones((n, n))\nY = np.zeros(n * n)\nind = np.ceil(n * n * np.random.uniform(size=int(nI))).astype(int)\n\nfor i in range(len(ind)):\n    Y[ind[i]] = 0.001 * X0\n\nINPUT1 = np.hstack((X0 * np.ones((n * n)), Y))\n\nY3 = Y\nY = np.reshape(Y, (n, n))\nY2 = Y\n\nINPUT3 = np.hstack((X, Y))\n\nINPUT2 = np.reshape(INPUT3, (2 * n * n, 1))\n\nfor i in range(len(INPUT1)):\n    INPUT1[i] = INPUT2[i]\n\nINPUT = INPUT1\nndem = np.zeros((n, n))\nSize = n\nN = N0\n# Note the size loop\nfor i in range(Size):\n    for j in range(Size):\n        ndem[i][j] = (1 - 4 * rho) * N\n        if i > 0: ndem[i][j] += rho * N\n        if i < (Size - 1): ndem[i][j] += rho * N\n        if j > 0: ndem[i][j] += rho * N\n        if j < (Size - 1): ndem[i][j] += rho * N\n\n\ndef diff_eqs(INP, t):\n    V = INP\n    Y = np.zeros(2 * n * n)\n\n    # internal dynamics\n    for j in range(Size):\n        for k in range(Size):\n            ss = j + k * Size * 2\n            ii = Size + j + k * Size * 2\n            Y[ss] = nu - beta * (1 - 4 * rho) * V[ss] * V[ii] / ndem[j][k] - mu * V[ss]\n            Y[ii] = beta * (1 - 4 * rho) * V[ss] * V[ii] / ndem[j][k] - (gamma + mu) * V[ii]\n\n            # Interactions with four neighbours Von Neumann neighborhood\n            if j > 0:\n                FoI = beta * V[ss] * rho * V[ii - 1] / ndem[j][k]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n            if j < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii + 1] / ndem[j][k]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n            if k > 0:\n                FoI = beta * V[ss] * rho * V[ii - Size * 2] / ndem[j][k]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n            if k < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii + Size * 2] / ndem[j][k]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n    return Y\n\n\nola = np.zeros((n * n), dtype=np.integer)\nfor i in range(Size):\n    for j in range(Size):\n        ola[i * n + j] = i * Size * 2 + j\n\nola1 = ola + n\ntcS = [(n * n * X0)]\ntcI = [sum(Y3[range(n * n)])]\ntc22 = np.zeros((n, n))\nif video == 1:\n    if os.path.exists(\'movie\'):\n        pass\n    else:\n        os.mkdir(\'movie\')\n\n    for k in range(ND):\n        t_range = np.arange(2.0)\n        RES = spi.odeint(diff_eqs, INPUT, t_range)\n        INPUT = RES[-1]\n\n        tcS.append(sum(RES[-1][ola]))\n        tcI.append(sum(RES[-1][ola1]))\n\n        if k % 1 == 0:\n            pl.clf()\n            tc22 = np.reshape(RES[-1][ola1], (n, n))\n            pl.subplot(211)\n            # pl.pcolor(tc22, cmap=pl.cm.spectral)\n            pl.pcolor(tc22, cmap=cm.get_cmap(""Spectral""))\n            pl.title(\'Coupled Lattice Model\')\n            pl.colorbar()\n\n            pl.subplot(413)\n            pl.plot(tcS, color=\'b\')\n            pl.ylabel(\'Susceptible\')\n            pl.subplot(414)\n            pl.plot(tcI, color=\'r\')\n            pl.ylabel(\'Infected\')\n            pl.xlabel(\'Time (days)\')\n            pl.savefig(""movie/frame_%04d.png"" % k)\n            ## watch the progress\n            print(k)\n\n    # You will mencoder from mplayer for this to work\n    # With windows you have to modify the path\n    # With linux if you have mencoder istall usually it should work\n    # Format is windows media player - plays on windows\n    # You could try other formats also\n    print(\'Please wait... Converting pictures to avis....\')\n    # Select different video speed\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=5:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_very_slow.avi\')\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=10:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_slow.avi\')\n    #     os.system(\'mencoder ""mf://movie/*.png"" -mf fps=25:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_fast.avi\')\n\n    image_folder = \'movie\'\n    video_name = \'video.avi\'\n\n    images = [img for img in os.listdir(image_folder) if img.endswith("".png"")]\n    frame = cv2.imread(os.path.join(image_folder, images[0]))\n    height, width, layers = frame.shape\n\n    frame_rate = 25\n    video = cv2.VideoWriter(video_name, 0, frame_rate, (width, height))\n\n    for image in images:\n        video.write(cv2.imread(os.path.join(image_folder, image)))\n\n    cv2.destroyAllWindows()\n    video.release()\n\n    print(\'Convertion completed. Hope it worked...\')\n    # Delete images to save work space\n    os.system(\'rm movie/*.png\')\n\n    print(""Operation took %g seconds"" % (time.time() - t))\n\nelse:\n    # You could also try plotting at each step but it is slow\n\n    pl.ion()\n    for k in range(ND):\n        t_range = np.arange(2.0)\n        RES = spi.odeint(diff_eqs, INPUT, t_range)\n        INPUT = RES[-1]\n\n        tcS.append(sum(RES[-1][ola]))\n        tcI.append(sum(RES[-1][ola1]))\n\n        # Changing the k%50 parameter you change the frames you are watching\n        #  With 1 you can see all the graphs\n        if k % 10 == 0:\n            pl.clf()\n            tc22 = np.reshape(RES[-1][ola1], (n, n))\n            pl.subplot(211)\n            # pl.pcolor(tc22, cmap=pl.cm.spectral)\n            pl.pcolor(tc22, cmap=cm.get_cmap(""Spectral""))\n            pl.title(\'Coupled Lattice Model\')\n            pl.colorbar()\n\n            pl.subplot(413)\n            pl.plot(tcS, color=\'b\')\n            pl.ylabel(\'Susceptible\')\n\n            pl.subplot(414)\n            pl.plot(tcI, color=\'r\')\n            pl.ylabel(\'Infected\')\n            pl.xlabel(\'Time (days)\')\n\n            # watch the progress\n            print(k)\n            pl.draw()\n    pl.ioff()\n    pl.show()\n'"
WorkingModels/CoupledLatticeMoore.py,18,"b'####################################################################\n###    This is the PYTHON version of program 7.3 from page 256 of  #\n### ""Modeling Infectious Disease in humans and animals""            #\n### by Keeling & Rohani.\t\t\t\t\t\t\t\t\t\t   #\n###\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   #\n### It is the SIR epidemic on an nxn lattice with coupling (rho)   #\n### to 8 nearest neighbour. nI defines the number of lattice sites #\n### (chosen randomly) that start with some infection.              #\n####################################################################\n\n###################################\n### Written by Ilias Soumpasis    #\n### ilias.soumpasis@ucd.ie (work) #\n### ilias.soumpasis@gmail.com\t  #\n###################################\n\nimport scipy.integrate as spi\nimport numpy as np\nimport pylab as pl\nimport time\nimport cv2\nimport os\nimport matplotlib.cm as cm\n\n### Select if you want to make a video (faster way) \nvideo = 1\n### or just0in-time plotting\n# video = 0\nt = time.time()\n\nn = 25\nbeta = .42\ngamma = .14\nmu = 0.0001\nrho = 0.1\nX0 = 0.1\nnI = 8.\nN0 = 1.0\nnu = mu\ntimestep = 1.\n# ND=MaxTime=2910 #changed\nND = MaxTime = 300  # changed\nC = np.arange(0.0, 1.0, 0.001)\nX = X0 * np.ones((n, n))\nY = np.zeros(n * n)\n# ind = np.ceil(n * n * np.random.uniform(size=nI))\nind = np.ceil(n * n * np.random.uniform(size=int(nI))).astype(int)\nfor i in range(len(ind)):\n    Y[ind[i]] = 0.001 * X0\n\nINPUT1 = np.hstack((X0 * np.ones((n * n)), Y))\n\nY3 = Y\nY = np.reshape(Y, (n, n))\nY2 = Y\n\nINPUT3 = np.hstack((X, Y))\n\nINPUT2 = np.reshape(INPUT3, (2 * n * n, 1))\n\nfor i in range(len(INPUT1)):\n    INPUT1[i] = INPUT2[i]\n\nINPUT = INPUT1\nndem = np.zeros((n, n))\nSize = n\nN = N0\n### Note the size loop\nfor i in range(Size):\n    for j in range(Size):\n        # ndem[i][j]=(1-4*rho)*N\n        ndem[i][j] = (1 - 8 * rho) * N\n\n        if i > 0: ndem[i][j] += rho * N\n        if i < (Size - 1): ndem[i][j] += rho * N\n        if j > 0: ndem[i][j] += rho * N\n        if j < (Size - 1): ndem[i][j] += rho * N\n\n        # Extra\n        if i > 0 and j > 0: ndem[i][j] += rho * N\n        if i < (Size - 1) and j < (Size - 1): ndem[i][j] += rho * N\n        if i > 0 and j < (Size - 1): ndem[i][j] += rho * N\n        if i < (Size - 1) and j > 0: ndem[i][j] += rho * N\n\n\ndef diff_eqs(INP, t):\n    V = INP\n    Y = np.zeros(2 * n * n)\n\n    # internal dynamics\n    for i in range(Size):\n        for j in range(Size):\n            ss = i + j * Size * 2\n            ii = Size + i + j * Size * 2\n            # Y[ss]=nu - beta*(1-4*rho)*V[ss]*V[ii]/ndem[i][j] - mu * V[ss]\n            # Y[ii]=beta*(1-4*rho)*V[ss]*V[ii]/ndem[i][j] - (gamma + mu) * V[ii]\n            Y[ss] = nu - beta * (1 - 8 * rho) * V[ss] * V[ii] / ndem[i][j] - mu * V[ss]\n            Y[ii] = beta * (1 - 8 * rho) * V[ss] * V[ii] / ndem[i][j] - (gamma + mu) * V[ii]\n\n            # Interactions with four neighbours - Moor neighborhood\n            if i > 0:\n                FoI = beta * V[ss] * rho * V[ii - 1] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if i < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii + 1] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if j > 0:\n                FoI = beta * V[ss] * rho * V[ii - Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if j < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii + Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n            # Extra\n            if i > 0 and j > 0:\n                FoI = beta * V[ss] * rho * V[ii - 1 - Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if i < (Size - 1) and j < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii + 1 + Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if i < (Size - 1) and j > 0:\n                FoI = beta * V[ss] * rho * V[ii + 1 - Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n            if i > 0 and j < (Size - 1):\n                FoI = beta * V[ss] * rho * V[ii - 1 + Size * 2] / ndem[i][j]\n                Y[ss] -= FoI\n                Y[ii] += FoI\n\n    return Y\n\n\nola = np.zeros((n * n), dtype=np.integer)\nfor i in range(Size):\n    for j in range(Size):\n        ola[i * n + j] = i * Size * 2 + j\n\nola1 = ola + n\ntcS = [(n * n * X0)]\ntcI = [sum(Y3[range(n * n)])]\ntc22 = np.zeros((n, n))\nif video == 1:\n    if os.path.exists(\'movie\') == True:\n        pass\n    else:\n        os.mkdir(\'movie\')\n\n    for k in range(ND):\n        t_range = np.arange(2.0)\n        RES = spi.odeint(diff_eqs, INPUT, t_range)\n        INPUT = RES[-1]\n\n        tcS.append(sum(RES[-1][ola]))\n        tcI.append(sum(RES[-1][ola1]))\n\n        if k % 1 == 0:\n            pl.clf()\n            tc22 = np.reshape(RES[-1][ola1], (n, n))\n            pl.subplot(211)\n            # pl.pcolor(tc22, cmap=pl.cm.spectral)\n            pl.pcolor(tc22, cmap=cm.get_cmap(""Spectral""))\n            pl.title(\'Coupled Lattice Model (Moore)\')\n            pl.colorbar()\n\n            pl.subplot(413)\n            pl.plot(tcS, color=\'b\')\n            pl.ylabel(\'Susceptible\')\n            pl.subplot(414)\n            pl.plot(tcI, color=\'r\')\n            pl.ylabel(\'Infected\')\n            pl.xlabel(\'Time (days)\')\n            pl.savefig(""movie/frame_%04d.png"" % k)\n            # watch the progress\n            print(k)\n\n    # You will mencoder from mplayer for this to work\n    # With windows you have to modify the path\n    # With linux if you have mencoder istall usually it should work\n    # Format is windows media player - plays on windows\n    # You could try other formats also\n    print(\'Please wait... Converting pictures to avis....\')\n    # Select different video speed\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=5:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_very_slow.avi\')\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=10:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_slow.avi\')\n    # os.system(\n    #     \'mencoder ""mf://movie/*.png"" -mf fps=25:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_fast.avi\')\n    # print(\'Convertion completed. Hope it worked...\')\n    # ## Delete images to save work space\n    # os.system(\'rm movie/*.png\')\n    #\n    # print(""Operation took %g seconds"" % (time.time() - t))\n    image_folder = \'movie\'\n    video_name = \'video.avi\'\n\n    images = [img for img in os.listdir(image_folder) if img.endswith("".png"")]\n    frame = cv2.imread(os.path.join(image_folder, images[0]))\n    height, width, layers = frame.shape\n\n    frame_rate = 25\n    video = cv2.VideoWriter(video_name, 0, frame_rate, (width, height))\n\n    for image in images:\n        video.write(cv2.imread(os.path.join(image_folder, image)))\n\n    cv2.destroyAllWindows()\n    video.release()\n\n    print(\'Conversion completed. Hope it worked...\')\n    # Delete images to save work space\n    os.system(\'rm movie/*.png\')\n\nelse:\n    ## You could also try plotting at each step but it is slow\n    pl.ion()\n    for k in range(ND):\n        t_range = np.arange(2.0)\n        RES = spi.odeint(diff_eqs, INPUT, t_range)\n        INPUT = RES[-1]\n\n        tcS.append(sum(RES[-1][ola]))\n        tcI.append(sum(RES[-1][ola1]))\n\n        if k % 100 == 0:\n            print(k)\n\n        # Changing the k%50 parameter you change the frames you are watching\n        #  With 1 you can see all the graphs\n        """"""\n        if k%10==0:\n            pl.clf()\n            tc22=np.reshape(RES[-1][ola1], (n,n))\n            pl.subplot(211)\n            pl.pcolor(tc22, cmap=pl.cm.spectral)\n            pl.title(\'Coupled Lattice Model\')\n            pl.colorbar()\n\n            pl.subplot(413)\n            pl.plot(tcS, color=\'b\')\n            pl.ylabel(\'Susceptible\')\n\n            pl.subplot(414)\n            pl.plot(tcI, color=\'r\')\n            pl.ylabel(\'Infected\')\n            pl.xlabel(\'Time (days)\')\n\n            ### watch the progress\n            print k\n            #pl.draw()\n            """"""\n\n    pl.clf()\n    tc22 = np.reshape(RES[-1][ola1], (n, n))\n    pl.subplot(211)\n    # pl.pcolor(tc22, cmap=pl.cm.spectral)\n    pl.pcolor(tc22, cmap=cm.get_cmap(""Spectral""))\n    pl.title(\'Coupled Lattice Model (Moore)\')\n    pl.colorbar()\n\n    pl.subplot(413)\n    pl.plot(tcS, color=\'b\')\n    pl.ylabel(\'Susceptible\')\n\n    pl.subplot(414)\n    pl.plot(tcI, color=\'r\')\n    pl.ylabel(\'Infected\')\n    pl.xlabel(\'Time (days)\')\n\n    # watch the progress\n    print(k)\n    # pl.draw()\n\n    pl.ioff()\n    pl.show()\n'"
WorkingModels/FlocksAgentModel.py,3,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (0, 0, 0)\n        WHITE = (255, 255, 255)\n        BLUE = (0, 0, 255)\n        GREEN = (0, 255, 0)\n        YELLOW = (255, 255, 0)\n        RED = (255, 0, 0)\n        ORANGE = (255, 165, 0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        # Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 18)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60  # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15  # .15 # how long one single images should be displayed in seconds\n        delayAmount = 5 # 500 # milliseconds\n        currentTimeStep = 0\n        mouseX = 0\n        mouseY = 0\n        mousePoint = PVector(0, 0)  # Point of mouse vector\n\n        moverObjectCount = 20  # 20\n        moverToMouseList = [MoverToMouse() for i in range(moverObjectCount)]\n        flockSize = 1  # 60\n        flockList = Flock(flockSize)\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0  # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n\n                for i in timeRange:\n                    event = pygame.event.poll()\n                    if event.type == pygame.QUIT:\n                        running = 0\n                    # elif event.type == pygame.MOUSEMOTION:\n                    #     mouseX, mouseY = event.pos\n                    elif event.type == pygame.MOUSEBUTTONDOWN:\n                        mouseX, mouseY = event.pos\n\n                    mousePoint = PVector(mouseX, mouseY)\n\n                    screen.fill(WHITE)  # Refresh screen\n\n                    flockList.run()\n                    # for currentWalker in moverToMouseList:\n                    #     mousePointDirection = PVector(mouseX, mouseY)\n                    #     mousePointDirection.subtract(currentWalker.Location)\n                    #     mousePointDirection.normalize()\n                    #     mousePointDirection.multiply(2.5)\n                    #\n                    #     tempMousePoint = PVector(mouseX, mouseY)\n                    #     tempMousePoint.subtract(currentWalker.Location)\n                    #\n                    #     currentWalker.walkVectorAcceleration(mousePointDirection)\n\n                    for currentBoid in flockList.Boids:\n                        # Draw point\n                        # screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                        # Draw triangle\n                        # triangleSide = 8 # pixels\n                        # a = [int(currentBoid.Location.X), int(currentBoid.Location.Y) - (triangleSide)]\n                        # b = [int(currentBoid.Location.X) + (triangleSide /2 ), int(currentBoid.Location.Y) + (triangleSide /2 )]\n                        # c = [int(currentBoid.Location.X) - (triangleSide /2 ), int(currentBoid.Location.Y) + (triangleSide /2 )]\n                        # pygame.draw.polygon(screen, BLUE, [a, b, c])\n                        # pygame.draw.polygon(screen, BLACK, [a, b, c], 1)\n                        # Draw circle\n                        circleRadius = 5\n                        circleThickness = 1\n                        pygame.draw.circle(screen, BLUE, (int(currentBoid.Location.X), int(currentBoid.Location.Y)),\n                                           circleRadius, 0)\n                        pygame.draw.circle(screen, BLACK, (int(currentBoid.Location.X), int(currentBoid.Location.Y)),\n                                           circleRadius, circleThickness)\n\n                        # label = myfont.render(""Flock Size: "" + str(len(flockList.Boids)), 1, RED)\n                        label = myfont.render(""Flock Size: "" + str(len(flockList.Boids)) + "" Target (click) x:{} y:{}"".format(mouseX, mouseY), 1, RED)\n                        screen.blit(label, (10, 5))  # Draw the text\n\n                        label = myfont.render(""X"".format(mouseX, mouseY), 1, RED)\n                        screen.blit(label, (mouseX, mouseY))  # Draw the text\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % flockList.T)\n\n                    pygame.time.wait(delayAmount)  # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n\n    def random2D(self):\n        self.X = random.random()\n        self.Y = random.random()\n\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n\n    def limit(self, max):\n        if self.magnitude() > max:\n            self.normalize()\n            self.multiply(max)\n\n    def setMangitude(self, inputMagnitude):\n        self.normalize()\n        self.multiply(inputMagnitude)\n\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n\n    def getDistance(self, otherLocation):\n        return np.sqrt((self.X - otherLocation.X) ** 2 + (self.Y - otherLocation.Y) ** 2)\n\n\nclass Boid:\n    def __init__(self, x, y):\n        self.Location = PVector(cellCountX / 2, cellCountY / 2)  # PVector(x, y)\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)  # PVector(0, 0)\n        self.Acceleration = PVector(-0.1, 1)  # PVector(-0.01, 0.1)#PVector(0, 0)\n        self.R = 4  # 1.0 # For size\n        self.MaxForce = 0.2\n        self.MaxSpeed = 2  # 0.1\n        self.NeighbourDistance = 1\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        self.invertEdges()\n        # self.wrapEdges()\n\n    def update(self):\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.MaxSpeed)\n        self.Location.add(self.Velocity)\n        self.Acceleration.multiply(0.0)\n\n    def flock(self, inputBoids):\n        separateVector = self.separate(inputBoids)\n        alignVector = self.align(inputBoids)\n        cohesionVector = self.cohesion(inputBoids)\n\n        separateVector.multiply(1.5)\n        alignVector.multiply(1)\n        cohesionVector.multiply(1)\n\n        self.applyForce(separateVector)\n        self.applyForce(alignVector)\n        self.applyForce(cohesionVector)\n        self.checkEdges()\n        self.update()\n\n    def align(self, inputBoids):\n        sum = PVector(0, 0)\n\n        for currentBoid in inputBoids:\n            sum.add(currentBoid.Velocity)\n\n        sum.divide(len(inputBoids))\n        sum.setMangitude(self.MaxSpeed)\n\n        steer = PVector(sum.X, sum.Y)\n        steer.subtract(self.Velocity)\n        steer.limit(self.MaxForce)\n\n        return steer\n\n    def separate(self, inputBoids):\n        desiredSeparation = self.R * 2\n        sum = PVector(0, 0)\n        count = 0\n        for currentBoid in inputBoids:\n            distance = self.Location.getDistance(currentBoid.Location)\n            if distance > 0 and distance < desiredSeparation:\n                diff = PVector(self.Location.X, self.Location.Y)\n                diff.subtract(currentBoid.Location)\n                diff.normalize()\n                diff.divide(distance)\n                sum.add(diff)\n                count += 1\n        if count > 0:\n            sum.divide(count)\n            sum.normalize()\n            sum.multiply(self.MaxSpeed)\n            steer = PVector(sum.X, sum.Y)\n            steer.subtract(self.Velocity)\n            steer.limit(self.MaxForce)\n            return steer\n        else:\n            return PVector(0, 0)\n\n    def cohesion(self, inputBoids):\n        sum = PVector(0, 0)\n        count = 0\n        for currentBoid in inputBoids:\n            distance = self.Location.getDistance(currentBoid.Location)\n            if (distance > 0 and distance < self.NeighbourDistance):\n                sum.add(currentBoid.Location)\n                count += 1\n\n        if count > 0:\n            sum.divide(count)\n            return self.seek(sum)\n        else:\n            return PVector(0, 0)\n\n    def seek(self, targetVector):\n        desired = targetVector\n        desired.subtract(self.Location)\n        desired.normalize()\n        desired.multiply(self.MaxSpeed)\n\n        steer = desired\n        desired.subtract(self.Velocity)\n        return desired\n\n    def applyForce(self, inputForce):\n        self.Acceleration.add(inputForce)\n\n\nclass Flock:\n    def __init__(self, inputBoidCount):\n        self.BoidCount = inputBoidCount\n        self.Boids = [Boid(10, 10) for i in range(self.BoidCount)]\n        self.T = 0\n\n    def run(self):\n        self.T += 1\n        for currentBoid in self.Boids:\n            currentBoid.flock(self.Boids)\n\n\nclass MoverToMouse:\n    def __init__(self):\n        self.Location = PVector(random.randint(0, cellCountX), random.randint(0, cellCountY))\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)\n        self.Acceleration = PVector(-0.01, 0.1)\n        self.TopSpeed = 20  # 20\n        self.T = 0\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        # self.invertEdges()\n        self.wrapEdges()\n\n    def walkVectorAcceleration(self, acceleration):\n        self.T += 1\n\n        self.Acceleration = acceleration\n        self.checkEdges()\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVector(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Acceleration.random2D()\n        accelerationFactor = random.uniform(-5, 5)\n        self.Acceleration.multiply(accelerationFactor)\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkAcceleratingVector(self):\n        self.T += 1\n\n        self.checkEdges()\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVectorNormalize(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 800\ncellCountY = 600\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()\n'"
WorkingModels/ForestFireCA.py,15,"b'####################################################################\n###    This is the PYTHON version of program 7.4 from page 260 of  #\n### ""Modeling Infectious Disease in humans and animals""            #\n### by Keeling & Rohani.\t\t\t\t\t\t\t\t\t\t   #\n###\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   #\n### It is the forest-fire model on a grid of size NxN.             #\n### A zero time-step means that asynchronous updating is used.     #\n####################################################################\n\n###################################\n### Written by Ilias Soumpasis    #\n### ilias.soumpasis@ucd.ie (work) #\n### ilias.soumpasis@gmail.com\t  #\n###################################\n\nimport scipy.integrate as spi\nimport numpy as np\nimport pylab as pl\nimport time, os\n\n### Select if you want to make a video (faster way) \n# video=1\n### or just0in-time plotting\nvideo = 0\nt = time.time()\n\nN = 25\ntau = 1.0\ngamma = 0  # 0.1\nnu = 0.01\nepsilon = 1e-4\ntimestep = 0.5\nND = MaxTime = 1000\n\nGrid = 2 * np.ones((N, N), dtype=np.integer)\nGrid[int(np.ceil((N - 1) * np.random.uniform(size=1))[0]), int(np.ceil((N - 1) * np.random.uniform(size=1))[0])] = 3\nt = 0\ni = 1\nT = []\nX = []\nY = []\n\n\ndef diff_eqs(INP, t):\n    INF = np.zeros((N, N))\n    SUS = np.zeros((N, N))\n    EMP = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            if INP[i][j] == 1: EMP[i][j] = 1\n            if INP[i][j] == 2: SUS[i][j] = 1\n            if INP[i][j] == 3: INF[i][j] = 1\n\n    Infecteds = INF\n    Susceptibles = SUS\n    X.append(sum(sum(Susceptibles)))\n    Y.append(sum(sum(Infecteds)))  # T[i]=t\n\n    Inf_Nbrs = Infecteds[:, np.hstack((np.arange(1, N), 0))] + \\\n               Infecteds[np.hstack((np.arange(1, N), 0)), :] + \\\n               Infecteds[:, np.hstack((49, np.arange(49)))] + \\\n               Infecteds[np.hstack((49, np.arange(49))), :]\n\n    if (timestep == 0):  # asynchronous updating\n        Rates = nu * EMP + gamma * Infecteds + tau * Susceptibles * (Inf_Nbrs + epsilon)\n        vectorRates = np.reshape(Rates, N * N)\n        Total_Rates = sum(vectorRates)\n        Cum_Rates = np.cumsum(vectorRates)\n        step = -np.log(np.random.uniform(size=(N, N))) / Total_Rates\n        R = rand(1, 1) * Total_Rates\n        Event = min(pl.find(R < Cum_Rates))\n        S[Event] = np.mod(S[Event], 3) + 1\n    else:\n        Rates = nu * EMP + gamma * Infecteds + tau * Susceptibles * (Inf_Nbrs + epsilon)\n        R = timestep * Rates - np.random.uniform(size=(N, N))\n        S = np.mod(Grid - 1 + np.ceil(R), 3) + 1\n        step = timestep\n\n    return S, X, Y, timestep\n\n\nif video == 1:\n    if os.path.exists(\'movie\') == True:\n        pass\n    else:\n        os.mkdir(\'movie\')\n    k = 0\n    while t <= ND:\n        [Grid, X, Y, timestep] = diff_eqs(Grid, timestep)\n        t += timestep\n        T.append(t)\n        k += 1\n\n        pl.clf()\n        pl.subplot(211)\n        pl.pcolor(Grid, cmap=pl.cm.jet)\n        pl.title(\'Forest-Fire Model\')\n\n        pl.subplot(413)\n        pl.plot(T, X, color=\'g\')\n        pl.ylabel(\'Susceptible\')\n        pl.subplot(414)\n        pl.plot(T, Y, color=\'r\')\n        pl.ylabel(\'Infected\')\n        pl.xlabel(\'Time (days)\')\n        pl.savefig(""movie/frame_%04d.png"" % k)\n        print(k)\n\n    ## You will mencoder from mplayer for this to work\n    ## With windows you have to modify the path\n    ## With linux if you have mencoder istall usually it should work\n    ## Format is windows media player - plays on windows\n    ## You could try other formats also\n    print(\'Please wait... Converting pictures to avis....\')\n    ## Select different video speed\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=5:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_very_slow.avi\')\n    #    os.system(\'mencoder ""mf://movie/*.png"" -mf fps=10:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_slow.avi\')\n    os.system(\n        \'mencoder ""mf://movie/*.png"" -mf fps=25:type=png -ovc lavc -lavcopts vcodec=wmv1 -of avi -o movie/movie_fast.avi\')\n    print(\'Convertion completed. Hope it worked...\')\n    ## Delete images to save work space\n    os.system(\'rm movie/*.png\')\n\n    print(""Operation took %g seconds"" % (time.time() - t))\n\nelse:\n    ### You could also try plotting at each step but it is slow\n    k = 0\n    pl.ion()\n    while t <= ND:\n        [Grid, X, Y, timestep] = diff_eqs(Grid, timestep)\n        t += timestep\n        T.append(t)\n        k += 1\n\n        pl.clf()\n        pl.subplot(211)\n        pl.pcolor(Grid, cmap=pl.cm.jet)\n        pl.title(\'Forest-Fire Model\')\n\n        pl.subplot(413)\n        pl.plot(T, X, color=\'g\')\n        pl.ylabel(\'Susceptible\')\n\n        pl.subplot(414)\n        pl.plot(T, Y, color=\'r\')\n        pl.ylabel(\'Infected\')\n        pl.xlabel(\'Time (days)\')\n        print(k)\n        pl.draw()\n    pl.ioff()\n    pl.show()\n'"
WorkingModels/GameOfLife2DSEIRSImage.py,6,"b'"""""" A 2D CA model for SEIRS without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\nfrom operator import itemgetter\n# Import a library of functions called \'pygame\'\nimport pygame\n\n\ndef drawSquare(screen, currentColour, currentColumn, cellSize, currentRow):\n    pygame.draw.rect(screen, currentColour, [currentColumn * cellSize, currentRow * cellSize, (currentColumn + 1)\n                                             * cellSize, (currentRow + 1) * cellSize])\n\n\ndef getRandomNumber(distribution):\n    if distribution == 0:\n        returningRandomNumber = np.random.uniform()  # UNIFORM\n    elif distribution == 1:\n        returningRandomNumber = np.random.normal(.5, .1)  # NORMAL\n    elif distribution == 2:\n        returningRandomNumber = (np.random.binomial(20, .5, 100) % 10) * 0.1  # BINOMIAL\n    elif distribution == 3:\n        returningRandomNumber = np.random.poisson(2) * .1  # POISSON\n    return returningRandomNumber\n\n\ndef drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow):\n    minX = currentColumn * cellSize\n    maxX = (currentColumn + 1) * cellSize\n    minY = currentRow * cellSize\n    maxY = (currentRow + 1) * cellSize\n    quarterLength = (maxY - minY) / 4\n\n    spacing = (2 * quarterLength)\n\n    if currentColumn > 1:\n        minX -= spacing * int(currentColumn / 2)\n        maxX -= spacing * int(currentColumn / 2)\n\n    if currentColumn % 2 == 1:\n        minX -= quarterLength\n        maxX -= quarterLength\n        minY += spacing\n        maxY += spacing\n\n    center = [minX + 2 * quarterLength, minY + 2 * quarterLength]\n    a = [minX + quarterLength, minY]\n    b = [minX + 3 * quarterLength, minY]\n    d = [maxX, minY + 2 * quarterLength]\n    e = [minX + 3 * quarterLength, maxY]\n    f = [minX + quarterLength, maxY]\n    g = [minX, minY + 2 * quarterLength]\n\n    pygame.draw.polygon(screen, currentColour, [center, a, b])\n    pygame.draw.polygon(screen, currentColour, [center, b, d])\n    pygame.draw.polygon(screen, currentColour, [center, d, e])\n    pygame.draw.polygon(screen, currentColour, [center, e, f])\n    pygame.draw.polygon(screen, currentColour, [center, f, g])\n    pygame.draw.polygon(screen, currentColour, [center, g, a])\n\n\ndef drawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries):\n    # Initialize the game engine\n    pygame.init()\n\n    # Define the colors we will use in RGB format\n    BLACK = (0, 0, 0)\n    WHITE = (255, 255, 255)\n    BLUE = (0, 0, 255)\n    GREEN = (0, 255, 0)\n    YELLOW = (255, 255, 0)\n    RED = (255, 0, 0)\n    ORANGE = (255, 165, 0)\n\n    # Set the height and width of the screen\n    screenHeight = 400\n    screenWidth = 400\n\n    cellSize = screenHeight / cellCountX\n    if hexagonLayout:\n        screenHeight *= 0.85\n        screenWidth *= 1.04\n\n    size = [int(screenHeight), int(screenWidth)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    # Loop until the user clicks the close button.\n    clock = pygame.time.Clock()\n\n    # while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60  # desired max. framerate in frames per second.\n    playtime = 0\n    cycletime = 0\n    interval = .15  # .15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    # for currentStep in range(simulationIterations):\n    currentTimeStep = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0  # seconds passed since last frame (float)\n        playtime += seconds\n        cycletime += seconds\n        if cycletime > interval:\n\n            if currentTimeStep >= simulationIterations:\n                currentTimeStep = 0\n            else:\n                currentTimeStep += 1\n            # pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % currentTimeStep)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycletime = 0\n\n            currentColour = BLACK\n            for currentRow in range(cellCountY):  # Draw a solid rectangle\n                for currentColumn in range(cellCountX):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if currentTimeStep > 0 and currentTimeStep < simulationIterations:\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'0\':\n                            currentColour = BLUE\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'1\':\n                            currentColour = YELLOW\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'2\':\n                            currentColour = RED\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'3\':\n                            currentColour = GREEN\n\n                        if hexagonLayout:\n                            drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow)\n                        else:\n                            drawSquare(screen, currentColour, currentColumn, cellSize, currentRow)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        # pygame.time.delay(1)\n        # time.sleep(3)\n\n\n\'\'\' Print the current generation \'\'\'\n\n\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter,\n                            infectedCharacter, recoveredCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', susceptibleCharacter + "" "").replace(\'1\',\n                                                                                                               exposedCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\n\'\'\' This method calculates the new state of the cell based on Moore HEX neighborhood \'\'\'\n\n\ndef getNewState2DHex(selfCharacter, hexNeighbours):\n    newState = selfCharacter\n\n    # getRandomNumber: 0 is UNIFORM, 1 is NORMAL, 2 is BINOMIAL, 3 is POISSON\n    if selfCharacter == \'0\':  # If S and there is an Infected close, be Exposed\n        if (hexNeighbours.count(\'2\') > 0):\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'1\'\n    elif selfCharacter == \'1\':  # if Exposed, calculate the probability to be Infected\n        sigmaChance = getRandomNumber(0)\n        if sigmaChance > 0 and sigmaChance < sigma:\n            newState = \'2\'\n        else:\n            if (hexNeighbours.count(\'2\') > 0):\n                newState = \'1\'\n            else:\n                newState = \'0\'\n    elif selfCharacter == \'2\':  # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'3\'\n    elif selfCharacter == \'3\':  # Recovered, immune for a while\n        alphaChance = getRandomNumber(0)\n        if alphaChance < alpha and alphaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\n\'\'\' This method calculates the new state of the cell based on Moore neighborhood \'\'\'\n\n\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n    selfCharacter = currentRowNeighbours[1]\n    newState = selfCharacter\n\n    # beta = .9 # Chance to get E from S\n    # sigma = .5 # Chance to get I from E\n    # gamma = .2 # Chance to get from I to R\n    # alpha = 0 # Chance to get from R to S (Loss of immunity rate)\n\n    if selfCharacter == \'0\':  # If S and there is an Infected close, be Exposed\n        if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\n                \'2\') > 0:\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'1\'\n    elif selfCharacter == \'1\':  # if Exposed, calculate the probability to be Infected\n        sigmaChance = getRandomNumber(0)\n        if sigmaChance > 0 and sigmaChance < sigma:\n            newState = \'2\'\n        else:\n            if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\n                    \'2\') > 0:\n                newState = \'1\'\n            else:\n                newState = \'0\'\n    elif selfCharacter == \'2\':  # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'3\'\n    elif selfCharacter == \'3\':  # Recovered, immune for a while\n        alphaChance = getRandomNumber(0)\n        if alphaChance < alpha and alphaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\n# TODO: Add Seed parameter\n# TODO: Add popoulation density\n# TODO: Non linearity coefficient?\n# TODO: Add ""Expected Numerical Results"" graph versus ""Spatial Results""\n\n# SEIR Model Parameters\n\n# Salmonela rates:\n# E->I: 0.33\n# S->E: 0.18\n# E->I: 0.01\n\n# Salmonela Cerro - Dairy herd http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2870801/\n# S->E: 0.9\n# Birt and Death: 0.03\n# Indirect Transmission: 10^-12\n# I->R: 0.14\n# R->S: 0.22\n# Environment pathogen removal: 10^9\n# Pathogen addition to environment due to animal shedding: 0.99\n\n# Rates - Units are 1/time in days\n\nbeta = .4 # .4247  # Transmission Rate: S -> E (or S->I) # TODO: Only different parameter vs the numerical model, others are the same\nsigma = .9  # Incubation Rate: E -> I (or epsilon)\ngamma = .1486  # .2 # Recovery Rate: I -> R\nalpha = .22  # Immunity Loss Rate: I -> S\nmu = 0  # TODO: Mortality Rate\nmuStart = 0  # TODO: Birth Rate\ndelta = 0  # TODO: Infectious Mortality Rate\n\nsimulationIterations = 70\ncellCountX = 50\ncellCountY = 50\nhexagonLayout = False\n\n# Init values\nsusceptibleCharacter = \'S\'\nexposedCharacter = \'E\'\nrecoveredCharacter = \'R\'\ninfectedCharacter = \'I\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    # if currentColumn == (cellCountY / 2):\n    #     universe = \'\'.join(\'0\' for universeColumn in range((cellCountX / 2) - 1))\n    #     universe += \'2\'\n    #     universe += \'\'.join(\'0\' for universeColumn in range(cellCountX / 2))\n    # else:\n    universe = \'\'.join(random.choice(\'00000000000000000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\nuniverseTimeSeries = []\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 0:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter,\n                                infectedCharacter, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n        threeCount += universeList[currentRow].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    toCopyUniverseList = []\n    for currentRow in range(cellCountY):\n        if hexagonLayout:\n            oldUniverseList.append(universeList[currentRow])\n        else:\n            oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n        toCopyUniverseList.append(universeList[currentRow])\n\n    universeTimeSeries.append(toCopyUniverseList)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n\n            if hexagonLayout:\n                # HEX\n                hexNeighbours = list(""000000"")  # list of characters\n\n                # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n                if (currentRow - 1) >= 0:  # CELL 2\n                    hexNeighbours[2] = oldUniverseList[currentRow - 1][currentColumn]\n                if (currentRow + 1) < cellCountY:  # CELL 3\n                    hexNeighbours[3] = oldUniverseList[currentRow + 1][currentColumn]\n\n                if (currentColumn % 2 == 0):\n                    if (currentColumn - 1) >= 0:  # CELL 1 EVEN\n                        hexNeighbours[1] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0:  # CELL 0 EVEN\n                            hexNeighbours[0] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX:  # CELL 5 EVEN\n                        hexNeighbours[5] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow - 1) >= 0:  # CELL 4 EVEN\n                            hexNeighbours[4] = oldUniverseList[currentRow - 1][currentColumn + 1]\n                else:\n                    # Make string of ODD neighbours - Check ranges\n                    if (currentColumn - 1) >= 0:  # CELL 0 ODD\n                        hexNeighbours[0] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0:  # CELL 1 ODD\n                            hexNeighbours[1] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX:  # CELL 4 ODD\n                        hexNeighbours[4] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow + 1) < cellCountY:  # CELL 5 ODD\n                            hexNeighbours[5] = oldUniverseList[currentRow + 1][currentColumn + 1]\n\n                # Get the new state by sending the currentCell value + string of all neighbours\n                hexNeighbours = """".join(hexNeighbours)  # join the characters into 1 string\n                newUniverseRow += getNewState2DHex(oldUniverseList[currentRow][currentColumn], hexNeighbours)\n                universeList[currentRow] = newUniverseRow\n            else:\n                # SQUARE\n                upperRowNeighbours = \'000\'\n                lowerRowNeighbours = \'000\'\n                currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn + 3]\n                if (currentRow - 1) >= 0:\n                    upperRowNeighbours = oldUniverseList[currentRow - 1][currentColumn:currentColumn + 3]\n                if (currentRow + 1) < cellCountY:\n                    lowerRowNeighbours = oldUniverseList[currentRow + 1][currentColumn:currentColumn + 3]\n\n                newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n                universeList[currentRow] = newUniverseRow\n\n                # TODO: Square neighbours to list of characters\n                # squareNeighbours = list(""00000000"") # list of characters\n\n# print RES\nRES = np.array(RES)\n# print(universeTimeSeries)\n\n# Ploting\npl.subplot(2, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 1], \'-y\', label=\'Exposed\')\npl.plot(RES[:, 4], RES[:, 3], \'-g\', label=\'Recovered\')\npl.legend(loc=0)\npl.title(\'All vs Time\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(2, 1, 2)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'Infected and Susceptibles\')\npl.xlabel(\'Infected\')\npl.ylabel(\'Susceptibles\')\n\npl.show()\n\ndrawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries)\n'"
WorkingModels/GameOfLife2DSIRImage.py,6,"b'"""""" A 2D CA model for SIR without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\nimport pygame\n\n\ndef get_random_number(distribution):\n\n    returning_random_number = 0.0\n    if distribution == 0:\n        returning_random_number = np.random.uniform()  # UNIFORM\n    elif distribution == 1:\n        returning_random_number = np.random.normal(.5, .1)  # NORMAL\n    elif distribution == 2:\n        returning_random_number = (np.random.binomial(20, .5, 100) % 10) * 0.1  # BINOMIAL\n    elif distribution == 3:\n        returning_random_number = np.random.poisson(2) * .1  # POISSON\n    return returning_random_number\n\n\ndef draw_square(screen, current_colour, current_column, cell_size, current_row):\n    pygame.draw.rect(screen, current_colour, [current_column * cell_size, current_row * cell_size, (current_column + 1)\n                                              * cell_size, (current_row + 1) * cell_size])\n\n\ndef draw_hexagon(screen, current_colour, current_column, cell_size, current_row):\n\n    min_x = current_column * cell_size\n    max_x = (current_column + 1) * cell_size\n    min_y = current_row * cell_size\n    max_y = (current_row + 1) * cell_size\n    quarter_length = (max_y - min_y) / 4\n\n    spacing =  (2 * quarter_length)\n\n    if current_column > 1:\n        min_x -= spacing * int(current_column / 2)\n        max_x -= spacing * int(current_column / 2)\n\n    if current_column % 2 == 1:\n        min_x -= quarter_length\n        max_x -= quarter_length\n        min_y += spacing\n        max_y += spacing\n\n    center = [min_x + 2 * quarter_length, min_y + 2 * quarter_length]\n    a = [min_x + quarter_length, min_y]\n    b = [min_x + 3 * quarter_length, min_y]\n    d = [max_x, min_y + 2 * quarter_length]\n    e = [min_x + 3 * quarter_length, max_y]\n    f = [min_x + quarter_length, max_y]\n    g = [min_x, min_y + 2 * quarter_length]\n\n    pygame.draw.polygon(screen, current_colour, [center, a, b])\n    pygame.draw.polygon(screen, current_colour, [center, b, d])\n    pygame.draw.polygon(screen, current_colour, [center, d, e])\n    pygame.draw.polygon(screen, current_colour, [center, e, f])\n    pygame.draw.polygon(screen, current_colour, [center, f, g])\n    pygame.draw.polygon(screen, current_colour, [center, g, a])\n\n\ndef draw_generation_universe(cell_count_x, cell_count_y, universe_time_series):\n\n    pygame.init()  # Initialize the game engine\n\n    # Define the colors we will use in RGB format\n    BLACK = (0,   0,   0)\n    WHITE = (255, 255, 255)\n    BLUE = (0,   0, 255)\n    GREEN = (0, 255,   0)\n    YELLOW = (255,   255,   0)\n    RED = (255,   0,   0)\n    ORANGE = (255,   165,   0)\n\n    # Set the height and width of the screen\n    screen_height = 800\n    screen_width = 800\n\n    cell_size = screen_height / cell_count_x\n    if hexagon_layout:\n        screen_height *= 0.85\n        screen_width *= 1.04\n\n    size = [int(screen_height), int(screen_width)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    clock = pygame.time.Clock()  # Loop until the user clicks the close button.\n\n    #while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60  # desired max. framerate in frames per second.\n    playtime = 0\n    cycle_time = 0\n    interval = .15  #.15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    #for currentStep in range(simulationIterations):\n    current_time_step = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n        playtime += seconds\n        cycle_time += seconds\n        if cycle_time > interval:\n\n            if current_time_step >= simulation_iterations:\n                current_time_step = 0\n            else:\n                current_time_step += 1\n            #pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % current_time_step)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycle_time = 0\n\n            current_colour = BLACK\n            for current_row in range(cell_count_y):  # Draw a solid rectangle\n                for current_column in range (cell_count_x):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if 0 < current_time_step < simulation_iterations:\n                        if universe_time_series[current_time_step][current_row][current_column] == \'0\':\n                            current_colour = BLUE\n                        if universe_time_series[current_time_step][current_row][current_column] == \'1\':\n                            current_colour = YELLOW\n                        if universe_time_series[current_time_step][current_row][current_column] == \'2\':\n                            current_colour = RED\n                        if universe_time_series[current_time_step][current_row][current_column] == \'3\':\n                            current_colour = GREEN\n\n                        if hexagon_layout:\n                            draw_hexagon(screen, current_colour, current_column, cell_size, current_row)\n                        else:\n                            draw_square(screen, current_colour, current_column, cell_size, current_row)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        #pygame.time.delay(1)\n        #time.sleep(3)\n\n\ndef printGenerationUniverse(current_time_step, cell_count_x, cell_count_y, susceptible_character, exposed_character, infected_character, recoveredCharacter):\n    """"""\n    Print the current generation.\n    :param current_time_step:\n    :param cell_count_x:\n    :param cell_count_y:\n    :param susceptible_character:\n    :param exposed_character:\n    :param infected_character:\n    :param recoveredCharacter:\n    :return:\n    """"""\n\n    print(""TimeStep %3i:  "" % current_time_step)\n    row_label = ""  ""\n    for l in range(cell_count_x):\n        row_label += str(l) + "" ""\n    print(row_label)\n    for current_row in range(cell_count_y):\n        print(""%s %s"" % (current_row, universeList[current_row].replace(\'0\', susceptible_character + "" "").replace(\'1\', exposedCharacter + "" "").\n                         replace(\'2\', infected_character + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\ndef get_new_state2DHex(self_character, hex_neighbors):\n    """"""\n    This method calculates the new state of the cell based on Moore HEX neighborhood.\n    :param self_character:\n    :param hex_neighbors:\n    :return:\n    """"""\n\n    new_state = self_character\n\n    if self_character == \'0\': # If S and there is an Infected close, be Infected\n        if hex_neighbors.count(\'2\') > 0:\n            beta_chance = get_random_number(0)\n            if beta > beta_chance > 0:\n                new_state = \'2\'\n    elif self_character == \'2\':  # if Infected, calculate the probability to be Recovered\n        gamma_chance = get_random_number(0)\n        if gamma > gamma_chance > 0:\n            new_state = \'3\'\n\n    return new_state\n\n\ndef get_new_state2D(current_row_neighbors, upper_row_neighbors, lower_row_neighbors):\n    """"""\n    This method calculates the new state of the cell based on Moore neighborhood.\n    :param current_row_neighbors:\n    :param upper_row_neighbors:\n    :param lower_row_neighbors:\n    :return:\n    """"""\n\n    self_character = current_row_neighbors[1]\n    new_state = self_character\n\n    if self_character == \'0\': # If S and there is an Infected close, be Infected\n        if current_row_neighbors.count(\'2\') > 0 or upper_row_neighbors.count(\'2\') > 0 or lower_row_neighbors.count(\'2\') > 0:\n            beta_chance = get_random_number(0)\n            if beta > beta_chance > 0:\n                new_state = \'2\'\n    elif self_character == \'2\': # if Infected, calculate the probability to be Recovered\n        gamma_chance = get_random_number(0)\n\n        if gamma > gamma_chance > 0:\n            new_state = \'3\'\n\n    return new_state\n\n# TODO: Add Seed parameter\n# TODO: Add population density\n# TODO: Non linearity coefficient?\n# TODO: Add ""Expected Numerical Results"" graph versus ""Spatial Results""\n\n# SEIR Model Parameters\n\n# Salmonela rates:\n# E->I: 0.33\n# S->E: 0.18\n# E->I: 0.01\n\n# Salmonela Cerro - Dairy herd http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2870801/\n# S->E: 0.9\n# Birt and Death: 0.03\n# Indirect Transmission: 10^-12\n# I->R: 0.14\n# R->S: 0.22\n# Environment pathogen removal: 10^9\n# Pathogen addition to environment due to animal shedding: 0.99\n\n# Rates - Units are 1/time in days\nbeta = .4247  # Transmission Rate: S -> E (or S->I) # TODO: Only different parameter vs the numerical model, others are the same\n#sigma = .9 # Incubation Rate: E -> I (or epsilon)\ngamma =.14286  #.2 # Recovery Rate: I -> R\n#alpha = .22  # Immunity Loss Rate: I -> S\nmu = 0  # TODO: Mortality Rate\nmuStart = 0  # TODO: Birth Rate\ndelta = 0  # TODO: Infectious Mortality Rate\n\nsimulation_iterations = 70\ncell_count_x = 100\ncell_count_y = 100\nhexagon_layout = False\n\n# Init values\nsusceptible_character = \'S\'\nexposedCharacter = \'E\'\nrecoveredCharacter = \'R\'\ninfected_character = \'I\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulation_iterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cell_count_y):\n    # if currentColumn == (cell_count_y / 2):\n        # universe = \'\'.join(\'0\' for universeColumn in range((cell_count_x / 2) - 1))\n        # universe += \'2\'\n        # universe += \'\'.join(\'0\' for universeColumn in range(cell_count_x / 2))\n    # else:\n    #     universe = \'\'.join(random.choice(\'0\') for universeColumn in range(cell_count_x))\n    universe = \'\'.join(random.choice(\'000000000000000000000000000000000000000000000000000000000002\') for universeColumn in range(cell_count_x))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\nuniverseTimeSeries = []\n\n# Main Execution loop\nfor current_time_step in range(simulation_iterations):\n\n    # Print the current generation\n    if current_time_step < 0:\n        printGenerationUniverse(current_time_step, cell_count_x, cell_count_y, susceptible_character, exposedCharacter, infected_character, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for current_row in range(cell_count_y):\n        zeroCount += universeList[current_row].count(\'0\')\n        oneCount += universeList[current_row].count(\'1\')\n        twoCount += universeList[current_row].count(\'2\')\n        threeCount += universeList[current_row].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, current_time_step])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    toCopyUniverseList = []\n    for current_row in range(cell_count_y):\n        if hexagon_layout:\n            oldUniverseList.append(universeList[current_row])\n        else:\n            oldUniverseList.append(extremeEndValue + universeList[current_row] + extremeEndValue)\n        toCopyUniverseList.append(universeList[current_row])\n\n    universeTimeSeries.append(toCopyUniverseList)\n\n    for current_row in range(cell_count_y):\n        newUniverseRow = \'\'\n        for currentColumn in range(cell_count_x):\n\n            if hexagon_layout:\n                # HEX\n                hex_neighbours = list(""000000"") # list of characters\n\n                # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n                if (current_row - 1) >= 0: # CELL 2\n                    hex_neighbours[2] = oldUniverseList[current_row - 1][currentColumn]\n                if (current_row + 1) < cell_count_y: # CELL 3\n                    hex_neighbours[3] = oldUniverseList[current_row + 1][currentColumn]\n\n                if (currentColumn % 2 == 0):\n                    if (currentColumn - 1) >= 0: # CELL 1 EVEN\n                        hex_neighbours[1] = oldUniverseList[current_row][currentColumn - 1]\n                        if (current_row - 1) >= 0: # CELL 0 EVEN\n                            hex_neighbours[0] = oldUniverseList[current_row - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cell_count_x: # CELL 5 EVEN\n                        hex_neighbours[5] = oldUniverseList[current_row][currentColumn + 1]\n                        if (current_row - 1) >= 0: # CELL 4 EVEN\n                            hex_neighbours[4] = oldUniverseList[current_row - 1][currentColumn + 1]\n                else:\n                    # Make string of ODD neighbours - Check ranges\n                    if (currentColumn - 1) >= 0: # CELL 0 ODD\n                        hex_neighbours[0] = oldUniverseList[current_row][currentColumn - 1]\n                        if (current_row - 1) >= 0: # CELL 1 ODD\n                            hex_neighbours[1] = oldUniverseList[current_row - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cell_count_x: # CELL 4 ODD\n                        hex_neighbours[4] = oldUniverseList[current_row][currentColumn + 1]\n                        if (current_row + 1) < cell_count_y: # CELL 5 ODD\n                            hex_neighbours[5] = oldUniverseList[current_row + 1][currentColumn + 1]\n\n                # Get the new state by sending the currentCell value + string of all neighbours\n                hex_neighbours = """".join(hex_neighbours) # join the characters into 1 string\n                newUniverseRow += get_new_state2DHex(oldUniverseList[current_row][currentColumn], hex_neighbours)\n                universeList[current_row] = newUniverseRow\n            else:\n                # SQUARE\n                upper_row_neighbours = \'000\'\n                lower_row_neighbours = \'000\'\n                current_row_neighbours = oldUniverseList[current_row][currentColumn:currentColumn+3]\n                if (current_row - 1) >= 0:\n                    upper_row_neighbours = oldUniverseList[current_row-1][currentColumn:currentColumn+3]\n                if (current_row + 1) < cell_count_y:\n                    lower_row_neighbours = oldUniverseList[current_row+1][currentColumn:currentColumn+3]\n\n                newUniverseRow += get_new_state2D(current_row_neighbours, upper_row_neighbours, lower_row_neighbours)\n                universeList[current_row] = newUniverseRow\n\n                # TODO: Square neighbours to list of characters\n                #squareNeighbours = list(""00000000"") # list of characters\n\n# print RES\n# print(universeTimeSeries)\nRES = np.array(RES)\n\n# Ploting\npl.subplot(1, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 3], \'-g\', label=\'Recovered\')\npl.legend(loc=0)\npl.title(\'CA SIR\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\n""""""\npl.subplot(2, 1, 2)\npl.plot(map(itemgetter(4), RES), map(itemgetter(2), RES), \'-r\', label=\'Infected\')\npl.plot(map(itemgetter(4), RES), map(itemgetter(0), RES), \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'Infected and Susceptibles\')\npl.xlabel(\'Infected\')\npl.ylabel(\'Susceptibles\')\n""""""\npl.show()\n\ndraw_generation_universe(cell_count_x, cell_count_y, universeTimeSeries)\n'"
WorkingModels/GameOfLife2DSIRSImage.py,6,"b'"""""" A 2D CA model for SIR without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\nfrom operator import itemgetter\n# Import a library of functions called \'pygame\'\nimport pygame\n\ndef getRandomNumber(distribution):\n    if distribution == 0:\n        returningRandomNumber = np.random.uniform() # UNIFORM\n    elif distribution == 1:\n        returningRandomNumber = np.random.normal(.5, .1) # NORMAL\n    elif distribution == 2:\n        returningRandomNumber = (np.random.binomial(20, .5, 100) % 10) * 0.1 # BINOMIAL\n    elif distribution == 3:\n        returningRandomNumber = np.random.poisson(2) * .1 # POISSON\n    return returningRandomNumber\n\ndef drawSquare(screen, currentColour, currentColumn, cellSize, currentRow):\n    pygame.draw.rect(screen, currentColour, [currentColumn * cellSize, currentRow * cellSize, (currentColumn + 1)\n                                             * cellSize, (currentRow + 1) * cellSize])\n\ndef drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow):\n    minX = currentColumn * cellSize\n    maxX =(currentColumn + 1)* cellSize\n    minY = currentRow * cellSize\n    maxY = (currentRow + 1) * cellSize\n    quarterLength = (maxY - minY) / 4\n\n    spacing =  (2 * quarterLength)\n\n    if currentColumn > 1:\n        minX -= spacing * int(currentColumn / 2)\n        maxX -= spacing * int(currentColumn / 2)\n\n    if currentColumn % 2 == 1:\n        minX -= quarterLength\n        maxX -= quarterLength\n        minY += spacing\n        maxY += spacing\n\n    center = [minX + 2 * quarterLength, minY + 2 * quarterLength]\n    a = [minX + quarterLength, minY]\n    b = [minX + 3 * quarterLength, minY]\n    d = [maxX, minY + 2 * quarterLength]\n    e = [minX + 3 * quarterLength, maxY]\n    f = [minX + quarterLength, maxY]\n    g = [minX, minY + 2 * quarterLength]\n\n    pygame.draw.polygon(screen, currentColour, [center, a, b])\n    pygame.draw.polygon(screen, currentColour, [center, b, d])\n    pygame.draw.polygon(screen, currentColour, [center, d, e])\n    pygame.draw.polygon(screen, currentColour, [center, e, f])\n    pygame.draw.polygon(screen, currentColour, [center, f, g])\n    pygame.draw.polygon(screen, currentColour, [center, g, a])\n\ndef drawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries):\n    # Initialize the game engine\n    pygame.init()\n\n    # Define the colors we will use in RGB format\n    BLACK = (  0,   0,   0)\n    WHITE = (255, 255, 255)\n    BLUE =  (  0,   0, 255)\n    GREEN = (  0, 255,   0)\n    YELLOW =   (255,   255,   0)\n    RED =   (255,   0,   0)\n    ORANGE =   (255,   165,   0)\n\n    # Set the height and width of the screen\n    screenHeight = 800\n    screenWidth = 800\n\n    cellSize = screenHeight / cellCountX\n    if hexagonLayout:\n        screenHeight *= 0.85\n        screenWidth *= 1.04\n\n    size = [int(screenHeight), int(screenWidth)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    #Loop until the user clicks the close button.\n    clock = pygame.time.Clock()\n\n    #while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60                           # desired max. framerate in frames per second.\n    playtime = 0\n    cycletime = 0\n    interval = .15#.15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    #for currentStep in range(simulationIterations):\n    currentTimeStep = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n        playtime += seconds\n        cycletime += seconds\n        if cycletime > interval:\n\n            if currentTimeStep >= simulationIterations:\n                currentTimeStep = 0\n            else:\n                currentTimeStep += 1\n            #pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % currentTimeStep)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycletime = 0\n\n            currentColour = BLACK\n            for currentRow in range(cellCountY):# Draw a solid rectangle\n                for currentColumn in range (cellCountX):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if currentTimeStep > 0 and currentTimeStep < simulationIterations:\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'0\':\n                            currentColour = BLUE\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'1\':\n                            currentColour = YELLOW\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'2\':\n                            currentColour = RED\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'3\':\n                            currentColour = GREEN\n\n                        if hexagonLayout:\n                            drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow)\n                        else:\n                            drawSquare(screen, currentColour, currentColumn, cellSize, currentRow)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        #pygame.time.delay(1)\n        #time.sleep(3)\n\n\'\'\' Print the current generation \'\'\'\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', susceptibleCharacter + "" "").replace(\'1\', exposedCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\'\'\' This method calculates the new state of the cell based on Moore HEX neighborhood \'\'\'\ndef getNewState2DHex(selfCharacter, hexNeighbours):\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Infected\n        if (hexNeighbours.count(\'2\') > 0):\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'2\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'3\'\n    elif selfCharacter == \'3\': # Recovered, immune for a while\n        alphaChance = getRandomNumber(0)\n        if alphaChance < alpha and alphaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\'\'\' This method calculates the new state of the cell based on Moore neighborhood \'\'\'\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n\n    selfCharacter = currentRowNeighbours[1]\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Infected\n        if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\'2\') > 0:\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'2\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'3\'\n    elif selfCharacter == \'3\': # Recovered, immune for a while\n        alphaChance = getRandomNumber(0)\n        if alphaChance < alpha and alphaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n# TODO: Add Seed parameter\n# TODO: Add popoulation density\n# TODO: Non linearity coefficient?\n# TODO: Add ""Expected Numerical Results"" graph versus ""Spatial Results""\n\n# SEIR Model Parameters\n\n# Salmonela rates:\n# E->I: 0.33\n# S->E: 0.18\n# E->I: 0.01\n\n# Salmonela Cerro - Dairy herd http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2870801/\n# S->E: 0.9\n# Birt and Death: 0.03\n# Indirect Transmission: 10^-12\n# I->R: 0.14\n# R->S: 0.22\n# Environment pathogen removal: 10^9\n# Pathogen addition to environment due to animal shedding: 0.99\n\n# Rates - Units are 1/time in days\n\nbeta = 1#.4247 # Transmission Rate: S -> E (or S->I) # TODO: Only different parameter vs the numerical model, others are the same\nsigma = .9 # Incubation Rate: E -> I (or epsilon)\ngamma = .1486 #.2 # Recovery Rate: I -> R\nalpha = .22 # Immunity Loss Rate: I -> S\nmu = 0 # TODO: Mortality Rate\nmuStart = 0 # TODO: Birth Rate\ndelta = 0 # TODO: Infectious Mortality Rate\n\nsimulationIterations = 70\ncellCountX = 25\ncellCountY = 25\nhexagonLayout = False\n\n# Init values\nsusceptibleCharacter = \'S\'\nexposedCharacter = \'E\'\nrecoveredCharacter = \'R\'\ninfectedCharacter = \'I\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    # if currentColumn == (cellCountY / 2):\n    #     universe = \'\'.join(\'0\' for universeColumn in range((cellCountX / 2) - 1))\n    #     universe += \'2\'\n    #     universe += \'\'.join(\'0\' for universeColumn in range(cellCountX / 2))\n    # else:\n    universe = \'\'.join(random.choice(\'0000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\nuniverseTimeSeries = []\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 0:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n        threeCount += universeList[currentRow].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    toCopyUniverseList = []\n    for currentRow in range(cellCountY):\n        if hexagonLayout:\n            oldUniverseList.append(universeList[currentRow])\n        else:\n            oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n        toCopyUniverseList.append(universeList[currentRow])\n\n    universeTimeSeries.append(toCopyUniverseList)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n\n            if hexagonLayout:\n                # HEX\n                hexNeighbours = list(""000000"") # list of characters\n\n                # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n                if (currentRow - 1) >= 0: # CELL 2\n                    hexNeighbours[2] = oldUniverseList[currentRow - 1][currentColumn]\n                if (currentRow + 1) < cellCountY: # CELL 3\n                    hexNeighbours[3] = oldUniverseList[currentRow + 1][currentColumn]\n\n                if (currentColumn % 2 == 0):\n                    if (currentColumn - 1) >= 0: # CELL 1 EVEN\n                        hexNeighbours[1] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 0 EVEN\n                            hexNeighbours[0] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 5 EVEN\n                        hexNeighbours[5] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow - 1) >= 0: # CELL 4 EVEN\n                            hexNeighbours[4] = oldUniverseList[currentRow - 1][currentColumn + 1]\n                else:\n                    # Make string of ODD neighbours - Check ranges\n                    if (currentColumn - 1) >= 0: # CELL 0 ODD\n                        hexNeighbours[0] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 1 ODD\n                            hexNeighbours[1] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 4 ODD\n                        hexNeighbours[4] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow + 1) < cellCountY: # CELL 5 ODD\n                            hexNeighbours[5] = oldUniverseList[currentRow + 1][currentColumn + 1]\n\n                # Get the new state by sending the currentCell value + string of all neighbours\n                hexNeighbours = """".join(hexNeighbours) # join the characters into 1 string\n                newUniverseRow += getNewState2DHex(oldUniverseList[currentRow][currentColumn], hexNeighbours)\n                universeList[currentRow] = newUniverseRow\n            else:\n                # SQUARE\n                upperRowNeighbours = \'000\'\n                lowerRowNeighbours = \'000\'\n                currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn+3]\n                if (currentRow - 1) >= 0:\n                    upperRowNeighbours = oldUniverseList[currentRow-1][currentColumn:currentColumn+3]\n                if (currentRow + 1) < cellCountY:\n                    lowerRowNeighbours = oldUniverseList[currentRow+1][currentColumn:currentColumn+3]\n\n                newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n                universeList[currentRow] = newUniverseRow\n\n                # TODO: Square neighbours to list of characters\n                #squareNeighbours = list(""00000000"") # list of characters\n\n#print RES\n\nRES = np.array(RES)\n#print(universeTimeSeries)\n\n#Ploting\npl.subplot(2, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 3], \'-g\', label=\'Recovered\')\npl.legend(loc=0)\npl.title(\'All vs Time\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(2, 1, 2)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'Infected and Susceptibles\')\npl.xlabel(\'Infected\')\npl.ylabel(\'Susceptibles\')\n\npl.show()\n\ndrawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries)\n'"
WorkingModels/GameOfLife2DSISImage.py,6,"b'"""""" A 2D CA model for SIS without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\nfrom operator import itemgetter\n# Import a library of functions called \'pygame\'\nimport pygame\n\ndef drawSquare(screen, currentColour, currentColumn, cellSize, currentRow):\n    pygame.draw.rect(screen, currentColour, [currentColumn * cellSize, currentRow * cellSize, (currentColumn + 1)\n                                             * cellSize, (currentRow + 1) * cellSize])\n\ndef getRandomNumber(distribution):\n    if distribution == 0:\n        returningRandomNumber = np.random.uniform() # UNIFORM\n    elif distribution == 1:\n        returningRandomNumber = np.random.normal(.5, .1) # NORMAL\n    elif distribution == 2:\n        returningRandomNumber = (np.random.binomial(20, .5, 100) % 10) * 0.1 # BINOMIAL\n    elif distribution == 3:\n        returningRandomNumber = np.random.poisson(2) * .1 # POISSON\n    return returningRandomNumber\n\ndef drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow):\n    minX = currentColumn * cellSize\n    maxX =(currentColumn + 1)* cellSize\n    minY = currentRow * cellSize\n    maxY = (currentRow + 1) * cellSize\n    quarterLength = (maxY - minY) / 4\n\n    spacing =  (2 * quarterLength)\n\n    if currentColumn > 1:\n        minX -= spacing * int(currentColumn / 2)\n        maxX -= spacing * int(currentColumn / 2)\n\n    if currentColumn % 2 == 1:\n        minX -= quarterLength\n        maxX -= quarterLength\n        minY += spacing\n        maxY += spacing\n\n    center = [minX + 2 * quarterLength, minY + 2 * quarterLength]\n    a = [minX + quarterLength, minY]\n    b = [minX + 3 * quarterLength, minY]\n    d = [maxX, minY + 2 * quarterLength]\n    e = [minX + 3 * quarterLength, maxY]\n    f = [minX + quarterLength, maxY]\n    g = [minX, minY + 2 * quarterLength]\n\n    pygame.draw.polygon(screen, currentColour, [center, a, b])\n    pygame.draw.polygon(screen, currentColour, [center, b, d])\n    pygame.draw.polygon(screen, currentColour, [center, d, e])\n    pygame.draw.polygon(screen, currentColour, [center, e, f])\n    pygame.draw.polygon(screen, currentColour, [center, f, g])\n    pygame.draw.polygon(screen, currentColour, [center, g, a])\n\ndef drawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries):\n    # Initialize the game engine\n    pygame.init()\n\n    # Define the colors we will use in RGB format\n    BLACK = (  0,   0,   0)\n    WHITE = (255, 255, 255)\n    BLUE =  (  0,   0, 255)\n    GREEN = (  0, 255,   0)\n    YELLOW =   (255,   255,   0)\n    RED =   (255,   0,   0)\n    ORANGE =   (255,   165,   0)\n\n    # Set the height and width of the screen\n    screenHeight = 800\n    screenWidth = 800\n\n    cellSize = screenHeight / cellCountX\n    if hexagonLayout:\n        screenHeight *= 0.85\n        screenWidth *= 1.04\n\n    size = [int(screenHeight), int(screenWidth)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    #Loop until the user clicks the close button.\n    clock = pygame.time.Clock()\n\n    #while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60                           # desired max. framerate in frames per second.\n    playtime = 0\n    cycletime = 0\n    interval = .15#.15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    #for currentStep in range(simulationIterations):\n    currentTimeStep = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n        playtime += seconds\n        cycletime += seconds\n        if cycletime > interval:\n\n            if currentTimeStep >= simulationIterations:\n                currentTimeStep = 0\n            else:\n                currentTimeStep += 1\n            #pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % currentTimeStep)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycletime = 0\n\n            currentColour = BLACK\n            for currentRow in range(cellCountY):# Draw a solid rectangle\n                for currentColumn in range (cellCountX):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if currentTimeStep > 0 and currentTimeStep < simulationIterations:\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'0\':\n                            currentColour = BLUE\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'1\':\n                            currentColour = YELLOW\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'2\':\n                            currentColour = RED\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'3\':\n                            currentColour = GREEN\n\n                        if hexagonLayout:\n                            drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow)\n                        else:\n                            drawSquare(screen, currentColour, currentColumn, cellSize, currentRow)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        #pygame.time.delay(1)\n        #time.sleep(3)\n\n\'\'\' Print the current generation \'\'\'\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', susceptibleCharacter + "" "").replace(\'1\', exposedCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\'\'\' This method calculates the new state of the cell based on Moore HEX neighborhood \'\'\'\ndef getNewState2DHex(selfCharacter, hexNeighbours):\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Infected\n        if (hexNeighbours.count(\'2\') > 0):\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'2\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\'\'\' This method calculates the new state of the cell based on Moore neighborhood \'\'\'\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n\n    selfCharacter = currentRowNeighbours[1]\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Infected\n        if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\'2\') > 0:\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'2\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n# TODO: Add Seed parameter\n# TODO: Add popoulation density\n# TODO: Non linearity coefficient?\n# TODO: Add ""Expected Numerical Results"" graph versus ""Spatial Results""\n\n# SEIR Model Parameters\n\n# Salmonela rates:\n# E->I: 0.33\n# S->E: 0.18\n# E->I: 0.01\n\n# Salmonela Cerro - Dairy herd http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2870801/\n# S->E: 0.9\n# Birt and Death: 0.03\n# Indirect Transmission: 10^-12\n# I->R: 0.14\n# R->S: 0.22\n# Environment pathogen removal: 10^9\n# Pathogen addition to environment due to animal shedding: 0.99\n\n# Rates - Units are 1/time in days\n\nbeta = .4247 # Transmission Rate: S -> E (or S->I) # TODO: Only different parameter vs the numerical model, others are the same\n#sigma = .9 # Incubation Rate: E -> I (or epsilon)\ngamma = .14286 #.2 # Recovery Rate: I -> R\n#alpha = .22 # Immunity Loss Rate: I -> S\nmu = 0 # TODO: Mortality Rate\nmuStart = 0 # TODO: Birth Rate\ndelta = 0 # TODO: Infectious Mortality Rate\n\nsimulationIterations = 70\ncellCountX = 150\ncellCountY = 150\nhexagonLayout = False\n\n# Init values\nsusceptibleCharacter = \'S\'\nexposedCharacter = \'E\'\nrecoveredCharacter = \'R\'\ninfectedCharacter = \'I\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    # if currentColumn == (cellCountY / 2):\n    #     universe = \'\'.join(\'0\' for universeColumn in range((cellCountX / 2) - 1))\n    #     universe += \'2\'\n    #     universe += \'\'.join(\'0\' for universeColumn in range(cellCountX / 2))\n    # else:\n    universe = \'\'.join(random.choice(\'0000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\nuniverseTimeSeries = []\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 0:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n        threeCount += universeList[currentRow].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    toCopyUniverseList = []\n    for currentRow in range(cellCountY):\n        if hexagonLayout:\n            oldUniverseList.append(universeList[currentRow])\n        else:\n            oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n        toCopyUniverseList.append(universeList[currentRow])\n\n    universeTimeSeries.append(toCopyUniverseList)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n\n            if hexagonLayout:\n                # HEX\n                hexNeighbours = list(""000000"") # list of characters\n\n                # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n                if (currentRow - 1) >= 0: # CELL 2\n                    hexNeighbours[2] = oldUniverseList[currentRow - 1][currentColumn]\n                if (currentRow + 1) < cellCountY: # CELL 3\n                    hexNeighbours[3] = oldUniverseList[currentRow + 1][currentColumn]\n\n                if (currentColumn % 2 == 0):\n                    if (currentColumn - 1) >= 0: # CELL 1 EVEN\n                        hexNeighbours[1] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 0 EVEN\n                            hexNeighbours[0] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 5 EVEN\n                        hexNeighbours[5] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow - 1) >= 0: # CELL 4 EVEN\n                            hexNeighbours[4] = oldUniverseList[currentRow - 1][currentColumn + 1]\n                else:\n                    # Make string of ODD neighbours - Check ranges\n                    if (currentColumn - 1) >= 0: # CELL 0 ODD\n                        hexNeighbours[0] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 1 ODD\n                            hexNeighbours[1] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 4 ODD\n                        hexNeighbours[4] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow + 1) < cellCountY: # CELL 5 ODD\n                            hexNeighbours[5] = oldUniverseList[currentRow + 1][currentColumn + 1]\n\n                # Get the new state by sending the currentCell value + string of all neighbours\n                hexNeighbours = """".join(hexNeighbours) # join the characters into 1 string\n                newUniverseRow += getNewState2DHex(oldUniverseList[currentRow][currentColumn], hexNeighbours)\n                universeList[currentRow] = newUniverseRow\n            else:\n                # SQUARE\n                upperRowNeighbours = \'000\'\n                lowerRowNeighbours = \'000\'\n                currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn+3]\n                if (currentRow - 1) >= 0:\n                    upperRowNeighbours = oldUniverseList[currentRow-1][currentColumn:currentColumn+3]\n                if (currentRow + 1) < cellCountY:\n                    lowerRowNeighbours = oldUniverseList[currentRow+1][currentColumn:currentColumn+3]\n\n                newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n                universeList[currentRow] = newUniverseRow\n\n                # TODO: Square neighbours to list of characters\n                #squareNeighbours = list(""00000000"") # list of characters\n\n#print RES\n\n#print(universeTimeSeries)\nRES = np.array(RES)\n\n#Ploting\npl.subplot(2, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'All vs Time\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(2, 1, 2)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'Infected and Susceptibles\')\npl.xlabel(\'Infected\')\npl.ylabel(\'Susceptibles\')\n\npl.show()\n\ndrawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries)\n'"
WorkingModels/GameOfLifeSEISImage.py,6,"b'"""""" A 2D CA model for SEIRS without mortality or birth """"""\n\nimport random\nimport numpy as np\nimport pylab as pl\nfrom operator import itemgetter\n# Import a library of functions called \'pygame\'\nimport pygame\n\ndef getRandomNumber(distribution):\n    if distribution == 0:\n        returningRandomNumber = np.random.uniform() # UNIFORM\n    elif distribution == 1:\n        returningRandomNumber = np.random.normal(.5, .1) # NORMAL\n    elif distribution == 2:\n        returningRandomNumber = (np.random.binomial(20, .5, 100) % 10) * 0.1 # BINOMIAL\n    elif distribution == 3:\n        returningRandomNumber = np.random.poisson(2) * .1 # POISSON\n    return returningRandomNumber\n\ndef drawSquare(screen, currentColour, currentColumn, cellSize, currentRow):\n    pygame.draw.rect(screen, currentColour, [currentColumn * cellSize, currentRow * cellSize, (currentColumn + 1)\n                                             * cellSize, (currentRow + 1) * cellSize])\n\ndef drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow):\n    minX = currentColumn * cellSize\n    maxX =(currentColumn + 1)* cellSize\n    minY = currentRow * cellSize\n    maxY = (currentRow + 1) * cellSize\n    quarterLength = (maxY - minY) / 4\n\n    spacing =  (2 * quarterLength)\n\n    if currentColumn > 1:\n        minX -= spacing * int(currentColumn / 2)\n        maxX -= spacing * int(currentColumn / 2)\n\n    if currentColumn % 2 == 1:\n        minX -= quarterLength\n        maxX -= quarterLength\n        minY += spacing\n        maxY += spacing\n\n    center = [minX + 2 * quarterLength, minY + 2 * quarterLength]\n    a = [minX + quarterLength, minY]\n    b = [minX + 3 * quarterLength, minY]\n    d = [maxX, minY + 2 * quarterLength]\n    e = [minX + 3 * quarterLength, maxY]\n    f = [minX + quarterLength, maxY]\n    g = [minX, minY + 2 * quarterLength]\n\n    pygame.draw.polygon(screen, currentColour, [center, a, b])\n    pygame.draw.polygon(screen, currentColour, [center, b, d])\n    pygame.draw.polygon(screen, currentColour, [center, d, e])\n    pygame.draw.polygon(screen, currentColour, [center, e, f])\n    pygame.draw.polygon(screen, currentColour, [center, f, g])\n    pygame.draw.polygon(screen, currentColour, [center, g, a])\n\ndef drawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries):\n    # Initialize the game engine\n    pygame.init()\n\n    # Define the colors we will use in RGB format\n    BLACK = (  0,   0,   0)\n    WHITE = (255, 255, 255)\n    BLUE =  (  0,   0, 255)\n    GREEN = (  0, 255,   0)\n    YELLOW =   (255,   255,   0)\n    RED =   (255,   0,   0)\n    ORANGE =   (255,   165,   0)\n\n    # Set the height and width of the screen\n    screenHeight = 800\n    screenWidth = 800\n\n    cellSize = screenHeight / cellCountX\n    if hexagonLayout:\n        screenHeight *= 0.85\n        screenWidth *= 1.04\n\n    size = [int(screenHeight), int(screenWidth)]\n    screen = pygame.display.set_mode(size)\n    screen.fill(WHITE)\n\n    #Loop until the user clicks the close button.\n    clock = pygame.time.Clock()\n\n    #while 1:\n    # Make sure game doesn\'t run at more than 60 frames per second\n    mainloop = True\n    FPS = 60                           # desired max. framerate in frames per second.\n    playtime = 0\n    cycletime = 0\n    interval = .15#.15 # how long one single images should be displayed in seconds\n    picnr = 0\n\n    #for currentStep in range(simulationIterations):\n    currentTimeStep = 0\n\n    while mainloop:\n        milliseconds = clock.tick(FPS)  # milliseconds passed since last frame\n        seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n        playtime += seconds\n        cycletime += seconds\n        if cycletime > interval:\n\n            if currentTimeStep >= simulationIterations:\n                currentTimeStep = 0\n            else:\n                currentTimeStep += 1\n            #pygame.time.delay(3000)\n            pygame.display.set_caption(""TimeStep %3i:  "" % currentTimeStep)\n\n            picnr += 1\n            if picnr > 5:\n                picnr = 0\n            cycletime = 0\n\n            currentColour = BLACK\n            for currentRow in range(cellCountY):# Draw a solid rectangle\n                for currentColumn in range (cellCountX):\n                    # rect(Surface, color, Rect, width=0) -> Rect\n                    if currentTimeStep > 0 and currentTimeStep < simulationIterations:\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'0\':\n                            currentColour = BLUE\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'1\':\n                            currentColour = YELLOW\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'2\':\n                            currentColour = RED\n                        if universeTimeSeries[currentTimeStep][currentRow][currentColumn] == \'3\':\n                            currentColour = GREEN\n\n                        if hexagonLayout:\n                            drawHexagon(screen, currentColour, currentColumn, cellSize, currentRow)\n                        else:\n                            drawSquare(screen, currentColour, currentColumn, cellSize, currentRow)\n\n        # This MUST happen after all the other drawing commands.\n        # Go ahead and update the screen with what we\'ve drawn.\n        pygame.display.flip()\n        #pygame.time.delay(1)\n        #time.sleep(3)\n\n\'\'\' Print the current generation \'\'\'\ndef printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter):\n    print(""TimeStep %3i:  "" % currentTimeStep)\n    rowLabel = ""  ""\n    for l in range(cellCountX):\n        rowLabel += str(l) + "" ""\n    print(rowLabel)\n    for currentRow in range(cellCountY):\n        print(""%s %s"" % (currentRow, universeList[currentRow].replace(\'0\', susceptibleCharacter + "" "").replace(\'1\', exposedCharacter + "" "").\n                         replace(\'2\', infectedCharacter + "" "").replace(\'3\', recoveredCharacter + "" "")))\n\n\'\'\' This method calculates the new state of the cell based on Moore HEX neighborhood \'\'\'\ndef getNewState2DHex(selfCharacter, hexNeighbours):\n    newState = selfCharacter\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Exposed\n        if (hexNeighbours.count(\'2\') > 0):\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'1\'\n    elif selfCharacter == \'1\': # if Exposed, calculate the probability to be Infected\n        sigmaChance = getRandomNumber(0)\n        if sigmaChance > 0 and sigmaChance < sigma:\n            newState = \'2\'\n        else:\n            if (hexNeighbours.count(\'2\') > 0):\n                newState = \'1\'\n            else:\n                newState = \'0\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n\'\'\' This method calculates the new state of the cell based on Moore neighborhood \'\'\'\ndef getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours):\n\n    selfCharacter = currentRowNeighbours[1]\n    newState = selfCharacter\n\n    #beta = .9 # Chance to get E from S\n    #sigma = .5 # Chance to get I from E\n    #gamma = .2 # Chance to get from I to R\n    #alpha = 0 # Chance to get from R to S (Loss of immunity rate)\n\n    if selfCharacter == \'0\': # If S and there is an Infected close, be Exposed\n        if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\'2\') > 0:\n            betaChance = getRandomNumber(0)\n            if betaChance < beta and betaChance > 0:\n                newState = \'1\'\n    elif selfCharacter == \'1\': # if Exposed, calculate the probability to be Infected\n        sigmaChance = getRandomNumber(0)\n        if sigmaChance > 0 and sigmaChance < sigma:\n            newState = \'2\'\n        else:\n            if currentRowNeighbours.count(\'2\') > 0 or upperRowNeighbours.count(\'2\') > 0 or lowerRowNeighbours.count(\'2\') > 0:\n                newState = \'1\'\n            else:\n                newState = \'0\'\n    elif selfCharacter == \'2\': # if Infected, calculate the probability to be Recovered\n        gammaChance = getRandomNumber(0)\n        if gammaChance < gamma and gammaChance > 0:\n            newState = \'0\'\n\n    return newState\n\n# TODO: Add Seed parameter\n# TODO: Add popoulation density\n# TODO: Non linearity coefficient?\n# TODO: Add ""Expected Numerical Results"" graph versus ""Spatial Results""\n\n# SEIR Model Parameters\n\n# Salmonela rates:\n# E->I: 0.33\n# S->E: 0.18\n# E->I: 0.01\n\n# Salmonela Cerro - Dairy herd http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2870801/\n# S->E: 0.9\n# Birt and Death: 0.03\n# Indirect Transmission: 10^-12\n# I->R: 0.14\n# R->S: 0.22\n# Environment pathogen removal: 10^9\n# Pathogen addition to environment due to animal shedding: 0.99\n\n# Rates - Units are 1/time in days\n\nbeta = .4247 # Transmission Rate: S -> E (or S->I) # TODO: Only different parameter vs the numerical model, others are the same\nsigma = .9 # Incubation Rate: E -> I (or epsilon)\ngamma = .14286 #.2 # Recovery Rate: I -> R\nalpha = .22 # Immunity Loss Rate: I -> S\nmu = 0 # TODO: Mortality Rate\nmuStart = 0 # TODO: Birth Rate\ndelta = 0 # TODO: Infectious Mortality Rate\n\nsimulationIterations = 70\ncellCountX = 150\ncellCountY = 150\nhexagonLayout = False\n\n# Init values\nsusceptibleCharacter = \'S\'\nexposedCharacter = \'E\'\nrecoveredCharacter = \'R\'\ninfectedCharacter =\'I\'\nextremeEndValue = \'0\'\ntimeStart = 0.0\ntimeEnd = simulationIterations\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\nuniverseList = []\n\n# Randomise first state\nfor currentColumn in range(cellCountY):\n    # if currentColumn == (cellCountY / 2):\n    #     universe = \'\'.join(\'0\' for universeColumn in range((cellCountX / 2) - 1))\n    #     universe += \'2\'\n    #     universe += \'\'.join(\'0\' for universeColumn in range(cellCountX / 2))\n    # else:\n    universe = \'\'.join(random.choice(\'0000000002\') for universeColumn in range(cellCountX))\n    universeList.append(universe)\n\n# TODO: Fix init state vars\nInitSusceptibles = 0.0\nInitInfected = 0.0\nInitRecovered = 0.0\nInitVariables = [InitSusceptibles, InitInfected, 0.0, 0.0, 0.0]\n\nRES = [InitVariables]\n\nuniverseTimeSeries = []\n\n# Main Execution loop\nfor currentTimeStep in range(simulationIterations):\n\n    # Print the current generation\n    if currentTimeStep < 0:\n        printGenerationUniverse(currentTimeStep, cellCountX, cellCountY, susceptibleCharacter, exposedCharacter, infectedCharacter, recoveredCharacter)\n\n    # Store the counts of I, S and the time iteration\n    zeroCount = 0\n    oneCount = 0\n    twoCount = 0\n    threeCount = 0\n    for currentRow in range(cellCountY):\n        zeroCount += universeList[currentRow].count(\'0\')\n        oneCount += universeList[currentRow].count(\'1\')\n        twoCount += universeList[currentRow].count(\'2\')\n        threeCount += universeList[currentRow].count(\'3\')\n    RES.append([zeroCount, oneCount, twoCount, threeCount, currentTimeStep])\n\n    # Put extreme ends neighbouring cells temporarily on the old universe\n    oldUniverseList = []\n    toCopyUniverseList = []\n    for currentRow in range(cellCountY):\n        if hexagonLayout:\n            oldUniverseList.append(universeList[currentRow])\n        else:\n            oldUniverseList.append(extremeEndValue + universeList[currentRow] + extremeEndValue)\n        toCopyUniverseList.append(universeList[currentRow])\n\n    universeTimeSeries.append(toCopyUniverseList)\n\n    for currentRow in range(cellCountY):\n        newUniverseRow = \'\'\n        for currentColumn in range(cellCountX):\n\n            if hexagonLayout:\n                # HEX\n                hexNeighbours = list(""000000"") # list of characters\n\n                # Top/bottom CELL 2 & CELL 3 - Same for ODD and EVEN\n                if (currentRow - 1) >= 0: # CELL 2\n                    hexNeighbours[2] = oldUniverseList[currentRow - 1][currentColumn]\n                if (currentRow + 1) < cellCountY: # CELL 3\n                    hexNeighbours[3] = oldUniverseList[currentRow + 1][currentColumn]\n\n                if (currentColumn % 2 == 0):\n                    if (currentColumn - 1) >= 0: # CELL 1 EVEN\n                        hexNeighbours[1] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 0 EVEN\n                            hexNeighbours[0] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 5 EVEN\n                        hexNeighbours[5] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow - 1) >= 0: # CELL 4 EVEN\n                            hexNeighbours[4] = oldUniverseList[currentRow - 1][currentColumn + 1]\n                else:\n                    # Make string of ODD neighbours - Check ranges\n                    if (currentColumn - 1) >= 0: # CELL 0 ODD\n                        hexNeighbours[0] = oldUniverseList[currentRow][currentColumn - 1]\n                        if (currentRow - 1) >= 0: # CELL 1 ODD\n                            hexNeighbours[1] = oldUniverseList[currentRow - 1][currentColumn - 1]\n                    if (currentColumn + 1) < cellCountX: # CELL 4 ODD\n                        hexNeighbours[4] = oldUniverseList[currentRow][currentColumn + 1]\n                        if (currentRow + 1) < cellCountY: # CELL 5 ODD\n                            hexNeighbours[5] = oldUniverseList[currentRow + 1][currentColumn + 1]\n\n                # Get the new state by sending the currentCell value + string of all neighbours\n                hexNeighbours = """".join(hexNeighbours) # join the characters into 1 string\n                newUniverseRow += getNewState2DHex(oldUniverseList[currentRow][currentColumn], hexNeighbours)\n                universeList[currentRow] = newUniverseRow\n            else:\n                # SQUARE\n                upperRowNeighbours = \'000\'\n                lowerRowNeighbours = \'000\'\n                currentRowNeighbours = oldUniverseList[currentRow][currentColumn:currentColumn+3]\n                if (currentRow - 1) >= 0:\n                    upperRowNeighbours = oldUniverseList[currentRow-1][currentColumn:currentColumn+3]\n                if (currentRow + 1) < cellCountY:\n                    lowerRowNeighbours = oldUniverseList[currentRow+1][currentColumn:currentColumn+3]\n\n                newUniverseRow += getNewState2D(currentRowNeighbours, upperRowNeighbours, lowerRowNeighbours)\n                universeList[currentRow] = newUniverseRow\n\n                # TODO: Square neighbours to list of characters\n                #squareNeighbours = list(""00000000"") # list of characters\n\n#print RES\nRES = np.array(RES)\n#print(universeTimeSeries)\n\n#Ploting\npl.subplot(2, 1, 1)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.plot(RES[:, 4], RES[:, 1], \'-y\', label=\'Exposed\')\npl.plot(RES[:, 4], RES[:, 3], \'-g\', label=\'Recovered\')\npl.legend(loc=0)\npl.title(\'All vs Time\')\npl.xlabel(\'Time\')\npl.ylabel(\'Count\')\n\npl.subplot(2, 1, 2)\npl.plot(RES[:, 4], RES[:, 2], \'-r\', label=\'Infected\')\npl.plot(RES[:, 4], RES[:, 0], \'-b\', label=\'Susceptibles\')\npl.legend(loc=0)\npl.title(\'Infected and Susceptibles\')\npl.xlabel(\'Infected\')\npl.ylabel(\'Susceptibles\')\n\npl.show()\n\ndrawGenerationUniverse(cellCountX, cellCountY, universeTimeSeries)\n'"
WorkingModels/SimpleSIRNoBirthsNoDeaths.py,2,"b'####################################################################\n###    This is the PYTHON version of program 2.1 from page 19 of   #\n### ""Modeling Infectious Disease in humans and animals""            #\n### by Keeling & Rohani.\t\t\t\t\t    #\n###\t\t\t\t\t\t\t\t    #\n### It is the simple SIR epidemic without births or deaths.        #\n####################################################################\n\n##########################################################################\n### Copyright (C) <2008> Ilias Soumpasis                                 #\n### ilias.soumpasis@deductivethinking.com                                #\n### ilias.soumpasis@gmail.com\t                                         #\n###                                                                      #\n### This program is free software: you can redistribute it and/or modify #\n### it under the terms of the GNU General Public License as published by #\n### the Free Software Foundation, version 3.                             #\n###                                                                      #\n### This program is distributed in the hope that it will be useful,      #\n### but WITHOUT ANY WARRANTY; without even the implied warranty of       #\n### MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        #\n### GNU General Public License for more details.                         #\n###                                                                      #\n### You should find a copy of the GNU General Public License at          #\n###the Copyrights section or, see http://www.gnu.org/licenses.           #\n##########################################################################\n\n\nimport scipy.integrate as spi\nimport numpy as np\nimport pylab as pl\n\nbeta = .4247\ngamma = .14286\n\npopulationCount = 10000\n\nTimeStep = 1.0\nTimeRange = 70.0\n# InitInfected=1e-6\n# InitSusceptibles=1-1e-6\nInitInfected = 0.0016\nInitSusceptibles = 1 - InitInfected\nInitVariables = (InitSusceptibles, InitInfected, 0.0, 0.0)\n\n\ndef diff_eqs(INP, t):\n    \'\'\'The main set of equations\'\'\'\n    Y = np.zeros((4))\n    V = INP\n\n    \'\'\'SIR\'\'\'\n    Y[0] = - beta * V[0] * V[1]\n    Y[1] = beta * V[0] * V[1] - gamma * V[1]\n    Y[2] = gamma * V[1]\n\n    \'\'\'SIS\'\'\'\n    \'\'\'Y[0] = - beta * V[0] * V[1] + gamma * V[1]\n\tY[1] = beta * V[0] * V[1] - gamma * V[1]\'\'\'\n\n    Y[3] = V[0] + V[1] + V[2]  # Should always be constant\n    # Y[3] = Y[0] + Y[1] + Y[2] # Should always be zero\n    return Y  # For odeint\n\n\nt_start = 0.0\nt_end = TimeRange\nt_inc = TimeStep\nt_range = np.arange(t_start, t_end + t_start, t_inc)\n\nRES = spi.odeint(diff_eqs, InitVariables, t_range)\n\nprint(RES)\n\n# Ploting\npl.subplot(111)\npl.plot(RES[:, 0] * populationCount, \'-b\', label=\'Susceptibles\')\npl.plot(RES[:, 2] * populationCount, \'-g\', label=\'Recovereds\')\npl.plot(RES[:, 1] * populationCount, \'-r\', label=\'Infected\')\npl.legend(loc=0)\npl.title(\'Numerical SIR\')\npl.xlabel(\'Time\')\npl.ylabel(\'Susceptibles and Recovereds\')\n\n# pl.subplot(212)\n# pl.plot(RES[:,0], \'-b\', label=\'Susceptibles\')\n# pl.plot(RES[:,1], \'-r\', label=\'Infected\')\n# pl.legend(loc=0)\n# pl.xlabel(\'Time\')\n# pl.ylabel(\'Susceptibles and Infectious\')\npl.show()\n'"
WorkingModels/SimpleSIRWIthBirthsAndDeaths.py,2,"b'####################################################################\n###    This is the PYTHON version of program 2.2 from page 27 of   #\n### ""Modeling Infectious Disease in humans and animals""            #\n### by Keeling & Rohani.\t\t\t\t\t\t\t\t\t\t   #\n###\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   #\n### It is the simple SIR epidemic with equal births and deaths.    #\n####################################################################\n\n###################################\n### Written by Ilias Soumpasis    #\n### ilias.soumpasis@ucd.ie (work) #\n### ilias.soumpasis@gmail.com\t  #\n###################################\n\nimport scipy.integrate as spi\nimport numpy as np\nimport pylab as pl\n\nmu = 0.0001  # 1/(70*365.0)\nbeta = 1  # 520/365.0\ngamma = 0  # 1/7.0\nTS = 1.0\nND = 50  # 60*365\nI0 = 0.001\nS0 = 1.0 - I0\nR0 = 0  # 1-S0-I0\nINPUT = (S0, I0, R0)\n\n\ndef diff_eqs(INP, t):\n    \'\'\'The main set of equations\'\'\'\n    Y = np.zeros((3))\n    V = INP\n    Y[0] = mu - beta * V[0] * V[1] - mu * V[0]\n    Y[1] = beta * V[0] * V[1] - gamma * V[1] - mu * V[1]\n    Y[2] = gamma * V[1] - mu * V[2]\n    return Y  # For odeint\n\n\nt_start = 0.0;\nt_end = ND;\nt_inc = TS\nt_range = np.arange(t_start, t_end + t_inc, t_inc)\nRES = spi.odeint(diff_eqs, INPUT, t_range)\n\nprint(RES)\n\n# Ploting\npl.subplot(311)\npl.plot(RES[:, 0], \'-g\', label=\'Susceptibles\')\npl.title(\'Program_2_2.py\')\npl.xlabel(\'Time\')\npl.ylabel(\'Susceptibles\')\npl.subplot(312)\npl.plot(RES[:, 1], \'-r\', label=\'Infectious\')\npl.xlabel(\'Time\')\npl.ylabel(\'Infectious\')\npl.subplot(313)\npl.plot(RES[:, 2], \'-k\', label=\'Recovereds\')\npl.xlabel(\'Time\')\npl.ylabel(\'Recovereds\')\npl.show()\n'"
WorkingModels/__init__.py,0,"b""__author__ = 'madks_000'\n"""
TestModels/AgentModels/Flocks.py,3,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n        mouseX = 0\n        mouseY = 0\n        mousePoint = PVector(0, 0)  # Point of mouse vector\n\n        moverObjectCount = 20\n        moverToMouseList = [ MoverToMouse() for i in range(moverObjectCount)]\n        flockList = Flock(30)\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n\n                for i in timeRange:\n                    event = pygame.event.poll()\n                    if event.type == pygame.QUIT:\n                        running = 0\n                    elif event.type == pygame.MOUSEMOTION:\n                        mouseX, mouseY = event.pos\n\n                    mousePoint = PVector(mouseX, mouseY)\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    flockList.run()\n                    # for currentWalker in moverToMouseList:\n                    #     mousePointDirection = PVector(mouseX, mouseY)\n                    #     mousePointDirection.subtract(currentWalker.Location)\n                    #     mousePointDirection.normalize()\n                    #     mousePointDirection.multiply(2.5)\n                    #\n                    #     tempMousePoint = PVector(mouseX, mouseY)\n                    #     tempMousePoint.subtract(currentWalker.Location)\n                    #\n                    #     currentWalker.walkVectorAcceleration(mousePointDirection)\n\n                    for currentBoid in flockList.Boids:\n\n                        # Draw point\n                        #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                        # Draw triangle\n                        # triangleSide = 8 # pixels\n                        # a = [int(currentBoid.Location.X), int(currentBoid.Location.Y) - (triangleSide)]\n                        # b = [int(currentBoid.Location.X) + (triangleSide /2 ), int(currentBoid.Location.Y) + (triangleSide /2 )]\n                        # c = [int(currentBoid.Location.X) - (triangleSide /2 ), int(currentBoid.Location.Y) + (triangleSide /2 )]\n                        # pygame.draw.polygon(screen, BLUE, [a, b, c])\n                        # pygame.draw.polygon(screen, BLACK, [a, b, c], 1)\n                        # Draw circle\n                        circleRadius = 5\n                        circleThickness = 1\n                        pygame.draw.circle(screen, BLUE, (int(currentBoid.Location.X), int(currentBoid.Location.Y)), circleRadius, 0)\n                        pygame.draw.circle(screen, BLACK, (int(currentBoid.Location.X), int(currentBoid.Location.Y)), circleRadius, circleThickness)\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % flockList.T)\n\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n    def random2D(self):\n        self.X = random.random()\n        self.Y = random.random()\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n    def limit(self, max):\n        if self.magnitude() > max:\n            self.normalize()\n            self.multiply(max)\n    def setMangitude(self, inputMagnitude):\n        self.normalize()\n        self.multiply(inputMagnitude)\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n    def getDistance(self, otherLocation):\n        return np.sqrt((self.X - otherLocation.X)** 2 + (self.Y - otherLocation.Y)**2)\n\nclass Boid:\n    def __init__(self, x, y):\n        self.Location = PVector(cellCountX / 2, cellCountY / 2)#PVector(x, y)\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)#PVector(0, 0)\n        self.Acceleration = PVector(-0.1, 1)#PVector(-0.01, 0.1)#PVector(0, 0)\n        self.R = 4#1.0 # For size\n        self.MaxForce = 0.2\n        self.MaxSpeed = 2#0.1\n        self.NeighbourDistance = 1\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        #self.invertEdges()\n        self.wrapEdges()\n\n    def update(self):\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.MaxSpeed)\n        self.Location.add(self.Velocity)\n        self.Acceleration.multiply(0.0)\n\n    def flock(self, inputBoids):\n        separateVector = self.separate(inputBoids)\n        alignVector = self.align(inputBoids)\n        cohesionVector = self.cohesion(inputBoids)\n\n        separateVector.multiply(1.5)\n        alignVector.multiply(1)\n        cohesionVector.multiply(1)\n\n        self.applyForce(separateVector)\n        self.applyForce(alignVector)\n        self.applyForce(cohesionVector)\n        self.checkEdges()\n        self.update()\n\n    def align(self, inputBoids):\n        sum = PVector(0, 0)\n\n        for currentBoid in inputBoids:\n            sum.add(currentBoid.Velocity)\n\n        sum.divide(len(inputBoids))\n        sum.setMangitude(self.MaxSpeed)\n\n        steer = PVector(sum.X, sum.Y)\n        steer.subtract(self.Velocity)\n        steer.limit(self.MaxForce)\n\n        return steer\n\n    def separate(self, inputBoids):\n        desiredSeparation = self.R * 2\n        sum = PVector(0, 0)\n        count = 0\n        for currentBoid in inputBoids:\n            distance = self.Location.getDistance(currentBoid.Location)\n            if distance > 0 and distance < desiredSeparation:\n                diff = PVector(self.Location.X, self.Location.Y)\n                diff.subtract(currentBoid.Location)\n                diff.normalize()\n                diff.divide(distance)\n                sum.add(diff)\n                count += 1\n        if count > 0:\n            sum.divide(count)\n            sum.normalize()\n            sum.multiply(self.MaxSpeed)\n            steer = PVector(sum.X, sum.Y)\n            steer.subtract(self.Velocity)\n            steer.limit(self.MaxForce)\n            return steer\n        else:\n            return PVector(0, 0)\n\n    def cohesion(self, inputBoids):\n        sum = PVector(0, 0)\n        count = 0\n        for currentBoid in inputBoids:\n            distance = self.Location.getDistance(currentBoid.Location)\n            if (distance > 0 and distance < self.NeighbourDistance):\n                sum.add(currentBoid.Location)\n                count += 1\n\n        if count > 0:\n            sum.divide(count)\n            return self.seek(sum)\n        else:\n            return PVector(0, 0)\n\n    def seek(self, targetVector):\n        desired = targetVector\n        desired.subtract(self.Location)\n        desired.normalize()\n        desired.multiply(self.MaxSpeed)\n\n        steer = desired\n        desired.subtract(self.Velocity)\n        return desired\n\n    def applyForce(self, inputForce):\n        self.Acceleration.add(inputForce)\n\nclass Flock:\n    def __init__(self, inputBoidCount):\n        self.BoidCount = inputBoidCount\n        self.Boids = [ Boid(10, 10) for i in range(self.BoidCount)]\n        self.T = 0\n    def run(self):\n        self.T += 1\n        for currentBoid in self.Boids:\n            currentBoid.flock(self.Boids)\n\nclass MoverToMouse:\n    def __init__(self):\n        self.Location = PVector(random.randint(0, cellCountX), random.randint(0, cellCountY))\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)\n        self.Acceleration = PVector(-0.01, 0.1)\n        self.TopSpeed = 20\n        self.T = 0\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        #self.invertEdges()\n        self.wrapEdges()\n\n    def walkVectorAcceleration(self, acceleration):\n        self.T += 1\n\n        self.Acceleration = acceleration\n        self.checkEdges()\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVector(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Acceleration.random2D()\n        accelerationFactor = random.uniform(-5, 5)\n        self.Acceleration.multiply(accelerationFactor)\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkAcceleratingVector(self):\n        self.T += 1\n\n        self.checkEdges()\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVectorNormalize(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
TestModels/AgentModels/Mover.py,2,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n        mouseX = 0\n        mouseY = 0\n        mousePoint = PVector(0, 0)  # Point of mouse vector\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n                walker = Mover()\n                for i in timeRange:\n                    #walker.walk()\n                    #walker.walkStep()\n                    #walker.walkStepRight()\n                    #walker.walkDistribution()\n                    #walker.walkPerlinNoise()\n                    walker.walkVector()\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    # Draw point\n                    #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                    # Draw triangle\n                    # triangleSide = 10 # pixels\n                    # a = [walker.X, walker.Y - (triangleSide /2 )]\n                    # b = [walker.X + (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # c = [walker.X - (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # pygame.draw.polygon(screen, currentColour, [a, b, c])\n\n                    # Draw circle\n                    circleRadius = 15\n                    circleThickness = 3\n                    pygame.draw.circle(screen, BLUE, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, 0)\n                    pygame.draw.circle(screen, BLACK, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, circleThickness)\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % walker.T)\n\n                    event = pygame.event.poll()\n                    if event.type == pygame.QUIT:\n                        running = 0\n                    elif event.type == pygame.MOUSEMOTION:\n                        mouseX, mouseY = event.pos\n\n                    mousePoint = PVector(mouseX, mouseY)\n                    tempMousePoint = PVector(mouseX, mouseY)\n                    tempMousePoint.subtract(walker.Location)\n\n                    label4 = myfont.render(""Magnitude from mouse: "" + str(tempMousePoint.magnitude()), 1, RED)\n                    screen.blit(label4, (10, 35)) # Draw the text\n\n                    center = PVector(cellCountX / 2, cellCountY / 2)\n                    center.subtract(walker.Location)\n                    label = myfont.render(""Magnitude from Center: "" + str(center.magnitude()), 1, RED)\n                    label2 = myfont.render(""Magnitude from 0,0: "" + str(walker.Location.magnitude()), 1, RED)\n                    label3 = myfont.render(""Magnitude of Velocity: "" + str(walker.Velocity.magnitude()), 1, RED)\n                    screen.blit(label, (10, 5)) # Draw the text\n                    screen.blit(label2, (10, 15)) # Draw the text\n                    screen.blit(label3, (10, 25)) # Draw the text\n\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n    def random2D(self):\n        self.X = random.random()\n        self.Y = random.random()\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n    def limit(self, max):\n        if self.magnitude() > max:\n            self.normalize()\n            self.multiply(max)\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n\nclass Mover:\n    def __init__(self):\n        self.Location = PVector(random.randint(0, cellCountX), random.randint(0, cellCountY))\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)\n        self.Acceleration = PVector(-0.01, 0.1)\n        self.TopSpeed = 50\n        self.T = 0\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        #self.invertEdges()\n        self.wrapEdges()\n\n    def walkVector(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Acceleration.random2D()\n        accelerationFactor = random.uniform(-5, 5)\n        self.Acceleration.multiply(accelerationFactor)\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkAcceleratingVector(self):\n        self.T += 1\n\n        self.checkEdges()\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVectorNormalize(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
TestModels/AgentModels/MoverToMouse.py,2,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n        mouseX = 0\n        mouseY = 0\n        mousePoint = PVector(0, 0)  # Point of mouse vector\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n\n                walker = MoverToMouse()\n                for i in timeRange:\n                    event = pygame.event.poll()\n                    if event.type == pygame.QUIT:\n                        running = 0\n                    elif event.type == pygame.MOUSEMOTION:\n                        mouseX, mouseY = event.pos\n\n                    mousePoint = PVector(mouseX, mouseY)\n\n                    mousePointDirection = PVector(mouseX, mouseY)\n                    mousePointDirection.subtract(walker.Location)\n                    mousePointDirection.normalize()\n                    mousePointDirection.multiply(2.5)\n\n                    tempMousePoint = PVector(mouseX, mouseY)\n                    tempMousePoint.subtract(walker.Location)\n\n                    #walker.walk()\n                    #walker.walkStep()\n                    #walker.walkStepRight()\n                    #walker.walkDistribution()\n                    #walker.walkPerlinNoise()\n                    #walker.walkVector()\n                    walker.walkVectorAcceleration(mousePointDirection)\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    # Draw point\n                    #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                    # Draw triangle\n                    # triangleSide = 10 # pixels\n                    # a = [walker.X, walker.Y - (triangleSide /2 )]\n                    # b = [walker.X + (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # c = [walker.X - (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # pygame.draw.polygon(screen, currentColour, [a, b, c])\n\n\n                    # Draw circle\n                    circleRadius = 15\n                    circleThickness = 3\n                    pygame.draw.circle(screen, BLUE, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, 0)\n                    pygame.draw.circle(screen, BLACK, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, circleThickness)\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % walker.T)\n\n                    label4 = myfont.render(""Magnitude from mouse: "" + str(tempMousePoint.magnitude()), 1, RED)\n                    screen.blit(label4, (10, 35)) # Draw the text\n\n                    center = PVector(cellCountX / 2, cellCountY / 2)\n                    center.subtract(walker.Location)\n                    label = myfont.render(""Magnitude from Center: "" + str(center.magnitude()), 1, RED)\n                    label2 = myfont.render(""Magnitude from 0,0: "" + str(walker.Location.magnitude()), 1, RED)\n                    label3 = myfont.render(""Magnitude of Velocity: "" + str(walker.Velocity.magnitude()), 1, RED)\n                    screen.blit(label, (10, 5)) # Draw the text\n                    screen.blit(label2, (10, 15)) # Draw the text\n                    screen.blit(label3, (10, 25)) # Draw the text\n\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n    def random2D(self):\n        self.X = random.random()\n        self.Y = random.random()\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n    def limit(self, max):\n        if self.magnitude() > max:\n            self.normalize()\n            self.multiply(max)\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n\nclass MoverToMouse:\n    def __init__(self):\n        self.Location = PVector(random.randint(0, cellCountX), random.randint(0, cellCountY))\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)\n        self.Acceleration = PVector(-0.01, 0.1)\n        self.TopSpeed = 20\n        self.T = 0\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        #self.invertEdges()\n        self.wrapEdges()\n\n    def walkVectorAcceleration(self, acceleration):\n        self.T += 1\n\n        self.Acceleration = acceleration\n        self.checkEdges()\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVector(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Acceleration.random2D()\n        accelerationFactor = random.uniform(-5, 5)\n        self.Acceleration.multiply(accelerationFactor)\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkAcceleratingVector(self):\n        self.T += 1\n\n        self.checkEdges()\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVectorNormalize(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
TestModels/AgentModels/MultiMoverToMouse.py,2,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n        mouseX = 0\n        mouseY = 0\n        mousePoint = PVector(0, 0)  # Point of mouse vector\n\n        moverObjectCount = 20\n        moverToMouseList = [ MoverToMouse() for i in range(moverObjectCount)]\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n\n                for i in timeRange:\n                    event = pygame.event.poll()\n                    if event.type == pygame.QUIT:\n                        running = 0\n                    elif event.type == pygame.MOUSEMOTION:\n                        mouseX, mouseY = event.pos\n\n                    mousePoint = PVector(mouseX, mouseY)\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    for currentWalker in moverToMouseList:\n                        mousePointDirection = PVector(mouseX, mouseY)\n                        mousePointDirection.subtract(currentWalker.Location)\n                        mousePointDirection.normalize()\n                        mousePointDirection.multiply(2.5)\n\n                        tempMousePoint = PVector(mouseX, mouseY)\n                        tempMousePoint.subtract(currentWalker.Location)\n\n                        currentWalker.walkVectorAcceleration(mousePointDirection)\n\n\n                        # Draw point\n                        #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                        # Draw triangle\n                        # triangleSide = 10 # pixels\n                        # a = [walker.X, walker.Y - (triangleSide /2 )]\n                        # b = [walker.X + (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                        # c = [walker.X - (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                        # pygame.draw.polygon(screen, currentColour, [a, b, c])\n\n\n                        # Draw circle\n                        circleRadius = 15\n                        circleThickness = 3\n                        pygame.draw.circle(screen, BLUE, (int(currentWalker.Location.X), int(currentWalker.Location.Y)), circleRadius, 0)\n                        pygame.draw.circle(screen, BLACK, (int(currentWalker.Location.X), int(currentWalker.Location.Y)), circleRadius, circleThickness)\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % currentWalker.T)\n\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n    def random2D(self):\n        self.X = random.random()\n        self.Y = random.random()\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n    def limit(self, max):\n        if self.magnitude() > max:\n            self.normalize()\n            self.multiply(max)\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n\nclass MoverToMouse:\n    def __init__(self):\n        self.Location = PVector(random.randint(0, cellCountX), random.randint(0, cellCountY))\n        self.Velocity = PVector(random.uniform(-2, 2) * 4, random.uniform(-2, 2) * 4)\n        self.Acceleration = PVector(-0.01, 0.1)\n        self.TopSpeed = 20\n        self.T = 0\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def invertEdges(self):\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y <= 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n    def wrapEdges(self):\n        if self.Location.X <= 0:\n            self.Location.X = cellCountX\n        if self.Location.X > cellCountX - 1:\n            self.Location.X = 0\n        if self.Location.Y <= 0:\n            self.Location.Y = cellCountY\n        if self.Location.Y > cellCountY - 1:\n            self.Location.Y = 0\n\n    def checkEdges(self):\n        #self.invertEdges()\n        self.wrapEdges()\n\n    def walkVectorAcceleration(self, acceleration):\n        self.T += 1\n\n        self.Acceleration = acceleration\n        self.checkEdges()\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVector(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Acceleration.random2D()\n        accelerationFactor = random.uniform(-5, 5)\n        self.Acceleration.multiply(accelerationFactor)\n\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkAcceleratingVector(self):\n        self.T += 1\n\n        self.checkEdges()\n        self.Velocity.add(self.Acceleration)\n        self.Velocity.limit(self.TopSpeed)\n        self.Location.add(self.Velocity)\n\n    def walkVectorNormalize(self):\n        self.T += 1\n\n        self.checkEdges()\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
TestModels/AgentModels/RandomWalker.py,7,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n                walker = Walker()\n                for i in timeRange:\n                    #walker.walk()\n                    #walker.walkStep()\n                    #walker.walkStepRight()\n                    #walker.walkDistribution()\n                    walker.walkPerlinNoise()\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    # Draw point\n                    #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                    # Draw triangle\n                    # triangleSide = 10 # pixels\n                    # a = [walker.X, walker.Y - (triangleSide /2 )]\n                    # b = [walker.X + (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # c = [walker.X - (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # pygame.draw.polygon(screen, currentColour, [a, b, c])\n\n                    # Draw circle\n                    circleRadius = 15\n                    circleThickness = 3\n                    pygame.draw.circle(screen, BLUE, (walker.X, walker.Y), circleRadius, 0)\n                    pygame.draw.circle(screen, BLACK, (walker.X, walker.Y), circleRadius, circleThickness)\n\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % walker.T)\n                    pygame.display.flip()\n\n                    #label = myfont.render(str(milliseconds) + "" ms"", 1, RED)\n                    #screen.blit(label, (20, 20)) # Draw the text\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass Walker:\n    def __init__(self):\n        self.X = int(cellCountX/2)\n        self.Y = int(cellCountY/2)\n        self.T = 0\n        #self.Universe = [[0 for x in range(cellCountX)] for x in range(cellCountY)]\n\n    def walkPerlinNoise(self):\n        self.T += 1\n\n        # Get the noise at different time steps because Perlin noise function is deterministic\n        stepX = int(self.perlinNoiseNumber(self.T * 5, timeEnd) * 20)\n        stepY = int(self.perlinNoiseNumber(abs(timeEnd * 10 - self.T), timeEnd) * 20)\n\n        newX = self.X + stepX\n        newY = self.Y + stepY\n        self.updateLocation(newX, newY)\n\n\n    def walkDistribution(self):\n        self.T += 1\n        randomFloat = self.getRandomNumber(4)\n\n        stepX = 0\n        stepY = 0\n\n        if randomFloat < 0.25:\n            stepX = 1\n        elif randomFloat < 0.5:\n            stepX = -1\n        elif randomFloat < 0.75:\n            stepY = -1\n        else:\n            stepY = 1\n\n        newX = self.X + stepX\n        newY = self.Y + stepY\n        self.updateLocation(newX, newY)\n\n    def updateLocation(self, newX, newY):\n        if newX >= 0 and newX < cellCountX - 1:\n            self.X = newX\n        if newY >= 0 and newY < cellCountY - 1:\n            self.Y = newY\n\n    def walkStepRight(self):\n        self.T += 1\n        randomFloat = random.random()\n\n        stepX = 0\n        stepY = 0\n\n        if randomFloat < 0.4:\n            stepX = 1\n        elif randomFloat < 0.6:\n            stepX = -1\n        elif randomFloat < 0.8:\n            stepY = 1\n        else:\n            stepY = -1\n        newX = self.X + stepX\n        newY = self.Y + stepY\n        self.updateLocation(newX, newY)\n\n    def updateLocation(self, newX, newY):\n        if newX >= 0 and newX < cellCountX - 1:\n            self.X = newX\n        if newY >= 0 and newY < cellCountY - 1:\n            self.Y = newY\n\n    def walkStep(self):\n        self.T += 1\n        stepX = random.randint(-1,1)\n        stepY = random.randint(-1,1)\n        newX = self.X + stepX\n        newY = self.Y + stepY\n        self.updateLocation(newX, newY)\n\n    def walk(self):\n        self.T += 1\n        randChoice = randint(0,3)\n\n        if randChoice == 0:\n            if self.X < cellCountX - 1:\n                self.X = self.X + 1\n        elif randChoice == 1:\n            if self.X > 0:\n                self.X = self.X - 1\n        elif randChoice == 2:\n            if self.Y < cellCountY - 1:\n                self.Y = self.Y + 1\n        elif randChoice == 3:\n            if self.Y > 0:\n                self.Y = self.Y - 1\n\n    def monteCarlo(self):\n        r1 = 0.0\n        while(True):\n            # Pick a random value.\n            r1 = np.random.uniform()\n            if np.random.uniform() < r1:\n                return r1\n\n    # PERLIN NOISE 1 to -1\n    def perlinNoiseNumber(self, timeStep, maxTimeStep, octaves = 10, timeSpan = 300):\n        base = 0.5\n        x = float(timeStep) * timeSpan / maxTimeStep - 0.5 * timeSpan\n        y = pnoise1(x + base, octaves)\n        return y\n\n    def getRandomNumber(self, distribution = 0):\n        returningRandomNumber = 0.0\n        if distribution == 0:\n            returningRandomNumber = np.random.uniform() # UNIFORM\n        elif distribution == 1:\n            returningRandomNumber = np.random.normal(.5, .1) # NORMAL\n        elif distribution == 2:\n            returningRandomNumber = (np.random.binomial(20, .5, 100) % 10) * 0.1 # BINOMIAL\n        elif distribution == 3:\n            returningRandomNumber = np.random.poisson(2) * .1 # POISSON\n        elif distribution == 4:\n            returningRandomNumber = self.monteCarlo() # MONTE CARLO METHOD\n        return returningRandomNumber\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
TestModels/AgentModels/VectorWalker.py,2,"b'import pygame\nimport numpy as np\nimport random\nfrom noise import pnoise1\n\nclass DrawHandler:\n    def drawWalker(self):\n        # Initialize the game engine\n        pygame.init()\n\n        # Define the colors we will use in RGB format\n        BLACK = (  0,   0,   0)\n        WHITE = (255, 255, 255)\n        BLUE =  (  0,   0, 255)\n        GREEN = (  0, 255,   0)\n        YELLOW =   (255,   255,   0)\n        RED =   (255,   0,   0)\n        ORANGE =   (255,   165,   0)\n\n        # Set the height and width of the screen\n        screenHeight = cellCountX\n        screenWidth = cellCountY\n\n        size = [int(screenHeight), int(screenWidth)]\n        screen = pygame.display.set_mode(size)\n        screen.fill(WHITE)\n\n        #Loop until the user clicks the close button.\n        clock = pygame.time.Clock()\n        myfont = pygame.font.SysFont(""monospace"", 15)\n\n        # Make sure game doesn\'t run at more than 60 frames per second\n        mainloop = True\n        maxFPS = 60 # desired max. framerate in frames per second.\n        cycletime = 0\n        interval = .15#.15 # how long one single images should be displayed in seconds\n        delayAmount = 50\n        currentTimeStep = 0\n\n        while mainloop:\n\n            milliseconds = clock.tick(maxFPS)  # milliseconds passed since last frame\n            seconds = milliseconds / 1000.0 # seconds passed since last frame (float)\n            cycletime += seconds\n            if cycletime > interval:\n                cycletime = 0\n                if currentTimeStep >= simulationIterations:\n                    currentTimeStep = 0\n                else:\n                    currentTimeStep += 1\n\n                currentColour = BLACK\n                walker = VectorWalker()\n                for i in timeRange:\n                    #walker.walk()\n                    #walker.walkStep()\n                    #walker.walkStepRight()\n                    #walker.walkDistribution()\n                    #walker.walkPerlinNoise()\n                    walker.walkVector()\n\n                    screen.fill(WHITE) # Refresh screen\n\n                    # Draw point\n                    #screen.fill(currentColour,((walker.X, walker.Y), (1, 1)))\n\n                    # Draw triangle\n                    # triangleSide = 10 # pixels\n                    # a = [walker.X, walker.Y - (triangleSide /2 )]\n                    # b = [walker.X + (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # c = [walker.X - (triangleSide /2 ), walker.Y + (triangleSide /2 )]\n                    # pygame.draw.polygon(screen, currentColour, [a, b, c])\n\n                    # Draw circle\n                    circleRadius = 15\n                    circleThickness = 3\n                    pygame.draw.circle(screen, BLUE, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, 0)\n                    pygame.draw.circle(screen, BLACK, (int(walker.Location.X), int(walker.Location.Y)), circleRadius, circleThickness)\n\n                    pygame.display.set_caption(""TimeStep %3i:  "" % walker.T)\n\n                    center = PVector(cellCountX / 2, cellCountY / 2)\n                    center.subtract(walker.Location)\n                    label = myfont.render(""Magnitude from Center: "" + str(center.magnitude()), 1, RED)\n                    label2 = myfont.render(""Magnitude from 0,0: "" + str(walker.Location.magnitude()), 1, RED)\n                    label3 = myfont.render(""Magnitude of Velocity: "" + str(walker.Velocity.magnitude()), 1, RED)\n                    screen.blit(label, (10, 10)) # Draw the text\n                    screen.blit(label2, (10, 30)) # Draw the text\n                    screen.blit(label3, (10, 50)) # Draw the text\n                    pygame.time.wait(delayAmount) # Delay the update of the walker\n\n                    pygame.display.flip()\n\n                # This MUST happen after all the other drawing commands.\n                # Go ahead and update the screen with what we\'ve drawn.\n                pygame.display.flip()\n\nclass PVector:\n    def __init__(self, x, y):\n        self.X = x\n        self.Y = y\n    def add(self, inputVector):\n        self.X += inputVector.X\n        self.Y += inputVector.Y\n    def subtract(self, inputVector):\n        self.X -= inputVector.X\n        self.Y -= inputVector.Y\n    def multiply(self, inputNumber):\n        self.X *= inputNumber\n        self.Y *= inputNumber\n    def divide(self, inputNumber):\n        self.X /= inputNumber\n        self.Y /= inputNumber\n    def magnitude(self):\n        return np.sqrt(self.X * self.X + self.Y * self.Y)\n    def normalize(self):\n        m = self.magnitude()\n        if (m != 0):\n            self.divide(m)\n\nclass VectorWalker:\n    def __init__(self):\n        self.Location = PVector(int(cellCountX/2), int(cellCountY/2))\n        self.Velocity = PVector(25.0, 20.0)\n        self.T = 0\n        #self.Universe = [[0 for x in range(cellCountX)] for x in range(cellCountY)]\n\n    def update(self):\n        self.Location.add(self.Velocity)\n\n    def walkVector(self):\n        self.T += 1\n\n        if self.Location.X <= 0 or self.Location.X > cellCountX - 1:\n            self.Velocity.X *= -1\n        if self.Location.Y < 0 or self.Location.Y > cellCountY - 1:\n            self.Velocity.Y *= -1\n\n        self.Velocity.normalize()\n        self.Velocity.multiply(10)\n\n        self.update()\n\ntimeStart = 0.0\ntimeEnd = 5000\ntimeStep = 1\ntimeRange = np.arange(timeStart, timeEnd + timeStart, timeStep)\ntimeStart = 0\nsimulationIterations = int(timeStart + timeEnd)\ncellCountX = 400\ncellCountY = 400\n\nuniverseDrawHandler = DrawHandler()\nuniverseDrawHandler.drawWalker()'"
