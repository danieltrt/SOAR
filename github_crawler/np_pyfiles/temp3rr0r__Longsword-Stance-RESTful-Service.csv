file_path,api_count,code
kerasRunnerRestfulSocket.py,28,"b'from __future__ import print_function\nfrom flask import Flask, request, jsonify\nfrom flask_restful import Resource, Api, abort, reqparse\nimport numpy as np\nfrom keras.models import model_from_json\nimport timeit\nimport json\nimport socket\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.metrics import f1_score\nfrom sklearn.metrics import accuracy_score\n\n# Flask\napp = Flask(__name__)\napi = Api(app)\n\nimport logging\nlog = logging.getLogger(\'werkzeug\')\nlog.setLevel(logging.ERROR) # Only basic logging\n\nclass KerasModel: # Init and load the LSTM model\n    def __init__(self):\n\t#self.loaded_model = model_from_json(\'{""class_name"": ""Sequential"", ""config"": [{""class_name"": ""Embedding"", ""config"": {""name"": ""embedding_1"", ""trainable"": true, ""batch_input_shape"": [null, 12], ""dtype"": ""float32"", ""input_dim"": 35537, ""output_dim"": 128, ""embeddings_initializer"": {""class_name"": ""RandomUniform"", ""config"": {""minval"": -0.05, ""maxval"": 0.05, ""seed"": null}}, ""embeddings_regularizer"": null, ""activity_regularizer"": null, ""embeddings_constraint"": null, ""mask_zero"": false, ""input_length"": 12}}, {""class_name"": ""Bidirectional"", ""config"": {""name"": ""bidirectional_1"", ""trainable"": true, ""layer"": {""class_name"": ""LSTM"", ""config"": {""name"": ""lstm_1"", ""trainable"": true, ""return_sequences"": false, ""return_state"": false, ""go_backwards"": false, ""stateful"": false, ""unroll"": false, ""implementation"": 0, ""units"": 64, ""activation"": ""tanh"", ""recurrent_activation"": ""hard_sigmoid"", ""use_bias"": true, ""kernel_initializer"": {""class_name"": ""VarianceScaling"", ""config"": {""scale"": 1.0, ""mode"": ""fan_avg"", ""distribution"": ""uniform"", ""seed"": null}}, ""recurrent_initializer"": {""class_name"": ""Orthogonal"", ""config"": {""gain"": 1.0, ""seed"": null}}, ""bias_initializer"": {""class_name"": ""Zeros"", ""config"": {}}, ""unit_forget_bias"": true, ""kernel_regularizer"": null, ""recurrent_regularizer"": null, ""bias_regularizer"": null, ""activity_regularizer"": null, ""kernel_constraint"": null, ""recurrent_constraint"": null, ""bias_constraint"": null, ""dropout"": 0.0, ""recurrent_dropout"": 0.0}}, ""merge_mode"": ""concat""}}, {""class_name"": ""Dropout"", ""config"": {""name"": ""dropout_1"", ""trainable"": true, ""rate"": 0.5}}, {""class_name"": ""Dense"", ""config"": {""name"": ""dense_1"", ""trainable"": true, ""units"": 6, ""activation"": ""softmax"", ""use_bias"": true, ""kernel_initializer"": {""class_name"": ""VarianceScaling"", ""config"": {""scale"": 1.0, ""mode"": ""fan_avg"", ""distribution"": ""uniform"", ""seed"": null}}, ""bias_initializer"": {""class_name"": ""Zeros"", ""config"": {}}, ""kernel_regularizer"": null, ""bias_regularizer"": null, ""activity_regularizer"": null, ""kernel_constraint"": null, ""bias_constraint"": null}}], ""keras_version"": ""2.0.8"", ""backend"": ""tensorflow""}\')\n\tself.loaded_model = model_from_json(\'{""class_name"": ""Sequential"", ""config"": [{""class_name"": ""Embedding"", ""config"": {""name"": ""embedding_1"", ""trainable"": true, ""batch_input_shape"": [null, 34], ""dtype"": ""float32"", ""input_dim"": 65536, ""output_dim"": 128, ""embeddings_initializer"": {""class_name"": ""RandomUniform"", ""config"": {""minval"": -0.05, ""maxval"": 0.05, ""seed"": null}}, ""embeddings_regularizer"": null, ""activity_regularizer"": null, ""embeddings_constraint"": null, ""mask_zero"": false, ""input_length"": 34}}, {""class_name"": ""Bidirectional"", ""config"": {""name"": ""bidirectional_1"", ""trainable"": true, ""layer"": {""class_name"": ""LSTM"", ""config"": {""name"": ""lstm_1"", ""trainable"": true, ""return_sequences"": false, ""return_state"": false, ""go_backwards"": false, ""stateful"": false, ""unroll"": false, ""implementation"": 0, ""units"": 64, ""activation"": ""tanh"", ""recurrent_activation"": ""hard_sigmoid"", ""use_bias"": true, ""kernel_initializer"": {""class_name"": ""VarianceScaling"", ""config"": {""scale"": 1.0, ""mode"": ""fan_avg"", ""distribution"": ""uniform"", ""seed"": null}}, ""recurrent_initializer"": {""class_name"": ""Orthogonal"", ""config"": {""gain"": 1.0, ""seed"": null}}, ""bias_initializer"": {""class_name"": ""Zeros"", ""config"": {}}, ""unit_forget_bias"": true, ""kernel_regularizer"": null, ""recurrent_regularizer"": null, ""bias_regularizer"": null, ""activity_regularizer"": null, ""kernel_constraint"": null, ""recurrent_constraint"": null, ""bias_constraint"": null, ""dropout"": 0.0, ""recurrent_dropout"": 0.0}}, ""merge_mode"": ""concat""}}, {""class_name"": ""Dropout"", ""config"": {""name"": ""dropout_1"", ""trainable"": true, ""rate"": 0.5}}, {""class_name"": ""Dense"", ""config"": {""name"": ""dense_1"", ""trainable"": true, ""units"": 7, ""activation"": ""softmax"", ""use_bias"": true, ""kernel_initializer"": {""class_name"": ""VarianceScaling"", ""config"": {""scale"": 1.0, ""mode"": ""fan_avg"", ""distribution"": ""uniform"", ""seed"": null}}, ""bias_initializer"": {""class_name"": ""Zeros"", ""config"": {}}, ""kernel_regularizer"": null, ""bias_regularizer"": null, ""activity_regularizer"": null, ""kernel_constraint"": null, ""bias_constraint"": null}}], ""keras_version"": ""2.0.8"", ""backend"": ""tensorflow""}\')\n\n\t#self.loaded_model.load_weights(""models/bidirectionalClassLstmLongswordModelWeights.h5"")\n\tself.loaded_model.load_weights(""models/bidirectionalRetrainingLstmLongswordModelWeights.h5"")\n \n    def predict(self, data):\n\treturn self.loaded_model.predict(data)\n\nkerasModel = KerasModel()\n\n# Setup socket connection\nTCP_IP = \'127.0.0.1\'\nTCP_PORT = 5001\nBUFFER_SIZE = 1024\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.connect((TCP_IP, TCP_PORT))\n\nverbose = False\n\nyExpected = []\nyPredicted = []\nconfusionMatrix = []\nclassAccuracy = []\n\nclass Predict(Resource):\n\n    lastScores = { \'data\': \'no data yet\' }\n\n    def get(self):\n\treturn json.dumps(Predict.lastScores)\n\n    def post(self):\n\tstart_time = timeit.default_timer() # TODO: temp\n\tjson_data = request.get_json(force=True)\n\t\n\t# Input data\n\tx_test = np.array([json_data[\'row\']])\n\ty_expected = json_data[\'classification\']\n\tr = x_test\n\tr2 = np.copy(r)\n\tr[r < 0] = 0\n\tr2[r2 > 0] = 0\n\tr2 *= -1\n\t#r = np.insert(r, 0, values=r2[:,0], axis=1)        \n\t#r = np.insert(r, 1, values=r2[:,1], axis=1)\n\t#r = np.insert(r, 2, values=r2[:,2], axis=1)\n\t#r = np.insert(r, 3, values=r2[:,3], axis=1)\n\t#r = np.insert(r, 4, values=r2[:,4], axis=1)\n\t#r = np.insert(r, 5, values=r2[:,5], axis=1)\n\n\tr = np.insert(r, 0, values=r2[:,0], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 1, values=r2[:,1], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 2, values=r2[:,2], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 3, values=r2[:,3], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 4, values=r2[:,4], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 5, values=r2[:,5], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 6, values=r2[:,6], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 7, values=r2[:,7], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 8, values=r2[:,8], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 9, values=r2[:,9], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 10, values=r2[:,10], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 11, values=r2[:,11], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 12, values=r2[:,12], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 13, values=r2[:,13], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 14, values=r2[:,14], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 15, values=r2[:,15], axis=1) # inser2t values befor2e column 3\n\tr = np.insert(r, 16, values=r2[:,16], axis=1) # inser2t values befor2e column 3\n\t#r = np.insert(r, 17, values=r2[:,17], axis=1) # inser2t values befor2e column 3\n\tx_test = r\t\n\n\t# Predict\t\n\tprediction  = kerasModel.predict(x_test)\n\tpredictionArgMax = np.argmax(prediction, axis=1)        \n      \tjson_data[\'predictedClass\']= predictionArgMax[0]\n\tjson_data[\'confidence\'] = float(prediction[0, predictionArgMax[0]])\n\telapsed = timeit.default_timer() - start_time # TODO: temp\n\tresponse =  { \'predictedClass\': predictionArgMax[0], \'confidence\': float(prediction[0, predictionArgMax[0]]), \'elapsedMilliseconds\': elapsed * 1000 }\n\tif verbose == True:\n\t\tprint (""x_test: "", x_test)\n\t\tprint (response)\t\n\t\tprint(json_data)\t\n\t\n\t# TODO: calc confusion matrix\n\tyExpected.append(y_expected)\n\tyPredicted.append(predictionArgMax[0])\n\tif (len(yPredicted) > 0):\n\t\tconfusionMatrix = confusion_matrix(yExpected, yPredicted)\n\t\trowSums = np.sum(confusionMatrix, axis = 1)\n\t\tdiagonal = confusionMatrix.diagonal(0)\n\t\t\n\t\tclassAccuracyOut = [0.0] * 7\n\t\tf1ScoresOut = [0.0] * 7\n\t\t\n\t\tf1Scores = f1_score(yExpected, yPredicted, average = None)\n\t\tfor i in range(len(f1Scores)):\n\t\t\tf1ScoresOut[i] = f1ScoresOut[i] + f1Scores[i]\n\t\tfor i in range(len(rowSums)):\n\t\t\tif rowSums[i] != 0:\n\t\t\t\tclassAccuracy = float(float(diagonal[i]) / float(rowSums[i]))\n\t\t\t\tclassAccuracyOut[i] = classAccuracyOut[i] + classAccuracy\n\n\t\tif verbose == True:\n\t\t\tprint(""yExpected: "" + str(yExpected))\n\t\t\tprint(""yPredicted: "" + str(yPredicted))\n\t\t\tprint(""f1Scores: "" + str(f1Scores))\n\t\t\tprint(""classAccuracy: "" + str(classAccuracyOut))\n\t\t\tprint(""rowSums: "" + str(rowSums))\n\t\t\tprint(""diagonal: "" + str(diagonal))\n\n\t\tjson_data[\'classAccuracy\'] = classAccuracyOut\n\t\tjson_data[\'f1Scores\'] = f1ScoresOut\n\t\tjson_data[\'accuracyScore\'] = accuracy_score(yExpected, yPredicted)\n\n\tPredict.lastScores = json_data # Store the last data globally for the GET method\n\n\ts.send(json.dumps(json_data)) # Send socket response\t\n\treturn response # Send response to lambda # TODO: disable response for speed?\n\napi.add_resource(Predict, \'/predict\')\n\nif __name__ == \'__main__\':\n     app.run(host=\'0.0.0.0\')\n\ns.close() # Close socket connection\n'"
