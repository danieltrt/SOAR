file_path,api_count,code
Fourier.py,35,"b'import numpy as np\n\n# Fourier.get_circles\nfrom itertools import chain\n\nclass Fourier(object):\n    def __init__(self, n_approx = 1000, coord_1 = None, coord_2 = None):\n        if coord_1 is not None:\n            temp = coord_1[:,:,0] + 1j * coord_1[:,:,1]\n            self.complex_coord_1 = temp.reshape(temp.shape[0])\n        if coord_2 is not None:\n            temp = coord_2[:,:,0] + 1j * coord_2[:,:,1]\n            self.complex_coord_2 = temp.reshape(temp.shape[0])\n            # To ensure the two images then have the same ""frequency""\n            if self.complex_coord_2.size > self.complex_coord_1.size:\n                self.complex_coord_1 = np.hstack((self.complex_coord_1, np.full((self.complex_coord_2.size - self.complex_coord_1.size), self.complex_coord_1[-1], dtype = np.complex_)))\n            elif self.complex_coord_1.size > self.complex_coord_2.size:\n                self.complex_coord_2 = np.hstack((self.complex_coord_2, np.full((self.complex_coord_1.size - self.complex_coord_2.size), self.complex_coord_2[-1], dtype = np.complex_)))\n        else:\n            self.complex_coord_2 = None\n\n        # Avoid aliasing\n        self.n_approx = self.complex_coord_1.size//2 if n_approx > self.complex_coord_1.size//2  else n_approx\n\n    def get_circles(self, mode=1):\n        if self.complex_coord_1 is not None and self.complex_coord_2 is not None:\n            return self.get_two_circles_two_images()\n        elif mode == 2:\n            return self.get_two_circles_one_image()\n        return self.get_one_circle_one_image()\n        \n    def get_one_circle_one_image(self):\n        period = self.complex_coord_1.size\n        time   = np.arange(period)\n        circles_loc = np.zeros((2*(self.n_approx-1), period), dtype = np.complex_)\n        circles_rad = np.zeros((2*(self.n_approx-1)), dtype = np.float_)\n\n        for idx, multiple in enumerate(chain(range(-self.n_approx+1, 0), range(1, self.n_approx))):\n            # Fourier coefficient\n            cn = self.cn(time, period, multiple, self.complex_coord_1)\n            # Radius of circle\n            circles_rad[idx] = np.absolute(cn)\n            # Location of point on circle\n            circles_loc[idx, :] = self.polar_locations(time, period, multiple, cn)\n\n        # Sorting big to small\n        order = np.argsort(circles_rad)[::-1]\n        circles_loc = circles_loc[order]\n        circles_rad = circles_rad[order]\n\n        # Location of each circle\'s center and the final point\n        circles_loc = np.add.accumulate(circles_loc, 0)\n                        \n        return period, (circles_rad,), (circles_loc,)\n\n    def get_two_circles_one_image(self):\n        period = self.complex_coord_1.size\n        time   = np.arange(period)\n        circles_loc_1 = np.zeros((2*(self.n_approx - 1), period), dtype = np.complex_)\n        circles_rad_1 = np.zeros((2*(self.n_approx - 1)), dtype = np.float_)\n        circles_loc_2 = np.zeros((2*(self.n_approx - 1), period), dtype = np.complex_)\n        circles_rad_2 = np.zeros((2*(self.n_approx - 1)), dtype = np.float_)\n\n        for idx, multiple in enumerate(range(1, self.n_approx)):\n\n            ### X coordinate Fourier Series\n            # an_1 = Fourier coefficient for cos, bn_1 = Fourier coefficient for sine\n            cn_1 = self.cn(time, period, multiple, self.complex_coord_1.real)\n            an_1, bn_1 = cn_1.real, cn_1.imag\n\n            circles_rad_1[idx] = np.absolute(an_1)\n            circles_rad_1[idx+self.n_approx-1] = np.absolute(bn_1)\n\n            circles_loc_1[idx, :] = self.cartesian_locations(time, period, multiple, an_1)\n            circles_loc_1[idx+self.n_approx-1, :] = self.cartesian_locations(time, period, multiple, bn_1)\n            # A Fourier term is both sine and cos,\n            # We are interested in getting both sine and cos Fourier Series terms real because we are solving for the X coordinate (real part of e^ix is cos)\n            # But self.cartesian_locations(time, period, multiple, bn_1) outputs the sine part as imaginary, so we flip!\n            # Note that flipping just means that the circle has a phase of 90 degrees at the start\n            circles_loc_1[idx+self.n_approx-1, :] = circles_loc_1[idx + self.n_approx - 1, :].imag + 1j * circles_loc_1[idx + self.n_approx - 1, :].real\n            \n            ### Y coordinate Fourier Series\n            # an_2 = Fourier coefficient for cos, bn_2 = Fourier coefficient for sine\n            cn_2 = self.cn(time, period, multiple, self.complex_coord_1.imag)\n            an_2, bn_2 = cn_2.real, cn_2.imag\n\n            circles_rad_2[idx] = np.absolute(bn_2)\n            circles_rad_2[idx+self.n_approx-1] = np.absolute(an_2)\n            \n            circles_loc_2[idx, :] = self.cartesian_locations(time, period, multiple, bn_2)\n            circles_loc_2[idx+self.n_approx-1, :] = self.cartesian_locations(time, period, multiple, an_2)\n            # A Fourier term is both sine and cos,\n            # We are interested in getting both sine and cos Fourier Series terms imaginary because we are solving for the Y coordinate (imaginary part of e^ix is sine)\n            # But self.cartesian_locations(time, period, multiple, bn_1) outputs the cos part as real, so we flip!\n            # Note that flipping just means that the circle has a phase of 90 degrees at the start\n            circles_loc_2[idx+self.n_approx-1, :] = circles_loc_2[idx + self.n_approx - 1, :].imag + 1j * circles_loc_2[idx + self.n_approx - 1, :].real\n\n        # Sorting big to small\n        order_1 = np.argsort(circles_rad_1)[::-1]\n        circles_loc_1 = circles_loc_1[order_1]\n        circles_rad_1 = circles_rad_1[order_1]\n        order_2 = np.argsort(circles_rad_2)[::-1]\n        circles_loc_2 = circles_loc_2[order_2]\n        circles_rad_2 = circles_rad_2[order_2]\n        \n        # Location of each circle\'s center and the final point\n        circles_loc_1 = np.add.accumulate(circles_loc_1, 0)\n        circles_loc_2 = np.add.accumulate(circles_loc_2, 0)\n\n        return period, (circles_rad_1, circles_rad_2), (circles_loc_1, circles_loc_2)\n\n    def get_two_circles_two_images(self):\n        period = self.complex_coord_1.size\n        time   = np.arange(period)\n        circles_loc_1 = np.zeros((2*(self.n_approx-1), period), dtype = np.complex_)\n        circles_rad_1 = np.zeros((2*(self.n_approx-1)), dtype = np.float_)\n        circles_loc_2 = np.zeros((2*(self.n_approx-1), period), dtype = np.complex_)\n        circles_rad_2 = np.zeros((2*(self.n_approx-1)), dtype = np.float_)\n            \n        for idx, multiple in enumerate(chain(range(-self.n_approx+1, 0), range(1, self.n_approx))):\n            # Artificially entwine the two images by swapping their imaginary parts (Y coordinate) and then solving for Fourier coefficient\n            cn_1 = self.cn(time, period, multiple, self.complex_coord_1.real + 1j * self.complex_coord_2.imag)\n            cn_2 = self.cn(time, period, multiple, self.complex_coord_2.real + 1j * self.complex_coord_1.imag)\n\n            circles_rad_1[idx] = np.absolute(cn_1)\n            circles_rad_2[idx] = np.absolute(cn_2)\n                  \n            circles_loc_1[idx, :] = self.polar_locations(time, period, multiple, cn_1)              \n            circles_loc_2[idx, :] = self.polar_locations(time, period, multiple, cn_2)\n                                 \n        # Sorting big to small\n        order_1 = np.argsort(circles_rad_1)[::-1]\n        circles_loc_1 = circles_loc_1[order_1]\n        circles_rad_1 = circles_rad_1[order_1]\n        order_2 = np.argsort(circles_rad_2)[::-1]\n        circles_loc_2 = circles_loc_2[order_2]\n        circles_rad_2 = circles_rad_2[order_2]\n                                 \n        # Location of each circle\'s center and the final point\n        circles_loc_1 = np.add.accumulate(circles_loc_1, 0)\n        circles_loc_2 = np.add.accumulate(circles_loc_2, 0)\n\n        return period, (circles_rad_1, circles_rad_2), (circles_loc_1, circles_loc_2)\n\n    def cn(self, time, period, multiple, coordinates):\n        c = coordinates * np.exp(-1j * (2*multiple*np.pi/period) * time)\n        return c.sum() / period\n\n    def polar_locations(self, time, period, multiple, fourier_coeff):\n        return np.absolute(fourier_coeff) * np.exp(1j * ((2*multiple*np.pi/period) * time + np.angle(fourier_coeff)))\n\n    def cartesian_locations(self, time, period, multiple, fourier_coeff):\n        return fourier_coeff * np.exp(1j * ((2*multiple*np.pi/period) * time))\n'"
Image.py,15,"b'import cv2\nimport numpy as np\n\n# Image.find_order(contours)\nfrom bisect import bisect\n# Image.find_paths(contours)\nfrom scipy.spatial.distance import cdist\nfrom collections import defaultdict\n\nclass Image(object):\n    def __init__(self, img_loc, shape = None):\n        self.img = cv2.imread(img_loc)\n        if shape:\n            self.img = cv2.resize(self.img, shape)\n\n    def sort(self):\n        contours = self.find_contours()\n        return np.vstack([contours[idx][start::-1] if start is None and end is None and stride == -1\n                                                   else contours[idx] if start is None and end is None and stride == 1\n                                                   else contours[idx][:end:-1] if start is None and end is not None and stride == -1\n                                                   else contours[idx][start:end:stride] for idx, (start, end, stride) in self.find_order(contours)])\n    \n    def find_contours(self):\n#       img = cv2.GaussianBlur(self.img, (5,5), 0)\n        edges = cv2.Canny(self.img, 100, 255)\n        ret, thresh = cv2.threshold(edges, 127, 255, 0)\n        contours, __ = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)\n\n        return contours\n\n    def find_order(self, contours):\n        # This function was written as recursive originally.\n        # This function obtains a dictionary of connections from find_paths(contours)\n        # and ""recursively"" goes through the dictionary to find the slice notations that connects all contours together.\n        order = []\n        stack = [(0, 0, 0)]\n        paths = self.find_paths(contours)\n\n        while stack:\n            cur_contour, cur_pos, original_pos = stack.pop(-1)\n            if paths[cur_contour]:\n                pos = bisect([start for _, (start,_) in paths[cur_contour]], cur_pos)\n                # Check connections to the left and then to the right\n                next_contour, (start, end) = paths[cur_contour].pop(pos-1 if pos>0 else 0)\n                # Order imitates slicing notation\n                # For example, (cur_pos, start+1, 1) indicates a slice of cur_pos:start+1:1\n                order.append((cur_contour, (cur_pos, start+1, 1) if start+1 > cur_pos else (cur_pos, start-1 if start>0 else None, -1)))\n                stack.append((cur_contour, start, original_pos))\n                if next_contour in paths:\n                    stack.append((next_contour, end, end))\n                else:\n                    order.append((next_contour, (end, None, -1)))\n                    order.append((next_contour, (None, None, 1)))\n                    order.append((next_contour, (None, end-1 if end > 0 else None, -1)))\n            else:\n                order.append((cur_contour, (cur_pos, None, 1)))\n                order.append((cur_contour, (None, original_pos-1 if original_pos > 0 else None, -1)))\n\n        return order\n\n    def find_paths(self, contours):\n        # This function first gets a distance matrix from cdist(points, points)\n        # Then consider a ""blob"" that contains contours[0] (all the points of contours[0])\n        # This function then uses that distance matrix to find the closest point to blob\n        # And then adding said closest point into the blob because it is now connected\n        # And then ignoring said closest point\'s distance to the blob and vice versa by setting the distance in the distance matrix to np.inf.\n        # Finally construct a dictionary of connections.\n        points = np.vstack(contours)\n        points = points.reshape((points.shape[0], 2))\n        dist = cdist(points, points)\n        \n        len_arr = np.array([len(contour) for contour in contours], dtype = np.int_)\n        end_points = np.add.accumulate(len_arr)\n\n        start = 0\n        start_end = []\n        for end in end_points:\n            dist[start:end:, start:end:] = np.inf\n            start_end.append((start, end))\n            start = end\n    \n        paths = defaultdict(list)\n        # temp_order keeps track of the order in temp_dist\n        # temp_start_end keeps track of the starts and ends of each contour in temp_dist\n        # temp_dist is a slice (in terms of rows) of the original distance matrix, mainly to reduce np.argmin calculations.\n        temp_order = [0]\n        temp_start_end  = [start_end[0]]\n        temp_dist = dist[start_end[0][0]:start_end[0][1]]\n        \n        # The first connection connects two contours, and the rest connects only one contour\n        while len(temp_order) < end_points.size:\n\n            row_min = np.argmin(temp_dist, axis = 0)\n            cols = np.indices(row_min.shape)\n            col_min = np.argmin(temp_dist[row_min, cols])\n\n            # row_min[col_min] gives the row min of temp_dist\n            temp_row, temp_col = row_min[col_min], col_min\n            temp_cur_contour = self.find_contour_index(temp_row, temp_start_end)\n            cur_contour  = temp_order[temp_cur_contour]\n            # express row in terms of the index inside contours[cur_contour]\n            row = temp_row - temp_start_end[temp_cur_contour][0]\n            next_contour = self.find_contour_index(temp_col, start_end)\n            col = temp_col - start_end[next_contour][0]\n\n            paths[cur_contour].append((next_contour, (row, col)))\n            # Ignore the distance from connected points to other connected points\n            start, end = start_end[next_contour]\n            for order in temp_order:\n                new_start, new_end = start_end[order]\n                dist[new_start:new_end:, start:end:] = np.inf\n                dist[start:end:, new_start:new_end:] = np.inf\n\n            temp_order.append(next_contour)\n            temp_len_arr = np.array([len(contours[order]) for order in temp_order], dtype = np.int_)\n            temp_end_points = np.add.accumulate(temp_len_arr)\n            temp_start_end.append((temp_start_end[-1][-1], temp_start_end[-1][-1]+temp_len_arr[-1]))\n            temp_dist = dist[np.hstack([np.arange(start_end[order][0], start_end[order][1]) for order in temp_order])]\n\n        for contour in paths:\n            paths[contour].sort(key = lambda x: x[1][0])\n        return paths\n\n    def find_contour_index(self, idx, start_end):\n        for i, (start, end) in enumerate(start_end):\n            if start <= idx < end:\n                return i\n        return len(start_end) - 1\n    \n'"
Plot.py,7,"b'import numpy as np\n\nfrom matplotlib import animation\nfrom matplotlib import pyplot as plt\nfrom matplotlib.patches import ConnectionPatch\n\nclass Plot(object):\n    def __init__(self, period, tup_circles_rad, tup_circles_loc, speed=8, visualize = False):\n        self.fig = plt.figure(1)\n        self.period = period\n        self.tup_circles_loc = tup_circles_loc\n        self.speed = speed\n        self.visualize = visualize\n\n        # Two circle lists means we have to draw two images and two sets of circles.\n        if len(tup_circles_rad) == 2:\n            # 224 is the bottom right subplot\n            # 222 is the top right subplot\n            # 221 is the top left subplot\n            # 223 is the bottom left subplot\n            self.axes = [self.fig.add_subplot(int(i)) for i in (""224"", ""222"", ""221"", ""223"")]\n            \n            # bottom right/top left subplot = circles, bottom left/top right subplot = images\n            # axesA=axes[0], axesB=axes[3] connects bottom right subplot to top right subplot\n            # axesA=axes[0], axesB=axes[1] connects bottom right subplot to bottom left subplot\n            # axesA=axes[2], axesB=axes[3] connects top left subplot to top right subplot\n            # axesA=axes[2], axesB=axes[1] connects top left subplot to bottom left subplot\n            self.con_patch_tup = tuple(self.get_con_patch((0,0), (0,0), axesA, axesB) for (axesA, axesB) in zip([0]*2+[2]*2, [1,3]*2))\n            self.add_con_patch(self.con_patch_tup)\n            self.axes[1].set_zorder(-1)\n            self.axes[3].set_zorder(-1)\n\n            # Points that draws the images\n            self.final_points = (self.get_final_point(self.axes[1]), self.get_final_point(self.axes[3]))\n            self.x_lim = min(np.amin(tup_circles_loc[0][-1].real), np.amin(tup_circles_loc[1][-1].real)), max(np.amax(tup_circles_loc[0][-1].real), np.amax(tup_circles_loc[1][-1].real))\n            self.y_lim = max(np.amax(tup_circles_loc[0][-1].imag), np.amax(tup_circles_loc[1][-1].imag)), min(np.amin(tup_circles_loc[0][-1].imag), np.amin(tup_circles_loc[1][-1].imag))\n\n        else:\n            self.axes = [self.fig.add_subplot(111)]\n            # Point that draws the images\n            self.final_points = (self.get_final_point(self.axes[0]),)\n            self.x_lim = np.amin(tup_circles_loc[0][-1].real), np.amax(tup_circles_loc[0][-1].real)\n            self.y_lim = np.amax(tup_circles_loc[0][-1].imag), np.amin(tup_circles_loc[0][-1].imag)\n\n        if self.visualize is False:\n            circle_lst = list()\n            axes = (0, 2)\n            for n, circle_rad_lst in enumerate(tup_circles_rad):\n                circle_lst.append(list())\n                for radius in circle_rad_lst:\n                    circle = self.get_circle((0,0), radius)\n                    self.axes[axes[n]].add_patch(circle)\n                    circle_lst[n].append(circle)\n                # Center circle doesn\'t move, so remove it!\n                circle_lst[n].pop(0)\n            self.tup_circles_lst = tuple(circle_lst)\n        \n    def get_circle(self, loc, radius):\n        return plt.Circle(loc, np.absolute(radius), alpha = 1, fill = False)\n    def get_con_patch(self, xyA, xyB, axesA, axesB):\n        return ConnectionPatch(xyA=xyA, xyB=xyB,\n                               coordsA=""data"", coordsB=""data"",\n                               axesA=self.axes[axesA], axesB=self.axes[axesB],\n                               zorder=25, fc=""w"", ec=""darkblue"", lw=2)\n    \n    def add_con_patch(self, con_patch_tup):\n        self.axes[0].add_artist(con_patch_tup[0])\n        self.axes[0].add_artist(con_patch_tup[1])\n        self.axes[2].add_artist(con_patch_tup[2])\n        self.axes[2].add_artist(con_patch_tup[3])\n\n    def get_final_point(self, axis):\n        return axis.plot(0,0, color=\'#000000\')[0]\n    \n    def plot(self, save = False, ani_name = None, ImageMagickLoc = None, close_after_animation = True):\n        if self.visualize:\n            self.get_visualize()\n        else:\n            update, time = self.get_draw(close_after_animation=close_after_animation, save=save)\n        for ax in self.axes:\n            ax.set_xlim(self.x_lim)\n            ax.set_ylim(self.y_lim)\n        ani = animation.FuncAnimation(self.fig, update, time, interval=1, blit=True, repeat=close_after_animation)\n        if save is True and ImageMagickLoc is not None:\n            plt.rcParams[\'animation.convert_path\'] = ImageMagickLoc\n            writer = animation.ImageMagickFileWriter(fps = 100)\n            ani.save(ani_name if ani_name else \'gif_1.gif\', writer=writer)\n        else:\n            # TODO(Darius): Figure out a way to get Matplotlib to close the figure nicely after animation is done\n            try:\n                plt.show()\n            except e as Exception: # _tkinter.TclError: invalid command name ""pyimage10""\n                pass\n\n        plt.clf()\n        plt.cla()\n        plt.close()\n        \n    def get_draw(self, close_after_animation, save):\n        time = np.arange(0, self.period, self.speed)\n        def update(i):\n            if close_after_animation and not save and i == time[-1]:\n                plt.close()\n            else:\n                for n_1, circles_tup in enumerate(self.tup_circles_lst):\n                    for n_2, circle in enumerate(circles_tup):\n                        circle.center = self.get_circle_loc_point(n_1, n_1, circle_idx=n_2, time_idx = i)\n                if len(self.tup_circles_lst) == 2:\n                    self.final_points[0].set_data(self.get_circle_loc_slice(0, 1, -1, i))\n                    self.final_points[1].set_data(self.get_circle_loc_slice(1, 0, -1, i))\n                    for con_patch in self.con_patch_tup:\n                        con_patch.remove()\n                    con_patch_lst = []\n                    for ((idx_1, idx_2), (idx_3, idx_4)), (axesA, axesB) in zip(zip([(0,0)]*2 + [(1,1)]*2, [(0,1), (1,0)]*2), zip([0]*2+[2]*2, [1,3]*2)):\n                        con_patch_lst.append(self.get_con_patch(self.get_circle_loc_point(idx_1, idx_2, -1, i), self.get_circle_loc_point(idx_3, idx_4, -1, i), axesA, axesB))\n                    self.con_patch_tup = tuple(con_patch_lst)\n                    self.add_con_patch(self.con_patch_tup)\n                else:\n                    self.final_points[0].set_data(self.get_circle_loc_slice(0, 0, -1, i))\n            return ([])\n        return update, time\n        \n    def get_circle_loc_point(self, idx_1, idx_2, circle_idx, time_idx):\n        return (self.tup_circles_loc[idx_1][circle_idx, time_idx].real, self.tup_circles_loc[idx_2][circle_idx, time_idx].imag)\n    \n    def get_circle_loc_slice(self, idx_1, idx_2, circle_idx, time_idx):\n        return (self.tup_circles_loc[idx_1][circle_idx, :time_idx].real, self.tup_circles_loc[idx_2][circle_idx, :time_idx].imag)\n\n    def get_visualize(self):\n        self.n_text = self.axes[0].text(0.02, 0.95, \'Number of Points = 0\', transform=self.axes[0].transAxes)\n        def update(i):\n            self.final_points[0].set_data(self.get_circle_loc_slice(0, 0, i, -1))\n            self.n_text.set_text(\'Number of Fourier Terms = %d\' % i)\n            return ([])\n        self.time = np.arange(0, self.tup_circles_loc[0].shape[0], self.speed)\n        self.update = update\n'"
main.py,0,"b'from Image import Image\nfrom Fourier import Fourier\nfrom Plot import Plot\n\nim_1 = Image(""images/pikachu.png"", (200, 200))\n# im_2 = Image(""images/einstein.jpg"", (200, 200))\n# im_3 = Image(""images/formula.jpeg"", (200, 200))\n# im_4 = Image(""images/dickbutt.jpg"", (200, 200))\n# im_5 = Image(""images/obama.jpg"", (200, 200))\n\npath_1 = im_1.sort()\n# path_2 = im_2.sort()\n# path_3 = im_3.sort()\n# path_4 = im_4.sort()\n# path_5 = im_5.sort()\n\nperiod_1, tup_circle_rads_1, tup_circle_locs_1 = Fourier(n_approx = 1000, coord_1 = path_1).get_circles()\n# period_2, tup_circle_rads_2, tup_circle_locs_2 = Fourier(n_approx = 1000, coord_1 = path_2).get_circles(mode=2)\n# period_3, tup_circle_rads_3, tup_circle_locs_3 = Fourier(n_approx = 1000, coord_1 = path_3, coord_2 = path_4).get_circles()\n# period_4, tup_circle_rads_4, tup_circle_locs_4 = Fourier(coord_1 = path_5).get_circles()\n\n##Plot(period_1, tup_circle_rads_1, tup_circle_locs_1, speed = 200).plot(save = True, ani_name = \'im_1.gif\', ImageMagickLoc = \'C:\\Program Files\\ImageMagick-7.0.8-Q16/magick.exe\')\nPlot(period_1, tup_circle_rads_1, tup_circle_locs_1, speed = 200).plot(close_after_animation = True)\n#Plot(period_2, tup_circle_rads_2, tup_circle_locs_2, speed = 8).plot()\n# Plot(period_3, tup_circle_rads_3, tup_circle_locs_3, speed = 8).plot()\n# Plot(period_4, tup_circle_rads_4, tup_circle_locs_4, visualize = True).plot()\n\n'"
