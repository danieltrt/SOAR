file_path,api_count,code
setup.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\n\nimport os.path\nfrom typing import Dict\n\nimport setuptools\n\n\nMODULE_NAME = ""pytablewriter""\nREPOSITORY_URL = ""https://github.com/thombashi/{:s}"".format(MODULE_NAME)\nREQUIREMENT_DIR = ""requirements""\nENCODING = ""utf8""\n\npkg_info = {}  # type: Dict[str, str]\n\n\ndef get_release_command_class() -> Dict[str, setuptools.Command]:\n    try:\n        from releasecmd import ReleaseCommand\n    except ImportError:\n        return {}\n\n    return {""release"": ReleaseCommand}\n\n\nwith open(os.path.join(MODULE_NAME, ""__version__.py"")) as f:\n    exec(f.read(), pkg_info)\n\nwith open(""README.rst"", encoding=ENCODING) as f:\n    long_description = f.read()\n\nwith open(os.path.join(""docs"", ""pages"", ""introduction"", ""summary.txt""), encoding=ENCODING) as f:\n    summary = f.read().strip()\n\nwith open(os.path.join(REQUIREMENT_DIR, ""requirements.txt"")) as f:\n    install_requires = [line.strip() for line in f if line.strip()]\n\nwith open(os.path.join(REQUIREMENT_DIR, ""test_requirements.txt"")) as f:\n    tests_requires = [line.strip() for line in f if line.strip()]\n\nwith open(os.path.join(REQUIREMENT_DIR, ""docs_requirements.txt"")) as f:\n    docs_requires = [line.strip() for line in f if line.strip()]\n\nsetuptools_require = [""setuptools>=38.3.0""]\n\nexcel_requires = [""xlwt"", ""XlsxWriter>=0.9.6,<2""]\nes7_requires = [""elasticsearch>=7.0.5,<8""]\nfrom_requires = [""pytablereader>=0.30.0,<2""]\nhtml_requires = [""dominate>=2.1.5,<3""]\nlogging_requires = [""loguru>=0.4.1,<1""]\nsqlite_requires = [""SimpleSQLite>=1.1.1,<2""]\ntoml_requires = [""toml>=0.9.3,<1""]\nyaml_requires = [""PyYAML>=3.11,<6""]\noptional_requires = [""simplejson>=3.8.1,<4""]\nall_requires = (\n    excel_requires\n    + es7_requires\n    + from_requires\n    + html_requires\n    + logging_requires\n    + sqlite_requires\n    + toml_requires\n    + yaml_requires\n    + optional_requires\n)\ntests_requires = list(set(tests_requires + all_requires))\n\nsetuptools.setup(\n    name=MODULE_NAME,\n    version=pkg_info[""__version__""],\n    url=REPOSITORY_URL,\n    author=pkg_info[""__author__""],\n    author_email=pkg_info[""__email__""],\n    description=summary,\n    include_package_data=True,\n    keywords=[\n        ""table"",\n        ""CSV"",\n        ""Excel"",\n        ""JavaScript"",\n        ""JSON"",\n        ""LTSV"",\n        ""Markdown"",\n        ""MediaWiki"",\n        ""HTML"",\n        ""pandas"",\n        ""reStructuredText"",\n        ""SQLite"",\n        ""TSV"",\n        ""TOML"",\n    ],\n    license=pkg_info[""__license__""],\n    long_description=long_description,\n    long_description_content_type=""text/x-rst"",\n    packages=setuptools.find_packages(exclude=[""test*""]),\n    package_data={MODULE_NAME: [""py.typed""]},\n    project_urls={\n        ""Documentation"": ""https://{:s}.rtfd.io/"".format(MODULE_NAME),\n        ""Source"": REPOSITORY_URL,\n        ""Tracker"": ""{:s}/issues"".format(REPOSITORY_URL),\n    },\n    python_requires="">=3.5"",\n    install_requires=setuptools_require + install_requires,\n    setup_requires=setuptools_require,\n    extras_require={\n        ""all"": all_requires,\n        ""docs"": docs_requires,\n        ""excel"": excel_requires,\n        ""es5"": [""elasticsearch>=5.5.3,<6""],\n        ""es6"": [""elasticsearch>=6.3.1,<7""],\n        ""es7"": es7_requires,\n        ""html"": html_requires,\n        ""from"": from_requires,\n        ""logging"": logging_requires,\n        ""sqlite"": sqlite_requires,\n        ""test"": tests_requires,\n        ""toml"": toml_requires,\n        ""yaml"": yaml_requires,\n    },\n    classifiers=[\n        ""Development Status :: 4 - Beta"",\n        ""Intended Audience :: Developers"",\n        ""Intended Audience :: Information Technology"",\n        ""License :: OSI Approved :: MIT License"",\n        ""Operating System :: OS Independent"",\n        ""Programming Language :: Python :: 3"",\n        ""Programming Language :: Python :: 3.5"",\n        ""Programming Language :: Python :: 3.6"",\n        ""Programming Language :: Python :: 3.7"",\n        ""Programming Language :: Python :: 3.8"",\n        ""Programming Language :: Python :: 3.9"",\n        ""Programming Language :: Python :: 3 :: Only"",\n        ""Programming Language :: Python :: Implementation :: CPython"",\n        ""Programming Language :: Python :: Implementation :: PyPy"",\n        ""Topic :: Software Development :: Code Generators"",\n        ""Topic :: Software Development :: Libraries"",\n        ""Topic :: Software Development :: Libraries :: Python Modules"",\n        ""Topic :: Text Processing"",\n        ""Topic :: Text Processing :: Markup :: HTML"",\n        ""Topic :: Text Processing :: Markup :: LaTeX"",\n    ],\n    cmdclass=get_release_command_class(),\n)\n'"
docs/conf.py,0,"b'import os\nimport sys\n\nimport sphinx_rtd_theme\n\nfrom pytablewriter import __author__, __copyright__, __name__, __version__\n\n\nsys.path.insert(0, os.path.abspath(\'../pytablewriter\'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.todo\',\n    \'sphinx.ext.viewcode\',\n    \'sphinx.ext.napoleon\',\n]\n\nintersphinx_mapping = {\'python\': (\'https://docs.python.org/\', None)}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\nsource_encoding = \'utf-8\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = __name__\ncopyright = __copyright__\nauthor = __author__\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = __version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = \'en\'\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\nautodoc_default_flags = [\'inherited-members\', \'show-inheritance\']\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# The name for this set of Sphinx documents.\n# ""<project> v<release> documentation"" by default.\n#html_title = u\'pytablewriter v0.1.0\'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not None, a \'Last updated on:\' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to \'%b %d, %Y\'.\n#html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'hu\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'ru\', \'sv\', \'tr\', \'zh\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# \'ja\' uses this config value.\n# \'zh\' user can custom change `jieba` dictionary path.\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'pytablewriterdoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'pytablewriter.tex\', \'pytablewriter Documentation\',\n     __author__, \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pytablewriter\', \'pytablewriter Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'pytablewriter\', \'pytablewriter Documentation\',\n     author, \'pytablewriter\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n\n\nrp_common = """"""\n.. |TM| replace:: :superscript:`TM`\n""""""\n\nrp_builtin = """"""\n.. |False| replace:: :py:obj:`False`\n.. |True| replace:: :py:obj:`True`\n.. |None| replace:: :py:obj:`None`\n.. |inf| replace:: :py:obj:`inf`\n.. |nan| replace:: :py:obj:`nan`\n\n.. |bool| replace:: :py:class:`bool`\n.. |dict| replace:: :py:class:`dict`\n.. |int| replace:: :py:class:`int`\n.. |list| replace:: :py:class:`list`\n.. |float| replace:: :py:class:`float`\n.. |str| replace:: :py:class:`str`\n.. |tuple| replace:: :py:obj:`tuple`\n""""""\n\nrp_func = """"""\n.. |namedtuple| replace:: :py:func:`~collections.namedtuple`\n""""""\n\nrp_class = """"""\n.. |Connection| replace:: :py:class:`sqlite3.Connection`\n.. |datetime| replace:: :py:class:`datetime.datetime`\n.. |timedelta| replace:: :py:class:`datetime.timedelta`\n\n.. |Style| replace:: :py:class:`~pytablewriter.style.Style`\n.. |TableData| replace:: `TableData <https://tabledata.rtfd.io/en/latest/pages/reference/data.html#tabledata>`__\n.. |Typecode| replace:: :py:class:`typepy.Typecode`\n\n.. |CsvTableWriter| replace:: :py:class:`~pytablewriter.CsvTableWriter`\n.. |ElasticsearchWriter| replace:: :py:class:`~pytablewriter.ElasticsearchWriter`\n.. |ExcelXlsxTableWriter| replace:: :py:class:`~pytablewriter.ExcelXlsxTableWriter`\n.. |HtmlTableWriter| replace:: :py:class:`~pytablewriter.HtmlTableWriter`\n.. |JavaScriptTableWriter| replace:: :py:class:`~pytablewriter.JavaScriptTableWriter`\n.. |JsonTableWriter| replace:: :py:class:`~pytablewriter.JsonTableWriter`\n.. |LatexMatrixWriter| replace:: :py:class:`~pytablewriter.LatexMatrixWriter`\n.. |LatexTableWriter| replace:: :py:class:`~pytablewriter.LatexTableWriter`\n.. |LtsvTableWriter| replace:: :py:class:`~pytablewriter.LtsvTableWriter`\n.. |MarkdownTableWriter| replace:: :py:class:`~pytablewriter.MarkdownTableWriter`\n.. |MediaWikiTableWriter| replace:: :py:class:`~pytablewriter.MediaWikiTableWriter`\n.. |NumpyTableWriter| replace:: :py:class:`~pytablewriter.NumpyTableWriter`\n.. |PandasDataFrameWriter| replace:: :py:class:`~pytablewriter.PandasDataFrameWriter`\n.. |PythonCodeTableWriter| replace:: :py:class:`~pytablewriter.PythonCodeTableWriter`\n.. |RstCsvTableWriter| replace:: :py:class:`~pytablewriter.RstCsvTableWriter`\n.. |RstGridTableWriter| replace:: :py:class:`~pytablewriter.RstGridTableWriter`\n.. |RstSimpleTableWriter| replace:: :py:class:`~pytablewriter.RstSimpleTableWriter`\n.. |SpaceAlignedTableWriter| replace:: :py:class:`~pytablewriter.SpaceAlignedTableWriter`\n.. |SqliteTableWriter| replace:: :py:class:`~pytablewriter.SqliteTableWriter`\n.. |TsvTableWriter| replace:: :py:class:`~pytablewriter.TsvTableWriter`\n.. |TomlTableWriter| replace:: :py:class:`~pytablewriter.TomlTableWriter`\n.. |YamlTableWriter| replace:: :py:class:`~pytablewriter.YamlTableWriter`\n.. |UnicodeTableWriter| replace:: :py:class:`~pytablewriter.UnicodeTableWriter`\n""""""\n\nrp_module = """"""\n.. |sqlite3| replace:: :py:mod:`sqlite3`\n\n.. |package| replace:: pytablewriter\n""""""\n\nrp_attr = """"""\n.. |iteration_length| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.iteration_length`\n\n.. |stream| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.stream`\n\n.. |table_name| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.table_name`\n\n.. |headers| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.headers`\n\n.. |value_matrix| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.value_matrix`\n\n.. |write_callback| replace::\n    :py:attr:`~pytablewriter.writer._table_writer.AbstractTableWriter.write_callback`\n\n.. |column_delimiter| replace::\n    :py:attr:`~pytablewriter._text_writer.TextTableWriter.column_delimiter`\n\n.. |excel_attr| replace::\n    This attributes available after execution of\n    the :py:meth:`~.ExcelXlsxTableWriter.write_table` method.\n\n.. |is_datetime_instance_formatting| replace::\n    :py:attr:`~pytablewriter._text_writer.is_datetime_instance_formatting`\n""""""\n\nrp_method = """"""\n.. |write_table| replace:: Write a table to the |stream|\n\n.. |WriterNotFoundError_desc| replace::\n    If an appropriate writer not found for\n""""""\n\nrp_raises = """"""\n""""""\n\nrst_prolog = (\n    rp_common +\n    rp_builtin +\n    rp_func +\n    rp_class +\n    rp_module +\n    rp_raises +\n    rp_attr +\n    rp_method\n)\n'"
docs/make_readme.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport sys\n\nfrom path import Path\nfrom readmemaker import ReadmeMaker\n\n\nPROJECT_NAME = ""pytablewriter""\nOUTPUT_DIR = ""..""\n\n\ndef write_examples(maker: ReadmeMaker) -> None:\n    maker.set_indent_level(0)\n    maker.write_chapter(""Examples"")\n\n    examples_root = Path(""pages"").joinpath(""examples"")\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Write tables"")\n    maker.inc_indent_level()\n\n    maker.write_chapter(""Write a Markdown table"")\n    maker.write_file(examples_root.joinpath(""table_format"", ""text"", ""markdown_example.txt""))\n\n    maker.inc_indent_level()\n    maker.write_chapter(""Write a Markdown table with a margin"")\n    maker.write_file(\n        examples_root.joinpath(""table_format"", ""text"", ""markdown_example_with_margin.txt"")\n    )\n    maker.dec_indent_level()\n\n    maker.write_chapter(""Write a reStructuredText table (Grid Tables)"")\n    maker.write_file(\n        examples_root.joinpath(""table_format"", ""text"", ""rst"", ""rst_grid_table_example.txt"")\n    )\n\n    maker.write_chapter(\n        ""Write a table with JavaScript format (as a nested list variable definition)""\n    )\n    maker.write_file(\n        examples_root.joinpath(""table_format"", ""text"", ""sourcecode"", ""javascript_example.txt"")\n    )\n\n    maker.write_chapter(""Write a table to an Excel sheet"")\n    maker.write_file(\n        examples_root.joinpath(""table_format"", ""binary"", ""spreadsheet"", ""exel_single_example.txt"")\n    )\n\n    maker.write_chapter(""Write a Unicode table"")\n    maker.write_file(examples_root.joinpath(""table_format"", ""text"", ""unicode_example.txt""))\n\n    maker.write_chapter(""Write a Markdown table from ``pandas.DataFrame`` instance"")\n    maker.write_file(examples_root.joinpath(""datasource"", ""from_pandas_dataframe_example.txt""))\n\n    maker.write_chapter(""Write a markdown table from a space-separated values"")\n    maker.write_file(examples_root.joinpath(""datasource"", ""from_ssv_example.txt""))\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Get rendered tabular text as str"")\n    maker.write_file(examples_root.joinpath(""output"", ""dump"", ""dumps.txt""))\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Configure table styles"")\n    maker.inc_indent_level()\n    maker.write_chapter(""Column styles"")\n    maker.write_file(examples_root.joinpath(""style"", ""column_style_example.txt""))\n\n    maker.write_chapter(""Style filter"")\n    maker.write_lines(\n        [\n            ""Example:"",\n            """",\n            "".. figure:: ss/color_filter.png"",\n            ""    :scale: 60%"",\n            ""    :alt: true_color_and_styles"",\n        ]\n    )\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Make tables for specific applications"")\n    maker.inc_indent_level()\n\n    maker.write_chapter(""Render a table on Jupyter Notebook"")\n    maker.write_file(examples_root.joinpath(""jupyter_notebook"", ""jupyter_notebook_example.txt""))\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Multibyte character support"")\n    maker.inc_indent_level()\n\n    maker.write_chapter(""Write a table using multibyte character"")\n    maker.write_file(examples_root.joinpath(""multibyte"", ""multibyte_table_example.txt""))\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""Multi processing"")\n    maker.write_file(examples_root.joinpath(""customize"", ""multi_process.txt""))\n\n    # maker.write_chapter(""Create Elasticsearch index and put data"")\n    # maker.write_file(examples_root.joinpath(""table_format"", ""elasticsearch_example.txt""))\n\n    maker.set_indent_level(1)\n    maker.write_chapter(""For more information"")\n    maker.write_lines(\n        [\n            ""More examples are available at "",\n            ""https://{:s}.rtfd.io/en/latest/pages/examples/index.html"".format(PROJECT_NAME),\n        ]\n    )\n\n\ndef main():\n    maker = ReadmeMaker(\n        PROJECT_NAME,\n        OUTPUT_DIR,\n        is_make_toc=True,\n        project_url=""https://github.com/thombashi/{}"".format(PROJECT_NAME),\n    )\n\n    maker.write_chapter(""Summary"")\n    maker.write_introduction_file(""summary.txt"")\n    maker.write_introduction_file(""badges.txt"")\n    maker.write_introduction_file(""feature.txt"")\n\n    write_examples(maker)\n\n    maker.write_file(maker.doc_page_root_dir_path.joinpath(""installation.rst""))\n\n    maker.set_indent_level(0)\n    maker.write_chapter(""Documentation"")\n    maker.write_lines([""https://{:s}.rtfd.io/"".format(PROJECT_NAME)])\n\n    maker.write_file(maker.doc_page_root_dir_path.joinpath(""related.rst""))\n\n    return 0\n\n\nif __name__ == ""__main__"":\n    sys.exit(main())\n'"
pytablewriter/__init__.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom dataproperty import LineBreakHandling\nfrom typepy import (\n    Bool,\n    DateTime,\n    Dictionary,\n    Infinity,\n    Integer,\n    IpAddress,\n    List,\n    Nan,\n    NoneType,\n    NullString,\n    RealNumber,\n    String,\n)\n\nfrom .__version__ import __author__, __copyright__, __email__, __license__, __version__\nfrom ._factory import TableWriterFactory\nfrom ._function import dump_tabledata, dumps_tabledata\nfrom ._logger import set_log_level, set_logger\nfrom ._table_format import FormatAttr, TableFormat\nfrom .error import (\n    EmptyTableDataError,\n    EmptyTableNameError,\n    EmptyValueError,\n    NotSupportedError,\n    WriterNotFoundError,\n)\nfrom .style import Align, Format\nfrom .writer import (\n    AbstractTableWriter,\n    BoldUnicodeTableWriter,\n    BorderlessTableWriter,\n    CssTableWriter,\n    CsvTableWriter,\n    ElasticsearchWriter,\n    ExcelXlsTableWriter,\n    ExcelXlsxTableWriter,\n    HtmlTableWriter,\n    JavaScriptTableWriter,\n    JsonLinesTableWriter,\n    JsonTableWriter,\n    LatexMatrixWriter,\n    LatexTableWriter,\n    LtsvTableWriter,\n    MarkdownTableWriter,\n    MediaWikiTableWriter,\n    NullTableWriter,\n    NumpyTableWriter,\n    PandasDataFrameWriter,\n    PythonCodeTableWriter,\n    RstCsvTableWriter,\n    RstGridTableWriter,\n    RstSimpleTableWriter,\n    SpaceAlignedTableWriter,\n    SqliteTableWriter,\n    TomlTableWriter,\n    TsvTableWriter,\n    UnicodeTableWriter,\n    YamlTableWriter,\n)\n'"
pytablewriter/__version__.py,0,"b'__author__ = ""Tsuyoshi Hombashi""\n__copyright__ = ""Copyright 2016, {}"".format(__author__)\n__license__ = ""MIT License""\n__version__ = ""0.54.0""\n__maintainer__ = __author__\n__email__ = ""tsuyoshi.hombashi@gmail.com""\n'"
pytablewriter/_converter.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport re\n\n\ndef strip_quote(text: str, value: str) -> str:\n    re_replace = re.compile(""[\\""\']{:s}[\\""\']"".format(value), re.MULTILINE)\n\n    return re_replace.sub(value, text)\n'"
pytablewriter/_factory.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport os\nfrom typing import List\n\nimport typepy\n\nfrom ._logger import logger\nfrom ._table_format import FormatAttr, TableFormat\nfrom .error import WriterNotFoundError\nfrom .writer._table_writer import AbstractTableWriter\n\n\nclass TableWriterFactory:\n    """"""\n    A factor class of table writer classes.\n    """"""\n\n    @classmethod\n    def create_from_file_extension(cls, file_extension: str) -> AbstractTableWriter:\n        """"""\n        Create a table writer class instance from a file extension.\n        Supported file extensions are as follows:\n\n            ==================  ===================================\n            Extension           Writer Class\n            ==================  ===================================\n            ``"".css""``          :py:class:`~.CssTableWriter`\n            ``"".csv""``          :py:class:`~.CsvTableWriter`\n            ``"".htm""``          :py:class:`~.HtmlTableWriter`\n            ``"".html""``         :py:class:`~.HtmlTableWriter`\n            ``"".js""``           :py:class:`~.JavaScriptTableWriter`\n            ``"".json""``         :py:class:`~.JsonTableWriter`\n            ``"".jsonl""``        :py:class:`~.JsonLinesTableWriter`\n            ``"".ltsv""``         :py:class:`~.LtsvTableWriter`\n            ``"".ldjson""``       :py:class:`~.JsonLinesTableWriter`\n            ``"".md""``           :py:class:`~.MarkdownTableWriter`\n            ``"".ndjson""``       :py:class:`~.JsonLinesTableWriter`\n            ``"".py""``           :py:class:`~.PythonCodeTableWriter`\n            ``"".rst""``          :py:class:`~.RstGridTableWriter`\n            ``"".tsv""``          :py:class:`~.TsvTableWriter`\n            ``"".xls""``          :py:class:`~.ExcelXlsTableWriter`\n            ``"".xlsx""``         :py:class:`~.ExcelXlsxTableWriter`\n            ``"".sqlite""``       :py:class:`~.SqliteTableWriter`\n            ``"".sqlite3""``      :py:class:`~.SqliteTableWriter`\n            ``"".tsv""``          :py:class:`~.TsvTableWriter`\n            ``"".toml""``         :py:class:`~.TomlTableWriter`\n            ``"".yml""``          :py:class:`~.YamlTableWriter`\n            ==================  ===================================\n\n        :param str file_extension:\n            File extension string (case insensitive).\n        :return:\n            Writer instance that coincides with the ``file_extension``.\n        :rtype:\n            :py:class:`~pytablewriter.writer._table_writer.TableWriterInterface`\n        :raises pytablewriter.WriterNotFoundError:\n            |WriterNotFoundError_desc| the file extension.\n        """"""\n\n        ext = os.path.splitext(file_extension)[1]\n        if typepy.is_null_string(ext):\n            file_extension = file_extension\n        else:\n            file_extension = ext\n\n        file_extension = file_extension.lstrip(""."").lower()\n\n        for table_format in TableFormat:\n            if file_extension not in table_format.file_extensions:\n                continue\n\n            if table_format.format_attribute & FormatAttr.SECONDARY_EXT:\n                continue\n\n            logger.debug(""create a {} instance"".format(table_format.writer_class.__name__))\n\n            return table_format.writer_class()\n\n        raise WriterNotFoundError(\n            ""\\n"".join(\n                [\n                    ""{:s} (unknown file extension)."".format(file_extension),\n                    """",\n                    ""acceptable file extensions are: {}."".format("", "".join(cls.get_extensions())),\n                ]\n            )\n        )\n\n    @classmethod\n    def create_from_format_name(cls, format_name: str) -> AbstractTableWriter:\n        """"""\n        Create a table writer class instance from a format name.\n        Supported file format names are as follows:\n\n            =============================================  ===================================\n            Format name                                    Writer Class\n            =============================================  ===================================\n            ``""css""``                                      :py:class:`~.CssTableWriter`\n            ``""csv""``                                      :py:class:`~.CsvTableWriter`\n            ``""elasticsearch""``                            :py:class:`~.ElasticsearchWriter`\n            ``""excel""``                                    :py:class:`~.ExcelXlsxTableWriter`\n            ``""html""``/``""htm""``                           :py:class:`~.HtmlTableWriter`\n            ``""javascript""``/``""js""``                      :py:class:`~.JavaScriptTableWriter`\n            ``""json""``                                     :py:class:`~.JsonTableWriter`\n            ``""json_lines""``                               :py:class:`~.JsonLinesTableWriter`\n            ``""latex_matrix""``                             :py:class:`~.LatexMatrixWriter`\n            ``""latex_table""``                              :py:class:`~.LatexTableWriter`\n            ``""ldjson""``                                   :py:class:`~.JsonLinesTableWriter`\n            ``""ltsv""``                                     :py:class:`~.LtsvTableWriter`\n            ``""markdown""``/``""md""``                        :py:class:`~.MarkdownTableWriter`\n            ``""mediawiki""``                                :py:class:`~.MediaWikiTableWriter`\n            ``""null""``                                     :py:class:`~.NullTableWriter`\n            ``""pandas""``                                   :py:class:`~.PandasDataFrameWriter`\n            ``""py""``/``""python""``                          :py:class:`~.PythonCodeTableWriter`\n            ``""rst""``/``""rst_grid""``/``""rst_grid_table""``  :py:class:`~.RstGridTableWriter`\n            ``""rst_simple""``/``""rst_simple_table""``        :py:class:`~.RstSimpleTableWriter`\n            ``""rst_csv""``/``""rst_csv_table""``              :py:class:`~.RstCsvTableWriter`\n            ``""sqlite""``                                   :py:class:`~.SqliteTableWriter`\n            ``""tsv""``                                      :py:class:`~.TsvTableWriter`\n            ``""toml""``                                     :py:class:`~.TomlTableWriter`\n            ``""unicode""``                                  :py:class:`~.UnicodeTableWriter`\n            ``""yaml""``                                     :py:class:`~.YamlTableWriter`\n            =============================================  ===================================\n\n        :param str format_name: Format name string (case insensitive).\n        :return: Writer instance that coincides with the ``format_name``:\n        :rtype:\n            :py:class:`~pytablewriter.writer._table_writer.TableWriterInterface`\n        :raises pytablewriter.WriterNotFoundError:\n            |WriterNotFoundError_desc| for the format.\n        """"""\n\n        format_name = format_name.lower()\n\n        for table_format in TableFormat:\n            if format_name in table_format.names and not (\n                table_format.format_attribute & FormatAttr.SECONDARY_NAME\n            ):\n                logger.debug(""create a {} instance"".format(table_format.writer_class.__name__))\n\n                return table_format.writer_class()\n\n        raise WriterNotFoundError(\n            ""\\n"".join(\n                [\n                    ""{} (unknown format name)."".format(format_name),\n                    ""acceptable format names are: {}."".format("", "".join(cls.get_format_names())),\n                ]\n            )\n        )\n\n    @classmethod\n    def get_format_names(cls) -> List[str]:\n        """"""\n        :return: Available format names.\n        :rtype: list\n\n        :Example:\n            .. code:: python\n\n                >>> import pytablewriter as ptw\n                >>> for name in ptw.TableWriterFactory.get_format_names():\n                ...     print(name)\n                ...\n                css\n                csv\n                elasticsearch\n                excel\n                htm\n                html\n                javascript\n                js\n                json\n                json_lines\n                jsonl\n                latex_matrix\n                latex_table\n                ldjson\n                ltsv\n                markdown\n                md\n                mediawiki\n                ndjson\n                null\n                numpy\n                pandas\n                py\n                python\n                rst\n                rst_csv\n                rst_csv_table\n                rst_grid\n                rst_grid_table\n                rst_simple\n                rst_simple_table\n                space_aligned\n                sqlite\n                toml\n                tsv\n                unicode\n                yaml\n\n        """"""\n\n        format_name_set = set()\n        for table_format in TableFormat:\n            for format_name in table_format.names:\n                format_name_set.add(format_name)\n\n        return sorted(list(format_name_set))\n\n    @classmethod\n    def get_extensions(cls) -> List[str]:\n        """"""\n        :return: Available file extensions.\n        :rtype: list\n\n        :Example:\n            .. code:: python\n\n                >>> import pytablewriter as ptw\n                >>> for name in ptw.TableWriterFactory.get_extensions():\n                ...     print(name)\n                ...\n                css\n                csv\n                htm\n                html\n                js\n                json\n                jsonl\n                ldjson\n                ltsv\n                md\n                ndjson\n                py\n                rst\n                sqlite\n                sqlite3\n                tex\n                toml\n                tsv\n                xls\n                xlsx\n                yml\n        """"""\n\n        file_extension_set = set()\n        for table_format in TableFormat:\n            for file_extension in table_format.file_extensions:\n                file_extension_set.add(file_extension)\n\n        return sorted(list(file_extension_set))\n'"
pytablewriter/_function.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom enum import Enum\nfrom typing import Optional, Type\n\nimport dataproperty\nfrom pathvalidate import replace_symbol\nfrom tabledata._core import TableData\n\n\ndef quote_datetime_formatter(value) -> str:\n    return \'""{:s}""\'.format(value.strftime(dataproperty.DefaultValue.DATETIME_FORMAT))\n\n\ndef dateutil_datetime_formatter(value) -> str:\n    return \'dateutil.parser.parse(""{:s}"")\'.format(\n        value.strftime(dataproperty.DefaultValue.DATETIME_FORMAT)\n    )\n\n\ndef dumps_tabledata(value: TableData, format_name: str = ""rst_grid_table"", **kwargs) -> str:\n    """"""\n    :param tabledata.TableData value: Tabular data to dump.\n    :param str format_name:\n        Dumped format name of tabular data.\n        Available formats are described in\n        :py:meth:`~pytablewriter.TableWriterFactory.create_from_format_name`\n\n    :Example:\n        .. code:: python\n\n            >>> dumps_tabledata(value)\n            .. table:: sample_data\n\n                ======  ======  ======\n                attr_a  attr_b  attr_c\n                ======  ======  ======\n                     1     4.0  a\n                     2     2.1  bb\n                     3   120.9  ccc\n                ======  ======  ======\n    """"""\n\n    from ._factory import TableWriterFactory\n\n    if not value:\n        raise TypeError(""value must be a tabledata.TableData instance"")\n\n    writer = TableWriterFactory.create_from_format_name(format_name)\n\n    for attr_name, attr_value in kwargs.items():\n        setattr(writer, attr_name, attr_value)\n\n    writer.from_tabledata(value)\n\n    return writer.dumps()\n\n\ndef dump_tabledata(value, format_name=""rst_grid_table"", **kwargs):\n    # depreated: alias to dumps_tabledata()\n    return dumps_tabledata(value, format_name, **kwargs)\n\n\ndef normalize_enum(\n    value, enum_class: Type[Enum], validate: bool = True, default: Optional[Enum] = None\n):\n    if value is None:\n        return default\n\n    if isinstance(value, enum_class):\n        return value\n\n    try:\n        return enum_class[replace_symbol(value.strip(), ""_"").upper()]\n    except AttributeError:\n        if validate:\n            raise TypeError(\n                ""value must be a {} or a str: actual={}"".format(enum_class, type(value))\n            )\n    except KeyError:\n        if validate:\n            raise ValueError(\n                ""invalid valid found: expected={}, actual={}"".format(\n                    ""/"".join([item.name for item in enum_class]), value\n                )\n            )\n\n    return value\n'"
pytablewriter/_table_format.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport enum\nfrom typing import Any, List\n\nfrom .writer import (\n    BoldUnicodeTableWriter,\n    BorderlessTableWriter,\n    CssTableWriter,\n    CsvTableWriter,\n    ElasticsearchWriter,\n    ExcelXlsTableWriter,\n    ExcelXlsxTableWriter,\n    HtmlTableWriter,\n    JavaScriptTableWriter,\n    JsonLinesTableWriter,\n    JsonTableWriter,\n    LatexMatrixWriter,\n    LatexTableWriter,\n    LtsvTableWriter,\n    MarkdownTableWriter,\n    MediaWikiTableWriter,\n    NullTableWriter,\n    NumpyTableWriter,\n    PandasDataFrameWriter,\n    PythonCodeTableWriter,\n    RstCsvTableWriter,\n    RstGridTableWriter,\n    RstSimpleTableWriter,\n    SpaceAlignedTableWriter,\n    SqliteTableWriter,\n    TomlTableWriter,\n    TsvTableWriter,\n    UnicodeTableWriter,\n    YamlTableWriter,\n)\n\n\nclass FormatAttr:\n    """"""\n    Bitmaps to represent table attributes.\n    """"""\n\n    NONE = 1 << 1\n\n    #: Can create a file with the format.\n    FILE = 1 << 2\n\n    #: Table format that can represent as a text.\n    TEXT = 1 << 3\n\n    #: Table format that can represent as a binary file.\n    BIN = 1 << 4\n\n    #: Can create a source code (variables definition)\n    #: one of the programming language.\n    SOURCECODE = 1 << 5\n\n    #: Can call API for external service.\n    API = 1 << 6\n\n    SECONDARY_EXT = 1 << 10\n    SECONDARY_NAME = 1 << 11\n\n\n@enum.unique\nclass TableFormat(enum.Enum):\n    """"""\n    Enum to represent table format attributes.\n    """"""\n\n    CSV = ([CsvTableWriter.FORMAT_NAME], CsvTableWriter, FormatAttr.FILE | FormatAttr.TEXT, [""csv""])\n    CSS = (\n        [CssTableWriter.FORMAT_NAME],\n        CssTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""css""],\n    )\n    ELASTICSEARCH = (\n        [ElasticsearchWriter.FORMAT_NAME],  # type: ignore\n        ElasticsearchWriter,\n        FormatAttr.API,\n        [],\n    )\n    EXCEL_XLSX = (\n        [ExcelXlsxTableWriter.FORMAT_NAME],\n        ExcelXlsxTableWriter,\n        FormatAttr.FILE | FormatAttr.BIN,\n        [""xlsx""],\n    )\n    EXCEL_XLS = (\n        [ExcelXlsTableWriter.FORMAT_NAME],\n        ExcelXlsTableWriter,\n        FormatAttr.FILE | FormatAttr.BIN | FormatAttr.SECONDARY_NAME,\n        [""xls""],\n    )\n    HTML = (\n        [HtmlTableWriter.FORMAT_NAME, ""htm""],\n        HtmlTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""html"", ""htm""],\n    )\n    JAVASCRIPT = (\n        [JavaScriptTableWriter.FORMAT_NAME, ""js""],\n        JavaScriptTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SOURCECODE,\n        [""js""],\n    )\n    JSON = (\n        [JsonTableWriter.FORMAT_NAME],\n        JsonTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""json""],\n    )\n    JSON_LINES = (\n        [JsonLinesTableWriter.FORMAT_NAME, ""jsonl"", ""ldjson"", ""ndjson""],\n        JsonLinesTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""jsonl"", ""ldjson"", ""ndjson""],\n    )\n    LATEX_MATRIX = (\n        [LatexMatrixWriter.FORMAT_NAME],\n        LatexMatrixWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""tex""],\n    )\n    LATEX_TABLE = (\n        [LatexTableWriter.FORMAT_NAME],\n        LatexTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SECONDARY_EXT,\n        [""tex""],\n    )\n    LTSV = (\n        [LtsvTableWriter.FORMAT_NAME],\n        LtsvTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""ltsv""],\n    )\n    MARKDOWN = (\n        [MarkdownTableWriter.FORMAT_NAME, ""md""],\n        MarkdownTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""md""],\n    )\n    MEDIAWIKI = (\n        [MediaWikiTableWriter.FORMAT_NAME],  # type: ignore\n        MediaWikiTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [],\n    )\n    NULL = (\n        [NullTableWriter.FORMAT_NAME],  # type: ignore\n        NullTableWriter,\n        FormatAttr.NONE,\n        [],\n    )\n    NUMPY = (\n        [NumpyTableWriter.FORMAT_NAME],\n        NumpyTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SOURCECODE | FormatAttr.SECONDARY_EXT,\n        [""py""],\n    )\n    PANDAS = (\n        [PandasDataFrameWriter.FORMAT_NAME],\n        PandasDataFrameWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SOURCECODE | FormatAttr.SECONDARY_EXT,\n        [""py""],\n    )\n    PYTHON = (\n        [PythonCodeTableWriter.FORMAT_NAME, ""py""],\n        PythonCodeTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SOURCECODE,\n        [""py""],\n    )\n    RST_CSV_TABLE = (\n        [RstCsvTableWriter.FORMAT_NAME, ""rst_csv""],\n        RstCsvTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SECONDARY_EXT,\n        [""rst""],\n    )\n    RST_GRID_TABLE = (\n        [RstGridTableWriter.FORMAT_NAME, ""rst_grid"", ""rst""],\n        RstGridTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""rst""],\n    )\n    RST_SIMPLE_TABLE = (\n        [RstSimpleTableWriter.FORMAT_NAME, ""rst_simple""],\n        RstSimpleTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT | FormatAttr.SECONDARY_EXT,\n        [""rst""],\n    )\n    SPACE_ALIGNED = (\n        [SpaceAlignedTableWriter.FORMAT_NAME],  # type: ignore\n        SpaceAlignedTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [],\n    )\n    SQLITE = (\n        [SqliteTableWriter.FORMAT_NAME],\n        SqliteTableWriter,\n        FormatAttr.FILE | FormatAttr.BIN,\n        [""sqlite"", ""sqlite3""],\n    )\n    TOML = (\n        [TomlTableWriter.FORMAT_NAME],\n        TomlTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""toml""],\n    )\n    TSV = ([TsvTableWriter.FORMAT_NAME], TsvTableWriter, FormatAttr.FILE | FormatAttr.TEXT, [""tsv""])\n    UNICODE = (\n        [UnicodeTableWriter.FORMAT_NAME],  # type: ignore\n        UnicodeTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [],\n    )\n    YAML = (\n        [YamlTableWriter.FORMAT_NAME],\n        YamlTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [""yml""],\n    )\n    BOLD_UNICODE = (\n        [BoldUnicodeTableWriter.FORMAT_NAME],  # type: ignore\n        BoldUnicodeTableWriter,\n        FormatAttr.FILE | FormatAttr.TEXT,\n        [],\n    )\n    BORDERLESS = (\n        [BorderlessTableWriter.FORMAT_NAME],  # type: ignore\n        BorderlessTableWriter,\n        FormatAttr.TEXT,\n        [],\n    )\n\n    @property\n    def names(self) -> List[str]:\n        """"""Names associated with the table format.\n\n        Returns:\n            List[str]: format names\n        """"""\n\n        return self.__names\n\n    @property\n    def writer_class(self) -> Any:\n        """"""Table writer class associated with the table format.\n\n        Returns:\n            Type[AbstractTableWriter]:\n        """"""\n\n        return self.__writer_class\n\n    @property\n    def format_attribute(self) -> int:\n        """"""Table attributes bitmap.\n\n        Returns:\n            :py:class:`pytablewriter.FormatAttr`:\n        """"""\n\n        return self.__format_attribute\n\n    @property\n    def file_extensions(self) -> List[str]:\n        """"""File extensions associated with the table format.\n\n        Returns:\n            List[str]:\n        """"""\n\n        return self.__file_extensions\n\n    def __init__(self, names, writer_class, format_attribute, file_extensions):\n        self.__names = names\n        self.__writer_class = writer_class\n        self.__format_attribute = format_attribute\n        self.__file_extensions = file_extensions\n\n    @classmethod\n    def find_all_attr(cls, format_attribute: int) -> List:\n        """"""Searching table formats which have specific attributes.\n\n        Args:\n            format_attribute (FormatAttr):\n                Table format attributes to look for.\n\n        Returns:\n            List[TableFormat]: Table formats that matched the attribute.\n        """"""\n\n        return [\n            table_format\n            for table_format in TableFormat\n            if table_format.format_attribute & format_attribute\n        ]\n\n    @classmethod\n    def from_name(cls, format_name: str):\n        """"""Get a table format from a name.\n\n        Args:\n            format_name (str): Table format specifier.\n\n        Returns:\n            Optional[TableFormat]: A table format enum value corresponding to the ``format_name``.\n        """"""\n\n        format_name = format_name.lower().strip()\n\n        for table_format in TableFormat:\n            if format_name in table_format.names:\n                return table_format\n\n        return None\n'"
pytablewriter/_typing.py,0,"b'""""""\nsource code from: python/typing/typing_extensions/src_py3/typing_extensions.py\ntag: 3.7.4.1\n\nCopyright (c) 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,\n2011, 2012, 2013, 2014 Python Software Foundation; All Rights Reserved\n\nhttps://github.com/python/typing/blob/3.7.4.1/LICENSE\n""""""\n\nimport abc\nimport collections\nimport contextlib\nimport sys\nimport typing\nimport collections.abc as collections_abc\nimport operator\n\n# These are used by Protocol implementation\n# We use internal typing helpers here, but this significantly reduces\n# code duplication. (Also this is only until Protocol is in typing.)\nfrom typing import Generic, Callable, TypeVar, Tuple\n\n# After PEP 560, internal typing API was substantially reworked.\n# This is especially important for Protocol class which uses internal APIs\n# quite extensivelly.\nPEP_560 = sys.version_info[:3] >= (3, 7, 0)\n\nif PEP_560:\n    GenericMeta = TypingMeta = type\nelse:\n    from typing import GenericMeta, TypingMeta\nOLD_GENERICS = False\ntry:\n    from typing import _type_vars, _next_in_mro, _type_check\nexcept ImportError:\n    OLD_GENERICS = True\ntry:\n    from typing import _subs_tree  # noqa\n    SUBS_TREE = True\nexcept ImportError:\n    SUBS_TREE = False\ntry:\n    from typing import _tp_cache\nexcept ImportError:\n    def _tp_cache(x):\n        return x\ntry:\n    from typing import _TypingEllipsis, _TypingEmpty\nexcept ImportError:\n    class _TypingEllipsis:\n        pass\n\n    class _TypingEmpty:\n        pass\n\n\n# The two functions below are copies of typing internal helpers.\n# They are needed by _ProtocolMeta\n\n\ndef _no_slots_copy(dct):\n    dict_copy = dict(dct)\n    if \'__slots__\' in dict_copy:\n        for slot in dict_copy[\'__slots__\']:\n            dict_copy.pop(slot, None)\n    return dict_copy\n\n\ndef _check_generic(cls, parameters):\n    if not cls.__parameters__:\n        raise TypeError(""%s is not a generic class"" % repr(cls))\n    alen = len(parameters)\n    elen = len(cls.__parameters__)\n    if alen != elen:\n        raise TypeError(""Too %s parameters for %s; actual %s, expected %s"" %\n                        (""many"" if alen > elen else ""few"", repr(cls), alen, elen))\n\n\nif hasattr(typing, \'_generic_new\'):\n    _generic_new = typing._generic_new\nelse:\n    # Note: The \'_generic_new(...)\' function is used as a part of the\n    # process of creating a generic type and was added to the typing module\n    # as of Python 3.5.3.\n    #\n    # We\'ve defined \'_generic_new(...)\' below to exactly match the behavior\n    # implemented in older versions of \'typing\' bundled with Python 3.5.0 to\n    # 3.5.2. This helps eliminate redundancy when defining collection types\n    # like \'Deque\' later.\n    #\n    # See https://github.com/python/typing/pull/308 for more details -- in\n    # particular, compare and contrast the definition of types like\n    # \'typing.List\' before and after the merge.\n\n    def _generic_new(base_cls, cls, *args, **kwargs):\n        return base_cls.__new__(cls, *args, **kwargs)\n\n# See https://github.com/python/typing/pull/439\nif hasattr(typing, \'_geqv\'):\n    from typing import _geqv\n    _geqv_defined = True\nelse:\n    _geqv = None\n    _geqv_defined = False\n\nif sys.version_info[:2] >= (3, 6):\n    import _collections_abc\n    _check_methods_in_mro = _collections_abc._check_methods\nelse:\n    def _check_methods_in_mro(C, *methods):\n        mro = C.__mro__\n        for method in methods:\n            for B in mro:\n                if method in B.__dict__:\n                    if B.__dict__[method] is None:\n                        return NotImplemented\n                    break\n            else:\n                return NotImplemented\n        return True\n\n\n# Please keep __all__ alphabetized within each category.\n__all__ = [\n    # Super-special typing primitives.\n    \'ClassVar\',\n    \'Final\',\n    \'Type\',\n\n    # ABCs (from collections.abc).\n    # The following are added depending on presence\n    # of their non-generic counterparts in stdlib:\n    # \'Awaitable\',\n    # \'AsyncIterator\',\n    # \'AsyncIterable\',\n    # \'Coroutine\',\n    # \'AsyncGenerator\',\n    # \'AsyncContextManager\',\n    # \'ChainMap\',\n\n    # Concrete collection types.\n    \'ContextManager\',\n    \'Counter\',\n    \'Deque\',\n    \'DefaultDict\',\n    \'TypedDict\',\n\n    # One-off things.\n    \'final\',\n    \'IntVar\',\n    \'Literal\',\n    \'NewType\',\n    \'overload\',\n    \'Text\',\n    \'TYPE_CHECKING\',\n]\n\n# Annotated relies on substitution trees of pep 560. It will not work for\n# versions of typing older than 3.5.3\nHAVE_ANNOTATED = PEP_560 or SUBS_TREE\n\nif PEP_560:\n    __all__.append(""get_type_hints"")\n\nif HAVE_ANNOTATED:\n    __all__.append(""Annotated"")\n\n# Protocols are hard to backport to the original version of typing 3.5.0\nHAVE_PROTOCOLS = sys.version_info[:3] != (3, 5, 0)\n\nif HAVE_PROTOCOLS:\n    __all__.extend([\'Protocol\', \'runtime\', \'runtime_checkable\'])\n\n\n# TODO\nif hasattr(typing, \'NoReturn\'):\n    NoReturn = typing.NoReturn\nelif hasattr(typing, \'_FinalTypingBase\'):\n    class _NoReturn(typing._FinalTypingBase, _root=True):\n        """"""Special type indicating functions that never return.\n        Example::\n\n          from typing import NoReturn\n\n          def stop() -> NoReturn:\n              raise Exception(\'no way\')\n\n        This type is invalid in other positions, e.g., ``List[NoReturn]``\n        will fail in static type checkers.\n        """"""\n        __slots__ = ()\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""NoReturn cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""NoReturn cannot be used with issubclass()."")\n\n    NoReturn = _NoReturn(_root=True)\nelse:\n    class _NoReturnMeta(typing.TypingMeta):\n        """"""Metaclass for NoReturn""""""\n        def __new__(cls, name, bases, namespace, _root=False):\n            return super().__new__(cls, name, bases, namespace, _root=_root)\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""NoReturn cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""NoReturn cannot be used with issubclass()."")\n\n    class NoReturn(typing.Final, metaclass=_NoReturnMeta, _root=True):\n        """"""Special type indicating functions that never return.\n        Example::\n\n          from typing import NoReturn\n\n          def stop() -> NoReturn:\n              raise Exception(\'no way\')\n\n        This type is invalid in other positions, e.g., ``List[NoReturn]``\n        will fail in static type checkers.\n        """"""\n        __slots__ = ()\n\n\n# Some unconstrained type variables.  These are used by the container types.\n# (These are not for export.)\nT = typing.TypeVar(\'T\')  # Any type.\nKT = typing.TypeVar(\'KT\')  # Key type.\nVT = typing.TypeVar(\'VT\')  # Value type.\nT_co = typing.TypeVar(\'T_co\', covariant=True)  # Any type covariant containers.\nV_co = typing.TypeVar(\'V_co\', covariant=True)  # Any type covariant containers.\nVT_co = typing.TypeVar(\'VT_co\', covariant=True)  # Value type covariant containers.\nT_contra = typing.TypeVar(\'T_contra\', contravariant=True)  # Ditto contravariant.\n\n\nif hasattr(typing, \'ClassVar\'):\n    ClassVar = typing.ClassVar\nelif hasattr(typing, \'_FinalTypingBase\'):\n    class _ClassVar(typing._FinalTypingBase, _root=True):\n        """"""Special type construct to mark class variables.\n\n        An annotation wrapped in ClassVar indicates that a given\n        attribute is intended to be used as a class variable and\n        should not be set on instances of that class. Usage::\n\n          class Starship:\n              stats: ClassVar[Dict[str, int]] = {} # class variable\n              damage: int = 10                     # instance variable\n\n        ClassVar accepts only types and cannot be further subscribed.\n\n        Note that ClassVar is not a class itself, and should not\n        be used with isinstance() or issubclass().\n        """"""\n\n        __slots__ = (\'__type__\',)\n\n        def __init__(self, tp=None, **kwds):\n            self.__type__ = tp\n\n        def __getitem__(self, item):\n            cls = type(self)\n            if self.__type__ is None:\n                return cls(typing._type_check(item,\n                           \'{} accepts only single type.\'.format(cls.__name__[1:])),\n                           _root=True)\n            raise TypeError(\'{} cannot be further subscripted\'\n                            .format(cls.__name__[1:]))\n\n        def _eval_type(self, globalns, localns):\n            new_tp = typing._eval_type(self.__type__, globalns, localns)\n            if new_tp == self.__type__:\n                return self\n            return type(self)(new_tp, _root=True)\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__type__ is not None:\n                r += \'[{}]\'.format(typing._type_repr(self.__type__))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__type__))\n\n        def __eq__(self, other):\n            if not isinstance(other, _ClassVar):\n                return NotImplemented\n            if self.__type__ is not None:\n                return self.__type__ == other.__type__\n            return self is other\n\n    ClassVar = _ClassVar(_root=True)\nelse:\n    class _ClassVarMeta(typing.TypingMeta):\n        """"""Metaclass for ClassVar""""""\n\n        def __new__(cls, name, bases, namespace, tp=None, _root=False):\n            self = super().__new__(cls, name, bases, namespace, _root=_root)\n            if tp is not None:\n                self.__type__ = tp\n            return self\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""ClassVar cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""ClassVar cannot be used with issubclass()."")\n\n        def __getitem__(self, item):\n            cls = type(self)\n            if self.__type__ is not None:\n                raise TypeError(\'{} cannot be further subscripted\'\n                                .format(cls.__name__[1:]))\n\n            param = typing._type_check(\n                item,\n                \'{} accepts only single type.\'.format(cls.__name__[1:]))\n            return cls(self.__name__, self.__bases__,\n                       dict(self.__dict__), tp=param, _root=True)\n\n        def _eval_type(self, globalns, localns):\n            new_tp = typing._eval_type(self.__type__, globalns, localns)\n            if new_tp == self.__type__:\n                return self\n            return type(self)(self.__name__, self.__bases__,\n                              dict(self.__dict__), tp=self.__type__,\n                              _root=True)\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__type__ is not None:\n                r += \'[{}]\'.format(typing._type_repr(self.__type__))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__type__))\n\n        def __eq__(self, other):\n            if not isinstance(other, ClassVar):\n                return NotImplemented\n            if self.__type__ is not None:\n                return self.__type__ == other.__type__\n            return self is other\n\n    class ClassVar(typing.Final, metaclass=_ClassVarMeta, _root=True):\n        """"""Special type construct to mark class variables.\n\n        An annotation wrapped in ClassVar indicates that a given\n        attribute is intended to be used as a class variable and\n        should not be set on instances of that class. Usage::\n\n          class Starship:\n              stats: ClassVar[Dict[str, int]] = {} # class variable\n              damage: int = 10                     # instance variable\n\n        ClassVar accepts only types and cannot be further subscribed.\n\n        Note that ClassVar is not a class itself, and should not\n        be used with isinstance() or issubclass().\n        """"""\n\n        __type__ = None\n\n# On older versions of typing there is an internal class named ""Final"".\nif hasattr(typing, \'Final\') and sys.version_info[:2] >= (3, 7):\n    Final = typing.Final\nelif sys.version_info[:2] >= (3, 7):\n    class _FinalForm(typing._SpecialForm, _root=True):\n\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n\n        def __getitem__(self, parameters):\n            item = typing._type_check(parameters,\n                                      \'{} accepts only single type\'.format(self._name))\n            return _GenericAlias(self, (item,))\n\n    Final = _FinalForm(\'Final\',\n                       doc=""""""A special typing construct to indicate that a name\n                       cannot be re-assigned or overridden in a subclass.\n                       For example:\n\n                           MAX_SIZE: Final = 9000\n                           MAX_SIZE += 1  # Error reported by type checker\n\n                           class Connection:\n                               TIMEOUT: Final[int] = 10\n                           class FastConnector(Connection):\n                               TIMEOUT = 1  # Error reported by type checker\n\n                       There is no runtime checking of these properties."""""")\nelif hasattr(typing, \'_FinalTypingBase\'):\n    class _Final(typing._FinalTypingBase, _root=True):\n        """"""A special typing construct to indicate that a name\n        cannot be re-assigned or overridden in a subclass.\n        For example:\n\n            MAX_SIZE: Final = 9000\n            MAX_SIZE += 1  # Error reported by type checker\n\n            class Connection:\n                TIMEOUT: Final[int] = 10\n            class FastConnector(Connection):\n                TIMEOUT = 1  # Error reported by type checker\n\n        There is no runtime checking of these properties.\n        """"""\n\n        __slots__ = (\'__type__\',)\n\n        def __init__(self, tp=None, **kwds):\n            self.__type__ = tp\n\n        def __getitem__(self, item):\n            cls = type(self)\n            if self.__type__ is None:\n                return cls(typing._type_check(item,\n                           \'{} accepts only single type.\'.format(cls.__name__[1:])),\n                           _root=True)\n            raise TypeError(\'{} cannot be further subscripted\'\n                            .format(cls.__name__[1:]))\n\n        def _eval_type(self, globalns, localns):\n            new_tp = typing._eval_type(self.__type__, globalns, localns)\n            if new_tp == self.__type__:\n                return self\n            return type(self)(new_tp, _root=True)\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__type__ is not None:\n                r += \'[{}]\'.format(typing._type_repr(self.__type__))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__type__))\n\n        def __eq__(self, other):\n            if not isinstance(other, _Final):\n                return NotImplemented\n            if self.__type__ is not None:\n                return self.__type__ == other.__type__\n            return self is other\n\n    Final = _Final(_root=True)\nelse:\n    class _FinalMeta(typing.TypingMeta):\n        """"""Metaclass for Final""""""\n\n        def __new__(cls, name, bases, namespace, tp=None, _root=False):\n            self = super().__new__(cls, name, bases, namespace, _root=_root)\n            if tp is not None:\n                self.__type__ = tp\n            return self\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""Final cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""Final cannot be used with issubclass()."")\n\n        def __getitem__(self, item):\n            cls = type(self)\n            if self.__type__ is not None:\n                raise TypeError(\'{} cannot be further subscripted\'\n                                .format(cls.__name__[1:]))\n\n            param = typing._type_check(\n                item,\n                \'{} accepts only single type.\'.format(cls.__name__[1:]))\n            return cls(self.__name__, self.__bases__,\n                       dict(self.__dict__), tp=param, _root=True)\n\n        def _eval_type(self, globalns, localns):\n            new_tp = typing._eval_type(self.__type__, globalns, localns)\n            if new_tp == self.__type__:\n                return self\n            return type(self)(self.__name__, self.__bases__,\n                              dict(self.__dict__), tp=self.__type__,\n                              _root=True)\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__type__ is not None:\n                r += \'[{}]\'.format(typing._type_repr(self.__type__))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__type__))\n\n        def __eq__(self, other):\n            if not isinstance(other, Final):\n                return NotImplemented\n            if self.__type__ is not None:\n                return self.__type__ == other.__type__\n            return self is other\n\n    class Final(typing.Final, metaclass=_FinalMeta, _root=True):\n        """"""A special typing construct to indicate that a name\n        cannot be re-assigned or overridden in a subclass.\n        For example:\n\n            MAX_SIZE: Final = 9000\n            MAX_SIZE += 1  # Error reported by type checker\n\n            class Connection:\n                TIMEOUT: Final[int] = 10\n            class FastConnector(Connection):\n                TIMEOUT = 1  # Error reported by type checker\n\n        There is no runtime checking of these properties.\n        """"""\n\n        __type__ = None\n\n\nif hasattr(typing, \'final\'):\n    final = typing.final\nelse:\n    def final(f):\n        """"""This decorator can be used to indicate to type checkers that\n        the decorated method cannot be overridden, and decorated class\n        cannot be subclassed. For example:\n\n            class Base:\n                @final\n                def done(self) -> None:\n                    ...\n            class Sub(Base):\n                def done(self) -> None:  # Error reported by type checker\n                    ...\n            @final\n            class Leaf:\n                ...\n            class Other(Leaf):  # Error reported by type checker\n                ...\n\n        There is no runtime checking of these properties.\n        """"""\n        return f\n\n\ndef IntVar(name):\n    return TypeVar(name)\n\n\nif hasattr(typing, \'Literal\'):\n    Literal = typing.Literal\nelif sys.version_info[:2] >= (3, 7):\n    class _LiteralForm(typing._SpecialForm, _root=True):\n\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n\n        def __getitem__(self, parameters):\n            return _GenericAlias(self, parameters)\n\n    Literal = _LiteralForm(\'Literal\',\n                           doc=""""""A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n\n                               var: Literal[4] = 4\n\n                           The type checker understands that \'var\' is literally equal to\n                           the value 4 and no other value.\n\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type."""""")\nelif hasattr(typing, \'_FinalTypingBase\'):\n    class _Literal(typing._FinalTypingBase, _root=True):\n        """"""A type that can be used to indicate to type checkers that the\n        corresponding value has a value literally equivalent to the\n        provided parameter. For example:\n\n            var: Literal[4] = 4\n\n        The type checker understands that \'var\' is literally equal to the\n        value 4 and no other value.\n\n        Literal[...] cannot be subclassed. There is no runtime checking\n        verifying that the parameter is actually a value instead of a type.\n        """"""\n\n        __slots__ = (\'__values__\',)\n\n        def __init__(self, values=None, **kwds):\n            self.__values__ = values\n\n        def __getitem__(self, values):\n            cls = type(self)\n            if self.__values__ is None:\n                if not isinstance(values, tuple):\n                    values = (values,)\n                return cls(values, _root=True)\n            raise TypeError(\'{} cannot be further subscripted\'\n                            .format(cls.__name__[1:]))\n\n        def _eval_type(self, globalns, localns):\n            return self\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__values__ is not None:\n                r += \'[{}]\'.format(\', \'.join(map(typing._type_repr, self.__values__)))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__values__))\n\n        def __eq__(self, other):\n            if not isinstance(other, _Literal):\n                return NotImplemented\n            if self.__values__ is not None:\n                return self.__values__ == other.__values__\n            return self is other\n\n    Literal = _Literal(_root=True)\nelse:\n    class _LiteralMeta(typing.TypingMeta):\n        """"""Metaclass for Literal""""""\n\n        def __new__(cls, name, bases, namespace, values=None, _root=False):\n            self = super().__new__(cls, name, bases, namespace, _root=_root)\n            if values is not None:\n                self.__values__ = values\n            return self\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""Literal cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""Literal cannot be used with issubclass()."")\n\n        def __getitem__(self, item):\n            cls = type(self)\n            if self.__values__ is not None:\n                raise TypeError(\'{} cannot be further subscripted\'\n                                .format(cls.__name__[1:]))\n\n            if not isinstance(item, tuple):\n                item = (item,)\n            return cls(self.__name__, self.__bases__,\n                       dict(self.__dict__), values=item, _root=True)\n\n        def _eval_type(self, globalns, localns):\n            return self\n\n        def __repr__(self):\n            r = super().__repr__()\n            if self.__values__ is not None:\n                r += \'[{}]\'.format(\', \'.join(map(typing._type_repr, self.__values__)))\n            return r\n\n        def __hash__(self):\n            return hash((type(self).__name__, self.__values__))\n\n        def __eq__(self, other):\n            if not isinstance(other, Literal):\n                return NotImplemented\n            if self.__values__ is not None:\n                return self.__values__ == other.__values__\n            return self is other\n\n    class Literal(typing.Final, metaclass=_LiteralMeta, _root=True):\n        """"""A type that can be used to indicate to type checkers that the\n        corresponding value has a value literally equivalent to the\n        provided parameter. For example:\n\n            var: Literal[4] = 4\n\n        The type checker understands that \'var\' is literally equal to the\n        value 4 and no other value.\n\n        Literal[...] cannot be subclassed. There is no runtime checking\n        verifying that the parameter is actually a value instead of a type.\n        """"""\n\n        __values__ = None\n\n\ndef _overload_dummy(*args, **kwds):\n    """"""Helper for @overload to raise when called.""""""\n    raise NotImplementedError(\n        ""You should not call an overloaded function. ""\n        ""A series of @overload-decorated functions ""\n        ""outside a stub module should always be followed ""\n        ""by an implementation that is not @overload-ed."")\n\n\ndef overload(func):\n    """"""Decorator for overloaded functions/methods.\n\n    In a stub file, place two or more stub definitions for the same\n    function in a row, each decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n\n    In a non-stub file (i.e. a regular .py file), do the same but\n    follow it with an implementation.  The implementation should *not*\n    be decorated with @overload.  For example:\n\n      @overload\n      def utf8(value: None) -> None: ...\n      @overload\n      def utf8(value: bytes) -> bytes: ...\n      @overload\n      def utf8(value: str) -> bytes: ...\n      def utf8(value):\n          # implementation goes here\n    """"""\n    return _overload_dummy\n\n\n# This is not a real generic class.  Don\'t use outside annotations.\nif hasattr(typing, \'Type\'):\n    Type = typing.Type\nelse:\n    # Internal type variable used for Type[].\n    CT_co = typing.TypeVar(\'CT_co\', covariant=True, bound=type)\n\n    class Type(typing.Generic[CT_co], extra=type):\n        """"""A special construct usable to annotate class objects.\n\n        For example, suppose we have the following classes::\n\n          class User: ...  # Abstract base for User classes\n          class BasicUser(User): ...\n          class ProUser(User): ...\n          class TeamUser(User): ...\n\n        And a function that takes a class argument that\'s a subclass of\n        User and returns an instance of the corresponding class::\n\n          U = TypeVar(\'U\', bound=User)\n          def new_user(user_class: Type[U]) -> U:\n              user = user_class()\n              # (Here we could write the user object to a database)\n              return user\n          joe = new_user(BasicUser)\n\n        At this point the type checker knows that joe has type BasicUser.\n        """"""\n\n        __slots__ = ()\n\n\n# Various ABCs mimicking those in collections.abc.\n# A few are simply re-exported for completeness.\n\ndef _define_guard(type_name):\n    """"""\n    Returns True if the given type isn\'t defined in typing but\n    is defined in collections_abc.\n\n    Adds the type to __all__ if the collection is found in either\n    typing or collection_abc.\n    """"""\n    if hasattr(typing, type_name):\n        __all__.append(type_name)\n        globals()[type_name] = getattr(typing, type_name)\n        return False\n    elif hasattr(collections_abc, type_name):\n        __all__.append(type_name)\n        return True\n    else:\n        return False\n\n\nclass _ExtensionsGenericMeta(GenericMeta):\n    def __subclasscheck__(self, subclass):\n        """"""This mimics a more modern GenericMeta.__subclasscheck__() logic\n        (that does not have problems with recursion) to work around interactions\n        between collections, typing, and typing_extensions on older\n        versions of Python, see https://github.com/python/typing/issues/501.\n        """"""\n        if sys.version_info[:3] >= (3, 5, 3) or sys.version_info[:3] < (3, 5, 0):\n            if self.__origin__ is not None:\n                if sys._getframe(1).f_globals[\'__name__\'] not in [\'abc\', \'functools\']:\n                    raise TypeError(""Parameterized generics cannot be used with class ""\n                                    ""or instance checks"")\n                return False\n        if not self.__extra__:\n            return super().__subclasscheck__(subclass)\n        res = self.__extra__.__subclasshook__(subclass)\n        if res is not NotImplemented:\n            return res\n        if self.__extra__ in subclass.__mro__:\n            return True\n        for scls in self.__extra__.__subclasses__():\n            if isinstance(scls, GenericMeta):\n                continue\n            if issubclass(subclass, scls):\n                return True\n        return False\n\n\nif _define_guard(\'Awaitable\'):\n    class Awaitable(typing.Generic[T_co], metaclass=_ExtensionsGenericMeta,\n                    extra=collections_abc.Awaitable):\n        __slots__ = ()\n\n\nif _define_guard(\'Coroutine\'):\n    class Coroutine(Awaitable[V_co], typing.Generic[T_co, T_contra, V_co],\n                    metaclass=_ExtensionsGenericMeta,\n                    extra=collections_abc.Coroutine):\n        __slots__ = ()\n\n\nif _define_guard(\'AsyncIterable\'):\n    class AsyncIterable(typing.Generic[T_co],\n                        metaclass=_ExtensionsGenericMeta,\n                        extra=collections_abc.AsyncIterable):\n        __slots__ = ()\n\n\nif _define_guard(\'AsyncIterator\'):\n    class AsyncIterator(AsyncIterable[T_co],\n                        metaclass=_ExtensionsGenericMeta,\n                        extra=collections_abc.AsyncIterator):\n        __slots__ = ()\n\n\nif hasattr(typing, \'Deque\'):\n    Deque = typing.Deque\nelif _geqv_defined:\n    class Deque(collections.deque, typing.MutableSequence[T],\n                metaclass=_ExtensionsGenericMeta,\n                extra=collections.deque):\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if _geqv(cls, Deque):\n                return collections.deque(*args, **kwds)\n            return _generic_new(collections.deque, cls, *args, **kwds)\nelse:\n    class Deque(collections.deque, typing.MutableSequence[T],\n                metaclass=_ExtensionsGenericMeta,\n                extra=collections.deque):\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if cls._gorg is Deque:\n                return collections.deque(*args, **kwds)\n            return _generic_new(collections.deque, cls, *args, **kwds)\n\n\nif hasattr(typing, \'ContextManager\'):\n    ContextManager = typing.ContextManager\nelif hasattr(contextlib, \'AbstractContextManager\'):\n    class ContextManager(typing.Generic[T_co],\n                         metaclass=_ExtensionsGenericMeta,\n                         extra=contextlib.AbstractContextManager):\n        __slots__ = ()\nelse:\n    class ContextManager(typing.Generic[T_co]):\n        __slots__ = ()\n\n        def __enter__(self):\n            return self\n\n        @abc.abstractmethod\n        def __exit__(self, exc_type, exc_value, traceback):\n            return None\n\n        @classmethod\n        def __subclasshook__(cls, C):\n            if cls is ContextManager:\n                # In Python 3.6+, it is possible to set a method to None to\n                # explicitly indicate that the class does not implement an ABC\n                # (https://bugs.python.org/issue25958), but we do not support\n                # that pattern here because this fallback class is only used\n                # in Python 3.5 and earlier.\n                if (any(""__enter__"" in B.__dict__ for B in C.__mro__) and\n                    any(""__exit__"" in B.__dict__ for B in C.__mro__)):\n                    return True\n            return NotImplemented\n\n\nif hasattr(typing, \'AsyncContextManager\'):\n    AsyncContextManager = typing.AsyncContextManager\n    __all__.append(\'AsyncContextManager\')\nelif hasattr(contextlib, \'AbstractAsyncContextManager\'):\n    class AsyncContextManager(typing.Generic[T_co],\n                              metaclass=_ExtensionsGenericMeta,\n                              extra=contextlib.AbstractAsyncContextManager):\n        __slots__ = ()\n\n    __all__.append(\'AsyncContextManager\')\nelif sys.version_info[:2] >= (3, 5):\n    exec(""""""\nclass AsyncContextManager(typing.Generic[T_co]):\n    __slots__ = ()\n\n    async def __aenter__(self):\n        return self\n\n    @abc.abstractmethod\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        return None\n\n    @classmethod\n    def __subclasshook__(cls, C):\n        if cls is AsyncContextManager:\n            return _check_methods_in_mro(C, ""__aenter__"", ""__aexit__"")\n        return NotImplemented\n\n__all__.append(\'AsyncContextManager\')\n"""""")\n\n\nif hasattr(typing, \'DefaultDict\'):\n    DefaultDict = typing.DefaultDict\nelif _geqv_defined:\n    class DefaultDict(collections.defaultdict, typing.MutableMapping[KT, VT],\n                      metaclass=_ExtensionsGenericMeta,\n                      extra=collections.defaultdict):\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if _geqv(cls, DefaultDict):\n                return collections.defaultdict(*args, **kwds)\n            return _generic_new(collections.defaultdict, cls, *args, **kwds)\nelse:\n    class DefaultDict(collections.defaultdict, typing.MutableMapping[KT, VT],\n                      metaclass=_ExtensionsGenericMeta,\n                      extra=collections.defaultdict):\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if cls._gorg is DefaultDict:\n                return collections.defaultdict(*args, **kwds)\n            return _generic_new(collections.defaultdict, cls, *args, **kwds)\n\n\nif hasattr(typing, \'Counter\'):\n    Counter = typing.Counter\nelif (3, 5, 0) <= sys.version_info[:3] <= (3, 5, 1):\n    assert _geqv_defined\n    _TInt = typing.TypeVar(\'_TInt\')\n\n    class _CounterMeta(typing.GenericMeta):\n        """"""Metaclass for Counter""""""\n        def __getitem__(self, item):\n            return super().__getitem__((item, int))\n\n    class Counter(collections.Counter,\n                  typing.Dict[T, int],\n                  metaclass=_CounterMeta,\n                  extra=collections.Counter):\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if _geqv(cls, Counter):\n                return collections.Counter(*args, **kwds)\n            return _generic_new(collections.Counter, cls, *args, **kwds)\n\nelif _geqv_defined:\n    class Counter(collections.Counter,\n                  typing.Dict[T, int],\n                  metaclass=_ExtensionsGenericMeta, extra=collections.Counter):\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if _geqv(cls, Counter):\n                return collections.Counter(*args, **kwds)\n            return _generic_new(collections.Counter, cls, *args, **kwds)\n\nelse:\n    class Counter(collections.Counter,\n                  typing.Dict[T, int],\n                  metaclass=_ExtensionsGenericMeta, extra=collections.Counter):\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwds):\n            if cls._gorg is Counter:\n                return collections.Counter(*args, **kwds)\n            return _generic_new(collections.Counter, cls, *args, **kwds)\n\n\nif hasattr(typing, \'ChainMap\'):\n    ChainMap = typing.ChainMap\n    __all__.append(\'ChainMap\')\nelif hasattr(collections, \'ChainMap\'):\n    # ChainMap only exists in 3.3+\n    if _geqv_defined:\n        class ChainMap(collections.ChainMap, typing.MutableMapping[KT, VT],\n                       metaclass=_ExtensionsGenericMeta,\n                       extra=collections.ChainMap):\n\n            __slots__ = ()\n\n            def __new__(cls, *args, **kwds):\n                if _geqv(cls, ChainMap):\n                    return collections.ChainMap(*args, **kwds)\n                return _generic_new(collections.ChainMap, cls, *args, **kwds)\n    else:\n        class ChainMap(collections.ChainMap, typing.MutableMapping[KT, VT],\n                       metaclass=_ExtensionsGenericMeta,\n                       extra=collections.ChainMap):\n\n            __slots__ = ()\n\n            def __new__(cls, *args, **kwds):\n                if cls._gorg is ChainMap:\n                    return collections.ChainMap(*args, **kwds)\n                return _generic_new(collections.ChainMap, cls, *args, **kwds)\n\n    __all__.append(\'ChainMap\')\n\n\nif _define_guard(\'AsyncGenerator\'):\n    class AsyncGenerator(AsyncIterator[T_co], typing.Generic[T_co, T_contra],\n                         metaclass=_ExtensionsGenericMeta,\n                         extra=collections_abc.AsyncGenerator):\n        __slots__ = ()\n\n\nif hasattr(typing, \'NewType\'):\n    NewType = typing.NewType\nelse:\n    def NewType(name, tp):\n        """"""NewType creates simple unique types with almost zero\n        runtime overhead. NewType(name, tp) is considered a subtype of tp\n        by static type checkers. At runtime, NewType(name, tp) returns\n        a dummy function that simply returns its argument. Usage::\n\n            UserId = NewType(\'UserId\', int)\n\n            def name_by_id(user_id: UserId) -> str:\n                ...\n\n            UserId(\'user\')          # Fails type check\n\n            name_by_id(42)          # Fails type check\n            name_by_id(UserId(42))  # OK\n\n            num = UserId(5) + 1     # type: int\n        """"""\n\n        def new_type(x):\n            return x\n\n        new_type.__name__ = name\n        new_type.__supertype__ = tp\n        return new_type\n\n\nif hasattr(typing, \'Text\'):\n    Text = typing.Text\nelse:\n    Text = str\n\n\nif hasattr(typing, \'TYPE_CHECKING\'):\n    TYPE_CHECKING = typing.TYPE_CHECKING\nelse:\n    # Constant that\'s True when type checking, but False here.\n    TYPE_CHECKING = False\n\n\ndef _gorg(cls):\n    """"""This function exists for compatibility with old typing versions.""""""\n    assert isinstance(cls, GenericMeta)\n    if hasattr(cls, \'_gorg\'):\n        return cls._gorg\n    while cls.__origin__ is not None:\n        cls = cls.__origin__\n    return cls\n\n\nif OLD_GENERICS:\n    def _next_in_mro(cls):  # noqa\n        """"""This function exists for compatibility with old typing versions.""""""\n        next_in_mro = object\n        for i, c in enumerate(cls.__mro__[:-1]):\n            if isinstance(c, GenericMeta) and _gorg(c) is Generic:\n                next_in_mro = cls.__mro__[i + 1]\n        return next_in_mro\n\n\n_PROTO_WHITELIST = [\'Callable\', \'Awaitable\',\n                    \'Iterable\', \'Iterator\', \'AsyncIterable\', \'AsyncIterator\',\n                    \'Hashable\', \'Sized\', \'Container\', \'Collection\', \'Reversible\',\n                    \'ContextManager\', \'AsyncContextManager\']\n\n\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  # without object\n        if base.__name__ in (\'Protocol\', \'Generic\'):\n            continue\n        annotations = getattr(base, \'__annotations__\', {})\n        for attr in list(base.__dict__.keys()) + list(annotations.keys()):\n            if (not attr.startswith(\'_abc_\') and attr not in (\n                    \'__abstractmethods__\', \'__annotations__\', \'__weakref__\',\n                    \'_is_protocol\', \'_is_runtime_protocol\', \'__dict__\',\n                    \'__args__\', \'__slots__\',\n                    \'__next_in_mro__\', \'__parameters__\', \'__origin__\',\n                    \'__orig_bases__\', \'__extra__\', \'__tree_hash__\',\n                    \'__doc__\', \'__subclasshook__\', \'__init__\', \'__new__\',\n                    \'__module__\', \'_MutableMapping__marker\', \'_gorg\')):\n                attrs.add(attr)\n    return attrs\n\n\ndef _is_callable_members_only(cls):\n    return all(callable(getattr(cls, attr, None)) for attr in _get_protocol_attrs(cls))\n\n\nif hasattr(typing, \'Protocol\'):\n    Protocol = typing.Protocol\nelif HAVE_PROTOCOLS and not PEP_560:\n    class _ProtocolMeta(GenericMeta):\n        """"""Internal metaclass for Protocol.\n\n        This exists so Protocol classes can be generic without deriving\n        from Generic.\n        """"""\n        if not OLD_GENERICS:\n            def __new__(cls, name, bases, namespace,\n                        tvars=None, args=None, origin=None, extra=None, orig_bases=None):\n                # This is just a version copied from GenericMeta.__new__ that\n                # includes ""Protocol"" special treatment. (Comments removed for brevity.)\n                assert extra is None  # Protocols should not have extra\n                if tvars is not None:\n                    assert origin is not None\n                    assert all(isinstance(t, TypeVar) for t in tvars), tvars\n                else:\n                    tvars = _type_vars(bases)\n                    gvars = None\n                    for base in bases:\n                        if base is Generic:\n                            raise TypeError(""Cannot inherit from plain Generic"")\n                        if (isinstance(base, GenericMeta) and\n                                base.__origin__ in (Generic, Protocol)):\n                            if gvars is not None:\n                                raise TypeError(\n                                    ""Cannot inherit from Generic[...] or""\n                                    "" Protocol[...] multiple times."")\n                            gvars = base.__parameters__\n                    if gvars is None:\n                        gvars = tvars\n                    else:\n                        tvarset = set(tvars)\n                        gvarset = set(gvars)\n                        if not tvarset <= gvarset:\n                            raise TypeError(\n                                ""Some type variables (%s) ""\n                                ""are not listed in %s[%s]"" %\n                                ("", "".join(str(t) for t in tvars if t not in gvarset),\n                                 ""Generic"" if any(b.__origin__ is Generic\n                                                  for b in bases) else ""Protocol"",\n                                 "", "".join(str(g) for g in gvars)))\n                        tvars = gvars\n\n                initial_bases = bases\n                if (extra is not None and type(extra) is abc.ABCMeta and\n                        extra not in bases):\n                    bases = (extra,) + bases\n                bases = tuple(_gorg(b) if isinstance(b, GenericMeta) else b\n                              for b in bases)\n                if any(isinstance(b, GenericMeta) and b is not Generic for b in bases):\n                    bases = tuple(b for b in bases if b is not Generic)\n                namespace.update({\'__origin__\': origin, \'__extra__\': extra})\n                self = super(GenericMeta, cls).__new__(cls, name, bases, namespace,\n                                                       _root=True)\n                super(GenericMeta, self).__setattr__(\'_gorg\',\n                                                     self if not origin else\n                                                     _gorg(origin))\n                self.__parameters__ = tvars\n                self.__args__ = tuple(... if a is _TypingEllipsis else\n                                      () if a is _TypingEmpty else\n                                      a for a in args) if args else None\n                self.__next_in_mro__ = _next_in_mro(self)\n                if orig_bases is None:\n                    self.__orig_bases__ = initial_bases\n                elif origin is not None:\n                    self._abc_registry = origin._abc_registry\n                    self._abc_cache = origin._abc_cache\n                if hasattr(self, \'_subs_tree\'):\n                    self.__tree_hash__ = (hash(self._subs_tree()) if origin else\n                                          super(GenericMeta, self).__hash__())\n                return self\n\n        def __init__(cls, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            if not cls.__dict__.get(\'_is_protocol\', None):\n                cls._is_protocol = any(b is Protocol or\n                                       isinstance(b, _ProtocolMeta) and\n                                       b.__origin__ is Protocol\n                                       for b in cls.__bases__)\n            if cls._is_protocol:\n                for base in cls.__mro__[1:]:\n                    if not (base in (object, Generic) or\n                            base.__module__ == \'collections.abc\' and\n                            base.__name__ in _PROTO_WHITELIST or\n                            isinstance(base, TypingMeta) and base._is_protocol or\n                            isinstance(base, GenericMeta) and\n                            base.__origin__ is Generic):\n                        raise TypeError(\'Protocols can only inherit from other\'\n                                        \' protocols, got %r\' % base)\n\n                def _no_init(self, *args, **kwargs):\n                    if type(self)._is_protocol:\n                        raise TypeError(\'Protocols cannot be instantiated\')\n                cls.__init__ = _no_init\n\n            def _proto_hook(other):\n                if not cls.__dict__.get(\'_is_protocol\', None):\n                    return NotImplemented\n                if not isinstance(other, type):\n                    # Same error as for issubclass(1, int)\n                    raise TypeError(\'issubclass() arg 1 must be a class\')\n                for attr in _get_protocol_attrs(cls):\n                    for base in other.__mro__:\n                        if attr in base.__dict__:\n                            if base.__dict__[attr] is None:\n                                return NotImplemented\n                            break\n                        annotations = getattr(base, \'__annotations__\', {})\n                        if (isinstance(annotations, typing.Mapping) and\n                                attr in annotations and\n                                isinstance(other, _ProtocolMeta) and\n                                other._is_protocol):\n                            break\n                    else:\n                        return NotImplemented\n                return True\n            if \'__subclasshook__\' not in cls.__dict__:\n                cls.__subclasshook__ = _proto_hook\n\n        def __instancecheck__(self, instance):\n            # We need this method for situations where attributes are\n            # assigned in __init__.\n            if ((not getattr(self, \'_is_protocol\', False) or\n                    _is_callable_members_only(self)) and\n                    issubclass(instance.__class__, self)):\n                return True\n            if self._is_protocol:\n                if all(hasattr(instance, attr) and\n                        (not callable(getattr(self, attr, None)) or\n                         getattr(instance, attr) is not None)\n                        for attr in _get_protocol_attrs(self)):\n                    return True\n            return super(GenericMeta, self).__instancecheck__(instance)\n\n        def __subclasscheck__(self, cls):\n            if self.__origin__ is not None:\n                if sys._getframe(1).f_globals[\'__name__\'] not in [\'abc\', \'functools\']:\n                    raise TypeError(""Parameterized generics cannot be used with class ""\n                                    ""or instance checks"")\n                return False\n            if (self.__dict__.get(\'_is_protocol\', None) and\n                    not self.__dict__.get(\'_is_runtime_protocol\', None)):\n                if sys._getframe(1).f_globals[\'__name__\'] in [\'abc\',\n                                                              \'functools\',\n                                                              \'typing\']:\n                    return False\n                raise TypeError(""Instance and class checks can only be used with""\n                                "" @runtime protocols"")\n            if (self.__dict__.get(\'_is_runtime_protocol\', None) and\n                    not _is_callable_members_only(self)):\n                if sys._getframe(1).f_globals[\'__name__\'] in [\'abc\',\n                                                              \'functools\',\n                                                              \'typing\']:\n                    return super(GenericMeta, self).__subclasscheck__(cls)\n                raise TypeError(""Protocols with non-method members""\n                                "" don\'t support issubclass()"")\n            return super(GenericMeta, self).__subclasscheck__(cls)\n\n        if not OLD_GENERICS:\n            @_tp_cache\n            def __getitem__(self, params):\n                # We also need to copy this from GenericMeta.__getitem__ to get\n                # special treatment of ""Protocol"". (Comments removed for brevity.)\n                if not isinstance(params, tuple):\n                    params = (params,)\n                if not params and _gorg(self) is not Tuple:\n                    raise TypeError(\n                        ""Parameter list to %s[...] cannot be empty"" % self.__qualname__)\n                msg = ""Parameters to generic types must be types.""\n                params = tuple(_type_check(p, msg) for p in params)\n                if self in (Generic, Protocol):\n                    if not all(isinstance(p, TypeVar) for p in params):\n                        raise TypeError(\n                            ""Parameters to %r[...] must all be type variables"" % self)\n                    if len(set(params)) != len(params):\n                        raise TypeError(\n                            ""Parameters to %r[...] must all be unique"" % self)\n                    tvars = params\n                    args = params\n                elif self in (Tuple, Callable):\n                    tvars = _type_vars(params)\n                    args = params\n                elif self.__origin__ in (Generic, Protocol):\n                    raise TypeError(""Cannot subscript already-subscripted %s"" %\n                                    repr(self))\n                else:\n                    _check_generic(self, params)\n                    tvars = _type_vars(params)\n                    args = params\n\n                prepend = (self,) if self.__origin__ is None else ()\n                return self.__class__(self.__name__,\n                                      prepend + self.__bases__,\n                                      _no_slots_copy(self.__dict__),\n                                      tvars=tvars,\n                                      args=args,\n                                      origin=self,\n                                      extra=self.__extra__,\n                                      orig_bases=self.__orig_bases__)\n\n    class Protocol(metaclass=_ProtocolMeta):\n        """"""Base class for protocol classes. Protocol classes are defined as::\n\n          class Proto(Protocol):\n              def meth(self) -> int:\n                  ...\n\n        Such classes are primarily used with static type checkers that recognize\n        structural subtyping (static duck-typing), for example::\n\n          class C:\n              def meth(self) -> int:\n                  return 0\n\n          def func(x: Proto) -> int:\n              return x.meth()\n\n          func(C())  # Passes static type check\n\n        See PEP 544 for details. Protocol classes decorated with\n        @typing_extensions.runtime act as simple-minded runtime protocol that checks\n        only the presence of given attributes, ignoring their type signatures.\n\n        Protocol classes can be generic, they are defined as::\n\n          class GenProto({bases}):\n              def meth(self) -> T:\n                  ...\n        """"""\n        __slots__ = ()\n        _is_protocol = True\n\n        def __new__(cls, *args, **kwds):\n            if _gorg(cls) is Protocol:\n                raise TypeError(""Type Protocol cannot be instantiated; ""\n                                ""it can be used only as a base class"")\n            if OLD_GENERICS:\n                return _generic_new(_next_in_mro(cls), cls, *args, **kwds)\n            return _generic_new(cls.__next_in_mro__, cls, *args, **kwds)\n    if Protocol.__doc__ is not None:\n        Protocol.__doc__ = Protocol.__doc__.format(bases=""Protocol, Generic[T]"" if\n                                                   OLD_GENERICS else ""Protocol[T]"")\n\n\nelif PEP_560:\n    from typing import _type_check, _GenericAlias, _collect_type_vars  # noqa\n\n    class _ProtocolMeta(abc.ABCMeta):\n        # This metaclass is a bit unfortunate and exists only because of the lack\n        # of __instancehook__.\n        def __instancecheck__(cls, instance):\n            # We need this method for situations where attributes are\n            # assigned in __init__.\n            if ((not getattr(cls, \'_is_protocol\', False) or\n                    _is_callable_members_only(cls)) and\n                    issubclass(instance.__class__, cls)):\n                return True\n            if cls._is_protocol:\n                if all(hasattr(instance, attr) and\n                        (not callable(getattr(cls, attr, None)) or\n                         getattr(instance, attr) is not None)\n                        for attr in _get_protocol_attrs(cls)):\n                    return True\n            return super().__instancecheck__(instance)\n\n    class Protocol(metaclass=_ProtocolMeta):\n        # There is quite a lot of overlapping code with typing.Generic.\n        # Unfortunately it is hard to avoid this while these live in two different\n        # modules. The duplicated code will be removed when Protocol is moved to typing.\n        """"""Base class for protocol classes. Protocol classes are defined as::\n\n            class Proto(Protocol):\n                def meth(self) -> int:\n                    ...\n\n        Such classes are primarily used with static type checkers that recognize\n        structural subtyping (static duck-typing), for example::\n\n            class C:\n                def meth(self) -> int:\n                    return 0\n\n            def func(x: Proto) -> int:\n                return x.meth()\n\n            func(C())  # Passes static type check\n\n        See PEP 544 for details. Protocol classes decorated with\n        @typing_extensions.runtime act as simple-minded runtime protocol that checks\n        only the presence of given attributes, ignoring their type signatures.\n\n        Protocol classes can be generic, they are defined as::\n\n            class GenProto(Protocol[T]):\n                def meth(self) -> T:\n                    ...\n        """"""\n        __slots__ = ()\n        _is_protocol = True\n\n        def __new__(cls, *args, **kwds):\n            if cls is Protocol:\n                raise TypeError(""Type Protocol cannot be instantiated; ""\n                                ""it can only be used as a base class"")\n            return super().__new__(cls)\n\n        @_tp_cache\n        def __class_getitem__(cls, params):\n            if not isinstance(params, tuple):\n                params = (params,)\n            if not params and cls is not Tuple:\n                raise TypeError(\n                    ""Parameter list to {}[...] cannot be empty"".format(cls.__qualname__))\n            msg = ""Parameters to generic types must be types.""\n            params = tuple(_type_check(p, msg) for p in params)\n            if cls is Protocol:\n                # Generic can only be subscripted with unique type variables.\n                if not all(isinstance(p, TypeVar) for p in params):\n                    i = 0\n                    while isinstance(params[i], TypeVar):\n                        i += 1\n                    raise TypeError(\n                        ""Parameters to Protocol[...] must all be type variables.""\n                        "" Parameter {} is {}"".format(i + 1, params[i]))\n                if len(set(params)) != len(params):\n                    raise TypeError(\n                        ""Parameters to Protocol[...] must all be unique"")\n            else:\n                # Subscripting a regular Generic subclass.\n                _check_generic(cls, params)\n            return _GenericAlias(cls, params)\n\n        def __init_subclass__(cls, *args, **kwargs):\n            tvars = []\n            if \'__orig_bases__\' in cls.__dict__:\n                error = Generic in cls.__orig_bases__\n            else:\n                error = Generic in cls.__bases__\n            if error:\n                raise TypeError(""Cannot inherit from plain Generic"")\n            if \'__orig_bases__\' in cls.__dict__:\n                tvars = _collect_type_vars(cls.__orig_bases__)\n                # Look for Generic[T1, ..., Tn] or Protocol[T1, ..., Tn].\n                # If found, tvars must be a subset of it.\n                # If not found, tvars is it.\n                # Also check for and reject plain Generic,\n                # and reject multiple Generic[...] and/or Protocol[...].\n                gvars = None\n                for base in cls.__orig_bases__:\n                    if (isinstance(base, _GenericAlias) and\n                            base.__origin__ in (Generic, Protocol)):\n                        # for error messages\n                        the_base = \'Generic\' if base.__origin__ is Generic else \'Protocol\'\n                        if gvars is not None:\n                            raise TypeError(\n                                ""Cannot inherit from Generic[...]""\n                                "" and/or Protocol[...] multiple types."")\n                        gvars = base.__parameters__\n                if gvars is None:\n                    gvars = tvars\n                else:\n                    tvarset = set(tvars)\n                    gvarset = set(gvars)\n                    if not tvarset <= gvarset:\n                        s_vars = \', \'.join(str(t) for t in tvars if t not in gvarset)\n                        s_args = \', \'.join(str(g) for g in gvars)\n                        raise TypeError(""Some type variables ({}) are""\n                                        "" not listed in {}[{}]"".format(s_vars,\n                                                                       the_base, s_args))\n                    tvars = gvars\n            cls.__parameters__ = tuple(tvars)\n\n            # Determine if this is a protocol or a concrete subclass.\n            if not cls.__dict__.get(\'_is_protocol\', None):\n                cls._is_protocol = any(b is Protocol for b in cls.__bases__)\n\n            # Set (or override) the protocol subclass hook.\n            def _proto_hook(other):\n                if not cls.__dict__.get(\'_is_protocol\', None):\n                    return NotImplemented\n                if not getattr(cls, \'_is_runtime_protocol\', False):\n                    if sys._getframe(2).f_globals[\'__name__\'] in [\'abc\', \'functools\']:\n                        return NotImplemented\n                    raise TypeError(""Instance and class checks can only be used with""\n                                    "" @runtime protocols"")\n                if not _is_callable_members_only(cls):\n                    if sys._getframe(2).f_globals[\'__name__\'] in [\'abc\', \'functools\']:\n                        return NotImplemented\n                    raise TypeError(""Protocols with non-method members""\n                                    "" don\'t support issubclass()"")\n                if not isinstance(other, type):\n                    # Same error as for issubclass(1, int)\n                    raise TypeError(\'issubclass() arg 1 must be a class\')\n                for attr in _get_protocol_attrs(cls):\n                    for base in other.__mro__:\n                        if attr in base.__dict__:\n                            if base.__dict__[attr] is None:\n                                return NotImplemented\n                            break\n                        annotations = getattr(base, \'__annotations__\', {})\n                        if (isinstance(annotations, typing.Mapping) and\n                                attr in annotations and\n                                isinstance(other, _ProtocolMeta) and\n                                other._is_protocol):\n                            break\n                    else:\n                        return NotImplemented\n                return True\n            if \'__subclasshook__\' not in cls.__dict__:\n                cls.__subclasshook__ = _proto_hook\n\n            # We have nothing more to do for non-protocols.\n            if not cls._is_protocol:\n                return\n\n            # Check consistency of bases.\n            for base in cls.__bases__:\n                if not (base in (object, Generic) or\n                        base.__module__ == \'collections.abc\' and\n                        base.__name__ in _PROTO_WHITELIST or\n                        isinstance(base, _ProtocolMeta) and base._is_protocol):\n                    raise TypeError(\'Protocols can only inherit from other\'\n                                    \' protocols, got %r\' % base)\n\n            def _no_init(self, *args, **kwargs):\n                if type(self)._is_protocol:\n                    raise TypeError(\'Protocols cannot be instantiated\')\n            cls.__init__ = _no_init\n\n\nif hasattr(typing, \'runtime_checkable\'):\n    runtime_checkable = typing.runtime_checkable\nelif HAVE_PROTOCOLS:\n    def runtime_checkable(cls):\n        """"""Mark a protocol class as a runtime protocol, so that it\n        can be used with isinstance() and issubclass(). Raise TypeError\n        if applied to a non-protocol class.\n\n        This allows a simple-minded structural check very similar to the\n        one-offs in collections.abc such as Hashable.\n        """"""\n        if not isinstance(cls, _ProtocolMeta) or not cls._is_protocol:\n            raise TypeError(\'@runtime_checkable can be only applied to protocol classes,\'\n                            \' got %r\' % cls)\n        cls._is_runtime_protocol = True\n        return cls\n\n\nif HAVE_PROTOCOLS:\n    # Exists for backwards compatibility.\n    runtime = runtime_checkable\n\n\nif hasattr(typing, \'TypedDict\'):\n    TypedDict = typing.TypedDict\nelse:\n    def _check_fails(cls, other):\n        try:\n            if sys._getframe(1).f_globals[\'__name__\'] not in [\'abc\',\n                                                              \'functools\',\n                                                              \'typing\']:\n                # Typed dicts are only for static structural subtyping.\n                raise TypeError(\'TypedDict does not support instance and class checks\')\n        except (AttributeError, ValueError):\n            pass\n        return False\n\n    def _dict_new(cls, *args, **kwargs):\n        return dict(*args, **kwargs)\n\n    def _typeddict_new(cls, _typename, _fields=None, **kwargs):\n        total = kwargs.pop(\'total\', True)\n        if _fields is None:\n            _fields = kwargs\n        elif kwargs:\n            raise TypeError(""TypedDict takes either a dict or keyword arguments,""\n                            "" but not both"")\n\n        ns = {\'__annotations__\': dict(_fields), \'__total__\': total}\n        try:\n            # Setting correct module is necessary to make typed dict classes pickleable.\n            ns[\'__module__\'] = sys._getframe(1).f_globals.get(\'__name__\', \'__main__\')\n        except (AttributeError, ValueError):\n            pass\n\n        return _TypedDictMeta(_typename, (), ns)\n\n    class _TypedDictMeta(type):\n        def __new__(cls, name, bases, ns, total=True):\n            # Create new typed dict class object.\n            # This method is called directly when TypedDict is subclassed,\n            # or via _typeddict_new when TypedDict is instantiated. This way\n            # TypedDict supports all three syntaxes described in its docstring.\n            # Subclasses and instances of TypedDict return actual dictionaries\n            # via _dict_new.\n            ns[\'__new__\'] = _typeddict_new if name == \'TypedDict\' else _dict_new\n            tp_dict = super(_TypedDictMeta, cls).__new__(cls, name, (dict,), ns)\n\n            anns = ns.get(\'__annotations__\', {})\n            msg = ""TypedDict(\'Name\', {f0: t0, f1: t1, ...}); each t must be a type""\n            anns = {n: typing._type_check(tp, msg) for n, tp in anns.items()}\n            for base in bases:\n                anns.update(base.__dict__.get(\'__annotations__\', {}))\n            tp_dict.__annotations__ = anns\n            if not hasattr(tp_dict, \'__total__\'):\n                tp_dict.__total__ = total\n            return tp_dict\n\n        __instancecheck__ = __subclasscheck__ = _check_fails\n\n    TypedDict = _TypedDictMeta(\'TypedDict\', (dict,), {})\n    TypedDict.__module__ = __name__\n    TypedDict.__doc__ = \\\n        """"""A simple typed name space. At runtime it is equivalent to a plain dict.\n\n        TypedDict creates a dictionary type that expects all of its\n        instances to have a certain set of keys, with each key\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime but is only enforced by type checkers.\n        Usage::\n\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n\n            a: Point2D = {\'x\': 1, \'y\': 2, \'label\': \'good\'}  # OK\n            b: Point2D = {\'z\': 3, \'label\': \'bad\'}           # Fails type check\n\n            assert Point2D(x=1, y=2, label=\'first\') == dict(x=1, y=2, label=\'first\')\n\n        The type info could be accessed via Point2D.__annotations__. TypedDict\n        supports two additional equivalent forms::\n\n            Point2D = TypedDict(\'Point2D\', x=int, y=int, label=str)\n            Point2D = TypedDict(\'Point2D\', {\'x\': int, \'y\': int, \'label\': str})\n\n        The class syntax is only supported in Python 3.6+, while two other\n        syntax forms work for Python 2.7 and 3.2+\n        """"""\n\n\nif PEP_560:\n    class _AnnotatedAlias(typing._GenericAlias, _root=True):\n        """"""Runtime representation of an annotated type.\n\n        At its core \'Annotated[t, dec1, dec2, ...]\' is an alias for the type \'t\'\n        with extra annotations. The alias behaves like a normal typing alias,\n        instantiating is the same as instantiating the underlying type, binding\n        it to types is also the same.\n        """"""\n        def __init__(self, origin, metadata):\n            if isinstance(origin, _AnnotatedAlias):\n                metadata = origin.__metadata__ + metadata\n                origin = origin.__origin__\n            super().__init__(origin, origin)\n            self.__metadata__ = metadata\n\n        def copy_with(self, params):\n            assert len(params) == 1\n            new_type = params[0]\n            return _AnnotatedAlias(new_type, self.__metadata__)\n\n        def __repr__(self):\n            return ""typing_extensions.Annotated[{}, {}]"".format(\n                typing._type_repr(self.__origin__),\n                "", "".join(repr(a) for a in self.__metadata__)\n            )\n\n        def __reduce__(self):\n            return operator.getitem, (\n                Annotated, (self.__origin__,) + self.__metadata__\n            )\n\n        def __eq__(self, other):\n            if not isinstance(other, _AnnotatedAlias):\n                return NotImplemented\n            if self.__origin__ != other.__origin__:\n                return False\n            return self.__metadata__ == other.__metadata__\n\n        def __hash__(self):\n            return hash((self.__origin__, self.__metadata__))\n\n    class Annotated:\n        """"""Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type (and will be in\n        the __origin__ field), the remaining arguments are kept as a tuple in\n        the __extra__ field.\n\n        Details:\n\n        - It\'s an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        """"""\n\n        __slots__ = ()\n\n        def __new__(cls, *args, **kwargs):\n            raise TypeError(""Type Annotated cannot be instantiated."")\n\n        @_tp_cache\n        def __class_getitem__(cls, params):\n            if not isinstance(params, tuple) or len(params) < 2:\n                raise TypeError(""Annotated[...] should be used ""\n                                ""with at least two arguments (a type and an ""\n                                ""annotation)."")\n            msg = ""Annotated[t, ...]: t must be a type.""\n            origin = typing._type_check(params[0], msg)\n            metadata = tuple(params[1:])\n            return _AnnotatedAlias(origin, metadata)\n\n        def __init_subclass__(cls, *args, **kwargs):\n            raise TypeError(\n                ""Cannot subclass {}.Annotated"".format(cls.__module__)\n            )\n\n    def _strip_annotations(t):\n        """"""Strips the annotations from a given type.\n        """"""\n        if isinstance(t, _AnnotatedAlias):\n            return _strip_annotations(t.__origin__)\n        if isinstance(t, typing._GenericAlias):\n            stripped_args = tuple(_strip_annotations(a) for a in t.__args__)\n            if stripped_args == t.__args__:\n                return t\n            res = t.copy_with(stripped_args)\n            res._special = t._special\n            return res\n        return t\n\n    def get_type_hints(obj, globalns=None, localns=None, include_extras=False):\n        """"""Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        \'Annotated[T, ...]\' with \'T\' (unless \'include_extras=True\').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module\'s globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        """"""\n        hint = typing.get_type_hints(obj, globalns=globalns, localns=localns)\n        if include_extras:\n            return hint\n        return {k: _strip_annotations(t) for k, t in hint.items()}\n\nelif HAVE_ANNOTATED:\n\n    def _is_dunder(name):\n        """"""Returns True if name is a __dunder_variable_name__.""""""\n        return len(name) > 4 and name.startswith(\'__\') and name.endswith(\'__\')\n\n    # Prior to Python 3.7 types did not have `copy_with`. A lot of the equality\n    # checks, argument expansion etc. are done on the _subs_tre. As a result we\n    # can\'t provide a get_type_hints function that strips out annotations.\n\n    class AnnotatedMeta(typing.GenericMeta):\n        """"""Metaclass for Annotated""""""\n\n        def __new__(cls, name, bases, namespace, **kwargs):\n            if any(b is not object for b in bases):\n                raise TypeError(""Cannot subclass "" + str(Annotated))\n            return super().__new__(cls, name, bases, namespace, **kwargs)\n\n        @property\n        def __metadata__(self):\n            return self._subs_tree()[2]\n\n        def _tree_repr(self, tree):\n            cls, origin, metadata = tree\n            if not isinstance(origin, tuple):\n                tp_repr = typing._type_repr(origin)\n            else:\n                tp_repr = origin[0]._tree_repr(origin)\n            metadata_reprs = "", "".join(repr(arg) for arg in metadata)\n            return \'%s[%s, %s]\' % (cls, tp_repr, metadata_reprs)\n\n        def _subs_tree(self, tvars=None, args=None):  # noqa\n            if self is Annotated:\n                return Annotated\n            res = super()._subs_tree(tvars=tvars, args=args)\n            # Flatten nested Annotated\n            if isinstance(res[1], tuple) and res[1][0] is Annotated:\n                sub_tp = res[1][1]\n                sub_annot = res[1][2]\n                return (Annotated, sub_tp, sub_annot + res[2])\n            return res\n\n        def _get_cons(self):\n            """"""Return the class used to create instance of this type.""""""\n            if self.__origin__ is None:\n                raise TypeError(""Cannot get the underlying type of a ""\n                                ""non-specialized Annotated type."")\n            tree = self._subs_tree()\n            while isinstance(tree, tuple) and tree[0] is Annotated:\n                tree = tree[1]\n            if isinstance(tree, tuple):\n                return tree[0]\n            else:\n                return tree\n\n        @_tp_cache\n        def __getitem__(self, params):\n            if not isinstance(params, tuple):\n                params = (params,)\n            if self.__origin__ is not None:  # specializing an instantiated type\n                return super().__getitem__(params)\n            elif not isinstance(params, tuple) or len(params) < 2:\n                raise TypeError(""Annotated[...] should be instantiated ""\n                                ""with at least two arguments (a type and an ""\n                                ""annotation)."")\n            else:\n                msg = ""Annotated[t, ...]: t must be a type.""\n                tp = typing._type_check(params[0], msg)\n                metadata = tuple(params[1:])\n            return self.__class__(\n                self.__name__,\n                self.__bases__,\n                _no_slots_copy(self.__dict__),\n                tvars=_type_vars((tp,)),\n                # Metadata is a tuple so it won\'t be touched by _replace_args et al.\n                args=(tp, metadata),\n                origin=self,\n            )\n\n        def __call__(self, *args, **kwargs):\n            cons = self._get_cons()\n            result = cons(*args, **kwargs)\n            try:\n                result.__orig_class__ = self\n            except AttributeError:\n                pass\n            return result\n\n        def __getattr__(self, attr):\n            # For simplicity we just don\'t relay all dunder names\n            if self.__origin__ is not None and not _is_dunder(attr):\n                return getattr(self._get_cons(), attr)\n            raise AttributeError(attr)\n\n        def __setattr__(self, attr, value):\n            if _is_dunder(attr) or attr.startswith(\'_abc_\'):\n                super().__setattr__(attr, value)\n            elif self.__origin__ is None:\n                raise AttributeError(attr)\n            else:\n                setattr(self._get_cons(), attr, value)\n\n        def __instancecheck__(self, obj):\n            raise TypeError(""Annotated cannot be used with isinstance()."")\n\n        def __subclasscheck__(self, cls):\n            raise TypeError(""Annotated cannot be used with issubclass()."")\n\n    class Annotated(metaclass=AnnotatedMeta):\n        """"""Add context specific metadata to a type.\n\n        Example: Annotated[int, runtime_check.Unsigned] indicates to the\n        hypothetical runtime_check module that this type is an unsigned int.\n        Every other consumer of this type can ignore this metadata and treat\n        this type as int.\n\n        The first argument to Annotated must be a valid type, the remaining\n        arguments are kept as a tuple in the __metadata__ field.\n\n        Details:\n\n        - It\'s an error to call `Annotated` with less than two arguments.\n        - Nested Annotated are flattened::\n\n            Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]\n\n        - Instantiating an annotated type is equivalent to instantiating the\n        underlying type::\n\n            Annotated[C, Ann1](5) == C(5)\n\n        - Annotated can be used as a generic type alias::\n\n            Optimized = Annotated[T, runtime.Optimize()]\n            Optimized[int] == Annotated[int, runtime.Optimize()]\n\n            OptimizedList = Annotated[List[T], runtime.Optimize()]\n            OptimizedList[int] == Annotated[List[int], runtime.Optimize()]\n        """"""\n'"
pytablewriter/error.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\n\nclass NotSupportedError(Exception):\n    pass\n\n\nclass EmptyTableNameError(Exception):\n    """"""\n    Exception raised when a table writer class of the |table_name| attribute\n    is null and the class is not accepted null |table_name|.\n    """"""\n\n\nclass EmptyValueError(Exception):\n    """"""\n    Exception raised when a table writer class of the |value_matrix| attribute\n    is null, and the class is not accepted null |value_matrix|.\n    """"""\n\n\nclass EmptyTableDataError(Exception):\n    """"""\n    Exception raised when a table writer class of the |headers| and\n    |value_matrix| attributes are null.\n    """"""\n\n\nclass WriterNotFoundError(Exception):\n    """"""\n    Exception raised when appropriate loader writer found.\n    """"""\n'"
pytablewriter/typehint.py,0,"b'from typepy import (\n    Bool,\n    DateTime,\n    Dictionary,\n    Infinity,\n    Integer,\n    IpAddress,\n    List,\n    Nan,\n    NoneType,\n    NullString,\n    RealNumber,\n    String,\n)\n'"
test/__init__.py,0,b''
test/_common.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport sys\n\n\ndef print_test_result(expected, actual, error=None):\n    print(""[expected]\\n{}\\n"".format(expected))\n    print(""[actual]\\n{}\\n"".format(actual))\n\n    if error:\n        print(error, file=sys.stderr)\n\n    print(""----------------------------------------"")\n'"
test/data.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport datetime\nimport itertools\nfrom decimal import Decimal\n\nfrom tabledata import TableData\n\nfrom pytablewriter import EmptyTableDataError\nfrom pytablewriter.style import Style\n\n\nTIME = datetime.datetime(2017, 1, 1, 0, 0, 0)\nINF = float(""inf"")\nNAN = float(""nan"")\n\nheaders = [""a"", ""b"", ""c"", ""dd"", ""e""]\nvalue_matrix = [\n    [""1"", 123.1, ""a"", ""1"", 1],\n    [2, 2.2, ""bb"", ""2.2"", 2.2],\n    [3, 3.3, ""ccc"", ""3"", ""cccc""],\n]\nvalue_matrix_with_none = [\n    [""1"", None, ""a"", ""1"", None],\n    [None, 2.2, None, ""2.2"", 2.2],\n    [3, 3.3, ""ccc"", None, ""cccc""],\n    [None, None, None, None, None],\n]\n\nmix_header_list = [\n    ""i"",\n    ""f"",\n    ""c"",\n    ""if"",\n    ""ifc"",\n    ""bool"",\n    ""inf"",\n    ""nan"",\n    ""mix_num"",\n    ""time"",\n]\nmix_value_matrix = [\n    [1, 1.1, ""aa"", 1, 1, True, INF, NAN, 1.0, TIME,],\n    [\n        2,\n        2.2,\n        ""bbb"",\n        2.2,\n        2.2,\n        False,\n        Decimal(""inf""),\n        Decimal(""nan""),\n        INF,\n        ""2017-01-02 03:04:05+09:00"",\n    ],\n    [3, 3.33, ""cccc"", -3, ""ccc"", True, float(""infinity""), float(""NAN""), NAN, TIME,],\n]\nmix_tabledata = TableData(table_name=""mix data"", headers=mix_header_list, rows=mix_value_matrix)\n\nfloat_header_list = [""a"", ""b"", ""c""]\nfloat_value_matrix = [\n    [0.01, 0.00125, 0.0],\n    [1.0, 99.9, 0.01],\n    [1.2, 999999.123, 0.001],\n]\nfloat_tabledata = TableData(\n    table_name=""float data"", headers=float_header_list, rows=float_value_matrix\n)\n\nvalue_matrix_iter = [\n    [[1, 2, 3], [11, 12, 13],],\n    [[1, 2, 3], [11, 12, 13],],\n    [[101, 102, 103], [1001, 1002, 1003],],\n]\n\nvalue_matrix_iter_1 = [\n    [[""a b c d e f g h i jklmn"", 2.1, 3], [""aaaaa"", 12.1, 13],],\n    [[""bbb"", 2, 3], [""cc"", 12, 13],],\n    [[""a"", 102, 103], ["""", 1002, 1003],],\n]\n\nData = collections.namedtuple(""Data"", ""table indent header value expected"")\nnull_test_data_list = [\n    Data(table=""dummy"", indent=0, header=header, value=value, expected=EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\nvut_style_tabledata = TableData(\n    ""style test"",\n    [\n        ""none"",\n        ""empty"",\n        ""tiny"",\n        ""small"",\n        ""medium"",\n        ""large"",\n        ""null w/ bold"",\n        ""L bold"",\n        ""S italic"",\n        ""L bold italic"",\n    ],\n    [\n        [111, 111, 111, 111, 111, 111, """", 111, 111, 111],\n        [1234, 1234, 1234, 1234, 1234, 1234, """", 1234, 1234, 1234],\n    ],\n)\nvut_styles = [\n    None,\n    Style(),\n    Style(font_size=""TINY""),\n    Style(font_size=""SMALL""),\n    Style(font_size=""MEDIUM"", thousand_separator="",""),\n    Style(font_size=""LARGE"", thousand_separator="" ""),\n    Style(font_weight=""bold"", thousand_separator="",""),\n    Style(font_size=""LARGE"", font_weight=""bold""),\n    Style(font_size=""SMALL"", font_style=""italic""),\n    Style(font_size=""LARGE"", font_weight=""bold"", font_style=""italic""),\n]\n'"
test/test_elasticsearch_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport datetime\nimport json\nfrom decimal import Decimal\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ._common import print_test_result\nfrom .data import headers, value_matrix\n\n\ninf = Decimal(""Infinity"")\nnan = None\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nexception_test_data_list = [\n    Data(table="""", header=headers, value=value_matrix, expected=ptw.EmptyTableNameError),\n    Data(table=""dummy"", header=[], value=[], expected=ptw.EmptyTableDataError),\n    Data(table=""dummy"", header=headers, value=[], expected=ptw.EmptyValueError),\n]\n\ntable_writer_class = ptw.ElasticsearchWriter\n\n\nclass Test_ElasticsearchWriter__get_mappings:\n    def test_normal(self):\n        writer = table_writer_class()\n        writer.table_name = ""es mappings""\n        writer.headers = [\n            ""text"",\n            ""byte"",\n            ""short"",\n            ""int"",\n            ""long"",\n            ""float"",\n            ""date"",\n            ""bool"",\n            ""ip"",\n            ""none"",\n            ""inf"",\n            ""nan"",\n        ]\n        writer.value_matrix = [\n            [\n                ""This is XXX"",\n                100,\n                10000,\n                2000000000,\n                200000000000,\n                0.1,\n                datetime.datetime(2017, 1, 3, 4, 5, 6),\n                True,\n                ""127.0.0.1"",\n                None,\n                float(""inf""),\n                float(""nan""),\n            ],\n            [\n                ""What is it"",\n                -10,\n                -1000,\n                -200000000,\n                -20000000000,\n                100.1,\n                datetime.datetime(2017, 1, 3, 4, 5, 6),\n                False,\n                ""::1"",\n                None,\n                float(""inf""),\n                float(""nan""),\n            ],\n        ]\n\n        # mappings w/o type hint ---\n        writer._preprocess()\n        mappings = writer._get_mappings()\n        expected_mappings = {\n            ""mappings"": {\n                ""table"": {\n                    ""properties"": {\n                        ""text"": {""type"": ""text""},\n                        ""byte"": {""type"": ""byte""},\n                        ""short"": {""type"": ""short""},\n                        ""int"": {""type"": ""integer""},\n                        ""long"": {""type"": ""long""},\n                        ""float"": {""type"": ""double""},\n                        ""date"": {""type"": ""date"", ""format"": ""date_optional_time""},\n                        ""bool"": {""type"": ""boolean""},\n                        ""ip"": {""type"": ""text""},\n                        ""none"": {""type"": ""keyword""},\n                        ""inf"": {""type"": ""keyword""},\n                        ""nan"": {""type"": ""keyword""},\n                    }\n                }\n            }\n        }\n\n        print_test_result(expected=expected_mappings, actual=json.dumps(mappings, indent=4))\n        assert mappings == expected_mappings\n\n        # mappings w/ type hint ---\n        writer.type_hints = [None, None, None, None, None, None, None, None, ptw.IpAddress]\n        writer._preprocess()\n        mappings = writer._get_mappings()\n        expected_mappings = {\n            ""mappings"": {\n                ""table"": {\n                    ""properties"": {\n                        ""text"": {""type"": ""text""},\n                        ""byte"": {""type"": ""byte""},\n                        ""short"": {""type"": ""short""},\n                        ""int"": {""type"": ""integer""},\n                        ""long"": {""type"": ""long""},\n                        ""float"": {""type"": ""double""},\n                        ""date"": {""type"": ""date"", ""format"": ""date_optional_time""},\n                        ""bool"": {""type"": ""boolean""},\n                        ""ip"": {""type"": ""ip""},\n                        ""none"": {""type"": ""keyword""},\n                        ""inf"": {""type"": ""keyword""},\n                        ""nan"": {""type"": ""keyword""},\n                    }\n                }\n            }\n        }\n\n        print_test_result(expected=expected_mappings, actual=json.dumps(mappings, indent=4))\n        assert mappings == expected_mappings\n\n        # body ---\n        body = list(writer._get_body())\n        expected_body = [\n            {\n                ""text"": ""This is XXX"",\n                ""byte"": 100,\n                ""short"": 10000,\n                ""int"": 2000000000,\n                ""long"": 200000000000,\n                ""float"": Decimal(""0.1""),\n                ""date"": ""2017-01-03T04:05:06"",\n                ""bool"": True,\n                ""ip"": ""127.0.0.1"",\n                ""none"": None,\n                ""inf"": ""Infinity"",\n                ""nan"": ""NaN"",\n            },\n            {\n                ""text"": ""What is it"",\n                ""byte"": -10,\n                ""short"": -1000,\n                ""int"": -200000000,\n                ""long"": -20000000000,\n                ""float"": Decimal(""100.1""),\n                ""date"": ""2017-01-03T04:05:06"",\n                ""bool"": False,\n                ""ip"": ""::1"",\n                ""none"": None,\n                ""inf"": ""Infinity"",\n                ""nan"": ""NaN"",\n            },\n        ]\n\n        print_test_result(expected=expected_body, actual=body)\n        assert body == expected_body\n\n\nclass Test_ElasticsearchWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        import elasticsearch\n\n        writer = table_writer_class()\n        writer.stream = elasticsearch.Elasticsearch()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/test_function.py,0,"b'from textwrap import dedent\n\nimport pytest\nfrom tabledata import TableData\n\nfrom pytablewriter import dumps_tabledata\n\nfrom ._common import print_test_result\n\n\ntest_tabledata = TableData(\n    ""fake name and address"",\n    (""name"", ""address""),\n    [\n        (""vRyan Gallagher"", ""6317 Mary Light\\nSmithview, HI 13900""),\n        (""Amanda Johnson"", ""3608 Samuel Mews Apt. 337\\nHousebury, WA 13608""),\n    ],\n)\n\n\nclass Test_dump_tabledata:\n    @pytest.mark.parametrize(\n        [""value"", ""format_name"", ""expected""],\n        [\n            [\n                test_tabledata,\n                ""markdown"",\n                dedent(\n                    """"""\\\n                    # fake name and address\n                    |     name      |                   address                   |\n                    |---------------|---------------------------------------------|\n                    |vRyan Gallagher|6317 Mary Light Smithview, HI 13900          |\n                    |Amanda Johnson |3608 Samuel Mews Apt. 337 Housebury, WA 13608|\n                    """"""\n                ),\n            ]\n        ],\n    )\n    def test_normal_format_name(self, value, format_name, expected):\n        out = dumps_tabledata(value, format_name=format_name)\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""value"", ""kwargs"", ""expected""],\n        [\n            [\n                test_tabledata,\n                {},\n                dedent(\n                    """"""\\\n                    .. table:: fake name and address\n\n                        +---------------+---------------------------------------------+\n                        |     name      |                   address                   |\n                        +===============+=============================================+\n                        |vRyan Gallagher|6317 Mary Light Smithview, HI 13900          |\n                        +---------------+---------------------------------------------+\n                        |Amanda Johnson |3608 Samuel Mews Apt. 337 Housebury, WA 13608|\n                        +---------------+---------------------------------------------+\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal_kwargs(self, value, kwargs, expected):\n        out = dumps_tabledata(value, **kwargs)\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n    @pytest.mark.parametrize([""value"", ""expected""], [[None, TypeError]])\n    def test_exception(self, value, expected):\n        with pytest.raises(expected):\n            dumps_tabledata(value)\n'"
test/test_logger.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytest\n\nfrom pytablewriter import set_logger\nfrom pytablewriter._logger._null_logger import NullLogger\n\n\nclass Test_set_logger:\n    @pytest.mark.parametrize([""value""], [[True], [False]])\n    def test_smoke(self, value):\n        set_logger(value)\n\n\nclass Test_NullLogger:\n    @pytest.mark.parametrize([""value""], [[True], [False]])\n    def test_smoke(self, value, monkeypatch):\n        monkeypatch.setattr(""pytablewriter._logger._logger.logger"", NullLogger())\n        set_logger(value)\n'"
test/test_null_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytablewriter\n\n\ntable_writer_class = pytablewriter.NullTableWriter\n\n\nclass Test_NullTableWriter_set_indent_level:\n    def test_smoke(self):\n        writer = table_writer_class()\n        writer.set_indent_level(0)\n\n\nclass Test_NullTableWriter_inc_indent_level:\n    def test_smoke(self):\n        writer = table_writer_class()\n        writer.inc_indent_level()\n\n\nclass Test_NullTableWriter_dec_indent_level:\n    def test_smoke(self):\n        writer = table_writer_class()\n        writer.dec_indent_level()\n\n\nclass Test_NullTableWriter_write_new_line:\n    def test_smoke(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == """"\n\n\nclass Test_NullTableWriter_write_table:\n    def test_smoke(self, capsys):\n        writer = table_writer_class()\n        writer.write_table()\n\n        out, _err = capsys.readouterr()\n        assert out == """"\n\n\nclass Test_NullTableWriter_dumps:\n    def test_smoke(self):\n        writer = table_writer_class()\n\n        assert writer.dumps() == """"\n\n\nclass Test_NullTableWriter_write_table_iter:\n    def test_smoke(self, capsys):\n        writer = table_writer_class()\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n        assert out == """"\n'"
test/test_style.py,0,"b'import copy\nimport sys\n\nimport pytest\n\nfrom pytablewriter.style import (\n    Align,\n    Cell,\n    DecorationLine,\n    FontSize,\n    FontStyle,\n    FontWeight,\n    Style,\n    ThousandSeparator,\n)\n\nfrom ._common import print_test_result\n\n\nclass Test_Cell_is_header_row:\n    @pytest.mark.parametrize(\n        [""row"", ""expected""], [[-1, True], [0, False], [sys.maxsize, False]],\n    )\n    def test_normal(self, row, expected):\n        cell = Cell(row=row, col=0, value=None, default_style=None)\n        assert cell.is_header_row() is expected\n\n\nclass Test_Style_constructor:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [\n                {\n                    ""align"": Align.RIGHT,\n                    ""decoration_line"": DecorationLine.LINE_THROUGH,\n                    ""font_size"": FontSize.TINY,\n                    ""font_weight"": FontWeight.BOLD,\n                    ""thousand_separator"": ThousandSeparator.SPACE,\n                },\n                {\n                    ""align"": Align.RIGHT,\n                    ""decoration_line"": DecorationLine.LINE_THROUGH,\n                    ""font_size"": FontSize.TINY,\n                    ""font_weight"": FontWeight.BOLD,\n                    ""thousand_separator"": ThousandSeparator.SPACE,\n                },\n            ],\n            [\n                {\n                    ""align"": ""left"",\n                    ""decoration_line"": ""underline"",\n                    ""font_size"": ""small"",\n                    ""font_weight"": ""bold"",\n                    ""thousand_separator"": "","",\n                },\n                {\n                    ""align"": Align.LEFT,\n                    ""decoration_line"": DecorationLine.UNDERLINE,\n                    ""font_size"": FontSize.SMALL,\n                    ""font_weight"": FontWeight.BOLD,\n                    ""thousand_separator"": ThousandSeparator.COMMA,\n                },\n            ],\n            [\n                {""font_size"": ""TINY""},\n                {\n                    ""align"": Align.AUTO,\n                    ""decoration_line"": DecorationLine.NONE,\n                    ""font_size"": FontSize.TINY,\n                    ""font_weight"": FontWeight.NORMAL,\n                    ""thousand_separator"": ThousandSeparator.NONE,\n                },\n            ],\n            [\n                {\n                    ""align"": None,\n                    ""font_size"": None,\n                    ""font_weight"": None,\n                    ""thousand_separator"": None,\n                },\n                {\n                    ""align"": Align.AUTO,\n                    ""decoration_line"": DecorationLine.NONE,\n                    ""font_size"": FontSize.NONE,\n                    ""font_weight"": FontWeight.NORMAL,\n                    ""thousand_separator"": ThousandSeparator.NONE,\n                },\n            ],\n        ],\n    )\n    def test_normal(self, value, expected):\n        style = Style(**value)\n\n        print(""expected: {}\\nactual: {}"".format(expected, style), file=sys.stderr)\n\n        assert style.align is expected.get(""align"")\n        assert style.font_size is expected.get(""font_size"")\n        assert style.font_weight is expected.get(""font_weight"")\n        assert style.thousand_separator is expected.get(""thousand_separator"")\n\n\nclass Test_Style_eq:\n    @pytest.mark.parametrize(\n        [""lhs"", ""rhs"", ""expected""],\n        [\n            [Style(), Style(), True],\n            [Style(align=Align.RIGHT), Style(align=Align.RIGHT), True],\n            [Style(align=Align.RIGHT), Style(align=Align.LEFT), False],\n            [Style(align=Align.RIGHT), Style(align=""right""), True],\n            [Style(align=Align.RIGHT), Style(align=Align.RIGHT, font_size=FontSize.TINY), False],\n            [Style(font_size=FontSize.TINY), Style(font_size=FontSize.TINY), True],\n            [Style(font_size=FontSize.TINY), Style(font_size=""tiny""), True],\n            [Style(font_size=FontSize.TINY), Style(font_size=FontSize.LARGE), False],\n            [Style(font_weight=""bold""), Style(font_weight=FontWeight.BOLD), True],\n            [Style(font_weight=""bold""), Style(font_weight=""normal""), False],\n            [Style(font_style=""italic""), Style(font_style=FontStyle.ITALIC), True],\n            [Style(font_style=""italic""), Style(font_style=""normal""), False],\n            [Style(thousand_separator="",""), Style(thousand_separator="",""), True],\n            [Style(thousand_separator="",""), Style(thousand_separator=""comma""), True],\n            [Style(thousand_separator=""_""), Style(thousand_separator=""underscore""), True],\n            [Style(thousand_separator=""""), Style(thousand_separator="",""), False],\n            [\n                Style(thousand_separator=ThousandSeparator.COMMA),\n                Style(thousand_separator=ThousandSeparator.COMMA),\n                True,\n            ],\n            [\n                Style(thousand_separator=""space""),\n                Style(thousand_separator=ThousandSeparator.SPACE),\n                True,\n            ],\n            [\n                Style(thousand_separator=ThousandSeparator.COMMA),\n                Style(thousand_separator=ThousandSeparator.COMMA, font_size=FontSize.TINY),\n                False,\n            ],\n            [\n                Style(\n                    align=Align.LEFT,\n                    font_size=FontSize.TINY,\n                    font_style=FontStyle.ITALIC,\n                    font_weight=FontWeight.BOLD,\n                    thousand_separator=ThousandSeparator.COMMA,\n                ),\n                Style(\n                    align=""left"",\n                    font_size=""tiny"",\n                    font_style=""italic"",\n                    font_weight=""bold"",\n                    thousand_separator="","",\n                ),\n                True,\n            ],\n            [Style(), None, False],\n        ],\n    )\n    def test_normal(self, lhs, rhs, expected):\n        assert (lhs == rhs) == expected\n        assert (lhs != rhs) != expected\n\n    @pytest.mark.parametrize(\n        [""align"", ""font_size"", ""thousand_separator"", ""expected""],\n        [\n            [""invali"", None, None, ValueError],\n            [FontSize.TINY, None, None, TypeError],\n            [None, 12, None, TypeError],\n            [None, Align.LEFT, None, TypeError],\n            [None, None, ""invalid"", TypeError],\n        ],\n    )\n    def test_exception(self, align, font_size, thousand_separator, expected):\n        with pytest.raises(expected):\n            Style(align=align, font_size=font_size, thousand_separator=thousand_separator)\n\n\nclass Test_Style_repr:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [\n                Style(\n                    align=""left"",\n                    padding=1,\n                    vertical_align=""bottom"",\n                    color=""red"",\n                    bg_color=""#2f2f2f"",\n                    decoration_line=""line-through"",\n                    font_size=""tiny"",\n                    font_style=""italic"",\n                    font_weight=""bold"",\n                    thousand_separator="","",\n                ),\n                ""(align=left, padding=1, valign=bottom, ""\n                ""color=Color(code=#cd3131, rgb=(205, 49, 49), name=RED), ""\n                ""bg_color=Color(code=#2f2f2f, rgb=(47, 47, 47)), ""\n                ""decoration_line=line_through, ""\n                ""font_size=tiny, font_style=italic, font_weight=bold, ""\n                ""thousand_separator=comma)"",\n            ],\n            [Style(), ""(align=auto, valign=baseline, font_style=normal, font_weight=normal)""],\n        ],\n    )\n    def test_normal(self, value, expected):\n        out = str(value)\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n\nclass Test_Style_update:\n    def test_normal(self):\n        lhs = Style(\n            align=""left"",\n            padding=1,\n            vertical_align=""bottom"",\n            color=""red"",\n            bg_color=""#2f2f2f"",\n            decoration_line=""line-through"",\n            font_size=""tiny"",\n            font_style=""italic"",\n            font_weight=""bold"",\n            thousand_separator="","",\n        )\n        rhs = copy.deepcopy(lhs)\n        rhs.update(color=""black"")\n\n        assert lhs.color != rhs.color\n        assert lhs.bg_color == rhs.bg_color\n'"
test/test_table_format.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytest\n\nfrom pytablewriter import FormatAttr, TableFormat\n\n\nclass Test_TableFormat_search_table_format:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [\n                FormatAttr.TEXT,\n                [\n                    TableFormat.BOLD_UNICODE,\n                    TableFormat.BORDERLESS,\n                    TableFormat.CSS,\n                    TableFormat.CSV,\n                    TableFormat.HTML,\n                    TableFormat.JAVASCRIPT,\n                    TableFormat.JSON,\n                    TableFormat.JSON_LINES,\n                    TableFormat.LATEX_MATRIX,\n                    TableFormat.LATEX_TABLE,\n                    TableFormat.LTSV,\n                    TableFormat.MARKDOWN,\n                    TableFormat.MEDIAWIKI,\n                    TableFormat.NUMPY,\n                    TableFormat.PANDAS,\n                    TableFormat.PYTHON,\n                    TableFormat.RST_CSV_TABLE,\n                    TableFormat.RST_GRID_TABLE,\n                    TableFormat.RST_SIMPLE_TABLE,\n                    TableFormat.SPACE_ALIGNED,\n                    TableFormat.TOML,\n                    TableFormat.TSV,\n                    TableFormat.UNICODE,\n                    TableFormat.YAML,\n                ],\n            ],\n            [FormatAttr.BIN, [TableFormat.EXCEL_XLS, TableFormat.EXCEL_XLSX, TableFormat.SQLITE]],\n            [FormatAttr.API, [TableFormat.ELASTICSEARCH]],\n            [0, []],\n        ],\n    )\n    def test_normal(self, value, expected):\n        assert set(TableFormat.find_all_attr(value)) == set(expected)\n\n\nclass Test_TableFormat_from_name:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [[""csv"", TableFormat.CSV], [""CSV"", TableFormat.CSV], [""excel"", TableFormat.EXCEL_XLSX],],\n    )\n    def test_normal(self, value, expected):\n        assert TableFormat.from_name(value) == expected\n'"
test/test_writer_factory.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport itertools\n\nimport pytest\n\nimport pytablewriter as ptw\n\n\nclass Test_WriterFactory_get_format_names:\n    def test_normal(self):\n        assert ptw.TableWriterFactory.get_format_names() == [\n            ""bold_unicode"",\n            ""borderless"",\n            ""css"",\n            ""csv"",\n            ""elasticsearch"",\n            ""excel"",\n            ""htm"",\n            ""html"",\n            ""javascript"",\n            ""js"",\n            ""json"",\n            ""json_lines"",\n            ""jsonl"",\n            ""latex_matrix"",\n            ""latex_table"",\n            ""ldjson"",\n            ""ltsv"",\n            ""markdown"",\n            ""md"",\n            ""mediawiki"",\n            ""ndjson"",\n            ""null"",\n            ""numpy"",\n            ""pandas"",\n            ""py"",\n            ""python"",\n            ""rst"",\n            ""rst_csv"",\n            ""rst_csv_table"",\n            ""rst_grid"",\n            ""rst_grid_table"",\n            ""rst_simple"",\n            ""rst_simple_table"",\n            ""space_aligned"",\n            ""sqlite"",\n            ""toml"",\n            ""tsv"",\n            ""unicode"",\n            ""yaml"",\n        ]\n\n\nclass Test_WriterFactory_get_extensions:\n    def test_normal(self):\n        assert ptw.TableWriterFactory.get_extensions() == [\n            ""css"",\n            ""csv"",\n            ""htm"",\n            ""html"",\n            ""js"",\n            ""json"",\n            ""jsonl"",\n            ""ldjson"",\n            ""ltsv"",\n            ""md"",\n            ""ndjson"",\n            ""py"",\n            ""rst"",\n            ""sqlite"",\n            ""sqlite3"",\n            ""tex"",\n            ""toml"",\n            ""tsv"",\n            ""xls"",\n            ""xlsx"",\n            ""yml"",\n        ]\n\n\nclass Test_WriterFactory_create_from_file_extension:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        list(\n            itertools.product(\n                [""valid_ext.csv"", ""valid_ext.CSV"", "".csv"", ""CSV""], [ptw.CsvTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.css"", ""valid_ext.CSS"", "".css"", ""CSS""], [ptw.CssTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.html"", ""valid_ext.HTML"", "".html"", ""HTML""], [ptw.HtmlTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.htm"", ""valid_ext.HTM"", "".htm"", ""HTM""], [ptw.HtmlTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.js"", ""valid_ext.JS"", "".js"", ""JS""], [ptw.JavaScriptTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.json"", ""valid_ext.JSON"", "".json"", ""JSON""], [ptw.JsonTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.ltsv"", ""valid_ext.LTSV"", "".ltsv"", ""LTSV""], [ptw.LtsvTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.md"", ""valid_ext.MD"", "".md"", ""MD""], [ptw.MarkdownTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.py"", ""valid_ext.PY"", "".py"", ""PY""], [ptw.PythonCodeTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.rst"", ""valid_ext.RST"", "".rst"", ""RST""], [ptw.RstGridTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.sqlite"", ""valid_ext.sqlite3"", "".sqlite"", ""SQLITE""],\n                [ptw.SqliteTableWriter],\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.tex"", ""valid_ext.TEX"", "".tex"", ""TEX""], [ptw.LatexMatrixWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.tsv"", ""valid_ext.TSV"", "".tsv"", ""TSV""], [ptw.TsvTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.toml"", ""valid_ext.TOML"", "".toml"", ""TOML""], [ptw.TomlTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.xls"", ""valid_ext.XLS"", "".xls"", ""XLS""], [ptw.ExcelXlsTableWriter]\n            )\n        )\n        + list(\n            itertools.product(\n                [""valid_ext.xlsx"", ""valid_ext.XLSX"", "".xlsx""], [ptw.ExcelXlsxTableWriter]\n            )\n        )\n        + list(\n            itertools.product([""valid_ext.yml"", ""valid_ext.YML"", "".yml""], [ptw.YamlTableWriter])\n        ),\n    )\n    def test_normal(self, value, expected):\n        writer = ptw.TableWriterFactory.create_from_file_extension(value)\n\n        assert isinstance(writer, expected)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [""hoge"", ptw.WriterNotFoundError],\n            [""hoge.txt"", ptw.WriterNotFoundError],\n            ["".txt"", ptw.WriterNotFoundError],\n        ],\n    )\n    def test_exception(self, value, expected):\n        with pytest.raises(expected):\n            ptw.TableWriterFactory.create_from_file_extension(value)\n\n\nclass Test_FileLoaderFactory_create_from_format_name:\n    @pytest.mark.parametrize(\n        [""format_name"", ""expected""],\n        [\n            [""csv"", ptw.CsvTableWriter],\n            [""CSV"", ptw.CsvTableWriter],\n            [""excel"", ptw.ExcelXlsxTableWriter],\n            [""Excel"", ptw.ExcelXlsxTableWriter],\n            [""elasticsearch"", ptw.ElasticsearchWriter],\n            [""Elasticsearch"", ptw.ElasticsearchWriter],\n            [""html"", ptw.HtmlTableWriter],\n            [""HTML"", ptw.HtmlTableWriter],\n            [""htm"", ptw.HtmlTableWriter],\n            [""HTML"", ptw.HtmlTableWriter],\n            [""javascript"", ptw.JavaScriptTableWriter],\n            [""JAVASCRIPT"", ptw.JavaScriptTableWriter],\n            [""js"", ptw.JavaScriptTableWriter],\n            [""JS"", ptw.JavaScriptTableWriter],\n            [""json"", ptw.JsonTableWriter],\n            [""JSON"", ptw.JsonTableWriter],\n            [""latex_matrix"", ptw.LatexMatrixWriter],\n            [""latex_table"", ptw.LatexTableWriter],\n            [""ltsv"", ptw.LtsvTableWriter],\n            [""LTSV"", ptw.LtsvTableWriter],\n            [""markdown"", ptw.MarkdownTableWriter],\n            [""Markdown"", ptw.MarkdownTableWriter],\n            [""md"", ptw.MarkdownTableWriter],\n            [""MD"", ptw.MarkdownTableWriter],\n            [""mediawiki"", ptw.MediaWikiTableWriter],\n            [""MediaWiki"", ptw.MediaWikiTableWriter],\n            [""null"", ptw.NullTableWriter],\n            [""NULL"", ptw.NullTableWriter],\n            [""numpy"", ptw.NumpyTableWriter],\n            [""pandas"", ptw.PandasDataFrameWriter],\n            [""py"", ptw.PythonCodeTableWriter],\n            [""Python"", ptw.PythonCodeTableWriter],\n            [""rst"", ptw.RstGridTableWriter],\n            [""rst_grid_table"", ptw.RstGridTableWriter],\n            [""rst_simple_table"", ptw.RstSimpleTableWriter],\n            [""rst_csv_table"", ptw.RstCsvTableWriter],\n            [""space_aligned"", ptw.SpaceAlignedTableWriter],\n            [""SPACE_ALIGNED"", ptw.SpaceAlignedTableWriter],\n            [""sqlite"", ptw.SqliteTableWriter],\n            [""SQLite"", ptw.SqliteTableWriter],\n            [""tsv"", ptw.TsvTableWriter],\n            [""TSV"", ptw.TsvTableWriter],\n            [""toml"", ptw.TomlTableWriter],\n            [""TOML"", ptw.TomlTableWriter],\n            [""unicode"", ptw.UnicodeTableWriter],\n            [""Unicode"", ptw.UnicodeTableWriter],\n            [""yaml"", ptw.YamlTableWriter],\n            [""YAML"", ptw.YamlTableWriter],\n        ],\n    )\n    def test_normal(self, format_name, expected):\n        writer = ptw.TableWriterFactory.create_from_format_name(format_name)\n\n        assert isinstance(writer, expected)\n\n    @pytest.mark.parametrize(\n        [""format_name"", ""expected""],\n        [\n            [""not_exist_format"", ptw.WriterNotFoundError],\n            ["""", ptw.WriterNotFoundError],\n            [None, AttributeError],\n        ],\n    )\n    def test_exception(self, format_name, expected):\n        with pytest.raises(expected):\n            ptw.TableWriterFactory.create_from_format_name(format_name)\n'"
examples/py/elasticsearch_index.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport argparse\nimport datetime\nimport json\nimport sys\n\nfrom elasticsearch import Elasticsearch\n\nimport pytablewriter as ptw\n\n\ndef parse_option():\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(""--host"", default=""localhost"", help=""default=%(default)s"")\n    parser.add_argument(""--port"", type=int, default=9200, help=""default=%(default)s"")\n\n    return parser.parse_args()\n\n\ndef main():\n    options = parse_option()\n\n    es = Elasticsearch(hosts=""{:s}:{:d}"".format(options.host, options.port))\n\n    writer = ptw.ElasticsearchWriter()\n    writer.stream = es\n    writer.index_name = ""es writer example""\n    writer.headers = [\n        ""str"",\n        ""byte"",\n        ""short"",\n        ""int"",\n        ""long"",\n        ""float"",\n        ""date"",\n        ""bool"",\n        ""ip"",\n    ]\n    writer.value_matrix = [\n        [\n            ""abc"",\n            100,\n            10000,\n            2000000000,\n            200000000000,\n            0.1,\n            datetime.datetime(2017, 1, 2, 3, 4, 5),\n            True,\n            ""127.0.0.1"",\n        ],\n        [\n            ""def"",\n            -10,\n            -1000,\n            -200000000,\n            -20000000000,\n            100.1,\n            datetime.datetime(2017, 6, 5, 4, 5, 2),\n            False,\n            ""::1"",\n        ],\n    ]\n\n    # delete existing index ---\n    es.indices.delete(index=writer.index_name, ignore=404)\n\n    # create an index and put data ---\n    writer.write_table()\n\n    # display the result ---\n    es.indices.refresh(index=writer.index_name)\n\n    print(""----- mappings -----"")\n    response = es.indices.get_mapping(index=writer.index_name, doc_type=""table"")\n    print(""{}\\n"".format(json.dumps(response, indent=4)))\n\n    print(""----- documents -----"")\n    response = es.search(\n        index=writer.index_name, doc_type=""table"", body={""query"": {""match_all"": {}}}\n    )\n    for hit in response[""hits""][""hits""]:\n        print(json.dumps(hit[""_source""], indent=4))\n\n    return 0\n\n\nif __name__ == ""__main__"":\n    sys.exit(main())\n'"
examples/py/excel_table_multi.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom pytablewriter import ExcelXlsxTableWriter\n\n\ndef main():\n    writer = ExcelXlsxTableWriter()\n    filepath = ""multi_sheet_example.xlsx""\n\n    # write the first worksheet\n    writer.table_name = ""example""\n    writer.headers = [""int"", ""float"", ""str"", ""bool"", ""mix"", ""time""]\n    writer.value_matrix = [\n        [0, 0.1, ""hoge"", True, 0, ""2017-01-01 03:04:05+0900""],\n        [2, ""-2.23"", ""foo"", False, None, ""2017-12-23 12:34:51+0900""],\n        [3, 0, ""bar"", ""true"", ""inf"", ""2017-03-03 22:44:55+0900""],\n        [-10, -9.9, """", ""FALSE"", ""nan"", ""2017-01-01 00:00:00+0900""],\n    ]\n    writer.dump(filepath, close_after_write=False)\n\n    # write the second worksheet\n    writer.table_name = ""Timezone""\n    writer.headers = [\n        ""zone_id"",\n        ""abbreviation"",\n        ""time_start"",\n        ""gmt_offset"",\n        ""dst"",\n    ]\n    writer.value_matrix = [\n        [""1"", ""CEST"", ""1017536400"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1048986000"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1080435600"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1111885200"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1143334800"", ""7200"", ""1""],\n    ]\n    writer.dump(filepath)\n\n\nif __name__ == ""__main__"":\n    main()\n'"
examples/py/excel_table_single.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom pytablewriter import ExcelXlsxTableWriter\n\n\ndef main():\n    writer = ExcelXlsxTableWriter()\n\n    writer.table_name = ""example""\n    writer.headers = [""int"", ""float"", ""str"", ""bool"", ""mix"", ""time""]\n    writer.value_matrix = [\n        [0, 0.1, ""hoge"", True, 0, ""2017-01-01 03:04:05+0900""],\n        [2, ""-2.23"", ""foo"", False, None, ""2017-12-23 12:34:51+0900""],\n        [3, 0, ""bar"", ""true"", ""inf"", ""2017-03-03 22:44:55+0900""],\n        [-10, -9.9, """", ""FALSE"", ""nan"", ""2017-01-01 00:00:00+0900""],\n    ]\n    writer.dump(""sample.xlsx"")\n\n\nif __name__ == ""__main__"":\n    main()\n'"
examples/py/from_csv_file.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytablewriter\n\n\nfilename = ""sample.csv""\n\n\ndef main():\n    with open(filename, ""w"", encoding=""utf8"") as f:\n        f.write(\n            dedent(\n                """"""\\\n            ""i"",""f"",""c"",""if"",""ifc"",""bool"",""inf"",""nan"",""mix_num"",""time""\n            1,1.10,""aa"",1.0,""1"",True,Infinity,NaN,1,""2017-01-01 00:00:00+09:00""\n            2,2.20,""bbb"",2.2,""2.2"",False,Infinity,NaN,Infinity,""2017-01-02 03:04:05+09:00""\n            3,3.33,""cccc"",-3.0,""ccc"",True,Infinity,NaN,NaN,""2017-01-01 00:00:00+09:00""\n            """"""\n            )\n        )\n\n    writer = pytablewriter.MarkdownTableWriter()\n    writer.from_csv(filename)\n    writer.write_table()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
examples/py/from_pandas_dataframe.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport io\nfrom textwrap import dedent\n\nimport pandas as pd\n\nimport pytablewriter\n\n\ndef main():\n    df = pd.read_csv(\n        io.StringIO(\n            dedent(\n                """"""\\\n        ""i"",""f"",""c"",""if"",""ifc"",""bool"",""inf"",""nan"",""mix_num"",""time""\n        1,1.10,""aa"",1.0,""1"",True,Infinity,NaN,1,""2017-01-01 00:00:00+09:00""\n        22,2.20,""bbb"",2.2,""2.2"",False,Infinity,NaN,Infinity,""2017-01-02 03:04:05+09:00""\n        333,3.33,""cccc"",-3.0,""ccc"",True,Infinity,NaN,NaN,""2017-01-01 00:00:00+09:00""\n        """"""\n            )\n        ),\n        sep="","",\n    )\n\n    writer = pytablewriter.MarkdownTableWriter()\n    writer.from_dataframe(df)\n    writer.write_table()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
examples/py/multi_byte_table.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytablewriter\n\n\ndef main():\n    writer = pytablewriter.RstSimpleTableWriter()\n    writer.table_name = ""\xe7\x94\x9f\xe6\x88\x90\xe3\x81\xab\xe9\x96\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x91\xe3\x82\xbf\xe3\x83\xbc\xe3\x83\xb3""\n    writer.headers = [""\xe3\x83\x91\xe3\x82\xbf\xe3\x83\xbc\xe3\x83\xb3\xe5\x90\x8d"", ""\xe6\xa6\x82\xe8\xa6\x81"", ""GoF"", ""Code Complete[1]""]\n    writer.value_matrix = [\n        [""Abstract Factory"", ""\xe9\x96\xa2\xe9\x80\xa3\xe3\x81\x99\xe3\x82\x8b\xe4\xb8\x80\xe9\x80\xa3\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe7\x8a\xb6\xe6\xb3\x81\xe3\x81\xab\xe5\xbf\x9c\xe3\x81\x98\xe3\x81\xa6\xe3\x80\x81\xe9\x81\xa9\xe5\x88\x87\xe3\x81\xab\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe6\x96\xb9\xe6\xb3\x95\xe3\x82\x92\xe6\x8f\x90\xe4\xbe\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n        [""Builder"", ""\xe8\xa4\x87\xe5\x90\x88\xe5\x8c\x96\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xae\xe7\x94\x9f\xe6\x88\x90\xe9\x81\x8e\xe7\xa8\x8b\xe3\x82\x92\xe9\x9a\xa0\xe8\x94\xbd\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""No""],\n        [""Factory Method"", ""\xe5\xae\x9f\xe9\x9a\x9b\xe3\x81\xab\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x82\x8b\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xab\xe4\xbe\x9d\xe5\xad\x98\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe3\x80\x81\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xae\xe7\x94\x9f\xe6\x88\x90\xe6\x96\xb9\xe6\xb3\x95\xe3\x82\x92\xe6\x8f\x90\xe4\xbe\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n        [""Prototype"", ""\xe5\x90\x8c\xe6\xa7\x98\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe3\x80\x81\xe5\x8e\x9f\xe5\x9e\x8b\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe8\xa4\x87\xe8\xa3\xbd\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""No""],\n        [""Singleton"", ""\xe3\x81\x82\xe3\x82\x8b\xe3\x82\xaf\xe3\x83\xa9\xe3\x82\xb9\xe3\x81\xab\xe3\x81\xa4\xe3\x81\x84\xe3\x81\xa6\xe3\x80\x81\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\x8c\xe5\x8d\x98\xe4\xb8\x80\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8b\xe3\x81\x93\xe3\x81\xa8\xe3\x82\x92\xe4\xbf\x9d\xe8\xa8\xbc\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n    ]\n    writer.dump(""multibyte_table_output.txt"")\n\n\nif __name__ == ""__main__"":\n    main()\n'"
examples/py/sqlite_table.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytablewriter\n\n\ndef main():\n    writer = pytablewriter.SqliteTableWriter()\n\n    # create the first table\n    writer.table_name = ""example""\n    writer.headers = [""int"", ""float"", ""str"", ""bool"", ""mix"", ""time""]\n    writer.value_matrix = [\n        [0, 0.1, ""hoge"", True, 0, ""2017-01-01 03:04:05+0900""],\n        [2, ""-2.23"", ""foo"", False, None, ""2017-12-23 12:34:51+0900""],\n        [3, 0, ""bar"", ""true"", ""inf"", ""2017-03-03 22:44:55+0900""],\n        [-10, -9.9, """", ""FALSE"", ""nan"", ""2017-01-01 00:00:00+0900""],\n    ]\n    writer.dump(""sample.sqlite"", close_after_write=False)\n\n    # write the second table\n    writer.table_name = ""Timezone""\n    writer.headers = [\n        ""zone_id"",\n        ""abbreviation"",\n        ""time_start"",\n        ""gmt_offset"",\n        ""dst"",\n    ]\n    writer.value_matrix = [\n        [""1"", ""CEST"", ""1017536400"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1048986000"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1080435600"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1111885200"", ""7200"", ""1""],\n        [""1"", ""CEST"", ""1143334800"", ""7200"", ""1""],\n    ]\n    writer.dump(""sample.sqlite"")\n\n    writer.close()\n\n\nif __name__ == ""__main__"":\n    main()\n'"
pytablewriter/_logger/__init__.py,0,"b'from ._logger import WriterLogger, logger, set_log_level, set_logger\n'"
pytablewriter/_logger/_logger.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom typing import List\n\nimport dataproperty\nfrom mbstrdecoder import MultiByteStrDecoder\n\nfrom ._null_logger import NullLogger\n\n\nMODULE_NAME = ""pytablewriter""\n\ntry:\n    from loguru import logger\n\n    logger.disable(MODULE_NAME)\nexcept ImportError:\n    logger = NullLogger()  # type: ignore\n\n\ndef set_logger(is_enable: bool, propagation_depth: int = 1) -> None:\n    if is_enable:\n        logger.enable(MODULE_NAME)\n    else:\n        logger.disable(MODULE_NAME)\n\n    if propagation_depth <= 0:\n        return\n\n    dataproperty.set_logger(is_enable, propagation_depth - 1)\n\n    try:\n        import simplesqlite\n\n        simplesqlite.set_logger(is_enable, propagation_depth - 1)\n    except ImportError:\n        pass\n\n    try:\n        import pytablereader\n\n        pytablereader.set_logger(is_enable, propagation_depth - 1)\n    except ImportError:\n        pass\n\n\ndef set_log_level(log_level):\n    # deprecated\n    return\n\n\nclass WriterLogger:\n    @property\n    def logger(self):\n        return self.__logger\n\n    def __init__(self, writer) -> None:\n        self.__writer = writer\n        self.__logger = logger\n\n        self.logger.debug(""created WriterLogger: format={}"".format(writer.format_name))\n\n    def __enter__(self):\n        self.logging_start_write()\n        return self\n\n    def __exit__(self, *exc):\n        self.logging_complete_write()\n        return False\n\n    def logging_start_write(self) -> None:\n        log_entry_list = [\n            self.__get_format_name_message(),\n            self.__get_table_name_message(),\n            ""headers={}"".format(self.__writer.headers),\n        ]\n\n        try:\n            log_entry_list.append(""rows={}"".format(len(self.__writer.value_matrix)))\n        except (TypeError, AttributeError):\n            log_entry_list.append(""rows=NaN"")\n\n        log_entry_list.append(self.__get_typehint_message())\n        log_entry_list.extend(self.__get_extra_log_entry_list())\n\n        self.logger.debug(""start write table: {}"".format("", "".join(log_entry_list)))\n\n    def logging_complete_write(self) -> None:\n        log_entry_list = [self.__get_format_name_message(), self.__get_table_name_message()]\n        log_entry_list.extend(self.__get_extra_log_entry_list())\n\n        self.logger.debug(""complete write table: {}"".format("", "".join(log_entry_list)))\n\n    def __get_format_name_message(self) -> str:\n        return ""format={:s}"".format(self.__writer.format_name)\n\n    def __get_table_name_message(self) -> str:\n        if self.__writer.table_name:\n            table_name = MultiByteStrDecoder(self.__writer.table_name).unicode_str\n        else:\n            table_name = """"\n\n        return ""table-name=\'{}\'"".format(table_name)\n\n    def __get_extra_log_entry_list(self) -> List[str]:\n        if self.__writer._iter_count is None:\n            return []\n\n        return [""iteration={}/{}"".format(self.__writer._iter_count, self.__writer.iteration_length)]\n\n    def __get_typehint_message(self) -> str:\n        try:\n            return ""type-hints={}"".format(\n                [type_hint(None).typename for type_hint in self.__writer.type_hints]\n            )\n        except (TypeError, AttributeError):\n            return ""type-hints=[]""\n'"
pytablewriter/_logger/_null_logger.py,0,"b'class NullLogger:\n    level_name = None\n\n    def remove(self, handler_id=None):  # pragma: no cover\n        pass\n\n    def add(self, sink, **kwargs):  # pragma: no cover\n        pass\n\n    def disable(self, name):  # pragma: no cover\n        pass\n\n    def enable(self, name):  # pragma: no cover\n        pass\n\n    def critical(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def debug(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def error(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def exception(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def info(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def log(self, __level, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def success(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def trace(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n\n    def warning(self, __message, *args, **kwargs):  # pragma: no cover\n        pass\n'"
pytablewriter/sanitizer/__init__.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom ._elasticsearch import ElasticsearchIndexNameSanitizer\nfrom ._excel import sanitize_excel_sheet_name, validate_excel_sheet_name\nfrom ._javascript import JavaScriptVarNameSanitizer, sanitize_js_var_name, validate_js_var_name\nfrom ._python import PythonVarNameSanitizer, sanitize_python_var_name, validate_python_var_name\n'"
pytablewriter/sanitizer/_base.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport abc\nimport re\n\nfrom pathvalidate.error import ErrorReason, ValidationError\nfrom typepy import is_null_string\n\nfrom ._interface import NameSanitizer\n\n\ndef _preprocess(name: str) -> str:\n    return name.strip()\n\n\nclass VarNameSanitizer(NameSanitizer):\n    @abc.abstractproperty\n    def _invalid_var_name_head_re(self):  # pragma: no cover\n        pass\n\n    @abc.abstractproperty\n    def _invalid_var_name_re(self):  # pragma: no cover\n        pass\n\n    def validate(self) -> None:\n        self._validate(self._value)\n\n    def sanitize(self, replacement_text: str = """") -> str:\n        var_name = self._invalid_var_name_re.sub(replacement_text, self._str)\n\n        # delete invalid char(s) in the beginning of the variable name\n        is_require_remove_head = any(\n            [\n                is_null_string(replacement_text),\n                self._invalid_var_name_head_re.search(replacement_text) is not None,\n            ]\n        )\n\n        if is_require_remove_head:\n            var_name = self._invalid_var_name_head_re.sub("""", var_name)\n        else:\n            match = self._invalid_var_name_head_re.search(var_name)\n            if match is not None:\n                var_name = match.end() * replacement_text + self._invalid_var_name_head_re.sub(\n                    """", var_name\n                )\n\n        if not var_name:\n            return """"\n\n        try:\n            self._validate(var_name)\n        except ValidationError as e:\n            if e.reason == ErrorReason.RESERVED_NAME and e.reusable_name is False:\n                var_name += ""_""\n\n        return var_name\n\n    def _validate(self, value: str) -> None:\n        self._validate_null_string(value)\n\n        unicode_var_name = _preprocess(value)\n\n        if self._is_reserved_keyword(unicode_var_name):\n            raise ValidationError(\n                description=""{:s} is a reserved keyword by python"".format(unicode_var_name),\n                reason=ErrorReason.RESERVED_NAME,\n                reusable_name=False,\n                reserved_name=unicode_var_name,\n            )\n\n        match = self._invalid_var_name_re.search(unicode_var_name)\n        if match is not None:\n            raise ValidationError(\n                description=""invalid char found in the variable name: \'{}\'"".format(\n                    re.escape(match.group())\n                ),\n                reason=ErrorReason.INVALID_CHARACTER,\n            )\n\n        match = self._invalid_var_name_head_re.search(unicode_var_name)\n        if match is not None:\n            raise ValidationError(\n                description=""the first character of the variable name is invalid: \'{}\'"".format(\n                    re.escape(match.group())\n                ),\n                reason=ErrorReason.INVALID_CHARACTER,\n            )\n'"
pytablewriter/sanitizer/_elasticsearch.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport re\nfrom typing import List, Pattern\n\nfrom ._base import VarNameSanitizer\n\n\nclass ElasticsearchIndexNameSanitizer(VarNameSanitizer):\n\n    __RE_INVALID_INDEX_NAME = re.compile(""["" + re.escape(\'\\\\/*?""<>|,""\') + r""\\s]+"")\n    __RE_INVALID_INDEX_NAME_HEAD = re.compile(""^[_]+"")\n\n    @property\n    def reserved_keywords(self) -> List:\n        return []\n\n    @property\n    def _invalid_var_name_head_re(self) -> Pattern:\n        return self.__RE_INVALID_INDEX_NAME_HEAD\n\n    @property\n    def _invalid_var_name_re(self) -> Pattern:\n        return self.__RE_INVALID_INDEX_NAME\n'"
pytablewriter/sanitizer/_excel.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport re\n\nfrom pathvalidate import validate_pathtype\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom ._base import _preprocess\n\n\n__MAX_SHEET_NAME_LEN = 31\n\n__INVALID_EXCEL_CHARS = ""[]:*?/\\\\""\n\n__RE_INVALID_EXCEL_SHEET_NAME = re.compile(\n    ""[{:s}]"".format(re.escape(__INVALID_EXCEL_CHARS)), re.UNICODE\n)\n\n\ndef validate_excel_sheet_name(sheet_name: str) -> None:\n    """"""\n    :param str sheet_name: Excel sheet name to validate.\n    :raises pathvalidate.ValidationError (ErrorReason.INVALID_CHARACTER):\n        If the ``sheet_name`` includes invalid char(s):\n        |invalid_excel_sheet_chars|.\n    :raises pathvalidate.ValidationError (ErrorReason.INVALID_LENGTH):\n        If the ``sheet_name`` is longer than 31 characters.\n    """"""\n\n    validate_pathtype(sheet_name)\n\n    if len(sheet_name) > __MAX_SHEET_NAME_LEN:\n        raise ValidationError(\n            description=""sheet name is too long: expected<={:d}, actual={:d}"".format(\n                __MAX_SHEET_NAME_LEN, len(sheet_name)\n            ),\n            reason=ErrorReason.INVALID_LENGTH,\n        )\n\n    unicode_sheet_name = _preprocess(sheet_name)\n    match = __RE_INVALID_EXCEL_SHEET_NAME.search(unicode_sheet_name)\n    if match is not None:\n        raise ValidationError(\n            description=""invalid char found in the sheet name: \'{:s}\'"".format(\n                re.escape(match.group())\n            ),\n            reason=ErrorReason.INVALID_CHARACTER,\n        )\n\n\ndef sanitize_excel_sheet_name(sheet_name: str, replacement_text: str = """") -> str:\n    """"""\n    Replace invalid characters for an Excel sheet name within\n    the ``sheet_name`` with the ``replacement_text``.\n    Invalid characters are as follows:\n    |invalid_excel_sheet_chars|.\n    The ``sheet_name`` truncate to 31 characters\n    (max sheet name length of Excel) from the head, if the length\n    of the name is exceed 31 characters.\n\n    :param str sheet_name: Excel sheet name to sanitize.\n    :param str replacement_text: Replacement text.\n    :return: A replacement string.\n    :rtype: str\n    :raises ValueError: If the ``sheet_name`` is an invalid sheet name.\n    """"""\n\n    try:\n        unicode_sheet_name = _preprocess(sheet_name)\n    except AttributeError as e:\n        raise ValueError(e)\n\n    modify_sheet_name = __RE_INVALID_EXCEL_SHEET_NAME.sub(replacement_text, unicode_sheet_name)\n\n    return modify_sheet_name[:__MAX_SHEET_NAME_LEN]\n'"
pytablewriter/sanitizer/_interface.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport abc\nfrom typing import List\n\nfrom pathvalidate import validate_pathtype\n\n\nclass NameSanitizer(metaclass=abc.ABCMeta):\n    @abc.abstractproperty\n    def reserved_keywords(self) -> List:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def validate(self) -> None:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def sanitize(self, replacement_text: str = """") -> str:  # pragma: no cover\n        pass\n\n    @property\n    def _str(self) -> str:\n        return str(self._value)\n\n    def __init__(self, value: str) -> None:\n        self._validate_null_string(value)\n\n        self._value = value.strip()\n\n    def _is_reserved_keyword(self, value: str) -> bool:\n        return value in self.reserved_keywords\n\n    @staticmethod\n    def _validate_null_string(text: str) -> None:\n        validate_pathtype(text, error_msg=""null name"")\n'"
pytablewriter/sanitizer/_javascript.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport re\nfrom typing import List, Pattern\n\nfrom ._base import VarNameSanitizer\n\n\nclass JavaScriptVarNameSanitizer(VarNameSanitizer):\n    __JS_RESERVED_KEYWORDS_ES6 = [\n        ""break"",\n        ""case"",\n        ""catch"",\n        ""class"",\n        ""const"",\n        ""continue"",\n        ""debugger"",\n        ""default"",\n        ""delete"",\n        ""do"",\n        ""else"",\n        ""export"",\n        ""extends"",\n        ""finally"",\n        ""for"",\n        ""function"",\n        ""if"",\n        ""import"",\n        ""in"",\n        ""instanceof"",\n        ""new"",\n        ""return"",\n        ""super"",\n        ""switch"",\n        ""this"",\n        ""throw"",\n        ""try"",\n        ""typeof"",\n        ""var"",\n        ""void"",\n        ""while"",\n        ""with"",\n        ""yield"",\n    ]\n    __JS_RESERVED_KEYWORDS_FUTURE = [\n        ""enum"",\n        ""implements"",\n        ""interface"",\n        ""let"",\n        ""package"",\n        ""private"",\n        ""protected"",\n        ""public"",\n        ""static"",\n        ""await"",\n        ""abstract"",\n        ""boolean"",\n        ""byte"",\n        ""char"",\n        ""double"",\n        ""final"",\n        ""float"",\n        ""goto"",\n        ""int"",\n        ""long"",\n        ""native"",\n        ""short"",\n        ""synchronized"",\n        ""throws"",\n        ""transient"",\n        ""volatile"",\n    ]\n    __JS_BUILTIN_CONSTANTS = [""null"", ""true"", ""false""]\n\n    __RE_INVALID_VAR_NAME = re.compile(""[^a-zA-Z0-9_$]"")\n    __RE_INVALID_VAR_NAME_HEAD = re.compile(""^[^a-zA-Z$]+"")\n\n    @property\n    def reserved_keywords(self) -> List:\n        return (\n            self.__JS_RESERVED_KEYWORDS_ES6\n            + self.__JS_RESERVED_KEYWORDS_FUTURE\n            + self.__JS_BUILTIN_CONSTANTS\n        )\n\n    @property\n    def _invalid_var_name_head_re(self) -> Pattern:\n        return self.__RE_INVALID_VAR_NAME_HEAD\n\n    @property\n    def _invalid_var_name_re(self) -> Pattern:\n        return self.__RE_INVALID_VAR_NAME\n\n\ndef validate_js_var_name(var_name: str) -> None:\n    """"""\n    :param str var_name: Name to validate.\n    :raises pathvalidate.ValidationError (ErrorReason.INVALID_CHARACTER):\n        If the ``var_name`` is invalid as a JavaScript identifier.\n    :raises pathvalidate.ValidationError (ErrorReason.RESERVED_NAME):\n        If the ``var_name`` is equals to\n        `JavaScript reserved keywords\n        <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords>`__.\n\n    .. note::\n\n        Currently, not supported unicode variable names.\n    """"""\n\n    JavaScriptVarNameSanitizer(var_name).validate()\n\n\ndef sanitize_js_var_name(var_name: str, replacement_text: str = """") -> str:\n    """"""\n    Make a valid JavaScript variable name from ``var_name``.\n\n    To make a valid name:\n\n    - Replace invalid characters for a JavaScript variable name within\n      the ``var_name`` with the ``replacement_text``\n    - Delete invalid chars for the beginning of the variable name\n    - Append underscore (``""_""``) at the tail of the name if sanitized name\n      is one of the JavaScript reserved names\n\n    :JavaScriptstr filename: Name to sanitize.\n    :param str replacement_text: Replacement text.\n    :return: A replacement string.\n    :rtype: str\n    :raises ValueError: If ``var_name`` or ``replacement_text`` is invalid.\n\n    :Example:\n        :ref:`example-sanitize-var-name`\n\n    .. note::\n        Currently, not supported Unicode variable names.\n\n    .. seealso::\n        :py:func:`.validate_js_var_name`\n    """"""\n\n    return JavaScriptVarNameSanitizer(var_name).sanitize(replacement_text)\n'"
pytablewriter/sanitizer/_python.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport re\nfrom typing import List, Pattern\n\nfrom ._base import VarNameSanitizer\n\n\nclass PythonVarNameSanitizer(VarNameSanitizer):\n    __PYTHON_RESERVED_KEYWORDS = [\n        ""and"",\n        ""del"",\n        ""from"",\n        ""not"",\n        ""while"",\n        ""as"",\n        ""elif"",\n        ""global"",\n        ""or"",\n        ""with"",\n        ""assert"",\n        ""else"",\n        ""if"",\n        ""pass"",\n        ""yield"",\n        ""break"",\n        ""except"",\n        ""import"",\n        ""print"",\n        ""class"",\n        ""exec"",\n        ""in"",\n        ""raise"",\n        ""continue"",\n        ""finally"",\n        ""is"",\n        ""return"",\n        ""def"",\n        ""for"",\n        ""lambda"",\n        ""try"",\n    ]\n    __PYTHON_BUILTIN_CONSTANTS = [\n        ""False"",\n        ""True"",\n        ""None"",\n        ""NotImplemented"",\n        ""Ellipsis"",\n        ""__debug__"",\n    ]\n\n    __RE_INVALID_VAR_NAME = re.compile(""[^a-zA-Z0-9_]"")\n    __RE_INVALID_VAR_NAME_HEAD = re.compile(""^[^a-zA-Z]+"")\n\n    @property\n    def reserved_keywords(self) -> List:\n        return self.__PYTHON_RESERVED_KEYWORDS + self.__PYTHON_BUILTIN_CONSTANTS\n\n    @property\n    def _invalid_var_name_head_re(self) -> Pattern:\n        return self.__RE_INVALID_VAR_NAME_HEAD\n\n    @property\n    def _invalid_var_name_re(self) -> Pattern:\n        return self.__RE_INVALID_VAR_NAME\n\n\ndef validate_python_var_name(var_name: str) -> None:\n    """"""\n    :param str var_name: Name to validate.\n    :raises pathvalidate.ValidationError (ErrorReason.INVALID_CHARACTER): If the ``var_name`` is invalid as\n        `Python identifier\n        <https://docs.python.org/3/reference/lexical_analysis.html#identifiers>`__.\n    :raises pathvalidate.ValidationError (ErrorReason.RESERVED_NAME):\n        If the ``var_name`` is equals to\n        `Python reserved keywords\n        <https://docs.python.org/3/reference/lexical_analysis.html#keywords>`__\n        or\n        `Python built-in constants\n        <https://docs.python.org/3/library/constants.html>`__.\n\n    :Example:\n        :ref:`example-validate-var-name`\n    """"""\n\n    PythonVarNameSanitizer(var_name).validate()\n\n\ndef sanitize_python_var_name(var_name: str, replacement_text: str = """") -> str:\n    """"""\n    Make a valid Python variable name from ``var_name``.\n\n    To make a valid name:\n\n    - Replace invalid characters for a Python variable name within\n      the ``var_name`` with the ``replacement_text``\n    - Delete invalid chars for the beginning of the variable name\n    - Append underscore (``""_""``) at the tail of the name if sanitized name\n      is one of the Python reserved names\n\n    :param str filename: Name to sanitize.\n    :param str replacement_text: Replacement text.\n    :return: A replacement string.\n    :rtype: str\n    :raises ValueError: If ``var_name`` or ``replacement_text`` is invalid.\n\n    :Example:\n        :ref:`example-sanitize-var-name`\n\n    .. seealso::\n        :py:func:`.validate_python_var_name`\n    """"""\n\n    return PythonVarNameSanitizer(var_name).sanitize(replacement_text)\n'"
pytablewriter/style/__init__.py,0,"b'from dataproperty import Format\n\nfrom ._cell import Cell\nfrom ._font import FontSize, FontStyle, FontWeight\nfrom ._style import Align, Style, ThousandSeparator, VerticalAlign\nfrom ._styler import (\n    DecorationLine,\n    GFMarkdownStyler,\n    HtmlStyler,\n    LatexStyler,\n    MarkdownStyler,\n    NullStyler,\n    ReStructuredTextStyler,\n    StylerInterface,\n    TextStyler,\n)\n'"
pytablewriter/style/_cell.py,0,"b'from typing import Any\n\nfrom ._style import Style\n\n\n# @dataclass  # starting PYthon 3.7\nclass Cell:\n    """"""\n    .. py:attribute:: row\n        :type: int\n\n        row index.\n\n    .. py:attribute:: col\n        :type: int\n\n        column index.\n\n    .. py:attribute:: value\n        :type: Any\n\n        data for the cell.\n\n    .. py:attribute:: default_style\n        :type: pytablewriter.style.Style\n\n        default |Style| for the cell.\n    """"""\n\n    def __init__(self, row: int, col: int, value: Any, default_style: Style):\n        self.row = row\n        self.col = col\n        self.value = value\n        self.default_style = default_style\n\n    def is_header_row(self) -> bool:\n        """"""\n        Return |True| if the cell is a header.\n        """"""\n\n        return self.row < 0\n'"
pytablewriter/style/_font.py,0,"b'from enum import Enum, unique\n\n\n@unique\nclass FontSize(Enum):\n    NONE = ""none""\n    TINY = ""tiny""\n    SMALL = ""small""\n    MEDIUM = ""medium""\n    LARGE = ""large""\n\n\n@unique\nclass FontStyle(Enum):\n    NORMAL = ""normal""\n    ITALIC = ""italic""\n\n\n@unique\nclass FontWeight(Enum):\n    NORMAL = ""normal""\n    BOLD = ""bold""\n'"
pytablewriter/style/_style.py,0,"b'from enum import Enum, unique\nfrom typing import Optional, Union, cast\n\nfrom dataproperty import Align\nfrom tcolorpy import Color\n\nfrom .._function import normalize_enum\nfrom ._font import FontSize, FontStyle, FontWeight\n\n\n@unique\nclass DecorationLine(Enum):\n    NONE = ""none""\n    LINE_THROUGH = ""line_through""\n    STRIKE = ""strike""\n    UNDERLINE = ""underline""\n\n\n@unique\nclass ThousandSeparator(Enum):\n    NONE = ""none""  #: no thousands separator\n    COMMA = ""comma""  #: ``\',\'`` as thousands separator\n    SPACE = ""space""  #: ``\' \'`` as thousands separator\n    UNDERSCORE = ""underscore""  #: ``\'_\'`` as thousands separator\n\n\n@unique\nclass VerticalAlign(Enum):\n    BASELINE = (1 << 0, ""baseline"")\n    TOP = (1 << 1, ""top"")\n    MIDDLE = (1 << 2, ""middle"")\n    BOTTOM = (1 << 3, ""bottom"")\n\n    @property\n    def align_code(self):\n        return self.__align_code\n\n    @property\n    def align_str(self):\n        return self.__align_string\n\n    def __init__(self, code, string):\n        self.__align_code = code\n        self.__align_string = string\n\n\n_s_to_ts = {\n    """": ThousandSeparator.NONE,\n    "","": ThousandSeparator.COMMA,\n    "" "": ThousandSeparator.SPACE,\n    ""_"": ThousandSeparator.UNDERSCORE,\n}\n\n\ndef _normalize_thousand_separator(value: Union[str, ThousandSeparator]) -> ThousandSeparator:\n    if isinstance(value, ThousandSeparator):\n        return value\n\n    norm_value = _s_to_ts.get(value)\n    if norm_value is None:\n        return cast(ThousandSeparator, value)\n\n    return norm_value\n\n\nclass Style:\n    """"""Style specifier class for table elements.\n\n    Args:\n        color (Union[|str|, tcolorpy.Color, |None|]):\n            Text color for cells.\n            When using str, specify a color code (``""#XXXXXX""``) or a color name.\n\n            .. note::\n                In the current version, only applicable for part of text format writer classes.\n\n        bg_color (Union[|str|, tcolorpy.Color, |None|]):\n            background color for cells.\n            When using str, specify a color code (``""#XXXXXX""``) or a color name.\n\n            .. note::\n                In the current version, only applicable for part of text format writer classes.\n\n        align (|str| / :py:class:`~.style.Align`):\n            Horizontal text alignment for cells.\n            This can be only applied for text format writer classes.\n            Possible string values are:\n\n            - ``""auto""`` (default)\n                - Detect data type for each column and set alignment that appropriate\n                  for the type automatically\n            - ``""left""``\n            - ``""right""``\n            - ``""center""``\n\n        vertical_align (|str| / :py:class:`~.style.VerticalAlign`):\n            Vertical text alignment for cells.\n            This can be only applied for HtmlTableWriter class.\n            Possible string values are:\n\n            - ``""baseline""`` (default)\n            - ``""top""``\n            - ``""middle""``\n            - ``""bottom""``\n\n        font_size (|str| / :py:class:`~.style.FontSize`):\n            Font size specification for cells in a column.\n            This can be only applied for HTML/Latex writer classes.\n            Possible string values are:\n\n            - ``""tiny""``\n            - ``""small""``\n            - ``""medium""``\n            - ``""large""``\n            - ``""none""`` (default: no font size specification)\n\n        font_weight (|str| / :py:class:`~.style.FontWeight`):\n            Font weight specification for cells in a column.\n            This can be only applied for HTML/Latex/Markdown writer classes.\n            Possible string values are:\n\n            - ``""normal""`` (default)\n            - ``""bold""``\n\n        font_style (|str| / :py:class:`~.style.FontStyle`):\n            Font style specification for cells in a column.\n            This can be applied only for HTML/Latex/Markdown writer classes.\n            Possible string values are:\n\n            - ``""normal""`` (default)\n            - ``""italic""``\n\n        decoration_line (|str| / :py:class:`~.style.DecorationLine`)\n\n            Experiental.\n            Possible string values are:\n\n            - ``""line-through""``\n            - ``""strike""`` (alias for ``""line-through""``)\n            - ``""underline""``\n            - ``""none""`` (default)\n\n        thousand_separator (|str| / :py:class:`~.style.ThousandSeparator`):\n            Thousand separator specification for numbers in a column.\n            This can be only applied for text format writer classes.\n            Possible string values are:\n\n            - ``"",""``/``""comma""``\n            - ``"" ""``/``""space""``\n            - ``""_""``/``""underscore""``\n            - ``""""``/``""none""`` (default)\n\n    Example:\n        :ref:`example-style`\n    """"""\n\n    @property\n    def align(self) -> Align:\n        return self.__align\n\n    @align.setter\n    def align(self, value: Align) -> None:\n        self.__align = value\n\n    @property\n    def vertical_align(self) -> VerticalAlign:\n        return self.__valign\n\n    @property\n    def decoration_line(self) -> DecorationLine:\n        return self.__decoration_line\n\n    @property\n    def font_size(self) -> FontSize:\n        return self.__font_size\n\n    @property\n    def font_style(self) -> FontStyle:\n        return self.__font_style\n\n    @property\n    def font_weight(self) -> FontWeight:\n        return self.__font_weight\n\n    @property\n    def color(self) -> Optional[Color]:\n        return self.__fg_color\n\n    @property\n    def bg_color(self) -> Optional[Color]:\n        return self.__bg_color\n\n    @property\n    def thousand_separator(self) -> ThousandSeparator:\n        return self.__thousand_separator\n\n    @property\n    def padding(self):\n        return self.__padding\n\n    @padding.setter\n    def padding(self, value: Optional[int]):\n        self.__padding = value\n\n    def __init__(self, **kwargs) -> None:\n        self.__update(initialize=True, **kwargs)\n\n    def __repr__(self) -> str:\n        items = []\n\n        if self.align:\n            items.append(""align={}"".format(self.align.align_string))\n        if self.padding is not None:\n            items.append(""padding={}"".format(self.padding))\n        if self.vertical_align:\n            items.append(""valign={}"".format(self.vertical_align.align_str))\n        if self.color:\n            items.append(""color={}"".format(self.color))\n        if self.bg_color:\n            items.append(""bg_color={}"".format(self.bg_color))\n        if self.decoration_line is not DecorationLine.NONE:\n            items.append(""decoration_line={}"".format(self.decoration_line.value))\n        if self.font_size is not FontSize.NONE:\n            items.append(""font_size={}"".format(self.font_size.value))\n        if self.font_style:\n            items.append(""font_style={}"".format(self.font_style.value))\n        if self.font_weight:\n            items.append(""font_weight={}"".format(self.font_weight.value))\n        if self.thousand_separator is not ThousandSeparator.NONE:\n            items.append(""thousand_separator={}"".format(self.thousand_separator.value))\n\n        return ""({})"".format("", "".join(items))\n\n    def __eq__(self, other):\n        if self.__class__ is not other.__class__:\n            return NotImplemented\n\n        return all(\n            [\n                self.align is other.align,\n                self.font_size is other.font_size,\n                self.font_style is other.font_style,\n                self.font_weight is other.font_weight,\n                self.thousand_separator is other.thousand_separator,\n            ]\n        )\n\n    def __ne__(self, other):\n        equal = self.__eq__(other)\n        return NotImplemented if equal is NotImplemented else not equal\n\n    def update(self, **kwargs) -> None:\n        """"""Update specified style attributes.\n        """"""\n        self.__update(initialize=False, **kwargs)\n\n    def __update(self, initialize: bool, **kwargs) -> None:\n        fg_color = kwargs.get(""color"")\n        if fg_color:\n            self.__fg_color = Color(fg_color)\n        elif initialize:\n            self.__fg_color = None  # type: ignore\n\n        bg_color = kwargs.get(""bg_color"")\n        if bg_color:\n            self.__bg_color = Color(bg_color)\n        elif initialize:\n            self.__bg_color = None  # type: ignore\n\n        padding = kwargs.get(""padding"")\n        if padding is not None:\n            self.__padding = padding\n        elif initialize:\n            self.__padding = None\n\n        align = kwargs.get(""align"")\n        if align:\n            self.__align = normalize_enum(align, Align, default=Align.AUTO)\n        elif initialize:\n            self.__align = Align.AUTO\n\n        valign = kwargs.get(""vertical_align"")\n        if valign:\n            self.__valign = normalize_enum(valign, VerticalAlign, default=VerticalAlign.BASELINE)\n        elif initialize:\n            self.__valign = VerticalAlign.BASELINE\n\n        decoration_line = kwargs.get(""decoration_line"")\n        if decoration_line:\n            self.__decoration_line = normalize_enum(\n                decoration_line, DecorationLine, default=DecorationLine.NONE\n            )\n        elif initialize:\n            self.__decoration_line = DecorationLine.NONE\n\n        font_size = kwargs.get(""font_size"")\n        if font_size:\n            self.__font_size = normalize_enum(\n                kwargs.get(""font_size""), FontSize, validate=False, default=FontSize.NONE\n            )\n        elif initialize:\n            self.__font_size = FontSize.NONE\n        self.__validate_attr(""font_size"", (FontSize, str))\n\n        font_style = kwargs.get(""font_style"")\n        if font_style:\n            self.__font_style = normalize_enum(font_style, FontStyle, default=FontStyle.NORMAL)\n        elif initialize:\n            self.__font_style = FontStyle.NORMAL\n\n        font_weight = kwargs.get(""font_weight"")\n        if font_weight:\n            self.__font_weight = normalize_enum(font_weight, FontWeight, default=FontWeight.NORMAL)\n        elif initialize:\n            self.__font_weight = FontWeight.NORMAL\n\n        thousand_separator = kwargs.get(""thousand_separator"")\n        if thousand_separator:\n            self.__thousand_separator = _normalize_thousand_separator(\n                normalize_enum(\n                    thousand_separator,\n                    ThousandSeparator,\n                    default=ThousandSeparator.NONE,\n                    validate=False,\n                )\n            )\n        elif initialize:\n            self.__thousand_separator = ThousandSeparator.NONE\n        self.__validate_attr(""thousand_separator"", ThousandSeparator)\n\n    def __validate_attr(self, attr_name: str, expected_type) -> None:\n        value = getattr(self, attr_name)\n        if isinstance(expected_type, (list, tuple)):\n            expected = "" or "".join([c.__name__ for c in expected_type])\n        else:\n            expected = expected_type.__name__\n\n        if not isinstance(value, expected_type):\n            raise TypeError(\n                ""{} must be instance of {}: actual={}"".format(attr_name, expected, type(value))\n            )\n'"
pytablewriter/style/_styler.py,0,"b'import abc\nfrom typing import Any, Optional, cast\n\nfrom tcolorpy import tcolor\n\nfrom ._font import FontSize, FontStyle, FontWeight\nfrom ._style import Align, DecorationLine, Style, ThousandSeparator\n\n\n_align_char_mapping = {\n    Align.AUTO: ""<"",\n    Align.LEFT: ""<"",\n    Align.RIGHT: "">"",\n    Align.CENTER: ""^"",\n}\n\n\ndef get_align_char(align: Align) -> str:\n    return _align_char_mapping[align]\n\n\nclass StylerInterface(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def apply(self, value: Any, style: Style) -> str:  # pragma: no cover\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def apply_align(self, value: str, style: Style) -> str:  # pragma: no cover\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def apply_terminal_style(self, value: str, style: Style) -> str:  # pragma: no cover\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_font_size(self, style: Style) -> Optional[str]:  # pragma: no cover\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    def get_additional_char_width(self, style: Style) -> int:  # pragma: no cover\n        raise NotImplementedError()\n\n\nclass AbstractStyler(StylerInterface):\n    def __init__(self, writer):\n        self._writer = writer\n        self._font_size_map = self._get_font_size_map()\n\n    def get_font_size(self, style: Style) -> Optional[str]:\n        return self._font_size_map.get(style.font_size)\n\n    def get_additional_char_width(self, style: Style) -> int:\n        return 0\n\n    def apply(self, value: Any, style: Style) -> str:\n        return value\n\n    def apply_align(self, value: str, style: Style) -> str:\n        return value\n\n    def apply_terminal_style(self, value: str, style: Style) -> str:\n        return value\n\n    def _get_font_size_map(self):\n        return {}\n\n\nclass NullStyler(AbstractStyler):\n    def get_font_size(self, style: Style) -> Optional[str]:\n        return """"\n\n\nclass TextStyler(AbstractStyler):\n    def apply_terminal_style(self, value: str, style: Style) -> str:\n        if not self._writer.colorize_terminal:\n            return value\n\n        ansi_styles = []\n\n        if style.decoration_line in (DecorationLine.STRIKE, DecorationLine.LINE_THROUGH):\n            ansi_styles.append(""strike"")\n        if style.decoration_line == DecorationLine.UNDERLINE:\n            ansi_styles.append(""underline"")\n\n        if style.font_weight == FontWeight.BOLD:\n            ansi_styles.append(""bold"")\n\n        return tcolor(value, color=style.color, bg_color=style.bg_color, styles=ansi_styles)\n\n    def __get_align_format(self, style: Style) -> str:\n        align_char = get_align_char(style.align)\n        format_items = [""{:"" + align_char]\n        if style.padding is not None and style.padding > 0:\n            format_items.append(str(style.padding))\n        format_items.append(""s}"")\n\n        return """".join(format_items)\n\n    def apply_align(self, value: str, style: Style) -> str:\n        return self.__get_align_format(style).format(value)\n\n    def apply(self, value: Any, style: Style) -> str:\n        if value:\n            if style.thousand_separator == ThousandSeparator.SPACE:\n                value = value.replace("","", "" "")\n            elif style.thousand_separator == ThousandSeparator.UNDERSCORE:\n                value = value.replace("","", ""_"")\n\n        return value\n\n\nclass HtmlStyler(TextStyler):\n    def _get_font_size_map(self):\n        return {\n            FontSize.TINY: ""font-size:x-small"",\n            FontSize.SMALL: ""font-size:small"",\n            FontSize.MEDIUM: ""font-size:medium"",\n            FontSize.LARGE: ""font-size:large"",\n        }\n\n\nclass LatexStyler(TextStyler):\n    class Command:\n        BOLD = r""\\bf""\n        ITALIC = r""\\it""\n\n    def get_additional_char_width(self, style: Style) -> int:\n        width = 0\n\n        if self.get_font_size(style):\n            width += len(cast(str, self.get_font_size(style)))\n\n        if style.font_weight == FontWeight.BOLD:\n            width += len(self.Command.BOLD)\n\n        if style.font_style == FontStyle.ITALIC:\n            width += len(self.Command.ITALIC)\n\n        return width\n\n    def apply(self, value: Any, style: Style) -> str:\n        value = super().apply(value, style)\n        if not value:\n            return value\n\n        font_size = self.get_font_size(style)\n        item_list = []\n\n        if font_size:\n            item_list.append(font_size)\n\n        if style.font_weight == FontWeight.BOLD:\n            item_list.append(self.Command.BOLD)\n\n        if style.font_style == FontStyle.ITALIC:\n            item_list.append(self.Command.ITALIC)\n\n        item_list.append(value)\n        return "" "".join(item_list)\n\n    def _get_font_size_map(self):\n        return {\n            FontSize.TINY: r""\\tiny"",\n            FontSize.SMALL: r""\\small"",\n            FontSize.MEDIUM: r""\\normalsize"",\n            FontSize.LARGE: r""\\large"",\n        }\n\n\nclass MarkdownStyler(TextStyler):\n    def get_additional_char_width(self, style: Style) -> int:\n        width = 0\n\n        if style.font_weight == FontWeight.BOLD:\n            width += 4\n\n        if style.font_style == FontStyle.ITALIC:\n            width += 2\n\n        return width\n\n    def apply(self, value: Any, style: Style) -> str:\n        value = super().apply(value, style)\n        if not value:\n            return value\n\n        if style.font_weight == FontWeight.BOLD:\n            value = ""**{}**"".format(value)\n\n        if style.font_style == FontStyle.ITALIC:\n            value = ""_{}_"".format(value)\n\n        return value\n\n\nclass GFMarkdownStyler(MarkdownStyler):\n    def get_additional_char_width(self, style: Style) -> int:\n        width = super().get_additional_char_width(style)\n\n        if style.decoration_line in (DecorationLine.STRIKE, DecorationLine.LINE_THROUGH):\n            width += 4\n\n        return width\n\n    def apply(self, value: Any, style: Style) -> str:\n        value = super().apply(value, style)\n        if not value:\n            return value\n\n        if style.decoration_line in (DecorationLine.STRIKE, DecorationLine.LINE_THROUGH):\n            value = ""~~{}~~"".format(value)\n\n        return value\n\n\nclass ReStructuredTextStyler(TextStyler):\n    def get_additional_char_width(self, style: Style) -> int:\n        from ..writer import RstCsvTableWriter\n\n        width = 0\n\n        if style.font_weight == FontWeight.BOLD:\n            width += 4\n        elif style.font_style == FontStyle.ITALIC:\n            width += 2\n\n        if (\n            style.thousand_separator == ThousandSeparator.COMMA\n            and self._writer.format_name == RstCsvTableWriter.FORMAT_NAME\n        ):\n            width += 2\n\n        return width\n\n    def apply(self, value: Any, style: Style) -> str:\n        from ..writer import RstCsvTableWriter\n\n        value = super().apply(value, style)\n        if not value:\n            return value\n\n        if style.font_weight == FontWeight.BOLD:\n            value = ""**{}**"".format(value)\n        elif style.font_style == FontStyle.ITALIC:\n            # in reStructuredText, some custom style definition will be required to\n            # set for both bold and italic (currently not supported)\n            value = ""*{}*"".format(value)\n\n        if (\n            style.thousand_separator == ThousandSeparator.COMMA\n            and self._writer.format_name == RstCsvTableWriter.FORMAT_NAME\n        ):\n            value = \'""{}""\'.format(value)\n\n        return value\n'"
pytablewriter/writer/__init__.py,0,"b'from ._elasticsearch import ElasticsearchWriter\nfrom ._null import NullTableWriter\nfrom ._table_writer import AbstractTableWriter\nfrom .binary import ExcelXlsTableWriter, ExcelXlsxTableWriter, SqliteTableWriter\nfrom .text import (\n    BoldUnicodeTableWriter,\n    BorderlessTableWriter,\n    CssTableWriter,\n    CsvTableWriter,\n    HtmlTableWriter,\n    JsonLinesTableWriter,\n    JsonTableWriter,\n    LatexMatrixWriter,\n    LatexTableWriter,\n    LtsvTableWriter,\n    MarkdownTableWriter,\n    MediaWikiTableWriter,\n    RstCsvTableWriter,\n    RstGridTableWriter,\n    RstSimpleTableWriter,\n    SpaceAlignedTableWriter,\n    TomlTableWriter,\n    TsvTableWriter,\n    UnicodeTableWriter,\n    YamlTableWriter,\n)\nfrom .text.sourcecode import (\n    JavaScriptTableWriter,\n    NumpyTableWriter,\n    PandasDataFrameWriter,\n    PythonCodeTableWriter,\n)\n'"
pytablewriter/writer/_common.py,0,"b'from textwrap import dedent\n\n\nimport_error_msg_template = dedent(\n    """"""\\\n    dependency packages for {0} not found.\n    you can install the dependencies with \'pip install pytablewriter[{0}]\'\n    """"""\n)\n'"
pytablewriter/writer/_elasticsearch.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\n\nimport copy\nfrom typing import Dict, Generator\n\nimport dataproperty\nimport msgfy\nfrom dataproperty import ColumnDataProperty\nfrom typepy import Typecode\n\nfrom ._table_writer import AbstractTableWriter\n\n\ndef _get_es_datatype(column_dp: ColumnDataProperty) -> Dict[str, str]:\n    if column_dp.typecode in (\n        Typecode.NONE,\n        Typecode.NULL_STRING,\n        Typecode.INFINITY,\n        Typecode.NAN,\n    ):\n        return {""type"": ""keyword""}\n\n    if column_dp.typecode == Typecode.STRING:\n        return {""type"": ""text""}\n\n    if column_dp.typecode == Typecode.DATETIME:\n        return {""type"": ""date"", ""format"": ""date_optional_time""}\n\n    if column_dp.typecode == Typecode.REAL_NUMBER:\n        return {""type"": ""double""}\n\n    if column_dp.typecode == Typecode.BOOL:\n        return {""type"": ""boolean""}\n\n    if column_dp.typecode == Typecode.IP_ADDRESS:\n        return {""type"": ""ip""}\n\n    if column_dp.typecode == Typecode.INTEGER:\n        assert column_dp.bit_length is not None\n\n        if column_dp.bit_length <= 8:\n            return {""type"": ""byte""}\n        elif column_dp.bit_length <= 16:\n            return {""type"": ""short""}\n        elif column_dp.bit_length <= 32:\n            return {""type"": ""integer""}\n        elif column_dp.bit_length <= 64:\n            return {""type"": ""long""}\n\n        raise ValueError(\n            ""too large integer bits: expected<=64bits, actual={:d}bits"".format(column_dp.bit_length)\n        )\n\n    raise ValueError(""unknown typecode: {}"".format(column_dp.typecode))\n\n\nclass ElasticsearchWriter(AbstractTableWriter):\n    """"""\n    A table writer class for Elasticsearch.\n\n    :Dependency Packages:\n        - `elasticsearch-py <https://github.com/elastic/elasticsearch-py>`__\n\n    .. py:attribute:: index_name\n        :type: str\n\n        Alias attribute for |table_name|.\n\n    .. py:attribute:: document_type\n        :type: str\n        :value: ""table""\n\n        Specify document type for indices.\n\n    .. py:method:: write_table()\n\n        Create an index and put documents for each row to Elasticsearch.\n\n        You need to pass an\n        `elasticsearch.Elasticsearch <https://elasticsearch-py.rtfd.io/en/master/api.html#elasticsearch>`__\n        instance to |stream| before calling this method.\n        |table_name|/:py:attr:`~pytablewriter.ElasticsearchWriter.index_name`\n        used as the creating index name,\n        invalid characters in the name are replaced with underscore (``\'_\'``).\n        Document data types for documents are automatically detected\n        from the data.\n\n        :raises ValueError:\n            If the |stream| has not elasticsearch.Elasticsearch instance.\n        :Example:\n            :ref:`example-elasticsearch-table-writer`\n    """"""\n\n    FORMAT_NAME = ""elasticsearch""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    @property\n    def table_name(self) -> str:\n        return super().table_name\n\n    @table_name.setter\n    def table_name(self, value) -> None:\n        from ..sanitizer import ElasticsearchIndexNameSanitizer\n        from pathvalidate import ValidationError, ErrorReason\n\n        try:\n            self._table_name = ElasticsearchIndexNameSanitizer(value).sanitize(replacement_text=""_"")\n        except ValidationError as e:\n            if e.reason is ErrorReason.NULL_NAME:\n                self._table_name = """"\n            else:\n                raise\n\n    @property\n    def index_name(self) -> str:\n        return self.table_name\n\n    @index_name.setter\n    def index_name(self, value: str) -> None:\n        self.table_name = value\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.stream = None\n        self.is_padding = False\n        self.is_formatting_float = False\n        self._is_require_table_name = True\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n        self._dp_extractor.type_value_map = copy.deepcopy(dataproperty.DefaultValue.TYPE_VALUE_MAP)\n\n        self.document_type = ""table""\n\n    def write_null_line(self) -> None:\n        pass\n\n    def _get_mappings(self) -> Dict[str, Dict]:\n        properties = {}\n\n        for header, column_dp in zip(self.headers, self._column_dp_list):\n            properties[header] = _get_es_datatype(column_dp)\n\n        return {""mappings"": {self.document_type: {""properties"": properties}}}\n\n    def _get_body(self) -> Generator:\n        str_datatype = (Typecode.DATETIME, Typecode.IP_ADDRESS, Typecode.INFINITY, Typecode.NAN)\n\n        for value_dp_list in self._table_value_dp_matrix:\n            values = [\n                value_dp.data if value_dp.typecode not in str_datatype else value_dp.to_str()\n                for value_dp in value_dp_list\n            ]\n\n            yield dict(zip(self.headers, values))\n\n    def _write_table(self, **kwargs) -> None:\n        import elasticsearch as es\n\n        if not isinstance(self.stream, es.Elasticsearch):\n            raise ValueError(""stream must be an elasticsearch.Elasticsearch instance"")\n\n        self._verify_value_matrix()\n        self._preprocess()\n\n        mappings = self._get_mappings()\n\n        try:\n            result = self.stream.indices.create(index=self.index_name, body=mappings)\n            self._logger.logger.debug(result)\n        except es.TransportError as e:\n            if e.error == ""index_already_exists_exception"":\n                # ignore already existing index\n                self._logger.logger.debug(msgfy.to_error_message(e))\n            else:\n                raise\n\n        for body in self._get_body():\n            try:\n                self.stream.index(index=self.index_name, body=body, doc_type=self.document_type)\n            except es.exceptions.RequestError as e:\n                self._logger.logger.error(""{}, body={}"".format(msgfy.to_error_message(e), body))\n\n    def _write_value_row_separator(self) -> None:\n        pass\n'"
pytablewriter/writer/_interface.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\n\nimport abc\n\n\nclass TableWriterInterface(metaclass=abc.ABCMeta):\n    """"""\n    Interface class for writing a table.\n    """"""\n\n    @abc.abstractproperty\n    def format_name(self) -> str:  # pragma: no cover\n        """"""Format name for the writer.\n\n        Returns:\n            |str|\n        """"""\n\n    @abc.abstractproperty\n    def support_split_write(self) -> bool:  # pragma: no cover\n        """"""Represents the writer class supported iterative table writing (``write_table_iter`` method).\n\n        Returns:\n            bool: |True| if the writer supported iterative table writing.\n        """"""\n\n    @abc.abstractmethod\n    def write_table(self, **kwargs) -> None:  # pragma: no cover\n        """"""\n        |write_table|.\n        """"""\n\n    def dump(self, output, close_after_write: bool, **kwargs) -> None:  # pragma: no cover\n        raise NotImplementedError(""{} writer did not support dump method"".format(self.format_name))\n\n    def dumps(self) -> str:  # pragma: no cover\n        raise NotImplementedError(""{} writer did not support dumps method"".format(self.format_name))\n\n    def write_table_iter(self, **kwargs) -> None:  # pragma: no cover\n        """"""\n        Write a table with iteration. ""Iteration"" means that divide the table\n        writing into multiple processes.\n        This method is useful, especially for large data.\n        The following are premises to execute this method:\n\n        - set iterator to the |value_matrix|\n        - set the number of iterations to the |iteration_length| attribute\n\n        Call back function (Optional):\n        Callback function is called when for each of the iteration of writing\n        a table is completed. To set call back function,\n        set a callback function to the |write_callback| attribute.\n\n        :raises pytablewriter.NotSupportedError:\n            If the class does not support this method.\n\n        .. note::\n            Following classes do not support this method:\n            |HtmlTableWriter|, |RstGridTableWriter|, |RstSimpleTableWriter|.\n            ``support_split_write`` attribute return |True| if the class\n            is supporting this method.\n        """"""\n\n        self._write_table_iter(**kwargs)\n\n    @abc.abstractmethod\n    def _write_table_iter(self, **kwargs) -> None:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def close(self) -> None:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def _write_value_row_separator(self) -> None:  # pragma: no cover\n        pass\n'"
pytablewriter/writer/_null.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\n\nfrom ._interface import TableWriterInterface\nfrom .text._interface import IndentationInterface, TextWriterInterface\n\n\nclass NullTableWriter(IndentationInterface, TextWriterInterface, TableWriterInterface):\n    FORMAT_NAME = ""null""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def set_indent_level(self, indent_level: int) -> None:\n        pass\n\n    def inc_indent_level(self) -> None:\n        pass\n\n    def dec_indent_level(self) -> None:\n        pass\n\n    def write_null_line(self) -> None:\n        pass\n\n    def write_table(self, **kwargs) -> None:\n        pass\n\n    def dump(self, output, close_after_write: bool = True, **kwargs) -> None:\n        pass\n\n    def dumps(self) -> str:\n        return """"\n\n    def _write_table_iter(self, **kwargs) -> None:\n        pass\n\n    def close(self) -> None:\n        pass\n\n    def _write_value_row_separator(self) -> None:\n        pass\n'"
pytablewriter/writer/_table_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport abc\nimport copy\nimport math\nimport warnings\nfrom typing import Mapping  # noqa\nfrom typing import Any, Dict, List, Optional, Sequence, Union, cast\n\nimport msgfy\nimport typepy\nfrom dataproperty import (\n    ColumnDataProperty,\n    DataProperty,\n    DataPropertyExtractor,\n    Format,\n    MatrixFormatting,\n    Preprocessor,\n)\nfrom dataproperty.typing import TransFunc\nfrom tabledata import TableData, convert_idx_to_alphabet, to_value_matrix\nfrom typepy import String, Typecode, extract_typepy_from_dtype\n\nfrom .._logger import WriterLogger\nfrom ..error import EmptyTableDataError, EmptyTableNameError, EmptyValueError, NotSupportedError\nfrom ..style import Align, Cell, NullStyler, Style, StylerInterface, ThousandSeparator\nfrom ._interface import TableWriterInterface\n\n\ntry:\n    from typing import Protocol\nexcept ImportError:\n    # typing.Protocol is only available starting from Python 3.8.\n    from .._typing import Protocol  # noqa\n\n\nclass StyleFilterFunc(Protocol):\n    def __call__(self, cell: Cell, **kwargs: Any) -> Optional[Style]:\n        ...\n\n\nclass ColSeparatorStyleFilterFunc(Protocol):\n    def __call__(\n        self, left_cell: Optional[Cell], right_cell: Optional[Cell], **kwargs: Any\n    ) -> Optional[Style]:\n        ...\n\n\n_ts_to_flag = {\n    ThousandSeparator.NONE: Format.NONE,\n    ThousandSeparator.COMMA: Format.THOUSAND_SEPARATOR,\n    ThousandSeparator.SPACE: Format.THOUSAND_SEPARATOR,\n    ThousandSeparator.UNDERSCORE: Format.THOUSAND_SEPARATOR,\n}\n\n\nclass AbstractTableWriter(TableWriterInterface, metaclass=abc.ABCMeta):\n    """"""\n    An abstract base class of table writer classes.\n\n    .. py:attribute:: stream\n\n        Stream to write tables.\n        You can use arbitrary stream which supported ``write`` method\n        such as ``sys.stdout``, file stream, ``StringIO``, and so forth.\n        Defaults to ``sys.stdout``.\n\n        :Example:\n            :ref:`example-configure-stream`\n\n    .. py:attribute:: is_write_header\n        :type: bool\n\n        Write headers of a table if the value is |True|.\n\n    .. py:attribute:: is_padding\n        :type: bool\n\n        Padding for each item in the table if the value is |True|.\n\n    .. py:attribute:: iteration_length\n        :type: int\n\n        The number of iterations to write a table.\n        This value used in :py:meth:`.write_table_iter` method.\n        (defaults to ``-1`` which means number of iterations is indefinite)\n\n    .. py:attribute:: style_filter_kwargs\n        :type: Dict[str, Any]\n\n        Extra keyword arguments for style filter functions.\n        These arguments will passing to filter functions added by\n        :py:meth:`.add_style_filter` or :py:meth:`.add_col_separator_style_filter`\n\n    .. py:attribute:: colorize_terminal\n        :type: bool\n        :value: True\n\n        [Only for text format writers] If |True|, colorize text with |Style| for terminals.\n\n    .. py:attribute:: write_callback\n\n        The value expected to a function.\n        The function called when for each of the iteration of writing a table\n        completed. (defaults to |None|)\n        Example, callback function definition is as follows:\n\n        .. code:: python\n\n            def callback_example(iter_count, iter_length):\n                print(""{:d}/{:d}"".format(iter_count, iter_length))\n\n        Arguments that passed to the callback is:\n\n        - first argument: current iteration number (start from ``1``)\n        - second argument: a total number of iteration\n    """"""\n\n    @property\n    def is_formatting_float(self) -> bool:\n        return self._dp_extractor.is_formatting_float\n\n    @is_formatting_float.setter\n    def is_formatting_float(self, value: bool) -> None:\n        if self._dp_extractor.is_formatting_float == value:\n            return\n\n        self._dp_extractor.is_formatting_float = value\n        self.__clear_preprocess()\n\n    @property\n    def margin(self) -> int:\n        raise NotImplementedError()\n\n    @margin.setter\n    def margin(self, value: int) -> None:\n        raise NotImplementedError()\n\n    @property\n    def headers(self) -> Sequence[str]:\n        """"""\n        List of table header to write.\n        """"""\n\n        return self._dp_extractor.headers\n\n    @headers.setter\n    def headers(self, value: Sequence[str]) -> None:\n        self._dp_extractor.headers = value\n\n    @property\n    def header_list(self):\n        warnings.warn(""\'header_list\' has moved to \'headers\'"", DeprecationWarning)\n\n        return self.headers\n\n    @header_list.setter\n    def header_list(self, value):\n        warnings.warn(""\'header_list\' has moved to \'headers\'"", DeprecationWarning)\n        self.headers = value\n\n    @property\n    def value_matrix(self) -> List:\n        """"""\n        Tabular data to write.\n        """"""\n\n        return self.__value_matrix_org\n\n    @value_matrix.setter\n    def value_matrix(self, value_matrix: Sequence) -> None:\n        self.__set_value_matrix(value_matrix)\n        self.__clear_preprocess()\n\n    @property\n    def tabledata(self) -> TableData:\n        """"""Get tabular data of the writer.\n\n        Returns:\n            tabledata.TableData:\n        """"""\n\n        return TableData(\n            self.table_name, self.headers, self.value_matrix, max_workers=self.max_workers\n        )\n\n    @property\n    def type_hints(self) -> Sequence:\n        """"""\n        Type hints for each column of the tabular data.\n        Writers convert data for each column using the type hints information\n        before writing tables when you call ``write_xxx`` methods.\n\n        Acceptable values are as follows:\n\n            - |None| (automatically detect column type from values in the column)\n            - :py:class:`pytablewriter.typehint.Bool`\n            - :py:class:`pytablewriter.typehint.DateTime`\n            - :py:class:`pytablewriter.typehint.Dictionary`\n            - :py:class:`pytablewriter.typehint.Infinity`\n            - :py:class:`pytablewriter.typehint.Integer`\n            - :py:class:`pytablewriter.typehint.IpAddress`\n            - :py:class:`pytablewriter.typehint.List`\n            - :py:class:`pytablewriter.typehint.Nan`\n            - :py:class:`pytablewriter.typehint.NoneType`\n            - :py:class:`pytablewriter.typehint.NullString`\n            - :py:class:`pytablewriter.typehint.RealNumber`\n            - :py:class:`pytablewriter.typehint.String`\n\n        If a type-hint value is not |None|, the writer tries to\n        convert data for each data in a column to type-hint class.\n        If the type-hint value is |None| or failed to convert data,\n        the writer automatically detect column data type from\n        the column data.\n\n        If ``type_hints`` is |None|, the writer detects data types for all\n        of the columns automatically and writes a table by using detected column types.\n\n        Defaults to |None|.\n\n        :Examples:\n            - :ref:`example-type-hint-js`\n            - :ref:`example-type-hint-python`\n        """"""\n\n        return self._dp_extractor.column_type_hints\n\n    @type_hints.setter\n    def type_hints(self, value: Sequence) -> None:\n        hints = list(value)\n        if self.type_hints == hints:\n            return\n\n        self.__set_type_hints(hints)\n        self.__clear_preprocess()\n\n    @property\n    def type_hint_list(self):\n        warnings.warn(""\'type_hint_list\' has moved to \'type_hints\'"", DeprecationWarning)\n\n        return self.type_hints\n\n    @type_hint_list.setter\n    def type_hint_list(self, value):\n        warnings.warn(""\'type_hint_list\' has moved to \'type_hints\'"", DeprecationWarning)\n\n        self.type_hints = value\n\n    @property\n    def styles(self):\n        # deprecated\n        return self.column_styles\n\n    @styles.setter\n    def styles(self, value):\n        # deprecated\n        self.column_styles = value\n\n    @property\n    def style_list(self):\n        warnings.warn(""\'style_list\' has moved to \'column_styles\'"", DeprecationWarning)\n\n        return self.column_styles\n\n    @style_list.setter\n    def style_list(self, value):\n        warnings.warn(""\'style_list\' has moved to \'column_styles\'"", DeprecationWarning)\n\n        self.column_styles = value\n\n    def register_trans_func(self, trans_func: TransFunc) -> None:\n        self._dp_extractor.register_trans_func(trans_func)\n        self.__clear_preprocess()\n\n    @property\n    def value_preprocessor(self):\n        return self._dp_extractor.preprocessor\n\n    @value_preprocessor.setter\n    def value_preprocessor(self, value):\n        warnings.warn(\n            ""this setter will be deleted in the future. use update_preprocessor instead"",\n            DeprecationWarning,\n        )\n\n        if self._dp_extractor.preprocessor == value:\n            return\n\n        self._dp_extractor.preprocessor = value\n        self.__clear_preprocess()\n\n    def update_preprocessor(self, **kwargs) -> None:\n        # TODO: documentation\n        #   is_escape_formula_injection: for CSV/Excel\n\n        if not self._dp_extractor.update_preprocessor(**kwargs):\n            return\n\n        self.__clear_preprocess()\n\n    @property\n    def escape_formula_injection(self):\n        # Deprecated\n        return self._dp_extractor.preprocessor.is_escape_formula_injection\n\n    @escape_formula_injection.setter\n    def escape_formula_injection(self, value) -> None:\n        # Deprecated\n        if self._dp_extractor.preprocessor.is_escape_formula_injection == value:\n            return\n\n        self._dp_extractor.preprocessor.is_escape_formula_injection = value\n        self.__clear_preprocess()\n\n    @property\n    def stream(self):\n        return self._stream\n\n    @stream.setter\n    def stream(self, value) -> None:\n        self._stream = value\n\n    @property\n    def _quoting_flags(self) -> Dict[Typecode, bool]:\n        return self._dp_extractor.quoting_flags\n\n    @_quoting_flags.setter\n    def _quoting_flags(self, value: Mapping[Typecode, bool]) -> None:\n        self._dp_extractor.quoting_flags = value\n        self.__clear_preprocess()\n\n    @property\n    def max_workers(self) -> int:\n        return self._dp_extractor.max_workers\n\n    @max_workers.setter\n    def max_workers(self, value: Optional[int]) -> None:\n        self._dp_extractor.max_workers = value  # type: ignore\n\n    @abc.abstractmethod\n    def _write_table(self, **kwargs) -> None:\n        pass\n\n    def __init__(self) -> None:\n        self._logger = WriterLogger(self)\n\n        self._table_name = """"\n        self.value_matrix = []\n\n        self.is_write_header = True\n        self.is_write_header_separator_row = True\n        self.is_write_value_separator_row = False\n        self.is_write_opening_row = False\n        self.is_write_closing_row = False\n\n        self._use_default_header = False\n\n        self._dp_extractor = DataPropertyExtractor()\n        self._dp_extractor.min_column_width = 1\n        self._dp_extractor.strip_str_header = \'""\'\n        self._dp_extractor.preprocessor = Preprocessor(strip_str=\'""\')\n        self._dp_extractor.type_value_map[Typecode.NONE] = """"\n        self._dp_extractor.matrix_formatting = MatrixFormatting.HEADER_ALIGNED\n        self._dp_extractor.update_strict_level_map({Typecode.BOOL: 1})\n\n        self.is_formatting_float = True\n        self.is_padding = True\n\n        self.headers = []\n        self.type_hints = []\n        self._quoting_flags = {\n            Typecode.BOOL: False,\n            Typecode.DATETIME: True,\n            Typecode.DICTIONARY: False,\n            Typecode.INFINITY: False,\n            Typecode.INTEGER: False,\n            Typecode.IP_ADDRESS: True,\n            Typecode.LIST: False,\n            Typecode.NAN: False,\n            Typecode.NONE: False,\n            Typecode.NULL_STRING: True,\n            Typecode.REAL_NUMBER: False,\n            Typecode.STRING: True,\n        }\n\n        self._is_require_table_name = False\n        self._is_require_header = False\n\n        self.iteration_length = -1\n        self.write_callback = lambda _iter_count, _iter_length: None  # NOP\n        self._iter_count = None  # type: Optional[int]\n\n        self.__default_style = Style()\n        self.__col_style_list = []  # type: List[Optional[Style]]\n        self._style_filters = []  # type: List[StyleFilterFunc]\n        self._styler = self._create_styler(self)\n        self.style_filter_kwargs = {}  # type: Dict[str, Any]\n        self.colorize_terminal = True\n\n        self.max_workers = 1\n\n        self.__clear_preprocess()\n\n    def _repr_html_(self) -> str:\n        from .text._html import HtmlTableWriter\n\n        writer = HtmlTableWriter()\n        writer.table_name = self.table_name\n        writer.headers = self.headers\n        writer.value_matrix = self.value_matrix\n        writer.column_styles = self.column_styles\n\n        return writer.dumps()\n\n    def __clear_preprocess_status(self) -> None:\n        self._is_complete_table_dp_preprocess = False\n        self._is_complete_table_property_preprocess = False\n        self._is_complete_header_preprocess = False\n        self._is_complete_value_matrix_preprocess = False\n\n    def __clear_preprocess_data(self) -> None:\n        self._column_dp_list = []  # type: List[ColumnDataProperty]\n        self._table_headers = []  # type: List[str]\n        self._table_value_matrix = []  # type: List[Union[List[str], Dict]]\n        self._table_value_dp_matrix = []  # type: Sequence[Sequence[DataProperty]]\n\n    @property\n    def table_name(self) -> str:\n        """"""\n        Name of the table.\n        """"""\n\n        return self._table_name\n\n    @table_name.setter\n    def table_name(self, value: str) -> None:\n        self._table_name = value\n\n    @property\n    def default_style(self) -> Style:\n        """"""Default |Style| for each cell.\n        """"""\n\n        return self.__default_style\n\n    @default_style.setter\n    def default_style(self, style) -> None:\n        if style is None:\n            style = Style()\n\n        if not isinstance(style, Style):\n            raise TypeError(""default_style must be a Style instance"")\n\n        if self.__default_style == style:\n            return\n\n        self.__default_style = style\n        self.__clear_preprocess()\n\n    @property\n    def column_styles(self) -> List[Optional[Style]]:\n        """"""Output |Style| for each column.\n\n        Returns:\n            list of |Style|:\n        """"""\n\n        return self.__col_style_list\n\n    @column_styles.setter\n    def column_styles(self, value: Sequence[Optional[Style]]) -> None:\n        if self.__col_style_list == value:\n            return\n\n        self.__col_style_list = list(value)\n\n        if self.__col_style_list:\n            self._dp_extractor.format_flags_list = [\n                _ts_to_flag[self._get_col_style(col_idx).thousand_separator]\n                for col_idx in range(len(self.__col_style_list))\n            ]\n        else:\n            self._dp_extractor.format_flags_list = []\n\n        self.__clear_preprocess()\n\n    def add_style_filter(self, style_filter: StyleFilterFunc) -> None:\n        """"""Add a style filter function.\n\n        Args:\n            style_filter:\n                A function for filtering table cells, the function required to implement\n                the following Protocol:\n\n                .. code-block:: python\n\n                    class StyleFilterFunc(Protocol):\n                        def __call__(self, cell: Cell, **kwargs: Any) -> Optional[Style]:\n                            ...\n        """"""\n\n        self._style_filters.insert(0, style_filter)\n\n    def add_col_separator_style_filter(self, style_filter: ColSeparatorStyleFilterFunc) -> None:\n        raise NotImplementedError(""this method only implemented in text format writer classes"")\n\n    def set_style(self, column: Union[str, int], style: Style) -> None:\n        """"""Set |Style| for a specific column.\n\n        Args:\n            column (|int| or |str|):\n                Column specifier. column index or header name correlated with the column.\n            style (|Style|):\n                Style value to be set to the column.\n\n        Raises:\n            ValueError: If the column specifier is invalid.\n        """"""\n\n        column_idx = None\n\n        while len(self.headers) > len(self.__col_style_list):\n            self.__col_style_list.append(None)\n\n        if isinstance(column, int):\n            column_idx = column\n        elif isinstance(column, str):\n            try:\n                column_idx = self.headers.index(column)\n            except ValueError:\n                pass\n\n        if column_idx is not None:\n            self.__col_style_list[column_idx] = style\n            self.__clear_preprocess()\n            self._dp_extractor.format_flags_list = [\n                _ts_to_flag[self._get_col_style(col_idx).thousand_separator]\n                for col_idx in range(len(self.__col_style_list))\n            ]\n            return\n\n        raise ValueError(""column must be an int or string: actual={}"".format(column))\n\n    def close(self) -> None:\n        """"""\n        Close the current |stream|.\n        """"""\n\n        if self.stream is None:\n            return\n\n        try:\n            self.stream.isatty()\n\n            if self.stream.name in [""<stdin>"", ""<stdout>"", ""<stderr>""]:\n                return\n        except AttributeError:\n            pass\n        except ValueError:\n            # raised when executing an operation to a closed stream\n            pass\n\n        try:\n            from _pytest.compat import CaptureIO\n            from _pytest.capture import EncodedFile\n\n            if isinstance(self.stream, (CaptureIO, EncodedFile)):\n                # avoid closing streams for pytest\n                return\n        except ImportError:\n            pass\n\n        try:\n            from ipykernel.iostream import OutStream\n\n            if isinstance(self.stream, OutStream):\n                # avoid closing streams for Jupyter Notebook\n                return\n        except ImportError:\n            pass\n\n        try:\n            self.stream.close()\n        except AttributeError:\n            self._logger.logger.warning(\n                ""the stream has no close method implementation: type={}"".format(type(self.stream))\n            )\n        finally:\n            self._stream = None\n\n    def from_tabledata(self, value: TableData, is_overwrite_table_name: bool = True) -> None:\n        """"""\n        Set tabular attributes to the writer from |TableData|.\n        Following attributes are configured:\n\n        - :py:attr:`~.table_name`.\n        - :py:attr:`~.headers`.\n        - :py:attr:`~.value_matrix`.\n\n        |TableData| can be created from various data formats by\n        ``pytablereader``. More detailed information can be found in\n        https://pytablereader.rtfd.io/en/latest/\n\n        :param tabledata.TableData value: Input table data.\n        """"""\n\n        self.__clear_preprocess()\n\n        if is_overwrite_table_name:\n            self.table_name = value.table_name if value.table_name else """"\n\n        self.headers = value.headers\n        self.value_matrix = list(value.rows)\n\n        if not value.has_value_dp_matrix:\n            return\n\n        self._table_value_dp_matrix = value.value_dp_matrix\n        self._column_dp_list = self._dp_extractor.to_column_dp_list(\n            self._table_value_dp_matrix, self._column_dp_list\n        )\n        self.__set_type_hints([col_dp.type_class for col_dp in self._column_dp_list])\n\n        self._is_complete_table_dp_preprocess = True\n\n    def from_csv(self, csv_source: str, delimiter: str = "","") -> None:\n        """"""\n        Set tabular attributes to the writer from a character-separated values (CSV) data source.\n        Following attributes are set to the writer by the method:\n\n        - :py:attr:`~.headers`.\n        - :py:attr:`~.value_matrix`.\n\n        :py:attr:`~.table_name` also be set if the CSV data source is a file.\n        In that case, :py:attr:`~.table_name` is as same as the filename.\n\n        :param str csv_source:\n            Input CSV data source either can be designated CSV text or\n            CSV file path.\n\n        :Examples:\n            :ref:`example-from-csv`\n\n        :Dependency Packages:\n            - `pytablereader <https://github.com/thombashi/pytablereader>`__\n        """"""\n\n        import pytablereader as ptr\n\n        loader = ptr.CsvTableTextLoader(csv_source, quoting_flags=self._quoting_flags)\n        loader.delimiter = delimiter\n        try:\n            for table_data in loader.load():\n                self.from_tabledata(table_data, is_overwrite_table_name=False)\n            return\n        except ptr.DataError:\n            pass\n\n        loader = ptr.CsvTableFileLoader(csv_source, quoting_flags=self._quoting_flags)\n        loader.delimiter = delimiter\n        for table_data in loader.load():\n            self.from_tabledata(table_data)\n\n    def from_dataframe(self, dataframe, add_index_column: bool = False) -> None:\n        """"""\n        Set tabular attributes to the writer from :py:class:`pandas.DataFrame`.\n        Following attributes are set by the method:\n\n            - :py:attr:`~.headers`\n            - :py:attr:`~.value_matrix`\n            - :py:attr:`~.type_hints`\n\n        Args:\n            dataframe(pandas.DataFrame or |str|):\n                Input pandas.DataFrame object or pickle.\n            add_index_column(bool, optional):\n                If |True|, add a column of ``index`` of the ``dataframe``.\n                Defaults to |False|.\n\n        Example:\n            :ref:`example-from-pandas-dataframe`\n        """"""\n\n        if typepy.String(dataframe).is_type():\n            import pandas as pd\n\n            dataframe = pd.read_pickle(dataframe)\n\n        self.headers = list(dataframe.columns.values)\n        self.type_hints = [extract_typepy_from_dtype(dtype) for dtype in dataframe.dtypes]\n\n        if add_index_column:\n            self.headers = [""""] + self.headers\n            if self.type_hints:\n                self.type_hints = [None] + self.type_hints\n            self.value_matrix = [\n                [index] + row\n                for index, row in zip(dataframe.index.tolist(), dataframe.values.tolist())\n            ]\n        else:\n            self.value_matrix = dataframe.values.tolist()\n\n    def from_series(self, series, add_index_column: bool = True) -> None:\n        """"""\n        Set tabular attributes to the writer from :py:class:`pandas.Series`.\n        Following attributes are set by the method:\n\n            - :py:attr:`~.headers`\n            - :py:attr:`~.value_matrix`\n            - :py:attr:`~.type_hints`\n\n        Args:\n            series(pandas.Series):\n                Input pandas.Series object.\n            add_index_column(bool, optional):\n                If |True|, add a column of ``index`` of the ``series``.\n                Defaults to |True|.\n        """"""\n\n        if series.name:\n            self.headers = [series.name]\n        else:\n            self.headers = [""value""]\n\n        self.type_hints = [extract_typepy_from_dtype(series.dtype)]\n\n        if add_index_column:\n            self.headers = [""""] + self.headers\n            if self.type_hints:\n                self.type_hints = [None] + self.type_hints\n            self.value_matrix = [\n                [index] + [value] for index, value in zip(series.index.tolist(), series.tolist())\n            ]\n        else:\n            self.value_matrix = [[value] for value in series.tolist()]\n\n    def from_tablib(self, tablib_dataset) -> None:\n        """"""\n        Set tabular attributes to the writer from :py:class:`tablib.Dataset`.\n        """"""\n\n        self.headers = tablib_dataset.headers\n        self.value_matrix = [row for row in tablib_dataset]\n\n    def from_writer(\n        self, writer: ""AbstractTableWriter"", is_overwrite_table_name: bool = True\n    ) -> None:\n        """"""\n        Set tabular attributes to the writer from an another table writer class incetance.\n        """"""\n\n        self.__clear_preprocess()\n\n        if is_overwrite_table_name:\n            self.table_name = str(writer.table_name)\n\n        self.headers = writer.headers\n        self.value_matrix = writer.value_matrix\n\n        self.type_hints = writer.type_hints\n        self.column_styles = writer.column_styles\n        self._style_filters = writer._style_filters\n\n        self._table_headers = writer._table_headers\n        self._table_value_dp_matrix = writer._table_value_dp_matrix\n        self._column_dp_list = writer._column_dp_list\n        self._table_value_matrix = writer._table_value_matrix\n\n        self._is_complete_table_dp_preprocess = writer._is_complete_table_dp_preprocess\n        self._is_complete_table_property_preprocess = writer._is_complete_table_property_preprocess\n        self._is_complete_header_preprocess = writer._is_complete_header_preprocess\n        self._is_complete_value_matrix_preprocess = writer._is_complete_value_matrix_preprocess\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table|.\n        """"""\n\n        with self._logger:\n            self._verify_property()\n            self._write_table(**kwargs)\n\n    def _write_table_iter(self, **kwargs) -> None:\n        if not self.support_split_write:\n            raise NotSupportedError(""the class not supported the write_table_iter method"")\n\n        self._verify_table_name()\n        self._verify_stream()\n\n        if all(\n            [typepy.is_empty_sequence(self.headers), typepy.is_empty_sequence(self.value_matrix)]\n        ):\n            raise EmptyTableDataError()\n\n        self._verify_header()\n\n        self._logger.logger.debug(\n            ""_write_table_iter: iteration-length={:d}"".format(self.iteration_length)\n        )\n\n        stash_is_write_header = self.is_write_header\n        stach_is_write_opening_row = self.is_write_opening_row\n        stash_is_write_closing_row = self.is_write_closing_row\n\n        try:\n            self.is_write_closing_row = False\n            self._iter_count = 1\n\n            for work_matrix in self.value_matrix:\n                is_final_iter = all(\n                    [self.iteration_length > 0, self._iter_count >= self.iteration_length]\n                )\n\n                if is_final_iter:\n                    self.is_write_closing_row = True\n\n                self.__set_value_matrix(work_matrix)\n                self.__clear_preprocess_status()\n\n                with self._logger:\n                    self._write_table(**kwargs)\n\n                    if not is_final_iter:\n                        self._write_value_row_separator()\n\n                self.is_write_opening_row = False\n                self.is_write_header = False\n\n                self.write_callback(self._iter_count, self.iteration_length)\n\n                # update typehint for the next iteration\n                """"""\n                if self.type_hints is None:\n                    self.__set_type_hints([\n                        column_dp.type_class for column_dp in self._column_dp_list\n                    ])\n                """"""\n\n                if is_final_iter:\n                    break\n\n                self._iter_count += 1\n        finally:\n            self.is_write_header = stash_is_write_header\n            self.is_write_opening_row = stach_is_write_opening_row\n            self.is_write_closing_row = stash_is_write_closing_row\n            self._iter_count = None\n\n    def _get_padding_len(\n        self, column_dp: ColumnDataProperty, value_dp: Optional[DataProperty] = None\n    ) -> int:\n        if not self.is_padding:\n            return 0\n\n        try:\n            return cast(DataProperty, value_dp).get_padding_len(column_dp.ascii_char_width)\n        except AttributeError:\n            return column_dp.ascii_char_width\n\n    def _to_header_item(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        format_string = self._get_header_format_string(col_dp, value_dp)\n        header = String(value_dp.data).force_convert().strip()\n        default_style = self._get_col_style(col_dp.column_index)\n        style = self._fetch_style_from_filter(-1, col_dp, value_dp, default_style)\n\n        return self._styler.apply_terminal_style(format_string.format(header), style=style)\n\n    def _get_header_format_string(\n        self, _col_dp: ColumnDataProperty, _value_dp: DataProperty\n    ) -> str:\n        return ""{:s}""\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        default_style = self._get_col_style(col_dp.column_index)\n        style = self._fetch_style_from_filter(row_idx, col_dp, value_dp, default_style)\n        value = self._apply_style_to_row_item(row_idx, col_dp, value_dp, style)\n\n        return self._styler.apply_terminal_style(value, style=style)\n\n    def _apply_style_to_row_item(\n        self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty, style: Style\n    ) -> str:\n        return self._styler.apply_align(\n            self._styler.apply(col_dp.dp_to_str(value_dp), style=style), style=style\n        )\n\n    def _fetch_style_from_filter(\n        self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty, default_style: Style\n    ) -> Style:\n        self.style_filter_kwargs.update({""writer"": self})\n\n        style = None  # Optional[Style]\n\n        for style_filter in self._style_filters:\n            style = style_filter(\n                Cell(\n                    row=row_idx,\n                    col=col_dp.column_index,\n                    value=value_dp.data,\n                    default_style=default_style,\n                ),\n                **self.style_filter_kwargs\n            )\n            if style:\n                break\n\n        if style is None:\n            style = copy.deepcopy(default_style)\n\n        if style.align is None or (style.align == Align.AUTO and row_idx >= 0):\n            style.align = self.__retrieve_align_from_data(col_dp, value_dp)\n\n        if style.padding is None:\n            style.padding = self._get_padding_len(col_dp, value_dp)\n\n        return style\n\n    def _get_col_style(self, col_idx: int) -> Style:\n        try:\n            style = self.column_styles[col_idx]\n        except (TypeError, IndexError, KeyError):\n            pass\n        else:\n            if style:\n                return style\n\n        return self.default_style\n\n    def _get_align(self, col_idx: int, default_align: Align) -> Align:\n        align = self._get_col_style(col_idx).align\n\n        if align is None:\n            return default_align\n\n        if align == Align.AUTO:\n            return default_align\n\n        return align\n\n    def __retrieve_align_from_data(\n        self, col_dp: ColumnDataProperty, value_dp: DataProperty\n    ) -> Align:\n        if col_dp.typecode == Typecode.STRING and (\n            value_dp.typecode in (Typecode.INTEGER, Typecode.REAL_NUMBER)\n            or value_dp.typecode == Typecode.STRING\n            and value_dp.is_include_ansi_escape\n        ):\n            return value_dp.align\n\n        return col_dp.align\n\n    def _verify_property(self) -> None:\n        self._verify_table_name()\n        self._verify_stream()\n\n        if all(\n            [\n                typepy.is_empty_sequence(self.headers),\n                typepy.is_empty_sequence(self.value_matrix),\n                typepy.is_empty_sequence(self._table_value_dp_matrix),\n            ]\n        ):\n            raise EmptyTableDataError()\n\n        self._verify_header()\n        try:\n            self._verify_value_matrix()\n        except EmptyValueError:\n            pass\n\n    def __set_value_matrix(self, value_matrix):\n        self.__value_matrix_org = value_matrix\n\n    def __set_type_hints(self, type_hints):\n        self._dp_extractor.column_type_hints = type_hints\n\n    def _verify_table_name(self) -> None:\n        if all([self._is_require_table_name, typepy.is_null_string(self.table_name)]):\n            raise EmptyTableNameError(\n                ""table_name must be a string, with at least one or more character.""\n            )\n\n    def _verify_stream(self) -> None:\n        if self.stream is None:\n            raise OSError(""null output stream"")\n\n    def _verify_header(self) -> None:\n        if self._is_require_header and not self._use_default_header:\n            self._validate_empty_header()\n\n    def _validate_empty_header(self) -> None:\n        """"""\n        Raises:\n            ValueError: If the |headers| is empty.\n        """"""\n\n        if typepy.is_empty_sequence(self.headers):\n            raise ValueError(""headers expected to have one or more header names"")\n\n    def _verify_value_matrix(self) -> None:\n        if typepy.is_empty_sequence(self.value_matrix):\n            raise EmptyValueError()\n\n    def _create_styler(self, writer) -> StylerInterface:\n        return NullStyler(writer)\n\n    def _preprocess_table_dp(self) -> None:\n        if self._is_complete_table_dp_preprocess:\n            return\n\n        self._logger.logger.debug(""_preprocess_table_dp"")\n\n        if typepy.is_empty_sequence(self.headers) and self._use_default_header:\n            self.headers = [\n                convert_idx_to_alphabet(col_idx)\n                for col_idx in range(len(self.__value_matrix_org[0]))\n            ]\n\n        try:\n            self._table_value_dp_matrix = self._dp_extractor.to_dp_matrix(\n                to_value_matrix(self.headers, self.__value_matrix_org)\n            )\n        except TypeError as e:\n            self._logger.logger.debug(msgfy.to_error_message(e))\n            self._table_value_dp_matrix = []\n\n        self._column_dp_list = self._dp_extractor.to_column_dp_list(\n            self._table_value_dp_matrix, self._column_dp_list\n        )\n\n        self._is_complete_table_dp_preprocess = True\n\n    def _preprocess_table_property(self) -> None:\n        if self._is_complete_table_property_preprocess:\n            return\n\n        self._logger.logger.debug(""_preprocess_table_property"")\n\n        if self._iter_count == 1:\n            for column_dp in self._column_dp_list:\n                column_dp.extend_width(int(math.ceil(column_dp.ascii_char_width * 0.25)))\n\n        for column_dp in self._column_dp_list:\n            style = self._get_col_style(column_dp.column_index)\n            column_dp.extend_body_width(self._styler.get_additional_char_width(style))\n\n        self._is_complete_table_property_preprocess = True\n\n    def _preprocess_header(self) -> None:\n        if self._is_complete_header_preprocess:\n            return\n\n        self._logger.logger.debug(""_preprocess_header"")\n\n        self._table_headers = [\n            self._to_header_item(col_dp, header_dp)\n            for col_dp, header_dp in zip(\n                self._column_dp_list, self._dp_extractor.to_header_dp_list()\n            )\n        ]\n\n        self._is_complete_header_preprocess = True\n\n    def _preprocess_value_matrix(self) -> None:\n        if self._is_complete_value_matrix_preprocess:\n            return\n\n        self._logger.logger.debug(\n            ""_preprocess_value_matrix: value-rows={}"".format(len(self._table_value_dp_matrix))\n        )\n\n        self._table_value_matrix = [\n            [\n                self._to_row_item(row_idx, col_dp, value_dp)\n                for col_dp, value_dp in zip(self._column_dp_list, value_dp_list)\n            ]\n            for row_idx, value_dp_list in enumerate(self._table_value_dp_matrix)\n        ]\n\n        self._is_complete_value_matrix_preprocess = True\n\n    def _preprocess(self) -> None:\n        self._preprocess_table_dp()\n        self._preprocess_table_property()\n        self._preprocess_header()\n        self._preprocess_value_matrix()\n\n    def __clear_preprocess(self) -> None:\n        self.__clear_preprocess_status()\n        self.__clear_preprocess_data()\n'"
test/sanitizer/__init__.py,0,b''
test/sanitizer/_common.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport random\nimport string\n\n\nalphanum_chars = [x for x in string.digits + string.ascii_letters]\n\n\nINVALID_PATH_CHARS = [""\\0""]\nINVALID_FILENAME_CHARS = [""/""]\nINVALID_WIN_PATH_CHARS = ["":"", ""*"", ""?"", \'""\', ""<"", "">"", ""|""] + INVALID_PATH_CHARS\nINVALID_WIN_FILENAME_CHARS = INVALID_WIN_PATH_CHARS + INVALID_FILENAME_CHARS + [""\\\\""]\n\nVALID_FILENAME_CHARS = [\n    ""!"",\n    ""#"",\n    ""$"",\n    ""&"",\n    ""\'"",\n    ""_"",\n    ""="",\n    ""~"",\n    ""^"",\n    ""@"",\n    ""`"",\n    ""["",\n    ""]"",\n    ""+"",\n    ""-"",\n    "";"",\n    ""{"",\n    ""}"",\n    "","",\n    ""."",\n    ""("",\n    "")"",\n    ""%"",\n]\nVALID_PATH_CHARS = VALID_FILENAME_CHARS + [""/""]\n\nINVALID_JS_VAR_CHARS = INVALID_WIN_FILENAME_CHARS + [\n    ""!"",\n    ""#"",\n    ""&"",\n    ""\'"",\n    ""="",\n    ""~"",\n    ""^"",\n    ""@"",\n    ""`"",\n    ""["",\n    ""]"",\n    ""+"",\n    ""-"",\n    "";"",\n    ""{"",\n    ""}"",\n    "","",\n    ""."",\n    ""("",\n    "")"",\n    ""%"",\n    "" "",\n    ""\\t"",\n    ""\\n"",\n    ""\\r"",\n    ""\\f"",\n    ""\\v"",\n]\nINVALID_PYTHON_VAR_CHARS = INVALID_JS_VAR_CHARS + [""$""]\n\n\ndef make_random_str(length, chars=alphanum_chars):\n    return """".join([random.choice(chars) for _i in range(length)])\n'"
test/sanitizer/test_elasticsearch.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport itertools\n\nimport pytest\n\nfrom pytablewriter.sanitizer import ElasticsearchIndexNameSanitizer\n\n\nINVALID_ES_CHARS = [""\\\\"", "","" ""*"", ""?"", \'""\', ""<"", "">"", ""|"", "" ""]\n\n\nclass Test_ElasticsearchIndexNameSanitizer:\n    SANITIZE_CHAR_LIST = INVALID_ES_CHARS\n    NOT_SANITIZE_CHAR_LIST = [""_""]\n    REPLACE_TEXT_LIST = ["""", ""_""]\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [\n            [""A"" + c + ""B"", rep, ""A"" + rep + ""B""]\n            for c, rep in itertools.product(SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [""A"" + c + ""B"", rep, ""A"" + c + ""B""]\n            for c, rep in itertools.product(NOT_SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ],\n    )\n    def test_normal(self, value, replace_text, expected):\n        sanitized_name = ElasticsearchIndexNameSanitizer(value).sanitize(replace_text)\n\n        assert sanitized_name == expected\n\n        ElasticsearchIndexNameSanitizer(sanitized_name).validate()\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_char + ""hoge_123"", ""_"", ""hoge_123""] for invalid_char in ""_""]\n        + [[invalid_char + ""hoge_123"", ""a"", ""ahoge_123""] for invalid_char in ""_""],\n    )\n    def test_normal_invalid_first_char_x1(self, value, replace_text, expected):\n        sanitized_name = ElasticsearchIndexNameSanitizer(value).sanitize(replace_text)\n\n        assert sanitized_name == expected\n\n        ElasticsearchIndexNameSanitizer(sanitized_name).validate()\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_char * 2 + ""hoge_123"", ""_"", ""hoge_123""] for invalid_char in ""_""]\n        + [[invalid_char * 2 + ""hoge_123"", ""a"", ""aahoge_123""] for invalid_char in ""_""],\n    )\n    def test_normal_invalid_first_char_x2(self, value, replace_text, expected):\n        sanitized_name = ElasticsearchIndexNameSanitizer(value).sanitize(replace_text)\n\n        assert sanitized_name == expected\n\n        ElasticsearchIndexNameSanitizer(sanitized_name).validate()\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""], [[None, ValueError], [1, TypeError], [True, TypeError]]\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            ElasticsearchIndexNameSanitizer(value).validate()\n'"
test/sanitizer/test_excel.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport itertools\nimport random\n\nimport pytest\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom pytablewriter.sanitizer import sanitize_excel_sheet_name, validate_excel_sheet_name\n\nfrom ._common import VALID_PATH_CHARS, make_random_str\n\n\nrandom.seed(0)\n\nINVALID_EXCEL_CHARS = [""["", ""]"", "":"", ""*"", ""?"", ""/"", ""\\\\""]\n\n\nclass Test_validate_excel_sheet_name:\n    VALID_CHAR_LIST = set(VALID_PATH_CHARS).difference(set(INVALID_EXCEL_CHARS))\n    INVALID_CHAR_LIST = INVALID_EXCEL_CHARS\n\n    @pytest.mark.parametrize(\n        [""value""],\n        [\n            [make_random_str(15) + invalid_char + make_random_str(15)]\n            for invalid_char in VALID_CHAR_LIST\n        ],\n    )\n    def test_normal(self, value):\n        validate_excel_sheet_name(value)\n\n    @pytest.mark.parametrize([""value""], [[""\xe3\x81\x82\xe3\x81\x84\xe3\x81\x86\xe3\x81\x88\xe3\x81\x8a""], [""\xe3\x82\xb7\xe3\x83\xbc\xe3\x83\x88""]])\n    def test_normal_multibyte(self, value):\n        validate_excel_sheet_name(value)\n\n    @pytest.mark.parametrize(\n        [""value""],\n        [\n            [make_random_str(15) + invalid_char + make_random_str(15)]\n            for invalid_char in INVALID_CHAR_LIST\n        ],\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_excel_sheet_name(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [None, ValidationError],\n            ["""", ValidationError],\n            [1, TypeError],\n            [True, TypeError],\n            [""a"" * 32, ValidationError],\n        ],\n    )\n    def test_exception(self, value, expected):\n        with pytest.raises(expected):\n            validate_excel_sheet_name(value)\n\n\nclass Test_sanitize_excel_sheet_name:\n    SANITIZE_CHAR_LIST = INVALID_EXCEL_CHARS\n    NOT_SANITIZE_CHAR_LIST = set(VALID_PATH_CHARS).difference(set(INVALID_EXCEL_CHARS))\n    REPLACE_TEXT_LIST = ["""", ""_""]\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [\n            [""A"" + c + ""B"", rep, ""A"" + rep + ""B""]\n            for c, rep in itertools.product(SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [""A"" + c + ""B"", rep, ""A"" + c + ""B""]\n            for c, rep in itertools.product(NOT_SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ]\n        + [[""a"" * 32, """", ""a"" * 31]],\n    )\n    def test_normal(self, value, replace_text, expected):\n        sanitized_name = sanitize_excel_sheet_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_excel_sheet_name(sanitized_name)\n\n    @pytest.mark.parametrize([""value"", ""expected""], [[""\xe3\x81\x82\xe3\x81\x84*\xe3\x81\x86\xe3\x81\x88\xe3\x81\x8a"", ""\xe3\x81\x82\xe3\x81\x84\xe3\x81\x86\xe3\x81\x88\xe3\x81\x8a""], [""\xe3\x82\xb7\xe3\x83\xbc?\xe3\x83\x88"", ""\xe3\x82\xb7\xe3\x83\xbc\xe3\x83\x88""]])\n    def test_normal_multibyte(self, value, expected):\n        sanitize_excel_sheet_name(value)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""], [[None, ValueError], [1, ValueError], [True, ValueError]]\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            sanitize_excel_sheet_name(value)\n'"
test/sanitizer/test_js_var_name.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport itertools\nimport string\n\nimport pytest\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom pytablewriter.sanitizer import sanitize_js_var_name, validate_js_var_name\n\nfrom ._common import INVALID_JS_VAR_CHARS\n\n\nRESERVED_KEYWORDS = [\n    ""break"",\n    ""case"",\n    ""catch"",\n    ""class"",\n    ""const"",\n    ""continue"",\n    ""debugger"",\n    ""default"",\n    ""delete"",\n    ""do"",\n    ""else"",\n    ""export"",\n    ""extends"",\n    ""finally"",\n    ""for"",\n    ""function"",\n    ""if"",\n    ""import"",\n    ""in"",\n    ""instanceof"",\n    ""new"",\n    ""return"",\n    ""super"",\n    ""switch"",\n    ""this"",\n    ""throw"",\n    ""try"",\n    ""typeof"",\n    ""var"",\n    ""void"",\n    ""while"",\n    ""with"",\n    ""yield"",\n    ""enum"",\n    ""implements"",\n    ""interface"",\n    ""let"",\n    ""package"",\n    ""private"",\n    ""protected"",\n    ""public"",\n    ""static"",\n    ""await"",\n    ""abstract"",\n    ""boolean"",\n    ""byte"",\n    ""char"",\n    ""double"",\n    ""final"",\n    ""float"",\n    ""goto"",\n    ""int"",\n    ""long"",\n    ""native"",\n    ""short"",\n    ""synchronized"",\n    ""throws"",\n    ""transient"",\n    ""volatile"",\n    ""null"",\n    ""true"",\n    ""false"",\n]\n\n\nclass Test_validate_js_var_name:\n    VALID_CHAR_LIST = [c for c in string.digits + string.ascii_letters + ""_""]\n    INVALID_CHAR_LIST = INVALID_JS_VAR_CHARS\n\n    @pytest.mark.parametrize(\n        [""value""], [[""abc"" + valid_char + ""hoge123""] for valid_char in VALID_CHAR_LIST]\n    )\n    def test_normal(self, value):\n        validate_js_var_name(value)\n\n    @pytest.mark.parametrize(\n        [""value""], [[""abc"" + invalid_char + ""hoge123""] for invalid_char in INVALID_CHAR_LIST]\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_js_var_name(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n    @pytest.mark.parametrize(\n        [""value""], [[invalid_char + ""hoge123""] for invalid_char in string.digits + ""_""]\n    )\n    def test_exception_invalid_first_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_js_var_name(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [None, ValueError],\n            ["""", ValidationError],\n            [""123"", ValueError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            validate_js_var_name(value)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [[reserved_keyword, ErrorReason.RESERVED_NAME] for reserved_keyword in RESERVED_KEYWORDS],\n    )\n    def test_exception_reserved(self, value, expected):\n        with pytest.raises(ValidationError) as e:\n            validate_js_var_name(value)\n        assert e.value.reason == expected\n        assert e.value.reusable_name is False\n\n\nclass Test_sanitize_js_var_name:\n    SANITIZE_CHAR_LIST = INVALID_JS_VAR_CHARS\n    NOT_SANITIZE_CHAR_LIST = [""_""]\n    REPLACE_TEXT_LIST = ["""", ""_""]\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [\n            [""A"" + c + ""B"", rep, ""A"" + rep + ""B""]\n            for c, rep in itertools.product(SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [""A"" + c + ""B"", rep, ""A"" + c + ""B""]\n            for c, rep in itertools.product(NOT_SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ],\n    )\n    def test_normal(self, value, replace_text, expected):\n        sanitized_name = sanitize_js_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_js_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_char + ""hoge_123"", ""_"", ""hoge_123""] for invalid_char in string.digits + ""_""]\n        + [[invalid_char + ""hoge_123"", ""a"", ""ahoge_123""] for invalid_char in string.digits + ""_""],\n    )\n    def test_normal_invalid_first_char_x1(self, value, replace_text, expected):\n        sanitized_name = sanitize_js_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_js_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_char * 2 + ""hoge_123"", ""_"", ""hoge_123""] for invalid_char in string.digits + ""_""]\n        + [\n            [invalid_char * 2 + ""hoge_123"", ""a"", ""aahoge_123""]\n            for invalid_char in string.digits + ""_""\n        ],\n    )\n    def test_normal_invalid_first_char_x2(self, value, replace_text, expected):\n        sanitized_name = sanitize_js_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_js_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [[reserved_keyword, reserved_keyword + ""_""] for reserved_keyword in RESERVED_KEYWORDS],\n    )\n    def test_normal_reserved(self, value, expected):\n        assert sanitize_js_var_name(value) == expected\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""], [[None, ValueError], [1, TypeError], [True, TypeError]]\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            sanitize_js_var_name(value)\n'"
test/sanitizer/test_python_var_name.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport itertools\nimport string\n\nimport pytest\nfrom pathvalidate.error import ErrorReason, ValidationError\n\nfrom pytablewriter.sanitizer import sanitize_python_var_name, validate_python_var_name\n\nfrom ._common import INVALID_PYTHON_VAR_CHARS\n\n\nRESERVED_KEYWORDS = [\n    ""and"",\n    ""del"",\n    ""from"",\n    ""not"",\n    ""while"",\n    ""as"",\n    ""elif"",\n    ""global"",\n    ""or"",\n    ""with"",\n    ""assert"",\n    ""else"",\n    ""if"",\n    ""pass"",\n    ""yield"",\n    ""break"",\n    ""except"",\n    ""import"",\n    ""print"",\n    ""class"",\n    ""exec"",\n    ""in"",\n    ""raise"",\n    ""continue"",\n    ""finally"",\n    ""is"",\n    ""return"",\n    ""def"",\n    ""for"",\n    ""lambda"",\n    ""try"",\n    ""False"",\n    ""True"",\n    ""None"",\n    ""NotImplemented"",\n    ""Ellipsis"",\n]\n\n\nclass Test_validate_python_var_name:\n    VALID_CHAR_LIST = [c for c in string.digits + string.ascii_letters + ""_""]\n    INVALID_CHAR_LIST = INVALID_PYTHON_VAR_CHARS\n\n    @pytest.mark.parametrize(\n        [""value""], [[""abc"" + valid_c + ""hoge123""] for valid_c in VALID_CHAR_LIST]\n    )\n    def test_normal(self, value):\n        validate_python_var_name(value)\n\n    @pytest.mark.parametrize(\n        [""value""], [[""abc"" + invalid_c + ""hoge123""] for invalid_c in INVALID_CHAR_LIST]\n    )\n    def test_exception_invalid_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_python_var_name(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n    @pytest.mark.parametrize(\n        [""value""], [[invalid_c + ""hoge123""] for invalid_c in string.digits + ""_""]\n    )\n    def test_exception_invalid_first_char(self, value):\n        with pytest.raises(ValidationError) as e:\n            validate_python_var_name(value)\n        assert e.value.reason == ErrorReason.INVALID_CHARACTER\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [None, ValueError],\n            ["""", ValidationError],\n            [""123"", ValueError],\n            [1, TypeError],\n            [True, TypeError],\n        ],\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            validate_python_var_name(value)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [reserved_keyword, ErrorReason.RESERVED_NAME]\n            for reserved_keyword in RESERVED_KEYWORDS + [""__debug__""]\n        ],\n    )\n    def test_exception_reserved(self, value, expected):\n        with pytest.raises(ValidationError) as e:\n            validate_python_var_name(value)\n        assert e.value.reason == expected\n        assert e.value.reusable_name is False\n\n\nclass Test_sanitize_python_var_name:\n    SANITIZE_CHAR_LIST = INVALID_PYTHON_VAR_CHARS\n    NOT_SANITIZE_CHAR_LIST = [""_""]\n    REPLACE_TEXT_LIST = ["""", ""_""]\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [\n            [""A"" + c + ""B"", rep, ""A"" + rep + ""B""]\n            for c, rep in itertools.product(SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ]\n        + [\n            [""A"" + c + ""B"", rep, ""A"" + c + ""B""]\n            for c, rep in itertools.product(NOT_SANITIZE_CHAR_LIST, REPLACE_TEXT_LIST)\n        ],\n    )\n    def test_normal(self, value, replace_text, expected):\n        sanitized_name = sanitize_python_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_python_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_c + ""hoge_123"", ""_"", ""hoge_123""] for invalid_c in string.digits + ""_""]\n        + [[invalid_c + ""hoge_123"", ""a"", ""ahoge_123""] for invalid_c in string.digits + ""_""],\n    )\n    def test_normal_invalid_first_char_x1(self, value, replace_text, expected):\n        sanitized_name = sanitize_python_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_python_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""replace_text"", ""expected""],\n        [[invalid_c * 2 + ""hoge_123"", ""_"", ""hoge_123""] for invalid_c in string.digits + ""_""]\n        + [[invalid_c * 2 + ""hoge_123"", ""a"", ""aahoge_123""] for invalid_c in string.digits + ""_""],\n    )\n    def test_normal_invalid_first_char_x2(self, value, replace_text, expected):\n        sanitized_name = sanitize_python_var_name(value, replace_text)\n        assert sanitized_name == expected\n        validate_python_var_name(sanitized_name)\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [[reserved_keyword, reserved_keyword + ""_""] for reserved_keyword in RESERVED_KEYWORDS],\n    )\n    def test_normal_reserved(self, value, expected):\n        assert sanitize_python_var_name(value) == expected\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""], [[None, ValueError], [1, TypeError], [True, TypeError]]\n    )\n    def test_exception_type(self, value, expected):\n        with pytest.raises(expected):\n            sanitize_python_var_name(value)\n'"
test/writer/__init__.py,0,b''
examples/py/stream/configure_stream.py,0,"b'#!/usr/bin/env python3\n\n""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport io\n\nimport pytablewriter as ptw\n\n\ndef main():\n    writer = ptw.MarkdownTableWriter()\n    writer.table_name = ""zone""\n    writer.headers = [""zone_id"", ""country_code"", ""zone_name""]\n    writer.value_matrix = [\n        [""1"", ""AD"", ""Europe/Andorra""],\n        [""2"", ""AE"", ""Asia/Dubai""],\n        [""3"", ""AF"", ""Asia/Kabul""],\n        [""4"", ""AG"", ""America/Antigua""],\n        [""5"", ""AI"", ""America/Anguilla""],\n    ]\n\n    # writer instance writes a table to stdout by default\n    writer.write_table()\n    writer.write_null_line()\n\n    # change the stream to a string buffer to get the output as a string\n    # you can also get tabular text by using dumps method\n    writer.stream = io.StringIO()\n    writer.write_table()\n    print(writer.stream.getvalue())\n\n    # change the output stream to a file\n    with open(""sample.md"", ""w"") as f:\n        writer.stream = f\n        writer.write_table()\n\n\nif __name__ == ""__main__"":\n\n    main()\n'"
pytablewriter/writer/binary/__init__.py,0,"b'from ._excel import ExcelXlsTableWriter, ExcelXlsxTableWriter\nfrom ._sqlite import SqliteTableWriter\n'"
pytablewriter/writer/binary/_excel.py,0,"b'import abc\nimport copy\nimport warnings\nfrom typing import Any, Dict, Optional, cast  # noqa\n\nimport dataproperty\nimport typepy\nfrom dataproperty import DataProperty\nfrom tabledata import TableData\nfrom typepy import Integer\n\nfrom .._common import import_error_msg_template\nfrom ._excel_workbook import ExcelWorkbookInterface, ExcelWorkbookXls, ExcelWorkbookXlsx\nfrom ._interface import AbstractBinaryTableWriter\n\n\nclass ExcelTableWriter(AbstractBinaryTableWriter, metaclass=abc.ABCMeta):\n    """"""\n    An abstract class of a table writer for Excel file format.\n    """"""\n\n    FORMAT_NAME = ""excel""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    @property\n    def workbook(self) -> Optional[ExcelWorkbookInterface]:\n        return self._workbook\n\n    @property\n    def first_header_row(self) -> int:\n        """"""\n        :return: Index of the first row of the header.\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._first_header_row\n\n    @property\n    def last_header_row(self) -> int:\n        """"""\n        :return: Index of the last row of the header.\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._last_header_row\n\n    @property\n    def first_data_row(self) -> int:\n        """"""\n        :return: Index of the first row of the data (table body).\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._first_data_row\n\n    @property\n    def last_data_row(self) -> Optional[int]:\n        """"""\n        :return: Index of the last row of the data (table body).\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._last_data_row\n\n    @property\n    def first_data_col(self) -> int:\n        """"""\n        :return: Index of the first column of the table.\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._first_data_col\n\n    @property\n    def last_data_col(self) -> Optional[int]:\n        """"""\n        :return: Index of the last column of the table.\n        :rtype: int\n\n        .. note:: |excel_attr|\n        """"""\n\n        return self._last_data_col\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self._workbook = None  # type: Optional[ExcelWorkbookInterface]\n\n        self._dp_extractor.type_value_map = {\n            typepy.Typecode.INFINITY: ""Inf"",\n            typepy.Typecode.NAN: ""NaN"",\n        }\n\n        self._first_header_row = 0\n        self._last_header_row = self.first_header_row\n        self._first_data_row = self.last_header_row + 1\n        self._first_data_col = 0\n        self._last_data_row = None  # type: Optional[int]\n        self._last_data_col = None  # type: Optional[int]\n\n        self._current_data_row = self._first_data_row\n\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n        self._quoting_flags[typepy.Typecode.DATETIME] = True\n\n    def is_opened(self) -> bool:\n        return self.workbook is not None\n\n    def open(self, file_path: str) -> None:\n        """"""\n        Open an Excel workbook file.\n\n        :param str file_path: Excel workbook file path to open.\n        """"""\n\n        if self.is_opened() and self.workbook.file_path == file_path:  # type: ignore\n            self._logger.logger.debug(""workbook already opened: {}"".format(self.workbook.file_path))  # type: ignore\n            return\n\n        self.close()\n        self._open(file_path)\n\n    @abc.abstractmethod\n    def _open(self, workbook_path: str) -> None:  # pragma: no cover\n        pass\n\n    def close(self) -> None:\n        """"""\n        Close the current workbook.\n        """"""\n\n        if self.is_opened():\n            self.workbook.close()  # type: ignore\n            self._workbook = None\n\n    def from_tabledata(self, value: TableData, is_overwrite_table_name: bool = True) -> None:\n        """"""\n        Set following attributes from |TableData|\n\n        - :py:attr:`~.table_name`.\n        - :py:attr:`~.headers`.\n        - :py:attr:`~.value_matrix`.\n\n        And create worksheet named from :py:attr:`~.table_name` ABC\n        if not existed yet.\n\n        :param tabledata.TableData value: Input table data.\n        """"""\n\n        super().from_tabledata(value)\n\n        if self.is_opened():\n            self.make_worksheet(self.table_name)\n\n    def make_worksheet(self, sheet_name: Optional[str] = None) -> None:\n        """"""Make a worksheet to the current workbook.\n\n        Args:\n            sheet_name (str):\n                Name of the worksheet to create. The name will be automatically generated\n                (like ``""Sheet1""``) if the ``sheet_name`` is empty.\n        """"""\n\n        if sheet_name is None:\n            sheet_name = self.table_name\n        if not sheet_name:\n            sheet_name = """"\n\n        self._stream = self.workbook.add_worksheet(sheet_name)  # type: ignore\n        self._current_data_row = self._first_data_row\n\n    def dump(self, output: str, close_after_write: bool = True, **kwargs) -> None:\n        """"""Write a worksheet to the current workbook.\n\n        Args:\n            output (str):\n                Path to the workbook file to write.\n            close_after_write (bool, optional):\n                Close the workbook after write.\n                Defaults to |True|.\n        """"""\n\n        self.open(output)\n        try:\n            self.make_worksheet(self.table_name)\n            self.write_table(**kwargs)\n        finally:\n            if close_after_write:\n                self.close()\n\n    @abc.abstractmethod\n    def _write_header(self) -> None:\n        pass\n\n    @abc.abstractmethod\n    def _write_cell(self, row: int, col: int, value_dp: DataProperty) -> None:\n        pass\n\n    def _write_table(self, **kwargs) -> None:\n        self._preprocess_table_dp()\n        self._preprocess_table_property()\n        self._write_header()\n        self._write_value_matrix()\n        self._postprocess()\n\n    def _write_value_row_separator(self) -> None:\n        pass\n\n    def _write_value_matrix(self) -> None:\n        for value_dp_list in self._table_value_dp_matrix:\n            for col_idx, value_dp in enumerate(value_dp_list):\n                self._write_cell(self._current_data_row, col_idx, value_dp)\n\n            self._current_data_row += 1\n\n    def _get_last_column(self) -> int:\n        if typepy.is_not_empty_sequence(self.headers):\n            return len(self.headers) - 1\n\n        if typepy.is_not_empty_sequence(self.value_matrix):\n            return len(self.value_matrix[0]) - 1\n\n        raise ValueError(""data not found"")\n\n    def _postprocess(self) -> None:\n        self._last_data_row = self._current_data_row\n        self._last_data_col = self._get_last_column()\n\n\nclass ExcelXlsTableWriter(ExcelTableWriter):\n    """"""\n    A table writer class for Excel file format: ``.xls`` (older or equal to Office 2003).\n\n    ``xlwt`` package required to use this class.\n\n    .. py:method:: write_table()\n\n        Write a table to the current opened worksheet.\n\n        :raises IOError: If failed to write data to the worksheet.\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as an empty string\n            - |inf|: written as ``Inf``\n            - |nan|: written as ``NaN``\n    """"""\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.__col_style_table = {}  # type: Dict[int, Any]\n\n    def _open(self, workbook_path: str) -> None:\n        self._workbook = ExcelWorkbookXls(workbook_path)\n\n    def _write_header(self) -> None:\n        if not self.is_write_header or typepy.is_empty_sequence(self.headers):\n            return\n\n        for col, value in enumerate(self.headers):\n            self.stream.write(self.first_header_row, col, value)\n\n    def _write_cell(self, row: int, col: int, value_dp: DataProperty) -> None:\n        if value_dp.typecode in [typepy.Typecode.REAL_NUMBER]:\n            try:\n                cell_style = self.__get_cell_style(col)\n            except ValueError:\n                pass\n            else:\n                self.stream.write(row, col, value_dp.data, cell_style)\n                return\n\n        self.stream.write(row, col, value_dp.data)\n\n    def _postprocess(self) -> None:\n        super()._postprocess()\n\n        self.__col_style_table = {}\n\n    def __get_cell_style(self, col: int):\n        try:\n            import xlwt\n        except ImportError:\n            warnings.warn(import_error_msg_template.format(""excel""))\n            raise\n\n        if col in self.__col_style_table:\n            return self.__col_style_table.get(col)\n\n        try:\n            col_dp = self._column_dp_list[col]\n        except KeyError:\n            return {}\n\n        if col_dp.typecode not in [typepy.Typecode.REAL_NUMBER]:\n            raise ValueError()\n\n        if not Integer(col_dp.minmax_decimal_places.max_value).is_type():\n            raise ValueError()\n\n        float_digit = col_dp.minmax_decimal_places.max_value\n        if float_digit <= 0:\n            raise ValueError()\n\n        num_format_str = ""#,{:s}0.{:s}"".format(""#"" * int(float_digit), ""0"" * int(float_digit))\n        cell_style = xlwt.easyxf(num_format_str=num_format_str)\n        self.__col_style_table[col] = cell_style\n\n        return cell_style\n\n\nclass ExcelXlsxTableWriter(ExcelTableWriter):\n    """"""\n    A table writer class for Excel file format: ``.xlsx`` (newer or equal to Office 2007).\n\n    .. py:method:: write_table()\n\n        Write a table to the current opened worksheet.\n\n        :raises IOError: If failed to write data to the worksheet.\n        :Examples:\n            :ref:`example-excel-table-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as an empty string\n            - |inf|: written as ``Inf``\n            - |nan|: written as ``NaN``\n    """"""\n\n    MAX_CELL_WIDTH = 60\n\n    class TableFormat:\n        HEADER = ""header""\n        CELL = ""cell""\n        NAN = ""nan""\n\n    class Default:\n        FONT_NAME = ""MS Gothic""\n        FONT_SIZE = 9\n\n        CELL_FORMAT = {\n            ""font_name"": FONT_NAME,\n            ""font_size"": FONT_SIZE,\n            ""align"": ""top"",\n            ""text_wrap"": True,\n            ""top"": 1,\n            ""left"": 1,\n            ""bottom"": 1,\n            ""right"": 1,\n        }\n        HEADER_FORMAT = {\n            ""font_name"": FONT_NAME,\n            ""font_size"": FONT_SIZE,\n            ""bg_color"": ""#DFDFFF"",\n            ""bold"": True,\n            ""left"": 1,\n            ""right"": 1,\n        }\n        NAN_FORMAT = {\n            ""font_name"": FONT_NAME,\n            ""font_size"": FONT_SIZE,\n            ""font_color"": ""silver"",\n            ""top"": 1,\n            ""left"": 1,\n            ""bottom"": 1,\n            ""right"": 1,\n        }\n\n    @property\n    def __nan_format_property(self) -> Dict:\n        return self.format_table.get(self.TableFormat.NAN, self.default_format)\n\n    @property\n    def __cell_format_property(self) -> Dict:\n        return self.format_table.get(self.TableFormat.CELL, self.default_format)\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.default_format = self.Default.CELL_FORMAT\n        self.format_table = {\n            self.TableFormat.CELL: self.Default.CELL_FORMAT,\n            self.TableFormat.HEADER: self.Default.HEADER_FORMAT,\n            self.TableFormat.NAN: self.Default.NAN_FORMAT,\n        }\n\n        self.__col_cell_format_cache = {}  # type: Dict[int, Any]\n        self.__col_numprops_table = {}  # type: Dict[int, Dict]\n\n    def _open(self, workbook_path: str) -> None:\n        self._workbook = ExcelWorkbookXlsx(workbook_path)\n\n    def _write_header(self) -> None:\n        if not self.is_write_header or typepy.is_empty_sequence(self.headers):\n            return\n\n        header_format_props = self.format_table.get(self.TableFormat.HEADER, self.default_format)\n        header_format = self.__add_format(header_format_props)\n\n        self.stream.write_row(\n            row=self.first_header_row, col=0, data=self.headers, cell_format=header_format\n        )\n        for row in range(self.first_header_row, self.last_header_row):\n            self.stream.write_row(\n                row=row, col=0, data=[""""] * len(self.headers), cell_format=header_format\n            )\n\n    def _write_cell(self, row: int, col: int, value_dp: DataProperty) -> None:\n        base_props = dict(self.__cell_format_property)\n        format_key = ""{:d}_{:s}"".format(col, value_dp.typecode.name)\n\n        if value_dp.typecode in [typepy.Typecode.INTEGER, typepy.Typecode.REAL_NUMBER]:\n            num_props = self.__get_number_property(col)\n            base_props.update(num_props)\n            cell_format = self.__get_cell_format(format_key, base_props)\n\n            try:\n                self.stream.write_number(row, col, float(value_dp.data), cell_format)\n                return\n            except TypeError:\n                pass\n\n        if value_dp.typecode is typepy.Typecode.NAN:\n            base_props = dict(self.__nan_format_property)\n\n        cell_format = self.__get_cell_format(format_key, base_props)\n        self.stream.write(row, col, value_dp.data, cell_format)\n\n    def __get_number_property(self, col: int) -> Dict:\n        if col in self.__col_numprops_table:\n            return cast(Dict, self.__col_numprops_table.get(col))\n\n        try:\n            col_dp = self._column_dp_list[col]\n        except KeyError:\n            return {}\n\n        if col_dp.typecode not in [typepy.Typecode.INTEGER, typepy.Typecode.REAL_NUMBER]:\n            return {}\n\n        num_props = {}\n        if Integer(col_dp.minmax_decimal_places.max_value).is_type():\n            float_digit = col_dp.minmax_decimal_places.max_value\n            if float_digit > 0:\n                num_props = {""num_format"": ""0.{:s}"".format(""0"" * int(float_digit))}\n\n        self.__col_numprops_table[col] = num_props\n\n        return num_props\n\n    def __get_cell_format(self, format_key, cell_props) -> Dict:\n        cell_format = self.__col_cell_format_cache.get(format_key)\n        if cell_format is not None:\n            return cell_format\n\n        # cache miss\n        cell_format = self.__add_format(cell_props)\n        self.__col_cell_format_cache[format_key] = cell_format\n\n        return cell_format\n\n    def __add_format(self, dict_property):\n        return self.workbook.workbook.add_format(dict_property)\n\n    def __set_cell_width(self):\n        font_size = self.__cell_format_property.get(""font_size"")\n\n        if not Integer(font_size).is_type():\n            return\n\n        for col_idx, col_dp in enumerate(self._column_dp_list):\n            width = min(col_dp.ascii_char_width, self.MAX_CELL_WIDTH) * (font_size / 10.0) + 2\n            self.stream.set_column(col_idx, col_idx, width=width)\n\n    def _preprocess_table_property(self) -> None:\n        super()._preprocess_table_property()\n\n        self.__set_cell_width()\n\n    def _postprocess(self) -> None:\n        super()._postprocess()\n\n        self.stream.autofilter(\n            self.last_header_row, self.first_data_col, self.last_data_row, self.last_data_col\n        )\n        self.stream.freeze_panes(self.first_data_row, self.first_data_col)\n\n        self.__col_cell_format_cache = {}\n        self.__col_numprops_table = {}\n'"
pytablewriter/writer/binary/_excel_workbook.py,0,"b'import abc\nimport warnings\nfrom typing import Dict, Optional  # noqa\n\nimport msgfy\nimport typepy\n\nfrom ..._logger import logger\nfrom ...sanitizer import sanitize_excel_sheet_name\nfrom .._common import import_error_msg_template\n\n\nclass ExcelWorkbookInterface(metaclass=abc.ABCMeta):\n    @abc.abstractproperty\n    def workbook(self):  # pragma: no cover\n        pass\n\n    @abc.abstractproperty\n    def file_path(self):  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def open(self, file_path: str) -> None:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def close(self) -> None:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def add_worksheet(self, worksheet_name):  # pragma: no cover\n        pass\n\n\nclass ExcelWorkbook(ExcelWorkbookInterface):\n    @property\n    def workbook(self):\n        return self._workbook\n\n    @property\n    def file_path(self) -> Optional[str]:\n        return self._file_path\n\n    def _clear(self) -> None:\n        self._workbook = None\n        self._file_path = None  # type: Optional[str]\n        self._worksheet_table = {}  # type: Dict\n\n    def __init__(self, file_path: str) -> None:\n        self._clear()\n        self._file_path = file_path\n\n    def __del__(self) -> None:\n        self.close()\n\n\nclass ExcelWorkbookXls(ExcelWorkbook):\n    def __init__(self, file_path: str) -> None:\n        super().__init__(file_path)\n\n        self.open(file_path)\n\n    def open(self, file_path: str) -> None:\n        try:\n            import xlwt\n        except ImportError:\n            warnings.warn(import_error_msg_template.format(""excel""))\n            raise\n\n        self._workbook = xlwt.Workbook()\n\n    def close(self) -> None:\n        if self.workbook is None:\n            return\n\n        try:\n            self.workbook.save(self._file_path)\n        except IndexError as e:\n            logger.debug(msgfy.to_error_message(e))\n\n        self._clear()\n\n    def add_worksheet(self, worksheet_name):\n        worksheet_name = sanitize_excel_sheet_name(worksheet_name)\n\n        if typepy.is_not_null_string(worksheet_name):\n            if worksheet_name in self._worksheet_table:\n                # the work sheet is already exists\n                return self._worksheet_table.get(worksheet_name)\n        else:\n            sheet_id = 1\n            while True:\n                worksheet_name = ""Sheet{:d}"".format(sheet_id)\n                if worksheet_name not in self._worksheet_table:\n                    break\n                sheet_id += 1\n\n        worksheet = self.workbook.add_sheet(worksheet_name)\n        self._worksheet_table[worksheet_name] = worksheet\n\n        return worksheet\n\n\nclass ExcelWorkbookXlsx(ExcelWorkbook):\n    def __init__(self, file_path: str) -> None:\n        super().__init__(file_path)\n\n        self.open(file_path)\n\n    def open(self, file_path: str) -> None:\n        try:\n            import xlsxwriter\n        except ImportError:\n            warnings.warn(import_error_msg_template.format(""excel""))\n            raise\n\n        self._workbook = xlsxwriter.Workbook(file_path)\n\n    def close(self) -> None:\n        if self.workbook is None:\n            return\n\n        self._workbook.close()  # type: ignore\n        self._clear()\n\n    def add_worksheet(self, worksheet_name):\n        worksheet_name = sanitize_excel_sheet_name(worksheet_name)\n\n        if typepy.is_not_null_string(worksheet_name):\n            if worksheet_name in self._worksheet_table:\n                # the work sheet is already exists\n                return self._worksheet_table.get(worksheet_name)\n        else:\n            worksheet_name = None\n\n        worksheet = self.workbook.add_worksheet(worksheet_name)\n        self._worksheet_table[worksheet_name] = worksheet\n\n        return worksheet\n'"
pytablewriter/writer/binary/_interface.py,0,"b'import abc\n\nfrom .._table_writer import AbstractTableWriter\n\n\nclass BinaryWriterInterface(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def is_opened(self) -> bool:  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def open(self, file_path: str) -> None:  # pragma: no cover\n        """"""\n        Open a file for output stream.\n\n        Args:\n            file_path (str): path to the file.\n        """"""\n\n\nclass AbstractBinaryTableWriter(AbstractTableWriter, BinaryWriterInterface):\n    @property\n    def stream(self):\n        return self._stream\n\n    @stream.setter\n    def stream(self, value) -> None:\n        raise RuntimeError(\n            ""cannot assign a stream to binary format writers. use open method instead.""\n        )\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self._stream = None\n\n    def dumps(self) -> str:\n        raise NotImplementedError(""binary format writers did not support dumps method"")\n\n    def _verify_stream(self) -> None:\n        if self.stream is None:\n            raise OSError(""null output stream. required to open(file_path) first."")\n'"
pytablewriter/writer/binary/_sqlite.py,0,"b'from os.path import abspath\n\nimport tabledata\n\nfrom ._interface import AbstractBinaryTableWriter\n\n\nclass SqliteTableWriter(AbstractBinaryTableWriter):\n    """"""\n    A table writer class for SQLite database.\n\n    .. py:method:: write_table()\n\n        Write a table to a SQLite database.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |table_name| is empty.\n        :raises pytablewriter.EmptyValueError:\n            If the |value_matrix| is empty.\n        :Example:\n            :ref:`example-sqlite-table-writer`\n    """"""\n\n    FORMAT_NAME = ""sqlite""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        import copy\n        import dataproperty\n\n        super().__init__()\n\n        self.is_padding = False\n        self.is_formatting_float = False\n        self._use_default_header = True\n\n        self._is_require_table_name = True\n        self._is_require_header = True\n\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n\n    def __del__(self) -> None:\n        self.close()\n\n    def is_opened(self) -> bool:\n        return self.stream is not None\n\n    def open(self, file_path: str) -> None:\n        """"""\n        Open a SQLite database file.\n\n        :param str file_path: SQLite database file path to open.\n        """"""\n\n        from simplesqlite import SimpleSQLite\n\n        if self.is_opened():\n            if self.stream.database_path == abspath(file_path):\n                self._logger.logger.debug(\n                    ""database already opened: {}"".format(self.stream.database_path)\n                )\n                return\n\n            self.close()\n\n        self._stream = SimpleSQLite(file_path, ""w"")\n\n    def dump(self, output: str, close_after_write: bool = True, **kwargs) -> None:\n        """"""Write data to the SQLite database file.\n\n        Args:\n            output (file descriptor or filepath):\n            close_after_write (bool, optional):\n                Close the output after write.\n                Defaults to |True|.\n        """"""\n\n        self.open(output)\n        try:\n            self.write_table(**kwargs)\n        finally:\n            if close_after_write:\n                self.close()\n\n    def _write_table(self, **kwargs) -> None:\n        self._verify_value_matrix()\n        self._preprocess()\n\n        table_data = tabledata.TableData(\n            self.table_name,\n            self.headers,\n            [\n                [value_dp.data for value_dp in value_dp_list]\n                for value_dp_list in self._table_value_dp_matrix\n            ],\n            type_hints=self.type_hints,\n            max_workers=self.max_workers,\n        )\n        self.stream.create_table_from_tabledata(table_data)\n\n    def _write_value_row_separator(self) -> None:\n        pass\n'"
pytablewriter/writer/text/__init__.py,0,"b'from ._borderless import BorderlessTableWriter\nfrom ._css import CssTableWriter\nfrom ._csv import CsvTableWriter\nfrom ._html import HtmlTableWriter\nfrom ._json import JsonTableWriter\nfrom ._jsonlines import JsonLinesTableWriter\nfrom ._latex import LatexMatrixWriter, LatexTableWriter\nfrom ._ltsv import LtsvTableWriter\nfrom ._markdown import MarkdownTableWriter\nfrom ._mediawiki import MediaWikiTableWriter\nfrom ._rst import RstCsvTableWriter, RstGridTableWriter, RstSimpleTableWriter\nfrom ._spacealigned import SpaceAlignedTableWriter\nfrom ._toml import TomlTableWriter\nfrom ._tsv import TsvTableWriter\nfrom ._unicode import BoldUnicodeTableWriter, UnicodeTableWriter\nfrom ._yaml import YamlTableWriter\n'"
pytablewriter/writer/text/_borderless.py,0,"b'import copy\n\nimport dataproperty as dp\n\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass BorderlessTableWriter(IndentationTextTableWriter):\n    """"""\n    A table writer class for borderless table.\n    """"""\n\n    FORMAT_NAME = ""borderless""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n\n        self.column_delimiter = """"\n        self.char_left_side_row = """"\n        self.char_right_side_row = """"\n\n        self.indent_string = ""    ""\n        self.is_write_header_separator_row = False\n        self.is_write_value_separator_row = False\n        self.is_write_opening_row = False\n        self.is_write_closing_row = False\n\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n'"
pytablewriter/writer/text/_common.py,0,"b'from decimal import Decimal\nfrom typing import Any\n\nfrom dataproperty import DataProperty\nfrom typepy import Typecode\n\n\ndef bool_to_str(value) -> str:\n    if value is True:\n        return ""true""\n    if value is False:\n        return ""false""\n\n    return value\n\n\ndef serialize_dp(dp: DataProperty) -> Any:\n    if dp.typecode in (Typecode.REAL_NUMBER, Typecode.INFINITY, Typecode.NAN) and isinstance(\n        dp.data, Decimal\n    ):\n        return float(dp.data)\n\n    if dp.typecode == Typecode.DATETIME:\n        return dp.to_str()\n\n    return dp.data\n'"
pytablewriter/writer/text/_css.py,0,"b'import copy\nfrom typing import List, cast\n\nfrom dataproperty import NOT_QUOTING_FLAGS, DataProperty\nfrom pathvalidate import replace_symbol\n\nfrom ...style import Align, DecorationLine, FontStyle, FontWeight, Style, VerticalAlign\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass CssTableWriter(IndentationTextTableWriter):\n    """"""\n    A CSS writer class.\n    """"""\n\n    FORMAT_NAME = ""css""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return False\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_padding = False\n        self.indent_string = ""    ""\n\n        self._dp_extractor.preprocessor.is_escape_html_tag = False\n        self._quoting_flags = copy.deepcopy(NOT_QUOTING_FLAGS)\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with CSS.\n        """"""\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            self.__write_css(\n                css_class=replace_symbol(self.table_name, replacement_text=""-""),\n                write_style_tag=kwargs.get(""write_style_tag"", False),\n            )\n\n    def __extract_css_tags(self, value_dp: DataProperty, style: Style) -> List[str]:\n        css_tags = []  # List[str]\n\n        if self._styler.get_font_size(style):\n            css_tags.append(cast(str, self._styler.get_font_size(style)))\n        if style.font_weight == FontWeight.BOLD:\n            css_tags.append(""font-weight:bold"")\n        if style.font_style == FontStyle.ITALIC:\n            css_tags.append(""font-style:italic"")\n\n        if style.color:\n            css_tags.append(""color: {}"".format(style.color.color_code))\n\n        if style.bg_color:\n            css_tags.append(""background-color: {}"".format(style.bg_color.color_code))\n\n        css_tag = self.__extract_align_tag(value_dp, style)\n        if css_tag:\n            css_tags.append(css_tag)\n\n        if style.vertical_align != VerticalAlign.BASELINE:\n            css_tags.append(""vertical-align: {}"".format(style.vertical_align.align_str))\n\n        if style.decoration_line in (DecorationLine.LINE_THROUGH, DecorationLine.STRIKE):\n            css_tags.append(""text-decoration-line: line-through"")\n        elif style.decoration_line == DecorationLine.UNDERLINE:\n            css_tags.append(""text-decoration-line: underline"")\n\n        return css_tags\n\n    def __extract_align_tag(self, value_dp: DataProperty, style: Style) -> str:\n        if style.align == Align.AUTO:\n            value = value_dp.align.align_string\n        else:\n            value = style.align.align_string\n\n        return ""text-align: {}"".format(value)\n\n    def __write_css_thead(self, css_class: str, base_indent_level: int) -> None:\n        for col_dp, header_dp in zip(self._column_dp_list, self._dp_extractor.to_header_dp_list()):\n            default_style = self._get_col_style(col_dp.column_index)\n            style = self._fetch_style_from_filter(-1, col_dp, header_dp, default_style)\n            css_tags = self.__extract_css_tags(header_dp, style)\n\n            if not css_tags:\n                continue\n\n            self.set_indent_level(base_indent_level)\n            self._write_line(\n                "".{css_class} thead th:nth-child({col}) {{"".format(\n                    css_class=css_class, col=col_dp.column_index + 1\n                )\n            )\n\n            self.set_indent_level(base_indent_level + 1)\n            for css_tag in css_tags:\n                self._write_line(""{};"".format(css_tag))\n\n            self.set_indent_level(base_indent_level)\n            self._write_line(""}"")\n\n    def __write_css_tbody(self, css_class: str, base_indent_level: int) -> None:\n        for row_idx, (values, value_dp_list) in enumerate(\n            zip(self._table_value_matrix, self._table_value_dp_matrix)\n        ):\n            for value, value_dp, col_dp in zip(values, value_dp_list, self._column_dp_list):\n                default_style = self._get_col_style(col_dp.column_index)\n                style = self._fetch_style_from_filter(row_idx, col_dp, value_dp, default_style)\n                css_tags = self.__extract_css_tags(value_dp, style)\n\n                if not css_tags:\n                    continue\n\n                self.set_indent_level(base_indent_level)\n                self._write_line(\n                    "".{css_class} tbody tr:nth-child({row}) td:nth-child({col}) {{"".format(\n                        css_class=css_class, row=row_idx + 1, col=col_dp.column_index + 1\n                    )\n                )\n\n                self.set_indent_level(base_indent_level + 1)\n                for css_tag in css_tags:\n                    self._write_line(""{};"".format(css_tag))\n\n                self.set_indent_level(base_indent_level)\n                self._write_line(""}"")\n\n    def __write_css(self, css_class: str, write_style_tag: bool = False) -> None:\n        base_indent_level = 0\n\n        if write_style_tag:\n            self._write_line(\'<style type=""text/css"">\')\n            base_indent_level = 1\n\n        self.__write_css_thead(css_class, base_indent_level)\n        self.__write_css_tbody(css_class, base_indent_level)\n\n        if write_style_tag:\n            self.set_indent_level(0)\n            self._write_line(""</style>"")\n'"
pytablewriter/writer/text/_csv.py,0,"b'from typing import List\n\nimport typepy\n\nfrom ._text_writer import TextTableWriter\n\n\nclass CsvTableWriter(TextTableWriter):\n    """"""\n    A table writer class for character separated values format.\n    The default separated character is a comma (``"",""``).\n\n        :Example:\n            :ref:`example-csv-table-writer`\n    """"""\n\n    FORMAT_NAME = ""csv""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self._set_chars("""")\n        self.indent_string = """"\n        self.column_delimiter = "",""\n\n        self.is_padding = False\n        self.is_formatting_float = False\n        self.is_write_header_separator_row = False\n\n        self._quoting_flags[typepy.Typecode.NULL_STRING] = False\n\n    def _write_header(self) -> None:\n        if typepy.is_empty_sequence(self.headers):\n            return\n\n        super()._write_header()\n\n    def _get_opening_row_items(self) -> List[str]:\n        return []\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return []\n\n    def _get_closing_row_items(self) -> List[str]:\n        return []\n'"
pytablewriter/writer/text/_html.py,0,"b'import copy\nimport warnings\nfrom typing import Any, List, Optional, Tuple, cast  # noqa\n\nimport dataproperty\nimport typepy\nfrom mbstrdecoder import MultiByteStrDecoder\nfrom pathvalidate import replace_symbol\n\nfrom ...sanitizer import sanitize_python_var_name\nfrom ...style import Align, FontStyle, FontWeight, HtmlStyler, Style, StylerInterface, VerticalAlign\nfrom .._common import import_error_msg_template\nfrom .._table_writer import AbstractTableWriter\nfrom ._css import CssTableWriter\nfrom ._text_writer import TextTableWriter\n\n\ndef _get_tags_module() -> Tuple:\n    try:\n        from dominate import tags\n        from dominate.util import raw\n\n        return tags, raw\n    except ImportError:\n        warnings.warn(import_error_msg_template.format(""html""))\n        raise\n\n\nclass HtmlTableWriter(TextTableWriter):\n    """"""\n    A table writer class for HTML format.\n\n        :Example:\n            :ref:`example-html-table-writer`\n    """"""\n\n    FORMAT_NAME = ""html""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return False\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_padding = False\n        self.indent_string = ""    ""\n\n        self._dp_extractor.preprocessor.line_break_repl = ""<br>""\n        self._dp_extractor.preprocessor.is_escape_html_tag = False\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n        self._table_tag = None  # type: Any\n\n        self.colorize_terminal = False\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with HTML table format.\n\n        Args:\n            write_css (bool):\n                If |True|, write CSS corresponding to the specified styles,\n                instead of attributes of HTML tags.\n\n        Example:\n            :ref:`example-html-table-writer`\n\n        .. note::\n            - |None| values will be replaced with an empty value\n        """"""\n\n        tags, raw = _get_tags_module()\n        write_css = kwargs.get(""write_css"", False)\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            css_class = None\n\n            if write_css:\n                css_class = kwargs.get(""css_class"")\n                css_class = css_class if css_class else ""{}-css"".format(self.table_name)\n                css_class = replace_symbol(self.table_name, replacement_text=""-"")\n\n                css_writer = CssTableWriter()\n                css_writer.from_writer(self)\n                css_writer.table_name = css_class\n                css_writer.write_table(write_style_tag=True)\n\n            if typepy.is_not_null_string(self.table_name):\n                if css_class:\n                    self._table_tag = tags.table(\n                        id=sanitize_python_var_name(self.table_name), class_name=css_class\n                    )\n                else:\n                    self._table_tag = tags.table(id=sanitize_python_var_name(self.table_name))\n                self._table_tag += tags.caption(MultiByteStrDecoder(self.table_name).unicode_str)\n            else:\n                self._table_tag = tags.table()\n\n            try:\n                self._write_header()\n            except ValueError:\n                pass\n\n            self._write_body(not write_css)\n\n    def _write_header(self) -> None:\n        tags, raw = _get_tags_module()\n\n        if not self.is_write_header:\n            return\n\n        if typepy.is_empty_sequence(self._table_headers):\n            raise ValueError(""headers is empty"")\n\n        tr_tag = tags.tr()\n        for header in self._table_headers:\n            tr_tag += tags.th(raw(MultiByteStrDecoder(header).unicode_str))\n\n        thead_tag = tags.thead()\n        thead_tag += tr_tag\n\n        self._table_tag += thead_tag\n\n    def _write_body(self, write_attr: bool) -> None:\n        tags, raw = _get_tags_module()\n        tbody_tag = tags.tbody()\n\n        for row_idx, (values, value_dp_list) in enumerate(\n            zip(self._table_value_matrix, self._table_value_dp_matrix)\n        ):\n            tr_tag = tags.tr()\n            for value, value_dp, column_dp in zip(values, value_dp_list, self._column_dp_list):\n                td_tag = tags.td(raw(MultiByteStrDecoder(value).unicode_str))\n\n                default_style = self._get_col_style(column_dp.column_index)\n                style = self._fetch_style_from_filter(row_idx, column_dp, value_dp, default_style)\n\n                if write_attr:\n                    if style.align == Align.AUTO:\n                        td_tag[""align""] = value_dp.align.align_string\n                    else:\n                        td_tag[""align""] = style.align.align_string\n\n                    if style.vertical_align != VerticalAlign.BASELINE:\n                        td_tag[""valign""] = style.vertical_align.align_str\n\n                    style_tag = self.__make_style_tag(style=style)\n                    if style_tag:\n                        td_tag[""style""] = style_tag\n\n                tr_tag += td_tag\n            tbody_tag += tr_tag\n\n        self._table_tag += tbody_tag\n        self._write_line(self._table_tag.render(indent=self.indent_string))\n\n    def __make_style_tag(self, style: Style) -> Optional[str]:\n        styles = []  # List[str]\n\n        if self._styler.get_font_size(style):\n            styles.append(cast(str, self._styler.get_font_size(style)))\n        if style.font_weight == FontWeight.BOLD:\n            styles.append(""font-weight:bold"")\n        if style.font_style == FontStyle.ITALIC:\n            styles.append(""font-style:italic"")\n\n        if not styles:\n            return None\n\n        return ""; "".join(styles)\n\n    def _create_styler(self, writer: AbstractTableWriter) -> StylerInterface:\n        return HtmlStyler(writer)\n'"
pytablewriter/writer/text/_interface.py,0,"b'import abc\n\n\nclass TextWriterInterface(metaclass=abc.ABCMeta):\n    """"""\n    Interface class for writing texts.\n    """"""\n\n    @abc.abstractmethod\n    def write_null_line(self):  # pragma: no cover\n        pass\n\n\nclass IndentationInterface(metaclass=abc.ABCMeta):\n    """"""\n    Interface class for indentation methods.\n    """"""\n\n    @abc.abstractmethod\n    def set_indent_level(self, indent_level):  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def inc_indent_level(self):  # pragma: no cover\n        pass\n\n    @abc.abstractmethod\n    def dec_indent_level(self):  # pragma: no cover\n        pass\n'"
pytablewriter/writer/text/_json.py,0,"b'import copy\nfrom textwrap import indent\nfrom typing import List\n\nimport dataproperty\nimport msgfy\nimport typepy\nfrom dataproperty import ColumnDataProperty, DataProperty\nfrom mbstrdecoder import MultiByteStrDecoder\nfrom tabledata import to_value_matrix\nfrom typepy import Typecode\n\nfrom ._common import serialize_dp\nfrom ._text_writer import IndentationTextTableWriter\n\n\ntry:\n    import simplejson as json\nexcept ImportError:\n    import json  # type: ignore\n\n\nclass JsonTableWriter(IndentationTextTableWriter):\n    """"""\n    A table writer class for JSON format.\n\n        :Examples:\n            :ref:`example-json-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with JSON format.\n\n        Args:\n            indent (Optional[int]):\n                Indent level of an output.\n                Interpretation of indent level value differ format to format.\n                Some writer classes may ignore this value.\n                Defaults to 4.\n\n            sort_keys (Optional[bool]):\n                If |True|, the output of dictionaries will be sorted by key.\n                Defaults to |False|.\n\n        Examples:\n            :ref:`example-json-table-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as ``null``\n            - |inf|: written as ``Infinity``\n            - |nan|: written as ``NaN``\n    """"""\n\n    FORMAT_NAME = ""json""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.set_indent_level(4)\n\n        self.is_formatting_float = False\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n        self.char_right_side_row = "",""\n        self.char_opening_row_cross_point = """"\n        self.char_closing_row_cross_point = """"\n\n        self._is_require_header = True\n        self._dp_extractor.type_value_map = {\n            Typecode.INFINITY: ""Infinity"",\n            Typecode.NAN: ""NaN"",\n        }\n        self._dp_extractor.update_strict_level_map({Typecode.BOOL: typepy.StrictLevel.MAX})\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n\n    def write_null_line(self) -> None:\n        self._verify_stream()\n        self.stream.write(""\\n"")\n\n    def _write_table(self, **kwargs) -> None:\n        sort_keys = kwargs.get(""sort_keys"", False)\n\n        self._preprocess()\n\n        with self._logger:\n            self._write_opening_row()\n\n            json_text_list = []\n            for json_data in self._table_value_matrix:\n                json_text = json.dumps(\n                    json_data, indent=self._indent_level, ensure_ascii=False, sort_keys=sort_keys\n                )\n                json_text_list.append(json_text)\n\n            joint_text = self.char_right_side_row + ""\\n""\n            json_text = joint_text.join(json_text_list)\n            if all([not self.is_write_closing_row, typepy.is_not_null_string(json_text)]):\n                json_text += joint_text\n\n            self.stream.write(indent(json_text, "" "" * self._indent_level))\n            self._write_closing_row()\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return value_dp.to_str()\n\n    def _preprocess_table_dp(self) -> None:\n        if self._is_complete_table_dp_preprocess:\n            return\n\n        self._logger.logger.debug(""_preprocess_table_dp"")\n\n        try:\n            self._table_value_dp_matrix = self._dp_extractor.to_dp_matrix(\n                to_value_matrix(self.headers, self.value_matrix)\n            )\n        except TypeError as e:\n            self._logger.logger.debug(msgfy.to_error_message(e))\n            self._table_value_dp_matrix = []\n\n        self._is_complete_table_dp_preprocess = True\n\n    def _preprocess_header(self) -> None:\n        if self._is_complete_header_preprocess:\n            return\n\n        self._logger.logger.debug(""_preprocess_header"")\n\n        self._table_headers = [\n            header_dp.to_str() for header_dp in self._dp_extractor.to_header_dp_list()\n        ]\n\n        self._is_complete_header_preprocess = True\n\n    def _preprocess_value_matrix(self) -> None:\n        if self._is_complete_value_matrix_preprocess:\n            return\n\n        self._table_value_matrix = [\n            dict(zip(self._table_headers, [serialize_dp(dp) for dp in dp_list]))\n            for dp_list in self._table_value_dp_matrix\n        ]\n\n        self._is_complete_value_matrix_preprocess = True\n\n    def _get_opening_row_items(self) -> List[str]:\n        if typepy.is_not_null_string(self.table_name):\n            return [\'{{ ""{:s}"" : [\'.format(MultiByteStrDecoder(self.table_name).unicode_str)]\n\n        return [""[""]\n\n    def _get_closing_row_items(self) -> List[str]:\n        if typepy.is_not_null_string(self.table_name):\n            return [""\\n]}""]\n\n        return [""\\n]""]\n'"
pytablewriter/writer/text/_jsonlines.py,0,"b'from ._json import JsonTableWriter\n\n\ntry:\n    import simplejson as json\nexcept ImportError:\n    import json  # type: ignore\n\n\nclass JsonLinesTableWriter(JsonTableWriter):\n    """"""\n    A table writer class for JSON lines format.\n\n        :Example:\n            :ref:`example-jsonl-writer`\n    """"""\n\n    FORMAT_NAME = ""json_lines""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with\n        `Line-delimited JSON(LDJSON) <https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON>`__\n        /NDJSON/JSON Lines format.\n\n        Args:\n            sort_keys (Optional[bool]):\n                If |True|, the output of dictionaries will be sorted by key.\n                Defaults to |False|.\n\n        Example:\n            :ref:`example-jsonl-writer`\n        """"""\n\n        sort_keys = kwargs.get(""sort_keys"", False)\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            for values in self._table_value_matrix:\n                self._write_line(json.dumps(values, ensure_ascii=False, sort_keys=sort_keys))\n'"
pytablewriter/writer/text/_latex.py,0,"b'import copy\nimport re\nfrom typing import List\n\nimport dataproperty as dp\nimport typepy\nfrom dataproperty import ColumnDataProperty, DataProperty\nfrom typepy import Typecode\n\nfrom ...style import Align, LatexStyler, StylerInterface\nfrom .._table_writer import AbstractTableWriter\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass LatexWriter(IndentationTextTableWriter):\n    """"""\n    A base writer class for LaTeX format.\n    """"""\n\n    _RE_MATH_PARTS = re.compile(""^[\\\\]?[a-zA-z]+$"")\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self._set_chars("""")\n\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n        self.indent_string = ""    ""\n        self.column_delimiter = "" & ""\n        self.char_right_side_row = r"" \\\\""\n\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n\n    def _is_math_parts(self, value_dp: DataProperty) -> bool:\n        if value_dp.typecode in [Typecode.INTEGER, Typecode.REAL_NUMBER]:\n            return False\n\n        try:\n            if self._RE_MATH_PARTS.search(value_dp.data):\n                return True\n        except TypeError:\n            pass\n\n        return False\n\n    def _get_col_align_char_list(self) -> List[str]:\n        col_align_list = []\n\n        for col_dp in self._column_dp_list:\n            align = self._get_col_style(col_dp.column_index).align\n            if align is None or align == Align.AUTO:\n                align = col_dp.align\n\n            if align == Align.RIGHT:\n                col_align = ""r""\n            elif align == Align.CENTER:\n                col_align = ""c""\n            else:\n                col_align = ""l""\n\n            col_align_list.append(col_align)\n\n        return col_align_list\n\n    def _write_opening_row(self) -> None:\n        super()._write_opening_row()\n        self.inc_indent_level()\n\n    def _write_closing_row(self) -> None:\n        self.dec_indent_level()\n        super()._write_closing_row()\n\n    def _to_math_parts(self, value: str) -> str:\n        # dollar characters for both sides of math parts are not required in\n        # Jupyter latex.\n        # return r""${:s}$"".format(value)\n\n        return value\n\n    def _create_styler(self, writer: AbstractTableWriter) -> StylerInterface:\n        return LatexStyler(writer)\n\n\nclass LatexMatrixWriter(LatexWriter):\n    """"""\n    A matrix writer class for LaTeX environment.\n\n        :Example:\n            :ref:`example-latex-matrix-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with LaTeX ``array`` environment.\n\n        :Example:\n            :ref:`example-latex-matrix-writer`\n    """"""\n\n    FORMAT_NAME = ""latex_matrix""\n    _RE_VAR = re.compile(r""^[a-zA-Z]+_\\{[a-zA-Z0-9]+\\}$"")\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_write_header = False\n        self.is_write_header_separator_row = False\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        row_item = super()._to_row_item(row_idx, col_dp, value_dp)\n\n        if self._RE_VAR.search(row_item):\n            return row_item\n\n        if self._is_math_parts(value_dp):\n            return self._to_math_parts(row_item)\n\n        return row_item\n\n    def _get_header_row_separator_items(self) -> List[str]:\n        return []\n\n    def _get_opening_row_items(self) -> List[str]:\n        row_item_list = []\n\n        if typepy.is_not_null_string(self.table_name):\n            row_item_list.append(self.table_name + r"" = \\left( "")\n        else:\n            row_item_list.append(r""\\left( "")\n\n        row_item_list.extend(\n            [r""\\begin{array}{"", ""{:s}"".format("""".join(self._get_col_align_char_list())), ""}""]\n        )\n\n        return ["""".join(row_item_list)]\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [r""\\end{array} \\right)""]\n\n    def _write_opening_row(self) -> None:\n        self._write_line(r""\\begin{equation}"")\n        self.inc_indent_level()\n        super()._write_opening_row()\n\n    def _write_closing_row(self) -> None:\n        super()._write_closing_row()\n        self.dec_indent_level()\n        self._write_line(r""\\end{equation}"")\n\n\nclass LatexTableWriter(LatexWriter):\n    """"""\n    A matrix writer class for LaTeX environment.\n\n        :Example:\n            :ref:`example-latex-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with LaTeX ``array`` environment.\n\n        :Example:\n            :ref:`example-latex-table-writer`\n    """"""\n\n    FORMAT_NAME = ""latex_table""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.char_right_side_row = r"" \\\\ \\hline""\n        self._dp_extractor.type_value_map[Typecode.INFINITY] = r""\\infty""\n\n    def _get_opening_row_items(self) -> List[str]:\n        return [\n            """".join(\n                [\n                    r""\\begin{array}{"",\n                    ""{:s}"".format("" | "".join(self._get_col_align_char_list())),\n                    r""} \\hline"",\n                ]\n            )\n        ]\n\n    def __is_requre_verbatim(self, value_dp: DataProperty) -> bool:\n        if value_dp.typecode != typepy.Typecode.STRING:\n            return False\n\n        return True\n\n    def __verbatim(self, value: str) -> str:\n        return r""\\verb"" + ""|{:s}|"".format(value)\n\n    def _to_header_item(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return self.__verbatim(super()._to_header_item(col_dp, value_dp))\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        row_item = super()._to_row_item(row_idx, col_dp, value_dp)\n\n        if self._is_math_parts(value_dp):\n            return self._to_math_parts(row_item)\n\n        if self.__is_requre_verbatim(value_dp):\n            return self.__verbatim(row_item)\n\n        return row_item\n\n    def _get_header_row_separator_items(self) -> List[str]:\n        return [r""\\hline""]\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [r""\\end{array}""]\n'"
pytablewriter/writer/text/_ltsv.py,0,"b'import pathvalidate\nimport typepy\n\nfrom ._csv import CsvTableWriter\n\n\nclass LtsvTableWriter(CsvTableWriter):\n    """"""\n    A table writer class for\n    `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ format.\n\n        :Example:\n            :ref:`example-ltsv-table-writer`\n    """"""\n\n    FORMAT_NAME = ""ltsv""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_write_header = False\n\n        self._is_require_header = True\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with\n        `Labeled Tab-separated Values (LTSV) <http://ltsv.org/>`__ format.\n        Invalid characters in labels/data are removed.\n\n        :Example:\n            :ref:`example-ltsv-table-writer`\n        """"""\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            for values in self._table_value_matrix:\n                ltsv_item_list = [\n                    ""{:s}:{}"".format(pathvalidate.sanitize_ltsv_label(header_name), value)\n                    for header_name, value in zip(self.headers, values)\n                    if typepy.is_not_null_string(value)\n                ]\n\n                if typepy.is_empty_sequence(ltsv_item_list):\n                    continue\n\n                self._write_line(""\\t"".join(ltsv_item_list))\n'"
pytablewriter/writer/text/_markdown.py,0,"b'import copy\nfrom typing import List\n\nimport dataproperty as dp\nimport typepy\nfrom dataproperty import ColumnDataProperty, DataProperty\nfrom mbstrdecoder import MultiByteStrDecoder\n\nfrom ...style import Align, GFMarkdownStyler, MarkdownStyler, StylerInterface\nfrom .._table_writer import AbstractTableWriter\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass MarkdownTableWriter(IndentationTextTableWriter):\n    """"""\n    A table writer class for Markdown format.\n\n        :Example:\n            :ref:`example-markdown-table-writer`\n    """"""\n\n    FORMAT_NAME = ""markdown""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        self.__flavor = """"\n\n        super().__init__()\n\n        self.indent_string = """"\n        self.column_delimiter = ""|""\n        self.char_left_side_row = ""|""\n        self.char_right_side_row = ""|""\n        self.char_cross_point = ""|""\n        self.char_header_row_cross_point = ""|""\n        self.char_header_row_left_cross_point = ""|""\n        self.char_header_row_right_cross_point = ""|""\n\n        self.is_write_opening_row = True\n        self._use_default_header = True\n\n        self._is_require_header = True\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n        self._dp_extractor.min_column_width = 3\n\n        self._init_cross_point_maps()\n\n    def _to_header_item(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return self.__escape_vertical_bar_char(super()._to_header_item(col_dp, value_dp))\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return self.__escape_vertical_bar_char(super()._to_row_item(row_idx, col_dp, value_dp))\n\n    def _get_opening_row_items(self) -> List[str]:\n        return []\n\n    def _get_header_row_separator_items(self) -> List[str]:\n        header_separator_list = []\n        for col_dp in self._column_dp_list:\n            padding_len = self._get_padding_len(col_dp) + self.margin * 2\n            align = self._get_align(col_dp.column_index, col_dp.align)\n\n            if align == Align.RIGHT:\n                separator_item = ""-"" * (padding_len - 1) + "":""\n            elif align == Align.CENTER:\n                separator_item = "":"" + ""-"" * (padding_len - 2) + "":""\n            else:\n                separator_item = ""-"" * padding_len\n\n            header_separator_list.append(separator_item)\n\n        return header_separator_list\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return []\n\n    def _get_closing_row_items(self) -> List[str]:\n        return []\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with Markdown table format.\n\n        Args:\n            flavor (Optional[str]):\n                possible flavors are:\n\n                    - ``""github""``\n                    - ``""gfm""`` (alias for ``""github""``)\n\n                Defaults to |None|.\n\n        Example:\n            :ref:`example-markdown-table-writer`\n\n        .. note::\n            - |None| values are written as an empty string\n            - Vertical bar characters (``\'|\'``) in table items are escaped\n        """"""\n\n        self.__flavor = kwargs.pop(""flavor"", """")\n        if self.__flavor:\n            self.__flavor = self.__flavor.lower()\n            self._styler = self._create_styler(self)\n\n        with self._logger:\n            self._verify_property()\n            self.__write_chapter()\n            self._write_table(**kwargs)\n            if self.is_write_null_line_after_table:\n                self.write_null_line()\n\n    def _write_table_iter(self, **kwargs) -> None:\n        self.__write_chapter()\n        super()._write_table_iter()\n\n    def __write_chapter(self) -> None:\n        if typepy.is_null_string(self.table_name):\n            return\n\n        self._write_line(\n            ""{:s} {:s}"".format(\n                ""#"" * (self._indent_level + 1), MultiByteStrDecoder(self.table_name).unicode_str\n            )\n        )\n\n    def _create_styler(self, writer: AbstractTableWriter) -> StylerInterface:\n        if self.__flavor in (""gfm"", ""github""):\n            return GFMarkdownStyler(writer)\n\n        return MarkdownStyler(writer)\n\n    @staticmethod\n    def __escape_vertical_bar_char(value: str) -> str:\n        return value.replace(""|"", r""\\|"")\n'"
pytablewriter/writer/text/_mediawiki.py,0,"b'import copy\nimport re\nfrom typing import List, Sequence\n\nimport dataproperty as dp\nimport typepy\nfrom dataproperty import ColumnDataProperty, DataProperty, LineBreakHandling\nfrom mbstrdecoder import MultiByteStrDecoder\n\nfrom ...style import Align\nfrom ...style._styler import get_align_char\nfrom ._text_writer import TextTableWriter\n\n\nclass MediaWikiTableWriter(TextTableWriter):\n    """"""\n    A table writer class for MediaWiki format.\n\n        :Example:\n            :ref:`example-mediawiki-table-writer`\n    """"""\n\n    FORMAT_NAME = ""mediawiki""\n    __RE_TABLE_SEQUENCE = re.compile(r""^[\\s]+[*|#]+"")\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.column_delimiter = ""\\n""\n\n        self.is_padding = False\n        self.is_write_header_separator_row = True\n        self.is_write_value_separator_row = True\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n\n        self.update_preprocessor(line_break_handling=LineBreakHandling.NOP)\n\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n\n    def _write_header(self) -> None:\n        if not self.is_write_header:\n            return\n\n        if typepy.is_not_null_string(self.table_name):\n            self._write_line(""|+"" + MultiByteStrDecoder(self.table_name).unicode_str)\n\n        super()._write_header()\n\n    def _write_value_row(\n        self, row: int, values: Sequence[str], value_dp_list: Sequence[DataProperty]\n    ) -> None:\n        self._write_row(\n            row,\n            [\n                self.__modify_table_element(value, value_dp)\n                for value, value_dp, in zip(values, value_dp_list)\n            ],\n        )\n\n    def _get_opening_row_items(self) -> List[str]:\n        return [\'{| class=""wikitable""\']\n\n    def _get_header_row_separator_items(self) -> List[str]:\n        return [""|-""]\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return self._get_header_row_separator_items()\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [""|}""]\n\n    def _get_header_format_string(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return ""! {{:{:s}{:s}}}"".format(\n            get_align_char(Align.CENTER), str(self._get_padding_len(col_dp, value_dp))\n        )\n\n    def __modify_table_element(self, value: str, value_dp: DataProperty):\n        if value_dp.align is Align.LEFT:\n            forma_stirng = ""| {1:s}""\n        else:\n            forma_stirng = \'| style=""text-align:{0:s}""| {1:s}\'\n\n        if self.__RE_TABLE_SEQUENCE.search(value) is not None:\n            value = ""\\n"" + value.lstrip()\n\n        return forma_stirng.format(value_dp.align.align_string, value)\n'"
pytablewriter/writer/text/_rst.py,0,"b'import copy\nfrom typing import List\n\nimport dataproperty\nimport typepy\nfrom mbstrdecoder import MultiByteStrDecoder\n\nfrom ...style import ReStructuredTextStyler, StylerInterface\nfrom .._table_writer import AbstractTableWriter\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass RstTableWriter(IndentationTextTableWriter):\n    """"""\n    A base class of reStructuredText table writer.\n    """"""\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n        self.char_header_row_separator = ""=""\n        self.char_cross_point = ""+""\n        self.char_left_cross_point = ""+""\n        self.char_right_cross_point = ""+""\n        self.char_top_left_cross_point = ""+""\n        self.char_top_right_cross_point = ""+""\n        self.char_bottom_left_cross_point = ""+""\n        self.char_bottom_right_cross_point = ""+""\n        self.char_header_row_cross_point = ""+""\n        self.char_header_row_left_cross_point = ""+""\n        self.char_header_row_right_cross_point = ""+""\n\n        self.char_opening_row_cross_point = ""+""\n        self.char_closing_row_cross_point = ""+""\n\n        self.indent_string = ""    ""\n        self.is_write_header_separator_row = True\n        self.is_write_value_separator_row = True\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n\n    def write_table(self, **kwargs) -> None:\n        with self._logger:\n            self._write_line(self._get_table_directive())\n            self._verify_property()\n            self._write_table(**kwargs)\n            if self.is_write_null_line_after_table:\n                self.write_null_line()\n\n    def _get_table_directive(self) -> str:\n        if typepy.is_null_string(self.table_name):\n            return "".. table:: \\n""\n\n        return "".. table:: {}\\n"".format(MultiByteStrDecoder(self.table_name).unicode_str)\n\n    def _write_table(self, **kwargs) -> None:\n        self.inc_indent_level()\n        super()._write_table(**kwargs)\n        self.dec_indent_level()\n\n    def _create_styler(self, writer: AbstractTableWriter) -> StylerInterface:\n        return ReStructuredTextStyler(writer)\n\n\nclass RstCsvTableWriter(RstTableWriter):\n    """"""\n    A table class writer for reStructuredText\n    `CSV table <http://docutils.sourceforge.net/docs/ref/rst/directives.html#id4>`__\n    format.\n\n        :Example:\n            :ref:`example-rst-csv-table-writer`\n    """"""\n\n    FORMAT_NAME = ""rst_csv_table""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.column_delimiter = "", ""\n        self.char_cross_point = """"\n        self.is_padding = False\n        self.is_write_header_separator_row = False\n        self.is_write_value_separator_row = False\n        self.is_write_closing_row = False\n\n        self._quoting_flags[typepy.Typecode.STRING] = True\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with reStructuredText CSV table format.\n\n        :raises pytablewriter.EmptyTableDataError:\n            If the |headers| and the |value_matrix| is empty.\n        :Example:\n            :ref:`example-rst-csv-table-writer`\n\n        .. note::\n            - |None| values are written as an empty string\n        """"""\n\n        IndentationTextTableWriter.write_table(self, **kwargs)\n\n    def _get_opening_row_items(self) -> List[str]:\n        directive = "".. csv-table:: ""\n\n        if typepy.is_null_string(self.table_name):\n            return [directive]\n\n        return [directive + MultiByteStrDecoder(self.table_name).unicode_str]\n\n    def _write_opening_row(self) -> None:\n        self.dec_indent_level()\n        super()._write_opening_row()\n        self.inc_indent_level()\n\n    def _write_header(self) -> None:\n        if not self.is_write_header:\n            return\n\n        if typepy.is_not_empty_sequence(self.headers):\n            self._write_line(\n                \':header: ""{:s}""\'.format(\n                    \'"", ""\'.join(\n                        [MultiByteStrDecoder(header).unicode_str for header in self.headers]\n                    )\n                )\n            )\n\n        self._write_line(\n            "":widths: ""\n            + "", "".join([str(col_dp.ascii_char_width) for col_dp in self._column_dp_list])\n        )\n        self._write_line()\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return []\n\n    def _get_closing_row_items(self) -> List[str]:\n        return []\n\n\nclass RstGridTableWriter(RstTableWriter):\n    """"""\n    A table writer class for reStructuredText\n    `Grid Tables <http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#grid-tables>`__\n    format.\n\n        :Example:\n            :ref:`example-rst-grid-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with reStructuredText grid tables format.\n\n        :Example:\n            :ref:`example-rst-grid-table-writer`\n\n        .. note::\n            - |None| values are written as an empty string\n    """"""\n\n    FORMAT_NAME = ""rst_grid_table""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return False\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.char_left_side_row = ""|""\n        self.char_right_side_row = ""|""\n\n\nclass RstSimpleTableWriter(RstTableWriter):\n    """"""\n    A table writer class for reStructuredText\n    `Simple Tables <http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#simple-tables>`__\n    format.\n\n        :Example:\n            :ref:`example-rst-simple-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with reStructuredText simple tables format.\n\n        :Example:\n            :ref:`example-rst-simple-table-writer`\n\n        .. note::\n            - |None| values are written as an empty string\n    """"""\n\n    FORMAT_NAME = ""rst_simple_table""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return False\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.column_delimiter = ""  ""\n        self.char_cross_point = ""  ""\n        self.char_opening_row_cross_point = ""  ""\n        self.char_closing_row_cross_point = ""  ""\n        self.char_header_row_cross_point = ""  ""\n        self.char_header_row_left_cross_point = ""  ""\n        self.char_header_row_right_cross_point = ""  ""\n\n        self.char_opening_row = ""=""\n        self.char_closing_row = ""=""\n\n        self.is_write_value_separator_row = False\n\n        self._init_cross_point_maps()\n'"
pytablewriter/writer/text/_spacealigned.py,0,"b'import copy\n\nimport dataproperty\n\nfrom ._csv import CsvTableWriter\n\n\nclass SpaceAlignedTableWriter(CsvTableWriter):\n    """"""\n    A table writer class for space aligned format.\n\n        :Example:\n            :ref:`example-space-aligned-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with space aligned format.\n\n        :Example:\n            :ref:`example-space-aligned-table-writer`\n    """"""\n\n    FORMAT_NAME = ""space_aligned""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.column_delimiter = ""  ""\n        self.char_cross_point = ""  ""\n\n        self.is_padding = True\n        self.is_formatting_float = True\n\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n'"
pytablewriter/writer/text/_text_writer.py,0,"b'import enum\nimport io\nimport sys\nfrom itertools import chain\nfrom typing import List, Optional, Sequence, cast\n\nimport typepy\nfrom dataproperty import Align, ColumnDataProperty, DataProperty, LineBreakHandling\n\nfrom ...style import Cell, Style, StylerInterface, TextStyler\nfrom ...style._styler import get_align_char\nfrom .._table_writer import AbstractTableWriter, ColSeparatorStyleFilterFunc\nfrom ._interface import IndentationInterface, TextWriterInterface\n\n\n@enum.unique\nclass RowType(enum.Enum):\n    OPENING = ""opening""\n    HEADER_SEPARATOR = ""header separator""\n    MIDDLE = ""middle""\n    CLOSING = ""closing""\n\n\nclass TextTableWriter(AbstractTableWriter, TextWriterInterface):\n    """"""\n    A base class for table writer with text formats.\n\n    .. figure:: ss/table_char.png\n       :scale: 60%\n       :alt: table_char\n\n       Character attributes that compose a table\n\n    .. py:attribute:: column_delimiter\n        :type: str\n\n        A column delimiter of a table.\n\n    .. py:attribute:: char_left_side_row\n        :type: str\n\n        A character of a left side of a row.\n\n    .. py:attribute:: char_right_side_row\n        :type: str\n\n        A character of a right side of a row.\n\n    .. py:attribute:: char_cross_point\n        :type: str\n\n        A character of the crossing point of column delimiter and row\n        delimiter.\n\n    .. py:attribute:: char_opening_row\n        :type: str\n\n        A character of the first line of a table.\n\n    .. py:attribute:: char_header_row_separator\n        :type: str\n\n        A character of a separator line of the header and\n        the body of the table.\n\n    .. py:attribute:: char_value_row_separator\n        :type: str\n\n        A character of a row separator line of the table.\n\n    .. py:attribute:: char_closing_row\n        :type: str\n\n        A character of the last line of a table.\n\n    .. py:attribute:: is_write_header_separator_row\n        :type: bool\n\n        Write a header separator line of the table if the value is |True|.\n\n    .. py:attribute:: is_write_value_separator_row\n        :type: bool\n\n        Write row separator line(s) of the table if the value is |True|.\n\n    .. py:attribute:: is_write_opening_row\n        :type: bool\n\n        Write an opening line of the table if the value is |True|.\n\n    .. py:attribute:: is_write_closing_row\n        :type: bool\n\n        Write a closing line of the table if the value is |True|.\n\n    .. py:attribute:: is_write_null_line_after_table\n        :type: bool\n\n        Write a blank line of after writing a table if the value is |True|.\n\n    .. py:attribute:: margin\n        :type: int\n\n        Margin size for each cells\n\n    """"""\n\n    @property\n    def margin(self) -> int:\n        return self.__margin\n\n    @margin.setter\n    def margin(self, value: int) -> None:\n        self.__margin = value\n\n    def __update_template(self) -> None:\n        self.__value_cell_margin_format = self.__make_margin_format("" "")\n        self.__opening_row_cell_format = self.__make_margin_format(self.char_opening_row)\n        self._header_row_separator_cell_format = self.__make_margin_format(\n            self.char_header_row_separator\n        )\n        self.__value_row_separator_cell_format = self.__make_margin_format(\n            self.char_value_row_separator\n        )\n        self.__closing_row_cell_format = self.__make_margin_format(self.char_closing_row)\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.stream = sys.stdout\n\n        self._set_chars("""")\n\n        self.column_delimiter = ""|""\n\n        self.char_opening_row = ""-""\n        self.char_opening_row_cross_point = ""-""\n\n        self.char_header_row_separator = ""-""\n        self.char_header_row_cross_point = ""-""\n\n        self.char_value_row_separator = ""-""\n\n        self.char_closing_row = ""-""\n        self.char_closing_row_cross_point = ""-""\n\n        self.margin = 0\n\n        self._dp_extractor.preprocessor.line_break_handling = LineBreakHandling.REPLACE\n        self.is_write_null_line_after_table = False\n\n        self._init_cross_point_maps()\n\n        self._col_separator_style_filters = []  # type: List[ColSeparatorStyleFilterFunc]\n\n    def _init_cross_point_maps(self) -> None:\n        self.__cross_point_maps = {\n            RowType.OPENING: self.char_opening_row_cross_point,\n            RowType.HEADER_SEPARATOR: self.char_header_row_cross_point,\n            RowType.MIDDLE: self.char_cross_point,\n            RowType.CLOSING: self.char_closing_row_cross_point,\n        }\n        self.__left_cross_point_maps = {\n            RowType.OPENING: self.char_top_left_cross_point,\n            RowType.HEADER_SEPARATOR: self.char_header_row_left_cross_point,\n            RowType.MIDDLE: self.char_left_cross_point,\n            RowType.CLOSING: self.char_bottom_left_cross_point,\n        }\n        self.__right_cross_point_maps = {\n            RowType.OPENING: self.char_top_right_cross_point,\n            RowType.HEADER_SEPARATOR: self.char_header_row_right_cross_point,\n            RowType.MIDDLE: self.char_right_cross_point,\n            RowType.CLOSING: self.char_bottom_right_cross_point,\n        }\n\n    def add_col_separator_style_filter(self, style_filter: ColSeparatorStyleFilterFunc) -> None:\n        self._col_separator_style_filters.insert(0, style_filter)\n\n    def write_null_line(self) -> None:\n        """"""\n        Write a null line to the |stream|.\n        """"""\n\n        self._write_line()\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table|.\n\n        .. note::\n            - |None| values are written as an empty string.\n        """"""\n\n        super().write_table(**kwargs)\n        if self.is_write_null_line_after_table:\n            self.write_null_line()\n\n    def dump(self, output, close_after_write: bool = True, **kwargs) -> None:\n        """"""Write data to the output with tabular format.\n\n        Args:\n            output (file descriptor or str):\n                file descriptor or path to the output file.\n\n            close_after_write (bool, optional):\n                Close the output after write.\n                Defaults to |True|.\n        """"""\n\n        try:\n            output.write\n            self.stream = output\n        except AttributeError:\n            self.stream = open(output, ""w"", encoding=""utf-8"")\n\n        try:\n            self.write_table(**kwargs)\n        finally:\n            if close_after_write:\n                self.stream.close()\n                self.stream = sys.stdout\n\n    def dumps(self, **kwargs) -> str:\n        """"""Get rendered tabular text from the table data.\n\n        Only available for text format table writers.\n\n        Args:\n            **kwargs:\n                Optional arguments that the writer takes.\n\n        Returns:\n            str: Rendered tabular text.\n        """"""\n\n        old_stream = self.stream\n\n        try:\n            self.stream = io.StringIO()\n            self.write_table(**kwargs)\n            tabular_text = self.stream.getvalue()\n        finally:\n            self.stream = old_stream\n\n        return tabular_text\n\n    def _set_chars(self, c: str) -> None:\n        self.char_left_side_row = c\n        self.char_right_side_row = c\n\n        self.char_cross_point = c\n        self.char_left_cross_point = c\n        self.char_right_cross_point = c\n        self.char_top_left_cross_point = c\n        self.char_top_right_cross_point = c\n        self.char_bottom_left_cross_point = c\n        self.char_bottom_right_cross_point = c\n\n        self.char_opening_row = c\n        self.char_opening_row_cross_point = c\n\n        self.char_header_row_separator = c\n        self.char_header_row_cross_point = c\n        self.char_header_row_left_cross_point = c\n        self.char_header_row_right_cross_point = c\n\n        self.char_value_row_separator = c\n\n        self.char_closing_row = c\n        self.char_closing_row_cross_point = c\n\n        self._init_cross_point_maps()\n\n    def _create_styler(self, writer: AbstractTableWriter) -> StylerInterface:\n        return TextStyler(writer)\n\n    def _write_table_iter(self, **kwargs) -> None:\n        super()._write_table_iter()\n        if self.is_write_null_line_after_table:\n            self.write_null_line()\n\n    def _write_table(self, **kwargs) -> None:\n        self._preprocess()\n        self._write_opening_row()\n\n        try:\n            self._write_header()\n            self.__write_header_row_separator()\n        except ValueError:\n            pass\n\n        is_first_value_row = True\n        for row, (values, value_dp_list) in enumerate(\n            zip(self._table_value_matrix, self._table_value_dp_matrix)\n        ):\n            try:\n                if is_first_value_row:\n                    is_first_value_row = False\n                else:\n                    if self.is_write_value_separator_row:\n                        self._write_value_row_separator()\n\n                self._write_value_row(row, cast(List[str], values), value_dp_list)\n            except TypeError:\n                continue\n\n        self._write_closing_row()\n\n    def _get_opening_row_items(self) -> List[str]:\n        return self.__get_row_separator_items(self.__opening_row_cell_format, self.char_opening_row)\n\n    def _get_header_row_separator_items(self) -> List[str]:\n        return self.__get_row_separator_items(\n            self._header_row_separator_cell_format, self.char_header_row_separator\n        )\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return self.__get_row_separator_items(\n            self.__value_row_separator_cell_format, self.char_value_row_separator\n        )\n\n    def _get_closing_row_items(self) -> List[str]:\n        return self.__get_row_separator_items(self.__closing_row_cell_format, self.char_closing_row)\n\n    def __get_row_separator_items(self, margin_format: str, separator_char: str) -> List[str]:\n        return [\n            margin_format.format(separator_char * self._get_padding_len(col_dp))\n            for col_dp in self._column_dp_list\n        ]\n\n    def _get_header_format_string(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return ""{{:{:s}{:s}}}"".format(\n            get_align_char(Align.CENTER), str(self._get_padding_len(col_dp, value_dp)),\n        )\n\n    def _to_header_item(self, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        return self.__value_cell_margin_format.format(super()._to_header_item(col_dp, value_dp))\n\n    def _apply_style_to_row_item(\n        self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty, style: Style\n    ) -> str:\n        return self.__value_cell_margin_format.format(\n            super()._apply_style_to_row_item(row_idx, col_dp, value_dp, style)\n        )\n\n    def _write_raw_string(self, unicode_text: str) -> None:\n        self.stream.write(unicode_text)\n\n    def _write_raw_line(self, unicode_text: str = """") -> None:\n        self._write_raw_string(unicode_text + ""\\n"")\n\n    def _write(self, text):\n        self._write_raw_string(text)\n\n    def _write_line(self, text: str = """") -> None:\n        self._write_raw_line(text)\n\n    def _fetch_col_separator_style(\n        self, left_cell: Optional[Cell], right_cell: Optional[Cell], default_style: Style\n    ) -> Style:\n        for style_filter in self._col_separator_style_filters:\n            style = style_filter(left_cell, right_cell, **self.style_filter_kwargs)\n            if style:\n                return style\n\n        return default_style\n\n    def __to_column_delimiter(\n        self,\n        row: int,\n        left_col_dp: Optional[ColumnDataProperty],\n        right_col_dp: Optional[ColumnDataProperty],\n        col_delimiter: str,\n    ) -> str:\n        left_cell = None\n        if left_col_dp:\n            left_cell = Cell(\n                row=row,\n                col=left_col_dp.column_index,\n                value=col_delimiter,\n                default_style=self._get_col_style(left_col_dp.column_index),\n            )\n\n        right_cell = None\n        if right_col_dp:\n            right_cell = Cell(\n                row=row,\n                col=right_col_dp.column_index,\n                value=col_delimiter,\n                default_style=self._get_col_style(right_col_dp.column_index),\n            )\n\n        style = self._fetch_col_separator_style(\n            left_cell=left_cell, right_cell=right_cell, default_style=self.default_style,\n        )\n\n        return self._styler.apply_terminal_style(col_delimiter, style=style)\n\n    def _write_row(self, row: int, values: Sequence[str]) -> None:\n        if typepy.is_empty_sequence(values):\n            return\n\n        col_delimiters = (\n            [\n                self.__to_column_delimiter(\n                    row, None, self._column_dp_list[0], self.char_left_side_row,\n                )\n            ]\n            + [\n                self.__to_column_delimiter(\n                    row,\n                    self._column_dp_list[col_idx],\n                    self._column_dp_list[col_idx + 1],\n                    self.column_delimiter,\n                )\n                for col_idx in range(len(self._column_dp_list) - 1)\n            ]\n            + [\n                self.__to_column_delimiter(\n                    row, self._column_dp_list[-1], None, self.char_right_side_row,\n                )\n            ]\n        )\n\n        row_items = [""""] * (len(col_delimiters) + len(values))\n        row_items[::2] = col_delimiters\n        row_items[1::2] = list(values)\n\n        self._write_line("""".join(chain.from_iterable(row_items)))\n\n    def _write_header(self) -> None:\n        if not self.is_write_header:\n            return\n\n        if typepy.is_empty_sequence(self._table_headers):\n            raise ValueError(""header is empty"")\n\n        self._write_row(-1, self._table_headers)\n\n    def _write_value_row(\n        self, row: int, values: Sequence[str], value_dp_list: Sequence[DataProperty]\n    ) -> None:\n        self._write_row(row, values)\n\n    def __write_separator_row(self, values, row_type=RowType.MIDDLE):\n        if typepy.is_empty_sequence(values):\n            return\n\n        cross_point = self.__cross_point_maps[row_type]\n        left_cross_point = self.__left_cross_point_maps[row_type]\n        right_cross_point = self.__right_cross_point_maps[row_type]\n\n        left_cross_point = left_cross_point if left_cross_point else cross_point\n        right_cross_point = right_cross_point if right_cross_point else cross_point\n        if typepy.is_null_string(self.char_left_side_row):\n            left_cross_point = """"\n        if typepy.is_null_string(self.char_right_side_row):\n            right_cross_point = """"\n\n        self._write_line(left_cross_point + cross_point.join(values) + right_cross_point)\n\n    def _write_opening_row(self) -> None:\n        if not self.is_write_opening_row:\n            return\n\n        self.__write_separator_row(self._get_opening_row_items(), row_type=RowType.OPENING)\n\n    def __write_header_row_separator(self):\n        if any([not self.is_write_header, not self.is_write_header_separator_row]):\n            return\n\n        self.__write_separator_row(\n            self._get_header_row_separator_items(), row_type=RowType.HEADER_SEPARATOR\n        )\n\n    def _write_value_row_separator(self) -> None:\n        """"""\n        Write row separator of the table which matched to the table type\n        regardless of the value of the\n        :py:attr:`.is_write_value_separator_row`.\n        """"""\n\n        self.__write_separator_row(self._get_value_row_separator_items())\n\n    def _write_closing_row(self) -> None:\n        if not self.is_write_closing_row:\n            return\n\n        self.__write_separator_row(self._get_closing_row_items(), row_type=RowType.CLOSING)\n\n    def __make_margin_format(self, margin_char):\n        margin_str = margin_char * self.__margin\n\n        return margin_str + ""{:s}"" + margin_str\n\n    def _preprocess_table_property(self) -> None:\n        super()._preprocess_table_property()\n\n        self.__update_template()\n        self._init_cross_point_maps()\n\n\nclass IndentationTextTableWriter(TextTableWriter, IndentationInterface):\n    """"""\n    A base class for table writer with indentation text formats.\n\n    .. py:attribute:: indent_string\n\n        Indentation string for each level.\n    """"""\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.set_indent_level(0)\n        self.indent_string = """"\n\n    def set_indent_level(self, indent_level: int) -> None:\n        """"""\n        Set the current indent level.\n\n        :param int indent_level: New indent level.\n        """"""\n\n        self._indent_level = indent_level\n\n    def inc_indent_level(self) -> None:\n        """"""\n        Increment the current indent level.\n        """"""\n\n        self._indent_level += 1\n\n    def dec_indent_level(self) -> None:\n        """"""\n        Decrement the current indent level.\n        """"""\n\n        self._indent_level -= 1\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table|.\n\n        Args:\n            indent (Optional[int]):\n                Indent level of an output.\n                Interpretation of indent level value differ format to format.\n                Some writer classes may ignore this value.\n\n        .. note::\n            - |None| values are written as an empty string.\n        """"""\n\n        indent = kwargs.pop(""indent"", None)\n\n        if indent is not None:\n            self._logger.logger.debug(""indent: {}"".format(indent))\n            self.set_indent_level(int(indent))\n\n        super().write_table(**kwargs)\n\n    def _get_indent_string(self) -> str:\n        return self.indent_string * self._indent_level\n\n    def _write(self, text):\n        self._write_raw_string(self._get_indent_string() + text)\n\n    def _write_line(self, text: str = """") -> None:\n        if typepy.is_not_null_string(text):\n            self._write_raw_line(self._get_indent_string() + text)\n        else:\n            self._write_raw_line("""")\n'"
pytablewriter/writer/text/_toml.py,0,"b'import warnings\nfrom decimal import Decimal\n\nimport typepy\n\nfrom .._common import import_error_msg_template\nfrom ._common import serialize_dp\nfrom ._text_writer import TextTableWriter\n\n\nclass TomlTableWriter(TextTableWriter):\n    """"""\n    A table writer class for\n    `TOML <https://github.com/toml-lang/toml>`__ data format.\n\n        :Example:\n            :ref:`example-toml-table-writer`\n    """"""\n\n    FORMAT_NAME = ""toml""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self):\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_formatting_float = False\n\n        self._is_require_table_name = True\n        self._is_require_header = True\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with\n        `TOML <https://github.com/toml-lang/toml>`__ format.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |headers| is empty.\n        :Example:\n            :ref:`example-toml-table-writer`\n        """"""\n\n        try:\n            import toml\n\n            class TomlTableEncoder(toml.encoder.TomlEncoder):  # type: ignore\n                def __init__(self, _dict=dict, preserve=False):\n                    super().__init__(_dict=_dict, preserve=preserve)\n\n                    self.dump_funcs[str] = str\n\n                    # pytype: disable=module-attr\n                    self.dump_funcs[Decimal] = toml.encoder._dump_float\n                    # pytype: enable=module-attr\n\n        except ImportError:\n            warnings.warn(import_error_msg_template.format(""toml""))\n            raise\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            body = []\n            for value_dp_list in self._table_value_dp_matrix:\n                row = {}\n\n                for header, value in zip(\n                    self.headers, [serialize_dp(value_dp) for value_dp in value_dp_list],\n                ):\n                    if typepy.is_null_string(value):\n                        continue\n\n                    row[header] = value\n\n                body.append(row)\n\n            self.stream.write(\n                toml.dumps({self.table_name: body}, encoder=TomlTableEncoder())  # type: ignore\n            )\n'"
pytablewriter/writer/text/_tsv.py,0,"b'from ._csv import CsvTableWriter\n\n\nclass TsvTableWriter(CsvTableWriter):\n    """"""\n    A table writer class for tab separated values (TSV) format.\n\n        :Example:\n            :ref:`example-tsv-table-writer`\n    """"""\n\n    FORMAT_NAME = ""tsv""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.column_delimiter = ""\\t""\n'"
pytablewriter/writer/text/_unicode.py,0,"b'import copy\n\nimport dataproperty as dp\n\nfrom ._text_writer import IndentationTextTableWriter\n\n\nclass UnicodeTableWriter(IndentationTextTableWriter):\n    """"""\n    A table writer class using Unicode characters.\n\n        :Example:\n            :ref:`example-unicode-table-writer`\n    """"""\n\n    FORMAT_NAME = ""unicode""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n\n        self.column_delimiter = ""\xe2\x94\x82""\n        self.char_left_side_row = ""\xe2\x94\x82""\n        self.char_right_side_row = ""\xe2\x94\x82""\n\n        self.char_cross_point = ""\xe2\x94\xbc""\n        self.char_left_cross_point = ""\xe2\x94\x9c""\n        self.char_right_cross_point = ""\xe2\x94\xa4""\n        self.char_header_row_cross_point = ""\xe2\x94\xbc""\n        self.char_header_row_left_cross_point = ""\xe2\x94\x9c""\n        self.char_header_row_right_cross_point = ""\xe2\x94\xa4""\n        self.char_top_left_cross_point = ""\xe2\x94\x8c""\n        self.char_top_right_cross_point = ""\xe2\x94\x90""\n        self.char_bottom_left_cross_point = ""\xe2\x94\x94""\n        self.char_bottom_right_cross_point = ""\xe2\x94\x98""\n\n        self.char_opening_row = ""\xe2\x94\x80""\n        self.char_opening_row_cross_point = ""\xe2\x94\xac""\n\n        self.char_header_row_separator = ""\xe2\x94\x80""\n        self.char_value_row_separator = ""\xe2\x94\x80""\n\n        self.char_closing_row = ""\xe2\x94\x80""\n        self.char_closing_row_cross_point = ""\xe2\x94\xb4""\n\n        self.indent_string = ""    ""\n        self.is_write_header_separator_row = True\n        self.is_write_value_separator_row = True\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n\n\nclass BoldUnicodeTableWriter(IndentationTextTableWriter):\n    """"""\n    A table writer class using bold Unicode characters.\n\n        :Example:\n            :ref:`example-unicode-table-writer`\n    """"""\n\n    FORMAT_NAME = ""bold_unicode""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n\n        self.column_delimiter = ""\xe2\x94\x83""\n        self.char_left_side_row = ""\xe2\x94\x83""\n        self.char_right_side_row = ""\xe2\x94\x83""\n\n        self.char_cross_point = ""\xe2\x95\x8b""\n        self.char_left_cross_point = ""\xe2\x94\xa3""\n        self.char_right_cross_point = ""\xe2\x94\xab""\n        self.char_header_row_cross_point = ""\xe2\x95\x8b""\n        self.char_header_row_left_cross_point = ""\xe2\x94\xa3""\n        self.char_header_row_right_cross_point = ""\xe2\x94\xab""\n        self.char_top_left_cross_point = ""\xe2\x94\x8f""\n        self.char_top_right_cross_point = ""\xe2\x94\x93""\n        self.char_bottom_left_cross_point = ""\xe2\x94\x97""\n        self.char_bottom_right_cross_point = ""\xe2\x94\x9b""\n\n        self.char_opening_row = ""\xe2\x94\x81""\n        self.char_opening_row_cross_point = ""\xe2\x94\xb3""\n\n        self.char_header_row_separator = ""\xe2\x94\x81""\n        self.char_value_row_separator = ""\xe2\x94\x81""\n\n        self.char_closing_row = ""\xe2\x94\x81""\n        self.char_closing_row_cross_point = ""\xe2\x94\xbb""\n\n        self.indent_string = ""    ""\n        self.is_write_header_separator_row = True\n        self.is_write_value_separator_row = True\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n\n        self._quoting_flags = copy.deepcopy(dp.NOT_QUOTING_FLAGS)\n\n        self._init_cross_point_maps()\n'"
pytablewriter/writer/text/_yaml.py,0,"b'import copy\nimport warnings\n\nimport dataproperty\n\nfrom .._common import import_error_msg_template\nfrom ._common import serialize_dp\nfrom ._text_writer import TextTableWriter\n\n\nclass YamlTableWriter(TextTableWriter):\n    """"""\n    A table writer class for `YAML <https://yaml.org/>`__ format.\n\n        :Example:\n            :ref:`example-yaml-table-writer`\n    """"""\n\n    FORMAT_NAME = ""yaml""\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.is_padding = False\n\n        self._dp_extractor.float_type = float\n        self._quoting_flags = copy.deepcopy(dataproperty.NOT_QUOTING_FLAGS)\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return False\n\n    def write_table(self, **kwargs) -> None:\n        """"""\n        |write_table| with\n        YAML format.\n\n        :Example:\n            :ref:`example-yaml-table-writer`\n        """"""\n\n        try:\n            import yaml\n        except ImportError:\n            warnings.warn(import_error_msg_template.format(""yaml""))\n            raise\n\n        with self._logger:\n            self._verify_property()\n            self._preprocess()\n\n            if self.headers:\n                matrix = [\n                    dict(zip(self.headers, [serialize_dp(value_dp) for value_dp in value_dp_list]))\n                    for value_dp_list in self._table_value_dp_matrix\n                ]\n            else:\n                matrix = [\n                    [serialize_dp(value_dp) for value_dp in value_dp_list]  # type: ignore\n                    for value_dp_list in self._table_value_dp_matrix\n                ]  # type: ignore\n\n            if self.table_name:\n                self._write(yaml.safe_dump({self.table_name: matrix}, default_flow_style=False))\n            else:\n                self._write(yaml.safe_dump(matrix, default_flow_style=False))\n'"
test/writer/binary/__init__.py,0,b''
test/writer/binary/test_excel_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nfrom decimal import Decimal\n\nimport pytest\nfrom pytablereader import ExcelTableFileLoader\nfrom tabledata import TableData\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import headers, mix_header_list, mix_value_matrix, value_matrix, value_matrix_iter\n\n\ntry:\n    import xlwt  # noqa: W0611\n\n    HAS_XLWT = True\nexcept ImportError:\n    HAS_XLWT = False\n\n\ninf = Decimal(""Infinity"")\nnan = Decimal(""NaN"")\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table=""tablename"",\n        header=headers,\n        value=value_matrix,\n        expected=TableData(\n            ""tablename"",\n            [""a"", ""b"", ""c"", ""dd"", ""e""],\n            [[1, 123.1, ""a"", 1, 1], [2, 2.2, ""bb"", 2.2, 2.2], [3, 3.3, ""ccc"", 3, ""cccc""]],\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        header=headers,\n        value=None,\n        expected=TableData(""tablename"", [""a"", ""b"", ""c"", ""dd"", ""e""], []),\n    ),\n    Data(\n        table="""",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=TableData(\n            ""Sheet1"",\n            [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n            [\n                [1, ""1.1"", ""aa"", 1, 1, 1, inf, nan, 1, ""2017-01-01T00:00:00""],\n                [2, ""2.2"", ""bbb"", ""2.2"", ""2.2"", 0, inf, nan, inf, ""2017-01-02 03:04:05+09:00""],\n                [3, ""3.33"", ""cccc"", -3, ""ccc"", 1, inf, nan, nan, ""2017-01-01T00:00:00""],\n            ],\n        ),\n    ),\n    Data(\n        table=""infnan"",\n        header=[""inf"", ""nan""],\n        value=[[inf, nan], [""inf"", ""nan""], [""INF"", ""NAN""], [""INFINITY"", ""inf""]],\n        expected=TableData(\n            ""infnan"", [""inf"", ""nan""], [[inf, nan], [inf, nan], [inf, nan], [inf, inf]]\n        ),\n    ),\n    Data(\n        table=""line breaks"",\n        header=[""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        expected=TableData(\n            ""line breaks"", [""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""], [[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]]\n        ),\n    ),\n]\n\ninvalid_test_data_list = [\n    Data(table="""", header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class_list = [ptw.ExcelXlsTableWriter, ptw.ExcelXlsxTableWriter]\n\n\n@pytest.mark.xfail(run=False)\nclass Test_ExcelTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""writer_class"", ""table"", ""header"", ""value"", ""expected""],\n        [\n            [writer_class, data.table, data.header, data.value, data.expected]\n            for writer_class, data in itertools.product(\n                table_writer_class_list, normal_test_data_list\n            )\n        ],\n    )\n    def test_normal(self, tmpdir, writer_class, table, header, value, expected):\n        if writer_class == ptw.ExcelXlsTableWriter and not HAS_XLWT:\n            pytest.skip()\n\n        test_file_path = tmpdir.join(""test.xlsx"")\n\n        writer = writer_class()\n        writer.open(str(test_file_path))\n        writer.make_worksheet(table)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n        writer.close()\n\n        for table_data in ExcelTableFileLoader(str(test_file_path)).load():\n            expected_dump = ptw.dumps_tabledata(expected)\n            actual_dump = ptw.dumps_tabledata(table_data)\n\n            print_test_result(expected=expected_dump, actual=actual_dump)\n\n            assert actual_dump == expected_dump\n\n    @pytest.mark.parametrize(\n        [""writer_class"", ""table"", ""header"", ""value"", ""expected""],\n        [\n            [writer_class, data.table, data.header, data.value, data.expected]\n            for writer_class, data in itertools.product(\n                table_writer_class_list, invalid_test_data_list\n            )\n        ],\n    )\n    def test_exception(self, tmpdir, writer_class, table, header, value, expected):\n        if writer_class == ptw.ExcelXlsTableWriter and not HAS_XLWT:\n            pytest.skip()\n\n        test_file_path = tmpdir.join(""test.xlsx"")\n\n        writer = writer_class()\n        writer.open(str(test_file_path))\n        writer.make_worksheet(table)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n    @pytest.mark.parametrize(\n        [""writer_class"", ""header"", ""value""],\n        [\n            [writer_class, data.header, data.value]\n            for writer_class, data in itertools.product(\n                table_writer_class_list, normal_test_data_list\n            )\n        ],\n    )\n    def test_exception_null_sheet(self, tmpdir, writer_class, header, value):\n        if writer_class == ptw.ExcelXlsTableWriter and not HAS_XLWT:\n            pytest.skip()\n\n        test_file_path = tmpdir.join(""test.xlsx"")\n\n        writer = writer_class()\n        writer.open(str(test_file_path))\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(IOError):\n            writer.write_table()\n\n\n@pytest.mark.xfail(run=False)\nclass Test_ExcelTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""writer_class"", ""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                table_writer_class,\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                TableData(\n                    ""tablename"",\n                    [""ha"", ""hb"", ""hc""],\n                    [\n                        [1.0, 2.0, 3.0],\n                        [11.0, 12.0, 13.0],\n                        [1.0, 2.0, 3.0],\n                        [11.0, 12.0, 13.0],\n                        [101.0, 102.0, 103.0],\n                        [1001.0, 1002.0, 1003.0],\n                    ],\n                ),\n            ]\n            for table_writer_class in table_writer_class_list\n        ],\n    )\n    def test_normal(self, tmpdir, writer_class, table, header, value, expected):\n        if writer_class == ptw.ExcelXlsTableWriter and not HAS_XLWT:\n            pytest.skip()\n\n        test_file_path = tmpdir.join(""test.xlsx"")\n\n        writer = writer_class()\n        writer.open(str(test_file_path))\n        writer.make_worksheet(table)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        writer.close()\n        assert writer.first_data_row == 1\n        assert writer.last_data_row == 7\n\n        for table_data in ExcelTableFileLoader(str(test_file_path)).load():\n            assert table_data == expected\n\n    @pytest.mark.parametrize(\n        [""writer_class"", ""header"", ""value""],\n        [\n            [writer_class, data.header, data.value]\n            for writer_class, data in itertools.product(\n                table_writer_class_list, normal_test_data_list\n            )\n        ],\n    )\n    def test_exception_null_sheet(self, tmpdir, writer_class, header, value):\n        if writer_class == ptw.ExcelXlsTableWriter and not HAS_XLWT:\n            pytest.skip()\n\n        test_file_path = tmpdir.join(""test.xlsx"")\n\n        writer = writer_class()\n        writer.open(str(test_file_path))\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(IOError):\n            writer.write_table_iter()\n\n\n@pytest.mark.xfail(run=False)\nclass Test_ExcelTableWriter_dump:\n    def test_normal_single_sheet(self, tmpdir):\n        for writer_class in table_writer_class_list:\n            test_filepath = str(tmpdir.join(""test.xlsx""))\n            data = TableData(\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                [\n                    [1.0, 2.0, 3.0],\n                    [11.0, 12.0, 13.0],\n                    [1.0, 2.0, 3.0],\n                    [11.0, 12.0, 13.0],\n                    [101.0, 102.0, 103.0],\n                    [1001.0, 1002.0, 1003.0],\n                ],\n            )\n\n            writer = writer_class()\n            writer.from_tabledata(data)\n            writer.dump(test_filepath)\n\n            assert writer.first_data_row == 1\n            assert writer.last_data_row == 7\n\n            for expected in ExcelTableFileLoader(test_filepath).load():\n                assert data == expected\n\n    def test_normal_multi_sheet(self, tmpdir):\n        for writer_class in table_writer_class_list:\n            test_filepath = str(tmpdir.join(""test.xlsx""))\n            data_list = [\n                TableData(""first"", [""ha1"", ""hb1"", ""hc1""], [[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]]),\n                TableData(""second"", [""ha2"", ""hb2"", ""hc2""], [[11.0, 12.0, 13.0], [1.0, 2.0, 3.0]]),\n            ]\n\n            writer = writer_class()\n\n            for data in data_list:\n                writer.from_tabledata(data)\n                writer.dump(test_filepath, close_after_write=False)\n\n            writer.close()\n\n            for data, expected in zip(data_list, ExcelTableFileLoader(test_filepath).load()):\n                assert data == expected\n\n\n@pytest.mark.xfail(run=False)\nclass Test_ExcelTableWriter_dumps:\n    def test_exception(self, tmpdir):\n        for writer_class in table_writer_class_list:\n            test_filepath = tmpdir.join(""test.xlsx"")\n\n            writer = writer_class()\n            writer.open(str(test_filepath))\n\n            with pytest.raises(NotImplementedError):\n                writer.dumps()\n'"
test/writer/binary/test_sqlite_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nfrom collections import OrderedDict\nfrom decimal import Decimal\n\nimport pytest\nfrom pytablereader import SqliteFileLoader\nfrom sqliteschema import SQLiteSchemaExtractor\nfrom tabledata import TableData\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import headers, mix_header_list, mix_value_matrix, value_matrix, value_matrix_iter\n\n\ninf = Decimal(""Infinity"")\nnan = None\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table=""tablename"",\n        header=headers,\n        value=value_matrix,\n        expected=TableData(\n            ""tablename"",\n            [""a"", ""b"", ""c"", ""dd"", ""e""],\n            [[1, 123.1, ""a"", 1, 1], [2, 2.2, ""bb"", 2.2, 2.2], [3, 3.3, ""ccc"", 3, ""cccc""]],\n        ),\n    ),\n    Data(\n        table=""mix_data"",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=TableData(\n            ""mix_data"",\n            [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n            [\n                [1, ""1.1"", ""aa"", 1, 1, 1, inf, nan, 1, ""2017-01-01 00:00:00""],\n                [2, ""2.2"", ""bbb"", ""2.2"", ""2.2"", 0, inf, nan, inf, ""2017-01-02 03:04:05+09:00""],\n                [3, ""3.33"", ""cccc"", -3, ""ccc"", 1, inf, nan, nan, ""2017-01-01 00:00:00""],\n            ],\n        ),\n    ),\n    Data(\n        table=""infnan"",\n        header=[""inf"", ""nan""],\n        value=[[inf, float(""nan"")], [""inf"", ""nan""], [""INF"", ""NAN""], [""INFINITY"", ""inf""]],\n        expected=TableData(\n            ""infnan"", [""inf"", ""nan""], [[inf, nan], [inf, nan], [inf, nan], [inf, inf]]\n        ),\n    ),\n    Data(\n        table=""line breaks"",\n        header=[""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        expected=TableData(\n            ""line_breaks"", [""a_b"", ""_c__d_"", ""e__f""], [[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]]\n        ),\n    ),\n    Data(\n        table=""empty header"",\n        header=[],\n        value=value_matrix,\n        expected=TableData(\n            ""empty_header"",\n            [""A"", ""B"", ""C"", ""D"", ""E""],\n            [[1, 123.1, ""a"", 1, 1], [2, 2.2, ""bb"", 2.2, 2.2], [3, 3.3, ""ccc"", 3, ""cccc""]],\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(table="""", header=headers, value=value_matrix, expected=ptw.EmptyTableNameError),\n    Data(table=""dummy"", header=[], value=[], expected=ptw.EmptyTableDataError),\n    Data(table=""dummy"", header=headers, value=[], expected=ptw.EmptyValueError),\n]\n\n\n@pytest.mark.xfail(run=False)\nclass Test_SqliteTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, tmpdir, table, header, value, expected):\n        test_file_path = tmpdir.join(""test.sqlite"")\n\n        writer = ptw.SqliteTableWriter()\n        writer.open(str(test_file_path))\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n        writer.close()\n\n        for table_data in SqliteFileLoader(str(test_file_path)).load():\n            expected_dump = ptw.dumps_tabledata(expected)\n            actual_dump = ptw.dumps_tabledata(table_data)\n\n            print_test_result(expected=expected_dump, actual=actual_dump)\n\n            assert actual_dump == expected_dump\n\n    def test_normal_type_hints(self, tmpdir):\n        test_file_path = str(tmpdir.join(""test.sqlite""))\n\n        writer = ptw.SqliteTableWriter()\n        writer.open(test_file_path)\n        writer.table_name = ""hoge""\n        writer.headers = [""a"", ""b""]\n        writer.value_matrix = [[1, 2], [11, 12]]\n        writer.type_hints = [ptw.String]\n        writer.write_table()\n        writer.close()\n\n        schema = SQLiteSchemaExtractor(test_file_path).fetch_database_schema_as_dict()\n\n        assert schema[writer.table_name] == [\n            OrderedDict(\n                [\n                    (""Field"", ""a""),\n                    (""Index"", False),\n                    (""Type"", ""TEXT""),\n                    (""Null"", ""YES""),\n                    (""Key"", """"),\n                    (""Default"", ""NULL""),\n                    (""Extra"", """"),\n                ]\n            ),\n            OrderedDict(\n                [\n                    (""Field"", ""b""),\n                    (""Index"", False),\n                    (""Type"", ""INTEGER""),\n                    (""Null"", ""YES""),\n                    (""Key"", """"),\n                    (""Default"", ""NULL""),\n                    (""Extra"", """"),\n                ]\n            ),\n        ]\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, tmpdir, table, header, value, expected):\n        writer = ptw.SqliteTableWriter()\n        writer.open("":memory:"")\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\n@pytest.mark.xfail(run=False)\nclass Test_SqliteTableWriter_dump:\n    def test_normal_single_table(self, tmpdir):\n        test_filepath = str(tmpdir.join(""test.sqlite""))\n        data = TableData(\n            ""tablename"", [""ha"", ""hb"", ""hc""], [[1.0, 2.0, 3.0], [11.0, 12.0, 13.0], [1.0, 2.0, 3.0]]\n        )\n\n        writer = ptw.SqliteTableWriter()\n        writer.from_tabledata(data)\n        writer.dump(test_filepath)\n\n        for expected in SqliteFileLoader(test_filepath).load():\n            assert data == expected\n\n    def test_normal_multi_table(self, tmpdir):\n        test_filepath = str(tmpdir.join(""test.sqlite""))\n        data_list = [\n            TableData(""first"", [""ha1"", ""hb1"", ""hc1""], [[1.0, 2.0, 3.0], [11.0, 12.0, 13.0]]),\n            TableData(""second"", [""ha2"", ""hb2"", ""hc2""], [[11.0, 12.0, 13.0], [1.0, 2.0, 3.0]]),\n        ]\n\n        writer = ptw.SqliteTableWriter()\n\n        for data in data_list:\n            writer.from_tabledata(data)\n            writer.dump(test_filepath, close_after_write=False)\n\n        writer.close()\n\n        count = 0\n        for data, expected in zip(data_list, SqliteFileLoader(test_filepath).load()):\n            assert data == expected\n            count += 1\n\n        assert count == 2\n\n\n@pytest.mark.xfail(run=False)\nclass Test_SqliteTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                TableData(\n                    ""tablename"",\n                    [""ha"", ""hb"", ""hc""],\n                    [\n                        [1.0, 2.0, 3.0],\n                        [11.0, 12.0, 13.0],\n                        [1.0, 2.0, 3.0],\n                        [11.0, 12.0, 13.0],\n                        [101.0, 102.0, 103.0],\n                        [1001.0, 1002.0, 1003.0],\n                    ],\n                ),\n            ]\n        ],\n    )\n    def test_normal(self, tmpdir, table, header, value, expected):\n        test_file_path = tmpdir.join(""test.sqlite"")\n\n        writer = ptw.SqliteTableWriter()\n        writer.open(str(test_file_path))\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        writer.close()\n\n        for table_data in SqliteFileLoader(str(test_file_path)).load():\n            assert table_data == expected\n\n\n@pytest.mark.xfail(run=False)\nclass Test_SqliteTableWriter_dumps:\n    def test_exception(self, tmpdir):\n        writer = ptw.SqliteTableWriter()\n        writer.open("":memory:"")\n\n        with pytest.raises(NotImplementedError):\n            writer.dumps()\n'"
test/writer/text/__init__.py,0,b''
test/writer/text/_common.py,0,"b'import re\n\n\nregexp_ansi_escape = re.compile(\n    r""(?:\\x1B[@-Z\\\\-_]|[\\x80-\\x9A\\x9C-\\x9F]|(?:\\x1B\\[|\\x9B)[0-?]*[ -/]*[@-~])""\n)\n'"
test/writer/text/test_borderless_writer.py,0,"b'from textwrap import dedent\n\nimport pytest\n\nfrom pytablewriter import BorderlessTableWriter\n\nfrom ..._common import print_test_result\nfrom ...data import vut_style_tabledata, vut_styles\nfrom ._common import regexp_ansi_escape\n\n\nclass Test_BorderlessTableWriter_write_new_line:\n    @pytest.mark.parametrize([""table_writer_class""], [[BorderlessTableWriter]])\n    def test_normal(self, capsys, table_writer_class):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_BorderlessTableWriter_write_table:\n    def test_normal_styles(self, capsys):\n        writer = BorderlessTableWriter()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            noneemptytinysmallmediumlargenull w/ boldL boldS italicL bold italic\n             111  111 111  111   111  111               111     111          111\n            1234 12341234 1234 1,2341 234              1234    1234         1234\n            """"""\n        )\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n'"
test/writer/text/test_css.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\nfrom pytablewriter.style import Style\n\nfrom ..._common import print_test_result\nfrom ...data import null_test_data_list, vut_style_tabledata, vut_styles\n\n\ntable_writer_class = pytablewriter.CssTableWriter\n\n\nclass Test_CssTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_CssTableWriter_write_table:\n    def test_normal_styles(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n.style-test thead th:nth-child(1) {\n    text-align: left;\n}\n.style-test thead th:nth-child(2) {\n    text-align: left;\n}\n.style-test thead th:nth-child(3) {\n    text-align: left;\n}\n.style-test thead th:nth-child(4) {\n    text-align: left;\n}\n.style-test thead th:nth-child(5) {\n    text-align: left;\n}\n.style-test thead th:nth-child(6) {\n    text-align: left;\n}\n.style-test thead th:nth-child(7) {\n    font-weight:bold;\n    text-align: left;\n}\n.style-test thead th:nth-child(8) {\n    font-weight:bold;\n    text-align: left;\n}\n.style-test thead th:nth-child(9) {\n    font-style:italic;\n    text-align: left;\n}\n.style-test thead th:nth-child(10) {\n    font-weight:bold;\n    font-style:italic;\n    text-align: left;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(1) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(2) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(3) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(4) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(5) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(6) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(7) {\n    font-weight:bold;\n    text-align: left;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(8) {\n    font-weight:bold;\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(9) {\n    font-style:italic;\n    text-align: right;\n}\n.style-test tbody tr:nth-child(1) td:nth-child(10) {\n    font-weight:bold;\n    font-style:italic;\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(1) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(2) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(3) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(4) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(5) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(6) {\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(7) {\n    font-weight:bold;\n    text-align: left;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(8) {\n    font-weight:bold;\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(9) {\n    font-style:italic;\n    text-align: right;\n}\n.style-test tbody tr:nth-child(2) td:nth-child(10) {\n    font-weight:bold;\n    font-style:italic;\n    text-align: right;\n}\n""""""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_valign(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""vertical-align""\n        writer.headers = [\n            """",\n            ""top"",\n            ""middle"",\n            ""bottom"",\n            ""top-right"",\n            ""middle-right"",\n            ""bottom-right"",\n        ]\n        writer.value_matrix = [\n            [""te\\nst"", ""x"", ""x"", ""x"", ""x"", ""x"", ""x""],\n        ]\n        writer.column_styles = [\n            Style(vertical_align=""baseline""),\n            Style(vertical_align=""top""),\n            Style(vertical_align=""middle""),\n            Style(vertical_align=""bottom""),\n            Style(align=""right"", vertical_align=""top""),\n            Style(align=""right"", vertical_align=""middle""),\n            Style(align=""right"", vertical_align=""bottom""),\n        ]\n\n        writer.write_table()\n\n        expected = """"""\\\n.vertical-align thead th:nth-child(1) {\n    text-align: left;\n}\n.vertical-align thead th:nth-child(2) {\n    text-align: left;\n    vertical-align: top;\n}\n.vertical-align thead th:nth-child(3) {\n    text-align: left;\n    vertical-align: middle;\n}\n.vertical-align thead th:nth-child(4) {\n    text-align: left;\n    vertical-align: bottom;\n}\n.vertical-align thead th:nth-child(5) {\n    text-align: right;\n    vertical-align: top;\n}\n.vertical-align thead th:nth-child(6) {\n    text-align: right;\n    vertical-align: middle;\n}\n.vertical-align thead th:nth-child(7) {\n    text-align: right;\n    vertical-align: bottom;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(1) {\n    text-align: left;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(2) {\n    text-align: left;\n    vertical-align: top;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(3) {\n    text-align: left;\n    vertical-align: middle;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(4) {\n    text-align: left;\n    vertical-align: bottom;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(5) {\n    text-align: right;\n    vertical-align: top;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(6) {\n    text-align: right;\n    vertical-align: middle;\n}\n.vertical-align tbody tr:nth-child(1) td:nth-child(7) {\n    text-align: right;\n    vertical-align: bottom;\n}\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_write_style_tag(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""none value""\n        writer.headers = [""none""]\n        writer.value_matrix = [[None]]\n        writer.write_table(write_style_tag=True)\n        expected = """"""\\\n<style type=""text/css"">\n    .none-value thead th:nth-child(1) {\n        text-align: left;\n    }\n    .none-value tbody tr:nth-child(1) td:nth-child(1) {\n        text-align: left;\n    }\n</style>\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_flavor(self):\n        writer = table_writer_class()\n        writer.table_name = ""decoration line""\n        writer.column_styles = [\n            Style(decoration_line=""underline""),\n            Style(decoration_line=""strike""),\n            Style(decoration_line=""line-through""),\n        ]\n        writer.headers = [""w/o style"", ""w/ strike"", ""w/ line through""]\n        writer.value_matrix = [[""u"", ""s"", ""lt""]]\n\n        expected = """"""\\\n.decoration-line thead th:nth-child(1) {\n    text-align: left;\n    text-decoration-line: underline;\n}\n.decoration-line thead th:nth-child(2) {\n    text-align: left;\n    text-decoration-line: line-through;\n}\n.decoration-line thead th:nth-child(3) {\n    text-align: left;\n    text-decoration-line: line-through;\n}\n.decoration-line tbody tr:nth-child(1) td:nth-child(1) {\n    text-align: left;\n    text-decoration-line: underline;\n}\n.decoration-line tbody tr:nth-child(1) td:nth-child(2) {\n    text-align: left;\n    text-decoration-line: line-through;\n}\n.decoration-line tbody tr:nth-child(1) td:nth-child(3) {\n    text-align: left;\n    text-decoration-line: line-through;\n}\n""""""\n\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n\n        assert output == expected\n\n    def test_normal_dumps(self):\n        writer = table_writer_class()\n        writer.table_name = ""none value""\n        writer.headers = [""none""]\n        writer.value_matrix = [[None]]\n        expected = """"""\\\n<style type=""text/css"">\n    .none-value thead th:nth-child(1) {\n        text-align: left;\n    }\n    .none-value tbody tr:nth-child(1) td:nth-child(1) {\n        text-align: left;\n    }\n</style>\n""""""\n        out = writer.dumps(write_style_tag=True)\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.indent_string = indent\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_CssTableWriter_write_table_iter:\n    def test_exception(self):\n        writer = table_writer_class()\n\n        with pytest.raises(pytablewriter.NotSupportedError):\n            writer.write_table_iter()\n'"
test/writer/text/test_csv_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\nData = collections.namedtuple(""Data"", ""col_delim header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        col_delim="","",\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            ""a"",""b"",""c"",""dd"",""e""\n            1,123.1,""a"",1,1\n            2,2.2,""bb"",2.2,2.2\n            3,3.3,""ccc"",3,""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=headers,\n        value=[],\n        expected=dedent(\n            """"""\\\n            ""a"",""b"",""c"",""dd"",""e""\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=[],\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            1,123.1,""a"",1,1\n            2,2.2,""bb"",2.2,2.2\n            3,3.3,""ccc"",3,""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        col_delim=""\\t"",\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            1\\t123.1\\t""a""\\t1\\t1\n            2\\t2.2\\t""bb""\\t2.2\\t2.2\n            3\\t3.3\\t""ccc""\\t3\\t""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            ""a"",""b"",""c"",""dd"",""e""\n            1,,""a"",1,\n            ,2.2,,2.2,2.2\n            3,3.3,""ccc"",,""cccc""\n            ,,,,\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            ""i"",""f"",""c"",""if"",""ifc"",""bool"",""inf"",""nan"",""mix_num"",""time""\n            1,1.1,""aa"",1,1,True,Infinity,NaN,1,""2017-01-01T00:00:00""\n            2,2.2,""bbb"",2.2,2.2,False,Infinity,NaN,Infinity,""2017-01-02 03:04:05+09:00""\n            3,3.33,""cccc"",-3,""ccc"",True,Infinity,NaN,NaN,""2017-01-01T00:00:00""\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=dedent(\n            """"""\\\n            ""a"",""b"",""c""\n            0.01,0.00125,0\n            1,99.9,0.01\n            1.2,999999.123,0.001\n            """"""\n        ),\n    ),\n    Data(\n        col_delim="","",\n        header=[""a\\nb"", ""c\\n\\nd"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        expected=dedent(\n            """"""\\\n            ""a b"",""c  d"",""e f""\n            ""v1 v1"",""v2  v2"",""v3 v3""\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(col_delim="","", header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.CsvTableWriter\n\n\nclass Test_CsvTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_CsvTableWriter_from_csv:\n\n    __CSV_TEXT_INPUT = dedent(\n        """"""\\\n        ""a"",""b"",""c"",""dd"",""e""\n        1,1.1,""a"",1.0,\n        2,2.2,,2.2,""2.2""\n        3,3.3,""ccc"",,""cc\\ncc""\n        """"""\n    )\n\n    __CSV_EXPECTED = dedent(\n        """"""\\\n        ""a"",""b"",""c"",""dd"",""e""\n        1,1.1,""a"",1,\n        2,2.2,,2.2,2.2\n        3,3.3,""ccc"",,""cc cc""\n        """"""\n    )\n\n    def test_normal_from_text(self, capsys):\n        writer = table_writer_class()\n        writer.from_csv(self.__CSV_TEXT_INPUT)\n        writer.write_table()\n\n        out, _err = capsys.readouterr()\n\n        assert writer.table_name == """"\n        assert writer.headers == [""a"", ""b"", ""c"", ""dd"", ""e""]\n\n        print_test_result(expected=self.__CSV_EXPECTED, actual=out)\n\n        assert out == self.__CSV_EXPECTED\n\n    def test_normal_from_file(self, capsys, tmpdir):\n        file_path = str(tmpdir.join(""test_data.csv""))\n        with open(file_path, ""w"", encoding=""utf-8"") as f:\n            f.write(self.__CSV_TEXT_INPUT)\n\n        writer = table_writer_class()\n        writer.from_csv(file_path)\n        writer.write_table()\n\n        out, _err = capsys.readouterr()\n\n        assert writer.table_name == ""test_data""\n        assert writer.headers == [""a"", ""b"", ""c"", ""dd"", ""e""]\n\n        print_test_result(expected=self.__CSV_EXPECTED, actual=out)\n\n        assert out == self.__CSV_EXPECTED\n\n\nclass Test_CsvTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""col_delim"", ""header"", ""value"", ""expected""],\n        [\n            [data.col_delim, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, col_delim, header, value, expected):\n        writer = table_writer_class()\n        writer.column_delimiter = col_delim\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_escape_formula_injection(self, capsys):\n        writer = table_writer_class()\n        writer.headers = [""a"", ""b"", ""c"", ""d"", ""e""]\n        writer.value_matrix = [[""a+b"", ""=a+b"", ""-a+b"", ""+a+b"", ""@a+b""]]\n        writer.update_preprocessor(is_escape_formula_injection=True)\n        writer.write_table()\n        expected = r""""""""a"",""b"",""c"",""d"",""e""\n""a+b"",""\\""=a+b"",""\\""-a+b"",""\\""+a+b"",""\\""@a+b""\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_CsvTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                dedent(\n                    """"""\\\n                ""ha"",""hb"",""hc""\n                1,2,3\n                11,12,13\n                1,2,3\n                11,12,13\n                101,102,103\n                1001,1002,1003\n                """"""\n                ),\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_html_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\nfrom pytablewriter.style import Style\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_with_none,\n    vut_style_tabledata,\n    vut_styles,\n)\n\n\nnormal_test_data_list = [\n    Data(\n        table="""",\n        indent=""  "",\n        header=headers,\n        value=value_matrix,\n        expected=""""""<table>\n  <thead>\n    <tr>\n      <th>a</th>\n      <th>b</th>\n      <th>c</th>\n      <th>dd</th>\n      <th>e</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=""right"">1</td>\n      <td align=""right"">123.1</td>\n      <td align=""left"">a</td>\n      <td align=""right"">1.0</td>\n      <td align=""right"">1</td>\n    </tr>\n    <tr>\n      <td align=""right"">2</td>\n      <td align=""right"">2.2</td>\n      <td align=""left"">bb</td>\n      <td align=""right"">2.2</td>\n      <td align=""right"">2.2</td>\n    </tr>\n    <tr>\n      <td align=""right"">3</td>\n      <td align=""right"">3.3</td>\n      <td align=""left"">ccc</td>\n      <td align=""right"">3.0</td>\n      <td align=""left"">cccc</td>\n    </tr>\n  </tbody>\n</table>\n"""""",\n    ),\n    Data(\n        table=None,\n        indent=""  "",\n        header=None,\n        value=value_matrix,\n        expected=""""""<table>\n  <tbody>\n    <tr>\n      <td align=""right"">1</td>\n      <td align=""right"">123.1</td>\n      <td align=""left"">a</td>\n      <td align=""right"">1.0</td>\n      <td align=""right"">1</td>\n    </tr>\n    <tr>\n      <td align=""right"">2</td>\n      <td align=""right"">2.2</td>\n      <td align=""left"">bb</td>\n      <td align=""right"">2.2</td>\n      <td align=""right"">2.2</td>\n    </tr>\n    <tr>\n      <td align=""right"">3</td>\n      <td align=""right"">3.3</td>\n      <td align=""left"">ccc</td>\n      <td align=""right"">3.0</td>\n      <td align=""left"">cccc</td>\n    </tr>\n  </tbody>\n</table>\n"""""",\n    ),\n    Data(\n        table=""tablename"",\n        indent=""    "",\n        header=headers,\n        value=[],\n        expected=""""""<table id=""tablename"">\n    <caption>tablename</caption>\n    <thead>\n        <tr>\n            <th>a</th>\n            <th>b</th>\n            <th>c</th>\n            <th>dd</th>\n            <th>e</th>\n        </tr>\n    </thead>\n    <tbody></tbody>\n</table>\n"""""",\n    ),\n    Data(\n        table=None,\n        indent=""    "",\n        header=headers,\n        value=None,\n        expected=""""""<table>\n    <thead>\n        <tr>\n            <th>a</th>\n            <th>b</th>\n            <th>c</th>\n            <th>dd</th>\n            <th>e</th>\n        </tr>\n    </thead>\n    <tbody></tbody>\n</table>\n"""""",\n    ),\n    Data(\n        table="""",\n        indent=""  "",\n        header=headers,\n        value=value_matrix_with_none,\n        expected=""""""<table>\n  <thead>\n    <tr>\n      <th>a</th>\n      <th>b</th>\n      <th>c</th>\n      <th>dd</th>\n      <th>e</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td align=""right"">1</td>\n      <td align=""right""></td>\n      <td align=""left"">a</td>\n      <td align=""right"">1.0</td>\n      <td align=""left""></td>\n    </tr>\n    <tr>\n      <td align=""right""></td>\n      <td align=""right"">2.2</td>\n      <td align=""left""></td>\n      <td align=""right"">2.2</td>\n      <td align=""right"">2.2</td>\n    </tr>\n    <tr>\n      <td align=""right"">3</td>\n      <td align=""right"">3.3</td>\n      <td align=""left"">ccc</td>\n      <td align=""right""></td>\n      <td align=""left"">cccc</td>\n    </tr>\n    <tr>\n      <td align=""right""></td>\n      <td align=""right""></td>\n      <td align=""left""></td>\n      <td align=""right""></td>\n      <td align=""left""></td>\n    </tr>\n  </tbody>\n</table>\n"""""",\n    ),\n    Data(\n        table=""tablename"",\n        indent=""    "",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=""""""<table id=""tablename"">\n    <caption>tablename</caption>\n    <thead>\n        <tr>\n            <th>i</th>\n            <th>f</th>\n            <th>c</th>\n            <th>if</th>\n            <th>ifc</th>\n            <th>bool</th>\n            <th>inf</th>\n            <th>nan</th>\n            <th>mix_num</th>\n            <th>time</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td align=""right"">1</td>\n            <td align=""right"">1.10</td>\n            <td align=""left"">aa</td>\n            <td align=""right"">1.0</td>\n            <td align=""right"">1</td>\n            <td align=""left"">True</td>\n            <td align=""left"">Infinity</td>\n            <td align=""left"">NaN</td>\n            <td align=""right"">1</td>\n            <td align=""left"">2017-01-01T00:00:00</td>\n        </tr>\n        <tr>\n            <td align=""right"">2</td>\n            <td align=""right"">2.20</td>\n            <td align=""left"">bbb</td>\n            <td align=""right"">2.2</td>\n            <td align=""right"">2.2</td>\n            <td align=""left"">False</td>\n            <td align=""left"">Infinity</td>\n            <td align=""left"">NaN</td>\n            <td align=""right"">Infinity</td>\n            <td align=""left"">2017-01-02 03:04:05+09:00</td>\n        </tr>\n        <tr>\n            <td align=""right"">3</td>\n            <td align=""right"">3.33</td>\n            <td align=""left"">cccc</td>\n            <td align=""right"">-3.0</td>\n            <td align=""left"">ccc</td>\n            <td align=""left"">True</td>\n            <td align=""left"">Infinity</td>\n            <td align=""left"">NaN</td>\n            <td align=""right"">NaN</td>\n            <td align=""left"">2017-01-01T00:00:00</td>\n        </tr>\n    </tbody>\n</table>\n"""""",\n    ),\n]\n\ntable_writer_class = pytablewriter.HtmlTableWriter\n\n\nclass Test_HtmlTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_HtmlTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.indent_string = indent\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_styles(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            <table id=""styletest"">\n                <caption>style test</caption>\n                <thead>\n                    <tr>\n                        <th>none</th>\n                        <th>empty</th>\n                        <th>tiny</th>\n                        <th>small</th>\n                        <th>medium</th>\n                        <th>large</th>\n                        <th>null w/ bold</th>\n                        <th>L bold</th>\n                        <th>S italic</th>\n                        <th>L bold italic</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr>\n                        <td align=""right"">111</td>\n                        <td align=""right"">111</td>\n                        <td align=""right"" style=""font-size:x-small"">111</td>\n                        <td align=""right"" style=""font-size:small"">111</td>\n                        <td align=""right"" style=""font-size:medium"">111</td>\n                        <td align=""right"" style=""font-size:large"">111</td>\n                        <td align=""left"" style=""font-weight:bold""></td>\n                        <td align=""right"" style=""font-size:large; font-weight:bold"">111</td>\n                        <td align=""right"" style=""font-size:small; font-style:italic"">111</td>\n                        <td align=""right"" style=""font-size:large; font-weight:bold; font-style:italic"">111</td>\n                    </tr>\n                    <tr>\n                        <td align=""right"">1234</td>\n                        <td align=""right"">1234</td>\n                        <td align=""right"" style=""font-size:x-small"">1234</td>\n                        <td align=""right"" style=""font-size:small"">1234</td>\n                        <td align=""right"" style=""font-size:medium"">1,234</td>\n                        <td align=""right"" style=""font-size:large"">1 234</td>\n                        <td align=""left"" style=""font-weight:bold""></td>\n                        <td align=""right"" style=""font-size:large; font-weight:bold"">1234</td>\n                        <td align=""right"" style=""font-size:small; font-style:italic"">1234</td>\n                        <td align=""right"" style=""font-size:large; font-weight:bold; font-style:italic"">1234</td>\n                    </tr>\n                </tbody>\n            </table>\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n        out = writer._repr_html_()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n    def test_normal_valign(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""vertical-align""\n        writer.headers = [\n            """",\n            ""top"",\n            ""middle"",\n            ""bottom"",\n            ""top-right"",\n            ""middle-right"",\n            ""bottom-right"",\n        ]\n        writer.value_matrix = [\n            [""te\\nst"", ""x"", ""x"", ""x"", ""x"", ""x"", ""x""],\n        ]\n        writer.column_styles = [\n            Style(vertical_align=""baseline""),\n            Style(vertical_align=""top""),\n            Style(vertical_align=""middle""),\n            Style(vertical_align=""bottom""),\n            Style(align=""right"", vertical_align=""top""),\n            Style(align=""right"", vertical_align=""middle""),\n            Style(align=""right"", vertical_align=""bottom""),\n        ]\n\n        writer.write_table()\n\n        expected = """"""\\\n<table id=""verticalalign"">\n    <caption>vertical-align</caption>\n    <thead>\n        <tr>\n            <th></th>\n            <th>top</th>\n            <th>middle</th>\n            <th>bottom</th>\n            <th>top-right</th>\n            <th>middle-right</th>\n            <th>bottom-right</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td align=""left"">te<br>st</td>\n            <td align=""left"" valign=""top"">x</td>\n            <td align=""left"" valign=""middle"">x</td>\n            <td align=""left"" valign=""bottom"">x</td>\n            <td align=""right"" valign=""top"">x</td>\n            <td align=""right"" valign=""middle"">x</td>\n            <td align=""right"" valign=""bottom"">x</td>\n        </tr>\n    </tbody>\n</table>\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_line_breaks(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""line breaks""\n        writer.headers = [""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""]\n        writer.value_matrix = [[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]]\n        writer.write_table()\n\n        expected = """"""\\\n<table id=""linebreaks"">\n    <caption>line breaks</caption>\n    <thead>\n        <tr>\n            <th>a<br>b</th>\n            <th><br>c<br><br>d<br></th>\n            <th>e<br>f</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td align=""left"">v1<br>v1</td>\n            <td align=""left"">v2<br><br>v2</td>\n            <td align=""left"">v3<br>v3</td>\n        </tr>\n    </tbody>\n</table>\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_none_values(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""none value""\n        writer.headers = [""none""]\n        writer.value_matrix = [[None]]\n        writer.write_table()\n\n        expected = """"""\\\n<table id=""nonevalue"">\n    <caption>none value</caption>\n    <thead>\n        <tr>\n            <th>none</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td align=""left""></td>\n        </tr>\n    </tbody>\n</table>\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    def test_normal_write_css(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""write_css""\n        writer.headers = [""int""]\n        writer.value_matrix = [[1]]\n        writer.write_table(write_css=True)\n\n        expected = """"""\\\n<style type=""text/css"">\n    .write-css thead th:nth-child(1) {\n        text-align: left;\n    }\n    .write-css tbody tr:nth-child(1) td:nth-child(1) {\n        text-align: right;\n    }\n</style>\n<table class=""write-css"" id=""write_css"">\n    <caption>write_css</caption>\n    <thead>\n        <tr>\n            <th>int</th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>1</td>\n        </tr>\n    </tbody>\n</table>\n""""""\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.indent_string = indent\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_HtmlTableWriter_write_table_iter:\n    def test_exception(self):\n        writer = table_writer_class()\n\n        with pytest.raises(pytablewriter.NotSupportedError):\n            writer.write_table_iter()\n'"
test/writer/text/test_javascript_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport datetime\nimport itertools\nfrom textwrap import dedent\n\nimport pytest\nimport typepy\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\nData = collections.namedtuple(\n    ""Data"", ""table indent header value is_write_header is_dti_fmt expected""\n)\n\nnormal_test_data_list = [\n    Data(\n        table=""table-name ho\'ge"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const table_name_ho_ge = [\n                [""a"", ""b"", ""c"", ""dd"", ""e""],\n                [1, 123.1, ""a"", 1, 1],\n                [2, 2.2, ""bb"", 2.2, 2.2],\n                [3, 3.3, ""ccc"", 3, ""cccc""]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""null value"",\n        indent=0,\n        header=headers,\n        value=None,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const null_value = [\n                [""a"", ""b"", ""c"", ""dd"", ""e""]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""null table"",\n        indent=0,\n        header=headers,\n        value=None,\n        is_write_header=False,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const null_table = [\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=None,\n        value=value_matrix,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const table_name = [\n                [1, 123.1, ""a"", 1, 1],\n                [2, 2.2, ""bb"", 2.2, 2.2],\n                [3, 3.3, ""ccc"", 3, ""cccc""]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=""""""\\\n    const tablename = [\n        [""a"", ""b"", ""c"", ""dd"", ""e""],\n        [1, 123.1, ""a"", 1, 1],\n        [2, 2.2, ""bb"", 2.2, 2.2],\n        [3, 3.3, ""ccc"", 3, ""cccc""]\n    ];\n"""""",\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const tablename = [\n                [""a"", ""b"", ""c"", ""dd"", ""e""],\n                [1, null, ""a"", 1, null],\n                [null, 2.2, null, 2.2, 2.2],\n                [3, 3.3, ""ccc"", null, ""cccc""],\n                [null, null, null, null, null]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=dedent(\n            """"""\\\n            const tablename = [\n                [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n                [1, 1.1, ""aa"", 1, 1, true, Infinity, NaN, 1, new Date(""2017-01-01T00:00:00"")],\n                [2, 2.2, ""bbb"", 2.2, 2.2, false, Infinity, NaN, Infinity, ""2017-01-02 03:04:05+09:00""],\n                [3, 3.33, ""cccc"", -3, ""ccc"", true, Infinity, NaN, NaN, new Date(""2017-01-01T00:00:00"")]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        is_write_header=True,\n        is_dti_fmt=False,\n        expected=dedent(\n            """"""\\\n            const tablename = [\n                [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n                [1, 1.1, ""aa"", 1, 1, true, Infinity, NaN, 1, ""2017-01-01T00:00:00""],\n                [2, 2.2, ""bbb"", 2.2, 2.2, false, Infinity, NaN, Infinity, ""2017-01-02 03:04:05+09:00""],\n                [3, 3.33, ""cccc"", -3, ""ccc"", true, Infinity, NaN, NaN, ""2017-01-01T00:00:00""]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""float-with-null"",\n        indent=0,\n        header=[""a"", ""b""],\n        value=[\n            [""0.03785679191278808"", ""826.21158713263""],\n            [None, ""826.21158713263""],\n            [0.1, ""1.0499675627886724""],\n        ],\n        is_write_header=True,\n        is_dti_fmt=False,\n        expected=dedent(\n            """"""\\\n            const float_with_null = [\n                [""a"", ""b""],\n                [0.03785679191278808, 826.21158713263],\n                [null, 826.21158713263],\n                [0.1, 1.0499675627886724]\n            ];\n            """"""\n        ),\n    ),\n    Data(\n        table=""line breaks"",\n        indent=0,\n        header=[""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        is_write_header=True,\n        is_dti_fmt=False,\n        expected=dedent(\n            """"""\\\n            const line_breaks = [\n                [""a b"", "" c  d "", ""e f""],\n                [""v1 v1"", ""v2  v2"", ""v3 v3""]\n            ];\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(\n        table="""",\n        indent=normal_test_data_list[0].indent,\n        header=normal_test_data_list[0].header,\n        value=normal_test_data_list[0].value,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=pytablewriter.EmptyTableNameError,\n    )\n] + [\n    Data(\n        table=""dummy"",\n        indent=0,\n        header=header,\n        value=value,\n        is_write_header=True,\n        is_dti_fmt=True,\n        expected=pytablewriter.EmptyTableDataError,\n    )\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = pytablewriter.JavaScriptTableWriter\n\n\nclass Test_JavaScriptTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_JavaScriptTableWriter_type_hint:\n    DATATIME_DATA = datetime.datetime(2017, 1, 2, 3, 4, 5)\n    STR_DATA = ""2017-01-02 03:04:05""\n    DATA_MATRIX = [[STR_DATA, DATATIME_DATA], [STR_DATA, DATATIME_DATA]]\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""type_hint"", ""expected""],\n        [\n            [\n                ""th_none_none"",\n                [""string"", ""datetime""],\n                DATA_MATRIX,\n                [None, None],\n                dedent(\n                    """"""\\\n                    const th_none_none = [\n                        [""string"", ""datetime""],\n                        [""2017-01-02 03:04:05"", new Date(""2017-01-02T03:04:05"")],\n                        [""2017-01-02 03:04:05"", new Date(""2017-01-02T03:04:05"")]\n                    ];\n                    """"""\n                ),\n            ],\n            [\n                ""typehint_datetime-string"",\n                [""string"", ""datetime""],\n                DATA_MATRIX,\n                [typepy.DateTime, typepy.String],\n                dedent(\n                    """"""\\\n                    const typehint_datetime_string = [\n                        [""string"", ""datetime""],\n                        [new Date(""2017-01-02T03:04:05""), ""2017-01-02 03:04:05""],\n                        [new Date(""2017-01-02T03:04:05""), ""2017-01-02 03:04:05""]\n                    ];\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, type_hint, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.type_hints = type_hint\n\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n\nclass Test_JavaScriptTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""is_write_header"", ""is_dti_fmt"", ""expected""],\n        [\n            [\n                data.table,\n                data.indent,\n                data.header,\n                data.value,\n                data.is_write_header,\n                data.is_dti_fmt,\n                data.expected,\n            ]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal_single(\n        self, capsys, table, indent, header, value, is_write_header, is_dti_fmt, expected\n    ):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.is_write_header = is_write_header\n        writer.is_datetime_instance_formatting = is_dti_fmt\n\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_variable_declaration(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""$change variable declaration""\n        writer.variable_declaration = ""var""\n        writer.value_matrix = value_matrix\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            var $change_variable_declaration = [\n                [1, 123.1, ""a"", 1, 1],\n                [2, 2.2, ""bb"", 2.2, 2.2],\n                [3, 3.3, ""ccc"", 3, ""cccc""]\n            ];\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_escape_quotes_1(self, capsys):\n        writer = table_writer_class()\n\n        expected = r""""""const escape_quotes_1 = [\n    [8, ""data = [""],\n    [9, ""    [0,   0.1,      \\""hoge\\"", True,   0,      \\""2017-01-01 03:04:05+0900\\""],""],\n    [10, ""    [2,   \\""-2.23\\"",  \\""foo\\"",  False,  None,   \\""2017-12-23 12:34:51+0900\\""],""],\n    [11, ""    [3,   0,        \\""bar\\"",  \\""true\\"",  \\""inf\\"", \\""2017-03-03 22:44:55+0900\\""],""],\n    [12, ""    [-10, -9.9,     \\""\\"",     \\""FALSE\\"", \\""nan\\"", \\""2017-01-01 00:00:00+0900\\""],""],\n    [13, ""]""]\n];\n""""""\n        writer.table_name = ""escape quotes 1""\n        writer.value_matrix = [\n            [8, ""data = [""],\n            [9, \'    [0,   0.1,      ""hoge"", True,   0,      ""2017-01-01 03:04:05+0900""],\'],\n            [10, \'    [2,   ""-2.23"",  ""foo"",  False,  None,   ""2017-12-23 12:34:51+0900""],\'],\n            [11, \'    [3,   0,        ""bar"",  ""true"",  ""inf"", ""2017-03-03 22:44:55+0900""],\'],\n            [12, \'    [-10, -9.9,     """",     ""FALSE"", ""nan"", ""2017-01-01 00:00:00+0900""],\'],\n            [13, ""]""],\n        ]\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_escape_quotes_2(self, capsys):\n        writer = table_writer_class()\n\n        expected = r""""""const escape_quotes_2 = [\n    [2, ""writer.from_csv(""],\n    [3, ""    dedent(\\""\\""\\""\\\\""],\n    [4, ""        USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND""],\n    [5, ""        root         1  0.0  0.4  77664  8784 ?        Ss   May11   0:02 /sbin/init""],\n    [6, ""        root         2  0.0  0.0      0     0 ?        S    May11   0:00 [kthreadd]""],\n    [7, ""        root         4  0.0  0.0      0     0 ?        I<   May11   0:00 [kworker/0:0H]""],\n    [8, ""        root         6  0.0  0.0      0     0 ?        I<   May11   0:00 [mm_percpu_wq]""],\n    [9, ""        root         7  0.0  0.0      0     0 ?        S    May11   0:01 [ksoftirqd/0]""],\n    [10, ""    \\""\\""\\""),""],\n    [11, ""    delimiter=\\"" \\"")""]\n];\n""""""\n        writer.table_name = ""escape quotes 2""\n        writer.value_matrix = [\n            [2, ""writer.from_csv(""],\n            [3, \'    dedent(""""""\\\\\'],\n            [4, ""        USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND""],\n            [\n                5,\n                ""        root         1  0.0  0.4  77664  8784 ?        Ss   May11   0:02 /sbin/init"",\n            ],\n            [\n                6,\n                ""        root         2  0.0  0.0      0     0 ?        S    May11   0:00 [kthreadd]"",\n            ],\n            [\n                7,\n                ""        root         4  0.0  0.0      0     0 ?        I<   May11   0:00 [kworker/0:0H]"",\n            ],\n            [\n                8,\n                ""        root         6  0.0  0.0      0     0 ?        I<   May11   0:00 [mm_percpu_wq]"",\n            ],\n            [\n                9,\n                ""        root         7  0.0  0.0      0     0 ?        S    May11   0:01 [ksoftirqd/0]"",\n            ],\n            [10, \'    """"""),\'],\n            [11, \'    delimiter="" "")\'],\n        ]\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""is_write_header"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.is_write_header, data.expected]\n            for data in exception_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, is_write_header, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.is_write_header = is_write_header\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_JavaScriptTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""iter_len"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                len(value_matrix_iter),\n                dedent(\n                    """"""\\\n                    const tablename = [\n                        [""ha"", ""hb"", ""hc""],\n                        [1, 2, 3],\n                        [11, 12, 13],\n                        [1, 2, 3],\n                        [11, 12, 13],\n                        [101, 102, 103],\n                        [1001, 1002, 1003]\n                    ];\n                    """"""\n                ),\n            ],\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                len(value_matrix_iter) - 1,\n                dedent(\n                    """"""\\\n                    const tablename = [\n                        [""ha"", ""hb"", ""hc""],\n                        [1, 2, 3],\n                        [11, 12, 13],\n                        [1, 2, 3],\n                        [11, 12, 13]\n                    ];\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, iter_len, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = iter_len\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_json_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport json\nimport platform as m_platform\nimport sys\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table="""",\n        header=headers,\n        value=value_matrix,\n        expected=json.loads(\n            """"""[\n            {\n                ""a"": 1,\n                ""b"": 123.1,\n                ""c"": ""a"",\n                ""dd"": 1,\n                ""e"": 1\n            },\n            {\n                ""a"": 2,\n                ""b"": 2.2,\n                ""c"": ""bb"",\n                ""dd"": 2.2,\n                ""e"": 2.2\n            },\n            {\n                ""a"": 3,\n                ""b"": 3.3,\n                ""c"": ""ccc"",\n                ""dd"": 3,\n                ""e"": ""cccc""\n            }\n        ]\n        """"""\n        ),\n    ),\n    Data(table="""", header=headers, value=None, expected=json.loads(""[]"")),\n    Data(\n        table=""tablename"",\n        header=headers,\n        value=value_matrix,\n        expected=json.loads(\n            """"""{\n            ""tablename"": [\n                {\n                    ""a"": 1,\n                    ""b"": 123.1,\n                    ""c"": ""a"",\n                    ""dd"": 1,\n                    ""e"": 1\n                },\n                {\n                    ""a"": 2,\n                    ""b"": 2.2,\n                    ""c"": ""bb"",\n                    ""dd"": 2.2,\n                    ""e"": 2.2\n                },\n                {\n                    ""a"": 3,\n                    ""b"": 3.3,\n                    ""c"": ""ccc"",\n                    ""dd"": 3,\n                    ""e"": ""cccc""\n                }\n            ]\n        }\n        """"""\n        ),\n    ),\n    Data(\n        table=""with none values"",\n        header=headers,\n        value=value_matrix_with_none,\n        expected=json.loads(\n            """"""{\n            ""with none values"": [\n                {\n                    ""a"": 1,\n                    ""b"": null,\n                    ""c"": ""a"",\n                    ""dd"": 1,\n                    ""e"": null\n                },\n                {\n                    ""a"": null,\n                    ""b"": 2.2,\n                    ""c"": null,\n                    ""dd"": 2.2,\n                    ""e"": 2.2\n                },\n                {\n                    ""a"": 3,\n                    ""b"": 3.3,\n                    ""c"": ""ccc"",\n                    ""dd"": null,\n                    ""e"": ""cccc""\n                },\n                {\n                    ""a"": null,\n                    ""b"": null,\n                    ""c"": null,\n                    ""dd"": null,\n                    ""e"": null\n                }\n            ]\n        }\n        """"""\n        ),\n    ),\n    Data(\n        table=""mixed values"",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=json.loads(\n            """"""{ ""mixed values"" : [\n            {\n                ""bool"": true,\n                ""c"": ""aa"",\n                ""f"": 1.1,\n                ""i"": 1,\n                ""if"": 1,\n                ""ifc"": 1,\n                ""inf"": ""Infinity"",\n                ""mix_num"": 1.0,\n                ""nan"": ""NaN"",\n                ""time"": ""2017-01-01T00:00:00""\n            },\n            {\n                ""bool"": false,\n                ""c"": ""bbb"",\n                ""f"": 2.2,\n                ""i"": 2,\n                ""if"": 2.2,\n                ""ifc"": 2.2,\n                ""inf"": ""Infinity"",\n                ""mix_num"": ""Infinity"",\n                ""nan"": ""NaN"",\n                ""time"": ""2017-01-02 03:04:05+09:00""\n            },\n            {\n                ""bool"": true,\n                ""c"": ""cccc"",\n                ""f"": 3.33,\n                ""i"": 3,\n                ""if"": -3,\n                ""ifc"": ""ccc"",\n                ""inf"": ""Infinity"",\n                ""mix_num"": ""NaN"",\n                ""nan"": ""NaN"",\n                ""time"": ""2017-01-01T00:00:00""\n            }]}\n        """"""\n        ),\n    ),\n    Data(\n        table=""float"",\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=json.loads(\n            """"""{ ""float"" : [\n{\n    ""a"": 0.01,\n    ""b"": 0.00125,\n    ""c"": 0\n},\n{\n    ""a"": 1,\n    ""b"": 99.9,\n    ""c"": 0.01\n},\n{\n    ""a"": 1.2,\n    ""b"": 999999.123,\n    ""c"": 0.001\n}]}\n\n""""""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(table="""", header=[], value=[], expected=pytablewriter.EmptyTableDataError),\n    Data(table="""", header=[], value=normal_test_data_list[0].value, expected=ValueError,),\n]\n\ntable_writer_class = pytablewriter.JsonTableWriter\n\n\nclass Test_JsonTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_JsonTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert json.loads(out) == expected\n\n    @pytest.mark.skipif(\n        m_platform.system() == ""Windows"" and sys.version_info < (3, 6), reason=""env dependent tests""\n    )\n    def test_normal_sort_keys(self):\n        writer = table_writer_class()\n        writer.headers = [""z"", ""i""]\n        writer.value_matrix = [\n            {""z"": ""abc"", ""i"": 1},\n            {""z"": ""efg"", ""i"": 2},\n        ]\n\n        assert writer.dumps(sort_keys=True) != writer.dumps(sort_keys=False)\n\n    def test_normal_json_rows(self):\n        writer = table_writer_class()\n        writer.headers = [""a"", ""i"", ""f"", ""b"", ""n""]\n        writer.value_matrix = [\n            {""a"": ""abc"", ""b"": True, ""f"": ""NaN"", ""i"": 0, ""n"": 0.1},\n            {""a"": ""abcdef"", ""b"": False, ""f"": ""Infinity"", ""i"": -1, ""n"": None},\n            {""n"": None, ""f"": ""Infinity"", ""a"": """", ""i"": 1, ""b"": False},\n        ]\n        out = writer.dumps(sort_keys=True)\n\n        expected = dedent(\n            """"""\\\n            [\n                {\n                    ""a"": ""abc"",\n                    ""b"": true,\n                    ""f"": ""NaN"",\n                    ""i"": 0,\n                    ""n"": 0.1\n                },\n                {\n                    ""a"": ""abcdef"",\n                    ""b"": false,\n                    ""f"": ""Infinity"",\n                    ""i"": -1,\n                    ""n"": null\n                },\n                {\n                    ""a"": """",\n                    ""b"": false,\n                    ""f"": ""Infinity"",\n                    ""i"": 1,\n                    ""n"": null\n                }\n            ]\n            """"""\n        )\n\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n    def test_normal_indent_wo_table_name(self):\n        writer = table_writer_class()\n        writer.headers = [""a"", ""i""]\n        writer.value_matrix = [\n            [""abc"", 1],\n            [""efg"", 2],\n        ]\n\n        assert writer.dumps(sort_keys=True) == writer.dumps(sort_keys=True, indent=4)\n        assert writer.dumps(sort_keys=True, indent=2) != writer.dumps(sort_keys=True, indent=4)\n\n        writer.table_name = ""example""\n        assert writer.dumps(sort_keys=True, indent=2) != writer.dumps(sort_keys=True, indent=4)\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_JsonTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                json.loads(\n                    """"""{ ""tablename"" : [\n                {\n                    ""ha"": 1,\n                    ""hb"": 2,\n                    ""hc"": 3\n                },\n                {\n                    ""ha"": 11,\n                    ""hb"": 12,\n                    ""hc"": 13\n                },\n                {\n                    ""ha"": 1,\n                    ""hb"": 2,\n                    ""hc"": 3\n                },\n                {\n                    ""ha"": 11,\n                    ""hb"": 12,\n                    ""hc"": 13\n                },\n                {\n                    ""ha"": 101,\n                    ""hb"": 102,\n                    ""hc"": 103\n                },\n                {\n                    ""ha"": 1001,\n                    ""hb"": 1002,\n                    ""hc"": 1003\n                }]}""""""\n                ),\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n        assert json.loads(out) == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_jsonlines_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nimport json\nfrom decimal import Decimal\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import float_header_list, float_value_matrix, headers, value_matrix\n\n\nData = collections.namedtuple(""Data"", ""header value expected_list"")\n\nnormal_test_data_list = [\n    Data(\n        header=headers,\n        value=value_matrix,\n        expected_list=[\n            {""a"": 1, ""b"": 123.1, ""c"": ""a"", ""dd"": 1, ""e"": 1},\n            {""a"": 2, ""b"": 2.2, ""c"": ""bb"", ""dd"": 2.2, ""e"": 2.2},\n            {""a"": 3, ""b"": 3.3, ""c"": ""ccc"", ""dd"": 3, ""e"": ""cccc""},\n        ],\n    ),\n    Data(\n        header=headers,\n        value=[\n            [""1"", """", ""a"", ""1"", None],\n            [None, 2.2, None, ""2.2"", 2.2],\n            [None, None, None, None, None],\n            [3, 3.3, ""ccc"", None, ""cccc""],\n            [None, None, None, None, None],\n        ],\n        expected_list=[\n            {""a"": 1, ""b"": """", ""c"": ""a"", ""dd"": 1, ""e"": None},\n            {""a"": None, ""b"": 2.2, ""c"": None, ""dd"": 2.2, ""e"": 2.2},\n            {""a"": None, ""b"": None, ""c"": None, ""dd"": None, ""e"": None},\n            {""a"": 3, ""b"": 3.3, ""c"": ""ccc"", ""dd"": None, ""e"": ""cccc""},\n            {""a"": None, ""b"": None, ""c"": None, ""dd"": None, ""e"": None},\n        ],\n    ),\n    Data(\n        header=float_header_list,\n        value=float_value_matrix,\n        expected_list=[\n            {""a"": 0.01, ""b"": 0.00125, ""c"": 0},\n            {""a"": 1, ""b"": 99.9, ""c"": 0.01},\n            {""a"": 1.2, ""b"": 999999.123, ""c"": 0.001},\n        ],\n    ),\n]\nexception_test_data_list = [\n    Data(header=header, value=value, expected_list=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n] + [Data(header=None, value=value_matrix, expected_list=ValueError)]\ntable_writer_class = ptw.JsonLinesTableWriter\n\n\nclass Test_JsonLinesTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_JsonLinesTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected_list""],\n        [[data.header, data.value, data.expected_list] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, header, value, expected_list):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        for actual, expected in zip(out.splitlines(), expected_list):\n            print_test_result(expected=expected, actual=actual, error=err)\n            assert json.loads(actual) == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected_list""],\n        [[data.header, data.value, data.expected_list] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected_list):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected_list):\n            writer.write_table()\n\n    def test_normal_mix_types(self):\n        expected_list = dedent(\n            """"""\\\n            {""a"": ""abc"", ""b"": true, ""f"": ""NaN"", ""i"": 0, ""n"": 0.1}\n            {""a"": ""abcdef"", ""b"": false, ""f"": ""Infinity"", ""i"": -1, ""n"": null}\n            {""a"": """", ""b"": false, ""f"": ""Infinity"", ""i"": 1, ""n"": null}\n            """"""\n        ).splitlines()\n\n        writer = table_writer_class()\n        writer.headers = [""a"", ""i"", ""f"", ""b"", ""n""]\n        writer.value_matrix = [\n            [""abc"", 0, float(""nan""), True, 0.1],\n            [""abcdef"", -1, float(""inf""), False, None],\n            ["""", 1, Decimal(""inf""), False, None],\n        ]\n\n        for actual, expected in zip(writer.dumps(sort_keys=True).splitlines(), expected_list):\n            print_test_result(expected=expected, actual=actual)\n            assert actual == expected\n'"
test/writer/text/test_latex_matrix_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\n\nimport pytest\n\nimport pytablewriter as ptw\nfrom pytablewriter.style import Style\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    value_matrix,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table="""",\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=r""""""\\begin{equation}\n    \\left( \\begin{array}{rrr}\n        0.01 &      0.0012 & 0.000 \\\\\n        1.00 &     99.9000 & 0.010 \\\\\n        1.20 & 999999.1230 & 0.001 \\\\\n    \\end{array} \\right)\n\\end{equation}\n"""""",\n    ),\n    Data(\n        table=""A"",\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=r""""""\\begin{equation}\n    A = \\left( \\begin{array}{rrr}\n        0.01 &      0.0012 & 0.000 \\\\\n        1.00 &     99.9000 & 0.010 \\\\\n        1.20 & 999999.1230 & 0.001 \\\\\n    \\end{array} \\right)\n\\end{equation}\n"""""",\n    ),\n    Data(\n        table=""B"",\n        header=None,\n        value=[\n            [""a_{11}"", ""a_{12}"", r""\\ldots"", ""a_{1n}""],\n            [""a_{21}"", ""a_{22}"", r""\\ldots"", ""a_{2n}""],\n            [""a_{31}"", ""a_{32}"", r""\\ldots"", ""a_{3n}""],\n        ],\n        expected=r""""""\\begin{equation}\n    B = \\left( \\begin{array}{llll}\n        a_{11} & a_{12} & \\ldots & a_{1n} \\\\\n        a_{21} & a_{22} & \\ldots & a_{2n} \\\\\n        a_{31} & a_{32} & \\ldots & a_{3n} \\\\\n    \\end{array} \\right)\n\\end{equation}\n"""""",\n    ),\n    Data(\n        table=""C"",\n        header="""",\n        value=value_matrix,\n        expected=r""""""\\begin{equation}\n    C = \\left( \\begin{array}{rrlrl}\n        1 & 123.1 & a   & 1.0 &    1 \\\\\n        2 &   2.2 & bb  & 2.2 &  2.2 \\\\\n        3 &   3.3 & ccc & 3.0 & cccc \\\\\n    \\end{array} \\right)\n\\end{equation}\n"""""",\n    ),\n]\n\nexception_test_data_list = [\n    Data(table=table, header=header, value=value, expected=ptw.EmptyTableDataError)\n    for table, header, value in itertools.product([None, [], """"], [None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.LatexMatrixWriter\n\n\nclass Test_LatexMatrixWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_LatexMatrixWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_styles(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = r""""""\\begin{equation}\n    style test = \\left( \\begin{array}{rrrrrrlrrr}\n         111 &   111 & \\tiny 111 & \\small 111 &  \\normalsize 111 &  \\large 111 &              & \\large \\bf 111 & \\small \\it 111 & \\large \\bf \\it 111 \\\\\n        1234 &  1234 & \\tiny 1234 & \\small 1234 & \\normalsize 1,234 & \\large 1 234 &              & \\large \\bf 1234 & \\small \\it 1234 & \\large \\bf \\it 1234 \\\\\n    \\end{array} \\right)\n\\end{equation}\n""""""\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n        writer.column_styles = [\n            None,\n            Style(align=""auto""),\n            Style(align=""auto"", font_size=""tiny"", thousand_separator="",""),\n            Style(align=""left"", font_size=""small"", thousand_separator="" ""),\n            Style(align=""right"", font_size=""medium""),\n            Style(align=""center"", font_size=""large""),\n            Style(font_size=""large"", font_weight=""bold""),\n        ]\n        out = writer.dumps()\n        expected = r""""""\\begin{equation}\n    style test = \\left( \\begin{array}{rrrlrclrrr}\n         111 &   111 &  \\tiny 111 & \\small 111  & \\normalsize 111 & \\large 111 &              &    111 &      111 &           111 \\\\\n        1234 &  1234 & \\tiny 1,234 & \\small 1 234 & \\normalsize 1234 & \\large 1234 &              &   1234 &     1234 &          1234 \\\\\n    \\end{array} \\right)\n\\end{equation}\n""""""\n        print_test_result(expected=expected, actual=out)\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_latex_table_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\nData = collections.namedtuple(""Data"", ""header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=r""""""\\begin{array}{r | r | l | r | l | l | l | l | l | l} \\hline\n    \\verb|i| & \\verb| f  | & \\verb| c  | & \\verb| if | & \\verb|ifc| & \\verb|bool | & \\verb| inf  | & \\verb|nan| & \\verb|mix_num| & \\verb|          time           | \\\\ \\hline\n    \\hline\n    1 & 1.10 & aa   &  1.0 &   1 & True  & \\infty & NaN &       1 & 2017-01-01T00:00:00       \\\\ \\hline\n    2 & 2.20 & bbb  &  2.2 & 2.2 & False & \\infty & NaN & \\infty  & \\verb|2017-01-02 03:04:05+09:00| \\\\ \\hline\n    3 & 3.33 & cccc & -3.0 & ccc & True  & \\infty & NaN & NaN     & 2017-01-01T00:00:00       \\\\ \\hline\n\\end{array}\n"""""",\n    ),\n    Data(\n        header=None,\n        value=value_matrix,\n        expected=r""""""\\begin{array}{r | r | l | r | l} \\hline\n    1 & 123.1 & a   & 1.0 &    1 \\\\ \\hline\n    2 &   2.2 & bb  & 2.2 &  2.2 \\\\ \\hline\n    3 &   3.3 & ccc & 3.0 & cccc \\\\ \\hline\n\\end{array}\n"""""",\n    ),\n    Data(\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=r""""""\\begin{array}{r | r | r} \\hline\n    \\verb| a  | & \\verb|     b     | & \\verb|  c  | \\\\ \\hline\n    \\hline\n    0.01 &      0.0012 & 0.000 \\\\ \\hline\n    1.00 &     99.9000 & 0.010 \\\\ \\hline\n    1.20 & 999999.1230 & 0.001 \\\\ \\hline\n\\end{array}\n"""""",\n    ),\n]\n\nexception_test_data_list = [\n    Data(header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.LatexTableWriter\n\n\nclass Test_LatexTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_LatexTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_styles(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = r""""""\\begin{array}{r | r | r | r | r | r | l | r | r | r} \\hline\n    \\verb|none| & \\verb|empty| & \\verb|  tiny   | & \\verb|  small   | & \\verb|     medium     | & \\verb|   large   | & \\verb|null w/ bold| & \\verb|   L bold    | & \\verb|  S italic   | & \\verb| L bold italic  | \\\\ \\hline\n    \\hline\n     111 &   111 & \\tiny 111 & \\small 111 &  \\normalsize 111 &  \\large 111 &              & \\large \\bf 111 & \\small \\it 111 & \\large \\bf \\it 111 \\\\ \\hline\n    1234 &  1234 & \\tiny 1234 & \\small 1234 & \\normalsize 1,234 & \\large 1 234 &              & \\large \\bf 1234 & \\small \\it 1234 & \\large \\bf \\it 1234 \\\\ \\hline\n\\end{array}\n""""""\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_ltsv_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import float_header_list, float_value_matrix, headers, value_matrix\n\n\nData = collections.namedtuple(""Data"", ""header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            a:1\\tb:123.1\\tc:""a""\\tdd:1\\te:1\n            a:2\\tb:2.2\\tc:""bb""\\tdd:2.2\\te:2.2\n            a:3\\tb:3.3\\tc:""ccc""\\tdd:3\\te:""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        header=headers,\n        value=[\n            [""1"", """", ""a"", ""1"", None],\n            [None, 2.2, None, ""2.2"", 2.2],\n            [None, None, None, None, None],\n            [3, 3.3, ""ccc"", None, ""cccc""],\n            [None, None, None, None, None],\n        ],\n        expected=dedent(\n            """"""\\\n            a:1\\tc:""a""\\tdd:1\n            b:2.2\\tdd:2.2\\te:2.2\n            a:3\\tb:3.3\\tc:""ccc""\\te:""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        header=[""a!0"", ""a#1"", ""a.2$"", ""a_%3"", ""a-&4""],\n        value=[[""a\\0b"", ""c   d"", ""e\\tf"", ""g\\nh"", ""i\\r\\nj""]],\n        expected=dedent(\n            """"""\\\n            a0:""a\\0b""\\ta1:""c   d""\\ta.2:""e  f""\\ta_3:""g h""\\ta-4:""i j""\n            """"""\n        ),\n    ),\n    Data(\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=dedent(\n            """"""\\\n            a:0.01\\tb:0.00125\\tc:0\n            a:1\\tb:99.9\\tc:0.01\n            a:1.2\\tb:999999.123\\tc:0.001\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n] + [Data(header=None, value=value_matrix, expected=ValueError)]\n\ntable_writer_class = ptw.LtsvTableWriter\n\n\nclass Test_LtsvTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_LtsvTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_markdown_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport io\nfrom textwrap import dedent\nfrom typing import Optional\n\nimport pytest\nfrom tabledata import TableData\nfrom termcolor import colored\n\nimport pytablewriter as ptw\nfrom pytablewriter.style import Align, Cell, FontSize, Style, ThousandSeparator\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_iter_1,\n    value_matrix_with_none,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\ntry:\n    import pandas as pd\n\n    SKIP_DATAFRAME_TEST = False\nexcept ImportError:\n    SKIP_DATAFRAME_TEST = True\n\n\nData = collections.namedtuple(""Data"", ""table indent header value is_formatting_float expected"")\n\nnormal_test_data_list = [\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | a |  b  | c |dd | e  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |1.0|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|3.0|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=None,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | a | b | c |dd | e |\n            |---|---|---|---|---|\n            """"""\n        ),\n    ),\n    Data(\n        table=""floating point"",\n        indent=0,\n        header=headers,\n        value=[\n            [""1"", 123.09999999999999, ""a"", ""1"", 1],\n            [2, 2.2000000000000002, ""bb"", ""2.2"", 2.2000000000000002],\n            [3, 3.2999999999999998, ""ccc"", ""3.2999999999999998"", ""cccc""],\n        ],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # floating point\n            | a |  b  | c |dd | e  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |1.0|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|3.3|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            ## tablename\n            | a |  b  | c |dd | e  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |1.0|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|3.0|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | a | b | c |dd | e  |\n            |--:|--:|---|--:|----|\n            |  1|   |a  |1.0|    |\n            |   |2.2|   |2.2| 2.2|\n            |  3|3.3|ccc|   |cccc|\n            |   |   |   |   |    |\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | i | f  | c  | if |ifc|bool|  inf   |nan|mix_num |          time           |\n            |--:|---:|----|---:|---|----|--------|---|-------:|-------------------------|\n            |  1|1.10|aa  | 1.0|  1|X   |Infinity|NaN|       1|2017-01-01T00:00:00      |\n            |  2|2.20|bbb | 2.2|2.2|    |Infinity|NaN|Infinity|2017-01-02 03:04:05+09:00|\n            |  3|3.33|cccc|-3.0|ccc|X   |Infinity|NaN|     NaN|2017-01-01T00:00:00      |\n            """"""\n        ),\n    ),\n    Data(\n        table=""formatting float 1"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # formatting float 1\n            | a |  b  | c |dd | e  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |1.0|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|3.0|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table=""formatting float 2"",\n        indent=0,\n        header=float_header_list,\n        value=float_value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # formatting float 2\n            | a  |     b     |  c  |\n            |---:|----------:|----:|\n            |0.01|     0.0012|0.000|\n            |1.00|    99.9000|0.010|\n            |1.20|999999.1230|0.001|\n            """"""\n        ),\n    ),\n    Data(\n        table=""not formatting float 1"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        is_formatting_float=False,\n        expected=dedent(\n            """"""\\\n            # not formatting float 1\n            | a |  b  | c |dd | e  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |  1|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|  3|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table=""not formatting float 2"",\n        indent=0,\n        header=float_header_list,\n        value=float_value_matrix,\n        is_formatting_float=False,\n        expected=dedent(\n            """"""\\\n            # not formatting float 2\n            | a  |    b     |  c  |\n            |---:|---------:|----:|\n            |0.01|   0.00125|    0|\n            |   1|      99.9| 0.01|\n            | 1.2|999999.123|0.001|\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=[""Name"", ""xUnit"", ""Source"", ""Remarks""],\n        value=[\n            [\n                ""Crotest"",\n                """",\n                ""[160]"",\n                ""MIT License. A tiny and simple test framework for Crystal\\nwith common assertions and no pollution into Object class."",\n                """",\n            ]\n        ],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | Name  |xUnit|Source|                                                      Remarks                                                       |\n            |-------|-----|------|--------------------------------------------------------------------------------------------------------------------|\n            |Crotest|     |[160] |MIT License. A tiny and simple test framework for Crystal with common assertions and no pollution into Object class.|\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=[""\xe5\xa7\x93"", ""\xe5\x90\x8d"", ""\xe7\x94\x9f\xe5\xb9\xb4\xe6\x9c\x88\xe6\x97\xa5"", ""\xe9\x83\xb5\xe4\xbe\xbf\xe7\x95\xaa\xe5\x8f\xb7"", ""\xe4\xbd\x8f\xe6\x89\x80"", ""\xe9\x9b\xbb\xe8\xa9\xb1\xe7\x95\xaa\xe5\x8f\xb7""],\n        value=[\n            [""\xe5\xb1\xb1\xe7\x94\xb0"", ""\xe5\xa4\xaa\xe9\x83\x8e"", ""2001/1/1"", ""100-0002"", ""\xe6\x9d\xb1\xe4\xba\xac\xe9\x83\xbd\xe5\x8d\x83\xe4\xbb\xa3\xe7\x94\xb0\xe5\x8c\xba\xe7\x9a\x87\xe5\xb1\x85\xe5\xa4\x96\xe8\x8b\x91"", ""03-1234-5678""],\n            [""\xe5\xb1\xb1\xe7\x94\xb0"", ""\xe6\xac\xa1\xe9\x83\x8e"", ""2001/1/2"", ""251-0036"", ""\xe7\xa5\x9e\xe5\xa5\x88\xe5\xb7\x9d\xe7\x9c\x8c\xe8\x97\xa4\xe6\xb2\xa2\xe5\xb8\x82\xe6\xb1\x9f\xe3\x81\xae\xe5\xb3\xb6\xef\xbc\x91\xe4\xb8\x81\xe7\x9b\xae"", ""03-9999-9999""],\n        ],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            | \xe5\xa7\x93 | \xe5\x90\x8d |\xe7\x94\x9f\xe5\xb9\xb4\xe6\x9c\x88\xe6\x97\xa5|\xe9\x83\xb5\xe4\xbe\xbf\xe7\x95\xaa\xe5\x8f\xb7|           \xe4\xbd\x8f\xe6\x89\x80           |  \xe9\x9b\xbb\xe8\xa9\xb1\xe7\x95\xaa\xe5\x8f\xb7  |\n            |----|----|--------|--------|--------------------------|------------|\n            |\xe5\xb1\xb1\xe7\x94\xb0|\xe5\xa4\xaa\xe9\x83\x8e|2001/1/1|100-0002|\xe6\x9d\xb1\xe4\xba\xac\xe9\x83\xbd\xe5\x8d\x83\xe4\xbb\xa3\xe7\x94\xb0\xe5\x8c\xba\xe7\x9a\x87\xe5\xb1\x85\xe5\xa4\x96\xe8\x8b\x91    |03-1234-5678|\n            |\xe5\xb1\xb1\xe7\x94\xb0|\xe6\xac\xa1\xe9\x83\x8e|2001/1/2|251-0036|\xe7\xa5\x9e\xe5\xa5\x88\xe5\xb7\x9d\xe7\x9c\x8c\xe8\x97\xa4\xe6\xb2\xa2\xe5\xb8\x82\xe6\xb1\x9f\xe3\x81\xae\xe5\xb3\xb6\xef\xbc\x91\xe4\xb8\x81\xe7\x9b\xae|03-9999-9999|\n            """"""\n        ),\n    ),\n    Data(\n        table=""quoted values"",\n        indent=0,\n        header=[\'""quote""\', \'""abc efg""\'],\n        value=[[\'""1""\', \'""abc""\'], [\'""-1""\', \'""efg""\']],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # quoted values\n            |quote|abc efg|\n            |----:|-------|\n            |    1|abc    |\n            |   -1|efg    |\n            """"""\n        ),\n    ),\n    Data(\n        table=""not str headers"",\n        indent=0,\n        header=[None, 1, 0.1],\n        value=[[None, 1, 0.1]],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # not str headers\n            |   | 1 |0.1|\n            |---|--:|--:|\n            |   |  1|0.1|\n            """"""\n        ),\n    ),\n    Data(\n        table=""no uniform matrix"",\n        indent=0,\n        header=[""a"", ""b"", ""c""],\n        value=[[""a"", 0], [""b"", 1, ""bb""], [""c"", 2, ""ccc"", 0.1]],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # no uniform matrix\n            | a | b | c |\n            |---|--:|---|\n            |a  |  0|   |\n            |b  |  1|bb |\n            |c  |  2|ccc|\n            """"""\n        ),\n    ),\n    Data(\n        table=""line breaks"",\n        indent=0,\n        header=[""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # line breaks\n            | a b | c  d | e f |\n            |-----|------|-----|\n            |v1 v1|v2  v2|v3 v3|\n            """"""\n        ),\n    ),\n    Data(\n        table=""empty header"",\n        indent=0,\n        header=[],\n        value=value_matrix,\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # empty header\n            | A |  B  | C | D | E  |\n            |--:|----:|---|--:|----|\n            |  1|123.1|a  |1.0|   1|\n            |  2|  2.2|bb |2.2| 2.2|\n            |  3|  3.3|ccc|3.0|cccc|\n            """"""\n        ),\n    ),\n    Data(\n        table=""vertical bar"",\n        indent=1,\n        header=[""a|b"", ""|c||d|""],\n        value=[[""|v1|v1|"", ""v2|v2""]],\n        is_formatting_float=True,\n        expected=r""""""## vertical bar\n|  a\\|b  |\\|c\\|\\|d\\||\n|-------|------|\n|\\|v1\\|v1\\||v2\\|v2 |\n"""""",\n    ),\n    Data(\n        table=""mixed value types"",\n        indent=0,\n        header=[""data"", ""v""],\n        value=[\n            [3.4375, 65.5397978633],\n            [65.5397978633, 127.642095727],\n            [189.74439359, 189.74439359],\n            [10064.0097539, 10001.907456],\n            [""next"", 10250.3166474],\n        ],\n        is_formatting_float=True,\n        expected=dedent(\n            """"""\\\n            # mixed value types\n            |  data   |   v    |\n            |---------|-------:|\n            |    3.437|   65.54|\n            |   65.540|  127.64|\n            |  189.744|  189.74|\n            |10064.010|10001.91|\n            |next     |10250.32|\n            """"""\n        ),\n    ),\n    Data(\n        table=""list of dict"",\n        indent=0,\n        header=[""A"", ""B"", ""C""],\n        value=[\n            {""A"": 1},\n            {""B"": 2.1, ""C"": ""hoge""},\n            {""A"": 0, ""B"": 0.1, ""C"": ""foo""},\n            {},\n            {""A"": -1, ""B"": -0.1, ""C"": ""bar"", ""D"": ""extra""},\n        ],\n        is_formatting_float=False,\n        expected=dedent(\n            """"""\\\n            # list of dict\n            | A | B  | C  |\n            |--:|---:|----|\n            |  1|    |    |\n            |   | 2.1|hoge|\n            |  0| 0.1|foo |\n            |   |    |    |\n            | -1|-0.1|bar |\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(\n        table="""",\n        indent=0,\n        header=[],\n        value=[],\n        is_formatting_float=True,\n        expected=ptw.EmptyTableDataError,\n    )\n]\n\ntable_writer_class = ptw.MarkdownTableWriter\n\n\ndef trans_func(value):\n    if value is None:\n        return """"\n    if value is True:\n        return ""X""\n    if value is False:\n        return """"\n    return value\n\n\nclass Test_MarkdownTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_MarkdownTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""is_formatting_float"", ""expected""],\n        [\n            [\n                data.table,\n                data.indent,\n                data.header,\n                data.value,\n                data.is_formatting_float,\n                data.expected,\n            ]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, is_formatting_float, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.is_formatting_float = is_formatting_float\n        writer.register_trans_func(trans_func)\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_single_tabledata(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(\n            TableData(\n                ""loader_mapping"",\n                [""Name"", ""Loader""],\n                [\n                    [""csv"", ""CsvTableFileLoader""],\n                    [""excel"", ""ExcelTableFileLoader""],\n                    [""html"", ""HtmlTableFileLoader""],\n                    [""markdown"", ""MarkdownTableFileLoader""],\n                    [""mediawiki"", ""MediaWikiTableFileLoader""],\n                    [""json"", ""JsonTableFileLoader""],\n                    [""Long Format Name"", ""Loader""],\n                ],\n            )\n        )\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            # loader_mapping\n            |      Name      |         Loader         |\n            |----------------|------------------------|\n            |csv             |CsvTableFileLoader      |\n            |excel           |ExcelTableFileLoader    |\n            |html            |HtmlTableFileLoader     |\n            |markdown        |MarkdownTableFileLoader |\n            |mediawiki       |MediaWikiTableFileLoader|\n            |json            |JsonTableFileLoader     |\n            |Long Format Name|Loader                  |\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_multiple_write(self, capsys):\n        writer = table_writer_class()\n        writer.is_write_null_line_after_table = True\n        writer.from_tabledata(\n            TableData(\n                ""first"",\n                [""Name"", ""Loader""],\n                [[""csv"", ""CsvTableFileLoader""], [""excel"", ""ExcelTableFileLoader""]],\n            )\n        )\n        writer.write_table()\n\n        writer.from_tabledata(\n            TableData(""second"", [""a"", ""b"", ""c""], [[""1"", ""AA"", ""abc""], [""2"", ""BB"", ""zzz""]])\n        )\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            # first\n            |Name |       Loader       |\n            |-----|--------------------|\n            |csv  |CsvTableFileLoader  |\n            |excel|ExcelTableFileLoader|\n\n            # second\n            | a | b | c |\n            |--:|---|---|\n            |  1|AA |abc|\n            |  2|BB |zzz|\n\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_style_align(self):\n        writer = table_writer_class()\n        writer.from_tabledata(\n            TableData(\n                ""auto align"",\n                [""left"", ""right"", ""center"", ""auto"", ""auto"", ""None""],\n                [\n                    [0, ""r"", ""center align"", 0, ""a"", ""n""],\n                    [11, ""right align"", ""bb"", 11, ""auto"", ""none (auto)""],\n                ],\n            )\n        )\n        expected = dedent(\n            """"""\\\n            # auto align\n            |left|   right   |   center   |auto|auto|   None    |\n            |---:|-----------|------------|---:|----|-----------|\n            |   0|r          |center align|   0|a   |n          |\n            |  11|right align|bb          |  11|auto|none (auto)|\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n        writer.table_name = ""specify alignment for each column manually""\n        writer.column_styles = [\n            Style(align=Align.LEFT),\n            Style(align=Align.RIGHT),\n            Style(align=Align.CENTER),\n            Style(align=Align.AUTO),\n            Style(align=Align.AUTO),\n            None,\n        ]\n        expected = dedent(\n            """"""\\\n            # specify alignment for each column manually\n            |left|   right   |   center   |auto|auto|   None    |\n            |----|----------:|:----------:|---:|----|-----------|\n            |0   |          r|center align|   0|a   |n          |\n            |11  |right align|     bb     |  11|auto|none (auto)|\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n    def test_normal_style_thousand_separator(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(\n            TableData(\n                """",\n                [""none_format"", ""thousand_separator_i"", ""thousand_separator_f"", ""f"", ""wo_f""],\n                [\n                    [1000, 1234567, 1234567.8, 1234.5678, 1234567.8],\n                    [1000, 1234567, 1234567.8, 1234.5678, 1234567.8],\n                ],\n            )\n        )\n\n        writer.column_styles = [\n            Style(thousand_separator=ThousandSeparator.NONE),\n            Style(thousand_separator=ThousandSeparator.COMMA),\n            Style(thousand_separator=ThousandSeparator.UNDERSCORE),\n            Style(thousand_separator=ThousandSeparator.SPACE),\n        ]\n        out = writer.dumps()\n        expected = dedent(\n            """"""\\\n            |none_format|thousand_separator_i|thousand_separator_f|   f   |  wo_f   |\n            |----------:|-------------------:|-------------------:|------:|--------:|\n            |       1000|           1,234,567|         1_234_567.8|1 234.6|1234567.8|\n            |       1000|           1,234,567|         1_234_567.8|1 234.6|1234567.8|\n            """"""\n        )\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n    def test_normal_style_font_size(self):\n        writer = table_writer_class()\n        writer.table_name = ""style test: font size will not be affected""\n        writer.headers = [""none"", ""empty_style"", ""tiny"", ""small"", ""medium"", ""large""]\n        writer.value_matrix = [[111, 111, 111, 111, 111, 111], [1234, 1234, 1234, 1234, 1234, 1234]]\n        writer.column_styles = [\n            None,\n            Style(),\n            Style(font_size=FontSize.TINY),\n            Style(font_size=FontSize.SMALL),\n            Style(font_size=FontSize.MEDIUM),\n            Style(font_size=FontSize.LARGE),\n        ]\n\n        expected = dedent(\n            """"""\\\n            # style test: font size will not be affected\n            |none|empty_style|tiny|small|medium|large|\n            |---:|----------:|---:|----:|-----:|----:|\n            | 111|        111| 111|  111|   111|  111|\n            |1234|       1234|1234| 1234|  1234| 1234|\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n    def test_normal_style_font_weight(self):\n        writer = table_writer_class()\n        writer.table_name = ""style test: bold""\n        writer.headers = [""normal"", ""bold""]\n        writer.value_matrix = [[11, 11], [123456, 123456]]\n        writer.column_styles = [Style(font_weight=""normal""), Style(font_weight=""bold"")]\n\n        expected = dedent(\n            """"""\\\n            # style test: bold\n            |normal|   bold   |\n            |-----:|---------:|\n            |    11|    **11**|\n            |123456|**123456**|\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    def test_normal_style_mix(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = dedent(\n            """"""\\\n            # style test\n            |none|empty|tiny|small|medium|large|null w/ bold| L bold |S italic|L bold italic|\n            |---:|----:|---:|----:|-----:|----:|------------|-------:|-------:|------------:|\n            | 111|  111| 111|  111|   111|  111|            | **111**|   _111_|    _**111**_|\n            |1234| 1234|1234| 1234| 1,234|1 234|            |**1234**|  _1234_|   _**1234**_|\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    def test_normal_style_filter(self):\n        def style_filter(cell: Cell, **kwargs) -> Optional[Style]:\n            if isinstance(cell.value, int):\n                return Style(align=""left"")\n\n            if cell.value == ""c"":\n                return Style(align=""center"")\n\n            if cell.value == ""r"":\n                return Style(align=""right"")\n\n            return None\n\n        writer = table_writer_class()\n        writer.table_name = ""style filter""\n        writer.headers = [""left"", ""center"", ""right"", ""overwrite l"", ""overwrite c"", ""overwrite r""]\n        writer.value_matrix = [\n            [1, ""c"", ""r"", 1, ""c"", ""r""],\n            [2.2, ""left"", ""left"", 2.2, ""right"", ""center""],\n        ]\n        writer.margin = 1\n        writer.column_styles = [\n            None,\n            None,\n            None,\n            Style(align=""center""),\n            Style(align=""right""),\n            Style(align=""center""),\n        ]\n        writer.add_style_filter(style_filter)\n\n        expected = dedent(\n            """"""\\\n            # style filter\n            | left | center | right | overwrite l | overwrite c | overwrite r |\n            |-----:|--------|-------|:-----------:|------------:|:-----------:|\n            | 1.0  |   c    |     r | 1.0         |      c      |           r |\n            |  2.2 | left   | left  |     2.2     |       right |   center    |\n            """"""\n        )\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n\n        assert output == expected\n\n    def test_normal_set_style(self):\n        writer = table_writer_class()\n        writer.table_name = ""set style method""\n        writer.headers = [""normal"", ""style by idx"", ""style by header""]\n        writer.value_matrix = [[11, 11, 11], [123456, 123456, 123456]]\n\n        writer.set_style(1, Style(font_weight=""bold"", thousand_separator="",""))\n        writer.set_style(\n            ""style by header"", Style(align=""center"", font_weight=""bold"", thousand_separator="" "")\n        )\n        expected = dedent(\n            """"""\\\n            # set style method\n            |normal|style by idx|style by header|\n            |-----:|-----------:|:-------------:|\n            |    11|      **11**|    **11**     |\n            |123456| **123,456**|  **123 456**  |\n            """"""\n        )\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n        assert regexp_ansi_escape.search(output)\n        assert regexp_ansi_escape.sub("""", output) == expected\n\n        writer.table_name = ""change style""\n        writer.set_style(1, Style(align=""right"", font_style=""italic""))\n        writer.set_style(""style by header"", Style())\n        expected = dedent(\n            """"""\\\n            # change style\n            |normal|style by idx|style by header|\n            |-----:|-----------:|--------------:|\n            |    11|        _11_|             11|\n            |123456|    _123456_|         123456|\n            """"""\n        )\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n        assert regexp_ansi_escape.sub("""", output) == expected\n\n    def test_normal_ansi_color(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""ANCI escape sequence""\n        writer.headers = [""colored_i"", ""colored_f"", ""colored_s"", ""wo_anci""]\n        writer.value_matrix = [\n            [colored(111, ""red""), colored(1.1, ""green""), colored(""abc"", ""blue""), ""abc""],\n            [colored(0, ""red""), colored(0.12, ""green""), colored(""abcdef"", ""blue""), ""abcdef""],\n        ]\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            # ANCI escape sequence\n            |colored_i|colored_f|colored_s|wo_anci|\n            |--------:|--------:|---------|-------|\n            |      111|      1.1|abc      |abc    |\n            |        0|     0.12|abcdef   |abcdef |\n            """"""\n        )\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    def test_normal_ansi_style(self):\n        writer = table_writer_class()\n        writer.column_styles = [\n            Style(decoration_line=""strike""),\n            Style(decoration_line=""line-through""),\n        ]\n        writer.headers = [""w/ strike"", ""w/ line through""]\n        writer.value_matrix = [[""strike"", ""line-through""]]\n\n        expected = dedent(\n            """"""\\\n            |w/ strike|w/ line through|\n            |---------|---------------|\n            |strike   |line-through   |\n            """"""\n        )\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    def test_normal_margin_1(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(TableData("""", headers, value_matrix))\n        writer.margin = 1\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            |  a  |   b   |  c  | dd  |  e   |\n            |----:|------:|-----|----:|------|\n            |   1 | 123.1 | a   | 1.0 |    1 |\n            |   2 |   2.2 | bb  | 2.2 |  2.2 |\n            |   3 |   3.3 | ccc | 3.0 | cccc |\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_margin_2(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(TableData("""", headers, value_matrix))\n        writer.margin = 2\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            |   a   |    b    |   c   |  dd   |   e    |\n            |------:|--------:|-------|------:|--------|\n            |    1  |  123.1  |  a    |  1.0  |     1  |\n            |    2  |    2.2  |  bb   |  2.2  |   2.2  |\n            |    3  |    3.3  |  ccc  |  3.0  |  cccc  |\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_register_trans_func(self):\n        writer = table_writer_class()\n        writer.headers = [""a"", ""b""]\n        writer.value_matrix = [[""foo"", True], [""bar"", False]]\n        writer.register_trans_func(trans_func)\n\n        expected = dedent(\n            """"""\\\n            | a | b |\n            |---|---|\n            |foo|X  |\n            |bar|   |\n            """"""\n        )\n\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n\n        assert output == expected\n\n    def test_normal_flavor(self):\n        writer = table_writer_class()\n        writer.colorize_terminal = False\n        writer.column_styles = [\n            None,\n            Style(decoration_line=""strike""),\n            Style(decoration_line=""line-through""),\n        ]\n        writer.headers = [""w/o style"", ""w/ strike"", ""w/ line through""]\n        writer.value_matrix = [[""no"", ""strike"", ""line-through""]]\n\n        expected = dedent(\n            """"""\\\n            |w/o style|w/ strike |w/ line through |\n            |---------|----------|----------------|\n            |no       |~~strike~~|~~line-through~~|\n            """"""\n        )\n\n        output = writer.dumps(flavor=""gfm"")\n        print_test_result(expected=expected, actual=output)\n\n        assert output == expected\n\n    def test_normal_avoid_overwrite_stream_by_dumps(self):\n        writer = table_writer_class()\n        writer.headers = [""a"", ""b""]\n        writer.value_matrix = [[""foo"", ""bar""]]\n        writer.stream = io.StringIO()\n\n        expected = dedent(\n            """"""\\\n            | a | b |\n            |---|---|\n            |foo|bar|\n            """"""\n        )\n\n        output = writer.dumps()\n        print_test_result(expected=expected, actual=output)\n        assert output == expected\n\n        print(""--------------------"")\n\n        writer.write_table()\n        output = writer.stream.getvalue()\n        print_test_result(expected=expected, actual=output)\n        assert output == expected\n\n    def test_normal_escape_html_tag(self, capsys):\n        writer = table_writer_class()\n        writer.headers = [""no"", ""text""]\n        writer.value_matrix = [[1, ""<caption>Table \'formatting for Jupyter Notebook.</caption>""]]\n        writer.update_preprocessor(is_escape_html_tag=True)\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            |no |                                   text                                    |\n            |--:|---------------------------------------------------------------------------|\n            |  1|&lt;caption&gt;Table &#x27;formatting for Jupyter Notebook.&lt;/caption&gt;|\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_escape_html_tag_from_tabledata(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(\n            TableData(\n                """",\n                [""no"", ""text""],\n                [[1, ""<caption>Table \'formatting for Jupyter Notebook.</caption>""]],\n            )\n        )\n        writer.update_preprocessor(is_escape_html_tag=True)\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            |no |                                   text                                    |\n            |--:|---------------------------------------------------------------------------|\n            |  1|&lt;caption&gt;Table &#x27;formatting for Jupyter Notebook.&lt;/caption&gt;|\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in exception_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_MarkdownTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                dedent(\n                    """"""\\\n                    # tablename\n                    | ha | hb | hc |\n                    |---:|---:|---:|\n                    |   1|   2|   3|\n                    |  11|  12|  13|\n                    |   1|   2|   3|\n                    |  11|  12|  13|\n                    | 101| 102| 103|\n                    |1001|1002|1003|\n                    """"""\n                ),\n            ],\n            [\n                ""mix length"",\n                [""string"", ""hb"", ""hc""],\n                value_matrix_iter_1,\n                dedent(\n                    """"""\\\n                    # mix length\n                    |           string            | hb  | hc |\n                    |-----------------------------|----:|---:|\n                    |a b c d e f g h i jklmn      |  2.1|   3|\n                    |aaaaa                        | 12.1|  13|\n                    |bbb                          |    2|   3|\n                    |cc                           |   12|  13|\n                    |a                            |  102| 103|\n                    |                             | 1002|1003|\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n\n\nclass Test_MarkdownTableWriter_dump:\n    def test_normal(self, tmpdir):\n        test_filepath = str(tmpdir.join(""test.sqlite""))\n\n        writer = table_writer_class()\n        writer.headers = [""a"", ""b""]\n        writer.value_matrix = [[""foo"", ""bar""]]\n        writer.dump(test_filepath)\n\n        expected = dedent(\n            """"""\\\n            | a | b |\n            |---|---|\n            |foo|bar|\n            """"""\n        )\n\n        with open(test_filepath) as f:\n            output = f.read()\n\n        print_test_result(expected=expected, actual=output)\n        assert output == expected\n\n\nclass Test_MarkdownTableWriter_from_writer:\n    def test_normal(self):\n        writer_rhs = table_writer_class()\n        writer_rhs.from_tabledata(\n            TableData(\n                ""loader_mapping"",\n                [""Name"", ""Loader""],\n                [\n                    [""csv"", ""CsvTableFileLoader""],\n                    [""excel"", ""ExcelTableFileLoader""],\n                    [""html"", ""HtmlTableFileLoader""],\n                    [""markdown"", ""MarkdownTableFileLoader""],\n                    [""mediawiki"", ""MediaWikiTableFileLoader""],\n                    [""json"", ""JsonTableFileLoader""],\n                    [""Long Format Name"", ""Loader""],\n                ],\n            )\n        )\n        rhs = writer_rhs.dumps()\n\n        writer_lhs = table_writer_class()\n        writer_lhs.from_writer(writer_rhs)\n        lhs = writer_lhs.dumps()\n\n        print_test_result(expected=lhs, actual=rhs)\n\n        assert lhs == rhs\n\n\nclass Test_MarkdownTableWriter_from_tablib:\n    def test_normal_multiple_write(self, capsys):\n        try:\n            import tablib\n        except ImportError:\n            pytest.skip(""requires tablib"")\n\n        data = tablib.Dataset()\n        data.headers = [""a"", ""b"", ""c""]\n        data.append([""1"", ""AA"", ""abc""])\n        data.append([""2"", ""BB"", ""zzz""])\n\n        writer = table_writer_class()\n        writer.from_tablib(data)\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            | a | b | c |\n            |--:|---|---|\n            |  1|AA |abc|\n            |  2|BB |zzz|\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n\nclass Test_MarkdownTableWriter_line_break_handling:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [\n            [\n                ptw.LineBreakHandling.REPLACE,\n                dedent(\n                    """"""\\\n                    |no |    text    |\n                    |--:|------------|\n                    |  1|first second|\n                    """"""\n                ),\n            ],\n            [\n                ptw.LineBreakHandling.ESCAPE,\n                r""""""|no |    text     |\n|--:|-------------|\n|  1|first\\nsecond|\n"""""",\n            ],\n            [\n                ""escape"",\n                r""""""|no |    text     |\n|--:|-------------|\n|  1|first\\nsecond|\n"""""",\n            ],\n        ],\n    )\n    def test_normal_line(self, value, expected):\n        writer = table_writer_class()\n        writer.headers = [""no"", ""text""]\n        writer.value_matrix = [[1, ""first\\nsecond""]]\n        writer.update_preprocessor(line_break_handling=value)\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n\n@pytest.mark.skipif(SKIP_DATAFRAME_TEST, reason=""required package not found"")\nclass Test_MarkdownTableWriter_from_dataframe:\n    @pytest.mark.parametrize(\n        [""add_index_column"", ""expected""],\n        [\n            [\n                False,\n                dedent(\n                    """"""\\\n                    # add_index_column: False\n                    | A | B |\n                    |--:|--:|\n                    |  1| 10|\n                    |  2| 11|\n                    """"""\n                ),\n            ],\n            [\n                True,\n                dedent(\n                    """"""\\\n                    # add_index_column: True\n                    |   | A | B |\n                    |---|--:|--:|\n                    |a  |  1| 10|\n                    |b  |  2| 11|\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, tmpdir, add_index_column, expected):\n        writer = table_writer_class()\n        writer.table_name = ""add_index_column: {}"".format(add_index_column)\n        df = pd.DataFrame({""A"": [1, 2], ""B"": [10, 11]}, index=[""a"", ""b""])\n\n        writer.from_dataframe(df, add_index_column=add_index_column)\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n        # pickle test\n        df_pkl_filepath = str(tmpdir.join(""df.pkl""))\n        df.to_pickle(df_pkl_filepath)\n\n        writer.from_dataframe(df_pkl_filepath, add_index_column=add_index_column)\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n\n\n@pytest.mark.skipif(SKIP_DATAFRAME_TEST, reason=""required package not found"")\nclass Test_MarkdownTableWriter_from_series:\n    @pytest.mark.parametrize(\n        [""add_index_column"", ""expected""],\n        [\n            [\n                False,\n                dedent(\n                    """"""\\\n                    # add_index_column: False\n                    |value |\n                    |-----:|\n                    |100.00|\n                    | 49.50|\n                    | 29.01|\n                    |  0.00|\n                    | 24.75|\n                    | 49.50|\n                    | 74.25|\n                    | 99.00|\n                    """"""\n                ),\n            ],\n            [\n                True,\n                dedent(\n                    """"""\\\n                    # add_index_column: True\n                    |     |value |\n                    |-----|-----:|\n                    |count|100.00|\n                    |mean | 49.50|\n                    |std  | 29.01|\n                    |min  |  0.00|\n                    |25%  | 24.75|\n                    |50%  | 49.50|\n                    |75%  | 74.25|\n                    |max  | 99.00|\n                    """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, add_index_column, expected):\n        writer = table_writer_class()\n        writer.table_name = ""add_index_column: {}"".format(add_index_column)\n\n        writer.from_series(\n            pd.Series(list(range(100))).describe(), add_index_column=add_index_column\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert out == expected\n'"
test/writer/text/test_mediawiki_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\nData = collections.namedtuple(""Data"", ""table header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table=""test table"",\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            |+test table\n            ! a\n            ! b\n            ! c\n            ! dd\n            ! e\n            |-\n            | style=""text-align:right""| 1\n            | style=""text-align:right""| 123.1\n            | a\n            | style=""text-align:right""| 1.0\n            | style=""text-align:right""| 1\n            |-\n            | style=""text-align:right""| 2\n            | style=""text-align:right""| 2.2\n            | bb\n            | style=""text-align:right""| 2.2\n            | style=""text-align:right""| 2.2\n            |-\n            | style=""text-align:right""| 3\n            | style=""text-align:right""| 3.3\n            | ccc\n            | style=""text-align:right""| 3.0\n            | cccc\n            |}\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        header=headers,\n        value=None,\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            ! a\n            ! b\n            ! c\n            ! dd\n            ! e\n            |-\n            |}\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        header=[""ho ge"", ""foo - bar""],\n        value=[\n            [1, ""\\n"".join(["" # a b c"", ""# h o g e""])],\n            [2, ""\\n"".join(["" *hoge"", ""* abc""])],\n            [3, ""\\n"".join(["" a * b"", ""a # b ## c ###""])],\n            [3, ""\\n"".join(["" a # b"", ""a * b ** c ***""])],\n        ],\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            ! ho ge\n            ! foo - bar\n            |-\n            | style=""text-align:right""| 1\n            | \n            # a b c\n            # h o g e\n            |-\n            | style=""text-align:right""| 2\n            | \n            *hoge\n            * abc\n            |-\n            | style=""text-align:right""| 3\n            |  a * b\n            a # b ## c ###\n            |-\n            | style=""text-align:right""| 3\n            |  a # b\n            a * b ** c ***\n            |}\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            | style=""text-align:right""| 1\n            | style=""text-align:right""| 123.1\n            | a\n            | style=""text-align:right""| 1.0\n            | style=""text-align:right""| 1\n            |-\n            | style=""text-align:right""| 2\n            | style=""text-align:right""| 2.2\n            | bb\n            | style=""text-align:right""| 2.2\n            | style=""text-align:right""| 2.2\n            |-\n            | style=""text-align:right""| 3\n            | style=""text-align:right""| 3.3\n            | ccc\n            | style=""text-align:right""| 3.0\n            | cccc\n            |}\n            """"""\n        ),\n    ),\n    Data(\n        table=""test table"",\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            |+test table\n            ! a\n            ! b\n            ! c\n            ! dd\n            ! e\n            |-\n            | style=""text-align:right""| 1\n            | \n            | a\n            | style=""text-align:right""| 1.0\n            | \n            |-\n            | \n            | style=""text-align:right""| 2.2\n            | \n            | style=""text-align:right""| 2.2\n            | style=""text-align:right""| 2.2\n            |-\n            | style=""text-align:right""| 3\n            | style=""text-align:right""| 3.3\n            | ccc\n            | \n            | cccc\n            |-\n            | \n            | \n            | \n            | \n            | \n            |}\n            """"""\n        ),\n    ),\n    Data(\n        table=""test table"",\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            {| class=""wikitable""\n            |+test table\n            ! i\n            ! f\n            ! c\n            ! if\n            ! ifc\n            ! bool\n            ! inf\n            ! nan\n            ! mix_num\n            ! time\n            |-\n            | style=""text-align:right""| 1\n            | style=""text-align:right""| 1.10\n            | aa\n            | style=""text-align:right""| 1.0\n            | style=""text-align:right""| 1\n            | True\n            | Infinity\n            | NaN\n            | style=""text-align:right""| 1\n            | 2017-01-01T00:00:00\n            |-\n            | style=""text-align:right""| 2\n            | style=""text-align:right""| 2.20\n            | bbb\n            | style=""text-align:right""| 2.2\n            | style=""text-align:right""| 2.2\n            | False\n            | Infinity\n            | NaN\n            | Infinity\n            | 2017-01-02 03:04:05+09:00\n            |-\n            | style=""text-align:right""| 3\n            | style=""text-align:right""| 3.33\n            | cccc\n            | style=""text-align:right""| -3.0\n            | ccc\n            | True\n            | Infinity\n            | NaN\n            | NaN\n            | 2017-01-01T00:00:00\n            |}\n            """"""\n        ),\n    ),\n]\n\ntable_writer_class = pytablewriter.MediaWikiTableWriter\n\n\nclass Test_MediaWikiTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_MediaWikiTableWriter_write_table:\n    @pytest.mark.xfail(run=False)\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\ndef simple_write_callback(iter_count, iteration_length):\n    print(""{:d}/{:d}"".format(iter_count, iteration_length))\n\n\nclass Test_MediaWikiTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""callback"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                lambda a, b: None,\n                dedent(\n                    """"""\\\n                {| class=""wikitable""\n                |+tablename\n                ! ha\n                ! hb\n                ! hc\n                |-\n                | style=""text-align:right""| 1\n                | style=""text-align:right""| 2\n                | style=""text-align:right""| 3\n                |-\n                | style=""text-align:right""| 11\n                | style=""text-align:right""| 12\n                | style=""text-align:right""| 13\n                |-\n                | style=""text-align:right""| 1\n                | style=""text-align:right""| 2\n                | style=""text-align:right""| 3\n                |-\n                | style=""text-align:right""| 11\n                | style=""text-align:right""| 12\n                | style=""text-align:right""| 13\n                |-\n                | style=""text-align:right""| 101\n                | style=""text-align:right""| 102\n                | style=""text-align:right""| 103\n                |-\n                | style=""text-align:right""| 1001\n                | style=""text-align:right""| 1002\n                | style=""text-align:right""| 1003\n                |}\n                """"""\n                ),\n            ],\n            [\n                None,\n                None,\n                value_matrix_iter,\n                simple_write_callback,\n                dedent(\n                    """"""\\\n                {| class=""wikitable""\n                | style=""text-align:right""| 1\n                | style=""text-align:right""| 2\n                | style=""text-align:right""| 3\n                |-\n                | style=""text-align:right""| 11\n                | style=""text-align:right""| 12\n                | style=""text-align:right""| 13\n                |-\n                1/3\n                | style=""text-align:right""| 1\n                | style=""text-align:right""| 2\n                | style=""text-align:right""| 3\n                |-\n                | style=""text-align:right""| 11\n                | style=""text-align:right""| 12\n                | style=""text-align:right""| 13\n                |-\n                2/3\n                | style=""text-align:right""| 101\n                | style=""text-align:right""| 102\n                | style=""text-align:right""| 103\n                |-\n                | style=""text-align:right""| 1001\n                | style=""text-align:right""| 1002\n                | style=""text-align:right""| 1003\n                |}\n                3/3\n                """"""\n                ),\n            ],\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, callback, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_callback = callback\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_multibyte.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytest\n\nimport pytablewriter as ptw\n\n\nclass Test_CsvTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""format_name""],\n        [\n            [format_name]\n            for format_name in ptw.TableWriterFactory.get_format_names()\n            if format_name not in [""null"", ""elasticsearch"", ""excel"", ""sqlite""]\n        ],\n    )\n    def test_smoke_multi_byte(self, capsys, format_name):\n        writer = ptw.TableWriterFactory.create_from_format_name(format_name)\n        writer.table_name = ""\xe7\x94\x9f\xe6\x88\x90\xe3\x81\xab\xe9\x96\xa2\xe3\x81\x99\xe3\x82\x8b\xe3\x83\x91\xe3\x82\xbf\xe3\x83\xbc\xe3\x83\xb3""\n        writer.headers = [""\xe3\x83\x91\xe3\x82\xbf\xe3\x83\xbc\xe3\x83\xb3\xe5\x90\x8d"", ""\xe6\xa6\x82\xe8\xa6\x81"", ""GoF"", ""Code Complete[1]""]\n        writer.value_matrix = [\n            [""Abstract Factory"", ""\xe9\x96\xa2\xe9\x80\xa3\xe3\x81\x99\xe3\x82\x8b\xe4\xb8\x80\xe9\x80\xa3\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe7\x8a\xb6\xe6\xb3\x81\xe3\x81\xab\xe5\xbf\x9c\xe3\x81\x98\xe3\x81\xa6\xe3\x80\x81\xe9\x81\xa9\xe5\x88\x87\xe3\x81\xab\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe6\x96\xb9\xe6\xb3\x95\xe3\x82\x92\xe6\x8f\x90\xe4\xbe\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n            [""Builder"", ""\xe8\xa4\x87\xe5\x90\x88\xe5\x8c\x96\xe3\x81\x95\xe3\x82\x8c\xe3\x81\x9f\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xae\xe7\x94\x9f\xe6\x88\x90\xe9\x81\x8e\xe7\xa8\x8b\xe3\x82\x92\xe9\x9a\xa0\xe8\x94\xbd\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""No""],\n            [""Factory Method"", ""\xe5\xae\x9f\xe9\x9a\x9b\xe3\x81\xab\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x95\xe3\x82\x8c\xe3\x82\x8b\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xab\xe4\xbe\x9d\xe5\xad\x98\xe3\x81\x97\xe3\x81\xaa\xe3\x81\x84\xe3\x80\x81\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\xae\xe7\x94\x9f\xe6\x88\x90\xe6\x96\xb9\xe6\xb3\x95\xe3\x82\x92\xe6\x8f\x90\xe4\xbe\x9b\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n            [""Prototype"", ""\xe5\x90\x8c\xe6\xa7\x98\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe7\x94\x9f\xe6\x88\x90\xe3\x81\x99\xe3\x82\x8b\xe3\x81\x9f\xe3\x82\x81\xe3\x81\xab\xe3\x80\x81\xe5\x8e\x9f\xe5\x9e\x8b\xe3\x81\xae\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\x92\xe8\xa4\x87\xe8\xa3\xbd\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""No""],\n            [""Singleton"", ""\xe3\x81\x82\xe3\x82\x8b\xe3\x82\xaf\xe3\x83\xa9\xe3\x82\xb9\xe3\x81\xab\xe3\x81\xa4\xe3\x81\x84\xe3\x81\xa6\xe3\x80\x81\xe3\x82\xa4\xe3\x83\xb3\xe3\x82\xb9\xe3\x82\xbf\xe3\x83\xb3\xe3\x82\xb9\xe3\x81\x8c\xe5\x8d\x98\xe4\xb8\x80\xe3\x81\xa7\xe3\x81\x82\xe3\x82\x8b\xe3\x81\x93\xe3\x81\xa8\xe3\x82\x92\xe4\xbf\x9d\xe8\xa8\xbc\xe3\x81\x99\xe3\x82\x8b\xe3\x80\x82"", ""Yes"", ""Yes""],\n        ]\n\n        writer.write_table()\n\n        out, _err = capsys.readouterr()\n\n        assert len(out) > 100\n'"
test/writer/text/test_numpy_writer.py,13,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\ntry:\n    import numpy as np  # noqa: W0611\n\n    SKIP_DATAFRAME_TEST = False\nexcept ImportError:\n    SKIP_DATAFRAME_TEST = True\n\n\nnormal_test_data_list = [\n    Data(\n        table=""table-name ho\'ge"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=""""""table_name_ho_ge = np.array([\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n    [1, 123.1, ""a"", 1, 1],\n    [2, 2.2, ""bb"", 2.2, 2.2],\n    [3, 3.3, ""ccc"", 3, ""cccc""],\n])\n"""""",\n    ),\n    Data(\n        table=""empty value"",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=""""""empty_value = np.array([\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n])\n"""""",\n    ),\n    Data(\n        table=""table with%null-value"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=""""""table_with_null_value = np.array([\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n    [1, None, ""a"", 1, None],\n    [None, 2.2, None, 2.2, 2.2],\n    [3, 3.3, ""ccc"", None, ""cccc""],\n    [None, None, None, None, None],\n])\n"""""",\n    ),\n    Data(\n        table=""mix data types"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=""""""mix_data_types = np.array([\n    [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n    [1, 1.1, ""aa"", 1, 1, True, np.inf, np.nan, 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n    [2, 2.2, ""bbb"", 2.2, 2.2, False, np.inf, np.nan, np.inf, ""2017-01-02 03:04:05+09:00""],\n    [3, 3.33, ""cccc"", -3, ""ccc"", True, np.inf, np.nan, np.nan, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n])\n"""""",\n    ),\n    Data(\n        table=""mix data types wo header"",\n        indent=0,\n        header=None,\n        value=mix_value_matrix,\n        expected=""""""mix_data_types_wo_header = np.array([\n    [1, 1.1, ""aa"", 1, 1, True, np.inf, np.nan, 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n    [2, 2.2, ""bbb"", 2.2, 2.2, False, np.inf, np.nan, np.inf, ""2017-01-02 03:04:05+09:00""],\n    [3, 3.33, ""cccc"", -3, ""ccc"", True, np.inf, np.nan, np.nan, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n])\n"""""",\n    ),\n    Data(\n        table=""float-with-null"",\n        indent=0,\n        header=[""a"", ""b""],\n        value=[\n            [""0.03785679191278808"", ""826.21158713263""],\n            [None, ""826.21158713263""],\n            [0.1, ""1.0499675627886724""],\n        ],\n        expected=""""""float_with_null = np.array([\n    [""a"", ""b""],\n    [0.03785679191278808, 826.21158713263],\n    [None, 826.21158713263],\n    [0.1, 1.0499675627886724],\n])\n"""""",\n    ),\n]\n\n\ntable_writer_class = ptw.NumpyTableWriter\n\n\nclass Test_NumpyTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_NumpyTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n            + [\n                Data(\n                    table=None,\n                    indent=0,\n                    header=headers,\n                    value=value_matrix,\n                    expected=ptw.EmptyTableNameError,\n                )\n            ]\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_NumpyTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                """"""tablename = np.array([\n    [""ha"", ""hb"", ""hc""],\n    [1, 2, 3],\n    [11, 12, 13],\n    [1, 2, 3],\n    [11, 12, 13],\n    [101, 102, 103],\n    [1001, 1002, 1003],\n])\n"""""",\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_pandas_writer.py,14,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter as ptw\nfrom pytablewriter.typehint import Integer, RealNumber\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\ntry:\n    import numpy as np\n    import pandas as pd\n\n    SKIP_DATAFRAME_TEST = False\nexcept ImportError:\n    SKIP_DATAFRAME_TEST = True\n\n\nnormal_test_data_list = [\n    Data(\n        table=""table-name ho\'ge"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            table_name_ho_ge = pd.DataFrame([\n                [1, 123.1, ""a"", 1, 1],\n                [2, 2.2, ""bb"", 2.2, 2.2],\n                [3, 3.3, ""ccc"", 3, ""cccc""],\n            ], columns=[""a"", ""b"", ""c"", ""dd"", ""e""])\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=dedent(\n            """"""\\\n            tablename = pd.DataFrame([\n            ], columns=[""a"", ""b"", ""c"", ""dd"", ""e""])\n            """"""\n        ),\n    ),\n    Data(\n        table=""table with%null-value"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            table_with_null_value = pd.DataFrame([\n                [1, None, ""a"", 1, None],\n                [None, 2.2, None, 2.2, 2.2],\n                [3, 3.3, ""ccc"", None, ""cccc""],\n                [None, None, None, None, None],\n            ], columns=[""a"", ""b"", ""c"", ""dd"", ""e""])\n            """"""\n        ),\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            tablename = pd.DataFrame([\n                [1, 1.1, ""aa"", 1, 1, True, np.inf, np.nan, 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n                [2, 2.2, ""bbb"", 2.2, 2.2, False, np.inf, np.nan, np.inf, ""2017-01-02 03:04:05+09:00""],\n                [3, 3.33, ""cccc"", -3, ""ccc"", True, np.inf, np.nan, np.nan, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n            ], columns=[""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""])\n            """"""\n        ),\n    ),\n    Data(\n        table=""float-with-null"",\n        indent=0,\n        header=[""a"", ""b""],\n        value=[\n            [""0.03785679191278808"", ""826.21158713263""],\n            [None, ""826.21158713263""],\n            [0.1, ""1.0499675627886724""],\n        ],\n        expected=dedent(\n            """"""\\\n            float_with_null = pd.DataFrame([\n                [0.03785679191278808, 826.21158713263],\n                [None, 826.21158713263],\n                [0.1, 1.0499675627886724],\n            ], columns=[""a"", ""b""])\n            """"""\n        ),\n    ),\n    Data(\n        table=""empty header"",\n        indent=0,\n        header=[],\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            empty_header = pd.DataFrame([\n                [1, 123.1, ""a"", 1, 1],\n                [2, 2.2, ""bb"", 2.2, 2.2],\n                [3, 3.3, ""ccc"", 3, ""cccc""],\n            ])\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(\n        table=""dummy"",\n        indent=normal_test_data_list[0].indent,\n        header=[],\n        value=[],\n        expected=ptw.EmptyTableDataError,\n    ),\n    Data(\n        table="""",\n        indent=normal_test_data_list[0].indent,\n        header=normal_test_data_list[0].header,\n        value=normal_test_data_list[0].value,\n        expected=ptw.EmptyTableNameError,\n    ),\n]\n\ntable_writer_class = ptw.PandasDataFrameWriter\n\n\nclass Test_PandasDataFrameWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_PandasDataFrameWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in exception_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_PandasDataFrameWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                dedent(\n                    """"""\\\n                tablename = pd.DataFrame([\n                    [1, 2, 3],\n                    [11, 12, 13],\n                    [1, 2, 3],\n                    [11, 12, 13],\n                    [101, 102, 103],\n                    [1001, 1002, 1003],\n                ], columns=[""ha"", ""hb"", ""hc""])\n                """"""\n                ),\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n\n\n@pytest.mark.skipif(SKIP_DATAFRAME_TEST, reason=""required package not found"")\nclass Test_PandasDataFrameWriter_from_dataframe:\n    def test_normal(self):\n        import dateutil\n\n        writer = table_writer_class()\n        writer.table_name = ""pd dataframe""\n        writer.from_dataframe(\n            pd.DataFrame(\n                [\n                    [\n                        1,\n                        0.125,\n                        ""aa"",\n                        1.0,\n                        ""1"",\n                        True,\n                        np.inf,\n                        np.nan,\n                        1,\n                        dateutil.parser.parse(""2017-01-01T00:00:00""),\n                    ],\n                    [\n                        2,\n                        2.2,\n                        ""bbb"",\n                        2.2,\n                        ""2.2"",\n                        False,\n                        np.inf,\n                        np.nan,\n                        np.inf,\n                        dateutil.parser.parse(""2017-01-02T03:04:05+0900""),\n                    ],\n                    [\n                        3,\n                        3333.3,\n                        ""cccc"",\n                        -3.0,\n                        ""ccc"",\n                        True,\n                        np.inf,\n                        np.nan,\n                        np.nan,\n                        dateutil.parser.parse(""2017-01-01T00:00:00""),\n                    ],\n                ],\n                columns=[""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n            )\n        )\n\n        expected = dedent(\n            """"""\\\n            pd_dataframe = pd.DataFrame([\n                [1, 0.125, ""aa"", 1, 1, True, np.inf, np.nan, 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n                [2, 2.2, ""bbb"", 2.2, 2.2, False, np.inf, np.nan, np.inf, dateutil.parser.parse(""2017-01-02T03:04:05+0900"")],\n                [3, 3333.3, ""cccc"", -3, ""ccc"", True, np.inf, np.nan, np.nan, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n            ], columns=[""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""])\n            """"""\n        )\n\n        assert writer.value_matrix is not None\n        assert writer.type_hints == [\n            Integer,\n            RealNumber,\n            None,\n            RealNumber,\n            None,\n            None,\n            RealNumber,\n            RealNumber,\n            RealNumber,\n            None,\n        ]\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n\n@pytest.mark.skipif(SKIP_DATAFRAME_TEST, reason=""required package not found"")\nclass Test_as_dataframe:\n    def test_normal(self):\n        writer = table_writer_class()\n        writer.table_name = ""table""\n        writer.headers = [""c"", ""d""]\n        writer.value_matrix = [[""without_mirrors"", 4593356]]\n\n        assert str(writer.tabledata.as_dataframe().to_numpy()) == ""[[\'without_mirrors\' 4593356]]""\n'"
test/writer/text/test_python_code_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n)\n\n\nnormal_test_data_list = [\n    Data(\n        table=""Table-Name ho\'ge"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=""""""table_name_ho_ge = [\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n    [1, 123.1, ""a"", 1, 1],\n    [2, 2.2, ""bb"", 2.2, 2.2],\n    [3, 3.3, ""ccc"", 3, ""cccc""],\n]\n"""""",\n    ),\n    Data(\n        table=""TABLENAME"",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=""""""tablename = [\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n]\n"""""",\n    ),\n    Data(\n        table=""TableName"",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        expected=""""""    tablename = [\n        [""a"", ""b"", ""c"", ""dd"", ""e""],\n        [1, 123.1, ""a"", 1, 1],\n        [2, 2.2, ""bb"", 2.2, 2.2],\n        [3, 3.3, ""ccc"", 3, ""cccc""],\n    ]\n"""""",\n    ),\n    Data(\n        table=""TABLE Name"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=""""""table_name = [\n    [""a"", ""b"", ""c"", ""dd"", ""e""],\n    [1, None, ""a"", 1, None],\n    [None, 2.2, None, 2.2, 2.2],\n    [3, 3.3, ""ccc"", None, ""cccc""],\n    [None, None, None, None, None],\n]\n"""""",\n    ),\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=""""""tablename = [\n    [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n    [1, 1.1, ""aa"", 1, 1, True, float(""inf""), float(""nan""), 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n    [2, 2.2, ""bbb"", 2.2, 2.2, False, float(""inf""), float(""nan""), float(""inf""), ""2017-01-02 03:04:05+09:00""],\n    [3, 3.33, ""cccc"", -3, ""ccc"", True, float(""inf""), float(""nan""), float(""nan""), dateutil.parser.parse(""2017-01-01T00:00:00"")],\n]\n"""""",\n    ),\n    Data(\n        table=""quoted values"",\n        indent=0,\n        header=[\'""quote""\', \'""abc efg""\'],\n        value=[[\'""1\', \'""abc""\'], [\'""-1\', \'""efg""\']],\n        expected=""""""quoted_values = [\n    [""quote"", ""abc efg""],\n    [1, ""abc""],\n    [-1, ""efg""],\n]\n"""""",\n    ),\n    Data(\n        table=""float-with-null"",\n        indent=0,\n        header=[""a"", ""b""],\n        value=[\n            [""0.03785679191278808"", ""826.21158713263""],\n            [None, ""826.21158713263""],\n            [0.1, ""1.0499675627886724""],\n        ],\n        expected=""""""float_with_null = [\n    [""a"", ""b""],\n    [0.03785679191278808, 826.21158713263],\n    [None, 826.21158713263],\n    [0.1, 1.0499675627886724],\n]\n"""""",\n    ),\n]\n\ntable_writer_class = ptw.PythonCodeTableWriter\n\n\nclass Test_PythonCodeTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_PythonCodeTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_not_strict(self, capsys):\n        writer = table_writer_class()\n        writer.table_name = ""tablename""\n        writer.headers = mix_header_list\n        writer.value_matrix = mix_value_matrix\n        writer.write_table()\n\n        expected = """"""tablename = [\n    [""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""],\n    [1, 1.1, ""aa"", 1, 1, True, float(""inf""), float(""nan""), 1, dateutil.parser.parse(""2017-01-01T00:00:00"")],\n    [2, 2.2, ""bbb"", 2.2, 2.2, False, float(""inf""), float(""nan""), float(""inf""), ""2017-01-02 03:04:05+09:00""],\n    [3, 3.33, ""cccc"", -3, ""ccc"", True, float(""inf""), float(""nan""), float(""nan""), dateutil.parser.parse(""2017-01-01T00:00:00"")],\n]\n""""""\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n            + [\n                Data(\n                    table=None,\n                    indent=0,\n                    header=headers,\n                    value=value_matrix,\n                    expected=ptw.EmptyTableNameError,\n                )\n            ]\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_PythonCodeTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                """"""tablename = [\n    [""ha"", ""hb"", ""hc""],\n    [1, 2, 3],\n    [11, 12, 13],\n    [1, 2, 3],\n    [11, 12, 13],\n    [101, 102, 103],\n    [1001, 1002, 1003],\n]\n"""""",\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, _err = capsys.readouterr()\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_rst_csv_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_iter,\n    value_matrix_with_none,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\nnormal_test_data_list = [\n    Data(\n        table=""table name"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. csv-table:: table name\n                :header: ""a"", ""b"", ""c"", ""dd"", ""e""\n                :widths: 3, 5, 5, 4, 6\n\n                1, 123.1, ""a"", 1.0, 1\n                2, 2.2, ""bb"", 2.2, 2.2\n                3, 3.3, ""ccc"", 3.0, ""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=dedent(\n            """"""\\\n            .. csv-table:: \n                :header: ""a"", ""b"", ""c"", ""dd"", ""e""\n                :widths: 3, 3, 3, 4, 3\n\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        indent=0,\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. csv-table:: \n                :widths: 1, 5, 5, 3, 6\n\n                1, 123.1, ""a"", 1.0, 1\n                2, 2.2, ""bb"", 2.2, 2.2\n                3, 3.3, ""ccc"", 3.0, ""cccc""\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        expected=""""""    .. csv-table:: \n        :header: ""a"", ""b"", ""c"", ""dd"", ""e""\n        :widths: 3, 5, 5, 4, 6\n\n        1, 123.1, ""a"", 1.0, 1\n        2, 2.2, ""bb"", 2.2, 2.2\n        3, 3.3, ""ccc"", 3.0, ""cccc""\n"""""",\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            .. csv-table:: table name\n                :header: ""a"", ""b"", ""c"", ""dd"", ""e""\n                :widths: 3, 3, 5, 4, 6\n\n                1, , ""a"", 1.0, \n                , 2.2, , 2.2, 2.2\n                3, 3.3, ""ccc"", , ""cccc""\n                , , , , \n            """"""\n        ),\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            .. csv-table:: table name\n                :header: ""i"", ""f"", ""c"", ""if"", ""ifc"", ""bool"", ""inf"", ""nan"", ""mix_num"", ""time""\n                :widths: 3, 4, 6, 4, 5, 6, 8, 5, 9, 27\n\n                1, 1.10, ""aa"", 1.0, 1, True, Infinity, NaN, 1, 2017-01-01T00:00:00\n                2, 2.20, ""bbb"", 2.2, 2.2, False, Infinity, NaN, Infinity, ""2017-01-02 03:04:05+09:00""\n                3, 3.33, ""cccc"", -3.0, ""ccc"", True, Infinity, NaN, NaN, 2017-01-01T00:00:00\n            """"""\n        ),\n    ),\n]\n\ntable_writer_class = pytablewriter.RstCsvTableWriter\n\n\nclass Test_RstCsvTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_RstCsvTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert out == expected\n\n    def test_normal_styles(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = dedent(\n            """"""\\\n            .. csv-table:: style test\n                :header: ""none"", ""empty"", ""tiny"", ""small"", ""medium"", ""large"", ""null w/ bold"", ""L bold"", ""S italic"", ""L bold italic""\n                :widths: 6, 7, 6, 7, 8, 7, 14, 8, 10, 15\n\n                111, 111, 111, 111, ""111"", 111, , **111**, *111*, **111**\n                1234, 1234, 1234, 1234, ""1,234"", 1 234, , **1234**, *1234*, **1234**\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_RstCsvTableWriter_write_table_iter:\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [\n            [\n                ""tablename"",\n                [""ha"", ""hb"", ""hc""],\n                value_matrix_iter,\n                dedent(\n                    """"""\\\n                    .. csv-table:: tablename\n                        :header: ""ha"", ""hb"", ""hc""\n                        :widths: 5, 5, 5\n\n                        1, 2, 3\n                        11, 12, 13\n                        1, 2, 3\n                        11, 12, 13\n                        101, 102, 103\n                        1001, 1002, 1003\n                    """"""\n                ),\n            ]\n        ],\n    )\n    def test_normal(self, capsys, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n        writer.iteration_length = len(value)\n        writer.write_table_iter()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""header"", ""value"", ""expected""],\n        [[data.table, data.header, data.value, data.expected] for data in null_test_data_list],\n    )\n    def test_exception(self, table, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table_iter()\n'"
test/writer/text/test_rst_grid_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\nfrom tabledata import TableData\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_with_none,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\nnormal_test_data_list = [\n    Data(\n        table=""table name"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: table name\n\n                +-+-----+---+---+----+\n                |a|  b  | c |dd | e  |\n                +=+=====+===+===+====+\n                |1|123.1|a  |1.0|   1|\n                +-+-----+---+---+----+\n                |2|  2.2|bb |2.2| 2.2|\n                +-+-----+---+---+----+\n                |3|  3.3|ccc|3.0|cccc|\n                +-+-----+---+---+----+\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=dedent(\n            """"""\\\n            .. table:: \n\n                +-+-+-+--+-+\n                |a|b|c|dd|e|\n                +=+=+=+==+=+\n                +-+-+-+--+-+\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        indent=0,\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: \n\n                +-+-----+---+---+----+\n                |1|123.1|a  |1.0|   1|\n                +-+-----+---+---+----+\n                |2|  2.2|bb |2.2| 2.2|\n                +-+-----+---+---+----+\n                |3|  3.3|ccc|3.0|cccc|\n                +-+-----+---+---+----+\n            """"""\n        ),\n    ),\n    Data(\n        table=""INDENTATION"",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        expected=""""""    .. table:: INDENTATION\n\n        +-+-----+---+---+----+\n        |a|  b  | c |dd | e  |\n        +=+=====+===+===+====+\n        |1|123.1|a  |1.0|   1|\n        +-+-----+---+---+----+\n        |2|  2.2|bb |2.2| 2.2|\n        +-+-----+---+---+----+\n        |3|  3.3|ccc|3.0|cccc|\n        +-+-----+---+---+----+\n"""""",\n    ),\n    Data(\n        table=""zone"",\n        indent=0,\n        header=[""zone_id"", ""country_code"", ""zone_name""],\n        value=[\n            [""1"", ""AD"", ""Europe/Andorra""],\n            [""2"", ""AE"", ""Asia/Dubai""],\n            [""3"", ""AF"", ""Asia/Kabul""],\n            [""4"", ""AG"", ""America/Antigua""],\n            [""5"", ""AI"", ""America\\nAnguilla""],\n        ],\n        expected=dedent(\n            """"""\\\n            .. table:: zone\n\n                +-------+------------+----------------+\n                |zone_id|country_code|   zone_name    |\n                +=======+============+================+\n                |      1|AD          |Europe/Andorra  |\n                +-------+------------+----------------+\n                |      2|AE          |Asia/Dubai      |\n                +-------+------------+----------------+\n                |      3|AF          |Asia/Kabul      |\n                +-------+------------+----------------+\n                |      4|AG          |America/Antigua |\n                +-------+------------+----------------+\n                |      5|AI          |America Anguilla|\n                +-------+------------+----------------+\n            """"""\n        ),\n    ),\n    Data(\n        table=""table with None values."",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            .. table:: table with None values.\n\n                +-+---+---+---+----+\n                |a| b | c |dd | e  |\n                +=+===+===+===+====+\n                |1|   |a  |1.0|    |\n                +-+---+---+---+----+\n                | |2.2|   |2.2| 2.2|\n                +-+---+---+---+----+\n                |3|3.3|ccc|   |cccc|\n                +-+---+---+---+----+\n                | |   |   |   |    |\n                +-+---+---+---+----+\n            """"""\n        ),\n    ),\n    Data(\n        table=""Mixed-Type-Columns"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: Mixed-Type-Columns\n\n                +-+----+----+----+---+-----+--------+---+--------+-------------------------+\n                |i| f  | c  | if |ifc|bool |  inf   |nan|mix_num |          time           |\n                +=+====+====+====+===+=====+========+===+========+=========================+\n                |1|1.10|aa  | 1.0|  1|True |Infinity|NaN|       1|2017-01-01T00:00:00      |\n                +-+----+----+----+---+-----+--------+---+--------+-------------------------+\n                |2|2.20|bbb | 2.2|2.2|False|Infinity|NaN|Infinity|2017-01-02 03:04:05+09:00|\n                +-+----+----+----+---+-----+--------+---+--------+-------------------------+\n                |3|3.33|cccc|-3.0|ccc|True |Infinity|NaN|     NaN|2017-01-01T00:00:00      |\n                +-+----+----+----+---+-----+--------+---+--------+-------------------------+\n            """"""\n        ),\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=[""int"", ""float"", ""str"", ""bool"", ""mix"", ""time""],\n        value=[\n            [0, 0.1, ""hoge"", True, 0, ""2017-01-01 03:04:05+0900""],\n            [2, ""-2.23"", ""foo"", False, None, ""2017-12-23 12:01:23+0900""],\n            [3, 0, ""bar"", ""true"", ""inf"", ""2017-03-03 22:44:55+0900""],\n            [-10, -9.9, """", ""FALSE"", ""nan"", ""2017-01-01 00:00:00+0900""],\n        ],\n        expected=dedent(\n            """"""\\\n            .. table:: table name\n\n                +---+-----+----+-----+--------+------------------------+\n                |int|float|str |bool |  mix   |          time          |\n                +===+=====+====+=====+========+========================+\n                |  0| 0.10|hoge|True |       0|2017-01-01 03:04:05+0900|\n                +---+-----+----+-----+--------+------------------------+\n                |  2|-2.23|foo |False|        |2017-12-23 12:01:23+0900|\n                +---+-----+----+-----+--------+------------------------+\n                |  3| 0.00|bar |True |Infinity|2017-03-03 22:44:55+0900|\n                +---+-----+----+-----+--------+------------------------+\n                |-10|-9.90|    |False|     NaN|2017-01-01 00:00:00+0900|\n                +---+-----+----+-----+--------+------------------------+\n            """"""\n        ),\n    ),\n    Data(\n        table=""line breaks will be converted to a white space"",\n        indent=0,\n        header=[""a\\nb"", ""\\nc\\n\\nd\\n"", ""e\\r\\nf""],\n        value=[[""v1\\nv1"", ""v2\\n\\nv2"", ""v3\\r\\nv3""]],\n        expected=dedent(\n            """"""\\\n            .. table:: line breaks will be converted to a white space\n\n                +-----+------+-----+\n                | a b | c  d | e f |\n                +=====+======+=====+\n                |v1 v1|v2  v2|v3 v3|\n                +-----+------+-----+\n            """"""\n        ),\n    ),\n]\n\ntable_writer_class = pytablewriter.RstGridTableWriter\n\n\nclass Test_RstGridTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_RstGridTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert writer.dumps() == expected\n\n    def test_normal_margin_1(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(TableData(""margin 1"", headers, value_matrix))\n        writer.margin = 1\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            .. table:: margin 1\n\n                +---+-------+-----+-----+------+\n                | a |   b   |  c  | dd  |  e   |\n                +===+=======+=====+=====+======+\n                | 1 | 123.1 | a   | 1.0 |    1 |\n                +---+-------+-----+-----+------+\n                | 2 |   2.2 | bb  | 2.2 |  2.2 |\n                +---+-------+-----+-----+------+\n                | 3 |   3.3 | ccc | 3.0 | cccc |\n                +---+-------+-----+-----+------+\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_margin_2(self, capsys):\n        writer = table_writer_class()\n        writer.from_tabledata(TableData(""margin 2"", headers, value_matrix))\n        writer.margin = 2\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            .. table:: margin 2\n\n                +-----+---------+-------+-------+--------+\n                |  a  |    b    |   c   |  dd   |   e    |\n                +=====+=========+=======+=======+========+\n                |  1  |  123.1  |  a    |  1.0  |     1  |\n                +-----+---------+-------+-------+--------+\n                |  2  |    2.2  |  bb   |  2.2  |   2.2  |\n                +-----+---------+-------+-------+--------+\n                |  3  |    3.3  |  ccc  |  3.0  |  cccc  |\n                +-----+---------+-------+-------+--------+\n            """"""\n        )\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_styles(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = dedent(\n            """"""\\\n            .. table:: style test\n\n                +----+-----+----+-----+------+-----+------------+--------+--------+-------------+\n                |none|empty|tiny|small|medium|large|null w/ bold| L bold |S italic|L bold italic|\n                +====+=====+====+=====+======+=====+============+========+========+=============+\n                | 111|  111| 111|  111|   111|  111|            | **111**|   *111*|      **111**|\n                +----+-----+----+-----+------+-----+------------+--------+--------+-------------+\n                |1234| 1234|1234| 1234| 1,234|1 234|            |**1234**|  *1234*|     **1234**|\n                +----+-----+----+-----+------+-----+------------+--------+--------+-------------+\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_RstGridTableWriter_write_table_iter:\n    def test_exception(self):\n        writer = table_writer_class()\n\n        with pytest.raises(pytablewriter.NotSupportedError):\n            writer.write_table_iter()\n'"
test/writer/text/test_rst_simple_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    Data,\n    headers,\n    mix_header_list,\n    mix_value_matrix,\n    null_test_data_list,\n    value_matrix,\n    value_matrix_with_none,\n    vut_style_tabledata,\n    vut_styles,\n)\nfrom ._common import regexp_ansi_escape\n\n\nnormal_test_data_list = [\n    Data(\n        table=""tablename"",\n        indent=0,\n        header=headers,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: tablename\n\n                =  =====  ===  ===  ====\n                a    b     c   dd    e  \n                =  =====  ===  ===  ====\n                1  123.1  a    1.0     1\n                2    2.2  bb   2.2   2.2\n                3    3.3  ccc  3.0  cccc\n                =  =====  ===  ===  ====\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=0,\n        header=headers,\n        value=None,\n        expected=dedent(\n            """"""\\\n            .. table:: \n\n                =  =  =  ==  =\n                a  b  c  dd  e\n                =  =  =  ==  =\n                =  =  =  ==  =\n            """"""\n        ),\n    ),\n    Data(\n        table=None,\n        indent=0,\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: \n\n                =  =====  ===  ===  ====\n                1  123.1  a    1.0     1\n                2    2.2  bb   2.2   2.2\n                3    3.3  ccc  3.0  cccc\n                =  =====  ===  ===  ====\n            """"""\n        ),\n    ),\n    Data(\n        table="""",\n        indent=1,\n        header=headers,\n        value=value_matrix,\n        expected=""""""    .. table:: \n\n        =  =====  ===  ===  ====\n        a    b     c   dd    e  \n        =  =====  ===  ===  ====\n        1  123.1  a    1.0     1\n        2    2.2  bb   2.2   2.2\n        3    3.3  ccc  3.0  cccc\n        =  =====  ===  ===  ====\n"""""",\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=headers,\n        value=value_matrix_with_none,\n        expected=dedent(\n            """"""\\\n            .. table:: table name\n\n                =  ===  ===  ===  ====\n                a   b    c   dd    e  \n                =  ===  ===  ===  ====\n                1       a    1.0      \n                   2.2       2.2   2.2\n                3  3.3  ccc       cccc\n\n                =  ===  ===  ===  ====\n            """"""\n        ),\n    ),\n    Data(\n        table=""table name"",\n        indent=0,\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            .. table:: table name\n\n                =  ====  ====  ====  ===  =====  ========  ===  ========  =========================\n                i   f     c     if   ifc  bool     inf     nan  mix_num             time           \n                =  ====  ====  ====  ===  =====  ========  ===  ========  =========================\n                1  1.10  aa     1.0    1  True   Infinity  NaN         1  2017-01-01T00:00:00      \n                2  2.20  bbb    2.2  2.2  False  Infinity  NaN  Infinity  2017-01-02 03:04:05+09:00\n                3  3.33  cccc  -3.0  ccc  True   Infinity  NaN       NaN  2017-01-01T00:00:00      \n                =  ====  ====  ====  ===  =====  ========  ===  ========  =========================\n            """"""\n        ),\n    ),\n]\n\ntable_writer_class = pytablewriter.RstSimpleTableWriter\n\n\nclass Test_RstSimpleTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_RstSimpleTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    def test_normal_styles(self):\n        writer = table_writer_class()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n\n        expected = dedent(\n            """"""\\\n            .. table:: style test\n\n                ====  =====  ====  =====  ======  =====  ============  ========  ========  =============\n                none  empty  tiny  small  medium  large  null w/ bold   L bold   S italic  L bold italic\n                ====  =====  ====  =====  ======  =====  ============  ========  ========  =============\n                 111    111   111    111     111    111                 **111**     *111*        **111**\n                1234   1234  1234   1234   1,234  1 234                **1234**    *1234*       **1234**\n                ====  =====  ====  =====  ======  =====  ============  ========  ========  =============\n            """"""\n        )\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n    @pytest.mark.parametrize(\n        [""table"", ""indent"", ""header"", ""value"", ""expected""],\n        [\n            [data.table, data.indent, data.header, data.value, data.expected]\n            for data in null_test_data_list\n        ],\n    )\n    def test_exception(self, table, indent, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table\n        writer.set_indent_level(indent)\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n\n\nclass Test_RstSimpleTableWriter_write_table_iter:\n    def test_exception(self):\n        writer = table_writer_class()\n\n        with pytest.raises(pytablewriter.NotSupportedError):\n            writer.write_table_iter()\n'"
test/writer/text/test_space_aligned_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nfrom textwrap import dedent\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n)\n\n\nData = collections.namedtuple(""Data"", ""header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=dedent(\n            """"""\\\n            i   f     c     if   ifc  bool     inf     nan  mix_num             time           \n            1  1.10  aa     1.0    1  True   Infinity  NaN         1  2017-01-01T00:00:00      \n            2  2.20  bbb    2.2  2.2  False  Infinity  NaN  Infinity  2017-01-02 03:04:05+09:00\n            3  3.33  cccc  -3.0  ccc  True   Infinity  NaN       NaN  2017-01-01T00:00:00      \n            """"""\n        ),\n    ),\n    Data(\n        header=None,\n        value=value_matrix,\n        expected=dedent(\n            """"""\\\n            1  123.1  a    1.0     1\n            2    2.2  bb   2.2   2.2\n            3    3.3  ccc  3.0  cccc\n            """"""\n        ),\n    ),\n    Data(\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=dedent(\n            """"""\\\n             a         b         c  \n            0.01       0.0012  0.000\n            1.00      99.9000  0.010\n            1.20  999999.1230  0.001\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.SpaceAlignedTableWriter\n\n\nclass Test_SpaceAlignedTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_SpaceAlignedTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_toml_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\nfrom decimal import Decimal\n\nimport pytest\nimport toml\nfrom dateutil.parser import parse\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import float_header_list, float_value_matrix, headers, value_matrix\n\n\nData = collections.namedtuple(""Data"", ""table_name header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        table_name=""normal"",\n        header=headers,\n        value=value_matrix,\n        expected=""""""[[normal]]\na = 1\nc = ""a""\nb = 123.1\ne = 1\ndd = 1\n[[normal]]\na = 2\nc = ""bb""\nb = 2.2\ne = 2.2\ndd = 2.2\n[[normal]]\na = 3\nc = ""ccc""\nb = 3.3\ne = ""cccc""\ndd = 3\n"""""",\n    ),\n    Data(\n        table_name=""sparse"",\n        header=headers,\n        value=[\n            [""1"", """", ""a"", ""1"", None],\n            [None, 2.2, None, ""2.2"", 2.2],\n            [None, None, None, None, None],\n            [3, 3.3, ""ccc"", None, ""cccc""],\n            [None, None, None, None, None],\n        ],\n        expected=""""""[[sparse]]\na = 1\nb = """"\nc = ""a""\ndd = 1\n\n[[sparse]]\nb = 2.2\ndd = 2.2\ne = 2.2\n\n[[sparse]]\n\n[[sparse]]\na = 3\nb = 3.3\nc = ""ccc""\ne = ""cccc""\n\n[[sparse]]\n"""""",\n    ),\n    Data(\n        table_name=""symbols"",\n        header=[""a!0"", ""a#1"", ""a.2$"", ""a_%3"", ""a-&4""],\n        value=[[""a?b"", ""c   d"", ""e+f"", ""g=h"", ""i*j""], [1, 2.0, 3.3, Decimal(""4.4""), """"]],\n        expected=""""""[[symbols]]\n""a-&4"" = ""i*j""\n""a#1"" = ""c   d""\n""a_%3"" = ""g=h""\n""a!0"" = ""a?b""\n""a.2$"" = ""e+f""\n[[symbols]]\n""a-&4"" = """"\n""a#1"" = 2\n""a_%3"" = 4.4\n""a!0"" = 1\n""a.2$"" = 3.3\n"""""",\n    ),\n    Data(\n        table_name=""mixtype"",\n        header=[""int"", ""float"", ""bool"", ""datetime""],\n        value=[\n            [0, 2.2, True, parse(""2017-01-02T03:04:05"")],\n            [-1, Decimal(""4.4""), False, parse(""2022-01-01T00:00:00"")],\n        ],\n        expected=""""""[[mixtype]]\nint = 0\nfloat = 2.2\nbool = true\ndatetime = ""2017-01-02T03:04:05""\n\n[[mixtype]]\nint = -1\nfloat = 4.4\nbool = false\ndatetime = ""2022-01-01T00:00:00""\n"""""",\n    ),\n    Data(\n        table_name=""float"",\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=""""""[[float]]\na = 0.01\nb = 0.00125\nc = 0\n\n[[float]]\na = 1\nb = 99.90000000000001\nc = 0.01\n\n[[float]]\na = 1.2\nb = 999999.123\nc = 0.001\n"""""",\n    ),\n]\n\nexception_test_data_list = [\n    Data(table_name=""dummy"", header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n] + [\n    Data(table_name=""empty_header"", header=None, value=value_matrix, expected=ValueError),\n    Data(table_name=None, header=headers, value=value_matrix, expected=ptw.EmptyTableNameError),\n]\n\ntable_writer_class = ptw.TomlTableWriter\n\n\nclass Test_TomlTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_TomlTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""table_name"", ""header"", ""value"", ""expected""],\n        [\n            [data.table_name, data.header, data.value, data.expected]\n            for data in normal_test_data_list\n        ],\n    )\n    def test_normal(self, capsys, table_name, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table_name\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert toml.loads(out) == toml.loads(expected)\n\n    @pytest.mark.parametrize(\n        [""table_name"", ""header"", ""value"", ""expected""],\n        [\n            [data.table_name, data.header, data.value, data.expected]\n            for data in exception_test_data_list\n        ],\n    )\n    def test_exception(self, capsys, table_name, header, value, expected):\n        writer = table_writer_class()\n        writer.table_name = table_name\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_tsv_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nimport collections\nimport itertools\n\nimport pytest\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import (\n    float_header_list,\n    float_value_matrix,\n    mix_header_list,\n    mix_value_matrix,\n    value_matrix,\n)\n\n\nData = collections.namedtuple(""Data"", ""header value expected"")\n\nnormal_test_data_list = [\n    Data(\n        header=mix_header_list,\n        value=mix_value_matrix,\n        expected=""""""""i""\\t""f""\\t""c""\\t""if""\\t""ifc""\\t""bool""\\t""inf""\\t""nan""\\t""mix_num""\\t""time""\n1\\t1.1\\t""aa""\\t1\\t1\\tTrue\\tInfinity\\tNaN\\t1\\t""2017-01-01T00:00:00""\n2\\t2.2\\t""bbb""\\t2.2\\t2.2\\tFalse\\tInfinity\\tNaN\\tInfinity\\t""2017-01-02 03:04:05+09:00""\n3\\t3.33\\t""cccc""\\t-3\\t""ccc""\\tTrue\\tInfinity\\tNaN\\tNaN\\t""2017-01-01T00:00:00""\n"""""",\n    ),\n    Data(\n        header=None,\n        value=value_matrix,\n        expected=""""""1\\t123.1\\t""a""\\t1\\t1\n2\\t2.2\\t""bb""\\t2.2\\t2.2\n3\\t3.3\\t""ccc""\\t3\\t""cccc""\n"""""",\n    ),\n    Data(\n        header=float_header_list,\n        value=float_value_matrix,\n        expected=""""""""a""\\t""b""\\t""c""\n0.01\\t0.00125\\t0\n1\\t99.9\\t0.01\n1.2\\t999999.123\\t0.001\n"""""",\n    ),\n]\n\nexception_test_data_list = [\n    Data(header=header, value=value, expected=ptw.EmptyTableDataError)\n    for header, value in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.TsvTableWriter\n\n\nclass Test_TsvTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_TsvTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n\n    @pytest.mark.parametrize(\n        [""header"", ""value"", ""expected""],\n        [[data.header, data.value, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, header, value, expected):\n        writer = table_writer_class()\n        writer.headers = header\n        writer.value_matrix = value\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
test/writer/text/test_unicode_writer.py,0,"b'""""""\n.. codeauthor:: Tsuyoshi Hombashi <tsuyoshi.hombashi@gmail.com>\n""""""\n\nfrom textwrap import dedent\n\nimport pytest\n\nfrom pytablewriter import BoldUnicodeTableWriter, UnicodeTableWriter\n\nfrom ..._common import print_test_result\nfrom ...data import vut_style_tabledata, vut_styles\nfrom ._common import regexp_ansi_escape\n\n\nclass Test_UnicodeTableWriter_write_new_line:\n    @pytest.mark.parametrize(\n        [""table_writer_class""], [[UnicodeTableWriter], [BoldUnicodeTableWriter],]\n    )\n    def test_normal(self, capsys, table_writer_class):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n        assert out == ""\\n""\n\n\nclass Test_UnicodeTableWriter_write_table:\n    def test_normal_styles(self, capsys):\n        writer = UnicodeTableWriter()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            \xe2\x94\x8c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xac\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x90\n            \xe2\x94\x82none\xe2\x94\x82empty\xe2\x94\x82tiny\xe2\x94\x82small\xe2\x94\x82medium\xe2\x94\x82large\xe2\x94\x82null w/ bold\xe2\x94\x82L bold\xe2\x94\x82S italic\xe2\x94\x82L bold italic\xe2\x94\x82\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n            \xe2\x94\x82 111\xe2\x94\x82  111\xe2\x94\x82 111\xe2\x94\x82  111\xe2\x94\x82   111\xe2\x94\x82  111\xe2\x94\x82            \xe2\x94\x82   111\xe2\x94\x82     111\xe2\x94\x82          111\xe2\x94\x82\n            \xe2\x94\x9c\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xbc\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xa4\n            \xe2\x94\x821234\xe2\x94\x82 1234\xe2\x94\x821234\xe2\x94\x82 1234\xe2\x94\x82 1,234\xe2\x94\x821 234\xe2\x94\x82            \xe2\x94\x82  1234\xe2\x94\x82    1234\xe2\x94\x82         1234\xe2\x94\x82\n            \xe2\x94\x94\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\xb4\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x98\n            """"""\n        )\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n\n\nclass Test_BoldUnicodeTableWriter_write_table:\n    def test_normal_styles(self, capsys):\n        writer = BoldUnicodeTableWriter()\n        writer.from_tabledata(vut_style_tabledata)\n        writer.column_styles = vut_styles\n        writer.write_table()\n\n        expected = dedent(\n            """"""\\\n            \xe2\x94\x8f\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xb3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x93\n            \xe2\x94\x83none\xe2\x94\x83empty\xe2\x94\x83tiny\xe2\x94\x83small\xe2\x94\x83medium\xe2\x94\x83large\xe2\x94\x83null w/ bold\xe2\x94\x83L bold\xe2\x94\x83S italic\xe2\x94\x83L bold italic\xe2\x94\x83\n            \xe2\x94\xa3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xab\n            \xe2\x94\x83 111\xe2\x94\x83  111\xe2\x94\x83 111\xe2\x94\x83  111\xe2\x94\x83   111\xe2\x94\x83  111\xe2\x94\x83            \xe2\x94\x83   111\xe2\x94\x83     111\xe2\x94\x83          111\xe2\x94\x83\n            \xe2\x94\xa3\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x95\x8b\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xab\n            \xe2\x94\x831234\xe2\x94\x83 1234\xe2\x94\x831234\xe2\x94\x83 1234\xe2\x94\x83 1,234\xe2\x94\x831 234\xe2\x94\x83            \xe2\x94\x83  1234\xe2\x94\x83    1234\xe2\x94\x83         1234\xe2\x94\x83\n            \xe2\x94\x97\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\xbb\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x81\xe2\x94\x9b\n            """"""\n        )\n\n        out = writer.dumps()\n        print_test_result(expected=expected, actual=out)\n        assert regexp_ansi_escape.search(out)\n        assert regexp_ansi_escape.sub("""", out) == expected\n'"
test/writer/text/test_yaml_writer.py,0,"b'import collections\nimport itertools\nfrom io import StringIO\nfrom textwrap import dedent\n\nimport pytest\nimport yaml\nfrom tabledata import TableData\n\nimport pytablewriter as ptw\n\nfrom ..._common import print_test_result\nfrom ...data import float_tabledata, mix_tabledata, value_matrix\n\n\nData = collections.namedtuple(""Data"", ""tabledata expected"")\n\nnormal_test_data_list = [\n    Data(\n        tabledata=mix_tabledata,\n        expected=dedent(\n            """"""\\\n            mix data:\n            - bool: true\n              c: aa\n              f: 1.1\n              i: 1\n              if: 1\n              ifc: 1\n              inf: .inf\n              mix_num: 1\n              nan: .nan\n              time: \'2017-01-01T00:00:00\'\n            - bool: false\n              c: bbb\n              f: 2.2\n              i: 2\n              if: 2.2\n              ifc: 2.2\n              inf: .inf\n              mix_num: .inf\n              nan: .nan\n              time: \'2017-01-02 03:04:05+09:00\'\n            - bool: true\n              c: cccc\n              f: 3.33\n              i: 3\n              if: -3\n              ifc: ccc\n              inf: .inf\n              mix_num: .nan\n              nan: .nan\n              time: \'2017-01-01T00:00:00\'\n            """"""\n        ),\n    ),\n    Data(\n        tabledata=TableData(table_name=None, headers=[], rows=value_matrix,),\n        expected=dedent(\n            """"""\\\n            - - 1\n              - 123.1\n              - a\n              - 1\n              - 1\n            - - 2\n              - 2.2\n              - bb\n              - 2.2\n              - 2.2\n            - - 3\n              - 3.3\n              - ccc\n              - 3\n              - cccc\n            """"""\n        ),\n    ),\n    Data(\n        tabledata=float_tabledata,\n        expected=dedent(\n            """"""\\\n            float data:\n            - a: 0.01\n              b: 0.00125\n              c: 0\n            - a: 1\n              b: 99.9\n              c: 0.01\n            - a: 1.2\n              b: 999999.123\n              c: 0.001\n            """"""\n        ),\n    ),\n]\n\nexception_test_data_list = [\n    Data(\n        tabledata=TableData(table_name=None, headers=headers, rows=rows),\n        expected=ptw.EmptyTableDataError,\n    )\n    for headers, rows in itertools.product([None, [], """"], [None, [], """"])\n]\n\ntable_writer_class = ptw.YamlTableWriter\n\n\nclass Test_YamlTableWriter_write_new_line:\n    def test_normal(self, capsys):\n        writer = table_writer_class()\n        writer.write_null_line()\n\n        out, _err = capsys.readouterr()\n\n        assert out == ""\\n""\n\n\nclass Test_YamlTableWriter_write_table:\n    @pytest.mark.parametrize(\n        [""value"", ""expected""], [[data.tabledata, data.expected] for data in normal_test_data_list],\n    )\n    def test_normal(self, capsys, value, expected):\n        writer = table_writer_class()\n        writer.from_tabledata(value)\n        writer.write_table()\n\n        out, err = capsys.readouterr()\n        print_test_result(expected=expected, actual=out, error=err)\n\n        assert out == expected\n        assert yaml.safe_load(StringIO(out))\n\n    @pytest.mark.parametrize(\n        [""value"", ""expected""],\n        [[data.tabledata, data.expected] for data in exception_test_data_list],\n    )\n    def test_exception(self, value, expected):\n        writer = table_writer_class()\n        writer.from_tabledata(value)\n\n        with pytest.raises(expected):\n            writer.write_table()\n'"
pytablewriter/writer/text/sourcecode/__init__.py,0,b'from ._javascript import JavaScriptTableWriter\nfrom ._numpy import NumpyTableWriter\nfrom ._pandas import PandasDataFrameWriter\nfrom ._python import PythonCodeTableWriter\n'
pytablewriter/writer/text/sourcecode/_javascript.py,0,"b'import io\nfrom typing import List\n\nfrom dataproperty import ColumnDataProperty, DataProperty, DefaultValue\nfrom typepy import StrictLevel, Typecode\n\nfrom ...._converter import strip_quote\nfrom ...._function import quote_datetime_formatter\nfrom ....sanitizer import sanitize_js_var_name\nfrom .._common import bool_to_str\nfrom ._sourcecode import SourceCodeTableWriter\n\n\ndef js_datetime_formatter(value) -> str:\n    try:\n        return \'new Date(""{:s}"")\'.format(value.strftime(DefaultValue.DATETIME_FORMAT))\n    except ValueError:\n        # the datetime strftime() methods require year >= 1900\n        return \'new Date(""{}"")\'.format(value)\n\n\nclass JavaScriptTableWriter(SourceCodeTableWriter):\n    """"""\n    A table writer for class JavaScript format.\n\n        :Example:\n            :ref:`example-js-table-writer`\n\n    .. py:attribute:: variable_declaration\n        :type: str\n        :value: ""const""\n\n        JavaScript variable declarations type.\n        The value must be either ``""var""``, ``""let""`` or ``""const""``.\n\n    .. py:method:: write_table\n\n        |write_table| with JavaScript format.\n        The tabular data are written as a nested list variable definition.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |table_name| is empty.\n        :raises pytablewriter.EmptyTableDataError:\n            If the |headers| and the |value_matrix| is empty.\n        :Example:\n            :ref:`example-js-table-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as ``null``\n            - |inf|: written as ``Infinity``\n            - |nan|: written as ``NaN``\n            - |datetime| instances determined by |is_datetime_instance_formatting| attribute:\n                - |True|: written as `dateutil.parser <https://dateutil.readthedocs.io/en/stable/parser.html>`__\n                - |False|: written as |str|\n\n            .. seealso::\n                :ref:`example-type-hint-js`\n    """"""\n\n    FORMAT_NAME = ""javascript""\n    __VALID_VAR_DECLARATION = (""var"", ""let"", ""const"")\n    __NONE_VALUE_DP = DataProperty(""null"")\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    @property\n    def variable_declaration(self) -> str:\n        return self.__variable_declaration\n\n    @variable_declaration.setter\n    def variable_declaration(self, value: str):\n        value = value.strip().lower()\n        if value not in self.__VALID_VAR_DECLARATION:\n            raise ValueError(""declaration must be either var, let or const"")\n\n        self.__variable_declaration = value\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.variable_declaration = ""const""\n        self._dp_extractor.type_value_map = {\n            # Typecode.NONE: ""null"",\n            Typecode.INFINITY: ""Infinity"",\n            Typecode.NAN: ""NaN"",\n        }\n        self._dp_extractor.update_strict_level_map({Typecode.BOOL: StrictLevel.MAX})\n        self.register_trans_func(bool_to_str)\n\n    def get_variable_name(self, value: str) -> str:\n        return sanitize_js_var_name(value, ""_"").lower()\n\n    def _write_table(self, **kwargs) -> None:\n        if self.is_datetime_instance_formatting:\n            self._dp_extractor.datetime_formatter = js_datetime_formatter\n        else:\n            self._dp_extractor.datetime_formatter = quote_datetime_formatter\n\n        org_stream = self.stream\n        self.stream = io.StringIO()\n\n        self.inc_indent_level()\n        super()._write_table(**kwargs)\n        self.dec_indent_level()\n        js_matrix_var_def_text = self.stream.getvalue().rstrip(""\\n"")\n        js_matrix_var_def_text = strip_quote(js_matrix_var_def_text, ""true"")\n        js_matrix_var_def_text = strip_quote(js_matrix_var_def_text, ""false"")\n        if self.is_write_closing_row:\n            js_matrix_var_def_line_list = js_matrix_var_def_text.splitlines()\n            js_matrix_var_def_line_list[-2] = js_matrix_var_def_line_list[-2].rstrip("","")\n            js_matrix_var_def_text = ""\\n"".join(js_matrix_var_def_line_list)\n\n        self.stream.close()\n        self.stream = org_stream\n\n        self.dec_indent_level()\n        self._write_line(js_matrix_var_def_text)\n        self.inc_indent_level()\n\n    def _get_opening_row_items(self) -> List[str]:\n        return [""{:s} {:s} = ["".format(self.variable_declaration, self.variable_name)]\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [""];""]\n\n    def _to_row_item(self, row_idx: int, col_dp: ColumnDataProperty, value_dp: DataProperty) -> str:\n        if value_dp.data is None:\n            value_dp = self.__NONE_VALUE_DP\n\n        return super()._to_row_item(row_idx, col_dp, value_dp)\n'"
pytablewriter/writer/text/sourcecode/_numpy.py,0,"b'from typing import List\n\nimport typepy\n\nfrom ._python import PythonCodeTableWriter\n\n\nclass NumpyTableWriter(PythonCodeTableWriter):\n    """"""\n    A table writer class for ``NumPy`` source code format.\n\n        :Example:\n            :ref:`example-numpy-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with ``NumPy`` format.\n        The tabular data are written as a variable definition of\n        ``numpy.array``.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |table_name| is empty.\n        :raises pytablewriter.EmptyTableDataError:\n            If the |headers| and the |value_matrix| is empty.\n        :Example:\n            :ref:`example-numpy-table-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as ``None``\n            - |inf|: written as ``numpy.inf``\n            - |nan|: written as ``numpy.nan``\n            - |datetime| instances determined by |is_datetime_instance_formatting| attribute:\n                - |True|: written as `dateutil.parser <https://dateutil.readthedocs.io/en/stable/parser.html>`__\n                - |False|: written as |str|\n\n            .. seealso::\n                :ref:`example-type-hint-python`\n    """"""\n\n    FORMAT_NAME = ""numpy""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.import_numpy_as = ""np""\n        self._dp_extractor.type_value_map[typepy.Typecode.INFINITY] = ""{:s}.inf"".format(\n            self.import_numpy_as\n        )\n        self._dp_extractor.type_value_map[typepy.Typecode.NAN] = ""{:s}.nan"".format(\n            self.import_numpy_as\n        )\n\n    def _get_opening_row_items(self) -> List[str]:\n        array_def = ""{:s}.array(["".format(self.import_numpy_as)\n\n        if typepy.is_not_null_string(self.table_name):\n            return [""{} = {}"".format(self.variable_name, array_def)]\n\n        return [array_def]\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [""])""]\n'"
pytablewriter/writer/text/sourcecode/_pandas.py,0,"b'from typing import List\n\nimport typepy\nfrom mbstrdecoder import MultiByteStrDecoder\n\nfrom ....error import EmptyTableNameError\nfrom ._numpy import NumpyTableWriter\n\n\nclass PandasDataFrameWriter(NumpyTableWriter):\n    """"""\n    A writer class for Pandas DataFrame format.\n\n        :Example:\n            :ref:`example-pandas-dataframe-writer`\n\n    .. py:attribute:: import_pandas_as\n        :type: str\n        :value: ""pd""\n\n        Specify ``pandas`` module import name of an output source code.\n\n    .. py:attribute:: import_numpy_as\n        :type: str\n        :value: ""np""\n\n        Specify ``numpy`` module import name of an output source code.\n\n    .. py:method:: write_table\n\n        |write_table| with Pandas DataFrame format.\n        The tabular data are written as a ``pandas.DataFrame`` class\n        instance definition.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |table_name| is empty.\n\n        :Example:\n            :ref:`example-pandas-dataframe-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as ``None``\n            - |inf|: written as ``numpy.inf``\n            - |nan|: written as ``numpy.nan``\n            - |datetime| instances determined by |is_datetime_instance_formatting| attribute:\n                - |True|: written as `dateutil.parser <https://dateutil.readthedocs.io/en/stable/parser.html>`__\n                - |False|: written as |str|\n\n            .. seealso::\n                :ref:`example-type-hint-python`\n    """"""\n\n    FORMAT_NAME = ""pandas""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n        self.import_pandas_as = ""pd""\n        self.is_write_header = False\n\n    def _get_opening_row_items(self) -> List[str]:\n        return [""{} = {}.DataFrame(["".format(self.variable_name, self.import_pandas_as)]\n\n    def _get_closing_row_items(self) -> List[str]:\n        if typepy.is_not_empty_sequence(self.headers):\n            return [\n                ""], columns=[{}])"".format(\n                    "", "".join(\n                        [\n                            \'""{}""\'.format(MultiByteStrDecoder(header).unicode_str)\n                            for header in self.headers\n                        ]\n                    )\n                )\n            ]\n\n        return [""])""]\n\n    def _verify_property(self) -> None:\n        super()._verify_property()\n\n        if typepy.is_null_string(self.table_name):\n            raise EmptyTableNameError(""table_name must be a string of one or more characters"")\n'"
pytablewriter/writer/text/sourcecode/_python.py,0,"b'from typing import List\n\nimport typepy\n\nfrom ...._function import dateutil_datetime_formatter, quote_datetime_formatter\nfrom ....sanitizer import sanitize_python_var_name\nfrom ._sourcecode import SourceCodeTableWriter\n\n\nclass PythonCodeTableWriter(SourceCodeTableWriter):\n    """"""\n    A table writer class for Python source code format.\n\n        :Example:\n            :ref:`example-python-code-table-writer`\n\n    .. py:method:: write_table\n\n        |write_table| with Python format.\n        The tabular data are written as a nested list variable definition\n        for Python format.\n\n        :raises pytablewriter.EmptyTableNameError:\n            If the |table_name| is empty.\n        :raises pytablewriter.EmptyTableDataError:\n            If the |headers| and the |value_matrix| is empty.\n        :Example:\n            :ref:`example-python-code-table-writer`\n\n        .. note::\n            Specific values in the tabular data are converted when writing:\n\n            - |None|: written as ``None``\n            - |inf|: written as ``float(""inf"")``\n            - |nan|: written as ``float(""nan"")``\n            - |datetime| instances determined by |is_datetime_instance_formatting| attribute:\n                - |True|: written as `dateutil.parser <https://dateutil.readthedocs.io/en/stable/parser.html>`__\n                - |False|: written as |str|\n\n            .. seealso::\n                :ref:`example-type-hint-python`\n    """"""\n\n    FORMAT_NAME = ""python""\n\n    @property\n    def format_name(self) -> str:\n        return self.FORMAT_NAME\n\n    @property\n    def support_split_write(self) -> bool:\n        return True\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.table_name = """"\n        self._dp_extractor.type_value_map = {\n            typepy.Typecode.NONE: None,\n            typepy.Typecode.INFINITY: \'float(""inf"")\',\n            typepy.Typecode.NAN: \'float(""nan"")\',\n        }\n\n    def get_variable_name(self, value: str) -> str:\n        return sanitize_python_var_name(self.table_name, ""_"").lower()\n\n    def _write_table(self, **kwargs) -> None:\n        if self.is_datetime_instance_formatting:\n            self._dp_extractor.datetime_formatter = dateutil_datetime_formatter\n        else:\n            self._dp_extractor.datetime_formatter = quote_datetime_formatter\n\n        self.inc_indent_level()\n        super()._write_table(**kwargs)\n        self.dec_indent_level()\n\n    def _get_opening_row_items(self) -> List[str]:\n        if typepy.is_not_null_string(self.table_name):\n            return [self.variable_name + "" = [""]\n\n        return [""[""]\n\n    def _get_closing_row_items(self) -> List[str]:\n        return [""]""]\n'"
pytablewriter/writer/text/sourcecode/_sourcecode.py,0,"b'import abc\nfrom typing import List\n\nimport typepy\n\nfrom .._text_writer import IndentationTextTableWriter\n\n\nclass SourceCodeTableWriter(IndentationTextTableWriter):\n    """"""\n    Base class of table writer with a source code (variable definition) format.\n\n    .. py:attribute:: is_datetime_instance_formatting\n        :type: bool\n\n        Write |datetime| values in the table as definition of |datetime| class\n        instances coincide with specific language if this value is |True|.\n        Write as |str| if this value is |False|.\n    """"""\n\n    @abc.abstractmethod\n    def get_variable_name(self, value: str) -> str:  # pragma: no cover\n        pass\n\n    @property\n    def variable_name(self) -> str:\n        """"""\n        Return a valid variable name that converted from the |table_name|.\n\n        :return: A variable name.\n        :rtype: str\n        """"""\n\n        return self.get_variable_name(self.table_name)\n\n    def __init__(self) -> None:\n        super().__init__()\n\n        self.indent_string = ""    ""\n        self.column_delimiter = "", ""\n\n        self.char_left_side_row = ""[""\n        self.char_right_side_row = ""],""\n        self.char_cross_point = """"\n        self.char_opening_row_cross_point = """"\n        self.char_closing_row_cross_point = """"\n\n        self.is_padding = False\n        self.is_write_header_separator_row = False\n        self.is_write_opening_row = True\n        self.is_write_closing_row = True\n\n        self.is_formatting_float = False\n        self.is_datetime_instance_formatting = True\n\n        self._quoting_flags[typepy.Typecode.DATETIME] = False\n        self._is_require_table_name = True\n\n        self._init_cross_point_maps()\n\n    def _get_value_row_separator_items(self) -> List[str]:\n        return []\n\n    def _write_opening_row(self) -> None:\n        self.dec_indent_level()\n        super()._write_opening_row()\n        self.inc_indent_level()\n\n    def _write_closing_row(self) -> None:\n        self.dec_indent_level()\n        super()._write_closing_row()\n        self.inc_indent_level()\n'"
