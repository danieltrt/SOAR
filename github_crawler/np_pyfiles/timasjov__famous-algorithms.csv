file_path,api_count,code
graphs/bfs.py,0,"b""edges = [line.rstrip() for line in open('graph.txt')]\n\ndirected_graph = dict()\nfor edge in edges:\n    start_node = edge[0]\n    end_node = edge[2]\n    if start_node in directed_graph:\n        directed_graph[start_node].append(end_node)\n    else:\n        directed_graph[start_node] = [end_node]\n\n# directed graph:\n#     'A': ['D', 'C', 'G'],\n#     'C': ['D', 'E'],\n#     'B': ['K'],\n#     'E': ['N', 'F', 'H'],\n#     'D': ['B'],\n#     'F': ['I'],\n#     'H': ['G'],\n#     'K': ['D'],\n#     'J': ['I'],\n#     'M': ['F', 'L'],\n#     'L': ['M'],\n#     'N': ['A', 'G']\n\n# recursive BFS algorithm\ndef bfs_rec(graph, start, visited=None, queue=None):\n    if visited is None:\n        visited = []\n    if queue is None:\n        queue = []\n    if start not in visited:\n        visited.append(start)\n    if start in graph.keys():\n        unvisited = [x for x in list(graph[start]) if x not in visited]\n        [queue.append(v) for v in unvisited if v not in queue]\n        if len(queue) != 0:\n            vertex_to_visit_next = queue.pop(0)\n            bfs_rec(graph, vertex_to_visit_next, visited, queue)\n    return visited\nprint('Recursive BFS algorithm: ' + str(bfs_rec(directed_graph, 'A')))"""
graphs/dfs.py,0,"b""edges = [line.rstrip() for line in open('graph.txt')]\n\ndirected_graph = dict()\nfor edge in edges:\n    start_node = edge[0]\n    end_node = edge[2]\n    if start_node in directed_graph:\n        directed_graph[start_node].append(end_node)\n    else:\n        directed_graph[start_node] = [end_node]\n\n# directed graph:\n#     'A': ['D', 'C', 'G'],\n#     'C': ['D', 'E'],\n#     'B': ['K'],\n#     'E': ['N', 'F', 'H'],\n#     'D': ['B'],\n#     'F': ['I'],\n#     'H': ['G'],\n#     'K': ['D'],\n#     'J': ['I'],\n#     'M': ['F', 'L'],\n#     'L': ['M'],\n#     'N': ['A', 'G']\n\n# recursive DFS algorithm\ndiscovery_time = dict()\nfinishing_time = dict()\ncounter = 1\ndef dfs_rec(graph, start, visited=None):\n    global counter\n    if visited is None:\n        visited = []\n    if counter == 1:\n        discovery_time[start] = counter\n        counter += 1\n    visited.append(start)\n    if start in graph.keys():\n        unvisited = [x for x in list(graph[start]) if x not in visited]\n        for vertex in unvisited:\n            if vertex not in discovery_time.keys():\n                discovery_time[vertex] = counter\n                counter += 1\n        for vertex in unvisited:\n            if vertex not in visited:\n                dfs_rec(graph, vertex, visited)\n    if start not in finishing_time.keys():\n        finishing_time[start] = counter\n        counter += 1\n    return visited\nprint('Recursive DFS algorithm: ' + str(dfs_rec(directed_graph, 'A')))\nprint('Discovery times: ' + str(discovery_time))\nprint('Finishing times: ' + str(finishing_time))\n\n# not recursive DFS algorithm with stack\ndef dfs_no_rec_stack(graph, start):\n    visited = []\n    stack = [start]\n    while stack:\n        vertex = stack.pop(0)\n        if vertex not in visited:\n            visited.append(vertex)\n            if vertex in graph.keys():\n                unvisited = [x for x in list(graph[vertex]) if x not in visited]\n                stack = unvisited + stack\n    return visited\nprint('Not recursive DFS algorithm with stack ' + str(dfs_no_rec_stack(directed_graph, 'A')))"""
hashing/BloomFilter.py,0,"b'from random import randrange\n\nMAX_K =16\nDEFAULT_K = 8\n\n\ndef hash(word):\n    wordStr = str(word)\n    assert len(wordStr) <= MAX_K\n\n    value = 0\n    for n, ch in enumerate(wordStr):\n        value += ord(ch) * 128 ** n\n        #value += 2 * ord(ch) ** n\n        \n    return value\n\n\nclass BloomFilter(object):\n    allchars = """".join([chr(i) for i in range(128)])\n\n    def __init__(self, tablesizes, k=DEFAULT_K):\n        self.tables = [(size, [0] * size) for size in tablesizes]\n        self.k = k\n\n    def add(self, word):\n        val = hash(word)\n        for size, ht in self.tables:\n            ht[val % size] = 1\n\n    def __contains__(self, word):\n        val = hash(word)\n        return all(ht[val % size] for (size, ht) in self.tables)\n\nbloomFilter = BloomFilter([1001, 1003, 1005])\n#bloomFilter = BloomFilter([100000])\n\nlines = []\nfor line in open(\'1000_keys.txt\'):\n    num = line.strip()\n    lines.append(num)\n    bloomFilter.add(num)\n\nfalsePositives = 0\nfor num in lines:\n    if not (num in bloomFilter):\n        falsePositives += 1\nprint(\'Number of false positives: \' + str(falsePositives))\n'"
maximize-minimize-expression/max-min.py,0,"b'def maxmin(a, type):\n    if operation == \'max\':\n        type = True\n    else:\n        type = False\n    height = len(a)\n    matrix = [[0] * height for row in xrange(height)]\n    for nr_signs in range(height):\n        matrix[nr_signs][nr_signs] = int(a[nr_signs])\n\n    for nr_signs in range(1, height):  # loop total number of signs needed to put\n        for row in range(0, height - nr_signs):  # loop total number of signs per row\n            add = []\n            mult = []\n            pos = nr_signs + row  # position in row where to put the element\n            for operation in range(nr_signs):  # number of operations per row per sign\n                add.append(matrix[row][row + operation] + matrix[row + operation + 1][row + nr_signs])\n                mult.append(matrix[row][row + operation] * matrix[row + operation + 1][row + nr_signs])\n            if type:\n                max_mult = max(mult)\n                max_add = max(add)\n            else:\n                max_mult = min(mult)\n                max_add = min(add)\n\n            if max_mult >= max_add and type:\n                matrix[row][pos] = max_mult\n            elif type:\n                matrix[row][pos] = max_add\n            elif max_mult <= max_add:\n                matrix[row][pos] = max_mult\n            else:\n                matrix[row][pos] = max_add\n\n    return matrix\n\n\nnumbers = [2, 1, 2, 1, 1, 3, 6, 10, 1, 2, 2, 1, 6, 1, 2, 2, 1, 7, 2, 1, 1, 3, 2, 1, 5, 1, 7, 2, 1, 2, 1, 2, 1, 2, 3, 1, 4, 4, 5, 2, 1, 2, 2, 2, 1, 1, 1, 2, 3]\nresult_max = maxmin(numbers, ""max"")\nprint(\'Max: \' + str(result_max[0][-1]))\nresult_min = maxmin(numbers, ""min"")\nprint(\'Min: \' + str(result_min[0][-1]))'"
scientific/curve_fitting.py,6,"b""#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Simple 2 degree polynomial fit can be done using numpy build in functions: numpy.polyfit and poly1d\n# First function performs squares polynomial fit and second calculates new points\n\n# Example data\npoints = np.array([(0., 0.), (1., 1.), (-1., .9), (.5, .7)])\n\n# Get x and y vectors\n# numpy.polyfit will work only when array is sorted\nx = np.array([-1., 0., .5, 1.])\ny = np.array([.9, 0., .7, 1.])\n\n# Calculate polynomial\nz = np.polyfit(x, y, 2)\nf = np.poly1d(z)\n\n# Calculate new x's and y's\nx_new = np.linspace(x[0], x[-1], 50)\ny_new = f(x_new)\n\nplt.plot(x, y, 'o', x_new, y_new)\nplt.xlim([x[0] - 1, x[-1] + 1])\nplt.show()"""
scientific/gauss_elimination_with_partial_pivoting.py,8,"b""#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\n\n# Example matrix\nA = np.matrix([[3, 1, 2], [0, -2, -2], [1, 5, 3]], dtype=float)\nb = np.array([1, 1, 2], dtype=float)\nX = np.matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float)\n\n# Partial pivoting in the Gauss elimination method of matrix A\ndef pivotingLU(A, b):\n    A1 = A.copy()\n    n = len(A)\n    L = np.zeros(shape=(n, n))\n    U = np.zeros(shape=(n, n))\n    ps = np.arange(b.size)\n\n    for k in range(0, n - 1):\n        column = [np.abs(A1[i, k]) for i in range(0, n)]\n        column2 = column[k:n]\n        p = np.argmax(column2) + k\n\n        if p != k:\n            for j in range(0, n):\n                z = A1[k, j]\n                A1[k, j] = A1[p, j]\n                A1[p, j] = z\n\n            z = ps[k]\n            ps[k] = ps[p]\n            ps[p] = z\n\n        if A1[k, k] != 0:\n            for i in range(k + 1, n):\n                A1[i, k] = A1[i, k] / A1[k, k]\n\n            for j in range(k + 1, n):\n                for i in range(k + 1, n):\n                    A1[i, j] = A1[i, j] - A1[i, k] * A1[k, j]\n\n            for i in range(n):\n                for j in range(n):\n                    if i > j:\n                        L[i, j] = A1[i, j]\n                    else:\n                        U[i, j] = A1[i, j]\n                    if i == j:\n                        L[i, j] = 1\n    return ps, L, U\n\n\nplu = pivotingLU(A, b)\nps = plu[0]\nU = plu[1]\nL = plu[2]\n\nprint('ps=', plu[0])\nprint('L=', plu[2])\nprint('U=', plu[1])"""
scientific/gradient_descent.py,8,"b'#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\nfrom scipy import optimize\nimport matplotlib.pylab as plt\n\n# Initial guess x^0\nx = [(-8, -2)] \nh = 1E-07\ntolerance = 1E-03\n\n# Example function\ndef F(x1, x2):\n    return (x1 ** 2) + 5 * (x2 ** 2)\n\n\ndef gradient(x1, x2):\n    ix1 = (F(x1 + h, x2) - F(x1, x2)) / h\n    ix2 = (F(x1, x2 + h) - F(x1, x2)) / h\n    dF = (ix1, ix2)\n    return dF\n\n\ndef searchDirection(gradient):\n    sd = (-gradient[0], -gradient[1])\n    return sd\n\n\ndef stepSize(x):\n    res = optimize.line_search(lambda z: F(z[0], z[1]), lambda t: gradient(t[0], t[1]), np.array(x), np.array(sd), gr)\n    alpha = res[0]\n    return alpha\n\n\ndef makeStep(x, alpha, sd):\n    step = x + np.multiply(alpha, sd)\n    return step[0], step[1]\n\n\ndef checkTolerance(x1, x2):\n    return True if np.abs(x1) < tolerance or np.abs(x2) < tolerance else False\n\n\ni = 0\nwhile True:\n    currentX = x[i]\n    gr = gradient(currentX[0], currentX[1])\n    sd = searchDirection(gr)\n    alpha = stepSize(currentX)\n    newX = makeStep(currentX, alpha, sd)\n    if checkTolerance(newX[0], newX[1]):\n        break\n    else:\n        x.append(newX)\n        i += 1\n\npoints = np.array(x)\n\nfig = plt.Figure()\nfig, ax = plt.subplots()\nax.set_aspect(1)\nx1, x2, y1, y2 = plt.axis()\nplt.axis((-8, 8, -2, 2))\nax.plot(points[:, 0], points[:, 1], ""bo-"", label=r""gradient descent"")\n\nxc = np.linspace(-10, 10, 100)\nyc = np.linspace(-5, 5, 100)\nXC, YC = np.meshgrid(xc, yc)\nlevels = np.arange(-40, 40, 4)\nplt.contour(XC, YC, F(XC,YC), levels)\nax.legend(loc=1)\n\nplt.show()'"
scientific/jakobi_method.py,9,"b'#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\n\n# Implementation of sparse matrices. Alternatively can use scipy.sparse function\nclass SparseMatrix:\n    ""Sparse matrix in triple storage format.""\n\n    def __init__(self, m, n, nnz):\n        """"""Sparse matrix\n        @arg m: number of rows\n        @arg n: number of columns\n        @arg nnz: number of non-zero elements""""""\n\n        self.m = m\n        self.n = n\n        self.nnz = nnz\n        self.irows = np.zeros(nnz, dtype=int)\n        self.icols = np.zeros(nnz, dtype=int)\n        self.vals = np.zeros(nnz, dtype=float)\n\n    def __str__(self):\n        ""String representation of the matrix.""\n        vs = []\n        for i in xrange(self.nnz):\n            vs.append(""%d %d %.15f"" % (self.irows[i], self.icols[i], self.vals[i]))\n        vs_str = ""\\n"".join(vs)\n        return ""%d x %d nnz=%d\\n%s"" % (self.m, self.n, self.nnz, vs_str)\n\n    def __mul__(self, vec):\n        """"""Matrix vector multiplication.\n        @arg vec: NumPy vector\n        """"""\n        y = np.zeros(vec.shape, dtype=float)\n        for k in range(0, self.nnz):\n            i = self.irows[k]\n            j = self.icols[k]\n            v = self.vals[k]\n            y[i] += vec[j] * v\n\n        return y\n\n    def __getitem__(self, (i, j)):\n        for k in range(self.nnz):\n            if self.irows[k] == i and self.icols[k] == j:\n                return self.vals[k]\n        return 0.0\n\n\ndef as_sparse_matrix(matrix, m, n, nnz):\n    ""Create sparse matrix from NumPy matrix.""\n    A = SparseMatrix(m, n, nnz)\n    A.irows = [];\n    A.icols = [];\n    A.vals = [];\n    for i in range(len(matrix)):\n        for j in range(len(matrix)):\n            if matrix[i, j] != 0:\n                A.irows.append(i)\n                A.icols.append(j)\n                A.vals.append(matrix[i, j])\n\n    return A\n\n\t\ndef countnnz(A):\n    count = 0\n    for i in range(len(A)):\n        for j in range(len(A)):\n            if A[i, j] != 0:\n                count += 1\n    return count\n\n# Solves the system of linear equations using Jacobi method\ndef jakobi(S, b):\n    x = np.zeros(shape=(len(b), 1))\n    x_next = np.zeros(shape=(len(b), 1))\n    tol = 1E-6\n    E = tol + 1\n    max_iter = 1000\n    iter_count = 0\n    while E > tol and iter_count < max_iter:\n        E = np.sqrt(np.sum((b - S * x) ** 2))\n        print ""Iter: {}"".format(iter_count)\n        print ""E: {}"".format(E)\n\n        for i in range(S.m):\n            sum = 0.0\n            for j in range(S.n):\n                if i != j:\n                    sum = x[j] * S[i, j]\n                    x_next[i] = 1.0 / S[i, i] * (b[i] - sum)\n        x[:] = x_next\n        iter_count += 1\n\n    return x\n\t\n\n# Example matrix\nA = np.matrix([[2, -1, 0], [-1, 2, -1], [0, -1, 2]], dtype=float)\nb = np.array([[1], [2], [3]], dtype=float)\n\nprint ""A: {}"".format(A)\nprint ""b: {}"".format(b)\n\nS = as_sparse_matrix(A, len(A), len(A), countnnz(A))\nprint ""S: {}"".format(S)\n\nx = jakobi(S, b)\nprint ""x: {}"".format(x)'"
scientific/laplace_1d_generate.py,4,"b'#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\nimport matplotlib.pylab as plt\n\nN = 10\n\n# Generates 1D Laplace matrix using Dirichlet boundary conditions\ndef generate_1D(N):\n    L = np.zeros(shape=((N - 1), (N - 1)))\n    for i in range(0, N - 1):       # rows\n        for j in range(0, N - 1):   # columns\n            L[i, j] = 0.0\n            if i == j:\n                L[i, j] = 2.0\n            if i + 1 == j or j + 1 == i:\n                L[i, j] = -1\n    return L\n\n\nL = generate_1D(N)\nb = np.random.randn(N - 1)\nx = np.linalg.solve(L, b)\n\npoints = [x[i - 1] for i in range(1, (len(x) + 1))]\npoints.append(0)\ninterval = np.linspace(0.0, 1.0, num=N)\n\nfig = plt.Figure()\nfig, ax = plt.subplots()\nax.plot(interval, points, ""bo-"")\nplt.show()'"
scientific/laplace_2d_generate.py,6,"b'#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\nimport matplotlib.pylab as plt\nfrom mpl_toolkits.mplot3d import Axes3D\nimport time\n\nstart = time.time()\nN = 10\nm = (N - 1) * (N - 1)\n\n# Generates 2D Laplace matrix using Dirichlet boundary conditions\ndef generate_2D(N):\n    L = np.zeros(shape=((N - 1) * (N - 1), (N - 1) * (N - 1)))\n    for i in range(0, m):       # rows\n        for j in range(0, m):   # columns\n            L[i, j] = 0.0\n            if i == j:\n                L[i, j] = 4.0\n            if i + 1 == j or j + 1 == i or i + 3 == j or j + 3 == i:\n                L[i, j] = -1.0\n    return L\n\nL = generate_2D(N)\nb = np.random.randn(m)\nx = np.linalg.solve(L, b)\nx.shape = (N - 1, N - 1)\nelapsed = (time.time() - start)\nprint(""Elapsed: {}"".format(elapsed))\n\nspace = np.linspace(0,1, N + 1)\nfig = plt.Figure()\naxes1 = plt.subplot(2, 2, 1, projection=""3d"")\nxx, yy = np.meshgrid(space, space)\nvalues = np.zeros(shape=(N + 1,N + 1))\n\nfor i in range(1, N):\n    for j in range(1, N):\n        values[i,j] = x[i - 1, j - 1]\n\nplt.contour(xx, yy, values)\nplt.show()'"
scientific/lu_factorization.py,2,"b""#!/usr/local/bin/python\n# coding=utf-8\n\nimport numpy as np\n\n# Example matrix\nA = np.matrix([[3, 1, 2], [0, -2, -2], [1, 5, 3]], dtype=float)\nX = np.matrix([[0, 0, 0], [0, 0, 0], [0, 0, 0]], dtype=float)\n\n# LU factorization of matrix A\ndef LU(A):\n    n = len(A)\n    A1 = A.copy()\n    M = A.copy()\n    LU = A.copy()\n    U = X.copy()\n    L = X.copy()\n\n    for k in range(0, n - 1):\n        # stop in case pivot = 0\n        if A[k, k] == 0:\n            return 0\n        for i in range(k + 1, n):\n            # coefficient calculation in column i\n            M[i, k] = A1[i, k] / A1[k, k]\n            LU[i, k] = M[i, k]\n            L[i, k] = LU[i, k]\n        for j in range(k + 1, n):\n            # applying transformations to the rest of the matrix\n            for i in range(k + 1, n):\n                A1[i, j] = A1[i, j] - M[i, k] * A1[k, j]\n                LU[i, j] = A1[i, j]\n\n    for i in range(0, n):\n        for j in range(0, n):\n            if i <= j:\n                U[i, j] = LU[i, j]\n\n    for i in range(len(L)):\n        L[i, i] = 1\n    return LU, U, L\n\nfactorization = LU(A)\nU = factorization[1]\nL = factorization[2]\n\nprint('LU', factorization[0])\nprint('L', factorization[2])\nprint('U', factorization[1])"""
