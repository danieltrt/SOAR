file_path,api_count,code
setup.py,0,"b'import os\nimport re\nimport sys\nimport platform\nimport subprocess\n\nfrom setuptools import setup, find_packages, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom distutils.version import LooseVersion\n\n\nclass CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=\'\'):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\n\n\nclass CMakeBuild(build_ext):\n    def run(self):\n        try:\n            out = subprocess.check_output([\'cmake\', \'--version\'])\n        except OSError:\n            raise RuntimeError(\n                ""CMake must be installed to build the following extensions: "" +\n                "", "".join(e.name for e in self.extensions))\n\n        if platform.system() == ""Windows"":\n            cmake_version = LooseVersion(\n                re.search(r\'version\\s*([\\d.]+)\', out.decode()).group(1))\n            if cmake_version < \'3.1.0\':\n                raise RuntimeError(""CMake >= 3.1.0 is required on Windows"")\n\n        for ext in self.extensions:\n            self.build_extension(ext)\n\n    def build_extension(self, ext):\n        extdir = os.path.abspath(\n            os.path.dirname(self.get_ext_fullpath(ext.name)))\n        cmake_args = [\n            \'-DCMAKE_LIBRARY_OUTPUT_DIRECTORY=\' + extdir,\n            \'-DPYTHON_EXECUTABLE=\' + sys.executable\n        ]\n\n        cfg = \'Debug\' if self.debug else \'Release\'\n        build_args = [\'--config\', cfg]\n\n        if platform.system() == ""Windows"":\n            cmake_args += [\n                \'-DCMAKE_LIBRARY_OUTPUT_DIRECTORY_{}={}\'.format(cfg.upper(),\n                                                                extdir)\n            ]\n            # if sys.maxsize > 2**32:\n            #     cmake_args += [\'-A\', \'x64\']\n            # build_args += [\'--\', \'/m\']\n        elif platform.system() == ""Darwin"":\n            cmake_args += [\'-DCMAKE_BUILD_TYPE=\' + cfg]\n            cmake_args += [\'-DCMAKE_CXX_COMPILER=clang++\']\n        else:\n            cmake_args += [\'-DCMAKE_BUILD_TYPE=\' + cfg]\n            cmake_args += [\'-DCMAKE_CXX_COMPILER=g++\']\n            build_args += [\'--\', \'-j8\']\n\n        env = os.environ.copy()\n        env[\'CXXFLAGS\'] = \'{} -DVERSION_INFO=\\\\""{}\\\\""\'.format(\n            env.get(\'CXXFLAGS\', \'\'), self.distribution.get_version())\n        if not os.path.exists(self.build_temp):\n            os.makedirs(self.build_temp)\n        subprocess.check_call(\n            [\'cmake\', ext.sourcedir] + cmake_args,\n            cwd=self.build_temp,\n            env=env)\n        subprocess.check_call(\n            [\'cmake\', \'--build\', \'.\'] + build_args, cwd=self.build_temp)\n\n\nsetup(\n    name=\'pyversor\',\n    version=\'0.0.1\',\n    author=\'Lars Tingelstad\',\n    author_email=\'lars.tingelstad@ntnu.no\',\n    description=\'Python bindings for the Versor Geometric Algebra\',\n    long_description=\'\',\n    packages=find_packages(exclude=[\'tests\']),\n    ext_modules=[CMakeExtension(\'__pyversor__\')],\n    cmdclass=dict(build_ext=CMakeBuild),\n    zip_safe=False, )\n'"
pyversor/__init__.py,0,b'from . import e3d\nfrom . import e41\nfrom . import c3d\nfrom . import c2d\nfrom . import sta\nfrom . import visuals\n'
tests/test.py,0,"b'import sys\nsys.path.append(\'build\')\nimport numpy.random as rnd\n\nimport pyversor\nprint(dir(pyversor))\n\na = pyversor.cga.round.null(pyversor.ega.Vector(1,2,3))\nprint(a)\n\nfrom pyversor import ega, cga\n# from pyversor.cga.round import null\n\na = ega.Vector(1,2,3)\nprint(a)\n\nB = a.undual()\nprint(B)\n\nR = 1 + B\nprint(R)\n\nprint(R.grade(2))\n\na = ega.Bivector(1,2,3)\nR = 1.0 + a\n\nprint(R)\n\ns = R.grade(0)\nB = R.grade(2)\n\nprint(s)\nprint(B)\n\nprint(R.grade(3))\n\nprint(""Conformal"")\na = cga.Vector(*rnd.randn(5))\nprint(a)\n\nap = a.spin(R)\nprint(a)\n\na = ega.Multivector(*rnd.randn(8))\n\nb = ega.Multivector(a)\nprint(a)\nprint(b)\n\nprint(""Projected"")\nprint(ega.Rotator(b))\n\n\nprint(cga.round.null(ega.Vector(1,2,3)))\n\na = cga.Vector(*rnd.randn(5))\nprint(a)\nprint(cga.round.radius(a))\nprint(cga.round.radius(a.undual()))\n\nprint(cga.round.null(a))\nprint(cga.round.radius(cga.round.null(a)))'"
tests/test_visuals.py,5,"b'import sys\nsys.path.append(\'build\')\n\nimport numpy as np\nimport numpy.random as rnd\n\n\nimport zmq\nimport random\nimport sys\nimport time\n\nimport pickle\n\nfrom pyversor_ import ega, cga\nfrom pyversor_.cga.round import null\n\nimport datetime\n\nfrom vispy import io\nfrom vispy import scene, visuals\nfrom vispy.gloo.util import _screenshot as screenshot\nfrom vispy.visuals.transforms import MatrixTransform, STTransform\n\nega.Vector(1,2,3).dual()\n\ncanvas = scene.SceneCanvas(keys=\'interactive\', bgcolor=\'white\',\n                           size=(1920,1080), show=True, dpi=1000)\n\nview = canvas.central_widget.add_view()\nview.camera = \'arcball\'\n\nEllipse3D = scene.visuals.create_visual_node(visuals.EllipseVisual)\ncircle_visual = Ellipse3D([0,0,0], radius=2.5, border_color=\'r\', color=(0,0,0,0.5))\n\nobjects = []\n\n\n\na = cga.construct.sphere(null(ega.Vector(0,0,0)), 0.5)\npos_a = cga.round.location(a)\npos_a = np.array(pos_a)[:3]\nb = cga.construct.sphere(null(ega.Vector(0,-0.75,0)), 0.5)\npos_b = cga.round.location(b)\npos_b = np.array(pos_b)[:3]\n\nprint(a ^ 3.0)\nprint(5.0 ^ a)\n\nm = cga.generate.exp(cga.DualLine(*rnd.randn(6)))\nprint(a)\nprint(a.spin(m))\n\n# InfiniteLine3D = scene.visuals.create_visual_node(visuals.InfiniteLineVisual)\n# InfiniteLine3D(pos = 1, parent=view.scene, color=(1,0,0,1))\n\n\ncircle = cga.construct.meet(a,b)\n\n\npos = cga.round.location(circle)\npos = np.array(pos)[:3]\naa = cga.operate.axis_angle(circle)\naa = np.array(aa)\nradius = cga.round.radius(circle)\n\ncircle_visual = Ellipse3D([0,0,0], radius=radius, parent=view.scene, border_color=\'r\', color=(0,0,0,0))\n# circle_visual.border.method = \'agg\'\n# circle_visual.border.set_data(width=2)\n\nm = MatrixTransform()\nm.rotate(aa[0], aa[1:])\nm.translate(pos)\n\ncircle_visual.transform = m\n\nm = MatrixTransform()\nm.rotate(45, [1,0,0])\nm.translate([1,2,3])\n\n# print(m.matrix.T)\n\nsphere1 = scene.visuals.Sphere(radius=cga.round.radius(a), method=\'latitude\', parent=view.scene, color=(0.1,0.2,0.3,1),\n                               edge_color=None)\n\nsphere1.transform = STTransform(translate=pos_a)\n\nsphere2 = scene.visuals.Sphere(radius=cga.round.radius(b), method=\'latitude\', parent=view.scene,  color=(0.3,0.2,0.1,1),\n                               edge_color=None)\nsphere2.transform = STTransform(translate=pos_b)\n\n# sphere3 = scene.visuals.Sphere(radius=radius(c), rows=10, cols=10, depth=10,\n#                                method=\'cube\', parent=view.scene,\n#                                edge_color=\'black\')\n\nbase = scene.visuals.XYZAxis(parent=view.scene)\n# frame = scene.visuals.XYZAxis(parent=view.scene, antialias=True)\n# frame.transform = m\n\n\n# view.camera.set_range(x=[-3, 3])\n\n# im = screenshot((0,0,canvas.size[0], canvas.size[1]))\n# im = np.array(im)\n\n# Add some text instructions\n# text = scene.visuals.Text(""Drag right mouse button to zoom."", \n#                           color=\'b\',\n#                           anchor_x=\'left\',\n#                           parent=view,\n#                           pos=(20, 30))\n# # im[:, :, 3] = 255\n# print(im)\n\n\n# import threading\n# def worker():\n#     port = ""5556""\n#     context = zmq.Context()\n#     socket = context.socket(zmq.PAIR)\n#     socket.bind(""tcp://*:%s"" % port)\n#     while True:\n#         socket.send_string(""Server message to client3"")\n#         msg = socket.recv()\n#         a = pickle.loads(msg)\n#         print(a)\n#         time.sleep(1)\n\n# thread = threading.Thread(target=worker)\n# thread.start()\n\ndef on_key_press(event):\n    # modifiers = [key.name for key in event.modifiers]\n    # print(\'Key pressed - text: %r, key: %s, modifiers: %r\' % (\n    #     event.text, event.key.name, modifiers))\n    if event.key.name == \'A\':\n        # print(dir(view.scene))\n        print(view.scene.children)\n        objects.append(Ellipse3D([0,0,0], parent=view.scene, radius=2.5, border_color=\'r\', color=(0,0,0,0.5)))\n    if event.key.name == \'S\':\n        filename = \'{}-pyversor-screenshot.png\'.format(datetime.datetime.now().isoformat())\n        screenshot = canvas.render()\n        io.write_png(filename, screenshot)\n        print(\'Saved screenshot with filename: {}\'.format(filename))\n\ncanvas.connect(on_key_press)\n\n\nif __name__ == \'__main__\' and sys.flags.interactive == 0:\n    canvas.app.run()\n'"
pyversor/c2d/__init__.py,0,b'from __pyversor__.c2d import *\n'
pyversor/c3d/__init__.py,0,"b'from __pyversor__.c3d import (\n    Vector,\n    Bivector,\n    Trivector,\n    Quadvector,\n    Infinity,\n    Origin,\n    Pseudoscalar,\n    Multivector\n)\n\nfrom . import generate\nfrom . import operate\nfrom . import construct\nfrom . import flats\nfrom . import rounds\nfrom . import directions\nfrom . import tangents\nfrom . import versors\n\n\nni = Infinity(1.0)\nno = Origin(1.0)\n\nI = Pseudoscalar(1.0)\n'"
pyversor/c3d/construct.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations to construct geometric objects in 3D conformal geometric algebra.""""""\nfrom __pyversor__.c3d.construct import *\n'"
pyversor/c3d/directions.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on directions in 3D conformal geometric algebra.""""""\nfrom __pyversor__.c3d.directions import (\n    DirectionVector, DirectionBivector, DirectionTrivector)\n'"
pyversor/c3d/flats.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on flat geometric objects in 3D conformal geometric algebra.""""""\n\nfrom __pyversor__.c3d.flats import (\n    DualLine, Line, DualPlane, Plane, FlatPoint)\n'"
pyversor/c3d/generate.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Lie algebra generators and operations in 3D conformal geometric algebra.""""""\nfrom __pyversor__.c3d.generate import *\n'"
pyversor/c3d/operate.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on multivectors in 3D conformal geometric algebra.""""""\nfrom __pyversor__.c3d.operate import *\n'"
pyversor/c3d/rounds.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on rounds in 3D conformal geometric algebra.""""""\n\nfrom __pyversor__.c3d.tangents import (\n    TangentVector, TangentBivector, TangentTrivector)\n\n\nfrom __pyversor__.c3d.rounds import (carrier, center, curvature,\n                                     direction, distance, location,\n                                     normalize, null, produce, radius,\n                                     renormalize, size, split,\n                                     split_location, squared_distance,\n                                     surround)\n\n\nfrom .import Vector as DualSphere\nfrom .import Bivector as PointPair\nfrom .import Trivector as Circle\nfrom .import Quadvector as Sphere\n\n\n__round_types = [DualSphere, PointPair, Circle, Sphere]\n\nPointPair.carrier = lambda self: carrier(self)\nCircle.carrier = lambda self: carrier(self)\nPointPair.direction = lambda self: direction(self)\nCircle.direction = lambda self: direction(self)\n\nDualSphere.distance = lambda self: distance(self)\nDualSphere.null = lambda self: null(self)\n\nfor round_type in __round_types:\n    round_type.center = lambda self: center(self)\n    round_type.curvature = lambda self: curvature(self)\n    round_type.location = lambda self: location(self)\n    round_type.normalize = lambda self: normalize(self)\n'"
pyversor/c3d/tangents.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on tangents in 3D conformal geometric algebra.""""""\n\nfrom __pyversor__.c3d.tangents import (\n    TangentVector, TangentBivector, TangentTrivector)\n'"
pyversor/c3d/versors.py,0,"b'# Copyright (c) 2015, Lars Tingelstad\n# All rights reserved.\n#\n# All rights reserved.\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# * Redistributions of source code must retain the above copyright notice, this\n#   list of conditions and the following disclaimer.\n#\n# * Redistributions in binary form must reproduce the above copyright notice,\n#   this list of conditions and the following disclaimer in the documentation\n#   and/or other materials provided with the distribution.\n#\n# * Neither the name of pyversor nor the names of its\n#   contributors may be used to endorse or promote products derived from\n#   this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n""""""Operations on versors in 3D conformal geometric algebra.""""""\n\nfrom __pyversor__.c3d.versors import (\n    Rotator,\n    Translator,\n    Motor,\n    ConformalRotor,\n    Boost\n)\n'"
pyversor/e3d/__init__.py,0,b'from __pyversor__.e3d import *\n'
pyversor/e41/__init__.py,0,b'from __pyversor__.e41 import *\n\n\n\n\n\n'
pyversor/sta/__init__.py,0,b'from __pyversor__.sta import *\n'
pyversor/visuals/__init__.py,0,b'from .gui import Gui\n'
pyversor/visuals/gui.py,1,"b'\nfrom vispy import app, io, scene, visuals\nfrom vispy.visuals.transforms import MatrixTransform, STTransform\n\nimport datetime\nimport time\nimport threading\nimport pickle\nimport zmq\n\nimport numpy as np\n\n# canvas = scene.SceneCanvas(keys=\'interactive\', bgcolor=\'white\',\n#                            size=(800, 600), show=True)\n\n# view = canvas.central_widget.add_view()\n# view.camera = \'arcball\'\n\n\n# Plot3D = scene.visuals.create_visual_node(visuals.LinePlotVisual)\n\n\n# def draw_sphere(msg):\n#     pos = msg[\'translation\']\n#     radius = msg[\'radius\']\n#     color = msg[\'color\']\n#     sphere = scene.visuals.Sphere(radius=radius, color=color)\n#     sphere.transform = STTransform(translate=pos)\n#     view.add(sphere)\n#     objects.append(sphere)\n\n# # def draw_line(msg):\n# #     pos = np.array([pos, [0, 0, 0]])\n# #     arrow = scene.visuals.Arrow()\n# #     arrow.set_data(pos=pos, color=color, arrows=pos)\n# #     view.add(arrow)\n# #     objects.append(arrow)\n\n\n# objects = []\n\n\n# def draw_scatter(points):\n#     scatter = scene.visuals.Markers()\n#     scatter.set_data(points, edge_color=None, face_color=(1, 1, 1, .5), size=5)\n#     view.add(scatter)\n#     objects.append(scatter)\n\n\n# def draw_path(msg):\n#     pos = msg[\'path\']\n#     print(pos.shape)\n#     color = msg[\'color\']\n#     path = Plot3D(pos, parent=view.scene)\n#     # path = Plot3D(pos, width=2.0, color=color,\n#     #               edge_color=\'w\', symbol=\'o\', face_color=(0.2, 0.2, 1, 0.8),\n#     #               parent=view.scene)\n#     objects.append(path)\n\n\n# def clear_view():\n#     global objects\n#     for obj in objects:\n#         obj.parent = None\n#     objects = []\n\n\n# canvas.connect(on_key_press)\n\n\nclass Gui(scene.SceneCanvas):\n    def __init__(self, **kwargs):\n        scene.SceneCanvas.__init__(\n            self, title=\'pyversor\', keys=\'interactive\', bgcolor=\'white\', size=(800, 600), show=True)\n\n        self.unfreeze()\n\n        self.view = self.central_widget.add_view()\n        self.view.camera = \'turntable\'\n\n        self._worker_thread = threading.Thread(target=self.worker)\n        self._worker_thread.daemon = True\n        self._worker_thread.start()\n\n        self._base_frame = scene.visuals.XYZAxis()\n\n        self._objects = []\n\n        self.freeze()\n\n    def clear_view(self):\n        for obj in self._objects:\n            obj.parent = None\n        objects = []\n\n    def on_key_press(self, event):\n        if event.key.name == \'S\':\n            filename = \'{}-pyversor-screenshot.png\'.format(\n                datetime.datetime.now().isoformat())\n            screenshot = self.render()\n            io.write_png(filename, screenshot)\n            print(\'Saved screenshot with filename: {}\'.format(filename))\n        elif event.key.name == \'C\':\n            self.clear_view()\n        elif event.key.name == \'F\':\n            # Toggle base frame\n            if self._base_frame.parent is None:\n                self._base_frame.parent = self.view.scene\n            else:\n                self._base_frame.parent = None\n\n    def worker(self):\n        global objects\n        port = ""5556""\n        context = zmq.Context()\n        socket = context.socket(zmq.PAIR)\n        # socket.bind(""tcp://127.0.0.1:%s"" % port)\n        socket.bind(""tcp://*:%s"" % port)\n\n        while True:\n            print(""waiting"")\n            data = socket.recv()\n            msg = pickle.loads(data)\n            type_ = msg[\'type\']\n            if msg[\'clear\']:\n                clear_view()\n            if type_ == \'sphere\':\n                draw_sphere(msg)\n            elif type_ == \'path\':\n                print(\'got path\')\n                draw_path(msg)\n\n\nif __name__ == \'__main__\':\n    canvas = Gui()\n\n    app.run()\n'"
