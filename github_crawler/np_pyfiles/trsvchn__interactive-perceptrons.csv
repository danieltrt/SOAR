file_path,api_count,code
perceptrons.py,10,"b'import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.cm as cm\nfrom ipywidgets import fixed, interactive\nfrom IPython.display import display\n\n##########################################\n# CONFIGS\n##########################################\n\nPARAM_RANGE = (-10.0, 10.0)  # range value for weights and biases\nRESOLUTION = 100  # number of points for surface plot (a kind of resolution)\nX1_RANGE = [-0.25, 1.25]  # axis range\nX2_RANGE = [-0.25, 1.25]  # axis range\nFIGURE_PARAMS = {\'num\': None,\n                 \'figsize\': (5, 5),\n                 \'dpi\': 100,\n                 \'facecolor\': \'w\',\n                 \'edgecolor\': None,\n                 }\nMAIN_TITLE = {\'fontsize\': \'xx-large\',\n              \'ha\': \'center\',\n              }\nCORRECT_COLOR = \'g\'\nWRONG_COLOR = \'r\'\nZEROS_COLOR = \'r\'\nONES_COLOR = \'b\'\nLEVELS = np.linspace(0, 1, 3)  # number of colormap levels\nCMAP = cm.RdBu  # color mapp; other candidates: bwr_r seismic_r\nPOINT_SIZE = 200  # size of the test points\nEDGECOLORS = \'w\'  # test points edge color (white)\nTITLE = {\'color\': \'w\',\n         \'fontsize\': \'large\',\n         \'verticalalignment\': \'top\',\n         }\nWRONG = \'Don\\\'t Give Up! You Can Do It!\'  # title for wrong solution\nCORRECT = \'Nice! You Did It!\'  # title for correct solution\nXTICKS = [0, 1]  # ticks for x axis\nYTICKS = [0, 1]  # ticks for y axis\n# titles, x test values and y ground truth values used for perceptrons:\nANDCONFIG = [\'ANDPerceptron\', [(0, 0), (0, 1), (1, 0), (1, 1)], [0, 0, 0, 1]]\nORCONFIG = [\'ORPerceptron\', [(0, 0), (0, 1), (1, 0), (1, 1)], [0, 1, 1, 1]]\nNOTCONFIG = [\'NOTPerceptron\', [(0, 0), (0, 1), (1, 0), (1, 1)], [1, 0, 1, 0]]\nXORCONFIG = [\'XORPerceptron\', [(0, 0), (0, 1), (1, 0), (1, 1)], [0, 1, 1, 0]]\nXOR2CONFIG = [\'XOR2LayerPerceptron\', XORCONFIG[1], XORCONFIG[2]]\n\n##########################################\n# All the functional stuff starts here\n##########################################\n\n\ndef heaviside(z):\n    """"""Heaviside step function.""""""\n    a = np.where(z >= 0, 1, 0)\n    return a\n\n\ndef neuron(x, w, b, activation=heaviside):\n    """"""Simple forward propagation: linear + heaviside (by default).\n    Inputs:\n    x: input;\n    w: weights;\n    b: bias;\n    activation: activation function (default: heaviside).\n    """"""\n    return activation(x @ w.T + b)\n\n\ndef transform():\n    """"""Prepares input data for neuron.""""""\n    X1 = np.linspace(X1_RANGE[0], X1_RANGE[1], RESOLUTION)\n    X2 = np.linspace(X2_RANGE[0], X2_RANGE[1], RESOLUTION)\n    XX1, XX2 = np.meshgrid(X1, X2)\n    X = np.dstack([XX1, XX2])\n    return X\n\n\ndef plot_results(x, yhat):\n    """"""Simply plots the results.\n    Inputs:\n    x: input;\n    yhat: predicted values of y""""""\n    plt.contourf(x[:, :, 0], x[:, :, 1], yhat, cmap=CMAP, levels=LEVELS)\n\n\ndef plot_test_points(x, y, wb, mlp=False) -> None:\n    """"""Plots test points, showing the required solution (result).\n    Inputs:\n    x: input;\n    y: ground truth values;\n    wb: list of weights and bias(es);\n    mlp: type of propagation (default: single neuron).\n    """"""\n    gt = list()\n    for i, j in zip(x, y):\n        gt_i = int(neuron(i, wb[0], wb[1])) if not mlp else int(propagate_mlp(i, wb))\n        gt.append(gt_i)\n        c = ONES_COLOR if j else ZEROS_COLOR\n        plt.scatter([i[0]], [i[1]], s=POINT_SIZE, edgecolors=EDGECOLORS, c=c)\n\n    result, c = (CORRECT, CORRECT_COLOR) if (gt == y) else (WRONG, WRONG_COLOR)\n    TITLE[\'label\'] = f\'{result}\'  # sets the corrct title\n    TITLE[\'backgroundcolor\'] = c  # sets the right title color\n    plt.title(**TITLE)\n\n\ndef prepare_plot(t: str) -> None:\n    """"""Sets title, init fig, sets ticks and axis limits.\n    Inputs:\n    t: plot title.\n    """"""\n    # set the plot title\n    MAIN_TITLE[\'t\'] = f\'  {t}\'\n    # prepare figure\n    plt.figure(**FIGURE_PARAMS)\n    plt.suptitle(**MAIN_TITLE)\n    # add ticks\n    plt.xticks(XTICKS)\n    plt.yticks(YTICKS)\n    # set the axis limits\n    plt.xlim(X1_RANGE)\n    plt.ylim(X2_RANGE)\n\n\ndef plot(x, y, weight1, weight2, bias):\n    """"""Propagates and plots the results for the simple neuron.\n    Inputs:\n    x: input;\n    y: ground truth values;\n    weight[], bias: weights and bias of the neuron.\n    """"""\n    w = np.array([weight1, weight2])\n    X = transform()\n    yhat = neuron(X, w, bias)\n\n    plot_results(X, yhat)\n    plot_test_points(x, y, [w, bias])\n\n\ndef run(t, x, y, weight1=PARAM_RANGE, weight2=PARAM_RANGE, bias=PARAM_RANGE):\n    """"""This function will be interactive.\n    Inputs:\n    t: main title;\n    x: input;\n    y: ground truth values;\n    weight[], bias: weights and bias of the neuron.\n    """"""\n    prepare_plot(t)\n    plot(x, y, weight1, weight2, bias)\n\n\ndef perceptron(t: str, x, y, **kwargs):\n    """"""Base function for single neuron perceptrons. Returns ipython widget.\n    Inputs:\n    t: main title;\n    x: input;\n    y: ground truth values.\n    """"""\n    return interactive(run, t=fixed(t), x=fixed(x), y=fixed(y), **kwargs)\n\n\ndef propagate_mlp(x, wb: list):\n    """"""Forward propagation for 2LayerPerceptron.\n    Inputs:\n    x: input;\n    wb: weights and biases values.\n    """"""\n    l1n1 = neuron(x, wb[0], wb[1])  # Layer 1 Neuron 1\n    l1n2 = neuron(x, wb[2], wb[3])  # Layer 1 Neuron 2\n    l1 = np.dstack([l1n1, l1n2])  # Layer 1 output\n    l2 = neuron(l1, wb[4], wb[5])  # Layer 2 output\n    return l2\n\n\ndef plot_mlp(x, y, wb: list):\n    """"""Propagates and plot the mlp results.\n    Inputs:\n    x: input;\n    y: ground truth values;\n    wb: weights and biases values.\n    """"""\n    X = transform()\n    yhat = propagate_mlp(X, wb)\n    plot_results(X, yhat)\n    plot_test_points(x, y, wb, mlp=True)\n\n\ndef run_mlp(t,\n            x,\n            y,\n            l1n1_w1=PARAM_RANGE,\n            l1n1_w2=PARAM_RANGE,\n            l1n1_b=PARAM_RANGE,\n            l1n2_w1=PARAM_RANGE,\n            l1n2_w2=PARAM_RANGE,\n            l1n2_b=PARAM_RANGE,\n            l2_w1=PARAM_RANGE,\n            l2_w2=PARAM_RANGE,\n            l2_b=PARAM_RANGE):\n    """"""This function will be interactive.""""""\n    l1n1_W, l1n2_W = np.array([l1n1_w1, l1n1_w2]), np.array([l1n2_w1, l1n2_w2])\n    l2_W = np.array([l2_w1, l2_w2])\n    wb = [l1n1_W, l1n1_b, l1n2_W, l1n2_b, l2_W, l2_b]\n\n    prepare_plot(t)\n    plot_mlp(x, y, wb)\n\n\ndef mlp(t, x, y, **kwargs):\n    """"""Base function for interactive MLPs.""""""\n    return interactive(run_mlp, t=fixed(t), x=fixed(x), y=fixed(y), **kwargs)\n\n\n##########################################\n# Here\'s final functions for export :)\n##########################################\n\n\ndef and_perceptron():\n    """"""Interactive AND Perceptron.""""""\n    display(perceptron(*ANDCONFIG))\n\n\ndef or_perceptron():\n    """"""Interactive OR Perceptron.""""""\n    display(perceptron(*ORCONFIG))\n\n\ndef not_perceptron():\n    """"""Interactive NOT Perceptron.""""""\n    display(perceptron(*NOTCONFIG, weight1=(0, 0)))\n\n\ndef xor_perceptron():\n    """"""Unsolvable Interactive XOR Perceptron.""""""\n    display(perceptron(*XORCONFIG))\n\n\ndef xor_mlp():\n    """"""Interactive XOR 2-Layer Perceptron.""""""\n    display(mlp(*XOR2CONFIG))\n'"
