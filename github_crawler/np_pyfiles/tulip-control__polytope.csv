file_path,api_count,code
run_tests.py,0,"b'#!/usr/bin/env python\n""""""\nDriver script for testing polytope package.  Try calling it with ""-h"" flag.\n\nThis script was originally copied from one by the same name in\nTuLiP (http://tulip-control.org).\n""""""\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nimport imp\nimport sys\nimport os.path\n\nimport nose\n\n\nif __name__ == ""__main__"":\n    if (""-h"" in sys.argv) or (""--help"" in sys.argv):\n        print(""""""Usage: run_tests.py [OPTIONS...] [[-]TESTFILES...]\n\n    TESTFILES... is space-separated list of test file names, where the suffix\n    ""_test.py"" is added to each given name.  E.g.,\n\n      run_tests.py gr1cint\n\n    causes the gr1cint_test.py file to be used and no others.  If no arguments\n    are given, then default is to run all tests.  If TESTFILES... each have a\n    prefix of ""-"", then all tests *except* those listed will be run.  Besides\n    what is below, OPTIONS... are passed on to nose.\n\n    --fast           exclude tests that are marked as slow\n    --cover          generate a coverage report\n    --outofsource    import polytope from outside the current directory\n    --where=DIR      search for tests in directory DIR; default is ""tests""\n                     (this is exactly the ""-w"" or ""--where"" option of nose)"""""")\n        exit(1)\n\n    if ""--fast"" in sys.argv:\n        skip_slow = True\n        sys.argv.remove(""--fast"")\n    else:\n        skip_slow = False\n\n    if ""--cover"" in sys.argv:\n        measure_coverage = True\n        sys.argv.remove(""--cover"")\n    else:\n        measure_coverage = False\n\n    if ""--outofsource"" in sys.argv:\n        require_nonlocaldir_polytope = True\n        sys.argv.remove(""--outofsource"")\n    else:\n        require_nonlocaldir_polytope = False\n\n    # Try to find test directory among command-line arguments\n    given_tests_dir = False\n    for i in range(len(sys.argv[1:])):\n        if sys.argv[i+1] == ""-w"":\n            given_tests_dir = True\n            tests_dir = sys.argv[i+2]\n            break\n        if sys.argv[i+1].startswith(""--where=""):\n            given_tests_dir = True\n            tests_dir = sys.argv[i+1][len(""--where=""):]\n            break\n    if not given_tests_dir:\n        tests_dir = ""tests""\n\n    if require_nonlocaldir_polytope:\n        # Scrub local directory from search path for modules\n        import os\n        try:\n            while True:\n                sys.path.remove("""")\n        except ValueError:\n            pass\n        try:\n            while True:\n                sys.path.remove(os.path.abspath(os.curdir))\n        except ValueError:\n            pass\n    try:\n        modtuple = imp.find_module(""polytope"", sys.path)\n        imp.load_module(""polytope"", *modtuple)\n    except ImportError:\n        if require_nonlocaldir_polytope:\n            raise ImportError(\n                ""polytope package not found, ""\n                ""besides in the local directory"")\n        else:\n            raise\n\n    argv = [""nosetests""]\n    if skip_slow:\n        argv.append(""--attr=!slow"")\n    if measure_coverage:\n        argv.extend([\n            ""--with-coverage"",\n            ""--cover-html"",\n            ""--cover-package=polytope""])\n    testfiles = []\n    excludefiles = []\n    for basename in sys.argv[1:]:  # Only add extant file names\n        if os.path.exists(os.path.join(tests_dir, basename+""_test.py"")):\n            testfiles.append(basename+""_test.py"")\n        elif basename[0] == ""-"":\n            if os.path.exists(\n                    os.path.join(tests_dir, basename[1:]+""_test.py"")):\n                excludefiles.append(basename[1:]+""_test.py"")\n            else:\n                argv.append(basename)\n        else:\n            argv.append(basename)\n    if len(testfiles) > 0 and len(excludefiles) > 0:\n        print(""You can specify files to exclude or include, but not both."")\n        print(""Try calling it with \\""-h\\"" flag."")\n        exit(1)\n    if len(excludefiles) > 0:\n        argv.append(""--exclude=""+""|"".join(excludefiles))\n    argv.extend(testfiles)\n    if not given_tests_dir:\n        argv += [""--where=""+tests_dir]\n    nose.main(argv=argv+[""--verbosity=3"", ""--exe""])\n'"
setup.py,0,"b'#!/usr/bin/env python\n""""""Installation script.""""""\nfrom __future__ import absolute_import\nfrom __future__ import print_function\nfrom __future__ import unicode_literals\n\nimport imp\nimport os\nfrom setuptools import setup\nimport subprocess\n\n\nclassifiers = [\n    \'Development Status :: 2 - Pre-Alpha\',\n    \'Intended Audience :: Developers\',\n    \'Intended Audience :: Science/Research\',\n    \'License :: OSI Approved :: BSD License\',\n    \'Operating System :: OS Independent\',\n    \'Programming Language :: Python\',\n    \'Programming Language :: Python :: 2\',\n    \'Programming Language :: Python :: 2.7\',\n    \'Programming Language :: Python :: 3\',\n    \'Programming Language :: Python :: 3.4\',\n    \'Programming Language :: Python :: 3.5\',\n    \'Programming Language :: Python :: 3.6\',\n    \'Programming Language :: Python :: 3.7\',\n    \'Programming Language :: Python :: 3.8\',\n    \'Topic :: Scientific/Engineering\',\n    \'Topic :: Software Development\']\n\n\ndef retrieve_git_info():\n    """"""Return commit hash of HEAD, or ""release"", or None if failure.\n\n    If the git command fails, then return None.\n\n    If HEAD has tag with prefix ""vM"" where M is an integer, then\n    return \'release\'.\n    Tags with such names are regarded as version or release tags.\n\n    Otherwise, return the commit hash as str.\n    """"""\n    # Is Git installed?\n    try:\n        subprocess.call([\'git\', \'--version\'],\n                        stdout=subprocess.PIPE)\n    except OSError:\n        return None\n    # Decide whether this is a release\n    p = subprocess.Popen(\n        [\'git\', \'describe\', \'--tags\', \'--candidates=0\', \'HEAD\'],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT)\n    p.wait()\n    if p.returncode == 0:\n        tag = p.stdout.read().decode(\'utf-8\')\n        if len(tag) >= 2 and tag.startswith(\'v\'):\n            try:\n                int(tag[1])\n                return \'release\'\n            except ValueError:\n                pass\n    # Otherwise, return commit hash\n    p = subprocess.Popen(\n        [\'git\', \'log\', \'-1\', \'--format=%H\'],\n        stdout=subprocess.PIPE)\n    p.wait()\n    sha1 = p.stdout.read().decode(\'utf-8\')\n    return sha1\n\n\ndef run_setup():\n    """"""Get version from git, then install.""""""\n    # load long description from README.rst\n    readme_file = \'README.rst\'\n    if os.path.exists(readme_file):\n        long_description = open(readme_file).read()\n    else:\n        print(\'Could not find readme file to extract long_description.\')\n        long_description = \'\'\n    # If .git directory is present, create commit_hash.txt accordingly\n    # to indicate version information\n    if os.path.exists(\'.git\'):\n        # Provide commit hash or empty file to indicate release\n        sha1 = retrieve_git_info()\n        if sha1 is None:\n            sha1 = \'unknown-commit\'\n        elif sha1 == \'release\':\n            sha1 = \'\'\n        commit_hash_header = (\n            \'# DO NOT EDIT!  \'\n            \'This file was automatically generated by setup.py of polytope\')\n        with open(\'polytope/commit_hash.txt\', \'w\') as f:\n            f.write(commit_hash_header + \'\\n\')\n            f.write(sha1 + \'\\n\')\n    # Import polytope/version.py without importing polytope\n    version = imp.load_module(\'version\',\n                              *imp.find_module(\'version\', [\'polytope\']))\n    polytope_version = version.version\n    setup(\n        name=\'polytope\',\n        version=polytope_version,\n        description=\'Polytope Toolbox\',\n        long_description=long_description,\n        author=\'Caltech Control and Dynamical Systems\',\n        author_email=\'polytope@tulip-control.org\',\n        url=\'http://tulip-control.org\',\n        bugtrack_url=\'http://github.com/tulip-control/polytope/issues\',\n        license=\'BSD\',\n        setup_requires=[\'setuptools >= 23.0.0\'],\n        install_requires=[\n            \'numpy >= 1.10.0\',\n            \'scipy >= 0.18.0\',\n            \'networkx >= 1.6\'],\n        tests_require=[\n            \'nose\',\n            \'matplotlib >= 2.0.0\'],\n        packages=[\n            \'polytope\'],\n        package_dir=dict(polytope=\'polytope\'),\n        package_data=dict(polytope=[\'commit_hash.txt\']),\n        classifiers=classifiers)\n\n\nif __name__ == \'__main__\':\n    run_setup()\n'"
examples/randplot.py,1,"b'#!/usr/bin/env python\n""""""\nSample N points in the unit square, compute hull and plot.\n\n  Usage: randplot.py [N]\n\nThe default value of N is 3.  Note that plotting requires matplotlib\n(http://matplotlib.org), which is an optional dependency.\n""""""\nfrom __future__ import print_function\nimport sys\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport polytope\n\n\nif __name__ == ""__main__"":\n    if len(sys.argv) < 2:\n        N = 3\n    else:\n        N = int(sys.argv[1])\n\n    V = np.random.rand(N, 2)\n\n    print(""Sampled ""+str(N)+"" points:"")\n    print(V)\n\n    P = polytope.qhull(V)\n    print(""Computed the convex hull:"")\n    print(P)\n\n    V_min = polytope.extreme(P)\n    print(""which has extreme points:"")\n    print(V_min)\n\n    P.plot()\n    plt.show()\n'"
examples/timing_benchmarks.py,4,"b'""""""\nexecution time measurements for polytope package\n""""""\nimport os\nimport numpy as np\nimport polytope as pc\n\nif os.name is not \'posix\':\n    raise Exception(\'works only on POSIX operating systems\')\n\n# [0, 1] x [0, 1]\nA0 = np.array([\n    [0.0, 1.0],\n    [0.0, -1.0],\n    [1.0, 0.0],\n    [-1.0, 0.0]\n])\n\nb0 = np.array([[1.0, 0.0, 1.0, 0.0]])\n\n# [0, 0.5] x [0, 0.5]\nA1 = np.array([\n    [0.0, 2.0],\n    [0.0, -1.0],\n    [2.0, 0.0],\n    [-1.0, 0.0]\n])\n\nb1 = np.array([1.0, 0.0, 1.0, 0.0])\n\nN = 10**4\n\nprint(\'starting timing measurements...\')\n\n# instance creation\nstart = os.times()[4]\nfor i in range(N):\n    p0 = pc.Polytope(A0, b0)\n\nend = os.times()[4]\nprint(\'instantiation: \' + str(end - start))\n\n# intersection\np0 = pc.Polytope(A0, b0)\np1 = pc.Polytope(A1, b1)\n\nstart = os.times()[4]\nfor i in range(N):\n    union = p0.intersect(p1)\nend = os.times()[4]\nprint(\'intersection: \' + str(end - start))\n\nstart = os.times()[4]\nfor i in range(N):\n    union = p0.union(p1)\nend = os.times()[4]\nprint(\'union: \' + str(end - start))\n\nstart = os.times()[4]\nfor i in range(N):\n    union = p0.diff(p1)\nend = os.times()[4]\nprint(\'difference: \' + str(end - start))\n\nprint(\'end of timing measurements.\')\n'"
polytope/__init__.py,0,"b'# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n""""""Polytope package.""""""\nfrom __future__ import absolute_import\nfrom .version import version as __version__\n\nfrom .polytope import (\n    Polytope, Region,\n    is_empty, is_fulldim, is_convex, is_adjacent, is_subset,\n    reduce, separate, box2poly, grid_region,\n    cheby_ball, bounding_box, envelope, extreme, qhull,\n    is_inside, union, mldivide, intersect, volume, projection\n)\n# from .plot import plot_partition, plot_transition_arrow\nfrom .prop2partition import (\n    Partition, MetricPartition, find_adjacent_regions)\n'"
polytope/esp.py,144,"b'# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\nr""""""Equality Set Projection (ESP).\n\nNon-vertex polytope projection method from\n    http://www-control.eng.cam.ac.uk/~cnj22/research/projection.html\n\nVery unstable, can not handle complex polytopes.\n\n\nReference\n=========\n\n\\cite{Jones04}\n""""""\n# Created by P. Nilsson, 8/2/11\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport pickle\n\nimport numpy as np\nfrom scipy import io as sio\nfrom scipy import linalg\n\nfrom polytope import solvers\n\n\nclass Ridge(object):\n    """"""A ridge.\n\n    Attributes:\n\n    - `E_r`: Equality set of a facet\n\n    - `ar, br`: Affine hull of the facet\n      s.t. P_{E_0} = P intersection {x | ar x = br}.\n    """"""\n\n    def __init__(self, E, a, b):\n        self.E_r = E\n        self.ar = a\n        self.br = b\n\n\nclass Ridge_Facet(object):\n    """"""A ridge facet.\n\n    Attributes:\n\n        - `E_r`: Equality set of a ridge\n\n        - `ar,br`: Affine hull of the ridge s.t.\n            P_{E_f} intersection {x | ar x = br}\n            defines the ridge, where E_f is the\n            equality set of the facet.\n\n        - `E_0`: Equality set of a facet\n\n        - `af,bf`: Affine hull of the facet.\n    """"""\n\n    def __init__(self, E_r, ar, br, E_0, af, bf):\n        self.E_r = E_r\n        self.ar = ar\n        self.br = br\n        self.E_0 = E_0\n        self.af = af\n        self.bf = bf\n\n\ndef esp(CC, DD, bb, centered=False, abs_tol=1e-10, verbose=0):\n    """"""Project polytope [C D] x <= b onto C coordinates.\n\n    Projects the polytope [C D] x <= b onto the\n    coordinates that correspond to C. The projection of the polytope\n    P = {[C D]x <= b} where C is M x D and D is M x K is\n    defined as proj(P) = {x in R^d | exist y in R^k s.t Cx + Dy < b}\n    """"""\n    if \'glpk\' in solvers.installed_solvers:\n        raise Exception(\n            ""projection_esp error:""\n            "" Equality set projection requires `cvxopt.glpk` to run."")\n    # Remove zero columns and rows\n    nonzerorows = np.nonzero(\n        np.sum(np.abs(np.hstack([CC, DD])), axis=1) > abs_tol)[0]\n    nonzeroxcols = np.nonzero(np.sum(np.abs(CC), axis=0) > abs_tol)[0]\n    nonzeroycols = np.nonzero(np.sum(np.abs(DD), axis=0) > abs_tol)[0]\n    C = CC[nonzerorows, :].copy()\n    D = DD[nonzerorows, :].copy()\n    C = C[:, nonzeroxcols]\n    D = D[:, nonzeroycols]\n    b = bb[nonzerorows].copy()\n    # Make sure origo is inside polytope\n    if not centered:\n        xc0, yc0, trans = cheby_center(C, D, b)\n        if trans:\n            b = b - np.dot(C, xc0).flatten() - np.dot(D, yc0).flatten()\n        else:\n            b = b\n    else:\n        trans = False\n    d = C.shape[1]\n    k = D.shape[1]\n    if verbose > 0:\n        print(""Projecting from dim "" + str(d + k) + "" to "" + str(d))\n    if k == 0:\n        # Not projecting\n        return C, bb, []\n    if d == 1:\n        # Projection to 1D\n        c = np.zeros(d + k)\n        c[0] = 1\n        G = np.hstack([C, D])\n        sol = solvers.lpsolve(c, G, b, solver=\'glpk\')\n        if sol[\'status\'] != ""optimal"":\n            raise Exception(\n                ""esp: projection to 1D is not full-dimensional, ""\n                ""LP returned status "" + str(sol[\'status\']))\n        min_sol = np.array(sol[\'x\']).flatten()\n        min_dual_sol = np.array(sol[\'z\']).flatten()\n        sol = solvers.lpsolve(-c, G, b, solver=\'glpk\')\n        if sol[\'status\'] != ""optimal"":\n            raise Exception(\n                ""esp: projection to 1D is not full-dimensional, "" +\n                ""LP returned status "" + str(sol[\'status\']))\n        max_sol = np.array(sol[\'x\']).flatten()\n        max_dual_sol = np.array(sol[\'z\']).flatten()\n        # min, max\n        x_min = min_sol[0]\n        x_max = max_sol[0]\n        y_min = min_sol[range(1, k + 1)]\n        y_max = max_sol[range(1, k + 1)]\n        if is_dual_degenerate(c, G, b, None, None, min_sol, min_dual_sol):\n            # Min case, relax constraint a little to avoid infeasibility\n            E_min = unique_equalityset(\n                C, D, b, np.array([1.]), x_min + abs_tol / 3, abs_tol=abs_tol)\n        else:\n            E_min = np.nonzero(np.abs(np.dot(G, min_sol) - b) < abs_tol)[0]\n        if is_dual_degenerate(c, G, b, None, None, max_sol, max_dual_sol):\n            # Max case, relax constraint a little to avoid infeasibility\n            E_max = unique_equalityset(\n                C, D, b, np.array([1.]), x_max - abs_tol / 3, abs_tol=abs_tol)\n        else:\n            E_max = np.nonzero(np.abs(np.dot(G, max_sol) - b) < abs_tol)[0]\n        G = np.array([[1.], [-1.]])\n        g = np.array([x_max, -x_min])\n        # Relocate\n        if trans:\n            g = g + np.dot(G, xc0)\n        # Return zero cols/rows\n        E_max = nonzerorows[E_max]\n        E_min = nonzerorows[E_min]\n        if verbose > 0:\n            print(\n                ""Returning projection from dim "" +\n                str(d + k) + "" to dim 1 \\n"")\n        return G, g, [E_max, E_min]\n    E = []\n    L = []\n    E_0, af, bf = shoot(C, D, b, abs_tol=abs_tol)\n    ridge_list = ridge(C, D, b, E_0, af, bf, abs_tol=abs_tol, verbose=verbose)\n    for i in range(len(ridge_list)):\n        r = ridge_list[i]\n        L.append(Ridge_Facet(r.E_r, r.ar, r.br, E_0, af, bf))\n    G = af.T\n    g = bf\n    if verbose > 0:\n        print(""\\nStarting eq set "" + str(E_0) + ""\\nStarting ridges "")\n        for rr in L:\n            print(str(rr.E_r))\n    E.append(E_0)\n    while len(L) > 0:\n        rid_fac1 = L[0]\n        if verbose > 0:\n            print(""\\nLooking for neighbors to "" + str(rid_fac1.E_0) +\n                  "" and "" + str(rid_fac1.E_r) + "" .."")\n        E_adj, a_adj, b_adj = adjacent(C, D, b, rid_fac1, abs_tol=abs_tol)\n        if verbose > 0:\n            print(""found neighbor "" + str(E_adj) +\n                  "". \\n\\nLooking for ridges of neighbor.."")\n        ridge_list = ridge(\n            C, D, b, E_adj, a_adj, b_adj,\n            abs_tol=abs_tol, verbose=verbose)\n        if verbose > 0:\n            print(""found "" + str(len(ridge_list)) + "" ridges\\n"")\n        found_org = False\n        for i in range(len(ridge_list)):\n            r = ridge_list[i]\n            E_r = r.E_r\n            ar = r.ar\n            br = r.br\n            found = False\n            for j in range(len(L)):\n                rid_fac2 = L[j]\n                A_r = rid_fac2.E_r\n                if len(A_r) != len(E_r):\n                    continue\n                t1 = np.sort(np.array(A_r))\n                t2 = np.sort(np.array(E_r))\n                if np.sum(np.abs(t1 - t2)) < abs_tol:\n                    found = True\n                    break\n            if found:\n                if verbose > 0:\n                    print(""Ridge "" + str(E_r) +\n                          "" already visited, removing from L.."")\n                if rid_fac2 == rid_fac1:\n                    found_org = True\n                L.remove(rid_fac2)\n            else:\n                if verbose > 0:\n                    print(""Adding ridge-facet "" + str(E_adj) +\n                          "" "" + str(E_r) + """")\n                L.append(Ridge_Facet(E_r, ar, br, E_adj, a_adj, b_adj))\n        if not found_org:\n            print(""Expected ridge "" + str(rid_fac1.E_r))\n            print(""but got ridges "")\n            for rid in ridge_list:\n                print(rid.E_r)\n            raise Exception(\n                ""esp: ridge did not return neighboring ridge as expected"")\n        G = np.vstack([G, a_adj])\n        g = np.hstack([g, b_adj])\n        E.append(E_adj)\n    # Restore center\n    if trans:\n        g = g + np.dot(G, xc0)\n    # Return zero rows\n    for Ef in E:\n        Ef = nonzerorows[Ef]\n    return G, g, E\n\n\ndef shoot(C, D, b, maxiter=1000, abs_tol=1e-7):\n    """"""Return random equality set of P that projects on a projection facet.\n\n    Returns randomly selected equality set E_0 of P such\n    that the projection of the equality set is a facet of the projection.\n\n    @param C: Matrix defining the polytope Cx+Dy <= b\n    @param D: Matrix defining the polytope Cx+Dy <= b\n    @param b: Vector defining the polytope Cx+Dy <= b\n\n    @return: `E_0,af,bf`: Equality set and affine hull\n    """"""\n    d = C.shape[1]\n    k = D.shape[1]\n    iter = 0\n    while True:\n        if iter > maxiter:\n            raise Exception(\n                ""shoot: could not find starting equality set"")\n        gamma = np.random.rand(d) - 0.5\n        c = np.zeros(k + 1)\n        c[0] = -1\n        G = np.hstack([np.array([np.dot(C, gamma)]).T, D])\n        sol = solvers.lpsolve(c, G, b, solver=\'glpk\')\n        opt_sol = np.array(sol[\'x\']).flatten()\n        opt_dual = np.array(sol[\'z\']).flatten()\n        r_opt = opt_sol[0]\n        y_opt = np.array(opt_sol[range(1, len(opt_sol))]).flatten()\n        x_opt = r_opt * gamma\n        E_0 = np.nonzero(\n            np.abs(np.dot(C, x_opt) + np.dot(D, y_opt) - b) < abs_tol)[0]\n        DE0 = D[E_0, :]\n        CE0 = C[E_0, :]\n        b0 = b[E_0]\n        if rank(np.dot(null_space(DE0.T).T, CE0)) == 1:\n            break\n        iter += 1\n    af, bf = proj_aff(CE0, DE0, b0, abs_tol=abs_tol)\n    if is_dual_degenerate(c, G, b, None, None, opt_sol,\n                          opt_dual, abs_tol=abs_tol):\n        E_0 = unique_equalityset(C, D, b, af, bf, abs_tol=abs_tol)\n    af, bf = proj_aff(C[E_0, :], D[E_0, :], b[E_0])\n    if len(bf) > 1:\n        raise Exception(""shoot: wrong dimension of affine hull"")\n    return E_0, af.flatten(), bf\n\n\ndef ridge(C, D, b, E, af, bf, abs_tol=1e-7, verbose=0):\n    """"""Compute all ridges of a facet in the projection.\n\n    Input:\n    `C,D,b`: Original polytope data\n    `E,af,bf`: Equality set and affine hull of a facet in the projection\n\n    Output:\n    `ridge_list`: A list containing all the ridges of\n        the facet as Ridge objects\n    """"""\n    d = C.shape[1]\n    k = D.shape[1]\n    Er_list = []\n    q = C.shape[0]\n    E_c = np.setdiff1d(range(q), E)\n    # E slices\n    C_E = C[E, :]\n    D_E = D[E, :]\n    b_E = b[E, :]\n    # E_c slices\n    C_Ec = C[E_c, :]\n    D_Ec = D[E_c, :]\n    b_Ec = b[E_c]\n    # dots\n    S = C_Ec - np.dot(np.dot(D_Ec, linalg.pinv(D_E)), C_E)\n    L = np.dot(D_Ec, null_space(D_E))\n    t = b_Ec - np.dot(D_Ec, np.dot(linalg.pinv(D_E), b_E))\n    if rank(np.hstack([C_E, D_E])) < k + 1:\n        if verbose > 1:\n            print(""Doing recursive ESP call"")\n        u, s, v = linalg.svd(np.array([af]), full_matrices=1)\n        sigma = s[0]\n        v = v.T * u[0, 0]  # Correct sign\n        V_hat = v[:, [0]]\n        V_tilde = v[:, range(1, v.shape[1])]\n        Cnew = np.dot(S, V_tilde)\n        Dnew = L\n        bnew = t - np.dot(S, V_hat).flatten() * bf / sigma\n        Anew = np.hstack([Cnew, Dnew])\n        xc2, yc2, cen2 = cheby_center(Cnew, Dnew, bnew)\n        bnew = bnew - np.dot(Cnew, xc2).flatten() - np.dot(Dnew, yc2).flatten()\n        Gt, gt, E_t = esp(\n            Cnew, Dnew, bnew,\n            centered=True, abs_tol=abs_tol, verbose=0)\n        if (len(E_t[0]) == 0) or (len(E_t[1]) == 0):\n            raise Exception(\n                ""ridge: recursive call did not return any equality sets"")\n        for i in range(len(E_t)):\n            E_f = E_t[i]\n            er = np.sort(np.hstack([E, E_c[E_f]]))\n            ar = np.dot(Gt[i, :], V_tilde.T).flatten()\n            br0 = gt[i].flatten()\n            # Make orthogonal to facet\n            ar = ar - af * np.dot(af.flatten(), ar.flatten())\n            br = br0 - bf * np.dot(af.flatten(), ar.flatten())\n            # Normalize and make ridge equation point outwards\n            norm = np.sqrt(np.sum(ar * ar))\n            ar = ar * np.sign(br) / norm\n            br = br * np.sign(br) / norm\n            # Restore center\n            br = br + np.dot(Gt[i, :], xc2) / norm\n            if len(ar) > d:\n                raise Exception(""ridge: wrong length of new ridge!"")\n            Er_list.append(Ridge(er, ar, br))\n    else:\n        if verbose > 0:\n            print(""Doing direct calculation of ridges"")\n        X = np.arange(S.shape[0])\n        while len(X) > 0:\n            i = X[0]\n            X = np.setdiff1d(X, i)\n            if np.linalg.norm(S[i, :]) < abs_tol:\n                continue\n            Si = S[i, :]\n            Si = Si / np.linalg.norm(Si)\n            if np.linalg.norm(af - np.dot(Si, af) * Si) > abs_tol:\n                test1 = null_space(\n                    np.vstack([\n                        np.hstack([af, bf]),\n                        np.hstack([S[i, :], t[i]])]),\n                    nonempty=True)\n                test2 = np.hstack([S, np.array([t]).T])\n                test = np.dot(test1.T, test2.T)\n                test = np.sum(np.abs(test), 0)\n                Q_i = np.nonzero(test > abs_tol)[0]\n                Q = np.nonzero(test < abs_tol)[0]\n                X = np.setdiff1d(X, Q)\n                # Have Q_i\n                Sq = S[Q_i, :]\n                tq = t[Q_i]\n                c = np.zeros(d + 1)\n                c[0] = 1\n                Gup = np.hstack([-np.ones([Sq.shape[0], 1]), Sq])\n                Gdo = np.hstack([-1, np.zeros(Sq.shape[1])])\n                G = np.vstack([Gup, Gdo])\n                h = np.hstack([tq, 1])\n                Al = np.zeros([2, 1])\n                Ar = np.vstack([af, S[i, :]])\n                A = np.hstack([Al, Ar])\n                bb = np.hstack([bf, t[i]])\n                sol = solvers._solve_lp_using_cvxopt(\n                    c, G, h, A=A, b=bb)\n                if sol[\'status\'] == \'optimal\':\n                    tau = sol[\'x\'][0]\n                    if tau < -abs_tol:\n                        ar = np.array([S[i, :]]).flatten()\n                        br = t[i].flatten()\n                        # Make orthogonal to facet\n                        ar = ar - af * np.dot(af.flatten(), ar.flatten())\n                        br = br - bf * np.dot(af.flatten(), ar.flatten())\n                        # Normalize and make ridge equation point outwards\n                        norm = np.sqrt(np.sum(ar * ar))\n                        ar = ar / norm\n                        br = br / norm\n                        # accumulate\n                        Er_list.append(\n                            Ridge(np.sort(np.hstack([E, E_c[Q]])), ar, br))\n    return Er_list\n\n\ndef adjacent(C, D, b, rid_fac, abs_tol=1e-7):\n    """"""Compute the (unique) adjacent facet.\n\n    @param rid_fac: A Ridge_Facet object containing the parameters for\n        a facet and one of its ridges.\n\n    @return: (E_adj,a_adj,b_adj): The equality set and parameters for\n        the adjacent facet such that::\n\n            P_{E_adj} = P intersection {x | a_adj x = b_adj}\n    """"""\n    E = rid_fac.E_0\n    af = rid_fac.af\n    bf = rid_fac.bf\n    #\n    E_r = rid_fac.E_r\n    ar = rid_fac.ar\n    br = rid_fac.br\n    # shape\n    d = C.shape[1]\n    k = D.shape[1]\n    # E_r slices\n    C_er = C[E_r, :]\n    D_er = D[E_r, :]\n    b_er = b[E_r]\n    # stack\n    c = -np.hstack([ar, np.zeros(k)])\n    G = np.hstack([C_er, D_er])\n    h = b_er\n    A = np.hstack([af, np.zeros(k)])\n    sol = solvers._solve_lp_using_cvxopt(\n        c, G, h, A=A.T, b=bf * (1 - 0.01))\n    if sol[\'status\'] != ""optimal"":\n        print(G)\n        print(h)\n        print(af)\n        print(bf)\n        print(ar)\n        print(br)\n        print(np.dot(af, ar))\n        data = {}\n        data[""C""] = C\n        data[""D""] = D\n        data[""b""] = b\n        sio.savemat(""matlabdata"", data)\n        pickle.dump(data, open(""polytope.p"", ""wb""))\n        raise Exception(\n            ""adjacent: Lp returned status "" + str(sol[\'status\']))\n    opt_sol = np.array(sol[\'x\']).flatten()\n    dual_opt_sol = np.array(sol[\'z\']).flatten()\n    x_opt = opt_sol[range(0, d)]\n    y_opt = opt_sol[range(d, d + k)]\n    if is_dual_degenerate(\n            c.flatten(), G, h, A, bf * (1 - 0.01),\n            opt_sol, dual_opt_sol, abs_tol=abs_tol):\n        # If degenerate, compute affine hull and take preimage\n        E_temp = np.nonzero(np.abs(np.dot(G, opt_sol) - h) < abs_tol)[0]\n        a_temp, b_temp = proj_aff(\n            C_er[E_temp, :], D_er[E_temp, :], b_er[E_temp],\n            expected_dim=1, abs_tol=abs_tol)\n        E_adj = unique_equalityset(C, D, b, a_temp, b_temp, abs_tol=abs_tol)\n        if len(E_adj) == 0:\n            data = {}\n            data[""C""] = C\n            data[""D""] = D\n            data[""b""] = b\n            data[""Er""] = E_r + 1\n            data[""ar""] = ar\n            data[""br""] = br\n            data[""Ef""] = E + 1\n            data[""af""] = af\n            data[""bf""] = bf\n            sio.savemat(""matlabdata"", data)\n            raise Exception(\n                ""adjacent: equality set computation returned empty set"")\n    else:\n        r = np.abs(np.dot(C, x_opt) + np.dot(D, y_opt) - b) < abs_tol\n        E_adj = np.nonzero(r)[0]\n    C_eadj = C[E_adj, :]\n    D_eadj = D[E_adj, :]\n    b_eadj = b[E_adj]\n    af_adj, bf_adj = proj_aff(C_eadj, D_eadj, b_eadj, abs_tol=abs_tol)\n    return E_adj, af_adj, bf_adj\n\n\ndef proj_aff(Ce, De, be, expected_dim=None, abs_tol=1e-7):\n    """"""Affine projection.\n\n    Compute the set aff = {x | Ce x + De y = be} on the form\n    aff = ({x | a x = b} intersection {Ce x + De y < be}).\n\n    Input: Polytope parameters Ce, De and be\n\n    Output: Constants a and b\n    """"""\n    # Remove zero columns\n    ind = np.nonzero(np.sum(np.abs(De), axis=0) > abs_tol)[0]\n    D = De[:, ind]\n    if D.shape[1] == 0:\n        a = Ce\n        b = be\n        a_n, b_n = normalize(a, b)\n        if expected_dim is not None:\n            if expected_dim != b_n.size:\n                raise Exception(\n                    ""proj_aff: wrong dimension calculated in 1"")\n        return a_n.flatten(), b_n\n    sh = np.shape(D.T)\n    m = sh[0]\n    n = sh[1]\n    nDe = null_space(D.T)\n    a = np.dot(nDe.T, Ce)\n    b = np.dot(nDe.T, be)\n    a_n, b_n = normalize(a, b)\n    if expected_dim is not None:\n        if expected_dim != b_n.size:\n            raise Exception(""proj_aff: wrong dimension calculated in 2"")\n    return a_n, b_n\n\n\ndef is_dual_degenerate(c, G, h, A, b, x_opt, z_opt, abs_tol=1e-7):\n    """"""Return `True` if pair of dual problems is dual degenerate.\n\n    Checks if the pair of dual problems::\n\n      (P): min c\'x        (D): max h\'z + b\'y\n           s.t Gx <= h         s.t G\'z + A\'y = c\n               Ax = b                z <= 0\n\n    is dual degenerate, i.e. if (P) has several optimal solutions.\n    Optimal solutions x* and z* are required.\n\n    Input:\n\n    `G,h,A,b`: Parameters of (P)\n    `x_opt`: One optimal solution to (P)\n    `z_opt`: The optimal solution to (D) corresponding to\n        _inequality constraints_ in (P)\n\n    Output:\n    `dual`: Boolean indicating whether (P) has many optimal solutions.\n    """"""\n    D = - G\n    d = - h.flatten()\n    mu = - z_opt.flatten()  # mu >= 0\n    # Active constraints\n    I = np.nonzero(np.abs(np.dot(D, x_opt).flatten() - d) < abs_tol)[0]\n    # Positive elements in dual opt\n    J = np.nonzero(mu > abs_tol)[0]\n    # i, j\n    i = mu < abs_tol  # Zero elements in dual opt\n    i = i.astype(int)\n    j = np.zeros(len(mu), dtype=int)\n    j[I] = 1  # 1 if active\n    # Indices where active constraints have 0 dual opt\n    L = np.nonzero(i + j == 2)[0]\n    # sizes\n    nI = len(I)\n    nJ = len(J)\n    nL = len(L)\n    # constraints\n    DI = D[I, :]  # Active constraints\n    DJ = D[J, :]  # Constraints with positive lagrange mult\n    DL = D[L, :]  # Active constraints with zero dual opt\n    dual = 0\n    if A is None:\n        test = DI\n    else:\n        test = np.vstack([DI, A])\n    if rank(test) < np.amin(DI.shape):\n        return True\n    else:\n        if len(L) > 0:\n            if A is None:\n                Ae = DJ\n            else:\n                Ae = np.vstack([DJ, A])\n            be = np.zeros(Ae.shape[0])\n            Ai = - DL\n            bi = np.zeros(nL)\n            sol = solvers._solve_lp_using_cvxopt(\n                c= - np.sum(DL, axis=0), G=Ai,\n                h=bi, A=Ae, b=be)\n            if sol[\'status\'] == ""dual infeasible"":\n                # Dual infeasible -> primal unbounded -> value>epsilon\n                return True\n            if sol[\'primal objective\'] > abs_tol:\n                return True\n    return False\n\n\ndef unique_equalityset(C, D, b, af, bf, abs_tol=1e-7, verbose=0):\n    """"""Return equality set E with the following property:\n\n    P_E = {x | af x = bf} intersection P\n\n    where P is the polytope C x + D y < b\n\n    The inequalities have to be satisfied with equality everywhere on\n    the face defined by af and bf.\n    """"""\n    if D is not None:\n        A = np.hstack([C, D])\n        a = np.hstack([af, np.zeros(D.shape[1])])\n    else:\n        A = C\n        a = af\n    E = []\n    for i in range(A.shape[0]):\n        A_i = np.array(A[i, :])\n        b_i = b[i]\n        sol = solvers._solve_lp_using_cvxopt(\n            c=A_i, G=A, h=b,\n            A=a.T, b=bf)\n        if sol[\'status\'] != ""optimal"":\n            raise Exception(\n                ""unique_equalityset: LP returned status "" +\n                str(sol[\'status\']))\n        if np.abs(sol[\'primal objective\'] - b_i) < abs_tol:\n            # Constraint is active everywhere\n            E.append(i)\n    if len(E) == 0:\n        raise Exception(""unique_equalityset: empty E"")\n    return np.array(E)\n\n\ndef unique_equalityset2(C, D, b, opt_sol, abs_tol=1e-7):\n    A = np.hstack([C, D])\n    E0 = np.nonzero(np.abs(np.dot(A, opt_sol) - b) < abs_tol)[0]\n    af, bf = proj_aff(C[E0, :], D[E0, :], b[E0], expected_dim=1)\n    # stack\n    ineq = np.hstack([af, np.zeros(D.shape[1])])\n    G = np.vstack([A, np.vstack([ineq, -ineq])])\n    h = np.hstack([b, np.hstack([bf, -bf])])\n    # shape\n    m = G.shape[0]\n    n = G.shape[1]\n    # ht\n    e = 1e-3\n    v = np.vstack([np.zeros([1, n]), np.eye(n)]).T\n    v = v - np.array([np.mean(v, axis=1)]).T\n    v = v * e\n    ht = h + np.amin(-np.dot(G, v), axis=1)\n    # stack\n    H1 = np.hstack([G, -np.eye(m)])\n    H2 = np.hstack([G, np.zeros([m, m])])\n    H3 = np.hstack([np.zeros([m, n]), -np.eye(m)])\n    H = np.vstack([H1, np.vstack([H2, H3])])\n    h = np.hstack([ht, np.hstack([h, np.zeros(m)])])\n    c = np.hstack([np.zeros(n), np.ones(m)])\n    sol = solvers.lpsolve(c, H, h, solver=\'glpk\')\n    if not sol[\'status\'] == ""optimal"":\n        raise Exception(\n            ""unique_equalityset: LP returned status "" +\n            str(sol[\'status\']))\n    opt_sol2 = np.array(sol[\'x\']).flatten()\n    x = opt_sol2[range(0, n)]\n    s = opt_sol2[range(n, len(opt_sol2))]\n    E = np.nonzero(s > abs_tol)[0]\n    print(E)\n    E = np.sort(E[np.nonzero(E < C.shape[0])])\n    # Check that they define the same projection\n    at, bt = proj_aff(C[E, :], D[E, :], b[E])\n    if bt.size != 1 or np.sum(np.abs(at - af)) + np.abs(bt - bf) > abs_tol:\n        raise Exception(""unique_equalityset2: affine hulls not the same"")\n    return E\n\n\ndef cheby_center(C, D, b):\n    """"""Calculate Chebyshev center for the polytope `C x + D y <= b`.\n\n    Input:\n    `C, D, b`: Polytope parameters\n\n    Output:\n    `x_0, y_0`: The chebyshev centra\n    `boolean`: True if a point could be found, False otherwise.\n    """"""\n    d = C.shape[1]\n    k = D.shape[1]\n    A = np.hstack([C, D])\n    dim = np.shape(A)[1]\n    c = - np.r_[np.zeros(dim), 1]\n    norm2 = np.sqrt(np.sum(A * A, axis=1))\n    G = np.c_[A, norm2]\n    sol = solvers.lpsolve(c, G, h=b, solver=\'glpk\')\n    if sol[\'status\'] == ""optimal"":\n        opt = np.array(sol[\'x\'][0:-1]).flatten()\n        return opt[range(0, d)], opt[range(d, d + k)], True\n    else:\n        return np.zeros(d), np.zeros(k), False\n\n\ndef normalize(AA, bb, abs_tol=1e-7):\n    """"""Normalize `A x = b` such that `A\'A = 1` and `b > 0`.\n\n    Also, remove duplicate lines.\n    """"""\n    if AA.size == 0:\n        return AA, bb\n    dim = AA.size / bb.size\n    A = AA.copy().reshape(bb.size, dim)\n    b = bb.copy().reshape(bb.size, 1)\n    # Remove zero lines\n    keepind = np.nonzero(\n        np.sum(np.abs(np.hstack([A, b])), axis=1) > abs_tol)[0]\n    A = A[keepind, :]\n    b = b[keepind]\n    # Normalize\n    anorm = np.sqrt(np.sum(A * A, axis=1))\n    for i in range(len(anorm)):\n        A[i, :] = A[i, :] * np.sign(b[i, 0]) / anorm[i]\n        b[i, 0] = np.sign(b[i, 0]) * b[i, 0] / anorm[i]\n    # Remove duplicate rows\n    keep_row = []\n    for i in range(len(anorm)):\n        unique = True\n        for j in range(i + 1, len(anorm)):\n            test = np.sum(np.abs(A[i, :] - A[j, :])) + \\\n                np.abs(b[i, 0] - b[j, 0])\n            if test < abs_tol:\n                unique = False\n                break\n        if unique:\n            keep_row.append(i)\n    A_n = A[keep_row, :]\n    b_n = b[keep_row, 0]\n    # Return flat A if only one row\n    if A_n.size == dim:\n        A_n = A_n.flatten()\n    return A_n, b_n.flatten()\n\n\ndef rank(A, eps=1e-15):\n    u, s, vh = linalg.svd(A)\n    m = A.shape[0]\n    n = A.shape[1]\n    tol = np.amax([m, n]) * np.amax(s) * eps\n    return np.sum(s > tol)\n\n\ndef null_space(A, eps=1e-15, nonempty=False):\n    """"""Returns the null space N_A to matrix A such that A N_A = 0.""""""\n    u, s, v = linalg.svd(A, full_matrices=1)\n    m = A.shape[0]\n    n = A.shape[1]\n    tol = np.amax([m, n]) * np.amax(s) * eps\n    rank = np.sum(s > tol)\n    N_space = v[range(rank, n), :].T\n    if nonempty and (len(N_space) == 0):\n        N_space = v[range(np.amax(n - 1, 1), n), :]\n    return N_space\n'"
polytope/plot.py,5,"b'# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n""""""Functions for plotting Partitions.""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nimport logging\n\nimport numpy as np\nimport networkx as nx\n\nfrom . import polytope as pc\n# inline imports:\n#\n# import matplotlib as mpl\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef plot_partition(\n        ppp, trans=None, ppp2trans=None, only_adjacent=False,\n        ax=None, plot_numbers=True, color_seed=None):\n    """"""Plot partition with arrows from digraph.\n\n    For filtering edges based on label use L{plot_ts_on_partition}.\n\n    See Also\n    ========\n    L{abstract.prop2partition.PropPreservingPartition},\n    L{plot_trajectory}\n\n    @type ppp: L{PropPreservingPartition}\n\n    @param trans: Transition matrix. If used,\n        then transitions in C{ppp} are shown with arrows.\n        Otherwise C{ppp.adj} is plotted.\n\n        To show C{ppp.adj}, pass: trans = True\n\n    @param plot_numbers: If True,\n        then annotate each Region center with its number.\n\n    @param ax: axes where to plot\n\n    @param color_seed: seed for reproducible random coloring\n\n    @param ppp2trans: order mapping ppp indices to trans states\n    @type ppp2trans: list of trans states\n    """"""\n    import matplotlib as mpl\n    # needs to be converted to adjacency matrix ?\n    if isinstance(trans, nx.MultiDiGraph):\n        if trans is not None and ppp2trans is None:\n            msg = (\n                \'trans is a networkx MultiDiGraph, \'\n                \'so ppp2trans required to define state order,\\n\'\n                \'used when converting the graph to \'\n                \'an adjacency matrix.\')\n            raise Exception(msg)\n        trans = nx.to_numpy_matrix(trans, nodelist=ppp2trans)\n        trans = np.array(trans)\n    l, u = ppp.domain.bounding_box\n    arr_size = (u[0, 0] - l[0, 0]) / 50.0\n    ax = pc._newax(ax)\n    # no trans given: use partition\'s\n    if trans is True and ppp.adj is not None:\n        ax.set_title(\'Adjacency from Partition\')\n        trans = ppp.adj\n    elif trans is None:\n        trans = \'none\'\n    else:\n        ax.set_title(\'Adjacency from given Transitions\')\n    ax.set_xlim(l[0, 0], u[0, 0])\n    ax.set_ylim(l[1, 0], u[1, 0])\n    # repeatable coloring ?\n    if color_seed is not None:\n        prng = np.random.RandomState(color_seed)\n    else:\n        prng = np.random.RandomState()\n    # plot polytope patches\n    for i, reg in enumerate(ppp.regions):\n        # select random color,\n        # same color for all polytopes in each region\n        col = prng.rand(3)\n\n        # single polytope or region ?\n        reg.plot(color=col, ax=ax)\n        if plot_numbers:\n            reg.text(str(i), ax, color=\'black\')\n    # not show trans ?\n    if trans is \'none\':\n        mpl.pyplot.show()\n        return ax\n    # plot transition arrows between patches\n    rows, cols = np.nonzero(trans)\n    for i, j in zip(rows, cols):\n        # mask non-adjacent cell transitions ?\n        if only_adjacent:\n            if ppp.adj[i, j] == 0:\n                continue\n\n        plot_transition_arrow(\n            ppp.regions[i], ppp.regions[j], ax, arr_size)\n    mpl.pyplot.show()\n    return ax\n\n\ndef plot_transition_arrow(polyreg0, polyreg1, ax, arr_size=None):\n    """"""Plot arrow starting from polyreg0 and ending at polyreg1.\n\n    @type polyreg0: L{Polytope} or L{Region}\n    @type polyreg1: L{Polytope} or L{Region}\n    @param ax: axes where to plot\n\n    @return: arrow object\n    """"""\n    from matplotlib import patches\n    # brevity\n    p0 = polyreg0\n    p1 = polyreg1\n    rc0, xc0 = pc.cheby_ball(p0)\n    rc1, xc1 = pc.cheby_ball(p1)\n    if np.sum(np.abs(xc1 - xc0)) < 1e-7:\n        return None\n    if arr_size is None:\n        l, u = polyreg1.bounding_box\n        arr_size = (u[0, 0] - l[0, 0]) / 25.0\n    # TODO: 3d\n    x = xc0[0]\n    y = xc0[1]\n    dx = xc1[0] - xc0[0]\n    dy = xc1[1] - xc0[1]\n    arrow = patches.Arrow(\n        float(x), float(y), float(dx), float(dy),\n        width=arr_size, color=\'black\')\n    ax.add_patch(arrow)\n    return arrow\n'"
polytope/polytope.py,208,"b'# -*- coding: utf-8 -*-\n#\n# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n#\n#\n#  Acknowledgement:\n#  The overall structure of this library and the functions in the list\n#  below are taken with permission from:\n#\n#  M. Kvasnica, P. Grieder and M. Baoti\xc4\x87,\n#  Multi-Parametric Toolbox (MPT),\n#  http://control.ee.ethz.ch/~mpt/\n#\n#  mldivide\n#  region_diff\n#  extreme\n#  envelope\n#  is_convex\n#  bounding_box\n#  intersect2\n#  projection_interhull\n#  projection_exthull\n#\nr""""""Computational geometry module for polytope computations.\n\nFor linear programming the fastest installed solver is selected.\nTo change this choice, see the module `polytope.solvers`.\n\nThe structure of this module is based on \\cite{MPT04}.\n""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport warnings\n\nimport numpy as np\n\nfrom polytope.solvers import lpsolve\nfrom polytope.esp import esp\nfrom polytope.quickhull import quickhull\n\n\nlogger = logging.getLogger(__name__)\ntry:\n    xrange\nexcept NameError:\n    xrange = range\n\n# Nicer numpy output\nnp.set_printoptions(precision=5, suppress=True)\n\n# global default absolute tolerance,\n# to enable changing it code w/o passing arguments,\n# so that magic methods can still be used\nABS_TOL = 1e-7\n\n# inline imports:\n#\n# import matplotlib as mpl\n# from matplotlib import pyplot as plt\n\n\nclass Polytope(object):\n    """"""Polytope class with following fields\n\n      - `A`: a numpy array for the hyperplane normals in hyperplane\n             representation of a polytope\n      - `b`: a numpy array for the hyperplane offsets in hyperplane\n             representation of a polytope\n      - `chebXc`: coordinates of chebyshev center (if calculated)\n      - `chebR`: chebyshev radius (if calculated)\n      - `bbox`: bounding box (if calculated)\n      - `minrep`: if polytope is in minimal representation (after\n                  running reduce)\n      - `normalize`: if True (default), normalize given A and b arrays;\n                     else, use A and b without modification.\n      - `dim`: dimension\n      - `volume`: volume, computed on first call\n\n    See Also\n    ========\n    L{Region}\n    """"""\n\n    def __init__(\n            self, A=np.array([]), b=np.array([]), minrep=False,\n            chebR=0, chebX=None, fulldim=None,\n            volume=None, vertices=None, normalize=True):\n        self.A = A.astype(float)\n        self.b = b.astype(float).flatten()\n        if A.size > 0 and normalize:\n            # Normalize\n            Anorm = np.sqrt(np.sum(A * A, 1)).flatten()\n            pos = np.nonzero(Anorm > 1e-10)[0]\n            self.A = self.A[pos, :]\n            self.b = self.b[pos]\n            Anorm = Anorm[pos]\n            mult = 1 / Anorm\n            for i in xrange(self.A.shape[0]):\n                self.A[i, :] = self.A[i, :] * mult[i]\n            self.b = self.b.flatten() * mult\n        self.minrep = minrep\n        self._chebXc = chebX\n        self._chebR = chebR\n        self.bbox = None\n        self.fulldim = fulldim\n        self._volume = volume\n        self.vertices = vertices\n\n    def __str__(self):\n        """"""Return pretty-formatted H-representation of polytope.""""""\n        A, b = self.A, self.b\n        A_rows = str(A).split(\'\\n\')\n        n_rows = len(A_rows)\n        # column vector from `b`, if not already one\n        b_col = b.reshape(b.shape[0], 1) if len(b.shape) == 1 else b\n        b_rows = str(b_col).split(\'\\n\')\n        # place an ""x"" somewhere near the middle\n        x_row = int((n_rows - 1) / 2)  # where ""x"" is shown\n        above = x_row\n        below = (n_rows - x_row - 2)\n        spacer = \' |    \'\n        last_middle = [spacer[1:]] if n_rows > 1 else []\n        middle = (\n            above * [spacer]\n            + [\' x <= \']\n            + below * [spacer]\n            + last_middle)\n        assert len(middle) == n_rows, (middle, n_rows)\n        # format lines\n        lines = [A_rows[k] + middle[k] + b_rows[k]\n                 for k in range(n_rows)]\n        output = \'Single polytope \\n  {lines}\\n\'.format(\n            lines=\'\\n  \'.join(lines))\n        return output\n\n    def __len__(self):\n        return 0\n\n    def __copy__(self):\n        A = self.A.copy()\n        b = self.b.copy()\n        P = Polytope(A, b)\n        P._chebXc = self._chebXc\n        P._chebR = self._chebR\n        P.minrep = self.minrep\n        P.bbox = self.bbox\n        P.fulldim = self.fulldim\n        return P\n\n    def __contains__(self, point):\n        """"""Return `True` if `self` contains `point`.\n\n        Boundary points are included.\n\n        @param point: column vector, e.g., as `numpy.ndarray`\n        @rtype: bool\n\n        For multiple points, see the method `self.contains`.\n        """"""\n        if not isinstance(point, np.ndarray):\n            point = np.array(point)\n        test = self.A.dot(point.flatten()) - self.b < ABS_TOL\n        return np.all(test)\n\n    def contains(self, points, abs_tol=ABS_TOL):\n        """"""Return Boolean array of whether each point in `self`.\n\n        Any point that satisfies all inequalities is\n        contained in `self`. A tolerance is added, and\n        strict inequality checked (<). Pass `abs_tol=0`\n        to exclude the boundary.\n\n        @param points: column vectors\n        @rtype: bool, 1d array\n        """"""\n        test = self.A.dot(points) - self.b[:, np.newaxis] < abs_tol\n        return np.all(test, axis=0)\n\n    def __eq__(self, other):\n        return self <= other and other <= self\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __le__(self, other):\n        return is_subset(self, other)\n\n    def __ge__(self, other):\n        return is_subset(other, self)\n\n    def __bool__(self):\n        return bool(self.volume > 0)\n\n    __nonzero__ = __bool__\n\n    def union(self, other, check_convex=False):\n        """"""Return union with Polytope or Region.\n\n        For usage see function union.\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return union(self, other, check_convex)\n\n    def diff(self, other):\n        """"""Return set difference with Polytope or Region.\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return mldivide(self, other)\n\n    def intersect(self, other, abs_tol=ABS_TOL):\n        """"""Return intersection with Polytope or Region.\n\n        @type other: L{Polytope}.\n        @rtype: L{Polytope} or L{Region}\n        """"""\n        if isinstance(other, Region):\n            return other.intersect(self)\n        if not isinstance(other, Polytope):\n            msg = \'Polytope intersection defined only\'\n            msg += \' with other Polytope. Got instead: \'\n            msg += str(type(other))\n            raise Exception(msg)\n        if (not is_fulldim(self)) or (not is_fulldim(other)):\n            return Polytope()\n        if self.dim != other.dim:\n            raise Exception(""polytopes have different dimension"")\n        iA = np.vstack([self.A, other.A])\n        ib = np.hstack([self.b, other.b])\n\n        return reduce(Polytope(iA, ib), abs_tol=abs_tol)\n\n    def translation(self, d):\n        """"""Returns a copy of C{self} translated by the vector C{d}.\n\n        Consult L{polytope.polytope._translate} for implementation details.\n\n        @type d: 1d array\n        """"""\n        newpoly = self.copy()\n        _translate(newpoly, d)\n        return newpoly\n\n    def rotation(self, i=None, j=None, theta=None):\n        """"""Returns a rotated copy of C{self}.\n\n        Describe the plane of rotation and the angle of rotation (in radians)\n        with i, j, and theta.\n\n        i and j are the indices 0..N-1 of two of the identity basis\n        vectors, and theta is the angle of rotation.\n\n        Consult L{polytope.polytope._rotate} for more detail.\n\n        @type i: int\n        @type j: int\n        @type theta: number\n        """"""\n        newpoly = self.copy()\n        _rotate(newpoly, i=i, j=j, theta=theta)\n        return newpoly\n\n    def copy(self):\n        """"""Return copy of this Polytope.""""""\n        return self.__copy__()\n\n    @classmethod\n    def from_box(cls, intervals=[]):\n        """"""Class method for easy construction of hyperrectangles.\n\n        @param intervals: intervals [xi_min, xi_max],\n            the cross-product of which defines the polytope\n            as an N-dimensional hyperrectangle\n        @type intervals: [ndim x 2] numpy array or\n            list of lists::\n\n                [[x0_min, x0_max],\n                 [x1_min, x1_max],\n                 ...\n                 [xN_min, xN_max]]\n\n        @return: hyperrectangle defined by C{intervals}\n        @rtype: L{Polytope}\n        """"""\n        if not isinstance(intervals, np.ndarray):\n            try:\n                intervals = np.array(intervals)\n            except Exception:\n                raise Exception(\'Polytope.from_box:\' +\n                                \'intervals must be a numpy ndarray or \' +\n                                \'convertible as arg to numpy.array\')\n        if intervals.ndim != 2:\n            raise Exception(\'Polytope.from_box: \' +\n                            \'intervals must be 2 dimensional\')\n        n = intervals.shape\n        if n[1] != 2:\n            raise Exception(\'Polytope.from_box: \' +\n                            \'intervals must have 2 columns\')\n        n = n[0]\n        # a <= b for each interval ?\n        if (intervals[:, 0] > intervals[:, 1]).any():\n            msg = \'Polytope.from_box: \'\n            msg += \'Invalid interval in from_box method.\\n\'\n            msg += \'First element of an interval must\'\n            msg += \' not be larger than the second.\'\n            raise Exception(msg)\n        A = np.vstack([np.eye(n), -np.eye(n)])\n        b = np.hstack([intervals[:, 1], -intervals[:, 0]])\n\n        return cls(A, b, minrep=True)\n\n    def project(self, dim, solver=None,\n                abs_tol=ABS_TOL, verbose=0):\n        """"""Return Polytope projection on selected subspace.\n\n        For usage details see function: L{projection}.\n        """"""\n        return projection(self, dim, solver, abs_tol, verbose)\n\n    def scale(self, factor):\n        """"""Multiply polytope by scalar factor.\n\n        A x <= b, becomes: A x <= (factor * b)\n\n        @type factor: float\n        """"""\n        self.b = factor * self.b\n\n    @property\n    def dim(self):\n        """"""Return Polytope dimension.""""""\n        try:\n            return np.shape(self.A)[1]\n        except Exception:\n            return 0.0\n\n    @property\n    def volume(self):\n        if self._volume is None:\n            self._volume = volume(self)\n        return self._volume\n\n    @property\n    def chebR(self):\n        r, xc = cheby_ball(self)\n        return self._chebR\n\n    @property\n    def chebXc(self):\n        r, xc = cheby_ball(self)\n        return self._chebXc\n\n    @property\n    def cheby(self):\n        return cheby_ball(self)\n\n    @property\n    def bounding_box(self):\n        """"""Wrapper of L{polytope.bounding_box}.\n\n        Computes the bounding box on first call.\n        """"""\n        if self.bbox is None:\n            self.bbox = bounding_box(self)\n        return self.bbox\n\n    def plot(self, ax=None, color=None, hatch=None, alpha=1.0, linestyle=None, linewidth=None, edgecolor=None):\n        if self.dim != 2:\n            raise Exception(""Cannot plot polytopes of dimension larger than 2"")\n        \n        # Setting default values for plotting\n        linestyle = linestyle or ""dashed""\n        linewidth = linewidth or 3\n        edgecolor = edgecolor or ""black""\n        \n        ax = _newax(ax)\n        if not is_fulldim(self):\n            logger.error(""Cannot plot empty polytope"")\n            return None\n        if color is None:\n            color = np.random.rand(3)\n        poly = _get_patch(\n            self, facecolor=color, hatch=hatch,\n            alpha=alpha, linestyle=linestyle, linewidth=linewidth,\n            edgecolor=edgecolor)\n        ax.add_patch(poly)\n        return ax\n\n    def text(self, txt, ax=None, color=\'black\'):\n        """"""Plot text at chebyshev center.""""""\n        _plot_text(self, txt, ax, color)\n\n\ndef _translate(polyreg, d):\n    """"""Translate C{polyreg} by the vector C{d}. Modifies C{polyreg} in-place.\n\n    @type d: 1d array\n    """"""\n    if isinstance(polyreg, Polytope):\n        # Translate hyperplanes\n        polyreg.b = polyreg.b + np.dot(polyreg.A, d)\n    else:\n        # Translate subregions\n        for poly in polyreg.list_poly:\n            _translate(poly, d)\n    # Translate bbox and cheby\n    if polyreg.bbox is not None:\n        polyreg.bbox = (polyreg.bbox[0] + d,\n                        polyreg.bbox[1] + d)\n    if polyreg._chebXc is not None:\n        polyreg._chebXc = polyreg._chebXc + d\n\n\ndef _rotate(polyreg, i=None, j=None, u=None, v=None, theta=None, R=None):\n    """"""Rotate C{polyreg} in-place. Return the rotation matrix.\n\n    There are two types of rotation: simple and compound. For simple rotations,\n    by definition, all motion can be projected as circles in a single plane;\n    the other N - 2 dimensions are invariant. Therefore any simple rotation can\n    be parameterized by its plane of rotation. Compound rotations are the\n    combination of multiple simple rotations; they have more than one plane of\n    rotation. For N > 3 dimensions, a compound rotation may be necessary to map\n    one orientation to another (Euler\'s rotation theorem no longer applies).\n\n    Use one of the following three methods to specify rotation. The first two\n    can only express simple rotation, but simple rotations may be applied in a\n    sequence to achieve a compound rotation.\n\n    (1) Provide the indices 0..N-1 of the identity basis vectors, i and j,\n    which define the plane of rotation and a radian angle of rotation, theta,\n    between them. This method contructs the Givens rotation matrix. The right\n    hand rule defines the positive rotation direction.\n\n    (2) Provide two vectors, the two vectors define the plane of rotation\n    and angle of rotation is TWICE the angle from the first vector, u, to\n    the second vector, v.\n\n    (3) Provide an N-by-N rotation matrix, R. WARNING: No checks are made to\n    determine whether the provided transformation matrix is a valid rotation.\n\n    Further Reading\n    https://en.wikipedia.org/wiki/Plane_of_rotation\n\n    @param polyreg: The polytope or region to be rotated.\n    @type polyreg: L{Polytope} or L{Region}\n    @param i: The first index describing the plane of rotation.\n    @type i: int\n    @param j: The second index describing the plane of rotation.\n    @type j: int\n    @param u: The first vector describing the plane of rotation.\n    @type u: 1d array\n    @param u: The second vector describing the plane of rotation.\n    @type v: 1d array.\n    @param theta: The radian angle to rotate the polyreg in the plane defined\n                  by i and j.\n    @type theta: number\n    @param R: A predefined rotation matrix.\n    @type R: 2d array\n    """"""\n    # determine the rotation matrix based on inputs\n    if R is not None:\n        logger.debug(""rotate: R=\\n{}"".format(R))\n        assert i is None, i\n        assert j is None, j\n        assert theta is None, theta\n        assert u is None, u\n        assert v is None, v\n    elif i is not None and j is not None and theta is not None:\n        logger.info(""rotate via indices and angle."")\n        assert R is None, R\n        assert u is None, u\n        assert v is None, v\n        if i == j:\n            raise ValueError(""Must provide two unique basis vectors."")\n        R = givens_rotation_matrix(i, j, theta, polyreg.dim)\n    elif u is not None and v is not None:\n        logger.info(""rotate via 2 vectors."")\n        assert R is None, R\n        assert i is None, i\n        assert j is None, j\n        assert theta is None, theta\n        R = solve_rotation_ap(u, v)\n    else:\n        raise ValueError(""R or (i and j and theta) or (u and v) ""\n                         ""must be defined."")\n    if isinstance(polyreg, Polytope):\n        # Ensure that half space is normalized before rotation\n        n, p = _hessian_normal(polyreg.A, polyreg.b)\n        # Rotate the hyperplane normals\n        polyreg.A = np.inner(n, R)\n        polyreg.b = p\n    else:\n        # Rotate subregions\n        for poly in polyreg.list_poly:\n            _rotate(poly, None, None, R=R)\n    # transform bbox and cheby\n    if polyreg.bbox is not None:\n        polyreg.bbox = (np.inner(polyreg.bbox[0].T, R).T,\n                        np.inner(polyreg.bbox[1].T, R).T)\n    if polyreg._chebXc is not None:\n        polyreg._chebXc = np.inner(polyreg._chebXc, R)\n    return R\n\n\ndef givens_rotation_matrix(i, j, theta, N):\n    """"""Return the Givens rotation matrix for an N-dimensional space.""""""\n    R = np.identity(N)\n    c = np.cos(theta)\n    s = np.sin(theta)\n    R[i, i] = c\n    R[j, j] = c\n    R[i, j] = -s\n    R[j, i] = s\n    return R\n\n\ndef solve_rotation_ap(u, v):\n    r""""""Return the rotation matrix for the rotation in the plane defined by the\n    vectors u and v across TWICE the angle between u and v.\n\n    This algorithm uses the Aguilera-Perez Algorithm \\cite{Aguilera}\n    to generate the rotation matrix. The algorithm works basically as follows:\n\n    Starting with the Nth component of u, rotate u towards the (N-1)th\n    component until the Nth component is zero. Continue until u is parallel to\n    the 0th basis vector. Next do the same with v until it only has none zero\n    components in the first two dimensions. The result will be something like\n    this:\n\n    [[u0,  0, 0 ... 0],\n     [v0, v1, 0 ... 0]]\n\n    Now it is trivial to align u with v. Apply the inverse rotations to return\n    to the original orientation.\n\n    NOTE: The precision of this method is limited by sin, cos, and arctan\n    functions.\n    """"""\n    # TODO: Assert vectors are non-zero and non-parallel aka exterior\n    # product is non-zero\n    N = u.size  # the number of dimensions\n    uv = np.stack([u, v], axis=1)  # the plane of rotation\n    M = np.identity(N)  # stores the rotations for rorienting reference frame\n    # ensure u has positive basis0 component\n    if uv[0, 0] < 0:\n        M[0, 0] = -1\n        M[1, 1] = -1\n        uv = M.dot(uv)\n    # align uv plane with the basis01 plane and u with basis0.\n    for c in range(0, 2):\n        for r in range(N - 1, c, -1):\n            if uv[r, c] != 0:  # skip rotations when theta will be zero\n                theta = np.arctan2(uv[r, c], uv[r - 1, c])\n                Mk = givens_rotation_matrix(r, r - 1, theta, N)\n                uv = Mk.dot(uv)\n                M = Mk.dot(M)\n    # rotate u onto v\n    theta = 2 * np.arctan2(uv[1, 1], uv[0, 1])\n    logger.debug(\n        ""solve_rotation_ap: {d} degree rotation"".format(\n            d=180 * theta / np.pi))\n    R = givens_rotation_matrix(0, 1, theta, N)\n    # perform M rotations in reverse order\n    M_inverse = M.T\n    R = M_inverse.dot(R.dot(M))\n    return R\n\n\ndef _hessian_normal(A, b):\n    """"""Normalize half space representation according to hessian normal form.""""""\n    L2 = np.reshape(np.linalg.norm(A, axis=1), (-1, 1))  # needs to be column\n    if any(L2 == 0):\n        raise ValueError(\'One of the rows of A is a zero vector.\')\n    n = A / L2  # hyperplane normals\n    p = b / L2.flatten()  # hyperplane distances from origin\n    return n, p\n\n\nclass Region(object):\n    """"""Class for lists of convex polytopes\n\n    Contains the following fields:\n\n      - `list_poly`: list of Polytope objects\n      - `props`: set of propositions inside region\n      - `bbox`: if calculated, bounding box of region (see bounding_box)\n      - `fulldim`: if calculated, boolean indicating whether region is\n                   fully dimensional\n      - `dim`: dimension\n      - `volume`: volume of region, calculated on first call\n      - `chebXc`: coordinates of maximum chebyshev center (if calculated)\n      - `chebR`: maximum chebyshev radius (if calculated)\n\n    See Also\n    ========\n    L{Polytope}\n    """"""\n\n    def __init__(self, list_poly=None, props=None):\n        if list_poly is None:\n            list_poly = []\n        if props is None:\n            props = set()\n        if isinstance(list_poly, str):\n            # Hack to be able to use the Region class also for discrete\n            # problems.\n            self.list_poly = list_poly\n            self.props = set(props)\n        else:\n            if isinstance(list_poly, Region):\n                dim = list_poly[0].dim\n                for poly in list_poly:\n                    if poly.dim != dim:\n                        raise Exception(""Region error:""\n                                        "" Polytopes must be of same dimension!"")\n            self.list_poly = list_poly[:]\n            for poly in list_poly:\n                if is_empty(poly):\n                    self.list_poly.remove(poly)\n            self.props = set(props)\n            self.bbox = None\n            self.fulldim = None\n            self._volume = None\n            self._chebXc = None\n            self._chebR = None\n\n    def __iter__(self):\n        return iter(self.list_poly)\n\n    def __getitem__(self, key):\n        return self.list_poly[key]\n\n    def __str__(self):\n        output = \'\'\n        for i in xrange(len(self.list_poly)):\n            output += \'\\t Polytope number \' + str(i + 1) + \':\\n\'\n            poly_str = str(self.list_poly[i])\n            poly_str = poly_str.replace(\'\\n\', \'\\n\\t\\t\')\n            output += \'\\t \' + poly_str + \'\\n\'\n        output += \'\\n\'\n        return output\n\n    def __len__(self):\n        return len(self.list_poly)\n\n    def __contains__(self, point):\n        """"""Return `True` if `self` contains `point`.\n\n        See `Polytope.__contains__`.\n        """"""\n        if not isinstance(point, np.ndarray):\n            point = np.array(point)\n        return any(point in u for u in self.list_poly)\n\n    def contains(self, points, abs_tol=ABS_TOL):\n        """"""Return Boolean array of whether each point in `self`.\n\n        See `Polytope.contains`.\n        """"""\n        if not isinstance(points, np.ndarray):\n            points = np.array(points)\n        assert points.shape[0] == self.dim, \'points should be column vectors\'\n        contained = np.full(points.shape[1], False, dtype=bool)\n        for poly in self.list_poly:\n            contained = np.logical_or(\n                poly.contains(points, abs_tol),\n                contained)\n        return contained\n\n    def __eq__(self, other):\n        return self <= other and other <= self\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __le__(self, other):\n        return is_subset(self, other)\n\n    def __ge__(self, other):\n        return is_subset(other, self)\n\n    def __add__(self, other):\n        """"""Return union with Polytope or Region.\n\n        Applies convex simplification if possible.\n        To turn off this check,\n        use Region.union\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return union(self, other, check_convex=True)\n\n    def __bool__(self):\n        return bool(self.volume > 0)\n\n    __nonzero__ = __bool__\n\n    def union(self, other, check_convex=False):\n        """"""Return union with Polytope or Region.\n\n        For usage see function union.\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return union(self, other, check_convex)\n\n    def __sub__(self, other):\n        """"""Return set difference with Polytope or Region.\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return mldivide(self, other)\n\n    def diff(self, other):\n        """"""Return set difference with Polytope or Region.\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Region}\n        """"""\n        return mldivide(self, other)\n\n    def __and__(self, other):\n        """"""Return intersection with Polytope or Region.\n\n        Absolute tolerance 1e-7 used.\n        To select the absolute tolerance use\n        method Region.intersect\n\n        @type other: L{Polytope} or L{Region}\n        @rtype: L{Polytope} or L{Region}\n        """"""\n        return intersect(self, other)\n\n    def intersect(self, other, abs_tol=ABS_TOL):\n        """"""Return intersection with Polytope or Region.\n\n        @type other: iterable container of L{Polytope}.\n        @rtype: L{Region}\n        """"""\n        if isinstance(other, Polytope):\n            other = [other]\n        P = Region()\n        for poly0 in self:\n            for poly1 in other:\n                isect = poly0.intersect(poly1, abs_tol)\n                rp, xp = isect.cheby\n                if rp > abs_tol:\n                    P = union(P, isect, check_convex=True)\n        return P\n\n    def rotation(self, i=None, j=None, theta=None):\n        """"""Returns a rotated copy of C{self}.\n\n        Describe the plane of rotation and the angle of rotation (in radians)\n        with i, j, and theta.\n\n        i and j are the indices 0..N-1 of two of the identity basis\n        vectors, and theta is the angle of rotation.\n\n        Consult L{polytope.polytope._rotate} for more detail.\n\n        @type i: int\n        @type j: int\n        @type theta: number\n        """"""\n        newreg = self.copy()\n        _rotate(newreg, i=i, j=j, theta=theta)\n        return newreg\n\n    def translation(self, d):\n        """"""Returns a copy of C{self} translated by the vector C{d}.\n\n        Consult L{polytope.polytope._translate} for implementation details.\n\n        @type d: 1d array\n        """"""\n        newreg = self.copy()\n        _translate(newreg, d)\n        return newreg\n\n    def __copy__(self):\n        """"""Return copy of this Region.""""""\n        return Region(list_poly=self.list_poly[:],\n                      props=self.props.copy())\n\n    def copy(self):\n        """"""Return copy of this Region.""""""\n        return self.__copy__()\n\n    @property\n    def dim(self):\n        """"""Return Region dimension.""""""\n        return np.shape(self.list_poly[0].A)[1]\n\n    @property\n    def volume(self):\n        if self._volume is None:\n            self._volume = volume(self)\n        return self._volume\n\n    @property\n    def chebR(self):\n        r, xc = cheby_ball(self)\n        return self._chebR\n\n    @property\n    def chebXc(self):\n        r, xc = cheby_ball(self)\n        return self._chebXc\n\n    @property\n    def cheby(self):\n        return cheby_ball(self)\n\n    @property\n    def bounding_box(self):\n        """"""Wrapper of polytope.bounding_box.\n\n        Computes the bounding box on first call.\n        """"""\n        if self.bbox is None:\n            self.bbox = bounding_box(self)\n        return self.bbox\n\n    def plot(self, ax=None, color=None, hatch=None, alpha=1.0, linestyle=None, linewidth=None, edgecolor=None):\n        """"""Plot a `polytope` on axes `ax`.""""""\n        # TODO optional arg for text label\n        if self.dim != 2:\n            raise Exception(""Cannot plot region of dimension larger than 2"")\n        if not is_fulldim(self):\n            logger.error(""Cannot plot empty region"")\n            return None\n        ax = _newax(ax)\n        if color is None:\n            color = np.random.rand(3)\n        for poly2 in self.list_poly:\n            # TODO hatched polytopes in same region\n            poly2.plot(ax, color=color, hatch=hatch, alpha=alpha, linestyle=linestyle, linewidth=linewidth,\n                       edgecolor=edgecolor)\n        return ax\n\n    def text(self, txt, ax=None, color=\'black\'):\n        """"""Plot text at chebyshev center.""""""\n        _plot_text(self, txt, ax, color)\n\n\ndef is_empty(polyreg):\n    """"""Check if the description of a polytope is empty\n\n    @param polyreg: L{Polytope} or L{Region} instance\n\n    @return: Boolean indicating whether polyreg is empty\n    """"""\n    n = len(polyreg)\n    if len(polyreg) == 0:\n        try:\n            return len(polyreg.A) == 0\n        except Exception:\n            return True\n    else:\n        N = np.zeros(n, dtype=int)\n        for i in xrange(n):\n            N[i] = is_empty(polyreg.list_poly[i])\n        if np.all(N):\n            return True\n        else:\n            return False\n\n\ndef is_fulldim(polyreg, abs_tol=ABS_TOL):\n    """"""Check if a polytope or region has inner points.\n\n    @param polyreg: L{Polytope} or L{Region} instance\n\n    @return: Boolean that is True if inner points found, False\n        otherwise.\n    """"""\n    # logger.debug(\'is_fulldim\')\n    if polyreg.fulldim is not None:\n        return polyreg.fulldim\n    lenP = len(polyreg)\n    if lenP == 0:\n        rc, xc = cheby_ball(polyreg)\n        status = rc > abs_tol\n    else:\n        status = np.zeros(lenP)\n        for ii in xrange(lenP):\n            rc, xc = cheby_ball(polyreg.list_poly[ii])\n            status[ii] = rc > abs_tol\n        status = np.sum(status)\n        status = status > 0\n    polyreg.fulldim = status\n    return status\n\n\ndef is_convex(reg, abs_tol=ABS_TOL):\n    """"""Check if a region is convex.\n\n    @type reg: L{Region}\n\n    @return: result,envelope: result indicating if convex. if found to\n        be convex the envelope describing the convex polytope is\n        returned.\n    """"""\n    if not is_fulldim(reg):\n        return True\n    if len(reg) == 0:\n        return True\n    outer = envelope(reg)\n    if is_empty(outer):\n        # Probably because input polytopes were so small and ugly..\n        return False, None\n    Pl, Pu = reg.bounding_box\n    Ol, Ou = outer.bounding_box\n    bboxP = np.hstack([Pl, Pu])\n    bboxO = np.hstack([Ol, Ou])\n    if (\n            sum(abs(bboxP[:, 0] - bboxO[:, 0]) > abs_tol) > 0 or\n            sum(abs(bboxP[:, 1] - bboxO[:, 1]) > abs_tol) > 0):\n        return False, None\n    if is_fulldim(outer.diff(reg)):\n        return False, None\n    else:\n        return True, outer\n\n\ndef is_inside(polyreg, point, abs_tol=ABS_TOL):\n    """"""Return `point in polyreg`.\n\n    @type point: `collections.abc.Sequence` or `numpy.ndarray`\n    @rtype: bool\n    """"""\n    warnings.warn(\n        \'Write `point in polyreg` instead of \'\n        \'calling this function.\',\n        DeprecationWarning)\n    if not isinstance(point, np.ndarray):\n        point = np.array(point)\n    return polyreg.contains(point[:, np.newaxis], abs_tol)[0]\n\n\ndef is_subset(small, big, abs_tol=ABS_TOL):\n    """"""Return True if small \\subseteq big.\n\n    @type small: L{Polytope} or L{Region}\n    @type big:   L{Polytope} or L{Region}\n\n    @rtype: bool\n    """"""\n    for x in [small, big]:\n        if not isinstance(x, (Polytope, Region)):\n            msg = \'Not a Polytope or Region, got instead:\\n\\t\'\n            msg += str(type(x))\n            raise TypeError(msg)\n    diff = small.diff(big)\n    volume = diff.volume\n    if volume < abs_tol:\n        return True\n    else:\n        return False\n\n\ndef reduce(poly, nonEmptyBounded=1, abs_tol=ABS_TOL):\n    """"""Remove redundant inequalities from the hyperplane representation.\n\n    Uses the algorithm described at [1],\n    by solving one LP for each facet.\n\n    [1] http://www.ifor.math.ethz.ch/~fukuda/polyfaq/node24.html\n\n    Warning:\n      - nonEmptyBounded == 0 case is not tested much.\n\n    @type poly: L{Polytope} or L{Region}\n\n    @return: Reduced L{Polytope} or L{Region} object\n    """"""\n    if isinstance(poly, Region):\n        lst = []\n        for poly2 in poly.list_poly:\n            red = reduce(poly2)\n            if is_fulldim(red):\n                lst.append(red)\n        if len(lst) > 0:\n            return Region(lst, poly.props)\n        else:\n            return Polytope()\n    # is `poly` already in minimal representation ?\n    if poly.minrep:\n        return poly\n    if not is_fulldim(poly):\n        return Polytope()\n    # `poly` isn\'t flat\n    A_arr = poly.A\n    b_arr = poly.b\n    # Remove rows with b = inf\n    keep_row = np.nonzero(poly.b != np.inf)\n    A_arr = A_arr[keep_row]\n    b_arr = b_arr[keep_row]\n    neq = np.shape(A_arr)[0]\n    # first eliminate the linearly dependent rows\n    # corresponding to the same hyperplane\n    M1 = np.hstack([A_arr, np.array([b_arr]).T]).T\n    M1row = 1 / np.sqrt(np.sum(M1**2, 0))\n    M1n = np.dot(M1, np.diag(M1row))\n    M1n = M1n.T\n    keep_row = []\n    for i in xrange(neq):\n        keep_i = 1\n        for j in xrange(i + 1, neq):\n            if np.dot(M1n[i].T, M1n[j]) > 1 - abs_tol:\n                keep_i = 0\n        if keep_i:\n            keep_row.append(i)\n    A_arr = A_arr[keep_row]\n    b_arr = b_arr[keep_row]\n    neq, nx = A_arr.shape\n    if nonEmptyBounded:\n        if neq <= nx + 1:\n            return Polytope(A_arr, b_arr)\n    # Now eliminate hyperplanes outside the bounding box\n    if neq > 3 * nx:\n        lb, ub = Polytope(A_arr, b_arr).bounding_box\n        # cand = -(np.dot((A_arr>0)*A_arr,ub-lb)\n        #-(b_arr-np.dot(A_arr,lb).T).T<-1e-4)\n        cand = ~ (np.dot((A_arr > 0) * A_arr, ub - lb) -\n                  (np.array([b_arr]).T - np.dot(A_arr, lb)) < -1e-4)\n        A_arr = A_arr[cand.squeeze()]\n        b_arr = b_arr[cand.squeeze()]\n    neq, nx = A_arr.shape\n    if nonEmptyBounded:\n        if neq <= nx + 1:\n            return Polytope(A_arr, b_arr)\n    del keep_row[:]\n    for k in xrange(A_arr.shape[0]):\n        f = -A_arr[k, :]\n        G = A_arr\n        h = b_arr\n        h[k] += 0.1\n        sol = lpsolve(f, G, h)\n        h[k] -= 0.1\n        if sol[\'status\'] == 0:\n            obj = -sol[\'fun\'] - h[k]\n            if obj > abs_tol:\n                keep_row.append(k)\n        elif sol[\'status\'] == 3:\n            keep_row.append(k)\n    polyOut = Polytope(A_arr[keep_row], b_arr[keep_row])\n    polyOut.minrep = True\n    return polyOut\n\n\ndef union(polyreg1, polyreg2, check_convex=False):\n    """"""Compute the union of polytopes or regions\n\n    @type polyreg1: L{Polytope} or L{Region}\n    @type polyreg2: L{Polytope} or L{Region}\n    @param check_convex: if True, look for convex unions and simplify\n\n    @return: region of non-overlapping polytopes describing the union\n    """"""\n    # logger.debug(\'union\')\n    if is_empty(polyreg1):\n        return polyreg2\n    if is_empty(polyreg2):\n        return polyreg1\n    if check_convex:\n        s1 = intersect(polyreg1, polyreg2)\n        if is_fulldim(s1):\n            s2 = polyreg2.diff(polyreg1)\n            s3 = polyreg1.diff(polyreg2)\n        else:\n            s2 = polyreg1\n            s3 = polyreg2\n    else:\n        s1 = polyreg1\n        s2 = polyreg2\n        s3 = None\n    lst = []\n    if len(s1) == 0:\n        if not is_empty(s1):\n            lst.append(s1)\n    else:\n        for poly in s1.list_poly:\n            if not is_empty(poly):\n                lst.append(poly)\n    if len(s2) == 0:\n        if not is_empty(s2):\n            lst.append(s2)\n    else:\n        for poly in s2.list_poly:\n            if not is_empty(poly):\n                lst.append(poly)\n    if s3 is not None:\n        if len(s3) == 0:\n            if not is_empty(s3):\n                lst.append(s3)\n        else:\n            for poly in s3.list_poly:\n                if not is_empty(poly):\n                    lst.append(poly)\n    if check_convex:\n        final = []\n        N = len(lst)\n        if N > 1:\n            # Check convexity for each pair of polytopes\n            while N > 0:\n                templist = [lst[0]]\n                for ii in xrange(1, N):\n                    templist.append(lst[ii])\n                    is_conv, env = is_convex(Region(templist))\n                    if not is_conv:\n                        templist.remove(lst[ii])\n                for poly in templist:\n                    lst.remove(poly)\n                cvxpoly = reduce(envelope(Region(templist)))\n                if not is_empty(cvxpoly):\n                    final.append(reduce(cvxpoly))\n                N = len(lst)\n        else:\n            final = lst\n        ret = Region(final)\n    else:\n        ret = Region(lst)\n    return ret\n\n\ndef cheby_ball(poly1):\n    """"""Calculate Chebyshev radius and center for a polytope.\n\n    The Chebyshev radius is defined here as the radius of a maximal\n    inscribed ball of the given polytope. The center of a maximal ball\n    is also returned, but note that unlike the radius, it is not\n    necessarily unique. If input is a region, then a largest Chebyshev\n    ball is returned.\n\n    N.B., this function will return whatever it finds in attributes\n    chebR and chbXc if not None, without (re)computing the Chebyshev ball.\n\n    Example (low dimension):\n\n    r1,x1 = cheby_ball(P, [1]) calculates the center and half the\n    length of the longest line segment along the first coordinate axis\n    inside polytope P\n\n    @type poly1: L{Polytope}\n\n    @return: rc,xc: Chebyshev radius rc (float) and center xc (numpy array)\n    """"""\n    #logger.debug(\'cheby ball\')\n    if (poly1._chebXc is not None) and (poly1._chebR is not None):\n        # In case chebyshev ball already calculated and stored\n        return poly1._chebR, poly1._chebXc\n    if isinstance(poly1, Region):\n        maxr = 0\n        maxx = None\n        for poly in poly1.list_poly:\n            rc, xc = cheby_ball(poly)\n            if rc > maxr:\n                maxr = rc\n                maxx = xc\n        poly1._chebXc = maxx\n        poly1._chebR = maxr\n        return maxr, maxx\n    if is_empty(poly1):\n        return 0, None\n    # `poly1` is nonempty\n    r = 0\n    xc = None\n    A = poly1.A\n    c = np.negative(np.r_[np.zeros(np.shape(A)[1]), 1])\n    norm2 = np.sqrt(np.sum(A * A, axis=1))\n    G = np.c_[A, norm2]\n    h = poly1.b\n    sol = lpsolve(c, G, h)\n    if sol[\'status\'] == 0:\n        r = sol[\'x\'][-1]\n        if r < 0:\n            return 0, None\n        xc = sol[\'x\'][0:-1]\n    else:\n        # Polytope is empty\n        poly1 = Polytope(fulldim=False)\n        return 0, None\n    poly1._chebXc = np.array(xc)\n    poly1._chebR = np.double(r)\n    return poly1._chebR, poly1._chebXc\n\n\ndef bounding_box(polyreg):\n    """"""Return smallest hyperbox containing polytope or region.\n\n    If polyreg.bbox is not None,\n    then it is returned without update.\n\n    @type polyreg: L{Polytope} or L{Region}\n\n    @return: (l, u) where:\n\n        - l = [x1min,\n               x2min,\n               ...\n               xNmin]\n\n        - u = [x1max,\n               x2max,\n               ...\n               xNmax]\n\n    @rtype:\n        - l = 2d array\n        - u = 2d array\n    """"""\n    if polyreg.bbox is not None:\n        return polyreg.bbox\n    # For regions, calculate recursively for each\n    # convex polytope and take maximum\n    if isinstance(polyreg, Region):\n        lenP = len(polyreg)\n        dimP = polyreg.dim\n        alllower = np.zeros([lenP, dimP])\n        allupper = np.zeros([lenP, dimP])\n        # collect lower and upper bounds\n        for ii in xrange(0, lenP):\n            bbox = polyreg.list_poly[ii].bounding_box\n            ll, uu = bbox\n            alllower[ii, :] = ll.T\n            allupper[ii, :] = uu.T\n        l = np.zeros([dimP, 1])\n        u = np.zeros([dimP, 1])\n        # compute endpoints\n        for ii in xrange(0, dimP):\n            l[ii] = min(alllower[:, ii])\n            u[ii] = max(allupper[:, ii])\n        polyreg.bbox = l, u\n        return l, u\n    # For a single convex polytope, solve an optimization problem\n    (m, n) = np.shape(polyreg.A)\n    In = np.eye(n)\n    l = np.zeros([n, 1])\n    u = np.zeros([n, 1])\n    # lower corner\n    for i in xrange(0, n):\n        c = np.array(In[:, i])\n        G = polyreg.A\n        h = polyreg.b\n        sol = lpsolve(c, G, h)\n        if sol[\'status\'] == 0:\n            x = sol[\'x\']\n            l[i] = x[i]\n    # upper corner\n    for i in xrange(0, n):\n        c = np.negative(np.array(In[:, i]))\n        G = polyreg.A\n        h = polyreg.b\n        sol = lpsolve(c, G, h)\n        if sol[\'status\'] == 0:\n            x = sol[\'x\']\n            u[i] = x[i]\n    polyreg.bbox = l, u\n    return l, u\n\n\ndef envelope(reg, abs_tol=ABS_TOL):\n    """"""Compute envelope of a region.\n\n    The envelope is the polytope defined by all ""outer"" inequalities a\n    x < b such that {x | a x < b} intersection P = P for all polytopes\n    P in the region. In other words we want to find all ""outer""\n    equalities of the region.\n\n    If envelope can\'t be computed an empty polytope is returned\n\n    @type reg: L{Region}\n    @param abs_tol: Absolute tolerance for calculations\n\n    @return: Envelope of input\n    """"""\n    Ae = None\n    be = None\n    nP = len(reg.list_poly)\n    for i in xrange(nP):\n        poly1 = reg.list_poly[i]\n        outer_i = np.ones(poly1.A.shape[0])\n        for ii in xrange(poly1.A.shape[0]):\n            if outer_i[ii] == 0:\n                # If inequality already discarded\n                continue\n            for j in xrange(nP):\n                # Check for each polytope\n                # if it intersects with inequality ii\n                if i == j:\n                    continue\n                poly2 = reg.list_poly[j]\n                testA = np.vstack([poly2.A, -poly1.A[ii, :]])\n                testb = np.hstack([poly2.b, -poly1.b[ii]])\n                testP = Polytope(testA, testb)\n                rc, xc = cheby_ball(testP)\n                if rc > abs_tol:\n                    # poly2 intersects with inequality ii -> this inequality\n                    # can not be in envelope\n                    outer_i[ii] = 0\n        ind_i = np.nonzero(outer_i)[0]\n        if Ae is None:\n            Ae = poly1.A[ind_i, :]\n            be = poly1.b[ind_i]\n        else:\n            Ae = np.vstack([Ae, poly1.A[ind_i, :]])\n            be = np.hstack([be, poly1.b[ind_i]])\n    ret = reduce(Polytope(Ae, be))\n    if is_fulldim(ret):\n        return ret\n    else:\n        return Polytope()\n\n\ncount = 0\n\n\ndef mldivide(a, b, save=False):\n    """"""Return set difference a \\ b.\n\n    @param a: L{Polytope} or L{Region}\n    @param b: L{Polytope} to subtract\n\n    @return: L{Region} describing the set difference\n    """"""\n    if isinstance(b, Polytope):\n        b = Region([b])\n    if isinstance(a, Region):\n        logger.debug(\'mldivide got Region as minuend\')\n        P = Region()\n        for poly in a:\n            #assert(not is_fulldim(P.intersect(poly) ) )\n            Pdiff = poly\n            for poly1 in b:\n                Pdiff = mldivide(Pdiff, poly1, save=save)\n            P = union(P, Pdiff, check_convex=True)\n            if save:\n                global count\n                count = count + 1\n                # dump plot of `Pdiff`\n                ax = Pdiff.plot()\n                ax.axis([0.0, 1.0, 0.0, 2.0])\n                ax.figure.savefig(\'./img/Pdiff\' + str(count) + \'.pdf\')\n                # dump plot of `P`\n                ax = P.plot()\n                ax.axis([0.0, 1.0, 0.0, 2.0])\n                ax.figure.savefig(\'./img/P\' + str(count) + \'.pdf\')\n    elif isinstance(a, Polytope):\n        logger.debug(\'a is Polytope\')\n        P = region_diff(a, b)\n    else:\n        raise Exception(\'a neither Region nor Polytope\')\n    return P\n\n\ndef intersect(poly1, poly2, abs_tol=ABS_TOL):\n    """"""Compute the intersection between two polytopes or regions\n\n    @type poly1: L{Polytope} or L{Region}\n    @type poly2: L{Polytope} or L{Region}\n\n    @return: Intersection of poly1 and poly2 described by a polytope\n    """"""\n    # raise NotImplementedError(\'Being removed,\n    # use {Polytope, Region}.intersect instead\')\n    if isinstance(poly1, Region):\n        return poly1.intersect(poly2)\n    if isinstance(poly2, Region):\n        return poly2.intersect(poly1)\n    if not isinstance(poly1, Polytope):\n        msg = \'poly1 not Region nor Polytope.\'\n        msg += \'Got instead: \' + str(type(poly1))\n        raise Exception(msg)\n    return poly1.intersect(poly2, abs_tol)\n\n\ndef volume(polyreg):\n    """"""Approximately compute the volume of a Polytope or Region.\n\n    A randomized algorithm is used.\n\n    @type polyreg: L{Polytope} or L{Region}\n\n    @return: Volume of input\n    """"""\n    if not is_fulldim(polyreg):\n        return 0.0\n    try:\n        if polyreg._volume is not None:\n            return polyreg._volume\n    except Exception:\n        logger.debug(\'computing volume...\')\n    # `Region` ?\n    if isinstance(polyreg, Region):\n        tot_vol = 0.\n        for i in xrange(len(polyreg)):\n            tot_vol += volume(polyreg.list_poly[i])\n        polyreg._volume = tot_vol\n        return tot_vol\n    # `polyreg` is a `Polytope`\n    n = polyreg.A.shape[1]\n    if n == 1:\n        N = 50\n    elif n == 2:\n        N = 500\n    elif n == 3:\n        N = 3000\n    else:\n        N = 10000\n    l_b, u_b = polyreg.bounding_box\n    x = (np.tile(l_b, (1, N))\n         + np.random.rand(n, N)\n         * np.tile(u_b - l_b, (1, N)))\n    aux = (np.dot(polyreg.A, x)\n           - np.tile(np.array([polyreg.b]).T, (1, N)))\n    aux = np.nonzero(np.all(aux < 0, 0))[0].shape[0]\n    vol = np.prod(u_b - l_b) * aux / N\n    polyreg._volume = vol\n    return vol\n\n\ndef extreme(poly1):\n    """"""Compute the extreme points of a _bounded_ polytope\n\n    @param poly1: Polytope in dimension d\n\n    @return: A (N x d) numpy array containing the N vertices of poly1\n    """"""\n    if poly1.vertices is not None:\n        # In case vertices already stored\n        return poly1.vertices\n    V = np.array([])\n    R = np.array([])\n    if isinstance(poly1, Region):\n        raise Exception(""extreme: not executable for regions"")\n    # `poly1` is a `Polytope`\n    poly1 = reduce(poly1)  # Need to have polytope non-redundant!\n    if not is_fulldim(poly1):\n        return None\n    # `poly1` isn\'t flat\n    A = poly1.A.copy()\n    b = poly1.b.copy()\n    sh = np.shape(A)\n    nc = sh[0]\n    nx = sh[1]\n    # distinguish cases by dimension\n    if nx == 1:\n        # Polytope is a 1-dim line\n        for ii in xrange(nc):\n            V = np.append(V, b[ii] / A[ii])\n        if len(A) == 1:\n            R = np.append(R, 1)\n            raise Exception(""extreme: polytope is unbounded"")\n    elif nx == 2:\n        # Polytope is 2D\n        alf = np.angle(A[:, 0] + 1j * A[:, 1])\n        I = np.argsort(alf)\n        H = np.vstack([A, A[0, :]])\n        K = np.hstack([b, b[0]])\n        I = np.hstack([I, I[0]])\n        for ii in xrange(nc):\n            HH = np.vstack([H[I[ii], :], H[I[ii + 1], :]])\n            KK = np.hstack([K[I[ii]], K[I[ii + 1]]])\n            if np.linalg.cond(HH) == np.inf:\n                R = np.append(R, 1)\n                raise Exception(""extreme: polytope is unbounded"")\n            else:\n                try:\n                    v = np.linalg.solve(HH, KK)\n                except Exception:\n                    msg = \'Finding extreme points failed, \'\n                    msg += \'Check if any unbounded Polytope \'\n                    msg += \'is causing this.\'\n                    raise Exception(msg)\n                if len(V) == 0:\n                    V = np.append(V, v)\n                else:\n                    V = np.vstack([V, v])\n    else:\n        # General nD method,\n        # solve a vertex enumeration problem for\n        # the dual polytope\n        rmid, xmid = cheby_ball(poly1)\n        A = poly1.A.copy()\n        b = poly1.b.copy()\n        sh = np.shape(A)\n        Ai = np.zeros(sh)\n        for ii in xrange(sh[0]):\n            Ai[ii, :] = A[ii, :] / (b[ii] - np.dot(A[ii, :], xmid))\n        Q = reduce(qhull(Ai))\n        if not is_fulldim(Q):\n            return None\n        # `Q` isn\'t flat\n        H = Q.A\n        K = Q.b\n        sh = np.shape(H)\n        nx = sh[1]\n        V = np.zeros(sh)\n        for iv in xrange(sh[0]):\n            for ix in xrange(nx):\n                V[iv, ix] = H[iv, ix] / K[iv] + xmid[ix]\n    a = V.size / nx\n    assert a.is_integer(), a\n    a = int(a)\n    poly1.vertices = V.reshape((a, nx))\n    return poly1.vertices\n\n\ndef qhull(vertices, abs_tol=ABS_TOL):\n    """"""Use quickhull to compute a convex hull.\n\n    @param vertices: A N x d array containing N vertices in dimension d\n\n    @return: L{Polytope} describing the convex hull\n    """"""\n    A, b, vert = quickhull(vertices, abs_tol=abs_tol)\n    if A.size == 0:\n        return Polytope()\n    return Polytope(A, b, minrep=True, vertices=vert)\n\n\ndef projection(poly1, dim, solver=None, abs_tol=ABS_TOL, verbose=0):\n    """"""Projects a polytope onto lower dimensions.\n\n    Available solvers are:\n\n      - ""esp"": Equality Set Projection;\n      - ""exthull"": vertex projection;\n      - ""fm"": Fourier-Motzkin projection;\n      - ""iterhull"": iterative hull method.\n\n    Example:\n    To project the polytope `P` onto the first three dimensions, use\n        >>> P_proj = projection(P, [1,2,3])\n\n    @param poly1: Polytope to project\n    @param dim: Dimensions on which to project\n    @param solver: A solver can be specified, if left blank an attempt\n        is made to choose the most suitable solver.\n    @param verbose: if positive, print solver used in case of\n        guessing; default is 0 (be silent).\n\n    @rtype: L{Polytope}\n    @return: Projected polytope in lower dimension\n    """"""\n    if isinstance(poly1, Region):\n        ret = Polytope()\n        for i in xrange(len(poly1.list_poly)):\n            p = projection(\n                poly1.list_poly[i], dim,\n                solver=solver, abs_tol=abs_tol)\n            ret = ret + p\n        return ret\n    # flat ?\n    if (poly1.dim < len(dim)) or is_empty(poly1):\n        return poly1\n    # `poly1` isn\'t flat\n    poly_dim = poly1.dim\n    dim = np.array(dim)\n    org_dim = xrange(poly_dim)\n    new_dim = dim.flatten() - 1\n    del_dim = np.setdiff1d(org_dim, new_dim)  # Index of dimensions to remove\n    # logging\n    logger.debug(\'polytope dim = \' + str(poly_dim))\n    logger.debug(\'project on dims = \' + str(new_dim))\n    logger.debug(\'original dims = \' + str(org_dim))\n    logger.debug(\'dims to delete = \' + str(del_dim))\n    mA, nA = poly1.A.shape\n    # fewer rows than dimensions ?\n    if mA < poly_dim:\n        msg = \'fewer rows in A: \' + str(mA)\n        msg += \', than polytope dimension: \' + str(poly_dim)\n        logger.warning(msg)\n        # enlarge A, b with zeros\n        A = poly1.A.copy()\n        poly1.A = np.zeros((poly_dim, poly_dim))\n        poly1.A[0:mA, 0:nA] = A\n        # stack\n        poly1.b = np.hstack([poly1.b, np.zeros(poly_dim - mA)])\n    logger.debug(\'m, n = \' + str((mA, nA)))\n    # Compute cheby ball in lower dim to see if projection exists\n    norm = np.sum(poly1.A * poly1.A, axis=1).flatten()\n    norm[del_dim] = 0\n    c = np.zeros(len(org_dim) + 1, dtype=float)\n    c[len(org_dim)] = -1\n    G = np.hstack([poly1.A, norm.reshape(norm.size, 1)])\n    h = poly1.b\n    sol = lpsolve(c, G, h)\n    if sol[\'status\'] != 0:\n        # Projection not fulldim\n        return Polytope()\n    if sol[\'x\'][-1] < abs_tol:\n        return Polytope()\n    # select projection solver\n    if solver == ""esp"":\n        return projection_esp(poly1, new_dim, del_dim)\n    elif solver == ""exthull"":\n        return projection_exthull(poly1, new_dim)\n    elif solver == ""fm"":\n        return projection_fm(poly1, new_dim, del_dim)\n    elif solver == ""iterhull"":\n        return projection_iterhull(poly1, new_dim)\n    elif solver is not None:\n        logger.warning(\'unrecognized projection solver ""\' +\n                       str(solver) + \'"".\')\n    # `solver` undefined or unknown\n    # select method based on dimension criteria\n    if len(del_dim) <= 2:\n        logger.debug(""projection: using Fourier-Motzkin."")\n        return projection_fm(poly1, new_dim, del_dim)\n    elif len(org_dim) <= 4:\n        logger.debug(""projection: using exthull."")\n        return projection_exthull(poly1, new_dim)\n    else:\n        logger.debug(""projection: using iterative hull."")\n        return projection_iterhull(poly1, new_dim)\n\n\ndef separate(reg1, abs_tol=ABS_TOL):\n    """"""Divide a region into several regions such that they are\n    all connected.\n\n    @type reg1: L{Region}\n    @param abs_tol: Absolute tolerance\n\n    @return: List [] of connected Regions\n    """"""\n    final = []\n    ind_left = xrange(len(reg1))\n    props = reg1.props\n    while len(ind_left) > 0:\n        ind_del = []\n        connected_reg = Region(\n            [reg1.list_poly[ind_left[0]]],\n            [])\n        ind_del.append(ind_left[0])\n        for i in xrange(1, len(ind_left)):\n            j = ind_left[i]\n            if is_adjacent(connected_reg, reg1.list_poly[j]):\n                connected_reg = union(\n                    connected_reg,\n                    reg1.list_poly[j],\n                    check_convex=False)\n                ind_del.append(j)\n        connected_reg.props = props.copy()\n        final.append(connected_reg)\n        ind_left = np.setdiff1d(ind_left, ind_del)\n    return final\n\n\ndef is_adjacent(poly1, poly2, overlap=True, abs_tol=ABS_TOL):\n    """"""Return True if two polytopes or regions are adjacent.\n\n    Check by enlarging both slightly and checking for intersection.\n\n    @type poly1, poly2: L{Polytope}s or L{Region}s\n\n    @param overlap: return True if polytopes are neighbors OR overlap\n\n    @param abs_tol: absolute tolerance\n\n    @return: True if polytopes are adjacent\n    """"""\n    if poly1.dim != poly2.dim:\n        raise Exception(""is_adjacent: ""\n                        ""polytopes do not have the same dimension"")\n    if isinstance(poly1, Region):\n        for p in poly1:\n            adj = is_adjacent(p, poly2, overlap=overlap, abs_tol=abs_tol)\n            if adj:\n                return True\n        return False\n    if isinstance(poly2, Region):\n        for p in poly2:\n            adj = is_adjacent(poly1, p, overlap=overlap, abs_tol=abs_tol)\n            if adj:\n                return True\n        return False\n    # copy\n    A1_arr = poly1.A.copy()\n    A2_arr = poly2.A.copy()\n    b1_arr = poly1.b.copy()\n    b2_arr = poly2.b.copy()\n    if overlap:\n        b1_arr += abs_tol\n        b2_arr += abs_tol\n        dummy = Polytope(\n            np.concatenate((A1_arr, A2_arr)),\n            np.concatenate((b1_arr, b2_arr)))\n        return is_fulldim(dummy, abs_tol=abs_tol / 10)\n    else:\n        M1 = np.concatenate((poly1.A, np.array([poly1.b]).T), 1).T\n        M1row = 1 / np.sqrt(np.sum(M1**2, 0))\n        M1n = np.dot(M1, np.diag(M1row))\n\n        M2 = np.concatenate((poly2.A, np.array([poly2.b]).T), 1).T\n        M2row = 1 / np.sqrt(np.sum(M2**2, 0))\n        M2n = np.dot(M2, np.diag(M2row))\n        if not np.any(np.dot(M1n.T, M2n) < -0.99):\n            return False\n        dummy = np.dot(M1n.T, M2n)\n        row, col = np.nonzero(np.isclose(dummy, dummy.min()))\n        for i, j in zip(row, col):\n            b1_arr[i] += abs_tol\n            b2_arr[j] += abs_tol\n        dummy = Polytope(\n            np.concatenate((A1_arr, A2_arr)),\n            np.concatenate((b1_arr, b2_arr)))\n        return is_fulldim(dummy, abs_tol=abs_tol / 10)\n\n\ndef is_interior(r0, r1, abs_tol=ABS_TOL):\n    """"""Return True if r1 is strictly in the interior of r0.\n\n    Checks if r1 enlarged by abs_tol\n    is a subset of r0.\n\n    @type r0: L{Polytope} or L{Region}\n    @type r1: L{Polytope} or L{Region}\n\n    @rtype: bool\n    """"""\n    if isinstance(r0, Polytope):\n        r0 = Region([r0])\n    if isinstance(r1, Polytope):\n        r1 = Region([r1])\n    for p in r1:\n        A = p.A.copy()\n        b = p.b.copy() + abs_tol\n        dummy = Polytope(A, b)\n        if not dummy <= r0:\n            return True\n    return False\n\n\n#### Helper functions ####\n\ndef projection_fm(poly1, new_dim, del_dim, abs_tol=ABS_TOL):\n    """"""Help function implementing Fourier Motzkin projection.\n\n    Should work well for eliminating few dimensions.\n    """"""\n    # Remove last dim first to handle indices\n    del_dim = -np.sort(-del_dim)\n    if not poly1.minrep:\n        poly1 = reduce(poly1)\n    poly = poly1.copy()\n    for i in del_dim:\n        positive = np.nonzero(poly.A[:, i] > abs_tol)[0]\n        negative = np.nonzero(poly.A[:, i] < abs_tol)[0]\n        null = np.nonzero(np.abs(poly.A[:, i]) < abs_tol)[0]\n        nr = len(null) + len(positive) * len(negative)\n        nc = np.shape(poly.A)[0]\n        C = np.zeros([nr, nc])\n        A = poly.A[:, i].copy()\n        row = 0\n        for j in positive:\n            for k in negative:\n                C[row, j] = -A[k]\n                C[row, k] = A[j]\n                row += 1\n        for j in null:\n            C[row, j] = 1\n            row += 1\n        keep_dim = np.setdiff1d(\n            range(poly.A.shape[1]),\n            np.array([i]))\n        poly = Polytope(\n            np.dot(C, poly.A)[:, keep_dim],\n            np.dot(C, poly.b))\n        if not is_fulldim(poly):\n            return Polytope()\n        poly = reduce(poly)\n    return poly\n\n\ndef projection_exthull(poly1, new_dim):\n    """"""Help function implementing vertex projection.\n\n    Efficient in low dimensions.\n    """"""\n    vert = extreme(poly1)\n    if vert is None:\n        # qhull failed\n        return Polytope(fulldim=False, minrep=True)\n    return reduce(qhull(vert[:, new_dim]))\n\n\ndef projection_iterhull(poly1, new_dim, max_iter=1000,\n                        verbose=0, abs_tol=ABS_TOL):\n    """"""Helper function implementing the ""iterative hull"" method.\n\n    Works best when projecting _to_ lower dimensions.\n    """"""\n    r, xc = cheby_ball(poly1)\n    org_dim = poly1.A.shape[1]\n    logger.debug(""Starting iterhull projection from dim "" +\n                 str(org_dim) + "" to dim "" + str(len(new_dim)))\n    if len(new_dim) == 1:\n        f1 = np.zeros(poly1.A.shape[1])\n        f1[new_dim] = 1\n        sol = lpsolve(f1, poly1.A, poly1.b)\n        if sol[\'status\'] == 0:\n            vert1 = sol[\'x\']\n        sol = lpsolve(np.negative(f1), poly1.A, poly1.b)\n        if sol[\'status\'] == 0:\n            vert2 = sol[\'x\']\n        vert = np.vstack([vert1, vert2])\n        return qhull(vert)\n    else:\n        OK = False\n        cnt = 0\n        Vert = None\n        while not OK:\n            # Maximizing in random directions\n            # to find a starting simplex\n            cnt += 1\n            if cnt > max_iter:\n                raise Exception(""iterative_hull: ""\n                                ""could not find starting simplex"")\n            f1 = np.random.rand(len(new_dim)).flatten() - 0.5\n            f = np.zeros(org_dim)\n            f[new_dim] = f1\n            sol = lpsolve(np.negative(f), poly1.A, poly1.b)\n            xopt = np.array(sol[\'x\']).flatten()\n            if Vert is None:\n                Vert = xopt.reshape(1, xopt.size)\n            else:\n                k = np.nonzero(Vert[:, new_dim[0]] == xopt[new_dim[0]])[0]\n                for j in new_dim[range(1, len(new_dim))]:\n                    ii = np.nonzero(Vert[k, j] == xopt[j])[0]\n                    k = k[ii]\n                    if k.size == 0:\n                        break\n                if k.size == 0:\n                    Vert = np.vstack([Vert, xopt])\n            if Vert.shape[0] > len(new_dim):\n                u, s, v = np.linalg.svd(\n                    np.transpose(Vert[:, new_dim] - Vert[0, new_dim]))\n                rank = np.sum(s > abs_tol * 10)\n                if rank == len(new_dim):\n                    # If rank full we have found a starting simplex\n                    OK = True\n        logger.debug(""Found starting simplex after "" +\n                     str(cnt) + "" iterations"")\n        cnt = 0\n        P1 = qhull(Vert[:, new_dim])\n        HP = None\n        while True:\n            # Iteration:\n            # Maximaze in direction of each facet\n            # Take convex hull of all vertices\n            cnt += 1\n            if cnt > max_iter:\n                raise Exception(""iterative_hull: ""\n                                ""maximum number of iterations reached"")\n            logger.debug(""Iteration number "" + str(cnt))\n            for ind in xrange(P1.A.shape[0]):\n                f1 = np.round(P1.A[ind, :] / abs_tol) * abs_tol\n                f2 = np.hstack([np.round(P1.A[ind, :] / abs_tol) * abs_tol,\n                                np.round(P1.b[ind] / abs_tol) * abs_tol])\n                # See if already stored\n                k = np.array([])\n                if HP is not None:\n                    k = np.nonzero(HP[:, 0] == f2[0])[0]\n                    for j in xrange(1, np.shape(P1.A)[1] + 1):\n                        ii = np.nonzero(HP[k, j] == f2[j])[0]\n                        k = k[ii]\n                        if k.size == 0:\n                            break\n                if k.size == 1:\n                    # Already stored\n                    xopt = HP[\n                        k,\n                        range(\n                            np.shape(P1.A)[1] + 1,\n                            np.shape(P1.A)[1] + np.shape(Vert)[1] + 1)\n                    ]\n                else:\n                    # Solving optimization to find new vertex\n                    f = np.zeros(poly1.A.shape[1])\n                    f[new_dim] = f1\n                    sol = lpsolve(np.negative(f), poly1.A, poly1.b)\n                    if sol[\'status\'] != 0:\n                        logger.error(""iterhull: LP failure"")\n                        continue\n                    xopt = np.array(sol[\'x\']).flatten()\n                    add = np.hstack([f2, np.round(xopt / abs_tol) * abs_tol])\n                    # Add new half plane information\n                    # HP format: [ P1.Ai P1.bi xopt]\n                    if HP is None:\n                        HP = add.reshape(1, add.size)\n                    else:\n                        HP = np.vstack([HP, add])\n                    Vert = np.vstack([Vert, xopt])\n            logger.debug(""Taking convex hull of new points"")\n            P2 = qhull(Vert[:, new_dim])\n            logger.debug(""Checking if new points are inside convex hull"")\n            OK = 1\n            for i in xrange(np.shape(Vert)[0]):\n                if not P1.contains(np.transpose([Vert[i, new_dim]]),\n                                   abs_tol=1e-5):\n                    # If all new points are inside\n                    # old polytope -> Finished\n                    OK = 0\n                    break\n            if OK == 1:\n                logger.debug(""Returning projection after "" +\n                             str(cnt) + "" iterations\\n"")\n                return P2\n            else:\n                # Iterate\n                P1 = P2\n\n\ndef projection_esp(poly1, keep_dim, del_dim):\n    """"""Helper function implementing ""Equality set projection"".\n\n    CAUTION: Very buggy.\n    """"""\n    C = poly1.A[:, keep_dim]\n    D = poly1.A[:, del_dim]\n    if not is_fulldim(poly1):\n        return Polytope()\n    G, g, E = esp(C, D, poly1.b)\n    return Polytope(G, g)\n\n\ndef region_diff(poly, reg, abs_tol=ABS_TOL, intersect_tol=ABS_TOL,\n                save=False):\n    """"""Subtract a region from a polytope\n\n    @param poly: polytope from which to subtract a region\n    @param reg: region which should be subtracted\n    @param abs_tol: absolute tolerance\n\n    @return: polytope or region containing non-overlapping polytopes\n    """"""\n    if not isinstance(poly, Polytope):\n        raise Exception(\'poly not a Polytope, but: \' +\n                        str(type(poly)))\n    poly = poly.copy()\n    if isinstance(reg, Polytope):\n        reg = Region([reg])\n    if not isinstance(reg, Region):\n        raise Exception(\'reg not a Region, but: \'\n                        + str(type(reg)))\n    N = len(reg)\n    if N == 0:\n        # Hack if reg happens to be a polytope\n        reg = Region([reg])\n        N = 1\n    if is_empty(reg):\n        return poly\n    if is_empty(poly):\n        return Polytope()\n    # Checking intersections to find Polytopes in Region\n    # that intersect the Polytope\n    Rc = np.zeros(N)\n    for i, poly1 in enumerate(reg):\n        A_dummy = np.vstack([poly.A, poly1.A])\n        b_dummy = np.hstack([poly.b, poly1.b])\n        dummy = Polytope(A_dummy, b_dummy)\n        Rc[i], xc = cheby_ball(dummy)\n    N = np.sum(Rc >= intersect_tol)\n    if N == 0:\n        logger.debug(\'no Polytope in the Region intersects the given Polytope\')\n        return poly\n    # Sort radii\n    Rc = -Rc\n    ind = np.argsort(Rc)\n    #val = Rc[ind]\n    A = poly.A.copy()\n    B = poly.b.copy()\n    H = A.copy()\n    K = B.copy()\n    m = np.shape(A)[0]\n    mi = np.zeros(N, dtype=int)\n    # Finding constraints that are not in original polytope\n    HK = np.hstack([H, np.array([K]).T])\n    for ii in xrange(N):\n        i = ind[ii]\n        if not is_fulldim(reg.list_poly[i]):\n            continue\n        Hni = reg.list_poly[i].A.copy()\n        Kni = reg.list_poly[i].b.copy()\n        for j in xrange(np.shape(Hni)[0]):\n            HKnij = np.hstack([Hni[j, :], Kni[j]])\n            HK2 = np.tile(HKnij, [m, 1])\n            abs = np.abs(HK - HK2)\n            # is the constraint `HKnij` not in the original polytope ?\n            if np.all(np.sum(abs, axis=1) >= abs_tol):\n                mi[ii] = mi[ii] + 1\n                A = np.vstack([A, Hni[j, :]])\n                B = np.hstack([B, Kni[j]])\n    # If some Ri has no active constraints, Ri covers R\n    if np.any(mi == 0):\n        return Polytope()\n    # some constraints are active\n    M = np.sum(mi)\n    if len(mi[0:len(mi) - 1]) > 0:\n        csum = np.cumsum(np.hstack([0, mi[0:len(mi) - 1]]))\n        beg_mi = csum + m * np.ones(len(csum), dtype=int)\n    else:\n        beg_mi = np.array([m])\n    A = np.vstack([A, -A[range(m, m + M), :]])\n    B = np.hstack([B, -B[range(m, m + M)]])\n    counter = np.zeros([N, 1], dtype=int)\n    INDICES = np.arange(m, dtype=int)\n    level = 0\n    res_count = 0\n    res = Polytope()  # Initialize output\n    while level != -1:\n        if save:\n            if res:\n                ax = res.plot()\n                ax.axis([0.0, 1.0, 0.0, 2.0])\n                ax.figure.savefig(\'./img/res\' + str(res_count) + \'.pdf\')\n                res_count += 1\n        if counter[level] == 0:\n            if save:\n                logger.debug(\'counter[level] is 0\')\n\n            for j in xrange(level, N):\n                auxINDICES = np.hstack([\n                    INDICES,\n                    range(beg_mi[j], beg_mi[j] + mi[j])\n                ])\n                Adummy = A[auxINDICES, :]\n                bdummy = B[auxINDICES]\n                R, xopt = cheby_ball(Polytope(Adummy, bdummy))\n                if R > abs_tol:\n                    level = j\n                    counter[level] = 1\n                    INDICES = np.hstack([INDICES, beg_mi[level] + M])\n                    break\n            if R < abs_tol:\n                level = level - 1\n                res = union(res, Polytope(A[INDICES, :], B[INDICES]), False)\n                nzcount = np.nonzero(counter)[0]\n                for jj in xrange(len(nzcount) - 1, -1, -1):\n                    if counter[level] <= mi[level]:\n                        INDICES[len(INDICES) -\n                                1] = INDICES[len(INDICES) - 1] - M\n                        INDICES = np.hstack([\n                            INDICES,\n                            beg_mi[level] + counter[level] + M\n                        ])\n                        break\n                    else:\n                        counter[level] = 0\n                        INDICES = INDICES[0:m + sum(counter)]\n                        if level == -1:\n                            logger.debug(\'returning res from 1st point\')\n                            return res\n        else:\n            if save:\n                logger.debug(\'counter[level] > 0\')\n            # counter(level) > 0\n            nzcount = np.nonzero(counter)[0]\n            for jj in xrange(len(nzcount) - 1, -1, -1):\n                level = nzcount[jj]\n                counter[level] = counter[level] + 1\n                if counter[level] <= mi[level]:\n                    INDICES[len(INDICES) - 1] = INDICES[len(INDICES) - 1] - M\n                    INDICES = np.hstack([\n                        INDICES,\n                        beg_mi[level] + counter[level] + M - 1\n                    ])\n                    break\n                else:\n                    counter[level] = 0\n                    INDICES = INDICES[0:m + np.sum(counter)]\n                    level = level - 1\n                    if level == -1:\n                        if save:\n                            if save:\n                                if res:\n                                    ax = res.plot()\n                                    ax.axis([0.0, 1.0, 0.0, 2.0])\n                                    ax.figure.savefig(\'./img/res_returned\'\n                                                      + str(res_count)\n                                                      + \'.pdf\')\n                            logger.debug(\'returning res from 2nd point\')\n                        return res\n        test_poly = Polytope(A[INDICES, :], B[INDICES])\n        rc, xc = cheby_ball(test_poly)\n        if rc > abs_tol:\n            if level == N - 1:\n                res = union(res, reduce(test_poly), False)\n            else:\n                level = level + 1\n    logger.debug(\'returning res from end\')\n    return res\n\n\ndef num_bin(N, places=8):\n    """"""Return N as list of bits, zero-filled to places.\n\n    E.g., given N=7, num_bin returns [1, 1, 1, 0, 0, 0, 0, 0].\n    """"""\n    return [(N >> k) & 0x1 for k in xrange(places)]\n\n\ndef box2poly(box):\n    """"""Return new Polytope from box.\n\n    @param box: defining the Polytope\n    @type box: [[x1min, x1max], [x2min, x2max],...]\n    """"""\n    return Polytope.from_box(box)\n\n\ndef _get_patch(poly1, **kwargs):\n    """"""Return matplotlib patch for given Polytope.\n\n    Example::\n\n    > # Plot Polytope objects poly1 and poly2 in the same plot\n    > import matplotlib.pyplot as plt\n    > fig = plt.figure()\n    > ax = fig.add_subplot(111)\n    > p1 = _get_patch(poly1, color=""blue"")\n    > p2 = _get_patch(poly2, color=""yellow"")\n    > ax.add_patch(p1)\n    > ax.add_patch(p2)\n    > ax.set_xlim(xl, xu) # Optional: set axis max/min\n    > ax.set_ylim(yl, yu)\n    > plt.show()\n\n    @type poly1: L{Polytope}\n    @param kwargs: any keyword arguments valid for\n        matplotlib.patches.Polygon\n    """"""\n    import matplotlib as mpl\n    V = extreme(poly1)\n    rc, xc = cheby_ball(poly1)\n    x = V[:, 1] - xc[1]\n    y = V[:, 0] - xc[0]\n    mult = np.sqrt(x**2 + y**2)\n    x = x / mult\n    angle = np.arccos(x)\n    corr = np.ones(y.size) - 2 * (y < 0)\n    angle = angle * corr\n    ind = np.argsort(angle)\n    # create patch\n    patch = mpl.patches.Polygon(V[ind, :], True, **kwargs)\n    patch.set_zorder(0)\n    return patch\n\n\ndef grid_region(polyreg, res=None):\n    """"""Return bounding box grid points within `polyreg`.\n\n    @type polyreg: L{Polytope} or L{Region}\n    @param res: resolution of grid\n    """"""\n    # grid corners\n    bbox = polyreg.bounding_box\n    bbox = np.hstack(bbox)\n    dom = bbox.flatten()\n    # grid resolution\n    density = 8\n    if res is None:\n        res = list()\n        for i in xrange(0, dom.size, 2):\n            L = dom[i + 1] - dom[i]\n            res += [density * L]\n    linspaces = list()\n    for i, n in enumerate(res):\n        a = dom[2 * i]\n        b = dom[2 * i + 1]\n        r = np.linspace(a, b, n)\n        linspaces.append(r)\n    points = np.meshgrid(*linspaces)\n    x = np.vstack(map(np.ravel, points))\n    x = x[:, polyreg.contains(x)]\n    return (x, res)\n\n\ndef _plot_text(polyreg, txt, ax, color):\n    """"""Annotate center of Chebyshev ball with `txt`.""""""\n    ax = _newax(ax)\n    rc, xc = cheby_ball(polyreg)\n    ax.text(xc[0], xc[1], txt, color=color)\n\n\ndef _newax(ax=None):\n    """"""Add subplot to current figure and return axes.""""""\n    from matplotlib import pyplot as plt\n    if ax is not None:\n        return ax\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    return ax\n\n\ndef simplices2polytopes(points, triangles):\n    """"""Convert a simplicial mesh to polytope H-representation.\n\n    @type points: N x d\n    @type triangles: NT x 3\n    """"""\n    polytopes = []\n    for triangle in triangles:\n        logger.debug(\'Triangle: \' + str(triangle))\n        triangle_vertices = points[triangle, :]\n        logger.debug(\'\\t triangle points: \' +\n                     str(triangle_vertices))\n        poly = qhull(triangle_vertices)\n        logger.debug(\'\\n Polytope:\\n:\' + str(poly))\n        polytopes += [poly]\n    return polytopes\n'"
polytope/prop2partition.py,1,"b'# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n""""""Proposition preserving partition module.""""""\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\nimport logging\nimport warnings\n\nimport numpy as np\nfrom scipy import sparse as sp\n\nimport polytope as pc\n\n\nlogger = logging.getLogger(__name__)\n_hl = 40 * \'-\'\n\n\ndef find_adjacent_regions(partition):\n    """"""Return region pairs that are spatially adjacent.\n\n    @type partition: iterable container of L{Region}\n\n    @rtype: lil_matrix\n    """"""\n    n = len(partition)\n    adj = sp.lil_matrix((n, n), dtype=np.int8)\n    s = partition.regions\n\n    for i, a in enumerate(s):\n        adj[i, i] = 1\n\n        for j, b in enumerate(s[0:i]):\n            adj[i, j] = adj[j, i] = pc.is_adjacent(a, b)\n\n    return adj\n\n################################\n\n\nclass Partition(object):\n    """"""Partition of a set.\n\n    A C{Partition} is an iterable container of sets\n    over C{Partition.set} and these must implement the methods:\n\n        - union, __add__\n        - difference\n        - intersection\n        - __le__\n\n    so the builtin class C{set} can be used for discrete sets,\n    or custom classes (e.g. polytopes) can be used for sets\n    equipped with more structure.\n\n    To utilize additional structure, see L{MetricPartition}.\n    """"""\n\n    def __init__(self, domain=None):\n        """"""Partition over C{domain}.\n\n        C{domain} is used to avoid conflicts with\n        the python builtin set function.\n        """"""\n        self.set = domain\n\n    def __len__(self):\n        return len(self.regions)\n\n    def __iter__(self):\n        return iter(self.regions)\n\n    def __getitem__(self, key):\n        return self.regions[key]\n\n    def is_partition(self):\n        """"""Return True if Regions are pairwise disjoint and cover domain.\n        """"""\n        return self.is_cover() and self.are_disjoint()\n\n    def is_cover(self):\n        """"""Return True if Regions cover domain\n        """"""\n        union = pc.Region()\n        for region in self.regions:\n            union += region\n\n        if not self.domain <= union:\n            msg = \'partition does not cover domain.\'\n            logger.Error(msg)\n            warnings.warn(msg)\n            return False\n        else:\n            return True\n\n    def are_disjoint(self, check_all=False, fname=None):\n        """"""Return True if all Regions are disjoint.\n\n        Print:\n\n            - the offending Regions and their\n            - their intersection (mean) volume ratio\n            - their difference (mean) volume ratio\n\n        Optionally save numbered figures of:\n\n            - offending Regions\n            - their intersection\n            - their difference\n\n        @param check_all: don\'t return when first offending regions found,\n            continue and check all pairs\n        @type check_all: bool\n\n        @param fname: path prefix where to save the debugging figures\n            By default no figures are saved.\n        @type fname: str\n        """"""\n        logger.info(\'checking if PPP is a partition.\')\n\n        l, u = self.set.bounding_box\n        ok = True\n        for i, region in enumerate(self.regions):\n            for j, other in enumerate(self.regions[0:i]):\n                if pc.is_fulldim(region.intersect(other)):\n                    msg = \'PPP is not a partition, regions: \'\n                    msg += str(i) + \' and: \' + str(j)\n                    msg += \' intersect each other.\\n\'\n                    msg += \'Offending regions are:\\n\' + 10 * \'-\' + \'\\n\'\n                    msg += str(region) + 10 * \'-\' + \'\\n\'\n                    msg += str(other) + 10 * \'-\' + \'\\n\'\n\n                    isect = region.intersect(other)\n                    diff = region.diff(other)\n\n                    mean_volume = (region.volume + other.volume) / 2.0\n\n                    overlap = 100 * isect.volume / mean_volume\n                    non_overlap = 100 * diff.volume / mean_volume\n\n                    msg += \'|cap| = \' + str(overlap) + \' %\\n\'\n                    msg += \'|diff| = \' + str(non_overlap) + \'\\n\'\n\n                    logger.error(msg)\n\n                    if fname:\n                        print(\'saving\')\n                        fname1 = fname + \'region\' + str(i) + \'.pdf\'\n                        fname2 = fname + \'region\' + str(j) + \'.pdf\'\n                        fname3 = (\n                            fname + \'isect_\' + str(i) +\n                            \'_\' + str(j) + \'.pdf\')\n                        fname4 = (\n                            fname + \'diff_\' + str(i) +\n                            \'_\' + str(j) + \'.pdf\')\n\n                        _save_region_plot(region, fname1, l, u)\n                        _save_region_plot(other, fname2, l, u)\n                        _save_region_plot(isect, fname3, l, u)\n                        _save_region_plot(diff, fname4, l, u)\n\n                    ok = False\n                    if not check_all:\n                        break\n        return ok\n\n    def refines(self, other):\n        """"""Return True if each element is a subset of other.\n\n        @type other: PropPreservingPartition\n        """"""\n        for small in self:\n            found_superset = False\n            for big in other:\n                if small <= big:\n                    found_superset = True\n                    break\n            if not found_superset:\n                return False\n        return True\n\n    def preserves(self, other):\n        """"""Return True if it refines closure of C{other} under complement.\n\n        Closure under complement is the union of C{other}\n        with the collection of complements of its elements.\n\n        This method checks the annotation of elements in C{self}\n        with elements fro C{other}.\n        """"""\n        for item in self._elements:\n            # item subset of these sets\n            for superset in item.supersets:\n                if not item <= superset:\n                    return False\n\n            # item subset of the complements of these sets\n            for other_set in set(other).difference(item.supersets):\n                if item.intersect(other_set):\n                    return False\n        return True\n\n\nclass MetricPartition(Partition):\n    """"""Partition of a metric space.\n\n    Includes adjacency information which abstracts\n    the topology induced by the metric.\n\n    Two subsets in the partition are called adjacent\n    if the intersection of their closure is non-empty.\n\n    If the space is also a measure space,\n    then volume information is used for diagnostic purposes.\n    """"""\n\n    def compute_adj(self):\n        """"""Update the adjacency matrix by checking all region pairs.\n\n        Uses L{polytope.is_adjacent}.\n        """"""\n        n = len(self.regions)\n        adj = sp.lil_matrix((n, n))\n\n        logger.info(\'computing adjacency from scratch...\')\n        for i, region0 in enumerate(self.regions):\n            for j, region1 in enumerate(self.regions):\n                if i == j:\n                    adj[i, j] = 1\n                    continue\n\n                if pc.is_adjacent(region0, region1):\n                    adj[i, j] = 1\n                    adj[j, i] = 1\n\n                    logger.info(\'regions: \' + str(i) + \', \' +\n                                str(j) + \', are adjacent.\')\n        logger.info(\'...done computing adjacency.\')\n\n        # check previous one to unmask errors\n        if self.adj is not None:\n            logger.info(\'checking previous adjacency...\')\n\n            ok = True\n            row, col = adj.nonzero()\n\n            for i, j in zip(row, col):\n                assert(adj[i, j])\n                if adj[i, j] != self.adj[i, j]:\n                    ok = False\n\n                    msg = \'PPP adjacency matrix is incomplete, \'\n                    msg += \'missing: (\' + str(i) + \', \' + str(j) + \')\'\n                    logger.error(msg)\n\n            row, col = self.adj.nonzero()\n\n            for i, j in zip(row, col):\n                assert(self.adj[i, j])\n                if adj[i, j] != self.adj[i, j]:\n                    ok = False\n\n                    msg = \'PPP adjacency matrix is incorrect, \'\n                    msg += \'has 1 at: (\' + str(i) + \', \' + str(j) + \')\'\n                    logger.error(msg)\n\n            if not ok:\n                logging.error(\'PPP had incorrect adjacency matrix.\')\n\n            logger.info(\'done checking previous adjacency.\')\n        else:\n            ok = True\n            logger.info(\'no previous adjacency found: \' +\n                        \'skip verification.\')\n\n        # update adjacency\n        self.adj = adj\n\n        return ok\n\n\ndef _save_region_plot(region, fname, l, u):\n    ax = region.plot()\n    ax.set_xlim(l[0, 0], u[0, 0])\n    ax.set_ylim(l[1, 0], u[1, 0])\n    ax.figure.savefig(fname)\n'"
polytope/quickhull.py,51,"b'# Copyright (c) 2011-2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\nr""""""Implementation of the Quickhull algorithm for computing convex hulls.\n\nReference\n=========\n\n\\cite{Barber96toms}\n""""""\n# Created by P. Nilsson, 8/2/11\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport numpy as np\n\n\nclass Facet(object):\n    """"""Face of dimension n-1 of n-dimensional polyhedron.\n\n    A class describing a facet (n-1 dimensional face) of an\n    n dimensional polyhedron with the following fields:\n    N.B. Polyhedron is assumed to contain the origin\n    (inside and outside are defined accordingly)\n\n      - `outside`: a list of points outside the facet\n      - `vertices`: the vertices of the facet in a n*n matrix where\n        each row denotes a vertex\n      - `neighbors`: a list of other facets with which the facet\n        shares n-1 vertices\n      - `normal`: a normalized vector perpendicular to the facet,\n        pointing ""out""\n      - `distance`: the normal distance of the facet from origo\n    """"""\n\n    def __init__(self, points):\n        self.outside = []\n        self.vertices = points\n        self.neighbors = []\n        self.normal = None\n        self.distance = None\n\n        sh = np.shape(points)\n        A0 = np.hstack([points, np.ones([sh[0], 1])])\n        b0 = np.zeros([sh[0], 1])\n        b = np.vstack([np.zeros([sh[0], 1]), 1])\n        c = np.zeros(sh[1] + 1)\n        c[-1] = -1.\n        A = np.vstack([A0, c])\n        sol = np.linalg.solve(A, b)\n\n        xx = sol[0:sh[1]]\n        mult = np.sqrt(np.sum(xx**2))\n        n = xx / mult\n        d = sol[sh[1]] / mult\n        # Test to check that n is >outer< normal\n        if np.sum(n.flatten() * points[0]) < 0:\n            n = -n\n        self.normal = n\n        self.distance = -d\n\n    def get_furthest(self):\n        """"""Return point outside the furthest away from the facet.""""""\n        N = len(self.outside)\n        if N == 1:\n            ret = self.outside[0]\n            del self.outside[0]\n            return ret\n        else:\n            p0 = self.outside[0]\n            inddel = 0\n            for i in range(1, N):\n                if p0.distance < self.outside[i].distance:\n                    p0 = self.outside[i]\n                    inddel = i\n            del self.outside[inddel]\n            return p0\n\n\nclass Outside_point(object):\n    """"""Point coordinates and distance to facet.\n\n    The distance is between the point and the facet that\n    the point is assigned to.\n    """"""\n\n    def __init__(self, coordinates, distance):\n        self.distance = distance\n        self.coordinates = coordinates\n\n\ndef distance(p, fac1):\n    """"""Calculate the distance from a facet to a point.""""""\n    n = fac1.normal\n    d = fac1.distance\n    return np.sum(n.flatten() * p.flatten()) - d\n\n\ndef is_neighbor(fac1, fac2, abs_tol=1e-7):\n    """"""Determine if two facets share d-1 vertices.""""""\n    vert1 = fac1.vertices\n    vert2 = fac2.vertices\n    sh = np.shape(vert1)\n    dim = sh[1]\n    same = 0\n    for ii in range(dim):\n        v1 = vert1[ii, :]\n        for jj in range(dim):\n            v2 = vert2[jj, :]\n            if np.all(np.abs(v1 - v2) < abs_tol):\n                same += 1\n                break\n    return (same == dim - 1)\n\n\ndef quickhull(POINTS, abs_tol=1e-7):\n    """"""Compute the convex hull of a set of points.\n\n    @param POINTS: a n*d np array where each row denotes a point\n\n    @return: A,b,vertices: `A` and `b describing the convex hull\n        polytope as A x <= b (H-representation). `vertices is a list\n        of all the points in the convex hull (V-representation).\n    """"""\n    POINTS = POINTS.astype(\'float\')\n    sh = np.shape(POINTS)\n    dim = sh[1]\n    npt = sh[0]\n    if npt <= dim:\n        # Convex hull is empty\n        return np.array([]), np.array([]), None\n    # Check if convex hull is fully dimensional\n    u, s, v = np.linalg.svd(np.transpose(POINTS - POINTS[0, :]))\n    rank = np.sum(s > 1e-15)\n    if rank < dim:\n        print(\n            ""Warning: convex hull is not fully dimensional, ""\n            ""returning empty polytope"")\n        return np.array([]), np.array([]), None\n    # Choose starting simplex by choosing maximum\n    # points in random directions\n    rank = 0\n    while rank < dim:\n        ind = []\n        d = 0\n        while d < dim + 1:\n            rand = np.random.rand(dim) - 0.5\n            test = np.dot(POINTS, rand)\n            index = np.argsort(test)\n            i = 0\n            b = index[i] in ind\n            while b:\n                i += 1\n                b = index[i] in ind\n            ind.append(index[i])\n            d += 1\n        startsimplex = POINTS[ind, :]\n        u, s, v = np.linalg.svd(\n            np.transpose(startsimplex - startsimplex[0, :]))\n        rank = np.sum(s > 1e-10)\n    unassigned_points = POINTS[np.setdiff1d(range(npt), ind), :]\n    # Center starting simplex around origin by translation\n    xc = np.zeros(dim)\n    for ii in range(dim + 1):\n        xc += startsimplex[ii, :] / (dim + 1)\n    startsimplex = startsimplex - xc\n    unassigned_points = unassigned_points - xc\n    Forg = []\n    F = []\n    R = []\n    for i in range(dim + 1):\n        ind = np.setdiff1d(np.arange(dim + 1), [i])\n        fac = Facet(startsimplex[ind, :])\n        Forg.append(fac)\n    if npt == dim + 1:\n        # If only d+1 facets, we already have convex hull\n        num = len(Forg)\n        A = np.zeros([num, dim])\n        b = np.zeros([num, 1])\n        vert = np.zeros([num * dim, dim])\n        for ii in range(num):\n            idx = np.ix_(range(ii * dim, (ii + 1) * dim))\n            vert[idx, :] = Forg[ii].vertices + xc\n            A[ii, :] = Forg[ii].normal.flatten()\n            b[ii] = Forg[ii].distance\n        vert = np.unique(\n            vert.view([(\'\', vert.dtype)] * vert.shape[1])).view(\n                vert.dtype).reshape(-1, vert.shape[1])\n        b = b.flatten() + np.dot(A, xc.flatten())\n        return A, b.flatten(), vert\n    for ii in range(len(Forg)):\n        # In the starting simplex, all facets are neighbors\n        for jj in range(ii + 1, len(Forg)):\n            fac1 = Forg[ii]\n            fac2 = Forg[jj]\n            ind = np.setdiff1d(np.arange(dim + 1), [ii, jj])\n            fac1.neighbors.append(fac2)\n            fac2.neighbors.append(fac1)\n    for fac1 in Forg:\n        # Assign outside points to facets\n        npt = np.shape(unassigned_points)[0]\n        keep_list = np.ones(npt, dtype=int)\n        for ii in range(npt):\n            if npt == 1:\n                pu = unassigned_points\n            else:\n                pu = unassigned_points[ii, :]\n            d = distance(pu, fac1)\n            if d > abs_tol:\n                op = Outside_point(pu.flatten(), d)\n                fac1.outside.append(op)\n                keep_list[ii] = 0\n        if len(fac1.outside) > 0:\n            F.append(fac1)\n        ind = np.nonzero(keep_list)[0]\n        if len(ind) > 0:\n            unassigned_points = unassigned_points[ind, :]\n        else:\n            unassigned_points = None\n            break\n    # We now have a collection F of facets with outer points!\n    # Selecting the point furthest away from a facet\n    while len(F) > 0:\n        facet = F[0]\n        p = facet.get_furthest().coordinates\n        V = []  # Initialize visible set\n        # Want to add all facets that are visible from p\n        Ncoll = []  # Set of unvisited neighbors\n        visited = []\n        V.append(facet)  # facet itself is visible by definition\n        visited.append(facet)  # facet is visited\n        for N in facet.neighbors:  # add all neighbors for visit\n            Ncoll.append(N)\n        while len(Ncoll) > 0:  # Visit all neighbours\n            N = Ncoll[0]\n            visited.append(N)\n            if distance(p, N) > abs_tol:\n                V.append(N)\n                for neighbor in N.neighbors:\n                    if (neighbor not in visited) & (neighbor not in Ncoll):\n                        Ncoll.append(neighbor)\n            del Ncoll[0]\n        # Should now have all visible facets in V\n        NV = []\n        unassigned_points = None\n        for fac1 in V:\n            # Move points from facets in V to the set unassigned_points\n            N = len(fac1.outside)\n            for ii in range(N):\n                if unassigned_points is None:\n                    unassigned_points = np.array(\n                        [fac1.outside[ii].coordinates])\n                else:\n                    unassigned_points = np.vstack(\n                        [unassigned_points, fac1.outside[ii].coordinates])\n        for fac1 in V:\n            # Figure out the boundary of V, and create new facets\n            for fac2 in fac1.neighbors:\n                if not (fac2 in V):\n                    # fac1 is on the boundary!\n                    # Create new facet from intersection between fac1 and fac2\n                    # and p\n                    vert1 = fac1.vertices\n                    vert2 = fac2.vertices\n                    for ii in range(dim):\n                        p1 = vert1[ii, :]\n                        test = np.sum(vert2 == p1, 1)\n                        if not np.any(test == dim):\n                            ind = np.setdiff1d(np.arange(dim), np.array([ii]))\n                            points = vert1[ind]\n                            break\n                    points = np.vstack([p, points])\n                    # Vertex points are in points\n                    R = Facet(points)\n                    R.neighbors.append(fac2)\n                    fac2.neighbors.append(R)\n                    NV.append(R)\n        # Establish other neighbor relations in NV\n        for ii in range(len(NV)):\n            for jj in range(ii + 1, len(NV)):\n                if is_neighbor(NV[ii], NV[jj], abs_tol=abs_tol):\n                    NV[ii].neighbors.append(NV[jj])\n                    NV[jj].neighbors.append(NV[ii])\n        # Assign unassigned points to facets in NV,\n        # and add facets to F or Forg\n        for fac1 in NV:\n            if unassigned_points is None:\n                Forg.append(fac1)\n                continue\n            npt = np.shape(unassigned_points)[0]\n            keep_list = np.ones(npt, dtype=int)\n            for ii in range(npt):\n                if npt == 1:\n                    pu = unassigned_points\n                else:\n                    pu = unassigned_points[ii, :]\n                d = distance(pu, fac1)\n                if d > abs_tol:\n                    op = Outside_point(pu.flatten(), d)\n                    fac1.outside.append(op)\n                    keep_list[ii] = 0\n            if len(fac1.outside) > 0:\n                F.append(fac1)\n                Forg.append(fac1)\n            else:\n                Forg.append(fac1)\n            ind = np.nonzero(keep_list)\n            if len(ind[0]) > 0:\n                unassigned_points = unassigned_points[ind[0], :]\n            else:\n                unassigned_points = None\n        # Delete facets in V, and neighbor references\n        for fac1 in V:\n            for fac2 in fac1.neighbors:\n                fac2.neighbors.remove(fac1)\n            if fac1 in F:\n                F.remove(fac1)\n            Forg.remove(fac1)\n            fac1.neighbors = []\n        V = []\n    num = len(Forg)\n    A = np.zeros([num, dim])\n    b = np.zeros([num, 1])\n    vert = np.zeros([num * dim, dim])\n    for ii in range(num):\n        vert[np.ix_(range(ii * dim, (ii + 1) * dim)),\n             :] = Forg[ii].vertices + xc\n        A[ii, :] = Forg[ii].normal.flatten()\n        b[ii] = Forg[ii].distance\n    vert = np.unique(\n        vert.view([(\'\', vert.dtype)] * vert.shape[1])).view(\n            vert.dtype).reshape(-1, vert.shape[1])\n    b = b.flatten() + np.dot(A, xc.flatten())\n    return A, b.flatten(), vert\n'"
polytope/solvers.py,2,"b'# Copyright (c) 2011-2017 by California Institute of Technology\n# All rights reserved. Licensed under 3-clause BSD.\n""""""Interface to linear programming solvers.\n\nThe `polytope` package selects the default solver as follows:\n\n1. use GLPK if installed\n2. otherwise use SciPy\n\nYou can change this default at runtime by setting the variable\n`default_solver` in the module `solvers`.\n\nFor example:\n\n```python\nfrom polytope import solvers\n\nsolvers.default_solver = \'scipy\'\n\n# to inspect which solvers were successfully imported:\nprint(solvers.installed_solvers)\n```\n\nChoose an installed solver to avoid errors.\n""""""\nfrom __future__ import absolute_import\nimport logging\n\nimport numpy as np\nfrom scipy import optimize\n\n\nlogger = logging.getLogger(__name__)\ninstalled_solvers = {\'scipy\'}\ntry:\n    import cvxopt as cvx\n    import cvxopt.glpk\n    from cvxopt import matrix\n\n    installed_solvers.add(\'glpk\')\n    # Hide optimizer output\n    cvx.solvers.options[\'show_progress\'] = False\n    cvx.glpk.options[\'msg_lev\'] = \'GLP_MSG_OFF\'\nexcept ImportError:\n    logger.warning(\n        \'`polytope` failed to import `cvxopt.glpk`.\')\ntry:\n    import mosek\n    installed_solvers.add(\'mosek\')\nexcept ImportError:\n    logger.info(\'MOSEK solver not found.\')\n\n\n# choose default from installed choices\nif \'glpk\' in installed_solvers:\n    default_solver = \'glpk\'\nelif \'scipy\' in installed_solvers:\n    default_solver = \'scipy\'\n    logger.warning(\'will use `scipy.optimize.linprog`\')\nelse:\n    raise ValueError(\n        ""`installed_solvers` wasn\'t empty above?"")\n\n\n\ndef lpsolve(c, G, h, solver=None):\n    """"""Try to solve linear program with given or default solver.\n\n    Solvers:\n        - `cvxopt.glpk`: identified by `\'glpk\'`\n        - `scipy.optimize.linprog`: identified by `\'scipy\'`\n        - MOSEK: identified by `\'mosek\'`\n\n    @param solver:\n        - `in {\'glpk\', \'mosek\', \'scipy\'}`\n        - `None`: use the module\'s `default_solver`\n\n        You can change the default choice of solver by setting\n        the module variable `default_solver`. See the module\'s\n        docstring for an example.\n\n    @return: solution with status as in `scipy.optimize.linprog`\n    @rtype: `dict(status=int, x=argmin, fun=min_value)`\n    """"""\n    if solver is None:\n        solver = default_solver\n    if solver == \'glpk\' or solver == \'mosek\':\n        result = _solve_lp_using_cvxopt(c, G, h, solver=solver)\n    elif solver == \'scipy\':\n        result = _solve_lp_using_scipy(c, G, h)\n    else:\n        raise Exception(\n            \'unknown LP solver ""{s}"".\'.format(s=solver))\n    return result\n\n\ndef _solve_lp_using_cvxopt(c, G, h, A=None, b=None, solver=\'glpk\'):\n    """"""Attempt linear optimization using `cvxopt.glpk` or MOSEK.\n\n    @param solver: `in {\'glpk\', \'mosek\'}`\n    """"""\n    _assert_have_solver(solver)\n    if A is not None:\n        A = matrix(A)\n    if b is not None:\n        b = matrix(b)\n    sol = cvx.solvers.lp(\n        c=matrix(c), G=matrix(G), h=matrix(h),\n        A=A, b=b, solver=solver)\n    result = dict()\n    if sol[\'status\'] == \'optimal\':\n        result[\'status\'] = 0\n    elif sol[\'status\'] == \'primal infeasible\':\n        result[\'status\'] = 2\n    elif sol[\'status\'] == \'dual infeasible\':\n        result[\'status\'] = 3\n    elif sol[\'status\'] == \'unknown\':\n        result[\'status\'] = 4\n    else:\n        raise ValueError((\n            \'`cvxopt.solvers.lp` returned unexpected \'\n            \'status value: {v}\').format(v=sol[\'status\']))\n    # `cvxopt.solvers.lp` returns an array of shape `(2, 1)`\n    # squeeze only the second dimension, to obtain a 1-D array\n    # thus match what `scipy.optimize.linprog` returns.\n    x = sol[\'x\']\n    if x is not None:\n        assert x.typecode == \'d\', x.typecode\n        result[\'x\'] = np.fromiter(x, dtype=np.double)\n    else:\n        result[\'x\'] = None\n    result[\'fun\'] = sol[\'primal objective\']\n    return result\n\n\ndef _solve_lp_using_scipy(c, G, h):\n    """"""Attempt linear optimization using `scipy.optimize.linprog`.""""""\n    _assert_have_solver(\'scipy\')\n    sol = optimize.linprog(\n        c, G, np.transpose(h),\n        None, None, bounds=(None, None))\n    return dict(\n        status=sol.status,\n        x=sol.x,\n        fun=sol.fun)\n\n\ndef _assert_have_solver(solver):\n    """"""Raise `RuntimeError` if `solver` is absent.""""""\n    if solver in installed_solvers:\n        return\n    raise RuntimeError((\n        \'solver {solver} not in \'\n        \'installed solvers: {have}\').format(\n            solver=solver, have=installed_solvers))\n'"
polytope/version.py,0,"b'# Copyright (c) 2014 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n""""""polytope package version""""""\nimport os.path\n\nversion_info = (0, 2, 3)\n\nversion = \'.\'.join([str(x) for x in version_info])\n\n\n# Append annotation to version string to indicate development versions.\n#\n# An empty (modulo comments and blank lines) commit_hash.txt is used\n# to indicate a release, in which case nothing is appended to version\n# string as defined above.\npath_to_hashfile = os.path.join(os.path.dirname(__file__), ""commit_hash.txt"")\nif os.path.exists(path_to_hashfile):\n    commit_hash = """"\n    with open(path_to_hashfile, ""r"") as f:\n        for line in f:\n            line = line.strip()\n            if len(line) == 0 or line[0] == \'#\':\n                # Ignore blank lines and comments, the latter being\n                # any line that begins with #.\n                continue\n\n            # First non-blank line is assumed to be the commit hash\n            commit_hash = line\n            break\n\n    if len(commit_hash) > 0:\n        version += "".dev0+"" + commit_hash\nelse:\n    version += "".dev0+unknown.commit""\n'"
tests/plot_test.py,0,"b'#!/usr/bin/env python\n""""""Tests for plotting.""""""\nimport matplotlib.patches\n\nimport polytope as pc\nfrom polytope import plot\n\n\nclass Axes(object):\n    """"""Mock class.""""""\n\n    def add_patch(self, x):\n        pass\n\n\ndef test_plot_transition_arrow():\n    p0 = pc.box2poly([[0.0, 1.0], [0.0, 2.0]])\n    p1 = pc.box2poly([[0.1, 2.0], [0.0, 2.0]])\n    # matplotlib.patches is loaded also by matplotlib.pyplot\n    # and .figures, so instantiating real Axes w/o\n    # loading patches is impossible\n    ax = Axes()\n    arrow = plot.plot_transition_arrow(p0, p1, ax=ax)\n    assert(isinstance(arrow, matplotlib.patches.Arrow))\n'"
tests/polytope_test.py,88,"b'#!/usr/bin/env python\n""""""Tests for the polytope subpackage.""""""\nimport logging\n\nfrom nose import tools as nt\nimport numpy as np\nfrom numpy.testing import assert_allclose\nfrom numpy.testing import assert_array_equal\nimport scipy.optimize\n\nimport polytope as pc\nfrom polytope.polytope import solve_rotation_ap, givens_rotation_matrix\nfrom polytope import solvers\n\nlog = logging.getLogger(\'polytope.polytope\')\nlog.setLevel(logging.INFO)\n\n\ndef test_polytope_str():\n    # 1 constaint (so uniline)\n    A = np.array([[1]])\n    b = np.array([1])\n    p = pc.Polytope(A, b)\n    s = str(p)\n    s_ = \'Single polytope \\n  [[1.]] x <= [[1.]]\\n\'\n    assert s == s_, (s, s_)\n    # > 1 constraints (so multiline)\n    polys = dict(\n        p1d=[[0, 1]],\n        p2d=[[0, 1], [0, 2]],\n        p3d=[[0, 1], [0, 2], [0, 3]])\n    strings = dict(\n        p1d=\'Single polytope \\n  [[ 1.] x <= [[1.]\\n   [-1.]]|     [0.]]\\n\',\n        p2d=(\n            \'Single polytope \\n  [[ 1.  0.] |    [[1.]\\n   [ 0.  1.] \'\n            \'x <=  [2.]\\n   [-1. -0.] |     [0.]\\n   [-0. -1.]]|\'\n            \'     [0.]]\\n\'),\n        p3d=(\n            \'Single polytope \\n  [[ 1.  0.  0.] |    [[1.]\\n   \'\n            \'[ 0.  1.  0.] |     [2.]\\n   [ 0.  0.  1.] x <=  [3.]\\n\'\n            \'   [-1. -0. -0.] |     [0.]\\n   [-0. -1. -0.] |\'\n            \'     [0.]\\n   [-0. -0. -1.]]|     [0.]]\\n\'))\n    for name, poly in polys.items():\n        p = pc.Polytope.from_box(poly)\n        s = str(p)\n        s_ = strings[name]\n        assert s == s_, (s, s_)\n\n\nclass operations_test(object):\n    def setUp(self):\n        # unit square in first quadrant\n        self.Ab = np.array([[0.0, 1.0, 1.0],\n                            [0.0, -1.0, 0.0],\n                            [1.0, 0.0, 1.0],\n                            [-1.0, 0.0, 0.0]])\n\n        # unit square in second quadrant\n        self.Ab2 = np.array([[-1.0, 0.0, 1.0],\n                             [1.0, 0.0, 0.0],\n                             [0.0, 1.0, 1.0],\n                             [0.0, -1.0, 0.0]])\n\n        # unit square in third quadrant\n        self.Ab3 = np.array([[0.0, 1.0, 0.0],\n                             [0.0, -1.0, 1.0],\n                             [1.0, 0.0, 0.0],\n                             [-1.0, 0.0, 1.0]])\n\n        # unit square in fourth quadrant\n        self.Ab4 = np.array([[0.0, 1.0, 0.0],\n                             [0.0, -1.0, 1.0],\n                             [1.0, 0.0, 1.0],\n                             [-1.0, 0.0, 0.0]])\n\n        self.A = self.Ab[:, 0:2]\n        self.b = self.Ab[:, 2]\n\n    def tearDown(self):\n        pass\n\n\n    def comparison_test(self):\n        p = pc.Polytope(self.A, self.b)\n        p2 = pc.Polytope(self.A, 2*self.b)\n\n        assert(p <= p2)\n        assert(not p2 <= p)\n        assert(not p2 == p)\n\n        r = pc.Region([p])\n        r2 = pc.Region([p2])\n\n        assert(r <= r2)\n        assert(not r2 <= r)\n        assert(not r2 == r)\n\n        # test H-rep -> V-rep -> H-rep\n        v = pc.extreme(p)\n        p3 = pc.qhull(v)\n        assert(p3 == p)\n\n        # test V-rep -> H-rep with d+1 points\n        p4 = pc.qhull(np.array([[0, 0], [1, 0], [0, 1]]))\n        assert(p4 == pc.Polytope(\n            np.array([[1, 1], [0, -1], [0, -1]]),\n            np.array([1, 0, 0])))\n\n\n    def region_rotation_test(self):\n        p = pc.Region([pc.Polytope(self.A, self.b)])\n        p1 = pc.Region([pc.Polytope(self.A, self.b)])\n        p2 = pc.Region([pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])])\n        p3 = pc.Region([pc.Polytope(self.Ab3[:, 0:2], self.Ab3[:, 2])])\n        p4 = pc.Region([pc.Polytope(self.Ab4[:, 0:2], self.Ab4[:, 2])])\n\n        p = p.rotation(0, 1, np.pi/2)\n        print(p.bounding_box)\n        assert(p == p2)\n        assert(not p == p3)\n        assert(not p == p4)\n        assert(not p == p1)\n        assert_allclose(p.chebXc, [-0.5, 0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p3)\n        assert_allclose(p.chebXc, [-0.5, -0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p4)\n        assert_allclose(p.chebXc, [0.5, -0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p1)\n        assert_allclose(p.chebXc, [0.5, 0.5])\n\n\n    def polytope_rotation_test(self):\n        p = pc.Polytope(self.A, self.b)\n        p1 = pc.Polytope(self.A, self.b)\n        p2 = pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])\n        p3 = pc.Polytope(self.Ab3[:, 0:2], self.Ab3[:, 2])\n        p4 = pc.Polytope(self.Ab4[:, 0:2], self.Ab4[:, 2])\n\n        p = p.rotation(0, 1, np.pi/2)\n        print(p.bounding_box)\n        assert(p == p2)\n        assert(not p == p3)\n        assert(not p == p4)\n        assert(not p == p1)\n        assert_allclose(p.chebXc, [-0.5, 0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p3)\n        assert_allclose(p.chebXc, [-0.5, -0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p4)\n        assert_allclose(p.chebXc, [0.5, -0.5])\n\n        p = p.rotation(0, 1, np.pi/2)\n        assert(p == p1)\n        assert_allclose(p.chebXc, [0.5, 0.5])\n\n\n    def region_translation_test(self):\n        p = pc.Region([pc.Polytope(self.A, self.b)])\n        p1 = pc.Region([pc.Polytope(self.A, self.b)])\n        p2 = pc.Region([pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])])\n\n        p = p.translation([-1, 0])\n        assert(p == p2)\n        assert(not p == p1)\n        p = p.translation([1, 0])\n        assert(p == p1)\n\n\n    def polytope_translation_test(self):\n        p = pc.Polytope(self.A, self.b)\n        p1 = pc.Polytope(self.A, self.b)\n        p2 = pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])\n\n        p = p.translation([-1, 0])\n        assert(p == p2)\n        assert(not p == p1)\n        p = p.translation([1, 0])\n        assert(p == p1)\n\n    def region_empty_test(self):\n        # Note that as of commit a037b555758ed9ee736fa7cb324d300b8d622fb4\n        # Region.__init__ deletes empty polytopes from\n        # the given list of polytopes at instantiation.\n        reg = pc.Region()\n        reg.list_poly = [pc.Polytope(), pc.Polytope()]\n        assert len(reg) > 0\n        assert pc.is_empty(reg)\n\n    def polytope_full_dim_test(self):\n        assert pc.is_fulldim(pc.Polytope(self.A, self.b))\n        assert pc.is_fulldim(pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2]))\n        assert not pc.is_fulldim(pc.Polytope())\n        assert not pc.is_fulldim(pc.Polytope(self.A, self.b - 1e3))\n\n    def region_full_dim_test(self):\n        assert not pc.is_fulldim(pc.Region())\n\n        p1 = pc.Polytope(self.A, self.b)\n        p2 = pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])\n        reg = pc.Region([p1, p2])\n        assert pc.is_fulldim(reg)\n\n        # Adding empty polytopes should not affect the\n        # full-dimensional status of this region.\n        reg.list_poly.append(pc.Polytope())\n        assert pc.is_fulldim(reg)\n        reg.list_poly.append(pc.Polytope(self.A, self.b - 1e3))\n        assert pc.is_fulldim(reg)\n\n    def polytope_intersect_test(self):\n        p1 = pc.Polytope(self.A, self.b)\n        p2 = pc.Polytope(self.Ab2[:, 0:2], self.Ab2[:, 2])\n        p3 = p1.intersect(p2)\n        assert pc.is_fulldim(p1)\n        assert pc.is_fulldim(p2)\n        assert not pc.is_fulldim(p3)\n\n        # p4 is the unit square with center at the origin.\n        p4 = pc.Polytope(np.array([[ 1.,  0.],\n                                   [ 0.,  1.],\n                                   [-1.,  0.],\n                                   [ 0., -1.]]),\n                         np.array([0.5, 0.5, 0.5, 0.5]))\n        p5 = p2.intersect(p4)\n        assert pc.is_fulldim(p4)\n        assert pc.is_fulldim(p5)\n\n    def polytope_contains_test(self):\n        p = pc.Polytope(self.A, self.b)\n        # single point\n        point_i = [0.1, 0.3]\n        point_o = [2, 0]\n        assert point_i in p\n        assert point_o not in p\n        # multiple points\n        many_points_i = np.random.random((2, 8))\n        many_points_0 = np.random.random((2, 8)) - np.array([[0], [1]])\n        many_points = np.concatenate([many_points_0, many_points_i], axis=1)\n        truth = np.array([False] * 8 + [True] * 8, dtype=bool)\n        assert_array_equal(p.contains(many_points), truth)\n\n    def region_contains_test(self):\n        A = np.array([[1.0],\n                      [-1.0]])\n        b = np.array([1.0, 0.0])\n        poly = pc.Polytope(A, b)\n        polys = [poly]\n        reg = pc.Region(polys)\n        assert 0.5 in reg\n        # small positive tolerance (includes boundary)\n        points = np.array([[-1.0, 0.0, 0.5, 1.0, 2.0]])\n        c = reg.contains(points)\n        c_ = np.array(\n            [[False, True, True, True, False]], dtype=bool)\n        # zero tolerance (excludes boundary)\n        points = np.array([[-1.0, 0.0, 0.5, 1.0, 2.0]])\n        c = reg.contains(points, abs_tol=0)\n        c_ = np.array(\n            [[False, False, True, False, False]], dtype=bool)\n        assert np.all(c == c_), c\n\n    def is_inside_test(self):\n        box = [[0.0, 1.0], [0.0, 2.0]]\n        p = pc.Polytope.from_box(box)\n        point = np.array([0.0, 1.0])\n        abs_tol = 0.01\n        assert pc.is_inside(p, point)\n        assert pc.is_inside(p, point, abs_tol)\n        region = pc.Region([p])\n        assert pc.is_inside(region, point)\n        assert pc.is_inside(region, point, abs_tol)\n        point = np.array([2.0, 0.0])\n        assert not pc.is_inside(p, point)\n        assert not pc.is_inside(p, point, abs_tol)\n        region = pc.Region([p])\n        assert not pc.is_inside(region, point)\n        assert not pc.is_inside(region, point, abs_tol)\n        abs_tol = 1.2\n        assert pc.is_inside(p, point, abs_tol)\n        assert pc.is_inside(region, point, abs_tol)\n\n\ndef solve_rotation_test_090(atol=1e-15):\n    g1 = np.array([0, 1, 1, 0])\n    g2 = np.array([0, 1, 0, 0])\n    R = solve_rotation_ap(g1, g2)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, 1, -1, 1])\n    t1 = np.array([0, -1, 0, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef solve_rotation_test_180(atol=1e-15):\n    g1 = np.array([0, 1, 0, 0])\n    g2 = np.array([0, 0, 1, 0])\n    R = solve_rotation_ap(g1, g2)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, -1, -1, 1])\n    t1 = np.array([0, 0, 1, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef solve_rotation_test_270R(atol=1e-15):\n    g1 = np.array([0, -1, 0, 0])\n    g2 = np.array([0, 1, 1, 0])\n    R = solve_rotation_ap(g1, g2)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, -1, 1, 1])\n    t1 = np.array([0, 1, 0, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef solve_rotation_test_270L(atol=1e-15):\n    g1 = np.array([0, -1, 0, 0])\n    g2 = np.array([0, 1, -1, 0])\n    R = solve_rotation_ap(g1, g2)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, 1, -1, 1])\n    t1 = np.array([0, -1, 0, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef givens_rotation_test_180(atol=1e-15):\n    R = givens_rotation_matrix(1, 2, np.pi, 4)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, -1, -1, 1])\n    t1 = np.array([0, 0, 1, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef givens_rotation_test_270L(atol=1e-15):\n    g1 = np.array([0, -1, 0, 0])\n    g2 = np.array([0, 1, -1, 0])\n    R = givens_rotation_matrix(1, 2, 3*np.pi/2, 4)\n\n    e0 = np.array([0, 1, 1, 1])\n    e1 = np.array([0, 0, -1, 0])\n    e2 = np.array([0, 0, 0, 0])\n\n    t0 = np.array([0, 1, -1, 1])\n    t1 = np.array([0, -1, 0, 0])\n    t2 = np.array([0, 0, 0, 0])\n\n    assert_allclose(R.dot(e0), t0, atol=atol)\n    assert_allclose(R.dot(e1), t1, atol=atol)\n    assert_allclose(R.dot(e2), t2, atol=atol)\n\n\ndef test_lpsolve():\n    # Ensure same API for both `scipy` and `cvxopt`.\n    # Ensured by the different testing configurations.\n    # Could change `polytope.polytope.default_solver` to\n    # achieve the same result, when `cvxopt.glpk` is present.\n    #\n    # 2-D example\n    c = np.array([1, 1], dtype=float)\n    A = np.array([[-1, 0], [0, -1]], dtype=float)\n    b = np.array([1, 1], dtype=float)\n    res = solvers.lpsolve(c, A, b)\n    x = res[\'x\']\n    assert x.ndim == 1, x.ndim\n    assert x.shape == (2,), x.shape\n    #\n    # 1-D example\n    c, A, b = example_1d()\n    res = solvers.lpsolve(c, A, b)\n    x = res[\'x\']\n    assert x.ndim == 1, x.ndim\n    assert x.shape == (1,), x.shape\n\n\ndef example_1d():\n    c = np.array([1], dtype=float)\n    A = np.array([[-1]], dtype=float)\n    b = np.array([1], dtype=float)\n    return c, A, b\n\n\ndef test_lpsolve_solver_selection_scipy():\n    # should always work, because `polytope` requires `scipy`\n    c, A, b = example_1d()\n    r_ = np.array([-1.0])\n    # call directly to isolate from selection within `lpsolve`\n    r = solvers._solve_lp_using_scipy(c, A, b)\n    assert r[\'x\'] == r_, r[\'x\']\n    r = solvers.lpsolve(c, A, b, solver=\'scipy\')\n    assert r[\'x\'] == r_, r[\'x\']\n\n\ndef test_lpsolve_solver_selection_glpk_present():\n    c, A, b = example_1d()\n    have_glpk = is_glpk_present()\n    # skip if GLPK fails to import\n    if not have_glpk:\n        log.info(\n            \'Skipping GLPK test of `lpsolve` \'\n            \'because GLPK failed to import, \'\n            \'so assume not installed.\')\n        return\n    r = solvers.lpsolve(c, A, b, solver=\'glpk\')\n    assert r[\'x\'] == np.array([-1.0]), r[\'x\']\n\n\ndef test_lpsolve_solver_selection_glpk_absent():\n    c, A, b = example_1d()\n    have_glpk = is_glpk_present()\n    # skip if GLPK imports\n    if have_glpk:\n        log.info(\n            \'Skipping GLPK failure test, \'\n            \'because GLPK is present.\')\n        return\n    with nt.assert_raises(RuntimeError):\n        solvers.lpsolve(c, A, b, solver=\'glpk\')\n\n\ndef test_request_glpk_after_changing_default_to_scipy():\n    c, A, b = example_1d()\n    have_glpk = is_glpk_present()\n    if not have_glpk:\n        return\n    assert solvers.default_solver != \'scipy\'\n    solvers.default_solver = \'scipy\'\n    solvers.lpsolve(c, A, b, solver=\'glpk\')\n\n\ndef is_glpk_present():\n    """"""Return `True` if `cvxopt.glpk` imports.""""""\n    try:\n        import cvxopt.glpk\n        assert \'glpk\' in solvers.installed_solvers, (\n            solvers.installed_solvers)\n        return True\n    except ImportError:\n        assert \'glpk\' not in solvers.installed_solvers, (\n            solvers.installed_solvers)\n        return False\n\n\nif __name__ == \'__main__\':\n    pass\n'"
