file_path,api_count,code
setup.py,0,"b'import setuptools\n\nwith open(\'README.md\', encoding=\'utf-8\') as f:\n    long_description = f.read()\n\nsetuptools.setup(\n    name=\'discretisedfield\',\n    version=\'0.8.11\',\n    description=(\'Python package for definition, reading, \'\n                 \'and visualisation of finite difference fields.\'),\n    long_description=long_description,\n    long_description_content_type=\'text/markdown\',\n    url=\'https://ubermag.github.io\',\n    author=\'Marijan Beg, Ryan A. Pepper, Thomas Kluyver, and Hans Fangohr\',\n    packages=setuptools.find_packages(),\n    entry_points={\n        ""console_scripts"": [\n            ""ovf2vtk = discretisedfield.ovf2vtk:main"",\n        ],\n    },\n    include_package_data=True,\n    install_requires=[\'ubermagutil\',\n                      \'matplotlib\',\n                      \'pandas\',\n                      \'jupyterlab\',\n                      \'seaborn\',\n                      \'h5py\',\n                      \'k3d\'],\n    classifiers=[\'Development Status :: 3 - Alpha\',\n                 \'License :: OSI Approved :: BSD License\',\n                 \'Programming Language :: Python :: 3 :: Only\',\n                 \'Operating System :: Unix\',\n                 \'Operating System :: MacOS\',\n                 \'Operating System :: Microsoft :: Windows\',\n                 \'Topic :: Scientific/Engineering :: Physics\',\n                 \'Intended Audience :: Science/Research\',\n                 \'Natural Language :: English\']\n)\n'"
discretisedfield/__init__.py,0,"b""import os\nimport pytest\nimport pkg_resources\nfrom .region import Region\nfrom .mesh import Mesh\nfrom .field import Field\nfrom .line import Line\nfrom .interact import interact\nimport matplotlib.pyplot as plt\n\n# Enable default plotting style.\ndirname = os.path.abspath(os.path.dirname(__file__))\npath = os.path.join(dirname, './util/plotting-style.mplstyle')\nplt.style.use(path)\n\n__version__ = pkg_resources.get_distribution(__name__).version\n__dependencies__ = pkg_resources.require(__name__)\n\n\ndef test():\n    return pytest.main(['-v', '--pyargs',\n                        'discretisedfield', '-l'])  # pragma: no cover\n"""
discretisedfield/field.py,65,"b'import k3d\nimport h5py\nimport struct\nimport numbers\nimport itertools\nimport numpy as np\nimport discretisedfield as df\nimport ubermagutil.units as uu\nimport matplotlib.pyplot as plt\nimport ubermagutil.typesystem as ts\nimport discretisedfield.util as dfu\n\n# TODO: tutorials (code polishing), remove numbers from tutorials, installation\n# instructions (conda environment, k3d jupyterlab), fft\n\n\n@ts.typesystem(mesh=ts.Typed(expected_type=df.Mesh, const=True),\n               dim=ts.Scalar(expected_type=int, positive=True, const=True))\nclass Field:\n    """"""Finite difference field.\n\n    This class defines a finite difference field and enables certain operations\n    for its analysis and visualisation. The field is defined on a finite\n    difference mesh (`discretisedfield.Mesh`) passed by using ``mesh``. Another\n    value that must be passed is the dimension of the value using ``dim``. More\n    precisely, if the field is a scalar field ``dim=1`` must be passed. On the\n    other hand, for a three-dimensional vector field ``dim=3`` is passed. The\n    value of the field can be set by passing ``value``. For details on how the\n    value can be set, please refer to ``discretisedfield.Field.value``.\n    Similarly, if the field has ``dim>1``, the field can be normalised by\n    passing ``norm``. For details on setting the norm, please refer to\n    ``discretisedfield.Field.norm``.\n\n    Parameters\n    ----------\n    mesh : discretisedfield.Mesh\n\n        Finite difference rectangular mesh.\n\n    dim : int\n\n        Dimension of the field\'s value. For instance, if `dim=3` the field is a\n        three-dimensional vector field and for `dim=1` the field is a scalar\n        field.\n\n    value : array_like, callable, optional\n\n        Please refer to ``discretisedfield.Field.value`` property. Defaults to\n        0, meaning that if the value is not provided in the initialisation,\n        ""zero-field"" will be defined.\n\n    norm : numbers.Real, callable, optional\n\n        Please refer to ``discretisedfield.Field.norm`` property. Defaults to\n        ``None`` (``norm=None`` defines no norm).\n\n    Examples\n    --------\n    1. Defining a uniform three-dimensional vector field on a nano-sized thin\n    film.\n\n    >>> import discretisedfield as df\n    ...\n    >>> p1 = (-50e-9, -25e-9, 0)\n    >>> p2 = (50e-9, 25e-9, 5e-9)\n    >>> cell = (1e-9, 1e-9, 0.1e-9)\n    >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n    >>> dim = 3\n    >>> value = (0, 0, 1)\n    ...\n    >>> field = df.Field(mesh=mesh, dim=dim, value=value)\n    >>> field\n    Field(mesh=...)\n    >>> field.average\n    (0.0, 0.0, 1.0)\n\n    2. Defining a scalar field.\n\n    >>> p1 = (-10, -10, -10)\n    >>> p2 = (10, 10, 10)\n    >>> n = (1, 1, 1)\n    >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n    >>> dim = 1\n    >>> value = 3.14\n    ...\n    >>> field = df.Field(mesh=mesh, dim=dim, value=value)\n    >>> field\n    Field(mesh=...)\n    >>> field.average\n    3.14\n\n    3. Defining a uniform three-dimensional normalised vector field.\n\n    >>> import discretisedfield as df\n    ...\n    >>> p1 = (-50e9, -25e9, 0)\n    >>> p2 = (50e9, 25e9, 5e9)\n    >>> cell = (1e9, 1e9, 0.1e9)\n    >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n    >>> dim = 3\n    >>> value = (0, 0, 8)\n    >>> norm = 1\n    ...\n    >>> field = df.Field(mesh=mesh, dim=dim, value=value, norm=norm)\n    >>> field\n    Field(mesh=...)\n    >>> field.average\n    (0.0, 0.0, 1.0)\n\n    .. seealso:: :py:func:`~discretisedfield.Mesh`\n\n    """"""\n    def __init__(self, mesh, dim, value=0, norm=None):\n        self.mesh = mesh\n        self.dim = dim\n        self.value = value\n        self.norm = norm\n\n    @property\n    def value(self):\n        """"""Field value representation.\n\n        This property returns a representation of the field value if it exists.\n        Otherwise, ``discretisedfield.Field.array`` containing all field values\n        is returned.\n\n        The value of the field can be set using a scalar value for ``dim=1``\n        fields (e.g. ``value=3``) or ``array_like`` value for ``dim>1`` fields\n        (e.g. ``value=(1, 2, 3)``). Alternatively, the value can be defined\n        using a callable object, which takes a point tuple as an input argument\n        and returns a value of appropriate dimension. Internally, callable\n        object is called for every point in the mesh on which the field is\n        defined. For instance, callable object can be a Python function or\n        another ``discretisedfield.Field``. Finally, ``numpy.ndarray`` with\n        shape ``(*self.mesh.n, dim)`` can be passed.\n\n        Parameters\n        ----------\n        value : numbers.Real, array_like, callable\n\n            For scalar fields (``dim=1``) ``numbers.Real`` values are allowed.\n            In the case of vector fields, ``array_like`` (list, tuple,\n            numpy.ndarray) value with length equal to `dim` should be used.\n            Finally, the value can also be a callable (e.g. Python function or\n            another field), which for every coordinate in the mesh returns a\n            valid value. If ``value=0``, all values in the field will be set to\n            zero independent of the field dimension.\n\n        Returns\n        -------\n        array_like, callable, numbers.Real, numpy.ndarray\n\n            The value used (representation) for setting the field is returned.\n            However, if the actual value of the field does not correspond to\n            the initially used value anymore, a ``numpy.ndarray`` is returned\n            containing all field values.\n\n        Raises\n        ------\n        ValueError\n\n            If unsupported type is passed.\n\n        Examples\n        --------\n        1. Different ways of setting and getting the field value.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> value = (0, 0, 1)\n        ...\n        >>> # if value is not specified, zero-field is defined\n        >>> field = df.Field(mesh=mesh, dim=3)\n        >>> field.value\n        0\n        >>> field.value = (0, 0, 1)\n        >>> field.value\n        (0, 0, 1)\n        >>> # Setting the field value using a Python function (callable).\n        >>> def value_function(point):\n        ...     x, y, z = point\n        ...     if x <= 1:\n        ...         return (0, 0, 1)\n        ...     else:\n        ...         return (0, 0, -1)\n        >>> field.value = value_function\n        >>> field.value\n        <function value_function at ...>\n        >>> # We now change the value of a single cell so that the\n        >>> # representation used for initialising field is not valid\n        >>> # anymore.\n        >>> field.array[0, 0, 0, :] = (0, 0, 0)\n        >>> field.value\n        array(...)\n        >>> field.value.shape\n        (2, 2, 1, 3)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.array`\n\n        """"""\n        value_array = dfu.as_array(self.mesh, self.dim, self._value)\n        if np.array_equal(self.array, value_array):\n            return self._value\n        else:\n            return self.array\n\n    @value.setter\n    def value(self, val):\n        self._value = val\n        self.array = dfu.as_array(self.mesh, self.dim, val)\n\n    @property\n    def array(self):\n        """"""Field value as ``numpy.ndarray``.\n\n        The shape of the array is ``(*mesh.n, dim)``.\n\n        Parameters\n        ----------\n        array : numpy.ndarray\n\n            Array with shape ``(*mesh.n, dim)``.\n\n        Returns\n        -------\n        numpy.ndarray\n\n            Field values array.\n\n        Raises\n        ------\n        ValueError\n\n            If unsupported type or shape is passed.\n\n        Examples\n        --------\n        1. Accessing and setting the field array.\n\n        >>> import discretisedfield as df\n        >>> import numpy as np\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (1, 1, 1)\n        >>> cell = (0.5, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> value = (0, 0, 1)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=value)\n        >>> field.array\n        array(...)\n        >>> field.average\n        (0.0, 0.0, 1.0)\n        >>> field.array.shape\n        (2, 1, 1, 3)\n        >>> field.array = np.ones_like(field.array)\n        >>> field.array\n        array(...)\n        >>> field.average\n        (1.0, 1.0, 1.0)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.value`\n\n        """"""\n        return self._array\n\n    @array.setter\n    def array(self, val):\n        self._array = dfu.as_array(self.mesh, self.dim, val)\n\n    @property\n    def norm(self):\n        """"""Norm of the field.\n\n        Computes the norm of the field and returns it as\n        ``discretisedfield.Field`` with ``dim=1``. Norm of a scalar field\n        cannot be computed/set and ``ValueError`` is raised. Alternatively,\n        ``discretisedfield.Field.__abs__`` can be called for obtaining the norm\n        of the field.\n\n        The field norm can be set by passing ``numbers.Real``,\n        ``numpy.ndarray``, or callable. If the field has ``dim=1`` or it\n        contains zero values, norm cannot be set and ``ValueError`` is raised.\n\n        Parameters\n        ----------\n        numbers.Real, numpy.ndarray, callable\n\n            Norm value\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            ``dim=1`` norm field.\n\n        Raises\n        ------\n        ValueError\n\n            If the norm is set with wrong type, shape, or value. In addition,\n            if the field is scalar (``dim=1``) or the field contains zero\n            values.\n\n        Examples\n        --------\n        1. Manipulating the field norm.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (1, 1, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=(0, 0, 1))\n        >>> field.norm\n        Field(...)\n        >>> field.norm.average\n        1.0\n        >>> field.norm = 2\n        >>> field.average\n        (0.0, 0.0, 2.0)\n        >>> field.value = (1, 0, 0)\n        >>> field.norm.average\n        1.0\n        >>> # An attempt to set the norm for a zero field.\n        >>> field.value = 0\n        >>> field.average\n        (0.0, 0.0, 0.0)\n        >>> field.norm = 1\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.__abs__`\n\n        """"""\n        if self.dim == 1:\n            msg = f\'Cannot compute norm for field with dim={self.dim}.\'\n            raise ValueError(msg)\n\n        computed_norm = np.linalg.norm(self.array, axis=-1)[..., np.newaxis]\n        return self.__class__(self.mesh, dim=1, value=computed_norm)\n\n    @norm.setter\n    def norm(self, val):\n        if val is not None:\n            if self.dim == 1:\n                msg = f\'Cannot set norm for field with dim={self.dim}.\'\n                raise ValueError(msg)\n\n            if not np.all(self.norm.array):\n                msg = \'Cannot normalise field with zero values.\'\n                raise ValueError(msg)\n\n            self.array /= self.norm.array  # normalise to 1\n            self.array *= dfu.as_array(self.mesh, dim=1, val=val)\n\n    def __abs__(self):\n        """"""Field norm.\n\n        This method returns ``discretisedfield.Field.norm``.\n\n        .. seealso:: :py:func:`~discretisedfield.Field.norm`\n\n        """"""\n        return self.norm\n\n    @property\n    def zero(self):\n        """"""Zero field.\n\n        This method returns a zero field defined on the same mesh and with the\n        same value dimension.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Zero field.\n\n        Examples\n        --------\n        1. Getting the zero-field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 10, 13)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=(3, -1, 1))\n        >>> zero_field = field.zero\n        >>> zero_field.average\n        (0.0, 0.0, 0.0)\n\n        """"""\n        return self.__class__(self.mesh, dim=self.dim, value=0)\n\n    @property\n    def orientation(self):\n        """"""Orientation field.\n\n        This method computes the orientation (direction) of a vector field and\n        returns ``discretisedfield.Field`` with the same dimension. More\n        precisely, at every mesh discretisation cell, the vector is divided by\n        its norm, so that a unit vector is obtained. However, if the vector at\n        a discretisation cell is a zero-vector, it remains unchanged. In the\n        case of a scalar (``dim=1``) field, ``ValueError`` is raised.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Orientation field.\n\n        Raises\n        ------\n        ValueError\n\n            If the field is has ``dim=1``.\n\n        Examples\n        --------\n        1. Computing the orientation field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=(6, 0, 8))\n        >>> field.orientation\n        Field(...)\n        >>> field.orientation.norm.average\n        1.0\n\n        """"""\n        if self.dim == 1:\n            msg = (f\'Cannot compute orientation field for a \'\n                   f\'dim={self.dim} field.\')\n            raise ValueError(msg)\n\n        orientation_array = np.divide(self.array,\n                                      self.norm.array,\n                                      out=np.zeros_like(self.array),\n                                      where=(self.norm.array != 0))\n        return self.__class__(self.mesh, dim=self.dim, value=orientation_array)\n\n    @property\n    def average(self):\n        """"""Field average.\n\n        It computes the average of the field over the entire volume of the\n        mesh. It returns a tuple with the length same as the dimension\n        (``dim``) of the field.\n\n        Returns\n        -------\n        tuple\n\n            Field average tuple, whose length equals to the field\'s dimension.\n\n        Examples\n        --------\n        1. Computing the vector field average.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 5, 5)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=(0, 0, 1))\n        >>> field.average\n        (0.0, 0.0, 1.0)\n\n        2. Computing the scalar field average.\n\n        >>> field = df.Field(mesh=mesh, dim=1, value=55)\n        >>> field.average\n        55.0\n\n        """"""\n        return dfu.array2tuple(self.array.mean(axis=(0, 1, 2)))\n\n    def __repr__(self):\n        """"""Representation string.\n\n        Returns\n        -------\n        str\n\n            Representation string.\n\n        Example\n        -------\n        1. Getting representation string.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> field = df.Field(mesh, dim=1, value=1)\n        >>> repr(field)\n        ""Field(mesh=..., dim=1)""\n\n        """"""\n        return f""Field(mesh={repr(self.mesh)}, dim={self.dim})""\n\n    def __call__(self, point):\n        """"""Sample the field value at ``point``.\n\n        It returns the value of the field in the discretisation cell to which\n        ``point`` belongs to. It returns a tuple, whose length is the same as\n        the dimension (``dim``) of the field.\n\n        Parameters\n        ----------\n        point : (3,) array_like\n\n            The mesh point coordinate :math:`\\\\mathbf{p} = (p_{x}, p_{y},\n            p_{z})`.\n\n        Returns\n        -------\n        tuple\n\n            A tuple, whose length is the same as the dimension of the field.\n\n        Example\n        -------\n        1. Sampling the field value.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (20, 20, 20)\n        >>> n = (20, 20, 20)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n        ...\n        >>> field = df.Field(mesh, dim=3, value=(1, 3, 4))\n        >>> point = (10, 2, 3)\n        >>> field(point)\n        (1.0, 3.0, 4.0)\n\n        """"""\n        return dfu.array2tuple(self.array[self.mesh.point2index(point)])\n\n    def __getattr__(self, attr):\n        """"""Extracting the component of the vector field.\n\n        If ``\'x\'``, ``\'y\'``, or ``\'z\'`` is accessed, a scalar field of that\n        component will be returned. This method is effective for vector fields\n        with dimension 2 or 3 only.\n\n        Parameters\n        ----------\n        attr : str\n\n            Vector field component (``\'x\'``, ``\'y\'``, or ``\'z\'``)\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Scalar field with vector field component values.\n\n        Examples\n        --------\n        1. Accessing the vector field components.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 2)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> field = df.Field(mesh=mesh, dim=3, value=(0, 0, 1))\n        >>> field.x\n        Field(...)\n        >>> field.x.average\n        0.0\n        >>> field.y\n        Field(...)\n        >>> field.y.average\n        0.0\n        >>> field.z\n        Field(...)\n        >>> field.z.average\n        1.0\n        >>> field.z.dim\n        1\n\n        """"""\n        if attr in list(dfu.axesdict.keys())[:self.dim] and self.dim in (2, 3):\n            attr_array = self.array[..., dfu.axesdict[attr]][..., np.newaxis]\n            return self.__class__(mesh=self.mesh, dim=1, value=attr_array)\n        else:\n            msg = f\'Object has no attribute {attr}.\'\n            raise AttributeError(msg)\n\n    def __dir__(self):\n        """"""Extension of the ``dir(self)`` list.\n\n        Adds ``\'x\'``, ``\'y\'``, or ``\'z\'``, depending on the dimension of the\n        field, to the ``dir(self)`` list. Similarly, adds or removes methods\n        (``grad``, ``div``,...) depending on the dimension of the field.\n\n        Returns\n        -------\n        list\n\n            Avalilable attributes.\n\n        """"""\n        dirlist = dir(self.__class__)\n        if self.dim in (2, 3):\n            dirlist += list(dfu.axesdict.keys())[:self.dim]\n        if self.dim == 1:\n            need_removing = [\'div\', \'curl\', \'topological_charge\',\n                             \'topological_charge_density\', \'bergluescher\',\n                             \'norm\', \'orientation\', \'mpl_vector\',\n                             \'k3d_vectors\']\n        if self.dim == 3:\n            need_removing = [\'grad\', \'mpl_scalar\', \'k3d_voxels\', \'k3d_nonzero\']\n\n        for attr in need_removing:\n            dirlist.remove(attr)\n\n        return dirlist\n\n    def __iter__(self):\n        """"""Generator yielding coordinates and values of all mesh discretisation\n        cells.\n\n        Yields\n        ------\n        tuple (2,)\n\n            The first value is the mesh cell coordinates :math:`\\\\mathbf{p} =\n            (p_{x}, p_{y}, p_{z})`, whereas the second one is the field value.\n\n        Examples\n        --------\n        1. Iterating through the field coordinates and values\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> field = df.Field(mesh, dim=3, value=(0, 0, 1))\n        >>> for coord, value in field:\n        ...     print (coord, value)\n        (0.5, 0.5, 0.5) (0.0, 0.0, 1.0)\n        (1.5, 0.5, 0.5) (0.0, 0.0, 1.0)\n        (0.5, 1.5, 0.5) (0.0, 0.0, 1.0)\n        (1.5, 1.5, 0.5) (0.0, 0.0, 1.0)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.indices`\n\n        """"""\n        for point in self.mesh:\n            yield point, self(point)\n\n    def __eq__(self, other):\n        """"""Relational operator ``==``.\n\n        Two fields are considered to be equal if:\n\n          1. They are defined on the same mesh.\n\n          2. They have the same dimension (``dim``).\n\n          3. They both contain the same values in ``array``.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field\n\n            Second operand.\n\n        Returns\n        -------\n        bool\n\n            ``True`` if two fields are equal, ``False`` otherwise.\n\n        Examples\n        --------\n        1. Check if two fields are (not) equal.\n\n        >>> import discretisedfield as df\n        ...\n        >>> mesh = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), cell=(1, 1, 1))\n        ...\n        >>> f1 = df.Field(mesh, dim=1, value=3)\n        >>> f2 = df.Field(mesh, dim=1, value=4-1)\n        >>> f3 = df.Field(mesh, dim=3, value=(1, 4, 3))\n        >>> f1 == f2\n        True\n        >>> f1 != f2\n        False\n        >>> f1 == f3\n        False\n        >>> f1 != f3\n        True\n        >>> f2 == f3\n        False\n        >>> f1 == \'a\'\n        False\n\n        """"""\n        if not isinstance(other, self.__class__):\n            return False\n        elif (self.mesh == other.mesh and self.dim == other.dim and\n              np.array_equal(self.array, other.array)):\n            return True\n        else:\n            return False\n\n    def allclose(self, other, rtol=1e-5, atol=1e-8):\n        """"""Allclose method.\n\n        This method determines whether two fields are:\n\n          1. Defined on the same mesh.\n\n          2. Have the same dimension (``dim``).\n\n          3. All values in are within relative (``rtol``) and absolute\n          (``atol``) tolerances.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field\n\n            Field to be compared to.\n\n        rtol : numbers.Real\n\n            Relative tolerance. Defaults to 1e-5.\n\n        atol : numbers.Real\n\n            Absolute tolerance. Defaults to 1e-8.\n\n        Returns\n        -------\n        bool\n\n            ``True`` if two fields are within tolerance, ``False`` otherwise.\n\n        Raises\n        ------\n        TypeError\n\n            If a non field object is passed.\n\n        Examples\n        --------\n        1. Check if two fields are within a tolerance.\n\n        >>> import discretisedfield as df\n        ...\n        >>> mesh = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), cell=(1, 1, 1))\n        ...\n        >>> f1 = df.Field(mesh, dim=1, value=3)\n        >>> f2 = df.Field(mesh, dim=1, value=3+1e-9)\n        >>> f3 = df.Field(mesh, dim=1, value=3.1)\n        >>> f1.allclose(f2)\n        True\n        >>> f1.allclose(f3)\n        False\n        >>> f1.allclose(f3, atol=1e-2)\n        False\n\n        """"""\n        if not isinstance(other, self.__class__):\n            msg = (f\'Cannot apply allclose method between \'\n                   f\'{type(self)} and {type(other)} objects.\')\n            raise TypeError(msg)\n\n        if (self.mesh == other.mesh and self.dim == other.dim):\n            return np.allclose(self.array, other.array, rtol=rtol, atol=atol)\n        else:\n            return False\n\n    def __pos__(self):\n        """"""Unary ``+`` operator.\n\n        This method defines the unary operator ``+``. It returns the field\n        itself:\n\n        .. math::\n\n            +f(x, y, z) = f(x, y, z)\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field itself.\n\n        Example\n        -------\n        1. Applying unary ``+`` operator on a field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5e-9, 5e-9, 5e-9)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=(0, -1000, -3))\n        >>> res = +f\n        >>> res.average\n        (0.0, -1000.0, -3.0)\n        >>> res == f\n        True\n        >>> +(+f) == f\n        True\n\n        """"""\n        return self\n\n    def __neg__(self):\n        """"""Unary ``-`` operator.\n\n        This method negates the value of each discretisation cell. It is\n        equivalent to multiplication with -1:\n\n        .. math::\n\n            -f(x, y, z) = -1 \\\\cdot f(x, y, z)\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field multiplied with -1.\n\n        Example\n        -------\n        1. Applying unary ``-`` operator on a scalar field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5e-9, 3e-9, 1e-9)\n        >>> n = (10, 5, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=3.1)\n        >>> res = -f\n        >>> res.average\n        -3.1\n        >>> f == -(-f)\n        True\n\n        2. Applying unary negation operator on a vector field.\n\n        >>> f = df.Field(mesh, dim=3, value=(0, -1000, -3))\n        >>> res = -f\n        >>> res.average\n        (0.0, 1000.0, 3.0)\n\n        """"""\n        return -1 * self\n\n    def __pow__(self, other):\n        """"""Unary ``**`` operator.\n\n        This method defines the ``**`` operator for scalar (``dim=1``) fields\n        only. This operator is not defined for vector (``dim>1``) fields, and\n        ``ValueError`` is raised.\n\n        Parameters\n        ----------\n        other : numbers.Real\n\n            Value to which the field is raised.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Applying unary ``**`` operator on a scalar field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-25e-3, -25e-3, -25e-3)\n        >>> p2 = (25e-3, 25e-3, 25e-3)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=2)\n        >>> res = f**(-1)\n        >>> res\n        Field(...)\n        >>> res.average\n        0.5\n        >>> res = f**2\n        >>> res.average\n        4.0\n        >>> f**f  # the power must be numbers.Real\n        Traceback (most recent call last):\n        ...\n        TypeError: ...\n\n        2. Attempt to apply power operator on a vector field.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5e-9, 5e-9, 5e-9)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=(0, -1, -3))\n        >>> f**2\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        """"""\n        if self.dim != 1:\n            msg = f\'Cannot apply ** operator on dim={self.dim} field.\'\n            raise ValueError(msg)\n        if not isinstance(other, numbers.Real):\n            msg = (f\'Unsupported operand type(s) for **: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        return self.__class__(self.mesh, dim=1,\n                              value=np.power(self.array, other))\n\n    def __add__(self, other):\n        """"""Binary ``+`` operator.\n\n        It can be applied between two ``discretisedfield.Field`` objects or\n        between a ``discretisedfield.Field`` object and a ""constant"". For\n        instance if the field is a scalar field, a scalar field or\n        ``numbers.Real`` can be the second operand. Similarly, for a vector\n        field, either vector field or an iterable, such as ``tuple``, ``list``,\n        or ``numpy.ndarray``, can be the second operand. If the second operand\n        is a ``discretisedfield.Field`` object, both must be defined on the\n        same mesh and have the same dimensions.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field, numbers.Real, tuple, list, np.ndarray\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Add vector fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 3, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=3, value=(0, -1, -3.1))\n        >>> f2 = df.Field(mesh, dim=3, value=(0, 1, 3.1))\n        >>> res = f1 + f2\n        >>> res.average\n        (0.0, 0.0, 0.0)\n        >>> f1 + f2 == f2 + f1\n        True\n        >>> res = f1 + (1, 2, 3.1)\n        >>> res.average\n        (1.0, 1.0, 0.0)\n        >>> f1 + 5\n        Traceback (most recent call last):\n        ...\n        TypeError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.__sub__`\n\n        """"""\n        if isinstance(other, self.__class__):\n            if self.dim != other.dim:\n                msg = (f\'Cannot apply operator + on dim={self.dim} \'\n                       f\'and dim={other.dim} fields.\')\n                raise ValueError(msg)\n            if self.mesh != other.mesh:\n                msg = (\'Cannot apply operator + on fields \'\n                       \'defined on different meshes.\')\n                raise ValueError(msg)\n        elif self.dim == 1 and isinstance(other, numbers.Real):\n            other = self.__class__(self.mesh, dim=self.dim, value=other)\n        elif self.dim == 3 and isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=self.dim, value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for +: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        return self.__class__(self.mesh, dim=self.dim,\n                              value=self.array + other.array)\n\n    def __radd__(self, other):\n        return self + other\n\n    def __sub__(self, other):\n        """"""Binary ``-`` operator.\n\n        It can be applied between two ``discretisedfield.Field`` objects or\n        between a ``discretisedfield.Field`` object and a ""constant"". For\n        instance if the field is a scalar field, a scalar field or\n        ``numbers.Real`` can be the second operand. Similarly, for a vector\n        field, either vector field or an iterable, such as ``tuple``, ``list``,\n        or ``numpy.ndarray``, can be the second operand. If the second operand\n        is a ``discretisedfield.Field`` object, both must be defined on the\n        same mesh and have the same dimensions.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field, numbers.Real, tuple, list, np.ndarray\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Subtract vector fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 3, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=3, value=(0, 1, 6))\n        >>> f2 = df.Field(mesh, dim=3, value=(0, 1, 3))\n        >>> res = f1 - f2\n        >>> res.average\n        (0.0, 0.0, 3.0)\n        >>> f1 - f2 == -(f2 - f1)\n        True\n        >>> res = f1 - (0, 1, 0)\n        >>> res.average\n        (0.0, 0.0, 6.0)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.__add__`\n\n        """"""\n        # Make sure unary - can be applied to other.\n        if isinstance(other, (list, tuple)):\n            other = np.array(other)\n\n        return self + (-other)\n\n    def __rsub__(self, other):\n        return -self + other\n\n    def __mul__(self, other):\n        """"""Binary ``*`` operator.\n\n        It can be applied between:\n\n        1. Two scalar (``dim=1``) fields,\n\n        2. A field of any dimension and ``numbers.Real``, or\n\n        3. A field of any dimension and a scalar (``dim=1``) field.\n\n        If both operands are ``discretisedfield.Field`` objects, they must be\n        defined on the same mesh.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field, numbers.Real\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Multiply two scalar fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=1, value=5)\n        >>> f2 = df.Field(mesh, dim=1, value=9)\n        >>> res = f1 * f2\n        >>> res.average\n        45.0\n        >>> f1 * f2 == f2 * f1\n        True\n\n        2. Multiply vector field with a scalar.\n\n        >>> f1 = df.Field(mesh, dim=3, value=(0, 2, 5))\n        ...\n        >>> res = f1 * 5  # discretisedfield.Field.__mul__ is called\n        >>> res.average\n        (0.0, 10.0, 25.0)\n        >>> res = 10 * f1  # discretisedfield.Field.__rmul__ is called\n        >>> res.average\n        (0.0, 20.0, 50.0)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.__truediv__`\n\n        """"""\n        if isinstance(other, self.__class__):\n            if self.dim == 3 and other.dim == 3:\n                msg = (f\'Cannot apply operator * on dim={self.dim} \'\n                       f\'and dim={other.dim} fields.\')\n                raise ValueError(msg)\n            if self.mesh != other.mesh:\n                msg = (\'Cannot apply operator * on fields \'\n                       \'defined on different meshes.\')\n                raise ValueError(msg)\n        elif isinstance(other, numbers.Real):\n            other = self.__class__(self.mesh, dim=1, value=other)\n        elif self.dim == 1 and isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=3, value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for *: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        res_array = np.multiply(self.array, other.array)\n        return self.__class__(self.mesh, dim=res_array.shape[-1],\n                              value=res_array)\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __truediv__(self, other):\n        """"""Binary ``/`` operator.\n\n        It can be applied between:\n\n        1. Two scalar (``dim=1``) fields,\n\n        2. A field of any dimension and ``numbers.Real``, or\n\n        3. A field of any dimension and a scalar (``dim=1``) field.\n\n        If both operands are ``discretisedfield.Field`` objects, they must be\n        defined on the same mesh.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field, numbers.Real\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Divide two scalar fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=1, value=100)\n        >>> f2 = df.Field(mesh, dim=1, value=20)\n        >>> res = f1 / f2\n        >>> res.average\n        5.0\n        >>> f1 / f2 == (f2 / f1)**(-1)\n        True\n\n        2. Divide vector field by a scalar.\n\n        >>> f1 = df.Field(mesh, dim=3, value=(0, 10, 5))\n        >>> res = f1 / 5  # discretisedfield.Field.__mul__ is called\n        >>> res.average\n        (0.0, 2.0, 1.0)\n        >>> 10 / f1  # division by a vector is not allowed\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.__mul__`\n\n        """"""\n        return self * other**(-1)\n\n    def __rtruediv__(self, other):\n        return self**(-1) * other\n\n    def __matmul__(self, other):\n        """"""Binary ``@`` operator, defined as dot product.\n\n        This method computes the dot product between two fields. Both fields\n        must be three-dimensional (``dim=3``) and defined on the same mesh.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Compute the dot product of two vector fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 10e-9, 10e-9)\n        >>> cell = (2e-9, 2e-9, 2e-9)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=3, value=(1, 3, 6))\n        >>> f2 = df.Field(mesh, dim=3, value=(-1, -2, 2))\n        >>> (f1@f2).average\n        5.0\n\n        """"""\n        if isinstance(other, self.__class__):\n            if self.mesh != other.mesh:\n                msg = (\'Cannot apply operator @ on fields \'\n                       \'defined on different meshes.\')\n                raise ValueError(msg)\n        elif isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=3, value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for @: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        if self.dim != 3 or other.dim != 3:\n            msg = (f\'Cannot apply operator @ on dim={self.dim} \'\n                   f\'and dim={other.dim} fields.\')\n            raise ValueError(msg)\n\n        res_array = np.einsum(\'ijkl,ijkl->ijk\', self.array, other.array)\n        return df.Field(self.mesh, dim=1, value=res_array[..., np.newaxis])\n\n    def __rmatmul__(self, other):\n        return self @ other\n\n    def __and__(self, other):\n        """"""Binary ``&`` operator, defined as cross product.\n\n        This method computes the cross product between two fields. Both fields\n        must be three-dimensional (``dim=3``) and defined on the same mesh.\n\n        Parameters\n        ----------\n        other : discretisedfield.Field, tuple, list, numpy.ndarray\n\n            Second operand.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError, TypeError\n\n            If the operator cannot be applied.\n\n        Example\n        -------\n        1. Compute the cross product of two vector fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=3, value=(1, 0, 0))\n        >>> f2 = df.Field(mesh, dim=3, value=(0, 1, 0))\n        >>> (f1 & f2).average\n        (0.0, 0.0, 1.0)\n        >>> (f1 & (0, 0, 1)).average\n        (0.0, -1.0, 0.0)\n\n        """"""\n        if isinstance(other, self.__class__):\n            if self.mesh != other.mesh:\n                msg = (\'Cannot apply operator & on fields \'\n                       \'defined on different meshes.\')\n                raise ValueError(msg)\n        elif isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=3, value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for &: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        if self.dim != 3 or other.dim != 3:\n            msg = (f\'Cannot apply operator & on dim={self.dim} \'\n                   f\'and dim={other.dim} fields.\')\n            raise ValueError(msg)\n\n        res_array = np.cross(self.array, other.array)\n        return self.__class__(self.mesh, dim=3, value=res_array)\n\n    def __rand__(self, other):\n        return self & other\n\n    def __lshift__(self, other):\n        """"""Stacks multiple scalar fields in a single vector field.\n\n        This method takes a list of scalar (``dim=1``) fields and returns a\n        vector field, whose components are defined by the scalar fields passed.\n        If any of the fields passed has ``dim!=1` or they are not defined on\n        the same mesh, an exception is raised. The dimension of the resulting\n        field is equal to the length of the passed list.\n\n        Parameters\n        ----------\n        fields : list\n\n            List of ``discretisedfield.Field`` objects with ``dim=1``.\n\n        Returns\n        -------\n        disrectisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of any of the fields is not 1, or the fields\n            passed are not defined on the same mesh.\n\n        Example\n        -------\n        1. Stack 3 scalar fields.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f1 = df.Field(mesh, dim=1, value=1)\n        >>> f2 = df.Field(mesh, dim=1, value=5)\n        >>> f3 = df.Field(mesh, dim=1, value=-3)\n        ...\n        >>> f = f1 << f2 << f3\n        >>> f.average\n        (1.0, 5.0, -3.0)\n        >>> f.dim\n        3\n        >>> f.x == f1\n        True\n        >>> f.y == f2\n        True\n        >>> f.z == f3\n        True\n\n        """"""\n        if isinstance(other, self.__class__):\n            if self.mesh != other.mesh:\n                msg = (\'Cannot apply operator << on fields \'\n                       \'defined on different meshes.\')\n                raise ValueError(msg)\n        elif isinstance(other, numbers.Real):\n            other = self.__class__(self.mesh, dim=1, value=other)\n        elif isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=len(other), value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for <<: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        array_list = [self.array[..., i] for i in range(self.dim)]\n        array_list += [other.array[..., i] for i in range(other.dim)]\n        return self.__class__(self.mesh, dim=len(array_list),\n                              value=np.stack(array_list, axis=3))\n\n    def __rlshift__(self, other):\n        if isinstance(other, numbers.Real):\n            other = self.__class__(self.mesh, dim=1, value=other)\n        elif isinstance(other, (tuple, list, np.ndarray)):\n            other = self.__class__(self.mesh, dim=len(other), value=other)\n        else:\n            msg = (f\'Unsupported operand type(s) for <<: \'\n                   f\'{type(self)} and {type(other)}.\')\n            raise TypeError(msg)\n\n        return other << self\n\n    def pad(self, pad_width, mode, **kwargs):\n        """"""Field padding.\n\n        This method pads the field by adding more cells in chosen direction and\n        assigning to them the values as specified by the ``mode`` argument.\n        The way in which the field is going to padded is defined by passing\n        ``pad_width`` dictionary. The keys of the dictionary are the directions\n        (axes), e.g. ``\'x\'``, ``\'y\'``, or ``\'z\'``, whereas the values are the\n        tuples of length 2. The first integer in the tuple is the number of\n        cells added in the negative direction, and the second integer is the\n        number of cells added in the positive direction.\n\n        This method accepts any other arguments allowed by ``numpy.pad``\n        function.\n\n        Parameters\n        ----------\n        pad_width : dict\n\n            The keys of the dictionary are the directions (axes), e.g. ``\'x\'``,\n            ``\'y\'``, or ``\'z\'``, whereas the values are the tuples of length 2.\n            The first integer in the tuple is the number of cells added in the\n            negative direction, and the second integer is the number of cells\n            added in the positive direction.\n\n        mode: str\n\n            Padding mode as defined in ``numpy.pad``.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Padded field.\n\n        Examples\n        --------\n        1. Padding a field in the x direction by 1 cell with ``constant`` mode.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 1, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> field = df.Field(mesh, dim=1, value=1)\n        ...\n        >>> # Two cells with value 1\n        >>> pf = field.pad({\'x\': (1, 1)}, mode=\'constant\')  # zeros padded\n        >>> pf.average\n        0.5\n\n        """"""\n        d = {}\n        for key, value in pad_width.items():\n            d[dfu.axesdict[key]] = value\n        padding_sequence = dfu.assemble_index((0, 0), len(self.array.shape), d)\n\n        padded_array = np.pad(self.array, padding_sequence,\n                              mode=mode, **kwargs)\n        padded_mesh = self.mesh.pad(pad_width)\n\n        return self.__class__(padded_mesh, dim=self.dim, value=padded_array)\n\n    def derivative(self, direction, n=1):\n        """"""Directional derivative.\n\n        This method computes a directional derivative of the field and returns\n        a field. The direction in which the derivative is computed is passed\n        via ``direction`` argument, which can be ``\'x\'``, ``\'y\'``, or ``\'z\'``.\n        The order of the computed derivative can be 1 or 2 and it is specified\n        using argument ``n`` and it defaults to 1.\n\n        Directional derivative cannot be computed if only one discretisation\n        cell exists in a specified direction. In that case, a zero field is\n        returned. More precisely, it is assumed that the field does not change\n        in that direction. Computing of the directional derivative depends\n        strongly on the boundary condition specified in the mesh on which the\n        field is defined on. More precisely, the values of the derivatives at\n        the boundary are different for periodic, Neumann, or no boundary\n        conditions. For details on boundary conditions, please refer to the\n        ``disretisedfield.Mesh`` class. The derivatives are computed using\n        central differences inside the sample and using forward/backward\n        differences at the boundaries.\n\n        Parameters\n        ----------\n        direction : str\n\n            The direction in which the derivative is computed. It can be\n            ``\'x\'``, ``\'y\'``, or ``\'z\'``.\n\n        n : int\n\n            The order of the derivative. It can be 1 or 2 and it defaults to 1.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Directional derivative.\n\n        Raises\n        ------\n        NotImplementedError\n\n            If order ``n`` higher than 2 is asked for.\n\n        Example\n        -------\n        1. Compute the first-order directional derivative of a scalar field in\n        the y-direction of a spatially varying field. For the field we choose\n        :math:`f(x, y, z) = 2x + 3y - 5z`. Accordingly, we expect the\n        derivative in the y-direction to be to be a constant scalar field\n        :math:`df/dy = 3`.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100e-9, 100e-9, 10e-9)\n        >>> cell = (10e-9, 10e-9, 10e-9)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return 2*x + 3*y + -5*z\n        ...\n        >>> f = df.Field(mesh, dim=1, value=value_fun)\n        >>> f.derivative(\'y\').average  # first-order derivative by default\n        3.0\n\n        2. Try to compute the second-order directional derivative of the vector\n        field which has only one discretisation cell in the z-direction. For\n        the field we choose :math:`f(x, y, z) = (2x, 3y, -5z)`. Accordingly, we\n        expect the directional derivatives to be: :math:`df/dx = (2, 0, 0)`,\n        :math:`df/dy=(0, 3, 0)`, :math:`df/dz = (0, 0, -5)`. However, because\n        there is only one discretisation cell in the z-direction, the\n        derivative cannot be computed and a zero field is returned. Similarly,\n        second-order derivatives in all directions are expected to be zero.\n\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return (2*x, 3*y, -5*z)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=value_fun)\n        >>> f.derivative(\'x\', n=1).average\n        (2.0, 0.0, 0.0)\n        >>> f.derivative(\'y\', n=1).average\n        (0.0, 3.0, 0.0)\n        >>> f.derivative(\'z\', n=1).average  # derivative cannot be calculated\n        (0.0, 0.0, 0.0)\n        >>> # second-order derivatives\n\n        """"""\n        direction = dfu.axesdict[direction]\n\n        # If there are no neighbouring cells in the specified direction, zero\n        # field is returned.\n        if self.mesh.n[direction] == 1:\n            return self.zero\n\n        # Preparation (padding) for computing the derivative, depending on the\n        # boundary conditions (PBC, Neumann, or no BC). Depending on the BC,\n        # the field array is padded.\n        if dfu.raxesdict[direction] in self.mesh.bc:  # PBC\n            pad_width = {dfu.raxesdict[direction]: (1, 1)}\n            padding_mode = \'wrap\'\n        elif self.mesh.bc == \'neumann\':\n            pad_width = {dfu.raxesdict[direction]: (1, 1)}\n            padding_mode = \'edge\'\n        else:  # No BC - no padding\n            pad_width = {}\n            padding_mode = \'constant\'\n\n        padded_array = self.pad(pad_width, mode=padding_mode).array\n\n        if n not in (1, 2):\n            msg = f\'Derivative of the n={n} order is not implemented.\'\n            raise NotImplementedError(msg)\n\n        elif n == 1:\n            if self.dim == 1:\n                derivative_array = np.gradient(padded_array[..., 0],\n                                               self.mesh.cell[direction],\n                                               axis=direction)[..., np.newaxis]\n            else:\n                derivative_array = np.gradient(padded_array,\n                                               self.mesh.cell[direction],\n                                               axis=direction)\n\n        elif n == 2:\n            derivative_array = np.zeros_like(padded_array)\n            for i in range(padded_array.shape[direction]):\n                if i == 0:\n                    i1, i2, i3 = i+2, i+1, i\n                elif i == padded_array.shape[direction] - 1:\n                    i1, i2, i3 = i, i-1, i-2\n                else:\n                    i1, i2, i3 = i+1, i, i-1\n                index1 = dfu.assemble_index(slice(None), 4, {direction: i1})\n                index2 = dfu.assemble_index(slice(None), 4, {direction: i2})\n                index3 = dfu.assemble_index(slice(None), 4, {direction: i3})\n                index = dfu.assemble_index(slice(None), 4, {direction: i})\n                derivative_array[index] = ((padded_array[index1] -\n                                           2*padded_array[index2] +\n                                           padded_array[index3]) /\n                                           self.mesh.cell[direction]**2)\n\n        # Remove padded values (if any).\n        if derivative_array.shape != self.array.shape:\n            derivative_array = np.delete(derivative_array,\n                                         (0, self.mesh.n[direction]+1),\n                                         axis=direction)\n\n        return self.__class__(self.mesh, dim=self.dim, value=derivative_array)\n\n    @property\n    def grad(self):\n        """"""Gradient.\n\n        This method computes the gradient of a scalar (``dim=1``) field and\n        returns a vector field:\n\n        .. math::\n\n            \\\\nabla f = (\\\\frac{\\\\partial f}{\\\\partial x},\n                         \\\\frac{\\\\partial f}{\\\\partial y},\n                         \\\\frac{\\\\partial f}{\\\\partial z})\n\n        Directional derivative cannot be computed if only one discretisation\n        cell exists in a certain direction. In that case, a zero field is\n        considered to be that directional derivative. More precisely, it is\n        assumed that the field does not change in that direction.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 1.\n\n        Example\n        -------\n        1. Compute gradient of a contant field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 10e-9, 10e-9)\n        >>> cell = (2e-9, 2e-9, 2e-9)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=5)\n        >>> f.grad.average\n        (0.0, 0.0, 0.0)\n\n        2. Compute gradient of a spatially varying field. For a field we choose\n        :math:`f(x, y, z) = 2x + 3y - 5z`. Accordingly, we expect the gradient\n        to be a constant vector field :math:`\\\\nabla f = (2, 3, -5)`.\n\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return 2*x + 3*y - 5*z\n        ...\n        >>> f = df.Field(mesh, dim=1, value=value_fun)\n        >>> f.grad.average\n        (2.0, 3.0, -5.0)\n\n        3. Attempt to compute the gradient of a vector field.\n\n        >>> f = df.Field(mesh, dim=3, value=(1, 2, -3))\n        >>> f.grad\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.derivative`\n\n        """"""\n        if self.dim != 1:\n            msg = f\'Cannot compute gradient for dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        return (self.derivative(\'x\') <<\n                self.derivative(\'y\') <<\n                self.derivative(\'z\'))\n\n    @property\n    def div(self):\n        """"""Divergence.\n\n        This method computes the divergence of a vector (``dim=3``) field and\n        returns a scalar (``dim=1``) field as a result.\n\n        .. math::\n\n            \\\\nabla\\\\cdot\\\\mathbf{v} = \\\\frac{\\\\partial v_{x}}{\\\\partial x} +\n                                       \\\\frac{\\\\partial v_{y}}{\\\\partial y} +\n                                       \\\\frac{\\\\partial v_{z}}{\\\\partial z}\n\n        Directional derivative cannot be computed if only one discretisation\n        cell exists in a certain direction. In that case, a zero field is\n        considered to be that directional derivative. More precisely, it is\n        assumed that the field does not change in that direction.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 3.\n\n        Example\n        -------\n        1. Compute the divergence of a vector field. For a field we choose\n        :math:`\\\\mathbf{v}(x, y, z) = (2x, -2y, 5z)`. Accordingly, we expect\n        the divergence to be to be a constant scalar field :math:`\\\\nabla\\\\cdot\n        \\\\mathbf{v} = 5`.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100e-9, 100e-9, 100e-9)\n        >>> cell = (10e-9, 10e-9, 10e-9)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return (2*x, -2*y, 5*z)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=value_fun)\n        >>> f.div.average\n        5.0\n\n        2. Attempt to compute the divergence of a scalar field.\n\n        >>> f = df.Field(mesh, dim=1, value=3.14)\n        >>> f.div\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.derivative`\n\n        """"""\n        if self.dim != 3:\n            msg = f\'Cannot compute divergence for dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        return (self.x.derivative(\'x\') +\n                self.y.derivative(\'y\') +\n                self.z.derivative(\'z\'))\n\n    @property\n    def curl(self):\n        """"""Curl.\n\n        This method computes the curl of a vector (``dim=3``) field and returns\n        a vector (``dim=3``) as a result:\n\n        .. math::\n\n            \\\\nabla \\\\times \\\\mathbf{v} = \\\\left(\\\\frac{\\\\partial\n            v_{z}}{\\\\partial y} - \\\\frac{\\\\partial v_{y}}{\\\\partial z},\n            \\\\frac{\\\\partial v_{x}}{\\\\partial z} - \\\\frac{\\\\partial\n            v_{z}}{\\\\partial x}, \\\\frac{\\\\partial v_{y}}{\\\\partial x} -\n            \\\\frac{\\\\partial v_{x}}{\\\\partial y},\\\\right)\n\n        Directional derivative cannot be computed if only one discretisation\n        cell exists in a certain direction. In that case, a zero field is\n        considered to be that directional derivative. More precisely, it is\n        assumed that the field does not change in that direction.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 3.\n\n        Example\n        -------\n        1. Compute curl of a vector field. For a field we choose\n        :math:`\\\\mathbf{v}(x, y, z) = (2xy, -2y, 5xz)`. Accordingly, we expect\n        the curl to be to be a constant vector field :math:`\\\\nabla\\\\times\n        \\\\mathbf{v} = (0, -5z, -2x)`.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return (2*x*y, -2*y, 5*x*z)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=value_fun)\n        >>> f.curl((1, 1, 1))\n        (0.0, -5.0, -2.0)\n\n        2. Attempt to compute the curl of a scalar field.\n\n        >>> f = df.Field(mesh, dim=1, value=3.14)\n        >>> f.curl\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.derivative`\n\n        """"""\n        if self.dim != 3:\n            msg = f\'Cannot compute curl for dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        curl_x = self.z.derivative(\'y\') - self.y.derivative(\'z\')\n        curl_y = self.x.derivative(\'z\') - self.z.derivative(\'x\')\n        curl_z = self.y.derivative(\'x\') - self.x.derivative(\'y\')\n\n        return curl_x << curl_y << curl_z\n\n    @property\n    def laplace(self):\n        """"""Laplace operator.\n\n        This method computes the laplacian of a scalar (``dim=1``) or a vector\n        (``dim=3``) field and returns a resulting field:\n\n        .. math::\n\n            \\\\nabla^2 f = \\\\frac{\\\\partial^{2} f}{\\\\partial x^{2}} +\n                          \\\\frac{\\\\partial^{2} f}{\\\\partial y^{2}} +\n                          \\\\frac{\\\\partial^{2} f}{\\\\partial z^{2}}\n\n        .. math::\n\n            \\\\nabla^2 \\\\mathbf{f} = (\\\\nabla^2 f_{x},\n                                     \\\\nabla^2 f_{y},\n                                     \\\\nabla^2 f_{z})\n\n        Directional derivative cannot be computed if only one discretisation\n        cell exists in a certain direction. In that case, a zero field is\n        considered to be that directional derivative. More precisely, it is\n        assumed that the field does not change in that direction.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Resulting field.\n\n        Example\n        -------\n        1. Compute Laplacian of a contant scalar field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 10e-9, 10e-9)\n        >>> cell = (2e-9, 2e-9, 2e-9)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=5)\n        >>> f.laplace.average\n        0.0\n\n        2. Compute Laplacian of a spatially varying field. For a field we\n        choose :math:`f(x, y, z) = 2x^{2} + 3y - 5z`. Accordingly, we expect\n        the Laplacian to be a constant vector field :math:`\\\\nabla f = (4, 0,\n        0)`.\n\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     return 2*x**2 + 3*y - 5*z\n        ...\n        >>> f = df.Field(mesh, dim=1, value=value_fun)\n        >>> assert abs(f.laplace.average - 4) < 1e-3\n\n        .. seealso:: :py:func:`~discretisedfield.Field.derivative`\n\n        """"""\n        if self.dim == 1:\n            return (self.derivative(\'x\', n=2) +\n                    self.derivative(\'y\', n=2) +\n                    self.derivative(\'z\', n=2))\n        else:\n            return self.x.laplace << self.y.laplace << self.z.laplace\n\n    @property\n    def volume_integral(self):\n        """"""Volume integral.\n\n        This method integrates the field over volume and returns a single\n        (scalar or vector) value. This value can be understood as the product\n        of field\'s average value and the mesh volume, because the volume of all\n        discretisation cells is the same.\n\n        Returns\n        -------\n        numbers.Real, tuple\n\n            Volume integral.\n\n        Example\n        -------\n        1. Compute the volume integral of a scalar field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=5)\n        >>> f.volume_integral\n        5000.0\n\n        2. Compute the volume integral of a vector field.\n\n        >>> f = df.Field(mesh, dim=3, value=(-1, -2, -3))\n        >>> f.volume_integral\n        (-1000.0, -2000.0, -3000.0)\n\n        .. seealso::\n\n            :py:func:`~discretisedfield.Field.surface_integral`\n\n        """"""\n        cell_volume = self.mesh.region.volume / len(self.mesh)\n        field_sum = np.sum(self.array, axis=(0, 1, 2))\n        return dfu.array2tuple(field_sum * cell_volume)\n\n    @property\n    def surface_integral(self):\n        """"""Surface integral.\n\n        This method integrates the field over the plane and returns a single\n        scalar or vector value. This value can be understood as the product of\n        field\'s average value and the plane area, because the area of all\n        discretisation cells on the plane is the same.\n\n        The field must be sliced by a plane before surface integral is applied.\n\n        Returns\n        -------\n        numbers.Real, tuple\n\n            Surface integral.\n\n        Raises\n        ------\n        ValueError\n\n            If the field was not sliced before the surface integral ic\n            computed.\n\n        Example\n        -------\n        1. Compute the surface integral of a scalar field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=1, value=5)\n        >>> f.plane(\'z\').surface_integral\n        500.0\n\n        2. Compute the surface integral of a vector field.\n\n        >>> f = df.Field(mesh, dim=3, value=(-1, -2, -3))\n        >>> f.plane(\'z\').surface_integral\n        (-100.0, -200.0, -300.0)\n\n        .. seealso::\n\n            :py:func:`~discretisedfield.Field.volume_integral`\n\n        """"""\n        thickness = self.mesh.cell[self.mesh.info[\'planeaxis\']]\n        return dfu.array2tuple(np.divide(self.volume_integral, thickness))\n\n    @property\n    def topological_charge_density(self):\n        """"""Topological charge density.\n\n        This method computes the topological charge density for the vector\n        (``dim=3``) field:\n\n        .. math::\n\n            q = \\\\frac{1}{4\\\\pi} \\\\mathbf{n} \\\\cdot \\\\left(\\\\frac{\\\\partial\n            \\\\mathbf{n}}{\\\\partial x} \\\\times \\\\frac{\\\\partial\n            \\\\mathbf{n}}{\\\\partial x} \\\\right),\n\n        where :math:`\\\\mathbf{n}` is the orientation field. Topological charge\n        is defined on two-dimensional samples only. Therefore, the field must\n        be ""sliced"" using the ``discretisedfield.Field.plane`` method. If the\n        field is not three-dimensional or the field is not sliced,\n        ``ValueError`` is raised.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Topological charge density as a scalar field.\n\n        Raises\n        ------\n        ValueError\n\n            If the field is not three-dimensional or the field is not sliced.\n\n        Example\n        -------\n        1. Compute the topological charge density of a spatially constant\n        vector field.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=(1, 1, -1))\n        >>> f.plane(\'z\').topological_charge_density.average\n        0.0\n\n        2. Attempt to compute the topological charge density of a scalar field.\n\n        >>> f = df.Field(mesh, dim=1, value=12)\n        >>> f.plane(\'z\').topological_charge_density\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        3. Attempt to compute the topological charge density of a vector field,\n        which is not sliced.\n\n        >>> f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        >>> f.topological_charge_density\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso:: :py:func:`~discretisedfield.Field.topological_charge`\n\n        """"""\n        if self.dim != 3:\n            msg = (f\'Cannot compute topological charge density \'\n                   f\'for dim={self.dim} field.\')\n            raise ValueError(msg)\n        if not hasattr(self.mesh, \'info\'):\n            msg = (\'The field must be sliced before the topological \'\n                   \'charge density can be computed.\')\n            raise ValueError(msg)\n\n        of = self.orientation  # unit (orientation) field\n        prefactor = 1 / (4 * np.pi)\n        q = of @ (of.derivative(dfu.raxesdict[self.mesh.info[\'axis1\']]) &\n                  of.derivative(dfu.raxesdict[self.mesh.info[\'axis2\']]))\n\n        return prefactor * q\n\n    @property\n    def bergluescher(self):\n        """"""Topological charge computed using Berg-Luescher method.\n\n        The details of this method can be found in Berg and Luescher, Nuclear\n        Physics, Section B, Volume 190, Issue 2, p. 412-424.\n\n        This method computes the topological charge for the vector field\n        (``dim=3``). Topological charge is defined on two-dimensional samples.\n        Therefore, the field must be ""sliced"" using\n        ``discretisedfield.Field.plane`` method. If the field is not\n        three-dimensional or the field is not sliced, ``ValueError`` is raised.\n\n        Returns\n        -------\n        float\n\n            Topological charge.\n\n        Raises\n        ------\n        ValueError\n\n            If the field does not have ``dim=3`` or the field is not sliced.\n\n        Example\n        -------\n        1. Compute the topological charge of a spatially constant vector field.\n        Zero value is expected.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=(1, 1, -1))\n        >>> f.plane(\'z\').bergluescher\n        0.0\n        >>> f.plane(\'z\').bergluescher\n        0.0\n\n        .. seealso::\n\n            :py:func:`~discretisedfield.Field.topological_charge`\n            :py:func:`~discretisedfield.Field.tological_charge_density`\n\n        """"""\n        if self.dim != 3:\n            msg = (f\'Cannot compute Berg-Luescher topological charge \'\n                   f\'for dim={self.dim} field.\')\n            raise ValueError(msg)\n        if not hasattr(self.mesh, \'info\'):\n            msg = (\'The field must be sliced before the Berg-Luescher \'\n                   \'topological charge can be computed.\')\n            raise ValueError(msg)\n\n        axis1 = self.mesh.info[\'axis1\']\n        axis2 = self.mesh.info[\'axis2\']\n        of = self.orientation  # unit (orientation) field\n\n        topological_charge = 0\n        for i, j in itertools.product(range(of.mesh.n[axis1]-1),\n                                      range(of.mesh.n[axis2]-1)):\n            v1 = of.array[dfu.assemble_index(0, 3, {axis1: i, axis2: j})]\n            v2 = of.array[dfu.assemble_index(0, 3, {axis1: i+1, axis2: j})]\n            v3 = of.array[dfu.assemble_index(0, 3, {axis1: i+1, axis2: j+1})]\n            v4 = of.array[dfu.assemble_index(0, 3, {axis1: i, axis2: j+1})]\n\n            triangle1 = dfu.bergluescher_angle(v1, v2, v4)\n            triangle2 = dfu.bergluescher_angle(v2, v3, v4)\n\n            topological_charge += triangle1 + triangle2\n\n        return topological_charge\n\n    def topological_charge(self, method=\'continuous\'):\n        """"""Topological charge.\n\n        This method computes the topological charge for the vector field\n        (``dim=3``). There are two possible methods, which can be chosen using\n        ``method`` parameter:\n\n        1. ``continuous``: Topological charge density is integrated.\n\n        2. ``berg-luescher``: Topological charge is computed on a discrete\n        lattice, as described in: Berg and Luescher, Nuclear Physics, Section\n        B, Volume 190, Issue 2, p. 412-424.\n\n        Topological charge is defined on two-dimensional samples. Therefore,\n        the field must be ""sliced"" using ``discretisedfield.Field.plane``\n        method. If the field is not three-dimensional or the field is not\n        sliced, ``ValueError`` is raised.\n\n        Parameters\n        ----------\n        method : str, optional\n\n            Method how the topological charge is computed. It can be\n            ``continuous`` or ``berg-luescher``. Defaults to ``continuous``.\n\n        Returns\n        -------\n        float\n\n            Topological charge.\n\n        Raises\n        ------\n        ValueError\n\n            If the field does not have ``dim=3`` or the field is not sliced.\n\n        Example\n        -------\n        1. Compute the topological charge of a spatially constant vector field.\n        Zero value is expected.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10, 10, 10)\n        >>> cell = (2, 2, 2)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=(1, 1, -1))\n        >>> f.plane(\'z\').topological_charge(method=\'continuous\')\n        0.0\n        >>> f.plane(\'z\').topological_charge(method=\'berg-luescher\')\n        0.0\n\n        2. Attempt to compute the topological charge of a scalar field.\n\n        >>> f = df.Field(mesh, dim=1, value=12)\n        >>> f.plane(\'z\').topological_charge()\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        3. Attempt to compute the topological charge of a vector field, which\n        is not sliced.\n\n        >>> f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        >>> f.topological_charge_density()\n        Traceback (most recent call last):\n        ...\n        ValueError: ...\n\n        .. seealso::\n\n            :py:func:`~discretisedfield.Field.tological_charge_density`\n            :py:func:`~discretisedfield.Field.bergluescher`\n\n        """"""\n        if method == \'continuous\':\n            return self.topological_charge_density.surface_integral\n        elif method == \'berg-luescher\':\n            return self.bergluescher\n        else:\n            msg = \'Method can be either continuous or berg-luescher\'\n            raise ValueError(msg)\n\n    def line(self, p1, p2, n=100):\n        """"""Sampling the field along the line.\n\n        Given two points :math:`p_{1}` and :math:`p_{2}`, :math:`n` position\n        coordinates are generated and the corresponding field values.\n\n        .. math::\n\n           \\\\mathbf{r}_{i} = i\\\\frac{\\\\mathbf{p}_{2} -\n           \\\\mathbf{p}_{1}}{n-1}\n\n        Parameters\n        ----------\n        p1, p2 : (3,) array_like\n\n            Two points between which the line is generated.\n\n        n : int, optional\n\n            Number of points on the line. Defaults to 100.\n\n        Returns\n        -------\n        discretisedfield.Line\n\n            Line object.\n\n        Raises\n        ------\n        ValueError\n\n            If ``p1`` or ``p2`` is outside the mesh domain.\n\n        Examples\n        --------\n        1. Sampling the field along the line.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 2)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> field = df.Field(mesh, dim=2, value=(0, 3))\n        ...\n        >>> line = field.line(p1=(0, 0, 0), p2=(2, 0, 0), n=5)\n\n        """"""\n        points = list(self.mesh.line(p1=p1, p2=p2, n=n))\n        values = [self(p) for p in points]\n        # return points, values\n        return df.Line(points=points, values=values)\n\n    def plane(self, *args, n=None, **kwargs):\n        """"""Extracts field on the plane mesh.\n\n        If one of the axes (``\'x\'``, ``\'y\'``, or ``\'z\'``) is passed as a\n        string, a plane mesh perpendicular to that axis is extracted,\n        intersecting the mesh region at its centre, and the field is sampled on\n        that mesh. Alternatively, if a keyword argument is passed (e.g.\n        ``x=1e-9``), a plane perpendicular to the x-axis (parallel to yz-plane)\n        and intersecting it at ``x=1e-9`` is extracted. The number of points in\n        two dimensions on the plane can be defined using ``n`` tuple (e.g.\n        ``n=(10, 15)``).\n\n        Parameters\n        ----------\n        n : (2,) tuple\n\n            The number of points on the plane in two dimensions.\n\n        Returns\n        ------\n        discretisedfield.Field\n\n            An extracted field.\n\n        Examples\n        --------\n        1. Extracting the field on a plane at a specific point.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 5, 5)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> f = df.Field(mesh, dim=3, value=(0, 0, 1))\n        ...\n        >>> f.plane(y=1)\n        Field(...)\n\n        2. Extracting the field at the mesh region centre.\n\n        >>> f.plane(\'z\')\n        Field(...)\n\n        3. Specifying the number of points.\n\n        >>> f.plane(\'z\', n=(10, 10))\n        Field(...)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.plane`\n\n        """"""\n        plane_mesh = self.mesh.plane(*args, n=n, **kwargs)\n        return self.__class__(plane_mesh, dim=self.dim, value=self)\n\n    def __getitem__(self, key):\n        """"""Extracts the field on a subregion.\n\n        If subregions were defined by passing ``subregions`` dictionary when\n        the mesh was created, this method returns a field in a subregion\n        ``subregions[key]`` with the same discretisation cell as the parent\n        mesh.\n\n        Parameters\n        ----------\n        key : str\n\n            The key of a region in ``subregions`` dictionary.\n\n        Returns\n        -------\n        disretisedfield.Field\n\n            Field on a subregion.\n\n        Example\n        -------\n        1. Extract field on the subregion.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> cell = (10, 10, 10)\n        >>> subregions = {\'r1\': df.Region(p1=(0, 0, 0), p2=(50, 100, 100)),\n        ...               \'r2\': df.Region(p1=(50, 0, 0), p2=(100, 100, 100))}\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n        >>> def value_fun(point):\n        ...     x, y, z = point\n        ...     if x <= 50:\n        ...         return (1, 2, 3)\n        ...     else:\n        ...         return (-1, -2, -3)\n        ...\n        >>> f = df.Field(mesh, dim=3, value=value_fun)\n        >>> f.average\n        (0.0, 0.0, 0.0)\n        >>> f[\'r1\']\n        Field(...)\n        >>> f[\'r1\'].average\n        (1.0, 2.0, 3.0)\n        >>> f[\'r2\'].average\n        (-1.0, -2.0, -3.0)\n\n        """"""\n        return self.__class__(self.mesh[key], dim=self.dim, value=self)\n\n    def project(self, *args):\n        """"""Projects the field along one direction and averages it out along\n        that direction.\n\n        One of the axes (``\'x\'``, ``\'y\'``, or ``\'z\'``) is passed and the field\n        is projected (averaged) along that direction. For example\n        ``project(\'z\')`` would average the field in the z-direction and return\n        the field which has only one discretisation cell in the z-direction.\n\n        Returns\n        ------\n        discretisedfield.Field\n\n            An extracted field.\n\n        Example\n        -------\n        1. Projecting the field along a certain direction.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 2)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> field = df.Field(mesh, dim=3, value=(1, 2, 3))\n        ...\n        >>> field.project(\'z\')\n        Field(...)\n        >>> field.project(\'z\').average\n        (1.0, 2.0, 3.0)\n        >>> field.project(\'z\').array.shape\n        (2, 2, 1, 3)\n\n        """"""\n        plane_mesh = self.mesh.plane(*args)\n        project_array = self.array.mean(axis=plane_mesh.info[\'planeaxis\'],\n                                        keepdims=True)\n        return self.__class__(plane_mesh, dim=self.dim, value=project_array)\n\n    @property\n    def angle(self):\n        """"""In-plane angle of the vector field.\n\n        This method can be applied only on sliced fields, when a plane is\n        defined. This method then returns a scalar field which is an angle\n        between the in-plane compoenent of the vector field and the horizontal\n        axis. The angle is computed in radians.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Angle scalar field.\n\n        Raises\n        ------\n        ValueError\n\n            If the field is not sliced.\n\n        Example\n        -------\n        1. Computing the angle of the field in yz-plane.\n\n        >>> import discretisedfield as df\n        >>> import numpy as np\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=3, value=(0, 1, 0))\n        ...\n        >>> abs(field.plane(\'z\').angle.average - np.pi/2) < 1e-3\n        True\n\n        """"""\n        if not hasattr(self.mesh, \'info\'):\n            msg = (\'The field must be sliced before \'\n                   \'the angle can be computed.\')\n            raise ValueError(msg)\n\n        angle_array = np.arctan2(self.array[..., self.mesh.info[\'axis2\']],\n                                 self.array[..., self.mesh.info[\'axis1\']])\n\n        return self.__class__(self.mesh, dim=1,\n                              value=angle_array[..., np.newaxis])\n\n    def write(self, filename, representation=\'txt\', extend_scalar=False):\n        """"""Write the field to OVF, HDF5, or VTK file.\n\n        If the extension of ``filename`` is ``.vtk``, a VTK file is written\n        (:py:func:`~discretisedfield.Field._writevtk`).\n\n        For ``.ovf``, ``.omf``, or ``.ohf`` extensions, the field is saved to\n        OVF file (:py:func:`~discretisedfield.Field._writeovf`). In that case,\n        the representation of data (``\'bin4\'``, ``\'bin8\'``, or ``\'txt\'``) is\n        passed as ``representation`` and if ``extend_scalar=True``, a scalar\n        field will be saved as a vector field. More precisely, if the value at\n        a cell is X, that cell will be saved as (X, 0, 0).\n\n        Finally, if the extension of ``filename`` is ``.hdf5``, HDF5 file will\n        be written (:py:func:`~discretisedfield.Field._writehdf5`).\n\n        Parameters\n        ----------\n        filename : str\n\n            Name of the file written.\n\n        representation : str, optional\n\n            In the case of OVF files (``.ovf``, ``.omf``, or ``.ohf``),\n            representation can be specified (``\'bin4\'``, ``\'bin8\'``, or\n            ``\'txt\'``). Defaults to ``\'txt\'``.\n\n        extend_scalar : bool, optional\n\n            If ``True``, a scalar field will be saved as a vector field. More\n            precisely, if the value at a cell is 3, that cell will be saved as\n            (3, 0, 0). This is valid only for the OVF file formats. Defaults to\n            ``False``.\n\n        Example\n        -------\n        1. Write field to the OVF file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, -5e-9)\n        >>> p2 = (5e-9, 15e-9, 15e-9)\n        >>> n = (5, 15, 20)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=3, value=(5, 6, 7))\n        ...\n        >>> filename = \'mytestfile.omf\'\n        >>> field.write(filename)  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> field_read = df.Field.fromfile(filename)  # read the file\n        >>> field_read == field\n        True\n        >>> os.remove(filename)  # delete the file\n\n        2. Write field to the VTK file.\n\n        >>> filename = \'mytestfile.vtk\'\n        >>> field.write(filename)  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> os.remove(filename)  # delete the file\n\n        3. Write field to the HDF5 file.\n\n        >>> filename = \'mytestfile.hdf5\'\n        >>> field.write(filename)  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> field_read = df.Field.fromfile(filename)  # read the file\n        >>> field_read == field\n        True\n        >>> os.remove(filename)  # delete the file\n\n        .. seealso:: :py:func:`~discretisedfield.Field.fromfile`\n\n        """"""\n        if any([filename.endswith(ext) for ext in [\'.omf\', \'.ovf\', \'.ohf\']]):\n            self._writeovf(filename, representation=representation,\n                           extend_scalar=extend_scalar)\n        elif any([filename.endswith(ext) for ext in [\'.hdf5\', \'.h5\']]):\n            self._writehdf5(filename)\n        elif filename.endswith(\'.vtk\'):\n            self._writevtk(filename)\n        else:\n            msg = (f\'Writing file with extension {filename.split(""."")[-1]} \'\n                   f\'not supported.\')\n            raise ValueError(msg)\n\n    def _writeovf(self, filename, representation=\'txt\', extend_scalar=False):\n        """"""Write the field to an OVF2.0 file.\n\n        Data representation (``\'bin4\'``, ``\'bin8\'``, or ``\'txt\'``) is passed\n        using ``representation`` argument. If ``extend_scalar=True``, a scalar\n        field will be saved as a vector field. More precisely, if the value at\n        a cell is X, that cell will be saved as (X, 0, 0).\n\n        Parameters\n        ----------\n        filename : str\n\n            Name with an extension of the file written.\n\n        representation : str, optional\n\n            Representation; ``\'bin4\'``, ``\'bin8\'``, or ``\'txt\'``. Defaults to\n            ``\'txt\'``.\n\n        extend_scalar : bool, optional\n\n            If ``True``, a scalar field will be saved as a vector field. More\n            precisely, if the value at a cell is 3, that cell will be saved as\n            (3, 0, 0). Defaults to ``False``.\n\n        Example\n        -------\n        1. Write field to the OVF file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 5e-9, 3e-9)\n        >>> n = (10, 5, 3)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> value_fun = lambda point: (point[0], point[1], point[2])\n        >>> field = df.Field(mesh, dim=3, value=value_fun)\n        ...\n        >>> filename = \'mytestfile.ohf\'\n        >>> field._writeovf(filename, representation=\'bin8\')  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> field_read = df.Field.fromfile(filename)  # read the file\n        >>> field_read == field\n        True\n        >>> os.remove(filename)  # delete the file\n\n        .. seealso:: :py:func:`~discretisedfield.Field.fromfile`\n\n        """"""\n        if self.dim != 1 and self.dim != 3:\n            msg = (f\'Cannot write dim={self.dim} field.\')\n            raise TypeError(msg)\n\n        if extend_scalar and self.dim == 1:\n            write_dim = 3\n        else:\n            write_dim = self.dim\n\n        header = [\'OOMMF OVF 2.0\',\n                  \'\',\n                  \'Segment count: 1\',\n                  \'\',\n                  \'Begin: Segment\',\n                  \'Begin: Header\',\n                  \'\',\n                  \'Title: Field\',\n                  \'Desc: File generated by Field class\',\n                  \'meshunit: m\',\n                  \'meshtype: rectangular\',\n                  f\'xbase: {self.mesh.region.pmin[0] + self.mesh.cell[0]/2}\',\n                  f\'ybase: {self.mesh.region.pmin[1] + self.mesh.cell[1]/2}\',\n                  f\'zbase: {self.mesh.region.pmin[2] + self.mesh.cell[2]/2}\',\n                  f\'xnodes: {self.mesh.n[0]}\',\n                  f\'ynodes: {self.mesh.n[1]}\',\n                  f\'znodes: {self.mesh.n[2]}\',\n                  f\'xstepsize: {self.mesh.cell[0]}\',\n                  f\'ystepsize: {self.mesh.cell[1]}\',\n                  f\'zstepsize: {self.mesh.cell[2]}\',\n                  f\'xmin: {self.mesh.region.pmin[0]}\',\n                  f\'ymin: {self.mesh.region.pmin[1]}\',\n                  f\'zmin: {self.mesh.region.pmin[2]}\',\n                  f\'xmax: {self.mesh.region.pmax[0]}\',\n                  f\'ymax: {self.mesh.region.pmax[1]}\',\n                  f\'zmax: {self.mesh.region.pmax[2]}\',\n                  f\'valuedim: {write_dim}\',\n                  f\'valuelabels: field_x field_y field_z\',\n                  \'valueunits: None None None\',\n                  \'\',\n                  \'End: Header\',\n                  \'\']\n\n        if representation == \'bin4\':\n            header.append(\'Begin: Data Binary 4\')\n            footer = [\'End: Data Binary 4\',\n                      \'End: Segment\']\n        elif representation == \'bin8\':\n            header.append(\'Begin: Data Binary 8\')\n            footer = [\'End: Data Binary 8\',\n                      \'End: Segment\']\n        elif representation == \'txt\':\n            header.append(\'Begin: Data Text\')\n            footer = [\'End: Data Text\',\n                      \'End: Segment\']\n\n        # Write header lines\n        with open(filename, \'w\') as f:\n            f.write(\'\'.join(map(lambda line: f\'# {line}\\n\', header)))\n\n        binary_reps = {\'bin4\': (1234567.0, \'f\'),\n                       \'bin8\': (123456789012345.0, \'d\')}\n\n        # Write data.\n        if representation in binary_reps:\n            # Reopen with binary write, appending to the end of the file.\n            with open(filename, \'ab\') as f:\n                # Add the binary checksum.\n                packarray = [binary_reps[representation][0]]\n\n                # Write data to the ovf file.\n                for point, value in self:\n                    if self.dim == 3:\n                        v = value\n                    else:\n                        if extend_scalar:\n                            v = [value, 0.0, 0.0]\n                        else:\n                            v = [value]\n                    for vi in v:\n                        packarray.append(vi)\n\n                format = binary_reps[representation][1]*len(packarray)\n                f.write(struct.pack(format, *packarray))\n        else:\n            # Reopen with txt representation, appending to the end of the file.\n            with open(filename, \'a\') as f:\n                for point, value in self:\n                    if self.dim == 3:\n                        v = value\n                    else:\n                        if extend_scalar:\n                            v = [value, 0.0, 0.0]\n                        else:\n                            v = [value]\n                    for vi in v:\n                        f.write(f\' {str(vi)}\')\n                    f.write(\'\\n\')\n\n        # Write footer lines to OOMMF file.\n        with open(filename, \'a\') as f:\n            f.write(\'\'.join(map(lambda line: f\'# {line}\\n\', footer)))\n\n    def _writevtk(self, filename):\n        """"""Write the field to a VTK file.\n\n        The data is saved as a ``STRUCTURED_POINTS`` dataset. Scalar field\n        (``dim=1``) is saved as ``SCALARS``. On the other hand, vector field\n        (``dim=3``) is saved as both ``VECTORS`` as well as ``SCALARS`` for all\n        three components to enable easy colouring of vectors in some\n        visualisation packages.\n\n        The saved VTK file can be opened with `Paraview\n        <https://www.paraview.org/>`_ or `Mayavi\n        <https://docs.enthought.com/mayavi/mayavi/>`_.\n\n        Parameters\n        ----------\n        filename : str\n\n            File name with an extension.\n\n        Example\n        -------\n        1. Write field to a VTK file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 5e-9, 3e-9)\n        >>> n = (10, 5, 3)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> value_fun = lambda point: (point[0], point[1], point[2])\n        >>> field = df.Field(mesh, dim=3, value=value_fun)\n        ...\n        >>> filename = \'mytestfile.vtk\'\n        >>> field._writevtk(filename)  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> os.remove(filename)  # delete the file\n\n        """"""\n        header = [\'# vtk DataFile Version 3.0\',\n                  \'Field\',\n                  \'ASCII\',\n                  \'DATASET STRUCTURED_POINTS\',\n                  \'DIMENSIONS {} {} {}\'.format(*self.mesh.n),\n                  \'SPACINGS {} {} {}\'.format(*self.mesh.cell),\n                  \'ORIGIN {} {} {}\'.format(*self.mesh.index2point((0, 0, 0))),\n                  f\'POINT_DATA {len(self.mesh)}\']\n\n        if self.dim == 1:\n            data = dfu.vtk_scalar_data(self, \'field\')\n        elif self.dim == 3:\n            data = dfu.vtk_scalar_data(self.x, \'x-component\')\n            data += dfu.vtk_scalar_data(self.y, \'y-component\')\n            data += dfu.vtk_scalar_data(self.z, \'z-component\')\n            data += dfu.vtk_vector_data(self, \'field\')\n\n        with open(filename, \'w\') as f:\n            f.write(\'\\n\'.join(header+data))\n\n    def _writehdf5(self, filename):\n        """"""Write the field to an HDF5 file.\n\n        Parameters\n        ----------\n        filename : str\n\n            Name with an extension of the file written.\n\n        Example\n        -------\n        1. Write field to an HDF5 file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 5e-9, 3e-9)\n        >>> n = (10, 5, 3)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> value_fun = lambda point: (point[0], point[1], point[2])\n        >>> field = df.Field(mesh, dim=3, value=value_fun)\n        ...\n        >>> filename = \'mytestfile.h5\'\n        >>> field._writehdf5(filename)  # write the file\n        >>> os.path.isfile(filename)\n        True\n        >>> field_read = df.Field.fromfile(filename)  # read the file\n        >>> field_read == field\n        True\n        >>> os.remove(filename)  # delete the file\n\n        .. seealso:: :py:func:`~discretisedfield.Field.fromfile`\n\n        """"""\n        with h5py.File(filename, \'w\') as f:\n            # Set up the file structure\n            gfield = f.create_group(\'field\')\n            gmesh = gfield.create_group(\'mesh\')\n            gregion = gmesh.create_group(\'region\')\n\n            # Save everything as datasets\n            gregion.create_dataset(\'p1\', data=self.mesh.region.p1)\n            gregion.create_dataset(\'p2\', data=self.mesh.region.p2)\n            gmesh.create_dataset(\'n\', dtype=\'i4\', data=self.mesh.n)\n            gfield.create_dataset(\'dim\', dtype=\'i4\', data=self.dim)\n            gfield.create_dataset(\'array\', data=self.array)\n\n    @classmethod\n    def fromfile(cls, filename):\n        """"""Read the field from an OVF (1.0 or 2.0), VTK, or HDF5 file.\n\n        The extension of the ``filename`` should correspond to either:\n            - OVF (``.ovf``, ``.omf``, ``.ohf``, ``.oef``)\n            - VTK (``.vtk``), or\n            - HDF5 (``.hdf5`` or ``.h5``).\n\n        This is a ``classmethod`` and should be called as, for instance,\n        ``discretisedfield.Field.fromfile(\'myfile.omf\')``.\n\n        Parameters\n        ----------\n        filename : str\n\n            Name of the file to be read.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field read from the file.\n\n        Example\n        -------\n        1. Read the field from an OVF file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> dirname = os.path.join(os.path.dirname(__file__),\n        ...                        \'tests\', \'test_sample\')\n        >>> filename = os.path.join(dirname, \'oommf-ovf2-bin4.omf\')\n        >>> field = df.Field.fromfile(filename)\n        >>> field\n        Field(mesh=...)\n\n        2. Read a field from the VTK file.\n\n        >>> filename = os.path.join(dirname, \'vtk-file.vtk\')\n        >>> field = df.Field.fromfile(filename)\n        >>> field\n        Field(mesh=...)\n\n        3. Read a field from the HDF5 file.\n\n        >>> filename = os.path.join(dirname, \'hdf5-file.hdf5\')\n        >>> field = df.Field.fromfile(filename)\n        >>> field\n        Field(mesh=...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field._fromovf`\n        .. seealso:: :py:func:`~discretisedfield.Field._fromhdf5`\n        .. seealso:: :py:func:`~discretisedfield.Field._fromhdf5`\n        .. seealso:: :py:func:`~discretisedfield.Field.write`\n\n        """"""\n        if any([filename.endswith(ext) for ext in [\'.omf\', \'.ovf\',\n                                                   \'.ohf\', \'.oef\']]):\n            return cls._fromovf(filename)\n        elif any([filename.endswith(ext) for ext in [\'.vtk\']]):\n            return cls._fromvtk(filename)\n        elif any([filename.endswith(ext) for ext in [\'.hdf5\', \'.h5\']]):\n            return cls._fromhdf5(filename)\n        else:\n            msg = (f\'Reading file with extension {filename.split(""."")[-1]} \'\n                   f\'not supported.\')\n            raise ValueError(msg)\n\n    @classmethod\n    def _fromovf(cls, filename):\n        """"""Read the field from an OVF file.\n\n        Data representation (``txt``, ``bin4``, or ``bin8``) as well as the OVF\n        version (OVF1.0 or OVF2.0) are extracted from the file itself.\n\n        This is a ``classmethod`` and should be called as, for instance,\n        ``discretisedfield.Field._fromovf(\'myfile.omf\')``.\n\n        Parameters\n        ----------\n        filename : str\n\n            Name of the file to be read.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field read from the file.\n\n        Example\n        -------\n        1. Read a field from the OVF file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> dirname = os.path.join(os.path.dirname(__file__),\n        ...                        \'tests\', \'test_sample\')\n        >>> filename = os.path.join(dirname, \'oommf-ovf2-bin8.omf\')\n        >>> field = df.Field._fromovf(filename)\n        >>> field\n        Field(mesh=...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field._writeovf`\n\n        """"""\n        # valuedim is not in OVF1 metadata and has to be extracted\n        # from the data itself.\n        mdatalist = [\'xmin\', \'ymin\', \'zmin\',\n                     \'xmax\', \'ymax\', \'zmax\',\n                     \'xstepsize\', \'ystepsize\', \'zstepsize\',\n                     \'valuedim\']\n        mdatadict = dict()\n\n        try:\n            with open(filename, \'r\') as ovffile:\n                lines = ovffile.readlines()\n\n            mdatalines = list(filter(lambda s: s.startswith(\'#\'), lines))\n            datalines = np.loadtxt(filter(lambda s: not s.startswith(\'#\'),\n                                          lines))\n\n            if \'1.0\' in mdatalines[0]:\n                # valuedim is not in OVF1 file.\n                mdatadict[\'valuedim\'] = datalines.shape[-1]\n\n            for line in mdatalines:\n                for mdatum in mdatalist:\n                    if mdatum in line:\n                        mdatadict[mdatum] = float(line.split()[-1])\n                        break\n\n        except UnicodeDecodeError:\n            with open(filename, \'rb\') as ovffile:\n                f = ovffile.read()\n                lines = f.split(b\'\\n\')\n\n            mdatalines = list(filter(lambda s: s.startswith(bytes(\'#\',\n                                                                  \'utf-8\')),\n                                     lines))\n\n            if bytes(\'2.0\', \'utf-8\') in mdatalines[0]:\n                endian = \'<\'  # little-endian\n            elif bytes(\'1.0\', \'utf-8\') in mdatalines[0]:\n                endian = \'>\'  # big-endian\n\n            for line in mdatalines:\n                for mdatum in mdatalist:\n                    if bytes(mdatum, \'utf-8\') in line:\n                        mdatadict[mdatum] = float(line.split()[-1])\n                        break\n\n            header = b\'# Begin: Data Binary \'\n            data_start = f.find(header)\n            header = f[data_start:(data_start + len(header) + 1)]\n\n            data_start += len(header)\n            data_end = f.find(b\'# End: Data Binary \')\n\n            if b\'4\' in header:\n                nbytes = 4\n                formatstr = endian + \'f\'\n                checkvalue = 1234567.0\n            elif b\'8\' in header:\n                nbytes = 8\n                formatstr = endian + \'d\'\n                checkvalue = 123456789012345.0\n\n            newlines = [b\'\\n\\r\', b\'\\r\\n\', b\'\\n\']  # ordered by length\n            for nl in newlines:\n                if f.startswith(nl, data_start):\n                    data_start += len(nl)\n                    # There is a difference between files written by OOMMF and\n                    # mumax3. OOMMF has a newline character before the ""end\n                    # metadata line\', whereas mumax3 does not. Therefore if the\n                    # length of the data stream is not a multiple of nbytes, we\n                    # have to subtract the length of newline character from\n                    # data_end.\n                    if (data_end - data_start) % nbytes != 0:\n                        data_end -= len(nl)\n                    break\n\n            listdata = list(struct.iter_unpack(formatstr,\n                                               f[data_start:data_end]))\n            datalines = np.array(listdata)\n\n            if datalines[0] != checkvalue:\n                # These two lines cannot be accessed via tests. Therefore, they\n                # are excluded from coverage.\n                msg = \'Error in checksum comparison.\'  # pragma: no cover\n                raise AssertionError(msg)  # pragma: no cover\n\n            datalines = datalines[1:]\n\n        p1 = (mdatadict[key] for key in [\'xmin\', \'ymin\', \'zmin\'])\n        p2 = (mdatadict[key] for key in [\'xmax\', \'ymax\', \'zmax\'])\n        cell = (mdatadict[key] for key in [\'xstepsize\', \'ystepsize\',\n                                           \'zstepsize\'])\n\n        region = df.Region(p1=p1, p2=p2)\n        mesh = df.Mesh(region, cell=cell)\n\n        # valuedim is not in OVF1 file and for binary data it has to be\n        # extracted here.\n        if \'valuedim\' not in mdatadict.keys():\n            mdatadict[\'valuedim\'] = len(datalines) / len(mesh)\n\n        r_tuple = (*tuple(reversed(mesh.n)), int(mdatadict[\'valuedim\']))\n        t_tuple = (*tuple(reversed(range(3))), 3)\n\n        return cls(mesh, dim=int(mdatadict[\'valuedim\']),\n                   value=datalines.reshape(r_tuple).transpose(t_tuple))\n\n    @classmethod\n    def _fromvtk(cls, filename):\n        """"""Read the field from a VTK file.\n\n        This method reads the field from a VTK file defined on\n        STRUCTURED_POINTS written by ``discretisedfield._writevtk``.\n\n        This is a ``classmethod`` and should be called as, for instance,\n        ``discretisedfield.Field._fromvtk(\'myfile.vtk\')``.\n\n        Parameters\n        ----------\n        filename : str\n\n            Name of the file to be read.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field read from the file.\n\n        Example\n        -------\n        1. Read a field from the VTK file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> dirname = os.path.join(os.path.dirname(__file__),\n        ...                        \'tests\', \'test_sample\')\n        >>> filename = os.path.join(dirname, \'vtk-file.vtk\')\n        >>> field = df.Field._fromvtk(filename)\n        >>> field\n        Field(mesh=...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field._writevtk`\n\n        """"""\n        with open(filename, \'r\') as f:\n            content = f.read()\n        lines = content.split(\'\\n\')\n\n        # Determine the dimension of the field.\n        if \'VECTORS\' in content:\n            dim = 3\n            data_marker = \'VECTORS\'\n            skip = 0  # after how many lines data starts after marker\n        else:\n            dim = 1\n            data_marker = \'SCALARS\'\n            skip = 1\n\n        # Extract the metadata\n        mdatalist = [\'SPACINGS\', \'ORIGIN\', \'DIMENSIONS\']\n        mdatadict = dict()\n        for line in lines:\n            if not (line[0].isalpha() or line[0] == \'#\'):\n                break\n            for mdatum in mdatalist:\n                if mdatum in line:\n                    mdatadict[mdatum] = list(map(float, line.split()[1:]))\n\n        # Create objects from metadata info\n        cell = mdatadict[\'SPACINGS\']\n        n = list(map(int, mdatadict[\'DIMENSIONS\']))\n        p1 = np.subtract(mdatadict[\'ORIGIN\'], np.multiply(cell, 0.5))\n        p2 = np.add(p1, np.multiply(n, cell))\n        region = df.Region(p1=p1, p2=p2)\n        mesh = df.Mesh(region, n=n)\n        field = cls(mesh, dim=dim)\n\n        # Find where data starts.\n        for i, line in enumerate(lines):\n            if line.startswith(data_marker):\n                start_index = i\n                break\n\n        # Extract data.\n        for i, line in zip(mesh.indices, lines[start_index+skip+1:]):\n            if not line[0].isalpha():\n                field.array[i] = list(map(float, line.split()))\n\n        return field\n\n    @classmethod\n    def _fromhdf5(cls, filename):\n        """"""Read the field from an HDF5 file.\n\n        This method reads the field from an HDF5 file defined on written by\n        ``discretisedfield._writevtk``.\n\n        This is a ``classmethod`` and should be called as, for instance,\n        ``discretisedfield.Field._fromhdf5(\'myfile.h5\')``.\n\n        Parameters\n        ----------\n        filename : str\n\n            Name of the file to be read.\n\n        Returns\n        -------\n        discretisedfield.Field\n\n            Field read from the file.\n\n        Example\n        -------\n        1. Read a field from the HDF5 file.\n\n        >>> import os\n        >>> import discretisedfield as df\n        ...\n        >>> dirname = os.path.join(os.path.dirname(__file__),\n        ...                        \'tests\', \'test_sample\')\n        >>> filename = os.path.join(dirname, \'hdf5-file.hdf5\')\n        >>> field = df.Field._fromhdf5(filename)\n        >>> field\n        Field(mesh=...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field._writehdf5`\n\n        """"""\n        with h5py.File(filename, \'r\') as f:\n            # Read data from the file.\n            p1 = f[\'field/mesh/region/p1\']\n            p2 = f[\'field/mesh/region/p2\']\n            n = np.array(f[\'field/mesh/n\']).tolist()\n            dim = np.array(f[\'field/dim\']).tolist()\n            array = f[\'field/array\']\n\n            # Create field.\n            region = df.Region(p1=p1, p2=p2)\n            mesh = df.Mesh(region=region, n=n)\n            return cls(mesh, dim=dim, value=array[:])\n\n    def mpl_scalar(self, ax=None, figsize=None, filter_field=None,\n                   colorbar=True, colorbar_label=None, multiplier=None,\n                   filename=None, **kwargs):\n        """"""Plots the scalar field on a plane.\n\n        Before the field can be plotted, it must be sliced with a plane (e.g.\n        ``field.plane(\'z\')``). In addition, field must be a scalar field\n        (``dim=1``). Otherwise, ``ValueError`` is raised. ``mpl_scalar`` adds\n        the plot to ``matplotlib.axes.Axes`` passed via ``ax`` argument. If\n        ``ax`` is not passed, ``matplotlib.axes.Axes`` object is created\n        automatically and the size of a figure can be specified using\n        ``figsize``. By passing ``filter_field`` the points at which the pixels\n        are not coloured can be determined. More precisely, only those\n        discretisation cells where ``filter_field != 0`` are plotted. Colorbar\n        is shown by default and it can be removed from the plot by passing\n        ``colorbar=False``. The label for the colorbar can be defined by\n        passing ``colorbar_label`` as a string. It is often the case that the\n        region size is small (e.g. on a nanoscale) or very large (e.g. in units\n        of kilometers). Accordingly, ``multiplier`` can be passed as\n        :math:`10^{n}`, where :math:`n` is a multiple of 3  (..., -6, -3, 0, 3,\n        6,...). According to that value, the axes will be scaled and\n        appropriate units shown. For instance, if ``multiplier=1e-9`` is\n        passed, all mesh points will be divided by :math:`1\\\\,\\\\text{nm}` and\n        :math:`\\\\text{nm}` units will be used as axis labels. If ``multiplier``\n        is not passed, the best one is calculated internally. The plot can be\n        saved as a PDF when ``filename`` is passed.\n\n        This method plots the field using ``matplotlib.pyplot.imshow``\n        function, so any keyword arguments accepted by it can be passed (for\n        instance, ``cmap`` - colormap, ``clim`` - colorbar limits, etc.).\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the field plot is added. Defaults to ``None`` - axes\n            are created internally.\n\n        figsize : (2,) tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        filter_field : discretisedfield.Field, optional\n\n            A scalar field used for determining whether certain discretisation\n            cells are coloured. More precisely, only those discretisation cells\n            where ``filter_field != 0`` are plotted. Defaults to ``None``.\n\n        colorbar : bool, optional\n\n            If ``True``, colorbar is shown and it is hidden when ``False``.\n            Defaults to ``True``.\n\n        colorbar_label : str, optional\n\n            Colorbar label. Defaults to ``None``.\n\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the axes will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the mesh points will be\n            divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will\n            be used as axis labels. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Raises\n        ------\n        ValueError\n\n            If the field has not been sliced, its dimension is not 1, or the\n            dimension of ``filter_field`` is not 1.\n\n        Example\n        -------\n        1. Visualising the scalar field using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=1, value=2)\n        ...\n        >>> field.plane(\'y\').mpl_scalar()\n\n        .. seealso:: :py:func:`~discretisedfield.Field.mpl_vector`\n\n        """"""\n        if not hasattr(self.mesh, \'info\'):\n            msg = \'The field must be sliced before it can be plotted.\'\n            raise ValueError(msg)\n\n        if self.dim != 1:\n            msg = f\'Cannot plot dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111)\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.mesh.region.edges)\n\n        unit = f\' ({uu.rsi_prefixes[multiplier]}m)\'\n\n        points, values = map(list, zip(*list(self)))\n\n        if filter_field is not None:\n            if filter_field.dim != 1:\n                msg = f\'Cannot use dim={self.dim} filter_field.\'\n                raise ValueError(msg)\n\n            for i, point in enumerate(points):\n                if filter_field(point) == 0:\n                    values[i] = np.nan\n\n        pmin = np.divide(self.mesh.region.pmin, multiplier)\n        pmax = np.divide(self.mesh.region.pmax, multiplier)\n\n        extent = [pmin[self.mesh.info[\'axis1\']],\n                  pmax[self.mesh.info[\'axis1\']],\n                  pmin[self.mesh.info[\'axis2\']],\n                  pmax[self.mesh.info[\'axis2\']]]\n        n = (self.mesh.n[self.mesh.info[\'axis2\']],\n             self.mesh.n[self.mesh.info[\'axis1\']])\n\n        cp = ax.imshow(np.array(values).reshape(n), origin=\'lower\',\n                       extent=extent, **kwargs)\n\n        if colorbar:\n            cbar = plt.colorbar(cp)\n            if colorbar_label is not None:\n                cbar.ax.set_ylabel(colorbar_label)\n\n        ax.set_xlabel(dfu.raxesdict[self.mesh.info[\'axis1\']] + unit)\n        ax.set_ylabel(dfu.raxesdict[self.mesh.info[\'axis2\']] + unit)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def mpl_vector(self, ax=None, figsize=None, color=True, color_field=None,\n                   colorbar=True, colorbar_label=None, multiplier=None,\n                   filename=None, **kwargs):\n        """"""Plots the vector field on a plane.\n\n        Before the field can be plotted, it must be sliced with a plane (e.g.\n        ``field.plane(\'z\')``). In addition, field must be a vector field\n        (``dim=3``). Otherwise, ``ValueError`` is raised. ``mpl_vector`` adds\n        the plot to ``matplotlib.axes.Axes`` passed via ``ax`` argument. If\n        ``ax`` is not passed, ``matplotlib.axes.Axes`` object is created\n        automatically and the size of a figure can be specified using\n        ``figsize``. By default, plotted vectors are coloured according to the\n        out-of-plane component of the vectors. This can be changed by passing\n        ``color_field`` with ``dim=1``. To disable colouring of the plot,\n        ``color=False`` can be passed. Colorbar is shown by default and it can\n        be removed from the plot by passing ``colorbar=False``. The label for\n        the colorbar can be defined by passing ``colorbar_label`` as a string.\n        It is often the case that the region size is small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3  (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all mesh points will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally. The plot can be saved as a PDF when ``filename``\n        is passed.\n\n        This method plots the field using ``matplotlib.pyplot.quiver``\n        function, so any keyword arguments accepted by it can be passed (for\n        instance, ``cmap`` - colormap, ``clim`` - colorbar limits, etc.). In\n        particular, there are cases when ``matplotlib`` fails to find optimal\n        scale for plotting vectors. More precisely, sometimes vectors appear\n        too large in the plot. This can be resolved by passing ``scale``\n        argument, which scales all vectors in the plot. In other words, larger\n        ``scale``, smaller the vectors and vice versa. Please note that scale\n        can be in a very large range (e.g. 1e20).\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the field plot is added. Defaults to ``None`` - axes\n            are created internally.\n\n        figsize : tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        color_field : discretisedfield.Field, optional\n\n            A scalar field used for colouring the vectors. Defaults to ``None``\n            and vectors are coloured according to their out-of-plane\n            components.\n\n        colorbar : bool, optional\n\n            If ``True``, colorbar is shown and it is hidden when ``False``.\n            Defaults to ``True``.\n\n        colorbar_label : str, optional\n\n            Colorbar label. Defaults to ``None``.\n\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the axes will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the mesh points will be\n            divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will\n            be used as axis labels. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Raises\n        ------\n        ValueError\n\n            If the field has not been sliced, its dimension is not 3, or the\n            dimension of ``color_field`` is not 1.\n\n        Example\n        -------\n        1. Visualising the vector field using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=3, value=(1.1, 2.1, 3.1))\n        ...\n        >>> field.plane(\'y\').mpl_vector()\n\n        .. seealso:: :py:func:`~discretisedfield.Field.mpl_scalar`\n\n        """"""\n        if not hasattr(self.mesh, \'info\'):\n            msg = \'The field must be sliced before it can be plotted.\'\n            raise ValueError(msg)\n\n        if self.dim != 3:\n            msg = f\'Cannot plot dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111)\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.mesh.region.edges)\n\n        unit = f\' ({uu.rsi_prefixes[multiplier]}m)\'\n\n        points, values = map(list, zip(*list(self)))\n\n        # Remove points and values where norm is 0.\n        points = [p for p, v in zip(points, values)\n                  if not np.equal(v, 0).all()]\n        values = [v for v in values if not np.equal(v, 0).all()]\n\n        if color:\n            if color_field is None:\n                planeaxis = dfu.raxesdict[self.mesh.info[\'planeaxis\']]\n                color_field = getattr(self, planeaxis)\n\n            colors = [color_field(p) for p in points]\n\n        # ""Unpack"" values inside arrays and convert to np.ndarray.\n        points = np.array(list(zip(*points)))\n        values = np.array(list(zip(*values)))\n\n        points = np.divide(points, multiplier)\n\n        if color:\n            cp = ax.quiver(points[self.mesh.info[\'axis1\']],\n                           points[self.mesh.info[\'axis2\']],\n                           values[self.mesh.info[\'axis1\']],\n                           values[self.mesh.info[\'axis2\']],\n                           colors, pivot=\'mid\', **kwargs)\n        else:\n            ax.quiver(points[self.mesh.info[\'axis1\']],\n                      points[self.mesh.info[\'axis2\']],\n                      values[self.mesh.info[\'axis1\']],\n                      values[self.mesh.info[\'axis2\']],\n                      pivot=\'mid\', **kwargs)\n\n        if colorbar and color:\n            cbar = plt.colorbar(cp)\n            if colorbar_label is not None:\n                cbar.ax.set_ylabel(colorbar_label)\n\n        ax.set_xlabel(dfu.raxesdict[self.mesh.info[\'axis1\']] + unit)\n        ax.set_ylabel(dfu.raxesdict[self.mesh.info[\'axis2\']] + unit)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def mpl(self, ax=None, figsize=None, scalar_field=None,\n            scalar_filter_field=None, scalar_cmap=\'viridis\', scalar_clim=None,\n            scalar_colorbar=True, scalar_colorbar_label=None,\n            vector_field=None, vector_color=False, vector_color_field=None,\n            vector_cmap=\'cividis\', vector_clim=None, vector_colorbar=False,\n            vector_colorbar_label=None, vector_scale=None, multiplier=None,\n            filename=None):\n        """"""Plots the field on a plane.\n\n        This is a convenience method used for quick plotting, which combines\n        ``discretisedfield.Field.mpl_scalar`` and\n        ``discretisedfield.Field.mpl_vector`` methods. Depending on the\n        dimensionality of the field, it determines what plot is going to be\n        shown. For a scalar field only ``discretisedfield.Field.mpl_scalar`` is\n        used, whereas for a vector field, both\n        ``discretisedfield.Field.mpl_scalar`` and\n        ``discretisedfield.Field.mpl_vector`` plots are shown, where vector\n        plot shows the in-plane components of the vector and scalar plot\n        encodes the out-of-plane component.\n\n        All the default values can be changed by passing arguments, which are\n        then used in subplots. The way parameters of this function are used to\n        create plots can be understood with the following code snippet.\n\n        ```\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111)\n\n        scalar_field.mpl_scalar(ax=ax, filter_field=scalar_filter_field,\n                                colorbar=scalar_colorbar,\n                                colorbar_label=scalar_colorbar_label,\n                                multiplier=multiplier, cmap=scalar_cmap,\n                                clim=scalar_clim,)\n\n        vector_field.mpl_vector(ax=ax, color=vector_color,\n                                color_field=vector_color_field,\n                                colorbar=vector_colorbar,\n                                colorbar_label=vector_colorbar_label,\n                                multiplier=multiplier, scale=vector_scale,\n                                cmap=vector_cmap, clim=vector_clim,)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0.02)\n        ```\n\n        Therefore, to understand the meaning of the arguments which can be\n        passed to this method, please refer to\n        ``discretisedfield.Field.mpl_scalar`` and\n        ``discretisedfield.Field.mpl_vector`` documentation.\n\n        Raises\n        ------\n        ValueError\n\n            If the field has not been sliced with a plane.\n\n        Example\n        -------\n        1. Visualising the field using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=3, value=(1, 2, 0))\n        >>> field.plane(z=50, n=(5, 5)).mpl()\n\n        .. seealso::\n\n            :py:func:`~discretisedfield.Field.mpl_scalar`\n            :py:func:`~discretisedfield.Field.mpl_vector`\n\n        """"""\n        if not hasattr(self.mesh, \'info\'):\n            msg = \'The field must be sliced before it can be plotted.\'\n            raise ValueError(msg)\n\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111)\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.mesh.region.edges)\n\n        unit = f\' ({uu.rsi_prefixes[multiplier]}m)\'\n\n        planeaxis = dfu.raxesdict[self.mesh.info[\'planeaxis\']]\n\n        # Set up default values.\n        if self.dim == 1:\n            if scalar_field is None:\n                scalar_field = self\n            else:\n                scalar_field = self.__class__(self.mesh, dim=1,\n                                              value=scalar_field)\n        if self.dim == 3:\n            if vector_field is None:\n                vector_field = self\n            else:\n                vector_field = self.__class__(self.mesh, dim=3,\n                                              value=vector_field)\n            if scalar_field is None:\n                scalar_field = getattr(self, planeaxis)\n                scalar_colorbar_label = f\'{planeaxis}-component\'\n            else:\n                scalar_field = self.__class__(self.mesh, dim=1,\n                                              value=scalar_field)\n            if scalar_filter_field is None:\n                scalar_filter_field = self.norm\n            else:\n                scalar_filter_field = self.__class__(self.mesh, dim=1,\n                                                     value=scalar_filter_field)\n\n        if scalar_field is not None:\n            scalar_field.mpl_scalar(ax=ax, filter_field=scalar_filter_field,\n                                    colorbar=scalar_colorbar,\n                                    colorbar_label=scalar_colorbar_label,\n                                    multiplier=multiplier, cmap=scalar_cmap,\n                                    clim=scalar_clim,)\n        if vector_field is not None:\n            vector_field.mpl_vector(ax=ax, color=vector_color,\n                                    color_field=vector_color_field,\n                                    colorbar=vector_colorbar,\n                                    colorbar_label=vector_colorbar_label,\n                                    multiplier=multiplier, scale=vector_scale,\n                                    cmap=vector_cmap, clim=vector_clim,)\n\n        ax.set_xlabel(dfu.raxesdict[self.mesh.info[\'axis1\']] + unit)\n        ax.set_ylabel(dfu.raxesdict[self.mesh.info[\'axis2\']] + unit)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0.02)\n\n    def k3d_nonzero(self, plot=None, color=dfu.cp_int[0], multiplier=None,\n                    interactive_field=None, **kwargs):\n        """"""``k3d`` plot of non-zero discretisation cells.\n\n        If ``plot`` is not passed, ``k3d.Plot`` object is created\n        automatically. The colour of the region can be specified using\n        ``color`` argument.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        For interactive plots ``interactive=True`` must be passed, together\n        with the ``field``, which is a field object before slicing.\n\n        This method is based on ``k3d.voxels``, so any keyword arguments\n        accepted by it can be passed (e.g. ``wireframe``).\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which the plot is added. Defaults to ``None`` - plot is\n            created internally.\n\n        color : int, optional\n\n            Colour of the region. Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        interactive : bool\n\n            For interactive plotting, ``True`` must be passed. Defaults to\n            ``False``.\n\n        field : discretisedfield.Field\n\n            If ``field`` is passed, then the region of the field is plotted.\n            Defaults to ``None``.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 1.\n\n        Examples\n        --------\n        1. Visualising the ""non-zero"" region using ``k3d``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-50e-9, -50e-9, -50e-9)\n        >>> p2 = (50e-9, 50e-9, 50e-9)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n        >>> field = df.Field(mesh, dim=3, value=(1, 2, 0))\n        >>> def normfun(point):\n        ...     x, y, z = point\n        ...     if x**2 + y**2 < 30**2:\n        ...         return 1\n        ...     else:\n        ...         return 0\n        >>> field.norm = normfun\n        ...\n        >>> field.norm.k3d_nonzero()\n        Plot(...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.k3d_voxels`\n\n        """"""\n        if self.dim != 1:\n            msg = f\'Cannot plot dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        if plot is None:\n            plot = k3d.plot()\n            plot.display()\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.mesh.region.edges)\n\n        unit = f\'({uu.rsi_prefixes[multiplier]}m)\'\n\n        if interactive_field is not None:\n            plot.camera_auto_fit = False\n\n            for object in plot.objects:\n                if object.name != \'total_region\':\n                    plot -= object\n\n            if not any([i.name == \'total_region\' for i in plot.objects]):\n                bounds = [i for sublist in\n                          zip(np.divide(interactive_field.mesh.region.pmin,\n                                        multiplier),\n                              np.divide(interactive_field.mesh.region.pmax,\n                                        multiplier))\n                          for i in sublist]\n\n                plot += k3d.voxels(np.ones((1, 1, 1)).astype(np.uint8),\n                                   color_map=dfu.cp_int[0],\n                                   bounds=bounds,\n                                   outlines=False,\n                                   name=\'total_region\',\n                                   opacity=0.025)\n\n        plot_array = np.ones_like(self.array)  # all voxels have the same color\n        plot_array[self.array == 0] = 0  # remove voxels where field is zero\n        plot_array = plot_array[..., 0]  # remove an empty dimension\n        plot_array = np.swapaxes(plot_array, 0, 2)  # k3d: arrays are (z, y, x)\n        plot_array = plot_array.astype(np.uint8)  # to avoid k3d warning\n\n        bounds = [i for sublist in\n                  zip(np.divide(self.mesh.region.pmin, multiplier),\n                      np.divide(self.mesh.region.pmax, multiplier))\n                  for i in sublist]\n\n        plot += k3d.voxels(plot_array, color_map=color, bounds=bounds,\n                           outlines=False, **kwargs)\n\n        plot.axes = [f\'{i}\\,\\\\text{{{unit}}}\' for i in dfu.axesdict.keys()]\n\n    def k3d_voxels(self, plot=None, filter_field=None, multiplier=None,\n                   cmap=\'cividis\', n=256, field=None, interactive=False,\n                   **kwargs):\n        """"""Plots the scalar field as a coloured ``k3d.voxels()`` plot.\n\n        If ``plot`` is not passed, ``k3d`` plot will be created automaticaly.\n        By passing ``filter_field``, the points at which the voxels are plotted\n        can be determined. More precisely, only voxels where ``filter_field !=\n        0`` are plotted. It is often the case that the mesh region size is\n        small (e.g. on a nanoscale) or very large (e.g. in units of\n        kilometeres). Accordingly, ``multiplier`` can be passed as\n        :math:`10^{n}`, where :math:`n` is a multiple of 3 (..., -6, -3, 0, 3,\n        6,...). According to that value, the axes will be scaled and\n        appropriate units shown. For instance, if ``multiplier=1e-9`` is\n        passed, the mesh points will be divided by :math:`1\\\\,\\\\text{nm}` and\n        :math:`\\\\text{nm}` units will be used as axis labels. If ``multiplier``\n        is not passed, the optimum one is computed internally. The colormap and\n        the resolution of the colours can be set by passing ``cmap`` and ``n``.\n        When sliced field is plotted, it is sometimes necessary to plot the\n        region of the original field. This can be achieved by passing the field\n        using ``field``. In interactive plots, ``field`` must be passed.\n        ``interactive=True`` must be defined when the method is used for\n        interactive plotting.\n\n        This method plots the region using ``k3d.voxels()`` function, so any\n        keyword arguments accepted by it can be passed.\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which plot should be added. Defaults to ``None`` - new plot\n            will be created.\n\n        filter_field : discretisedfield.Field, optional\n\n            A (scalar) field used for determining whether certain voxels should\n            be plotted. More precisely, only discretisation cells where\n            ``filter_field != 0`` are plotted.\n\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the axes will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the mesh points will be\n            divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will\n            be used as axis labels. If ``multiplier`` is not passed, the\n            optimum one is computed internally. Defaults to ``None``.\n\n        cmap : str\n\n            Colormap. Defaults to ``\'cividis\'``.\n\n        n : int\n\n            The resolution of the colormap. Defaults to 256, which is also the\n            maximum possible value.\n\n        field : discretisedfield.Field\n\n            If ``field`` is passed, then the region of the field is plotted.\n            Defaults to ``None``.\n\n        interactive : bool\n\n            For interactive plotting, ``True`` must be passed. Defaults to\n            ``False``.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 1.\n\n        Example\n        -------\n        1. Plot the scalar field using ``k3d``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-50, -50, -50)\n        >>> p2 = (50, 50, 50)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> field = df.Field(mesh, dim=1, value=5)\n        >>> field.k3d_voxels()\n        Plot(...)\n\n        .. seealso:: :py:func:`~discretisedfield.Field.k3d_vectors`\n\n        """"""\n        if self.dim != 1:\n            msg = f\'Cannot plot dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        if filter_field is not None:\n            if filter_field.dim != 1:\n                msg = f\'Cannot use dim={self.dim} filter_field.\'\n                raise ValueError(msg)\n\n        if n > 256:\n            msg = f\'Cannot use n={n}. Maximum value is 256.\'\n            raise ValueError(msg)\n\n        plot_array = np.copy(self.array)  # make a deep copy\n        plot_array = plot_array[..., 0]  # remove an empty dimension\n\n        # All values must be in (1, 255) -> (1, n-1), for n=256 range, with\n        # maximum n=256. This is the limitation of k3d.voxels(). Voxels where\n        # values are zero, are invisible.\n        plot_array = dfu.normalise_to_range(plot_array, (1, n-1))\n\n        # Remove voxels where filter_field = 0.\n        if filter_field is not None:\n            for index in self.mesh.indices:\n                if filter_field(self.mesh.index2point(index)) == 0:\n                    plot_array[index] = 0\n\n        plot_array = np.swapaxes(plot_array, 0, 2)  # k3d: arrays are (z, y, x)\n\n        color_palette = dfu.color_palette(cmap, n, \'int\')\n\n        plot, multiplier = dfu.k3d_parameters(plot, multiplier,\n                                              self.mesh.region.edges)\n\n        if field is not None:\n            dfu.k3d_plot_region(plot, field.mesh.region, multiplier)\n\n        if interactive:\n            dfu.k3d_setup_interactive_plot(plot)\n\n        plot += dfu.voxels(plot_array, pmin=self.mesh.region.pmin,\n                           pmax=self.mesh.region.pmax,\n                           color_palette=color_palette, multiplier=multiplier,\n                           **kwargs)\n\n    def k3d_vectors(self, plot=None, color_field=None, points=True,\n                    cmap=\'cividis\', n=256,\n                    point_color=dfu.color_palette(\'deep\', 1, \'int\')[0],\n                    point_size=None, multiplier=None, vector_multiplier=None,\n                    field=None, interactive=False, **kwargs):\n        """"""Plots the vector field using ``k3d``.\n\n        If ``plot`` is not passed, ``k3d`` plot will be created automaticaly.\n        It is often the case that the mesh region size is small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometeres). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, the mesh points will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the optimum one is\n        computed internally. Similarly, the vectors can be too large or two\n        small to be plotted. In that case, ``vector_multiplier`` can be passed,\n        so that all vectors are divided by that scalar. If not passed, the\n        optimum value is computed internally. The colour of vectors can be\n        determined by passing ``color_field``, whereas the colormap and the\n        resolution can be determined by passing ``cmap`` and ``n``. In addition\n        to vectors, points at which the vectors are defined can be plotted if\n        ``points=True``. The size of the points can be passed using\n        ``point_size`` and if ``point_size`` is not passed, optimum size is\n        computed intenally. Similarly, ``point_color`` can be passed as an\n        integer. When sliced field is plotted, it is sometimes necessary to\n        plot the region of the original field. This can be achieved by passing\n        the field using ``field``. In interactive plots, ``field`` must be\n        passed. ``interactive=True`` must be defined when the method is used\n        for interactive plotting.\n\n        This method plots the vectors using ``k3d.vectors()`` function, so any\n        keyword arguments accepted by it can be passed.\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which vector plot should be added. Defaults to ``None`` -\n            new plot will be created.\n\n        color_field : discretisedfield.Field, optional\n\n            Field determining the values according to which the vectors are\n            coloured. Defults to ``None``.\n\n        points : bool, optional\n\n            If ``True``, points are added to the plot.\n\n        point_size : float, optional\n\n            Size of points.\n\n        point_color : int, optional\n\n            Colour of points. Defaults to\n            ``seaborn.color_pallette(palette=\'deep\')[0]``.\n\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the axes will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the mesh points will be\n            divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will\n            be used as axis labels. If ``multiplier`` is not passed, the\n            optimum one is computed internally. Defaults to ``None``.\n\n        vector_multiplier : numbers.Real, optional\n\n            Value by which all vectors are divided to fit the plot.\n\n        cmap : str\n\n            Colormap. Defaults to ``\'cividis\'``.\n\n        n : int\n\n            The resolution of the colormap. Defaults to 256.\n\n        field : discretisedfield.Field\n\n            If ``field`` is passed, then the region of the field is plotted.\n            Defaults to ``None``.\n\n        interactive : bool\n\n            For interactive plotting, ``True`` must be passed. Defaults to\n            ``False``.\n\n        Raises\n        ------\n        ValueError\n\n            If the dimension of the field is not 3.\n\n        Examples\n        --------\n        1. Visualising the vector field using ``k3d``.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        >>> field = df.Field(mesh, dim=3, value=(0, 0, 1))\n        >>> field.k3d_vectors()\n        Plot(...)\n\n        """"""\n        if self.dim != 3:\n            msg = f\'Cannot plot dim={self.dim} field.\'\n            raise ValueError(msg)\n\n        if color_field is not None:\n            if color_field.dim != 1:\n                msg = f\'Cannot use dim={self.dim} color_field.\'\n                raise ValueError(msg)\n\n        coordinates, vectors, color_values = [], [], []\n        norm_field = self.norm  # assigned to be computed only once\n        for coord, value in self:\n            if norm_field(coord) > 0:\n                coordinates.append(coord)\n                vectors.append(value)\n                if color_field is not None:\n                    color_values.append(color_field(coord))\n        coordinates, vectors = np.array(coordinates), np.array(vectors)\n\n        plot, multiplier = dfu.k3d_parameters(plot, multiplier,\n                                              self.mesh.region.edges)\n\n        if field is not None:\n            dfu.k3d_plot_region(plot, field.mesh.region, multiplier)\n\n        if interactive:\n            dfu.k3d_setup_interactive_plot(plot)\n\n        if vector_multiplier is None:\n            vector_multiplier = (vectors.max() /\n                                 np.divide(self.mesh.cell, multiplier).min())\n\n        if color_field is not None:\n            color_values = dfu.normalise_to_range(color_values, (0, n-1))\n\n            # Generate double pairs (body, head) for colouring vectors.\n            color_palette = dfu.color_palette(cmap, n, \'int\')\n            colors = []\n            for cval in color_values:\n                colors.append(2*(color_palette[cval],))\n        else:\n            # Uniform colour.\n            colors = (len(vectors) *\n                      ([2*(dfu.color_palette(\'deep\', 2, \'int\')[1],)]))\n\n        plot += dfu.vectors(coordinates, vectors, colors=colors,\n                            multiplier=multiplier,\n                            vector_multiplier=vector_multiplier, **kwargs)\n\n        if points:\n            if point_size is None:\n                # If undefined, the size of the point is 1/4 of the smallest\n                # cell dimension.\n                point_size = np.divide(self.mesh.cell, multiplier).min() / 4\n\n            plot += dfu.points(coordinates, color=point_color,\n                               point_size=point_size, multiplier=multiplier)\n'"
discretisedfield/interact.py,0,"b'import ipywidgets\n\n\ndef interact(**kwargs):\n    """"""Decorator for interactive plotting.\n\n    This is a wrapper around ``ipywidgets.interact``. For details, please refer\n    to ``interact`` function in ``ipywidgets`` package.\n\n    Example\n    -------\n    1. Interactive plotting.\n\n    >>> import discretisedfield as df\n    ...\n    >>> p1 = (-50e-9, -50e-9, -50e-9)\n    >>> p2 = (50e-9, 50e-9, 50e-9)\n    >>> n = (10, 10, 10)\n    >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n    >>> field = df.Field(mesh, dim=3, value=(1, 2, 0))\n    >>> @df.interact(x=field.mesh.slider(\'x\'))\n    ... def myplot(x):\n    ...     field.plane(x=x).mpl()\n    interactive(...)\n\n    """"""\n    return ipywidgets.interact(**kwargs)\n'"
discretisedfield/line.py,6,"b'import numbers\nimport ipywidgets\nimport numpy as np\nimport pandas as pd\nimport ubermagutil.units as uu\nimport matplotlib.pyplot as plt\nimport ubermagutil.typesystem as ts\nimport discretisedfield.util as dfu\n\n\n@ts.typesystem(dim=ts.Scalar(expected_type=int, positive=True, const=True),\n               n=ts.Scalar(expected_type=int, positive=True, const=True))\nclass Line:\n    """"""Line class.\n\n    This class implements the field sampled on the line. It is based on\n    ``pandas.DataFrame``, which is generated from two lists: ``points`` and\n    ``values`` of the same length. ``points`` is a list of length-3 tuples\n    representing the points on the line on which the field was sampled. On the\n    other hand, ``values`` is a list of field values, which are\n    ``numbers.Real`` for scalar fields or ``array_like`` for vector fields.\n    During the initialisation of the object, ``r`` column is added to\n    ``pandas.DataFrame`` and it represents the distance of the point from the\n    first point in ``points``.\n\n    By default the columns where points data is stored are labelled as ``px``,\n    ``py``, and ``pz``, storing the x, y, and z components of the point,\n    respectively. Similarly, for scalar fields, values are stored in column\n    ``v``, whereas for vector fields, data is stored in ``vx``, ``vy``, and\n    ``vz``. The default names of columns can be changed by passing\n    ``point_columns`` and ``value_columns`` lists. Both lists are composed of\n    strings and must have appropriate lengths.\n\n    The number of points can be retrieved as ``discretisedfield.Line.n`` and\n    the dimension of the value can be retrieved using\n    ``discretisedfield.Line.dim``.\n\n    Data in the form of ``pandas.DataFrame`` can be exposed as ``line.data``.\n\n    Parameters\n    ----------\n    points : list\n\n        Points at which the field was sampled. It is a list of length-3 tuples.\n\n    values : list\n\n        Values sampled at ``points``.\n\n    point_columns : list\n\n        Point column names. Defaults to None.\n\n    value_columns : list\n\n        Value column names. Defaults to None.\n\n    Raises\n    ------\n    ValueError\n\n        If the numbers of points is not the same as the number of values.\n\n    Example\n    -------\n    1. Defining ``Line`` object, which contains scalar values.\n\n    >>> import discretisedfield as df\n    ...\n    >>> points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n    >>> values = [1, 2, 3]  # scalar values\n    >>> line = df.Line(points=points, values=values)\n    >>> line.n  # the number of points\n    3\n    >>> line.dim\n    1\n\n    2. Defining ``Line`` for vector values.\n\n    >>> points = [(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3)]\n    >>> values = [(0, 0, 1), (0, 0, 2), (0, 0, 3), (0, 0, 4)]  # vector values\n    >>> line = df.Line(points=points, values=values)\n    >>> line.n  # the number of points\n    4\n    >>> line.dim\n    3\n\n    """"""\n    def __init__(self, points, values, point_columns=None, value_columns=None):\n        if len(points) != len(values):\n            msg = (f\'The number of points ({len(points)}) must be the same \'\n                   f\'as the number of values ({len(values)}).\')\n            raise ValueError(msg)\n\n        # Set the dimension (const descriptor).\n        if isinstance(values[0], numbers.Real):\n            self.dim = 1\n        else:\n            self.dim = len(values[0])\n\n        # Set the number of values (const descriptor).\n        self.n = len(points)\n\n        points = np.array(points)\n        values = np.array(values).reshape((points.shape[0], -1))\n\n        self.data = pd.DataFrame()\n        self.data[\'r\'] = np.linalg.norm(points - points[0, :], axis=1)\n        for i, column in enumerate(self.point_columns):\n            self.data[column] = points[..., i]\n        for i, column in zip(range(values.shape[-1]), self.value_columns):\n            self.data[column] = values[..., i]\n\n        if point_columns is not None:\n            self.point_columns = point_columns\n\n        if value_columns is not None:\n            self.value_columns = value_columns\n\n    @property\n    def point_columns(self):\n        """"""The names of point columns.\n\n        This method returns a list of strings denoting the names of columns\n        storing three coordinates of points. Similarly, by assigning a list of\n        strings to this property, the columns can be renamed.\n\n        Parameters\n        ----------\n        val : list\n\n            Point column names used to rename them.\n\n        Returns\n        -------\n        list\n\n            List of point column names.\n\n        Raises\n        ------\n        ValueError\n\n            If a list of inappropriate length is passed.\n\n        Examples\n        --------\n        1. Getting and setting the column names.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n        >>> values = [1, 2, 3]  # scalar values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.point_columns\n        [\'px\', \'py\', \'pz\']\n        >>> line.point_columns = [\'p0\', \'p1\', \'p2\']\n        >>> line.data.columns\n        Index([\'r\', \'p0\', \'p1\', \'p2\', \'v\'], dtype=\'object\')\n\n        """"""\n        if not hasattr(self, \'_point_columns\'):\n            return [f\'p{i}\' for i in dfu.axesdict.keys()]\n        else:\n            return self._point_columns\n\n    @point_columns.setter\n    def point_columns(self, val):\n        if len(val) != 3:\n            msg = (f\'Cannot change column names with a \'\n                   f\'list of lenght {len(val)}.\')\n            raise ValueError(msg)\n\n        self.data = self.data.rename(dict(zip(self.point_columns, val)),\n                                     axis=1)\n        self._point_columns = val\n\n    @property\n    def value_columns(self):\n        """"""The names of value columns.\n\n        This method returns a list of strings denoting the names of columns\n        storing values. The length of the list is the same as the dimension of\n        the value. Similarly, by assigning a list of strings to this property,\n        the columns can be renamed.\n\n        Parameters\n        ----------\n        val : list\n\n            Value column names used to rename them.\n\n        Returns\n        -------\n        list\n\n            List of value column names.\n\n        Raises\n        ------\n        ValueError\n\n            If a list of inappropriate length is passed.\n\n        Examples\n        --------\n        1. Getting and setting the column names.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n        >>> values = [1, 2, 3]  # scalar values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.value_columns\n        [\'v\']\n        >>> line.value_columns = [\'my_interesting_value\']\n        >>> line.data.columns\n        Index([\'r\', \'px\', \'py\', \'pz\', \'my_interesting_value\'], dtype=\'object\')\n\n        """"""\n        if not hasattr(self, \'_value_columns\'):\n            if self.dim == 1:\n                return [\'v\']\n            else:\n                return [f\'v{i}\' for i in list(dfu.axesdict.keys())[:self.dim]]\n        else:\n            return self._value_columns\n\n    @value_columns.setter\n    def value_columns(self, val):\n        if len(val) != self.dim:\n            msg = (f\'Cannot change column names with a \'\n                   f\'list of lenght {len(val)}.\')\n            raise ValueError(msg)\n\n        self.data = self.data.rename(dict(zip(self.value_columns, val)),\n                                     axis=1)\n        self._value_columns = val\n\n    @property\n    def length(self):\n        """"""Line length.\n\n        Length of the line is defined as the distance between the first and the\n        last point in ``points``.\n\n        Returns\n        -------\n        float\n\n            Line length.\n\n        Example\n        -------\n        1. Getting the length of the line.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (2, 0, 0), (4, 0, 0)]\n        >>> values = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # vector values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.length\n        4.0\n\n        """"""\n        return self.data[\'r\'].iloc[-1]\n\n    def __repr__(self):\n        """"""Representation string.\n\n        Returns\n        -------\n        str\n\n            Representation string.\n\n        Example\n        -------\n        1. Getting representation string.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (2, 0, 0), (4, 0, 0)]\n        >>> values = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # vector values\n        >>> line = df.Line(points=points, values=values)\n        >>> repr(line)\n        \'...\n\n        """"""\n        return repr(self.data)\n\n    def mpl(self, ax=None, figsize=None, yaxis=None, xlim=None,\n            multiplier=None, filename=None, **kwargs):\n        """"""Line values plot.\n\n        This method plots the values (scalar or individual components) as a\n        function of the distance ``r``. ``mpl`` adds the plot to\n        ``matplotlib.axes.Axes`` passed via ``ax`` argument. If ``ax`` is not\n        passed, ``matplotlib.axes.Axes`` object is created automatically and\n        the size of a figure can be specified using ``figsize``. To choose\n        particular value columns to be plotted ``yaxis`` can be passed as a\n        list of column names. The range of ``r``values on the horizontal axis\n        can be defined by passing a lenth-2 tuple. It is often the case that\n        the line length is small (e.g. on a nanoscale) or very large (e.g. in\n        units of kilometers). Accordingly, ``multiplier`` can be passed as\n        :math:`10^{n}`, where :math:`n` is a multiple of 3  (..., -6, -3, 0, 3,\n        6,...). According to that value, the horizontal axis will be scaled and\n        appropriate units shown. For instance, if ``multiplier=1e-9`` is\n        passed, all mesh points will be divided by :math:`1\\\\,\\\\text{nm}` and\n        :math:`\\\\text{nm}` units will be used as axis labels. If ``multiplier``\n        is not passed, the best one is calculated internally. The plot can be\n        saved as a PDF when ``filename`` is passed.\n\n        This method plots the mesh using ``matplotlib.pyplot.plot()`` function,\n        so any keyword arguments accepted by it can be passed.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the field plot is added. Defaults to ``None`` - axes\n            are created internally.\n\n        figsize : tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        yaxis : list, optional\n\n            A list of value columns to be plotted.\n\n        xlim : tuple\n\n            A length-2 tuple setting the limits of the horizontal axis.\n\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the axes will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the mesh points will be\n            divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will\n            be used as axis labels. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising the values on the line using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (2, 0, 0), (4, 0, 0)]\n        >>> values = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # vector values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.mpl()\n\n        """"""\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111)\n\n        if multiplier is None:\n            multiplier = uu.si_multiplier(self.length)\n\n        if yaxis is None:\n            yaxis = self.value_columns\n\n        for i in yaxis:\n            ax.plot(np.divide(self.data[\'r\'].to_numpy(), multiplier),\n                    self.data[i], label=i, **kwargs)\n\n        ax.set_xlabel(f\'r ({uu.rsi_prefixes[multiplier]}m)\')\n        ax.set_ylabel(\'value\')\n\n        ax.grid(True)  # grid is turned off by default for field plots\n        ax.legend()\n\n        if xlim is not None:\n            plt.xlim(*np.divide(xlim, multiplier))\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def slider(self, multiplier=None, **kwargs):\n        """"""Slider for interactive plotting.\n\n        Based on the values in the ``r`` column,\n        ``ipywidgets.SelectionRangeSlider`` is returned for navigating\n        interactive plots.\n\n        This method is based on ``ipywidgets.SelectionRangeSlider``, so any\n        keyword argument accepted by it can be passed.\n\n        Parameters\n        ----------\n        multiplier : numbers.Real, optional\n\n            ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is\n            a multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that\n            value, the values will be scaled and appropriate units shown. For\n            instance, if ``multiplier=1e-9`` is passed, the slider points will\n            be divided by :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units\n            will be used in the description. If ``multiplier`` is not passed,\n            the optimum one is computed internally. Defaults to ``None``.\n\n        Returns\n        -------\n        ipywidgets.SelectionRangeSlider\n\n            ``r`` range slider.\n\n        Example\n        -------\n        1. Get the slider for the horizontal axis.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (2, 0, 0), (4, 0, 0)]\n        >>> values = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # vector values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.slider()\n        SelectionRangeSlider(...)\n\n        """"""\n        if multiplier is None:\n            multiplier = uu.si_multiplier(self.length)\n\n        values = self.data[\'r\'].to_numpy()\n        labels = np.around(values/multiplier, decimals=2)\n        options = list(zip(labels, values))\n        slider_description = f\'r ({uu.rsi_prefixes[multiplier]}m):\'\n\n        return ipywidgets.SelectionRangeSlider(options=options,\n                                               value=(values[0], values[-1]),\n                                               description=slider_description,\n                                               **kwargs)\n\n    def selector(self, **kwargs):\n        """"""Selection list for interactive plotting.\n\n        Based on the value columns, ``ipywidgets.SelectMultiple`` widget is\n        returned for selecting the value columns to be plotted.\n\n        This method is based on ``ipywidgets.SelectMultiple``, so any\n        keyword argument accepted by it can be passed.\n\n        Returns\n        -------\n        ipywidgets.SelectMultiple\n\n            Selection list.\n\n        Example\n        -------\n        1. Get the widget for selecting value columns.\n\n        >>> import discretisedfield as df\n        ...\n        >>> points = [(0, 0, 0), (2, 0, 0), (4, 0, 0)]\n        >>> values = [(1, 0, 0), (0, 1, 0), (0, 0, 1)]  # vector values\n        >>> line = df.Line(points=points, values=values)\n        >>> line.selector()\n        SelectMultiple(...)\n\n        """"""\n        return ipywidgets.SelectMultiple(options=self.value_columns,\n                                         value=self.value_columns,\n                                         rows=3,\n                                         description=\'y-axis:\',\n                                         disabled=False,\n                                         **kwargs)\n'"
discretisedfield/mesh.py,31,"b'import k3d\nimport itertools\nimport ipywidgets\nimport collections\nimport numpy as np\nimport discretisedfield as df\nimport ubermagutil.units as uu\nimport matplotlib.pyplot as plt\nimport ubermagutil.typesystem as ts\nimport discretisedfield.util as dfu\nfrom mpl_toolkits.mplot3d import Axes3D\n\n\n@ts.typesystem(region=ts.Typed(expected_type=df.Region),\n               cell=ts.Vector(size=3, positive=True, const=True),\n               n=ts.Vector(size=3, component_type=int, unsigned=True,\n                           const=True),\n               bc=ts.Typed(expected_type=str),\n               subregions=ts.Dictionary(\n                   key_descriptor=ts.Name(),\n                   value_descriptor=ts.Typed(expected_type=df.Region),\n                   allow_empty=True))\nclass Mesh:\n    """"""Finite difference mesh.\n\n    Mesh discretises cubic ``discretisedfield.Region``, passed as ``region``,\n    using a regular finite difference mesh. Since cubic region spans between\n    two points :math:`\\\\mathbf{p}_{1}` and :math:`\\\\mathbf{p}_{2}`, these\n    points can be passed as ``p1`` and ``p2``, instead of passing\n    ``discretisedfield.Region`` object. In this case\n    ``discretisedfield.Region`` is created internally. Either ``region`` or\n    ``p1`` and ``p2`` must be passed, not both. The region is discretised using\n    a finite difference cell, whose dimensions are defined with ``cell``.\n    Alternatively, the domain can be discretised by passing the number of\n    discretisation cells ``n`` in all three dimensions. Either ``cell`` or\n    ``n`` should be passed to discretise the region, not both. Periodic\n    boundary conditions can be specified by passing ``bc`` argument as a string\n    containing one or more characters from ``{\'x\', \'y\', \'z\'}`` set (e.g.\n    ``\'x\'``, ``\'yz\'``, ``\'xyz\'``). Neumann or Dirichlet boundary conditions are\n    defined by passing ``\'neumann\'`` or ``dirichlet`` string. Neumann and\n    Dirichlett boundary conditions are still experimental. If it is necessary\n    to define subregions in the mesh, a dictionary can be passed as\n    ``subregions``. More precisely, dictionary keys are strings (as valid\n    Python variable names), whereas values are ``discretisedfield.Region``\n    objects. Subregions are not checked internally, so it is users\n    responsibility to make sure subregions are well defined.\n\n    In order to properly define a mesh, mesh region must be an aggregate of\n    discretisation cells. Otherwise, ``ValueError`` is raised.\n\n    Parameters\n    ----------\n    region : discretisedfield.Region, optional\n\n        Cubic region to be discretised on a regular mesh. Either ``region`` or\n        ``p1`` and ``p2`` should be defined, not both. Defaults to ``None``.\n\n    p1 / p2 : (3,) array_like, optional\n\n        Points between which the mesh region spans :math:`\\\\mathbf{p} = (p_{x},\n        p_{y}, p_{z})`. Either ``region`` or ``p1`` and ``p2`` should be\n        defined, not both. Defaults to ``None``.\n\n    cell : (3,) array_like, optional\n\n        Discretisation cell size :math:`(d_{x}, d_{y}, d_{z})`. Either ``cell``\n        or ``n`` should be defined, not both. Defaults to ``None``.\n\n    n : (3,) array_like, optional\n\n        The number of discretisation cells :math:`(n_{x}, n_{y}, n_{z})`.\n        Either ``cell`` or ``n`` should be defined, not both. Defaults to\n        ``None``.\n\n    bc : str, optional\n\n        Periodic boundary conditions in x, y, or z directions is a string\n        consisting of one or more characters ``\'x\'``, ``\'y\'``, or ``\'z\'``,\n        denoting the direction(s) along which the mesh is periodic. In the case\n        of Neumann or Dirichlet boundary condition, string ``\'neumann\'`` or\n        ``\'dirichlet\'`` is passed. Defaults to an empty string.\n\n    subregions : dict, optional\n\n        A dictionary defining subregions in the mesh. The keys of the\n        dictionary are the region names (``str``) as valid Python variable\n        names, whereas the values are ``discretisedfield.Region`` objects.\n        Defaults to an empty dictionary.\n\n    Raises\n    ------\n    ValueError\n\n        If mesh domain is not an aggregate of discretisation cells.\n        Alternatively, if both ``region`` as well as ``p1`` and ``p2`` or both\n        ``cell`` and ``n`` are passed.\n\n    Examples\n    --------\n    1. Defining a nano-sized thin film mesh by passing ``region`` and ``cell``\n    parameters.\n\n    >>> import discretisedfield as df\n    ...\n    >>> p1 = (-50e-9, -25e-9, 0)\n    >>> p2 = (50e-9, 25e-9, 5e-9)\n    >>> cell = (1e-9, 1e-9, 0.1e-9)\n    >>> region = df.Region(p1=p1, p2=p2)\n    >>> mesh = df.Mesh(region=region, cell=cell)\n    >>> mesh\n    Mesh(...)\n\n    2. Defining a nano-sized thin film mesh by passing ``p1``, ``p2`` and ``n``\n    parameters.\n\n    >>> n = (100, 50, 5)\n    >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n    >>> mesh\n    Mesh(...)\n\n    3. Defining a mesh with periodic boundary conditions in :math:`x` and\n    :math:`y` directions.\n\n    >>> bc = \'xy\'\n    >>> region = df.Region(p1=p1, p2=p2)\n    >>> mesh = df.Mesh(region=region, n=n, bc=bc)\n    >>> mesh\n    Mesh(...)\n\n    4. Defining a mesh with two subregions.\n\n    >>> p1 = (0, 0, 0)\n    >>> p2 = (100, 100, 100)\n    >>> n = (10, 10, 10)\n    >>> subregions = {\'r1\': df.Region(p1=(0, 0, 0), p2=(50, 100, 100)),\n    ...               \'r2\': df.Region(p1=(50, 0, 0), p2=(100, 100, 100))}\n    >>> mesh = df.Mesh(p1=p1, p2=p2, n=n, subregions=subregions)\n    >>> mesh\n    Mesh(...)\n\n    5. An attempt to define a mesh, whose region is not an aggregate of\n    discretisation cells in the :math:`z` direction.\n\n    >>> p1 = (-25, 3, 0)\n    >>> p2 = (25, 6, 1)\n    >>> cell = (5, 3, 0.4)\n    >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n    Traceback (most recent call last):\n        ...\n    ValueError: ...\n\n    """"""\n    def __init__(self, region=None, p1=None, p2=None, n=None, cell=None,\n                 bc=\'\', subregions=dict()):\n        if region is not None and p1 is None and p2 is None:\n            self.region = region\n        elif region is None and p1 is not None and p2 is not None:\n            self.region = df.Region(p1=p1, p2=p2)\n        else:\n            msg = \'Either region or p1 and p2 can be passed, not both.\'\n            raise ValueError(msg)\n\n        if cell is not None and n is None:\n            self.cell = tuple(cell)\n            n = np.divide(self.region.edges, self.cell).round().astype(int)\n            self.n = dfu.array2tuple(n)\n        elif n is not None and cell is None:\n            self.n = tuple(n)\n            cell = np.divide(self.region.edges, self.n).astype(float)\n            self.cell = dfu.array2tuple(cell)\n        else:\n            msg = \'Either n or cell can be passed, not both.\'\n            raise ValueError(msg)\n\n        # Check if the mesh region is an aggregate of the discretisation cell.\n        tol = 1e-12  # picometre tolerance\n        rem = np.remainder(self.region.edges, self.cell)\n        if np.logical_and(np.greater(rem, tol),\n                          np.less(rem, np.subtract(self.cell, tol))).any():\n            msg = \'Mesh region is not an aggregate of the discretisation cell.\'\n            raise ValueError(msg)\n\n        self.bc = bc.lower()\n        self.subregions = subregions\n\n    def __len__(self):\n        """"""Number of discretisation cells in the mesh.\n\n        It is computed by multiplying all elements of ``n``:\n\n        .. math::\n\n            n_\\\\text{total} = n_{x} n_{y} n_{z}.\n\n        Returns\n        -------\n        int\n\n            Total number of discretisation cells.\n\n        Examples\n        --------\n        1. Getting the number of discretisation cells in a mesh.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 5, 0)\n        >>> p2 = (5, 15, 2)\n        >>> cell = (1, 0.1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        >>> mesh.n\n        (5, 100, 2)\n        >>> len(mesh)\n        1000\n\n        """"""\n        return int(np.prod(self.n))\n\n    @property\n    def indices(self):\n        """"""Generator yielding indices of all mesh cells.\n\n        Yields\n        ------\n        tuple (3,)\n\n            Mesh cell indices :math:`(i_{x}, i_{y}, i_{z})`.\n\n        Examples\n        --------\n        1. Getting indices of all mesh cells.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (3, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> list(mesh.indices)\n        [(0, 0, 0), (1, 0, 0), (2, 0, 0), (0, 1, 0), (1, 1, 0), (2, 1, 0)]\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.__iter__`\n\n        """"""\n        for index in itertools.product(*map(range, reversed(self.n))):\n            yield tuple(reversed(index))\n\n    def __iter__(self):\n        """"""Generator yielding coordinates of discretisation cells.\n\n        The discretisation cell\'s coordinate corresponds to its centre point.\n\n        Yields\n        ------\n        tuple (3,)\n\n            Mesh cell\'s centre point :math:`\\\\mathbf{p} = (p_{x}, p_{y},\n            p_{z})`.\n\n        Examples\n        --------\n        1. Getting coordinates of all mesh cells.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        >>> list(mesh)\n        [(0.5, 0.5, 0.5), (1.5, 0.5, 0.5), (0.5, 1.5, 0.5), (1.5, 1.5, 0.5)]\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.indices`\n\n        """"""\n        for index in self.indices:\n            yield self.index2point(index)\n\n    def __eq__(self, other):\n        """"""Relational operator ``==``.\n\n        Two meshes are considered to be equal if:\n\n          1. Regions of both meshes are equal.\n\n          2. They have the same number of discretisation cells in all three\n          directions :math:`n^{1}_{i} = n^{2}_{i}`, for :math:`i = x, y, z`.\n\n        Boundary conditions ``bc`` and ``subregions`` are not considered to be\n        necessary conditions for determining equality.\n\n        Parameters\n        ----------\n        other : discretisedfield.Mesh\n\n            Second operand.\n\n        Returns\n        -------\n        bool\n\n            ``True`` if two meshes are equal and ``False`` otherwise.\n\n        Examples\n        --------\n        1. Check if meshes are equal.\n\n        >>> import discretisedfield as df\n        ...\n        >>> mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), cell=(1, 1, 1))\n        >>> mesh2 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), cell=(1, 1, 1))\n        >>> mesh3 = df.Mesh(p1=(1, 1, 1), p2=(5, 5, 5), cell=(2, 2, 2))\n        >>> mesh1 == mesh2\n        True\n        >>> mesh1 != mesh2\n        False\n        >>> mesh1 == mesh3\n        False\n        >>> mesh1 != mesh3\n        True\n\n        """"""\n        if not isinstance(other, self.__class__):\n            return False\n        if self.region == other.region and self.n == other.n:\n            return True\n        else:\n            return False\n\n    def __repr__(self):\n        """"""Representation string.\n\n        Returns\n        -------\n        str\n\n           Representation string.\n\n        Example\n        -------\n        1. Getting representation string.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> bc = \'x\'\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell, bc=bc)\n        >>> repr(mesh)\n        ""Mesh(region=Region(p1=(0, 0, 0), p2=(2, 2, 1)), n=(2, 2, 1), ...)""\n\n        """"""\n        return (f\'Mesh(region={repr(self.region)}, n={self.n}, \'\n                f\'bc=\\\'{self.bc}\\\', subregions={self.subregions})\')\n\n    def index2point(self, index):\n        """"""Convert cell\'s index to its coordinate.\n\n        Parameters\n        ----------\n        index : (3,) array_like\n\n            The cell\'s index :math:`(i_{x}, i_{y}, i_{z})`.\n\n        Returns\n        -------\n        (3,) tuple\n\n            The cell\'s coordinate :math:`\\\\mathbf{p} = (p_{x}, p_{y}, p_{z})`.\n\n        Raises\n        ------\n        ValueError\n\n            If ``index`` is out of range.\n\n        Examples\n        --------\n        1. Converting cell\'s index to its centre point coordinate.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        >>> mesh.index2point((0, 0, 0))\n        (0.5, 0.5, 0.5)\n        >>> mesh.index2point((0, 1, 0))\n        (0.5, 1.5, 0.5)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.point2index`\n\n        """"""\n        if np.logical_or(np.less(index, 0),\n                         np.greater_equal(index, self.n)).any():\n            msg = f\'Index {index} out of range.\'\n            raise ValueError(msg)\n\n        point = np.add(self.region.pmin,\n                       np.multiply(np.add(index, 0.5), self.cell))\n        return dfu.array2tuple(point)\n\n    def point2index(self, point):\n        """"""Convert point to the index of a cell which contains that point.\n\n        Parameters\n        ----------\n        point : (3,) array_like\n\n            Point :math:`\\\\mathbf{p} = (p_{x}, p_{y}, p_{z})`.\n\n        Returns\n        -------\n        (3,) tuple\n\n            The cell\'s index :math:`(i_{x}, i_{y}, i_{z})`.\n\n        Raises\n        ------\n        ValueError\n\n            If ``point`` is outside the mesh.\n\n        Examples\n        --------\n        1. Converting point to the cell\'s index.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        >>> mesh.point2index((0.2, 1.7, 0.3))\n        (0, 1, 0)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.index2point`\n\n        """"""\n        if point not in self.region:\n            msg = f\'Point {point} is outside the mesh region.\'\n            raise ValueError(msg)\n\n        index = np.subtract(np.divide(np.subtract(point, self.region.pmin),\n                                      self.cell), 0.5).round().astype(int)\n        # If index is rounded to the out-of-range values.\n        index = np.clip(index, 0, np.subtract(self.n, 1))\n\n        return dfu.array2tuple(index)\n\n    def neighbours(self, index):\n        """"""Indices of discretisation cell neighbours.\n\n        Parameters\n        ----------\n        index : (3,) array_like\n\n            The cell\'s index :math:`(i_{x}, i_{y}, i_{z})`.\n\n        Returns\n        -------\n        list\n\n            The list of cell\'s neighbour indices.\n\n        Raises\n        ------\n        ValueError\n\n            If ``index`` is outside the mesh.\n\n        Examples\n        --------\n        1. Getting cell neighbours\' indices.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell, bc=\'xz\')\n        >>> mesh.neighbours((1, 0, 0))\n        [(0, 0, 0), (1, 1, 0)]\n        >>> mesh.neighbours((0, 1, 0))\n        [(1, 1, 0), (0, 0, 0)]\n\n        """"""\n        if np.logical_or(np.less(index, 0),\n                         np.greater_equal(index, self.n)).any():\n            msg = f\'Index {index} out of range.\'\n            raise ValueError(msg)\n\n        nghbrs = []\n        for axis in range(3):\n            for i in [index[axis]-1, index[axis]+1]:\n                nghbr_index = list(index)  # make it mutable\n                if 0 <= i <= self.n[axis]-1:\n                    # not outside the mesh\n                    nghbr_index[axis] = i\n                elif dfu.raxesdict[axis] in self.bc:\n                    if i == -1 and self.n[axis] != 1:\n                        nghbr_index[axis] = self.n[0]-1\n                    elif i == self.n[axis] and self.n[axis] != 1:\n                        nghbr_index[axis] = 0\n                if tuple(nghbr_index) != index:\n                    nghbrs.append(tuple(nghbr_index))\n\n        # Remove duplicates and preserve order.\n        return list(collections.OrderedDict.fromkeys(nghbrs))\n\n    def line(self, p1, p2, n):\n        """"""Line generator.\n\n        Given two points ``p1`` and ``p2`` line is defined and ``n`` points on\n        that line are generated and yielded in ``n`` iterations:\n\n        .. math::\n\n           \\\\mathbf{r}_{i} = i\\\\frac{\\\\mathbf{p}_{2} - \\\\mathbf{p}_{1}}{n-1},\n           \\\\text{for}\\\\, i = 0, ..., n-1\n\n        Parameters\n        ----------\n        p1 / p2 : (3,) array_like\n\n            Points between which the line is defined :math:`\\\\mathbf{p} =\n            (p_{x}, p_{y}, p_{z})`.\n\n        n : int\n\n            Number of points on the line.\n\n        Yields\n        ------\n        tuple (3,)\n\n            :math:`\\\\mathbf{r}_{i}`\n\n        Raises\n        ------\n        ValueError\n\n            If ``p1`` or ``p2`` is outside the mesh region.\n\n        Examples\n        --------\n        1. Creating line generator.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 2)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> line = mesh.line(p1=(0, 0, 0), p2=(2, 0, 0), n=2)\n        >>> list(line)\n        [(0.0, 0.0, 0.0), (2.0, 0.0, 0.0)]\n\n        .. seealso:: :py:func:`~discretisedfield.Region.plane`\n\n        """"""\n        if p1 not in self.region or p2 not in self.region:\n            msg = f\'Point {p1} or point {p2} is outside the mesh region.\'\n            raise ValueError(msg)\n\n        dl = np.subtract(p2, p1) / (n-1)\n        for i in range(n):\n            yield dfu.array2tuple(np.add(p1, i*dl))\n\n    def plane(self, *args, n=None, **kwargs):\n        """"""Extracts plane mesh.\n\n        If one of the axes (``\'x\'``, ``\'y\'``, or ``\'z\'``) is passed as a\n        string, a plane mesh perpendicular to that axis is extracted,\n        intersecting the mesh region at its centre. Alternatively, if a keyword\n        argument is passed (e.g. ``x=1e-9``), a plane perpendicular to the\n        x-axis (parallel to yz-plane) and intersecting it at ``x=1e-9`` is\n        extracted. The number of points in two dimensions on the plane can be\n        defined using ``n`` tuple (e.g. ``n=(10, 15)``).\n\n        The resulting mesh has an attribute ``info``, which is a dictionary\n        containing basic information about the plane mesh.\n\n        Parameters\n        ----------\n        n : (2,) tuple\n\n            The number of points on the plane in two dimensions.\n\n        Returns\n        ------\n        discretisedfield.Mesh\n\n            An extracted mesh.\n\n        Examples\n        --------\n        1. Extracting the plane mesh at a specific point (``y=1``).\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 5, 5)\n        >>> cell = (1, 1, 1)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> plane_mesh = mesh.plane(y=1)\n\n        2. Extracting the xy-plane mesh at the mesh region centre.\n\n        >>> plane_mesh = mesh.plane(\'z\')\n\n        3. Specifying the number of points on the plane.\n\n        >>> plane_mesh = mesh.plane(\'z\', n=(3, 3))\n\n        .. seealso:: :py:func:`~discretisedfield.Region.line`\n\n        """"""\n        if args and not kwargs:\n            if len(args) != 1:\n                msg = f\'Multiple args ({args}) passed.\'\n                raise ValueError(msg)\n\n            # Only planeaxis is provided via args and the point is defined as\n            # the centre of the sample.\n            planeaxis = dfu.axesdict[args[0]]\n            point = self.region.centre[planeaxis]\n        elif kwargs and not args:\n            if len(kwargs) != 1:\n                msg = f\'Multiple kwargs ({kwargs}) passed.\'\n                raise ValueError(msg)\n\n            planeaxis, point = list(kwargs.items())[0]\n            planeaxis = dfu.axesdict[planeaxis]\n\n            # Check if point is outside the mesh region.\n            test_point = list(self.region.centre)  # make it mutable\n            test_point[planeaxis] = point\n            if test_point not in self.region:\n                msg = f\'Point {test_point} is outside the mesh region.\'\n                raise ValueError(msg)\n        else:\n            msg = \'Either one arg or one kwarg can be passed, not both.\'\n            raise ValueError(msg)\n\n        # Get indices of in-plane axes.\n        axis1, axis2 = tuple(filter(lambda val: val != planeaxis,\n                                    dfu.axesdict.values()))\n\n        if n is None:\n            n = (self.n[axis1], self.n[axis2])\n\n        # Build plane-mesh.\n        p1pm, p2pm, npm = np.zeros(3), np.zeros(3), np.zeros(3, dtype=int)\n        ilist = [axis1, axis2, planeaxis]\n        p1pm[ilist] = (self.region.pmin[axis1],\n                       self.region.pmin[axis2],\n                       point - self.cell[planeaxis]/2)\n        p2pm[ilist] = (self.region.pmax[axis1],\n                       self.region.pmax[axis2],\n                       point + self.cell[planeaxis]/2)\n        npm[ilist] = (*n, 1)\n\n        plane_mesh = self.__class__(p1=p1pm, p2=p2pm, n=dfu.array2tuple(npm))\n\n        # Add info dictionary, so that the mesh can be interpreted easier.\n        info = dict()\n        info[\'planeaxis\'] = planeaxis\n        info[\'point\'] = point\n        info[\'axis1\'], info[\'axis2\'] = axis1, axis2\n        plane_mesh.info = info\n\n        return plane_mesh\n\n    def __getitem__(self, key):\n        """"""Extracts the mesh of a subregion.\n\n        If subregions were defined by passing ``subregions`` dictionary when\n        the mesh was created, this method returns a mesh defined on a subregion\n        ``subregions[key]`` with the same discretisation cell as the parent\n        mesh.\n\n        Parameters\n        ----------\n        key : str\n\n            The key (name) of a subregion in ``subregions`` dictionary.\n\n        Returns\n        -------\n        disretisedfield.Mesh\n\n            Mesh of a subregion.\n\n        Example\n        -------\n        1. Extract subregion mesh.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> cell = (10, 10, 10)\n        >>> subregions = {\'r1\': df.Region(p1=(0, 0, 0), p2=(50, 100, 100)),\n        ...               \'r2\': df.Region(p1=(50, 0, 0), p2=(100, 100, 100))}\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n        ...\n        >>> len(mesh)  # number of discretisation cells\n        1000\n        >>> mesh.region.pmin\n        (0, 0, 0)\n        >>> mesh.region.pmax\n        (100, 100, 100)\n        >>> submesh = mesh[\'r1\']\n        >>> len(submesh)\n        500\n        >>> submesh.region.pmin\n        (0, 0, 0)\n        >>> submesh.region.pmax\n        (50, 100, 100)\n\n        """"""\n        return self.__class__(region=self.subregions[key], cell=self.cell)\n\n    def pad(self, pad_width):\n        """"""Mesh padding.\n\n        This method extends the mesh by adding (padding) discretisation cells\n        in chosen direction. The way in which the mesh is going to be padded is\n        defined by passing ``pad_width`` dictionary. The keys of the dictionary\n        are the directions (axes), e.g. ``\'x\'``, ``\'y\'``, or ``\'z\'``, whereas\n        the values are the tuples of length 2. The first integer in the tuple\n        is the number of cells added in the negative direction, and the second\n        integer is the number of cells added in the positive direction.\n\n        Parameters\n        ----------\n        pad_width : dict\n\n            The keys of the dictionary are the directions (axes), e.g. ``\'x\'``,\n            ``\'y\'``, or ``\'z\'``, whereas the values are the tuples of length 2.\n            The first integer in the tuple is the number of cells added in the\n            negative direction, and the second integer is the number of cells\n            added in the positive direction.\n\n        Returns\n        -------\n        discretisedfield.Mesh\n\n            Extended mesh.\n\n        Examples\n        --------\n        1. Padding a mesh in the x and y directions by 1 cell.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> cell = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        ...\n        >>> mesh.region.edges\n        (100, 100, 100)\n        >>> padded_mesh = mesh.pad({\'x\': (1, 1), \'y\': (1, 1), \'z\': (0, 1)})\n        >>> padded_mesh.region.edges\n        (120, 120, 110)\n        >>> padded_mesh.n\n        (12, 12, 11)\n\n        """"""\n        # Convert to np.ndarray to allow operations on them.\n        pmin = np.array(self.region.pmin)\n        pmax = np.array(self.region.pmax)\n        for direction in pad_width.keys():\n            axis = dfu.axesdict[direction]\n            pmin[axis] -= pad_width[direction][0] * self.cell[axis]\n            pmax[axis] += pad_width[direction][1] * self.cell[axis]\n\n        return self.__class__(p1=pmin, p2=pmax, cell=self.cell, bc=self.bc)\n\n    def mpl(self, ax=None, figsize=None, color=dfu.cp_hex[:2], multiplier=None,\n            filename=None, **kwargs):\n        """"""``matplotlib`` plot.\n\n        If ``ax`` is not passed, ``matplotlib.axes.Axes`` object is created\n        automatically and the size of a figure can be specified using\n        ``figsize``. The color of lines depicting the region and the\n        discretisation cell can be specified using ``color`` length-2 tuple,\n        where the first element is the colour of the region and the second\n        element is the colour of the discretisation cell. The plot is saved in\n        PDF-format if ``filename`` is passed.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``matplotlib.pyplot.plot``, so any keyword\n        arguments accepted by it can be passed (for instance, ``linewidth``,\n        ``linestyle``, etc.).\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the plot is added. Defaults to ``None`` - axes are\n            created internally.\n\n        figsize : (2,) tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        color : (2,) array_like\n\n            A valid ``matplotlib`` color for lines depicting the region.\n            Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising the mesh using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-50e-9, -50e-9, 0)\n        >>> p2 = (50e-9, 50e-9, 10e-9)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> mesh = df.Mesh(region=region, n=(50, 50, 5))\n        ...\n        >>> mesh.mpl()\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.k3d`\n\n        """"""\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111, projection=\'3d\')\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.region.edges)\n\n        cell_region = df.Region(p1=self.region.pmin,\n                                p2=np.add(self.region.pmin, self.cell))\n        self.region.mpl(ax=ax, color=color[0], multiplier=multiplier, **kwargs)\n        cell_region.mpl(ax=ax, color=color[1], multiplier=multiplier, **kwargs)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def mpl_subregions(self, ax=None, figsize=None, color=dfu.cp_hex,\n                       multiplier=None, filename=None, **kwargs):\n        """"""``matplotlib`` subregions plot.\n\n        If ``ax`` is not passed, ``matplotlib.axes.Axes`` object is created\n        automatically and the size of a figure can be specified using\n        ``figsize``. The color of lines depicting subregions and can be\n        specified using ``color`` list. The plot is saved in PDF-format if\n        ``filename`` is passed.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``matplotlib.pyplot.plot``, so any keyword\n        arguments accepted by it can be passed (for instance, ``linewidth``,\n        ``linestyle``, etc.).\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the plot is added. Defaults to ``None`` - axes are\n            created internally.\n\n        figsize : (2,) tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        color : array_like\n\n            Subregion colours. Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising subregions using ``matplotlib``.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> subregions = {\'r1\': df.Region(p1=(0, 0, 0), p2=(50, 100, 100)),\n        ...               \'r2\': df.Region(p1=(50, 0, 0), p2=(100, 100, 100))}\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n, subregions=subregions)\n        ...\n        >>> mesh.mpl_subregions()\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.k3d_subregions`\n\n        """"""\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111, projection=\'3d\')\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.region.edges)\n\n        for i, subregion in enumerate(self.subregions.values()):\n            subregion.mpl(ax=ax, multiplier=multiplier,\n                          color=color[i % len(color)], **kwargs)\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def k3d(self, plot=None, color=dfu.cp_int[:2], multiplier=None,\n            **kwargs):\n        """"""``k3d`` plot.\n\n        If ``plot`` is not passed, ``k3d.Plot`` object is created\n        automatically. The color of the region and the discretisation cell can\n        be specified using ``color`` length-2 tuple, where the first element is\n        the colour of the region and the second element is the colour of the\n        discretisation cell.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``k3d.voxels``, so any keyword arguments\n        accepted by it can be passed (e.g. ``wireframe``).\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which the plot is added. Defaults to ``None`` - plot is\n            created internally.\n\n        color : (2,) array_like\n\n            Colour of the region and the discretisation cell. Defaults to the\n            default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising the mesh using ``k3d``.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> mesh.k3d()\n        Plot(...)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.mpl`\n\n        """"""\n        if plot is None:\n            plot = k3d.plot()\n            plot.display()\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.region.edges)\n\n        unit = f\'({uu.rsi_prefixes[multiplier]}m)\'\n\n        plot_array = np.ones(tuple(reversed(self.n))).astype(np.uint8)\n        plot_array[0, 0, -1] = 2  # mark the discretisation cell\n\n        bounds = [i for sublist in\n                  zip(np.divide(self.region.pmin, multiplier),\n                      np.divide(self.region.pmax, multiplier))\n                  for i in sublist]\n\n        plot += k3d.voxels(plot_array, color_map=color, bounds=bounds,\n                           outlines=False, **kwargs)\n\n        plot.axes = [f\'{i}\\,\\\\text{{{unit}}}\' for i in dfu.axesdict.keys()]\n\n    def k3d_subregions(self, plot=None, color=dfu.cp_int, multiplier=None,\n                       **kwargs):\n        """"""``k3d`` subregions plot.\n\n        If ``plot`` is not passed, ``k3d.Plot`` object is created\n        automatically. The color of the subregions can be specified using\n        ``color``.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``k3d.voxels``, so any keyword arguments\n        accepted by it can be passed (e.g. ``wireframe``).\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which the plot is added. Defaults to ``None`` - plot is\n            created internally.\n\n        color : array_like\n\n            Colour of the subregions. Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising subregions using ``k3d``.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (100, 100, 100)\n        >>> n = (10, 10, 10)\n        >>> subregions = {\'r1\': df.Region(p1=(0, 0, 0), p2=(50, 100, 100)),\n        ...               \'r2\': df.Region(p1=(50, 0, 0), p2=(100, 100, 100))}\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n, subregions=subregions)\n        ...\n        >>> mesh.k3d_subregions()\n        Plot(...)\n\n        .. seealso:: :py:func:`~discretisedfield.Mesh.mpl_subregions`\n\n        """"""\n        if plot is None:\n            plot = k3d.plot()\n            plot.display()\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.region.edges)\n\n        unit = f\'({uu.rsi_prefixes[multiplier]}m)\'\n\n        plot_array = np.zeros(self.n)\n        for index in self.indices:\n            for i, subregion in enumerate(self.subregions.values()):\n                if self.index2point(index) in subregion:\n                    # +1 to avoid 0 value - invisible voxel\n                    plot_array[index] = (i % len(color)) + 1\n                    break\n        # swap axes for k3d.voxels and astypr to avoid k3d warning\n        plot_array = np.swapaxes(plot_array, 0, 2).astype(np.uint8)\n\n        bounds = [i for sublist in\n                  zip(np.divide(self.region.pmin, multiplier),\n                      np.divide(self.region.pmax, multiplier))\n                  for i in sublist]\n\n        plot += k3d.voxels(plot_array, color_map=color, bounds=bounds,\n                           outlines=False, **kwargs)\n\n        plot.axes = [f\'{i}\\,\\\\text{{{unit}}}\' for i in dfu.axesdict.keys()]\n\n    def slider(self, axis, multiplier=None, description=None, **kwargs):\n        """"""Axis slider.\n\n        For ``axis``, ``\'x\'``, ``\'y\'``, or ``\'z\'`` is passed. Based on that\n        value, ``ipywidgets.SelectionSlider`` is returned. Axis multiplier can\n        be changed via ``multiplier``.\n\n        This method is based on ``ipywidgets.SelectionSlider``, so any keyword\n        argument accepted by it can be passed.\n\n        Parameters\n        ----------\n        axis : str\n\n            Axis for which the slider is returned (``\'x\'``, ``\'y\'``, or\n            ``\'z\'``).\n\n        multiplier : numbers.Real, optional\n\n            Axis multiplier. Defaults to ``None``.\n\n        Returns\n        -------\n        ipywidgets.SelectionSlider\n\n            Axis slider.\n\n        Example\n        -------\n        1. Get the slider for the x-coordinate.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 10e-9, 10e-9)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> mesh.slider(\'x\')\n        SelectionSlider(...)\n\n        """"""\n        if isinstance(axis, str):\n            axis = dfu.axesdict[axis]\n\n        if multiplier is None:\n            multiplier = uu.si_multiplier(self.region.edges[axis])\n\n        slider_min = self.index2point((0, 0, 0))[axis]\n        slider_max = self.index2point(np.subtract(self.n, 1))[axis]\n        slider_step = self.cell[axis]\n        if description is None:\n            description = (f\'{dfu.raxesdict[axis]} \'\n                           f\'({uu.rsi_prefixes[multiplier]}m)\')\n\n        values = np.arange(slider_min, slider_max+1e-20, slider_step)\n        labels = np.around(values/multiplier, decimals=3)\n        options = list(zip(labels, values))\n\n        # Select middle element for slider value\n        slider_value = values[int(self.n[axis]/2)]\n\n        return ipywidgets.SelectionSlider(options=options,\n                                          value=slider_value,\n                                          description=description,\n                                          **kwargs)\n\n    def axis_selector(self, widget=\'dropdown\', description=\'axis\'):\n        """"""Axis selector.\n\n        For ``widget=\'dropdown\'``, ``ipywidgets.Dropdown`` is returned, whereas\n        for ``widget=\'radiobuttons\'``, ``ipywidgets.RadioButtons`` is returned.\n        Default widget description can be changed using ``description``.\n\n        Parameters\n        ----------\n        widget : str\n\n            Type of widget to be returned. Defaults to ``\'dropdown\'``.\n\n        description : str\n\n            Widget description to be showed. Defaults to ``\'axis\'``.\n\n        Returns\n        -------\n        ipywidgets.Dropdown, ipywidgets.RadioButtons\n\n            Axis selection widget.\n\n        Example\n        -------\n        1. Get the ``RadioButtons`` slider.\n\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (10e-9, 10e-9, 10e-9)\n        >>> n = (10, 10, 10)\n        >>> mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        ...\n        >>> mesh.axis_selector(widget=\'radiobuttons\')\n        RadioButtons(...)\n\n        """"""\n        if widget.lower() == \'dropdown\':\n            widget_cls = ipywidgets.Dropdown\n        elif widget == \'radiobuttons\':\n            widget_cls = ipywidgets.RadioButtons\n        else:\n            msg = f\'Widget {widget} is not supported.\'\n            raise ValueError(msg)\n\n        return widget_cls(options=list(dfu.axesdict.keys()),\n                          value=\'z\',\n                          description=description,\n                          disabled=False)\n'"
discretisedfield/ovf2vtk.py,0,"b""import argparse\nimport discretisedfield as df\n\n\ndef ovf2vtk():\n    parser = argparse.ArgumentParser(\n        prog='ovf2vtk',\n        description='ovf2vtk - OVF to VTK file format conversion.'\n    )\n    parser.add_argument('--input', '-i', type=argparse.FileType('r'),\n                        nargs='+', required=True, help='Input OVF file(s).')\n    parser.add_argument('--output', '-o', type=argparse.FileType('w'),\n                        nargs='+', required=False, help='Output VTK file(s).')\n    args = parser.parse_args()\n\n    input_files = [f.name for f in args.input]\n\n    if args.output:\n        # Output filenames provided.\n        if len(args.input) == len(args.output):\n            output_files = [f.name for f in args.output]\n        else:\n            msg = (f'The number of input files ({len(args.input)}) does not '\n                   f'match the number of output files ({len(args.output)}).')\n            raise ValueError(msg)\n    else:\n        # Output filenames are not provided and they are generated\n        # automatically.\n        output_files = [f'{filename[:-4]}.vtk' for filename in input_files]\n\n    for input_file, output_file in zip(input_files, output_files):\n        field = df.Field.fromfile(input_file)\n        field.write(output_file)\n\n\nif __name__ == '__main__':\n    ovf2vtk()\n"""
discretisedfield/region.py,14,"b'import k3d\nimport random\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport ubermagutil.units as uu\nimport ubermagutil.typesystem as ts\nimport discretisedfield.util as dfu\n\n\n@ts.typesystem(p1=ts.Vector(size=3, const=True),\n               p2=ts.Vector(size=3, const=True))\nclass Region:\n    """"""A cuboid region.\n\n    A cuboid region spans between two corner points :math:`\\\\mathbf{p}_{1}` and\n    :math:`\\\\mathbf{p}_{2}`.\n\n    Parameters\n    ----------\n    p1 / p2 : (3,) array_like\n\n        Points between which the cuboid region spans :math:`\\\\mathbf{p}_{i} =\n        (p_{x}, p_{y}, p_{z})`.\n\n    Raises\n    ------\n    ValueError\n\n        If the length of one or more region edges is zero.\n\n    Examples\n    --------\n    1. Defining a nano-sized region.\n\n    >>> import discretisedfield as df\n    ...\n    >>> p1 = (-50e-9, -25e-9, 0)\n    >>> p2 = (50e-9, 25e-9, 5e-9)\n    >>> region = df.Region(p1=p1, p2=p2)\n    >>> region\n    Region(...)\n\n    2. An attempt to define a region, where one of the edge lengths is zero.\n\n    >>> # The edge length in the z-direction is zero.\n    >>> p1 = (-25, 3, 1)\n    >>> p2 = (25, 6, 1)\n    >>> region = df.Region(p1=p1, p2=p2)\n    Traceback (most recent call last):\n        ...\n    ValueError: ...\n\n    """"""\n    def __init__(self, p1, p2):\n        self.p1 = tuple(p1)\n        self.p2 = tuple(p2)\n\n        if np.equal(self.edges, 0).any():\n            msg = f\'One of the region edges ({self.edges}) is zero.\'\n            raise ValueError(msg)\n\n    @property\n    def pmin(self):\n        """"""Point with minimum coordinates in the region.\n\n        The :math:`i`-th component of :math:`\\\\mathbf{p}_\\\\text{min}` is\n        computed from points :math:`p_{1}` and :math:`p_{2}` between which the\n        cuboid region spans: :math:`p_\\\\text{min}^{i} = \\\\text{min}(p_{1}^{i},\n        p_{2}^{i})`.\n\n        Returns\n        -------\n        tuple (3,)\n\n            Point with minimum coordinates :math:`(p_{x}^\\\\text{min},\n            p_{y}^\\\\text{min}, p_{z}^\\\\text{min})`.\n\n        Examples\n        --------\n        1. Getting the minimum coordinate point.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-1.1, 2.9, 0)\n        >>> p2 = (5, 0, -0.1)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.pmin\n        (-1.1, 0.0, -0.1)\n\n        .. seealso:: :py:func:`~discretisedfield.Region.pmax`\n\n        """"""\n        return dfu.array2tuple(np.minimum(self.p1, self.p2))\n\n    @property\n    def pmax(self):\n        """"""Point with maximum coordinates in the region.\n\n        The :math:`i`-th component of :math:`\\\\mathbf{p}_\\\\text{max}` is\n        computed from points :math:`p_{1}` and :math:`p_{2}` between which the\n        cuboid region spans: :math:`p_\\\\text{max}^{i} = \\\\text{max}(p_{1}^{i},\n        p_{2}^{i})`.\n\n        Returns\n        -------\n        tuple (3,)\n\n            Point with maximum coordinates :math:`(p_{x}^\\\\text{max},\n            p_{y}^\\\\text{max}, p_{z}^\\\\text{max})`.\n\n        Examples\n        --------\n        1. Getting the maximum coordinate point.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-1.1, 2.9, 0)\n        >>> p2 = (5, 0, -0.1)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.pmax\n        (5.0, 2.9, 0.0)\n\n        .. seealso:: :py:func:`~discretisedfield.Region.pmin`\n\n        """"""\n        return dfu.array2tuple(np.maximum(self.p1, self.p2))\n\n    @property\n    def edges(self):\n        """"""Edge lengths of the region.\n\n        Edge length is computed from the points between which the region spans\n        :math:`\\\\mathbf{p}_{1}` and :math:`\\\\mathbf{p}_{2}`:\n\n        .. math::\n\n            \\\\mathbf{l} = (|p_{2}^{x} - p_{1}^{x}|, |p_{2}^{y} - p_{1}^{y}|,\n            |p_{2}^{z} - p_{1}^{z}|).\n\n        Returns\n        -------\n        tuple (3,)\n\n             Edge lengths :math:`(l_{x}, l_{y}, l_{z})`.\n\n        Examples\n        --------\n        1. Getting edge lengths of the region.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, -5)\n        >>> p2 = (5, 15, 15)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.edges\n        (5, 15, 20)\n\n        """"""\n        return dfu.array2tuple(np.abs(np.subtract(self.p1, self.p2)))\n\n    @property\n    def centre(self):\n        """"""Centre point.\n\n        It is computed as the middle point between minimum and maximum point\n        coordinates:\n\n        .. math::\n\n            \\\\mathbf{p}_\\\\text{centre} = \\\\frac{1}{2} (\\\\mathbf{p}_\\\\text{min}\n            + \\\\mathbf{p}_\\\\text{max}).\n\n        Returns\n        -------\n        tuple (3,)\n\n            Centre point :math:`(p_{c}^{x}, p_{c}^{y}, p_{c}^{z})`.\n\n        Examples\n        --------\n        1. Getting the centre point.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 15, 20)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.centre\n        (2.5, 7.5, 10.0)\n\n        """"""\n        return dfu.array2tuple(np.multiply(np.add(self.pmin, self.pmax), 0.5))\n\n    @property\n    def volume(self):\n        """"""Region volume.\n\n        It is computed by multiplying edge lengths of the region:\n\n        .. math::\n\n            V = l_{x} l_{y} l_{z}.\n\n        Returns\n        -------\n        float\n\n            Volume of the region.\n\n        Examples\n        --------\n        1. Computing the volume of the region.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (5, 10, 2)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.volume\n        100.0\n\n        """"""\n        return float(np.prod(self.edges))\n\n    def random_point(self):\n        """"""Generate a random point in the region.\n\n        The use of this function is mostly for writing tests for packages based\n        on ``discretisedfield``. This method is not a property. Therefore, it\n        is called as ``discretisedfield.Region.random_point()``.\n\n        Returns\n        -------\n        tuple (3,)\n\n            Random point coordinates :math:`\\\\mathbf{p}_\\\\text{r} =\n            (p_{x}^\\\\text{r}, p_{y}^\\\\text{r}, p_{z}^\\\\text{r})`.\n\n        Examples\n        --------\n        1. Generating a random point.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (200e-9, 200e-9, 1e-9)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.random_point()\n        (...)\n\n        .. note::\n\n           In the example, ellipsis is used instead of an exact tuple because\n           the result differs each time\n           ``discretisedfield.Region.random_point`` method is called.\n\n        """"""\n        res = np.add(self.pmin, np.multiply(np.random.random(3), self.edges))\n        return dfu.array2tuple(res)\n\n    def __repr__(self):\n        """"""Representation string.\n\n        Returns\n        -------\n        str\n\n           Representation string.\n\n        Example\n        -------\n        1. Getting representation string.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> repr(region)\n        \'Region(p1=(0, 0, 0), p2=(2, 2, 1))\'\n\n        """"""\n        return f\'Region(p1={self.pmin}, p2={self.pmax})\'\n\n    def __eq__(self, other):\n        """"""Relational operator ``==``.\n\n        Two regions are considered to be equal if they have the same minimum\n        and maximum coordinate points: :math:`\\\\mathbf{p}^\\\\text{max}_{1} =\n        \\\\mathbf{p}^\\\\text{max}_{2}` and :math:`\\\\mathbf{p}^\\\\text{min}_{1} =\n        \\\\mathbf{p}^\\\\text{min}_{2}`.\n\n        Parameters\n        ----------\n        other : discretisedfield.Region\n\n            Second operand.\n\n        Returns\n        -------\n        bool\n\n            ``True`` if two regions are equal and ``False`` otherwise.\n\n        Examples\n        --------\n        1. Check if regions are equal.\n\n        >>> import discretisedfield as df\n        ...\n        >>> region1 = df.Region(p1=(0, 0, 0), p2=(5, 5, 5))\n        >>> region2 = df.Region(p1=(0.0, 0, 0), p2=(5.0, 5, 5))\n        >>> region3 = df.Region(p1=(1, 1, 1), p2=(5, 5, 5))\n        >>> region1 == region2\n        True\n        >>> region1 != region2\n        False\n        >>> region1 == region3\n        False\n        >>> region1 != region3\n        True\n\n        """"""\n        if not isinstance(other, self.__class__):\n            return False\n        elif self.pmin == other.pmin and self.pmax == other.pmax:\n            return True\n        else:\n            return False\n\n    def __contains__(self, point):\n        """"""Determine if ``point`` is in the region.\n\n        Point is considered to be in the region if\n\n        .. math::\n\n            p^\\\\text{min}_{i} \\\\le p_{i} \\\\le p^\\\\text{max}_{i}, \\\\text{for}\\\\,\n            i = x, y, z.\n\n        Parameters\n        ----------\n        point : (3,) array_like\n\n            The point coordinate :math:`(p_{x}, p_{y}, p_{z})`.\n\n        Returns\n        -------\n        bool\n\n            ``True`` if ``point`` is inside the region and ``False`` otherwise.\n\n        Example\n        -------\n        1. Check whether point is inside the region.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (0, 0, 0)\n        >>> p2 = (2, 2, 1)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> (1, 1, 1) in region\n        True\n        >>> (1, 3, 1) in region\n        False\n        >>> # corner points are inside the region\n        >>> p1 in region\n        True\n        >>> p2 in region\n        True\n\n        """"""\n        if np.logical_or(np.less(point, self.pmin),\n                         np.greater(point, self.pmax)).any():\n            return False\n        else:\n            return True\n\n    def mpl(self, ax=None, figsize=None, color=dfu.cp_hex[0], multiplier=None,\n            filename=None, **kwargs):\n        """"""``matplotlib`` plot.\n\n        If ``ax`` is not passed, ``matplotlib.axes.Axes`` object is created\n        automatically and the size of a figure can be specified using\n        ``figsize``. The colour of lines depicting the region can be specified\n        using ``color`` argument, which must be a valid ``matplotlib`` color.\n        The plot is saved in PDF-format if ``filename`` is passed.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``matplotlib.pyplot.plot``, so any keyword\n        arguments accepted by it can be passed (for instance, ``linewidth``,\n        ``linestyle``, etc.).\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes, optional\n\n            Axes to which the plot is added. Defaults to ``None`` - axes are\n            created internally.\n\n        figsize : (2,) tuple, optional\n\n            The size of a created figure if ``ax`` is not passed. Defaults to\n            ``None``.\n\n        color : int, str, tuple, optional\n\n            A valid ``matplotlib`` color for lines depicting the region.\n            Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        filename : str, optional\n\n            If filename is passed, the plot is saved. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising the region using ``matplotlib``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-50e-9, -50e-9, 0)\n        >>> p2 = (50e-9, 50e-9, 10e-9)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.mpl()\n\n        """"""\n        if ax is None:\n            fig = plt.figure(figsize=figsize)\n            ax = fig.add_subplot(111, projection=\'3d\')\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.edges)\n\n        unit = f\'({uu.rsi_prefixes[multiplier]}m)\'\n\n        pmin = np.divide(self.pmin, multiplier)\n        pmax = np.divide(self.pmax, multiplier)\n\n        dfu.plot_box(ax=ax, pmin=pmin, pmax=pmax, color=color, **kwargs)\n\n        ax.set(xlabel=f\'x {unit}\', ylabel=f\'y {unit}\', zlabel=f\'z {unit}\')\n\n        # Overwrite default plotting parameters.\n        ax.set_facecolor(\'#ffffff\')  # white face color\n        ax.tick_params(axis=\'both\', which=\'major\', pad=0)  # no pad for ticks\n\n        if filename is not None:\n            plt.savefig(filename, bbox_inches=\'tight\', pad_inches=0)\n\n    def k3d(self, plot=None, color=dfu.cp_int[0], multiplier=None, **kwargs):\n        """"""``k3d`` plot.\n\n        If ``plot`` is not passed, ``k3d.Plot`` object is created\n        automatically. The colour of the region can be specified using\n        ``color`` argument.\n\n        It is often the case that the object size is either small (e.g. on a\n        nanoscale) or very large (e.g. in units of kilometers). Accordingly,\n        ``multiplier`` can be passed as :math:`10^{n}`, where :math:`n` is a\n        multiple of 3 (..., -6, -3, 0, 3, 6,...). According to that value, the\n        axes will be scaled and appropriate units shown. For instance, if\n        ``multiplier=1e-9`` is passed, all axes will be divided by\n        :math:`1\\\\,\\\\text{nm}` and :math:`\\\\text{nm}` units will be used as\n        axis labels. If ``multiplier`` is not passed, the best one is\n        calculated internally.\n\n        This method is based on ``k3d.voxels``, so any keyword arguments\n        accepted by it can be passed (e.g. ``wireframe``).\n\n        Parameters\n        ----------\n        plot : k3d.Plot, optional\n\n            Plot to which the plot is added. Defaults to ``None`` - plot is\n            created internally.\n\n        color : int, optional\n\n            Colour of the region. Defaults to the default color palette.\n\n        multiplier : numbers.Real, optional\n\n            Axes multiplier. Defaults to ``None``.\n\n        Examples\n        --------\n        1. Visualising the region using ``k3d``.\n\n        >>> import discretisedfield as df\n        ...\n        >>> p1 = (-50e-9, -50e-9, 0)\n        >>> p2 = (50e-9, 50e-9, 10e-9)\n        >>> region = df.Region(p1=p1, p2=p2)\n        >>> region.k3d()\n        Plot(...)\n\n        """"""\n        if plot is None:\n            plot = k3d.plot()\n            plot.display()\n\n        if multiplier is None:\n            multiplier = uu.si_max_multiplier(self.edges)\n\n        unit = f\'({uu.rsi_prefixes[multiplier]}m)\'\n\n        plot_array = np.ones((1, 1, 1)).astype(np.uint8)  # avoid k3d warning\n\n        bounds = [i for sublist in\n                  zip(np.divide(self.pmin, multiplier),\n                      np.divide(self.pmax, multiplier))\n                  for i in sublist]\n\n        plot += k3d.voxels(plot_array, color_map=color, bounds=bounds,\n                           outlines=False, **kwargs)\n\n        plot.axes = [f\'{i}\\,\\\\text{{{unit}}}\' for i in dfu.axesdict.keys()]\n'"
docs/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'discretisedfield\'\ncopyright = \'2020, Marijan Beg and Hans Fangohr\'\nauthor = \'Marijan Beg, Ryan A. Pepper, Thomas Kluyver, and Hans Fangohr\'\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\'sphinx.ext.autodoc\',\n              \'sphinx.ext.napoleon\',\n              \'sphinx.ext.mathjax\',\n              \'nbsphinx\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\nmaster_doc = \'index\'\n'"
discretisedfield/tests/__init__.py,0,b''
discretisedfield/tests/test_field.py,40,"b""import os\nimport re\nimport k3d\nimport types\nimport random\nimport pytest\nimport numbers\nimport tempfile\nimport itertools\nimport numpy as np\nimport discretisedfield as df\nimport matplotlib.pyplot as plt\nfrom .test_mesh import TestMesh\n\n\ndef check_field(field):\n    assert isinstance(field.mesh, df.Mesh)\n\n    assert isinstance(field.dim, int)\n    assert field.dim > 0\n\n    assert isinstance(field.array, np.ndarray)\n    assert field.array.shape == (*field.mesh.n, field.dim)\n\n    average = field.average\n    assert isinstance(average, (tuple, numbers.Real))\n\n    rstr = repr(field)\n    assert isinstance(rstr, str)\n    pattern = (r'^Field\\(mesh=Mesh\\(region=Region\\(p1=\\(.+\\), '\n               r'p2=\\(.+\\)\\), .+\\), dim=\\d+\\)$')\n    assert re.search(pattern, rstr)\n\n    assert isinstance(field.__iter__(), types.GeneratorType)\n    assert len(list(field)) == len(field.mesh)\n\n    line = field.line(p1=field.mesh.region.pmin,\n                      p2=field.mesh.region.pmax,\n                      n=5)\n    assert isinstance(line, df.Line)\n    assert line.n == 5\n\n    plane = field.plane('z', n=(2, 2))\n    assert isinstance(plane, df.Field)\n    assert len(plane.mesh) == 4\n    assert plane.mesh.n == (2, 2, 1)\n\n    project = field.project('z')\n    assert isinstance(project, df.Field)\n    assert project.mesh.n[2] == 1\n\n    assert isinstance(field(field.mesh.region.centre), (tuple, numbers.Real))\n    assert isinstance(field(field.mesh.region.random_point()),\n                      (tuple, numbers.Real))\n\n    assert field == field\n    assert not field != field\n\n    assert +field == field\n    assert -(-field) == field\n    assert field + field == 2*field\n    assert field - (-field) == field + field\n    assert 1*field == field\n    assert -1*field == -field\n\n    integral = field.volume_integral\n    assert isinstance(integral, (tuple, numbers.Real))\n\n    if field.dim == 1:\n        grad = field.grad\n        assert isinstance(grad, df.Field)\n        assert grad.dim == 3\n\n        assert all(i not in dir(field) for i in 'xyz')\n\n    if field.dim == 3:\n        norm = field.norm\n        assert isinstance(norm, df.Field)\n        assert norm == abs(field)\n        assert norm.dim == 1\n\n        assert isinstance(field.x, df.Field)\n        assert field.x.dim == 1\n\n        assert isinstance(field.y, df.Field)\n        assert field.y.dim == 1\n\n        assert isinstance(field.z, df.Field)\n        assert field.z.dim == 1\n\n        div = field.div\n        assert isinstance(div, df.Field)\n        assert div.dim == 1\n\n        curl = field.curl\n        assert isinstance(curl, df.Field)\n        assert curl.dim == 3\n\n        field_plane = field.plane('z')\n        assert isinstance(field_plane.topological_charge_density, df.Field)\n        assert isinstance(field_plane.topological_charge(), numbers.Real)\n        assert isinstance(field_plane.bergluescher, numbers.Real)\n\n        orientation = field.orientation\n        assert isinstance(orientation, df.Field)\n        assert orientation.dim == 3\n\n        assert all(i in dir(field) for i in 'xyz')\n\n\nclass TestField:\n    def setup(self):\n        # Get meshes using valid arguments from TestMesh.\n        tm = TestMesh()\n        tm.setup()\n        self.meshes = []\n        for p1, p2, n, cell in tm.valid_args:\n            region = df.Region(p1=p1, p2=p2)\n            mesh = df.Mesh(region=region, n=n, cell=cell)\n            self.meshes.append(mesh)\n\n        # Create lists of field values.\n        self.consts = [0, -5., np.pi, 1e-15, 1.2e12, random.random()]\n        self.iters = [(0, 0, 1),\n                      (0, -5.1, np.pi),\n                      [70, 1e15, 2*np.pi],\n                      [5, random.random(), np.pi],\n                      np.array([4, -1, 3.7]),\n                      np.array([2.1, 0.0, -5*random.random()])]\n        self.sfuncs = [lambda c: 1,\n                       lambda c: -2.4,\n                       lambda c: -6.4e-15,\n                       lambda c: c[0] + c[1] + c[2] + 1,\n                       lambda c: (c[0]-1)**2 - c[1]+7 + c[2]*0.1,\n                       lambda c: np.sin(c[0]) + np.cos(c[1]) - np.sin(2*c[2])]\n        self.vfuncs = [lambda c: (1, 2, 0),\n                       lambda c: (-2.4, 1e-3, 9),\n                       lambda c: (c[0], c[1], c[2] + 100),\n                       lambda c: (c[0]+c[2]+10, c[1], c[2]+1),\n                       lambda c: (c[0]-1, c[1]+70, c[2]*0.1),\n                       lambda c: (np.sin(c[0]), np.cos(c[1]), -np.sin(2*c[2]))]\n\n        # Create a field for plotting tests\n        mesh = df.Mesh(p1=(-5e-9, -5e-9, -5e-9),\n                       p2=(5e-9, 5e-9, 5e-9),\n                       n=(5, 5, 5))\n\n        def norm_fun(point):\n            x, y, z = point\n            if x**2 + y**2 <= (5e-9)**2:\n                return 1\n            else:\n                return 0\n\n        def value_fun(point):\n            x, y, z = point\n            if x <= 0:\n                return (0, 0, 1)\n            else:\n                return (0, 0, -1)\n\n        self.pf = df.Field(mesh, dim=3, value=value_fun, norm=norm_fun)\n\n        # Make one vector point out-of-plane\n        # self.pf.array[0, 0, 0, :] = (0, 0, 1)\n\n    def test_init_valid_args(self):\n        for mesh in self.meshes:\n            for value in self.consts + self.sfuncs:\n                f = df.Field(mesh, dim=1, value=value)\n                check_field(f)\n\n            for value in self.iters + self.vfuncs:\n                f = df.Field(mesh, dim=3, value=value)\n                check_field(f)\n\n    def test_init_invalid_args(self):\n        with pytest.raises(TypeError):\n            mesh = 'meaningless_mesh_string'\n            f = df.Field(mesh, dim=1)\n\n        for mesh in self.meshes:\n            for dim in [0, -1, 'dim', (2, 3)]:\n                with pytest.raises((ValueError, TypeError)):\n                    f = df.Field(mesh, dim=dim)\n\n    def test_set_with_ndarray(self):\n        for mesh in self.meshes:\n            f = df.Field(mesh, dim=3)\n            f.value = np.ones((*f.mesh.n, f.dim,))\n\n            check_field(f)\n            assert isinstance(f.value, np.ndarray)\n            assert f.average == (1, 1, 1)\n\n            with pytest.raises(ValueError):\n                f.value = np.ones((2, 2))\n\n    def test_set_with_callable(self):\n        for mesh in self.meshes:\n            for func in self.sfuncs:\n                f = df.Field(mesh, dim=1, value=func)\n                check_field(f)\n\n                rp = f.mesh.region.random_point()\n                # Make sure to be at the centre of the cell\n                rp = f.mesh.index2point(f.mesh.point2index(rp))\n                assert f(rp) == func(rp)\n\n        for mesh in self.meshes:\n            for func in self.vfuncs:\n                f = df.Field(mesh, dim=3, value=func)\n                check_field(f)\n\n                rp = f.mesh.region.random_point()\n                rp = f.mesh.index2point(f.mesh.point2index(rp))\n                assert np.all(f(rp) == func(rp))\n\n    def test_set_with_dict(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 10e-9, 10e-9)\n        n = (5, 5, 5)\n        subregions = {'r1': df.Region(p1=(0, 0, 0), p2=(5e-9, 10e-9, 10e-9)),\n                      'r2': df.Region(p1=(5e-9, 0, 0),\n                                      p2=(10e-9, 10e-9, 10e-9))}\n        mesh = df.Mesh(p1=p1, p2=p2, n=n, subregions=subregions)\n\n        field = df.Field(mesh, dim=3, value={'r1': (0, 0, 1),\n                                             'r2': (0, 0, 2),\n                                             'r1:r2': (0, 0, 5)})\n        assert np.all(field((3e-9, 7e-9, 9e-9)) == (0, 0, 1))\n        assert np.all(field((8e-9, 2e-9, 9e-9)) == (0, 0, 2))\n\n    def test_set_exception(self):\n        for mesh in self.meshes:\n            with pytest.raises(ValueError):\n                f = df.Field(mesh, dim=3, value='meaningless_string')\n\n            with pytest.raises(ValueError):\n                f = df.Field(mesh, dim=3, value=5+5j)\n\n    def test_value(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 10e-9, 10e-9)\n        n = (5, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        f = df.Field(mesh, dim=3)\n        f.value = (1, 1, 1)\n\n        assert f.value == (1, 1, 1)\n\n        f.array[0, 0, 0, 0] = 3\n        assert isinstance(f.value, np.ndarray)\n\n    def test_norm(self):\n        mesh = df.Mesh(p1=(0, 0, 0), p2=(10, 10, 10), cell=(5, 5, 5))\n        f = df.Field(mesh, dim=3, value=(2, 2, 2))\n\n        assert np.all(f.norm.value == 2*np.sqrt(3))\n        assert np.all(f.norm.array == 2*np.sqrt(3))\n        assert np.all(f.array == 2)\n\n        f.norm = 1\n        assert np.all(f.norm.value == 1)\n        assert np.all(f.norm.array == 1)\n        assert np.all(f.array == 1/np.sqrt(3))\n\n        f.array[0, 0, 0, 0] = 3\n        assert isinstance(f.norm.value, np.ndarray)\n        assert not np.all(f.norm.value == 1)\n\n        for mesh in self.meshes:\n            for value in self.iters + self.vfuncs:\n                for norm_value in [1, 2.1, 50, 1e-3, np.pi]:\n                    f = df.Field(mesh, dim=3, value=value, norm=norm_value)\n\n                    # Compute norm.\n                    norm = f.array[..., 0]**2\n                    norm += f.array[..., 1]**2\n                    norm += f.array[..., 2]**2\n                    norm = np.sqrt(norm)\n\n                    assert norm.shape == f.mesh.n\n                    assert f.norm.array.shape == (*f.mesh.n, 1)\n                    assert np.all(abs(norm - norm_value) < 1e-12)\n\n        # Exception\n        mesh = df.Mesh(p1=(0, 0, 0), p2=(10, 10, 10), cell=(1, 1, 1))\n        f = df.Field(mesh, dim=1, value=-5)\n        with pytest.raises(ValueError):\n            norm = f.norm\n        with pytest.raises(ValueError):\n            f.norm = 5\n\n    def test_norm_is_not_preserved(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 10e-9, 10e-9)\n        n = (5, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        f = df.Field(mesh, dim=3)\n\n        f.value = (0, 3, 0)\n        f.norm = 1\n        assert np.all(f.norm.array == 1)\n\n        f.value = (0, 2, 0)\n        assert np.all(f.norm.value != 1)\n        assert np.all(f.norm.array == 2)\n\n    def test_norm_zero_field_exception(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 10e-9, 10e-9)\n        n = (5, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        f = df.Field(mesh, dim=3, value=(0, 0, 0))\n        with pytest.raises(ValueError):\n            f.norm = 1\n\n    def test_zero(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 10e-9, 10e-9)\n        n = (5, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        f = df.Field(mesh, dim=1, value=1e-6)\n        zf = f.zero\n\n        assert f.mesh == zf.mesh\n        assert f.dim == zf.dim\n        assert not np.any(zf.array)\n\n        f = df.Field(mesh, dim=3, value=(5, -7, 1e3))\n        zf = f.zero\n\n        assert f.mesh == zf.mesh\n        assert f.dim == zf.dim\n        assert not np.any(zf.array)\n\n    def test_orientation(self):\n        p1 = (-5e-9, -5e-9, -5e-9)\n        p2 = (5e-9, 5e-9, 5e-9)\n        cell = (1e-9, 1e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # No zero-norm cells\n        f = df.Field(mesh, dim=3, value=(2, 0, 0))\n        assert f.orientation.average == (1, 0, 0)\n\n        # With zero-norm cells\n        def value_fun(point):\n            x, y, z = point\n            if x <= 0:\n                return (0, 0, 0)\n            else:\n                return (3, 0, 4)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n        assert f.orientation((-1.5e-9, 3e-9, 0)) == (0, 0, 0)\n        assert f.orientation((1.5e-9, 3e-9, 0)) == (0.6, 0, 0.8)\n\n        f = df.Field(mesh, dim=1, value=0)\n        with pytest.raises(ValueError):\n            of = f.orientation\n\n    def test_average(self):\n        value = -1e-3 + np.pi\n        tol = 1e-12\n\n        p1 = (-5e-9, -5e-9, -5e-9)\n        p2 = (5e-9, 5e-9, 5e-9)\n        cell = (1e-9, 1e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f = df.Field(mesh, dim=1, value=2)\n        assert abs(f.average - 2) < tol\n\n        f = df.Field(mesh, dim=3, value=(0, 1, 2))\n        assert np.allclose(f.average, (0, 1, 2))\n\n    def test_field_component(self):\n        for mesh in self.meshes:\n            f = df.Field(mesh, dim=3, value=(1, 2, 3))\n            assert all(isinstance(getattr(f, i), df.Field) for i in 'xyz')\n            assert all(getattr(f, i).dim == 1 for i in 'xyz')\n\n            f = df.Field(mesh, dim=2, value=(1, 2))\n            assert all(isinstance(getattr(f, i), df.Field) for i in 'xy')\n            assert all(getattr(f, i).dim == 1 for i in 'xy')\n\n            # Exception.\n            f = df.Field(mesh, dim=1, value=1)\n            with pytest.raises(AttributeError):\n                fx = f.x.dim\n\n    def test_get_attribute_exception(self):\n        for mesh in self.meshes:\n            f = df.Field(mesh, dim=3)\n            with pytest.raises(AttributeError) as excinfo:\n                f.__getattr__('nonexisting_attribute')\n            assert 'has no attribute' in str(excinfo.value)\n\n    def test_dir(self):\n        for mesh in self.meshes:\n            f = df.Field(mesh, dim=3, value=(5, 6, -9))\n            assert all(attr in dir(f) for attr in ['x', 'y', 'z', 'div'])\n            assert 'grad' not in dir(f)\n\n            f = df.Field(mesh, dim=1, value=1)\n            assert all(attr not in dir(f) for attr in ['x', 'y', 'z', 'div'])\n            assert 'grad' in dir(f)\n\n    def test_eq(self):\n        p1 = (-5e-9, -5e-9, -5e-9)\n        p2 = (15e-9, 5e-9, 5e-9)\n        cell = (5e-9, 1e-9, 2.5e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f1 = df.Field(mesh, dim=1, value=0.2)\n        f2 = df.Field(mesh, dim=1, value=0.2)\n        f3 = df.Field(mesh, dim=1, value=3.1)\n        f4 = df.Field(mesh, dim=3, value=(1, -6, 0))\n        f5 = df.Field(mesh, dim=3, value=(1, -6, 0))\n\n        assert f1 == f2\n        assert not f1 != f2\n        assert not f1 == f3\n        assert f1 != f3\n        assert not f2 == f4\n        assert f2 != f4\n        assert f4 == f5\n        assert not f4 != f5\n        assert not f1 == 0.2\n        assert f1 != 0.2\n\n    def test_allclose(self):\n        p1 = (-5e-9, -5e-9, -5e-9)\n        p2 = (15e-9, 5e-9, 5e-9)\n        cell = (5e-9, 1e-9, 2.5e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f1 = df.Field(mesh, dim=1, value=0.2)\n        f2 = df.Field(mesh, dim=1, value=0.2+1e-9)\n        f3 = df.Field(mesh, dim=1, value=0.21)\n        f4 = df.Field(mesh, dim=3, value=(1, -6, 0))\n        f5 = df.Field(mesh, dim=3, value=(1, -6+1e-8, 0))\n        f6 = df.Field(mesh, dim=3, value=(1, -6.01, 0))\n\n        assert f1.allclose(f2)\n        assert not f1.allclose(f3)\n        assert not f1.allclose(f5)\n        assert f4.allclose(f5)\n        assert not f4.allclose(f6)\n\n        with pytest.raises(TypeError):\n            f1.allclose(2)\n\n    def test_point_neg(self):\n        p1 = (-5e-9, -5e-9, -5e-9)\n        p2 = (5e-9, 5e-9, 5e-9)\n        cell = (1e-9, 1e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Scalar field\n        f = df.Field(mesh, dim=1, value=3)\n        res = -f\n        check_field(res)\n        assert res.average == -3\n        assert f == +f\n        assert f == -(-f)\n        assert f == +(-(-f))\n\n        # Vector field\n        f = df.Field(mesh, dim=3, value=(1, 2, -3))\n        res = -f\n        check_field(res)\n        assert res.average == (-1, -2, 3)\n        assert f == +f\n        assert f == -(-f)\n        assert f == +(-(-f))\n\n    def test_pow(self):\n        p1 = (0, 0, 0)\n        p2 = (15e-9, 6e-9, 6e-9)\n        cell = (3e-9, 3e-9, 3e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Scalar field\n        f = df.Field(mesh, dim=1, value=2)\n        res = f**2\n        assert res.average == 4\n        res = f**(-1)\n        assert res.average == 0.5\n\n        # Attempt vector field\n        f = df.Field(mesh, dim=3, value=(1, 2, -2))\n        with pytest.raises(ValueError):\n            res = f**2\n\n        # Attempt to raise to non numbers.Real\n        f = df.Field(mesh, dim=1, value=2)\n        with pytest.raises(TypeError):\n            res = f**'a'\n        with pytest.raises(TypeError):\n            res = f**f\n\n    def test_add_subtract(self):\n        p1 = (0, 0, 0)\n        p2 = (5e-9, 10e-9, -5e-9)\n        n = (2, 2, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        # Scalar fields\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=1, value=-0.2)\n        res = f1 + f2\n        assert res.average == 1\n        res = f1 - f2\n        assert res.average == 1.4\n        f1 += f2\n        assert f1.average == 1\n        f1 -= f2\n        assert f1.average == 1.2\n\n        # Vector fields\n        f1 = df.Field(mesh, dim=3, value=(1, 2, 3))\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        res = f1 + f2\n        assert res.average == (0, -1, -2)\n        res = f1 - f2\n        assert res.average == (2, 5, 8)\n        f1 += f2\n        assert f1.average == (0, -1, -2)\n        f1 -= f2\n        assert f1.average == (1, 2, 3)\n\n        # Artithmetic checks\n        assert f1 + f2 + (1, 1, 1) == (1, 1, 1) + f2 + f1\n        assert f1 - f2 - (0, 0, 0) == (0, 0, 0) - (f2 - f1)\n        assert f1 + (f1 + f2) == (f1 + f1) + f2\n        assert f1 - (f1 + f2) == f1 - f1 - f2\n        assert f1 + f2 - f1 == f2 + (0, 0, 0)\n\n        # Constants\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        res = f1 + 2\n        assert res.average == 3.2\n        res = f1 - 1.2\n        assert res.average == 0\n        f1 += 2.5\n        assert f1.average == 3.7\n        f1 -= 3.7\n        assert f1.average == 0\n        res = f2 + (1, 3, 5)\n        assert res.average == (0, 0, 0)\n        res = f2 - (1, 2, 3)\n        assert res.average == (-2, -5, -8)\n        f2 += (1, 1, 1)\n        assert f2.average == (0, -2, -4)\n        f2 -= (-1, -2, 3)\n        assert f2.average == (1, 0, -7)\n\n        # Exceptions\n        with pytest.raises(TypeError):\n            res = f1 + '2'\n\n        # Fields with different dimensions\n        with pytest.raises(ValueError):\n            res = f1 + f2\n\n        # Fields defined on different meshes\n        mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), n=(1, 1, 1))\n        mesh2 = df.Mesh(p1=(0, 0, 0), p2=(3, 3, 3), n=(1, 1, 1))\n        f1 = df.Field(mesh1, dim=1, value=1.2)\n        f2 = df.Field(mesh2, dim=1, value=1)\n        with pytest.raises(ValueError):\n            res = f1 + f2\n        with pytest.raises(ValueError):\n            f1 += f2\n        with pytest.raises(ValueError):\n            f1 -= f2\n\n    def test_mul_truediv(self):\n        p1 = (0, 0, 0)\n        p2 = (5e-9, 5e-9, 5e-9)\n        cell = (1e-9, 5e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Scalar fields\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=1, value=-2)\n        res = f1 * f2\n        assert res.average == -2.4\n        res = f1 / f2\n        assert res.average == -0.6\n        f1 *= f2\n        assert f1.average == -2.4\n        f1 /= f2\n        assert f1.average == 1.2\n\n        # Scalar field with a constant\n        f = df.Field(mesh, dim=1, value=5)\n        res = f * 2\n        assert res.average == 10\n        res = 3 * f\n        assert res.average == 15\n        res = f * (1, 2, 3)\n        assert res.average == (5, 10, 15)\n        res = (1, 2, 3) * f\n        assert res.average == (5, 10, 15)\n        res = f / 2\n        assert res.average == 2.5\n        res = 10 / f\n        assert res.average == 2\n        res = (5, 10, 15) / f\n        assert res.average == (1, 2, 3)\n        f *= 10\n        assert f.average == 50\n        f /= 10\n        assert f.average == 5\n\n        # Scalar field with a vector field\n        f1 = df.Field(mesh, dim=1, value=2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, 5))\n        res = f1 * f2  # __mul__\n        assert res.average == (-2, -6, 10)\n        res = f2 * f1  # __rmul__\n        assert res.average == (-2, -6, 10)\n        res = f2 / f1  # __truediv__\n        assert res.average == (-0.5, -1.5, 2.5)\n        f2 *= f1  # __imul__\n        assert f2.average == (-2, -6, 10)\n        f2 /= f1  # __truediv__\n        assert f2.average == (-1, -3, 5)\n        with pytest.raises(ValueError):\n            res = f1 / f2  # __rtruediv__\n\n        # Vector field with a scalar\n        f = df.Field(mesh, dim=3, value=(1, 2, 0))\n        res = f * 2\n        assert res.average == (2, 4, 0)\n        res = 5 * f\n        assert res.average == (5, 10, 0)\n        res = f / 2\n        assert res.average == (0.5, 1, 0)\n        f *= 2\n        assert f.average == (2, 4, 0)\n        f /= 2\n        assert f.average == (1, 2, 0)\n        with pytest.raises(ValueError):\n            res = 10 / f\n\n        # Further checks\n        f1 = df.Field(mesh, dim=1, value=2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        assert f1 * f2 == f2 * f1\n        assert 1.3 * f2 == f2 * 1.3\n        assert -5 * f2 == f2 * (-5)\n        assert (1, 2.2, -1) * f1 == f1 * (1, 2.2, -1)\n        assert f1 * (f1 * f2) == (f1 * f1) * f2\n        assert f1 * f2 / f1 == f2\n\n        # Exceptions\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        with pytest.raises(TypeError):\n            res = f2 * 'a'\n        with pytest.raises(TypeError):\n            res = 'a' / f1\n        with pytest.raises(ValueError):\n            res = f2 * f2\n        with pytest.raises(ValueError):\n            res = f2 / f2\n        with pytest.raises(ValueError):\n            res = 1 / f2\n        with pytest.raises(ValueError):\n            res = f1 / f2\n        with pytest.raises(TypeError):\n            f2 *= 'a'\n        with pytest.raises(TypeError):\n            f2 /= 'a'\n        with pytest.raises(ValueError):\n            f1 /= f2\n\n        # Fields defined on different meshes\n        mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), n=(1, 1, 1))\n        mesh2 = df.Mesh(p1=(0, 0, 0), p2=(3, 3, 3), n=(1, 1, 1))\n        f1 = df.Field(mesh1, dim=1, value=1.2)\n        f2 = df.Field(mesh2, dim=1, value=1)\n        with pytest.raises(ValueError):\n            res = f1 * f2\n        with pytest.raises(ValueError):\n            res = f1 / f2\n        with pytest.raises(ValueError):\n            f1 *= f2\n        with pytest.raises(ValueError):\n            f1 /= f2\n\n    def test_dot(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Zero vectors\n        f1 = df.Field(mesh, dim=3, value=(0, 0, 0))\n        res = f1@f1\n        assert res.dim == 1\n        assert res.average == 0\n\n        # Orthogonal vectors\n        f1 = df.Field(mesh, dim=3, value=(1, 0, 0))\n        f2 = df.Field(mesh, dim=3, value=(0, 1, 0))\n        f3 = df.Field(mesh, dim=3, value=(0, 0, 1))\n        assert (f1 @ f2).average == 0\n        assert (f1 @ f3).average == 0\n        assert (f2 @ f3).average == 0\n        assert (f1 @ f1).average == 1\n        assert (f2 @ f2).average == 1\n        assert (f3 @ f3).average == 1\n\n        # Check if commutative\n        assert f1 @ f2 == f2 @ f1\n        assert f1 @ (-1, 3, 2.2) == (-1, 3, 2.2) @ f1\n\n        # Vector field with a constant\n        f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        res = (1, 1, 1) @ f\n        assert res.average == 6\n        res = f @ [1, 1, 1]\n        assert res.average == 6\n\n        # Spatially varying vectors\n        def value_fun1(point):\n            x, y, z = point\n            return (x, y, z)\n\n        def value_fun2(point):\n            x, y, z = point\n            return (z, x, y)\n\n        f1 = df.Field(mesh, dim=3, value=value_fun1)\n        f2 = df.Field(mesh, dim=3, value=value_fun2)\n\n        # Check if commutative\n        assert f1 @ f2 == f2 @ f1\n\n        # The dot product should be x*z + y*x + z*y\n        assert (f1 @ f2)((1, 1, 1)) == 3\n        assert (f1 @ f2)((3, 1, 1)) == 7\n        assert (f1 @ f2)((5, 7, 1)) == 47\n\n        # Check norm computed using dot product\n        assert f1.norm == (f1 @ f1)**(0.5)\n\n        # Exceptions\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        with pytest.raises(ValueError):\n            res = f1 @ f2\n        with pytest.raises(ValueError):\n            res = f1 @ f2\n        with pytest.raises(TypeError):\n            res = f1 @ 3\n\n        # Fields defined on different meshes\n        mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), n=(1, 1, 1))\n        mesh2 = df.Mesh(p1=(0, 0, 0), p2=(3, 3, 3), n=(1, 1, 1))\n        f1 = df.Field(mesh1, dim=3, value=(1, 2, 3))\n        f2 = df.Field(mesh2, dim=3, value=(3, 2, 1))\n        with pytest.raises(ValueError):\n            res = f1 @ f2\n\n    def test_cross(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Zero vectors\n        f1 = df.Field(mesh, dim=3, value=(0, 0, 0))\n        res = f1 & f1\n        assert res.dim == 3\n        assert res.average == (0, 0, 0)\n\n        # Orthogonal vectors\n        f1 = df.Field(mesh, dim=3, value=(1, 0, 0))\n        f2 = df.Field(mesh, dim=3, value=(0, 1, 0))\n        f3 = df.Field(mesh, dim=3, value=(0, 0, 1))\n        assert (f1 & f2).average == (0, 0, 1)\n        assert (f1 & f3).average == (0, -1, 0)\n        assert (f2 & f3).average == (1, 0, 0)\n        assert (f1 & f1).average == (0, 0, 0)\n        assert (f2 & f2).average == (0, 0, 0)\n        assert (f3 & f3).average == (0, 0, 0)\n\n        # Constants\n        assert (f1 & (0, 1, 0)).average == (0, 0, 1)\n        assert ((0, 1, 0) & f1).average == (0, 0, 1)\n\n        # Check if not comutative\n        assert f1 & f2 == -(f2 & f1)\n        assert f1 & f3 == -(f3 & f1)\n        assert f2 & f3 == -(f3 & f2)\n\n        f1 = df.Field(mesh, dim=3, value=lambda point: (point[0],\n                                                        point[1],\n                                                        point[2]))\n        f2 = df.Field(mesh, dim=3, value=lambda point: (point[2],\n                                                        point[0],\n                                                        point[1]))\n\n        # The cross product should be\n        # (y**2-x*z, z**2-x*y, x**2-y*z)\n        assert (f1 & f2)((1, 1, 1)) == (0, 0, 0)\n        assert (f1 & f2)((3, 1, 1)) == (-2, -2, 8)\n        assert (f2 & f1)((3, 1, 1)) == (2, 2, -8)\n        assert (f1 & f2)((5, 7, 1)) == (44, -34, 18)\n\n        # Exceptions\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=3, value=(-1, -3, -5))\n        with pytest.raises(TypeError):\n            res = f1 & 2\n        with pytest.raises(ValueError):\n            res = f1 & f2\n\n        # Fields defined on different meshes\n        mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), n=(1, 1, 1))\n        mesh2 = df.Mesh(p1=(0, 0, 0), p2=(3, 3, 3), n=(1, 1, 1))\n        f1 = df.Field(mesh1, dim=3, value=(1, 2, 3))\n        f2 = df.Field(mesh2, dim=3, value=(3, 2, 1))\n        with pytest.raises(ValueError):\n            res = f1 & f2\n\n    def test_stack(self):\n        p1 = (0, 0, 0)\n        p2 = (10e6, 10e6, 10e6)\n        cell = (5e6, 5e6, 5e6)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f1 = df.Field(mesh, dim=1, value=1)\n        f2 = df.Field(mesh, dim=1, value=-3)\n        f3 = df.Field(mesh, dim=1, value=5)\n\n        res = f1 << f2 << f3\n        assert res.dim == 3\n        assert res.average == (1, -3, 5)\n\n        # Different dimensions\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        f2 = df.Field(mesh, dim=2, value=(-1, -3))\n        res = f1 << f2\n        assert res.average == (1.2, -1, -3)\n        res = f2 << f1\n        assert res.average == (-1, -3, 1.2)\n\n        # Constants\n        f1 = df.Field(mesh, dim=1, value=1.2)\n        res = f1 << 2\n        assert res.average == (1.2, 2)\n        res = f1 << (1, -1)\n        assert res.average == (1.2, 1, -1)\n        res = 3 << f1\n        assert res.average == (3, 1.2)\n        res = (1.2, 3) << f1 << 3\n        assert res.average == (1.2, 3, 1.2, 3)\n\n        # Exceptions\n        with pytest.raises(TypeError):\n            res = 'a' << f1\n        with pytest.raises(TypeError):\n            res = f1 << 'a'\n\n        # Fields defined on different meshes\n        mesh1 = df.Mesh(p1=(0, 0, 0), p2=(5, 5, 5), n=(1, 1, 1))\n        mesh2 = df.Mesh(p1=(0, 0, 0), p2=(3, 3, 3), n=(1, 1, 1))\n        f1 = df.Field(mesh1, dim=1, value=1.2)\n        f2 = df.Field(mesh2, dim=1, value=1)\n        with pytest.raises(ValueError):\n            res = f1 << f2\n\n    def test_all_operators(self):\n        p1 = (0, 0, 0)\n        p2 = (5e-9, 5e-9, 10e-9)\n        n = (2, 2, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n\n        f1 = df.Field(mesh, dim=1, value=2)\n        f2 = df.Field(mesh, dim=3, value=(-4, 0, 1))\n        res = ((+f1/2 + f2.x)**2 - 2*f1*3)/(-f2.z) - 2*f2.y + 1/f2.z**2 + f2@f2\n        assert np.all(res.array == 21)\n\n        res = 1 + f1 + 0*f2.x - 3*f2.y/3\n        assert res.average == 3\n\n    def test_pad(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 8, 2)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        field = df.Field(mesh, dim=1, value=1)\n\n        pf = field.pad({'x': (1, 1)}, mode='constant')  # zeros padded\n        assert pf.array.shape == (12, 8, 2, 1)\n\n    def test_derivative(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n\n        # f(x, y, z) = 0 -> grad(f) = (0, 0, 0)\n        # No BC\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        f = df.Field(mesh, dim=1, value=0)\n\n        check_field(f.derivative('x'))\n        assert f.derivative('x', n=1).average == 0\n        assert f.derivative('y', n=1).average == 0\n        assert f.derivative('z', n=1).average == 0\n        assert f.derivative('x', n=2).average == 0\n        assert f.derivative('y', n=2).average == 0\n        assert f.derivative('z', n=2).average == 0\n\n        # f(x, y, z) = x + y + z -> grad(f) = (1, 1, 1)\n        # No BC\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        def value_fun(point):\n            x, y, z = point\n            return x + y + z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.derivative('x', n=1).average == 1\n        assert f.derivative('y', n=1).average == 1\n        assert f.derivative('z', n=1).average == 1\n        assert f.derivative('x', n=2).average == 0\n        assert f.derivative('y', n=2).average == 0\n        assert f.derivative('z', n=2).average == 0\n\n        # f(x, y, z) = x*y + 2*y + x*y*z ->\n        # grad(f) = (y+y*z, x+2+x*z, x*y)\n        # No BC\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        def value_fun(point):\n            x, y, z = point\n            return x*y + 2*y + x*y*z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.derivative('x')((7, 5, 1)) == 10\n        assert f.derivative('y')((7, 5, 1)) == 16\n        assert f.derivative('z')((7, 5, 1)) == 35\n        assert f.derivative('x', n=2)((1, 1, 1)) == 0\n        assert f.derivative('y', n=2)((1, 1, 1)) == 0\n        assert f.derivative('z', n=2)((1, 1, 1)) == 0\n\n        # f(x, y, z) = (0, 0, 0)\n        # -> dfdx = (0, 0, 0)\n        # -> dfdy = (0, 0, 0)\n        # -> dfdz = (0, 0, 0)\n        # No BC\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        f = df.Field(mesh, dim=3, value=(0, 0, 0))\n\n        check_field(f.derivative('y'))\n        assert f.derivative('x').average == (0, 0, 0)\n        assert f.derivative('y').average == (0, 0, 0)\n        assert f.derivative('z').average == (0, 0, 0)\n\n        # f(x, y, z) = (x,  y,  z)\n        # -> dfdx = (1, 0, 0)\n        # -> dfdy = (0, 1, 0)\n        # -> dfdz = (0, 0, 1)\n        def value_fun(point):\n            x, y, z = point\n            return (x, y, z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.derivative('x').average == (1, 0, 0)\n        assert f.derivative('y').average == (0, 1, 0)\n        assert f.derivative('z').average == (0, 0, 1)\n\n        # f(x, y, z) = (x*y, y*z, x*y*z)\n        # -> dfdx = (y, 0, y*z)\n        # -> dfdy = (x, z, x*z)\n        # -> dfdz = (0, y, x*y)\n        def value_fun(point):\n            x, y, z = point\n            return (x*y, y*z, x*y*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.derivative('x')((3, 1, 3)) == (1, 0, 3)\n        assert f.derivative('y')((3, 1, 3)) == (3, 3, 9)\n        assert f.derivative('z')((3, 1, 3)) == (0, 1, 3)\n        assert f.derivative('x')((5, 3, 5)) == (3, 0, 15)\n        assert f.derivative('y')((5, 3, 5)) == (5, 5, 25)\n        assert f.derivative('z')((5, 3, 5)) == (0, 3, 15)\n\n        # f(x, y, z) = (3+x*y, x-2*y, x*y*z)\n        # -> dfdx = (y, 1, y*z)\n        # -> dfdy = (x, -2, x*z)\n        # -> dfdz = (0, 0, x*y)\n        def value_fun(point):\n            x, y, z = point\n            return (3+x*y, x-2*y, x*y*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.derivative('x')((7, 5, 1)) == (5, 1, 5)\n        assert f.derivative('y')((7, 5, 1)) == (7, -2, 7)\n        assert f.derivative('z')((7, 5, 1)) == (0, 0, 35)\n\n        # f(x, y, z) = 2*x*x + 2*y*y + 3*z*z\n        # -> grad(f) = (4, 4, 6)\n        def value_fun(point):\n            x, y, z = point\n            return 2*x*x + 2*y*y + 3*z*z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.derivative('x', n=2).average == 4\n        assert f.derivative('y', n=2).average == 4\n        assert f.derivative('z', n=2).average == 6\n\n        # f(x, y, z) = (2*x*x, 2*y*y, 3*z*z)\n        def value_fun(point):\n            x, y, z = point\n            return (2*x*x, 2*y*y, 3*z*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.derivative('x', n=2).average == (4, 0, 0)\n        assert f.derivative('y', n=2).average == (0, 4, 0)\n        assert f.derivative('z', n=2).average == (0, 0, 6)\n\n        with pytest.raises(NotImplementedError):\n            res = f.derivative('x', n=3)\n\n    def test_derivative_pbc(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 8, 6)\n        cell = (2, 2, 2)\n\n        mesh_nopbc = df.Mesh(p1=p1, p2=p2, cell=cell)\n        mesh_pbc = df.Mesh(p1=p1, p2=p2, cell=cell, bc='xyz')\n\n        # Scalar field\n        def value_fun(point):\n            return point[0]*point[1]*point[2]\n\n        # No PBC\n        f = df.Field(mesh_nopbc, dim=1, value=value_fun)\n        assert f.derivative('x')((9, 1, 1)) == 1\n        assert f.derivative('y')((1, 7, 1)) == 1\n        assert f.derivative('z')((1, 1, 5)) == 1\n\n        # PBC\n        f = df.Field(mesh_pbc, dim=1, value=value_fun)\n        assert f.derivative('x')((9, 1, 1)) == -1.5\n        assert f.derivative('y')((1, 7, 1)) == -1\n        assert f.derivative('z')((1, 1, 5)) == -0.5\n\n        # Vector field\n        def value_fun(point):\n            return (point[0]*point[1]*point[2],) * 3\n\n        # No PBC\n        f = df.Field(mesh_nopbc, dim=3, value=value_fun)\n        assert f.derivative('x')((9, 1, 1)) == (1, 1, 1)\n        assert f.derivative('y')((1, 7, 1)) == (1, 1, 1)\n        assert f.derivative('z')((1, 1, 5)) == (1, 1, 1)\n\n        # PBC\n        f = df.Field(mesh_pbc, dim=3, value=value_fun)\n        assert f.derivative('x')((9, 1, 1)) == (-1.5, -1.5, -1.5)\n        assert f.derivative('y')((1, 7, 1)) == (-1, -1, -1)\n        assert f.derivative('z')((1, 1, 5)) == (-0.5, -0.5, -0.5)\n\n    def test_derivative_neumann(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 8, 6)\n        cell = (2, 2, 2)\n\n        mesh_noneumann = df.Mesh(p1=p1, p2=p2, cell=cell)\n        mesh_neumann = df.Mesh(p1=p1, p2=p2, cell=cell, bc='neumann')\n\n        # Scalar field\n        def value_fun(point):\n            return point[0]*point[1]*point[2]\n\n        # No Neumann\n        f1 = df.Field(mesh_noneumann, dim=1, value=value_fun)\n        assert f1.derivative('x')((9, 1, 1)) == 1\n        assert f1.derivative('y')((1, 7, 1)) == 1\n        assert f1.derivative('z')((1, 1, 5)) == 1\n\n        # Neumann\n        f2 = df.Field(mesh_neumann, dim=1, value=value_fun)\n        assert (f1.derivative('x')(f1.mesh.region.centre) ==\n                f2.derivative('x')(f2.mesh.region.centre))\n        assert (f1.derivative('x')((1, 7, 1)) !=\n                f2.derivative('x')((1, 7, 1)))\n\n    def test_derivative_single_cell(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 2)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Scalar field: f(x, y, z) = x + y + z\n        # -> grad(f) = (1, 1, 1)\n        def value_fun(point):\n            x, y, z = point\n            return x + y + z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        # only one cell in the z-direction\n        assert f.plane('x').derivative('x').average == 0\n        assert f.plane('y').derivative('y').average == 0\n        assert f.derivative('z').average == 0\n\n        # Vector field: f(x, y, z) = (x, y, z)\n        # -> grad(f) = (1, 1, 1)\n        def value_fun(point):\n            x, y, z = point\n            return (x, y, z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        # only one cell in the z-direction\n        assert f.plane('x').derivative('x').average == (0, 0, 0)\n        assert f.plane('y').derivative('y').average == (0, 0, 0)\n        assert f.derivative('z').average == (0, 0, 0)\n\n    def test_grad(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # f(x, y, z) = 0 -> grad(f) = (0, 0, 0)\n        f = df.Field(mesh, dim=1, value=0)\n\n        check_field(f.grad)\n        assert f.grad.average == (0, 0, 0)\n\n        # f(x, y, z) = x + y + z -> grad(f) = (1, 1, 1)\n        def value_fun(point):\n            x, y, z = point\n            return x + y + z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.grad.average == (1, 1, 1)\n\n        # f(x, y, z) = x*y + y + z -> grad(f) = (y, x+1, 1)\n        def value_fun(point):\n            x, y, z = point\n            return x*y + y + z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.grad((3, 1, 3)) == (1, 4, 1)\n        assert f.grad((5, 3, 5)) == (3, 6, 1)\n\n        # f(x, y, z) = x*y + 2*y + x*y*z ->\n        # grad(f) = (y+y*z, x+2+x*z, x*y)\n        def value_fun(point):\n            x, y, z = point\n            return x*y + 2*y + x*y*z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.grad((7, 5, 1)) == (10, 16, 35)\n        assert f.grad.x == f.derivative('x')\n        assert f.grad.y == f.derivative('y')\n        assert f.grad.z == f.derivative('z')\n\n        # Exception\n        f = df.Field(mesh, dim=3, value=(1, 2, 3))\n\n        with pytest.raises(ValueError):\n            res = f.grad\n\n    def test_div_curl(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # f(x, y, z) = (0, 0, 0)\n        # -> div(f) = 0\n        # -> curl(f) = (0, 0, 0)\n        f = df.Field(mesh, dim=3, value=(0, 0, 0))\n\n        check_field(f.div)\n        assert f.div.dim == 1\n        assert f.div.average == 0\n\n        check_field(f.curl)\n        assert f.curl.dim == 3\n        assert f.curl.average == (0, 0, 0)\n\n        # f(x, y, z) = (x, y, z)\n        # -> div(f) = 3\n        # -> curl(f) = (0, 0, 0)\n        def value_fun(point):\n            x, y, z = point\n            return (x, y, z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.div.average == 3\n        assert f.curl.average == (0, 0, 0)\n\n        # f(x, y, z) = (x*y, y*z, x*y*z)\n        # -> div(f) = y + z + x*y\n        # -> curl(f) = (x*z-y, -y*z, -x)\n        def value_fun(point):\n            x, y, z = point\n            return (x*y, y*z, x*y*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.div((3, 1, 3)) == 7\n        assert f.div((5, 3, 5)) == 23\n\n        assert f.curl((3, 1, 3)) == (8, -3, -3)\n        assert f.curl((5, 3, 5)) == (22, -15, -5)\n\n        # f(x, y, z) = (3+x*y, x-2*y, x*y*z)\n        # -> div(f) = y - 2 + x*y\n        # -> curl(f) = (x*z, -y*z, 1-x)\n        def value_fun(point):\n            x, y, z = point\n            return (3+x*y, x-2*y, x*y*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.div((7, 5, 1)) == 38\n        assert f.curl((7, 5, 1)) == (7, -5, -6)\n\n        # Exception\n        f = df.Field(mesh, dim=1, value=3.11)\n\n        with pytest.raises(ValueError):\n            res = f.div\n        with pytest.raises(ValueError):\n            res = f.curl\n\n    def test_laplace(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # f(x, y, z) = (0, 0, 0)\n        # -> laplace(f) = 0\n        f = df.Field(mesh, dim=3, value=(0, 0, 0))\n\n        check_field(f.laplace)\n        assert f.laplace.dim == 3\n        assert f.laplace.average == (0, 0, 0)\n\n        # f(x, y, z) = x + y + z\n        # -> laplace(f) = 0\n        def value_fun(point):\n            x, y, z = point\n            return x + y + z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n        check_field(f.laplace)\n        assert f.laplace.average == 0\n\n        # f(x, y, z) = 2*x*x + 2*y*y + 3*z*z\n        # -> laplace(f) = 4 + 4 + 6 = 14\n        def value_fun(point):\n            x, y, z = point\n            return 2*x*x + 2*y*y + 3*z*z\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n\n        assert f.laplace.average == 14\n\n        # f(x, y, z) = (2*x*x, 2*y*y, 3*z*z)\n        # -> laplace(f) = (4, 4, 6)\n        def value_fun(point):\n            x, y, z = point\n            return (2*x*x, 2*y*y, 3*z*z)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert f.laplace.average == (4, 4, 6)\n\n    def test_volume_integral(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f = df.Field(mesh, dim=1, value=0)\n        assert f.volume_integral == 0\n\n        f = df.Field(mesh, dim=1, value=2)\n        assert f.volume_integral == 2000\n\n        f = df.Field(mesh, dim=3, value=(-1, 0, 3))\n        assert f.volume_integral == (-1000, 0, 3000)\n\n        def value_fun(point):\n            x, y, z = point\n            if x <= 5:\n                return (-1, -2, -3)\n            else:\n                return (1, 2, 3)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n        assert f.volume_integral == (0, 0, 0)\n\n    def test_surface_integral(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 5, 3)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        f = df.Field(mesh, dim=1, value=0)\n        assert f.plane('x').surface_integral == 0\n\n        f = df.Field(mesh, dim=1, value=2)\n        assert f.plane('x').surface_integral == 30\n        assert f.plane('y').surface_integral == 60\n        assert f.plane('z').surface_integral == 100\n\n        f = df.Field(mesh, dim=3, value=(-1, 0, 3))\n        assert f.plane('x').surface_integral == (-15, 0, 45)\n        assert f.plane('y').surface_integral == (-30, 0, 90)\n        assert f.plane('z').surface_integral == (-50, 0, 150)\n\n    def test_topological_charge(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (2, 2, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # f(x, y, z) = (0, 0, 0)\n        # -> Q(f) = 0\n        f = df.Field(mesh, dim=3, value=(0, 0, 0))\n\n        q = f.plane('z').topological_charge_density\n        check_field(q)\n        assert q.dim == 1\n        assert q.average == 0\n        assert f.plane('z').topological_charge(method='continuous') == 0\n        assert f.plane('z').topological_charge(method='berg-luescher') == 0\n\n        # Skyrmion from a file\n        test_filename = os.path.join(os.path.dirname(__file__),\n                                     'test_sample/',\n                                     'skyrmion.omf')\n        f = df.Field.fromfile(test_filename)\n        Qc = f.plane('z').topological_charge(method='continuous')\n        Qbl = f.plane('z').topological_charge(method='berg-luescher')\n        assert abs(Qc - 1) < 0.15\n        assert abs(Qbl - 1) < 1e-3\n\n        # Not sliced\n        f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        with pytest.raises(ValueError):\n            res = f.topological_charge(method='continuous')\n        with pytest.raises(ValueError):\n            res = f.topological_charge(method='berg-luescher')\n\n        # Scalar field\n        f = df.Field(mesh, dim=1, value=3.14)\n        with pytest.raises(ValueError):\n            res = f.plane('z').topological_charge(method='continuous')\n        with pytest.raises(ValueError):\n            res = f.plane('z').topological_charge(method='berg-luescher')\n\n        # Method does not exist\n        with pytest.raises(ValueError):\n            res = f.plane('z').topological_charge(method='some-method')\n\n    def test_line(self):\n        mesh = df.Mesh(p1=(0, 0, 0), p2=(10, 10, 10), n=(10, 10, 10))\n        f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        check_field(f)\n\n        line = f.line(p1=(0, 0, 0), p2=(5, 5, 5), n=20)\n        assert isinstance(line, df.Line)\n\n        assert line.n == 20\n        assert line.dim == 3\n\n    def test_plane(self):\n        for mesh, direction in itertools.product(self.meshes, ['x', 'y', 'z']):\n            f = df.Field(mesh, dim=1, value=3)\n            check_field(f)\n            plane = f.plane(direction, n=(3, 3))\n            assert isinstance(plane, df.Field)\n\n            p, v = zip(*list(plane))\n            assert len(p) == 9\n            assert len(v) == 9\n\n    def test_getitem(self):\n        p1 = (0, 0, 0)\n        p2 = (90, 50, 10)\n        cell = (5, 5, 5)\n        subregions = {'r1': df.Region(p1=(0, 0, 0), p2=(30, 50, 10)),\n                      'r2': df.Region(p1=(30, 0, 0), p2=(90, 50, 10))}\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n\n        def value_fun(point):\n            x, y, z = point\n            if x <= 60:\n                return (-1, -2, -3)\n            else:\n                return (1, 2, 3)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n        check_field(f)\n        check_field(f['r1'])\n        check_field(f['r2'])\n\n        assert f['r1'].average == (-1, -2, -3)\n        assert f['r2'].average == (0, 0, 0)\n\n        assert len(f['r1'].mesh) + len(f['r2'].mesh) == len(f.mesh)\n\n    def test_project(self):\n        p1 = (-5, -5, -5)\n        p2 = (5, 5, 5)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n        # Constant scalar field\n        f = df.Field(mesh, dim=1, value=5)\n        check_field(f)\n        assert f.project('x').array.shape == (1, 10, 10, 1)\n        assert f.project('y').array.shape == (10, 1, 10, 1)\n        assert f.project('z').array.shape == (10, 10, 1, 1)\n\n        # Constant vector field\n        f = df.Field(mesh, dim=3, value=(1, 2, 3))\n        assert f.project('x').array.shape == (1, 10, 10, 3)\n        assert f.project('y').array.shape == (10, 1, 10, 3)\n        assert f.project('z').array.shape == (10, 10, 1, 3)\n\n        # Spatially varying scalar field\n        def value_fun(point):\n            x, y, z = point\n            if z <= 0:\n                return 1\n            else:\n                return -1\n\n        f = df.Field(mesh, dim=1, value=value_fun)\n        sf = f.project('z')\n        assert sf.array.shape == (10, 10, 1, 1)\n        assert sf.average == 0\n\n        # Spatially varying vector field\n        def value_fun(point):\n            x, y, z = point\n            if z <= 0:\n                return (3, 2, 1)\n            else:\n                return (3, 2, -1)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n        sf = f.project('z')\n        assert sf.array.shape == (10, 10, 1, 3)\n        assert sf.average == (3, 2, 0)\n\n    def test_angle(self):\n        p1 = (0, 0, 0)\n        p2 = (8e-9, 2e-9, 2e-9)\n        cell = (2e-9, 2e-9, 2e-9)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n\n        def value_fun(point):\n            x, y, z = point\n            if x < 2e-9:\n                return (1, 1, 1)\n            elif 2e-9 <= x < 4e-9:\n                return (1, -1, 0)\n            elif 4e-9 <= x < 6e-9:\n                return (-1, -1, 0)\n            elif 6e-9 <= x < 8e-9:\n                return (-1, 1, 0)\n\n        f = df.Field(mesh, dim=3, value=value_fun)\n\n        assert abs(f.plane('z').angle((1e-9, 2e-9, 2e-9)) - np.pi/4) < 1e-3\n        assert abs(f.plane('z').angle((3e-9, 2e-9, 2e-9)) + np.pi/4) < 1e-3\n        assert abs(f.plane('z').angle((5e-9, 2e-9, 2e-9)) + 3*np.pi/4) < 1e-3\n        assert abs(f.plane('z').angle((7e-9, 2e-9, 2e-9)) - 3*np.pi/4) < 1e-3\n\n        # Exception\n        with pytest.raises(ValueError):\n            res = f.angle  # the field is not sliced\n\n    def test_write_read_ovf(self):\n        representations = ['txt', 'bin4', 'bin8']\n        filename = 'testfile.ovf'\n        p1 = (0, 0, 0)\n        p2 = (8e-9, 5e-9, 3e-9)\n        cell = (1e-9, 1e-9, 1e-9)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n\n        # Write/read\n        for dim, value in [(1, lambda point: point[0] + point[1] + point[2]),\n                           (3, lambda point: (point[0], point[1], point[2]))]:\n            f = df.Field(mesh, dim=dim, value=value)\n            for rep in representations:\n                with tempfile.TemporaryDirectory() as tmpdir:\n                    tmpfilename = os.path.join(tmpdir, filename)\n                    f.write(tmpfilename, representation=rep)\n                    f_read = df.Field.fromfile(tmpfilename)\n\n                    assert f.allclose(f_read)\n\n        # Extend scalar\n        for rep in representations:\n            f = df.Field(mesh, dim=1,\n                         value=lambda point: point[0]+point[1]+point[2])\n            with tempfile.TemporaryDirectory() as tmpdir:\n                tmpfilename = os.path.join(tmpdir, filename)\n                f.write(tmpfilename, extend_scalar=True)\n                f_read = df.Field.fromfile(tmpfilename)\n\n                assert f.allclose(f_read.x)\n\n        # Read different OOMMF representations\n        # (OVF1, OVF2) x (txt, bin4, bin8)\n        filenames = ['oommf-ovf2-txt.omf',\n                     'oommf-ovf2-bin4.omf',\n                     'oommf-ovf2-bin8.omf',\n                     'oommf-ovf1-txt.omf',\n                     'oommf-ovf1-bin4.omf',\n                     'oommf-ovf1-bin8.omf']\n        dirname = os.path.join(os.path.dirname(__file__), 'test_sample')\n        for filename in filenames:\n            omffilename = os.path.join(dirname, filename)\n            f_read = df.Field.fromfile(omffilename)\n\n            if 'ovf2' in filename:\n                # The magnetisation is in the x-direction in OVF2 files.\n                assert f_read.x.average > 0.98\n            else:\n                # The norm of magnetisation is known.\n                assert abs(f_read.norm.average - 1261566.2610100) < 1e-3\n\n        # Read different mumax3 bin4 files (made on linux and windows)\n        filenames = ['mumax-bin4-linux.ovf', 'mumax-bin4-windows.ovf']\n        dirname = os.path.join(os.path.dirname(__file__), 'test_sample')\n        for filename in filenames:\n            omffilename = os.path.join(dirname, filename)\n            f_read = df.Field.fromfile(omffilename)\n\n            # We know the saved magentisation.\n            f_saved = df.Field(f_read.mesh, dim=3, value=(1, 0.1, 0), norm=1)\n            assert f_saved.allclose(f_read)\n\n        # Exception (dim=2)\n        f = df.Field(mesh, dim=2, value=(1, 2))\n        with pytest.raises(TypeError) as excinfo:\n            f.write(filename)\n\n    def test_write_read_vtk(self):\n        filename = 'testfile.vtk'\n\n        p1 = (0, 0, 0)\n        p2 = (1e-9, 2e-9, 5e-9)\n        cell = (1e-9, 1e-9, 1e-9)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n\n        for dim, value in [(1, -1.2), (3, (1e-3, -5e6, 5e6))]:\n            f = df.Field(mesh, dim=dim, value=value)\n            with tempfile.TemporaryDirectory() as tmpdir:\n                tmpfilename = os.path.join(tmpdir, filename)\n                f.write(tmpfilename)\n                f_read = df.Field.fromfile(tmpfilename)\n\n                assert f == f_read\n\n    def test_write_read_hdf5(self):\n        filenames = ['testfile.hdf5', 'testfile.h5']\n\n        p1 = (0, 0, 0)\n        p2 = (10e-12, 5e-12, 5e-12)\n        cell = (1e-12, 1e-12, 1e-12)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n\n        for dim, value in [(1, -1.23), (3, (1e-3 + np.pi, -5e6, 6e6))]:\n            f = df.Field(mesh, dim=dim, value=value)\n            for filename in filenames:\n                with tempfile.TemporaryDirectory() as tmpdir:\n                    tmpfilename = os.path.join(tmpdir, filename)\n                    f.write(tmpfilename)\n                    f_read = df.Field.fromfile(tmpfilename)\n\n                    assert f == f_read\n\n    def test_read_write_invalid_extension(self):\n        filename = 'testfile.jpg'\n\n        p1 = (0, 0, 0)\n        p2 = (10e-12, 5e-12, 3e-12)\n        cell = (1e-12, 1e-12, 1e-12)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n\n        f = df.Field(mesh, dim=1, value=5e-12)\n        with pytest.raises(ValueError) as excinfo:\n            f.write(filename)\n        with pytest.raises(ValueError) as excinfo:\n            f = df.Field.fromfile(filename)\n\n    def test_mpl_scalar(self):\n        # No axes\n        self.pf.x.plane('x', n=(3, 4)).mpl_scalar()\n\n        # Axes\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        self.pf.x.plane('x', n=(3, 4)).mpl_scalar(ax=ax)\n\n        # All arguments\n        self.pf.x.plane('x').mpl_scalar(figsize=(10, 10),\n                                        filter_field=self.pf.norm,\n                                        colorbar=True,\n                                        colorbar_label='something',\n                                        multiplier=1e-6, cmap='hsv',\n                                        clim=(-1, 1))\n\n        # Saving plot\n        filename = 'testfigure.pdf'\n        with tempfile.TemporaryDirectory() as tmpdir:\n            tmpfilename = os.path.join(tmpdir, filename)\n            self.pf.x.plane('x', n=(3, 4)).mpl_scalar(filename=tmpfilename)\n\n        # Exceptions\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.mpl_scalar()  # not sliced\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.plane('z').mpl_scalar()  # vector field\n        with pytest.raises(ValueError) as excinfo:\n            # wrong filter field\n            self.pf.plane('z').mpl_scalar(filter_field=self.pf)\n\n        plt.close('all')\n\n    def test_mpl_vector(self):\n        # No axes\n        self.pf.plane('x', n=(3, 4)).mpl_vector()\n\n        # Axes\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        self.pf.plane('x', n=(3, 4)).mpl_vector(ax=ax)\n\n        # All arguments\n        self.pf.plane('x').mpl_vector(figsize=(10, 10),\n                                      color_field=self.pf.y,\n                                      colorbar=True,\n                                      colorbar_label='something',\n                                      multiplier=1e-6, cmap='hsv',\n                                      clim=(-1, 1))\n\n        # Saving plot\n        filename = 'testfigure.pdf'\n        with tempfile.TemporaryDirectory() as tmpdir:\n            tmpfilename = os.path.join(tmpdir, filename)\n            self.pf.plane('x', n=(3, 4)).mpl_vector(filename=tmpfilename)\n\n        # Exceptions\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.mpl_vector()  # not sliced\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.y.plane('z').mpl_vector()  # scalar field\n        with pytest.raises(ValueError) as excinfo:\n            # wrong color field\n            self.pf.plane('z').mpl_vector(color_field=self.pf)\n\n        plt.close('all')\n\n    def test_mpl(self):\n        # No axes\n        self.pf.plane('x', n=(3, 4)).mpl()\n\n        # Axes\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        self.pf.x.plane('x', n=(3, 4)).mpl(ax=ax)\n\n        # All arguments\n        self.pf.plane('x').mpl(figsize=(12, 6),\n                               scalar_field=self.pf.plane('x').angle,\n                               scalar_colorbar_label='something',\n                               scalar_cmap='twilight', vector_field=self.pf,\n                               vector_color_field=self.pf.y, vector_color=True,\n                               vector_colorbar=True,\n                               vector_colorbar_label='vector',\n                               vector_cmap='hsv', vector_clim=(0, 1e6),\n                               multiplier=1e-12)\n\n        # Saving plot\n        filename = 'testfigure.pdf'\n        with tempfile.TemporaryDirectory() as tmpdir:\n            tmpfilename = os.path.join(tmpdir, filename)\n            self.pf.plane('x', n=(3, 4)).mpl(filename=tmpfilename)\n\n        # All exceptions are raised by submethods (mpl_scalaer and mpl_vector)\n        # and there is no need to test them here.\n\n        plt.close('all')\n\n    def test_k3d_nonzero(self):\n        self.pf.norm.k3d_nonzero()\n        self.pf.x.k3d_nonzero()\n        self.pf.z.k3d_nonzero(field=self.pf)\n        self.pf.norm.plane('z').k3d_nonzero(field=self.pf, interactive=True)\n\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.k3d_nonzero()\n\n    def test_k3d_voxels(self):\n        self.pf.x.k3d_voxels()\n        self.pf.y.k3d_voxels(filter_field=self.pf.norm)\n        self.pf.z.k3d_voxels(field=self.pf)\n        self.pf.norm.plane('z').k3d_voxels(field=self.pf, interactive=True)\n\n        # Exceptions\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.k3d_voxels()\n        with pytest.raises(ValueError):\n            self.pf.x.k3d_voxels(filter_field=self.pf)  # filter field dim=3\n        with pytest.raises(ValueError):\n            self.pf.x.k3d_voxels(filter_field=self.pf.norm, n=300)  # n > 256\n\n    def test_k3d_vectors(self):\n        self.pf.k3d_vectors()\n        self.pf.k3d_vectors(color_field=self.pf.z)\n        self.pf.k3d_vectors(points=False)\n        self.pf.k3d_vectors(field=self.pf)\n        self.pf.plane('z').k3d_vectors(field=self.pf, interactive=True)\n\n        # Simulate interactive plotting\n        plot = k3d.plot()\n        self.pf.plane('z').k3d_vectors(field=self.pf, interactive=True,\n                                       plot=plot)\n        self.pf.plane('y').k3d_vectors(field=self.pf, interactive=True,\n                                       plot=plot)\n\n        # Exceptions\n        with pytest.raises(ValueError) as excinfo:\n            self.pf.x.k3d_vectors()  # dim=1\n        with pytest.raises(ValueError):\n            self.pf.k3d_vectors(color_field=self.pf)  # color field dim=3\n\n    def test_plot_large_sample(self):\n        p1 = (0, 0, 0)\n        p2 = (50e9, 50e9, 50e9)\n        cell = (25e9, 25e9, 25e9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        value = (1e6, 1e6, 1e6)\n        field = df.Field(mesh, dim=3, value=value)\n\n        field.plane('z').mpl()\n        field.norm.k3d_nonzero()\n        field.x.k3d_voxels()\n        field.k3d_vectors()\n"""
discretisedfield/tests/test_init.py,0,"b""import discretisedfield as df\n\n\ndef test_version():\n    assert isinstance(df.__version__, str)\n    assert '.' in df.__version__\n\n\ndef test_dependencies():\n    assert isinstance(df.__dependencies__, list)\n    assert len(df.__dependencies__) > 0\n"""
discretisedfield/tests/test_interact.py,0,"b""import discretisedfield as df\n\n\ndef test_interact():\n    p1 = (-50e9, -50e9, -50e9)\n    p2 = (50e9, 50e9, 50e9)\n    n = (10, 10, 10)\n    mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n    field = df.Field(mesh, dim=3, value=(1, 2, 0))\n\n    # Only test whether it runs.\n    @df.interact(x=field.mesh.slider('x'))\n    def myplot(x):\n        field.plane(x=x).mpl()\n"""
discretisedfield/tests/test_line.py,2,"b""import os\nimport re\nimport pytest\nimport numbers\nimport tempfile\nimport ipywidgets\nimport numpy as np\nimport pandas as pd\nimport discretisedfield as df\nimport matplotlib.pyplot as plt\n\n\ndef check_line(line):\n    assert isinstance(line, df.Line)\n    assert isinstance(line.data, pd.DataFrame)\n\n    assert isinstance(line.n, int)\n    assert line.n > 0\n    assert isinstance(line.dim, int)\n    assert line.dim > 0\n\n    assert isinstance(line.point_columns, list)\n    assert len(line.point_columns) == 3\n    assert isinstance(line.value_columns, list)\n    assert len(line.value_columns) == line.dim\n\n    assert isinstance(line.length, numbers.Real)\n    assert line.length > 0\n\n    assert isinstance(repr(line), str)\n\n    assert isinstance(line.slider(), ipywidgets.SelectionRangeSlider)\n    assert isinstance(line.selector(), ipywidgets.SelectMultiple)\n\n\nclass TestLine:\n    def test_init(self):\n        # Scalar values\n        points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n        values = [-1, 2, -3]\n        line = df.Line(points=points, values=values)\n        check_line(line)\n\n        assert line.length == 2\n        assert line.n == 3\n        assert line.dim == 1\n\n        # Vector values\n        points = [(0, 0, 0), (1, 1, 1)]\n        values = [(0, 0, 1), (0, 1, 0)]\n\n        line = df.Line(points=points, values=values)\n        check_line(line)\n\n        assert abs(line.length - np.sqrt(3)) < 1e-12\n        assert line.n == 2\n        assert line.dim == 3\n\n        # Setting the point and value columns.\n        points = [(0, 0, 0), (1, 1, 1)]\n        values = [(0, 0, 1), (0, 1, 0)]\n\n        line = df.Line(points=points, values=values,\n                       point_columns=['a', 'b', 'c'],\n                       value_columns=['x', 'y', 'z'])\n        check_line(line)\n        assert line.point_columns == ['a', 'b', 'c']\n        assert line.value_columns == ['x', 'y', 'z']\n\n        assert abs(line.length - np.sqrt(3)) < 1e-12\n        assert line.n == 2\n        assert line.dim == 3\n\n        # From field\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 15e-9, 2e-9)\n        n = (10, 15, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        f = df.Field(mesh, dim=3, value=(1, 1, 1))\n\n        line = f.line(p1=p1, p2=(10e-9, 15e-9, 1e-9), n=200)\n        check_line(line)\n\n        assert line.n == 200\n        assert line.dim == 3\n\n        line = f.y.line(p1=p1, p2=(10e-9, 15e-9, 1e-9), n=100)\n        check_line(line)\n\n        assert line.n == 100\n        assert line.dim == 1\n\n        # Exceptions\n        points = [(0, 0, 0), (1, 0, 0)]\n        values = [-1, 2, -3]\n        with pytest.raises(ValueError):\n            line = df.Line(points=points, values=values)\n\n    def test_point_value_columns(self):\n        # Scalar values\n        points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n        values = [-1, 2, -3]\n        line = df.Line(points=points, values=values)\n\n        assert line.point_columns == ['px', 'py', 'pz']\n        assert line.value_columns == ['v']\n\n        line.point_columns = ['a', 'b', 'c']\n        line.value_columns = ['val']\n\n        assert line.data.columns.to_list() == ['r', 'a', 'b', 'c', 'val']\n\n        # Vector values.\n        points = [(0, 0, 0), (1, 0, 0), (2, 0, 0)]\n        values = [(0, 1, 3), (-1, 0, 0), (-2.13, 0, 0)]\n        line = df.Line(points=points, values=values)\n\n        assert line.point_columns == ['px', 'py', 'pz']\n        assert line.value_columns == ['vx', 'vy', 'vz']\n\n        line.point_columns = ['a', 'b', 'c']\n        line.value_columns = ['v0', 'v1', 'v2']\n\n        assert line.data.columns.to_list() == ['r', 'a', 'b', 'c',\n                                               'v0', 'v1', 'v2']\n\n    def test_mpl(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 15e-9, 2e-9)\n        n = (10, 15, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        f = df.Field(mesh, dim=3, value=(1, 1, 1))\n\n        line = f.line(p1=(1e-9, 1e-9, 0.1e-9), p2=(4e-9, 5e-9, 1e-9), n=20)\n\n        # No axis\n        line.mpl()\n\n        # Axis\n        fig = plt.figure(figsize=(10, 8))\n        ax = fig.add_subplot(111)\n        line.mpl(ax=ax)\n\n        # figsize\n        line.mpl(figsize=(10, 5))\n\n        # multiplier\n        line.mpl(multiplier=1e-6)\n\n        # y\n        line.mpl(yaxis=['vx', 'vz'])\n\n        # xlim\n        line.mpl(xlim=(0, 10e-9))\n\n        # kwargs\n        line.mpl(marker='o')\n\n        # filename\n        filename = 'line.pdf'\n        with tempfile.TemporaryDirectory() as tmpdir:\n            tmpfilename = os.path.join(tmpdir, filename)\n            line.mpl(filename=tmpfilename)\n\n        plt.close('all')\n\n    def test_slider_selector(self):\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 15e-9, 2e-9)\n        n = (10, 15, 2)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        f = df.Field(mesh, dim=3, value=(1, 1, 1))\n\n        line = f.line(p1=(1e-9, 1e-9, 0.1e-9), p2=(4e-9, 5e-9, 1e-9), n=20)\n\n        assert isinstance(line.slider(), ipywidgets.SelectionRangeSlider)\n        assert isinstance(line.selector(), ipywidgets.SelectMultiple)\n"""
discretisedfield/tests/test_mesh.py,2,"b""import os\nimport re\nimport types\nimport pytest\nimport numbers\nimport tempfile\nimport ipywidgets\nimport numpy as np\nimport discretisedfield as df\nimport matplotlib.pyplot as plt\n\n\ndef check_mesh(mesh):\n    assert isinstance(mesh.region, df.Region)\n\n    assert isinstance(mesh.cell, tuple)\n    assert len(mesh.cell) == 3\n    assert all(isinstance(i, numbers.Real) for i in mesh.cell)\n    assert all(i > 0 for i in mesh.cell)\n\n    assert isinstance(mesh.n, tuple)\n    assert len(mesh.n) == 3\n    assert all(isinstance(i, int) for i in mesh.n)\n    assert all(i > 0 for i in mesh.n)\n\n    assert isinstance(mesh.bc, str)\n\n    assert isinstance(mesh.subregions, dict)\n    assert all(isinstance(i, str) for i in mesh.subregions.keys())\n    assert all(isinstance(i, df.Region) for i in mesh.subregions.values())\n\n    assert isinstance(len(mesh), int)\n    assert len(mesh) > 0\n\n    assert isinstance(repr(mesh), str)\n    pattern = r'^Mesh\\(region=Region\\(p1=\\(.+\\), p2=\\(.+\\)\\), n=.+\\)$'\n    assert re.search(pattern, repr(mesh))\n\n    assert isinstance(mesh.indices, types.GeneratorType)\n    assert isinstance(mesh.__iter__(), types.GeneratorType)\n    assert len(list(mesh.indices)) == len(mesh)\n    assert len(list(mesh)) == len(mesh)\n\n    line = mesh.line(p1=mesh.region.pmin, p2=mesh.region.pmax, n=3)\n    assert isinstance(line, types.GeneratorType)\n    assert len(list(line)) == 3\n    assert all(isinstance(i, tuple) for i in line)\n    assert all(i in mesh.region for i in line)\n\n    plane_mesh = mesh.plane('z', n=(2, 2))\n    assert isinstance(plane_mesh, df.Mesh)\n    assert isinstance(plane_mesh.info, dict)\n    assert plane_mesh.info\n    assert 1 in plane_mesh.n\n    assert len(plane_mesh) == 4\n    assert all(isinstance(i, tuple) for i in plane_mesh)\n    assert all(i in mesh.region for i in plane_mesh)\n\n    assert mesh.point2index(mesh.index2point((0, 0, 0))) == (0, 0, 0)\n\n    assert mesh == mesh\n    assert not mesh != mesh\n\n\nclass TestMesh:\n    def setup(self):\n        self.valid_args = [[(0, 0, 0), (5, 5, 5),\n                            [1, 1, 1], None],\n                           [(-1, 0, -3), (5, 7, 5),\n                            None, (1, 1, 1)],\n                           [(0, 0, 0), (5e-9, 5e-9, 5e-9),\n                            None, (1e-9, 1e-9, 1e-9)],\n                           [(0, 0, 0), (5e-9, 5e-9, 5e-9),\n                            (5, 5, 5), None],\n                           [(-1.5e-9, -5e-9, 0), (1.5e-9, -15e-9, -10e-9),\n                            None, (1.5e-9, 0.5e-9, 10e-9)],\n                           [(-1.5e-9, -5e-9, 0), (1.5e-9, -15e-9, -10e-9),\n                            (3, 10, 2), None],\n                           [(-1.5e-9, -5e-9, -5e-9), np.array((0, 0, 0)),\n                            None, (0.5e-9, 1e-9, 5e-9)],\n                           [(-1.5e-9, -5e-9, -5e-9), np.array((0, 0, 0)),\n                            (5, 5, 7), None],\n                           [[0, 5e-6, 0], (-1.5e-6, -5e-6, -5e-6),\n                            None, (0.5e-6, 2e-6, 2.5e-6)],\n                           [[0, 5e-6, 0], (-1.5e-6, -5e-6, -5e-6),\n                            (1, 10, 20), None],\n                           [(0, 125e-9, 0), (500e-9, 0, -3e-9),\n                            None, (25e-9, 25e-9, 3e-9)]]\n\n        self.invalid_args = [[(0, 0, 0), (5, 5, 5),\n                              None, (-1, 1, 1)],\n                             [(0, 0, 0), (5, 5, 5),\n                              (-1, 1, 1), None],\n                             [(0, 0, 0), (5, 5, 5),\n                              'n', None],\n                             [(0, 0, 0), (5, 5, 5),\n                              (1, 2, 2+1j), None],\n                             [(0, 0, 0), (5, 5, 5),\n                              (1, 2, '2'), None],\n                             [('1', 0, 0), (1, 1, 1),\n                              None, (0, 0, 1e-9)],\n                             [(-1.5e-9, -5e-9, 'a'), (1.5e-9, 15e-9, 16e-9),\n                              None, (5, 1, -1e-9)],\n                             [(-1.5e-9, -5e-9, 'a'), (1.5e-9, 15e-9, 16e-9),\n                              (5, 1, -1), None],\n                             [(-1.5e-9, -5e-9, 0), (1.5e-9, 16e-9),\n                              None, (0.1e-9, 0.1e-9, 1e-9)],\n                             [(-1.5e-9, -5e-9, 0), (1.5e-9, 15e-9, 1+2j),\n                              None, (5, 1, 1e-9)],\n                             ['string', (5, 1, 1e-9),\n                              None, 'string'],\n                             [(-1.5e-9, -5e-9, 0), (1.5e-9, 15e-9, 16e-9),\n                              None, 2+2j]]\n\n    def test_init_valid_args(self):\n        for p1, p2, n, cell in self.valid_args:\n            mesh1 = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n, cell=cell)\n            check_mesh(mesh1)\n\n            mesh2 = df.Mesh(p1=p1, p2=p2, n=n, cell=cell)\n            check_mesh(mesh2)\n\n            assert mesh1 == mesh2\n\n    def test_init_invalid_args(self):\n        for p1, p2, n, cell in self.invalid_args:\n            with pytest.raises((TypeError, ValueError)):\n                mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n, cell=cell)\n\n            with pytest.raises((TypeError, ValueError)):\n                mesh = df.Mesh(p1=p1, p2=p2, n=n, cell=cell)\n\n    def test_init_subregions(self):\n        p1 = (0, 0, 0)\n        p2 = (100, 50, 10)\n        cell = (10, 10, 10)\n        subregions = {'r1': df.Region(p1=(0, 0, 0), p2=(50, 50, 10)),\n                      'r2': df.Region(p1=(50, 0, 0), p2=(100, 50, 10))}\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n        check_mesh(mesh)\n\n    def test_init_with_region_and_points(self):\n        p1 = (0, -4, 16.5)\n        p2 = (15, 10.1, 11)\n        region = df.Region(p1=p1, p2=p2)\n        n = (10, 10, 10)\n\n        with pytest.raises(ValueError) as excinfo:\n            mesh = df.Mesh(region=region, p1=p1, p2=p2, n=n)\n        assert 'not both.' in str(excinfo.value)\n\n    def test_init_with_n_and_cell(self):\n        p1 = (0, -4, 16.5)\n        p2 = (15, 10.1, 11)\n        n = (15, 141, 11)\n        cell = (1, 0.1, 0.5)\n\n        with pytest.raises(ValueError) as excinfo:\n            mesh = df.Mesh(p1=p1, p2=p2, n=n, cell=cell)\n        assert 'not both.' in str(excinfo.value)\n\n    def test_region_not_aggregate_of_cell(self):\n        args = [[(0, 100e-9, 1e-9),\n                 (150e-9, 120e-9, 6e-9),\n                 (4e-9, 1e-9, 1e-9)],\n                [(0, 100e-9, 0),\n                 (150e-9, 104e-9, 1e-9),\n                 (2e-9, 1.5e-9, 0.1e-9)],\n                [(10e9, 10e3, 0),\n                 (11e9, 11e3, 5),\n                 (1e9, 1e3, 1.5)]]\n\n        for p1, p2, cell in args:\n            with pytest.raises(ValueError) as excinfo:\n                mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n            assert 'not an aggregate' in str(excinfo.value)\n\n    def test_cell_greater_than_domain(self):\n        p1 = (0, 0, 0)\n        p2 = (1e-9, 1e-9, 1e-9)\n        args = [(2e-9, 1e-9, 1e-9),\n                (1e-9, 2e-9, 1e-9),\n                (1e-9, 1e-9, 2e-9),\n                (1e-9, 5e-9, 0.1e-9)]\n\n        for cell in args:\n            with pytest.raises(ValueError) as excinfo:\n                mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n            assert 'not an aggregate' in str(excinfo.value)\n\n    def test_len(self):\n        p1 = (0, 0, 0)\n        p2 = (5, 4, 3)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        assert len(mesh) == 5*4*3\n\n    def test_indices_coordinates_iter(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        n = (5, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        check_mesh(mesh)\n\n        assert len(list(mesh.indices)) == 125\n        for index in mesh.indices:\n            assert isinstance(index, tuple)\n            assert len(index) == 3\n            assert all(isinstance(i, int) for i in index)\n            assert all([0 <= i <= 4 for i in index])\n\n        assert len(list(mesh)) == 125\n        for point in mesh:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert all(isinstance(i, numbers.Real) for i in point)\n            assert all([1 <= i <= 9 for i in point])\n\n    def test_eq(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (1, 1, 1)\n        mesh1 = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh1)\n        mesh2 = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh2)\n\n        assert mesh1 == mesh2\n        assert not mesh1 != mesh2\n        assert mesh1 != 1\n        assert not mesh2 == 'mesh2'\n\n        p1 = (0, 0, 0)\n        p2 = (10e-9, 5e-9, 3e-9)\n        cell = (1e-9, 2.5e-9, 0.5e-9)\n        mesh3 = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh3)\n\n        assert not mesh1 == mesh3\n        assert not mesh2 == mesh3\n        assert mesh1 != mesh3\n        assert mesh2 != mesh3\n\n    def test_repr(self):\n        p1 = (-1, -4, 11)\n        p2 = (15, 10.1, 12.5)\n        cell = (1, 0.1, 0.5)\n\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell, bc='x')\n        check_mesh(mesh)\n\n        rstr = ('Mesh(region=Region(p1=(-1.0, -4.0, 11.0), '\n                'p2=(15.0, 10.1, 12.5)), n=(16, 141, 3), '\n                'bc=\\'x\\', subregions={})')\n        assert repr(mesh) == rstr\n\n    def test_index2point(self):\n        p1 = (15, -4, 12.5)\n        p2 = (-1, 10.1, 11)\n        cell = (1, 0.1, 0.5)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        assert mesh.index2point((5, 10, 1)) == (4.5, -2.95, 11.75)\n\n        # Correct minimum index\n        assert isinstance(mesh.index2point((0, 0, 0)), tuple)\n        assert mesh.index2point((0, 0, 0)) == (-0.5, -3.95, 11.25)\n\n        # Below minimum index\n        with pytest.raises(ValueError):\n            mesh.index2point((-1, 0, 0))\n        with pytest.raises(ValueError):\n            mesh.index2point((0, -1, 0))\n        with pytest.raises(ValueError):\n            mesh.index2point((0, 0, -1))\n\n        # Correct maximum index\n        assert isinstance(mesh.index2point((15, 140, 2)), tuple)\n        assert mesh.index2point((15, 140, 2)) == (14.5, 10.05, 12.25)\n\n        # Above maximum index\n        with pytest.raises(ValueError):\n            mesh.index2point((16, 0, 0))\n        with pytest.raises(ValueError):\n            mesh.index2point((0, 141, 0))\n        with pytest.raises(ValueError):\n            mesh.index2point((0, 0, 3))\n\n    def test_point2index(self):\n        p1 = (-10e-9, -5e-9, 10e-9)\n        p2 = (10e-9, 5e-9, 0)\n        cell = (1e-9, 5e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        # (0, 0, 0) cell\n        assert mesh.point2index((-10e-9, -5e-9, 0)) == (0, 0, 0)\n        assert mesh.point2index((-9.5e-9, -2.5e-9, 0.5e-9)) == (0, 0, 0)\n        assert mesh.point2index((-9.01e-9, -0.1e-9, 0.9e-9)) == (0, 0, 0)\n\n        # (19, 1, 9) cell\n        assert mesh.point2index((10e-9, 5e-9, 10e-9)) == (19, 1, 9)\n        assert mesh.point2index((9.5e-9, 2.5e-9, 9.5e-9)) == (19, 1, 9)\n        assert mesh.point2index((9.1e-9, 0.1e-9, 9.1e-9)) == (19, 1, 9)\n\n        # vicinity of (0, 0, 0) point\n        assert mesh.point2index((1e-16, 1e-16, 0.99e-16)) == (10, 1, 0)\n        assert mesh.point2index((-1e-16, -1e-16, 0.01e-16)) == (9, 0, 0)\n\n        # Points outside the mesh.\n        p1 = (-10, 5, 0)\n        p2 = (10, -5, 10e-9)\n        n = (10, 5, 5)\n        mesh = df.Mesh(p1=p1, p2=p2, n=n)\n        check_mesh(mesh)\n\n        tol = 1e-12  # picometer tolerance\n        with pytest.raises(ValueError):\n            mesh.point2index((-10-tol, 0, 5))\n        with pytest.raises(ValueError):\n            mesh.point2index((-5, -5-tol, 5))\n        with pytest.raises(ValueError):\n            mesh.point2index((-5, 0, -tol))\n        with pytest.raises(ValueError):\n            mesh.point2index((10+tol, 0, 5))\n        with pytest.raises(ValueError):\n            mesh.point2index((6, 5+tol, 5))\n        with pytest.raises(ValueError):\n            mesh.point2index((0, 0, 10e-9+tol))\n\n    def test_index2point_point2index_mutually_inverse(self):\n        p1 = (15, -4, 12.5)\n        p2 = (-1, 10.1, 11)\n        cell = (1, 0.1, 0.5)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), cell=cell)\n        check_mesh(mesh)\n\n        for p in [(-0.5, -3.95, 11.25), (14.5, 10.05, 12.25)]:\n            assert mesh.index2point(mesh.point2index(p)) == p\n\n        for i in [(1, 0, 0), (0, 1, 0), (0, 0, 1), (1, 1, 1)]:\n            assert mesh.point2index(mesh.index2point(i)) == i\n\n    def test_neighbours(self):\n        p1 = (0, 0, 0)\n        p2 = (5, 3, 2)\n        n = (5, 3, 2)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n)\n\n        neighbours = mesh.neighbours((1, 1, 1))\n        assert isinstance(neighbours, list)\n        assert len(neighbours) == 5\n        assert (0, 1, 1) in neighbours\n        assert (2, 1, 1) in neighbours\n        assert (1, 0, 1) in neighbours\n        assert (1, 2, 1) in neighbours\n        assert (1, 1, 0) in neighbours\n\n        neighbours = mesh.neighbours((0, 0, 0))\n        assert isinstance(neighbours, list)\n        assert len(neighbours) == 3\n        assert (1, 0, 0) in neighbours\n        assert (0, 1, 0) in neighbours\n        assert (0, 0, 1) in neighbours\n\n        p1 = (0, 0, 0)\n        p2 = (5, 5, 5)\n        n = (5, 5, 5)\n        mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n, bc='xy')\n\n        neighbours = mesh.neighbours((0, 0, 0))\n        assert isinstance(neighbours, list)\n        assert len(neighbours) == 5\n        assert (4, 0, 0) in neighbours\n        assert (1, 0, 0) in neighbours\n        assert (0, 1, 0) in neighbours\n        assert (0, 4, 0) in neighbours\n        assert (0, 0, 1) in neighbours\n\n        neighbours = mesh.neighbours((4, 4, 4))\n        assert isinstance(neighbours, list)\n        assert len(neighbours) == 5\n        assert (3, 4, 4) in neighbours\n        assert (0, 4, 4) in neighbours\n        assert (4, 0, 4) in neighbours\n        assert (4, 3, 4) in neighbours\n        assert (4, 4, 3) in neighbours\n\n        with pytest.raises(ValueError):\n            neighbours = mesh.neighbours((10, 4, 4))\n\n    def test_line(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 10, 10)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        tol = 1e-12\n        line = mesh.line(p1=(0, 0, 0), p2=(10, 10, 10), n=10)\n        assert isinstance(line, types.GeneratorType)\n        assert len(list(line)) == 10\n        for point in line:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert all([0 <= i <= 10 for i in point])\n\n        line = list(mesh.line((0, 0, 0), (10, 0, 0), n=11))\n        assert len(line) == 11\n        assert line[0] == (0, 0, 0)\n        assert line[-1] == (10, 0, 0)\n        assert line[5] == (5, 0, 0)\n\n        with pytest.raises(ValueError):\n            line = list(mesh.line(p1=(-1e-9, 0, 0), p2=(10, 0, 0), n=100))\n\n        with pytest.raises(ValueError):\n            line = list(mesh.line(p1=(0, 0, 0), p2=(11, 0, 0), n=100))\n\n    def test_plane(self):\n        p1 = (0, 0, 0)\n        p2 = (10, 5, 3)\n        cell = (1, 1, 1)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        plane = mesh.plane(z=1, n=(2, 2))\n        check_mesh(plane)\n        assert isinstance(plane, df.Mesh)\n        assert len(list(plane)) == 4\n        for point in plane:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert point[2] == 1\n\n        plane = mesh.plane(y=4.2, n=(3, 2))\n        check_mesh(plane)\n        assert isinstance(plane, df.Mesh)\n        assert len(list(plane)) == 6\n        for point in plane:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert point[1] == 4.2\n\n        plane = mesh.plane('x')\n        check_mesh(plane)\n        assert isinstance(plane, df.Mesh)\n        assert len(list(plane)) == 15\n        for point in plane:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert point[0] == 5\n\n        plane = mesh.plane('y', n=(10, 10))\n        check_mesh(plane)\n        assert isinstance(plane, df.Mesh)\n        assert len(list(plane)) == 100\n        for point in plane:\n            assert isinstance(point, tuple)\n            assert len(point) == 3\n            assert point[1] == 2.5\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane(x=-1))\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane(y=6))\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane(z=-1e-9))\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane('x', z=1))\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane('z', z=1))\n\n        with pytest.raises(ValueError):\n            plane = list(mesh.plane(x=2, z=1))\n\n        info = mesh.plane('x').info\n        assert info['planeaxis'] == 0\n        assert info['axis1'] == 1\n        assert info['axis2'] == 2\n        assert info['point'] == 5\n\n        info = mesh.plane('y').info\n        assert info['planeaxis'] == 1\n        assert info['axis1'] == 0\n        assert info['axis2'] == 2\n        assert info['point'] == 2.5\n\n        info = mesh.plane('z').info\n        assert info['planeaxis'] == 2\n        assert info['axis1'] == 0\n        assert info['axis2'] == 1\n        assert info['point'] == 1.5\n\n        info = mesh.plane(x=0).info\n        assert info['planeaxis'] == 0\n        assert info['axis1'] == 1\n        assert info['axis2'] == 2\n        assert info['point'] == 0\n\n        info = mesh.plane(y=0).info\n        assert info['planeaxis'] == 1\n        assert info['axis1'] == 0\n        assert info['axis2'] == 2\n        assert info['point'] == 0\n\n        info = mesh.plane(z=0).info\n        assert info['planeaxis'] == 2\n        assert info['axis1'] == 0\n        assert info['axis2'] == 1\n        assert info['point'] == 0\n\n        info = mesh.plane(x=5).info\n        assert info['planeaxis'] == 0\n        assert info['axis1'] == 1\n        assert info['axis2'] == 2\n        assert info['point'] == 5\n\n        with pytest.raises(KeyError):\n            plane_mesh = mesh.plane('xy')\n        with pytest.raises(KeyError):\n            plane_mesh = mesh.plane('zy')\n        with pytest.raises(ValueError):\n            plane_mesh = mesh.plane('y', 'x')\n        with pytest.raises(KeyError):\n            plane_mesh = mesh.plane('xzy')\n        with pytest.raises(ValueError):\n            plane_mesh = mesh.plane('z', x=3)\n        with pytest.raises(ValueError):\n            plane_mesh = mesh.plane('y', y=5)\n        with pytest.raises(ValueError):\n            plane_mesh = mesh.plane('z', x=5)\n\n    def test_getitem(self):\n        p1 = (0, 0, 0)\n        p2 = (100, 50, 10)\n        cell = (5, 5, 5)\n        subregions = {'r1': df.Region(p1=(0, 0, 0), p2=(50, 50, 10)),\n                      'r2': df.Region(p1=(50, 0, 0), p2=(100, 50, 10))}\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n        check_mesh(mesh)\n\n        submesh1 = mesh['r1']\n        check_mesh(submesh1)\n        assert submesh1.region.pmin == (0, 0, 0)\n        assert submesh1.region.pmax == (50, 50, 10)\n        assert submesh1.cell == (5, 5, 5)\n\n        submesh2 = mesh['r2']\n        check_mesh(submesh2)\n        assert submesh2.region.pmin == (50, 0, 0)\n        assert submesh2.region.pmax == (100, 50, 10)\n        assert submesh2.cell == (5, 5, 5)\n\n        assert len(submesh1) + len(submesh2) == len(mesh)\n\n    def test_pad(self):\n        p1 = (-1, 2, 7)\n        p2 = (5, 9, 4)\n        cell = (1, 1, 1)\n        region = df.Region(p1=p1, p2=p2)\n        mesh = df.Mesh(region=region, cell=cell)\n\n        padded_mesh = mesh.pad({'x': (0, 1)})\n        assert padded_mesh.region.pmin == (-1, 2, 4)\n        assert padded_mesh.region.pmax == (6, 9, 7)\n        assert padded_mesh.n == (7, 7, 3)\n\n        padded_mesh = mesh.pad({'y': (1, 1)})\n        assert padded_mesh.region.pmin == (-1, 1, 4)\n        assert padded_mesh.region.pmax == (5, 10, 7)\n        assert padded_mesh.n == (6, 9, 3)\n\n        padded_mesh = mesh.pad({'z': (2, 3)})\n        assert padded_mesh.region.pmin == (-1, 2, 2)\n        assert padded_mesh.region.pmax == (5, 9, 10)\n        assert padded_mesh.n == (6, 7, 8)\n\n        padded_mesh = mesh.pad({'x': (1, 1), 'y': (1, 1), 'z': (1, 1)})\n        assert padded_mesh.region.pmin == (-2, 1, 3)\n        assert padded_mesh.region.pmax == (6, 10, 8)\n        assert padded_mesh.n == (8, 9, 5)\n\n    def test_mpl(self):\n        for p1, p2, n, cell in self.valid_args:\n            mesh = df.Mesh(region=df.Region(p1=p1, p2=p2), n=n, cell=cell)\n            mesh.mpl()\n\n            filename = 'figure.pdf'\n            with tempfile.TemporaryDirectory() as tmpdir:\n                tmpfilename = os.path.join(tmpdir, filename)\n                mesh.mpl(filename=tmpfilename)\n\n            plt.close('all')\n\n    def test_k3d(self):\n        for p1, p2, n, cell in self.valid_args:\n            mesh = df.Mesh(p1=p1, p2=p2, n=n, cell=cell)\n            mesh.k3d()\n            mesh.plane('x').k3d()\n\n    def test_k3d_mpl_subregions(self):\n        p1 = (0, 0, 0)\n        p2 = (100, 80, 10)\n        cell = (100, 5, 10)\n        subregions = {'r1': df.Region(p1=(0, 0, 0), p2=(100, 10, 10)),\n                      'r2': df.Region(p1=(0, 10, 0), p2=(100, 20, 10)),\n                      'r3': df.Region(p1=(0, 20, 0), p2=(100, 30, 10)),\n                      'r4': df.Region(p1=(0, 30, 0), p2=(100, 40, 10)),\n                      'r5': df.Region(p1=(0, 40, 0), p2=(100, 50, 10)),\n                      'r6': df.Region(p1=(0, 50, 0), p2=(100, 60, 10)),\n                      'r7': df.Region(p1=(0, 60, 0), p2=(100, 70, 10)),\n                      'r8': df.Region(p1=(0, 70, 0), p2=(100, 80, 10))}\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell, subregions=subregions)\n        mesh.mpl_subregions()\n        mesh.k3d_subregions()\n\n        plt.close('all')\n\n    def test_slider(self):\n        p1 = (-10e-9, -5e-9, 10e-9)\n        p2 = (10e-9, 5e-9, 0)\n        cell = (1e-9, 2.5e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        x_slider = mesh.slider('x')\n        assert isinstance(x_slider, ipywidgets.SelectionSlider)\n\n        y_slider = mesh.slider('y', multiplier=1)\n        assert isinstance(x_slider, ipywidgets.SelectionSlider)\n\n        z_slider = mesh.slider('z', multiplier=1e3)\n        assert isinstance(x_slider, ipywidgets.SelectionSlider)\n\n    def test_axis_selector(self):\n        p1 = (-10e-9, -5e-9, 10e-9)\n        p2 = (10e-9, 5e-9, 0)\n        cell = (1e-9, 2.5e-9, 1e-9)\n        mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n        check_mesh(mesh)\n\n        axis_widget = mesh.axis_selector()\n        assert isinstance(axis_widget, ipywidgets.Dropdown)\n\n        axis_widget = mesh.axis_selector(widget='radiobuttons')\n        assert isinstance(axis_widget, ipywidgets.RadioButtons)\n\n        axis_widget = mesh.axis_selector(description='something')\n        assert isinstance(axis_widget, ipywidgets.Dropdown)\n\n        with pytest.raises(ValueError):\n            axis_widget = mesh.axis_selector(widget='something')\n"""
discretisedfield/tests/test_ovf2vtk.py,2,"b""import os\nimport sys\nimport tempfile\nimport subprocess\nimport numpy as np\nimport discretisedfield as df\n\n\ndef test_ovf2vtk():\n    p1 = (0, 0, 0)\n    p2 = (10e-9, 7e-9, 2e-9)\n    cell = (1e-9, 1e-9, 1e-9)\n    mesh = df.Mesh(p1=p1, p2=p2, cell=cell)\n\n    def value_fun(point):\n        x, y, z = point\n        c = 1e9\n        return c*x, c*y, c*z\n\n    f = df.Field(mesh, dim=3, value=value_fun)\n\n    # Output filename provided.\n    omffilename = 'test-ovf2vtk1.omf'\n    vtkfilename = 'test-ovf2vtk1.vtk'\n    with tempfile.TemporaryDirectory() as tmpdir:\n        omftmpfilename = os.path.join(tmpdir, omffilename)\n        vtktmpfilename = os.path.join(tmpdir, vtkfilename)\n        f._writeovf(omftmpfilename, representation='bin8')\n\n        cmd = [sys.executable, '-m', 'discretisedfield.ovf2vtk',\n               '--input', omftmpfilename]\n        proc_return = subprocess.run(cmd)\n        assert proc_return.returncode == 0\n\n        f_read = df.Field.fromfile(vtktmpfilename)\n        assert np.allclose(f.array, f_read.array)\n\n    # Output filename not provided.\n    omffilename = 'test-ovf2vtk2.omf'\n    vtkfilename = 'test-ovf2vtk2.vtk'\n    with tempfile.TemporaryDirectory() as tmpdir:\n        omftmpfilename = os.path.join(tmpdir, omffilename)\n        vtktmpfilename = os.path.join(tmpdir, vtkfilename)\n        f._writeovf(omftmpfilename, representation='bin4')\n\n        cmd = [sys.executable, '-m', 'discretisedfield.ovf2vtk',\n               '-i', omftmpfilename]\n        proc_return = subprocess.run(cmd)\n        assert proc_return.returncode == 0\n\n        f_read = df.Field.fromfile(vtktmpfilename)\n        assert np.allclose(f.array, f_read.array)\n\n    # Number of input and output files do not match.\n    cmd = [sys.executable, '-m', 'discretisedfield.ovf2vtk',\n           '-i', 'file1.omf' 'file2.omf',\n           '-o', 'file1.vtk']\n    proc_return = subprocess.run(cmd)\n    assert proc_return.returncode != 0\n"""
discretisedfield/tests/test_region.py,5,"b""import os\nimport re\nimport pytest\nimport numbers\nimport tempfile\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport discretisedfield as df\nimport discretisedfield.util as dfu\n\n\ndef check_region(region):\n    assert isinstance(region.p1, tuple)\n    assert len(region.p1) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.p1)\n    assert region.p1 in region\n\n    assert isinstance(region.p2, tuple)\n    assert len(region.p2) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.p2)\n    assert region.p2 in region\n\n    assert isinstance(region.pmin, tuple)\n    assert len(region.pmin) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.pmin)\n    assert region.pmin in region\n\n    assert isinstance(region.pmax, tuple)\n    assert len(region.pmax) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.pmax)\n    assert region.pmax in region\n\n    assert isinstance(region.edges, tuple)\n    assert len(region.edges) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.edges)\n\n    assert isinstance(region.centre, tuple)\n    assert len(region.centre) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.centre)\n    assert region.centre in region\n\n    assert isinstance(region.random_point(), tuple)\n    assert len(region.random_point()) == 3\n    assert all(isinstance(i, numbers.Real) for i in region.random_point())\n    assert region.random_point() in region\n\n    assert isinstance(region.volume, float)\n\n    assert isinstance(repr(region), str)\n    pattern = r'^Region\\(p1=\\([\\d\\se.,-]+\\), p2=\\([\\d\\se.,-]+\\)\\)$'\n    assert re.search(pattern, repr(region))\n\n    assert region == region\n    assert not region != region\n    assert region != 2\n\n\nclass TestRegion:\n    def setup(self):\n        self.valid_args = [[(0, 0, 0), (5, 5, 5)],\n                           [(-1, 0, -3), (5, 7, 5)],\n                           [(0, 0, 0), (5e-9, 5e-9, 5e-9)],\n                           [(-1.5e-9, -5e-9, 0), (1.5e-9, -15e-9, -10e-9)],\n                           [(-1.5e-9, -5e-9, -5e-9), np.array((0, 0, 0))],\n                           [[0, 5e-6, 0], (-1.5e-6, -5e-6, -5e-6)],\n                           [(0, 125e-9, 0), (500e-9, 0, -3e-9)]]\n\n        self.invalid_args = [[('1', 0, 0), (1, 1, 1)],\n                             [(-1.5e-9, -5e-9, 'a'), (1.5e-9, 15e-9, 16e-9)],\n                             [(-1.5e-9, -5e-9, 0), (1.5e-9, 16e-9)],\n                             [(-1.5e-9, -5e-9, 0), (1.5e-9, 15e-9, 1+2j)],\n                             ['string', (5, 1, 1e-9)]]\n\n    def test_init_valid_args(self):\n        for p1, p2 in self.valid_args:\n            region = df.Region(p1=p1, p2=p2)\n            check_region(region)\n\n    def test_init_invalid_args(self):\n        for p1, p2 in self.invalid_args:\n            with pytest.raises((TypeError, ValueError)):\n                region = df.Region(p1=p1, p2=p2)  # Raised by descriptors.\n\n    def test_init_zero_edge_length(self):\n        args = [[(0, 100e-9, 1e-9), (150e-9, 100e-9, 6e-9)],\n                [(0, 101e-9, -1), (150e-9, 101e-9, 0)],\n                [(10e9, 10e3, 0), (0.01e12, 11e3, 5)]]\n\n        for p1, p2 in args:\n            with pytest.raises(ValueError) as excinfo:\n                region = df.Region(p1=p1, p2=p2)\n            assert 'is zero' in str(excinfo.value)\n\n    def test_pmin_pmax_edges_centre_volume(self):\n        p1 = (0, -4, 16.5)\n        p2 = (15, -6, 11)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n        assert region.pmin == (0, -6, 11)\n        assert region.pmax == (15, -4, 16.5)\n        assert region.edges == (15, 2, 5.5)\n        assert region.centre == (7.5, -5, 13.75)\n        assert region.volume == 165\n\n        p1 = (-10e6, 0, 0)\n        p2 = (10e6, 1e6, 1e6)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n        assert region.pmin == (-10e6, 0, 0)\n        assert region.pmax == (10e6, 1e6, 1e6)\n        assert region.edges == (20e6, 1e6, 1e6)\n        assert region.centre == (0, 0.5e6, 0.5e6)\n        assert abs(region.volume - 20 * (1e6)**3) < 1\n\n        p1 = (-18.5e-9, 10e-9, 0)\n        p2 = (10e-9, 5e-9, -10e-9)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n        assert np.allclose(region.pmin, (-18.5e-9, 5e-9, -10e-9))\n        assert np.allclose(region.pmax, (10e-9, 10e-9, 0))\n        assert np.allclose(region.edges, (28.5e-9, 5e-9, 10e-9))\n        assert np.allclose(region.centre, (-4.25e-9, 7.5e-9, -5e-9))\n        assert abs(region.volume - 1425 * (1e-9**3)) < 1e-30\n\n    def test_repr(self):\n        p1 = (-1, -4, 11)\n        p2 = (15, 10.1, 12.5)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n        rstr = 'Region(p1=(-1.0, -4.0, 11.0), p2=(15.0, 10.1, 12.5))'\n        assert repr(region) == rstr\n\n    def test_eq(self):\n        region1 = df.Region(p1=(0, 0, 0), p2=(10, 10, 10))\n        region2 = df.Region(p1=(0, 0, 0), p2=(10, 10, 10))\n        region3 = df.Region(p1=(3, 3, 3), p2=(10, 10, 10))\n\n        check_region(region1)\n        check_region(region2)\n        check_region(region3)\n        assert region1 == region2\n        assert not region1 != region2\n        assert region1 != region3\n        assert not region1 == region3\n\n    def test_contains(self):\n        p1 = (0, 10e-9, 0)\n        p2 = (10e-9, 0, 20e-9)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n        tol = 1e-18\n        assert (0, 0, 0) in region\n        assert (0-tol, 0, 0) not in region\n        assert (0, 0-tol, 0) not in region\n        assert (0, 0, 0-tol) not in region\n        assert (10e-9, 10e-9, 20e-9) in region\n        assert (10e-9+tol, 10e-9, 20e-9) not in region\n        assert (10e-9, 10e-9+tol, 20e-9) not in region\n        assert (10e-9, 10e-9, 20e-9+tol) not in region\n\n    def test_mpl(self):\n        p1 = (-50e-9, -50e-9, 0)\n        p2 = (50e-9, 50e-9, 20e-9)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n\n        # Check if runs.\n        region.mpl()\n        region.mpl(figsize=(10, 10), multiplier=1e-9,\n                   color=dfu.color_palette('deep', 10, 'rgb')[1],\n                   linewidth=3, linestyle='dashed')\n\n        filename = 'figure.pdf'\n        with tempfile.TemporaryDirectory() as tmpdir:\n            tmpfilename = os.path.join(tmpdir, filename)\n            region.mpl(filename=tmpfilename)\n\n        plt.close('all')\n\n    def test_k3d(self):\n        p1 = (-50e9, -50e9, 0)\n        p2 = (50e9, 50e9, 20e9)\n        region = df.Region(p1=p1, p2=p2)\n\n        check_region(region)\n\n        # Check if runs.\n        region.k3d()\n        region.k3d(multiplier=1e9,\n                   color=dfu.color_palette('deep', 10, 'int')[3],\n                   wireframe=True)\n"""
discretisedfield/tests/test_util.py,5,"b""import pytest\nimport numpy as np\nimport discretisedfield as df\nimport discretisedfield.util as dfu\n\n\ndef test_array2tuple():\n    dfu.array2tuple(np.array([1, 2, 3])) == (1, 2, 3)\n\n\ndef test_bergluescher_angle():\n    # 1/8 of the full angle\n    v1 = (1, 0, 0)\n    v2 = (0, 1, 0)\n    v3 = (0, 0, 1)\n\n    angle = dfu.bergluescher_angle(v1, v2, v3)\n    # CCW orientation\n    assert dfu.bergluescher_angle(v1, v2, v3) == 1/8\n    assert dfu.bergluescher_angle(v2, v3, v1) == 1/8\n    assert dfu.bergluescher_angle(v3, v1, v2) == 1/8\n    # CW orientation\n    assert dfu.bergluescher_angle(v3, v2, v1) == -1/8\n    assert dfu.bergluescher_angle(v2, v1, v3) == -1/8\n    assert dfu.bergluescher_angle(v1, v3, v2) == -1/8\n\n    # 0 of the full angle\n    v1 = (1, 0, 0)\n    v2 = (1, 0, 0)\n    v3 = (0, 0, 1)\n\n    angle = dfu.bergluescher_angle(v1, v2, v3)\n    assert dfu.bergluescher_angle(v1, v2, v3) == 0\n    assert dfu.bergluescher_angle(v2, v3, v1) == 0\n    assert dfu.bergluescher_angle(v3, v1, v2) == 0\n\n\ndef test_assemble_index():\n    index_dict = {0: 5, 1: 3, 2: 4}\n    assert dfu.assemble_index(0, 3, index_dict) == (5, 3, 4)\n    index_dict = {2: 4}\n    assert dfu.assemble_index(0, 3, index_dict) == (0, 0, 4)\n    index_dict = {1: 5, 2: 3, 0: 4}\n    assert dfu.assemble_index(0, 3, index_dict) == (4, 5, 3)\n    index_dict = {1: 3, 2: 4}\n    assert dfu.assemble_index(0, 4, index_dict) == (0, 3, 4, 0)\n\n\ndef test_voxels():\n    plot_array = np.ones((5, 6, 7))\n    pmin = (0, 0, 0)\n    pmax = (5e6, 6e6, 7e6)\n    color_palette = dfu.color_palette('cividis', 2, 'int')\n\n    dfu.voxels(plot_array, pmin, pmax, color_palette)\n\n\ndef test_points():\n    coordinates = np.array([(0, 0, 0)])\n    color = dfu.color_palette('cividis', 1, 'int')[0]\n    point_size = 2\n\n    dfu.points(coordinates, color, point_size)\n\n\ndef test_vectors():\n    coordinates = np.array([(0, 0, 0)])\n    vectors = np.array([(1, 1, 1)])\n    colors = [100]\n\n    dfu.vectors(coordinates, vectors, colors)\n"""
discretisedfield/util/__init__.py,0,"b'from .util import axesdict, raxesdict, cp_int, cp_hex, array2tuple, as_array, \\\n    bergluescher_angle, assemble_index, plot_line, plot_box, color_palette, \\\n    vtk_scalar_data, vtk_vector_data, normalise_to_range, k3d_parameters, \\\n    k3d_plot_region, k3d_setup_interactive_plot, voxels, points, vectors\n'"
discretisedfield/util/util.py,23,"b""import k3d\nimport cmath\nimport numbers\nimport collections\nimport numpy as np\nimport seaborn as sns\nimport ubermagutil.units as uu\nimport matplotlib.pyplot as plt\n\naxesdict = collections.OrderedDict(x=0, y=1, z=2)\nraxesdict = {value: key for key, value in axesdict.items()}\n\n# Color pallete as hex and int.\ncp_hex = ['#4c72b0', '#dd8452', '#55a868', '#c44e52', '#8172b3',\n          '#937860', '#da8bc3', '#8c8c8c', '#ccb974', '#64b5cd']\ncp_int = [5010096, 14517330, 5613672, 12865106, 8483507,\n          9664608, 14322627, 9211020, 13416820, 6600141]\n\n\ndef array2tuple(array):\n    if array.size == 1:\n        return array.item()\n    else:\n        return tuple(array.tolist())\n\n\ndef as_array(mesh, dim, val):\n    array = np.empty((*mesh.n, dim))\n    if isinstance(val, numbers.Real) and (dim == 1 or val == 0):\n        # The array for a scalar field with numbers.Real value or any\n        # field with zero value.\n        array.fill(val)\n    elif isinstance(val, (tuple, list, np.ndarray)) and len(val) == dim:\n        array[..., :] = val\n    elif isinstance(val, np.ndarray) and val.shape == array.shape:\n        array = val\n    elif callable(val):\n        for index, point in zip(mesh.indices, mesh):\n            array[index] = val(point)\n    elif isinstance(val, dict) and mesh.subregions:\n        for index, point in zip(mesh.indices, mesh):\n            for region in mesh.subregions.keys():\n                if point in mesh.subregions[region]:\n                    array[index] = val[region]\n                    break\n    else:\n        msg = f'Unsupported {type(val)} or invalid value dimensions.'\n        raise ValueError(msg)\n    return array\n\n\ndef bergluescher_angle(v1, v2, v3):\n    if np.dot(v1, np.cross(v2, v3)) == 0:\n        # If the triple product is zero, then rho=0 and division by zero is\n        # encountered. In this case, all three vectors are in-plane and the\n        # space angle is zero.\n        return 0.0\n    else:\n        rho = (2 *\n               (1 + np.dot(v1, v2)) *\n               (1 + np.dot(v2, v3)) *\n               (1 + np.dot(v3, v1)))**0.5\n\n        numerator = (1 +\n                     np.dot(v1, v2) +\n                     np.dot(v2, v3) +\n                     np.dot(v3, v1) +\n                     1j*(np.dot(v1, np.cross(v2, v3))))\n\n        exp_omega = numerator/rho\n\n        return 2 * cmath.log(exp_omega).imag / (4*np.pi)\n\n\ndef assemble_index(value, n, dictionary):\n    index = [value, ] * n\n    for key, value in dictionary.items():\n        index[key] = value\n\n    return tuple(index)\n\n\ndef vtk_scalar_data(field, name):\n    header = [f'SCALARS {name} double',\n              'LOOKUP_TABLE default']\n    data = [str(value) for point, value in field]\n\n    return header + data\n\n\ndef vtk_vector_data(field, name):\n    header = [f'VECTORS {name} double']\n    data = ['{} {} {}'.format(*value) for point, value in field]\n\n    return header + data\n\n\ndef plot_line(ax, p1, p2, *args, **kwargs):\n    ax.plot(*zip(p1, p2), *args, **kwargs)\n\n\ndef plot_box(ax, pmin, pmax, *args, **kwargs):\n    x1, y1, z1 = pmin\n    x2, y2, z2 = pmax\n\n    plot_line(ax, (x1, y1, z1), (x2, y1, z1), *args, **kwargs)\n    plot_line(ax, (x1, y2, z1), (x2, y2, z1), *args, **kwargs)\n    plot_line(ax, (x1, y1, z2), (x2, y1, z2), *args, **kwargs)\n    plot_line(ax, (x1, y2, z2), (x2, y2, z2), *args, **kwargs)\n\n    plot_line(ax, (x1, y1, z1), (x1, y2, z1), *args, **kwargs)\n    plot_line(ax, (x2, y1, z1), (x2, y2, z1), *args, **kwargs)\n    plot_line(ax, (x1, y1, z2), (x1, y2, z2), *args, **kwargs)\n    plot_line(ax, (x2, y1, z2), (x2, y2, z2), *args, **kwargs)\n\n    plot_line(ax, (x1, y1, z1), (x1, y1, z2), *args, **kwargs)\n    plot_line(ax, (x2, y1, z1), (x2, y1, z2), *args, **kwargs)\n    plot_line(ax, (x1, y2, z1), (x1, y2, z2), *args, **kwargs)\n    plot_line(ax, (x2, y2, z1), (x2, y2, z2), *args, **kwargs)\n\n\ndef color_palette(cmap, n, value_type):\n    cp = sns.color_palette(palette=cmap, n_colors=n)\n    if value_type == 'rgb':\n        return cp\n    else:\n        return list(map(lambda c: int(c[1:], 16), cp.as_hex()))\n\n\ndef normalise_to_range(values, value_range):\n    values = np.array(values)\n\n    values -= values.min()  # min value is 0\n    # For uniform fields, avoid division by zero.\n    if values.max() != 0:\n        values /= values.max()  # all values in (0, 1)\n    values *= (value_range[1] - value_range[0])  # all values in (0, r[1]-r[0])\n    values += value_range[0]  # all values is range (r[0], r[1])\n    values = values.round()\n    values = values.astype(int)\n\n    return values\n\n\ndef k3d_parameters(plot, multiplier, value):\n    if plot is None:\n        plot = k3d.plot()\n        plot.display()\n\n    if multiplier is None:\n        multiplier = uu.si_max_multiplier(value)\n\n    unit = f' ({uu.rsi_prefixes[multiplier]}m)'\n    plot.axes = [i + unit for i in 'xyz']\n\n    return plot, multiplier\n\n\ndef k3d_plot_region(plot, region, multiplier):\n    if not plot.objects:  # if plot was not displayed (interactive plotting)\n        plot += voxels(np.ones((1, 1, 1)),\n                       pmin=region.pmin,\n                       pmax=region.pmax,\n                       color_palette=color_palette('deep', 1, 'int')[0],\n                       multiplier=multiplier,\n                       opacity=0.025)\n\n\ndef k3d_setup_interactive_plot(plot):\n    # Delete all objects except the field region.\n    for object in plot.objects[1:]:\n        plot -= object\n\n    # Make sure the camera and grid do not move in interactive plots. If\n    # the plot is not displayed (plot.outputs==[]), it will be displayed.\n    if not plot.outputs:\n        plot.display()\n        plot.camera_auto_fit = False\n        plot.grid_auto_fit = False\n\n\ndef voxels(plot_array, pmin, pmax, color_palette, multiplier=1, outlines=False,\n           **kwargs):\n    plot_array = plot_array.astype(np.uint8)  # to avoid k3d warning\n\n    bounds = [i for zl in zip(np.divide(pmin, multiplier),\n                              np.divide(pmax, multiplier)) for i in zl]\n\n    return k3d.voxels(plot_array, color_map=color_palette, bounds=bounds,\n                      outlines=outlines, **kwargs)\n\n\ndef points(coordinates, color, point_size, multiplier=1, **kwargs):\n    coordinates = coordinates.astype(np.float32)  # to avoid k3d warning\n\n    coordinates = np.divide(coordinates, multiplier)\n\n    return k3d.points(coordinates, point_size=point_size,\n                      color=color, **kwargs)\n\n\ndef vectors(coordinates, vectors, colors=[], multiplier=1, vector_multiplier=1,\n            **kwargs):\n    coordinates = coordinates.astype(np.float32)  # to avoid k3d warning\n    vectors = vectors.astype(np.float32)  # to avoid k3d warning\n\n    coordinates = np.divide(coordinates, multiplier)\n    vectors = np.divide(vectors, vector_multiplier)\n\n    # Plot middle of the arrow is at the cell centre.\n    coordinates = coordinates - 0.5*vectors\n\n    return k3d.vectors(coordinates, vectors, colors=colors, **kwargs)\n"""
