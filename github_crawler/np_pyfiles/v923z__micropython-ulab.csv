file_path,api_count,code
tests/00smoke.py,0,b'import ulab\nprint(ulab.eye(3))\n'
tests/argminmax.py,0,"b'import ulab\n\n# Adapted from https://docs.python.org/3.8/library/itertools.html#itertools.permutations\ndef permutations(iterable, r=None):\n    # permutations(\'ABCD\', 2) --> AB AC AD BA BC BD CA CB CD DA DB DC\n    # permutations(range(3)) --> 012 021 102 120 201 210\n    pool = tuple(iterable)\n    n = len(pool)\n    r = n if r is None else r\n    if r > n:\n        return\n    indices = list(range(n))\n    cycles = list(range(n, n-r, -1))\n    yield tuple(pool[i] for i in indices[:r])\n    while n:\n        for i in reversed(range(r)):\n            cycles[i] -= 1\n            if cycles[i] == 0:\n                indices[i:] = indices[i+1:] + indices[i:i+1]\n                cycles[i] = n - i\n            else:\n                j = cycles[i]\n                indices[i], indices[-j] = indices[-j], indices[i]\n                yield tuple(pool[i] for i in indices[:r])\n                break\n        else:\n            return\n\n# Combinations expected to throw\ntry:\n    print(ulab.numerical.argmin([]))\nexcept ValueError:\n    print(""ValueError"")\n\ntry:\n    print(ulab.numerical.argmax([]))\nexcept ValueError:\n    print(""ValueError"")\n\n# Combinations expected to succeed\nprint(ulab.numerical.argmin([1]))\nprint(ulab.numerical.argmax([1]))\nprint(ulab.numerical.argmin(ulab.array([1])))\nprint(ulab.numerical.argmax(ulab.array([1])))\n\nprint()\nprint(""max tests"")\nfor p in permutations((100,200,300)):\n    m1 = ulab.numerical.argmax(p)\n    m2 = ulab.numerical.argmax(ulab.array(p))\n    print(p, m1, m2)\n    if m1 != m2 or p[m1] != max(p):\n        print(""FAIL"", p, m1, m2, max(p))\n\nprint()\nprint(""min tests"")\nfor p in permutations((100,200,300)):\n    m1 = ulab.numerical.argmin(p)\n    m2 = ulab.numerical.argmin(ulab.array(p))\n    print(p, m1, m2)\n    if m1 != m2 or p[m1] != min(p):\n        print(""FAIL"", p, m1, m2, min(p))\n'"
tests/cholesky.py,0,"b'import ulab\nfrom ulab import linalg\n\na = ulab.array([[1, 2], [2, 5]])\nprint(linalg.cholesky(a))\n\nb = a = ulab.array([[25, 15, -5], [15, 18,  0], [-5,  0, 11]])\nprint(linalg.cholesky(b))\n\nc = ulab.array([[18, 22,  54,  42], [22, 70,  86,  62], [54, 86, 174, 134], [42, 62, 134, 106]])\nprint(linalg.cholesky(c))\n\n# this throw a ValueError exception\nd = ulab.array([[25, 15, -5], [15, 18,  0], [-5,  0, 1]])\n\n\n\n'"
tests/compare.py,0,"b'import ulab\nfrom ulab import compare\n\na = ulab.array([1, 2, 3, 4, 5], dtype=ulab.uint8)\nb = ulab.array([5, 4, 3, 2, 1], dtype=ulab.float)\nprint(compare.minimum(a, b))\nprint(compare.maximum(a, b))\nprint(compare.maximum(1, 5.5))\n\na = ulab.array(range(9), dtype=ulab.uint8)\nprint(compare.clip(a, 3, 7))\n\nb = 3 * ulab.ones(len(a), dtype=ulab.float)\nprint(compare.clip(a, b, 7))\n'"
tests/constructors.py,0,"b'from ulab import linalg\nimport ulab\nprint(ulab.ones(3))\nprint(ulab.ones((2,3)))\nprint(ulab.zeros(3))\nprint(ulab.zeros((2,3)))\nprint(ulab.eye(3))\nprint(ulab.ones(1, dtype=ulab.int8))\nprint(ulab.ones(2, dtype=ulab.uint8))\nprint(ulab.ones(3, dtype=ulab.int16))\nprint(ulab.ones(4, dtype=ulab.uint16))\nprint(ulab.ones(5, dtype=ulab.float))\nprint(ulab.linspace(0, 1, 9))\n'"
tests/linalg.py,0,"b'import ulab\nfrom ulab import linalg\n\na = ulab.array([[1, 2], [3, 4]])\nprint(linalg.inv(a))\n\nb = ulab.array([[1, 2, 3], [4, 5, 6], [7, 8, 7]])\nprint(linalg.inv(b))\n\nc = ulab.array([[1, 2, 0, 0], [0, 6, 7, 0], [0, 0, 8, 9], [0, 0, 15, 13]])\nprint(linalg.inv(c))\n\nprint(linalg.det(a))\nprint(linalg.det(b))\nprint(linalg.det(c))\n\n\n'"
tests/operators.py,0,b'import ulab\na = ulab.ones(3)\nprint(a+a)\nprint(a-a)\nprint(a*a)\nprint(a/a)\nprint(a+2)\nprint(a-2)\nprint(a*2)\nprint(a/2)\nprint(a<1)\nprint(a<2)\nprint(a<=0)\nprint(a<=1)\nprint(a>1)\nprint(a>2)\nprint(a>=0)\nprint(a>=1)\n#print(a==0)  # These print just true or false.  Is it right?  is it a micropython limitation?\n#print(a==1)\n'
tests/poly.py,0,"b'import ulab\nfrom ulab import poly\nfrom ulab import vector\n\n# polynom evaluation\nx = ulab.linspace(0, 10, num=9)\np = [1, 2, 3]\ny = poly.polyval(p, x)\nprint(y)\n\n# linear fit\nx = ulab.linspace(-5, 5, num=11)\ny = x + vector.sin(x)\np = poly.polyfit(x, y, 1)\nprint(p)\n\n# quadratic fit\nx = ulab.linspace(-5, 5, num=11)\ny = x*x + vector.sin(x)*3.0\np = poly.polyfit(x, y, 2)\nprint(p)\n\n# cubic fit\nx = ulab.linspace(-5, 5, num=11)\ny = x*x*x + vector.sin(x)*10.0\np = poly.polyfit(x, y, 3)\nprint(p)\n'"
tests/slicing.py,2,"b'try:\n    import ulab as np\nexcept:\n    import numpy as np\n\nfor num in range(1,4):\n    for start in range(-num, num+1):\n        for end in range(-num, num+1):\n            for stride in (-3, -2, -1, 1, 2, 3):\n                l = list(range(num))\n                a = np.array(l, dtype=np.int8)\n                sl = l[start:end:stride]\n                ll = len(sl)\n                try:\n                    sa = list(a[start:end:stride])\n                    la = len(sa)\n                except IndexError as e:\n                    sa = str(e)\n                    la = -1\n                print(""%2d [% d:% d:% d]     %-24r %-24r%s"" % (\n                    num, start, end, stride, sl, sa, "" ***"" if sa != sl else """"))\n\n                a[start:end:stride] = np.ones(len(sl)) * -1\n                print(""%2d [% d:% d:% d]     %r"" % (\n                    num, start, end, stride, list(a)))\n'"
tests/slicing2.py,1,"b'try:\n    import ulab as np\nexcept:\n    import numpy as np\n\na = np.array(range(9), dtype=np.float)\nprint(""a:\\t"", list(a))\nprint(""a < 5:\\t"", list(a[a < 5]))\n'"
docs/manual/source/conf.py,0,"b'# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath(\'.\'))\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \'micropython-ulab\'\ncopyright = \'2019-2020, Zolt\xc3\xa1n V\xc3\xb6r\xc3\xb6s\'\nauthor = \'Zolt\xc3\xa1n V\xc3\xb6r\xc3\xb6s\'\n\n# The full version, including alpha/beta/rc tags\nrelease = \'0.50.0\'\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = []\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\nmaster_doc = \'index\'\n\nauthor=u\'Zolt\xc3\xa1n V\xc3\xb6r\xc3\xb6s\'\ncopyright=author\nlanguage=\'en\'\n\nlatex_documents = [\n(master_doc, \'ulab-manual.tex\', \'Micropython ulab documentation\', \n\'Zolt\xc3\xa1n V\xc3\xb6r\xc3\xb6s\', \'manual\'),\n]\n   \n'"
