file_path,api_count,code
bench/numpy_bench.py,13,"b""#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Roughly based on: https://gist.github.com/fede-vaccaro/ac737942e233cc31ffb404bb928ee6cf\n# Logistic regression code from https://github.com/chrismcg/machine_learning_ng\n\nfrom __future__ import print_function\n\nimport numpy as np\nfrom time import time\n\nsize = 3000\nA, B = np.random.random((size, size)).astype('float32'), np.random.random((size, size)).astype('float32')\n\ntheta_t = np.array(range(0, 401)).reshape((401, 1))\nX_t = np.c_[np.ones((5000, 1)), np.array(range(0, 2000000)).reshape((5000, 400), order='F') / 10]\ny_t = np.random.randint(2, size=5000).reshape(5000, 1)\nlambda_t = 3\n\ndef sigmoid(x):\n  return 1 / (1 + np.exp(-x))\n\ndef logistic_cost(theta, x, y, reg_lambda):\n    m = y.size\n    # ensure it's a vector not an array for dot with reshape below\n    h = sigmoid(x.dot(theta.reshape((theta.size, 1))))\n\n    y_transpose = y.transpose()\n    j = (-y_transpose.dot(np.log(h)) - ((1 - y_transpose).dot(np.log(1 - h)))) / m\n\n    regularization = (reg_lambda / (2 * m)) * (theta[1:] ** 2).sum()\n    j = j + regularization\n\n    gradients = (x.transpose().dot(h - y)) / m\n    temp = theta.copy().reshape((theta.size, 1))\n    temp[0] = 0\n    gradients = gradients + ((reg_lambda / m) * temp)\n\n    return (j[0][0], gradients.flatten())\n\n\nprint('benchmark\\titerations\\taverage time')\n\n# Logistic regression cost function\nN = 1000\nt = time()\nfor i in range(N):\n    logistic_cost(theta_t, X_t, y_t, lambda_t)\ndelta = time() - t\nprint('logistic_cost()\\t%d\\t%0.2f ms/op' % (N, delta * 1000.0 / N))\n\n# Matrix dot\nN = 20\nt = time()\nfor i in range(N):\n    np.dot(A, B)\ndelta = time() - t\nprint('np.dot(A, B)\\t%d\\t%0.2f ms/op' % (N, delta * 1000.0 / N))\n\n# Matrix divison\nN = 100\nt = time()\nfor i in range(N):\n    np.divide(A, B)\ndelta = time() - t\nprint('np.divide(A, B)\\t%d\\t%0.2f ms/op' % (N, delta * 1000.0 / N))\n\n# Matrix addition\nN = 100\nt = time()\nfor i in range(N):\n    np.add(A, B)\ndelta = time() - t\nprint('np.add(A, B)\\t%d\\t%0.2f ms/op' % (N, delta * 1000.0 / N))\n\n# Sigmoid of matrix\nN = 50\nt = time()\nfor i in range(N):\n    sigmoid(A)\ndelta = time() - t\nprint('sigmoid(A)\\t%d\\t%0.2f ms/op' % (N, delta * 1000.0 / N))\n\n\n\n\n\n\nprint('')\nprint('This was obtained using the following Numpy configuration:')\nnp.__config__.show()\n"""
