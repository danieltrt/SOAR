file_path,api_count,code
recommendationSystem.py,4,"b'# coding: utf-8\n\n# # Assignment 3:  Recommendation systems\n#\n# Here we\'ll implement a content-based recommendation algorithm.\n# It will use the list of genres for a movie as the content.\n# The data come from the MovieLens project: http://grouplens.org/datasets/movielens/\n\n# Please only use these imports.\nfrom collections import Counter, defaultdict\nimport math\nimport numpy as np\nimport os\nimport pandas as pd\nimport re\nfrom scipy.sparse import csr_matrix\nimport urllib.request\nimport zipfile\n\ndef download_data():\n    """""" DONE. Download and unzip data.\n    """"""\n    url = \'https://www.dropbox.com/s/h9ubx22ftdkyvd5/ml-latest-small.zip?dl=1\'\n    urllib.request.urlretrieve(url, \'ml-latest-small.zip\')\n    zfile = zipfile.ZipFile(\'ml-latest-small.zip\')\n    zfile.extractall()\n    zfile.close()\n\n\ndef tokenize_string(my_string):\n    """""" DONE. You should use this in your tokenize function.\n    """"""\n    return re.findall(\'[\\w\\-]+\', my_string.lower())\n\n\ndef tokenize(movies):\n    """"""\n    Append a new column to the movies DataFrame with header \'tokens\'.\n    This will contain a list of strings, one per token, extracted\n    from the \'genre\' field of each movie. Use the tokenize_string method above.\n\n    Note: you may modify the movies parameter directly; no need to make\n    a new copy.\n    Params:\n      movies...The movies DataFrame\n    Returns:\n      The movies DataFrame, augmented to include a new column called \'tokens\'.\n\n    >>> movies = pd.DataFrame([[123, \'Horror|Romance\'], [456, \'Sci-Fi\']], columns=[\'movieId\', \'genres\'])\n    >>> movies = tokenize(movies)\n    >>> movies[\'tokens\'].tolist()\n    [[\'horror\', \'romance\'], [\'sci-fi\']]\n    """"""\n    tokenlist=[]\n    for index,row in movies.iterrows():\n        tokenlist.append(tokenize_string(row.genres))\n    movies[\'tokens\']=tokenlist\n    return movies\n\ndef featurize(movies):\n    """"""\n    Append a new column to the movies DataFrame with header \'features\'.\n    Each row will contain a csr_matrix of shape (1, num_features). Each\n    entry in this matrix will contain the tf-idf value of the term, as\n    defined in class:\n    tfidf(i, d) := tf(i, d) / max_k tf(k, d) * log10(N/df(i))\n    where:\n    i is a term\n    d is a document (movie)\n    tf(i, d) is the frequency of term i in document d\n    max_k tf(k, d) is the maximum frequency of any term in document d\n    N is the number of documents (movies)\n    df(i) is the number of unique documents containing term i\n\n    Params:\n      movies...The movies DataFrame\n    Returns:\n      A tuple containing:\n      - The movies DataFrame, which has been modified to include a column named \'features\'.\n      - The vocab, a dict from term to int. Make sure the vocab is sorted alphabetically as in a2 (e.g., {\'aardvark\': 0, \'boy\': 1, ...})\n    """"""\n    def tf(word,doc):\n        return doc.count(word) / Counter(doc).most_common()[0][1]\n\n    def df(word, doclist):\n        return sum(1 for d in doclist if word in d)\n\n    def tfidf(word, doc, dfdict, N):\n        return tf(word, doc) * math.log10((N/dfdict[word]))\n\n    def getcsrmatrix(tokens,dfdict,N,vocab):\n        matrixRow_list = []\n        matrixRow_list = np.zeros((1,len(vocab)),dtype=\'float\')\n        for t in tokens:\n            if t in vocab:\n                matrixRow_list[0][vocab[t]] = tfidf(t,tokens,dfdict,N)\n        return csr_matrix(matrixRow_list)\n\n    N=len(movies)\n    doclist = movies[\'tokens\'].tolist()\n    vocab = { i:x for x,i in enumerate(sorted(list(set(i for s in doclist for i in s)))) }\n\n    dfdict = {}\n    for v in vocab.items():\n        dfdict[v[0]] = df(v[0],doclist)\n\n    csrlist = []\n    for index, row in movies.iterrows():\n         csrlist.append(getcsrmatrix(row[\'tokens\'],dfdict,N,vocab))\n\n    movies[\'features\'] =  csrlist\n    return (movies,vocab)\n\n\ndef train_test_split(ratings):\n    """"""DONE.\n    Returns a random split of the ratings matrix into a training and testing set.\n    """"""\n    test = set(range(len(ratings))[::1000])\n    train = sorted(set(range(len(ratings))) - test)\n    test = sorted(test)\n    return ratings.iloc[train], ratings.iloc[test]\n\n\ndef cosine_sim(a, b):\n    """"""\n    Compute the cosine similarity between two 1-d csr_matrices.\n    Each matrix represents the tf-idf feature vector of a movie.\n    Params:\n      a...A csr_matrix with shape (1, number_features)\n      b...A csr_matrix with shape (1, number_features)\n    Returns:\n      The cosine similarity, defined as: dot(a, b) / ||a|| * ||b||\n      where ||a|| indicates the Euclidean norm (aka L2 norm) of vector a.\n    """"""\n    v1 = a.toarray()[0]\n    v2  = b.toarray()[0]\n    return sum(i[0] * i[1] for i in zip(v1, v2))/(math.sqrt(sum([i*i for i in v1]))*math.sqrt(sum([i*i for i in v2])))\n\ndef make_predictions(movies, ratings_train, ratings_test):\n    """"""\n    Using the ratings in ratings_train, predict the ratings for each\n    row in ratings_test.\n\n    To predict the rating of user u for movie i: Compute the weighted average\n    rating for every other movie that u has rated.  Restrict this weighted\n    average to movies that have a positive cosine similarity with movie\n    i. The weight for movie m corresponds to the cosine similarity between m\n    and i.\n\n    If there are no other movies with positive cosine similarity to use in the\n    prediction, use the mean rating of the target user in ratings_train as the\n    prediction.\n\n    Params:\n      movies..........The movies DataFrame.\n      ratings_train...The subset of ratings used for making predictions. These are the ""historical"" data.\n      ratings_test....The subset of ratings that need to predicted. These are the ""future"" data.\n    Returns:\n      A numpy array containing one predicted rating for each element of ratings_test.\n    """"""\n    result = []\n    for index,row in ratings_test.iterrows():\n        mlist = list(ratings_train.loc[ratings_train[\'userId\'] == row[\'userId\']][\'movieId\'])\n        csrlist = list(movies.loc[movies[\'movieId\'].isin(mlist)][\'features\'])\n        mrlist = list(ratings_train.loc[ratings_train[\'userId\'] ==row[\'userId\']][\'rating\'])\n        cmlist = [cosine_sim(c,movies.loc[movies[\'movieId\'] ==row[\'movieId\']][\'features\'].values[0]) for c in csrlist]\n        wan = sum([ v*mrlist[i] for i,v in enumerate(cmlist) if v>0 ])\n        wadlist = [i for i in cmlist if i>0]\n        if (len(wadlist)>0):\n            result.append(wan/sum(wadlist))\n        else:\n            result.append(np.mean(mrlist))\n    return np.array(result)\n\ndef mean_absolute_error(predictions, ratings_test):\n    """"""DONE.\n    Return the mean absolute error of the predictions.\n    """"""\n    return np.abs(predictions - np.array(ratings_test.rating)).mean()\n\n\ndef main():\n    download_data()\n    path = \'ml-latest-small\'\n    ratings = pd.read_csv(path + os.path.sep + \'ratings.csv\')\n    movies = pd.read_csv(path + os.path.sep + \'movies.csv\')\n    movies = tokenize(movies)\n    movies, vocab = featurize(movies)\n    print(\'vocab:\')\n    print(sorted(vocab.items())[:10])\n    ratings_train, ratings_test = train_test_split(ratings)\n    print(\'%d training ratings; %d testing ratings\' % (len(ratings_train), len(ratings_test)))\n    predictions = make_predictions(movies, ratings_train, ratings_test)\n    print(\'error=%f\' % mean_absolute_error(predictions, ratings_test))\n    print(predictions[:10])\n\n\nif __name__ == \'__main__\':\n    main()\n'"
