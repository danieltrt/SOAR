file_path,api_count,code
setup.py,1,"b""from setuptools import setup, Extension\nfrom setuptools.command.build_ext import build_ext\nfrom Cython.Build import cythonize\nfrom glob import glob\nfrom os.path import join\nfrom subprocess import call\nimport os\nimport sys\n\nVERSION = '0.4.6'\n\ndef to_bool(val):\n    if not val:\n        val = 0\n    else:\n        try:\n            val = int(val)\n        except:\n            val = 1\n    return bool(val)\n\n# numpy support is optional\nUSE_NUMPY = to_bool(os.environ.get('USE_NUMPY', '1'))\n# cysignals support is optional too\nUSE_CYSIGNALS = to_bool(os.environ.get('USE_CYSIGNALS', '1'))\nif sys.platform == 'win32':\n    USE_CYSIGNALS = False\n\n# if the module is being installed from pip using bdist_wheel or egg_info\n# make sure cysignals is installed before compiling\nif USE_CYSIGNALS and 'bdist_wheel' in sys.argv or 'egg_info' in sys.argv:\n    try:\n        import cysignals\n    except ImportError:\n        ret = call([sys.executable, '-m', 'pip', 'install', 'cysignals'])\n        if ret:\n            raise RuntimeError('cannot install cysignals with pip')\n\ndef get_fasttext_commit_hash():\n    try:\n        with open('.git/modules/fastText/HEAD', 'r') as f:\n            return f.read().strip()\n    except:\n        return 'unknown'\n\ninclude_dirs = ['.', 'src/variant/include', 'src']\nsetup_requires = []\ninstall_requires = ['future', 'cysignals']\n\nif USE_NUMPY:\n    setup_requires.append('numpy')\n    install_requires.append('numpy')\n\ncpp_dir = join('src', 'fastText', 'src')\n\nsources = ['src/pyfasttext.pyx', 'src/fasttext_access.cpp']\n# add all the fasttext source files except main.cc\nsources.extend(set(glob(join(cpp_dir, '*.cc'))).difference(set([join(cpp_dir, 'main.cc')])))\n\n# exit() replacement does not work when we use extra_compile_args\nos.environ['CFLAGS'] = '-iquote . -include src/custom_exit.h'\n\nclass BuildExt(build_ext):\n    def build_extensions(self):\n        extra_compile_args = self.extensions[0].extra_compile_args\n        if 'clang' in self.compiler.compiler[0]:\n            extra_compile_args.append('-std=c++1z')\n        else:\n            extra_compile_args.append('-std=c++0x')\n        build_ext.build_extensions(self)\n\n    def finalize_options(self):\n        build_ext.finalize_options(self)\n        # prevent numpy from thinking it is still in its setup process\n        if USE_NUMPY:\n            __builtins__.__NUMPY_SETUP__ = False\n            import numpy as np\n            self.include_dirs.append(np.get_include())\n\nextension = Extension(\n    'pyfasttext',\n    sources=sources,\n    libraries=['pthread'],\n    include_dirs=include_dirs,\n    language='c++',\n    extra_compile_args=['-Wno-sign-compare'])\n\nsetup(name='pyfasttext',\n      version=VERSION,\n      author='Vincent Rasneur',\n      author_email='vrasneur@free.fr',\n      url='https://github.com/vrasneur/pyfasttext',\n      download_url='https://github.com/vrasneur/pyfasttext/releases/download/%s/pyfasttext-%s.tar.gz' % (VERSION, VERSION),\n      description='Yet another Python binding for fastText',\n      long_description=open('README.rst', 'r').read(),\n      license='GPLv3',\n      package_dir={'': 'src'},\n      ext_modules=cythonize([extension], compile_time_env={'USE_NUMPY': USE_NUMPY,\n                                                           'USE_CYSIGNALS': USE_CYSIGNALS,\n                                                           'VERSION': VERSION,\n                                                           'FASTTEXT_VERSION': get_fasttext_commit_hash()}),\n      setup_requires=setup_requires,\n      install_requires=install_requires,\n      cmdclass={'build_ext': BuildExt},\n      classifiers=[\n          'Development Status :: 3 - Alpha',\n          'Intended Audience :: Developers',\n          'Intended Audience :: Science/Research',\n          'License :: OSI Approved :: GNU General Public License v3 (GPLv3)',\n          'Operating System :: POSIX',\n          'Programming Language :: C++',\n          'Programming Language :: Cython',\n          'Programming Language :: Python :: 2.6',\n          'Programming Language :: Python :: 2.7',\n          'Programming Language :: Python :: 3',\n          'Topic :: Scientific/Engineering :: Artificial Intelligence'\n      ])\n"""
examples/bayesopt_search_cont.py,2,"b""#!/usr/bin/env python3\n\nfrom collections import OrderedDict, namedtuple\n\nimport numpy as np\nimport bayesopt\n\nfrom sklearn.metrics import f1_score\nfrom pyfasttext import FastText\n\nclass FastTextBayesOpt(object):\n    TRAIN_PATH = '/path/to/dataset.train'\n    VALID_PATH = '/path/to/dataset.valid'\n    TEST_PATH = '/path/to/dataset.test'\n    VECTORS_PATH = '/path/to/unsupmodel.vec'\n    MODEL_PATH = '/path/to/supmodel'\n    \n    def __init__(self, noisy=False, metrics_fun=None, verbose=True):\n        self.noisy = noisy\n        self.metrics_fun = self.metrics_fun if metrics_fun is None else metrics_fun\n        self.verbose = verbose\n        self.y_true = self.generate_y_true()\n        self.bounds = self.generate_bounds()\n        self.hyperparams = self.generate_bayesopt_hyperparams()\n\n    # use a weighted F1 score because dataset may be imbalanced\n    def metrics_fun(self, y_pred):\n        return f1_score(self.y_true, y_pred, average='weighted')\n\n    def generate_bayesopt_hyperparams(self):\n        params = {'l_type': 'L_MCMC',\n                  # TODO: better estimates\n                  'noise': 1e-10 if not self.noisy else 0.01,\n                  'verbose_level': 4}\n        params['noise'] = \n        return params\n        \n    @classmethod\n    def generate_y_true(cls):\n        model = FastText()\n        return model.extract_classes(cls.VALID_PATH)\n        \n    @staticmethod\n    def generate_bounds():\n        Bound = namedtuple('Bound', ['low', 'high', 'fun'])\n        bounds = OrderedDict()\n        bounds['epoch'] = Bound(1, 50, int)\n        bounds['lr'] = Bound(0.025, 1.5, float)\n        bounds['bucket'] = Bound(200000, 16000000, int)\n        bounds['neg'] = Bound(50, 5000, int)\n        bounds['minn'] = Bound(0, 10, int)\n        bounds['maxn'] = Bound(0, 10, int)\n        bounds['wordNgrams'] = Bound(0, 10, int)\n        bounds['pretrainedVectors'] = Bound(0.0, 1.0, lambda x: x > 0.5)\n        return bounds\n      \n    @property\n    def lower_bound(self):\n        return np.array([bound.low for bound in self.bounds.values()], dtype=float)\n\n    @property\n    def upper_bound(self):\n        return np.array([bound.high for bound in self.bounds.values()], dtype=float)\n   \n    @property\n    def dim(self):\n        return len(self.bounds)\n    \n    def generate_fastText_hyperparams(self, params):\n        kwargs = OrderedDict()\n        for (key, bound), param in zip(self.bounds.items(), params):\n            if key == 'pretrainedVectors':\n                if bound.fun(param):\n                    kwargs[key] = self.VECTORS_PATH\n            else:\n                kwargs[key] = bound.fun(param)\n\n        if not self.noisy:\n            kwargs['thread'] = 1\n                \n        return kwargs\n\n    def train(self, params, test_path):\n        self.message('parameters:', params)\n        try:\n            kwargs = self.generate_fastText_hyperparams(params)\n            self.message('fastText parameters:')\n            for key, val in kwargs.items():\n                self.message(' ', key, ':', val)\n\n            model = FastText()\n            model.supervised(input=self.TRAIN_PATH, output=self.MODEL_PATH, **kwargs)\n            y_pred = [item[0] for item in model.predict_file(test_path)]\n            acc = self.metrics_fun(y_pred)\n            self.message('metrics:', acc)\n            return (1.0 - acc)\n        except Exception as exc:\n            self.message('failed to train!')\n            self.message(exc)\n            return 1.0\n\n    def train_valid(self, params):\n        return self.train(params, self.VALID_PATH)\n        \n    def train_test(self, params):\n        return self.train(params, self.TEST_PATH)\n        \n    def optimize(self):\n        return bayesopt.optimize(self.train_valid, self.dim, self.lower_bound, self.upper_bound, self.hyperparams)\n\n    def message(self, msg, *args, **kwargs):\n        if self.verbose:\n            print('[*] ', msg, *args, **kwargs)\n\ndef main():\n    fopt = FastTextBayesOpt(noisy=True)\n    res = fopt.optimize()\n    fopt.train_test(res)\n    print('results:', res)\n\nif __name__ == '__main__':\n    main()\n"""
examples/subwords.py,0,"b""#!/usr/bin/env python\n\nfrom pyfasttext import FastText\n\nfrom sys import argv\n\ndef print_subwords(fname):\n    model = FastText(fname)\n    maxn = model.args['maxn']\n    res = {}\n    \n    for word in model.words:\n        for subword, arr in zip(model.get_subwords(word), model.get_numpy_subword_vectors(word)):\n            # real ngram, not the full word?\n            if len(subword) > maxn:\n                continue\n            \n            res[subword] = arr\n\n    for key in sorted(res.keys()):\n        print('{} {}'.format(key, ' '.join(str(val) for val in res[key])))\n\nif __name__ == '__main__':\n    print_subwords(argv[1])\n"""
