file_path,api_count,code
player.py,0,"b'""Play an infinite remix of your favorite songs.""\n\nfrom random import random\nimport argparse\nimport gzip\nimport os\nimport pickle\nimport struct\n\nfrom scipy.misc import imresize\nimport alsaaudio\nimport librosa\nimport numpy\n\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\n\nwith open(os.path.join(BASE_DIR, \'timbre.pickle\'), \'rb\') as fh:\n    TIMBRE_PATTERNS = pickle.load(fh)\n\n\ndef enhance_diagonals(R, weight=0.2, steps=1):\n    for i in range(steps):\n        # combine each cell with its diagonal neighbors\n        R1 = numpy.roll(R, (1, 1), (0, 1))\n        R2 = numpy.roll(R, (-1, -1), (0, 1))\n        R = (weight * (R1 + R2) + (1 - weight) * R) / 2\n    return R\n\n\ndef iter_beat_slices(y, beat_frames):\n    beat_samples = librosa.frames_to_samples(beat_frames)\n    yield 0, beat_samples[0]\n    for start, end in zip(beat_samples[0:-1], beat_samples[1:]):\n        yield start, end\n    yield beat_samples[-1], len(y) - 1\n\n\ndef timbre(y):\n    spectrum = numpy.abs(librosa.stft(y))\n    resized = imresize(spectrum, (50, 70))\n    l = []\n    for pattern in TIMBRE_PATTERNS:\n        l.append(numpy.sum(pattern * resized))\n    return l\n\n\ndef analyze(y, sample_rate, beat_frames, bins_per_octave=12, n_octaves=7):\n    cqt = librosa.cqt(y=y, sr=sample_rate)\n    C = librosa.amplitude_to_db(cqt, ref=numpy.max)\n    sync = librosa.util.sync(C, beat_frames)\n    R_cqt = librosa.segment.recurrence_matrix(sync, width=4, mode=\'affinity\')\n\n    tim = numpy.array([\n        timbre(y[s:e]) for s, e in iter_beat_slices(y, beat_frames)\n    ]).T\n    R_timbre = librosa.segment.recurrence_matrix(tim, width=4, mode=\'affinity\')\n\n    return (R_cqt + R_timbre) / 2\n\n\ndef load(filename, force=False):\n    y, sample_rate = librosa.load(filename, sr=None)\n\n    fn_inf = filename + \'.inf\'\n    if not force and os.path.exists(fn_inf):\n        with gzip.open(fn_inf, \'rb\') as fh:\n            beat_frames, R = pickle.load(fh)\n    else:\n        print(\'Analyzing\xe2\x80\xa6\')\n        tempo, beat_frames = librosa.beat.beat_track(y=y, sr=sample_rate)\n        R = analyze(y, sample_rate, beat_frames)\n\n        with gzip.open(fn_inf, \'wb\') as fh:\n            pickle.dump((beat_frames, R), fh)\n\n    return y, sample_rate, beat_frames, R\n\n\ndef compute_buffers(y, beat_frames):\n    int_max = numpy.iinfo(numpy.int16).max\n    raw = (y * int_max).astype(numpy.int16).T.copy(order=\'C\')\n\n    buffers = []\n    for start, end in iter_beat_slices(raw, beat_frames):\n        samples = raw[start:end]\n        data = struct.pack(""h"" * len(samples), *samples)\n        duration = librosa.samples_to_time(end - start)\n        buffers.append((data, duration))\n\n    return buffers\n\n\ndef normalize(R, threshold):\n    n = len(R)\n\n    R = enhance_diagonals(R, 0.8, 4)\n\n    # scale\n    x_max = R.max()\n    x_min = x_max * threshold\n    y_max = (x_max + 0.5) / 2\n    # print(\'mapping {},{} to {},{}\'.format(x_min, x_max, 0, y_max))\n    R_norm = (R - x_min) / (x_max - x_min) * y_max\n\n    # privilege jumps back in order to prolong playing\n    R *= numpy.ones((n, n)) * 0.9 + numpy.tri(n, k=-1) * 0.1\n\n    # privilege wide jumps\n    M = numpy.zeros((n, n))\n    for i in range(1, n):\n        M += numpy.tri(n, k=-i)\n        M += numpy.tri(n, k=-i).T\n    R *= (M / (n - 1)) ** 0.1\n\n    return R_norm * (R_norm > 0)\n\n\ndef compute_jumps(R):\n    jumps = []\n    for row in R:\n        l = [(i, p) for i, p in enumerate(row) if p > 0]\n        jumps.append(sorted(l, key=lambda x: -x[1]))\n    return jumps\n\n\ndef play(buffers, sample_rate, jumps):\n    # https://larsimmisch.github.io/pyalsaaudio/libalsaaudio.html#pcm-objects\n    pcm = alsaaudio.PCM()\n    pcm.setrate(sample_rate)\n    pcm.setchannels(1)\n\n    i = 0\n    n = len(buffers)\n\n    while True:\n        data, duration = buffers[i]\n        pcm.write(data)\n\n        for j, p in jumps[i]:\n            if p > random():\n                # print(\'jump\', i, j)\n                i = j\n                break\n\n        i = i + 1\n\n        if i >= n:\n            # print(\'reached end\')\n            i = 0\n\n\ndef plot(R):\n    import librosa.display\n    import matplotlib.pyplot as plt\n\n    plt.figure()\n    librosa.display.specshow(R)\n    plt.show()\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\'filename\')\n    parser.add_argument(\n        \'-t\', \'--threshold\', type=float, default=0.5, help=\'Between 0 and 1. \'\n        \'A higher value will result in fewer but better jumps. (Default: 0.5)\')\n    parser.add_argument(\n        \'-f\', \'--force\', action=\'store_true\',\n        help=\'Ignore previously saved analysis data.\')\n    parser.add_argument(\'-P\', \'--plot\', action=\'store_true\')\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n\n    print(\'Loading\', args.filename)\n    y, sample_rate, beat_frames, R = load(args.filename, args.force)\n    R = normalize(R, args.threshold)\n    buffers = compute_buffers(y, beat_frames)\n    jumps = compute_jumps(R)\n    jump_count = sum(len(row) for row in jumps)\n\n    print(\'Detected {} jump opportunities on {} beats\'.format(\n        jump_count, len(buffers)))\n\n    if args.plot:\n        plot(R)\n\n    print(\'Playing\xe2\x80\xa6 (Press Ctrl-C to stop)\')\n    play(buffers, sample_rate, jumps)\n\n\nif __name__ == \'__main__\':\n    main()\n'"
