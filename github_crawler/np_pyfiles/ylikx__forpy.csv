file_path,api_count,code
fypp.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n################################################################################\n#\n# fypp -- Python powered Fortran preprocessor\n#\n# Copyright (c) 2016-2017 B\xc3\xa1lint Aradi, Universit\xc3\xa4t Bremen\n#\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice, this\n# list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \'AS IS\'\n# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n################################################################################\n\n\'\'\'For using the functionality of the Fypp preprocessor from within\nPython, one usually interacts with the following two classes:\n\n* `Fypp`_: The actual Fypp preprocessor. It returns for a given input\n  the preprocessed output.\n\n* `FyppOptions`_: Contains customizable settings controling the behaviour of\n  `Fypp`_. Alternatively, the function `get_option_parser()`_ can be used to\n  obtain an option parser, which can create settings based on command line\n  arguments.\n\nIf processing stops prematurely, an instance of one of the following\nsubclasses of `FyppError`_ is raised:\n\n* FyppFatalError: Unexpected error (e.g. bad input, missing files, etc.)\n\n* FyppStopRequest: Stop was triggered by an explicit request in the input\n  (by a stop- or an assert-directive).\n\'\'\'\n\nfrom __future__ import print_function\nimport sys\nimport types\nimport inspect\nimport re\nimport os\nimport errno\nimport time\nimport optparse\nif sys.version_info[0] >= 3:\n    import builtins\nelse:\n    import __builtin__ as builtins\n\n# Prevent cluttering user directory with Python bytecode\nsys.dont_write_bytecode = True\n\nVERSION = \'2.0.1\'\n\nSTDIN = \'<stdin>\'\n\nFILEOBJ = \'<fileobj>\'\n\nSTRING = \'<string>\'\n\nERROR_EXIT_CODE = 1\n\nUSER_ERROR_EXIT_CODE = 2\n\n_ALL_DIRECTIVES_PATTERN = r\'\'\'\n# comment block\n(?:^[ \\t]*\\#!.*\\n)+\n|\n# line directive (with optional continuation lines)\n^[ \\t]*(?P<ldirtype>[\\#\\$@]):[ \\t]*\n(?P<ldir>.+?(?:&[ \\t]*\\n(?:[ \\t]*&)?.*?)*)?[ \\t]*\\n\n|\n# inline eval directive\n(?P<idirtype>[$\\#@])\\{[ \\t]*(?P<idir>.+?)?[ \\t]*\\}(?P=idirtype)\n\'\'\'\n\n_ALL_DIRECTIVES_REGEXP = re.compile(\n    _ALL_DIRECTIVES_PATTERN, re.VERBOSE | re.MULTILINE)\n\n_CONTROL_DIR_REGEXP = re.compile(\n    r\'(?P<dir>[a-zA-Z_]\\w*)[ \\t]*(?:[ \\t]+(?P<param>[^ \\t].*))?$\')\n\n_DIRECT_CALL_REGEXP = re.compile(\n    r\'(?P<callname>[a-zA-Z_][\\w.]*)[ \\t]*\\((?P<callparams>.+?)?\\)$\')\n\n_DIRECT_CALL_KWARG_REGEXP = re.compile(\n    r\'(?:(?P<kwname>[a-zA-Z_]\\w*)\\s*=(?=[^=]|$))?\')\n\n_DEF_PARAM_REGEXP = re.compile(\n    r\'^(?P<name>[a-zA-Z_]\\w*)[ \\t]*\\(\\s*(?P<args>.+)?\\s*\\)$\')\n\n_SIMPLE_CALLABLE_REGEXP = re.compile(\n    r\'^(?P<name>[a-zA-Z_][\\w.]*)[ \\t]*(?:\\([ \\t]*(?P<args>.*)[ \\t]*\\))?$\')\n\n_IDENTIFIER_NAME_REGEXP = re.compile(r\'^(?P<name>[a-zA-Z_]\\w*)$\')\n\n_PREFIXED_IDENTIFIER_NAME_REGEXP = re.compile(r\'^(?P<name>[a-zA-Z_][\\w.]*)$\')\n\n_SET_PARAM_REGEXP = re.compile(\n    r\'^(?P<name>(?:[(]\\s*)?[a-zA-Z_]\\w*(?:\\s*,\\s*[a-zA-Z_]\\w*)*(?:\\s*[)])?)\\s*\'\\\n    r\'(?:=\\s*(?P<expr>.*))?$\')\n\n_DEL_PARAM_REGEXP = re.compile(\n    r\'^(?:[(]\\s*)?[a-zA-Z_]\\w*(?:\\s*,\\s*[a-zA-Z_]\\w*)*(?:\\s*[)])?$\')\n\n_FOR_PARAM_REGEXP = re.compile(\n    r\'^(?P<loopexpr>[a-zA-Z_]\\w*(\\s*,\\s*[a-zA-Z_]\\w*)*)\\s+in\\s+(?P<iter>.+)$\')\n\n_INCLUDE_PARAM_REGEXP = re.compile(r\'^(\\\'|"")(?P<fname>.*?)\\1$\')\n\n_COMMENTLINE_REGEXP = re.compile(r\'^[ \\t]*!.*$\')\n\n_CONTLINE_REGEXP = re.compile(r\'&[ \\t]*\\n(?:[ \\t]*&)?\')\n\n_UNESCAPE_TEXT_REGEXP1 = re.compile(r\'([$#@])\\\\(\\\\*)([{:])\')\n\n_UNESCAPE_TEXT_REGEXP2 = re.compile(r\'(\\})\\\\(\\\\*)([$#@])\')\n\n_INLINE_EVAL_REGION_REGEXP = re.compile(r\'\\${.*?}\\$\')\n\n_RESERVED_PREFIX = \'__\'\n\n_RESERVED_NAMES = set([\'defined\', \'setvar\', \'getvar\', \'delvar\', \'globalvar\',\n                       \'_LINE_\', \'_FILE_\', \'_THIS_FILE_\', \'_THIS_LINE_\',\n                       \'_TIME_\', \'_DATE_\'])\n\n_LINENUM_NEW_FILE = 1\n\n_LINENUM_RETURN_TO_FILE = 2\n\n_QUOTES_FORTRAN = \'\\\'""\'\n\n_OPENING_BRACKETS_FORTRAN = \'{([\'\n\n_CLOSING_BRACKETS_FORTRAN = \'})]\'\n\n_ARGUMENT_SPLIT_CHAR_FORTRAN = \',\'\n\n\nclass FyppError(Exception):\n    \'\'\'Signalizes error occuring during preprocessing.\n\n    Args:\n        msg (str): Error message.\n        fname (str): File name. None (default) if file name is not available.\n        span (tuple of int): Beginning and end line of the region where error\n            occured or None if not available. If fname was not None, span must\n            not be None.\n        cause (Exception): Contains the exception, which triggered this\n            exception or None, if this exception is not masking any underlying\n            one. (Emulates Python 3 exception chaining in a Python 2 compatible\n            way.)\n\n    Attributes:\n        msg (str): Error message.\n        fname (str or None): File name or None if not available.\n        span (tuple of int or None): Beginning and end line of the region\n            where error occured or None if not available. Line numbers start\n            from zero. For directives, which do not consume end of the line,\n            start and end lines are identical.\n        cause (Exception): In case this exception is raised in an except block,\n            the original exception should be passed here. (Emulates Python 3\n            exception chaining in a Python 2 compatible way.)\n    \'\'\'\n\n    def __init__(self, msg, fname=None, span=None, cause=None):\n        super(FyppError, self).__init__()\n        self.msg = msg\n        self.fname = fname\n        self.span = span\n        self.cause = cause\n\n\n    def __str__(self):\n        msg = [self.__class__.__name__, \': \']\n        if self.fname is not None:\n            msg.append(""file \'"" + self.fname + ""\'"")\n            if self.span[1] > self.span[0] + 1:\n                msg.append(\', lines {0}-{1}\'.format(\n                    self.span[0] + 1, self.span[1]))\n            else:\n                msg.append(\', line {0}\'.format(self.span[0] + 1))\n            msg.append(\'\\n\')\n        if self.msg:\n            msg.append(self.msg)\n        if self.cause is not None:\n            msg.append(\'\\n\' + str(self.cause))\n        return \'\'.join(msg)\n\n\nclass FyppFatalError(FyppError):\n    \'\'\'Signalizes an unexpected error during processing.\'\'\'\n    pass\n\n\nclass FyppStopRequest(FyppError):\n    \'\'\'Signalizes an explicitely triggered stop (e.g. via stop directive)\'\'\'\n    pass\n\n\nclass Parser:\n    \'\'\'Parses a text and generates events when encountering Fypp constructs.\n\n    Args:\n        includedirs (list): List of directories, in which include files should\n            be searched for, when they are not found at the default location.\n    \'\'\'\n\n    def __init__(self, includedirs=None):\n\n        # Directories to search for include files\n        if includedirs is None:\n            self._includedirs = []\n        else:\n            self._includedirs = includedirs\n\n        # Name of current file\n        self._curfile = None\n\n        # Directory of current file\n        self._curdir = None\n\n\n    def parsefile(self, fobj):\n        \'\'\'Parses file or a file like object.\n\n        Args:\n            fobj (str or file): Name of a file or a file like object.\n        \'\'\'\n        if isinstance(fobj, str):\n            if fobj == STDIN:\n                self._includefile(None, sys.stdin, STDIN, os.getcwd())\n            else:\n                inpfp = _open_input_file(fobj)\n                self._includefile(None, inpfp, fobj, os.path.dirname(fobj))\n                inpfp.close()\n        else:\n            self._includefile(None, fobj, FILEOBJ, os.getcwd())\n\n\n    def _includefile(self, span, fobj, fname, curdir):\n        oldfile = self._curfile\n        olddir = self._curdir\n        self._curfile = fname\n        self._curdir = curdir\n        self.handle_include(span, fname)\n        self._parse(fobj.read())\n        self.handle_endinclude(span, fname)\n        self._curfile = oldfile\n        self._curdir = olddir\n\n\n    def parse(self, txt):\n        \'\'\'Parses string.\n\n        Args:\n            txt (str): Text to parse.\n        \'\'\'\n        self._curfile = STRING\n        self._curdir = \'\'\n        self.handle_include(None, self._curfile)\n        self._parse(txt)\n        self.handle_endinclude(None, self._curfile)\n\n\n    def handle_include(self, span, fname):\n        \'\'\'Called when parser starts to process a new file.\n\n        It is a dummy methond and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the include directive\n                or None if called the first time for the main input.\n            fname (str): Name of the file.\n        \'\'\'\n        self._log_event(\'include\', span, filename=fname)\n\n\n    def handle_endinclude(self, span, fname):\n        \'\'\'Called when parser finished processing a file.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the include directive\n                or None if called the first time for the main input.\n            fname (str): Name of the file.\n        \'\'\'\n        self._log_event(\'endinclude\', span, filename=fname)\n\n\n    def handle_set(self, span, name, expr):\n        \'\'\'Called when parser encounters a set directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable.\n            expr (str): String representation of the expression to be assigned\n                to the variable.\n        \'\'\'\n        self._log_event(\'set\', span, name=name, expression=expr)\n\n\n    def handle_def(self, span, name, args):\n        \'\'\'Called when parser encounters a def directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the macro to be defined.\n            argexpr (str): String with argument definition (or None)\n        \'\'\'\n        self._log_event(\'def\', span, name=name, arguments=args)\n\n\n    def handle_enddef(self, span, name):\n        \'\'\'Called when parser encounters an enddef directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name found after the enddef directive.\n        \'\'\'\n        self._log_event(\'enddef\', span, name=name)\n\n\n    def handle_del(self, span, name):\n        \'\'\'Called when parser encounters a del directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable to delete.\n        \'\'\'\n        self._log_event(\'del\', span, name=name)\n\n\n    def handle_if(self, span, cond):\n        \'\'\'Called when parser encounters an if directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            cond (str): String representation of the branching condition.\n        \'\'\'\n        self._log_event(\'if\', span, condition=cond)\n\n\n    def handle_elif(self, span, cond):\n        \'\'\'Called when parser encounters an elif directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            cond (str): String representation of the branching condition.\n        \'\'\'\n        self._log_event(\'elif\', span, condition=cond)\n\n\n    def handle_else(self, span):\n        \'\'\'Called when parser encounters an else directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'else\', span)\n\n\n    def handle_endif(self, span):\n        \'\'\'Called when parser encounters an endif directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'endif\', span)\n\n\n    def handle_for(self, span, varexpr, iterator):\n        \'\'\'Called when parser encounters a for directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            varexpr (str): String representation of the loop variable\n                expression.\n            iterator (str): String representation of the iterable.\n        \'\'\'\n        self._log_event(\'for\', span, variable=varexpr, iterable=iterator)\n\n\n    def handle_endfor(self, span):\n        \'\'\'Called when parser encounters an endfor directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'endfor\', span)\n\n\n    def handle_call(self, span, name, argexpr):\n        \'\'\'Called when parser encounters a call directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the callable to call\n            argexpr (str or None): Argument expression containing additional\n                arguments for the call.\n        \'\'\'\n        self._log_event(\'call\', span, name=name, argexpr=argexpr)\n\n\n    def handle_nextarg(self, span, name):\n        \'\'\'Called when parser encounters a nextarg directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str or None): Name of the argument following next or\n                None if it should be the next positional argument.\n        \'\'\'\n        self._log_event(\'nextarg\', span, name=name)\n\n\n    def handle_endcall(self, span, name):\n        \'\'\'Called when parser encounters an endcall directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name found after the endcall directive.\n        \'\'\'\n        self._log_event(\'endcall\', span, name=name)\n\n\n    def handle_eval(self, span, expr):\n        \'\'\'Called when parser encounters an eval directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            expr (str): String representation of the Python expression to\n                be evaluated.\n        \'\'\'\n        self._log_event(\'eval\', span, expression=expr)\n\n\n    def handle_global(self, span, name):\n        \'\'\'Called when parser encounters a global directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable which should be made global.\n        \'\'\'\n        self._log_event(\'global\', span, name=name)\n\n\n    def handle_text(self, span, txt):\n        \'\'\'Called when parser finds text which must left unaltered.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            txt (str): Text.\n        \'\'\'\n        self._log_event(\'text\', span, content=txt)\n\n\n    def handle_comment(self, span):\n        \'\'\'Called when parser finds a preprocessor comment.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'comment\', span)\n\n\n    def handle_mute(self, span):\n        \'\'\'Called when parser finds a mute directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'mute\', span)\n\n\n    def handle_endmute(self, span):\n        \'\'\'Called when parser finds an endmute directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'endmute\', span)\n\n\n    def handle_stop(self, span, msg):\n        \'\'\'Called when parser finds an stop directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            msg (str): Stop message.\n        \'\'\'\n        self._log_event(\'stop\', span, msg=msg)\n\n\n    def handle_assert(self, span):\n        \'\'\'Called when parser finds an assert directive.\n\n        It is a dummy method and should be overriden for actual use.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._log_event(\'assert\', span)\n\n\n    @staticmethod\n    def _log_event(event, span=(-1, -1), **params):\n        print(\'{0}: {1} --> {2}\'.format(event, span[0], span[1]))\n        for parname, parvalue in params.items():\n            print(\'  {0}: ->|{1}|<-\'.format(parname, parvalue))\n        print()\n\n\n    def _parse(self, txt, linenr=0, directcall=False):\n        pos = 0\n        for match in _ALL_DIRECTIVES_REGEXP.finditer(txt):\n            start, end = match.span()\n            if start > pos:\n                endlinenr = linenr + txt.count(\'\\n\', pos, start)\n                self._process_text(txt[pos:start], (linenr, endlinenr))\n                linenr = endlinenr\n            endlinenr = linenr + txt.count(\'\\n\', start, end)\n            span = (linenr, endlinenr)\n            ldirtype, ldir, idirtype, idir = match.groups()\n            if directcall and (idirtype is None or idirtype != \'$\'):\n                msg = \'only inline eval directives allowed in direct calls\'\n                raise FyppFatalError(msg, self._curfile, span)\n            elif idirtype is not None:\n                if idir is None:\n                    msg = \'missing inline directive content\'\n                    raise FyppFatalError(msg, self._curfile, span)\n                dirtype = idirtype\n                content = idir\n            elif ldirtype is not None:\n                if ldir is None:\n                    msg = \'missing line directive content\'\n                    raise FyppFatalError(msg, self._curfile, span)\n                dirtype = ldirtype\n                content = _CONTLINE_REGEXP.sub(\'\', ldir)\n            else:\n                # Comment directive\n                dirtype = None\n            if dirtype == \'$\':\n                self.handle_eval(span, content)\n            elif dirtype == \'#\':\n                self._process_control_dir(content, span)\n            elif dirtype == \'@\':\n                self._process_direct_call(content, span)\n            else:\n                self.handle_comment(span)\n            pos = end\n            linenr = endlinenr\n        if pos < len(txt):\n            endlinenr = linenr + txt.count(\'\\n\', pos)\n            self._process_text(txt[pos:], (linenr, endlinenr))\n\n\n    def _process_text(self, txt, span):\n        escaped_txt = self._unescape(txt)\n        self.handle_text(span, escaped_txt)\n\n\n    def _process_control_dir(self, content, span):\n        match = _CONTROL_DIR_REGEXP.match(content)\n        if not match:\n            msg = ""invalid control directive content \'{0}\'"".format(content)\n            raise FyppFatalError(msg, self._curfile, span)\n        directive, param = match.groups()\n        if directive == \'if\':\n            self._check_param_presence(True, \'if\', param, span)\n            self.handle_if(span, param)\n        elif directive == \'else\':\n            self._check_param_presence(False, \'else\', param, span)\n            self.handle_else(span)\n        elif directive == \'elif\':\n            self._check_param_presence(True, \'elif\', param, span)\n            self.handle_elif(span, param)\n        elif directive == \'endif\':\n            self._check_param_presence(False, \'endif\', param, span)\n            self.handle_endif(span)\n        elif directive == \'def\':\n            self._check_param_presence(True, \'def\', param, span)\n            self._check_not_inline_directive(\'def\', span)\n            self._process_def(param, span)\n        elif directive == \'enddef\':\n            self._process_enddef(param, span)\n        elif directive == \'set\':\n            self._check_param_presence(True, \'set\', param, span)\n            self._process_set(param, span)\n        elif directive == \'del\':\n            self._check_param_presence(True, \'del\', param, span)\n            self._process_del(param, span)\n        elif directive == \'for\':\n            self._check_param_presence(True, \'for\', param, span)\n            self._process_for(param, span)\n        elif directive == \'endfor\':\n            self._check_param_presence(False, \'endfor\', param, span)\n            self.handle_endfor(span)\n        elif directive == \'call\':\n            self._check_param_presence(True, \'call\', param, span)\n            self._process_call(param, span)\n        elif directive == \'nextarg\':\n            self._process_nextarg(param, span)\n        elif directive == \'endcall\':\n            self._process_endcall(param, span)\n        elif directive == \'include\':\n            self._check_param_presence(True, \'include\', param, span)\n            self._check_not_inline_directive(\'include\', span)\n            self._process_include(param, span)\n        elif directive == \'mute\':\n            self._check_param_presence(False, \'mute\', param, span)\n            self._check_not_inline_directive(\'mute\', span)\n            self.handle_mute(span)\n        elif directive == \'endmute\':\n            self._check_param_presence(False, \'endmute\', param, span)\n            self._check_not_inline_directive(\'endmute\', span)\n            self.handle_endmute(span)\n        elif directive == \'stop\':\n            self._check_param_presence(True, \'stop\', param, span)\n            self._check_not_inline_directive(\'stop\', span)\n            self.handle_stop(span, param)\n        elif directive == \'assert\':\n            self._check_param_presence(True, \'assert\', param, span)\n            self._check_not_inline_directive(\'assert\', span)\n            self.handle_assert(span, param)\n        elif directive == \'global\':\n            self._check_param_presence(True, \'global\', param, span)\n            self._process_global(param, span)\n        else:\n            msg = ""unknown directive \'{0}\'"".format(directive)\n            raise FyppFatalError(msg, self._curfile, span)\n\n\n    def _process_direct_call(self, callexpr, span):\n        match = _DIRECT_CALL_REGEXP.match(callexpr)\n        if not match:\n            msg = ""invalid direct call expression""\n            raise FyppFatalError(msg, self._curfile, span)\n        callname = match.group(\'callname\')\n        self.handle_call(span, callname, None)\n        callparams = match.group(\'callparams\')\n        if callparams is None or not callparams.strip():\n            args = []\n        else:\n            try:\n                args = [arg.strip() for arg in _argsplit_fortran(callparams)]\n            except Exception as exc:\n                msg = \'unable to parse direct call argument\'\n                raise FyppFatalError(msg, self._curfile, span, exc)\n        for arg in args:\n            match = _DIRECT_CALL_KWARG_REGEXP.match(arg)\n            argval = arg[match.end():].strip()\n            # Remove enclosing braces if present\n            if argval.startswith(\'{\'):\n                argval = argval[1:-1]\n            keyword = match.group(\'kwname\')\n            self.handle_nextarg(span, keyword)\n            self._parse(argval, linenr=span[0], directcall=True)\n        self.handle_endcall(span, callname)\n\n\n    def _process_def(self, param, span):\n        match = _DEF_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid macro definition \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        name = match.group(\'name\')\n        argexpr = match.group(\'args\')\n        self.handle_def(span, name, argexpr)\n\n\n    def _process_enddef(self, param, span):\n        if param is not None:\n            match = _IDENTIFIER_NAME_REGEXP.match(param)\n            if not match:\n                msg = ""invalid enddef parameter \'{0}\'"".format(param)\n                raise FyppFatalError(msg, self._curfile, span)\n            param = match.group(\'name\')\n        self.handle_enddef(span, param)\n\n\n    def _process_set(self, param, span):\n        match = _SET_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid variable assignment \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        self.handle_set(span, match.group(\'name\'), match.group(\'expr\'))\n\n\n    def _process_global(self, param, span):\n        match = _DEL_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid variable specification \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        self.handle_global(span, param)\n\n\n    def _process_del(self, param, span):\n        match = _DEL_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid variable specification \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        self.handle_del(span, param)\n\n\n    def _process_for(self, param, span):\n        match = _FOR_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid for loop declaration \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        loopexpr = match.group(\'loopexpr\')\n        loopvars = [s.strip() for s in loopexpr.split(\',\')]\n        self.handle_for(span, loopvars, match.group(\'iter\'))\n\n\n    def _process_call(self, param, span):\n        match = _SIMPLE_CALLABLE_REGEXP.match(param)\n        if not match:\n            msg = ""invalid callable expression \'{}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        name, args = match.groups()\n        self.handle_call(span, name, args)\n\n\n    def _process_nextarg(self, param, span):\n        if param is not None:\n            match = _IDENTIFIER_NAME_REGEXP.match(param)\n            if not match:\n                msg = ""invalid nextarg parameter \'{0}\'"".format(param)\n                raise FyppFatalError(msg, self._curfile, span)\n            param = match.group(\'name\')\n        self.handle_nextarg(span, param)\n\n\n    def _process_endcall(self, param, span):\n        if param is not None:\n            match = _PREFIXED_IDENTIFIER_NAME_REGEXP.match(param)\n            if not match:\n                msg = ""invalid endcall parameter \'{0}\'"".format(param)\n                raise FyppFatalError(msg, self._curfile, span)\n            param = match.group(\'name\')\n        self.handle_endcall(span, param)\n\n\n    def _process_include(self, param, span):\n        match = _INCLUDE_PARAM_REGEXP.match(param)\n        if not match:\n            msg = ""invalid include file declaration \'{0}\'"".format(param)\n            raise FyppFatalError(msg, self._curfile, span)\n        fname = match.group(\'fname\')\n        for incdir in [self._curdir] + self._includedirs:\n            fpath = os.path.join(incdir, fname)\n            if os.path.exists(fpath):\n                break\n        else:\n            msg = ""include file \'{0}\' not found"".format(fname)\n            raise FyppFatalError(msg, self._curfile, span)\n        inpfp = _open_input_file(fpath)\n        self._includefile(span, inpfp, fpath, os.path.dirname(fpath))\n        inpfp.close()\n\n\n    def _process_mute(self, span):\n        if span[0] == span[1]:\n            msg = \'Inline form of mute directive not allowed\'\n            raise FyppFatalError(msg, self._curfile, span)\n        self.handle_mute(span)\n\n\n    def _process_endmute(self, span):\n        if span[0] == span[1]:\n            msg = \'Inline form of endmute directive not allowed\'\n            raise FyppFatalError(msg, self._curfile, span)\n        self.handle_endmute(span)\n\n\n    def _check_param_presence(self, presence, directive, param, span):\n        if (param is not None) != presence:\n            if presence:\n                msg = \'missing data in {0} directive\'.format(directive)\n            else:\n                msg = \'forbidden data in {0} directive\'.format(directive)\n            raise FyppFatalError(msg, self._curfile, span)\n\n\n    def _check_not_inline_directive(self, directive, span):\n        if span[0] == span[1]:\n            msg = \'Inline form of {0} directive not allowed\'.format(directive)\n            raise FyppFatalError(msg, self._curfile, span)\n\n\n    @staticmethod\n    def _unescape(txt):\n        txt = _UNESCAPE_TEXT_REGEXP1.sub(r\'\\1\\2\\3\', txt)\n        txt = _UNESCAPE_TEXT_REGEXP2.sub(r\'\\1\\2\\3\', txt)\n        return txt\n\n\nclass Builder:\n    \'\'\'Builds a tree representing a text with preprocessor directives.\n    \'\'\'\n\n    def __init__(self):\n        # The tree, which should be built.\n        self._tree = []\n\n        # List of all open constructs\n        self._open_blocks = []\n\n        # Nodes to which the open blocks have to be appended when closed\n        self._path = []\n\n        # Nr. of open blocks when file was opened. Used for checking whether all\n        # blocks have been closed, when file processing finishes.\n        self._nr_prev_blocks = []\n\n        # Current node, to which content should be added\n        self._curnode = self._tree\n\n        # Current file\n        self._curfile = None\n\n\n    def reset(self):\n        \'\'\'Resets the builder so that it starts to build a new tree.\'\'\'\n        self._tree = []\n        self._open_blocks = []\n        self._path = []\n        self._nr_prev_blocks = []\n        self._curnode = self._tree\n        self._curfile = None\n\n\n    def handle_include(self, span, fname):\n        \'\'\'Should be called to signalize change to new file.\n\n        Args:\n            span (tuple of int): Start and end line of the include directive\n                or None if called the first time for the main input.\n            fname (str): Name of the file to be included.\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        self._open_blocks.append(\n            (\'include\', self._curfile, [span], fname, None))\n        self._curfile = fname\n        self._nr_prev_blocks.append(len(self._open_blocks))\n\n\n    def handle_endinclude(self, span, fname):\n        \'\'\'Should be called when processing of a file finished.\n\n        Args:\n            span (tuple of int): Start and end line of the include directive\n                or None if called the first time for the main input.\n            fname (str): Name of the file which has been included.\n        \'\'\'\n        nprev_blocks = self._nr_prev_blocks.pop(-1)\n        if len(self._open_blocks) > nprev_blocks:\n            directive, fname, spans = self._open_blocks[-1][0:3]\n            msg = \'{0} directive still unclosed when reaching end of file\'\\\n                  .format(directive)\n            raise FyppFatalError(msg, self._curfile, spans[0])\n        block = self._open_blocks.pop(-1)\n        directive, blockfname, spans = block[0:3]\n        if directive != \'include\':\n            msg = \'internal error: last open block is not \\\'include\\\' when \'\\\n                  \'closing file \\\'{0}\\\'\'.format(fname)\n            raise FyppFatalError(msg)\n        if span != spans[0]:\n            msg = \'internal error: span for include and endinclude differ (\'\\\n                  \'{0} vs {1}\'.format(span, spans[0])\n            raise FyppFatalError(msg)\n        oldfname, _ = block[3:5]\n        if fname != oldfname:\n            msg = \'internal error: mismatching file name in close_file event\'\\\n                  "" (expected: \'{0}\', got: \'{1}\')"".format(oldfname, fname)\n            raise FyppFatalError(msg, fname)\n        block = directive, blockfname, spans, fname, self._curnode\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n        self._curfile = blockfname\n\n\n    def handle_if(self, span, cond):\n        \'\'\'Should be called to signalize an if directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            param (str): String representation of the branching condition.\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        self._open_blocks.append((\'if\', self._curfile, [span], [cond], []))\n\n\n    def handle_elif(self, span, cond):\n        \'\'\'Should be called to signalize an elif directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            cond (str): String representation of the branching condition.\n        \'\'\'\n        self._check_for_open_block(span, \'elif\')\n        block = self._open_blocks[-1]\n        directive, _, spans = block[0:3]\n        self._check_if_matches_last(directive, \'if\', spans[-1], span, \'elif\')\n        conds, contents = block[3:5]\n        conds.append(cond)\n        contents.append(self._curnode)\n        spans.append(span)\n        self._curnode = []\n\n\n    def handle_else(self, span):\n        \'\'\'Should be called to signalize an else directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._check_for_open_block(span, \'else\')\n        block = self._open_blocks[-1]\n        directive, _, spans = block[0:3]\n        self._check_if_matches_last(directive, \'if\', spans[-1], span, \'else\')\n        conds, contents = block[3:5]\n        conds.append(\'True\')\n        contents.append(self._curnode)\n        spans.append(span)\n        self._curnode = []\n\n\n    def handle_endif(self, span):\n        \'\'\'Should be called to signalize an endif directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._check_for_open_block(span, \'endif\')\n        block = self._open_blocks.pop(-1)\n        directive, _, spans = block[0:3]\n        self._check_if_matches_last(directive, \'if\', spans[-1], span, \'endif\')\n        _, contents = block[3:5]\n        contents.append(self._curnode)\n        spans.append(span)\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n\n\n    def handle_for(self, span, loopvar, iterator):\n        \'\'\'Should be called to signalize a for directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            varexpr (str): String representation of the loop variable\n                expression.\n            iterator (str): String representation of the iterable.\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        self._open_blocks.append((\'for\', self._curfile, [span], loopvar,\n                                  iterator, None))\n\n\n    def handle_endfor(self, span):\n        \'\'\'Should be called to signalize an endfor directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._check_for_open_block(span, \'endfor\')\n        block = self._open_blocks.pop(-1)\n        directive, fname, spans = block[0:3]\n        self._check_if_matches_last(directive, \'for\', spans[-1], span, \'endfor\')\n        loopvar, iterator, dummy = block[3:6]\n        spans.append(span)\n        block = (directive, fname, spans, loopvar, iterator, self._curnode)\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n\n\n    def handle_def(self, span, name, argexpr):\n        \'\'\'Should be called to signalize a def directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the macro to be defined.\n            argexpr (str): Macro argument definition or None\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        defblock = (\'def\', self._curfile, [span], name, argexpr, None)\n        self._open_blocks.append(defblock)\n\n\n    def handle_enddef(self, span, name):\n        \'\'\'Should be called to signalize an enddef directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the enddef statement. Could be None, if enddef\n                was specified without name.\n        \'\'\'\n        self._check_for_open_block(span, \'enddef\')\n        block = self._open_blocks.pop(-1)\n        directive, fname, spans = block[0:3]\n        self._check_if_matches_last(directive, \'def\', spans[-1], span, \'enddef\')\n        defname, argexpr, dummy = block[3:6]\n        if name is not None and name != defname:\n            msg = ""wrong name in enddef directive ""\\\n                  ""(expected \'{0}\', got \'{1}\')"".format(defname, name)\n            raise FyppFatalError(msg, fname, span)\n        spans.append(span)\n        block = (directive, fname, spans, defname, argexpr, self._curnode)\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n\n\n    def handle_call(self, span, name, argexpr):\n        \'\'\'Should be called to signalize a call directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the callable to call\n            argexpr (str or None): Argument expression containing additional\n                arguments for the call.\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        self._open_blocks.append(\n            (\'call\', self._curfile, [span, span], name, argexpr, [], []))\n\n\n    def handle_nextarg(self, span, name):\n        \'\'\'Should be called to signalize a nextarg directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str or None): Name of the argument following next or\n                None if it should be the next positional argument.\n        \'\'\'\n        self._check_for_open_block(span, \'nextarg\')\n        block = self._open_blocks[-1]\n        directive, fname, spans = block[0:3]\n        self._check_if_matches_last(\n            directive, \'call\', spans[-1], span, \'nextarg\')\n        args, argnames = block[5:7]\n        args.append(self._curnode)\n        spans.append(span)\n        if name is not None:\n            argnames.append(name)\n        elif argnames:\n            msg = \'non-keyword argument following keyword argument\'\n            raise FyppFatalError(msg, fname, span)\n        self._curnode = []\n\n\n    def handle_endcall(self, span, name):\n        \'\'\'Should be called to signalize an endcall directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the endcall statement. Could be None, if endcall\n                was specified without name.\n        \'\'\'\n        self._check_for_open_block(span, \'endcall\')\n        block = self._open_blocks.pop(-1)\n        directive, fname, spans = block[0:3]\n        self._check_if_matches_last(directive, \'call\', spans[0], span,\n                                    \'endcall\')\n        callname, callargexpr, args, argnames = block[3:7]\n        if name is not None and name != callname:\n            msg = ""wrong name in endcall directive ""\\\n                  ""(expected \'{0}\', got \'{1}\')"".format(callname, name)\n            raise FyppFatalError(msg, fname, span)\n        args.append(self._curnode)\n        # If nextarg or endcall immediately followed call, then first argument\n        # is empty and should be removed (to allow for calls without arguments\n        # and named first argument in calls)\n        if len(args) and not len(args[0]):\n            if len(argnames) == len(args):\n                del argnames[0]\n            del args[0]\n            del spans[1]\n        spans.append(span)\n        block = (directive, fname, spans, callname, callargexpr, args, argnames)\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n\n\n    def handle_set(self, span, name, expr):\n        \'\'\'Should be called to signalize a set directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable.\n            expr (str): String representation of the expression to be assigned\n                to the variable.\n        \'\'\'\n        self._curnode.append((\'set\', self._curfile, span, name, expr))\n\n\n    def handle_global(self, span, name):\n        \'\'\'Should be called to signalize a global directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable(s) to make global.\n        \'\'\'\n        self._curnode.append((\'global\', self._curfile, span, name))\n\n\n    def handle_del(self, span, name):\n        \'\'\'Should be called to signalize a del directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            name (str): Name of the variable(s) to delete.\n        \'\'\'\n        self._curnode.append((\'del\', self._curfile, span, name))\n\n\n    def handle_eval(self, span, expr):\n        \'\'\'Should be called to signalize an eval directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n            expr (str): String representation of the Python expression to\n                be evaluated.\n        \'\'\'\n        self._curnode.append((\'eval\', self._curfile, span, expr))\n\n\n    def handle_comment(self, span):\n        \'\'\'Should be called to signalize a comment directive.\n\n        The content of the comment is not needed by the builder, but it needs\n        the span of the comment to generate proper line numbers if needed.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._curnode.append((\'comment\', self._curfile, span))\n\n\n    def handle_text(self, span, txt):\n        \'\'\'Should be called to pass text which goes to output unaltered.\n\n        Args:\n            span (tuple of int): Start and end line of the text.\n            txt (str): Text.\n        \'\'\'\n        self._curnode.append((\'txt\', self._curfile, span, txt))\n\n\n    def handle_mute(self, span):\n        \'\'\'Should be called to signalize a mute directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._path.append(self._curnode)\n        self._curnode = []\n        self._open_blocks.append((\'mute\', self._curfile, [span], None))\n\n\n    def handle_endmute(self, span):\n        \'\'\'Should be called to signalize an endmute directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._check_for_open_block(span, \'endmute\')\n        block = self._open_blocks.pop(-1)\n        directive, fname, spans = block[0:3]\n        self._check_if_matches_last(directive, \'mute\', spans[-1], span,\n                                    \'endmute\')\n        spans.append(span)\n        block = (directive, fname, spans, self._curnode)\n        self._curnode = self._path.pop(-1)\n        self._curnode.append(block)\n\n\n    def handle_stop(self, span, msg):\n        \'\'\'Should be called to signalize a stop directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._curnode.append((\'stop\', self._curfile, span, msg))\n\n\n    def handle_assert(self, span, cond):\n        \'\'\'Should be called to signalize an assert directive.\n\n        Args:\n            span (tuple of int): Start and end line of the directive.\n        \'\'\'\n        self._curnode.append((\'assert\', self._curfile, span, cond))\n\n\n    @property\n    def tree(self):\n        \'\'\'Returns the tree built by the Builder.\'\'\'\n        return self._tree\n\n\n    def _check_for_open_block(self, span, directive):\n        if len(self._open_blocks) <= self._nr_prev_blocks[-1]:\n            msg = \'unexpected {0} directive\'.format(directive)\n            raise FyppFatalError(msg, self._curfile, span)\n\n\n    def _check_if_matches_last(self, lastdir, curdir, lastspan, curspan,\n                               directive):\n        if curdir != lastdir:\n            msg = ""mismatching \'{0}\' directive (last block opened was \'{1}\')""\\\n                .format(directive, lastdir)\n            raise FyppFatalError(msg, self._curfile, curspan)\n        inline_last = lastspan[0] == lastspan[1]\n        inline_cur = curspan[0] == curspan[1]\n        if inline_last != inline_cur:\n            if inline_cur:\n                msg = \'expecting line form of directive {0}\'.format(directive)\n            else:\n                msg = \'expecting inline form of directive {0}\'.format(directive)\n            raise FyppFatalError(msg, self._curfile, curspan)\n        elif inline_cur and curspan[0] != lastspan[0]:\n            msg = \'inline directives of the same construct must be in the \'\\\n                  \'same row\'\n            raise FyppFatalError(msg, self._curfile, curspan)\n\n\nclass Renderer:\n\n    \'\'\'\'Renders a tree.\n\n    Args:\n        evaluator (Evaluator, optional): Evaluator to use when rendering eval\n            directives. If None (default), Evaluator() is used.\n        linenums (bool, optional): Whether linenums should be generated,\n            defaults to False.\n        contlinenums (bool, optional): Whether linenums for continuation\n            should be generated, defaults to False.\n        linenumformat (str, optional): If set to ""gfortran5"", a workaround\n            for broken gfortran versions (version 5.1 and above) is applied when\n            emitting line numbering directives.\n        linefolder (callable): Callable to use when folding a line.\n    \'\'\'\n\n    def __init__(self, evaluator=None, linenums=False, contlinenums=False,\n                 linenumformat=None, linefolder=None):\n        # Evaluator to use for Python expressions\n        self._evaluator = Evaluator() if evaluator is None else evaluator\n\n        # Whether rendered output is diverted and will be processed\n        # further before output (if True: no line numbering and post processing)\n        self._diverted = False\n\n        # Whether file name and line numbers should be kept fixed and\n        # not updated (typically when rendering macro content)\n        self._fixedposition = False\n\n        # Whether line numbering directives should be emitted\n        self._linenums = linenums\n\n        # Whether line numbering directives in continuation lines are needed.\n        self._contlinenums = contlinenums\n\n        # Whether to use the fix for GFortran in the line numbering directives\n        self._linenum_gfortran5 = (linenumformat == \'gfortran5\')\n\n        # Callable to be used for folding lines\n        if linefolder is None:\n            self._linefolder = lambda line: [line]\n        else:\n            self._linefolder = linefolder\n\n\n    def render(self, tree, divert=False, fixposition=False):\n        \'\'\'Renders a tree.\n\n        Args:\n            tree (fypp-tree): Tree to render.\n            divert (bool): Whether output will be diverted and sent for further\n                processing, so that no line numbering directives and\n                postprocessing are needed at this stage. (Default: False)\n            fixposition (bool): Whether file name and line position (variables\n                _FILE_ and _LINE_) should be kept at their current values or\n                should be updated continuously. (Default: False).\n\n        Returns: str: Rendered string.\n        \'\'\'\n        diverted = self._diverted\n        self._diverted = divert\n        fixedposition = self._fixedposition\n        self._fixedposition = fixposition\n        output, eval_inds, eval_pos = self._render(tree)\n        if not self._diverted and eval_inds:\n            self._postprocess_eval_lines(output, eval_inds, eval_pos)\n        self._diverted = diverted\n        self._fixedposition = fixedposition\n        txt = \'\'.join(output)\n\n        return txt\n\n\n    def _render(self, tree):\n        output = []\n        eval_inds = []\n        eval_pos = []\n        for node in tree:\n            cmd = node[0]\n            if cmd == \'txt\':\n                output.append(node[3])\n            elif cmd == \'if\':\n                out, ieval, peval = self._get_conditional_content(*node[1:5])\n                eval_inds += _shiftinds(ieval, len(output))\n                eval_pos += peval\n                output += out\n            elif cmd == \'eval\':\n                out, ieval, peval = self._get_eval(*node[1:4])\n                eval_inds += _shiftinds(ieval, len(output))\n                eval_pos += peval\n                output += out\n            elif cmd == \'def\':\n                result = self._define_macro(*node[1:6])\n                output.append(result)\n            elif cmd == \'set\':\n                result = self._define_variable(*node[1:5])\n                output.append(result)\n            elif cmd == \'del\':\n                self._delete_variable(*node[1:4])\n            elif cmd == \'for\':\n                out, ieval, peval = self._get_iterated_content(*node[1:6])\n                eval_inds += _shiftinds(ieval, len(output))\n                eval_pos += peval\n                output += out\n            elif cmd == \'call\':\n                out, ieval, peval = self._get_called_content(*node[1:7])\n                eval_inds += _shiftinds(ieval, len(output))\n                eval_pos += peval\n                output += out\n            elif cmd == \'include\':\n                out, ieval, peval = self._get_included_content(*node[1:5])\n                eval_inds += _shiftinds(ieval, len(output))\n                eval_pos += peval\n                output += out\n            elif cmd == \'comment\':\n                output.append(self._get_comment(*node[1:3]))\n            elif cmd == \'mute\':\n                output.append(self._get_muted_content(*node[1:4]))\n            elif cmd == \'stop\':\n                self._handle_stop(*node[1:4])\n            elif cmd == \'assert\':\n                result = self._handle_assert(*node[1:4])\n                output.append(result)\n            elif cmd == \'global\':\n                self._add_global(*node[1:4])\n            else:\n                msg = ""internal error: unknown command \'{0}\'"".format(cmd)\n                raise FyppFatalError(msg)\n        return output, eval_inds, eval_pos\n\n\n    def _get_eval(self, fname, span, expr):\n        try:\n            result = self._evaluate(expr, fname, span[0])\n        except Exception as exc:\n            msg = ""exception occured when evaluating \'{0}\'"".format(expr)\n            raise FyppFatalError(msg, fname, span, exc)\n        out = []\n        ieval = []\n        peval = []\n        if result is not None:\n            out.append(str(result))\n            if not self._diverted:\n                ieval.append(0)\n                peval.append((span, fname))\n        if span[0] != span[1]:\n            out.append(\'\\n\')\n        return out, ieval, peval\n\n\n    def _get_conditional_content(self, fname, spans, conditions, contents):\n        out = []\n        ieval = []\n        peval = []\n        multiline = (spans[0][0] != spans[-1][1])\n        for condition, content, span in zip(conditions, contents, spans):\n            try:\n                cond = bool(self._evaluate(condition, fname, span[0]))\n            except Exception as exc:\n                msg = ""exception occured when evaluating \'{0}\'""\\\n                      .format(condition)\n                raise FyppFatalError(msg, fname, span, exc)\n            if cond:\n                if self._linenums and not self._diverted and multiline:\n                    out.append(linenumdir(span[1], fname))\n                outcont, ievalcont, pevalcont = self._render(content)\n                ieval += _shiftinds(ievalcont, len(out))\n                peval += pevalcont\n                out += outcont\n                break\n        if self._linenums and not self._diverted and multiline:\n            out.append(linenumdir(spans[-1][1], fname))\n        return out, ieval, peval\n\n\n    def _get_iterated_content(self, fname, spans, loopvars, loopiter, content):\n        out = []\n        ieval = []\n        peval = []\n        try:\n            iterobj = iter(self._evaluate(loopiter, fname, spans[0][0]))\n        except Exception as exc:\n            msg = ""exception occured when evaluating \'{0}\'""\\\n                .format(loopiter)\n            raise FyppFatalError(msg, fname, spans[0], exc)\n        multiline = (spans[0][0] != spans[-1][1])\n        for var in iterobj:\n            if len(loopvars) == 1:\n                self._define(loopvars[0], var)\n            else:\n                for varname, value in zip(loopvars, var):\n                    self._define(varname, value)\n            if self._linenums and not self._diverted and multiline:\n                out.append(linenumdir(spans[0][1], fname))\n            outcont, ievalcont, pevalcont = self._render(content)\n            ieval += _shiftinds(ievalcont, len(out))\n            peval += pevalcont\n            out += outcont\n        if self._linenums and not self._diverted and multiline:\n            out.append(linenumdir(spans[1][1], fname))\n        return out, ieval, peval\n\n\n    def _get_called_content(self, fname, spans, name, argexpr, contents,\n                            argnames):\n        posargs, kwargs = self._get_call_arguments(fname, spans, argexpr,\n                                                   contents, argnames)\n        # Since callobj uses the evaluators scope, the globals must be updated\n        # before calling it.\n        self._update_globals(fname, spans[0][0])\n        try:\n            callobj = self._evaluate(name, fname, spans[0][0])\n            result = callobj(*posargs, **kwargs)\n        except Exception as exc:\n            msg = ""exception occured when calling \'{0}\'"".format(name)\n            raise FyppFatalError(msg, fname, spans[0], exc)\n        span = (spans[0][0], spans[-1][1])\n        out = []\n        ieval = []\n        peval = []\n        if result is not None:\n            out = [str(result)]\n            if not self._diverted:\n                ieval = [0]\n                peval = [(span, fname)]\n        if span[0] != span[1]:\n            out.append(\'\\n\')\n        return out, ieval, peval\n\n\n    def _get_call_arguments(self, fname, spans, argexpr, contents, argnames):\n        if argexpr is None:\n            posargs = []\n            kwargs = {}\n        else:\n            # Parse and evaluate arguments passed in call header\n            self._evaluator.openscope()\n            try:\n                posargs, kwargs = self._evaluate(\n                    \'__getargvalues(\' + argexpr + \')\', fname, spans[0][0])\n            except Exception as exc:\n                msg = ""unable to parse argument expression \'{0}\'""\\\n                    .format(argexpr)\n                raise FyppFatalError(msg, fname, spans[0], exc)\n            self._evaluator.closescope()\n\n        # Render arguments passed in call body\n        args = []\n        for content in contents:\n            self._evaluator.openscope()\n            rendered = self.render(content, divert=True)\n            self._evaluator.closescope()\n            if rendered.endswith(\'\\n\'):\n                rendered = rendered[:-1]\n            args.append(rendered)\n\n        # Separate arguments in call body into positional and keyword ones:\n        if argnames:\n            posargs += args[:len(args) - len(argnames)]\n            offset = len(args) - len(argnames)\n            for iargname, argname in enumerate(argnames):\n                ind = offset + iargname\n                if argname in kwargs:\n                    msg = ""keyword argument \'{0}\' already defined""\\\n                        .format(argname)\n                    raise FyppFatalError(msg, fname, spans[ind + 1])\n                kwargs[argname] = args[ind]\n        else:\n            posargs += args\n\n        return posargs, kwargs\n\n\n    def _get_included_content(self, fname, spans, includefname, content):\n        includefile = spans[0] is not None\n        out = []\n        if self._linenums and not self._diverted:\n            if includefile or self._linenum_gfortran5:\n                out += linenumdir(0, includefname, _LINENUM_NEW_FILE)\n            else:\n                out += linenumdir(0, includefname)\n        outcont, ieval, peval = self._render(content)\n        ieval = _shiftinds(ieval, len(out))\n        out += outcont\n        if self._linenums and not self._diverted and includefile:\n            out += linenumdir(spans[0][1], fname, _LINENUM_RETURN_TO_FILE)\n        return out, ieval, peval\n\n\n    def _define_macro(self, fname, spans, name, argexpr, content):\n        if argexpr is None:\n            args = []\n            defaults = {}\n            varargs = None\n        else:\n            # Try to create a lambda function with the argument expression\n            self._evaluator.openscope()\n            lambdaexpr = \'lambda \' + argexpr + \': None\'\n            try:\n                func = self._evaluate(lambdaexpr, fname, spans[0][0])\n            except Exception as exc:\n                msg = ""exception occured when evaluating argument expression ""\\\n                      ""\'{0}\'"".format(argexpr)\n                raise FyppFatalError(msg, fname, spans[0], exc)\n            self._evaluator.closescope()\n            try:\n                args, defaults, varargs = _get_callable_argspec(func)\n            except Exception as exc:\n                msg = ""invalid argument expression \'{0}\'"".format(argexpr)\n                raise FyppFatalError(msg, fname, spans[0], exc)\n            named_args = args if varargs is None else args + [varargs]\n            for arg in named_args:\n                if arg in _RESERVED_NAMES or arg.startswith(_RESERVED_PREFIX):\n                    msg = ""invalid argument name \'{0}\'"".format(arg)\n                    raise FyppFatalError(msg, fname, spans[0])\n        result = \'\'\n        try:\n            macro = _Macro(\n                name, fname, spans, args, defaults, varargs, content, self,\n                self._evaluator, self._evaluator.localscope)\n            self._define(name, macro)\n        except Exception as exc:\n            msg = ""exception occured when defining macro \'{0}\'""\\\n                .format(name)\n            raise FyppFatalError(msg, fname, spans[0], exc)\n        if self._linenums and not self._diverted:\n            result = linenumdir(spans[1][1], fname)\n        return result\n\n\n    def _define_variable(self, fname, span, name, valstr):\n        result = \'\'\n        try:\n            self._define(name, self._evaluate(valstr, fname, span[0]))\n        except Exception as exc:\n            msg = ""exception occured when setting variable(s) \'{0}\' to \'{1}\'""\\\n                .format(name, valstr)\n            raise FyppFatalError(msg, fname, span, exc)\n        multiline = (span[0] != span[1])\n        if self._linenums and not self._diverted and multiline:\n            result = linenumdir(span[1], fname)\n        return result\n\n\n    def _delete_variable(self, fname, span, name):\n        result = \'\'\n        try:\n            self._evaluator.undefine(name)\n        except Exception as exc:\n            msg = ""exception occured when deleting variable(s) \'{0}\'""\\\n                  .format(name)\n            raise FyppFatalError(msg, fname, span, exc)\n        multiline = (span[0] != span[1])\n        if self._linenums and not self._diverted and multiline:\n            result = linenumdir(span[1], fname)\n        return result\n\n\n    def _add_global(self, fname, span, name):\n        result = \'\'\n        try:\n            self._evaluator.addglobal(name)\n        except Exception as exc:\n            msg = ""exception occured when making variable(s) \'{0}\' global""\\\n                .format(name)\n            raise FyppFatalError(msg, fname, span, exc)\n        multiline = (span[0] != span[1])\n        if self._linenums and not self._diverted and multiline:\n            result = linenumdir(span[1], fname)\n        return result\n\n\n    def _get_comment(self, fname, span):\n        if self._linenums and not self._diverted:\n            return linenumdir(span[1], fname)\n        else:\n            return \'\'\n\n\n    def _get_muted_content(self, fname, spans, content):\n        self._render(content)\n        if self._linenums and not self._diverted:\n            return linenumdir(spans[-1][1], fname)\n        else:\n            return \'\'\n\n\n    def _handle_stop(self, fname, span, msgstr):\n        try:\n            msg = str(self._evaluate(msgstr, fname, span[0]))\n        except Exception as exc:\n            msg = ""exception occured when evaluating stop message \'{0}\'""\\\n                .format(msgstr)\n            raise FyppFatalError(msg, fname, span, exc)\n        raise FyppStopRequest(msg, fname, span)\n\n\n    def _handle_assert(self, fname, span, expr):\n        result = \'\'\n        try:\n            cond = bool(self._evaluate(expr, fname, span[0]))\n        except Exception as exc:\n            msg = ""exception occured when evaluating assert condition \'{0}\'""\\\n                .format(expr)\n            raise FyppFatalError(msg, fname, span, exc)\n        if not cond:\n            msg = ""Assertion failed (\'{0}\')"".format(expr)\n            raise FyppStopRequest(msg, fname, span)\n        if self._linenums and not self._diverted:\n            result = linenumdir(span[1], fname)\n        return result\n\n\n    def _evaluate(self, expr, fname, linenr):\n        self._update_globals(fname, linenr)\n        return self._evaluator.evaluate(expr)\n\n\n    def _update_globals(self, fname, linenr):\n        self._evaluator.updatelocals(\n            _DATE_=time.strftime(\'%Y-%m-%d\'), _TIME_=time.strftime(\'%H:%M:%S\'),\n            _THIS_FILE_=fname, _THIS_LINE_=linenr + 1)\n        if not self._fixedposition:\n            self._evaluator.updatelocals(_FILE_=fname, _LINE_=linenr + 1)\n\n\n    def _define(self, var, value):\n        self._evaluator.define(var, value)\n\n\n    def _postprocess_eval_lines(self, output, eval_inds, eval_pos):\n        ilastproc = -1\n        for ieval, ind in enumerate(eval_inds):\n            span, fname = eval_pos[ieval]\n            if ind <= ilastproc:\n                continue\n            iprev, eolprev = self._find_last_eol(output, ind)\n            inext, eolnext = self._find_next_eol(output, ind)\n            curline = self._glue_line(output, ind, iprev, eolprev, inext,\n                                      eolnext)\n            output[iprev + 1:inext] = [\'\'] * (inext - iprev - 1)\n            output[ind] = self._postprocess_eval_line(curline, fname, span)\n            ilastproc = inext\n\n\n    @staticmethod\n    def _find_last_eol(output, ind):\n        \'Find last newline before current position.\'\n        iprev = ind - 1\n        while iprev >= 0:\n            eolprev = output[iprev].rfind(\'\\n\')\n            if eolprev != -1:\n                break\n            iprev -= 1\n        else:\n            iprev = 0\n            eolprev = -1\n        return iprev, eolprev\n\n\n    @staticmethod\n    def _find_next_eol(output, ind):\n        \'Find last newline before current position.\'\n        # find first eol after expr. evaluation\n        inext = ind + 1\n        while inext < len(output):\n            eolnext = output[inext].find(\'\\n\')\n            if eolnext != -1:\n                break\n            inext += 1\n        else:\n            inext = len(output) - 1\n            eolnext = len(output[-1]) - 1\n        return inext, eolnext\n\n\n    @staticmethod\n    def _glue_line(output, ind, iprev, eolprev, inext, eolnext):\n        \'Create line from parts between specified boundaries.\'\n        curline_parts = []\n        if iprev != ind:\n            curline_parts = [output[iprev][eolprev + 1:]]\n            output[iprev] = output[iprev][:eolprev + 1]\n        curline_parts.extend(output[iprev + 1:ind])\n        curline_parts.extend(output[ind])\n        curline_parts.extend(output[ind + 1:inext])\n        if inext != ind:\n            curline_parts.append(output[inext][:eolnext + 1])\n            output[inext] = output[inext][eolnext + 1:]\n        return \'\'.join(curline_parts)\n\n\n    def _postprocess_eval_line(self, evalline, fname, span):\n        lines = evalline.split(\'\\n\')\n        # If line ended on \'\\n\', last element is \'\'. We remove it and\n        # add the trailing newline later manually.\n        trailing_newline = (lines[-1] == \'\')\n        if trailing_newline:\n            del lines[-1]\n        lnum = linenumdir(span[0], fname) if self._linenums else \'\'\n        clnum = lnum if self._contlinenums else \'\'\n        linenumsep = \'\\n\' + lnum\n        clinenumsep = \'\\n\' + clnum\n        foldedlines = [self._foldline(line) for line in lines]\n        outlines = [clinenumsep.join(lines) for lines in foldedlines]\n        result = linenumsep.join(outlines)\n        # Add missing trailing newline\n        if trailing_newline:\n            trailing = \'\\n\'\n            if self._linenums:\n                # Last line was folded, but no linenums were generated for\n                # the continuation lines -> current line position is not\n                # in sync with the one calculated from the last line number\n                unsync = (\n                    len(foldedlines) and len(foldedlines[-1]) > 1\n                    and not self._contlinenums)\n                # Eval directive in source consists of more than one line\n                multiline = span[1] - span[0] > 1\n                if unsync or multiline:\n                    # For inline eval directives span[0] == span[1]\n                    # -> next line is span[0] + 1 and not span[1] as for\n                    # line eval directives\n                    nextline = max(span[1], span[0] + 1)\n                    trailing += linenumdir(nextline, fname)\n        else:\n            trailing = \'\'\n        return result + trailing\n\n\n    def _foldline(self, line):\n        if _COMMENTLINE_REGEXP.match(line) is None:\n            return self._linefolder(line)\n        else:\n            return [line]\n\n\nclass Evaluator:\n\n    \'\'\'Provides an isolated environment for evaluating Python expressions.\n\n    It restricts the builtins which can be used within this environment to a\n    (hopefully safe) subset. Additionally it defines the functions which are\n    provided by the preprocessor for the eval directives.\n\n    Args:\n        env (dict, optional): Initial definitions for the environment, defaults\n            to None.\n    \'\'\'\n\n    # Restricted builtins working in all supported Python verions. Version\n    # specific ones are added dynamically in _get_restricted_builtins().\n    _RESTRICTED_BUILTINS = {\n        \'abs\': builtins.abs,\n        \'all\': builtins.all,\n        \'any\': builtins.any,\n        \'bin\': builtins.bin,\n        \'bool\': builtins.bool,\n        \'bytearray\': builtins.bytearray,\n        \'bytes\': builtins.bytes,\n        \'chr\': builtins.chr,\n        \'classmethod\': builtins.classmethod,\n        \'complex\': builtins.complex,\n        \'delattr\': builtins.delattr,\n        \'dict\': builtins.dict,\n        \'dir\': builtins.dir,\n        \'divmod\': builtins.divmod,\n        \'enumerate\': builtins.enumerate,\n        \'filter\': builtins.filter,\n        \'float\': builtins.float,\n        \'format\': builtins.format,\n        \'frozenset\': builtins.frozenset,\n        \'getattr\': builtins.getattr,\n        \'globals\': builtins.globals,\n        \'hasattr\': builtins.hasattr,\n        \'hash\': builtins.hash,\n        \'hex\': builtins.hex,\n        \'id\': builtins.id,\n        \'int\': builtins.int,\n        \'isinstance\': builtins.isinstance,\n        \'issubclass\': builtins.issubclass,\n        \'iter\': builtins.iter,\n        \'len\': builtins.len,\n        \'list\': builtins.list,\n        \'locals\': builtins.locals,\n        \'map\': builtins.map,\n        \'max\': builtins.max,\n        \'min\': builtins.min,\n        \'next\': builtins.next,\n        \'object\': builtins.object,\n        \'oct\': builtins.oct,\n        \'ord\': builtins.ord,\n        \'pow\': builtins.pow,\n        \'property\': builtins.property,\n        \'range\': builtins.range,\n        \'repr\': builtins.repr,\n        \'reversed\': builtins.reversed,\n        \'round\': builtins.round,\n        \'set\': builtins.set,\n        \'setattr\': builtins.setattr,\n        \'slice\': builtins.slice,\n        \'sorted\': builtins.sorted,\n        \'staticmethod\': builtins.staticmethod,\n        \'str\': builtins.str,\n        \'sum\': builtins.sum,\n        \'super\': builtins.super,\n        \'tuple\': builtins.tuple,\n        \'type\': builtins.type,\n        \'vars\': builtins.vars,\n        \'zip\': builtins.zip,\n    }\n\n    def __init__(self, env=None):\n\n        # Global scope\n        self._globals = env if env is not None else {}\n\n        # Local scope(s)\n        self._locals = None\n        self._locals_stack = []\n\n        # Variables which are references to entries in global scope\n        self._globalrefs = None\n        self._globalrefs_stack = []\n\n        # Current scope (globals + locals in all embedding and in current scope)\n        self._scope = self._globals\n\n        # Turn on restricted mode\n        self._restrict_builtins()\n\n\n    def evaluate(self, expr):\n        \'\'\'Evaluate a Python expression using the `eval()` builtin.\n\n        Args:\n            expr (str): String represantion of the expression.\n\n        Return:\n            Python object: Result of the expression evaluation.\n        \'\'\'\n        result = eval(expr, self._scope)\n        return result\n\n\n    def import_module(self, module):\n        \'\'\'Import a module into the evaluator.\n\n        Note: Import only trustworthy modules! Module imports are global,\n        therefore, importing a malicious module which manipulates other global\n        modules could affect code behaviour outside of the Evaluator as well.\n\n        Args:\n            module (str): Python module to import.\n\n        Raises:\n            FyppFatalError: If module could not be imported.\n\n        \'\'\'\n        rootmod = module.split(\'.\', 1)[0]\n        try:\n            imported = __import__(module, self._scope)\n            self.define(rootmod, imported)\n        except Exception as exc:\n            msg = ""failed to import module \'{0}\'"".format(module)\n            raise FyppFatalError(msg, cause=exc)\n\n\n    def define(self, name, value):\n        \'\'\'Define a Python entity.\n\n        Args:\n            name (str): Name of the entity.\n            value (Python object): Value of the entity.\n\n        Raises:\n            FyppFatalError: If name starts with the reserved prefix or if it is\n                a reserved name.\n        \'\'\'\n        varnames = self._get_variable_names(name)\n        if len(varnames) == 1:\n            value = (value,)\n        elif len(varnames) != len(value):\n            msg = \'value for tuple assignment has incompatible length\'\n            raise FyppFatalError(msg)\n        for varname, varvalue in zip(varnames, value):\n            self._check_variable_name(varname)\n            if self._locals is None:\n                self._globals[varname] = varvalue\n            else:\n                if varname in self._globalrefs:\n                    self._globals[varname] = varvalue\n                else:\n                    self._locals[varname] = varvalue\n                self._scope[varname] = varvalue\n\n\n    def undefine(self, name):\n        \'\'\'Undefine a Python entity.\n\n        Args:\n            name (str): Name of the entity to undefine.\n\n        Raises:\n            FyppFatalError: If name starts with the reserved prefix or if it is\n                a reserved name.\n        \'\'\'\n        varnames = self._get_variable_names(name)\n        for varname in varnames:\n            self._check_variable_name(varname)\n            deleted = False\n            if self._locals is None:\n                if varname in self._globals:\n                    del self._globals[varname]\n                    deleted = True\n            else:\n                if varname in self._locals:\n                    del self._locals[varname]\n                    del self._scope[varname]\n                    deleted = True\n                elif varname in self._globalrefs and varname in self._globals:\n                    del self._globals[varname]\n                    del self._scope[varname]\n                    deleted = True\n            if not deleted:\n                msg = ""lookup for an erasable instance of \'{0}\' failed""\\\n                      .format(varname)\n                raise FyppFatalError(msg)\n\n\n    def addglobal(self, name):\n        \'\'\'Define a given entity as global.\n\n        Args:\n            name (str): Name of the entity to make global.\n\n        Raises:\n            FyppFatalError: If entity name is invalid or if the current scope is\n                 a local scope and entity is already defined in it.\n        \'\'\'\n        varnames = self._get_variable_names(name)\n        for varname in varnames:\n            self._check_variable_name(varname)\n            if self._locals is not None:\n                if varname in self._locals:\n                    msg = ""variable \'{0}\' already defined in local scope""\\\n                          .format(varname)\n                    raise FyppFatalError(msg)\n                self._globalrefs.add(varname)\n\n\n    def updatelocals(self, **vardict):\n        \'\'\'Update variables in the local scope.\n\n        This is a shortcut function to inject variables in the local scope\n        without extensive checks (as in define()). Vardict must not contain any\n        entries which have been made global via addglobal() before. In order to\n        ensure this, updatelocals() should be called immediately after\n        openscope(), or with variable names, which are warrantedly not globlas\n        (e.g variables starting with forbidden prefix)\n\n        Args:\n            **vardict: variable defintions.\n        \'\'\'\n        self._scope.update(vardict)\n        if self._locals is not None:\n            self._locals.update(vardict)\n\n\n    def openscope(self, customlocals=None):\n        \'\'\'Opens a new (embedded) scope.\n\n        Args:\n            customlocals (dict): By default, the locals of the embedding scope\n                are visible in the new one. When this is not the desired\n                behaviour a dictionary of customized locals can be passed,\n                and those locals will become the only visible ones.\n        \'\'\'\n        self._locals_stack.append(self._locals)\n        self._globalrefs_stack.append(self._globalrefs)\n        if customlocals is not None:\n            self._locals = customlocals.copy()\n        elif self._locals is not None:\n            self._locals = self._locals.copy()\n        else:\n            self._locals = {}\n        self._globalrefs = set()\n        self._scope = self._globals.copy()\n        self._scope.update(self._locals)\n\n\n    def closescope(self):\n        \'\'\'Close scope and restore embedding scope.\'\'\'\n        self._locals = self._locals_stack.pop(-1)\n        self._globalrefs = self._globalrefs_stack.pop(-1)\n        if self._locals is not None:\n            self._scope = self._globals.copy()\n            self._scope.update(self._locals)\n        else:\n            self._scope = self._globals\n\n\n    @property\n    def globalscope(self):\n        \'Dictionary of the global scope.\'\n        return self._globals\n\n\n    @property\n    def localscope(self):\n        \'Dictionary of the current local scope.\'\n        return self._locals\n\n\n    def _restrict_builtins(self):\n        builtindict = self._get_restricted_builtins()\n        builtindict[\'__import__\'] = self._func_import\n        builtindict[\'defined\'] = self._func_defined\n        builtindict[\'setvar\'] = self._func_setvar\n        builtindict[\'getvar\'] = self._func_getvar\n        builtindict[\'delvar\'] = self._func_delvar\n        builtindict[\'globalvar\'] = self._func_globalvar\n        builtindict[\'__getargvalues\'] = self._func_getargvalues\n        self._globals[\'__builtins__\'] = builtindict\n\n\n    @classmethod\n    def _get_restricted_builtins(cls):\n        bidict = dict(cls._RESTRICTED_BUILTINS)\n        major = sys.version_info[0]\n        if major == 2:\n            bidict[\'True\'] = True\n            bidict[\'False\'] = False\n        return bidict\n\n\n    @staticmethod\n    def _get_variable_names(varexpr):\n        lpar = varexpr.startswith(\'(\')\n        rpar = varexpr.endswith(\')\')\n        if lpar != rpar:\n            msg = ""unbalanced paranthesis around variable varexpr(s) in \'{0}\'""\\\n                .format(varexpr)\n            raise FyppFatalError(msg, None, None)\n        if lpar:\n            varexpr = varexpr[1:-1]\n        varnames = [s.strip() for s in varexpr.split(\',\')]\n        return varnames\n\n\n    @staticmethod\n    def _check_variable_name(varname):\n        if varname.startswith(_RESERVED_PREFIX):\n            msg = ""Name \'{0}\' starts with reserved prefix \'{1}\'""\\\n                .format(varname, _RESERVED_PREFIX)\n            raise FyppFatalError(msg, None, None)\n        if varname in _RESERVED_NAMES:\n            msg = ""Name \'{0}\' is reserved and can not be redefined""\\\n                .format(varname)\n            raise FyppFatalError(msg, None, None)\n\n\n    def _func_defined(self, var):\n        defined = var in self._scope\n        return defined\n\n\n    def _func_import(self, name, *_, **__):\n        module = self._scope.get(name, None)\n        if module is not None and isinstance(module, types.ModuleType):\n            return module\n        else:\n            msg = ""Import of module \'{0}\' via \'__import__\' not allowed""\\\n                  .format(name)\n            raise ImportError(msg)\n\n\n    def _func_setvar(self, *namesvalues):\n        if len(namesvalues) % 2:\n            msg = \'setvar function needs an even number of arguments\'\n            raise FyppFatalError(msg)\n        for ind in range(0, len(namesvalues), 2):\n            self.define(namesvalues[ind], namesvalues[ind + 1])\n\n\n    def _func_getvar(self, name, defvalue=None):\n        if name in self._scope:\n            return self._scope[name]\n        else:\n            return defvalue\n\n\n    def _func_delvar(self, *names):\n        for name in names:\n            self.undefine(name)\n\n\n    def _func_globalvar(self, *names):\n        for name in names:\n            self.addglobal(name)\n\n\n    @staticmethod\n    def _func_getargvalues(*args, **kwargs):\n        return list(args), kwargs\n\n\n\nclass _Macro:\n\n    \'\'\'Represents a user defined macro.\n\n    This object should only be initiatied by a Renderer instance, as it\n    needs access to Renderers internal variables and methods.\n\n    Args:\n        name (str): Name of the macro.\n        fname (str): The file where the macro was defined.\n        spans (str): Line spans of macro defintion.\n        argnames (list of str): Macro dummy arguments.\n        varargs (str): Name of variable positional arguments or None.\n        content (list): Content of the macro as tree.\n        renderer (Renderer): Renderer to use for evaluating macro content.\n        localscope (dict): Dictionary with local variables, which should be used\n            the local scope, when the macro is called. Default: None (empty\n            local scope).\n    \'\'\'\n\n    def __init__(self, name, fname, spans, argnames, defaults, varargs, content,\n                 renderer, evaluator, localscope=None):\n        self._name = name\n        self._fname = fname\n        self._spans = spans\n        self._argnames = argnames\n        self._defaults = defaults\n        self._varargs = varargs\n        self._content = content\n        self._renderer = renderer\n        self._evaluator = evaluator\n        self._localscope = localscope if localscope is not None else {}\n\n\n    def __call__(self, *args, **keywords):\n        argdict = self._process_arguments(args, keywords)\n        self._evaluator.openscope(customlocals=self._localscope)\n        self._evaluator.updatelocals(**argdict)\n        output = self._renderer.render(self._content, divert=True,\n                                       fixposition=True)\n        self._evaluator.closescope()\n        if output.endswith(\'\\n\'):\n            return output[:-1]\n        else:\n            return output\n\n\n    def _process_arguments(self, args, keywords):\n        argdict = {}\n        nargs = min(len(args), len(self._argnames))\n        for iarg in range(nargs):\n            argdict[self._argnames[iarg]] = args[iarg]\n        if nargs < len(args):\n            if self._varargs is None:\n                msg = ""macro \'{0}\' called with too many positional arguments ""\\\n                      ""(expected: {1}, received: {2})""\\\n                      .format(self._name, len(self._argnames), len(args))\n                raise FyppFatalError(msg, self._fname, self._spans[0])\n            else:\n                argdict[self._varargs] = tuple(args[nargs:])\n        elif self._varargs is not None:\n            argdict[self._varargs] = ()\n        for argname in self._argnames[:nargs]:\n            if argname in keywords:\n                msg = ""got multiple values for argument \'{0}\'"".format(argname)\n                raise FyppFatalError(msg, self._fname, self._spans[0])\n        if self._varargs is not None and self._varargs in keywords:\n            msg = ""got unexpected keyword argument \'{0}\'"".format(self._varargs)\n            raise FyppFatalError(msg, self._fname, self._spans[0])\n        argdict.update(keywords)\n        if nargs < len(self._argnames):\n            for argname in self._argnames[nargs:]:\n                if argname in argdict:\n                    pass\n                elif argname in self._defaults:\n                    argdict[argname] = self._defaults[argname]\n                else:\n                    msg = ""macro \'{0}\' called without mandatory positional ""\\\n                          ""argument \'{1}\'"".format(self._name, argname)\n                    raise FyppFatalError(msg, self._fname, self._spans[0])\n        return argdict\n\n\n\nclass Processor:\n\n    \'\'\'Connects various objects with each other to create a processor.\n\n    Args:\n        parser (Parser, optional): Parser to use for parsing text. If None\n            (default), `Parser()` is used.\n        builder (Builder, optional): Builder to use for building the tree\n            representation of the text. If None (default), `Builder()` is used.\n        renderer (Renderer, optional): Renderer to use for rendering the\n            output. If None (default), `Renderer()` is used with a default\n            Evaluator().\n        evaluator (Evaluator, optional): Evaluator to use for evaluating Python\n            expressions. If None (default), `Evaluator()` is used.\n    \'\'\'\n\n    def __init__(self, parser=None, builder=None, renderer=None,\n                 evaluator=None):\n        self._parser = Parser() if parser is None else parser\n        self._builder = Builder() if builder is None else builder\n        if renderer is None:\n            evaluator = Evaluator() if evaluator is None else evaluator\n            self._renderer = Renderer(evaluator)\n        else:\n            self._renderer = renderer\n\n        self._parser.handle_include = self._builder.handle_include\n        self._parser.handle_endinclude = self._builder.handle_endinclude\n        self._parser.handle_if = self._builder.handle_if\n        self._parser.handle_else = self._builder.handle_else\n        self._parser.handle_elif = self._builder.handle_elif\n        self._parser.handle_endif = self._builder.handle_endif\n        self._parser.handle_eval = self._builder.handle_eval\n        self._parser.handle_text = self._builder.handle_text\n        self._parser.handle_def = self._builder.handle_def\n        self._parser.handle_enddef = self._builder.handle_enddef\n        self._parser.handle_set = self._builder.handle_set\n        self._parser.handle_del = self._builder.handle_del\n        self._parser.handle_global = self._builder.handle_global\n        self._parser.handle_for = self._builder.handle_for\n        self._parser.handle_endfor = self._builder.handle_endfor\n        self._parser.handle_call = self._builder.handle_call\n        self._parser.handle_nextarg = self._builder.handle_nextarg\n        self._parser.handle_endcall = self._builder.handle_endcall\n        self._parser.handle_comment = self._builder.handle_comment\n        self._parser.handle_mute = self._builder.handle_mute\n        self._parser.handle_endmute = self._builder.handle_endmute\n        self._parser.handle_stop = self._builder.handle_stop\n        self._parser.handle_assert = self._builder.handle_assert\n\n\n    def process_file(self, fname):\n        \'\'\'Processeses a file.\n\n        Args:\n            fname (str): Name of the file to process.\n\n        Returns:\n            str: Processed content.\n        \'\'\'\n        self._parser.parsefile(fname)\n        return self._render()\n\n\n    def process_text(self, txt):\n        \'\'\'Processes a string.\n\n        Args:\n            txt (str): Text to process.\n\n        Returns:\n            str: Processed content.\n        \'\'\'\n        self._parser.parse(txt)\n        return self._render()\n\n\n    def _render(self):\n        output = self._renderer.render(self._builder.tree)\n        self._builder.reset()\n        return \'\'.join(output)\n\n\nclass Fypp:\n\n    \'\'\'Fypp preprocessor.\n\n    You can invoke it like ::\n\n        tool = fypp.Fypp()\n        tool.process_file(\'file.in\', \'file.out\')\n\n    to initialize Fypp with default options, process `file.in` and write the\n    result to `file.out`. If the input should be read from a string, the\n    ``process_text()`` method can be used::\n\n        tool = fypp.Fypp()\n        output = tool.process_text(\'#:if DEBUG > 0\\\\nprint *, ""DEBUG""\\\\n#:endif\\\\n\')\n\n    If you want to fine tune Fypps behaviour, pass a customized `FyppOptions`_\n    instance at initialization::\n\n        options = fypp.FyppOptions()\n        options.fixed_format = True\n        tool = fypp.Fypp(options)\n\n    Alternatively, you can use the command line parser ``optparse.OptionParser``\n    to set options for Fypp. The function ``get_option_parser()`` returns you a\n    default option parser. You can then use its ``parse_args()`` method to\n    obtain settings by reading the command line arguments::\n\n        optparser = fypp.get_option_parser()\n        options, leftover = optparser.parse_args()\n        tool = fypp.Fypp(options)\n\n    The command line options can also be passed directly as a list when\n    calling ``parse_args()``::\n\n        args = [\'-DDEBUG=0\', \'input.fpp\', \'output.f90\']\n        optparser = fypp.get_option_parser()\n        options, leftover = optparser.parse_args(args=args)\n        tool = fypp.Fypp(options)\n\n\n    Args:\n        options (object): Object containing the settings for Fypp. You typically\n            would pass a customized `FyppOptions`_ instance or an\n            ``optparse.Values`` object as returned by the option parser. If not\n            present, the default settings in `FyppOptions`_ are used.\n    \'\'\'\n\n    def __init__(self, options=None):\n        syspath = self._get_syspath_without_scriptdir()\n        self._adjust_syspath(syspath)\n        if options is None:\n            options = FyppOptions()\n        evaluator = Evaluator()\n        if options.modules:\n            self._import_modules(options.modules, evaluator, syspath,\n                                 options.moduledirs)\n        if options.defines:\n            self._apply_definitions(options.defines, evaluator)\n        parser = Parser(options.includes)\n        builder = Builder()\n\n        fixed_format = options.fixed_format\n        linefolding = not options.no_folding\n        if linefolding:\n            folding = \'brute\' if fixed_format else options.folding_mode\n            linelength = 72 if fixed_format else options.line_length\n            indentation = 5 if fixed_format else options.indentation\n            prefix = \'&\'\n            suffix = \'\' if fixed_format else \'&\'\n            linefolder = FortranLineFolder(linelength, indentation, folding,\n                                           prefix, suffix)\n        else:\n            linefolder = DummyLineFolder()\n        linenums = options.line_numbering\n        contlinenums = (options.line_numbering_mode != \'nocontlines\')\n        self._create_parent_folder = options.create_parent_folder\n        renderer = Renderer(\n            evaluator, linenums=linenums, contlinenums=contlinenums,\n            linenumformat=options.line_marker_format, linefolder=linefolder)\n        self._preprocessor = Processor(parser, builder, renderer)\n\n\n    def process_file(self, infile, outfile=None):\n        \'\'\'Processes input file and writes result to output file.\n\n        Args:\n            infile (str): Name of the file to read and process. If its value is\n                \'-\', input is read from stdin.\n            outfile (str, optional): Name of the file to write the result to.\n                If its value is \'-\', result is written to stdout. If not\n                present, result will be returned as string.\n            env (dict, optional): Additional definitions for the evaluator.\n\n        Returns:\n            str: Result of processed input, if no outfile was specified.\n        \'\'\'\n        infile = STDIN if infile == \'-\' else infile\n        output = self._preprocessor.process_file(infile)\n        if outfile is None:\n            return output\n        else:\n            if outfile == \'-\':\n                outfile = sys.stdout\n            else:\n                outfile = _open_output_file(outfile, self._create_parent_folder)\n            outfile.write(output)\n            if outfile != sys.stdout:\n                outfile.close()\n\n\n    def process_text(self, txt):\n        \'\'\'Processes a string.\n\n        Args:\n            txt (str): String to process.\n            env (dict, optional): Additional definitions for the evaluator.\n\n        Returns:\n            str: Processed content.\n        \'\'\'\n        return self._preprocessor.process_text(txt)\n\n\n    @staticmethod\n    def _apply_definitions(defines, evaluator):\n        for define in defines:\n            words = define.split(\'=\', 2)\n            name = words[0]\n            value = None\n            if len(words) > 1:\n                try:\n                    value = evaluator.evaluate(words[1])\n                except Exception as exc:\n                    msg = ""exception at evaluating \'{0}\' in definition for "" \\\n                          ""\'{1}\'"".format(words[1], name)\n                    raise FyppFatalError(msg, cause=exc)\n            evaluator.define(name, value)\n\n\n    def _import_modules(self, modules, evaluator, syspath, moduledirs):\n        lookuppath = []\n        if moduledirs is not None:\n            lookuppath += [os.path.abspath(moddir) for moddir in moduledirs]\n        lookuppath.append(os.path.abspath(\'.\'))\n        lookuppath += syspath\n        self._adjust_syspath(lookuppath)\n        for module in modules:\n            evaluator.import_module(module)\n        self._adjust_syspath(syspath)\n\n\n    @staticmethod\n    def _get_syspath_without_scriptdir():\n        \'\'\'Remove the folder of the fypp binary from the search path\'\'\'\n        syspath = list(sys.path)\n        scriptdir = os.path.abspath(os.path.dirname(sys.argv[0]))\n        if os.path.abspath(syspath[0]) == scriptdir:\n            del syspath[0]\n        return syspath\n\n\n    @staticmethod\n    def _adjust_syspath(syspath):\n        sys.path = syspath\n\n\nclass FyppOptions(optparse.Values):\n\n    \'\'\'Container for Fypp options with default values.\n\n    Attributes:\n        defines (list of str): List of variable definitions in the form of\n            \'VARNAME=VALUE\'. Default: []\n        includes (list of str): List of paths to search when looking for include\n            files. Default: []\n        line_numbering (bool): Whether line numbering directives should appear\n            in the output. Default: False\n        line_numbering_mode (str): Line numbering mode \'full\' or \'nocontlines\'.\n            Default: \'full\'.\n        line_marker_format (str): Line marker format. Currently \'cpp\' and\n            \'gfortran5\' are supported. Later fixes the line marker handling bug\n            introduced in GFortran 5. Default: \'cpp\'.\n        line_length (int): Length of output lines. Default: 132.\n        folding_mode (str): Folding mode \'smart\', \'simple\' or \'brute\'. Default:\n            \'smart\'.\n        no_folding (bool): Whether folding should be suppresed. Default: False.\n        indentation (int): Indentation in continuation lines. Default: 4.\n        modules (list of str): Modules to import at initialization. Default: [].\n        moduledirs (list of str): Module lookup directories for importing user\n            specified modules. The specified paths are looked up *before* the\n            standard module locations in sys.path.\n        fixed_format (bool): Whether input file is in fixed format.\n            Default: False.\n        create_parent_folder (bool): Whether the parent folder for the output\n            file should be created if it does not exist. Default: False.\n    \'\'\'\n\n    def __init__(self):\n        optparse.Values.__init__(self)\n        self.defines = []\n        self.includes = []\n        self.line_numbering = False\n        self.line_numbering_mode = \'full\'\n        self.line_marker_format = \'cpp\'\n        self.line_length = 132\n        self.folding_mode = \'smart\'\n        self.no_folding = False\n        self.indentation = 4\n        self.modules = []\n        self.moduledirs = []\n        self.fixed_format = False\n        self.create_parent_folder = False\n\n\nclass FortranLineFolder:\n\n    \'\'\'Implements line folding with Fortran continuation lines.\n\n    Args:\n        maxlen (int, optional): Maximal line length (default: 132).\n        indent (int, optional): Indentation for continuation lines (default: 4).\n        method (str, optional): Folding method with following options:\n\n            * ``brute``: folding with maximal length of continuation lines,\n            * ``simple``: indents with respect of indentation of first line,\n            * ``smart``: like ``simple``, but tries to fold at whitespaces.\n\n        prefix (str, optional): String to use at the beginning of a continuation\n            line (default: \'&\').\n        suffix (str, optional): String to use at the end of the line preceeding\n            a continuation line (default: \'&\')\n    \'\'\'\n\n    def __init__(self, maxlen=132, indent=4, method=\'smart\', prefix=\'&\',\n                 suffix=\'&\'):\n        # Line length should be long enough that contintuation lines can host at\n        # east one character apart of indentation and two continuation signs\n        minmaxlen = indent + len(prefix) + len(suffix) + 1\n        if maxlen < minmaxlen:\n            msg = \'Maximal line length less than {0} when using an indentation\'\\\n                  \' of {1}\'.format(minmaxlen, indent)\n            raise FyppFatalError(msg)\n        self._maxlen = maxlen\n        self._indent = indent\n        self._prefix = \' \' * self._indent + prefix\n        self._suffix = suffix\n        if method not in [\'brute\', \'smart\', \'simple\']:\n            raise FyppFatalError(\'invalid folding type\')\n        if method == \'brute\':\n            self._inherit_indent = False\n            self._fold_position_finder = self._get_maximal_fold_pos\n        elif method == \'simple\':\n            self._inherit_indent = True\n            self._fold_position_finder = self._get_maximal_fold_pos\n        elif method == \'smart\':\n            self._inherit_indent = True\n            self._fold_position_finder = self._get_smart_fold_pos\n\n\n    def __call__(self, line):\n        \'\'\'Folds a line.\n\n        Can be directly called to return the list of folded lines::\n\n            linefolder = FortranLineFolder(maxlen=10)\n            linefolder(\'  print *, ""some Fortran line""\')\n\n        Args:\n            line (str): Line to fold.\n\n        Returns:\n            list of str: Components of folded line. They should be\n                assembled via ``\\\\n.join()`` to obtain the string\n                representation.\n        \'\'\'\n        if self._maxlen < 0 or len(line) <= self._maxlen:\n            return [line]\n        if self._inherit_indent:\n            indent = len(line) - len(line.lstrip())\n            prefix = \' \' * indent + self._prefix\n        else:\n            indent = 0\n            prefix = self._prefix\n        suffix = self._suffix\n        return self._split_line(line, self._maxlen, prefix, suffix,\n                                self._fold_position_finder)\n\n\n    @staticmethod\n    def _split_line(line, maxlen, prefix, suffix, fold_position_finder):\n        # length of continuation lines with 1 or two continuation chars.\n        maxlen1 = maxlen - len(prefix)\n        maxlen2 = maxlen1 - len(suffix)\n        start = 0\n        end = fold_position_finder(line, start, maxlen - len(suffix))\n        result = [line[start:end] + suffix]\n        while end < len(line) - maxlen1:\n            start = end\n            end = fold_position_finder(line, start, start + maxlen2)\n            result.append(prefix + line[start:end] + suffix)\n        result.append(prefix + line[end:])\n        return result\n\n\n    @staticmethod\n    def _get_maximal_fold_pos(_, __, end):\n        return end\n\n\n    @staticmethod\n    def _get_smart_fold_pos(line, start, end):\n        linelen = end - start\n        ispace = line.rfind(\' \', start, end)\n        # The space we waste for smart folding should be max. 1/3rd of the line\n        if ispace != -1 and ispace >= start + (2 * linelen) // 3:\n            return ispace\n        else:\n            return end\n\n\nclass DummyLineFolder:\n\n    \'\'\'Implements a dummy line folder returning the line unaltered.\'\'\'\n\n    def __call__(self, line):\n        \'\'\'Returns the entire line without any folding.\n\n        Returns:\n            list of str: Components of folded line. They should be\n                assembled via ``\\\\n.join()`` to obtain the string\n                representation.\n        \'\'\'\n        return [line]\n\n\ndef get_option_parser():\n    \'\'\'Returns an option parser for the Fypp command line tool.\n\n    Returns:\n        OptionParser: Parser which can create an optparse.Values object with\n            Fypp settings based on command line arguments.\n    \'\'\'\n    defs = FyppOptions()\n    fypp_name = \'fypp\'\n    fypp_desc = \'Preprocesses source code with Fypp directives. The input is \'\\\n                \'read from INFILE (default: \\\'-\\\', stdin) and written to \'\\\n                \'OUTFILE (default: \\\'-\\\', stdout).\'\n    fypp_version = fypp_name + \' \' + VERSION\n    usage = \'%prog [options] [INFILE] [OUTFILE]\'\n    parser = optparse.OptionParser(prog=fypp_name, description=fypp_desc,\n                                   version=fypp_version, usage=usage)\n    msg = \'define variable, value is interpreted as \' \\\n          \'Python expression (e.g \\\'-DDEBUG=1\\\' sets DEBUG to the \' \\\n          \'integer 1) or set to None if ommitted\'\n    parser.add_option(\'-D\', \'--define\', action=\'append\', dest=\'defines\',\n                      metavar=\'VAR[=VALUE]\', default=defs.defines, help=msg)\n    msg = \'add directory to the search paths for include files\'\n    parser.add_option(\'-I\', \'--include\', action=\'append\', dest=\'includes\',\n                      metavar=\'INCDIR\', default=defs.includes, help=msg)\n    msg = \'import a python module at startup (import only trustworthy modules \'\\\n          \'as they have access to an **unrestricted** Python environment!)\'\n    parser.add_option(\'-m\', \'--module\', action=\'append\', dest=\'modules\',\n                      metavar=\'MOD\', default=defs.modules, help=msg)\n    msg = \'directory to be searched for user imported modules before \'\\\n          \'looking up standard locations in sys.path\'\n    parser.add_option(\'-M\', \'--module-dir\', action=\'append\',\n                      dest=\'moduledirs\', metavar=\'MODDIR\',\n                      default=defs.moduledirs, help=msg)\n    msg = \'emit line numbering markers\'\n    parser.add_option(\'-n\', \'--line-numbering\', action=\'store_true\',\n                      dest=\'line_numbering\', default=defs.line_numbering,\n                      help=msg)\n    msg = \'line numbering mode, \\\'full\\\' (default): line numbering \'\\\n          \'markers generated whenever source and output lines are out \'\\\n          \'of sync, \\\'nocontlines\\\': line numbering markers omitted \'\\\n          \'for continuation lines\'\n    parser.add_option(\'-N\', \'--line-numbering-mode\', metavar=\'MODE\',\n                      choices=[\'full\', \'nocontlines\'],\n                      default=defs.line_numbering_mode,\n                      dest=\'line_numbering_mode\', help=msg)\n    msg = \'line numbering marker format, \\\'cpp\\\' (default): GNU cpp format, \'\\\n          \'\\\'gfortran5\\\': modified markers to work around bug in GFortran 5 \'\\\n          \'and above\'\n    parser.add_option(\'--line-marker-format\', metavar=\'FMT\',\n                      choices=[\'cpp\', \'gfortran5\'], dest=\'line_marker_format\',\n                      default=defs.line_marker_format, help=msg)\n    msg = \'maximal line length (default: 132), lines modified by the \'\\\n          \'preprocessor are folded if becoming longer\'\n    parser.add_option(\'-l\', \'--line-length\', type=int, metavar=\'LEN\',\n                      dest=\'line_length\', default=defs.line_length, help=msg)\n    msg = \'line folding mode, \\\'smart\\\' (default): indentation context \'\\\n          \'and whitespace aware, \\\'simple\\\': indentation context aware, \'\\\n          \'\\\'brute\\\': mechnical folding\'\n    parser.add_option(\'-f\', \'--folding-mode\', metavar=\'MODE\',\n                      choices=[\'smart\', \'simple\', \'brute\'], dest=\'folding_mode\',\n                      default=defs.folding_mode, help=msg)\n    msg = \'suppress line folding\'\n    parser.add_option(\'-F\', \'--no-folding\', action=\'store_true\',\n                      dest=\'no_folding\', default=defs.no_folding, help=msg)\n    msg = \'indentation to use for continuation lines (default 4)\'\n    parser.add_option(\'--indentation\', type=int, metavar=\'IND\',\n                      dest=\'indentation\', default=defs.indentation, help=msg)\n    msg = \'produce fixed format output (any settings for options \'\\\n          \'--line-length, --folding-method and --indentation are ignored)\'\n    parser.add_option(\'--fixed-format\', action=\'store_true\',\n                      dest=\'fixed_format\', default=defs.fixed_format, help=msg)\n    msg = \'create parent folders of the output file if they do not exist\'\n    parser.add_option(\'-p\', \'--create-parents\', action=\'store_true\',\n                      dest=\'create_parent_folder\',\n                      default=defs.create_parent_folder, help=msg)\n    return parser\n\n\ndef run_fypp():\n    \'\'\'Run the Fypp command line tool.\'\'\'\n    options = FyppOptions()\n    optparser = get_option_parser()\n    opts, leftover = optparser.parse_args(values=options)\n    infile = leftover[0] if len(leftover) > 0 else \'-\'\n    outfile = leftover[1] if len(leftover) > 1 else \'-\'\n    try:\n        tool = Fypp(opts)\n        tool.process_file(infile, outfile)\n    except FyppStopRequest as exc:\n        sys.stderr.write(_formatted_exception(exc))\n        sys.exit(USER_ERROR_EXIT_CODE)\n    except FyppFatalError as exc:\n        sys.stderr.write(_formatted_exception(exc))\n        sys.exit(ERROR_EXIT_CODE)\n\n\ndef linenumdir(linenr, fname, flag=None):\n    \'\'\'Returns a line numbering directive.\n\n    Args:\n        linenr (int): Line nr (starting with 0).\n        fname (str): File name.\n    \'\'\'\n    if flag is None:\n        return \'# {0} ""{1}""\\n\'.format(linenr + 1, fname)\n    else:\n        return \'# {0} ""{1}"" {2}\\n\'.format(linenr + 1, fname, flag)\n\n\ndef _shiftinds(inds, shift):\n    return [ind + shift for ind in inds]\n\n\ndef _open_input_file(inpfile):\n    try:\n        inpfp = open(inpfile, \'r\')\n    except IOError as exc:\n        msg = ""Failed to open file \'{0}\' for read"".format(inpfile)\n        raise FyppFatalError(msg, cause=exc)\n    return inpfp\n\n\ndef _open_output_file(outfile, create_parents=False):\n    if create_parents:\n        parentdir = os.path.abspath(os.path.dirname(outfile))\n        if not os.path.exists(parentdir):\n            try:\n                os.makedirs(parentdir)\n            except OSError as exc:\n                if exc.errno != errno.EEXIST:\n                    msg = ""Folder \'{0}\' can not be created""\\\n                        .format(parentdir)\n                    raise FyppFatalError(msg, cause=exc)\n    try:\n        outfp = open(outfile, \'w\')\n    except IOError as exc:\n        msg = ""Failed to open file \'{0}\' for write"".format(outfile)\n        raise FyppFatalError(msg, cause=exc)\n    return outfp\n\n\ndef _get_callable_argspec_py2(func):\n    argspec = inspect.getargspec(func)\n    if argspec.keywords is not None:\n        msg = ""variable length keyword argument \'{0}\' found""\\\n            .format(argspec.keywords)\n        raise FyppFatalError(msg)\n    vararg = argspec.varargs\n    args = argspec.args\n    tuplearg = False\n    for elem in args:\n        tuplearg = tuplearg or isinstance(elem, list)\n    if tuplearg:\n        msg = \'tuple argument(s) found\'\n        raise FyppFatalError(msg)\n    defaults = {}\n    if argspec.defaults is not None:\n        for ind, default in enumerate(argspec.defaults):\n            iarg = len(args) - len(argspec.defaults) + ind\n            defaults[args[iarg]] = default\n    return args, defaults, vararg\n\n\ndef _get_callable_argspec_py3(func):\n    sig = inspect.signature(func)\n    args = []\n    defaults = {}\n    vararg = None\n    for param in sig.parameters.values():\n        if param.kind == param.POSITIONAL_OR_KEYWORD:\n            args.append(param.name)\n            if param.default != param.empty:\n                defaults[param.name] = param.default\n        elif param.kind == param.VAR_POSITIONAL:\n            vararg = param.name\n        else:\n            msg = ""argument \'{0}\' has invalid argument type"".format(param.name)\n            raise FyppFatalError(msg)\n    return args, defaults, vararg\n\n\n# Signature objects are available from Python 3.3 (and deprecated from 3.5)\n\nif sys.version_info[0] >= 3 and sys.version_info[1] >= 3:\n    _get_callable_argspec = _get_callable_argspec_py3\nelse:\n    _get_callable_argspec = _get_callable_argspec_py2\n\n\ndef _blank_match(match):\n    size = match.end() - match.start()\n    return "" "" * size\n\n\ndef _argsplit_fortran(argtxt):\n    txt = _INLINE_EVAL_REGION_REGEXP.sub(_blank_match, argtxt)\n    splitpos = [-1]\n    quote = None\n    closing_brace_stack = []\n    closing_brace = None\n    for ind, char in enumerate(txt):\n        if quote:\n            if char == quote:\n                quote = None\n            continue\n        if char in _QUOTES_FORTRAN:\n            quote = char\n            continue\n        if char in _OPENING_BRACKETS_FORTRAN:\n            closing_brace_stack.append(closing_brace)\n            ind = _OPENING_BRACKETS_FORTRAN.index(char)\n            closing_brace = _CLOSING_BRACKETS_FORTRAN[ind]\n            continue\n        if char in _CLOSING_BRACKETS_FORTRAN:\n            if char == closing_brace:\n                closing_brace = closing_brace_stack.pop(-1)\n                continue\n            else:\n                msg = ""unexpected closing delimiter \'{0}\' in expression \'{1}\' ""\\\n                      ""at position {2}"".format(char, argtxt, ind + 1)\n                raise FyppFatalError(msg)\n        if not closing_brace and char == _ARGUMENT_SPLIT_CHAR_FORTRAN:\n            splitpos.append(ind)\n    if quote or closing_brace:\n        msg = ""open quotes or brackets in expression \'{0}\'"".format(argtxt)\n        raise FyppFatalError(msg)\n    splitpos.append(len(txt))\n    fragments = [argtxt[start + 1 : end]\n                 for start, end in zip(splitpos, splitpos[1:])]\n    return fragments\n\n\ndef _formatted_exception(exc):\n    error_header_formstr = \'{file}:{line}: \'\n    error_body_formstr = \'error: {errormsg} [{errorclass}]\'\n    if not isinstance(exc, FyppError):\n        return error_body_formstr.format(\n            errormsg=str(exc), errorclass=exc.__class__.__name__)\n    out = []\n    if exc.fname is not None:\n        if exc.span[1] > exc.span[0] + 1:\n            line = \'{0}-{1}\'.format(exc.span[0] + 1, exc.span[1])\n        else:\n            line = \'{0}\'.format(exc.span[0] + 1)\n        out.append(error_header_formstr.format(file=exc.fname, line=line))\n    out.append(error_body_formstr.format(errormsg=exc.msg,\n                                         errorclass=exc.__class__.__name__))\n    if exc.cause is not None:\n        out.append(\'\\n\' + _formatted_exception(exc.cause))\n    out.append(\'\\n\')\n    return \'\'.join(out)\n\n\nif __name__ == \'__main__\':\n    run_fypp()\n'"
tests/test_basics.py,0,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Copyright (C) 2017-2018  Elias Rabel\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by \n# the Free Software Foundation, either version 3 of the License, or \n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\n\ntest_attribute = 123\nattribute_to_delete = 321\n\ndef do_nothing():\n    pass\n\ndef check_args_kwargs(*args, **kwargs):\n    """"""Tests if there are args or kwargs\n       returns: 0 - no args, no kwargs\n                1 -    args, no kwargs\n                2 - no args, kwargs\n                3      args and kwargs present""""""\n    res = 0\n    if len(args) > 0:\n        res += 1\n    if len(kwargs) > 0:\n        res += 2\n    \n    return res\n    \ndef raise_exc():\n    raise StopIteration\n    \ndef check_arg(v):\n    return (v == 42)\n\ndef check_kwarg(hello=99):\n    return (hello == 42)\n\n\nclass MyClass(object):\n    def __init__(self):\n        self.x = 42\n\ndef return_small():\n    return 5\n\ndef return_medium():\n    return 2**48\n    \ndef return_large():\n    return 2**100\n\ndef return_int32_bounds():\n    return (-2**31 - 1, -2**31, 2**31-1, 2**31)\n    \ndef int_expected(n):\n    if not isinstance(n, int):\n        raise TypeError\n\ndef get_zero_length_str():\n    return """"\n\ndef exception_before_return():\n    raise RuntimeError\n    return 3.14\n    \ndef return_unicode():\n    return u""\xe5\x9f\x83\xe5\x88\xa9\xe4\xba\x9a\xe6\x96\xaf""\n\ndef return_bytes():\n    return b""saile""\n\ndef check_sys_argv():\n    if sys.argv != [\'\']:\n        raise RuntimeError(""sys.argv != [\'\'], argv = {0}"".format(sys.argv))\n\n'"
tests/test_cast.py,0,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Copyright (C) 2017-2018  Elias Rabel\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by \n# the Free Software Foundation, either version 3 of the License, or \n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n    \nclass ConvertibleNumber:\n\t""""""Type that can be converted to different (numeric) types""""""\n\tdef __complex__(self):\n\t\treturn -12.3+4.56j\n\tdef __float__(self):\n\t\treturn -12.3\n\tdef __int__(self):\n\t\treturn -12\n'"
tests/test_ndarray.py,15,"b'#!/usr/bin/env python\n# -*- coding: UTF-8 -*-\n\n# Copyright (C) 2017-2018  Elias Rabel\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published by \n# the Free Software Foundation, either version 3 of the License, or \n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of \n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom __future__ import print_function\n\nimport numpy as np\n\ndef ndarray_expected(arr):\n    if not isinstance(arr, np.ndarray):\n        raise TypeError\n\ndef check_ndarray_1d(arr):\n    solution = np.arange(1,25,dtype=\'int\')\n    if not np.all(arr == solution):\n        raise ValueError\n\ndef check_ndarray_2d(arr):\n    solution = np.arange(1,25,dtype=\'float64\').reshape(4,6)\n    if not np.all(arr == solution):\n        print(""Got: "")\n        print(arr)\n        print(""Solution: "")\n        print(solution)\n        raise ValueError\n\ndef check_ndarray_3d(arr):\n    solution = np.arange(1,25,dtype=\'float32\').reshape(2,3,4)\n    if not np.all(arr == solution):\n        print(""Got: "")\n        print(arr)\n        print(""Solution: "")\n        print(solution)\n        raise ValueError\n        \ndef get_ndarray_2d():\n    arr = np.arange(1,25,dtype=\'float64\').reshape((4,6), order=\'F\')\n    return arr\n \ndef get_ndarray_2d_c_order():\n    arr = np.arange(1,25,dtype=\'float64\').reshape((4,6), order=\'C\')\n    #print(arr)\n    return arr\n\ndef get_ndarray_2d_not_contiguous():\n    arr = np.arange(1,25,dtype=\'float64\').reshape((4,6), order=\'F\')\n    arr = arr[0::2,0::2]\n    #print(arr)\n    return arr\n    \ndef check_transpose_2d(array_to_check):\n    solution = get_ndarray_2d().transpose()\n    if not np.all(array_to_check == solution):\n        raise ValueError\n        \ndef c_order_expected(x):\n    if not x.flags.c_contiguous:\n        raise TypeError\n\ndef get_test_array(dimension, dtype_string):\n    shape_4d = (7, 5, 3, 2)\n    shape = shape_4d[0:dimension]\n    tmp = np.array(range(1, np.prod(shape)+1), ""int64"")\n    #tmp[::2] *= -1\n    test_array = np.array(tmp,  dtype_string)\n    test_array = test_array.reshape(shape, order=\'F\')\n\n    if dtype_string in (""complex64"", ""complex128""):\n        #without imaginary part it would be boring\n        test_array += -3j * test_array\n\n    return test_array\n\ndef check_test_array(array_to_check, dimension, dtype_string):\n    if np.dtype(dtype_string) != array_to_check.dtype:\n        raise TypeError(""dtypes do not match"")\n\n    test_array = get_test_array(dimension, dtype_string)\n    \n    if test_array.shape != array_to_check.shape:\n        raise TypeError(""shapes do not match"")\n    \n    if not np.array_equal(array_to_check, test_array):\n        #print(array_to_check)\n        #print(test_array)\n        raise ValueError(""values do not match"")\n\t\n'"
