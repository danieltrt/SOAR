file_path,api_count,code
setup.py,0,"b""from distutils.command.install_headers import install_headers\nfrom pathlib import Path\nfrom setuptools import setup\n\n\nclass pyscience11_install_headers(install_headers):\n    def run(self):\n        headers = self.distribution.headers\n        if not headers:\n            return\n\n        for header in headers:\n            source_header_path = Path(header).relative_to('include/pyscience11')\n            install_path = Path(self.install_dir)/source_header_path\n            install_dir = str(install_path.parent)\n            self.mkpath(install_dir)\n\n            (out, _) = self.copy_file(header, install_dir)\n            self.outfiles.append(out)\n\n\nheaders = [\n    'include/pyscience11/matplotlib/pyplot.h',\n    'include/pyscience11/numpy/dual.h',\n    'include/pyscience11/numpy/fft.h',\n    'include/pyscience11/numpy/linalg.h',\n    'include/pyscience11/numpy/random.h',\n    'include/pyscience11/scipy/io/wavfile.h',\n    'include/pyscience11/scipy/fftpack.h',\n    'include/pyscience11/scipy/integrate.h',\n    'include/pyscience11/scipy/interpolate.h',\n    'include/pyscience11/scipy/io.h',\n    'include/pyscience11/scipy/linalg.h',\n    'include/pyscience11/scipy/ndimage.h',\n    'include/pyscience11/scipy/optimize.h',\n    'include/pyscience11/scipy/signal.h',\n    'include/pyscience11/scipy/spatial.h',\n    'include/pyscience11/scipy/special.h',\n    'include/pyscience11/scipy/stats.h',\n    'include/pyscience11/matplotlib.h',\n    'include/pyscience11/numpy.h',\n    'include/pyscience11/scipy.h',\n]\n\n# Fields are ordered: https://setuptools.readthedocs.io/en/latest/setuptools.html#metadata\n# Classifiers: https://pypi.org/pypi?%3Aaction=list_classifiers\nsetup(\n    name='pyscience11',\n    version='0.5',\n    url='https://github.com/yokaze/pyscience11',\n    author='Rue Yokaze',\n    author_email='yokaze.rue@gmail.com',\n    classifiers=[\n        'Development Status :: 3 - Alpha',\n        'Intended Audience :: Science/Research',\n        'License :: OSI Approved :: MIT License',\n        'Programming Language :: C++',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.6',\n    ],\n    license='MIT',\n    description='C++11 wrapper for NumPy, SciPy and Matplotlib',\n    long_description='C++11 wrapper for NumPy, SciPy and Matplotlib',\n    keywords=['C++', 'pybind11', 'numpy', 'scipy', 'matplotlib'],\n    packages=['pyscience11'],\n    package_data={\n        '': [\n            'LICENSE',\n            'original_license/MATPLOTLIB_LICENSE',\n            'original_license/NUMPY_LICENSE',\n            'original_license/SCIPY_LICENSE'\n        ],\n    },\n    headers=headers,\n    cmdclass={'install_headers': pyscience11_install_headers},\n)\n"""
generator/generator.py,0,"b'import os\nimport pathlib\nimport textwrap\nimport types\n\nimport matplotlib\nimport matplotlib.pyplot\nimport numpy\nimport scipy\nimport scipy.fftpack\nimport scipy.interpolate\nimport scipy.io\nimport scipy.io.wavfile\nimport scipy.signal\nimport scipy.special\n\n\ndef align_pragma(text):\n    ret = \'\'\n    for line in text.splitlines():\n        if (line.strip().startswith(\'#\')):\n            line = line.strip()\n        ret += line + \'\\n\'\n    return ret\n\n\ndef generate_copyright(filename, package_name, package_version):\n    template = \'\'\'\\\n//\n//  $FileName$\n//  pyscience11\n//\n//  Copyright (C) 2018 Rue Yokaze\n//  Distributed under the MIT License.\n//\n//  This header is compatible with $PackageName$ $PackageVersion$.\n//\n\'\'\'\n    ret = template.replace(\'$FileName$\', filename)\n    ret = ret.replace(\'$PackageName$\', package_name)\n    ret = ret.replace(\'$PackageVersion$\', package_version)\n    return ret\n\n\ndef generate_pragma_once():\n    return \'\'\'\\\n#pragma once\n\'\'\'\n\n\ndef generate_include(include_path):\n    if (type(include_path) == str):\n        template = \'\'\'\\\n#include <$IncludePath$>\n\'\'\'\n        include_text = template.replace(\'$IncludePath$\', include_path)\n        return include_text\n    elif (type(include_path) == list):\n        ret = \'\'\n        for s in include_path:\n            ret += generate_include(s)\n\n        return ret\n\n\ndef generate_begin_namespace(namespace_name):\n    template = \'\'\'\\\nnamespace $Namespace$ {\n\'\'\'\n    ret = \'\'\n    names = namespace_name.split(\'::\')\n    for i, name in zip(range(len(names)), names):\n        line = template.replace(\'$Namespace$\', name)\n        line = textwrap.indent(line, \'    \' * max(0, i - 1))\n        ret += line\n\n    return ret\n\n\ndef generate_end_namespace(namespace_name):\n    ret = \'\'\n    names = namespace_name.split(\'::\')\n    for i, name in reversed(list(zip(range(len(names)), names))):\n        line = \'\'\'\\\n}\n\'\'\'\n        line = textwrap.indent(line, \'    \' * max(0, i - 1))\n        ret += line\n    return ret\n\n\ndef generate_begin_class(class_name, indent=0):\n    template = \'\'\'\\\nclass $ClassName$_module : public pybind11::module {\npublic:\n    using pybind11::module::module;\n\'\'\'\n    ret = template.replace(\'$ClassName$\', class_name)\n    return textwrap.indent(ret, \' \' * indent)\n\n\ndef generate_end_class(class_name, indent=0):\n    ret = \'\'\'\\\n};\n\'\'\'\n    return textwrap.indent(ret, \' \' * indent)\n\n\ndef generate_class_function(function_name, indent=0):\n    def is_cpp_macro_function(function_name):\n        return (function_name in [\'isfinite\', \'isinf\', \'isnan\', \'signbit\'])\n\n    if (is_cpp_macro_function(function_name)):\n        template = \'\'\'\n#if !defined($FunctionName$)\ntemplate <class... TArgs>\npybind11::object $FunctionName$(TArgs&&... args)\n{\n    return attr(""$FunctionName$"")(std::forward<TArgs>(args)...);\n}\n#endif\n\ntemplate <class... TArgs>\npybind11::object call_$FunctionName$(TArgs&&... args)\n{\n    return attr(""$FunctionName$"")(std::forward<TArgs>(args)...);\n}\n\'\'\'\n    else:\n        template = \'\'\'\ntemplate <class... TArgs>\npybind11::object $FunctionName$(TArgs&&... args)\n{\n    return attr(""$FunctionName$"")(std::forward<TArgs>(args)...);\n}\n\'\'\'\n    ret = template.replace(\'$FunctionName$\', function_name)\n    return align_pragma(textwrap.indent(ret, \' \' * indent))\n\n\ndef generate_import(full_module_name, indent=0):\n    template = \'\'\'\\\n$ModuleName$_module import_$ModuleName$()\n{\n    return pybind11::module::import(""$FullModuleName$"");\n}\n\'\'\'\n    module_name = full_module_name.split(\'.\')[-1]\n    ret = template.replace(\'$ModuleName$\', module_name)\n    ret = ret.replace(\'$FullModuleName$\', full_module_name)\n    ret = textwrap.indent(ret, \' \' * indent)\n    return ret\n\n\ndef generate_blank_line():\n    return \'\'\'\n\'\'\'\n\n\ndef build_header(target_module, package_name, package_version):\n    cpp_keywords = [\'delete\', \'typename\']\n    full_module_name = target_module.__name__           # \'numpy.random\'\n    module_name_list = full_module_name.split(\'.\')      # [\'numpy\', \'random\']\n    module_name = module_name_list[-1]                  # \'random\'\n    root_namespace_name = module_name_list[0] + \'11\'    # \'numpy11\'\n    full_namespace_name = \'::\'.join([root_namespace_name] + module_name_list[:-1])    # \'numpy11::numpy\'\n    class_indent = 4 * (len(module_name_list) - 1)\n    member_indent = 4 * len(module_name_list)\n\n    header = generate_copyright(\'%s.h\' % module_name, package_name, package_version) + \\\n        generate_pragma_once() + \\\n        generate_include(\'pybind11/pybind11.h\') + \\\n        generate_blank_line() + \\\n        generate_begin_namespace(full_namespace_name) + \\\n        generate_blank_line() + \\\n        generate_begin_class(module_name, indent=class_indent)\n\n    sorted_keys = [x for x in target_module.__dict__.keys()]\n    sorted_keys.sort()\n\n    for key in sorted_keys:\n        value = target_module.__dict__[key]\n\n        if (key in cpp_keywords):\n            key += \'_\'\n        if (isinstance(value, types.BuiltinFunctionType) or\n                isinstance(value, types.FunctionType) or\n                isinstance(value, numpy.ufunc)):\n            header += generate_class_function(key, indent=member_indent)\n\n    header += generate_end_class(module_name, indent=class_indent) + \\\n        generate_blank_line() + \\\n        generate_import(full_module_name, indent=class_indent) + \\\n        generate_end_namespace(full_namespace_name)\n\n    include_path = pathlib.Path(\'include/pyscience11\')/(\'/\'.join(module_name_list) + \'.h\')\n    os.makedirs(include_path.parent, exist_ok=True)\n    fp = open(include_path, \'w\')\n    fp.write(header)\n\n\nbuild_header(numpy, numpy.__name__, numpy.__version__)\nbuild_header(numpy.dual, numpy.__name__, numpy.__version__)\nbuild_header(numpy.fft, numpy.__name__, numpy.__version__)\nbuild_header(numpy.linalg, numpy.__name__, numpy.__version__)\nbuild_header(numpy.random, numpy.__name__, numpy.__version__)\nbuild_header(scipy, scipy.__name__, scipy.__version__)\nbuild_header(scipy.fftpack, scipy.__name__, scipy.__version__)\nbuild_header(scipy.integrate, scipy.__name__, scipy.__version__)\nbuild_header(scipy.interpolate, scipy.__name__, scipy.__version__)\nbuild_header(scipy.io, scipy.__name__, scipy.__version__)\nbuild_header(scipy.io.wavfile, scipy.__name__, scipy.__version__)\nbuild_header(scipy.linalg, scipy.__name__, scipy.__version__)\nbuild_header(scipy.ndimage, scipy.__name__, scipy.__version__)\nbuild_header(scipy.optimize, scipy.__name__, scipy.__version__)\nbuild_header(scipy.signal, scipy.__name__, scipy.__version__)\nbuild_header(scipy.spatial, scipy.__name__, scipy.__version__)\nbuild_header(scipy.special, scipy.__name__, scipy.__version__)\nbuild_header(scipy.stats, scipy.__name__, scipy.__version__)\nbuild_header(matplotlib, matplotlib.__name__, matplotlib.__version__)\nbuild_header(matplotlib.pyplot, matplotlib.__name__, matplotlib.__version__)\n'"
pyscience11/__init__.py,0,b''
