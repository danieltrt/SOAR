file_path,api_count,code
yobi/crop.py,9,"b'import cv2\nimport numpy as np\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\nnp.random.seed(0)\n\nCrop_num = 100\nL = 56\n\nfor _ in range(Crop_num):\n\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n    \ncv2.imshow("""", img)\ncv2.waitKey(0)\n'"
yobi/crop_hog.py,33,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n#gt = np.array((41, 3, 83, 32), dtype=np.float32)\n#gt2 = np.array((123, 41, 161, 74), dtype=np.float32)\n#gt3 = np.array((97, 83, 137, 113), dtype=np.float32)\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n#cv2.rectangle(img, (gt2[0], gt2[1]), (gt2[2], gt2[3]), (0,255,255), 1)\n#cv2.rectangle(img, (gt3[0], gt3[1]), (gt3[2], gt3[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\n# crop and create database\n\nCrop_num = 300\nL = 60\n\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n + 1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = np.zeros((3,))\n    _iou[0] = iou(gt, crop)\n    #_iou[1] = iou(gt2, crop)\n    #_iou[2] = iou(gt3, crop)\n\n    if _iou.max() >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 0\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 1\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n    #cv2.rectangle(img, (x1, y1), (x2, y2), (255, 0,0), 1)\n    \ncv2.imshow(""re"", img)\ncv2.waitKey(0)\n\nfrom sklearn import svm\nclf = svm.SVC(kernel=\'linear\')\nclf.fit(X=db[..., :F_n], y=db[..., -1])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            r_hog = hog(region).ravel()\n\n            f_dif = np.sum(np.abs(db[:, :F_n] - r_hog) ** 2)\n            min_arg = np.argsort(f_dif)[:5]\n            pred = db[min_arg, -1]\n\n            #if len(np.where(pred==0)[0]) > 0:\n            #    cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n            \n            pred = clf.predict(r_hog[None, ...])[0]\n            if pred == 0:\n                cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n    print(y, x)\n\n                \n#print(db)\ncv2.imshow("""", img2)\ncv2.waitKey(0)\n'"
yobi/crop_hog_nn.py,66,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n#gt = np.array((41, 3, 83, 32), dtype=np.float32)\n#gt2 = np.array((123, 41, 161, 74), dtype=np.float32)\n#gt3 = np.array((97, 83, 137, 113), dtype=np.float32)\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n#cv2.rectangle(img, (gt2[0], gt2[1]), (gt2[2], gt2[3]), (0,255,255), 1)\n#cv2.rectangle(img, (gt3[0], gt3[1]), (gt3[2], gt3[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = np.zeros((3,))\n    _iou[0] = iou(gt, crop)\n    #_iou[1] = iou(gt2, crop)\n    #_iou[2] = iou(gt3, crop)\n\n    if _iou.max() >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n    #cv2.rectangle(img, (x1, y1), (x2, y2), (255, 0,0), 1)\n    \n#cv2.imshow(""re"", img)\n#cv2.waitKey(0)\n\n#print(db[:, :F_n].shape)\n#print(db[:, -1][..., None].shape)\n\n## training neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n            #if pred == 0:\n            #    cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n    print(y, x)\n\nprint(detects)\n\n\ndef nms(bboxes, iou_th=0.5, select_num=None, prob_th=None):\n\n    bboxes[:, 2] = bboxes[:, 2] - bboxes[:, 0]\n    bboxes[:, 3] = bboxes[:, 3] - bboxes[:, 1]\n    \n    # Sort by bbox\'s score. High -> Low\n    sort_inds = np.argsort(bboxes[:, -1])[::-1]\n\n    processed_bbox_ind = []\n    return_inds = []\n\n    unselected_inds = sort_inds.copy()\n    \n    while len(unselected_inds) > 0:\n        process_bboxes = bboxes[unselected_inds]\n        argmax_score_ind = np.argmax(process_bboxes[::, -1])\n        max_score_ind = unselected_inds[argmax_score_ind]\n        return_inds += [max_score_ind]\n        unselected_inds = np.delete(unselected_inds, argmax_score_ind)\n\n        base_bbox = bboxes[max_score_ind]\n        compare_bboxes = bboxes[unselected_inds]\n        \n        base_x1 = base_bbox[0]\n        base_y1 = base_bbox[1]\n        base_x2 = base_bbox[2] + base_x1\n        base_y2 = base_bbox[3] + base_y1\n        base_w = np.maximum(base_bbox[2], 0)\n        base_h = np.maximum(base_bbox[3], 0)\n        base_area = base_w * base_h\n\n        # compute iou-area between base bbox and other bboxes\n        iou_x1 = np.maximum(base_x1, compare_bboxes[:, 0])\n        iou_y1 = np.maximum(base_y1, compare_bboxes[:, 1])\n        iou_x2 = np.minimum(base_x2, compare_bboxes[:, 2] + compare_bboxes[:, 0])\n        iou_y2 = np.minimum(base_y2, compare_bboxes[:, 3] + compare_bboxes[:, 1])\n        iou_w = np.maximum(iou_x2 - iou_x1, 0)\n        iou_h = np.maximum(iou_y2 - iou_y1, 0)\n        iou_area = iou_w * iou_h\n\n        compare_w = np.maximum(compare_bboxes[:, 2], 0)\n        compare_h = np.maximum(compare_bboxes[:, 3], 0)\n        compare_area = compare_w * compare_h\n\n        # bbox\'s index which iou ratio over threshold is excluded\n        all_area = compare_area + base_area - iou_area\n        iou_ratio = np.zeros((len(unselected_inds)))\n        iou_ratio[all_area < 0.9] = 0.\n        _ind = all_area >= 0.9\n        iou_ratio[_ind] = iou_area[_ind] / all_area[_ind]\n\n        unselected_inds = np.delete(unselected_inds, np.where(iou_ratio >= iou_th)[0])\n\n    if prob_th is not None:\n        preds = bboxes[return_inds][:, -1]\n        return_inds = np.array(return_inds)[np.where(preds >= prob_th)[0]].tolist()\n        \n    # pick bbox\'s index by defined number with higher score\n    if select_num is not None:\n        return_inds = return_inds[:select_num]\n\n    return return_inds\n\ndetects = detects[nms(detects, iou_th=0.7)]\n\n#print(db)\ncv2.imshow("""", img2)\ncv2.waitKey(0)\n'"
yobi/hog.py,15,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ndef hog(gray):\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n    \n    gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n    gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    \n    N = 8\n    HH = H // N\n    HW = W // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\n\ntrain = glob(""../Question_81_90/train_*"")\ntrain.sort()\n\nfs = np.zeros((len(train), 16*16*9))\nls = np.zeros((len(train)))\n\nfor i, path in enumerate(train):\n    img = cv2.imread(path).astype(np.float32)\n    # Grayscale\n    gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n    fs[i] = hog(gray).ravel()\n    ls[i] = 0 if \'akahara\' in path else 1\n\nfrom sklearn import svm\nclf = svm.SVC(kernel=\'linear\')\nclf.fit(X=fs, y=ls)\n\n\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\nf = hog(gray).ravel()\nf = f[None, ...]\nprint(clf.predict(f))\n\n\nimg = cv2.imread(""madara.jpg"").astype(np.float32)\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\nf = hog(gray).ravel()\nf = f[None, ...]\nprint(clf.predict(f))\n'"
yobi/neural.py,0,"b'import numpy\nimport math\nimport random\nfrom matplotlib import pyplot\n\nclass Neural:\n\n    # constructor\n    def __init__(self, n_input, n_hidden, n_output):\n        self.hidden_weight = numpy.random.random_sample((n_hidden, n_input + 1))\n        self.output_weight = numpy.random.random_sample((n_output, n_hidden + 1))\n        self.hidden_momentum = numpy.zeros((n_hidden, n_input + 1))\n        self.output_momentum = numpy.zeros((n_output, n_hidden + 1))\n\n\n# public method\n    def train(self, X, T, epsilon, mu, epoch):\n        self.error = numpy.zeros(epoch)\n        N = X.shape[0]\n        for epo in range(epoch):\n            for i in range(N):\n                x = X[i, :]\n                t = T[i, :]\n\n                self.__update_weight(x, t, epsilon, mu)\n\n            self.error[epo] = self.__calc_error(X, T)\n\n\n    def predict(self, X):\n        N = X.shape[0]\n        C = numpy.zeros(N).astype(\'int\')\n        Y = numpy.zeros((N, X.shape[1]))\n        for i in range(N):\n            x = X[i, :]\n            z, y = self.__forward(x)\n\n            Y[i] = y\n            C[i] = y.argmax()\n\n        return (C, Y)\n\n\n    def error_graph(self):\n        pyplot.ylim(0.0, 2.0)\n        pyplot.plot(numpy.arange(0, self.error.shape[0]), self.error)\n        pyplot.show()\n\n\n# private method\n    def __sigmoid(self, arr):\n        return numpy.vectorize(lambda x: 1.0 / (1.0 + math.exp(-x)))(arr)\n\n\n    def __forward(self, x):\n        # z: output in hidden layer, y: output in output layer\n        z = self.__sigmoid(self.hidden_weight.dot(numpy.r_[numpy.array([1]), x]))\n        y = self.__sigmoid(self.output_weight.dot(numpy.r_[numpy.array([1]), z]))\n\n        return (z, y)\n\n    def __update_weight(self, x, t, epsilon, mu):\n        z, y = self.__forward(x)\n\n        # update output_weight\n        output_delta = (y - t) * y * (1.0 - y)\n        _output_weight = self.output_weight\n        self.output_weight -= epsilon * output_delta.reshape((-1, 1)) * numpy.r_[numpy.array([1]), z] - mu * self.output_momentum\n        self.output_momentum = self.output_weight - _output_weight\n\n        # update hidden_weight\n        hidden_delta = (self.output_weight[:, 1:].T.dot(output_delta)) * z * (1.0 - z)\n        _hidden_weight = self.hidden_weight\n        self.hidden_weight -= epsilon * hidden_delta.reshape((-1, 1)) * numpy.r_[numpy.array([1]), x]\n        self.hidden_momentum = self.hidden_weight - _hidden_weight\n\n\n    def __calc_error(self, X, T):\n        N = X.shape[0]\n        err = 0.0\n        for i in range(N):\n            x = X[i, :]\n            t = T[i, :]\n\n            z, y = self.__forward(x)\n            err += (y - t).dot((y - t).reshape((-1, 1))) / 2.0\n\n        return err\n\n\nif __name__ == \'__main__\':\n\n    X = numpy.array([[0, 0], [0, 1], [1, 0], [1, 1]])\n    T = numpy.array([[1, 0], [0, 1], [0, 1], [1, 0]])\n    N = X.shape[0] # number of data\n\n    input_size = X.shape[1]\n    hidden_size = 2\n    output_size = 2\n    epsilon = 0.1\n    mu = 0.9\n    epoch = 10000\n\n    nn = Neural(input_size, hidden_size, output_size)\n    nn.train(X, T, epsilon, mu, epoch)\n    nn.error_graph()\n\n    C, Y = nn.predict(X)\n\n    for i in range(N):\n        x = X[i, :]\n        y = Y[i, :]\n        c = C[i]\n\n        print(x)\n        print(y)\n        print(c)\n        print("""")\n'"
yobi/neuralnet.py,23,"b'import numpy as np\n\nnp.random.seed(4)\n\nclass NN:\n    def __init__(self, ind=2, w=10, outd=1, lr=1):\n        self.w2 = np.random.randn(ind, w)\n        self.w3 = np.random.randn(w, outd)\n        self.b2 = np.random.randn(w)\n        self.b3 = np.random.randn(1)\n        self.lr = lr\n        \n    def forward(self, x):\n        self.z1 = x\n        #self.z1 = np.hstack((x, [1]))\n        # add bias\n        self.z2 = sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        # add bias\n        #self.z2 = np.hstack((self.z2, [1]))\n        self.z3 = np.dot(self.z2, self.w3) + self.b3\n        self.out = sigmoid(self.z3)\n        return self.out\n\n    def backward(self, x, t):\n        #w3_d = (self.out * (1 - self.out)) * (self.out - y)\n        #xw3_delta = np.dot(self.w3.T * (self.out - xy), (self.out) * (1 - self.out))\n        #w3_dW = w3_d * self.z2.T[..., None]\n        #w3_dB = w3_d\n\n        w3_d = 2 * (self.out - t) * sigmoid_derivative(self.out)\n        print(self.w3.shape)\n        print(w3_d.shape)\n        print(self.w3.T.shape)\n        w3_dW = np.dot(self.w2.T, w3_d)\n        w3_dB = w3_d\n        \n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB\n\n        #w2_d = np.dot((self.z2 * (1 - self.z2))[..., None], (self.z3.T * w3_d))\n        w2_d = np.dot(self.z3.T, w3_d) * (self.z2) * (1 - self.z2)\n        w2_dW = w2_d[..., None] * self.z1\n        w2_dB = w2_d\n\n        self.w2 += self.lr * w2_dW\n        self.b2 += self.lr * w2_dB\n        \n    def train(self, x, t):\n        self.forward(x)\n        self.backward(x, t)\n\n\nclass NeuralNetwork:\n    def __init__(self, x, y):\n        self.input      = x\n        self.weights1   = np.random.rand(self.input.shape[1],4) \n        self.weights2   = np.random.rand(4,1)                 \n        self.y          = y\n        self.output     = np.zeros(self.y.shape)\n\n    def feedforward(self):\n        self.layer1 = sigmoid(np.dot(self.input, self.weights1))\n        self.output = sigmoid(np.dot(self.layer1, self.weights2))\n\n    def backprop(self):\n        # application of the chain rule to find derivative of the loss function with respect to weights2 and weights1\n        d_weights2 = np.dot(self.layer1.T, (2*(self.y - self.output) * sigmoid_derivative(self.output)))\n        d_weights1 = np.dot(self.input.T,  (np.dot(2*(self.y - self.output) * sigmoid_derivative(self.output), self.weights2.T) * sigmoid_derivative(self.layer1)))\n\n        # update the weights with the derivative (slope) of the loss function\n        self.weights1 += d_weights1\n        self.weights2 += d_weights2\n\n\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\ndef sigmoid_derivative(x):\n    return sigmoid(x) * (1. - sigmoid(x))\n\ntrainx = np.array(((0,0), (0,1), (1,0), (1,1)), dtype=np.float32)\ntrainy = np.array((0, 1, 1, 0), dtype=np.float32)\n\nnn = NN()\n\nnn2 = NeuralNetwork(trainx, trainy)\n\nfor i in range(10000):\n    """"""\n    for j in range(4):\n        nn.train(trainx[j%4], trainy[j%4])\n    #print(""epoch: "" , i)\n    for j in range(4):\n        if i == 0 or i == 9999:\n            print(nn.forward(trainx[j]), end=\' \')\n    #print()\n    """"""\n    nn2.feedforward()\n    nn2.backprop()\n\n    print(nn2.output)\n'"
yobi/neuralnet2.py,10,"b'import numpy as np\n\ndef sigmoid(x):\n    return 1.0/(1+ np.exp(-x))\n\ndef sigmoid_derivative(x):\n    return x * (1.0 - x)\n\nclass NeuralNetwork:\n    def __init__(self, x, t):\n        self.z1      = x\n        self.w2   = np.random.rand(self.z1.shape[1],3)\n        self.w3   = np.random.rand(3,1)\n        self.t          = t\n        self.out     = np.zeros(self.t.shape)\n\n    def feedforward(self):\n        self.z2 = sigmoid(np.dot(self.z1, self.w2))\n        self.out = sigmoid(np.dot(self.z2, self.w3))\n\n    def backprop(self):\n        # application of the chain rule to find derivative of the loss function with respect to w3 and w2\n        d_w3 = np.dot(self.z2.T, (2*(self.t - self.out) * sigmoid_derivative(self.out)))\n        d_w2 = np.dot(self.z1.T, (np.dot(2*(self.t - self.out) * sigmoid_derivative(self.out), self.w3.T) * sigmoid_derivative(self.z2)))\n\n        # update the weights with the derivative (slope) of the loss function\n        self.w2 += d_w2\n        self.w3 += d_w3\n\n\nif __name__ == ""__main__"":\n    X = np.array([[0, 0],\n                  [0, 1],\n                  [1, 0],\n                  [1, 1]])\n    y = np.array([[0],[1],[1],[0]])\n    nn = NeuralNetwork(X,y)\n    print(X.shape, y.shape)\n    for i in range(15000):\n        nn.feedforward()\n        nn.backprop()\n\n    print(nn.out)\n'"
yobi/nn.py,15,"b'import numpy as np\n\nnp.random.seed(0)\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.wout = np.random.randn(w, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.out = self.sigmoid(np.dot(self.z2, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z2.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        # backpropagation inter layer\n        w2_d = np.dot(out_d, self.wout.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\ntrain_x = np.array([[0,0], [0,1], [1,0], [1,1]], dtype=np.float32)\ntrain_t = np.array([[0], [1], [1], [0]], dtype=np.float32)\n\nnn = NN(ind=train_x.shape[1])\n\n# training\nfor i in range(1000):\n    nn.forward(train_x)\n    nn.train(train_x, train_t)\n\n# test\nfor j in range(4):\n    x = train_x[j]\n    t = train_t[j]\n    print(""in:"", x, ""pred:"", nn.forward(x))\n'"
Question_01_10/answers_py/answer_1.py,0,"b'import cv2\n\n# function: BGR -> RGB\ndef BGR2RGB(img):\n    b = img[:, :, 0].copy()\n    g = img[:, :, 1].copy()\n    r = img[:, :, 2].copy()\n\n    # RGB > BGR\n    img[:, :, 0] = r\n    img[:, :, 1] = g\n    img[:, :, 2] = b\n\n    return img\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# BGR -> RGB\nimg = BGR2RGB(img)\n\n# Save result\ncv2.imwrite(""out.jpg"", img)\ncv2.imshow(""result"", img)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_10.py,4,"b'import cv2\nimport numpy as np\n\n\n# Median filter\ndef median_filter(img, K_size=3):\n    H, W, C = img.shape\n\n    ## Zero padding\n    pad = K_size // 2\n    out = np.zeros((H + pad*2, W + pad*2, C), dtype=np.float)\n    out[pad:pad+H, pad:pad+W] = img.copy().astype(np.float)\n\n    tmp = out.copy()\n\n    # filtering\n    for y in range(H):\n        for x in range(W):\n            for c in range(C):\n                out[pad+y, pad+x, c] = np.median(tmp[y:y+K_size, x:x+K_size, c])\n\n    out = out[pad:pad+H, pad:pad+W].astype(np.uint8)\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""imori_noise.jpg"")\n\n\n# Median Filter\nout = median_filter(img, K_size=3)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_2.py,2,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# Grayscale\nout = BGR2GRAY(img)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_3.py,2,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# binalization\ndef binarization(img, th=128):\n\timg[img < th] = 0\n\timg[img >= th] = 255\n\treturn img\n\t\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Grayscale\nout = BGR2GRAY(img)\n\n# Binarization\nout = binarization(out)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_4.py,6,"b'import cv2\nimport numpy as np\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img):\n\tmax_sigma = 0\n\tmax_t = 0\n\tH, W = img.shape\n\t# determine threshold\n\tfor _t in range(1, 256):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n\n# Grayscale\nout = BGR2GRAY(img)\n\n# Otsu\'s binarization\nout = otsu_binarization(out)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_5.py,18,"b'import cv2\nimport numpy as np\n\n\n# BGR -> HSV\ndef BGR2HSV(_img):\n\timg = _img.copy() / 255.\n\n\thsv = np.zeros_like(img, dtype=np.float32)\n\n\t# get max and min\n\tmax_v = np.max(img, axis=2).copy()\n\tmin_v = np.min(img, axis=2).copy()\n\tmin_arg = np.argmin(img, axis=2)\n\n\t# H\n\thsv[..., 0][np.where(max_v == min_v)]= 0\n\t## if min == B\n\tind = np.where(min_arg == 0)\n\thsv[..., 0][ind] = 60 * (img[..., 1][ind] - img[..., 2][ind]) / (max_v[ind] - min_v[ind]) + 60\n\t## if min == R\n\tind = np.where(min_arg == 2)\n\thsv[..., 0][ind] = 60 * (img[..., 0][ind] - img[..., 1][ind]) / (max_v[ind] - min_v[ind]) + 180\n\t## if min == G\n\tind = np.where(min_arg == 1)\n\thsv[..., 0][ind] = 60 * (img[..., 2][ind] - img[..., 0][ind]) / (max_v[ind] - min_v[ind]) + 300\n\t\t\n\t# S\n\thsv[..., 1] = max_v.copy() - min_v.copy()\n\n\t# V\n\thsv[..., 2] = max_v.copy()\n\t\n\treturn hsv\n\n\ndef HSV2BGR(_img, hsv):\n\timg = _img.copy() / 255.\n\n\t# get max and min\n\tmax_v = np.max(img, axis=2).copy()\n\tmin_v = np.min(img, axis=2).copy()\n\n\tout = np.zeros_like(img)\n\n\tH = hsv[..., 0]\n\tS = hsv[..., 1]\n\tV = hsv[..., 2]\n\n\tC = S\n\tH_ = H / 60.\n\tX = C * (1 - np.abs( H_ % 2 - 1))\n\tZ = np.zeros_like(H)\n\n\tvals = [[Z,X,C], [Z,C,X], [X,C,Z], [C,X,Z], [C,Z,X], [X,Z,C]]\n\n\tfor i in range(6):\n\t\tind = np.where((i <= H_) & (H_ < (i+1)))\n\t\tout[..., 0][ind] = (V - C)[ind] + vals[i][0][ind]\n\t\tout[..., 1][ind] = (V - C)[ind] + vals[i][1][ind]\n\t\tout[..., 2][ind] = (V - C)[ind] + vals[i][2][ind]\n\n\tout[np.where(max_v == min_v)] = 0\n\tout = np.clip(out, 0, 1)\n\tout = (out * 255).astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# RGB > HSV\nhsv = BGR2HSV(img)\n\n# Transpose Hue\nhsv[..., 0] = (hsv[..., 0] + 180) % 360\n\n# HSV > RGB\nout = HSV2BGR(img, hsv)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_6.py,0,"b'import cv2\nimport numpy as np\n\n\n# Decrease color\ndef decrease_color(img):\n\tout = img.copy()\n\n\tout = out // 64 * 64 + 32\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# Dicrease color\nout = dicrease_color(img)\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_7.py,1,"b'import cv2\nimport numpy as np\n\n\n# average pooling\ndef average_pooling(img, G=8):\n    out = img.copy()\n\n    H, W, C = img.shape\n    Nh = int(H / G)\n    Nw = int(W / G)\n\n    for y in range(Nh):\n        for x in range(Nw):\n            for c in range(C):\n                out[G*y:G*(y+1), G*x:G*(x+1), c] = np.mean(out[G*y:G*(y+1), G*x:G*(x+1), c]).astype(np.int)\n    \n    return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# Average Pooling\nout = average_pooling(img)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_8.py,1,"b'import cv2\nimport numpy as np\n\n# max pooling\ndef max_pooling(img, G=8):\n    # Max Pooling\n    out = img.copy()\n\n    H, W, C = img.shape\n    Nh = int(H / G)\n    Nw = int(W / G)\n\n    for y in range(Nh):\n        for x in range(Nw):\n            for c in range(C):\n                out[G*y:G*(y+1), G*x:G*(x+1), c] = np.max(out[G*y:G*(y+1), G*x:G*(x+1), c])\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# Max pooling\nout = max_pooling(img)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_01_10/answers_py/answer_9.py,9,"b'import cv2\nimport numpy as np\n\n\n# Gaussian filter\ndef gaussian_filter(img, K_size=3, sigma=1.3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\timg = np.expand_dims(img, axis=-1)\n\t\tH, W, C = img.shape\n\n\t\t\n\t## Zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2, C), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\n\t## prepare Kernel\n\tK = np.zeros((K_size, K_size), dtype=np.float)\n\tfor x in range(-pad, -pad + K_size):\n\t\tfor y in range(-pad, -pad + K_size):\n\t\t\tK[y + pad, x + pad] = np.exp( -(x ** 2 + y ** 2) / (2 * (sigma ** 2)))\n\tK /= (2 * np.pi * sigma * sigma)\n\tK /= K.sum()\n\n\ttmp = out.copy()\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tfor c in range(C):\n\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y: y + K_size, x: x + K_size, c])\n\n\tout = np.clip(out, 0, 255)\n\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori_noise.jpg"")\n\n\n# Gaussian Filter\nout = gaussian_filter(img, K_size=3, sigma=1.3)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_11.py,4,"b'import cv2\nimport numpy as np\n\n# mean filter\ndef mean_filter(img, K_size=3):\n    H, W, C = img.shape\n\n    # zero padding\n    pad = K_size // 2\n    out = np.zeros((H + pad * 2, W + pad * 2, C), dtype=np.float)\n    out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n    tmp = out.copy()\n\n    # filtering\n    for y in range(H):\n        for x in range(W):\n            for c in range(C):\n                out[pad + y, pad + x, c] = np.mean(tmp[y: y + K_size, x: x + K_size, c])\n\n    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# Mean Filter\nout = mean_filter(img, K_size=3)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_12.py,5,"b'import cv2\nimport numpy as np\n\n# motion filter\ndef motion_filter(img, K_size=3):\n    H, W, C = img.shape\n\n    # Kernel\n    K = np.diag( [1] * K_size ).astype(np.float)\n    K /= K_size\n\n    # zero padding\n    pad = K_size // 2\n    out = np.zeros((H + pad * 2, W + pad * 2, C), dtype=np.float)\n    out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n    tmp = out.copy()\n\n    # filtering\n    for y in range(H):\n        for x in range(W):\n            for c in range(C):\n                out[pad + y, pad + x, c] = np.sum(K * tmp[y: y + K_size, x: x + K_size, c])\n\n    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"")\n\n# motion filtering\nout = motion_filter(img, K_size=3)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_13.py,10,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# max-min filter\ndef max_min_filter(img, K_size=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2, 3), dtype=np.float)\n\t\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(3):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.max(tmp[y: y + K_size, x: x + K_size, c]) - np.min(tmp[y: y + K_size, x: x + K_size, c])\n\n\t\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\telse:\n\t\tH, W = img.shape\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout[pad + y, pad + x] = np.max(tmp[y: y + K_size, x: x + K_size]) - np.min(tmp[y: y + K_size, x: x + K_size])\n\n\t\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# Max-Min filtering\nout = max_min_filter(gray, K_size=3)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_14.py,11,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# different filter\ndef different_filter(img, K_size=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\timg = np.expand_dims(img, axis=-1)\n\t\tH, W, C = img.shape\n\n\t# Zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\tout_v = out.copy()\n\tout_h = out.copy()\n\n\t# vertical kernel\n\tKv = [[0., -1., 0.],[0., 1., 0.],[0., 0., 0.]]\n\t# horizontal kernel\n\tKh = [[0., 0., 0.],[-1., 1., 0.], [0., 0., 0.]]\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))\n\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))\n\n\tout_v = np.clip(out_v, 0, 255)\n\tout_h = np.clip(out_h, 0, 255)\n\n\tout_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)\n\tout_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out_v, out_h\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# different filtering\nout_v, out_h = different_filter(gray, K_size=3)\n\n\n\n# Save result\ncv2.imwrite(""out_v.jpg"", out_v)\ncv2.imshow(""result_v"", out_v)\nwhile cv2.waitKey(100) != 27:# loop if not get ESC\n    if cv2.getWindowProperty(\'result_v\',cv2.WND_PROP_VISIBLE) <= 0:\n        break\ncv2.destroyWindow(\'result_v\')\n\ncv2.imwrite(""out_h.jpg"", out_h)\ncv2.imshow(""result_h"", out_h)\n# loop if not get ESC or click x\nwhile cv2.waitKey(100) != 27:\n    if cv2.getWindowProperty(\'result_h\',cv2.WND_PROP_VISIBLE) <= 0:\n        break\ncv2.destroyWindow(\'result_h\')\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_15.py,10,"b'import cv2\nimport numpy as np\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# prewitt filter\ndef prewitt_filter(img, K_size=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\n\t# Zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\tout_v = out.copy()\n\tout_h = out.copy()\n\n\t## prewitt vertical kernel\n\tKv = [[-1., -1., -1.],[0., 0., 0.], [1., 1., 1.]]\n\t## prewitt horizontal kernel\n\tKh = [[-1., 0., 1.],[-1., 0., 1.],[-1., 0., 1.]]\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))\n\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))\n\n\n\tout_v = np.clip(out_v, 0, 255)\n\tout_h = np.clip(out_h, 0, 255)\n\n\tout_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)\n\tout_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out_v, out_h\n\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# prewitt filtering\nout_v, out_h = prewitt_filter(gray, K_size=3)\n\n\n# Save result\ncv2.imwrite(""out_v.jpg"", out_v)\ncv2.imshow(""result"", out_v)\ncv2.waitKey(0)\n\ncv2.imwrite(""out_h.jpg"", out_h)\ncv2.imshow(""result"", out_h)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_16.py,11,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# sobel filter\ndef sobel_filter(img, K_size=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\timg = np.expand_dims(img, axis=-1)\n\t\tH, W, C = img.shape\n\n\t# Zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\tout_v = out.copy()\n\tout_h = out.copy()\n\n\t## Sobel vertical\n\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t## Sobel horizontal\n\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))\n\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))\n\n\tout_v = np.clip(out_v, 0, 255)\n\tout_h = np.clip(out_h, 0, 255)\n\n\tout_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)\n\tout_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out_v, out_h\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# sobel filtering\nout_v, out_h = sobel_filter(gray, K_size=3)\n\n# Save result\ncv2.imwrite(""out_v.jpg"", out_v)\ncv2.imshow(""result"", out_v)\ncv2.waitKey(0)\n\ncv2.imwrite(""out_h.jpg"", out_h)\ncv2.imshow(""result"", out_h)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_17.py,7,"b'import cv2\nimport numpy as np\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# laplacian filter\ndef laplacian_filter(img, K_size=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\n\t# zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\t# laplacian kernle\n\tK = [[0., 1., 0.],[1., -4., 1.], [0., 1., 0.]]\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout[pad + y, pad + x] = np.sum(K * (tmp[y: y + K_size, x: x + K_size]))\n\n\tout = np.clip(out, 0, 255)\n\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# prewitt filtering\nout = laplacian_filter(gray, K_size=3)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_18.py,7,"b'import cv2\nimport numpy as np\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# emboss filter\ndef emboss_filter(img, K_size=3):\n\tH, W, C = img.shape\n\n\t# zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\t# emboss kernel\n\tK = [[-2., -1., 0.],[-1., 1., 1.], [0., 1., 2.]]\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout[pad + y, pad + x] = np.sum(K * (tmp[y: y + K_size, x: x + K_size]))\n\n\tout = np.clip(out, 0, 255)\n\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# emboss filtering\nout = emboss_filter(gray, K_size=3)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_19.py,10,"b'import cv2\nimport numpy as np\n\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# LoG filter\ndef LoG_filter(img, K_size=5, sigma=3):\n\tif len(img.shape) == 3:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\n\t# zero padding\n\tpad = K_size // 2\n\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\tout[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)\n\ttmp = out.copy()\n\n\t# LoG Kernel\n\tK = np.zeros((K_size, K_size), dtype=np.float)\n\tfor x in range(-pad, -pad + K_size):\n\t\tfor y in range(-pad, -pad + K_size):\n\t\t\tK[y + pad, x + pad] = (x ** 2 + y ** 2 - 2 * (sigma ** 2)) * np.exp( - (x ** 2 + y ** 2) / (2 * (sigma ** 2)))\n\tK /= (2 * np.pi * (sigma ** 6))\n\tK /= K.sum()\n\n\t""""""\n\tK = np.array([[0, 0, 1, 0, 0],\n\t\t\t\t\t\t\t\t[0, 1, 2, 1, 0],\n\t\t\t\t\t\t\t\t[1, 2, -16, 2, 1],\n\t\t\t\t\t\t\t\t[0, 1, 2, 1, 0],\n\t\t\t\t\t\t\t\t[0, 0, 1, 0, 0]])\n\t""""""\n\tprint(K)\n\n\t# filtering\n\tfor y in range(H):\n\t\tfor x in range(W):\n\t\t\tout[pad + y, pad + x] = np.sum(K * tmp[y: y + K_size, x: x + K_size])\n\n\tout = np.clip(out, 0, 255)\n\tout = out[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori_noise.jpg"")\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# LoG filtering\nout = LoG_filter(gray, K_size=5, sigma=1)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_11_20/answers_py/answer_20.py,1,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Read image\nimg = cv2.imread(""imori_dark.jpg"").astype(np.float)\n\n# Display histogram\nplt.hist(img.ravel(), bins=255, rwidth=0.8, range=(0, 255))\nplt.savefig(""out.png"")\nplt.show()\n'"
Question_21_30/answers_py/answer_21.py,2,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# histogram normalization\ndef hist_normalization(img, a=0, b=255):\n\t# get max and min\n\tc = img.min()\n\td = img.max()\n\n\tout = img.copy()\n\n\t# normalization\n\tout = (b-a) / (d - c) * (out - c) + a\n\tout[out < a] = a\n\tout[out > b] = b\n\tout = out.astype(np.uint8)\n\t\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori_dark.jpg"").astype(np.float)\nH, W, C = img.shape\n\n# histogram normalization\nout = hist_normalization(img)\n\n# Display histogram\nplt.hist(out.ravel(), bins=255, rwidth=0.8, range=(0, 255))\nplt.savefig(""out_his.png"")\nplt.show()\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_22.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# histogram manipulation\ndef hist_mani(img, m0=128, s0=52):\n\tm = np.mean(img)\n\ts = np.std(img)\n\n\tout = img.copy()\n\n\t# normalize\n\tout = s0 / s * (out - m) + m0\n\tout[out < 0] = 0\n\tout[out > 255] = 255\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori_dark.jpg"").astype(np.float)\n\nout = hist_mani(img)\n\n# Display histogram\nplt.hist(out.ravel(), bins=255, rwidth=0.8, range=(0, 255))\nplt.savefig(""out_his.png"")\nplt.show()\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_23.py,3,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# histogram equalization\ndef hist_equal(img, z_max=255):\n\tH, W, C = img.shape\n\tS = H * W * C * 1.\n\n\tout = img.copy()\n\n\tsum_h = 0.\n\n\tfor i in range(1, 255):\n\t\tind = np.where(img == i)\n\t\tsum_h += len(img[ind])\n\t\tz_prime = z_max / S * sum_h\n\t\tout[ind] = z_prime\n\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# histogram normalization\nout = hist_equal(img)\n\n# Display histogram\nplt.hist(out.ravel(), bins=255, rwidth=0.8, range=(0, 255))\nplt.savefig(""out_his.png"")\nplt.show()\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_24.py,2,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# gamma correction\ndef gamma_correction(img, c=1, g=2.2):\n\tout = img.copy()\n\tout /= 255.\n\tout = (1/c * out) ** (1/g)\n\n\tout *= 255\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori_gamma.jpg"").astype(np.float)\n\n# Gammma correction\nout = gamma_correction(img)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_25.py,6,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Nereset Neighbor interpolation\ndef nn_interpolate(img, ax=1, ay=1):\n\tH, W, C = img.shape\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\ty = np.arange(aH).repeat(aW).reshape(aH, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\ty = np.round(y / ay).astype(np.int)\n\tx = np.round(x / ax).astype(np.int)\n\n\tout = img[y,x]\n\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# Nearest Neighbor\nout = nn_interpolate(img, ax=1.5, ay=1.5)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_26.py,11,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Bi-Linear interpolation\ndef bl_interpolate(img, ax=1., ay=1.):\n\tH, W, C = img.shape\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get position of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aH, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\n\t# get position of original position\n\ty = (y / ay)\n\tx = (x / ax)\n\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-2)\n\tiy = np.minimum(iy, H-2)\n\n\t# get distance \n\tdx = x - ix\n\tdy = y - iy\n\n\tdx = np.repeat(np.expand_dims(dx, axis=-1), 3, axis=-1)\n\tdy = np.repeat(np.expand_dims(dy, axis=-1), 3, axis=-1)\n\n\t# interpolation\n\tout = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# Bilinear interpolation\nout = bl_interpolate(img, ax=1.5, ay=1.5)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_27.py,21,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Bi-cubic interpolation\ndef bc_interpolate(img, ax=1., ay=1.):\n\tH, W, C = img.shape\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get positions of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aH, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\ty = (y / ay)\n\tx = (x / ax)\n\n\t# get positions of original image\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-1)\n\tiy = np.minimum(iy, H-1)\n\n\t# get distance of each position of original image\n\tdx2 = x - ix\n\tdy2 = y - iy\n\tdx1 = dx2 + 1\n\tdy1 = dy2 + 1\n\tdx3 = 1 - dx2\n\tdy3 = 1 - dy2\n\tdx4 = 1 + dx3\n\tdy4 = 1 + dy3\n\n\tdxs = [dx1, dx2, dx3, dx4]\n\tdys = [dy1, dy2, dy3, dy4]\n\n\t# bi-cubic weight\n\tdef weight(t):\n\t\ta = -1.\n\t\tat = np.abs(t)\n\t\tw = np.zeros_like(t)\n\t\tind = np.where(at <= 1)\n\t\tw[ind] = ((a+2) * np.power(at, 3) - (a+3) * np.power(at, 2) + 1)[ind]\n\t\tind = np.where((at > 1) & (at <= 2))\n\t\tw[ind] = (a*np.power(at, 3) - 5*a*np.power(at, 2) + 8*a*at - 4*a)[ind]\n\t\treturn w\n\n\tw_sum = np.zeros((aH, aW, C), dtype=np.float32)\n\tout = np.zeros((aH, aW, C), dtype=np.float32)\n\n\t# interpolate\n\tfor j in range(-1, 3):\n\t\tfor i in range(-1, 3):\n\t\t\tind_x = np.minimum(np.maximum(ix + i, 0), W-1)\n\t\t\tind_y = np.minimum(np.maximum(iy + j, 0), H-1)\n\n\t\t\twx = weight(dxs[i+1])\n\t\t\twy = weight(dys[j+1])\n\t\t\twx = np.repeat(np.expand_dims(wx, axis=-1), 3, axis=-1)\n\t\t\twy = np.repeat(np.expand_dims(wy, axis=-1), 3, axis=-1)\n\n\t\t\tw_sum += wx * wy\n\t\t\tout += wx * wy * img[ind_y, ind_x]\n\n\tout /= w_sum\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Bi-cubic interpolation\nout = bc_interpolate(img, ax=1.5, ay=1.5)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_28.py,12,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Affine\ndef affine(img, a, b, c, d, tx, ty):\n  \tH, W, C = img.shape\n\n\t# temporary image\n\timg = np.zeros((H+2, W+2, C), dtype=np.float32)\n\timg[1:H+1, 1:W+1] = _img\n\n\t# get new image shape\n\tH_new = np.round(H * d).astype(np.int)\n\tW_new = np.round(W * a).astype(np.int)\n\tout = np.zeros((H_new+1, W_new+1, C), dtype=np.float32)\n\n\t# get position of new image\n\tx_new = np.tile(np.arange(W_new), (H_new, 1))\n\ty_new = np.arange(H_new).repeat(W_new).reshape(H_new, -1)\n\n\t# get position of original image by affine\n\tadbc = a * d - b * c\n\tx = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + 1\n\ty = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + 1\n\n\tx = np.minimum(np.maximum(x, 0), W+1).astype(np.int)\n\ty = np.minimum(np.maximum(y, 0), H+1).astype(np.int)\n\n\t# assgin pixcel to new image\n\tout[y_new, x_new] = img[y, x]\n\n\tout = out[:H_new, :W_new]\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\n_img = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Affine\nout = affine(_img, a=1, b=0, c=0, d=1, tx=30, ty=-30)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_29.py,12,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Affine\ndef affine(img, a, b, c, d, tx, ty):\n  \tH, W, C = img.shape\n\n\t# temporary image\n\timg = np.zeros((H+2, W+2, C), dtype=np.float32)\n\timg[1:H+1, 1:W+1] = _img\n\n\t# get new image shape\n\tH_new = np.round(H * d).astype(np.int)\n\tW_new = np.round(W * a).astype(np.int)\n\tout = np.zeros((H_new+1, W_new+1, C), dtype=np.float32)\n\n\t# get position of new image\n\tx_new = np.tile(np.arange(W_new), (H_new, 1))\n\ty_new = np.arange(H_new).repeat(W_new).reshape(H_new, -1)\n\n\t# get position of original image by affine\n\tadbc = a * d - b * c\n\tx = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + 1\n\ty = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + 1\n\n\tx = np.minimum(np.maximum(x, 0), W+1).astype(np.int)\n\ty = np.minimum(np.maximum(y, 0), H+1).astype(np.int)\n\n\t# assgin pixcel to new image\n\tout[y_new, x_new] = img[y, x]\n\n\tout = out[:H_new, :W_new]\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\n_img = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Affine\nout = affine(_img, a=1.3, b=0, c=0, d=0.8, tx=30, ty=-30)\n\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_21_30/answers_py/answer_30.py,14,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# affine\ndef affine(img, a, b, c, d, tx, ty):\n\tH, W, C = _img.shape\n\n\t# temporary image\n\timg = np.zeros((H+2, W+2, C), dtype=np.float32)\n\timg[1:H+1, 1:W+1] = _img\n\n\t# get shape of new image\n\tH_new = np.round(H).astype(np.int)\n\tW_new = np.round(W).astype(np.int)\n\tout = np.zeros((H_new, W_new, C), dtype=np.float32)\n\n\t# get position of new image\n\tx_new = np.tile(np.arange(W_new), (H_new, 1))\n\ty_new = np.arange(H_new).repeat(W_new).reshape(H_new, -1)\n\n\t# get position of original image by affine\n\tadbc = a * d - b * c\n\tx = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + 1\n\ty = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + 1\n\n\t# adjust center by affine\n\tdcx = (x.max() + x.min()) // 2 - W // 2\n\tdcy = (y.max() + y.min()) // 2 - H // 2\n\n\tx -= dcx\n\ty -= dcy\n\n\tx = np.clip(x, 0, W + 1)\n\ty = np.clip(y, 0, H + 1)\n\n\t# assign pixcel\n\tout[y_new, x_new] = img[y, x]\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Read image\n_img = cv2.imread(""imori.jpg"").astype(np.float32)\n\n\n# Affine\nA = 30.\ntheta = - np.pi * A / 180.\n\nout = affine(_img, a=np.cos(theta), b=-np.sin(theta), c=np.sin(theta), d=np.cos(theta),\n tx=0, ty=0)\n\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/_answer_38.py,20,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# Gray scale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\n# DCT\nT = 8\nK = 8\nX = np.zeros((H, W), dtype=np.float64)\n#indx = np.tile(np.arange(T), (T, 1))\n#indy = np.arange(T).repeat(T).reshape(T, -1)\n#dct = np.ones_like(indx, dtype=np.float32)\n#dct[:, 0] /= np.sqrt(2)\n#dct[0] /= np.sqrt(2)\n\nQ = np.array(((16, 11, 10, 16, 24, 40, 51, 61),\n              (12, 12, 14, 19, 26, 58, 60, 55),\n              (14, 13, 16, 24, 40, 57, 69, 56),\n              (14, 17, 22, 29, 51, 87, 80, 62),\n              (18, 22, 37, 56, 68, 109, 103, 77),\n              (24, 35, 55, 64, 81, 104, 113, 92),\n              (49, 64, 78, 87, 103, 121, 120, 101),\n              (72, 92, 95, 98, 112, 100, 103, 99)), dtype=np.float32)\n\ndef w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n    \nfor yi in range(0, H, T):\n    for xi in range(0, W, T):\n        for v in range(T):\n            for u in range(T):\n                for y in range(T):\n                    for x in range(T):\n                        X[v+yi, u+xi] += gray[y+yi, x+xi] * w(x,y,u,v)\n        X[yi:yi+T, xi:xi+T] = np.round(X[yi:yi+T, xi:xi+T] / Q) * Q\n                \n                #_x = indx + xi * T\n                #_y = indy + yi * T\n                #_u = u + xi * T\n                #_v = v + yi * T\n                #X[_v, _u] = np.sum(C * gray[_y, _x] * np.cos((2*indx+1)*u*np.pi/(2*T)) * np.cos((2*indy+1)*v*np.pi/(2*T)))\n\n# IDCT\nout = np.zeros((H, W), dtype=np.float64)\n\nfor yi in range(0, H, T):\n    for xi in range(0, W, T):\n        for y in range(T):\n            for x in range(T):\n                for v in range(K):\n                    for u in range(K):\n                        out[y+yi, x+xi] += X[v+yi, u+xi] * w(x,y,u,v)\n                """"""\n                _u = indx + xi * T\n                _v = indy + yi * T\n                _x = x + yi * T\n                _y = y + xi * T\n                out[_y, _x] = np.sum(C * X[_v, _u] * np.cos((2*x+1)*indx*np.pi/(2*T)) * np.cos((2*y+1)*indy*np.pi/(2*T))) * 4. / (T ** 2)\n                """"""\nout[out>255] = 255\nout = np.floor(out).astype(np.uint8)\n\n# MSE\nv_max = 255.\nmse = np.sum(np.power(np.abs(gray.astype(np.float32) - out.astype(np.float32)), 2)) / (H * W)\npsnr = 10 * np.log10(v_max ** 2 / mse)\n\nprint(""PSNR >>"", psnr)\n\nbitrate = 1. * T * K ** 2 / (T ** 2)\nprint(""bitrate >>"", bitrate)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/_answer_40.py,19,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# RGB > YCbCr\nY = 0.2990 * img[..., 2] + 0.5870 * img[..., 1] + 0.1140 * img[..., 0]\nCb = -0.1687 * img[..., 2] - 0.3313 * img[..., 1] + 0.5 * img[..., 0] + 128.\nCr = 0.5 * img[..., 2] - 0.4187 * img[..., 1] - 0.0813 * img[..., 0] + 128.\n\nYCC = np.zeros_like(img, dtype=np.float32)\nYCC[..., 0] = Y\nYCC[..., 1] = Cb\nYCC[..., 2] = Cr\n\n\n# DCT\nT = 8\nK = 8\nX = np.zeros((H, W, C), dtype=np.float64)\n\nQ1 = np.array(((16, 11, 10, 16, 24, 40, 51, 61),\n               (12, 12, 14, 19, 26, 58, 60, 55),\n               (14, 13, 16, 24, 40, 57, 69, 56),\n               (14, 17, 22, 29, 51, 87, 80, 62),\n               (18, 22, 37, 56, 68, 109, 103, 77),\n               (24, 35, 55, 64, 81, 104, 113, 92),\n               (49, 64, 78, 87, 103, 121, 120, 101),\n               (72, 92, 95, 98, 112, 100, 103, 99)), dtype=np.float32)\n\nQ2 = np.array(((17, 18, 24, 47, 99, 99, 99, 99),\n               (18, 21, 26, 66, 99, 99, 99, 99),\n               (24, 26, 56, 99, 99, 99, 99, 99),\n               (47, 66, 99, 99, 99, 99, 99, 99),\n               (99, 99, 99, 99, 99, 99, 99, 99),\n               (99, 99, 99, 99, 99, 99, 99, 99),\n               (99, 99, 99, 99, 99, 99, 99, 99),\n               (99, 99, 99, 99, 99, 99, 99, 99)), dtype=np.float32)\n\ndef w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n    \nfor yi in range(0, H, T):\n    for xi in range(0, W, T):\n        for v in range(T):\n            for u in range(T):\n                for y in range(T):\n                    for x in range(T):\n                        for c in range(C):\n                            X[v+yi, u+xi, c] += YCC[y+yi, x+xi, c] * w(x,y,u,v)\n                            \n        X[yi:yi+T, xi:xi+T, 0] = np.round(X[yi:yi+T, xi:xi+T, 0] / Q1) * Q1\n        X[yi:yi+T, xi:xi+T, 1] = np.round(X[yi:yi+T, xi:xi+T, 1] / Q2) * Q2\n        X[yi:yi+T, xi:xi+T, 2] = np.round(X[yi:yi+T, xi:xi+T, 2] / Q2) * Q2\n                \n\n# IDCT\nIYCC = np.zeros((H, W, 3), dtype=np.float64)\n\nfor yi in range(0, H, T):\n    for xi in range(0, W, T):\n        for y in range(T):\n            for x in range(T):\n                for v in range(K):\n                    for u in range(K):\n                        IYCC[y+yi, x+xi] += X[v+yi, u+xi] * w(x,y,u,v)\n\n\n# YCbCr > RGB\nout = np.zeros_like(img, dtype=np.float32)\nout[..., 2] = IYCC[..., 0] + (IYCC[..., 2] - 128.) * 1.4020\nout[..., 1] = IYCC[..., 0] - (IYCC[..., 1] - 128.) * 0.3441 - (IYCC[..., 2] - 128.) * 0.7139\nout[..., 0] = IYCC[..., 0] + (IYCC[..., 1] - 128.) * 1.7718\n\nout[out>255] = 255\nout = out.astype(np.uint8)\n                        \n# MSE\nv_max = 255.\nmse = np.sum(np.power(np.abs(img.astype(np.float32) - out.astype(np.float32)), 2)) / (H * W * C)\npsnr = 10 * np.log10(v_max ** 2 / mse)\n\nprint(""PSNR >>"", psnr)\n\nbitrate = 1. * T * K ** 2 / (T ** 2)\nprint(""bitrate >>"", bitrate)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_31.py,12,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Affine\ndef affine(img, dx=30, dy=30):\n    # get shape\n    H, W, C = img.shape\n\n    # Affine hyper parameters\n    a = 1.\n    b = dx / H\n    c = dy / W\n    d = 1.\n    tx = 0.\n    ty = 0.\n\n    # prepare temporary\n    _img = np.zeros((H+2, W+2, C), dtype=np.float32)\n\n    # insert image to center of temporary\n    _img[1:H+1, 1:W+1] = img\n\n    # prepare affine image temporary\n    H_new = np.ceil(dy + H).astype(np.int)\n    W_new = np.ceil(dx + W).astype(np.int)\n    out = np.zeros((H_new, W_new, C), dtype=np.float32)\n\n    # preprare assigned index\n    x_new = np.tile(np.arange(W_new), (H_new, 1))\n    y_new = np.arange(H_new).repeat(W_new).reshape(H_new, -1)\n\n    # prepare inverse matrix for affine\n    adbc = a * d - b * c\n    x = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + 1\n    y = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + 1\n\n    x = np.minimum(np.maximum(x, 0), W+1).astype(np.int)\n    y = np.minimum(np.maximum(y, 0), H+1).astype(np.int)\n\n    # assign value from original to affine image\n    out[y_new, x_new] = _img[y, x]\n    out = out.astype(np.uint8)\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Affine\nout = affine(img, dx=30, dy=30)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_32.py,17,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# DFT hyper-parameters\nK, L = 128, 128\nchannel = 3\n\n\n# DFT\ndef dft(img):\n\tH, W, _ = img.shape\n\n\t# Prepare DFT coefficient\n\tG = np.zeros((L, K, channel), dtype=np.complex)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# dft\n\tfor c in range(channel):\n\t\tfor l in range(L):\n\t\t\tfor k in range(K):\n\t\t\t\tG[l, k, c] = np.sum(img[..., c] * np.exp(-2j * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)\n\t\t\t\t#for n in range(N):\n\t\t\t\t#    for m in range(M):\n\t\t\t\t#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))\n\t\t\t\t#G[l, k] = v / np.sqrt(M * N)\n\n\treturn G\n\n# IDFT\ndef idft(G):\n\t# prepare out image\n\tH, W, _ = G.shape\n\tout = np.zeros((H, W, channel), dtype=np.float32)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# idft\n\tfor c in range(channel):\n\t\tfor l in range(H):\n\t\t\tfor k in range(W):\n\t\t\t\tout[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(2j * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)\n\n\t# clipping\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# DFT\nG = dft(img)\n\n# write poser spectal to image\nps = (np.abs(G) / np.abs(G).max() * 255).astype(np.uint8)\ncv2.imwrite(""out_ps.jpg"", ps)\n\n# IDFT\nout = idft(G)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n\n\n\n""""""\nfimg = np.fft.fft2(gray)\n    \n# \xe7\xac\xac1\xe8\xb1\xa1\xe9\x99\x90\xe3\x81\xa8\xe7\xac\xac3\xe8\xb1\xa1\xe9\x99\x90, \xe7\xac\xac2\xe8\xb1\xa1\xe9\x99\x90\xe3\x81\xa8\xe7\xac\xac4\xe8\xb1\xa1\xe9\x99\x90\xe3\x82\x92\xe5\x85\xa5\xe3\x82\x8c\xe6\x9b\xbf\xe3\x81\x88\nfimg =  np.fft.fftshift(fimg)\nprint(fimg.shape)\n# \xe3\x83\x91\xe3\x83\xaf\xe3\x83\xbc\xe3\x82\xb9\xe3\x83\x9a\xe3\x82\xaf\xe3\x83\x88\xe3\x83\xab\xe3\x81\xae\xe8\xa8\x88\xe7\xae\x97\nmag = 20*np.log(np.abs(fimg))\n    \n# \xe5\x85\xa5\xe5\x8a\x9b\xe7\x94\xbb\xe5\x83\x8f\xe3\x81\xa8\xe3\x82\xb9\xe3\x83\x9a\xe3\x82\xaf\xe3\x83\x88\xe3\x83\xab\xe7\x94\xbb\xe5\x83\x8f\xe3\x82\x92\xe3\x82\xb0\xe3\x83\xa9\xe3\x83\x95\xe6\x8f\x8f\xe7\x94\xbb\nplt.subplot(121)\nplt.imshow(gray, cmap = \'gray\')\nplt.subplot(122)\nplt.imshow(mag, cmap = \'gray\')\nplt.show()\n""""""'"
Question_31_40/answers_py/answer_33.py,19,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# DFT hyper-parameters\nK, L = 128, 128\nchannel = 3\n\n# bgr -> gray\ndef bgr2gray(img):\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n\n# DFT\ndef dft(img):\n\t# Prepare DFT coefficient\n\tG = np.zeros((L, K, channel), dtype=np.complex)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# dft\n\tfor c in range(channel):\n\t\tfor l in range(L):\n\t\t\tfor k in range(K):\n\t\t\t\tG[l, k, c] = np.sum(img[..., c] * np.exp(-2j * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)\n\t\t\t\t#for n in range(N):\n\t\t\t\t#    for m in range(M):\n\t\t\t\t#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))\n\t\t\t\t#G[l, k] = v / np.sqrt(M * N)\n\n\treturn G\n\n# IDFT\ndef idft(G):\n\t# prepare out image\n\tH, W, _ = G.shape\n\tout = np.zeros((H, W, channel), dtype=np.float32)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# idft\n\tfor c in range(channel):\n\t\tfor l in range(H):\n\t\t\tfor k in range(W):\n\t\t\t\tout[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(2j * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)\n\n\t# clipping\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# LPF\ndef lpf(G, ratio=0.5):\n\tH, W, _ = G.shape\t\n\n\t# transfer positions\n\t_G = np.zeros_like(G)\n\t_G[:H//2, :W//2] = G[H//2:, W//2:]\n\t_G[:H//2, W//2:] = G[H//2:, :W//2]\n\t_G[H//2:, :W//2] = G[:H//2, W//2:]\n\t_G[H//2:, W//2:] = G[:H//2, :W//2]\n\n\t# get distance from center (H / 2, W / 2)\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# make filter\n\t_x = x - W // 2\n\t_y = y - H // 2\n\tr = np.sqrt(_x ** 2 + _y ** 2)\n\tmask = np.ones((H, W), dtype=np.float32)\n\tmask[r > (W // 2 * ratio)] = 0\n\n\tmask = np.repeat(mask, channel).reshape(H, W, channel)\n\n\t# filtering\n\t_G *= mask\n\n\t# reverse original positions\n\tG[:H//2, :W//2] = _G[H//2:, W//2:]\n\tG[:H//2, W//2:] = _G[H//2:, :W//2]\n\tG[H//2:, :W//2] = _G[:H//2, W//2:]\n\tG[H//2:, W//2:] = _G[:H//2, :W//2]\n\n\treturn G\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# Gray scale\ngray = bgr2gray(img)\n\n# DFT\nG = dft(img)\n\n# LPF\nG = lpf(G)\n\n# IDFT\nout = idft(G)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_34.py,19,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# DFT hyper-parameters\nK, L = 128, 128\nchannel = 3\n\n# bgr -> gray\ndef bgr2gray(img):\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n\n# DFT\ndef dft(img):\n\t# Prepare DFT coefficient\n\tG = np.zeros((L, K, channel), dtype=np.complex)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# dft\n\tfor c in range(channel):\n\t\tfor l in range(L):\n\t\t\tfor k in range(K):\n\t\t\t\tG[l, k, c] = np.sum(img[..., c] * np.exp(-2j * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)\n\t\t\t\t#for n in range(N):\n\t\t\t\t#    for m in range(M):\n\t\t\t\t#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))\n\t\t\t\t#G[l, k] = v / np.sqrt(M * N)\n\n\treturn G\n\n# IDFT\ndef idft(G):\n\t# prepare out image\n\tH, W, _ = G.shape\n\tout = np.zeros((H, W, channel), dtype=np.float32)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# idft\n\tfor c in range(channel):\n\t\tfor l in range(H):\n\t\t\tfor k in range(W):\n\t\t\t\tout[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(2j * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)\n\n\t# clipping\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# HPF\ndef hpf(G, ratio=0.1):\n\tH, W, _ = G.shape\t\n\n\t# transfer positions\n\t_G = np.zeros_like(G)\n\t_G[:H//2, :W//2] = G[H//2:, W//2:]\n\t_G[:H//2, W//2:] = G[H//2:, :W//2]\n\t_G[H//2:, :W//2] = G[:H//2, W//2:]\n\t_G[H//2:, W//2:] = G[:H//2, :W//2]\n\n\t# get distance from center (H / 2, W / 2)\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# make filter\n\t_x = x - W // 2\n\t_y = y - H // 2\n\tr = np.sqrt(_x ** 2 + _y ** 2)\n\tmask = np.ones((H, W), dtype=np.float32)\n\tmask[r < (W // 2 * ratio)] = 0\n\n\tmask = np.repeat(mask, channel).reshape(H, W, channel)\n\n\t# filtering\n\t_G *= mask\n\n\t# reverse original positions\n\tG[:H//2, :W//2] = _G[H//2:, W//2:]\n\tG[:H//2, W//2:] = _G[H//2:, :W//2]\n\tG[H//2:, :W//2] = _G[:H//2, W//2:]\n\tG[H//2:, W//2:] = _G[:H//2, :W//2]\n\n\treturn G\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# Gray scale\ngray = bgr2gray(img)\n\n# DFT\nG = dft(img)\n\n# HPF\nG = hpf(G)\n\n# IDFT\nout = idft(G)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_35.py,19,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# DFT hyper-parameters\nK, L = 128, 128\nchannel = 3\n\n# bgr -> gray\ndef bgr2gray(img):\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n\n# DFT\ndef dft(img):\n\t# Prepare DFT coefficient\n\tG = np.zeros((L, K, channel), dtype=np.complex)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# dft\n\tfor c in range(channel):\n\t\tfor l in range(L):\n\t\t\tfor k in range(K):\n\t\t\t\tG[l, k, c] = np.sum(img[..., c] * np.exp(-2j * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)\n\t\t\t\t#for n in range(N):\n\t\t\t\t#    for m in range(M):\n\t\t\t\t#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))\n\t\t\t\t#G[l, k] = v / np.sqrt(M * N)\n\n\treturn G\n\n# IDFT\ndef idft(G):\n\t# prepare out image\n\tH, W, _ = G.shape\n\tout = np.zeros((H, W, channel), dtype=np.float32)\n\n\t# prepare processed index corresponding to original image positions\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# idft\n\tfor c in range(channel):\n\t\tfor l in range(H):\n\t\t\tfor k in range(W):\n\t\t\t\tout[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(2j * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)\n\n\t# clipping\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# BPF\ndef bpf(G, ratio1=0.1, ratio2=0.5):\n\tH, W, _ = G.shape\t\n\n\t# transfer positions\n\t_G = np.zeros_like(G)\n\t_G[:H//2, :W//2] = G[H//2:, W//2:]\n\t_G[:H//2, W//2:] = G[H//2:, :W//2]\n\t_G[H//2:, :W//2] = G[:H//2, W//2:]\n\t_G[H//2:, W//2:] = G[:H//2, :W//2]\n\n\t# get distance from center (H / 2, W / 2)\n\tx = np.tile(np.arange(W), (H, 1))\n\ty = np.arange(H).repeat(W).reshape(H, -1)\n\n\t# make filter\n\t_x = x - W // 2\n\t_y = y - H // 2\n\tr = np.sqrt(_x ** 2 + _y ** 2)\n\tmask = np.ones((H, W), dtype=np.float32)\n\tmask[(r < (W // 2 * ratio1)) | (r > (W // 2 * ratio2))] = 0\n\n\tmask = np.repeat(mask, channel).reshape(H, W, channel)\n\n\t# filtering\n\t_G *= mask\n\n\t# reverse original positions\n\tG[:H//2, :W//2] = _G[H//2:, W//2:]\n\tG[:H//2, W//2:] = _G[H//2:, :W//2]\n\tG[H//2:, :W//2] = _G[:H//2, W//2:]\n\tG[H//2:, W//2:] = _G[:H//2, :W//2]\n\n\treturn G\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\nH, W, C = img.shape\n\n# Gray scale\ngray = bgr2gray(img)\n\n# DFT\nG = dft(img)\n\n# BPF\nG = bpf(G, ratio1=0.1, ratio2=0.5)\n\n# IDFT\nout = idft(G)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_36.py,9,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# DCT hyoer-parameter\nT = 8\nK = 8\nchannel = 3\n\n# DCT weight\ndef w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n\n# DCT\ndef dct(img):\n    H, W, _ = img.shape\n\n    F = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for v in range(T):\n                    for u in range(T):\n                        for y in range(T):\n                            for x in range(T):\n                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * w(x,y,u,v)\n\n    return F\n\n\n# IDCT\ndef idct(F):\n    H, W, _ = F.shape\n\n    out = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for y in range(T):\n                    for x in range(T):\n                        for v in range(K):\n                            for u in range(K):\n                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * w(x,y,u,v)\n\n    out = np.clip(out, 0, 255)\n    out = np.round(out).astype(np.uint8)\n\n    return out\n\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# DCT\nF = dct(img)\n\n# IDCT\nout = idct(F)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_37.py,11,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# DCT hyoer-parameter\nT = 8\nK = 4\nchannel = 3\n\n# DCT weight\ndef w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n\n# DCT\ndef dct(img):\n    H, W, _ = img.shape\n\n    F = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for v in range(T):\n                    for u in range(T):\n                        for y in range(T):\n                            for x in range(T):\n                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * w(x,y,u,v)\n\n    return F\n\n\n# IDCT\ndef idct(F):\n    H, W, _ = F.shape\n\n    out = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for y in range(T):\n                    for x in range(T):\n                        for v in range(K):\n                            for u in range(K):\n                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * w(x,y,u,v)\n\n    out = np.clip(out, 0, 255)\n    out = np.round(out).astype(np.uint8)\n\n    return out\n\n\n# MSE\ndef MSE(img1, img2):\n    H, W, _ = img1.shape\n    mse = np.sum((img1 - img2) ** 2) / (H * W * channel)\n    return mse\n\n# PSNR\ndef PSNR(mse, vmax=255):\n    return 10 * np.log10(vmax * vmax / mse)\n\n# bitrate\ndef BITRATE():\n    return 1. * T * K * K / T / T\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# DCT\nF = dct(img)\n\n# IDCT\nout = idct(F)\n\n# MSE\nmse = MSE(img, out)\n\n# PSNR\npsnr = PSNR(mse)\n\n# bitrate\nbitrate = BITRATE()\n\nprint(""MSE:"", mse)\nprint(""PSNR:"", psnr)\nprint(""bitrate:"", bitrate)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_38.py,14,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# DCT hyoer-parameter\nT = 8\nK = 4\nchannel = 3\n\n# DCT weight\ndef DCT_w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n\n# DCT\ndef dct(img):\n    H, W, _ = img.shape\n\n    F = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for v in range(T):\n                    for u in range(T):\n                        for y in range(T):\n                            for x in range(T):\n                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * DCT_w(x,y,u,v)\n\n    return F\n\n\n# IDCT\ndef idct(F):\n    H, W, _ = F.shape\n\n    out = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for y in range(T):\n                    for x in range(T):\n                        for v in range(K):\n                            for u in range(K):\n                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * DCT_w(x,y,u,v)\n\n    out = np.clip(out, 0, 255)\n    out = np.round(out).astype(np.uint8)\n\n    return out\n\n# Quantization\ndef quantization(F):\n    H, W, _ = F.shape\n\n    Q = np.array(((16, 11, 10, 16, 24, 40, 51, 61),\n                (12, 12, 14, 19, 26, 58, 60, 55),\n                (14, 13, 16, 24, 40, 57, 69, 56),\n                (14, 17, 22, 29, 51, 87, 80, 62),\n                (18, 22, 37, 56, 68, 109, 103, 77),\n                (24, 35, 55, 64, 81, 104, 113, 92),\n                (49, 64, 78, 87, 103, 121, 120, 101),\n                (72, 92, 95, 98, 112, 100, 103, 99)), dtype=np.float32)\n\n    for ys in range(0, H, T):\n        for xs in range(0, W, T):\n            for c in range(channel):\n                F[ys: ys + T, xs: xs + T, c] =  np.round(F[ys: ys + T, xs: xs + T, c] / Q) * Q\n\n    return F\n\n\n\n# MSE\ndef MSE(img1, img2):\n    H, W, _ = img1.shape\n    mse = np.sum((img1 - img2) ** 2) / (H * W * channel)\n    return mse\n\n# PSNR\ndef PSNR(mse, vmax=255):\n    return 10 * np.log10(vmax * vmax / mse)\n\n# bitrate\ndef BITRATE():\n    return 1. * T * K * K / T / T\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# DCT\nF = dct(img)\n\n# quantization\nF = quantization(F)\n\n# IDCT\nout = idct(F)\n\n# MSE\nmse = MSE(img, out)\n\n# PSNR\npsnr = PSNR(mse)\n\n# bitrate\nbitrate = BITRATE()\n\nprint(""MSE:"", mse)\nprint(""PSNR:"", psnr)\nprint(""bitrate:"", bitrate)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_39.py,5,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nchannel = 3\n\n# BGR -> Y Cb Cr\ndef BGR2YCbCr(img):\n  H, W, _ = img.shape\n\n  ycbcr = np.zeros([H, W, 3], dtype=np.float32)\n\n  ycbcr[..., 0] = 0.2990 * img[..., 2] + 0.5870 * img[..., 1] + 0.1140 * img[..., 0]\n  ycbcr[..., 1] = -0.1687 * img[..., 2] - 0.3313 * img[..., 1] + 0.5 * img[..., 0] + 128.\n  ycbcr[..., 2] = 0.5 * img[..., 2] - 0.4187 * img[..., 1] - 0.0813 * img[..., 0] + 128.\n\n  return ycbcr\n\n# Y Cb Cr -> BGR\ndef YCbCr2BGR(ycbcr):\n  H, W, _ = ycbcr.shape\n\n  out = np.zeros([H, W, channel], dtype=np.float32)\n  out[..., 2] = ycbcr[..., 0] + (ycbcr[..., 2] - 128.) * 1.4020\n  out[..., 1] = ycbcr[..., 0] - (ycbcr[..., 1] - 128.) * 0.3441 - (ycbcr[..., 2] - 128.) * 0.7139\n  out[..., 0] = ycbcr[..., 0] + (ycbcr[..., 1] - 128.) * 1.7718\n\n  out = np.clip(out, 0, 255)\n  out = out.astype(np.uint8)\n\n  return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# bgr -> Y Cb Cr\nycbcr = BGR2YCbCr(img)\n\n# process\nycbcr[..., 0] *= 0.7\n\n# YCbCr > RGB\nout = YCbCr2BGR(ycbcr)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_31_40/answers_py/answer_40.py,18,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# DCT hyoer-parameter\nT = 8\nK = 8\nchannel = 3\n\n\n# BGR -> Y Cb Cr\ndef BGR2YCbCr(img):\n  H, W, _ = img.shape\n\n  ycbcr = np.zeros([H, W, 3], dtype=np.float32)\n\n  ycbcr[..., 0] = 0.2990 * img[..., 2] + 0.5870 * img[..., 1] + 0.1140 * img[..., 0]\n  ycbcr[..., 1] = -0.1687 * img[..., 2] - 0.3313 * img[..., 1] + 0.5 * img[..., 0] + 128.\n  ycbcr[..., 2] = 0.5 * img[..., 2] - 0.4187 * img[..., 1] - 0.0813 * img[..., 0] + 128.\n\n  return ycbcr\n\n# Y Cb Cr -> BGR\ndef YCbCr2BGR(ycbcr):\n  H, W, _ = ycbcr.shape\n\n  out = np.zeros([H, W, channel], dtype=np.float32)\n  out[..., 2] = ycbcr[..., 0] + (ycbcr[..., 2] - 128.) * 1.4020\n  out[..., 1] = ycbcr[..., 0] - (ycbcr[..., 1] - 128.) * 0.3441 - (ycbcr[..., 2] - 128.) * 0.7139\n  out[..., 0] = ycbcr[..., 0] + (ycbcr[..., 1] - 128.) * 1.7718\n\n  out = np.clip(out, 0, 255)\n  out = out.astype(np.uint8)\n\n  return out\n\n\n# DCT weight\ndef DCT_w(x, y, u, v):\n    cu = 1.\n    cv = 1.\n    if u == 0:\n        cu /= np.sqrt(2)\n    if v == 0:\n        cv /= np.sqrt(2)\n    theta = np.pi / (2 * T)\n    return (( 2 * cu * cv / T) * np.cos((2*x+1)*u*theta) * np.cos((2*y+1)*v*theta))\n\n# DCT\ndef dct(img):\n    H, W, _ = img.shape\n\n    F = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for v in range(T):\n                    for u in range(T):\n                        for y in range(T):\n                            for x in range(T):\n                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * DCT_w(x,y,u,v)\n\n    return F\n\n\n# IDCT\ndef idct(F):\n    H, W, _ = F.shape\n\n    out = np.zeros((H, W, channel), dtype=np.float32)\n\n    for c in range(channel):\n        for yi in range(0, H, T):\n            for xi in range(0, W, T):\n                for y in range(T):\n                    for x in range(T):\n                        for v in range(K):\n                            for u in range(K):\n                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * DCT_w(x,y,u,v)\n\n    out = np.clip(out, 0, 255)\n    out = np.round(out).astype(np.uint8)\n\n    return out\n\n# Quantization\ndef quantization(F):\n    H, W, _ = F.shape\n\n    Q = np.array(((16, 11, 10, 16, 24, 40, 51, 61),\n                (12, 12, 14, 19, 26, 58, 60, 55),\n                (14, 13, 16, 24, 40, 57, 69, 56),\n                (14, 17, 22, 29, 51, 87, 80, 62),\n                (18, 22, 37, 56, 68, 109, 103, 77),\n                (24, 35, 55, 64, 81, 104, 113, 92),\n                (49, 64, 78, 87, 103, 121, 120, 101),\n                (72, 92, 95, 98, 112, 100, 103, 99)), dtype=np.float32)\n\n    for ys in range(0, H, T):\n        for xs in range(0, W, T):\n            for c in range(channel):\n                F[ys: ys + T, xs: xs + T, c] =  np.round(F[ys: ys + T, xs: xs + T, c] / Q) * Q\n\n    return F\n\n\n# JPEG without Hufman coding\ndef JPEG(img):\n    # BGR -> Y Cb Cr\n    ycbcr = BGR2YCbCr(img)\n\n    # DCT\n    F = dct(ycbcr)\n\n    # quantization\n    F = quantization(F)\n\n    # IDCT\n    ycbcr = idct(F)\n\n    # Y Cb Cr -> BGR\n    out = YCbCr2BGR(ycbcr)\n\n    return out\n\n\n# MSE\ndef MSE(img1, img2):\n    H, W, _ = img1.shape\n    mse = np.sum((img1 - img2) ** 2) / (H * W * channel)\n    return mse\n\n# PSNR\ndef PSNR(mse, vmax=255):\n    return 10 * np.log10(vmax * vmax / mse)\n\n# bitrate\ndef BITRATE():\n    return 1. * T * K * K / T / T\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# JPEG\nout = JPEG(img)\n\n# MSE\nmse = MSE(img, out)\n\n# PSNR\npsnr = PSNR(mse)\n\n# bitrate\nbitrate = BITRATE()\n\nprint(""MSE:"", mse)\nprint(""PSNR:"", psnr)\nprint(""bitrate:"", bitrate)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_41_50/answers_py/answer_41.py,31,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny_step1(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * (sigma ** 2)))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c]) \n\t\t\t\t\t\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\t#out = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\t#img = np.expand_dims(img, axis=-1)\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W].astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W].astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx, 2) + np.power(fy, 2))\n\t\tfx = np.maximum(fx, 1e-5)\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\treturn edge, angle\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Canny (step1)\nedge, angle = Canny_step1(img)\n\nedge = edge.astype(np.uint8)\nangle = angle.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", edge)\ncv2.imshow(""result"", edge)\ncv2.imwrite(""out2.jpg"", angle)\ncv2.imshow(""result2"", angle)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_42.py,33,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny_step2(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * (sigma ** 2)))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)\n\t\tout_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-5)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\treturn edge, angle\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Canny (step2)\nedge, angle = Canny_step2(img)\n\nedge = edge.astype(np.uint8)\nangle = angle.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", edge)\ncv2.imshow(""result"", edge)\ncv2.imwrite(""out2.jpg"", angle)\ncv2.imshow(""result2"", angle)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_43.py,35,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * sigma * sigma))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W]\n\t\tout_v = out_v.astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W]\n\t\tout_h = out_h.astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-10)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\t\t\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\tdef hysterisis(edge, HT=100, LT=30):\n\t\tH, W = edge.shape\n\n\t\t# Histeresis threshold\n\t\tedge[edge >= HT] = 255\n\t\tedge[edge <= LT] = 0\n\n\t\t_edge = np.zeros((H + 2, W + 2), dtype=np.float32)\n\t\t_edge[1 : H + 1, 1 : W + 1] = edge\n\n\t\t## 8 - Nearest neighbor\n\t\tnn = np.array(((1., 1., 1.), (1., 0., 1.), (1., 1., 1.)), dtype=np.float32)\n\n\t\tfor y in range(1, H+2):\n\t\t\t\tfor x in range(1, W+2):\n\t\t\t\t\t\tif _edge[y, x] < LT or _edge[y, x] > HT:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif np.max(_edge[y-1:y+2, x-1:x+2] * nn) >= HT:\n\t\t\t\t\t\t\t\t_edge[y, x] = 255\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\tedge = _edge[1:H+1, 1:W+1]\n\t\t\t\t\t\t\t\t\n\t\treturn edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\t# hysterisis threshold\n\tout = hysterisis(edge, 50, 20)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Canny\nedge = Canny(img)\n\nout = edge.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_44.py,41,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * sigma * sigma))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W]\n\t\tout_v = out_v.astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W]\n\t\tout_h = out_h.astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-10)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\t\t\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\tdef hysterisis(edge, HT=100, LT=30):\n\t\tH, W = edge.shape\n\n\t\t# Histeresis threshold\n\t\tedge[edge >= HT] = 255\n\t\tedge[edge <= LT] = 0\n\n\t\t_edge = np.zeros((H + 2, W + 2), dtype=np.float32)\n\t\t_edge[1 : H + 1, 1 : W + 1] = edge\n\n\t\t## 8 - Nearest neighbor\n\t\tnn = np.array(((1., 1., 1.), (1., 0., 1.), (1., 1., 1.)), dtype=np.float32)\n\n\t\tfor y in range(1, H+2):\n\t\t\t\tfor x in range(1, W+2):\n\t\t\t\t\t\tif _edge[y, x] < LT or _edge[y, x] > HT:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif np.max(_edge[y-1:y+2, x-1:x+2] * nn) >= HT:\n\t\t\t\t\t\t\t\t_edge[y, x] = 255\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\tedge = _edge[1:H+1, 1:W+1]\n\t\t\t\t\t\t\t\t\n\t\treturn edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\t# hysterisis threshold\n\tout = hysterisis(edge, 100, 30)\n\n\treturn out\n\n\ndef Hough_Line_step1(edge):\n\t## Voting\n\tdef voting(edge):\n\t\tH, W = edge.shape\n\t\tdrho = 1\n\t\tdtheta = 1\n\n\t\t# get rho max length\n\t\trho_max = np.ceil(np.sqrt(H ** 2 + W ** 2)).astype(np.int)\n\n\t\t# hough table\n\t\though = np.zeros((rho_max * 2, 180), dtype=np.int)\n\n\t\t# get index of edge\n\t\tind = np.where(edge == 255)\n\n\t\t## hough transformation\n\t\tfor y, x in zip(ind[0], ind[1]):\n\t\t\t\tfor theta in range(0, 180, dtheta):\n\t\t\t\t\t\t# get polar coordinat4s\n\t\t\t\t\t\tt = np.pi / 180 * theta\n\t\t\t\t\t\trho = int(x * np.cos(t) + y * np.sin(t))\n\n\t\t\t\t\t\t# vote\n\t\t\t\t\t\though[rho + rho_max, theta] += 1\n\t\t\t\t\t\t\t\n\t\tout = hough.astype(np.uint8)\n\n\t\treturn out\n\n\t# voting\n\tout = voting(edge)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Canny\nedge = Canny(img)\n\n# Hough\nout = Hough_Line_step1(edge)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_45.py,44,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * sigma * sigma))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W]\n\t\tout_v = out_v.astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W]\n\t\tout_h = out_h.astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-10)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\t\t\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\tdef hysterisis(edge, HT=100, LT=30):\n\t\tH, W = edge.shape\n\n\t\t# Histeresis threshold\n\t\tedge[edge >= HT] = 255\n\t\tedge[edge <= LT] = 0\n\n\t\t_edge = np.zeros((H + 2, W + 2), dtype=np.float32)\n\t\t_edge[1 : H + 1, 1 : W + 1] = edge\n\n\t\t## 8 - Nearest neighbor\n\t\tnn = np.array(((1., 1., 1.), (1., 0., 1.), (1., 1., 1.)), dtype=np.float32)\n\n\t\tfor y in range(1, H+2):\n\t\t\t\tfor x in range(1, W+2):\n\t\t\t\t\t\tif _edge[y, x] < LT or _edge[y, x] > HT:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif np.max(_edge[y-1:y+2, x-1:x+2] * nn) >= HT:\n\t\t\t\t\t\t\t\t_edge[y, x] = 255\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\tedge = _edge[1:H+1, 1:W+1]\n\t\t\t\t\t\t\t\t\n\t\treturn edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\t# hysterisis threshold\n\tout = hysterisis(edge, 100, 30)\n\n\treturn out\n\n\ndef Hough_Line_step2(edge):\n\t## Voting\n\tdef voting(edge):\n\t\tH, W = edge.shape\n\t\t\n\t\tdrho = 1\n\t\tdtheta = 1\n\n\t\t# get rho max length\n\t\trho_max = np.ceil(np.sqrt(H ** 2 + W ** 2)).astype(np.int)\n\n\t\t# hough table\n\t\though = np.zeros((rho_max * 2, 180), dtype=np.int)\n\n\t\t# get index of edge\n\t\tind = np.where(edge == 255)\n\n\t\t## hough transformation\n\t\tfor y, x in zip(ind[0], ind[1]):\n\t\t\t\tfor theta in range(0, 180, dtheta):\n\t\t\t\t\t\t# get polar coordinat4s\n\t\t\t\t\t\tt = np.pi / 180 * theta\n\t\t\t\t\t\trho = int(x * np.cos(t) + y * np.sin(t))\n\n\t\t\t\t\t\t# vote\n\t\t\t\t\t\though[rho + rho_max, theta] += 1\n\t\t\t\t\t\t\t\n\t\tout = hough.astype(np.uint8)\n\n\t\treturn out\n\n\t# non maximum suppression\n\tdef non_maximum_suppression(hough):\n\t\trho_max, _ = hough.shape\n\n\t\t## non maximum suppression\n\t\tfor y in range(rho_max):\n\t\t\tfor x in range(180):\n\t\t\t\t# get 8 nearest neighbor\n\t\t\t\tx1 = max(x-1, 0)\n\t\t\t\tx2 = min(x+2, 180)\n\t\t\t\ty1 = max(y-1, 0)\n\t\t\t\ty2 = min(y+2, rho_max-1)\n\t\t\t\tif np.max(hough[y1:y2, x1:x2]) == hough[y,x] and hough[y, x] != 0:\n\t\t\t\t\tpass\n\t\t\t\t\t#hough[y,x] = 255\n\t\t\t\telse:\n\t\t\t\t\though[y,x] = 0\n\n\t\t# for hough visualization\n\t\t# get top-10 x index of hough table\n\t\tind_x = np.argsort(hough.ravel())[::-1][:20]\n\t\t# get y index\n\t\tind_y = ind_x.copy()\n\t\tthetas = ind_x % 180\n\t\trhos = ind_y // 180\n\t\t_hough = np.zeros_like(hough, dtype=np.int)\n\t\t_hough[rhos, thetas] = 255\n\n\t\treturn _hough\n\n\t# voting\n\though = voting(edge)\n\n\t# non maximum suppression\n\tout = non_maximum_suppression(hough)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Canny\nedge = Canny(img)\n\n# Hough\nout = Hough_Line_step2(edge)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_46.py,49,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef Canny(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * sigma * sigma))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W]\n\t\tout_v = out_v.astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W]\n\t\tout_h = out_h.astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-10)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\t\t\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\tdef hysterisis(edge, HT=100, LT=30):\n\t\tH, W = edge.shape\n\n\t\t# Histeresis threshold\n\t\tedge[edge >= HT] = 255\n\t\tedge[edge <= LT] = 0\n\n\t\t_edge = np.zeros((H + 2, W + 2), dtype=np.float32)\n\t\t_edge[1 : H + 1, 1 : W + 1] = edge\n\n\t\t## 8 - Nearest neighbor\n\t\tnn = np.array(((1., 1., 1.), (1., 0., 1.), (1., 1., 1.)), dtype=np.float32)\n\n\t\tfor y in range(1, H+2):\n\t\t\t\tfor x in range(1, W+2):\n\t\t\t\t\t\tif _edge[y, x] < LT or _edge[y, x] > HT:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif np.max(_edge[y-1:y+2, x-1:x+2] * nn) >= HT:\n\t\t\t\t\t\t\t\t_edge[y, x] = 255\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\tedge = _edge[1:H+1, 1:W+1]\n\t\t\t\t\t\t\t\t\n\t\treturn edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\t# hysterisis threshold\n\tout = hysterisis(edge, 100, 30)\n\n\treturn out\n\n\ndef Hough_Line(edge, img):\n\t## Voting\n\tdef voting(edge):\n\t\tH, W = edge.shape\n\t\t\n\t\tdrho = 1\n\t\tdtheta = 1\n\n\t\t# get rho max length\n\t\trho_max = np.ceil(np.sqrt(H ** 2 + W ** 2)).astype(np.int)\n\n\t\t# hough table\n\t\though = np.zeros((rho_max * 2, 180), dtype=np.int)\n\n\t\t# get index of edge\n\t\tind = np.where(edge == 255)\n\n\t\t## hough transformation\n\t\tfor y, x in zip(ind[0], ind[1]):\n\t\t\t\tfor theta in range(0, 180, dtheta):\n\t\t\t\t\t\t# get polar coordinat4s\n\t\t\t\t\t\tt = np.pi / 180 * theta\n\t\t\t\t\t\trho = int(x * np.cos(t) + y * np.sin(t))\n\n\t\t\t\t\t\t# vote\n\t\t\t\t\t\though[rho + rho_max, theta] += 1\n\t\t\t\t\t\t\t\n\t\tout = hough.astype(np.uint8)\n\n\t\treturn out\n\n\t# non maximum suppression\n\tdef non_maximum_suppression(hough):\n\t\trho_max, _ = hough.shape\n\n\t\t## non maximum suppression\n\t\tfor y in range(rho_max):\n\t\t\tfor x in range(180):\n\t\t\t\t# get 8 nearest neighbor\n\t\t\t\tx1 = max(x-1, 0)\n\t\t\t\tx2 = min(x+2, 180)\n\t\t\t\ty1 = max(y-1, 0)\n\t\t\t\ty2 = min(y+2, rho_max-1)\n\t\t\t\tif np.max(hough[y1:y2, x1:x2]) == hough[y,x] and hough[y, x] != 0:\n\t\t\t\t\tpass\n\t\t\t\t\t#hough[y,x] = 255\n\t\t\t\telse:\n\t\t\t\t\though[y,x] = 0\n\n\t\treturn hough\n\n\tdef inverse_hough(hough, img):\n\t\tH, W, _ = img.shape\n\t\trho_max, _ = hough.shape\n\n\t\tout = img.copy()\n\n\t\t# get x, y index of hough table\n\t\tind_x = np.argsort(hough.ravel())[::-1][:20]\n\t\tind_y = ind_x.copy()\n\t\tthetas = ind_x % 180\n\t\trhos = ind_y // 180 - rho_max / 2\n\n\t\t# each theta and rho\n\t\tfor theta, rho in zip(thetas, rhos):\n\t\t\t# theta[radian] -> angle[degree]\n\t\t\tt = np.pi / 180. * theta\n\n\t\t\t# hough -> (x,y)\n\t\t\tfor x in range(W):\n\t\t\t\tif np.sin(t) != 0:\n\t\t\t\t\ty = - (np.cos(t) / np.sin(t)) * x + (rho) / np.sin(t)\n\t\t\t\t\ty = int(y)\n\t\t\t\t\tif y >= H or y < 0:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tout[y, x] = [0, 0, 255]\n\t\t\tfor y in range(H):\n\t\t\t\tif np.cos(t) != 0:\n\t\t\t\t\tx = - (np.sin(t) / np.cos(t)) * y + (rho) / np.cos(t)\n\t\t\t\t\tx = int(x)\n\t\t\t\t\tif x >= W or x < 0:\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tout[y, x] = [0, 0, 255]\n\t\t\t\t\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# voting\n\though = voting(edge)\n\n\t# non maximum suppression\n\though = non_maximum_suppression(hough)\n\n\t# inverse hough\n\tout = inverse_hough(hough, img)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Canny\nedge = Canny(img)\n\n# Hough\nout = Hough_Line(edge, img)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_47.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Morphology Erode\ndef Morphology_Erode(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Morphology - dilate\nout = Morphology_Erode(otsu, Dil_time=2)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_48.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Morphology Dilate\ndef Morphology_Dilate(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Morphology - dilate\nout = Morphology_Dilate(otsu, Erode_time=2)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_49.py,14,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Morphology Erode\ndef Morphology_Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Morphology Dilate\ndef Morphology_Dilate(img, Dilate_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dilate_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n\n# Opening morphology\ndef Morphology_Opening(img, time=1):\n\tout = Morphology_Erode(img, Erode_time=time)\n\tout = Morphology_Dilate(out, Dilate_time=time)\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Morphology - opening\nout = Morphology_Opening(otsu, time=1)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_41_50/answers_py/answer_50.py,42,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Canny\ndef Canny(img):\n\n\t# Gray scale\n\tdef BGR2GRAY(img):\n\t\tb = img[:, :, 0].copy()\n\t\tg = img[:, :, 1].copy()\n\t\tr = img[:, :, 2].copy()\n\n\t\t# Gray scale\n\t\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\n\t# Gaussian filter for grayscale\n\tdef gaussian_filter(img, K_size=3, sigma=1.3):\n\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\t\tgray = False\n\t\telse:\n\t\t\timg = np.expand_dims(img, axis=-1)\n\t\t\tH, W, C = img.shape\n\t\t\tgray = True\n\n\t\t## Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros([H + pad * 2, W + pad * 2, C], dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\n\t\t## prepare Kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(-pad, -pad + K_size):\n\t\t\tfor y in range(-pad, -pad + K_size):\n\t\t\t\tK[y + pad, x + pad] = np.exp( - (x ** 2 + y ** 2) / (2 * sigma * sigma))\n\t\t#K /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= (2 * np.pi * sigma * sigma)\n\t\tK /= K.sum()\n\n\t\ttmp = out.copy()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tfor c in range(C):\n\t\t\t\t\tout[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])\n\n\t\tout = np.clip(out, 0, 255)\n\t\tout = out[pad : pad + H, pad : pad + W]\n\t\tout = out.astype(np.uint8)\n\n\t\tif gray:\n\t\t\tout = out[..., 0]\n\n\t\treturn out\n\n\n\t# sobel filter\n\tdef sobel_filter(img, K_size=3):\n\t\tif len(img.shape) == 3:\n\t\t\tH, W, C = img.shape\n\t\telse:\n\t\t\tH, W = img.shape\n\n\t\t# Zero padding\n\t\tpad = K_size // 2\n\t\tout = np.zeros((H + pad * 2, W + pad * 2), dtype=np.float)\n\t\tout[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)\n\t\ttmp = out.copy()\n\n\t\tout_v = out.copy()\n\t\tout_h = out.copy()\n\n\t\t## Sobel vertical\n\t\tKv = [[1., 2., 1.],[0., 0., 0.], [-1., -2., -1.]]\n\t\t## Sobel horizontal\n\t\tKh = [[1., 0., -1.],[2., 0., -2.],[1., 0., -1.]]\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tout_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))\n\t\t\t\tout_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))\n\n\t\tout_v = np.clip(out_v, 0, 255)\n\t\tout_h = np.clip(out_h, 0, 255)\n\n\t\tout_v = out_v[pad : pad + H, pad : pad + W]\n\t\tout_v = out_v.astype(np.uint8)\n\t\tout_h = out_h[pad : pad + H, pad : pad + W]\n\t\tout_h = out_h.astype(np.uint8)\n\n\t\treturn out_v, out_h\n\n\n\tdef get_edge_angle(fx, fy):\n\t\t# get edge strength\n\t\tedge = np.sqrt(np.power(fx.astype(np.float32), 2) + np.power(fy.astype(np.float32), 2))\n\t\tedge = np.clip(edge, 0, 255)\n\n\t\tfx = np.maximum(fx, 1e-10)\n\t\t#fx[np.abs(fx) <= 1e-5] = 1e-5\n\n\t\t# get edge angle\n\t\tangle = np.arctan(fy / fx)\n\n\t\treturn edge, angle\n\n\n\tdef angle_quantization(angle):\n\t\tangle = angle / np.pi * 180\n\t\tangle[angle < -22.5] = 180 + angle[angle < -22.5]\n\t\t_angle = np.zeros_like(angle, dtype=np.uint8)\n\t\t_angle[np.where(angle <= 22.5)] = 0\n\t\t_angle[np.where((angle > 22.5) & (angle <= 67.5))] = 45\n\t\t_angle[np.where((angle > 67.5) & (angle <= 112.5))] = 90\n\t\t_angle[np.where((angle > 112.5) & (angle <= 157.5))] = 135\n\n\t\treturn _angle\n\n\n\tdef non_maximum_suppression(angle, edge):\n\t\tH, W = angle.shape\n\t\t_edge = edge.copy()\n\t\t\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\t\tif angle[y, x] == 0:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 0, 1, 0\n\t\t\t\t\telif angle[y, x] == 45:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, 1, 1, -1\n\t\t\t\t\telif angle[y, x] == 90:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = 0, -1, 0, 1\n\t\t\t\t\telif angle[y, x] == 135:\n\t\t\t\t\t\t\tdx1, dy1, dx2, dy2 = -1, -1, 1, 1\n\t\t\t\t\tif x == 0:\n\t\t\t\t\t\t\tdx1 = max(dx1, 0)\n\t\t\t\t\t\t\tdx2 = max(dx2, 0)\n\t\t\t\t\tif x == W-1:\n\t\t\t\t\t\t\tdx1 = min(dx1, 0)\n\t\t\t\t\t\t\tdx2 = min(dx2, 0)\n\t\t\t\t\tif y == 0:\n\t\t\t\t\t\t\tdy1 = max(dy1, 0)\n\t\t\t\t\t\t\tdy2 = max(dy2, 0)\n\t\t\t\t\tif y == H-1:\n\t\t\t\t\t\t\tdy1 = min(dy1, 0)\n\t\t\t\t\t\t\tdy2 = min(dy2, 0)\n\t\t\t\t\tif max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:\n\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\treturn _edge\n\n\tdef hysterisis(edge, HT=100, LT=30):\n\t\tH, W = edge.shape\n\n\t\t# Histeresis threshold\n\t\tedge[edge >= HT] = 255\n\t\tedge[edge <= LT] = 0\n\n\t\t_edge = np.zeros((H + 2, W + 2), dtype=np.float32)\n\t\t_edge[1 : H + 1, 1 : W + 1] = edge\n\n\t\t## 8 - Nearest neighbor\n\t\tnn = np.array(((1., 1., 1.), (1., 0., 1.), (1., 1., 1.)), dtype=np.float32)\n\n\t\tfor y in range(1, H+2):\n\t\t\t\tfor x in range(1, W+2):\n\t\t\t\t\t\tif _edge[y, x] < LT or _edge[y, x] > HT:\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tif np.max(_edge[y-1:y+2, x-1:x+2] * nn) >= HT:\n\t\t\t\t\t\t\t\t_edge[y, x] = 255\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\t\t_edge[y, x] = 0\n\n\t\tedge = _edge[1:H+1, 1:W+1]\n\t\t\t\t\t\t\t\t\n\t\treturn edge\n\n\t# grayscale\n\tgray = BGR2GRAY(img)\n\n\t# gaussian filtering\n\tgaussian = gaussian_filter(gray, K_size=5, sigma=1.4)\n\n\t# sobel filtering\n\tfy, fx = sobel_filter(gaussian, K_size=3)\n\n\t# get edge strength, angle\n\tedge, angle = get_edge_angle(fx, fy)\n\n\t# angle quantization\n\tangle = angle_quantization(angle)\n\n\t# non maximum suppression\n\tedge = non_maximum_suppression(angle, edge)\n\n\t# hysterisis threshold\n\tout = hysterisis(edge, 50, 20)\n\n\treturn out\n\n\n# Morphology Erode\ndef Morphology_Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Morphology Dilate\ndef Morphology_Dilate(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n# Morphology Closing\ndef Morphology_Closing(img, time=1):\n\tout = Morphology_Dilate(img, Dil_time=time)\n\t#ut = Morphology_Erode(out, Erode_time=time)\n\t\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Canny\ncanny = Canny(img)\n\n# Morphology - opening\nout = Morphology_Closing(canny, time=1)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_51.py,15,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Erosion\ndef Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Dilation\ndef Dilate(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Erode image\neroded = Erode(otsu)\n\n# Delate image\ndilated = Dilate(otsu)\n\n# Morphology\nout = np.abs(eroded - dilated) * 255\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_52.py,15,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Erosion\ndef Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Dilation\ndef Dilate(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n# Opening morphology\ndef Morphology_Opening(img, time=1):\n    dil = Dilate(img, Dil_time=time)\n    erode = Erode(dil, Erode_time=time)\n    return erode\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Opening process\nopened = Morphology_Opening(otsu, time=3)\n\n# Tophat\nout = np.abs(otsu - opened) * 255\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_53.py,15,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Gray scale\ndef BGR2GRAY(img):\n\tb = img[:, :, 0].copy()\n\tg = img[:, :, 1].copy()\n\tr = img[:, :, 2].copy()\n\n\t# Gray scale\n\tout = 0.2126 * r + 0.7152 * g + 0.0722 * b\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# Otsu Binalization\ndef otsu_binarization(img, th=128):\n\tH, W = img.shape\n\tout = img.copy()\n\n\tmax_sigma = 0\n\tmax_t = 0\n\n\t# determine threshold\n\tfor _t in range(1, 255):\n\t\tv0 = out[np.where(out < _t)]\n\t\tm0 = np.mean(v0) if len(v0) > 0 else 0.\n\t\tw0 = len(v0) / (H * W)\n\t\tv1 = out[np.where(out >= _t)]\n\t\tm1 = np.mean(v1) if len(v1) > 0 else 0.\n\t\tw1 = len(v1) / (H * W)\n\t\tsigma = w0 * w1 * ((m0 - m1) ** 2)\n\t\tif sigma > max_sigma:\n\t\t\tmax_sigma = sigma\n\t\t\tmax_t = _t\n\n\t# Binarization\n\tprint(""threshold >>"", max_t)\n\tth = max_t\n\tout[out < th] = 0\n\tout[out >= th] = 255\n\n\treturn out\n\n\n# Erosion\ndef Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) < 255*4:\n\t\t\t\t\tout[y-1, x-1] = 0\n\n\treturn out\n\n\n# Dilation\ndef Dilate(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H+1):\n\t\t\tfor x in range(1, W+1):\n\t\t\t\tif np.sum(MF * tmp[y-1:y+2, x-1:x+2]) >= 255:\n\t\t\t\t\tout[y-1, x-1] = 255\n\n\treturn out\n\n# Closing morphology\ndef Morphology_Closing(img, time=1):\n    erode = Erode(img, Erode_time=time)\n    dil = Dilate(erode, Dil_time=time)\n    return erode\n\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Grayscale\ngray = BGR2GRAY(img)\n\n# Otsu\'s binarization\notsu = otsu_binarization(gray)\n\n# Opening process\nopened = Morphology_Closing(otsu, time=3)\n\n# Tophat\nout = np.abs(opened - otsu) * 255\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_54.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# template matching\ndef Template_matching(img, template):\n    # get original image shape\n    H, W, C = img.shape\n\n    # get template image shape\n    Ht, Wt, Ct = template.shape\n\n    # Templete matching\n    # prepare x, y index\n    i, j = -1, -1\n    # prepare evaluate value\n    v = 255 * H * W * C\n\n    for y in range(H - Ht):\n        for x in range(W - Wt):\n            # get SSD value\n            _v = np.sum((img[y : y + Ht, x : x + Wt] - template) ** 2)\n\n            # if SSD is min\n            if _v < v:\n                v = _v\n                i, j = x, y\n\n    out = img.copy()\n    # draw rectangle\n    cv2.rectangle(out, pt1=(i, j), pt2=(i+Wt, j+Ht), color=(0,0,255), thickness=1)\n    out = out.astype(np.uint8)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Read templete image\ntemplate = cv2.imread(""imori_part.jpg"").astype(np.float32)\n\n# Template matching\nout = Template_matching(img, template)\n\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_55.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# template matching\ndef Template_matching(img, template):\n    # get original image shape\n    H, W, C = img.shape\n\n    # get template image shape\n    Ht, Wt, Ct = template.shape\n\n    # Templete matching\n    # prepare x, y index\n    i, j = -1, -1\n    # prepare evaluate value\n    v = 255 * H * W * C\n\n    for y in range(H - Ht):\n        for x in range(W - Wt):\n            # get SAD value\n            _v = np.sum(np.abs(img[y : y + Ht, x : x + Wt] - template))\n\n            # if SAD is min\n            if _v < v:\n                v = _v\n                i, j = x, y\n\n    out = img.copy()\n    # draw rectangle\n    cv2.rectangle(out, pt1=(i, j), pt2=(i+Wt, j+Ht), color=(0,0,255), thickness=1)\n    out = out.astype(np.uint8)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Read templete image\ntemplate = cv2.imread(""imori_part.jpg"").astype(np.float32)\n\n# Template matching\nout = Template_matching(img, template)\n\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_56.py,5,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# template matching\ndef Template_matching(img, template):\n    # get original image shape\n    H, W, C = img.shape\n\n    # get template image shape\n    Ht, Wt, Ct = template.shape\n\n    # Templete matching\n    # prepare x, y index\n    i, j = -1, -1\n    # prepare evaluate value\n    v = -1\n\n    for y in range(H - Ht):\n        for x in range(W - Wt):\n            # get NCC value\n            # get numerator of NCC\n            _v = np.sum(img[y : y + Ht, x : x + Wt] * template)\n            # devided numerator\n            _v /= (np.sqrt(np.sum(img[y : y + Ht, x : x + Wt] ** 2)) * np.sqrt(np.sum(template ** 2)))\n\n            # if NCC is max\n            if _v > v:\n                v = _v\n                i, j = x, y\n\n    out = img.copy()\n    # draw rectangle\n    cv2.rectangle(out, pt1=(i, j), pt2=(i+Wt, j+Ht), color=(0,0,255), thickness=1)\n    out = out.astype(np.uint8)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Read templete image\ntemplate = cv2.imread(""imori_part.jpg"").astype(np.float32)\n\n# Template matching\nout = Template_matching(img, template)\n                \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_57.py,7,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# template matching\ndef Template_matching(img, template):\n    # get original image shape\n    H, W, C = img.shape\n\n    # subtract mean BGR\n    _img = img - np.mean(img, axis=(0, 1))\n\n    # get template image shape\n    Ht, Wt, Ct = template.shape\n\n    # subtract mean BGR\n    _template = template - np.mean(img, axis=(0, 1))\n\n    # Templete matching\n    # prepare x, y index\n    i, j = -1, -1\n    # prepare evaluate value\n    v = -1\n\n    for y in range(H - Ht):\n        for x in range(W - Wt):\n            # get ZNCC value\n            # get numerator of ZNCC\n            _v = np.sum(_img[y : y + Ht, x : x + Wt] * _template)\n            # devided numerator\n            _v /= (np.sqrt(np.sum(_img[y : y + Ht, x : x + Wt] ** 2)) * np.sqrt(np.sum(template ** 2)))\n\n            # if ZNCC is max\n            if _v > v:\n                v = _v\n                i, j = x, y\n\n    out = img.copy()\n    # draw rectangle\n    cv2.rectangle(out, pt1=(i, j), pt2=(i+Wt, j+Ht), color=(0,0,255), thickness=1)\n    out = out.astype(np.uint8)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Read templete image\ntemplate = cv2.imread(""imori_part.jpg"").astype(np.float32)\n\n# Template matching\nout = Template_matching(img, template)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_58.py,3,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# labeling 4 nearest neighbor\ndef labeling_4nn(img):\n    # get image shape\n    H, W, C = img.shape\n\n    # prepare label tempolary image\n    label = np.zeros((H, W), dtype=np.int)\n    label[img[..., 0]>0] = 1\n\n    # look up table\n    LUT = [0 for _ in range(H*W)]\n\n    n = 1\n\n    for y in range(H):\n        for x in range(W):\n            # skip black pixel\n            if label[y, x] == 0:\n                continue\n            \n            # get above pixel\n            c3 = label[max(y-1,0), x]\n\n            # get left pixel\n            c5 = label[y, max(x-1,0)]\n\n            # if not labeled\n            if c3 < 2 and c5 < 2:\n                # labeling\n                n += 1\n                label[y, x] = n\n            else:\n                # replace min label index\n                _vs = [c3, c5]\n                vs = [a for a in _vs if a > 1]\n                v = min(vs)\n                label[y, x] = v\n                \n                minv = v\n                for _v in vs:\n                    if LUT[_v] != 0:\n                        minv = min(minv, LUT[_v])\n                for _v in vs:\n                    LUT[_v] = minv\n                    \n    count = 1\n\n    # integrate index of look up table\n    for l in range(2, n+1):\n        flag = True\n        for i in range(n+1):\n            if LUT[i] == l:\n                if flag:\n                    count += 1\n                    flag = False\n                LUT[i] = count\n\n    # draw color\n    COLORS = [[0, 0, 255], [0, 255, 0], [255, 0, 0], [255, 255, 0]]\n    out = np.zeros((H, W, C), dtype=np.uint8)\n\n    for i, lut in enumerate(LUT[2:]):\n        out[label == (i+2)] = COLORS[lut-2]\n\n    return out\n    \n\n# Read image\nimg = cv2.imread(""seg.png"").astype(np.float32)\n\n# labeling 4 nearest neighbor\nout = labeling_4nn(img)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_59.py,3,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# labeling 8 nearest neighbor\ndef labeling_8nn(img):\n    # get image shape\n    H, W, C = img.shape\n\n    # prepare labeling image\n    label = np.zeros((H, W), dtype=np.int)\n    label[img[..., 0]>0] = 1\n\n    # look up table\n    LUT = [0 for _ in range(H*W)]\n\n    n = 1\n\n    for y in range(H):\n        for x in range(W):\n            if label[y, x] == 0:\n                continue\n            # get right top pixel\n            c2 = label[max(y-1,0), min(x+1, W-1)]\n            # get top pixel\n            c3 = label[max(y-1,0), x]\n            # get left top pixel\n            c4 = label[max(y-1,0), max(x-1,0)]\n            # get left pixel\n            c5 = label[y, max(x-1,0)]\n\n            # if all pixel is non labeled\n            if c3 < 2 and c5 < 2 and c2 < 2 and c4 < 2:\n                n += 1\n                label[y, x] = n\n            else:\n                # get labeled index\n                _vs = [c3, c5, c2, c4]\n                vs = [a for a in _vs if a > 1]\n                v = min(vs)\n                label[y, x] = v\n\n                minv = v\n                for _v in vs:\n                    if LUT[_v] != 0:\n                        minv = min(minv, LUT[_v])\n                for _v in vs:\n                    LUT[_v] = minv\n                    \n    count = 1\n\n    # integrate labeled index of look up table\n    for l in range(2, n+1):\n        flag = True\n        for i in range(n+1):\n            if LUT[i] == l:\n                if flag:\n                    count += 1\n                    flag = False\n                LUT[i] = count\n\n    # draw color\n    COLORS = [[0, 0, 255], [0, 255, 0], [255, 0, 0], [255, 255, 0]]\n    out = np.zeros((H, W, C), dtype=np.uint8)\n\n    for i, lut in enumerate(LUT[2:]):\n        out[label == (i+2)] = COLORS[lut-2]\n\n    return out\n    \n\n# Read image\nimg = cv2.imread(""seg.png"").astype(np.float32)\n\n# labeling 8 nearest neighbor\nout = labeling_8nn(img)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_51_60/answers/answer_60.py,3,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# alpha blend\ndef alpha_blend(img1, img2, alpha):\n\t# blend\n\tout = img * alpha + img2 * (1 - alpha)\n\tout = out.astype(np.uint8)\n\treturn out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# Read blend target image\nimg2 = cv2.imread(""thorino.jpg"").astype(np.float32)\n\nout = alpha_blend(img, img2, alpha=0.6)\n    \n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_61.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Connect 4\ndef connect_4(img):\n    # get shape\n    H, W, C = img.shape\n\n    # prepare temporary image\n    tmp = np.zeros((H, W), dtype=np.int)\n\n    # binarize\n    tmp[img[..., 0] > 0] = 1\n\n    # prepare out image\n    out = np.zeros((H, W, 3), dtype=np.uint8)\n\n    # each pixel\n    for y in range(H):\n        for x in range(W):\n            if tmp[y, x] < 1:\n                continue\n\n            S = 0\n            S += (tmp[y,min(x+1,W-1)] - tmp[y,min(x+1,W-1)] * tmp[max(y-1,0),min(x+1,W-1)] * tmp[max(y-1,0),x])\n            S += (tmp[max(y-1,0),x] - tmp[max(y-1,0),x] * tmp[max(y-1,0),max(x-1,0)] * tmp[y,max(x-1,0)])\n            S += (tmp[y,max(x-1,0)] - tmp[y,max(x-1,0)] * tmp[min(y+1,H-1),max(x-1,0)] * tmp[min(y+1,H-1),x])\n            S += (tmp[min(y+1,H-1),x] - tmp[min(y+1,H-1),x] * tmp[min(y+1,H-1),min(x+1,W-1)] * tmp[y,min(x+1,W-1)])\n            \n            if S == 0:\n                out[y,x] = [0, 0, 255]\n            elif S == 1:\n                out[y,x] = [0, 255, 0]\n            elif S == 2:\n                out[y,x] = [255, 0, 0]\n            elif S == 3:\n                out[y,x] = [255, 255, 0]\n            elif S == 4:\n                out[y,x] = [255, 0, 255]\n                    \n    out = out.astype(np.uint8)\n\n    return out\n\n\n\n# Read image\nimg = cv2.imread(""renketsu.png"").astype(np.float32)\n\n# connect 4\nout = connect_4(img)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_62.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# connect 8\ndef connect_8(img):\n    # get shape\n    H, W, C = img.shape\n\n    # prepare temporary\n    _tmp = np.zeros((H, W), dtype=np.int)\n\n    # get binarize\n    _tmp[img[..., 0] > 0] = 1\n\n    # inverse for connect 8\n    tmp = 1 - _tmp\n\n    # prepare image\n    out = np.zeros((H, W, 3), dtype=np.uint8)\n\n    # each pixel\n    for y in range(H):\n        for x in range(W):\n            if _tmp[y, x] < 1:\n                continue\n\n            S = 0\n            S += (tmp[y,min(x+1,W-1)] - tmp[y,min(x+1,W-1)] * tmp[max(y-1,0),min(x+1,W-1)] * tmp[max(y-1,0),x])\n            S += (tmp[max(y-1,0),x] - tmp[max(y-1,0),x] * tmp[max(y-1,0),max(x-1,0)] * tmp[y,max(x-1,0)])\n            S += (tmp[y,max(x-1,0)] - tmp[y,max(x-1,0)] * tmp[min(y+1,H-1),max(x-1,0)] * tmp[min(y+1,H-1),x])\n            S += (tmp[min(y+1,H-1),x] - tmp[min(y+1,H-1),x] * tmp[min(y+1,H-1),min(x+1,W-1)] * tmp[y,min(x+1,W-1)])\n            \n            if S == 0:\n                out[y,x] = [0, 0, 255]\n            elif S == 1:\n                out[y,x] = [0, 255, 0]\n            elif S == 2:\n                out[y,x] = [255, 0, 0]\n            elif S == 3:\n                out[y,x] = [255, 255, 0]\n            elif S == 4:\n                out[y,x] = [255, 0, 255]\n                    \n    out = out.astype(np.uint8)\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""renketsu.png"").astype(np.float32)\n\n# connect 8\nout = connect_8(img)\n\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_63.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# thining algorythm\ndef thining(img):\n    # get shape\n    H, W, C = img.shape\n\n    # prepare out image\n    out = np.zeros((H, W), dtype=np.int)\n    out[img[..., 0] > 0] = 1\n\n    count = 1\n    while count > 0:\n        count = 0\n        tmp = out.copy()\n        # each pixel ( rasta scan )\n        for y in range(H):\n            for x in range(W):\n                # skip black pixel\n                if out[y, x] < 1:\n                    continue\n                \n                # count satisfied conditions\n                judge = 0\n                \n                ## condition 1\n                if (tmp[y, min(x+1, W-1)] + tmp[max(y-1, 0), x] + tmp[y, max(x-1, 0)] + tmp[min(y+1, H-1), x]) < 4:\n                    judge += 1\n                    \n                ## condition 2\n                c = 0\n                c += (tmp[y,min(x+1, W-1)] - tmp[y, min(x+1, W-1)] * tmp[max(y-1, 0),min(x+1, W-1)] * tmp[max(y-1, 0), x])\n                c += (tmp[max(y-1,0), x] - tmp[max(y-1,0), x] * tmp[max(y-1, 0), max(x-1, 0)] * tmp[y, max(x-1, 0)])\n                c += (tmp[y, max(x-1, 0)] - tmp[y,max(x-1, 0)] * tmp[min(y+1, H-1), max(x-1, 0)] * tmp[min(y+1, H-1), x])\n                c += (tmp[min(y+1, H-1), x] - tmp[min(y+1, H-1), x] * tmp[min(y+1, H-1), min(x+1, W-1)] * tmp[y, min(x+1, W-1)])\n                if c == 1:\n                    judge += 1\n                    \n                ##x condition 3\n                if np.sum(tmp[max(y-1, 0) : min(y+2, H), max(x-1, 0) : min(x+2, W)]) >= 4:\n                    judge += 1\n                \n                # if all conditions are satisfied\n                if judge == 3:\n                    out[y, x] = 0\n                    count += 1\n\n    out = out.astype(np.uint8) * 255\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""gazo.png"").astype(np.float32)\n\n# thining\nout = thining(img)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_64.py,5,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# hilditch thining\ndef hilditch(img):\n    # get shape\n    H, W, C = img.shape\n\n    # prepare out image\n    out = np.zeros((H, W), dtype=np.int)\n    out[img[..., 0] > 0] = 1\n\n    # inverse pixel value\n    tmp = out.copy()\n    _tmp = 1 - tmp\n\n    count = 1\n    while count > 0:\n        count = 0\n        tmp = out.copy()\n        _tmp = 1 - tmp\n\n        tmp2 = out.copy()\n        _tmp2 = 1 - tmp2\n        \n        # each pixel\n        for y in range(H):\n            for x in range(W):\n                # skip black pixel\n                if out[y, x] < 1:\n                    continue\n                \n                judge = 0\n                \n                ## condition 1\n                if (tmp[y, min(x+1, W-1)] * tmp[max(y-1,0 ), x] * tmp[y, max(x-1, 0)] * tmp[min(y+1, H-1), x]) == 0:\n                    judge += 1\n                    \n                ## condition 2\n                c = 0\n                c += (_tmp[y, min(x+1, W-1)] - _tmp[y, min(x+1, W-1)] * _tmp[max(y-1, 0), min(x+1, W-1)] * _tmp[max(y-1, 0), x])\n                c += (_tmp[max(y-1, 0), x] - _tmp[max(y-1, 0), x] * _tmp[max(y-1, 0), max(x-1, 0)] * _tmp[y, max(x-1, 0)])\n                c += (_tmp[y, max(x-1, 0)] - _tmp[y, max(x-1, 0)] * _tmp[min(y+1, H-1), max(x-1, 0)] * _tmp[min(y+1, H-1), x])\n                c += (_tmp[min(y+1, H-1), x] - _tmp[min(y+1, H-1), x] * _tmp[min(y+1, H-1), min(x+1, W-1)] * _tmp[y, min(x+1, W-1)])\n                if c == 1:\n                    judge += 1\n                    \n                ## condition 3\n                if np.sum(tmp[max(y-1, 0) : min(y+2, H), max(x-1, 0) : min(x+2, W)]) >= 3:\n                    judge += 1\n\n                ## condition 4\n                if np.sum(out[max(y-1, 0) : min(y+2, H), max(x-1, 0) : min(x+2, W)]) >= 2:\n                    judge += 1\n\n                ## condition 5\n                _tmp2 = 1 - out\n\n                c = 0\n                c += (_tmp2[y, min(x+1, W-1)] - _tmp2[y, min(x+1, W-1)] * _tmp2[max(y-1, 0), min(x+1, W-1)] * _tmp2[max(y-1, 0), x])\n                c += (_tmp2[max(y-1, 0), x] - _tmp2[max(y-1, 0), x] * (1 - tmp[max(y-1, 0), max(x-1, 0)]) * _tmp2[y, max(x-1, 0)])\n                c += (_tmp2[y, max(x-1, 0)] - _tmp2[y, max(x-1, 0)] * _tmp2[min(y+1, H-1), max(x-1, 0)] * _tmp2[min(y+1, H-1), x])\n                c += (_tmp2[min(y+1, H-1), x] - _tmp2[min(y+1, H-1), x] * _tmp2[min(y+1, H-1), min(x+1, W-1)] * _tmp2[y, min(x+1, W-1)])\n                if c == 1 or (out[max(y-1, 0), max(x-1,0 )] != tmp[max(y-1, 0), max(x-1, 0)]):\n                    judge += 1\n\n                c = 0\n                c += (_tmp2[y, min(x+1, W-1)] - _tmp2[y, min(x+1, W-1)] * _tmp2[max(y-1, 0), min(x+1, W-1)] * (1 - tmp[max(y-1, 0), x]))\n                c += ((1-tmp[max(y-1, 0), x]) - (1 - tmp[max(y-1, 0), x]) * _tmp2[max(y-1, 0), max(x-1, 0)] * _tmp2[y, max(x-1, 0)])\n                c += (_tmp2[y, max(x-1,0 )] - _tmp2[y, max(x-1,0 )] * _tmp2[min(y+1, H-1), max(x-1, 0)] * _tmp2[min(y+1, H-1), x])\n                c += (_tmp2[min(y+1, H-1), x] - _tmp2[min(y+1, H-1), x] * _tmp2[min(y+1, H-1), min(x+1, W-1)] * _tmp2[y, min(x+1, W-1)])\n                if c == 1 or (out[max(y-1, 0), x] != tmp[max(y-1, 0), x]):\n                    judge += 1\n\n                c = 0\n                c += (_tmp2[y, min(x+1, W-1)] - _tmp2[y, min(x+1, W-1)] * (1 - tmp[max(y-1, 0), min(x+1, W-1)]) * _tmp2[max(y-1, 0), x])\n                c += (_tmp2[max(y-1, 0), x] - _tmp2[max(y-1, 0), x] * _tmp2[max(y-1, 0), max(x-1, 0)] * _tmp2[y, max(x-1, 0)])\n                c += (_tmp2[y, max(x-1, 0)] - _tmp2[y, max(x-1, 0)] * _tmp2[min(y+1, H-1), max(x-1, 0)] * _tmp2[min(y+1, H-1), x])\n                c += (_tmp2[min(y+1, H-1), x] - _tmp2[min(y+1, H-1), x] * _tmp2[min(y+1, H-1), min(x+1, W-1)] * _tmp2[y, min(x+1, W-1)])\n                if c == 1 or (out[max(y-1, 0), min(x+1, W-1)] != tmp[max(y-1, 0), min(x+1, W-1)]):\n                    judge += 1\n\n                c = 0\n                c += (_tmp2[y, min(x+1, W-1)] - _tmp2[y, min(x+1, W-1)] * _tmp2[max(y-1, 0), min(x+1, W-1)] * _tmp2[max(y-1, 0), x])\n                c += (_tmp2[max(y-1, 0), x] - _tmp2[max(y-1, 0), x] * _tmp2[max(y-1, 0), max(x-1, 0)] * (1 - tmp[y, max(x-1, 0)]))\n                c += ((1 - tmp[y, max(x-1, 0)]) - (1 - tmp[y, max(x-1, 0)]) * _tmp2[min(y+1, H-1), max(x-1, 0)] * _tmp2[min(y+1, H-1), x])\n                c += (_tmp2[min(y+1, H-1), x] - _tmp2[min(y+1, H-1), x] * _tmp2[min(y+1, H-1), min(x+1, W-1)] * _tmp2[y, min(x+1, W-1)])\n                if c == 1 or (out[y, max(x-1, 0)] != tmp[y, max(x-1, 0)]):\n                    judge += 1\n                \n                if judge >= 8:\n                    out[y, x] = 0\n                    count += 1\n                    \n    out = out.astype(np.uint8) * 255\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""gazo.png"").astype(np.float32)\n\n# hilditch thining\nout = hilditch(img)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_64_a.py,6,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Read image\nimg = cv2.imread(""gazo.png"").astype(np.float32)\nH, W, C = img.shape\n\nout = np.zeros((H, W), dtype=np.int)\nout[img[..., 0]>0] = 1\n\ncount = 1\nwhile count > 0:\n    count = 0\n    tmp = out.copy()\n    _tmp = 1 - tmp\n    \n    for y in range(H):\n        for x in range(W):\n            # condition 1\n            if out[y, x] < 1:\n                continue\n            \n            judge = 0\n\n            out_a = np.abs(out)\n            \n            ## condition 2\n            if 1 - out_a[y, min(x+1, W-1)] + 1 - out_a[max(y-1, 0), x] + 1 - out_a[y, max(x-1,0)] + 1 - out_a[min(y+1,H-1), x] >= 1:\n                judge += 1\n                \n            ## condition 3\n            n8 = out[max(y-1,0):min(y+2,H), max(x-1,0):min(x+2,W)]\n            if np.sum(np.abs(n8)) >= 3:\n                judge += 1\n\n            ## condition 4\n            if np.sum(n8[n8==1]) >= 2:\n                judge += 1\n\n            ## condition 5\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n                \n            ## condition 6\n            c = 0\n            c += (0 - 0 * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * 0)\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * 0 * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * 0)\n            c += (0 - 0 * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * 0 * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * 0)\n            c += (0 - 0 * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * 0 * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * 0)\n            c += (0 - 0 * out_a[min(y+1,H-1),min(x+1,W-1)] * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n\n            c = 0\n            c += (out_a[y,min(x+1,W-1)] - out_a[y,min(x+1,W-1)] * out_a[max(y-1,0),min(x+1,W-1)] * out_a[max(y-1,0),x])\n            c += (out_a[max(y-1,0),x] - out_a[max(y-1,0),x] * out_a[max(y-1,0),max(x-1,0)] * out_a[y,max(x-1,0)])\n            c += (out_a[y,max(x-1,0)] - out_a[y,max(x-1,0)] * out_a[min(y+1,H-1),max(x-1,0)] * out_a[min(y+1,H-1),x])\n            c += (out_a[min(y+1,H-1),x] - out_a[min(y+1,H-1),x] * 0 * out_a[y,min(x+1,W-1)])\n            if c == 1:\n                judge += 1\n                \n                \n            if judge >= 5:\n                out[y,x] = -1\n                count += 1\n\n    out[out == -1] = 0\n    \n                \nout = out.astype(np.uint8) * 255\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_65.py,5,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Zhang Suen thining algorythm\ndef Zhang_Suen_thining(img):\n    # get shape\n    H, W, C = img.shape\n\n    # prepare out image\n    out = np.zeros((H, W), dtype=np.int)\n    out[img[..., 0] > 0] = 1\n\n    # inverse\n    out = 1 - out\n\n    while True:\n        s1 = []\n        s2 = []\n\n        # step 1 ( rasta scan )\n        for y in range(1, H-1):\n            for x in range(1, W-1):\n                \n                # condition 1\n                if out[y, x] > 0:\n                    continue\n\n                # condition 2\n                f1 = 0\n                if (out[y-1, x+1] - out[y-1, x]) == 1:\n                    f1 += 1\n                if (out[y, x+1] - out[y-1, x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x+1] - out[y, x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x] - out[y+1,x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x-1] - out[y+1, x]) == 1:\n                    f1 += 1\n                if (out[y, x-1] - out[y+1, x-1]) == 1:\n                    f1 += 1\n                if (out[y-1, x-1] - out[y, x-1]) == 1:\n                    f1 += 1\n                if (out[y-1, x] - out[y-1, x-1]) == 1:\n                    f1 += 1\n\n                if f1 != 1:\n                    continue\n                    \n                # condition 3\n                f2 = np.sum(out[y-1:y+2, x-1:x+2])\n                if f2 < 2 or f2 > 6:\n                    continue\n                \n                # condition 4\n                if out[y-1, x] + out[y, x+1] + out[y+1, x] < 1:\n                    continue\n\n                # condition 5\n                if out[y, x+1] + out[y+1, x] + out[y, x-1] < 1:\n                    continue\n                    \n                s1.append([y, x])\n\n        for v in s1:\n            out[v[0], v[1]] = 1\n\n        # step 2 ( rasta scan )\n        for y in range(1, H-1):\n            for x in range(1, W-1):\n                \n                # condition 1\n                if out[y, x] > 0:\n                    continue\n\n                # condition 2\n                f1 = 0\n                if (out[y-1, x+1] - out[y-1, x]) == 1:\n                    f1 += 1\n                if (out[y, x+1] - out[y-1, x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x+1] - out[y, x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x] - out[y+1,x+1]) == 1:\n                    f1 += 1\n                if (out[y+1, x-1] - out[y+1, x]) == 1:\n                    f1 += 1\n                if (out[y, x-1] - out[y+1, x-1]) == 1:\n                    f1 += 1\n                if (out[y-1, x-1] - out[y, x-1]) == 1:\n                    f1 += 1\n                if (out[y-1, x] - out[y-1, x-1]) == 1:\n                    f1 += 1\n\n                if f1 != 1:\n                    continue\n                    \n                # condition 3\n                f2 = np.sum(out[y-1:y+2, x-1:x+2])\n                if f2 < 2 or f2 > 6:\n                    continue\n                \n                # condition 4\n                if out[y-1, x] + out[y, x+1] + out[y, x-1] < 1:\n                    continue\n\n                # condition 5\n                if out[y-1, x] + out[y+1, x] + out[y, x-1] < 1:\n                    continue\n                    \n                s2.append([y, x])\n\n        for v in s2:\n            out[v[0], v[1]] = 1\n\n        # if not any pixel is changed\n        if len(s1) < 1 and len(s2) < 1:\n            break\n\n    out = 1 - out\n    out = out.astype(np.uint8) * 255\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""gazo.png"").astype(np.float32)\n\n# Zhang Suen thining\nout = Zhang_Suen_thining(img)\n\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_66.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# get HOG step1\ndef HOG_step1(img):\n     # Grayscale\n     def BGR2GRAY(img):\n          gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n          return gray\n\n     # Magnitude and gradient\n     def get_gradXY(gray):\n          H, W = gray.shape\n\n          # padding before grad\n          gray = np.pad(gray, (1, 1), \'edge\')\n\n          # get grad x\n          gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n          # get grad y\n          gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n          # replace 0 with \n          gx[gx == 0] = 1e-6\n\n          return gx, gy\n\n     # get magnitude and gradient\n     def get_MagGrad(gx, gy):\n          # get gradient maginitude\n          magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n          # get gradient angle\n          gradient = np.arctan(gy / gx)\n\n          gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n          return magnitude, gradient\n\n     # Gradient histogram\n     def quantization(gradient):\n          # prepare quantization table\n          gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n          # quantization base\n          d = np.pi / 9\n\n          # quantization\n          for i in range(9):\n               gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n          return gradient_quantized\n\n     # 1. BGR -> Gray\n     gray = BGR2GRAY(img)\n\n     # 1. Gray -> Gradient x and y\n     gx, gy = get_gradXY(gray)\n\n     # 2. get gradient magnitude and angle\n     magnitude, gradient = get_MagGrad(gx, gy)\n\n     # 3. Quantization\n     gradient_quantized = quantization(gradient)\n\n     return magnitude, gradient_quantized\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# get HOG step1\nmagnitude, gradient_quantized = HOG_step1(img)\n\n# Write gradient magnitude to file\n_magnitude = (magnitude / magnitude.max() * 255).astype(np.uint8)\n\ncv2.imwrite(""out_mag.jpg"", _magnitude)\n\n# Write gradient angle to file\nH, W, C = img.shape\nout = np.zeros((H, W, 3), dtype=np.uint8)\n\n# define color\nC = [[255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255], [0, 255, 255],\n     [127, 127, 0], [127, 0, 127], [0, 127, 127]]\n\n# draw color\nfor i in range(9):\n     out[gradient_quantized == i] = C[i]\n\n\ncv2.imwrite(""out_gra.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_67.py,9,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# get HOG step2\ndef HOG_step2(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n        \n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n\n    return histogram\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# get HOG step2\nhistogram = HOG_step2(img)\n                \n# write histogram to file\nfor i in range(9):\n    plt.subplot(3,3,i+1)\n    plt.imshow(histogram[..., i])\n    plt.axis(\'off\')\n    plt.xticks(color=""None"")\n    plt.yticks(color=""None"")\nplt.savefig(""out.png"")\nplt.show()\n\n'"
Question_61_70/answers/answer_68.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# get HOG\ndef HOG(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n\n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n\t\t# histogram normalization\n    def normalization(histogram, C=3, epsilon=1):\n        cell_N_H, cell_N_W, _ = histogram.shape\n        ## each histogram\n        for y in range(cell_N_H):\n    \t    for x in range(cell_N_W):\n       \t    #for i in range(9):\n                histogram[y, x] /= np.sqrt(np.sum(histogram[max(y - 1, 0) : min(y + 2, cell_N_H),\n                                                            max(x - 1, 0) : min(x + 2, cell_N_W)] ** 2) + epsilon)\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n    \n    # 5. Histogram normalization\n    histogram = normalization(histogram)\n\n    return histogram\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# get HOG\nhistogram = HOG(img)\n                \n# Write result to file\nfor i in range(9):\n    plt.subplot(3,3,i+1)\n    plt.imshow(histogram[..., i])\n    plt.axis(\'off\')\n    plt.xticks(color=""None"")\n    plt.yticks(color=""None"")\nplt.savefig(""out.png"")\nplt.show()\n\n        \n\n'"
Question_61_70/answers/answer_69.py,18,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# get HOG\ndef HOG(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n\n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n\t\t# histogram normalization\n    def normalization(histogram, C=3, epsilon=1):\n        cell_N_H, cell_N_W, _ = histogram.shape\n        ## each histogram\n        for y in range(cell_N_H):\n    \t    for x in range(cell_N_W):\n       \t    #for i in range(9):\n                histogram[y, x] /= np.sqrt(np.sum(histogram[max(y - 1, 0) : min(y + 2, cell_N_H),\n                                                            max(x - 1, 0) : min(x + 2, cell_N_W)] ** 2) + epsilon)\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n    \n    # 5. Histogram normalization\n    histogram = normalization(histogram)\n\n    return histogram\n\n\n# draw HOG\ndef draw_HOG(img, histogram):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    def draw(gray, histogram, N=8):\n        # get shape\n        H, W = gray.shape\n        cell_N_H, cell_N_W, _ = histogram.shape\n        \n        ## Draw\n        out = gray[1 : H + 1, 1 : W + 1].copy().astype(np.uint8)\n\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                cx = x * N + N // 2\n                cy = y * N + N // 2\n                x1 = cx + N // 2 - 1\n                y1 = cy\n                x2 = cx - N // 2 + 1\n                y2 = cy\n                \n                h = histogram[y, x] / np.sum(histogram[y, x])\n                h /= h.max()\n        \n                for c in range(9):\n                    #angle = (20 * c + 10 - 90) / 180. * np.pi\n                    # get angle\n                    angle = (20 * c + 10) / 180. * np.pi\n                    rx = int(np.sin(angle) * (x1 - cx) + np.cos(angle) * (y1 - cy) + cx)\n                    ry = int(np.cos(angle) * (x1 - cx) - np.cos(angle) * (y1 - cy) + cy)\n                    lx = int(np.sin(angle) * (x2 - cx) + np.cos(angle) * (y2 - cy) + cx)\n                    ly = int(np.cos(angle) * (x2 - cx) - np.cos(angle) * (y2 - cy) + cy)\n\n                    # color is HOG value\n                    c = int(255. * h[c])\n\n                    # draw line\n                    cv2.line(out, (lx, ly), (rx, ry), (c, c, c), thickness=1)\n\n        return out\n    \n\n    # get gray\n    gray = BGR2GRAY(img)\n\n    # draw HOG\n    out = draw(gray, histogram)\n\n    return out\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# get HOG\nhistogram = HOG(img)\n\n# draw HOG\nout = draw_HOG(img, histogram)\n\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_61_70/answers/answer_70.py,13,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# BGR -> HSV\ndef BGR2HSV(_img):\n\timg = _img.copy() / 255.\n\n\thsv = np.zeros_like(img, dtype=np.float32)\n\n\t# get max and min\n\tmax_v = np.max(img, axis=2).copy()\n\tmin_v = np.min(img, axis=2).copy()\n\tmin_arg = np.argmin(img, axis=2)\n\n\t# H\n\thsv[..., 0][np.where(max_v == min_v)]= 0\n\t## if min == B\n\tind = np.where(min_arg == 0)\n\thsv[..., 0][ind] = 60 * (img[..., 1][ind] - img[..., 2][ind]) / (max_v[ind] - min_v[ind]) + 60\n\t## if min == R\n\tind = np.where(min_arg == 2)\n\thsv[..., 0][ind] = 60 * (img[..., 0][ind] - img[..., 1][ind]) / (max_v[ind] - min_v[ind]) + 180\n\t## if min == G\n\tind = np.where(min_arg == 1)\n\thsv[..., 0][ind] = 60 * (img[..., 2][ind] - img[..., 0][ind]) / (max_v[ind] - min_v[ind]) + 300\n\t\t\n\t# S\n\thsv[..., 1] = max_v.copy() - min_v.copy()\n\n\t# V\n\thsv[..., 2] = max_v.copy()\n\t\n\treturn hsv\n\n# make mask\ndef get_mask(hsv):\n\tmask = np.zeros_like(hsv[..., 0])\n\t#mask[np.where((hsv > 180) & (hsv[0] < 260))] = 255\n\tmask[np.logical_and((hsv[..., 0] > 180), (hsv[..., 0] < 260))] = 255\n\treturn mask\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# RGB > HSV\nhsv = BGR2HSV(img)\n\n\n# color tracking\nmask = get_mask(hsv)\n\nout = mask.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.png"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_71_80/answers/answer_71.py,14,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# BGR -> HSV\ndef BGR2HSV(_img):\n\timg = _img.copy() / 255.\n\n\thsv = np.zeros_like(img, dtype=np.float32)\n\n\t# get max and min\n\tmax_v = np.max(img, axis=2).copy()\n\tmin_v = np.min(img, axis=2).copy()\n\tmin_arg = np.argmin(img, axis=2)\n\n\t# H\n\thsv[..., 0][np.where(max_v == min_v)]= 0\n\t## if min == B\n\tind = np.where(min_arg == 0)\n\thsv[..., 0][ind] = 60 * (img[..., 1][ind] - img[..., 2][ind]) / (max_v[ind] - min_v[ind]) + 60\n\t## if min == R\n\tind = np.where(min_arg == 2)\n\thsv[..., 0][ind] = 60 * (img[..., 0][ind] - img[..., 1][ind]) / (max_v[ind] - min_v[ind]) + 180\n\t## if min == G\n\tind = np.where(min_arg == 1)\n\thsv[..., 0][ind] = 60 * (img[..., 2][ind] - img[..., 0][ind]) / (max_v[ind] - min_v[ind]) + 300\n\t\t\n\t# S\n\thsv[..., 1] = max_v.copy() - min_v.copy()\n\n\t# V\n\thsv[..., 2] = max_v.copy()\n\t\n\treturn hsv\n\n# make mask\ndef get_mask(hsv):\n\tmask = np.zeros_like(hsv[..., 0])\n\t#mask[np.where((hsv > 180) & (hsv[0] < 260))] = 255\n\tmask[np.logical_and((hsv[..., 0] > 180), (hsv[..., 0] < 260))] = 1\n\treturn mask\n\n# masking\ndef masking(img, mask):\n\tmask = 1 - mask\n\tout = img.copy()\n\t# mask [h, w] -> [h, w, channel]\n\tmask = np.tile(mask, [3, 1, 1]).transpose([1, 2, 0])\n\tout *= mask\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# RGB > HSV\nhsv = BGR2HSV(img / 255.)\n\n# color tracking\nmask = get_mask(hsv)\n\n# masking\nout = masking(img, mask)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_71_80/answers/answer_72.py,22,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# BGR -> HSV\ndef BGR2HSV(_img):\n\timg = _img.copy() / 255.\n\n\thsv = np.zeros_like(img, dtype=np.float32)\n\n\t# get max and min\n\tmax_v = np.max(img, axis=2).copy()\n\tmin_v = np.min(img, axis=2).copy()\n\tmin_arg = np.argmin(img, axis=2)\n\n\t# H\n\thsv[..., 0][np.where(max_v == min_v)]= 0\n\t## if min == B\n\tind = np.where(min_arg == 0)\n\thsv[..., 0][ind] = 60 * (img[..., 1][ind] - img[..., 2][ind]) / (max_v[ind] - min_v[ind]) + 60\n\t## if min == R\n\tind = np.where(min_arg == 2)\n\thsv[..., 0][ind] = 60 * (img[..., 0][ind] - img[..., 1][ind]) / (max_v[ind] - min_v[ind]) + 180\n\t## if min == G\n\tind = np.where(min_arg == 1)\n\thsv[..., 0][ind] = 60 * (img[..., 2][ind] - img[..., 0][ind]) / (max_v[ind] - min_v[ind]) + 300\n\t\t\n\t# S\n\thsv[..., 1] = max_v.copy() - min_v.copy()\n\n\t# V\n\thsv[..., 2] = max_v.copy()\n\t\n\treturn hsv\n\n# make mask\ndef get_mask(hsv):\n\tmask = np.zeros_like(hsv[..., 0])\n\t#mask[np.where((hsv > 180) & (hsv[0] < 260))] = 255\n\tmask[np.logical_and((hsv[..., 0] > 180), (hsv[..., 0] < 260))] = 1\n\treturn mask\n\n# masking\ndef masking(img, mask):\n\tmask = 1 - mask\n\tout = img.copy()\n\t# mask [h, w] -> [h, w, channel]\n\tmask = np.tile(mask, [3, 1, 1]).transpose([1, 2, 0])\n\tout *= mask\n\n\treturn out\n\n\n# Erosion\ndef Erode(img, Erode_time=1):\n\tH, W = img.shape\n\tout = img.copy()\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each erode\n\tfor i in range(Erode_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\t# erode\n\t\tfor y in range(1, H + 1):\n\t\t\tfor x in range(1, W + 1):\n\t\t\t\tif np.sum(MF * tmp[y - 1 : y + 2 , x - 1 : x + 2]) < 1 * 4:\n\t\t\t\t\tout[y - 1, x - 1] = 0\n\n\treturn out\n\n\n# Dilation\ndef Dilate(img, Dil_time=1):\n\tH, W = img.shape\n\n\t# kernel\n\tMF = np.array(((0, 1, 0),\n\t\t\t\t(1, 0, 1),\n\t\t\t\t(0, 1, 0)), dtype=np.int)\n\n\t# each dilate time\n\tout = img.copy()\n\tfor i in range(Dil_time):\n\t\ttmp = np.pad(out, (1, 1), \'edge\')\n\t\tfor y in range(1, H + 1):\n\t\t\tfor x in range(1, W + 1):\n\t\t\t\tif np.sum(MF * tmp[y - 1 : y + 2, x - 1 : x + 2]) >= 1:\n\t\t\t\t\tout[y - 1, x - 1] = 1\n\n\treturn out\n\n\n# Opening morphology\ndef Morphology_Opening(img, time=1):\n    out = Erode(img, Erode_time=time)\n    out = Dilate(out, Dil_time=time)\n    return out\n\n# Closing morphology\ndef Morphology_Closing(img, time=1):\n\tout = Dilate(img, Dil_time=time)\n\tout = Erode(out, Erode_time=time)\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# RGB > HSV\nhsv = BGR2HSV(img / 255.)\n\n# color tracking\nmask = get_mask(hsv)\n\n# closing\nmask = Morphology_Closing(mask, time=5)\n\n# opening\nmask = Morphology_Opening(mask, time=5)\n\n# masking\nout = masking(img, mask)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n'"
Question_71_80/answers/answer_73.py,13,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Bi-Linear interpolation\ndef bl_interpolate(img, ax=1., ay=1.):\n\tif len(img.shape) > 2:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\t\tC = 1\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get position of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aW, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\n\t# get position of original position\n\ty = (y / ay)\n\tx = (x / ax)\n\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-2)\n\tiy = np.minimum(iy, H-2)\n\n\t# get distance \n\tdx = x - ix\n\tdy = y - iy\n\n\tif C > 1:\n\t\tdx = np.repeat(np.expand_dims(dx, axis=-1), C, axis=-1)\n\t\tdy = np.repeat(np.expand_dims(dy, axis=-1), C, axis=-1)\n\n\t# interpolation\n\tout = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\ngray = BGR2GRAY(img)\n\n# Bilinear interpolation\nout = bl_interpolate(gray.astype(np.float32), ax=0.5, ay=0.5)\n\n# Bilinear interpolation\nout = bl_interpolate(out, ax=2., ay=2.)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_71_80/answers/answer_74.py,14,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Bi-Linear interpolation\ndef bl_interpolate(img, ax=1., ay=1.):\n\tif len(img.shape) > 2:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\t\tC = 1\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get position of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aW, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\n\t# get position of original position\n\ty = (y / ay)\n\tx = (x / ax)\n\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-2)\n\tiy = np.minimum(iy, H-2)\n\n\t# get distance \n\tdx = x - ix\n\tdy = y - iy\n\n\tif C > 1:\n\t\tdx = np.repeat(np.expand_dims(dx, axis=-1), C, axis=-1)\n\t\tdy = np.repeat(np.expand_dims(dy, axis=-1), C, axis=-1)\n\n\t# interpolation\n\tout = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\ngray = BGR2GRAY(img)\n\n# Bilinear interpolation\nout = bl_interpolate(gray.astype(np.float32), ax=0.5, ay=0.5)\n\n# Bilinear interpolation\nout = bl_interpolate(out, ax=2., ay=2.)\n\nout = np.abs(out - gray)\n\nout = out / out.max() * 255\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_71_80/answers/answer_75.py,12,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Bi-Linear interpolation\ndef bl_interpolate(img, ax=1., ay=1.):\n\tif len(img.shape) > 2:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\t\tC = 1\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get position of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aW, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\n\t# get position of original position\n\ty = (y / ay)\n\tx = (x / ax)\n\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-2)\n\tiy = np.minimum(iy, H-2)\n\n\t# get distance \n\tdx = x - ix\n\tdy = y - iy\n\n\tif C > 1:\n\t\tdx = np.repeat(np.expand_dims(dx, axis=-1), C, axis=-1)\n\t\tdy = np.repeat(np.expand_dims(dy, axis=-1), C, axis=-1)\n\n\t# interpolation\n\tout = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# make image pyramid\ndef make_pyramid(gray):\n\t# first element\n\tpyramid = [gray]\n\t# each scale\n\tfor i in range(1, 6):\n\t\t# define scale\n\t\ta = 2. ** i\n\n\t\t# down scale\n\t\tp = bl_interpolate(gray, ax=1./a, ay=1. / a)\n\n\t\t# add pyramid list\n\t\tpyramid.append(p)\n\t\t\n\treturn pyramid\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\ngray = BGR2GRAY(img)\n\n# pyramid\npyramid = make_pyramid(gray)\n\nfor i in range(6):\n    cv2.imwrite(""out_{}.jpg"".format(2**i), pyramid[i].astype(np.uint8))\n    plt.subplot(1, 6, i+1)\n    plt.imshow(pyramid[i], cmap=\'gray\')\n    plt.axis(\'off\')\n    plt.xticks(color=""None"")\n    plt.yticks(color=""None"")\n\nplt.show()\n    \n\n'"
Question_71_80/answers/answer_76.py,20,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Bi-Linear interpolation\ndef bl_interpolate(img, ax=1., ay=1.):\n\tif len(img.shape) > 2:\n\t\tH, W, C = img.shape\n\telse:\n\t\tH, W = img.shape\n\t\tC = 1\n\n\taH = int(ay * H)\n\taW = int(ax * W)\n\n\t# get position of resized image\n\ty = np.arange(aH).repeat(aW).reshape(aW, -1)\n\tx = np.tile(np.arange(aW), (aH, 1))\n\n\t# get position of original position\n\ty = (y / ay)\n\tx = (x / ax)\n\n\tix = np.floor(x).astype(np.int)\n\tiy = np.floor(y).astype(np.int)\n\n\tix = np.minimum(ix, W-2)\n\tiy = np.minimum(iy, H-2)\n\n\t# get distance \n\tdx = x - ix\n\tdy = y - iy\n\n\tif C > 1:\n\t\tdx = np.repeat(np.expand_dims(dx, axis=-1), C, axis=-1)\n\t\tdy = np.repeat(np.expand_dims(dy, axis=-1), C, axis=-1)\n\n\t# interpolation\n\tout = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n\n\tout = np.clip(out, 0, 255)\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n# make image pyramid\ndef make_pyramid(gray):\n\t# first element\n\tpyramid = [gray]\n\t# each scale\n\tfor i in range(1, 6):\n\t\t# define scale\n\t\ta = 2. ** i\n\n\t\t# down scale\n\t\tp = bl_interpolate(gray, ax=1./a, ay=1. / a)\n\n\t\t# up scale\n\t\tp = bl_interpolate(p, ax=a, ay=a)\n\n\t\t# add pyramid list\n\t\tpyramid.append(p.astype(np.float32))\n\n\treturn pyramid\n\n# make saliency map\ndef saliency_map(pyramid):\n\t# get shape\n\tH, W = pyramid[0].shape\n\n\t# prepare out image\n\tout = np.zeros((H, W), dtype=np.float32)\n\n\t# add each difference\n\tout += np.abs(pyramid[0] - pyramid[1])\n\tout += np.abs(pyramid[0] - pyramid[3])\n\tout += np.abs(pyramid[0] - pyramid[5])\n\tout += np.abs(pyramid[1] - pyramid[4])\n\tout += np.abs(pyramid[2] - pyramid[3])\n\tout += np.abs(pyramid[3] - pyramid[5])\n\n\t# normalization\n\tout = out / out.max() * 255\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float)\n\n# grayscale\ngray = BGR2GRAY(img)\n\n# pyramid\npyramid = make_pyramid(gray)\n    \n# pyramid -> saliency\nout = saliency_map(pyramid)\n\nout = out.astype(np.uint8)\n\n# Save result\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\ncv2.imwrite(""out.jpg"", out)\n'"
Question_71_80/answers/answer_77.py,9,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gabor\ndef Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n\t# get half size\n\td = K_size // 2\n\n\t# prepare kernel\n\tgabor = np.zeros((K_size, K_size), dtype=np.float32)\n\n\t# each value\n\tfor y in range(K_size):\n\t\tfor x in range(K_size):\n\t\t\t# distance from center\n\t\t\tpx = x - d\n\t\t\tpy = y - d\n\n\t\t\t# degree -> radian\n\t\t\ttheta = angle / 180. * np.pi\n\n\t\t\t# get kernel x\n\t\t\t_x = np.cos(theta) * px + np.sin(theta) * py\n\n\t\t\t# get kernel y\n\t\t\t_y = -np.sin(theta) * px + np.cos(theta) * py\n\n\t\t\t# fill kernel\n\t\t\tgabor[y, x] = np.exp(-(_x**2 + Gamma**2 * _y**2) / (2 * Sigma**2)) * np.cos(2*np.pi*_x/Lambda + Psi)\n\n\t# kernel normalization\n\tgabor /= np.sum(np.abs(gabor))\n\n\treturn gabor\n\n\n# get gabor kernel\ngabor = Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0)\n\n# Visualize\n# normalize to [0, 255]\nout = gabor - np.min(gabor)\nout /= np.max(out)\nout *= 255\n\nout = out.astype(np.uint8)\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_71_80/answers/answer_78.py,9,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Gabor\ndef Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n\t# get half size\n\td = K_size // 2\n\n\t# prepare kernel\n\tgabor = np.zeros((K_size, K_size), dtype=np.float32)\n\n\t# each value\n\tfor y in range(K_size):\n\t\tfor x in range(K_size):\n\t\t\t# distance from center\n\t\t\tpx = x - d\n\t\t\tpy = y - d\n\n\t\t\t# degree -> radian\n\t\t\ttheta = angle / 180. * np.pi\n\n\t\t\t# get kernel x\n\t\t\t_x = np.cos(theta) * px + np.sin(theta) * py\n\n\t\t\t# get kernel y\n\t\t\t_y = -np.sin(theta) * px + np.cos(theta) * py\n\n\t\t\t# fill kernel\n\t\t\tgabor[y, x] = np.exp(-(_x**2 + Gamma**2 * _y**2) / (2 * Sigma**2)) * np.cos(2*np.pi*_x/Lambda + Psi)\n\n\t# kernel normalization\n\tgabor /= np.sum(np.abs(gabor))\n\n\treturn gabor\n\n\n# define each angle\nAs = [0, 45, 90, 135]\n\n# prepare pyplot\nplt.subplots_adjust(left=0, right=1, top=1, bottom=0, hspace=0, wspace=0.2)\n\n# each angle\nfor i, A in enumerate(As):\n    # get gabor kernel\n    gabor = Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=A)\n\n    # normalize to [0, 255]\n    out = gabor - np.min(gabor)\n    out /= np.max(out)\n    out *= 255\n    \n    out = out.astype(np.uint8)\n    plt.subplot(1, 4, i+1)\n    plt.imshow(out, cmap=\'gray\')\n    plt.axis(\'off\')\n    plt.title(""Angle ""+str(A))\n\nplt.savefig(""out.png"")\nplt.show()\n'"
Question_71_80/answers/answer_79.py,13,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Gabor\ndef Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n\t# get half size\n\td = K_size // 2\n\n\t# prepare kernel\n\tgabor = np.zeros((K_size, K_size), dtype=np.float32)\n\n\t# each value\n\tfor y in range(K_size):\n\t\tfor x in range(K_size):\n\t\t\t# distance from center\n\t\t\tpx = x - d\n\t\t\tpy = y - d\n\n\t\t\t# degree -> radian\n\t\t\ttheta = angle / 180. * np.pi\n\n\t\t\t# get kernel x\n\t\t\t_x = np.cos(theta) * px + np.sin(theta) * py\n\n\t\t\t# get kernel y\n\t\t\t_y = -np.sin(theta) * px + np.cos(theta) * py\n\n\t\t\t# fill kernel\n\t\t\tgabor[y, x] = np.exp(-(_x**2 + Gamma**2 * _y**2) / (2 * Sigma**2)) * np.cos(2*np.pi*_x/Lambda + Psi)\n\n\t# kernel normalization\n\tgabor /= np.sum(np.abs(gabor))\n\n\treturn gabor\n\n\ndef Gabor_filtering(gray, K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n    # get shape\n    H, W = gray.shape\n\n    # padding\n    gray = np.pad(gray, (K_size//2, K_size//2), \'edge\')\n\n    # prepare out image\n    out = np.zeros((H, W), dtype=np.float32)\n\n    # get gabor filter\n    gabor = Gabor_filter(K_size=K_size, Sigma=Sigma, Gamma=Gamma, Lambda=Lambda, Psi=0, angle=angle)\n        \n    # filtering\n    for y in range(H):\n        for x in range(W):\n            out[y, x] = np.sum(gray[y : y + K_size, x : x + K_size] * gabor)\n\n    out = np.clip(out, 0, 255)\n    out = out.astype(np.uint8)\n\n    return out\n\n\ndef Gabor_process(img):\n    # gray scale\n    gray = BGR2GRAY(img).astype(np.float32)\n\n    # define angle\n    As = [0, 45, 90, 135]\n\n    # prepare pyplot\n    plt.subplots_adjust(left=0, right=1, top=1, bottom=0, hspace=0, wspace=0.2)\n\n    # each angle\n    for i, A in enumerate(As):\n        # gabor filtering\n        out = Gabor_filtering(gray, K_size=11, Sigma=1.5, Gamma=1.2, Lambda=3, angle=A)\n\n        plt.subplot(1, 4, i+1)\n        plt.imshow(out, cmap=\'gray\')\n        plt.axis(\'off\')\n        plt.title(""Angle ""+str(A))\n\n    plt.savefig(""out.png"")\n    plt.show()\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# gabor process\nGabor_process(img)\n\n\n'"
Question_71_80/answers/answer_80.py,15,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Grayscale\ndef BGR2GRAY(img):\n\t# Grayscale\n\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\treturn gray\n\n# Gabor\ndef Gabor_filter(K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n\t# get half size\n\td = K_size // 2\n\n\t# prepare kernel\n\tgabor = np.zeros((K_size, K_size), dtype=np.float32)\n\n\t# each value\n\tfor y in range(K_size):\n\t\tfor x in range(K_size):\n\t\t\t# distance from center\n\t\t\tpx = x - d\n\t\t\tpy = y - d\n\n\t\t\t# degree -> radian\n\t\t\ttheta = angle / 180. * np.pi\n\n\t\t\t# get kernel x\n\t\t\t_x = np.cos(theta) * px + np.sin(theta) * py\n\n\t\t\t# get kernel y\n\t\t\t_y = -np.sin(theta) * px + np.cos(theta) * py\n\n\t\t\t# fill kernel\n\t\t\tgabor[y, x] = np.exp(-(_x**2 + Gamma**2 * _y**2) / (2 * Sigma**2)) * np.cos(2*np.pi*_x/Lambda + Psi)\n\n\t# kernel normalization\n\tgabor /= np.sum(np.abs(gabor))\n\n\treturn gabor\n\n\ndef Gabor_filtering(gray, K_size=111, Sigma=10, Gamma=1.2, Lambda=10, Psi=0, angle=0):\n    # get shape\n    H, W = gray.shape\n\n    # padding\n    gray = np.pad(gray, (K_size//2, K_size//2), \'edge\')\n\n    # prepare out image\n    out = np.zeros((H, W), dtype=np.float32)\n\n    # get gabor filter\n    gabor = Gabor_filter(K_size=K_size, Sigma=Sigma, Gamma=Gamma, Lambda=Lambda, Psi=0, angle=angle)\n        \n    # filtering\n    for y in range(H):\n        for x in range(W):\n            out[y, x] = np.sum(gray[y : y + K_size, x : x + K_size] * gabor)\n\n    out = np.clip(out, 0, 255)\n    out = out.astype(np.uint8)\n\n    return out\n\n\ndef Gabor_process(img):\n    # get shape\n    H, W, _ = img.shape\n\n    # gray scale\n    gray = BGR2GRAY(img).astype(np.float32)\n\n    # define angle\n    As = [0, 45, 90, 135]\n\n    # prepare pyplot\n    plt.subplots_adjust(left=0, right=1, top=1, bottom=0, hspace=0, wspace=0.2)\n\n    out = np.zeros([H, W], dtype=np.float32)\n\n    # each angle\n    for i, A in enumerate(As):\n        # gabor filtering\n        _out = Gabor_filtering(gray, K_size=11, Sigma=1.5, Gamma=1.2, Lambda=3, angle=A)\n\n        # add gabor filtered image\n        out += _out\n\n    # scale normalization\n    out = out / out.max() * 255\n    out = out.astype(np.uint8)\n\n    return out\n\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# gabor process\nout = Gabor_process(img)\n\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n\n'"
Question_81_90/answers/answer_81.py,16,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Hessian corner detection\ndef Hessian_corner(img):\n\n\t## Grayscale\n\tdef BGR2GRAY(img):\n\t\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\t\tgray = gray.astype(np.uint8)\n\t\treturn gray\n\n\t## Sobel\n\tdef Sobel_filtering(gray):\n\t\t# get shape\n\t\tH, W = gray.shape\n\n\t\t# sobel kernel\n\t\tsobely = np.array(((1, 2, 1),\n\t\t\t\t\t\t(0, 0, 0),\n\t\t\t\t\t\t(-1, -2, -1)), dtype=np.float32)\n\n\t\tsobelx = np.array(((1, 0, -1),\n\t\t\t\t\t\t(2, 0, -2),\n\t\t\t\t\t\t(1, 0, -1)), dtype=np.float32)\n\n\t\t# padding\n\t\ttmp = np.pad(gray, (1, 1), \'edge\')\n\n\t\t# prepare\n\t\tIx = np.zeros_like(gray, dtype=np.float32)\n\t\tIy = np.zeros_like(gray, dtype=np.float32)\n\n\t\t# get differential\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tIx[y, x] = np.mean(tmp[y : y  + 3, x : x + 3] * sobelx)\n\t\t\t\tIy[y, x] = np.mean(tmp[y : y + 3, x : x + 3] * sobely)\n\t\t\t\n\t\tIx2 = Ix ** 2\n\t\tIy2 = Iy ** 2\n\t\tIxy = Ix * Iy\n\n\t\treturn Ix2, Iy2, Ixy\n\n\t\t\n\n\t## Hessian\n\tdef corner_detect(gray, Ix2, Iy2, Ixy):\n\t\t# get shape\n\t\tH, W = gray.shape\n\n\t\t# prepare for show detection\n\t\tout = np.array((gray, gray, gray))\n\t\tout = np.transpose(out, (1,2,0))\n\n\t\t# get Hessian value\n\t\tHes = np.zeros((H, W))\n\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tHes[y,x] = Ix2[y,x] * Iy2[y,x] - Ixy[y,x] ** 2\n\n\t\t## Detect Corner and show\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tif Hes[y,x] == np.max(Hes[max(y-1, 0) : min(y+2, H), max(x-1, 0) : min(x+2, W)]) and Hes[y, x] > np.max(Hes) * 0.1:\n\t\t\t\t\tout[y, x] = [0, 0, 255]\n\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\t\n\t# 1. grayscale\n\tgray = BGR2GRAY(img)\n\n\t# 2. get difference image\n\tIx2, Iy2, Ixy = Sobel_filtering(gray)\n\n\t# 3. corner detection\n\tout = corner_detect(gray, Ix2, Iy2, Ixy)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Hessian corner detection\nout = Hessian_corner(img)\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_81_90/answers/answer_82.py,16,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Harris corner detection\ndef Harris_corner_step1(img):\n\n\t## Grayscale\n\tdef BGR2GRAY(img):\n\t\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\t\tgray = gray.astype(np.uint8)\n\t\treturn gray\n\n\t## Sobel\n\tdef Sobel_filtering(gray):\n\t\t# get shape\n\t\tH, W = gray.shape\n\n\t\t# sobel kernel\n\t\tsobely = np.array(((1, 2, 1),\n\t\t\t\t\t\t(0, 0, 0),\n\t\t\t\t\t\t(-1, -2, -1)), dtype=np.float32)\n\n\t\tsobelx = np.array(((1, 0, -1),\n\t\t\t\t\t\t(2, 0, -2),\n\t\t\t\t\t\t(1, 0, -1)), dtype=np.float32)\n\n\t\t# padding\n\t\ttmp = np.pad(gray, (1, 1), \'edge\')\n\n\t\t# prepare\n\t\tIx = np.zeros_like(gray, dtype=np.float32)\n\t\tIy = np.zeros_like(gray, dtype=np.float32)\n\n\t\t# get differential\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tIx[y, x] = np.mean(tmp[y : y  + 3, x : x + 3] * sobelx)\n\t\t\t\tIy[y, x] = np.mean(tmp[y : y + 3, x : x + 3] * sobely)\n\t\t\t\n\t\tIx2 = Ix ** 2\n\t\tIy2 = Iy ** 2\n\t\tIxy = Ix * Iy\n\n\t\treturn Ix2, Iy2, Ixy\n\n\n\t# gaussian filtering\n\tdef gaussian_filtering(I, K_size=3, sigma=3):\n\t\t# get shape\n\t\tH, W = I.shape\n\n\t\t## gaussian\n\t\tI_t = np.pad(I, (K_size // 2, K_size // 2), \'edge\')\n\n\t\t# gaussian kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(K_size):\n\t\t\tfor y in range(K_size):\n\t\t\t\t_x = x - K_size // 2\n\t\t\t\t_y = y - K_size // 2\n\t\t\t\tK[y, x] = np.exp( -(_x ** 2 + _y ** 2) / (2 * (sigma ** 2)))\n\t\tK /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= K.sum()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tI[y,x] = np.sum(I_t[y : y + K_size, x : x + K_size] * K)\n\t\t\t\t\n\t\treturn I\n\n\t\n\t# 1. grayscale\n\tgray = BGR2GRAY(img)\n\n\t# 2. get difference image\n\tIx2, Iy2, Ixy = Sobel_filtering(gray)\n\n\t# 3. gaussian filtering\n\tIx2 = gaussian_filtering(Ix2, K_size=3, sigma=3)\n\tIy2 = gaussian_filtering(Iy2, K_size=3, sigma=3)\n\tIxy = gaussian_filtering(Ixy, K_size=3, sigma=3)\n\n\t# show result\n\tplt.subplots_adjust(left=0, right=1, top=1, bottom=0, hspace=0, wspace=0.2)\n\n\tplt.subplot(1,3,1)\n\tplt.imshow(Ix2, cmap=\'gray\')\n\tplt.title(""Ix^2"")\n\tplt.axis(""off"")\n\n\tplt.subplot(1,3,2)\n\tplt.imshow(Iy2, cmap=\'gray\')\n\tplt.title(""Iy^2"")\n\tplt.axis(""off"")\n\n\tplt.subplot(1,3,3)\n\tplt.imshow(Ixy, cmap=\'gray\')\n\tplt.title(""Ixy"")\n\tplt.axis(""off"")\n\n\tplt.savefig(""out.png"")\n\tplt.show()\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Harris corner detection step1\nout = Harris_corner_step1(img)\n'"
Question_81_90/answers/answer_83.py,20,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# Harris corner detection\ndef Harris_corner(img):\n\n\t## Grayscale\n\tdef BGR2GRAY(img):\n\t\tgray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\t\tgray = gray.astype(np.uint8)\n\t\treturn gray\n\n\t## Sobel\n\tdef Sobel_filtering(gray):\n\t\t# get shape\n\t\tH, W = gray.shape\n\n\t\t# sobel kernel\n\t\tsobely = np.array(((1, 2, 1),\n\t\t\t\t\t\t(0, 0, 0),\n\t\t\t\t\t\t(-1, -2, -1)), dtype=np.float32)\n\n\t\tsobelx = np.array(((1, 0, -1),\n\t\t\t\t\t\t(2, 0, -2),\n\t\t\t\t\t\t(1, 0, -1)), dtype=np.float32)\n\n\t\t# padding\n\t\ttmp = np.pad(gray, (1, 1), \'edge\')\n\n\t\t# prepare\n\t\tIx = np.zeros_like(gray, dtype=np.float32)\n\t\tIy = np.zeros_like(gray, dtype=np.float32)\n\n\t\t# get differential\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tIx[y, x] = np.mean(tmp[y : y  + 3, x : x + 3] * sobelx)\n\t\t\t\tIy[y, x] = np.mean(tmp[y : y + 3, x : x + 3] * sobely)\n\t\t\t\n\t\tIx2 = Ix ** 2\n\t\tIy2 = Iy ** 2\n\t\tIxy = Ix * Iy\n\n\t\treturn Ix2, Iy2, Ixy\n\n\n\t# gaussian filtering\n\tdef gaussian_filtering(I, K_size=3, sigma=3):\n\t\t# get shape\n\t\tH, W = I.shape\n\n\t\t## gaussian\n\t\tI_t = np.pad(I, (K_size // 2, K_size // 2), \'edge\')\n\n\t\t# gaussian kernel\n\t\tK = np.zeros((K_size, K_size), dtype=np.float)\n\t\tfor x in range(K_size):\n\t\t\tfor y in range(K_size):\n\t\t\t\t_x = x - K_size // 2\n\t\t\t\t_y = y - K_size // 2\n\t\t\t\tK[y, x] = np.exp( -(_x ** 2 + _y ** 2) / (2 * (sigma ** 2)))\n\t\tK /= (sigma * np.sqrt(2 * np.pi))\n\t\tK /= K.sum()\n\n\t\t# filtering\n\t\tfor y in range(H):\n\t\t\tfor x in range(W):\n\t\t\t\tI[y,x] = np.sum(I_t[y : y + K_size, x : x + K_size] * K)\n\t\t\t\t\n\t\treturn I\n\n\t# corner detect\n\tdef corner_detect(gray, Ix2, Iy2, Ixy, k=0.04, th=0.1):\n\t\t# prepare output image\n\t\tout = np.array((gray, gray, gray))\n\t\tout = np.transpose(out, (1,2,0))\n\n\t\t# get R\n\t\tR = (Ix2 * Iy2 - Ixy ** 2) - k * ((Ix2 + Iy2) ** 2)\n\n\t\t# detect corner\n\t\tout[R >= np.max(R) * th] = [0, 0, 255]\n\n\t\tout = out.astype(np.uint8)\n\n\t\treturn out\n\n\t\n\t# 1. grayscale\n\tgray = BGR2GRAY(img)\n\n\t# 2. get difference image\n\tIx2, Iy2, Ixy = Sobel_filtering(gray)\n\n\t# 3. gaussian filtering\n\tIx2 = gaussian_filtering(Ix2, K_size=3, sigma=3)\n\tIy2 = gaussian_filtering(Iy2, K_size=3, sigma=3)\n\tIxy = gaussian_filtering(Ixy, K_size=3, sigma=3)\n\n\t# 4. corner detect\n\tout = corner_detect(gray, Ix2, Iy2, Ixy)\n\n\treturn out\n\n\n# Read image\nimg = cv2.imread(""thorino.jpg"").astype(np.float32)\n\n# Harris corner detection\nout = Harris_corner(img)\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_81_90/answers/answer_84.py,4,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n## Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n## Database\ndef get_DB():\n    # get image paths\n    train = glob(""dataset/train_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n\n    # each image\n    for i, path in enumerate(train):\n        img = dic_color(cv2.imread(path))\n        # get histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        img_h = img.copy() // 64\n        img_h[..., 1] += 4\n        img_h[..., 2] += 8\n        plt.subplot(2, 5, i+1)\n        plt.hist(img_h.ravel(), bins=12, rwidth=0.8)\n        plt.title(path)\n\n    print(db)\n    plt.show()\n\n# get database\nget_DB()\n'"
Question_81_90/answers/answer_85.py,11,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/train_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n\n    # prepare path database\n    pdb = []\n\n    # each image\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n\n        #get histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # store image path\n        pdb.append(path)\n\n    return db, pdb\n\n# test\ndef test_DB(db, pdb):\n    # get test image path\n    test = glob(""dataset/test_*"")\n    test.sort()\n\n    success_num = 0.\n\n    # each image\n    for path in test:\n        # read image\n        img = dic_color(cv2.imread(path))\n\n        # get histogram\n        hist = np.zeros(12, dtype=np.int32)\n        for j in range(4):\n            hist[j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            hist[j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            hist[j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get histogram difference\n        difs = np.abs(db[:, :12] - hist)\n        difs = np.sum(difs, axis=1)\n\n        # get argmin of difference\n        pred_i = np.argmin(difs)\n\n        # get prediction label\n        pred = db[pred_i, -1]\n\n        if pred == 0:\n            pl = ""akahara""\n        elif pred == 1:\n            pl = ""madara""\n        \n        print(path, ""is similar >>"", pdb[pred_i], "" Pred >>"", pl)\n\ndb, pdb = get_DB()\ntest_DB(db, pdb)'"
Question_81_90/answers/answer_86.py,11,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/train_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n\n    # prepare path database\n    pdb = []\n\n    # each image\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n\n        #get histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # store image path\n        pdb.append(path)\n\n    return db, pdb\n\n# test\ndef test_DB(db, pdb):\n    # get test image path\n    test = glob(""dataset/test_*"")\n    test.sort()\n\n    accurate_N = 0.\n\n    # each image\n    for path in test:\n        # read image\n        img = dic_color(cv2.imread(path))\n\n        # get histogram\n        hist = np.zeros(12, dtype=np.int32)\n        for j in range(4):\n            hist[j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            hist[j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            hist[j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get histogram difference\n        difs = np.abs(db[:, :12] - hist)\n        difs = np.sum(difs, axis=1)\n\n        # get argmin of difference\n        pred_i = np.argmin(difs)\n\n        # get prediction label\n        pred = db[pred_i, -1]\n\n        if pred == 0:\n            pred_label = ""akahara""\n        elif pred == 1:\n            pred_label = ""madara""\n\n        gt = ""akahara"" if ""akahara"" in path else ""madara""\n\n        if gt == pred_label:\n            accurate_N += 1\n        \n        print(path, ""is similar >>"", pdb[pred_i], "" Pred >>"", pred_label)\n\n    accuracy = accurate_N / len(test)\n    print(""Accuracy >>"", accuracy, ""({}/{})"".format(int(accurate_N), len(test)))\n\ndb, pdb = get_DB()\ntest_DB(db, pdb)\n\n\n'"
Question_81_90/answers/answer_87.py,11,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/train_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n    pdb = []\n\n    # each train\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n        # histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # add image path\n        pdb.append(path)\n\n    return db, pdb\n\n# test\ndef test_DB(db, pdb, N=3):\n    # get test image path\n    test = glob(""dataset/test_*"")\n    test.sort()\n\n    accuracy_N = 0.\n\n    # each image\n    for path in test:\n        # read image\n        img = dic_color(cv2.imread(path))\n\n        # get histogram\n        hist = np.zeros(12, dtype=np.int32)\n        for j in range(4):\n            hist[j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            hist[j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            hist[j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get histogram difference\n        difs = np.abs(db[:, :12] - hist)\n        difs = np.sum(difs, axis=1)\n\n        # get top N\n        pred_i = np.argsort(difs)[:N]\n\n        # predict class index\n        pred = db[pred_i, -1]\n\n        # get class label\n        if len(pred[pred == 0]) > len(pred[pred == 1]):\n            pl = ""akahara""\n        else:\n            pl = \'madara\'\n\n        print(path, ""is similar >> "", end=\'\')\n        for i in pred_i:\n            print(pdb[i], end=\', \')\n        print(""|Pred >>"", pl)\n\n        # count accuracy\n        gt = ""akahara"" if ""akahara"" in path else ""madara""\n        if gt == pl:\n            accuracy_N += 1.\n\n    accuracy = accuracy_N / len(test)\n    print(""Accuracy >>"", accuracy, ""({}/{})"".format(int(accuracy_N), len(test)))\n\n\ndb, pdb = get_DB()\ntest_DB(db, pdb)\n'"
Question_81_90/answers/answer_88.py,8,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/test_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n    pdb = []\n\n    # each train\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n        # histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # add image path\n        pdb.append(path)\n\n    return db, pdb\n\n# k-Means step1\ndef k_means_step1(db, pdb, Class=2):\n    # copy database\n    feats = db.copy()\n\n    # initiate random seed\n    np.random.seed(1)\n\n    # assign random class \n    for i in range(len(feats)):\n        if np.random.random() < 0.5:\n            feats[i, -1] = 0\n        else:\n            feats[i, -1] = 1\n\n    # prepare gravity\n    gs = np.zeros((Class, 12), dtype=np.float32)\n        \n    # get gravity\n    for i in range(Class):\n        gs[i] = np.mean(feats[np.where(feats[..., -1] == i)[0], :12], axis=0)\n    print(""assigned label"")\n    print(feats)\n    print(""Grabity"")\n    print(gs)\n\n\ndb, pdb = get_DB()\nk_means_step1(db, pdb)'"
Question_81_90/answers/answer_89.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/test_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n    pdb = []\n\n    # each train\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n        # histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # add image path\n        pdb.append(path)\n\n    return db, pdb\n\n# k-Means step2\ndef k_means_step2(db, pdb, Class=2):\n    # copy database\n    feats = db.copy()\n\n    # initiate random seed\n    np.random.seed(1)\n\n    # assign random class \n    for i in range(len(feats)):\n        if np.random.random() < 0.5:\n            feats[i, -1] = 0\n        else:\n            feats[i, -1] = 1\n\n    while True:\n        # prepare greavity\n        gs = np.zeros((Class, 12), dtype=np.float32)\n        change_count = 0\n\n        # compute gravity\n        for i in range(Class):\n            gs[i] = np.mean(feats[np.where(feats[..., -1] == i)[0], :12], axis=0)\n\n        # re-labeling\n        for i in range(len(feats)):\n            # get distance each nearest graviry\n            dis = np.sqrt(np.sum(np.square(np.abs(gs - feats[i, :12])), axis=1))\n\n            # get new label\n            pred = np.argmin(dis, axis=0)\n\n            # if label is difference from old label\n            if int(feats[i, -1]) != pred:\n                change_count += 1\n                feats[i, -1] = pred\n\n        if change_count < 1:\n            break\n\n    for i in range(db.shape[0]):\n        print(pdb[i], "" Pred:"", feats[i, -1])\n\n\ndb, pdb = get_DB()\nk_means_step2(db, pdb)\n'"
Question_81_90/answers/answer_90.py,10,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n# Dicrease color\ndef dic_color(img):\n    img //= 63\n    img = img * 64 + 32\n    return img\n\n\n# Database\ndef get_DB():\n    # get training image path\n    train = glob(""dataset/train_*"")\n    train.sort()\n\n    # prepare database\n    db = np.zeros((len(train), 13), dtype=np.int32)\n    pdb = []\n\n    # each train\n    for i, path in enumerate(train):\n        # read image\n        img = dic_color(cv2.imread(path))\n        # histogram\n        for j in range(4):\n            db[i, j] = len(np.where(img[..., 0] == (64 * j + 32))[0])\n            db[i, j+4] = len(np.where(img[..., 1] == (64 * j + 32))[0])\n            db[i, j+8] = len(np.where(img[..., 2] == (64 * j + 32))[0])\n\n        # get class\n        if \'akahara\' in path:\n            cls = 0\n        elif \'madara\' in path:\n            cls = 1\n\n        # store class label\n        db[i, -1] = cls\n\n        # add image path\n        pdb.append(path)\n\n    return db, pdb\n\n# k-Means\ndef k_means(db, pdb, Class=2, th=0.5):\n    # copy database\n    feats = db.copy()\n\n    # initiate random seed\n    np.random.seed(4)\n\n    # assign random class \n    for i in range(len(feats)):\n        if np.random.random() < th:\n            feats[i, -1] = 0\n        else:\n            feats[i, -1] = 1\n\n    while True:\n        # prepare greavity\n        gs = np.zeros((Class, 12), dtype=np.float32)\n        change_count = 0\n\n        # compute gravity\n        for i in range(Class):\n            gs[i] = np.mean(feats[np.where(feats[..., -1] == i)[0], :12], axis=0)\n\n        # re-labeling\n        for i in range(len(feats)):\n            # get distance each nearest graviry\n            dis = np.sqrt(np.sum(np.square(np.abs(gs - feats[i, :12])), axis=1))\n\n            # get new label\n            pred = np.argmin(dis, axis=0)\n\n            # if label is difference from old label\n            if int(feats[i, -1]) != pred:\n                change_count += 1\n                feats[i, -1] = pred\n\n        if change_count < 1:\n            break\n\n    for i in range(db.shape[0]):\n        print(pdb[i], "" Pred:"", feats[i, -1])\n\n\ndb, pdb = get_DB()\nk_means(db, pdb, th=0.3)\n\n'"
Question_91_100/answers/_answer_100.py,78,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n\n## training neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                #cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\n\n# Non-maximum suppression\ndef nms(_bboxes, iou_th=0.5, select_num=None, prob_th=None):\n    #\n    # Non Maximum Suppression\n    #\n    # Argument\n    #  bboxes(Nx5) ... [bbox-num, 5(leftTopX,leftTopY,w,h, score)]\n    #  iou_th([float]) ... threshold for iou between bboxes.\n    #  select_num([int]) ... max number for choice bboxes. If None, this is unvalid.\n    #  prob_th([float]) ... probability threshold to choice. If None, this is unvalid.\n    # Return\n    #  inds ... choced indices for bboxes\n    #\n\n    bboxes = _bboxes.copy()\n    \n    bboxes[:, 2] = bboxes[:, 2] - bboxes[:, 0]\n    bboxes[:, 3] = bboxes[:, 3] - bboxes[:, 1]\n    \n    # Sort by bbox\'s score. High -> Low\n    sort_inds = np.argsort(bboxes[:, -1])[::-1]\n\n    processed_bbox_ind = []\n    return_inds = []\n\n    unselected_inds = sort_inds.copy()\n    \n    while len(unselected_inds) > 0:\n        process_bboxes = bboxes[unselected_inds]\n        argmax_score_ind = np.argmax(process_bboxes[::, -1])\n        max_score_ind = unselected_inds[argmax_score_ind]\n        return_inds += [max_score_ind]\n        unselected_inds = np.delete(unselected_inds, argmax_score_ind)\n\n        base_bbox = bboxes[max_score_ind]\n        compare_bboxes = bboxes[unselected_inds]\n        \n        base_x1 = base_bbox[0]\n        base_y1 = base_bbox[1]\n        base_x2 = base_bbox[2] + base_x1\n        base_y2 = base_bbox[3] + base_y1\n        base_w = np.maximum(base_bbox[2], 0)\n        base_h = np.maximum(base_bbox[3], 0)\n        base_area = base_w * base_h\n\n        # compute iou-area between base bbox and other bboxes\n        iou_x1 = np.maximum(base_x1, compare_bboxes[:, 0])\n        iou_y1 = np.maximum(base_y1, compare_bboxes[:, 1])\n        iou_x2 = np.minimum(base_x2, compare_bboxes[:, 2] + compare_bboxes[:, 0])\n        iou_y2 = np.minimum(base_y2, compare_bboxes[:, 3] + compare_bboxes[:, 1])\n        iou_w = np.maximum(iou_x2 - iou_x1, 0)\n        iou_h = np.maximum(iou_y2 - iou_y1, 0)\n        iou_area = iou_w * iou_h\n\n        compare_w = np.maximum(compare_bboxes[:, 2], 0)\n        compare_h = np.maximum(compare_bboxes[:, 3], 0)\n        compare_area = compare_w * compare_h\n\n        # bbox\'s index which iou ratio over threshold is excluded\n        all_area = compare_area + base_area - iou_area\n        iou_ratio = np.zeros((len(unselected_inds)))\n        iou_ratio[all_area < 0.9] = 0.\n        _ind = all_area >= 0.9\n        iou_ratio[_ind] = iou_area[_ind] / all_area[_ind]\n        \n        unselected_inds = np.delete(unselected_inds, np.where(iou_ratio >= iou_th)[0])\n\n    if prob_th is not None:\n        preds = bboxes[return_inds][:, -1]\n        return_inds = np.array(return_inds)[np.where(preds >= prob_th)[0]].tolist()\n        \n    # pick bbox\'s index by defined number with higher score\n    if select_num is not None:\n        return_inds = return_inds[:select_num]\n\n    return return_inds\n\n\ndetects = detects[nms(detects, iou_th=0.25)]\n\n\n# Evaluation\n\n# [x1, y1, x2, y2]\nGT = np.array(((27, 48, 95, 110), (101, 75, 171, 138)), dtype=np.float32)\n\n## Recall, Precision, F-score\niou_th = 0.5\n\nRs = np.zeros((len(GT)))\nPs = np.zeros((len(detects)))\n\nfor i, g in enumerate(GT):\n    iou_x1 = np.maximum(g[0], detects[:, 0])\n    iou_y1 = np.maximum(g[1], detects[:, 1])\n    iou_x2 = np.minimum(g[2], detects[:, 2])\n    iou_y2 = np.minimum(g[3], detects[:, 3])\n    iou_w = np.maximum(0, iou_x2 - iou_x1)\n    iou_h = np.maximum(0, iou_y2 - iou_y1)\n    iou_area = iou_w * iou_h\n    g_area = (g[2] - g[0]) * (g[3] - g[1])\n    d_area = (detects[:, 2] - detects[:, 0]) * (detects[:, 3] - detects[:, 1])\n    ious = iou_area / (g_area + d_area - iou_area)\n    \n    Rs[i] = 1 if len(np.where(ious >= iou_th)[0]) > 0 else 0\n    Ps[ious >= iou_th] = 1\n    \n\nR = np.sum(Rs) / len(Rs)\nP = np.sum(Ps) / len(Ps)\nF = (2 * P * R) / (P + R) \n\nprint(""Recall >> {:.2f} ({} / {})"".format(R, np.sum(Rs), len(Rs)))\nprint(""Precision >> {:.2f} ({} / {})"".format(P, np.sum(Ps), len(Ps)))\nprint(""F-score >> "", F)\n\n## mAP\nmAP = 0.\nfor i in range(len(detects)):\n    mAP += np.sum(Ps[:i]) / (i + 1) * Ps[i]\nmAP /= np.sum(Ps)\n\nprint(""mAP >>"", mAP)\n\n# Display\nfor i in range(len(detects)):\n    v = list(map(int, detects[i, :4]))\n    if Ps[i] > 0:\n        cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (0,0,255), 1)\n    else:\n        cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (255,0,0), 1)\n    cv2.putText(img2, ""{:.2f}"".format(detects[i, -1]), (v[0], v[1]+9),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,0,255), 1)\n\nfor g in GT:\n    cv2.rectangle(img2, (g[0], g[1]), (g[2], g[3]), (0,255,0), 1)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
Question_91_100/answers/_answer_95.py,21,"b'import numpy as np\n\nnp.random.seed(0)\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\ntrain_x = np.array([[0,0], [0,1], [1,0], [1,1]], dtype=np.float32)\ntrain_t = np.array([[0], [1], [1], [0]], dtype=np.float32)\n\nnn = NN(ind=train_x.shape[1])\n\n# train\nfor i in range(1000):\n    nn.forward(train_x)\n    nn.train(train_x, train_t)\n\n# test\nfor j in range(4):\n    x = train_x[j]\n    t = train_t[j]\n    print(""in:"", x, ""pred:"", nn.forward(x))\n'"
Question_91_100/answers/_answer_96.py,44,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n#cv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = np.zeros((3,))\n    _iou[0] = iou(gt, crop)\n    #_iou[1] = iou(gt2, crop)\n    #_iou[2] = iou(gt3, crop)\n\n    if _iou.max() >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n# train neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n# test\nsuccess_pred = 0.\nfor data in db:\n    t = data[-1]\n    prob = nn.forward(data[:F_n])\n    pred = 1 if prob >= 0.5 else 0\n    if t == pred:\n        success_pred += 1\n\naccuracy = success_pred / len(db)\n\nprint(""Accuracy >> {} ({} / {})"".format(accuracy, success_pred, len(db)))\n\n'"
Question_91_100/answers/_answer_98.py,46,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n## train neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\nprint(detects)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
Question_91_100/answers/_answer_99.py,62,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w2 = np.random.randn(ind, w)\n        self.b2 = np.random.randn(w)\n        self.w3 = np.random.randn(w, w2)\n        self.b3 = np.random.randn(w2)\n        self.wout = np.random.randn(w2, outd)\n        self.bout = np.random.randn(outd)\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = self.sigmoid(np.dot(self.z1, self.w2) + self.b2)\n        self.z3 = self.sigmoid(np.dot(self.z2, self.w3) + self.b3)\n        self.out = self.sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        out_d = 2*(self.out - t) * self.out * (1 - self.out)\n        out_dW = np.dot(self.z3.T, out_d)\n        out_dB = np.dot(np.ones([1, out_d.shape[0]]), out_d)\n        self.wout -= self.lr * out_dW\n        self.bout -= self.lr * out_dB[0]\n\n        w3_d = np.dot(out_d, self.wout.T) * self.z3 * (1 - self.z3)\n        w3_dW = np.dot(self.z2.T, w3_d)\n        w3_dB = np.dot(np.ones([1, w3_d.shape[0]]), w3_d)\n        self.w3 -= self.lr * w3_dW\n        self.b3 -= self.lr * w3_dB[0]\n        \n        # backpropagation inter layer\n        w2_d = np.dot(w3_d, self.w3.T) * self.z2 * (1 - self.z2)\n        w2_dW = np.dot(self.z1.T, w2_d)\n        w2_dB = np.dot(np.ones([1, w2_d.shape[0]]), w2_d)\n        self.w2 -= self.lr * w2_dW\n        self.b2 -= self.lr * w2_dB[0]\n\n    def sigmoid(self, x):\n        return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n\n## training neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                #cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\n\n# Non-maximum suppression\ndef nms(_bboxes, iou_th=0.5, select_num=None, prob_th=None):\n    #\n    # Non Maximum Suppression\n    #\n    # Argument\n    #  bboxes(Nx5) ... [bbox-num, 5(leftTopX,leftTopY,w,h, score)]\n    #  iou_th([float]) ... threshold for iou between bboxes.\n    #  select_num([int]) ... max number for choice bboxes. If None, this is unvalid.\n    #  prob_th([float]) ... probability threshold to choice. If None, this is unvalid.\n    # Return\n    #  inds ... choced indices for bboxes\n    #\n\n    bboxes = _bboxes.copy()\n    \n    bboxes[:, 2] = bboxes[:, 2] - bboxes[:, 0]\n    bboxes[:, 3] = bboxes[:, 3] - bboxes[:, 1]\n    \n    # Sort by bbox\'s score. High -> Low\n    sort_inds = np.argsort(bboxes[:, -1])[::-1]\n\n    processed_bbox_ind = []\n    return_inds = []\n\n    unselected_inds = sort_inds.copy()\n    \n    while len(unselected_inds) > 0:\n        process_bboxes = bboxes[unselected_inds]\n        argmax_score_ind = np.argmax(process_bboxes[::, -1])\n        max_score_ind = unselected_inds[argmax_score_ind]\n        return_inds += [max_score_ind]\n        unselected_inds = np.delete(unselected_inds, argmax_score_ind)\n\n        base_bbox = bboxes[max_score_ind]\n        compare_bboxes = bboxes[unselected_inds]\n        \n        base_x1 = base_bbox[0]\n        base_y1 = base_bbox[1]\n        base_x2 = base_bbox[2] + base_x1\n        base_y2 = base_bbox[3] + base_y1\n        base_w = np.maximum(base_bbox[2], 0)\n        base_h = np.maximum(base_bbox[3], 0)\n        base_area = base_w * base_h\n\n        # compute iou-area between base bbox and other bboxes\n        iou_x1 = np.maximum(base_x1, compare_bboxes[:, 0])\n        iou_y1 = np.maximum(base_y1, compare_bboxes[:, 1])\n        iou_x2 = np.minimum(base_x2, compare_bboxes[:, 2] + compare_bboxes[:, 0])\n        iou_y2 = np.minimum(base_y2, compare_bboxes[:, 3] + compare_bboxes[:, 1])\n        iou_w = np.maximum(iou_x2 - iou_x1, 0)\n        iou_h = np.maximum(iou_y2 - iou_y1, 0)\n        iou_area = iou_w * iou_h\n\n        compare_w = np.maximum(compare_bboxes[:, 2], 0)\n        compare_h = np.maximum(compare_bboxes[:, 3], 0)\n        compare_area = compare_w * compare_h\n\n        # bbox\'s index which iou ratio over threshold is excluded\n        all_area = compare_area + base_area - iou_area\n        iou_ratio = np.zeros((len(unselected_inds)))\n        iou_ratio[all_area < 0.9] = 0.\n        _ind = all_area >= 0.9\n        iou_ratio[_ind] = iou_area[_ind] / all_area[_ind]\n        \n        unselected_inds = np.delete(unselected_inds, np.where(iou_ratio >= iou_th)[0])\n\n    if prob_th is not None:\n        preds = bboxes[return_inds][:, -1]\n        return_inds = np.array(return_inds)[np.where(preds >= prob_th)[0]].tolist()\n        \n    # pick bbox\'s index by defined number with higher score\n    if select_num is not None:\n        return_inds = return_inds[:select_num]\n\n    return return_inds\n\n\ndetects = detects[nms(detects, iou_th=0.25)]\n\nfor d in detects:\n    v = list(map(int, d[:4]))\n    cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (0,0,255), 1)\n    cv2.putText(img2, ""{:.2f}"".format(d[-1]), (v[0], v[1]+9),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,0,255), 1)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_100.py,79,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        self.b1 = np.random.normal(0, 1, [w])\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        self.b2 = np.random.normal(0, 1, [w2])\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        self.bout = np.random.normal(0, 1, [outd])\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n        \n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n\n## training neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                #cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\n\n# Non-maximum suppression\ndef nms(_bboxes, iou_th=0.5, select_num=None, prob_th=None):\n    #\n    # Non Maximum Suppression\n    #\n    # Argument\n    #  bboxes(Nx5) ... [bbox-num, 5(leftTopX,leftTopY,w,h, score)]\n    #  iou_th([float]) ... threshold for iou between bboxes.\n    #  select_num([int]) ... max number for choice bboxes. If None, this is unvalid.\n    #  prob_th([float]) ... probability threshold to choice. If None, this is unvalid.\n    # Return\n    #  inds ... choced indices for bboxes\n    #\n\n    bboxes = _bboxes.copy()\n    \n    bboxes[:, 2] = bboxes[:, 2] - bboxes[:, 0]\n    bboxes[:, 3] = bboxes[:, 3] - bboxes[:, 1]\n    \n    # Sort by bbox\'s score. High -> Low\n    sort_inds = np.argsort(bboxes[:, -1])[::-1]\n\n    processed_bbox_ind = []\n    return_inds = []\n\n    unselected_inds = sort_inds.copy()\n    \n    while len(unselected_inds) > 0:\n        process_bboxes = bboxes[unselected_inds]\n        argmax_score_ind = np.argmax(process_bboxes[::, -1])\n        max_score_ind = unselected_inds[argmax_score_ind]\n        return_inds += [max_score_ind]\n        unselected_inds = np.delete(unselected_inds, argmax_score_ind)\n\n        base_bbox = bboxes[max_score_ind]\n        compare_bboxes = bboxes[unselected_inds]\n        \n        base_x1 = base_bbox[0]\n        base_y1 = base_bbox[1]\n        base_x2 = base_bbox[2] + base_x1\n        base_y2 = base_bbox[3] + base_y1\n        base_w = np.maximum(base_bbox[2], 0)\n        base_h = np.maximum(base_bbox[3], 0)\n        base_area = base_w * base_h\n\n        # compute iou-area between base bbox and other bboxes\n        iou_x1 = np.maximum(base_x1, compare_bboxes[:, 0])\n        iou_y1 = np.maximum(base_y1, compare_bboxes[:, 1])\n        iou_x2 = np.minimum(base_x2, compare_bboxes[:, 2] + compare_bboxes[:, 0])\n        iou_y2 = np.minimum(base_y2, compare_bboxes[:, 3] + compare_bboxes[:, 1])\n        iou_w = np.maximum(iou_x2 - iou_x1, 0)\n        iou_h = np.maximum(iou_y2 - iou_y1, 0)\n        iou_area = iou_w * iou_h\n\n        compare_w = np.maximum(compare_bboxes[:, 2], 0)\n        compare_h = np.maximum(compare_bboxes[:, 3], 0)\n        compare_area = compare_w * compare_h\n\n        # bbox\'s index which iou ratio over threshold is excluded\n        all_area = compare_area + base_area - iou_area\n        iou_ratio = np.zeros((len(unselected_inds)))\n        iou_ratio[all_area < 0.9] = 0.\n        _ind = all_area >= 0.9\n        iou_ratio[_ind] = iou_area[_ind] / all_area[_ind]\n        \n        unselected_inds = np.delete(unselected_inds, np.where(iou_ratio >= iou_th)[0])\n\n    if prob_th is not None:\n        preds = bboxes[return_inds][:, -1]\n        return_inds = np.array(return_inds)[np.where(preds >= prob_th)[0]].tolist()\n        \n    # pick bbox\'s index by defined number with higher score\n    if select_num is not None:\n        return_inds = return_inds[:select_num]\n\n    return return_inds\n\n\ndetects = detects[nms(detects, iou_th=0.25)]\n\n\n# Evaluation\n\n# [x1, y1, x2, y2]\nGT = np.array(((27, 48, 95, 110), (101, 75, 171, 138)), dtype=np.float32)\n\n## Recall, Precision, F-score\niou_th = 0.5\n\nRs = np.zeros((len(GT)))\nPs = np.zeros((len(detects)))\n\nfor i, g in enumerate(GT):\n    iou_x1 = np.maximum(g[0], detects[:, 0])\n    iou_y1 = np.maximum(g[1], detects[:, 1])\n    iou_x2 = np.minimum(g[2], detects[:, 2])\n    iou_y2 = np.minimum(g[3], detects[:, 3])\n    iou_w = np.maximum(0, iou_x2 - iou_x1)\n    iou_h = np.maximum(0, iou_y2 - iou_y1)\n    iou_area = iou_w * iou_h\n    g_area = (g[2] - g[0]) * (g[3] - g[1])\n    d_area = (detects[:, 2] - detects[:, 0]) * (detects[:, 3] - detects[:, 1])\n    ious = iou_area / (g_area + d_area - iou_area)\n    \n    Rs[i] = 1 if len(np.where(ious >= iou_th)[0]) > 0 else 0\n    Ps[ious >= iou_th] = 1\n    \n\nR = np.sum(Rs) / len(Rs)\nP = np.sum(Ps) / len(Ps)\nF = (2 * P * R) / (P + R) \n\nprint(""Recall >> {:.2f} ({} / {})"".format(R, np.sum(Rs), len(Rs)))\nprint(""Precision >> {:.2f} ({} / {})"".format(P, np.sum(Ps), len(Ps)))\nprint(""F-score >> "", F)\n\n## mAP\nmAP = 0.\nfor i in range(len(detects)):\n    mAP += np.sum(Ps[:i]) / (i + 1) * Ps[i]\nmAP /= np.sum(Ps)\n\nprint(""mAP >>"", mAP)\n\n# Display\nfor i in range(len(detects)):\n    v = list(map(int, detects[i, :4]))\n    if Ps[i] > 0:\n        cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (0,0,255), 1)\n    else:\n        cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (255,0,0), 1)\n    cv2.putText(img2, ""{:.2f}"".format(detects[i, -1]), (v[0], v[1]+9),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,0,255), 1)\n\nfor g in GT:\n    cv2.rectangle(img2, (g[0], g[1]), (g[2], g[3]), (0,255,0), 1)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_91.py,9,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\n\n# K-means step1\ndef k_means_step1(img, Class=5):\n\t#  get shape\n\tH, W, C = img.shape\n\n\t# initiate random seed\n\tnp.random.seed(0)\n\n\t# reshape\n\timg = np.reshape(img, (H * W, -1))\n\n\t# select one index randomly\n\ti = np.random.choice(np.arange(H * W), Class, replace=False)\n\tCs = img[i].copy()\n\n\tprint(Cs)\n\n\tclss = np.zeros((H * W), dtype=int)\n\n\t# each pixel\n\tfor i in range(H * W):\n\t\t# get distance from base pixel\n\t\tdis = np.sqrt(np.sum((Cs - img[i]) ** 2, axis=1))\n\t\t# get argmin distance\n\t\tclss[i] = np.argmin(dis)\n\n\t# show\n\tout = np.reshape(clss, (H, W)) * 50\n\tout = out.astype(np.uint8)\n\n\treturn out\n\n\n# read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# K-means step2\nout = k_means_step1(img)\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_92.py,13,"b'import cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom glob import glob\n\ndef k_means(img, Class=5):\n    # get shape\n    H, W, C = img.shape\n\n    # initiate random seed\n    np.random.seed(0)\n\n    # reshape image\n    img = np.reshape(img, (H * W, -1))\n\n    # get index randomly\n    i = np.random.choice(np.arange(H * W), Class, replace=False)\n    Cs = img[i].copy()\n\n    while True:\n        # prepare pixel class label\n        clss = np.zeros((H * W), dtype=int)\n        \n        # each pixel\n        for i in range(H * W):\n            # get distance from index pixel\n            dis = np.sqrt(np.sum((Cs - img[i])**2, axis=1))\n            # get argmin distance\n            clss[i] = np.argmin(dis)\n\n        # selected pixel values\n        Cs_tmp = np.zeros((Class, 3))\n        \n        # each class label\n        for i in range(Class):\n            Cs_tmp[i] = np.mean(img[clss == i], axis=0)\n\n        # if not any change\n        if (Cs == Cs_tmp).all():\n            break\n        else:\n            Cs = Cs_tmp.copy()\n\n    # prepare out image\n    out = np.zeros((H * W, 3), dtype=np.float32)\n\n    # assign selected pixel values  \n    for i in range(Class):\n        out[clss == i] = Cs[i]\n\n    print(Cs)\n        \n    out = np.clip(out, 0, 255)\n\n    # reshape out image\n    out = np.reshape(out, (H, W, 3))\n    out = out.astype(np.uint8)\n\n    return out\n\n# read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# K-means\nout = k_means(img)\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_93.py,6,"b'import numpy as np\n\n# get IoU overlap ratio\ndef iou(a, b):\n\t# get area of a\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n\t# get area of b\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n\n\t# get left top x of IoU\n    iou_x1 = np.maximum(a[0], b[0])\n\t# get left top y of IoU\n    iou_y1 = np.maximum(a[1], b[1])\n\t# get right bottom of IoU\n    iou_x2 = np.minimum(a[2], b[2])\n\t# get right bottom of IoU\n    iou_y2 = np.minimum(a[3], b[3])\n\n\t# get width of IoU\n    iou_w = iou_x2 - iou_x1\n\t# get height of IoU\n    iou_h = iou_y2 - iou_y1\n\n\t# no overlap\n    if iou_w < 0 or iou_h < 0:\n\treturn 0.0\n\n\t# get area of IoU\n    area_iou = iou_w * iou_h\n\t# get overlap ratio between IoU and all area\n    iou = area_iou / (area_a + area_b - area_iou)\n\n    return iou\n\n# [x1, y1, x2, y2]\na = np.array((50, 50, 150, 150), dtype=np.float32)\n\nb = np.array((60, 60, 170, 160), dtype=np.float32)\n\nprint(iou(a, b))\n'"
Question_91_100/answers/answer_94.py,9,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# get IoU overlap ratio\ndef iou(a, b):\n\t# get area of a\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n\t# get area of b\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n\n\t# get left top x of IoU\n    iou_x1 = np.maximum(a[0], b[0])\n\t# get left top y of IoU\n    iou_y1 = np.maximum(a[1], b[1])\n\t# get right bottom of IoU\n    iou_x2 = np.minimum(a[2], b[2])\n\t# get right bottom of IoU\n    iou_y2 = np.minimum(a[3], b[3])\n\n\t# get width of IoU\n    iou_w = iou_x2 - iou_x1\n\t# get height of IoU\n    iou_h = iou_y2 - iou_y1\n\n\t# get area of IoU\n    area_iou = iou_w * iou_h\n\t# get overlap ratio between IoU and all area\n    iou = area_iou / (area_a + area_b - area_iou)\n\n    return iou\n\n\n# crop and create database\ndef crop_bbox(img, gt, Crop_N=200, L=60, th=0.5):\n    # get shape\n    H, W, C = img.shape\n\n    # each crop\n    for i in range(Crop_N):\n        # get left top x of crop bounding box\n        x1 = np.random.randint(W - L)\n        # get left top y of crop bounding box\n        y1 = np.random.randint(H - L)\n        # get right bottom x of crop bounding box\n        x2 = x1 + L\n        # get right bottom y of crop bounding box\n        y2 = y1 + L\n\n        # crop bounding box\n        crop = np.array((x1, y1, x2, y2))\n\n        # get IoU between crop box and gt\n        _iou = iou(gt, crop)\n\n        # assign label\n        if _iou >= th:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n            label = 1\n        else:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n            label = 0\n\n    return img\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\n\n# gt bounding box\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n# get crop bounding box\nimg = crop_bbox(img, gt)\n\n# draw gt\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,0), 1)\n\ncv2.imwrite(""out.jpg"", img)\ncv2.imshow(""result"", img)\ncv2.waitKey(0)\n\n'"
Question_91_100/answers/answer_95.py,22,"b'import numpy as np\n\nnp.random.seed(0)\n\n# neural network\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        # layer 1 weight\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        # layer 1 bias\n        self.b1 = np.random.normal(0, 1, [w])\n        # layer 2 weight\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        # layer 2 bias\n        self.b2 = np.random.normal(0, 1, [w2])\n        # output layer weight\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        # output layer bias\n        self.bout = np.random.normal(0, 1, [outd])\n        # learning rate\n        self.lr = lr\n\n    def forward(self, x):\n        # input tensor\n        self.z1 = x\n        # layer 1 output tensor\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        # layer 2 output tensor\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        # output layer tensor\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        # get gradients for weight and bias\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        # update weight and bias\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        # get gradients for weight and bias\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        # update weight and bias\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n        \n        # get gradients for weight and bias\n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        # update weight and bias\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\n# sigmoid\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\n# train\ndef train_nn(nn, train_x, train_t, iteration_N=5000):\n    for i in range(5000):\n        # feed-forward data\n        nn.forward(train_x)\n        #print(""ite>>"", i, \'y >>\', nn.forward(train_x))\n        # update parameters\n        nn.train(train_x, train_t)\n\n    return nn\n\n\n# test\ndef test_nn(nn, test_x, test_t):\n    for j in range(len(test_x)):\n        x = train_x[j]\n        t = train_t[j]\n        print(""in:"", x, ""pred:"", nn.forward(x))\n\n\n\n# train data\ntrain_x = np.array([[0,0], [0,1], [1,0], [1,1]], dtype=np.float32)\n\n# train label data\ntrain_t = np.array([[0], [1], [1], [0]], dtype=np.float32)\n\n# prepare neural network\nnn = NN()\n\n# train\nnn = train_nn(nn, train_x, train_t, iteration_N=5000)\n\n# test\ntest_nn(nn, train_x, train_t)\n'"
Question_91_100/answers/answer_96.py,48,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n\n# get HOG\ndef HOG(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n\n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n\t\t# histogram normalization\n    def normalization(histogram, C=3, epsilon=1):\n        cell_N_H, cell_N_W, _ = histogram.shape\n        ## each histogram\n        for y in range(cell_N_H):\n    \t    for x in range(cell_N_W):\n       \t    #for i in range(9):\n                histogram[y, x] /= np.sqrt(np.sum(histogram[max(y - 1, 0) : min(y + 2, cell_N_H),\n                                                            max(x - 1, 0) : min(x + 2, cell_N_W)] ** 2) + epsilon)\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n    \n    # 5. Histogram normalization\n    histogram = normalization(histogram)\n\n    return histogram\n\n\n# get IoU overlap ratio\ndef iou(a, b):\n\t# get area of a\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n\t# get area of b\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n\n\t# get left top x of IoU\n    iou_x1 = np.maximum(a[0], b[0])\n\t# get left top y of IoU\n    iou_y1 = np.maximum(a[1], b[1])\n\t# get right bottom of IoU\n    iou_x2 = np.minimum(a[2], b[2])\n\t# get right bottom of IoU\n    iou_y2 = np.minimum(a[3], b[3])\n\n\t# get width of IoU\n    iou_w = iou_x2 - iou_x1\n\t# get height of IoU\n    iou_h = iou_y2 - iou_y1\n\n\t# get area of IoU\n    area_iou = iou_w * iou_h\n\t# get overlap ratio between IoU and all area\n    iou = area_iou / (area_a + area_b - area_iou)\n\n    return iou\n\n# resize using bi-linear\ndef resize(img, h, w):\n    # get shape\n    _h, _w, _c  = img.shape\n\n    # get resize ratio\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n\n    # get index of each y\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    # get index of each x\n    x = np.tile(np.arange(w), (h, 1))\n\n    # get coordinate toward x and y of resized image\n    y = (y / ah)\n    x = (x / aw)\n\n    # transfer to int\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n\n    # clip index\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    # get distance between original image index and resized image index\n    dx = x - ix\n    dy = y - iy\n\n    dx = np.tile(dx, [_c, 1, 1]).transpose(1, 2, 0)\n    dy = np.tile(dy, [_c, 1, 1]).transpose(1, 2, 0)\n    \n    # resize\n    out = (1 - dx) * (1 - dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix + 1] + (1 - dx) * dy * img[iy + 1, ix] + dx * dy * img[iy + 1, ix + 1]\n    out[out > 255] = 255\n\n    return out\n\n\n# neural network\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        # layer 1 weight\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        # layer 1 bias\n        self.b1 = np.random.normal(0, 1, [w])\n        # layer 2 weight\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        # layer 2 bias\n        self.b2 = np.random.normal(0, 1, [w2])\n        # output layer weight\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        # output layer bias\n        self.bout = np.random.normal(0, 1, [outd])\n        # learning rate\n        self.lr = lr\n\n    def forward(self, x):\n        # input tensor\n        self.z1 = x\n        # layer 1 output tensor\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        # layer 2 output tensor\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        # output layer tensor\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        # get gradients for weight and bias\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        # update weight and bias\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        # get gradients for weight and bias\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        # update weight and bias\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n        \n        # get gradients for weight and bias\n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        # update weight and bias\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\n# sigmoid\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\n# train\ndef train_nn(nn, train_x, train_t, iteration_N=10000):\n    # each iteration\n    for i in range(iteration_N):\n        # feed-forward data\n        nn.forward(train_x)\n        # update parameter\n        nn.train(train_x, train_t)\n\n    return nn\n\n# test\ndef test_nn(nn, test_x, test_t, pred_th=0.5):\n    accuracy_N = 0.\n\n    # each data\n    for data, t in zip(test_x, test_t):\n        # get prediction\n        prob = nn.forward(data)\n\n        # count accuracy\n        pred = 1 if prob >= pred_th else 0\n        if t == pred:\n            accuracy_N += 1\n\n    # get accuracy \n    accuracy = accuracy_N / len(db)\n\n    print(""Accuracy >> {} ({} / {})"".format(accuracy, accuracy_N, len(db)))\n\n\n# crop bounding box and make dataset\ndef make_dataset(img, gt, Crop_N=200, L=60, th=0.5, H_size=32):\n    # get shape\n    H, W, _ = img.shape\n\n    # get HOG feature dimension\n    HOG_feature_N = ((H_size // 8) ** 2) * 9\n\n    # prepare database\n    db = np.zeros([Crop_N, HOG_feature_N + 1])\n\n    # each crop\n    for i in range(Crop_N):\n        # get left top x of crop bounding box\n        x1 = np.random.randint(W - L)\n        # get left top y of crop bounding box\n        y1 = np.random.randint(H - L)\n        # get right bottom x of crop bounding box\n        x2 = x1 + L\n        # get right bottom y of crop bounding box\n        y2 = y1 + L\n\n        # get bounding box\n        crop = np.array((x1, y1, x2, y2))\n\n        _iou = np.zeros((3,))\n        _iou[0] = iou(gt, crop)\n        #_iou[1] = iou(gt2, crop)\n        #_iou[2] = iou(gt3, crop)\n\n        # get label\n        if _iou.max() >= th:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n            label = 1\n        else:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n            label = 0\n\n        # crop area\n        crop_area = img[y1:y2, x1:x2]\n\n        # resize crop area\n        crop_area = resize(crop_area, H_size, H_size)\n\n        # get HOG feature\n        _hog = HOG(crop_area)\n        \n        # store HOG feature and label\n        db[i, :HOG_feature_N] = _hog.ravel()\n        db[i, -1] = label\n\n    return db\n\n# Read image\nimg = cv2.imread(""imori.jpg"").astype(np.float32)\n\n# get HOG\nhistogram = HOG(img)\n\n# prepare gt bounding box\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n# get database\ndb = make_dataset(img, gt)\n\n\n# train neural network\n# get input feature dimension\ninput_dim = db.shape[1] - 1\n# prepare train data X\ntrain_x = db[:, :input_dim]\n# prepare train data t\ntrain_t = db[:, -1][..., None]\n\n# prepare neural network\nnn = NN(ind=input_dim, lr=0.01)\n# training\nnn = train_nn(nn, train_x, train_t, iteration_N=10000)\n\n# test\ntest_nn(nn, train_x, train_t)\n\n'"
Question_91_100/answers/answer_97.py,23,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# get HOG\ndef HOG(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n\n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n\t\t# histogram normalization\n    def normalization(histogram, C=3, epsilon=1):\n        cell_N_H, cell_N_W, _ = histogram.shape\n        ## each histogram\n        for y in range(cell_N_H):\n    \t    for x in range(cell_N_W):\n       \t    #for i in range(9):\n                histogram[y, x] /= np.sqrt(np.sum(histogram[max(y - 1, 0) : min(y + 2, cell_N_H),\n                                                            max(x - 1, 0) : min(x + 2, cell_N_W)] ** 2) + epsilon)\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n    \n    # 5. Histogram normalization\n    histogram = normalization(histogram)\n\n    return histogram\n\n\n# get IoU overlap ratio\ndef iou(a, b):\n\t# get area of a\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n\t# get area of b\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n\n\t# get left top x of IoU\n    iou_x1 = np.maximum(a[0], b[0])\n\t# get left top y of IoU\n    iou_y1 = np.maximum(a[1], b[1])\n\t# get right bottom of IoU\n    iou_x2 = np.minimum(a[2], b[2])\n\t# get right bottom of IoU\n    iou_y2 = np.minimum(a[3], b[3])\n\n\t# get width of IoU\n    iou_w = iou_x2 - iou_x1\n\t# get height of IoU\n    iou_h = iou_y2 - iou_y1\n\n\t# get area of IoU\n    area_iou = iou_w * iou_h\n\t# get overlap ratio between IoU and all area\n    iou = area_iou / (area_a + area_b - area_iou)\n\n    return iou\n\n# resize using bi-linear\ndef resize(img, h, w):\n    # get shape\n    _h, _w, _c  = img.shape\n\n    # get resize ratio\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n\n    # get index of each y\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    # get index of each x\n    x = np.tile(np.arange(w), (h, 1))\n\n    # get coordinate toward x and y of resized image\n    y = (y / ah)\n    x = (x / aw)\n\n    # transfer to int\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n\n    # clip index\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    # get distance between original image index and resized image index\n    dx = x - ix\n    dy = y - iy\n\n    dx = np.tile(dx, [_c, 1, 1]).transpose(1, 2, 0)\n    dy = np.tile(dy, [_c, 1, 1]).transpose(1, 2, 0)\n    \n    # resize\n    out = (1 - dx) * (1 - dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix + 1] + (1 - dx) * dy * img[iy + 1, ix] + dx * dy * img[iy + 1, ix + 1]\n    out[out > 255] = 255\n\n    return out\n\n# sliding window\ndef sliding_window(img, H_size=32):\n    # get shape\n    H, W, _ = img.shape\n    \n    # base rectangle [h, w]\n    recs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\n    # sliding window\n    for y in range(0, H, 4):\n        for x in range(0, W, 4):\n            for rec in recs:\n                # get half size of ractangle\n                dh = int(rec[0] // 2)\n                dw = int(rec[1] // 2)\n\n                # get left top x\n                x1 = max(x - dw, 0)\n                # get left top y\n                x2 = min(x + dw, W)\n                # get right bottom x\n                y1 = max(y - dh, 0)\n                # get right bottom y\n                y2 = min(y + dh, H)\n\n                # crop region\n                region = img[max(y - dh, 0) : min(y + dh, H), max(x - dw, 0) : min(x + dw, W)]\n\n                # resize crop region\n                region = resize(region, H_size, H_size)\n\n                # get HOG feature\n                region_hog = HOG(region).ravel()\n\n\n\n# read detect target image\nimg = cv2.imread(""imori_many.jpg"")\n\nsliding_window(img)\n\n\n\n\n'"
Question_91_100/answers/answer_98.py,47,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n\n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n\n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        self.b1 = np.random.normal(0, 1, [w])\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        self.b2 = np.random.normal(0, 1, [w2])\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        self.bout = np.random.normal(0, 1, [outd])\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n\n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n\n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n## train neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\nprint(detects)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_98_2.py,51,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# get HOG\ndef HOG(img):\n    # Grayscale\n    def BGR2GRAY(img):\n        gray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n        return gray\n\n    # Magnitude and gradient\n    def get_gradXY(gray):\n        H, W = gray.shape\n\n        # padding before grad\n        gray = np.pad(gray, (1, 1), \'edge\')\n\n        # get grad x\n        gx = gray[1:H+1, 2:] - gray[1:H+1, :W]\n        # get grad y\n        gy = gray[2:, 1:W+1] - gray[:H, 1:W+1]\n        # replace 0 with \n        gx[gx == 0] = 1e-6\n\n        return gx, gy\n\n    # get magnitude and gradient\n    def get_MagGrad(gx, gy):\n        # get gradient maginitude\n        magnitude = np.sqrt(gx ** 2 + gy ** 2)\n\n        # get gradient angle\n        gradient = np.arctan(gy / gx)\n\n        gradient[gradient < 0] = np.pi / 2 + gradient[gradient < 0] + np.pi / 2\n\n        return magnitude, gradient\n\n    # Gradient histogram\n    def quantization(gradient):\n        # prepare quantization table\n        gradient_quantized = np.zeros_like(gradient, dtype=np.int)\n\n        # quantization base\n        d = np.pi / 9\n\n        # quantization\n        for i in range(9):\n            gradient_quantized[np.where((gradient >= d * i) & (gradient <= d * (i + 1)))] = i\n\n        return gradient_quantized\n\n\n    # get gradient histogram\n    def gradient_histogram(gradient_quantized, magnitude, N=8):\n        # get shape\n        H, W = magnitude.shape\n\n        # get cell num\n        cell_N_H = H // N\n        cell_N_W = W // N\n        histogram = np.zeros((cell_N_H, cell_N_W, 9), dtype=np.float32)\n\n        # each pixel\n        for y in range(cell_N_H):\n            for x in range(cell_N_W):\n                for j in range(N):\n                    for i in range(N):\n                        histogram[y, x, gradient_quantized[y * 4 + j, x * 4 + i]] += magnitude[y * 4 + j, x * 4 + i]\n\n        return histogram\n\n\t\t# histogram normalization\n    def normalization(histogram, C=3, epsilon=1):\n        cell_N_H, cell_N_W, _ = histogram.shape\n        ## each histogram\n        for y in range(cell_N_H):\n    \t    for x in range(cell_N_W):\n       \t    #for i in range(9):\n                histogram[y, x] /= np.sqrt(np.sum(histogram[max(y - 1, 0) : min(y + 2, cell_N_H),\n                                                            max(x - 1, 0) : min(x + 2, cell_N_W)] ** 2) + epsilon)\n\n        return histogram\n\n    # 1. BGR -> Gray\n    gray = BGR2GRAY(img)\n\n    # 1. Gray -> Gradient x and y\n    gx, gy = get_gradXY(gray)\n\n    # 2. get gradient magnitude and angle\n    magnitude, gradient = get_MagGrad(gx, gy)\n\n    # 3. Quantization\n    gradient_quantized = quantization(gradient)\n\n    # 4. Gradient histogram\n    histogram = gradient_histogram(gradient_quantized, magnitude)\n    \n    # 5. Histogram normalization\n    histogram = normalization(histogram)\n\n    return histogram\n\n\n# get IoU overlap ratio\ndef iou(a, b):\n\t# get area of a\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n\t# get area of b\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n\n\t# get left top x of IoU\n    iou_x1 = np.maximum(a[0], b[0])\n\t# get left top y of IoU\n    iou_y1 = np.maximum(a[1], b[1])\n\t# get right bottom of IoU\n    iou_x2 = np.minimum(a[2], b[2])\n\t# get right bottom of IoU\n    iou_y2 = np.minimum(a[3], b[3])\n\n\t# get width of IoU\n    iou_w = iou_x2 - iou_x1\n\t# get height of IoU\n    iou_h = iou_y2 - iou_y1\n\n\t# get area of IoU\n    area_iou = iou_w * iou_h\n\t# get overlap ratio between IoU and all area\n    iou = area_iou / (area_a + area_b - area_iou)\n\n    return iou\n\n# resize using bi-linear\ndef resize(img, h, w):\n    # get shape\n    _h, _w, _c  = img.shape\n\n    # get resize ratio\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n\n    # get index of each y\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    # get index of each x\n    x = np.tile(np.arange(w), (h, 1))\n\n    # get coordinate toward x and y of resized image\n    y = (y / ah)\n    x = (x / aw)\n\n    # transfer to int\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n\n    # clip index\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    # get distance between original image index and resized image index\n    dx = x - ix\n    dy = y - iy\n\n    dx = np.tile(dx, [_c, 1, 1]).transpose(1, 2, 0)\n    dy = np.tile(dy, [_c, 1, 1]).transpose(1, 2, 0)\n    \n    # resize\n    out = (1 - dx) * (1 - dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix + 1] + (1 - dx) * dy * img[iy + 1, ix] + dx * dy * img[iy + 1, ix + 1]\n    out[out > 255] = 255\n\n    return out\n\n\n# neural network\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        # layer 1 weight\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        # layer 1 bias\n        self.b1 = np.random.normal(0, 1, [w])\n        # layer 2 weight\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        # layer 2 bias\n        self.b2 = np.random.normal(0, 1, [w2])\n        # output layer weight\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        # output layer bias\n        self.bout = np.random.normal(0, 1, [outd])\n        # learning rate\n        self.lr = lr\n\n    def forward(self, x):\n        # input tensor\n        self.z1 = x\n        # layer 1 output tensor\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        # layer 2 output tensor\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        # output layer tensor\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        # get gradients for weight and bias\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        # update weight and bias\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        # get gradients for weight and bias\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        # update weight and bias\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n        \n        # get gradients for weight and bias\n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        # update weight and bias\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\n# sigmoid\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n\n# train\ndef train_nn(nn, train_x, train_t, iteration_N=10000):\n    # each iteration\n    for i in range(iteration_N):\n        # feed-forward data\n        nn.forward(train_x)\n        # update parameter\n        nn.train(train_x, train_t)\n\n    return nn\n\n\n# crop bounding box and make dataset\ndef make_dataset(img, gt, Crop_N=200, L=60, th=0.5, H_size=32):\n    # get shape\n    H, W, _ = img.shape\n\n    # get HOG feature dimension\n    HOG_feature_N = ((H_size // 8) ** 2) * 9\n\n    # prepare database\n    db = np.zeros([Crop_N, HOG_feature_N + 1])\n\n    # each crop\n    for i in range(Crop_N):\n        # get left top x of crop bounding box\n        x1 = np.random.randint(W - L)\n        # get left top y of crop bounding box\n        y1 = np.random.randint(H - L)\n        # get right bottom x of crop bounding box\n        x2 = x1 + L\n        # get right bottom y of crop bounding box\n        y2 = y1 + L\n\n        # get bounding box\n        crop = np.array((x1, y1, x2, y2))\n\n        _iou = np.zeros((3,))\n        _iou[0] = iou(gt, crop)\n        #_iou[1] = iou(gt2, crop)\n        #_iou[2] = iou(gt3, crop)\n\n        # get label\n        if _iou.max() >= th:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n            label = 1\n        else:\n            cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n            label = 0\n\n        # crop area\n        crop_area = img[y1:y2, x1:x2]\n\n        # resize crop area\n        crop_area = resize(crop_area, H_size, H_size)\n\n        # get HOG feature\n        _hog = HOG(crop_area)\n        \n        # store HOG feature and label\n        db[i, :HOG_feature_N] = _hog.ravel()\n        db[i, -1] = label\n\n    return db\n\n\n# sliding window\ndef sliding_window(img, nn, H_size=32, prob_th=0.7):\n    # get shape\n    H, W, _ = img.shape\n\n    # base rectangle [h, w]\n    recs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\n    # detected region\n    detects = np.ndarray((0, 5), dtype=np.float32)\n\n    # sliding window\n    for y in range(0, H, 4):\n        for x in range(0, W, 4):\n            for rec in recs:\n                # get half size of ractangle\n                dh = int(rec[0] // 2)\n                dw = int(rec[1] // 2)\n\n                # get left top x\n                x1 = max(x - dw, 0)\n                # get left top y\n                x2 = min(x + dw, W)\n                # get right bottom x\n                y1 = max(y - dh, 0)\n                # get right bottom y\n                y2 = min(y + dh, H)\n\n                # crop region\n                region = img[max(y - dh, 0) : min(y + dh, H), max(x - dw, 0) : min(x + dw, W)]\n\n                # resize crop region\n                region = resize(region, H_size, H_size)\n\n                # get HOG feature\n                region_hog = HOG(region).ravel()\n\n                # predict score using neural network\n                score = nn.forward(region_hog)\n\n                if score >= prob_th:\n                    cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n                    detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\n    print(detects)\n\n    return img\n\n\n# Read image\nimg = cv2.imread(""imori_1.jpg"").astype(np.float32)\n\n# prepare gt bounding box\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\n# get database\ndb = make_dataset(img, gt)\n\n\n# train neural network\n# get input feature dimension\ninput_dim = db.shape[1] - 1\n# prepare train data X\ntrain_x = db[:, :input_dim]\n# prepare train data t\ntrain_t = db[:, -1][..., None]\n\n# prepare neural network\nnn = NN(ind=input_dim, w=64, w2=64, lr=0.01)\n# training\nnn = train_nn(nn, train_x, train_t, iteration_N=10000)\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\n\n# detection\nout = sliding_window(img2, nn)\n\n\ncv2.imwrite(""out.jpg"", out)\ncv2.imshow(""result"", out)\ncv2.waitKey(0)\n'"
Question_91_100/answers/answer_99.py,63,"b'import cv2\nimport numpy as np\n\nnp.random.seed(0)\n\n# read image\nimg = cv2.imread(""imori_1.jpg"")\nH, W, C = img.shape\n\n# Grayscale\ngray = 0.2126 * img[..., 2] + 0.7152 * img[..., 1] + 0.0722 * img[..., 0]\n\ngt = np.array((47, 41, 129, 103), dtype=np.float32)\n\ncv2.rectangle(img, (gt[0], gt[1]), (gt[2], gt[3]), (0,255,255), 1)\n\ndef iou(a, b):\n    area_a = (a[2] - a[0]) * (a[3] - a[1])\n    area_b = (b[2] - b[0]) * (b[3] - b[1])\n    iou_x1 = np.maximum(a[0], b[0])\n    iou_y1 = np.maximum(a[1], b[1])\n    iou_x2 = np.minimum(a[2], b[2])\n    iou_y2 = np.minimum(a[3], b[3])\n    iou_w = max(iou_x2 - iou_x1, 0)\n    iou_h = max(iou_y2 - iou_y1, 0)\n    area_iou = iou_w * iou_h\n    iou = area_iou / (area_a + area_b - area_iou)\n    return iou\n\n\ndef hog(gray):\n    h, w = gray.shape\n    # Magnitude and gradient\n    gray = np.pad(gray, (1, 1), \'edge\')\n\n    gx = gray[1:h+1, 2:] - gray[1:h+1, :w]\n    gy = gray[2:, 1:w+1] - gray[:h, 1:w+1]\n    gx[gx == 0] = 0.000001\n\n    mag = np.sqrt(gx ** 2 + gy ** 2)\n    gra = np.arctan(gy / gx)\n    gra[gra<0] = np.pi / 2 + gra[gra < 0] + np.pi / 2\n\n    # Gradient histogram\n    gra_n = np.zeros_like(gra, dtype=np.int)\n\n    d = np.pi / 9\n    for i in range(9):\n        gra_n[np.where((gra >= d * i) & (gra <= d * (i+1)))] = i\n\n    N = 8\n    HH = h // N\n    HW = w // N\n    Hist = np.zeros((HH, HW, 9), dtype=np.float32)\n    for y in range(HH):\n        for x in range(HW):\n            for j in range(N):\n                for i in range(N):\n                    Hist[y, x, gra_n[y*4+j, x*4+i]] += mag[y*4+j, x*4+i]\n                \n    ## Normalization\n    C = 3\n    eps = 1\n    for y in range(HH):\n        for x in range(HW):\n            #for i in range(9):\n            Hist[y, x] /= np.sqrt(np.sum(Hist[max(y-1,0):min(y+2, HH), max(x-1,0):min(x+2, HW)] ** 2) + eps)\n\n    return Hist\n\ndef resize(img, h, w):\n    _h, _w  = img.shape\n    ah = 1. * h / _h\n    aw = 1. * w / _w\n    y = np.arange(h).repeat(w).reshape(w, -1)\n    x = np.tile(np.arange(w), (h, 1))\n    y = (y / ah)\n    x = (x / aw)\n\n    ix = np.floor(x).astype(np.int32)\n    iy = np.floor(y).astype(np.int32)\n    ix = np.minimum(ix, _w-2)\n    iy = np.minimum(iy, _h-2)\n\n    dx = x - ix\n    dy = y - iy\n    \n    out = (1-dx) * (1-dy) * img[iy, ix] + dx * (1 - dy) * img[iy, ix+1] + (1 - dx) * dy * img[iy+1, ix] + dx * dy * img[iy+1, ix+1]\n    out[out>255] = 255\n\n    return out\n\n\n\n\n# crop and create database\n\nCrop_num = 200\nL = 60\nH_size = 32\nF_n = ((H_size // 8) ** 2) * 9\n\ndb = np.zeros((Crop_num, F_n+1))\n\nfor i in range(Crop_num):\n    x1 = np.random.randint(W-L)\n    y1 = np.random.randint(H-L)\n    x2 = x1 + L\n    y2 = y1 + L\n    crop = np.array((x1, y1, x2, y2))\n\n    _iou = iou(gt, crop)\n\n    if _iou >= 0.5:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (0,0,255), 1)\n        label = 1\n    else:\n        cv2.rectangle(img, (x1, y1), (x2, y2), (255,0,0), 1)\n        label = 0\n\n    crop_area = gray[y1:y2, x1:x2]\n    crop_area = resize(crop_area, H_size, H_size)\n    _hog = hog(crop_area)\n    \n    db[i, :F_n] = _hog.ravel()\n    db[i, -1] = label\n\n\nclass NN:\n    def __init__(self, ind=2, w=64, w2=64, outd=1, lr=0.1):\n        self.w1 = np.random.normal(0, 1, [ind, w])\n        self.b1 = np.random.normal(0, 1, [w])\n        self.w2 = np.random.normal(0, 1, [w, w2])\n        self.b2 = np.random.normal(0, 1, [w2])\n        self.wout = np.random.normal(0, 1, [w2, outd])\n        self.bout = np.random.normal(0, 1, [outd])\n        self.lr = lr\n\n    def forward(self, x):\n        self.z1 = x\n        self.z2 = sigmoid(np.dot(self.z1, self.w1) + self.b1)\n        self.z3 = sigmoid(np.dot(self.z2, self.w2) + self.b2)\n        self.out = sigmoid(np.dot(self.z3, self.wout) + self.bout)\n        return self.out\n\n    def train(self, x, t):\n        # backpropagation output layer\n        #En = t * np.log(self.out) + (1-t) * np.log(1-self.out)\n        En = (self.out - t) * self.out * (1 - self.out)\n        grad_wout = np.dot(self.z3.T, En)\n        grad_bout = np.dot(np.ones([En.shape[0]]), En)\n        self.wout -= self.lr * grad_wout\n        self.bout -= self.lr * grad_bout\n\n        # backpropagation inter layer\n        grad_u2 = np.dot(En, self.wout.T) * self.z3 * (1 - self.z3)\n        grad_w2 = np.dot(self.z2.T, grad_u2)\n        grad_b2 = np.dot(np.ones([grad_u2.shape[0]]), grad_u2)\n        self.w2 -= self.lr * grad_w2\n        self.b2 -= self.lr * grad_b2\n        \n        grad_u1 = np.dot(grad_u2, self.w2.T) * self.z2 * (1 - self.z2)\n        grad_w1 = np.dot(self.z1.T, grad_u1)\n        grad_b1 = np.dot(np.ones([grad_u1.shape[0]]), grad_u1)\n        self.w1 -= self.lr * grad_w1\n        self.b1 -= self.lr * grad_b1\n\ndef sigmoid(x):\n    return 1. / (1. + np.exp(-x))\n    \n\n## training neural network\nnn = NN(ind=F_n, lr=0.01)\nfor i in range(10000):\n    nn.forward(db[:, :F_n])\n    nn.train(db[:, :F_n], db[:, -1][..., None])\n\n\n# read detect target image\nimg2 = cv2.imread(""imori_many.jpg"")\nH2, W2, C2 = img2.shape\n\n# Grayscale\ngray2 = 0.2126 * img2[..., 2] + 0.7152 * img2[..., 1] + 0.0722 * img2[..., 0]\n\n# [h, w]\nrecs = np.array(((42, 42), (56, 56), (70, 70)), dtype=np.float32)\n\ndetects = np.ndarray((0, 5), dtype=np.float32)\n\n# sliding window\nfor y in range(0, H2, 4):\n    for x in range(0, W2, 4):\n        for rec in recs:\n            dh = int(rec[0] // 2)\n            dw = int(rec[1] // 2)\n            x1 = max(x-dw, 0)\n            x2 = min(x+dw, W2)\n            y1 = max(y-dh, 0)\n            y2 = min(y+dh, H2)\n            region = gray2[max(y-dh,0):min(y+dh,H2), max(x-dw,0):min(x+dw,W2)]\n            region = resize(region, H_size, H_size)\n            region_hog = hog(region).ravel()\n\n            score = nn.forward(region_hog)\n            if score >= 0.7:\n                #cv2.rectangle(img2, (x1, y1), (x2, y2), (0,0,255), 1)\n                detects = np.vstack((detects, np.array((x1, y1, x2, y2, score))))\n\n\n# Non-maximum suppression\ndef nms(_bboxes, iou_th=0.5, select_num=None, prob_th=None):\n    #\n    # Non Maximum Suppression\n    #\n    # Argument\n    #  bboxes(Nx5) ... [bbox-num, 5(leftTopX,leftTopY,w,h, score)]\n    #  iou_th([float]) ... threshold for iou between bboxes.\n    #  select_num([int]) ... max number for choice bboxes. If None, this is unvalid.\n    #  prob_th([float]) ... probability threshold to choice. If None, this is unvalid.\n    # Return\n    #  inds ... choced indices for bboxes\n    #\n\n    bboxes = _bboxes.copy()\n    \n    bboxes[:, 2] = bboxes[:, 2] - bboxes[:, 0]\n    bboxes[:, 3] = bboxes[:, 3] - bboxes[:, 1]\n    \n    # Sort by bbox\'s score. High -> Low\n    sort_inds = np.argsort(bboxes[:, -1])[::-1]\n\n    processed_bbox_ind = []\n    return_inds = []\n\n    unselected_inds = sort_inds.copy()\n    \n    while len(unselected_inds) > 0:\n        process_bboxes = bboxes[unselected_inds]\n        argmax_score_ind = np.argmax(process_bboxes[::, -1])\n        max_score_ind = unselected_inds[argmax_score_ind]\n        return_inds += [max_score_ind]\n        unselected_inds = np.delete(unselected_inds, argmax_score_ind)\n\n        base_bbox = bboxes[max_score_ind]\n        compare_bboxes = bboxes[unselected_inds]\n        \n        base_x1 = base_bbox[0]\n        base_y1 = base_bbox[1]\n        base_x2 = base_bbox[2] + base_x1\n        base_y2 = base_bbox[3] + base_y1\n        base_w = np.maximum(base_bbox[2], 0)\n        base_h = np.maximum(base_bbox[3], 0)\n        base_area = base_w * base_h\n\n        # compute iou-area between base bbox and other bboxes\n        iou_x1 = np.maximum(base_x1, compare_bboxes[:, 0])\n        iou_y1 = np.maximum(base_y1, compare_bboxes[:, 1])\n        iou_x2 = np.minimum(base_x2, compare_bboxes[:, 2] + compare_bboxes[:, 0])\n        iou_y2 = np.minimum(base_y2, compare_bboxes[:, 3] + compare_bboxes[:, 1])\n        iou_w = np.maximum(iou_x2 - iou_x1, 0)\n        iou_h = np.maximum(iou_y2 - iou_y1, 0)\n        iou_area = iou_w * iou_h\n\n        compare_w = np.maximum(compare_bboxes[:, 2], 0)\n        compare_h = np.maximum(compare_bboxes[:, 3], 0)\n        compare_area = compare_w * compare_h\n\n        # bbox\'s index which iou ratio over threshold is excluded\n        all_area = compare_area + base_area - iou_area\n        iou_ratio = np.zeros((len(unselected_inds)))\n        iou_ratio[all_area < 0.9] = 0.\n        _ind = all_area >= 0.9\n        iou_ratio[_ind] = iou_area[_ind] / all_area[_ind]\n        \n        unselected_inds = np.delete(unselected_inds, np.where(iou_ratio >= iou_th)[0])\n\n    if prob_th is not None:\n        preds = bboxes[return_inds][:, -1]\n        return_inds = np.array(return_inds)[np.where(preds >= prob_th)[0]].tolist()\n        \n    # pick bbox\'s index by defined number with higher score\n    if select_num is not None:\n        return_inds = return_inds[:select_num]\n\n    return return_inds\n\n\ndetects = detects[nms(detects, iou_th=0.25)]\n\nfor d in detects:\n    v = list(map(int, d[:4]))\n    cv2.rectangle(img2, (v[0], v[1]), (v[2], v[3]), (0,0,255), 1)\n    cv2.putText(img2, ""{:.2f}"".format(d[-1]), (v[0], v[1]+9),\n                cv2.FONT_HERSHEY_SIMPLEX, 0.4, (255,0,255), 1)\n\ncv2.imwrite(""out.jpg"", img2)\ncv2.imshow(""result"", img2)\ncv2.waitKey(0)\n'"
