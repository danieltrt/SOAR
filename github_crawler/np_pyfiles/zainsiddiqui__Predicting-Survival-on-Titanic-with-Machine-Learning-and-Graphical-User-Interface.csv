file_path,api_count,code
GUI.py,0,"b'# This program consists of clean and polished Graphical User Interface (GUI) that interacts with 8 Machine Learning models and data visualization tools through the use of different Python libraries. \n# The user can interact with the GUI through selecting which model to run on the testing data on, which then takes them to a screen displaying the prediction results of the testing data as well as the general model accuracy. \n# The screen also includes various buttons that, when selected, display complex and attractive data visualizations on the testing data.\nimport tkinter as tk\nfrom tkinter import *\nimport tkinter.messagebox\nfrom PIL import Image, ImageTk\nimport dataPreprocessing\nimport machineLearningModels\nimport pandas as pd\n\nclass root(tk.Tk):\n    def __init__(self, *args, **kwargs):\n        tk.Tk.__init__(self, *args, **kwargs)\n        self.geometry(""1500x600+0+0"")\n        self.title(""Titanic Disaster Platform"")\n        container = tk.Frame(self)\n       # container.geometry(""500x500"")\n        \n        container.pack(side = ""top"", fill = ""both"", expand = True)\n        container.grid_rowconfigure(0, weight = 3)\n        container.grid_columnconfigure(0, weight = 3)\n        \n       # container.place(x = 500, y = 1500)\n        self.frames = {}\n\n        for F in (StartPage, Page1, Page2, Page3, Page4, Page5, Page6, Page7, Page8):\n            frame = F(container, self)\n            self.frames[F] = frame\n            frame.grid(row = 0, column = 0, sticky = ""snew"")\n\n        self.show_frame(StartPage)\n\n    def show_frame(self, cont):\n        frame = self.frames[cont]\n        frame.tkraise()\n\n\nclass StartPage(tk.Frame):\n    def __init__(self, parent, controller):\n        tk.Frame.__init__(self, parent)\n        \n        load1 = Image.open(\'MLModelPics/bg2.png\')\n        render1 = ImageTk.PhotoImage(load1)\n        img1 = tk.Label(self, image = render1)\n        img1.image = render1\n        img1.place(x = 0, y = 0)\n        \n        load2 = Image.open(\'MLModelPics/img1.jpg\')\n        render2 = ImageTk.PhotoImage(load2)\n        img2 = tk.Label(self, image = render2)\n        img2.image = render2\n        img2.place(x = 65, y = 25)\n\n        load3 = Image.open(\'MLModelPics/img2.png\')\n        render3 = ImageTk.PhotoImage(load3)\n        img3 = tk.Label(self, image = render3)\n        img3.image = render3\n        img3.place(x = 1175, y = 25)\n\n        labelA = tk.Label(self, text= ""These three buttons will help you understand\\nand visualize the type of people that were on the Titanic\\n by showing graphs of some interesting correlations\\n that occur with survival/death rates\\nand other passenger attributes."")\n        labelA.place(x = 1150, y = 300)\n\n        labelB = tk.Label(self, text = ""Each of our machine learning models employs an\\n algorithm that will go through the large set\\n of Titanic data and give a percentage\\n of correctness of survival/death rates along\\nwith a prediction array. Keep in mind,\\n that each time the model will load up a completely\\n new prediction percentage because\\n the data is very large."")\n        labelB.place(x = 50, y = 300)\n\n        buttonA = tk.Button(self, text = ""Train Distribution"", command = lambda: machineLearningModels.trainclassDistr(machineLearningModels.train_df))\n        buttonA.place(x = 1250, y = 400)\n\n        buttonB = tk.Button(self, text = ""Mean Fare Survival"", command = lambda: machineLearningModels.trainMeanFareSurvival(machineLearningModels.train_df))\n        buttonB.place(x = 1245, y = 450)\n\n        buttonC = tk.Button(self, text = ""Class Survival"", command = lambda: machineLearningModels.trainClassSurvival(machineLearningModels.train_df))\n        buttonC.place(x = 1260, y = 500)\n\n        label = tk.Label(self , text= ""Welcome to the Titanic Disaster Analysis Platform!\\n\\n Here you have the abilty to run algorithms and see data on the disaster that occurred in 1912 based on real passenger data.\\n Our team has used machine learning and data processing techniques to provide several examples and predictions of surivival/death rates.\\n\\n This platform was created by Zain Siddiqui, Haneef Pervez, and Krupal Patel"")\n        label.place(x = 400, y = 150)\n       \n       # button2 = tk.Button(self, text = ""useLog Regression"", command = hello)\n       # button2.place(x = 600, y = 150)\n        button = tk.Button(self, text = ""Log Regression"", command = lambda: controller.show_frame(Page1))\n        button.place(x = 500, y = 300)\n        \n        button2 = tk.Button(self, text = ""Stochastic Gradient\\nDescent"", command = lambda: controller.show_frame(Page2))\n        button2.place(x = 700, y = 300)\n        \n        button3 = tk.Button(self, text = ""K Nearest Neighbor"", command = lambda: controller.show_frame(Page3))\n        button3.place(x = 900, y = 300)\n        \n\n        button4 = tk.Button(self, text = ""Random Forest"", command = lambda: controller.show_frame(Page4))\n        button4.place(x = 500, y = 400)\n\n        button5 = tk.Button(self, text = ""Decision Tree"", command = lambda: controller.show_frame(Page5))\n        button5.place(x = 715, y = 400)\n\n        button6 = tk.Button(self, text = ""Perceptron"", command = lambda: controller.show_frame(Page6))\n        button6.place(x = 925, y = 400)\n\n        button7 = tk.Button(self, text = ""Linear Support\\nVector"", command = lambda: controller.show_frame(Page7))\n        button7.place(x = 600, y = 500)\n\n        button8 = tk.Button(self, text = ""Gaussian Naive\\nBayes"", command = lambda: controller.show_frame(Page8))\n        button8.place(x = 825, y = 500)\n\nclass Page1(tk.Frame):        \n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n                \n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n\t\t\n                load2 = Image.open(\'MLModelPics/LogRegression.jpg\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n                labelSum = tk.Label(self, text = ""Logistic regression is a classification algorithm.\\nIt predicts the probability of an input belonging to a certain set by \\nseparating data into two regions. Logistic regression is used when the response \\nvariable will be binary, for example, pass/fail."")\n                labelSum.place(x =100, y= 200)\n\n             #   label = tk.Label(self, text= machineLearningModels.logRegression(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n            #label.place(x = 700,y = 100)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.logRegression(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predLog))\n                buttonZ.place(x = 275, y = 400)\n\n\nclass Page2(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n                \n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n                load2 = Image.open(\'MLModelPics/gradient-descent.png\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n                labelSum = tk.Label(self, text = ""Gradient Descent is an algorithm that minimizes a cost function. \\nGradient descent is important in machine learning because it optimizes how well a machine \\nlearning algorithm is working by minimizing that algorithm\xe2\x80\x99s cost function. It works by calculating gradients\\n and using those gradients to change weights for predictions."")\n                labelSum.place(x =65, y= 200)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.SGD(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predSGD))\n                buttonZ.place(x = 275, y = 400)\n\nclass Page3(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n                \n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n                load2 = Image.open(\'MLModelPics/kNearestNeighbor.png\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n\n                labelSum = tk.Label(self, text = ""K-Nearest Neighbors is an algorithm that can be used for both classification and regression. \\nIt works by taking in training data and then seeing which data points are close to a data point\\n and then classifying that data point as part of the same class as the majority of the k-nearest \\ndata points. An advantage of k-nearest neighbors is that it is usually pretty accurate and \\nworks well for non-linear data. A disadvantage is that it has to store all the training\\n data which can lead to memory and runtime issues."")\n                labelSum.place(x =100, y= 200)\n\n                img2.place(x = 950, y = 75)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.KNN(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predK))\n                buttonZ.place(x = 275, y = 400)\n\n\nclass Page4(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n                \n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n\n                load2 = Image.open(\'MLModelPics/rForest.png\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n                labelSum = tk.Label(self, text = ""Decision trees that grow deep might lead to some incorrect results, random forests are a way to \\ndeal with this. Random forests work by building a number of decision trees and merging them together\\n and taking the averages of the test variables. One advantage of random forests is that it reduces\\n the variance of using decision trees. A disadvantage is that making multiple decision \\ntrees and merging them together might be run slow in some cases."")\n                labelSum.place(x =75, y= 200)\n\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.rForest(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predForest))\n                buttonZ.place(x = 275, y = 400)\n\nclass Page5(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n                \n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n                load2 = Image.open(\'MLModelPics/DecisionTree.jpg\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n                labelSum = tk.Label(self, text = ""A decision tree is a structure that is used to predict the value of a target value based on certain input variables.\\n Each node of the tree represents a decision that will affect the outcome of the target value. \\nOne advantage of using a decision tree to predict behavior is that decision trees are easy to understand and follow.\\n It is easy to follow the conditional logic that decision trees use."")\n                labelSum.place(x =50, y= 200)\n\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.dTree(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predTree))\n                buttonZ.place(x = 275, y = 400)\n\nclass Page6(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n\n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n\n                load2 = Image.open(\'MLModelPics/percepetron(neuron).jpg\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n\n                labelSum = tk.Label(self, text = ""A perceptron is used for classifying data. It is a linear classifier so it classifies \\ndata into two categories. It works by calculating a weighted sum of input values and returning 1 \\nif the sum is greater than a certain value or it returns 0 otherwise."")\n                labelSum.place(x =100, y= 200)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.precep(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predPer))\n                buttonZ.place(x = 275, y = 400)\n\n\nclass Page7(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n\n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n                load2 = Image.open(\'MLModelPics/LinearSUPPORTvector.png\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n\n                labelSum = tk.Label(self, text = ""Support Vector Machine is a linear model that can be used for classification\\n or regression. It works by creating a line or plane that separates \\ndata into classes. It finds a line between points from the two classes and then maximizes the distance \\nbetween the line and the points. SVMs usually have fast performances."")\n                labelSum.place(x =75, y= 200)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.lSVM(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predLSVM))\n                buttonZ.place(x = 275, y = 400)\n\nclass Page8(tk.Frame):\n        def __init__(self, parent, controller):\n                tk.Frame.__init__(self, parent)\n\n                load1 = Image.open(\'MLModelPics/bg2.png\')\n                render1 = ImageTk.PhotoImage(load1)\n                img1 = tk.Label(self, image = render1)\n                img1.image = render1\n                img1.place(x = 0, y = 0)\n\n                load2 = Image.open(\'MLModelPics/gNaiveBayes.png\')\n                load2 = load2.resize((450, 450))\n                render2 = ImageTk.PhotoImage(load2)\n                img2 = tk.Label(self, image = render2)\n                img2.image = render2\n                img2.place(x = 950, y = 75)\n\n\n                labelSum = tk.Label(self, text = ""Naive Bayes is a collection of algorithms that are based on the Bayes Theorem. \\nIt works by classifying features of input data. It can then predict \\nthe class of input by seeing which features match between \\nclasses. Some advantages are that it is fast and easy to train. A disadvantage is that it assumes every\\n feature is independent of the other which is not always true for every class."")\n                labelSum.place(x =80, y= 200)\n\n                textArea = tk.Text(self, height = 20, width = 15, wrap = tk.WORD)\n                textArea.insert(tk.END, machineLearningModels.gNaiveBayes(machineLearningModels.train1, machineLearningModels.train2, machineLearningModels.test))\n                textArea.configure(font=(""Arial"",12))\n\n                scroller = tk.Scrollbar(self, orient= tk.VERTICAL)\n                scroller.config(command = textArea.yview)\n                textArea.configure(yscrollcommand= scroller.set)\n                scroller.pack(side = tk.RIGHT, fill = tk.Y)\n                textArea.place(x = 700, y = 20)\n\n                labelScroll = tk.Label(self, text = ""Hover over the predicition box and scroll\\n down to see the model accuracy"")\n                labelScroll.place(x = 660, y= 410)\n\n                button1 = tk.Button(self, text=""Back to Home"", command=lambda: controller.show_frame(StartPage))\n                button1.place(x = 725, y = 500)\n\n                buttonZ = tk.Button(self, text=""Prediction Graph"", command=lambda: machineLearningModels.groupPlot(machineLearningModels.predBayes))\n                buttonZ.place(x = 275, y = 400)\n\n                \ndisplay = root()\ndisplay.mainloop()\n'"
dataPreprocessing.py,2,"b'# \n# Preprocesses data for Machine Learning models by dropping unncessary data as well as filling in blank values.\n#\nimport matplotlib\nmatplotlib.use(""TkAgg"")\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport re\n\n###########################################################\n# Processes Data\ndef preProcess(data):\n  \n# Drop \'PassengerId\' from data set as data column is not relevant to survival probability\n    data = data.drop([\'PassengerId\'], axis=1)\n\n# Dropping cabin data column due to missing data\n    deckType = {""A"": 1, ""B"": 2, ""C"": 3, ""D"": 4, ""E"": 5, ""F"": 6, ""G"": 7, ""U"": 8}\n    data[\'Cabin\'] = data[\'Cabin\'].fillna(""U0"")\n    data[\'Deck\'] = data[\'Cabin\'].map(lambda x: re.compile(""([a-zA-Z]+)"").search(x).group())\n    data[\'Deck\'] = data[\'Deck\'].map(deckType)\n    data[\'Deck\'] = data[\'Deck\'].fillna(0)\n    data[\'Deck\'] = data[\'Deck\'].astype(int)\n\n    data = data.drop([\'Cabin\'], axis=1)\n# Handling age data column missing values\n\n    mean = data[""Age""].mean()\n    std = data[""Age""].std()\n    is_null = data[""Age""].isnull().sum()\n# compute random numbers between the mean, std and is_null\n    try:\n      rand_age = np.random.randint(mean - std, mean + std, size = is_null)\n    except:\n      rand_age = 0\n\n# fill NaN values in Age column with random values generated\n    age_slice = data[""Age""].copy()\n    age_slice[np.isnan(age_slice)] = rand_age\n    data[""Age""] = age_slice\n    data[""Age""] = data[""Age""].astype(int)\n\n    fillVal = \'S\'\n    data[\'Embarked\'] = data[\'Embarked\'].fillna(fillVal)\n\n# Converting Fare from float to int\n    data[\'Fare\'] = data[\'Fare\'].fillna(0)\n    data[\'Fare\'] = data[\'Fare\'].astype(int)\n\n# Converting genders into 0 or 1\n    gender = {""male"": 0, ""female"":1}\n    data[\'Sex\'] = data[\'Sex\'].map(gender)\n\n# Dropping Ticket from dataset as data is not useful\n    data = data.drop([\'Ticket\'], axis=1)\n\n# Convering Embarked feature into numeric data\n    ports = {""S"": 0, ""C"": 1, ""Q"": 2}\n    data[\'Embarked\'] = data[\'Embarked\'].map(ports)\n#Dropping Name data as not useful\n    data = data.drop([\'Name\'], axis=1)\n\n# Creating age group\n    data[\'Age\'] = data[\'Age\'].astype(int)\n    data.loc[ data[\'Age\'] <= 11, \'Age\'] = 0\n    data.loc[(data[\'Age\'] > 11) & (data[\'Age\'] <= 18), \'Age\'] = 1\n    data.loc[(data[\'Age\'] > 18) & (data[\'Age\'] <= 22), \'Age\'] = 2\n    data.loc[(data[\'Age\'] > 22) & (data[\'Age\'] <= 27), \'Age\'] = 3\n    data.loc[(data[\'Age\'] > 27) & (data[\'Age\'] <= 33), \'Age\'] = 4\n    data.loc[(data[\'Age\'] > 33) & (data[\'Age\'] <= 40), \'Age\'] = 5\n    data.loc[(data[\'Age\'] > 40) & (data[\'Age\'] <= 66), \'Age\'] = 6\n    data.loc[ data[\'Age\'] > 66, \'Age\'] = 6\n\n# Creating Fare group\n    data.loc[ data[\'Fare\'] <= 7.91, \'Fare\'] = 0\n    data.loc[(data[\'Fare\'] > 7.91) & (data[\'Fare\'] <= 14.454), \'Fare\'] = 1\n    data.loc[(data[\'Fare\'] > 14.454) & (data[\'Fare\'] <= 31), \'Fare\']   = 2\n    data.loc[(data[\'Fare\'] > 31) & (data[\'Fare\'] <= 99), \'Fare\']   = 3\n    data.loc[(data[\'Fare\'] > 99) & (data[\'Fare\'] <= 250), \'Fare\']   = 4\n    data.loc[ data[\'Fare\'] > 250, \'Fare\'] = 5\n    data[\'Fare\'] = data[\'Fare\'].astype(int)\n# Adding new column for Age Class\n    data[\'Age_Class\']= data[\'Age\']* data[\'Pclass\']\n    return data\n######################################################################\n\n'"
machineLearningModels.py,2,"b'import matplotlib\nmatplotlib.use(""TkAgg"")\nfrom matplotlib import pyplot as plt\nfrom matplotlib import style\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport re\nfrom dataPreprocessing import preProcess\n\n# Silencing Future Warnings\ndef warn(*args, **kwargs):\n    pass\nimport warnings\nwarnings.warn = warn\n\n# Machine Learning Algorithmns\nfrom sklearn import linear_model\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.linear_model import Perceptron\nfrom sklearn.linear_model import SGDClassifier\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.svm import SVC, LinearSVC\nfrom sklearn.naive_bayes import GaussianNB\n\n\ndef sType(str):\n  if (str == \'1\'):\n    return ""Survived""\n  else:\n    return ""Deceased""\n\n\ndef printPrediction(predList):\n  i = 1\n  s = """"\n  for cell in predList:\n    s = s + (str(i) + "": "" +sType(str(cell))+ \'\\n\')\n    i = i + 1\n  \n  return s\n\n\n\n\nglobal predLog \n\n\n# Logistic Regression Machine Learning Model\ndef logRegression(train1,train2,test):\n  model = LogisticRegression()\n  model.fit(train1, train2)\n  prediction = model.predict(test)\n  global predLog\n  predLog = prediction\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\n \nglobal predSGD\n\n# Stochastic Gradient Descent Machine Learning Model\ndef SGD(train1,train2,test):\n  model = linear_model.SGDClassifier(max_iter=5, tol=None)\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predSGD\n  predSGD = prediction\n  model.score(train1,train2)\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\n  \n\nglobal predK\n\n# K Nearest Negihbor Machine Learning Model\ndef KNN(train1,train2,test):\n  model = KNeighborsClassifier(n_neighbors=3)\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predK\n  predK = prediction\n  print(prediction)\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\n\nglobal predForest\n# Random Forest Machine Learning Model\ndef rForest(train1,train2,test):\n  model = RandomForestClassifier(n_estimators=100)\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predForest\n  predForest = prediction\n  model.score(train1,train2)\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\nglobal predBayes\n\n# Random Forest Machine Learning Model\ndef gNaiveBayes(train1,train2,test):\n  model = GaussianNB()\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predBayes\n  predBayes = prediction\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\nglobal predPer\n# Perceptron Machine Learning Model\ndef precep(train1,train2,test):\n  model = Perceptron(max_iter=5)\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predPer\n  predPer = prediction\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\n\nglobal predLSVM\n# Linear Support Vector Machine Learning Model\ndef lSVM(train1,train2,test):\n  model = LinearSVC()\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predLSVM\n  predLSVM = prediction\n  accuracy = round(model.score(train1,train2)*100,2)\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\n\nglobal predTree\n# Decision Tree Machine Learning Model\ndef dTree(train1,train2,test):\n  model = DecisionTreeClassifier()\n  model.fit(train1,train2)\n  prediction = model.predict(test)\n  global predTree\n  predTree = prediction\n  accuracy = round(model.score(train1,train2)*100,2)\n  #print(""Model Accuracy:"" + str(accuracy)+""%"")\n  return \'Predicting... \\n \\n\'+ printPrediction(prediction) + \'\\nModel Accuracy: \' + str(accuracy)+\'%\'\n\ndef trainclassDistr(train_data):\n    train_data.Pclass.value_counts().plot(kind=""barh"")\n    plt.title(""Plot: Class Distribution"")\n    plt.xlabel(""Number of Passengers"")\n    plt.ylabel(""Ticket Class Type"")\n    plt.legend([""1st (Upper), 2nd (Middle), 3rd (Lower)""])\n    plt.show()\n\ndef trainMeanFareSurvival(train_data):\n    survived_0 = train_data[train_data[\'Survived\'] == 0][""Fare""].mean()\n    survived_1 = train_data[train_data[\'Survived\'] == 1][""Fare""].mean()\n    xs  = [survived_0, survived_1]\n    ys = [\'Dead\',\'Survived\']\n    plt.bar(ys, xs, 0.6, align=\'center\',color = \'green\')\n    plt.ylabel(\'Average Fare\')\n    plt.title(\'Bar Plot: Average Fair vs Survival\')\n    plt.xlabel(\'Outcomes\')\n    plt.show()\n\ndef trainClassSurvival(train_data):\n    pclass_survived = train_data[train_data[\'Survived\']==1][\'Pclass\'].value_counts()\n    pclass_dead = train_data[train_data[\'Survived\']==0][\'Pclass\'].value_counts()\n    df = pd.DataFrame([pclass_survived,pclass_dead])\n    df.index = [\'Survived\',\'Dead\']\n    df.plot(kind=\'bar\', stacked=True, figsize=(10,8))\n    plt.ylabel(\'Number of Passengers\')\n    plt.legend([""1st (Upper)"", ""2nd (Middle)"",""3rd (Lower)""])\n    plt.title(\'Stacked Plot: Ticket Class vs Survival\')\n    plt.show()\n\ndef groupPlot(data):\n    status = (\'Deceased\', \'Survived\')\n    y_pos = np.arange(len(status))\n    count1 = 0\n    for e in data:\n        if (e == 1):\n            count1 = count1 + 1\n        \n    count0 = 0\n    for z in data:\n        if (z == 0):\n            count0 = count0 + 1                                                                 \n            \n    predict = [count0,count1]                                                            \n    np.sort(data)\n    plt.bar(y_pos, predict, align=\'center\', color=\'blue\', alpha=0.5)\n    plt.xticks(y_pos, status)\n    plt.ylabel(\'Number of Passengers\')\n    plt.title(\'Bar Plot: Survied vs Deceased\')\n    plt.show()\n\ntrain_df = pd.read_csv(""train.csv"")\ntest_df = pd.read_csv(""test.csv"")\n# Need to convert features into numeric values in order for machine learning algorithmns to process data.\nprocessedData = preProcess(train_df)\nprocessedTestData = preProcess(test_df)\n\ntrain1 = processedData.drop(""Survived"", axis = 1)\ntrain2 = processedData[""Survived""]\ntest = processedTestData.copy()\n#print(SGD(train1,train2,test))\n\n'"
