file_path,api_count,code
integration/vagrant/bin/init_aws.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\n1. Auto configure external python libraries like boto\n2. Check environment variables\n3. Auto set up security group\n""""""\n\nimport os\nimport sys\nfrom sys import stderr\n\nfrom boto import ec2\nimport yaml\n\nfrom util import info, warn, error\n\n\ndef get_or_make_group(conn, name, vpc=None):\n    groups = [g for g in conn.get_all_security_groups() if (g.name == name)]\n    if (vpc == \'\'):\n        vpc = None\n    if (vpc is not None):\n        groups = [g for g in groups if (g.vpc_id == vpc)]\n    if len(groups) > 0:\n        return groups[0]\n    else:\n        info(""Creating security group {name} in {region}"".format(name=name, region=conn.region))\n        group = conn.create_security_group(name, ""Auto created by Alluxio deploy"", vpc)\n        info(""Created security group ID {id}"".format(id=group.id))\n        return group\n\n\ndef set_security_group(conn, name, vpc=None):\n    info(""Setting up security group {} in {}"".format(name, conn.region))\n    sg = get_or_make_group(conn, name, vpc)\n    if sg.rules != []:\n        warn(\'security group {} in {} already has rules, no modification will happen then\'.format(name, conn.region))\n        return sg.id\n    proto = [\'tcp\', \'udp\']\n    authorized_ip = \'0.0.0.0/0\' # all IP\n    for p in proto:\n        sg.authorize(p, 0, 65535, authorized_ip)\n    return sg.id\n\n\ndef get_aws_secret():\n    access_key = os.getenv(\'AWS_ACCESS_KEY_ID\')\n    if access_key is None:\n        error(""ERROR: The environment variable AWS_ACCESS_KEY_ID must be set"")\n        sys.exit(1)\n\n    secret_key = os.getenv(\'AWS_SECRET_ACCESS_KEY\')\n    if secret_key is None:\n        error(""ERROR: The environment variable AWS_SECRET_ACCESS_KEY must be set"")\n        sys.exit(1)\n\n    return access_key, secret_key\n\n\ndef gen_boto_config(access_key, secret_key):\n    home=os.path.expanduser(\'~\')\n    boto_config_path = os.path.join(home, \'.boto\')\n    with open(boto_config_path, \'w\') as boto_config:\n        boto_config.write(\'\\n\'.join([\n            \'[Credentials]\',\n            \'aws_access_key_id = \' + access_key,\n            \'aws_secret_access_key = \' + secret_key]))\n\n\ndef get_ec2_conf():\n    return yaml.load(open(\'conf/ec2.yml\'), Loader=yaml.FullLoader)\n\n\ndef get_conn():\n    try:\n        conn = ec2.connect_to_region(get_ec2_conf()[\'Region\'])\n        return conn\n    except Exception as e:\n        error(e.message)\n        sys.exit(1)\n\n\ndef configure_aws():\n    access_key, secret_key = get_aws_secret()\n    gen_boto_config(access_key, secret_key)\n\n    conn = get_conn()\n    ec2conf = get_ec2_conf()\n    return set_security_group(conn, ec2conf[\'Security_Group\'], ec2conf.get(\'VPC\', None))\n\n\nif __name__ == \'__main__\':\n    print configure_aws()\n'"
integration/vagrant/bin/is_aws_spot.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nIf \'Spot_Price\' is set in \'conf/ec2.yml\', print 0, else print 1.\nIf \'Spot_Price\' can not be parsed into \'float\', print 1 to stdout and error string to stderr.\n""""""\n\nfrom sys import stderr\n\nimport yaml\n\nfrom util import error\n\ndef is_spot(price):\n    return price is not None and price != \'\'\n\nif __name__ == \'__main__\':\n    price = yaml.load(open(\'conf/ec2.yml\'), Loader=yaml.FullLoader).get(\'Spot_Price\')\n    if is_spot(price):\n      try:\n        float(price)\n        print(0)\n        exit(0)\n      except ValueError:\n        error(""Spot_Price in ec2.yml can be not parsed into float"")\n    print(1)\n'"
integration/vagrant/bin/spot_request.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n""""""\nSubmit or Cancel spot instance requests.\n\nWhen submit, the process will block until the request is fulfilled\nor the process is killed by user(like CTRL + C),\nif the process is killed, the requests will be automatically canceled.\n""""""\n\nimport os\nimport time\nimport pickle\nimport argparse\nimport subprocess\n\nimport yaml\nimport boto.ec2.blockdevicemapping as bdm\n\nfrom util import mkdir_p, info, warn, error\nfrom init_aws import get_conn, get_ec2_conf\n\n\ndef get_bdm(ec2_conf):\n    def device(d):\n        dev = bdm.BlockDeviceType()\n        if d[\'VirtualName\'].startswith(\'ephemeral\'):\n            # Instance Storage\n            dev.ephemeral_name = d[\'VirtualName\']\n        else:\n            # EBS\n            dev.size = d[\'Ebs.VolumeSize\']\n            delete = d.get(\'Ebs.DeleteOnTermination\', None)\n            if delete is not None:\n                dev.delete_on_termination = delete\n        return (d[\'DeviceName\'], dev)\n    devices = map(device, ec2_conf[\'Block_Device_Mapping\'])\n    device_mapping = bdm.BlockDeviceMapping()\n    for name, dev in devices:\n        device_mapping[name] = dev\n    return device_mapping\n\n\ndef get_init_conf():\n    return yaml.load(open(\'conf/init.yml\'))\n\n\nclass RequestFailedError(Exception): pass\n\n\ndef all_fulfilled(requests):\n    fulfilled = True\n    for r in requests:\n        if r.status.code != \'fulfilled\':\n            fulfilled = False\n            if r.state == \'failed\':\n                raise RequestFailedError(r.status.message)\n        if not fulfilled:\n            break\n    return fulfilled\n\n\ndef wait_until_fulfilled(request_ids, conn):\n    while True:\n        requests = conn.get_all_spot_instance_requests(request_ids)\n        if not all_fulfilled(requests):\n            time.sleep(1)\n        else:\n            return requests\n\n\ndef add_tag(host):\n    return \'{}-{}\'.format(get_ec2_conf()[\'Tag\'], host)\n\n\ndef get_host(tag):\n    return tag.split(\'-\')[-1]\n\n\n# request_id -> tag\ndef request_id_to_tag(requests, masters):\n    ret = {}\n    for i, rid in enumerate([r.id for r in requests]):\n        # TODO(cc): This naming convention for host may need changes\n        if i == 0:\n            host = \'AlluxioMaster\'\n        elif i < masters:\n            host = \'AlluxioMaster{}\'.format(i + 1)\n        else:\n            host = \'AlluxioWorker{}\'.format(i - masters + 1)\n        ret[rid] = add_tag(host)\n    return ret\n\n\ndef save_request_ids(request_ids):\n    out = open(\'.request_ids\', \'w\')\n    pickle.dump(request_ids, out)\n    out.close()\n\n\ndef load_request_ids():\n    return pickle.load(open(\'.request_ids\'))\n\n\ndef submit_request(conn, ec2_conf, masters):\n    # enable ssh as root without tty\n    user_data = ""#!/bin/bash\\n \\\n        echo \'Defaults:root !requiretty\' > /etc/sudoers.d/998-vagrant-cloud-init-requiretty && \\\n        echo \'Defaults:ec2-user !requiretty\' > /etc/sudoers.d/999-vagrant-cloud-init-requiretty && \\\n        chmod 440 /etc/sudoers.d/998-vagrant-cloud-init-requiretty && chmod 440 /etc/sudoers.d/999-vagrant-cloud-init-requiretty""\n\n    requests = conn.request_spot_instances(\n        price = ec2_conf[\'Spot_Price\'],\n        image_id = ec2_conf[\'AMI\'],\n        count = get_init_conf()[\'MachineNumber\'],\n        availability_zone_group = ec2_conf[\'Availability_Zone\'],\n        placement = ec2_conf[\'Availability_Zone\'], # where to put instance\n        key_name = ec2_conf[\'Keypair\'],\n        security_groups = [ec2_conf[\'Security_Group\']],\n        user_data = user_data,\n        instance_type = ec2_conf[\'Instance_Type\'],\n        block_device_map = get_bdm(ec2_conf))\n    request_ids = [r.id for r in requests]\n    save_request_ids(request_ids)\n\n    # sleep before waiting for spot instances to be fulfilled.\n    time.sleep(5)\n\n    # block, waiting for all requests to be fulfilled\n    requests = wait_until_fulfilled(request_ids, conn)\n\n    # tag the requests and instances\n    rid_tag = request_id_to_tag(requests, masters)\n    for r in requests:\n        tag = rid_tag[r.id]\n        r.add_tag(\'Name\', tag)\n        conn.create_tags([r.instance_id], {\'Name\': tag})\n\n    return rid_tag, requests\n\n\ndef cancel_request(conn):\n    warn(\'canceling spot instance requests and terminating instances...\')\n    requests = conn.get_all_spot_instance_requests(load_request_ids())\n    for r in requests:\n        r.cancel()\n    instance_ids = [r.instance_id for r in requests if r.instance_id is not None]\n    if len(instance_ids) > 0:\n        conn.terminate_instances(instance_ids)\n\n\n# mock the inventory file and machine id files that should have\n# been generated by vagrant, so that we can keep the vagrant work flow.\ndef mock_vagrant_info(instance_id_to_tag_ip):\n    inventory_dir = \'.vagrant/provisioners/ansible/inventory\'\n    mkdir_p(inventory_dir)\n    inventory = open(os.path.join(inventory_dir, \'vagrant_ansible_inventory\'), \'w\')\n    for instance_id, tag_ip in instance_id_to_tag_ip.iteritems():\n        tag, ip = tag_ip\n        host = get_host(tag)\n\n        inventory.write(""{} ansible_ssh_host={} ansible_ssh_port=22\\n"".format(host, ip))\n\n        id_dir = os.path.join(\'.vagrant\', \'machines\', host, \'aws\')\n        mkdir_p(id_dir)\n        with open(os.path.join(id_dir, \'id\'), \'w\') as f:\n            f.write(instance_id)\n    inventory.close()\n\n\ndef is_ssh_ready(host):\n    s = subprocess.Popen([\'ssh\',\n        \'-o\', \'StrictHostKeyChecking=no\',\n        \'-o\', \'UserKnownHostsFile=/dev/null\',\n        \'-o\', \'ConnectTimeout=30\',\n        \'-i\', os.path.expanduser(get_ec2_conf()[\'Key_Path\']),\n        \'%s@%s\' % (\'ec2-user\', host),\n        \'true\'],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT)\n    s.communicate()\n    return s.returncode == 0\n\n\ndef wait_for_ssh(hosts):\n    while len(hosts):\n        hosts = [h for h in hosts if not is_ssh_ready(h)]\n\n\ndef parse():\n    parser = argparse.ArgumentParser()\n    grp = parser.add_mutually_exclusive_group(required=True)\n    grp.add_argument(\'-s\', \'--submit\', action=\'store_true\')\n    grp.add_argument(\'-c\', \'--cancel\', action=\'store_true\')\n    parser.add_argument(\'--masters\', type=int, default=1, help=\'number of Alluxio masters\')\n    return parser.parse_args()\n\n\ndef main(args):\n    ec2_conf = get_ec2_conf()\n    conn = get_conn()\n    if args.submit:\n        info(\'waiting for spot instance requests to be fulfilled, you can cancel by ctrl+c ...\')\n        try:\n            rid_tag, requests = submit_request(conn, ec2_conf, args.masters)\n        except (KeyboardInterrupt, RequestFailedError) as e:\n            error(e)\n            exit(1)\n        info(\'spot instance requests fulfilled\')\n        instance_id_to_tag_ip = {}\n        info(\'getting instance IPs...\')\n        for r in requests:\n            instance_id = r.instance_id\n            info(\'waiting for ip to be allocated to the machine\')\n            ip = conn.get_only_instances([instance_id])[0].ip_address\n            while ip is None:\n                time.sleep(1)\n                ip = conn.get_only_instances([instance_id])[0].ip_address\n            instance_id_to_tag_ip[instance_id] = (rid_tag[r.id], ip)\n        info(\'mocking vagrant info under .vagrant...\')\n        mock_vagrant_info(instance_id_to_tag_ip)\n        info(\'creation of spot instances done\')\n        info(\'waiting for ssh to be available...\')\n        wait_for_ssh([ip for tag, ip in instance_id_to_tag_ip.values()])\n        info(\'ssh for all instances are ready\')\n    elif args.cancel:\n        cancel_request(conn)\n\nif __name__ == \'__main__\':\n    main(parse())\n'"
integration/vagrant/bin/util.py,0,"b'#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nfrom __future__ import print_function\n\nimport os\nfrom sys import stderr\nimport errno\n\n\ndef mkdir_p(path):\n    """"""mkdir -p""""""\n    try:\n        os.makedirs(path)\n    except OSError as e:\n        if not e.errno == errno.EEXIST:\n            raise\n\n\ndef _colorize(code):\n    def _(text, bold=False):\n        c = code\n        if bold:\n            c = \'1;%s\' % c\n        return \'\\033[%sm%s\\033[0m\' % (c, text)\n    return _\n\n_red = _colorize(\'31\')\n_green = _colorize(\'32\')\n_yellow = _colorize(\'33\')\n\n\ndef info(msg):\n    print(_green("">>> "" + msg))\n\n\ndef error(msg):\n    print(_red("">>> "" + msg, True), file=stderr)\n\n\ndef warn(msg):\n    print(_yellow("">>> "" + msg, True))\n\n\n'"
